From 781c81721964e841fd35a0cd7a10c8ed51afa339 Mon Sep 17 00:00:00 2001
From: Richard Hughes <richard@hughsie.com>
Date: Sun, 17 Sep 2017 12:58:47 +0100
Subject: [PATCH] fwupd: Port to the version 1.0 API

---
 plugins/fwupd/gs-plugin-fwupd.c | 253 +++++++++++++++++++++++++++++++++++++++-
 1 file changed, 251 insertions(+), 2 deletions(-)

diff --git a/plugins/fwupd/gs-plugin-fwupd.c b/plugins/fwupd/gs-plugin-fwupd.c
index ced7d408..7c1559bf 100644
--- a/plugins/fwupd/gs-plugin-fwupd.c
+++ b/plugins/fwupd/gs-plugin-fwupd.c
@@ -46,8 +46,10 @@ struct GsPluginData {
 	GPtrArray		*to_ignore;
 	GsApp			*app_current;
 	GsApp			*cached_origin;
+#if !FWUPD_CHECK_VERSION(1,0,0)
 	GHashTable		*remote_asc_hash;
 	gchar			*config_fn;
+#endif
 };
 
 static void
@@ -103,6 +105,7 @@ gs_plugin_initialize (GsPlugin *plugin)
 	priv->client = fwupd_client_new ();
 	priv->to_download = g_ptr_array_new_with_free_func (g_free);
 	priv->to_ignore = g_ptr_array_new_with_free_func (g_free);
+#if !FWUPD_CHECK_VERSION(1,0,0)
 	priv->remote_asc_hash = g_hash_table_new_full (g_str_hash, g_str_equal,
 						       g_free, g_free);
 	priv->config_fn = g_build_filename (SYSCONFDIR, "fwupd.conf", NULL);
@@ -115,6 +118,7 @@ gs_plugin_initialize (GsPlugin *plugin)
 		gs_plugin_set_enabled (plugin, FALSE);
 		return;
 	}
+#endif
 
 	/* unique to us */
 	gs_plugin_set_app_gtype (plugin, GS_TYPE_FWUPD_APP);
@@ -129,8 +133,10 @@ gs_plugin_destroy (GsPlugin *plugin)
 	GsPluginData *priv = gs_plugin_get_data (plugin);
 	if (priv->cached_origin != NULL)
 		g_object_unref (priv->cached_origin);
+#if !FWUPD_CHECK_VERSION(1,0,0)
 	g_hash_table_unref (priv->remote_asc_hash);
 	g_free (priv->config_fn);
+#endif
 	g_object_unref (priv->client);
 	g_ptr_array_unref (priv->to_download);
 	g_ptr_array_unref (priv->to_ignore);
@@ -150,10 +156,16 @@ gs_plugin_fwupd_changed_cb (FwupdClient *client, GsPlugin *plugin)
 
 static void
 gs_plugin_fwupd_device_changed_cb (FwupdClient *client,
+#if FWUPD_CHECK_VERSION(1,0,0)
+				   FwupdDevice *dev,
+#else
 				   FwupdResult *res,
+#endif
 				   GsPlugin *plugin)
 {
+#if !FWUPD_CHECK_VERSION(1,0,0)
 	FwupdDevice *dev = fwupd_result_get_device (res);
+#endif
 
 	/* fwupd >= 0.7.1 supports per-device signals, and also the
 	 * SUPPORTED flag -- so we can limit number of UI refreshes */
@@ -237,6 +249,7 @@ gs_plugin_fwupd_get_file_checksum (const gchar *filename,
 	return g_compute_checksum_for_data (checksum_type, (const guchar *)data, len);
 }
 
+#if !FWUPD_CHECK_VERSION(1,0,0)
 static gboolean
 gs_plugin_fwupd_setup_remote (GsPlugin *plugin, FwupdRemote *remote, GError **error)
 {
@@ -290,6 +303,7 @@ gs_plugin_fwupd_setup_remotes (GsPlugin *plugin, GCancellable *cancellable, GErr
 	}
 	return TRUE;
 }
+#endif
 
 gboolean
 gs_plugin_setup (GsPlugin *plugin, GCancellable *cancellable, GError **error)
@@ -322,8 +336,12 @@ gs_plugin_setup (GsPlugin *plugin, GCancellable *cancellable, GError **error)
 	g_signal_connect (priv->client, "notify::status",
 			  G_CALLBACK (gs_plugin_fwupd_notify_status_cb), plugin);
 
+#if !FWUPD_CHECK_VERSION(1,0,0)
 	/* get the hashes of the previously downloaded asc files */
 	return gs_plugin_fwupd_setup_remotes (plugin, cancellable, error);
+#else
+	return TRUE;
+#endif
 }
 
 static void
@@ -345,11 +363,18 @@ gs_plugin_fwupd_add_required_location (GsPlugin *plugin, const gchar *location)
 	g_ptr_array_add (priv->to_download, g_strdup (location));
 }
 
+#if FWUPD_CHECK_VERSION(1,0,0)
+static GsApp *
+gs_plugin_fwupd_new_app_from_device (GsPlugin *plugin, FwupdDevice *dev)
+{
+	FwupdRelease *rel = fwupd_device_get_release_default (dev);
+#else
 static GsApp *
 gs_plugin_fwupd_new_app_from_results (GsPlugin *plugin, FwupdResult *res)
 {
 	FwupdDevice *dev = fwupd_result_get_device (res);
 	FwupdRelease *rel = fwupd_result_get_release (res);
+#endif
 	GsApp *app;
 	g_autofree gchar *id = NULL;
 	g_autoptr(AsIcon) icon = NULL;
@@ -397,11 +422,19 @@ gs_plugin_fwupd_new_app_from_results (GsPlugin *plugin, FwupdResult *res)
 static gboolean
 gs_plugin_add_update_app (GsPlugin *plugin,
 			  GsAppList *list,
+#if FWUPD_CHECK_VERSION(1,0,0)
+			  FwupdDevice *dev,
+#else
 			  FwupdResult *res,
+#endif
 			  gboolean is_downloaded,
 			  GError **error)
 {
+#if FWUPD_CHECK_VERSION(1,0,0)
+	FwupdRelease *rel = fwupd_device_get_release_default (dev);
+#else
 	FwupdRelease *rel = fwupd_result_get_release (res);
+#endif
 	GPtrArray *checksums;
 	const gchar *update_uri;
 	g_autofree gchar *basename = NULL;
@@ -410,7 +443,11 @@ gs_plugin_add_update_app (GsPlugin *plugin,
 	g_autoptr(GsApp) app = NULL;
 
 	/* update unsupported */
+#if FWUPD_CHECK_VERSION(1,0,0)
+	app = gs_plugin_fwupd_new_app_from_device (plugin, dev);
+#else
 	app = gs_plugin_fwupd_new_app_from_results (plugin, res);
+#endif
 	if (gs_app_get_state (app) != AS_APP_STATE_UPDATABLE_LIVE) {
 		g_set_error (error,
 			     GS_PLUGIN_ERROR,
@@ -529,14 +566,26 @@ gs_plugin_add_updates_historical (GsPlugin *plugin,
 	GsPluginData *priv = gs_plugin_get_data (plugin);
 	g_autoptr(GError) error_local = NULL;
 	g_autoptr(GsApp) app = NULL;
+#if FWUPD_CHECK_VERSION(1,0,0)
+	g_autoptr(FwupdDevice) dev = NULL;
+#else
 	g_autoptr(FwupdResult) res = NULL;
+#endif
 
 	/* get historical updates */
+#if FWUPD_CHECK_VERSION(1,0,0)
+	dev = fwupd_client_get_results (priv->client,
+					FWUPD_DEVICE_ID_ANY,
+					cancellable,
+					&error_local);
+	if (dev == NULL) {
+#else
 	res = fwupd_client_get_results (priv->client,
 					FWUPD_DEVICE_ID_ANY,
 					cancellable,
 					&error_local);
 	if (res == NULL) {
+#endif
 		if (g_error_matches (error_local,
 				     FWUPD_ERROR,
 				     FWUPD_ERROR_NOTHING_TO_DO))
@@ -552,7 +601,11 @@ gs_plugin_add_updates_historical (GsPlugin *plugin,
 	}
 
 	/* parse */
+#if FWUPD_CHECK_VERSION(1,0,0)
+	app = gs_plugin_fwupd_new_app_from_device (plugin, dev);
+#else
 	app = gs_plugin_fwupd_new_app_from_results (plugin, res);
+#endif
 	gs_app_list_add (list, app);
 	return TRUE;
 }
@@ -564,11 +617,72 @@ gs_plugin_fwupd_add_updates (GsPlugin *plugin,
 			     GCancellable *cancellable,
 			     GError **error)
 {
+#if FWUPD_CHECK_VERSION(1,0,0)
 	GsPluginData *priv = gs_plugin_get_data (plugin);
 	g_autoptr(GError) error_local = NULL;
-	g_autoptr(GPtrArray) results = NULL;
+	g_autoptr(GPtrArray) devices = NULL;
 
 	/* get current list of updates */
+	devices = fwupd_client_get_devices (priv->client, cancellable, &error_local);
+	if (devices == NULL) {
+		if (g_error_matches (error_local,
+				     FWUPD_ERROR,
+				     FWUPD_ERROR_NOTHING_TO_DO)) {
+			g_debug ("no devices");
+			return TRUE;
+		}
+		g_propagate_error (error, g_steal_pointer (&error_local));
+		gs_plugin_fwupd_error_convert (error);
+		return FALSE;
+	}
+	for (guint i = 0; i < devices->len; i++) {
+		FwupdDevice *dev = g_ptr_array_index (devices, i);
+		FwupdRelease *rel_newest;
+		g_autoptr(GError) error_local2 = NULL;
+		g_autoptr(GPtrArray) rels = NULL;
+
+		/* locked device that needs unlocking */
+		if (fwupd_device_has_flag (dev, FWUPD_DEVICE_FLAG_LOCKED)) {
+			g_autoptr(GsApp) app = NULL;
+			app = gs_plugin_fwupd_new_app_from_device (plugin, dev);
+			gs_fwupd_app_set_is_locked (app, TRUE);
+			gs_app_list_add (list, app);
+			continue;
+		}
+
+		/* not going to have results, so save a D-Bus round-trip */
+		if (!fwupd_device_has_flag (dev, FWUPD_DEVICE_FLAG_SUPPORTED))
+			continue;
+
+		/* get the releases for this device and filter for validity */
+		rels = fwupd_client_get_upgrades (priv->client,
+						  fwupd_device_get_id (dev),
+						  cancellable, &error_local2);
+		if (rels == NULL) {
+			if (g_error_matches (error_local2,
+					     FWUPD_ERROR,
+					     FWUPD_ERROR_NOTHING_TO_DO)) {
+				g_debug ("no updates for %s", fwupd_device_get_id (dev));
+				continue;
+			}
+			g_propagate_error (error, g_steal_pointer (&error_local2));
+			gs_plugin_fwupd_error_convert (error);
+			return FALSE;
+		}
+
+		/* normal device update */
+		rel_newest = g_ptr_array_index (rels, 0);
+		fwupd_device_add_release (dev, rel_newest);
+		if (!gs_plugin_add_update_app (plugin, list, dev,
+					       is_downloaded, &error_local2)) {
+			g_debug ("%s", error_local2->message);
+			continue;
+		}
+	}
+#else
+	GsPluginData *priv = gs_plugin_get_data (plugin);
+	g_autoptr(GError) error_local = NULL;
+	g_autoptr(GPtrArray) results = NULL;
 	results = fwupd_client_get_updates (priv->client,
 					    cancellable, &error_local);
 	if (results == NULL) {
@@ -604,7 +718,7 @@ gs_plugin_fwupd_add_updates (GsPlugin *plugin,
 					       is_downloaded, &error_local2))
 			g_debug ("%s", error_local2->message);
 	}
-
+#endif
 	return TRUE;
 }
 
@@ -634,6 +748,112 @@ gs_plugin_fwupd_refresh_remote (GsPlugin *plugin,
 				GError **error)
 {
 	GsPluginData *priv = gs_plugin_get_data (plugin);
+#if FWUPD_CHECK_VERSION(1,0,0)
+	GChecksumType checksum_kind;
+	const gchar *url_sig = NULL;
+	const gchar *url = NULL;
+	g_autoptr(GError) error_local = NULL;
+	g_autofree gchar *basename = NULL;
+	g_autofree gchar *basename_sig = NULL;
+	g_autofree gchar *cache_id = NULL;
+	g_autofree gchar *checksum = NULL;
+	g_autofree gchar *filename = NULL;
+	g_autofree gchar *filename_sig = NULL;
+	g_autoptr(GBytes) data = NULL;
+	g_autoptr(GsApp) app_dl = gs_app_new (gs_plugin_get_name (plugin));
+
+	/* sanity check */
+	if (fwupd_remote_get_filename_cache_sig (remote) == NULL) {
+		g_set_error (error,
+			     GS_PLUGIN_ERROR,
+			     GS_PLUGIN_ERROR_FAILED,
+			     "remote %s has no cache signature",
+			     fwupd_remote_get_id (remote));
+		return FALSE;
+	}
+
+	/* check cache age */
+	if (cache_age > 0) {
+		guint64 age = fwupd_remote_get_age (remote);
+		guint tmp = age < G_MAXUINT ? (guint) age : G_MAXUINT;
+		if (tmp < cache_age) {
+			g_debug ("%s is only %u seconds old, so ignoring refresh",
+				 filename_sig, tmp);
+			return TRUE;
+		}
+	}
+
+	/* download the signature first, it's smaller */
+	cache_id = g_strdup_printf ("fwupd/remotes.d/%s", fwupd_remote_get_id (remote));
+	basename_sig = g_path_get_basename (fwupd_remote_get_filename_cache_sig (remote));
+	filename_sig = gs_utils_get_cache_filename (cache_id, basename_sig,
+						    GS_UTILS_CACHE_FLAG_WRITEABLE,
+						    error);
+
+	/* download the signature first, it's smaller */
+	url_sig = fwupd_remote_get_metadata_uri_sig (remote);
+	gs_app_set_summary_missing (app_dl,
+				    /* TRANSLATORS: status text when downloading */
+				    _("Downloading firmware update signature…"));
+	data = gs_plugin_download_data (plugin, app_dl, url_sig, cancellable, error);
+	if (data == NULL) {
+		gs_utils_error_add_unique_id (error, priv->cached_origin);
+		return FALSE;
+	}
+
+	/* is the signature hash the same as we had before? */
+	checksum_kind = fwupd_checksum_guess_kind (fwupd_remote_get_checksum (remote));
+	checksum = g_compute_checksum_for_data (checksum_kind,
+						(const guchar *) g_bytes_get_data (data, NULL),
+						g_bytes_get_size (data));
+	if (g_strcmp0 (checksum, fwupd_remote_get_checksum (remote)) == 0) {
+		g_debug ("signature of %s is unchanged", url_sig);
+		return TRUE;
+	}
+
+	/* save to a file */
+	g_debug ("saving new remote signature to %s:", filename_sig);
+	if (!g_file_set_contents (filename_sig,
+				  g_bytes_get_data (data, NULL),
+				  (guint) g_bytes_get_size (data),
+				  &error_local)) {
+		g_set_error (error,
+			     GS_PLUGIN_ERROR,
+			     GS_PLUGIN_ERROR_WRITE_FAILED,
+			     "Failed to save firmware signature: %s",
+			     error_local->message);
+		return FALSE;
+	}
+
+	/* download the payload and save to file */
+	basename = g_path_get_basename (fwupd_remote_get_filename_cache (remote));
+	filename = gs_utils_get_cache_filename (cache_id, basename,
+						GS_UTILS_CACHE_FLAG_WRITEABLE,
+						error);
+	if (filename == NULL)
+		return FALSE;
+	g_debug ("saving new firmware metadata to %s:", filename);
+	gs_app_set_summary_missing (app_dl,
+				    /* TRANSLATORS: status text when downloading */
+				    _("Downloading firmware update metadata…"));
+	url = fwupd_remote_get_metadata_uri (remote);
+	if (!gs_plugin_download_file (plugin, app_dl, url, filename,
+				      cancellable, error)) {
+		gs_utils_error_add_unique_id (error, priv->cached_origin);
+		return FALSE;
+	}
+
+	/* phew, lets send all this to fwupd */
+	if (!fwupd_client_update_metadata (priv->client,
+					   fwupd_remote_get_id (remote),
+					   filename,
+					   filename_sig,
+					   cancellable,
+					   error)) {
+		gs_plugin_fwupd_error_convert (error);
+		return FALSE;
+	}
+#else
 	const gchar *checksum_old;
 	const gchar *url_asc = NULL;
 	const gchar *url = NULL;
@@ -737,6 +957,7 @@ gs_plugin_fwupd_refresh_remote (GsPlugin *plugin,
 		gs_plugin_fwupd_error_convert (error);
 		return FALSE;
 	}
+#endif
 	return TRUE;
 }
 
@@ -988,7 +1209,11 @@ gs_plugin_file_to_app (GsPlugin *plugin,
 	GsPluginData *priv = gs_plugin_get_data (plugin);
 	g_autofree gchar *content_type = NULL;
 	g_autofree gchar *filename = NULL;
+#if FWUPD_CHECK_VERSION(1,0,0)
+	g_autoptr(GPtrArray) devices = NULL;
+#else
 	g_autoptr(GPtrArray) results = NULL;
+#endif
 	const gchar *mimetypes[] = {
 		"application/vnd.ms-cab-compressed",
 		NULL };
@@ -1002,6 +1227,29 @@ gs_plugin_file_to_app (GsPlugin *plugin,
 
 	/* get results */
 	filename = g_file_get_path (file);
+#if FWUPD_CHECK_VERSION(1,0,0)
+	devices = fwupd_client_get_details (priv->client,
+					    filename,
+					    cancellable,
+					    error);
+	if (devices == NULL) {
+		gs_plugin_fwupd_error_convert (error);
+		return FALSE;
+	}
+	for (guint i = 0; i < devices->len; i++) {
+		FwupdDevice *dev = g_ptr_array_index (devices, i);
+		g_autoptr(GsApp) app = NULL;
+
+		/* create each app */
+		app = gs_plugin_fwupd_new_app_from_device (plugin, dev);
+
+		/* we have no update view for local files */
+		gs_app_set_version (app, gs_app_get_update_version (app));
+		gs_app_set_description (app, GS_APP_QUALITY_NORMAL,
+					gs_app_get_update_details (app));
+		gs_app_list_add (list, app);
+	}
+#else
 	results = fwupd_client_get_details_local (priv->client,
 						  filename,
 						  cancellable,
@@ -1023,6 +1271,7 @@ gs_plugin_file_to_app (GsPlugin *plugin,
 					gs_app_get_update_details (app));
 		gs_app_list_add (list, app);
 	}
+#endif
 
 	return TRUE;
 }
