From 37818c0de4e58d7bd078035dd7ea0945ede3cd95 Mon Sep 17 00:00:00 2001
From: Xiaotian Wu <wuxiaotian@loongson.cn>
Date: Mon, 11 Mar 2024 12:49:06 +0800
Subject: [PATCH 54/55] Fix build error for Motorcomm YT6801

---
 .../net/ethernet/motorcomm/fuxi-gmac-common.c |  4 +-
 .../ethernet/motorcomm/fuxi-gmac-ethtool.c    | 43 ++++++++++---------
 2 files changed, 24 insertions(+), 23 deletions(-)

diff --git a/drivers/net/ethernet/motorcomm/fuxi-gmac-common.c b/drivers/net/ethernet/motorcomm/fuxi-gmac-common.c
index 4b625f8425d6..86b55a7b6df3 100644
--- a/drivers/net/ethernet/motorcomm/fuxi-gmac-common.c
+++ b/drivers/net/ethernet/motorcomm/fuxi-gmac-common.c
@@ -76,8 +76,8 @@ static void fxgmac_default_config(struct fxgmac_pdata *pdata)
     // default to magic
     pdata->expansion.wol = WAKE_MAGIC;
 
-    strlcpy(pdata->drv_name, FXGMAC_DRV_NAME, sizeof(pdata->drv_name));
-    strlcpy(pdata->drv_ver, FXGMAC_DRV_VERSION, sizeof(pdata->drv_ver));
+    strscpy(pdata->drv_name, FXGMAC_DRV_NAME, sizeof(pdata->drv_name));
+    strscpy(pdata->drv_ver, FXGMAC_DRV_VERSION, sizeof(pdata->drv_ver));
 
     printk("FXGMAC_DRV_NAME:%s, FXGMAC_DRV_VERSION:%s\n", FXGMAC_DRV_NAME, FXGMAC_DRV_VERSION);
 }
diff --git a/drivers/net/ethernet/motorcomm/fuxi-gmac-ethtool.c b/drivers/net/ethernet/motorcomm/fuxi-gmac-ethtool.c
index bdd1228fc331..32ce0fa7b6ed 100644
--- a/drivers/net/ethernet/motorcomm/fuxi-gmac-ethtool.c
+++ b/drivers/net/ethernet/motorcomm/fuxi-gmac-ethtool.c
@@ -111,9 +111,9 @@ static void fxgmac_ethtool_get_drvinfo(struct net_device *netdev,
     u32 ver = pdata->hw_feat.version;
     u32 sver, devid, userver;
 
-    strlcpy(drvinfo->driver, pdata->drv_name, sizeof(drvinfo->driver));
-    strlcpy(drvinfo->version, pdata->drv_ver, sizeof(drvinfo->version));
-    strlcpy(drvinfo->bus_info, dev_name(pdata->dev),
+    strscpy(drvinfo->driver, pdata->drv_name, sizeof(drvinfo->driver));
+    strscpy(drvinfo->version, pdata->drv_ver, sizeof(drvinfo->version));
+    strscpy(drvinfo->bus_info, dev_name(pdata->dev),
     sizeof(drvinfo->bus_info));
     /*
     * D|DEVID: Indicates the Device family
@@ -277,8 +277,8 @@ static void fxgmac_get_reta(struct fxgmac_pdata *pdata, u32 *indir)
     	indir[i] = pdata->rss_table[i] & rss_m;
 }
 
-static int fxgmac_get_rxfh(struct net_device *netdev, u32 *indir, u8 *key,
-			  u8 *hfunc)
+static int fxgmac_get_rxfh(struct net_device *netdev,
+			   struct ethtool_rxfh_param *rxfh)
 {
     struct fxgmac_pdata *pdata = netdev_priv(netdev);
 
@@ -287,30 +287,31 @@ static int fxgmac_get_rxfh(struct net_device *netdev, u32 *indir, u8 *key,
     ETH_RSS_HASH_XOR        __ETH_RSS_HASH(XOR)
     ETH_RSS_HASH_CRC32      __ETH_RSS_HASH(CRC32)
     */
-    if (hfunc)
+    if (rxfh->hfunc)
     {
-    	//*hfunc = ETH_RSS_HASH_XOR;
-    	*hfunc = ETH_RSS_HASH_TOP;
+    	//rxfh->hfunc = ETH_RSS_HASH_XOR;
+    	rxfh->hfunc = ETH_RSS_HASH_TOP;
     	DPRINTK("fxmac, get_rxfh for hash function\n");
     }
 
-    if (indir)
+    if (rxfh->indir)
     {
-    	fxgmac_get_reta(pdata, indir);
+    	fxgmac_get_reta(pdata, rxfh->indir);
     	DPRINTK("fxmac, get_rxfh for indirection tab\n");
     }
 
-    if (key)
+    if (rxfh->key)
     {
-    	memcpy(key, pdata->rss_key, fxgmac_get_rxfh_key_size(netdev));
+    	memcpy(rxfh->key, pdata->rss_key, fxgmac_get_rxfh_key_size(netdev));
     	DPRINTK("fxmac, get_rxfh  for hash key\n");
     }
 
     return 0;
 }
 
-static int fxgmac_set_rxfh(struct net_device *netdev, const u32 *indir,
-			  const u8 *key, const u8 hfunc)
+static int fxgmac_set_rxfh(struct net_device *netdev,
+			   struct ethtool_rxfh_param *rxfh,
+			   struct netlink_ext_ack *extack)
 {
     struct fxgmac_pdata *pdata = netdev_priv(netdev);
     struct fxgmac_hw_ops *hw_ops = &pdata->hw_ops;
@@ -318,13 +319,13 @@ static int fxgmac_set_rxfh(struct net_device *netdev, const u32 *indir,
     u32 reta_entries = fxgmac_rss_indir_size(netdev);
     int max_queues = FXGMAC_MAX_DMA_CHANNELS;
 
-    DPRINTK("fxmac, set_rxfh callin, indir=%lx, key=%lx, func=%02x\n", (unsigned long)indir, (unsigned long)key, hfunc);
+    DPRINTK("fxmac, set_rxfh callin, indir=%lx, key=%lx, func=%02x\n", (unsigned long)rxfh->indir, (unsigned long)rxfh->key, rxfh->hfunc);
 
-    if (hfunc)
+    if (rxfh->hfunc)
     	return -EINVAL;
 
     /* Fill out the redirection table */
-    if (indir) {
+    if (rxfh->indir) {
 #if FXGMAC_MSIX_CH0RXDIS_EN
     	max_queues = max_queues; // kill warning
     	reta_entries = reta_entries;
@@ -334,19 +335,19 @@ static int fxgmac_set_rxfh(struct net_device *netdev, const u32 *indir,
 #else
     	/* double check user input. */
     	for (i = 0; i < reta_entries; i++)
-    	    if (indir[i] >= max_queues)
+    	    if (rxfh->indir[i] >= max_queues)
     	        return -EINVAL;
 
     	for (i = 0; i < reta_entries; i++)
-    	    pdata->rss_table[i] = indir[i];
+    	    pdata->rss_table[i] = rxfh->indir[i];
 
     	hw_ops->write_rss_lookup_table(pdata);
 #endif
     }
 
     /* Fill out the rss hash key */
-    if (FXGMAC_RSS_HASH_KEY_LINUX && key) {
-    	hw_ops->set_rss_hash_key(pdata, key);
+    if (FXGMAC_RSS_HASH_KEY_LINUX && rxfh->key) {
+    	hw_ops->set_rss_hash_key(pdata, rxfh->key);
     }
 
     return 0;
-- 
2.44.0

