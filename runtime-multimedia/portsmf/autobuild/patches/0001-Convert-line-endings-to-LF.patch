From d21c6ef6ff6c99a43ac522f2248fc97075ff08b3 Mon Sep 17 00:00:00 2001
From: Jiangjin Wang <kaymw@aosc.io>
Date: Mon, 29 Jan 2024 03:06:43 -0800
Subject: [PATCH 1/4] Convert line endings to LF

---
 Makefile.am               |   92 +--
 Makefile.in               | 1346 ++++++++++++++++----------------
 algrd_internal.h          |   10 +-
 allegrord.cpp             | 1548 ++++++++++++++++++-------------------
 allegroserial.cpp         |    4 +-
 allegrosmfrd.cpp          |  910 +++++++++++-----------
 allegrosmfwr.cpp          | 1294 +++++++++++++++----------------
 allegrowr.cpp             |  366 ++++-----
 configure.ac              |  272 +++----
 mfmidi.cpp                |  972 +++++++++++------------
 mfmidi.h                  |  196 ++---
 notes.txt                 |   68 +-
 portSMF-uninstalled.pc.in |   32 +-
 portSMF.pc.in             |   20 +-
 portsmf-VC8.sln           |   58 +-
 portsmf-VC8.vcproj        |  426 +++++-----
 portsmf.sln               |   70 +-
 portsmf.vcproj            |  428 +++++-----
 strparse.cpp              |  174 ++---
 strparse.h                |   36 +-
 todo.txt                  |    8 +-
 trace.cpp                 |   50 +-
 trace.h                   |    4 +-
 23 files changed, 4192 insertions(+), 4192 deletions(-)

diff --git a/Makefile.am b/Makefile.am
index 0e71249..25c81ea 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -1,46 +1,46 @@
-## Process this file with automake to produce Makefile.in
-# Makefile(.in) for portSMF using Autotools (but not libtool).
-# Written by Richard Ash following Gary Vaughan's Autobook
-
-# tell aclocal that extra macros can be found in autotools/m4/
-ACLOCAL_AMFLAGS = -I autotools/m4
-
-# define the output library (link with -lportSMF)
-lib_LIBRARIES = libportSMF.a
-
-# define the source files to use
-libportSMF_a_SOURCES = allegro.cpp \
-	allegrosmfwr.cpp \
-	allegrord.cpp \
-	allegrowr.cpp \
-	allegrosmfrd.cpp \
-	mfmidi.cpp \
-	strparse.cpp \
-	algrd_internal.h \
-	algsmfrd_internal.h
-
-# and the header files for the library. At the moment these go into the include
-# directory directly, it would be much better to have them in a subdirectory
-# but that would mean re-organising them here (a subdirectory called portSMF to
-# keep headers in, add -I$(srcdir)/portSMF/ to AM_CXXFLAGS, change the paths
-# to the headers here and change the name of the variable to nobase_include_...
-include_HEADERS = allegro.h \
-	mfmidi.h \
-	strparse.h \
-	trace.h
-
-# files that only really viscous cleans remove
-MAINTAINERCLEANFILES = Makefile.in
-
-# other distributed files in case users don't have a complete set of auto*
-AUX_DIST = $(ac_aux_dir)/config.guess \
-   $(ac_aux_dir)/config.sub \
-   $(ac_aux_dir)/install-sh \
-   $(ac_aux_dir)/mdate-sh \
-   $(ac_aux_dir)/missing \
-   $(ac_aux_dir)/mkinstalldirs \
-   $(MAINTAINERCLEANFILES)
-
-# Documentation files that should be both distributed and installed in the doc
-# directory,
-dist_doc_DATA = README.txt license.txt
+## Process this file with automake to produce Makefile.in
+# Makefile(.in) for portSMF using Autotools (but not libtool).
+# Written by Richard Ash following Gary Vaughan's Autobook
+
+# tell aclocal that extra macros can be found in autotools/m4/
+ACLOCAL_AMFLAGS = -I autotools/m4
+
+# define the output library (link with -lportSMF)
+lib_LIBRARIES = libportSMF.a
+
+# define the source files to use
+libportSMF_a_SOURCES = allegro.cpp \
+	allegrosmfwr.cpp \
+	allegrord.cpp \
+	allegrowr.cpp \
+	allegrosmfrd.cpp \
+	mfmidi.cpp \
+	strparse.cpp \
+	algrd_internal.h \
+	algsmfrd_internal.h
+
+# and the header files for the library. At the moment these go into the include
+# directory directly, it would be much better to have them in a subdirectory
+# but that would mean re-organising them here (a subdirectory called portSMF to
+# keep headers in, add -I$(srcdir)/portSMF/ to AM_CXXFLAGS, change the paths
+# to the headers here and change the name of the variable to nobase_include_...
+include_HEADERS = allegro.h \
+	mfmidi.h \
+	strparse.h \
+	trace.h
+
+# files that only really viscous cleans remove
+MAINTAINERCLEANFILES = Makefile.in
+
+# other distributed files in case users don't have a complete set of auto*
+AUX_DIST = $(ac_aux_dir)/config.guess \
+   $(ac_aux_dir)/config.sub \
+   $(ac_aux_dir)/install-sh \
+   $(ac_aux_dir)/mdate-sh \
+   $(ac_aux_dir)/missing \
+   $(ac_aux_dir)/mkinstalldirs \
+   $(MAINTAINERCLEANFILES)
+
+# Documentation files that should be both distributed and installed in the doc
+# directory,
+dist_doc_DATA = README.txt license.txt
diff --git a/Makefile.in b/Makefile.in
index 358f468..fe225d6 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -1,673 +1,673 @@
-# Makefile.in generated by automake 1.10.2 from Makefile.am.
-# @configure_input@
-
-# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
-# This Makefile.in is free software; the Free Software Foundation
-# gives unlimited permission to copy and/or distribute it,
-# with or without modifications, as long as this notice is preserved.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
-# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
-# PARTICULAR PURPOSE.
-
-@SET_MAKE@
-
-# Makefile(.in) for portSMF using Autotools (but not libtool).
-# Written by Richard Ash following Gary Vaughan's Autobook
-
-
-
-VPATH = @srcdir@
-pkgdatadir = $(datadir)/@PACKAGE@
-pkglibdir = $(libdir)/@PACKAGE@
-pkgincludedir = $(includedir)/@PACKAGE@
-am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
-install_sh_DATA = $(install_sh) -c -m 644
-install_sh_PROGRAM = $(install_sh) -c
-install_sh_SCRIPT = $(install_sh) -c
-INSTALL_HEADER = $(INSTALL_DATA)
-transform = $(program_transform_name)
-NORMAL_INSTALL = :
-PRE_INSTALL = :
-POST_INSTALL = :
-NORMAL_UNINSTALL = :
-PRE_UNINSTALL = :
-POST_UNINSTALL = :
-subdir = .
-DIST_COMMON = $(am__configure_deps) $(dist_doc_DATA) \
-	$(include_HEADERS) $(srcdir)/Makefile.am $(srcdir)/Makefile.in \
-	$(srcdir)/portSMF-uninstalled.pc.in $(srcdir)/portSMF.pc.in \
-	$(top_srcdir)/configure autotools/depcomp autotools/install-sh \
-	autotools/missing
-ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
-am__aclocal_m4_deps =  \
-	$(top_srcdir)/autotools/m4/ax_cflags_strict_prototypes.m4 \
-	$(top_srcdir)/autotools/m4/ax_cflags_warn_all.m4 \
-	$(top_srcdir)/autotools/m4/ax_cxx_check_flag.m4 \
-	$(top_srcdir)/autotools/m4/ax_cxxcpp_check_flag.m4 \
-	$(top_srcdir)/configure.ac
-am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
-	$(ACLOCAL_M4)
-am__CONFIG_DISTCLEAN_FILES = config.status config.cache config.log \
- configure.lineno config.status.lineno
-mkinstalldirs = $(install_sh) -d
-CONFIG_CLEAN_FILES = portSMF.pc portSMF-uninstalled.pc
-am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
-am__vpath_adj = case $$p in \
-    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
-    *) f=$$p;; \
-  esac;
-am__strip_dir = `echo $$p | sed -e 's|^.*/||'`;
-am__installdirs = "$(DESTDIR)$(libdir)" "$(DESTDIR)$(docdir)" \
-	"$(DESTDIR)$(includedir)"
-libLIBRARIES_INSTALL = $(INSTALL_DATA)
-LIBRARIES = $(lib_LIBRARIES)
-AR = ar
-ARFLAGS = cru
-libportSMF_a_AR = $(AR) $(ARFLAGS)
-libportSMF_a_LIBADD =
-am_libportSMF_a_OBJECTS = allegro.$(OBJEXT) allegrosmfwr.$(OBJEXT) \
-	allegrord.$(OBJEXT) allegrowr.$(OBJEXT) allegrosmfrd.$(OBJEXT) \
-	mfmidi.$(OBJEXT) strparse.$(OBJEXT)
-libportSMF_a_OBJECTS = $(am_libportSMF_a_OBJECTS)
-DEFAULT_INCLUDES = -I.@am__isrc@
-depcomp = $(SHELL) $(top_srcdir)/autotools/depcomp
-am__depfiles_maybe = depfiles
-CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
-	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)
-CXXLD = $(CXX)
-CXXLINK = $(CXXLD) $(AM_CXXFLAGS) $(CXXFLAGS) $(AM_LDFLAGS) $(LDFLAGS) \
-	-o $@
-COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
-	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
-CCLD = $(CC)
-LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
-SOURCES = $(libportSMF_a_SOURCES)
-DIST_SOURCES = $(libportSMF_a_SOURCES)
-dist_docDATA_INSTALL = $(INSTALL_DATA)
-DATA = $(dist_doc_DATA)
-includeHEADERS_INSTALL = $(INSTALL_HEADER)
-HEADERS = $(include_HEADERS)
-ETAGS = etags
-CTAGS = ctags
-DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
-distdir = $(PACKAGE)-$(VERSION)
-top_distdir = $(distdir)
-am__remove_distdir = \
-  { test ! -d $(distdir) \
-    || { find $(distdir) -type d ! -perm -200 -exec chmod u+w {} ';' \
-         && rm -fr $(distdir); }; }
-DIST_ARCHIVES = $(distdir).tar.gz
-GZIP_ENV = --best
-distuninstallcheck_listfiles = find . -type f -print
-distcleancheck_listfiles = find . -type f -print
-ACLOCAL = @ACLOCAL@
-AMTAR = @AMTAR@
-AUTOCONF = @AUTOCONF@
-AUTOHEADER = @AUTOHEADER@
-AUTOMAKE = @AUTOMAKE@
-AWK = @AWK@
-CC = @CC@
-CCDEPMODE = @CCDEPMODE@
-CFLAGS = @CFLAGS@
-CPPFLAGS = @CPPFLAGS@
-CXX = @CXX@
-CXXCPP = @CXXCPP@
-CXXDEPMODE = @CXXDEPMODE@
-CXXFLAGS = @CXXFLAGS@
-CYGPATH_W = @CYGPATH_W@
-DEFS = @DEFS@
-DEPDIR = @DEPDIR@
-ECHO_C = @ECHO_C@
-ECHO_N = @ECHO_N@
-ECHO_T = @ECHO_T@
-EGREP = @EGREP@
-EXEEXT = @EXEEXT@
-GREP = @GREP@
-INSTALL = @INSTALL@
-INSTALL_DATA = @INSTALL_DATA@
-INSTALL_PROGRAM = @INSTALL_PROGRAM@
-INSTALL_SCRIPT = @INSTALL_SCRIPT@
-INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
-LDFLAGS = @LDFLAGS@
-LIBOBJS = @LIBOBJS@
-LIBS = @LIBS@
-LTLIBOBJS = @LTLIBOBJS@
-MAINT = @MAINT@
-MAKEINFO = @MAKEINFO@
-MKDIR_P = @MKDIR_P@
-OBJEXT = @OBJEXT@
-PACKAGE = @PACKAGE@
-PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
-PACKAGE_NAME = @PACKAGE_NAME@
-PACKAGE_STRING = @PACKAGE_STRING@
-PACKAGE_TARNAME = @PACKAGE_TARNAME@
-PACKAGE_VERSION = @PACKAGE_VERSION@
-PATH_SEPARATOR = @PATH_SEPARATOR@
-RANLIB = @RANLIB@
-SED = @SED@
-SET_MAKE = @SET_MAKE@
-SHELL = @SHELL@
-STRIP = @STRIP@
-VERSION = @VERSION@
-abs_builddir = @abs_builddir@
-abs_srcdir = @abs_srcdir@
-abs_top_builddir = @abs_top_builddir@
-abs_top_srcdir = @abs_top_srcdir@
-ac_ct_CC = @ac_ct_CC@
-ac_ct_CXX = @ac_ct_CXX@
-am__include = @am__include@
-am__leading_dot = @am__leading_dot@
-am__quote = @am__quote@
-am__tar = @am__tar@
-am__untar = @am__untar@
-bindir = @bindir@
-build_alias = @build_alias@
-builddir = @builddir@
-datadir = @datadir@
-datarootdir = @datarootdir@
-docdir = @docdir@
-dvidir = @dvidir@
-exec_prefix = @exec_prefix@
-host_alias = @host_alias@
-htmldir = @htmldir@
-includedir = @includedir@
-infodir = @infodir@
-install_sh = @install_sh@
-libdir = @libdir@
-libexecdir = @libexecdir@
-localedir = @localedir@
-localstatedir = @localstatedir@
-mandir = @mandir@
-mkdir_p = @mkdir_p@
-oldincludedir = @oldincludedir@
-pdfdir = @pdfdir@
-prefix = @prefix@
-program_transform_name = @program_transform_name@
-psdir = @psdir@
-sbindir = @sbindir@
-sharedstatedir = @sharedstatedir@
-srcdir = @srcdir@
-sysconfdir = @sysconfdir@
-target_alias = @target_alias@
-top_build_prefix = @top_build_prefix@
-top_builddir = @top_builddir@
-top_srcdir = @top_srcdir@
-
-# tell aclocal that extra macros can be found in autotools/m4/
-ACLOCAL_AMFLAGS = -I autotools/m4
-
-# define the output library (link with -lportSMF)
-lib_LIBRARIES = libportSMF.a
-
-# define the source files to use
-libportSMF_a_SOURCES = allegro.cpp \
-	allegrosmfwr.cpp \
-	allegrord.cpp \
-	allegrowr.cpp \
-	allegrosmfrd.cpp \
-	mfmidi.cpp \
-	strparse.cpp \
-	algrd_internal.h \
-	algsmfrd_internal.h
-
-
-# and the header files for the library. At the moment these go into the include
-# directory directly, it would be much better to have them in a subdirectory
-# but that would mean re-organising them here (a subdirectory called portSMF to
-# keep headers in, add -I$(srcdir)/portSMF/ to AM_CXXFLAGS, change the paths
-# to the headers here and change the name of the variable to nobase_include_...
-include_HEADERS = allegro.h \
-	mfmidi.h \
-	strparse.h \
-	trace.h
-
-
-# files that only really viscous cleans remove
-MAINTAINERCLEANFILES = Makefile.in
-
-# other distributed files in case users don't have a complete set of auto*
-AUX_DIST = $(ac_aux_dir)/config.guess \
-   $(ac_aux_dir)/config.sub \
-   $(ac_aux_dir)/install-sh \
-   $(ac_aux_dir)/mdate-sh \
-   $(ac_aux_dir)/missing \
-   $(ac_aux_dir)/mkinstalldirs \
-   $(MAINTAINERCLEANFILES)
-
-
-# Documentation files that should be both distributed and installed in the doc
-# directory,
-dist_doc_DATA = README.txt license.txt
-all: all-am
-
-.SUFFIXES:
-.SUFFIXES: .cpp .o .obj
-am--refresh:
-	@:
-$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
-	@for dep in $?; do \
-	  case '$(am__configure_deps)' in \
-	    *$$dep*) \
-	      echo ' cd $(srcdir) && $(AUTOMAKE) --foreign '; \
-	      cd $(srcdir) && $(AUTOMAKE) --foreign  \
-		&& exit 0; \
-	      exit 1;; \
-	  esac; \
-	done; \
-	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign  Makefile'; \
-	cd $(top_srcdir) && \
-	  $(AUTOMAKE) --foreign  Makefile
-.PRECIOUS: Makefile
-Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
-	@case '$?' in \
-	  *config.status*) \
-	    echo ' $(SHELL) ./config.status'; \
-	    $(SHELL) ./config.status;; \
-	  *) \
-	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe)'; \
-	    cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe);; \
-	esac;
-
-$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
-	$(SHELL) ./config.status --recheck
-
-$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
-	cd $(srcdir) && $(AUTOCONF)
-$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
-	cd $(srcdir) && $(ACLOCAL) $(ACLOCAL_AMFLAGS)
-portSMF.pc: $(top_builddir)/config.status $(srcdir)/portSMF.pc.in
-	cd $(top_builddir) && $(SHELL) ./config.status $@
-portSMF-uninstalled.pc: $(top_builddir)/config.status $(srcdir)/portSMF-uninstalled.pc.in
-	cd $(top_builddir) && $(SHELL) ./config.status $@
-install-libLIBRARIES: $(lib_LIBRARIES)
-	@$(NORMAL_INSTALL)
-	test -z "$(libdir)" || $(MKDIR_P) "$(DESTDIR)$(libdir)"
-	@list='$(lib_LIBRARIES)'; for p in $$list; do \
-	  if test -f $$p; then \
-	    f=$(am__strip_dir) \
-	    echo " $(libLIBRARIES_INSTALL) '$$p' '$(DESTDIR)$(libdir)/$$f'"; \
-	    $(libLIBRARIES_INSTALL) "$$p" "$(DESTDIR)$(libdir)/$$f"; \
-	  else :; fi; \
-	done
-	@$(POST_INSTALL)
-	@list='$(lib_LIBRARIES)'; for p in $$list; do \
-	  if test -f $$p; then \
-	    p=$(am__strip_dir) \
-	    echo " $(RANLIB) '$(DESTDIR)$(libdir)/$$p'"; \
-	    $(RANLIB) "$(DESTDIR)$(libdir)/$$p"; \
-	  else :; fi; \
-	done
-
-uninstall-libLIBRARIES:
-	@$(NORMAL_UNINSTALL)
-	@list='$(lib_LIBRARIES)'; for p in $$list; do \
-	  p=$(am__strip_dir) \
-	  echo " rm -f '$(DESTDIR)$(libdir)/$$p'"; \
-	  rm -f "$(DESTDIR)$(libdir)/$$p"; \
-	done
-
-clean-libLIBRARIES:
-	-test -z "$(lib_LIBRARIES)" || rm -f $(lib_LIBRARIES)
-libportSMF.a: $(libportSMF_a_OBJECTS) $(libportSMF_a_DEPENDENCIES) 
-	-rm -f libportSMF.a
-	$(libportSMF_a_AR) libportSMF.a $(libportSMF_a_OBJECTS) $(libportSMF_a_LIBADD)
-	$(RANLIB) libportSMF.a
-
-mostlyclean-compile:
-	-rm -f *.$(OBJEXT)
-
-distclean-compile:
-	-rm -f *.tab.c
-
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/allegro.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/allegrord.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/allegrosmfrd.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/allegrosmfwr.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/allegrowr.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mfmidi.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/strparse.Po@am__quote@
-
-.cpp.o:
-@am__fastdepCXX_TRUE@	$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
-@am__fastdepCXX_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCXX_FALSE@	$(CXXCOMPILE) -c -o $@ $<
-
-.cpp.obj:
-@am__fastdepCXX_TRUE@	$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
-@am__fastdepCXX_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCXX_FALSE@	$(CXXCOMPILE) -c -o $@ `$(CYGPATH_W) '$<'`
-install-dist_docDATA: $(dist_doc_DATA)
-	@$(NORMAL_INSTALL)
-	test -z "$(docdir)" || $(MKDIR_P) "$(DESTDIR)$(docdir)"
-	@list='$(dist_doc_DATA)'; for p in $$list; do \
-	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
-	  f=$(am__strip_dir) \
-	  echo " $(dist_docDATA_INSTALL) '$$d$$p' '$(DESTDIR)$(docdir)/$$f'"; \
-	  $(dist_docDATA_INSTALL) "$$d$$p" "$(DESTDIR)$(docdir)/$$f"; \
-	done
-
-uninstall-dist_docDATA:
-	@$(NORMAL_UNINSTALL)
-	@list='$(dist_doc_DATA)'; for p in $$list; do \
-	  f=$(am__strip_dir) \
-	  echo " rm -f '$(DESTDIR)$(docdir)/$$f'"; \
-	  rm -f "$(DESTDIR)$(docdir)/$$f"; \
-	done
-install-includeHEADERS: $(include_HEADERS)
-	@$(NORMAL_INSTALL)
-	test -z "$(includedir)" || $(MKDIR_P) "$(DESTDIR)$(includedir)"
-	@list='$(include_HEADERS)'; for p in $$list; do \
-	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
-	  f=$(am__strip_dir) \
-	  echo " $(includeHEADERS_INSTALL) '$$d$$p' '$(DESTDIR)$(includedir)/$$f'"; \
-	  $(includeHEADERS_INSTALL) "$$d$$p" "$(DESTDIR)$(includedir)/$$f"; \
-	done
-
-uninstall-includeHEADERS:
-	@$(NORMAL_UNINSTALL)
-	@list='$(include_HEADERS)'; for p in $$list; do \
-	  f=$(am__strip_dir) \
-	  echo " rm -f '$(DESTDIR)$(includedir)/$$f'"; \
-	  rm -f "$(DESTDIR)$(includedir)/$$f"; \
-	done
-
-ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
-	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
-	mkid -fID $$unique
-tags: TAGS
-
-TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
-		$(TAGS_FILES) $(LISP)
-	tags=; \
-	here=`pwd`; \
-	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
-	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
-	  test -n "$$unique" || unique=$$empty_fix; \
-	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
-	    $$tags $$unique; \
-	fi
-ctags: CTAGS
-CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
-		$(TAGS_FILES) $(LISP)
-	tags=; \
-	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
-	test -z "$(CTAGS_ARGS)$$tags$$unique" \
-	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
-	     $$tags $$unique
-
-GTAGS:
-	here=`$(am__cd) $(top_builddir) && pwd` \
-	  && cd $(top_srcdir) \
-	  && gtags -i $(GTAGS_ARGS) $$here
-
-distclean-tags:
-	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
-
-distdir: $(DISTFILES)
-	$(am__remove_distdir)
-	test -d $(distdir) || mkdir $(distdir)
-	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
-	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
-	list='$(DISTFILES)'; \
-	  dist_files=`for file in $$list; do echo $$file; done | \
-	  sed -e "s|^$$srcdirstrip/||;t" \
-	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
-	case $$dist_files in \
-	  */*) $(MKDIR_P) `echo "$$dist_files" | \
-			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
-			   sort -u` ;; \
-	esac; \
-	for file in $$dist_files; do \
-	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
-	  if test -d $$d/$$file; then \
-	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
-	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
-	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
-	    fi; \
-	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
-	  else \
-	    test -f $(distdir)/$$file \
-	    || cp -p $$d/$$file $(distdir)/$$file \
-	    || exit 1; \
-	  fi; \
-	done
-	-find $(distdir) -type d ! -perm -777 -exec chmod a+rwx {} \; -o \
-	  ! -type d ! -perm -444 -links 1 -exec chmod a+r {} \; -o \
-	  ! -type d ! -perm -400 -exec chmod a+r {} \; -o \
-	  ! -type d ! -perm -444 -exec $(install_sh) -c -m a+r {} {} \; \
-	|| chmod -R a+r $(distdir)
-dist-gzip: distdir
-	tardir=$(distdir) && $(am__tar) | GZIP=$(GZIP_ENV) gzip -c >$(distdir).tar.gz
-	$(am__remove_distdir)
-
-dist-bzip2: distdir
-	tardir=$(distdir) && $(am__tar) | bzip2 -9 -c >$(distdir).tar.bz2
-	$(am__remove_distdir)
-
-dist-lzma: distdir
-	tardir=$(distdir) && $(am__tar) | lzma -9 -c >$(distdir).tar.lzma
-	$(am__remove_distdir)
-
-dist-tarZ: distdir
-	tardir=$(distdir) && $(am__tar) | compress -c >$(distdir).tar.Z
-	$(am__remove_distdir)
-
-dist-shar: distdir
-	shar $(distdir) | GZIP=$(GZIP_ENV) gzip -c >$(distdir).shar.gz
-	$(am__remove_distdir)
-
-dist-zip: distdir
-	-rm -f $(distdir).zip
-	zip -rq $(distdir).zip $(distdir)
-	$(am__remove_distdir)
-
-dist dist-all: distdir
-	tardir=$(distdir) && $(am__tar) | GZIP=$(GZIP_ENV) gzip -c >$(distdir).tar.gz
-	$(am__remove_distdir)
-
-# This target untars the dist file and tries a VPATH configuration.  Then
-# it guarantees that the distribution is self-contained by making another
-# tarfile.
-distcheck: dist
-	case '$(DIST_ARCHIVES)' in \
-	*.tar.gz*) \
-	  GZIP=$(GZIP_ENV) gunzip -c $(distdir).tar.gz | $(am__untar) ;;\
-	*.tar.bz2*) \
-	  bunzip2 -c $(distdir).tar.bz2 | $(am__untar) ;;\
-	*.tar.lzma*) \
-	  unlzma -c $(distdir).tar.lzma | $(am__untar) ;;\
-	*.tar.Z*) \
-	  uncompress -c $(distdir).tar.Z | $(am__untar) ;;\
-	*.shar.gz*) \
-	  GZIP=$(GZIP_ENV) gunzip -c $(distdir).shar.gz | unshar ;;\
-	*.zip*) \
-	  unzip $(distdir).zip ;;\
-	esac
-	chmod -R a-w $(distdir); chmod a+w $(distdir)
-	mkdir $(distdir)/_build
-	mkdir $(distdir)/_inst
-	chmod a-w $(distdir)
-	dc_install_base=`$(am__cd) $(distdir)/_inst && pwd | sed -e 's,^[^:\\/]:[\\/],/,'` \
-	  && dc_destdir="$${TMPDIR-/tmp}/am-dc-$$$$/" \
-	  && cd $(distdir)/_build \
-	  && ../configure --srcdir=.. --prefix="$$dc_install_base" \
-	    $(DISTCHECK_CONFIGURE_FLAGS) \
-	  && $(MAKE) $(AM_MAKEFLAGS) \
-	  && $(MAKE) $(AM_MAKEFLAGS) dvi \
-	  && $(MAKE) $(AM_MAKEFLAGS) check \
-	  && $(MAKE) $(AM_MAKEFLAGS) install \
-	  && $(MAKE) $(AM_MAKEFLAGS) installcheck \
-	  && $(MAKE) $(AM_MAKEFLAGS) uninstall \
-	  && $(MAKE) $(AM_MAKEFLAGS) distuninstallcheck_dir="$$dc_install_base" \
-	        distuninstallcheck \
-	  && chmod -R a-w "$$dc_install_base" \
-	  && ({ \
-	       (cd ../.. && umask 077 && mkdir "$$dc_destdir") \
-	       && $(MAKE) $(AM_MAKEFLAGS) DESTDIR="$$dc_destdir" install \
-	       && $(MAKE) $(AM_MAKEFLAGS) DESTDIR="$$dc_destdir" uninstall \
-	       && $(MAKE) $(AM_MAKEFLAGS) DESTDIR="$$dc_destdir" \
-	            distuninstallcheck_dir="$$dc_destdir" distuninstallcheck; \
-	      } || { rm -rf "$$dc_destdir"; exit 1; }) \
-	  && rm -rf "$$dc_destdir" \
-	  && $(MAKE) $(AM_MAKEFLAGS) dist \
-	  && rm -rf $(DIST_ARCHIVES) \
-	  && $(MAKE) $(AM_MAKEFLAGS) distcleancheck
-	$(am__remove_distdir)
-	@(echo "$(distdir) archives ready for distribution: "; \
-	  list='$(DIST_ARCHIVES)'; for i in $$list; do echo $$i; done) | \
-	  sed -e 1h -e 1s/./=/g -e 1p -e 1x -e '$$p' -e '$$x'
-distuninstallcheck:
-	@cd $(distuninstallcheck_dir) \
-	&& test `$(distuninstallcheck_listfiles) | wc -l` -le 1 \
-	   || { echo "ERROR: files left after uninstall:" ; \
-	        if test -n "$(DESTDIR)"; then \
-	          echo "  (check DESTDIR support)"; \
-	        fi ; \
-	        $(distuninstallcheck_listfiles) ; \
-	        exit 1; } >&2
-distcleancheck: distclean
-	@if test '$(srcdir)' = . ; then \
-	  echo "ERROR: distcleancheck can only run from a VPATH build" ; \
-	  exit 1 ; \
-	fi
-	@test `$(distcleancheck_listfiles) | wc -l` -eq 0 \
-	  || { echo "ERROR: files left in build directory after distclean:" ; \
-	       $(distcleancheck_listfiles) ; \
-	       exit 1; } >&2
-check-am: all-am
-check: check-am
-all-am: Makefile $(LIBRARIES) $(DATA) $(HEADERS)
-installdirs:
-	for dir in "$(DESTDIR)$(libdir)" "$(DESTDIR)$(docdir)" "$(DESTDIR)$(includedir)"; do \
-	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
-	done
-install: install-am
-install-exec: install-exec-am
-install-data: install-data-am
-uninstall: uninstall-am
-
-install-am: all-am
-	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
-
-installcheck: installcheck-am
-install-strip:
-	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
-	  `test -z '$(STRIP)' || \
-	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
-mostlyclean-generic:
-
-clean-generic:
-
-distclean-generic:
-	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
-
-maintainer-clean-generic:
-	@echo "This command is intended for maintainers to use"
-	@echo "it deletes files that may require special tools to rebuild."
-	-test -z "$(MAINTAINERCLEANFILES)" || rm -f $(MAINTAINERCLEANFILES)
-clean: clean-am
-
-clean-am: clean-generic clean-libLIBRARIES mostlyclean-am
-
-distclean: distclean-am
-	-rm -f $(am__CONFIG_DISTCLEAN_FILES)
-	-rm -rf ./$(DEPDIR)
-	-rm -f Makefile
-distclean-am: clean-am distclean-compile distclean-generic \
-	distclean-tags
-
-dvi: dvi-am
-
-dvi-am:
-
-html: html-am
-
-info: info-am
-
-info-am:
-
-install-data-am: install-dist_docDATA install-includeHEADERS
-
-install-dvi: install-dvi-am
-
-install-exec-am: install-libLIBRARIES
-
-install-html: install-html-am
-
-install-info: install-info-am
-
-install-man:
-
-install-pdf: install-pdf-am
-
-install-ps: install-ps-am
-
-installcheck-am:
-
-maintainer-clean: maintainer-clean-am
-	-rm -f $(am__CONFIG_DISTCLEAN_FILES)
-	-rm -rf $(top_srcdir)/autom4te.cache
-	-rm -rf ./$(DEPDIR)
-	-rm -f Makefile
-maintainer-clean-am: distclean-am maintainer-clean-generic
-
-mostlyclean: mostlyclean-am
-
-mostlyclean-am: mostlyclean-compile mostlyclean-generic
-
-pdf: pdf-am
-
-pdf-am:
-
-ps: ps-am
-
-ps-am:
-
-uninstall-am: uninstall-dist_docDATA uninstall-includeHEADERS \
-	uninstall-libLIBRARIES
-
-.MAKE: install-am install-strip
-
-.PHONY: CTAGS GTAGS all all-am am--refresh check check-am clean \
-	clean-generic clean-libLIBRARIES ctags dist dist-all \
-	dist-bzip2 dist-gzip dist-lzma dist-shar dist-tarZ dist-zip \
-	distcheck distclean distclean-compile distclean-generic \
-	distclean-tags distcleancheck distdir distuninstallcheck dvi \
-	dvi-am html html-am info info-am install install-am \
-	install-data install-data-am install-dist_docDATA install-dvi \
-	install-dvi-am install-exec install-exec-am install-html \
-	install-html-am install-includeHEADERS install-info \
-	install-info-am install-libLIBRARIES install-man install-pdf \
-	install-pdf-am install-ps install-ps-am install-strip \
-	installcheck installcheck-am installdirs maintainer-clean \
-	maintainer-clean-generic mostlyclean mostlyclean-compile \
-	mostlyclean-generic pdf pdf-am ps ps-am tags uninstall \
-	uninstall-am uninstall-dist_docDATA uninstall-includeHEADERS \
-	uninstall-libLIBRARIES
-
-# Tell versions [3.59,3.63) of GNU make to not export all variables.
-# Otherwise a system limit (for SysV at least) may be exceeded.
-.NOEXPORT:
+# Makefile.in generated by automake 1.10.2 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+# Makefile(.in) for portSMF using Autotools (but not libtool).
+# Written by Richard Ash following Gary Vaughan's Autobook
+
+
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+subdir = .
+DIST_COMMON = $(am__configure_deps) $(dist_doc_DATA) \
+	$(include_HEADERS) $(srcdir)/Makefile.am $(srcdir)/Makefile.in \
+	$(srcdir)/portSMF-uninstalled.pc.in $(srcdir)/portSMF.pc.in \
+	$(top_srcdir)/configure autotools/depcomp autotools/install-sh \
+	autotools/missing
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps =  \
+	$(top_srcdir)/autotools/m4/ax_cflags_strict_prototypes.m4 \
+	$(top_srcdir)/autotools/m4/ax_cflags_warn_all.m4 \
+	$(top_srcdir)/autotools/m4/ax_cxx_check_flag.m4 \
+	$(top_srcdir)/autotools/m4/ax_cxxcpp_check_flag.m4 \
+	$(top_srcdir)/configure.ac
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+am__CONFIG_DISTCLEAN_FILES = config.status config.cache config.log \
+ configure.lineno config.status.lineno
+mkinstalldirs = $(install_sh) -d
+CONFIG_CLEAN_FILES = portSMF.pc portSMF-uninstalled.pc
+am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
+am__vpath_adj = case $$p in \
+    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
+    *) f=$$p;; \
+  esac;
+am__strip_dir = `echo $$p | sed -e 's|^.*/||'`;
+am__installdirs = "$(DESTDIR)$(libdir)" "$(DESTDIR)$(docdir)" \
+	"$(DESTDIR)$(includedir)"
+libLIBRARIES_INSTALL = $(INSTALL_DATA)
+LIBRARIES = $(lib_LIBRARIES)
+AR = ar
+ARFLAGS = cru
+libportSMF_a_AR = $(AR) $(ARFLAGS)
+libportSMF_a_LIBADD =
+am_libportSMF_a_OBJECTS = allegro.$(OBJEXT) allegrosmfwr.$(OBJEXT) \
+	allegrord.$(OBJEXT) allegrowr.$(OBJEXT) allegrosmfrd.$(OBJEXT) \
+	mfmidi.$(OBJEXT) strparse.$(OBJEXT)
+libportSMF_a_OBJECTS = $(am_libportSMF_a_OBJECTS)
+DEFAULT_INCLUDES = -I.@am__isrc@
+depcomp = $(SHELL) $(top_srcdir)/autotools/depcomp
+am__depfiles_maybe = depfiles
+CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)
+CXXLD = $(CXX)
+CXXLINK = $(CXXLD) $(AM_CXXFLAGS) $(CXXFLAGS) $(AM_LDFLAGS) $(LDFLAGS) \
+	-o $@
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
+SOURCES = $(libportSMF_a_SOURCES)
+DIST_SOURCES = $(libportSMF_a_SOURCES)
+dist_docDATA_INSTALL = $(INSTALL_DATA)
+DATA = $(dist_doc_DATA)
+includeHEADERS_INSTALL = $(INSTALL_HEADER)
+HEADERS = $(include_HEADERS)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+distdir = $(PACKAGE)-$(VERSION)
+top_distdir = $(distdir)
+am__remove_distdir = \
+  { test ! -d $(distdir) \
+    || { find $(distdir) -type d ! -perm -200 -exec chmod u+w {} ';' \
+         && rm -fr $(distdir); }; }
+DIST_ARCHIVES = $(distdir).tar.gz
+GZIP_ENV = --best
+distuninstallcheck_listfiles = find . -type f -print
+distcleancheck_listfiles = find . -type f -print
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPPFLAGS = @CPPFLAGS@
+CXX = @CXX@
+CXXCPP = @CXXCPP@
+CXXDEPMODE = @CXXDEPMODE@
+CXXFLAGS = @CXXFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LDFLAGS = @LDFLAGS@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+OBJEXT = @OBJEXT@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_CXX = @ac_ct_CXX@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build_alias = @build_alias@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host_alias = @host_alias@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+
+# tell aclocal that extra macros can be found in autotools/m4/
+ACLOCAL_AMFLAGS = -I autotools/m4
+
+# define the output library (link with -lportSMF)
+lib_LIBRARIES = libportSMF.a
+
+# define the source files to use
+libportSMF_a_SOURCES = allegro.cpp \
+	allegrosmfwr.cpp \
+	allegrord.cpp \
+	allegrowr.cpp \
+	allegrosmfrd.cpp \
+	mfmidi.cpp \
+	strparse.cpp \
+	algrd_internal.h \
+	algsmfrd_internal.h
+
+
+# and the header files for the library. At the moment these go into the include
+# directory directly, it would be much better to have them in a subdirectory
+# but that would mean re-organising them here (a subdirectory called portSMF to
+# keep headers in, add -I$(srcdir)/portSMF/ to AM_CXXFLAGS, change the paths
+# to the headers here and change the name of the variable to nobase_include_...
+include_HEADERS = allegro.h \
+	mfmidi.h \
+	strparse.h \
+	trace.h
+
+
+# files that only really viscous cleans remove
+MAINTAINERCLEANFILES = Makefile.in
+
+# other distributed files in case users don't have a complete set of auto*
+AUX_DIST = $(ac_aux_dir)/config.guess \
+   $(ac_aux_dir)/config.sub \
+   $(ac_aux_dir)/install-sh \
+   $(ac_aux_dir)/mdate-sh \
+   $(ac_aux_dir)/missing \
+   $(ac_aux_dir)/mkinstalldirs \
+   $(MAINTAINERCLEANFILES)
+
+
+# Documentation files that should be both distributed and installed in the doc
+# directory,
+dist_doc_DATA = README.txt license.txt
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .cpp .o .obj
+am--refresh:
+	@:
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      echo ' cd $(srcdir) && $(AUTOMAKE) --foreign '; \
+	      cd $(srcdir) && $(AUTOMAKE) --foreign  \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign  Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign  Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    echo ' $(SHELL) ./config.status'; \
+	    $(SHELL) ./config.status;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	$(SHELL) ./config.status --recheck
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(srcdir) && $(AUTOCONF)
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(srcdir) && $(ACLOCAL) $(ACLOCAL_AMFLAGS)
+portSMF.pc: $(top_builddir)/config.status $(srcdir)/portSMF.pc.in
+	cd $(top_builddir) && $(SHELL) ./config.status $@
+portSMF-uninstalled.pc: $(top_builddir)/config.status $(srcdir)/portSMF-uninstalled.pc.in
+	cd $(top_builddir) && $(SHELL) ./config.status $@
+install-libLIBRARIES: $(lib_LIBRARIES)
+	@$(NORMAL_INSTALL)
+	test -z "$(libdir)" || $(MKDIR_P) "$(DESTDIR)$(libdir)"
+	@list='$(lib_LIBRARIES)'; for p in $$list; do \
+	  if test -f $$p; then \
+	    f=$(am__strip_dir) \
+	    echo " $(libLIBRARIES_INSTALL) '$$p' '$(DESTDIR)$(libdir)/$$f'"; \
+	    $(libLIBRARIES_INSTALL) "$$p" "$(DESTDIR)$(libdir)/$$f"; \
+	  else :; fi; \
+	done
+	@$(POST_INSTALL)
+	@list='$(lib_LIBRARIES)'; for p in $$list; do \
+	  if test -f $$p; then \
+	    p=$(am__strip_dir) \
+	    echo " $(RANLIB) '$(DESTDIR)$(libdir)/$$p'"; \
+	    $(RANLIB) "$(DESTDIR)$(libdir)/$$p"; \
+	  else :; fi; \
+	done
+
+uninstall-libLIBRARIES:
+	@$(NORMAL_UNINSTALL)
+	@list='$(lib_LIBRARIES)'; for p in $$list; do \
+	  p=$(am__strip_dir) \
+	  echo " rm -f '$(DESTDIR)$(libdir)/$$p'"; \
+	  rm -f "$(DESTDIR)$(libdir)/$$p"; \
+	done
+
+clean-libLIBRARIES:
+	-test -z "$(lib_LIBRARIES)" || rm -f $(lib_LIBRARIES)
+libportSMF.a: $(libportSMF_a_OBJECTS) $(libportSMF_a_DEPENDENCIES) 
+	-rm -f libportSMF.a
+	$(libportSMF_a_AR) libportSMF.a $(libportSMF_a_OBJECTS) $(libportSMF_a_LIBADD)
+	$(RANLIB) libportSMF.a
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/allegro.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/allegrord.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/allegrosmfrd.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/allegrosmfwr.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/allegrowr.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mfmidi.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/strparse.Po@am__quote@
+
+.cpp.o:
+@am__fastdepCXX_TRUE@	$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCXX_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCXX_FALSE@	$(CXXCOMPILE) -c -o $@ $<
+
+.cpp.obj:
+@am__fastdepCXX_TRUE@	$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCXX_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCXX_FALSE@	$(CXXCOMPILE) -c -o $@ `$(CYGPATH_W) '$<'`
+install-dist_docDATA: $(dist_doc_DATA)
+	@$(NORMAL_INSTALL)
+	test -z "$(docdir)" || $(MKDIR_P) "$(DESTDIR)$(docdir)"
+	@list='$(dist_doc_DATA)'; for p in $$list; do \
+	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
+	  f=$(am__strip_dir) \
+	  echo " $(dist_docDATA_INSTALL) '$$d$$p' '$(DESTDIR)$(docdir)/$$f'"; \
+	  $(dist_docDATA_INSTALL) "$$d$$p" "$(DESTDIR)$(docdir)/$$f"; \
+	done
+
+uninstall-dist_docDATA:
+	@$(NORMAL_UNINSTALL)
+	@list='$(dist_doc_DATA)'; for p in $$list; do \
+	  f=$(am__strip_dir) \
+	  echo " rm -f '$(DESTDIR)$(docdir)/$$f'"; \
+	  rm -f "$(DESTDIR)$(docdir)/$$f"; \
+	done
+install-includeHEADERS: $(include_HEADERS)
+	@$(NORMAL_INSTALL)
+	test -z "$(includedir)" || $(MKDIR_P) "$(DESTDIR)$(includedir)"
+	@list='$(include_HEADERS)'; for p in $$list; do \
+	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
+	  f=$(am__strip_dir) \
+	  echo " $(includeHEADERS_INSTALL) '$$d$$p' '$(DESTDIR)$(includedir)/$$f'"; \
+	  $(includeHEADERS_INSTALL) "$$d$$p" "$(DESTDIR)$(includedir)/$$f"; \
+	done
+
+uninstall-includeHEADERS:
+	@$(NORMAL_UNINSTALL)
+	@list='$(include_HEADERS)'; for p in $$list; do \
+	  f=$(am__strip_dir) \
+	  echo " rm -f '$(DESTDIR)$(includedir)/$$f'"; \
+	  rm -f "$(DESTDIR)$(includedir)/$$f"; \
+	done
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	$(am__remove_distdir)
+	test -d $(distdir) || mkdir $(distdir)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+	-find $(distdir) -type d ! -perm -777 -exec chmod a+rwx {} \; -o \
+	  ! -type d ! -perm -444 -links 1 -exec chmod a+r {} \; -o \
+	  ! -type d ! -perm -400 -exec chmod a+r {} \; -o \
+	  ! -type d ! -perm -444 -exec $(install_sh) -c -m a+r {} {} \; \
+	|| chmod -R a+r $(distdir)
+dist-gzip: distdir
+	tardir=$(distdir) && $(am__tar) | GZIP=$(GZIP_ENV) gzip -c >$(distdir).tar.gz
+	$(am__remove_distdir)
+
+dist-bzip2: distdir
+	tardir=$(distdir) && $(am__tar) | bzip2 -9 -c >$(distdir).tar.bz2
+	$(am__remove_distdir)
+
+dist-lzma: distdir
+	tardir=$(distdir) && $(am__tar) | lzma -9 -c >$(distdir).tar.lzma
+	$(am__remove_distdir)
+
+dist-tarZ: distdir
+	tardir=$(distdir) && $(am__tar) | compress -c >$(distdir).tar.Z
+	$(am__remove_distdir)
+
+dist-shar: distdir
+	shar $(distdir) | GZIP=$(GZIP_ENV) gzip -c >$(distdir).shar.gz
+	$(am__remove_distdir)
+
+dist-zip: distdir
+	-rm -f $(distdir).zip
+	zip -rq $(distdir).zip $(distdir)
+	$(am__remove_distdir)
+
+dist dist-all: distdir
+	tardir=$(distdir) && $(am__tar) | GZIP=$(GZIP_ENV) gzip -c >$(distdir).tar.gz
+	$(am__remove_distdir)
+
+# This target untars the dist file and tries a VPATH configuration.  Then
+# it guarantees that the distribution is self-contained by making another
+# tarfile.
+distcheck: dist
+	case '$(DIST_ARCHIVES)' in \
+	*.tar.gz*) \
+	  GZIP=$(GZIP_ENV) gunzip -c $(distdir).tar.gz | $(am__untar) ;;\
+	*.tar.bz2*) \
+	  bunzip2 -c $(distdir).tar.bz2 | $(am__untar) ;;\
+	*.tar.lzma*) \
+	  unlzma -c $(distdir).tar.lzma | $(am__untar) ;;\
+	*.tar.Z*) \
+	  uncompress -c $(distdir).tar.Z | $(am__untar) ;;\
+	*.shar.gz*) \
+	  GZIP=$(GZIP_ENV) gunzip -c $(distdir).shar.gz | unshar ;;\
+	*.zip*) \
+	  unzip $(distdir).zip ;;\
+	esac
+	chmod -R a-w $(distdir); chmod a+w $(distdir)
+	mkdir $(distdir)/_build
+	mkdir $(distdir)/_inst
+	chmod a-w $(distdir)
+	dc_install_base=`$(am__cd) $(distdir)/_inst && pwd | sed -e 's,^[^:\\/]:[\\/],/,'` \
+	  && dc_destdir="$${TMPDIR-/tmp}/am-dc-$$$$/" \
+	  && cd $(distdir)/_build \
+	  && ../configure --srcdir=.. --prefix="$$dc_install_base" \
+	    $(DISTCHECK_CONFIGURE_FLAGS) \
+	  && $(MAKE) $(AM_MAKEFLAGS) \
+	  && $(MAKE) $(AM_MAKEFLAGS) dvi \
+	  && $(MAKE) $(AM_MAKEFLAGS) check \
+	  && $(MAKE) $(AM_MAKEFLAGS) install \
+	  && $(MAKE) $(AM_MAKEFLAGS) installcheck \
+	  && $(MAKE) $(AM_MAKEFLAGS) uninstall \
+	  && $(MAKE) $(AM_MAKEFLAGS) distuninstallcheck_dir="$$dc_install_base" \
+	        distuninstallcheck \
+	  && chmod -R a-w "$$dc_install_base" \
+	  && ({ \
+	       (cd ../.. && umask 077 && mkdir "$$dc_destdir") \
+	       && $(MAKE) $(AM_MAKEFLAGS) DESTDIR="$$dc_destdir" install \
+	       && $(MAKE) $(AM_MAKEFLAGS) DESTDIR="$$dc_destdir" uninstall \
+	       && $(MAKE) $(AM_MAKEFLAGS) DESTDIR="$$dc_destdir" \
+	            distuninstallcheck_dir="$$dc_destdir" distuninstallcheck; \
+	      } || { rm -rf "$$dc_destdir"; exit 1; }) \
+	  && rm -rf "$$dc_destdir" \
+	  && $(MAKE) $(AM_MAKEFLAGS) dist \
+	  && rm -rf $(DIST_ARCHIVES) \
+	  && $(MAKE) $(AM_MAKEFLAGS) distcleancheck
+	$(am__remove_distdir)
+	@(echo "$(distdir) archives ready for distribution: "; \
+	  list='$(DIST_ARCHIVES)'; for i in $$list; do echo $$i; done) | \
+	  sed -e 1h -e 1s/./=/g -e 1p -e 1x -e '$$p' -e '$$x'
+distuninstallcheck:
+	@cd $(distuninstallcheck_dir) \
+	&& test `$(distuninstallcheck_listfiles) | wc -l` -le 1 \
+	   || { echo "ERROR: files left after uninstall:" ; \
+	        if test -n "$(DESTDIR)"; then \
+	          echo "  (check DESTDIR support)"; \
+	        fi ; \
+	        $(distuninstallcheck_listfiles) ; \
+	        exit 1; } >&2
+distcleancheck: distclean
+	@if test '$(srcdir)' = . ; then \
+	  echo "ERROR: distcleancheck can only run from a VPATH build" ; \
+	  exit 1 ; \
+	fi
+	@test `$(distcleancheck_listfiles) | wc -l` -eq 0 \
+	  || { echo "ERROR: files left in build directory after distclean:" ; \
+	       $(distcleancheck_listfiles) ; \
+	       exit 1; } >&2
+check-am: all-am
+check: check-am
+all-am: Makefile $(LIBRARIES) $(DATA) $(HEADERS)
+installdirs:
+	for dir in "$(DESTDIR)$(libdir)" "$(DESTDIR)$(docdir)" "$(DESTDIR)$(includedir)"; do \
+	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
+	done
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+	-test -z "$(MAINTAINERCLEANFILES)" || rm -f $(MAINTAINERCLEANFILES)
+clean: clean-am
+
+clean-am: clean-generic clean-libLIBRARIES mostlyclean-am
+
+distclean: distclean-am
+	-rm -f $(am__CONFIG_DISTCLEAN_FILES)
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+info: info-am
+
+info-am:
+
+install-data-am: install-dist_docDATA install-includeHEADERS
+
+install-dvi: install-dvi-am
+
+install-exec-am: install-libLIBRARIES
+
+install-html: install-html-am
+
+install-info: install-info-am
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-ps: install-ps-am
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -f $(am__CONFIG_DISTCLEAN_FILES)
+	-rm -rf $(top_srcdir)/autom4te.cache
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-dist_docDATA uninstall-includeHEADERS \
+	uninstall-libLIBRARIES
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS all all-am am--refresh check check-am clean \
+	clean-generic clean-libLIBRARIES ctags dist dist-all \
+	dist-bzip2 dist-gzip dist-lzma dist-shar dist-tarZ dist-zip \
+	distcheck distclean distclean-compile distclean-generic \
+	distclean-tags distcleancheck distdir distuninstallcheck dvi \
+	dvi-am html html-am info info-am install install-am \
+	install-data install-data-am install-dist_docDATA install-dvi \
+	install-dvi-am install-exec install-exec-am install-html \
+	install-html-am install-includeHEADERS install-info \
+	install-info-am install-libLIBRARIES install-man install-pdf \
+	install-pdf-am install-ps install-ps-am install-strip \
+	installcheck installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic pdf pdf-am ps ps-am tags uninstall \
+	uninstall-am uninstall-dist_docDATA uninstall-includeHEADERS \
+	uninstall-libLIBRARIES
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff --git a/algrd_internal.h b/algrd_internal.h
index 7e3ac88..8b58872 100644
--- a/algrd_internal.h
+++ b/algrd_internal.h
@@ -1,5 +1,5 @@
-/* algread_internal.h -- interface between allegro.cpp and allegrord.cpp */
-
-Alg_error alg_read(std::istream &file, Alg_seq_ptr new_seq, 
-                   double *offset_ptr = NULL);
-
+/* algread_internal.h -- interface between allegro.cpp and allegrord.cpp */
+
+Alg_error alg_read(std::istream &file, Alg_seq_ptr new_seq, 
+                   double *offset_ptr = NULL);
+
diff --git a/allegrord.cpp b/allegrord.cpp
index 307f956..87e1dcb 100755
--- a/allegrord.cpp
+++ b/allegrord.cpp
@@ -1,774 +1,774 @@
-#include "assert.h"
-#include "stdlib.h"
-#include "string.h"
-#include "ctype.h"
-#include "trace.h"
-#include <string>
-#include <fstream>
-#include <algorithm>
-#include "strparse.h"
-#include "allegro.h"
-#include "algrd_internal.h"
-
-using namespace std;
-
-#define streql(s1, s2) (strcmp(s1, s2) == 0)
-#define field_max 80
-
-class Alg_reader {
-public:
-    istream *file;
-    string input_line;
-    int line_no;
-    String_parse line_parser;
-    bool line_parser_flag;
-    string field;
-    bool error_flag;
-    Alg_seq_ptr seq;
-    double tsnum;
-    double tsden;
-    double offset;
-    bool offset_found;
-
-    Alg_reader(istream *a_file, Alg_seq_ptr new_seq);
-    void readline();
-    Alg_parameters_ptr process_attributes(Alg_parameters_ptr attributes,
-                                          double time);
-    bool parse();
-    long parse_chan(string &field);
-    long parse_int(string &field);
-    int find_real_in(string &field, int n);
-    double parse_real(string &field);
-    void parse_error(string &field, long offset, char *message);
-    double parse_dur(string &field, double base);
-    double parse_after_dur(double dur, string &field, int n, double base);
-    double parse_loud(string &field);
-    long parse_key(string &field);
-    double parse_pitch(string &field);
-    long parse_after_key(int key, string &field, int n);
-    long find_int_in(string &field, int n);
-    bool parse_attribute(string &field, Alg_parameter_ptr parm);
-    bool parse_val(Alg_parameter_ptr param, string &s, int i);
-    bool check_type(char type_char, Alg_parameter_ptr param);
-};
-
-
-double Alg_reader::parse_pitch(string &field)
-{
-    if (isdigit(field[1])) {
-        int last = find_real_in(field, 1);
-        string real_string = field.substr(1, last - 1);
-        return atof(real_string.c_str());
-    } else {
-        return (double) parse_key(field);
-    }
-}
-
-
-// it is the responsibility of the caller to delete
-// the seq
-Alg_reader::Alg_reader(istream *a_file, Alg_seq_ptr new_seq)
-{
-    file = a_file; // save the file
-    line_parser_flag = false;
-    line_no = 0;
-    tsnum = 4; // default time signature
-    tsden = 4;
-    seq = new_seq;
-    offset = 0.0;
-    offset_found = false;
-}
-
-
-Alg_error alg_read(istream &file, Alg_seq_ptr new_seq, double *offset_ptr)
-    // read a sequence from allegro file
-{
-    assert(new_seq);
-    Alg_reader alg_reader(&file, new_seq);
-    bool err = alg_reader.parse();
-    if (!err && offset_ptr) {
-        *offset_ptr = alg_reader.offset;
-    }
-    return (err ? alg_error_syntax : alg_no_error);
-}
-
-
-void Alg_reader::readline()
-{
-    // a word about memory management: this Alg_reader has a
-    // member variable input_line that holds a line of input
-    // it is reused for each line. input_line is parsed by
-    // line_parser, which holds a reference to input_line
-    line_parser_flag = false;
-    if (getline(*file, input_line)) {
-        line_parser.init(&input_line);
-        line_parser_flag = true;
-        error_flag = false;
-    }
-}
-
-
-Alg_parameters_ptr Alg_reader::process_attributes(
-        Alg_parameters_ptr attributes, double time)
-{
-    // print "process_attributes:", attributes
-    bool ts_flag = false;
-    if (attributes) {
-        Alg_parameters_ptr a;
-        bool in_seconds = seq->get_units_are_seconds();
-        if (a = Alg_parameters::remove_key(&attributes, "tempor")) {
-            double tempo = a->parm.r;
-            seq->insert_tempo(tempo, seq->get_time_map()->time_to_beat(time));
-        }
-        if (a = Alg_parameters::remove_key(&attributes, "beatr")) {
-            double beat = a->parm.r;
-            seq->insert_beat(time, beat);
-        }
-        if (a = Alg_parameters::remove_key(&attributes, "timesig_numr")) {
-            tsnum = a->parm.r;
-            ts_flag = true;
-        }
-        if (a = Alg_parameters::remove_key(&attributes, "timesig_denr")) {
-            tsden = a->parm.r;
-            ts_flag = true;
-        }
-        if (ts_flag) {
-            seq->set_time_sig(seq->get_time_map()->time_to_beat(time),
-            tsnum, tsden);
-        }
-        if (in_seconds) seq->convert_to_seconds();
-    }
-    return attributes; // in case it was modified
-}
-
-
-bool Alg_reader::parse()
-{
-    int voice = 0;
-    int key = 60;
-    double loud = 100.0;
-    double pitch = 60.0;
-    double dur = 1.0;
-    double time = 0.0;
-    int track_num = 0;
-    seq->convert_to_seconds();
-    //seq->set_real_dur(0.0); // just in case it's not initialized already
-    readline();
-    bool valid = false; // ignore blank lines
-    while (line_parser_flag) {
-        bool time_flag = false;
-        bool next_flag = false;
-        double next;
-        bool voice_flag = false;
-        bool loud_flag = false;
-        bool dur_flag = false;
-        bool new_pitch_flag = false; // "P" syntax or "A"-"G" syntax
-        double new_pitch = 0.0;
-        bool new_key_flag = false;   // "K" syntax
-        int new_key = 0;
-        Alg_parameters_ptr attributes = NULL;
-        if (line_parser.peek() == '#') {
-            // look for #track
-            line_parser.get_nonspace_quoted(field);
-            if (streql(field.c_str(), "#track")) {
-                line_parser.get_nonspace_quoted(field); // number
-                field.insert(0, " "); // need char at beginning because
-                // parse_int ignores the first character of the argument
-                track_num = parse_int(field);
-                seq->add_track(track_num);
-
-                // maybe we have a sequence or track name
-                line_parser.get_remainder(field);
-                // if there is a non-space character after #track n then
-                // use it as sequence or track name. Note that because we
-                // skip over spaces, a sequence or track name cannot begin
-                // with leading blanks. Another decision is that the name
-                // must be at time zero
-                if (field.length() > 0) {
-                    // insert the field as sequence name or track name
-                    Alg_update_ptr update = new Alg_update;
-                    update->chan = -1;
-                    update->time = 0;
-                    update->set_identifier(-1);
-                    // sequence name is whatever is on track 0
-                    // other tracks have track names
-                    const char *attr =
-                            (track_num == 0 ? "seqnames" : "tracknames");
-                    update->parameter.set_attr(
-                            symbol_table.insert_string(attr));
-                    update->parameter.s = heapify(field.c_str());
-                    seq->add_event(update, track_num);
-                }
-            } else if (streql(field.c_str(), "#offset")) {
-                if (offset_found) {
-                    parse_error(field, 0, "#offset specified twice");
-                }
-                offset_found = true;
-                line_parser.get_nonspace_quoted(field); // number
-                field.insert(0, " "); // need char at beginning because
-                // parse_real ignores first character in the argument
-                offset = parse_real(field);
-            }
-        } else {
-            // we must have a track to insert into
-            if (seq->tracks() == 0) seq->add_track(0);
-            line_parser.get_nonspace_quoted(field);
-            char pk = line_parser.peek();
-            // attributes are parsed as two adjacent nonspace_quoted tokens
-            // so we have to conditionally call get_nonspace_quoted() again
-            if (pk && !isspace(pk)) {
-                string field2;
-                line_parser.get_nonspace_quoted(field2);
-                field.append(field2);
-            }
-            while (field[0]) {
-                char first = toupper(field[0]);
-                if (strchr("ABCDEFGKLPUSIQHW-", first)) {
-                    valid = true; // it's a note or event
-                }
-                if (first == 'V') {
-                    if (voice_flag) {
-                        parse_error(field, 0, "Voice specified twice");
-                    } else {
-                        voice = parse_chan(field);
-                    }
-                    voice_flag = true;
-                } else if (first == 'T') {
-                    if (time_flag) {
-                        parse_error(field, 0, "Time specified twice");
-                    } else {
-                        time = parse_dur(field, 0.0);
-                    }
-                    time_flag = true;
-                } else if (first == 'N') {
-                    if (next_flag) {
-                        parse_error(field, 0, "Next specified twice");
-                    } else {
-                        next = parse_dur(field, time);
-                    }
-                    next_flag = true;
-                } else if (first == 'K') {
-                    if (new_key_flag) {
-                        parse_error(field, 0, "Key specified twice");
-                    } else {
-                        new_key = parse_key(field);
-                        new_key_flag = true;
-                    }
-                } else if (first == 'L') {
-                    if (loud_flag) {
-                        parse_error(field, 0, "Loudness specified twice");
-                    } else {
-                        loud = parse_loud(field);
-                    }
-                    loud_flag = true;
-                } else if (first == 'P') {
-                    if (new_pitch_flag) {
-                        parse_error(field, 0, "Pitch specified twice");
-                    } else {
-                        new_pitch = parse_pitch(field);
-                        new_pitch_flag = true;
-                    }
-                } else if (first == 'U') {
-                    if (dur_flag) {
-                        parse_error(field, 0, "Dur specified twice");
-                    } else {
-                        dur = parse_dur(field, time);
-                        dur_flag = true;
-                    }
-                } else if (strchr("SIQHW", first)) {
-                    if (dur_flag) {
-                        parse_error(field, 0, "Dur specified twice");
-                    } else {
-                        // prepend 'U' to field, copy EOS too
-                        field.insert((unsigned int) 0, 1, 'U');
-                        dur = parse_dur(field, time);
-                        dur_flag = true;
-                    }
-                } else if (strchr("ABCDEFG", first)) {
-                    if (new_pitch_flag) {
-                        parse_error(field, 0, "Pitch specified twice");
-                    } else {
-                        // prepend 'P' to field
-                        field.insert((unsigned int) 0, 1, 'P');
-                        new_pitch = parse_pitch(field);
-                        new_pitch_flag = true;
-                    }
-                } else if (first == '-') {
-                    Alg_parameter parm;
-                    if (parse_attribute(field, &parm)) { // enter attribute-value pair
-                        attributes = new Alg_parameters(attributes);
-                        attributes->parm = parm;
-                        parm.s = NULL; // protect string from deletion by destructor
-                    }
-                } else {
-                    parse_error(field, 0, "Unknown field");
-                }
-
-                if (error_flag) {
-                    field[0] = 0; // exit the loop
-                } else {
-                    line_parser.get_nonspace_quoted(field);
-                    pk = line_parser.peek();
-                    // attributes are parsed as two adjacent nonspace_quoted 
-                    // tokens so we have to conditionally call 
-                    // get_nonspace_quoted() again
-                    if (pk && !isspace(pk)) {
-                        string field2;
-                        line_parser.get_nonspace_quoted(field2);
-                        field.append(field2);
-                    }
-                }
-            }
-            // a case analysis:
-            // Key < 128 implies pitch unless pitch is explicitly given
-            // Pitch implies Key unless key is explicitly given,
-            // Pitch is rounded to nearest integer to determine the Key
-            //    if necessary, so MIDI files will lose the pitch fraction
-            // A-G is a Pitch specification (therefore it implies Key)
-            //   K60 P60 -- both are specified, use 'em
-            //   K60 P60 C4 -- overconstrained, an error
-            //   K60 C4 -- OK, but K60 is already implied by C4
-            //   K60 -- OK, pitch is 60
-            //   C4 P60 -- over constrained
-            //   P60 -- OK, key is 60
-            //   P60.1 -- OK, key is 60
-            //   C4 -- OK, key is 60, pitch is 60
-            //   <nothing> -- OK, key and pitch from before
-            //   K200 P60 -- ok, pitch is 60
-            //   K200 with neither P60 nor C4 uses 
-            //       pitch from before
-
-            // figure out what the key/instance is:
-            if (new_key_flag) { // it was directly specified
-                key = new_key;
-            } else if (new_pitch_flag) {
-                // pitch was specified, but key was not; get key from pitch
-                key = (int) (new_pitch + 0.5); // round to integer key number
-            }
-            if (new_pitch_flag) {
-                pitch = new_pitch;
-            } else if (key < 128 && new_key_flag) {
-                // no explicit pitch, but key < 128, so it implies pitch
-                pitch = key;
-                new_pitch_flag = true;
-            }
-            // now we've acquired new parameters
-            // if (it is a note, then enter the note
-            if (valid) {
-                // change tempo or beat
-                attributes = process_attributes(attributes, time);
-                // if there's a duration or pitch, make a note:
-                if (new_pitch_flag || dur_flag) {
-                    Alg_note_ptr note_ptr = new Alg_note;
-                    note_ptr->chan = voice;
-                    note_ptr->time = time;
-                    note_ptr->dur = dur;
-                    note_ptr->set_identifier(key);
-                    note_ptr->pitch = (float) pitch;
-                    note_ptr->loud = (float) loud;
-                    note_ptr->parameters = attributes;
-                    seq->add_event(note_ptr, track_num); // sort later
-                    if (seq->get_real_dur() < (time + dur)) seq->set_real_dur(time + dur);
-                } else {
-                    int update_key = -1;
-                    // key must appear explicitly; otherwise
-                    //    update applies to channel
-                    if (new_key_flag) {
-                        update_key = key;
-                    }
-                    if (loud_flag) {
-                        Alg_update_ptr new_upd = new Alg_update;
-                        new_upd->chan = voice;
-                        new_upd->time = time;
-                        new_upd->set_identifier(update_key);
-                        new_upd->parameter.set_attr(symbol_table.insert_string("loudr"));
-                        new_upd->parameter.r = pitch;
-                        seq->add_event(new_upd, track_num);
-                        if (seq->get_real_dur() < time) seq->set_real_dur(time);
-                    }
-                    if (attributes) {
-                        while (attributes) {
-                            Alg_update_ptr new_upd = new Alg_update;
-                            new_upd->chan = voice;
-                            new_upd->time = time;
-                            new_upd->set_identifier(update_key);
-                            new_upd->parameter = attributes->parm;
-                            seq->add_event(new_upd, track_num);
-                            Alg_parameters_ptr p = attributes;
-                            attributes = attributes->next;
-                            p->parm.s = NULL; // so we don't delete the string
-                            delete p;
-                        }
-                    }
-                }
-                if (next_flag) {
-                    time = time + next;
-                } else if (dur_flag || new_pitch_flag) { // a note: incr by dur
-                    time = time + dur;
-                }
-            }
-        }
-        readline();
-    }
-    if (!error_flag) { // why not convert even if there was an error? -RBD
-        seq->convert_to_seconds(); // make sure format is correct
-    }
-    // real_dur is valid, translate to beat_dur
-    seq->set_beat_dur((seq->get_time_map())->time_to_beat(seq->get_real_dur()));
-    return error_flag;
-}
-
-
-long Alg_reader::parse_chan(string &field)
-{
-    const char *int_string = field.c_str() + 1;
-    char *msg = "Integer or - expected";
-    const char *p = int_string;
-    char c;
-    // check that all chars in int_string are digits or '-':
-    while (c = *p++) {
-        if (!isdigit(c) && c != '-') {
-            parse_error(field, p - field.c_str() - 1, msg);
-            return 0;
-        }
-    }
-    p--; // p now points to end-of-string character
-    if (p - int_string == 0) {
-        // bad: string length is zero
-        parse_error(field, 1, msg);
-        return 0;
-    }
-    if (p - int_string == 1 && int_string[0] == '-') {
-        // special case: entire string is "-", interpret as -1
-        return -1;
-    }
-    return atoi(int_string);
-}
-
-
-long Alg_reader::parse_int(string &field)
-{
-    const char *int_string = field.c_str() + 1;
-    char *msg = "Integer expected";
-    const char *p = int_string;
-    char c;
-    // check that all chars in int_string are digits:
-    while (c = *p++) {
-        if (!isdigit(c)) {
-            parse_error(field, p - field.c_str() - 1, msg);
-            return 0;
-        }
-    }
-    p--; // p now points to end-of-string character
-    if (p - int_string == 0) {
-        // bad: string length is zero
-        parse_error(field, 1, msg);
-        return 0;
-    }
-    return atoi(int_string);
-}
-
-
-int Alg_reader::find_real_in(string &field, int n)
-{
-    // scans from offset n to the end of a real constant
-    bool decimal = false;
-    int len = field.length();
-    if (n < len && field[n] == '-') n += 1; // parse one minus sign
-    for (int i = n; i < len; i++) {
-        char c = field[i];
-        if (!isdigit(c)) {
-            if (c == '.' && !decimal) {
-                decimal = true;
-            } else {
-                return i;
-            }
-        }
-    }
-    return len;
-}
-
-
-double Alg_reader::parse_real(string &field)
-{
-    char *msg = "Real expected";
-    int last = find_real_in(field, 1);
-    string real_string = field.substr(1, last - 1);
-    if (last <= 1 || last < (int) field.length()) {
-       parse_error(field, 1, msg);
-       return 0;
-    }
-    return atof(real_string.c_str());
-}
-
-
-void Alg_reader::parse_error(string &field, long offset, char *message)
-{
-    int position = line_parser.pos - field.length() + offset;
-    error_flag = true;
-    puts(line_parser.str->c_str());
-    for (int i = 0; i < position; i++) {
-        putc(' ', stdout);
-    }
-    putc('^', stdout);
-    printf("    %s\n", message);
-}
-
-
-double duration_lookup[] = { 0.25, 0.5, 1.0, 2.0, 4.0 };
-
-
-double Alg_reader::parse_dur(string &field, double base)
-{
-    char *msg = "Duration expected";
-    char *durs = "SIQHW";
-    char *p;
-    int last;
-    double dur;
-    if (field.length() < 2) {
-        // fall through to error message
-        return -1;
-    } else if (isdigit(field[1])) {
-        last = find_real_in(field, 1);
-        string real_string = field.substr(1, last - 1);
-        dur = atof(real_string.c_str());
-        // convert dur from seconds to beats
-        dur = seq->get_time_map()->time_to_beat(base + dur) - 
-              seq->get_time_map()->time_to_beat(base);
-    } else if (p = strchr(durs, toupper(field[1]))) {
-        dur = duration_lookup[p - durs];
-        last = 2;
-    } else {
-        parse_error(field, 1, msg);
-        return 0;
-    }
-    dur = parse_after_dur(dur, field, last, base);
-    dur = seq->get_time_map()->beat_to_time(
-              seq->get_time_map()->time_to_beat(base) + dur) - base;
-    return dur;
-}
-
-
-double Alg_reader::parse_after_dur(double dur, string &field, 
-                                   int n, double base)
-{
-    if ((int) field.length() == n) {
-        return dur;
-    }
-    if (toupper(field[n]) == 'T') {
-        return parse_after_dur(dur * 2/3, field, n + 1, base);
-    }
-    if (field[n] == '.') {
-        return parse_after_dur(dur * 1.5, field, n + 1, base);
-    }
-    if (isdigit(field[n])) {
-        int last = find_real_in(field, n);
-        string a_string = field.substr(n, last - n);
-        double f = atof(a_string.c_str());
-        return parse_after_dur(dur * f, field, last, base);
-    }
-    if (field[n] == '+') {
-        string a_string = field.substr(n + 1);
-        return dur + parse_dur(
-                a_string, seq->get_time_map()->beat_to_time(
-                        seq->get_time_map()->time_to_beat(base) + dur));
-    }
-    parse_error(field, n, "Unexpected character in duration");
-    return dur;
-}
-
-struct loud_lookup_struct {
-    char *str;
-    int val;
-} loud_lookup[] = { {"FFF", 127}, {"FF", 120}, {"F", 110}, {"MF", 100}, 
-                    {"MP", 90}, {"P", 80}, {"PP", 70}, {"PPP", 60}, 
-                    {NULL, 0} };
-
-
-double Alg_reader::parse_loud(string &field)
-{
-    char *msg = "Loudness expected";
-    if (isdigit(field[1])) {
-        return parse_int(field);
-    } else {
-        string dyn = field.substr(1);
-        transform(dyn.begin(), dyn.end(), dyn.begin(), ::toupper);
-        for (int i = 0; loud_lookup[i].str; i++) {
-            if (streql(loud_lookup[i].str, dyn.c_str())) {
-                return (double) loud_lookup[i].val;
-            }
-        }
-    }
-    parse_error(field, 1, msg);
-    return 100.0;
-}
-
-
-int key_lookup[] = {21, 23, 12, 14, 16, 17, 19};
-
-
-// the field can be K<number> or K[A-G]<number> or P[A-G]<number>
-// (this can be called from parse_pitch() to handle [A-G])
-// Notice that the routine ignores the first character: K or P
-//
-long Alg_reader::parse_key(string &field)
-{
-    char *msg = "Pitch expected";
-    char *pitches = "ABCDEFG";
-    char *p;
-    if (isdigit(field[1])) {
-        // This routine would not have been called if field = "P<number>"
-        // so it must be "K<number>" so <number> must be an integer.
-        return parse_int(field);
-    } else if (p = strchr(pitches, toupper(field[1]))) {
-        long key = key_lookup[p - pitches];
-        key = parse_after_key(key, field, 2);
-        return key;
-    }
-    parse_error(field, 1, msg);
-    return 0;
-}
-
-
-long Alg_reader::parse_after_key(int key, string &field, int n)
-{
-    if ((int) field.length() == n) {
-        return key;
-    }
-    char c = toupper(field[n]);
-    if (c == 'S') {
-        return parse_after_key(key + 1, field, n + 1);
-    }
-    if (c == 'F') {
-        return parse_after_key(key - 1, field, n + 1);
-    }
-    if (isdigit(field[n])) {
-        int last = find_int_in(field, n);
-        string octave = field.substr(n, last - n);
-        int oct = atoi(octave.c_str());
-        return parse_after_key(key + oct * 12, field, last);
-    }
-    parse_error(field, n, "Unexpected character in pitch");
-    return key;
-}
-
-
-long Alg_reader::find_int_in(string &field, int n)
-{
-    while ((int) field.length() > n && isdigit(field[n])) {
-        n = n + 1;
-    }
-    return n;
-}
-
-
-bool Alg_reader::parse_attribute(string &field, Alg_parameter_ptr param)
-{
-    int i = 1;
-    while (i < (int) field.length()) {
-        if (field[i] == ':') {
-            string attr = field.substr(1, i - 1);
-            char type_char = field[i - 1];
-            if (strchr("iarsl", type_char)) {
-                param->set_attr(symbol_table.insert_string(attr.c_str()));
-                parse_val(param, field, i + 1);
-            } else {
-                parse_error(field, 0, "attribute needs to end with typecode: i,a,r,s, or l");
-            }
-            return !error_flag;
-        }
-        i = i + 1;
-    }
-    return false;
-}
-
-
-bool Alg_reader::parse_val(Alg_parameter_ptr param, string &s, int i)
-{
-    int len = (int) s.length();
-    if (i >= len) {
-        return false;
-    }
-    if (s[i] == '"') {
-        if (!check_type('s', param)) {
-            return false;
-        }
-        // note: (len - i) includes 2 quote characters but no EOS character
-        // so total memory to allocate is (len - i) - 1
-        char *r = new char[(len - i) - 1];
-        strncpy(r, s.c_str() + i + 1, (len - i) - 2);
-        r[(len - i) - 2] = 0; // terminate the string
-        param->s = r;
-    } else if (s[i] == '\'') {
-        if (!check_type('a', param)) {
-            return false;
-        }
-        string r = s.substr(i + 1, len - i - 2);
-        param->a = symbol_table.insert_string(r.c_str());
-    } else if (param->attr_type() == 'l') {
-        if (streql(s.c_str() + i, "true") || 
-            streql(s.c_str() + i, "t")) {
-            param->l = true;
-        } else if (streql(s.c_str() + i, "false") || 
-                   streql(s.c_str() + i, "nil")) {
-            param->l = false;
-        } else return false;
-    } else if (isdigit(s[i]) || s[i] == '-' || s[i] == '.') {
-        int pos = i;
-        bool period = false;
-        int sign = 1;
-        if (s[pos] == '-') {
-            sign = -1;
-            pos++;
-        }
-        while (pos < len) {
-            if (isdigit(s[pos])) {
-                ;
-            } else if (!period && s[pos] == '.') {
-                period = true;
-            } else {
-                parse_error(s, pos, "Unexpected char in number");
-                return false;
-            }
-            pos = pos + 1;
-        }
-        string r = s.substr(i, len - i);
-        if (period) {
-            if (!check_type('r', param)) {
-                return false;
-            }
-            param->r = atof(r.c_str());
-        } else {
-            if (param->attr_type() == 'r') {
-                param->r = atoi(r.c_str());
-            } else if (!check_type('i', param)) {
-                return false;
-            } else {
-                param->i = atoi(r.c_str());
-            }
-        }
-    } else {
-        parse_error(s, i, "invalid value");
-        return false;
-    }
-    return true;
-}
-
-
-bool Alg_reader::check_type(char type_char, Alg_parameter_ptr param)
-{
-    return param->attr_type() == type_char;
-}
-
-
-//duration_lookup = {"S": 0.5, "I": 0.5, "Q": 1, "H": 2, "W": 4}
-//key_lookup = {"C": 12, "D": 14, "E": 16, "F": 17, "G": 19, "A": 21, "B": 23}
-
-/*
-def test():
-    reader = Alg_reader(open("data\\test.gro", "r"))
-    reader.parse()
-    score = reader->seq.notes
-    print "score:", score
-    reader = nil
-*/
+#include "assert.h"
+#include "stdlib.h"
+#include "string.h"
+#include "ctype.h"
+#include "trace.h"
+#include <string>
+#include <fstream>
+#include <algorithm>
+#include "strparse.h"
+#include "allegro.h"
+#include "algrd_internal.h"
+
+using namespace std;
+
+#define streql(s1, s2) (strcmp(s1, s2) == 0)
+#define field_max 80
+
+class Alg_reader {
+public:
+    istream *file;
+    string input_line;
+    int line_no;
+    String_parse line_parser;
+    bool line_parser_flag;
+    string field;
+    bool error_flag;
+    Alg_seq_ptr seq;
+    double tsnum;
+    double tsden;
+    double offset;
+    bool offset_found;
+
+    Alg_reader(istream *a_file, Alg_seq_ptr new_seq);
+    void readline();
+    Alg_parameters_ptr process_attributes(Alg_parameters_ptr attributes,
+                                          double time);
+    bool parse();
+    long parse_chan(string &field);
+    long parse_int(string &field);
+    int find_real_in(string &field, int n);
+    double parse_real(string &field);
+    void parse_error(string &field, long offset, char *message);
+    double parse_dur(string &field, double base);
+    double parse_after_dur(double dur, string &field, int n, double base);
+    double parse_loud(string &field);
+    long parse_key(string &field);
+    double parse_pitch(string &field);
+    long parse_after_key(int key, string &field, int n);
+    long find_int_in(string &field, int n);
+    bool parse_attribute(string &field, Alg_parameter_ptr parm);
+    bool parse_val(Alg_parameter_ptr param, string &s, int i);
+    bool check_type(char type_char, Alg_parameter_ptr param);
+};
+
+
+double Alg_reader::parse_pitch(string &field)
+{
+    if (isdigit(field[1])) {
+        int last = find_real_in(field, 1);
+        string real_string = field.substr(1, last - 1);
+        return atof(real_string.c_str());
+    } else {
+        return (double) parse_key(field);
+    }
+}
+
+
+// it is the responsibility of the caller to delete
+// the seq
+Alg_reader::Alg_reader(istream *a_file, Alg_seq_ptr new_seq)
+{
+    file = a_file; // save the file
+    line_parser_flag = false;
+    line_no = 0;
+    tsnum = 4; // default time signature
+    tsden = 4;
+    seq = new_seq;
+    offset = 0.0;
+    offset_found = false;
+}
+
+
+Alg_error alg_read(istream &file, Alg_seq_ptr new_seq, double *offset_ptr)
+    // read a sequence from allegro file
+{
+    assert(new_seq);
+    Alg_reader alg_reader(&file, new_seq);
+    bool err = alg_reader.parse();
+    if (!err && offset_ptr) {
+        *offset_ptr = alg_reader.offset;
+    }
+    return (err ? alg_error_syntax : alg_no_error);
+}
+
+
+void Alg_reader::readline()
+{
+    // a word about memory management: this Alg_reader has a
+    // member variable input_line that holds a line of input
+    // it is reused for each line. input_line is parsed by
+    // line_parser, which holds a reference to input_line
+    line_parser_flag = false;
+    if (getline(*file, input_line)) {
+        line_parser.init(&input_line);
+        line_parser_flag = true;
+        error_flag = false;
+    }
+}
+
+
+Alg_parameters_ptr Alg_reader::process_attributes(
+        Alg_parameters_ptr attributes, double time)
+{
+    // print "process_attributes:", attributes
+    bool ts_flag = false;
+    if (attributes) {
+        Alg_parameters_ptr a;
+        bool in_seconds = seq->get_units_are_seconds();
+        if (a = Alg_parameters::remove_key(&attributes, "tempor")) {
+            double tempo = a->parm.r;
+            seq->insert_tempo(tempo, seq->get_time_map()->time_to_beat(time));
+        }
+        if (a = Alg_parameters::remove_key(&attributes, "beatr")) {
+            double beat = a->parm.r;
+            seq->insert_beat(time, beat);
+        }
+        if (a = Alg_parameters::remove_key(&attributes, "timesig_numr")) {
+            tsnum = a->parm.r;
+            ts_flag = true;
+        }
+        if (a = Alg_parameters::remove_key(&attributes, "timesig_denr")) {
+            tsden = a->parm.r;
+            ts_flag = true;
+        }
+        if (ts_flag) {
+            seq->set_time_sig(seq->get_time_map()->time_to_beat(time),
+            tsnum, tsden);
+        }
+        if (in_seconds) seq->convert_to_seconds();
+    }
+    return attributes; // in case it was modified
+}
+
+
+bool Alg_reader::parse()
+{
+    int voice = 0;
+    int key = 60;
+    double loud = 100.0;
+    double pitch = 60.0;
+    double dur = 1.0;
+    double time = 0.0;
+    int track_num = 0;
+    seq->convert_to_seconds();
+    //seq->set_real_dur(0.0); // just in case it's not initialized already
+    readline();
+    bool valid = false; // ignore blank lines
+    while (line_parser_flag) {
+        bool time_flag = false;
+        bool next_flag = false;
+        double next;
+        bool voice_flag = false;
+        bool loud_flag = false;
+        bool dur_flag = false;
+        bool new_pitch_flag = false; // "P" syntax or "A"-"G" syntax
+        double new_pitch = 0.0;
+        bool new_key_flag = false;   // "K" syntax
+        int new_key = 0;
+        Alg_parameters_ptr attributes = NULL;
+        if (line_parser.peek() == '#') {
+            // look for #track
+            line_parser.get_nonspace_quoted(field);
+            if (streql(field.c_str(), "#track")) {
+                line_parser.get_nonspace_quoted(field); // number
+                field.insert(0, " "); // need char at beginning because
+                // parse_int ignores the first character of the argument
+                track_num = parse_int(field);
+                seq->add_track(track_num);
+
+                // maybe we have a sequence or track name
+                line_parser.get_remainder(field);
+                // if there is a non-space character after #track n then
+                // use it as sequence or track name. Note that because we
+                // skip over spaces, a sequence or track name cannot begin
+                // with leading blanks. Another decision is that the name
+                // must be at time zero
+                if (field.length() > 0) {
+                    // insert the field as sequence name or track name
+                    Alg_update_ptr update = new Alg_update;
+                    update->chan = -1;
+                    update->time = 0;
+                    update->set_identifier(-1);
+                    // sequence name is whatever is on track 0
+                    // other tracks have track names
+                    const char *attr =
+                            (track_num == 0 ? "seqnames" : "tracknames");
+                    update->parameter.set_attr(
+                            symbol_table.insert_string(attr));
+                    update->parameter.s = heapify(field.c_str());
+                    seq->add_event(update, track_num);
+                }
+            } else if (streql(field.c_str(), "#offset")) {
+                if (offset_found) {
+                    parse_error(field, 0, "#offset specified twice");
+                }
+                offset_found = true;
+                line_parser.get_nonspace_quoted(field); // number
+                field.insert(0, " "); // need char at beginning because
+                // parse_real ignores first character in the argument
+                offset = parse_real(field);
+            }
+        } else {
+            // we must have a track to insert into
+            if (seq->tracks() == 0) seq->add_track(0);
+            line_parser.get_nonspace_quoted(field);
+            char pk = line_parser.peek();
+            // attributes are parsed as two adjacent nonspace_quoted tokens
+            // so we have to conditionally call get_nonspace_quoted() again
+            if (pk && !isspace(pk)) {
+                string field2;
+                line_parser.get_nonspace_quoted(field2);
+                field.append(field2);
+            }
+            while (field[0]) {
+                char first = toupper(field[0]);
+                if (strchr("ABCDEFGKLPUSIQHW-", first)) {
+                    valid = true; // it's a note or event
+                }
+                if (first == 'V') {
+                    if (voice_flag) {
+                        parse_error(field, 0, "Voice specified twice");
+                    } else {
+                        voice = parse_chan(field);
+                    }
+                    voice_flag = true;
+                } else if (first == 'T') {
+                    if (time_flag) {
+                        parse_error(field, 0, "Time specified twice");
+                    } else {
+                        time = parse_dur(field, 0.0);
+                    }
+                    time_flag = true;
+                } else if (first == 'N') {
+                    if (next_flag) {
+                        parse_error(field, 0, "Next specified twice");
+                    } else {
+                        next = parse_dur(field, time);
+                    }
+                    next_flag = true;
+                } else if (first == 'K') {
+                    if (new_key_flag) {
+                        parse_error(field, 0, "Key specified twice");
+                    } else {
+                        new_key = parse_key(field);
+                        new_key_flag = true;
+                    }
+                } else if (first == 'L') {
+                    if (loud_flag) {
+                        parse_error(field, 0, "Loudness specified twice");
+                    } else {
+                        loud = parse_loud(field);
+                    }
+                    loud_flag = true;
+                } else if (first == 'P') {
+                    if (new_pitch_flag) {
+                        parse_error(field, 0, "Pitch specified twice");
+                    } else {
+                        new_pitch = parse_pitch(field);
+                        new_pitch_flag = true;
+                    }
+                } else if (first == 'U') {
+                    if (dur_flag) {
+                        parse_error(field, 0, "Dur specified twice");
+                    } else {
+                        dur = parse_dur(field, time);
+                        dur_flag = true;
+                    }
+                } else if (strchr("SIQHW", first)) {
+                    if (dur_flag) {
+                        parse_error(field, 0, "Dur specified twice");
+                    } else {
+                        // prepend 'U' to field, copy EOS too
+                        field.insert((unsigned int) 0, 1, 'U');
+                        dur = parse_dur(field, time);
+                        dur_flag = true;
+                    }
+                } else if (strchr("ABCDEFG", first)) {
+                    if (new_pitch_flag) {
+                        parse_error(field, 0, "Pitch specified twice");
+                    } else {
+                        // prepend 'P' to field
+                        field.insert((unsigned int) 0, 1, 'P');
+                        new_pitch = parse_pitch(field);
+                        new_pitch_flag = true;
+                    }
+                } else if (first == '-') {
+                    Alg_parameter parm;
+                    if (parse_attribute(field, &parm)) { // enter attribute-value pair
+                        attributes = new Alg_parameters(attributes);
+                        attributes->parm = parm;
+                        parm.s = NULL; // protect string from deletion by destructor
+                    }
+                } else {
+                    parse_error(field, 0, "Unknown field");
+                }
+
+                if (error_flag) {
+                    field[0] = 0; // exit the loop
+                } else {
+                    line_parser.get_nonspace_quoted(field);
+                    pk = line_parser.peek();
+                    // attributes are parsed as two adjacent nonspace_quoted 
+                    // tokens so we have to conditionally call 
+                    // get_nonspace_quoted() again
+                    if (pk && !isspace(pk)) {
+                        string field2;
+                        line_parser.get_nonspace_quoted(field2);
+                        field.append(field2);
+                    }
+                }
+            }
+            // a case analysis:
+            // Key < 128 implies pitch unless pitch is explicitly given
+            // Pitch implies Key unless key is explicitly given,
+            // Pitch is rounded to nearest integer to determine the Key
+            //    if necessary, so MIDI files will lose the pitch fraction
+            // A-G is a Pitch specification (therefore it implies Key)
+            //   K60 P60 -- both are specified, use 'em
+            //   K60 P60 C4 -- overconstrained, an error
+            //   K60 C4 -- OK, but K60 is already implied by C4
+            //   K60 -- OK, pitch is 60
+            //   C4 P60 -- over constrained
+            //   P60 -- OK, key is 60
+            //   P60.1 -- OK, key is 60
+            //   C4 -- OK, key is 60, pitch is 60
+            //   <nothing> -- OK, key and pitch from before
+            //   K200 P60 -- ok, pitch is 60
+            //   K200 with neither P60 nor C4 uses 
+            //       pitch from before
+
+            // figure out what the key/instance is:
+            if (new_key_flag) { // it was directly specified
+                key = new_key;
+            } else if (new_pitch_flag) {
+                // pitch was specified, but key was not; get key from pitch
+                key = (int) (new_pitch + 0.5); // round to integer key number
+            }
+            if (new_pitch_flag) {
+                pitch = new_pitch;
+            } else if (key < 128 && new_key_flag) {
+                // no explicit pitch, but key < 128, so it implies pitch
+                pitch = key;
+                new_pitch_flag = true;
+            }
+            // now we've acquired new parameters
+            // if (it is a note, then enter the note
+            if (valid) {
+                // change tempo or beat
+                attributes = process_attributes(attributes, time);
+                // if there's a duration or pitch, make a note:
+                if (new_pitch_flag || dur_flag) {
+                    Alg_note_ptr note_ptr = new Alg_note;
+                    note_ptr->chan = voice;
+                    note_ptr->time = time;
+                    note_ptr->dur = dur;
+                    note_ptr->set_identifier(key);
+                    note_ptr->pitch = (float) pitch;
+                    note_ptr->loud = (float) loud;
+                    note_ptr->parameters = attributes;
+                    seq->add_event(note_ptr, track_num); // sort later
+                    if (seq->get_real_dur() < (time + dur)) seq->set_real_dur(time + dur);
+                } else {
+                    int update_key = -1;
+                    // key must appear explicitly; otherwise
+                    //    update applies to channel
+                    if (new_key_flag) {
+                        update_key = key;
+                    }
+                    if (loud_flag) {
+                        Alg_update_ptr new_upd = new Alg_update;
+                        new_upd->chan = voice;
+                        new_upd->time = time;
+                        new_upd->set_identifier(update_key);
+                        new_upd->parameter.set_attr(symbol_table.insert_string("loudr"));
+                        new_upd->parameter.r = pitch;
+                        seq->add_event(new_upd, track_num);
+                        if (seq->get_real_dur() < time) seq->set_real_dur(time);
+                    }
+                    if (attributes) {
+                        while (attributes) {
+                            Alg_update_ptr new_upd = new Alg_update;
+                            new_upd->chan = voice;
+                            new_upd->time = time;
+                            new_upd->set_identifier(update_key);
+                            new_upd->parameter = attributes->parm;
+                            seq->add_event(new_upd, track_num);
+                            Alg_parameters_ptr p = attributes;
+                            attributes = attributes->next;
+                            p->parm.s = NULL; // so we don't delete the string
+                            delete p;
+                        }
+                    }
+                }
+                if (next_flag) {
+                    time = time + next;
+                } else if (dur_flag || new_pitch_flag) { // a note: incr by dur
+                    time = time + dur;
+                }
+            }
+        }
+        readline();
+    }
+    if (!error_flag) { // why not convert even if there was an error? -RBD
+        seq->convert_to_seconds(); // make sure format is correct
+    }
+    // real_dur is valid, translate to beat_dur
+    seq->set_beat_dur((seq->get_time_map())->time_to_beat(seq->get_real_dur()));
+    return error_flag;
+}
+
+
+long Alg_reader::parse_chan(string &field)
+{
+    const char *int_string = field.c_str() + 1;
+    char *msg = "Integer or - expected";
+    const char *p = int_string;
+    char c;
+    // check that all chars in int_string are digits or '-':
+    while (c = *p++) {
+        if (!isdigit(c) && c != '-') {
+            parse_error(field, p - field.c_str() - 1, msg);
+            return 0;
+        }
+    }
+    p--; // p now points to end-of-string character
+    if (p - int_string == 0) {
+        // bad: string length is zero
+        parse_error(field, 1, msg);
+        return 0;
+    }
+    if (p - int_string == 1 && int_string[0] == '-') {
+        // special case: entire string is "-", interpret as -1
+        return -1;
+    }
+    return atoi(int_string);
+}
+
+
+long Alg_reader::parse_int(string &field)
+{
+    const char *int_string = field.c_str() + 1;
+    char *msg = "Integer expected";
+    const char *p = int_string;
+    char c;
+    // check that all chars in int_string are digits:
+    while (c = *p++) {
+        if (!isdigit(c)) {
+            parse_error(field, p - field.c_str() - 1, msg);
+            return 0;
+        }
+    }
+    p--; // p now points to end-of-string character
+    if (p - int_string == 0) {
+        // bad: string length is zero
+        parse_error(field, 1, msg);
+        return 0;
+    }
+    return atoi(int_string);
+}
+
+
+int Alg_reader::find_real_in(string &field, int n)
+{
+    // scans from offset n to the end of a real constant
+    bool decimal = false;
+    int len = field.length();
+    if (n < len && field[n] == '-') n += 1; // parse one minus sign
+    for (int i = n; i < len; i++) {
+        char c = field[i];
+        if (!isdigit(c)) {
+            if (c == '.' && !decimal) {
+                decimal = true;
+            } else {
+                return i;
+            }
+        }
+    }
+    return len;
+}
+
+
+double Alg_reader::parse_real(string &field)
+{
+    char *msg = "Real expected";
+    int last = find_real_in(field, 1);
+    string real_string = field.substr(1, last - 1);
+    if (last <= 1 || last < (int) field.length()) {
+       parse_error(field, 1, msg);
+       return 0;
+    }
+    return atof(real_string.c_str());
+}
+
+
+void Alg_reader::parse_error(string &field, long offset, char *message)
+{
+    int position = line_parser.pos - field.length() + offset;
+    error_flag = true;
+    puts(line_parser.str->c_str());
+    for (int i = 0; i < position; i++) {
+        putc(' ', stdout);
+    }
+    putc('^', stdout);
+    printf("    %s\n", message);
+}
+
+
+double duration_lookup[] = { 0.25, 0.5, 1.0, 2.0, 4.0 };
+
+
+double Alg_reader::parse_dur(string &field, double base)
+{
+    char *msg = "Duration expected";
+    char *durs = "SIQHW";
+    char *p;
+    int last;
+    double dur;
+    if (field.length() < 2) {
+        // fall through to error message
+        return -1;
+    } else if (isdigit(field[1])) {
+        last = find_real_in(field, 1);
+        string real_string = field.substr(1, last - 1);
+        dur = atof(real_string.c_str());
+        // convert dur from seconds to beats
+        dur = seq->get_time_map()->time_to_beat(base + dur) - 
+              seq->get_time_map()->time_to_beat(base);
+    } else if (p = strchr(durs, toupper(field[1]))) {
+        dur = duration_lookup[p - durs];
+        last = 2;
+    } else {
+        parse_error(field, 1, msg);
+        return 0;
+    }
+    dur = parse_after_dur(dur, field, last, base);
+    dur = seq->get_time_map()->beat_to_time(
+              seq->get_time_map()->time_to_beat(base) + dur) - base;
+    return dur;
+}
+
+
+double Alg_reader::parse_after_dur(double dur, string &field, 
+                                   int n, double base)
+{
+    if ((int) field.length() == n) {
+        return dur;
+    }
+    if (toupper(field[n]) == 'T') {
+        return parse_after_dur(dur * 2/3, field, n + 1, base);
+    }
+    if (field[n] == '.') {
+        return parse_after_dur(dur * 1.5, field, n + 1, base);
+    }
+    if (isdigit(field[n])) {
+        int last = find_real_in(field, n);
+        string a_string = field.substr(n, last - n);
+        double f = atof(a_string.c_str());
+        return parse_after_dur(dur * f, field, last, base);
+    }
+    if (field[n] == '+') {
+        string a_string = field.substr(n + 1);
+        return dur + parse_dur(
+                a_string, seq->get_time_map()->beat_to_time(
+                        seq->get_time_map()->time_to_beat(base) + dur));
+    }
+    parse_error(field, n, "Unexpected character in duration");
+    return dur;
+}
+
+struct loud_lookup_struct {
+    char *str;
+    int val;
+} loud_lookup[] = { {"FFF", 127}, {"FF", 120}, {"F", 110}, {"MF", 100}, 
+                    {"MP", 90}, {"P", 80}, {"PP", 70}, {"PPP", 60}, 
+                    {NULL, 0} };
+
+
+double Alg_reader::parse_loud(string &field)
+{
+    char *msg = "Loudness expected";
+    if (isdigit(field[1])) {
+        return parse_int(field);
+    } else {
+        string dyn = field.substr(1);
+        transform(dyn.begin(), dyn.end(), dyn.begin(), ::toupper);
+        for (int i = 0; loud_lookup[i].str; i++) {
+            if (streql(loud_lookup[i].str, dyn.c_str())) {
+                return (double) loud_lookup[i].val;
+            }
+        }
+    }
+    parse_error(field, 1, msg);
+    return 100.0;
+}
+
+
+int key_lookup[] = {21, 23, 12, 14, 16, 17, 19};
+
+
+// the field can be K<number> or K[A-G]<number> or P[A-G]<number>
+// (this can be called from parse_pitch() to handle [A-G])
+// Notice that the routine ignores the first character: K or P
+//
+long Alg_reader::parse_key(string &field)
+{
+    char *msg = "Pitch expected";
+    char *pitches = "ABCDEFG";
+    char *p;
+    if (isdigit(field[1])) {
+        // This routine would not have been called if field = "P<number>"
+        // so it must be "K<number>" so <number> must be an integer.
+        return parse_int(field);
+    } else if (p = strchr(pitches, toupper(field[1]))) {
+        long key = key_lookup[p - pitches];
+        key = parse_after_key(key, field, 2);
+        return key;
+    }
+    parse_error(field, 1, msg);
+    return 0;
+}
+
+
+long Alg_reader::parse_after_key(int key, string &field, int n)
+{
+    if ((int) field.length() == n) {
+        return key;
+    }
+    char c = toupper(field[n]);
+    if (c == 'S') {
+        return parse_after_key(key + 1, field, n + 1);
+    }
+    if (c == 'F') {
+        return parse_after_key(key - 1, field, n + 1);
+    }
+    if (isdigit(field[n])) {
+        int last = find_int_in(field, n);
+        string octave = field.substr(n, last - n);
+        int oct = atoi(octave.c_str());
+        return parse_after_key(key + oct * 12, field, last);
+    }
+    parse_error(field, n, "Unexpected character in pitch");
+    return key;
+}
+
+
+long Alg_reader::find_int_in(string &field, int n)
+{
+    while ((int) field.length() > n && isdigit(field[n])) {
+        n = n + 1;
+    }
+    return n;
+}
+
+
+bool Alg_reader::parse_attribute(string &field, Alg_parameter_ptr param)
+{
+    int i = 1;
+    while (i < (int) field.length()) {
+        if (field[i] == ':') {
+            string attr = field.substr(1, i - 1);
+            char type_char = field[i - 1];
+            if (strchr("iarsl", type_char)) {
+                param->set_attr(symbol_table.insert_string(attr.c_str()));
+                parse_val(param, field, i + 1);
+            } else {
+                parse_error(field, 0, "attribute needs to end with typecode: i,a,r,s, or l");
+            }
+            return !error_flag;
+        }
+        i = i + 1;
+    }
+    return false;
+}
+
+
+bool Alg_reader::parse_val(Alg_parameter_ptr param, string &s, int i)
+{
+    int len = (int) s.length();
+    if (i >= len) {
+        return false;
+    }
+    if (s[i] == '"') {
+        if (!check_type('s', param)) {
+            return false;
+        }
+        // note: (len - i) includes 2 quote characters but no EOS character
+        // so total memory to allocate is (len - i) - 1
+        char *r = new char[(len - i) - 1];
+        strncpy(r, s.c_str() + i + 1, (len - i) - 2);
+        r[(len - i) - 2] = 0; // terminate the string
+        param->s = r;
+    } else if (s[i] == '\'') {
+        if (!check_type('a', param)) {
+            return false;
+        }
+        string r = s.substr(i + 1, len - i - 2);
+        param->a = symbol_table.insert_string(r.c_str());
+    } else if (param->attr_type() == 'l') {
+        if (streql(s.c_str() + i, "true") || 
+            streql(s.c_str() + i, "t")) {
+            param->l = true;
+        } else if (streql(s.c_str() + i, "false") || 
+                   streql(s.c_str() + i, "nil")) {
+            param->l = false;
+        } else return false;
+    } else if (isdigit(s[i]) || s[i] == '-' || s[i] == '.') {
+        int pos = i;
+        bool period = false;
+        int sign = 1;
+        if (s[pos] == '-') {
+            sign = -1;
+            pos++;
+        }
+        while (pos < len) {
+            if (isdigit(s[pos])) {
+                ;
+            } else if (!period && s[pos] == '.') {
+                period = true;
+            } else {
+                parse_error(s, pos, "Unexpected char in number");
+                return false;
+            }
+            pos = pos + 1;
+        }
+        string r = s.substr(i, len - i);
+        if (period) {
+            if (!check_type('r', param)) {
+                return false;
+            }
+            param->r = atof(r.c_str());
+        } else {
+            if (param->attr_type() == 'r') {
+                param->r = atoi(r.c_str());
+            } else if (!check_type('i', param)) {
+                return false;
+            } else {
+                param->i = atoi(r.c_str());
+            }
+        }
+    } else {
+        parse_error(s, i, "invalid value");
+        return false;
+    }
+    return true;
+}
+
+
+bool Alg_reader::check_type(char type_char, Alg_parameter_ptr param)
+{
+    return param->attr_type() == type_char;
+}
+
+
+//duration_lookup = {"S": 0.5, "I": 0.5, "Q": 1, "H": 2, "W": 4}
+//key_lookup = {"C": 12, "D": 14, "E": 16, "F": 17, "G": 19, "A": 21, "B": 23}
+
+/*
+def test():
+    reader = Alg_reader(open("data\\test.gro", "r"))
+    reader.parse()
+    score = reader->seq.notes
+    print "score:", score
+    reader = nil
+*/
diff --git a/allegroserial.cpp b/allegroserial.cpp
index e6b52f3..3d43577 100755
--- a/allegroserial.cpp
+++ b/allegroserial.cpp
@@ -1,2 +1,2 @@
-// allegroserial.cpp -- convert track to memory buffer and back to structure
-
+// allegroserial.cpp -- convert track to memory buffer and back to structure
+
diff --git a/allegrosmfrd.cpp b/allegrosmfrd.cpp
index 456fe50..2010ede 100755
--- a/allegrosmfrd.cpp
+++ b/allegrosmfrd.cpp
@@ -1,455 +1,455 @@
-// midifile reader
-
-#include "stdlib.h"
-#include "stdio.h"
-#include "string.h"
-#include "assert.h"
-#include <string>
-#include <fstream>
-#include "allegro.h"
-#include "algsmfrd_internal.h"
-#include "mfmidi.h"
-#include "trace.h"
-
-using namespace std;
-
-typedef class Alg_note_list {
-public:
-    Alg_note_ptr note;
-    class Alg_note_list *next;
-    Alg_note_list(Alg_note_ptr n, class Alg_note_list *list) { 
-        note = n; next = list; }
-} *Alg_note_list_ptr;
-
-
-class Alg_midifile_reader: public Midifile_reader {
-public:
-    istream *file;
-    Alg_seq_ptr seq;
-    int divisions;
-    Alg_note_list_ptr note_list;
-    Alg_track_ptr track;
-    int track_number; // the number of the (current) track
-    // chan is actual_channel + channel_offset_per_track * track_num +
-    //                          channel_offset_per_track * port 
-    long channel_offset_per_track; // used to encode track number into channel
-        // default is 0, set this to 0 to merge all tracks to 16 channels
-    long channel_offset_per_port; // used to encode port number into channel
-        // default is 16, set to 0 to ignore port prefix meta events
-    // while reading, this is channel_offset_per_track * track_num
-    int channel_offset;
-
-    Alg_midifile_reader(istream &f, Alg_seq_ptr new_seq) {
-        file = &f;
-        note_list = NULL;
-        seq = new_seq;
-        channel_offset_per_track = 0;
-        channel_offset_per_port = 16;
-        track_number = -1; // no tracks started yet, 1st will be #0
-        meta_channel = -1;
-        port = 0;
-    }
-    // delete destroys the seq member as well, so set it to NULL if you
-    // copied the pointer elsewhere
-    ~Alg_midifile_reader();
-    // the following is used to load the Alg_seq from the file:
-    bool parse();
-
-    void set_nomerge(bool flag) { Mf_nomerge = flag; }
-    void set_skipinit(bool flag) { Mf_skipinit = flag; }
-    long get_currtime() { return Mf_currtime; }
-
-protected:
-    int meta_channel; // the channel for meta events, set by MIDI chan prefix
-    int port; // value from the portprefix meta event
-
-    double get_time();
-    void update(int chan, int key, Alg_parameter_ptr param);
-    void *Mf_malloc(size_t size) { return malloc(size); }
-    void Mf_free(void *obj, size_t size) { free(obj); }
-    /* Methods to be called while processing the MIDI file. */
-    void Mf_starttrack();
-    void Mf_endtrack();
-    int Mf_getc();
-    void Mf_chanprefix(int chan);
-    void Mf_portprefix(int port);
-    void Mf_eot();
-    void Mf_error(char *);
-    void Mf_header(int,int,int);
-    void Mf_on(int,int,int);
-    void Mf_off(int,int,int);
-    void Mf_pressure(int,int,int);
-    void Mf_controller(int,int,int);
-    void Mf_pitchbend(int,int,int);
-    void Mf_program(int,int);
-    void Mf_chanpressure(int,int);
-    void binary_msg(int len, unsigned char *msg, const char *attr_string);
-    void Mf_sysex(int,unsigned char*);
-    void Mf_arbitrary(int,unsigned char*);
-    void Mf_metamisc(int,int,unsigned char*);
-    void Mf_seqnum(int);
-    void Mf_smpte(int,int,int,int,int);
-    void Mf_timesig(int,int,int,int);
-    void Mf_tempo(int);
-    void Mf_keysig(int,int);
-    void Mf_sqspecific(int,unsigned char*);
-    void Mf_text(int,int,unsigned char*);
-};
-
-
-Alg_midifile_reader::~Alg_midifile_reader()
-{
-    while (note_list) {
-        Alg_note_list_ptr to_be_freed = note_list;
-        note_list = note_list->next;
-        delete to_be_freed;
-    }
-    finalize(); // free Mf reader memory
-}
-
-
-bool Alg_midifile_reader::parse()
-{
-    channel_offset = 0;
-    seq->convert_to_beats();
-    midifile();
-    seq->set_real_dur(seq->get_time_map()->beat_to_time(seq->get_beat_dur()));
-    return midifile_error != 0;
-}
-
-
-void Alg_midifile_reader::Mf_starttrack()
-{
-    // printf("starting new track\n");
-    // create a new track that will share the sequence time map
-    // since time is in beats, the seconds parameter is false
-    track_number++;
-    seq->add_track(track_number); // make sure track exists
-    track = seq->track(track_number); // keep pointer to current track
-    meta_channel = -1;
-    port = 0;
-}
-
-
-void Alg_midifile_reader::Mf_endtrack()
-{
-    // note: track is already part of seq, so do not add it here
-    // printf("finished track, length %d number %d\n", track->len, track_num / 100);
-    channel_offset += seq->channel_offset_per_track;
-    track = NULL;
-    double now = get_time();
-    if (seq->get_beat_dur() < now) seq->set_beat_dur(now);
-    meta_channel = -1;
-    port = 0;
-}
-
-
-int Alg_midifile_reader::Mf_getc()
-{
-    return file->get();
-}
-
-
-void Alg_midifile_reader::Mf_chanprefix(int chan)
-{
-    meta_channel = chan;
-}
-
-
-void Alg_midifile_reader::Mf_portprefix(int p)
-{
-    port = p;
-}
-
-
-void Alg_midifile_reader::Mf_eot()
-{
-    meta_channel = -1;
-    port = 0;
-}
-
-
-void Alg_midifile_reader::Mf_error(char *msg)
-{
-    fprintf(stdout, "Midifile reader error: %s\n", msg);
-}
-
-
-void Alg_midifile_reader::Mf_header(int format, int ntrks, int division)
-{
-    if (format > 1) {
-        char msg[80];
-#pragma warning(disable: 4996) // msg is long enough
-        sprintf(msg, "file format %d not implemented", format);
-#pragma warning(default: 4996)
-        Mf_error(msg);
-    }
-    divisions = division;
-}
-
-
-double Alg_midifile_reader::get_time()
-{
-    double beat = ((double) get_currtime()) / divisions;
-    return beat;
-}
-
-
-void Alg_midifile_reader::Mf_on(int chan, int key, int vel)
-{
-    assert(!seq->get_units_are_seconds());
-    if (vel == 0) {
-        Mf_off(chan, key, vel);
-        return;
-    }
-    Alg_note_ptr note = new Alg_note();
-    note_list = new Alg_note_list(note, note_list);
-    /*    trace("on: %d at %g\n", key, get_time()); */
-    note->time = get_time();
-    note->chan = chan + channel_offset + port * channel_offset_per_port;
-    note->dur = 0;
-    note->set_identifier(key);
-    note->pitch = (float) key;
-    note->loud = (float) vel;
-    track->append(note);
-    meta_channel = -1;
-}
-
-
-void Alg_midifile_reader::Mf_off(int chan, int key, int vel)
-{
-    double time = get_time();
-    Alg_note_list_ptr *p = &note_list;
-    while (*p) {
-        if ((*p)->note->get_identifier() == key &&
-            (*p)->note->chan == 
-                    chan + channel_offset + port * channel_offset_per_port) {
-            (*p)->note->dur = time - (*p)->note->time;
-            // trace("updated %d dur %g\n", (*p)->note->key, (*p)->note->dur);
-            Alg_note_list_ptr to_be_freed = *p;
-            *p = to_be_freed->next;
-            delete to_be_freed;
-        } else {
-            p = &((*p)->next);
-        }
-    }
-    meta_channel = -1;
-}
-
-
-void Alg_midifile_reader::update(int chan, int key, Alg_parameter_ptr param)
-{
-    Alg_update_ptr update = new Alg_update;
-    update->time = get_time();
-    update->chan = chan;
-    if (chan != -1) {
-        update->chan = chan + channel_offset + port * channel_offset_per_port;
-    }
-    update->set_identifier(key);
-    update->parameter = *param;
-    // prevent the destructor from destroying the string twice!
-    // the new Update takes the string from param
-    if (param->attr_type() == 's') param->s = NULL;
-    track->append(update);
-}
-
-
-void Alg_midifile_reader::Mf_pressure(int chan, int key, int val)
-{
-    Alg_parameter parameter;
-    parameter.set_attr(symbol_table.insert_string("pressurer"));
-    parameter.r = val / 127.0;
-    update(chan, key, &parameter);
-    meta_channel = -1;
-}
-
-
-void Alg_midifile_reader::Mf_controller(int chan, int control, int val)
-{
-    Alg_parameter parameter;
-    char name[32];
-#pragma warning(disable: 4996) // name is long enough
-    sprintf(name, "control%dr", control);
-#pragma warning(default: 4996)
-    parameter.set_attr(symbol_table.insert_string(name));
-    parameter.r = val / 127.0;
-    update(chan, -1, &parameter);
-    meta_channel = -1;
-}
-
-
-void Alg_midifile_reader::Mf_pitchbend(int chan, int c1, int c2)
-{
-    Alg_parameter parameter;
-    parameter.set_attr(symbol_table.insert_string("bendr"));
-    parameter.r = ((c2 << 7) + c1) / 8192.0 - 1.0;
-    update(chan, -1, &parameter);
-    meta_channel = -1;
-}
-
-
-void Alg_midifile_reader::Mf_program(int chan, int program)
-{
-    Alg_parameter parameter;
-    parameter.set_attr(symbol_table.insert_string("programi"));
-    parameter.i = program;
-    update(chan, -1, &parameter);
-    meta_channel = -1;
-}
-
-
-void Alg_midifile_reader::Mf_chanpressure(int chan, int val)
-{
-    Alg_parameter parameter;
-    parameter.set_attr(symbol_table.insert_string("pressurer"));
-    parameter.r = val / 127.0;
-    update(chan, -1, &parameter);
-    meta_channel = -1;
-}
-
-
-void Alg_midifile_reader::binary_msg(int len, unsigned char *msg, 
-                                     const char *attr_string)
-{
-    Alg_parameter parameter;
-    char *hexstr = new char[len * 2 + 1];
-    for (int i = 0; i < len; i++) {
-#pragma warning(disable: 4996) // hexstr is long enough
-        sprintf(hexstr + 2 * i, "%02x", (0xFF & msg[i]));
-#pragma warning(default: 4996)
-    }
-    parameter.s = hexstr;
-    parameter.set_attr(symbol_table.insert_string(attr_string));
-    update(meta_channel, -1, &parameter);
-}
-
-
-void Alg_midifile_reader::Mf_sysex(int len, unsigned char *msg)
-{
-    // sysex messages become updates with attribute sysexs and a hex string
-    binary_msg(len, msg, "sysexs");
-}
-
-
-void Alg_midifile_reader::Mf_arbitrary(int len, unsigned char *msg)
-{
-    Mf_error("arbitrary data ignored");
-}
-
-
-void Alg_midifile_reader::Mf_metamisc(int type, int len, unsigned char *msg)
-{
-    char text[128];
-#pragma warning(disable: 4996) // text is long enough
-    sprintf(text, "metamsic data, type 0x%x, ignored", type);
-#pragma warning(default: 4996)
-    Mf_error(text);
-}
-
-
-void Alg_midifile_reader::Mf_seqnum(int n)
-{
-    Mf_error("seqnum data ignored");
-}
-
-
-static char *fpsstr[4] = {"24", "25", "29.97", "30"};
-
-void Alg_midifile_reader::Mf_smpte(int hours, int mins, int secs,
-                                   int frames, int subframes)
-{
-    // string will look like "24fps:01h:27m:07s:19.00f"
-    // 30fps (drop frame) is notated as "29.97fps"
-    char text[32];
-    int fps = (hours >> 6) & 3;
-    hours &= 0x1F;
-#pragma warning(disable: 4996) // text is long enough
-    sprintf(text, "%sfps:%02dh:%02dm:%02ds:%02d.%02df", 
-            fpsstr[fps], hours, mins, secs, frames, subframes);
-#pragma warning(default: 4996)
-    Alg_parameter smpteoffset;
-    smpteoffset.s = heapify(text);
-    smpteoffset.set_attr(symbol_table.insert_string("smpteoffsets"));
-    update(meta_channel, -1, &smpteoffset);
-    // Mf_error("SMPTE data ignored");
-}
-
-
-void Alg_midifile_reader::Mf_timesig(int i1, int i2, int i3, int i4)
-{
-    seq->set_time_sig(double(get_currtime()) / divisions, i1, 1 << i2);
-}
-
-
-void Alg_midifile_reader::Mf_tempo(int tempo)
-{
-    double beat = get_currtime();
-    beat = beat / divisions; // convert to quarters
-    // 6000000 us/min / n us/beat => beat / min
-    double bpm = 60000000.0 / tempo;
-    seq->insert_tempo(bpm, beat);
-}
-
-
-void Alg_midifile_reader::Mf_keysig(int key, int mode)
-{
-    Alg_parameter key_parm;
-    key_parm.set_attr(symbol_table.insert_string("keysigi"));
-    // use 0 for C major, 1 for G, -1 for F, etc., that is,
-    // the number of sharps, where flats are negative sharps
-    key_parm.i = key; //<<<---- fix this
-    // use -1 to mean "all channels"
-    update(meta_channel, -1, &key_parm);
-    Alg_parameter mode_parm;
-    mode_parm.set_attr(symbol_table.insert_string("modea"));
-    mode_parm.a = (mode == 0 ? symbol_table.insert_string("major") :
-                               symbol_table.insert_string("minor"));
-    update(meta_channel, -1, &mode_parm);
-}
-
-
-void Alg_midifile_reader::Mf_sqspecific(int len, unsigned char *msg)
-{
-    // sequencer specific messages become updates with attribute sqspecifics
-    // and a hex string for the value
-    binary_msg(len, msg, "sqspecifics");
-}
-
-
-char *heapify2(int len, unsigned char *s)
-{
-    char *h = new char[len + 1];
-    memcpy(h, s, len);
-    h[len] = 0;
-    return h;
-}
-
-
-void Alg_midifile_reader::Mf_text(int type, int len, unsigned char *msg)
-{
-    Alg_parameter text;
-    text.s = heapify2(len, msg);
-    const char *attr = "miscs";
-    if (type == 1) attr = "texts";
-    else if (type == 2) attr = "copyrights";
-    else if (type == 3) 
-        attr = (track_number == 0 ? "seqnames" : "tracknames");
-    else if (type == 4) attr = "instruments";
-    else if (type == 5) attr = "lyrics";
-    else if (type == 6) attr = "markers";
-    else if (type == 7) attr = "cues";
-    text.set_attr(symbol_table.insert_string(attr));
-    update(meta_channel, -1, &text);
-}
-
-
-// parse file into a seq. 
-Alg_error alg_smf_read(istream &file, Alg_seq_ptr new_seq)
-{
-    assert(new_seq);
-    Alg_midifile_reader ar(file, new_seq);
-    bool err = ar.parse();
-    ar.seq->set_real_dur(ar.seq->get_time_map()->
-                         beat_to_time(ar.seq->get_beat_dur()));
-    return (err ? alg_error_syntax : alg_no_error);
-}
+// midifile reader
+
+#include "stdlib.h"
+#include "stdio.h"
+#include "string.h"
+#include "assert.h"
+#include <string>
+#include <fstream>
+#include "allegro.h"
+#include "algsmfrd_internal.h"
+#include "mfmidi.h"
+#include "trace.h"
+
+using namespace std;
+
+typedef class Alg_note_list {
+public:
+    Alg_note_ptr note;
+    class Alg_note_list *next;
+    Alg_note_list(Alg_note_ptr n, class Alg_note_list *list) { 
+        note = n; next = list; }
+} *Alg_note_list_ptr;
+
+
+class Alg_midifile_reader: public Midifile_reader {
+public:
+    istream *file;
+    Alg_seq_ptr seq;
+    int divisions;
+    Alg_note_list_ptr note_list;
+    Alg_track_ptr track;
+    int track_number; // the number of the (current) track
+    // chan is actual_channel + channel_offset_per_track * track_num +
+    //                          channel_offset_per_track * port 
+    long channel_offset_per_track; // used to encode track number into channel
+        // default is 0, set this to 0 to merge all tracks to 16 channels
+    long channel_offset_per_port; // used to encode port number into channel
+        // default is 16, set to 0 to ignore port prefix meta events
+    // while reading, this is channel_offset_per_track * track_num
+    int channel_offset;
+
+    Alg_midifile_reader(istream &f, Alg_seq_ptr new_seq) {
+        file = &f;
+        note_list = NULL;
+        seq = new_seq;
+        channel_offset_per_track = 0;
+        channel_offset_per_port = 16;
+        track_number = -1; // no tracks started yet, 1st will be #0
+        meta_channel = -1;
+        port = 0;
+    }
+    // delete destroys the seq member as well, so set it to NULL if you
+    // copied the pointer elsewhere
+    ~Alg_midifile_reader();
+    // the following is used to load the Alg_seq from the file:
+    bool parse();
+
+    void set_nomerge(bool flag) { Mf_nomerge = flag; }
+    void set_skipinit(bool flag) { Mf_skipinit = flag; }
+    long get_currtime() { return Mf_currtime; }
+
+protected:
+    int meta_channel; // the channel for meta events, set by MIDI chan prefix
+    int port; // value from the portprefix meta event
+
+    double get_time();
+    void update(int chan, int key, Alg_parameter_ptr param);
+    void *Mf_malloc(size_t size) { return malloc(size); }
+    void Mf_free(void *obj, size_t size) { free(obj); }
+    /* Methods to be called while processing the MIDI file. */
+    void Mf_starttrack();
+    void Mf_endtrack();
+    int Mf_getc();
+    void Mf_chanprefix(int chan);
+    void Mf_portprefix(int port);
+    void Mf_eot();
+    void Mf_error(char *);
+    void Mf_header(int,int,int);
+    void Mf_on(int,int,int);
+    void Mf_off(int,int,int);
+    void Mf_pressure(int,int,int);
+    void Mf_controller(int,int,int);
+    void Mf_pitchbend(int,int,int);
+    void Mf_program(int,int);
+    void Mf_chanpressure(int,int);
+    void binary_msg(int len, unsigned char *msg, const char *attr_string);
+    void Mf_sysex(int,unsigned char*);
+    void Mf_arbitrary(int,unsigned char*);
+    void Mf_metamisc(int,int,unsigned char*);
+    void Mf_seqnum(int);
+    void Mf_smpte(int,int,int,int,int);
+    void Mf_timesig(int,int,int,int);
+    void Mf_tempo(int);
+    void Mf_keysig(int,int);
+    void Mf_sqspecific(int,unsigned char*);
+    void Mf_text(int,int,unsigned char*);
+};
+
+
+Alg_midifile_reader::~Alg_midifile_reader()
+{
+    while (note_list) {
+        Alg_note_list_ptr to_be_freed = note_list;
+        note_list = note_list->next;
+        delete to_be_freed;
+    }
+    finalize(); // free Mf reader memory
+}
+
+
+bool Alg_midifile_reader::parse()
+{
+    channel_offset = 0;
+    seq->convert_to_beats();
+    midifile();
+    seq->set_real_dur(seq->get_time_map()->beat_to_time(seq->get_beat_dur()));
+    return midifile_error != 0;
+}
+
+
+void Alg_midifile_reader::Mf_starttrack()
+{
+    // printf("starting new track\n");
+    // create a new track that will share the sequence time map
+    // since time is in beats, the seconds parameter is false
+    track_number++;
+    seq->add_track(track_number); // make sure track exists
+    track = seq->track(track_number); // keep pointer to current track
+    meta_channel = -1;
+    port = 0;
+}
+
+
+void Alg_midifile_reader::Mf_endtrack()
+{
+    // note: track is already part of seq, so do not add it here
+    // printf("finished track, length %d number %d\n", track->len, track_num / 100);
+    channel_offset += seq->channel_offset_per_track;
+    track = NULL;
+    double now = get_time();
+    if (seq->get_beat_dur() < now) seq->set_beat_dur(now);
+    meta_channel = -1;
+    port = 0;
+}
+
+
+int Alg_midifile_reader::Mf_getc()
+{
+    return file->get();
+}
+
+
+void Alg_midifile_reader::Mf_chanprefix(int chan)
+{
+    meta_channel = chan;
+}
+
+
+void Alg_midifile_reader::Mf_portprefix(int p)
+{
+    port = p;
+}
+
+
+void Alg_midifile_reader::Mf_eot()
+{
+    meta_channel = -1;
+    port = 0;
+}
+
+
+void Alg_midifile_reader::Mf_error(char *msg)
+{
+    fprintf(stdout, "Midifile reader error: %s\n", msg);
+}
+
+
+void Alg_midifile_reader::Mf_header(int format, int ntrks, int division)
+{
+    if (format > 1) {
+        char msg[80];
+#pragma warning(disable: 4996) // msg is long enough
+        sprintf(msg, "file format %d not implemented", format);
+#pragma warning(default: 4996)
+        Mf_error(msg);
+    }
+    divisions = division;
+}
+
+
+double Alg_midifile_reader::get_time()
+{
+    double beat = ((double) get_currtime()) / divisions;
+    return beat;
+}
+
+
+void Alg_midifile_reader::Mf_on(int chan, int key, int vel)
+{
+    assert(!seq->get_units_are_seconds());
+    if (vel == 0) {
+        Mf_off(chan, key, vel);
+        return;
+    }
+    Alg_note_ptr note = new Alg_note();
+    note_list = new Alg_note_list(note, note_list);
+    /*    trace("on: %d at %g\n", key, get_time()); */
+    note->time = get_time();
+    note->chan = chan + channel_offset + port * channel_offset_per_port;
+    note->dur = 0;
+    note->set_identifier(key);
+    note->pitch = (float) key;
+    note->loud = (float) vel;
+    track->append(note);
+    meta_channel = -1;
+}
+
+
+void Alg_midifile_reader::Mf_off(int chan, int key, int vel)
+{
+    double time = get_time();
+    Alg_note_list_ptr *p = &note_list;
+    while (*p) {
+        if ((*p)->note->get_identifier() == key &&
+            (*p)->note->chan == 
+                    chan + channel_offset + port * channel_offset_per_port) {
+            (*p)->note->dur = time - (*p)->note->time;
+            // trace("updated %d dur %g\n", (*p)->note->key, (*p)->note->dur);
+            Alg_note_list_ptr to_be_freed = *p;
+            *p = to_be_freed->next;
+            delete to_be_freed;
+        } else {
+            p = &((*p)->next);
+        }
+    }
+    meta_channel = -1;
+}
+
+
+void Alg_midifile_reader::update(int chan, int key, Alg_parameter_ptr param)
+{
+    Alg_update_ptr update = new Alg_update;
+    update->time = get_time();
+    update->chan = chan;
+    if (chan != -1) {
+        update->chan = chan + channel_offset + port * channel_offset_per_port;
+    }
+    update->set_identifier(key);
+    update->parameter = *param;
+    // prevent the destructor from destroying the string twice!
+    // the new Update takes the string from param
+    if (param->attr_type() == 's') param->s = NULL;
+    track->append(update);
+}
+
+
+void Alg_midifile_reader::Mf_pressure(int chan, int key, int val)
+{
+    Alg_parameter parameter;
+    parameter.set_attr(symbol_table.insert_string("pressurer"));
+    parameter.r = val / 127.0;
+    update(chan, key, &parameter);
+    meta_channel = -1;
+}
+
+
+void Alg_midifile_reader::Mf_controller(int chan, int control, int val)
+{
+    Alg_parameter parameter;
+    char name[32];
+#pragma warning(disable: 4996) // name is long enough
+    sprintf(name, "control%dr", control);
+#pragma warning(default: 4996)
+    parameter.set_attr(symbol_table.insert_string(name));
+    parameter.r = val / 127.0;
+    update(chan, -1, &parameter);
+    meta_channel = -1;
+}
+
+
+void Alg_midifile_reader::Mf_pitchbend(int chan, int c1, int c2)
+{
+    Alg_parameter parameter;
+    parameter.set_attr(symbol_table.insert_string("bendr"));
+    parameter.r = ((c2 << 7) + c1) / 8192.0 - 1.0;
+    update(chan, -1, &parameter);
+    meta_channel = -1;
+}
+
+
+void Alg_midifile_reader::Mf_program(int chan, int program)
+{
+    Alg_parameter parameter;
+    parameter.set_attr(symbol_table.insert_string("programi"));
+    parameter.i = program;
+    update(chan, -1, &parameter);
+    meta_channel = -1;
+}
+
+
+void Alg_midifile_reader::Mf_chanpressure(int chan, int val)
+{
+    Alg_parameter parameter;
+    parameter.set_attr(symbol_table.insert_string("pressurer"));
+    parameter.r = val / 127.0;
+    update(chan, -1, &parameter);
+    meta_channel = -1;
+}
+
+
+void Alg_midifile_reader::binary_msg(int len, unsigned char *msg, 
+                                     const char *attr_string)
+{
+    Alg_parameter parameter;
+    char *hexstr = new char[len * 2 + 1];
+    for (int i = 0; i < len; i++) {
+#pragma warning(disable: 4996) // hexstr is long enough
+        sprintf(hexstr + 2 * i, "%02x", (0xFF & msg[i]));
+#pragma warning(default: 4996)
+    }
+    parameter.s = hexstr;
+    parameter.set_attr(symbol_table.insert_string(attr_string));
+    update(meta_channel, -1, &parameter);
+}
+
+
+void Alg_midifile_reader::Mf_sysex(int len, unsigned char *msg)
+{
+    // sysex messages become updates with attribute sysexs and a hex string
+    binary_msg(len, msg, "sysexs");
+}
+
+
+void Alg_midifile_reader::Mf_arbitrary(int len, unsigned char *msg)
+{
+    Mf_error("arbitrary data ignored");
+}
+
+
+void Alg_midifile_reader::Mf_metamisc(int type, int len, unsigned char *msg)
+{
+    char text[128];
+#pragma warning(disable: 4996) // text is long enough
+    sprintf(text, "metamsic data, type 0x%x, ignored", type);
+#pragma warning(default: 4996)
+    Mf_error(text);
+}
+
+
+void Alg_midifile_reader::Mf_seqnum(int n)
+{
+    Mf_error("seqnum data ignored");
+}
+
+
+static char *fpsstr[4] = {"24", "25", "29.97", "30"};
+
+void Alg_midifile_reader::Mf_smpte(int hours, int mins, int secs,
+                                   int frames, int subframes)
+{
+    // string will look like "24fps:01h:27m:07s:19.00f"
+    // 30fps (drop frame) is notated as "29.97fps"
+    char text[32];
+    int fps = (hours >> 6) & 3;
+    hours &= 0x1F;
+#pragma warning(disable: 4996) // text is long enough
+    sprintf(text, "%sfps:%02dh:%02dm:%02ds:%02d.%02df", 
+            fpsstr[fps], hours, mins, secs, frames, subframes);
+#pragma warning(default: 4996)
+    Alg_parameter smpteoffset;
+    smpteoffset.s = heapify(text);
+    smpteoffset.set_attr(symbol_table.insert_string("smpteoffsets"));
+    update(meta_channel, -1, &smpteoffset);
+    // Mf_error("SMPTE data ignored");
+}
+
+
+void Alg_midifile_reader::Mf_timesig(int i1, int i2, int i3, int i4)
+{
+    seq->set_time_sig(double(get_currtime()) / divisions, i1, 1 << i2);
+}
+
+
+void Alg_midifile_reader::Mf_tempo(int tempo)
+{
+    double beat = get_currtime();
+    beat = beat / divisions; // convert to quarters
+    // 6000000 us/min / n us/beat => beat / min
+    double bpm = 60000000.0 / tempo;
+    seq->insert_tempo(bpm, beat);
+}
+
+
+void Alg_midifile_reader::Mf_keysig(int key, int mode)
+{
+    Alg_parameter key_parm;
+    key_parm.set_attr(symbol_table.insert_string("keysigi"));
+    // use 0 for C major, 1 for G, -1 for F, etc., that is,
+    // the number of sharps, where flats are negative sharps
+    key_parm.i = key; //<<<---- fix this
+    // use -1 to mean "all channels"
+    update(meta_channel, -1, &key_parm);
+    Alg_parameter mode_parm;
+    mode_parm.set_attr(symbol_table.insert_string("modea"));
+    mode_parm.a = (mode == 0 ? symbol_table.insert_string("major") :
+                               symbol_table.insert_string("minor"));
+    update(meta_channel, -1, &mode_parm);
+}
+
+
+void Alg_midifile_reader::Mf_sqspecific(int len, unsigned char *msg)
+{
+    // sequencer specific messages become updates with attribute sqspecifics
+    // and a hex string for the value
+    binary_msg(len, msg, "sqspecifics");
+}
+
+
+char *heapify2(int len, unsigned char *s)
+{
+    char *h = new char[len + 1];
+    memcpy(h, s, len);
+    h[len] = 0;
+    return h;
+}
+
+
+void Alg_midifile_reader::Mf_text(int type, int len, unsigned char *msg)
+{
+    Alg_parameter text;
+    text.s = heapify2(len, msg);
+    const char *attr = "miscs";
+    if (type == 1) attr = "texts";
+    else if (type == 2) attr = "copyrights";
+    else if (type == 3) 
+        attr = (track_number == 0 ? "seqnames" : "tracknames");
+    else if (type == 4) attr = "instruments";
+    else if (type == 5) attr = "lyrics";
+    else if (type == 6) attr = "markers";
+    else if (type == 7) attr = "cues";
+    text.set_attr(symbol_table.insert_string(attr));
+    update(meta_channel, -1, &text);
+}
+
+
+// parse file into a seq. 
+Alg_error alg_smf_read(istream &file, Alg_seq_ptr new_seq)
+{
+    assert(new_seq);
+    Alg_midifile_reader ar(file, new_seq);
+    bool err = ar.parse();
+    ar.seq->set_real_dur(ar.seq->get_time_map()->
+                         beat_to_time(ar.seq->get_beat_dur()));
+    return (err ? alg_error_syntax : alg_no_error);
+}
diff --git a/allegrosmfwr.cpp b/allegrosmfwr.cpp
index f581831..cd06251 100755
--- a/allegrosmfwr.cpp
+++ b/allegrosmfwr.cpp
@@ -1,647 +1,647 @@
-// allegrosmfwr.cpp -- Allegro Standard Midi File Write
-
-#include <stdlib.h>
-#include <string.h>
-#include <math.h>
-#include <errno.h>
-#include <string>
-#include <iostream>
-#include <fstream>
-using namespace std;
-#include "allegro.h"
-
-// event_queue is a list element that keeps track of pending
-// things to write to a track, including note-ons, note-offs,
-// updates, tempo changes, and time signatures
-//
-class event_queue{
-public:
-  char type;//'n' for note, 'o' for off, 's' for time signature,
-            // 'c' for tempo changes
-  double time;
-  long index; //of the event in mSeq->notes
-  class event_queue *next;
-  event_queue(char t, double when, long x, class event_queue *n) {
-        type = t; time = when; index = x; next = n; }
-};
-
-
-class Alg_smf_write {
-public:
-    Alg_smf_write(Alg_seq_ptr seq);
-    ~Alg_smf_write();
-    long channels_per_track; // used to encode track number into chan field
-    // chan is actual_channel + channels_per_track * track_number
-    // default is 100, set this to 0 to merge all tracks to 16 channels
-
-    void write(ostream &file /* , midiFileFormat = 1 */);
-
-private:
-    long previous_divs; // time in ticks of most recently written event
-
-    void write_track(int i);
-    void write_tempo(int divs, int tempo);
-    void write_tempo_change(int i);
-    void write_time_signature(int i);
-    void write_note(Alg_note_ptr note, bool on);
-    void write_update(Alg_update_ptr update);
-    void write_text(Alg_update_ptr update, char type);
-    void write_binary(int type_byte, const char *msg);
-    void write_midi_channel_prefix(Alg_update_ptr update);
-    void write_smpteoffset(Alg_update_ptr update, char *s);
-    void write_data(int data);
-    int to_midi_channel(int channel);
-    int to_track(int channel);
-
-    ostream *out_file;
-
-    Alg_seq_ptr seq;
-
-    int num_tracks; // number of tracks not counting tempo track
-    int division; // divisions per quarter note, default = 120
-    int initial_tempo;
-
-    int timesig_num; // numerator of time signature
-    int timesig_den; // denominator of time signature
-    double timesig_when; // time of time signature
-
-    int keysig;          // number of sharps (+) or flats (-), -99 for undefined
-    char keysig_mode; // 'M' or 'm' for major/minor
-    double keysig_when;    // time of key signature
-
-    void write_delta(double event_time);
-    void write_varinum(int num);
-    void write_16bit(int num);
-    void write_24bit(int num);
-    void write_32bit(int num);
-};
-
-#define ROUND(x) (int) ((x)+0.5)
-
-Alg_smf_write::Alg_smf_write(Alg_seq_ptr a_seq)
-{
-    out_file = NULL;
-
-    // at 100bpm (a nominal tempo value), we would like a division
-    // to represent 1ms of time. So
-    // d ticks/beat * 100 beats/min = 60,000 ms/min * 1 tick/ms
-    // solving for d, d = 600
-    division = 600;         // divisions per quarter note
-    timesig_num = timesig_den = 0; // initially undefined
-    keysig = -99;
-    keysig_mode = 0;
-    initial_tempo = 500000;
-
-    seq = a_seq;
-
-    previous_divs = 0; // used to compute deltas for midifile
-}
-
-
-Alg_smf_write::~Alg_smf_write()
-{
-}
-
-
-// sorting is quite subtle due to rounding
-// For example, suppose times from a MIDI file are exact, but in
-// decimal round to TW0.4167 Q0.3333. Since the time in whole notes
-// rounded up, this note will start late. Even though the duration
-// rounded down, the amount is 1/4 as much because units are quarter
-// notes. Therefore, the total roundup is 0.0001 beats. This is 
-// enough to cause the note to sort later in the queue, perhaps
-// coming after a new note-on on the same pitch, and resulting in 
-// a turning on-off, on-off into on, on, off, off if data is moved
-// to Allegro (ascii) format with rounding and then back to SMF.
-//
-// The solution here is to consider things that round to the same
-// tick to be simultaneous. Then, be sure to deal with note-offs
-// before note-ons. We're going to do that by using event_queue
-// times that are rounded to the nearest tick time. Except note-offs
-// are going to go in with times that are 1/4 tick earlier so they
-// get scheduled first, but still end up on the same tick.
-//
-event_queue* push(event_queue *queue, event_queue *event)
-{
-    // printf("push: %.6g, %c, %d\n", event->time, event->type, event->index);
-    if (queue == NULL) {
-        event->next = NULL;
-        return event;
-    }
-   
-    event_queue *marker1 = NULL;
-    event_queue *marker2 = queue;
-    while (marker2 != NULL && marker2->time <= event->time) {
-        marker1 = marker2;
-        marker2 = marker2->next;
-    }
-    event->next = marker2;
-    if (marker1 != NULL) {
-        marker1->next=event;
-        return queue;
-    } else return event;
-}
-
-
-void print_queue(event_queue *q)
-{
-    printf("Printing queue. . .\n");
-    event_queue *q2=q;
-    while (q2) {
-        printf("%c at %f ;", q2->type, q2->time);
-        q2 = q2->next;
-    }
-    printf("\nDone printing.\n");
-}
-
-
-void Alg_smf_write::write_note(Alg_note_ptr note, bool on)
-{
-    double event_time = (on ? note->time : note->time + note->dur);
-    write_delta(event_time);
-
-    //printf("deltaDivisions: %d, beats elapsed: %g, on? %c\n", deltaDivisions, note->time, on);
-
-    char chan = char(note->chan & 15);
-    int pitch = int(note->pitch + 0.5);
-    if (pitch < 0) {
-          pitch = pitch % 12;
-    } else if (pitch > 127) {
-        pitch = (pitch % 12) + 120; // put pitch in 10th octave
-        if (pitch > 127) pitch -= 12; // or 9th octave
-    }
-    out_file->put(0x90 + chan);
-    out_file->put(pitch);
-    if (on) {
-        int vel = (int) note->loud;
-        if (vel <= 0) vel = 1;
-        write_data(vel);
-    } else out_file->put(0); // note-off indicated by velocty zero
-}
-
-
-void Alg_smf_write::write_midi_channel_prefix(Alg_update_ptr update)
-{
-   if (update->chan >= 0) { // write MIDI Channel Prefix
-        write_delta(update->time);
-        out_file->put('\xFF'); // Meta Event
-        out_file->put('\x20'); // Type code for MIDI Channel Prefix
-        out_file->put(1); // length
-        out_file->put(to_midi_channel(update->chan));
-        // one thing odd about the Std MIDI File spec is that once
-        // you turn on MIDI Channel Prefix, there seems to be no
-        // way to cancel it unless a non-Meta event shows up. We
-        // don't do any analysis to avoid assigning channels to
-        // meta events.
-    }
-}
-
-
-void Alg_smf_write::write_text(Alg_update_ptr update, char type)
-{
-    write_midi_channel_prefix(update);
-    write_delta(update->time);
-    out_file->put('\xFF');
-    out_file->put(type);
-    out_file->put((char) strlen(update->parameter.s));
-    *out_file << update->parameter.s;
-}
-
-
-void Alg_smf_write::write_smpteoffset(Alg_update_ptr update, char *s)
-{
-    write_midi_channel_prefix(update);
-    write_delta(update->time);
-    out_file->put('\xFF'); // meta event
-    out_file->put('\x54'); // smpte offset type code
-    out_file->put(5); // length
-    for (int i = 0; i < 5; i++) *out_file << s[i];
-}
-
-
-// write_data - limit data to the range of [0...127] and write it
-void Alg_smf_write::write_data(int data)
-{
-    if (data < 0) data = 0;
-    else if (data > 0x7F) data = 0x7F;
-
-    out_file->put(data);
-}
-
-
-int Alg_smf_write::to_midi_channel(int channel)
-{
-    // allegro track number is stored as multiple of 100
-    // also mask off all but 4 channel bits just in case
-    if (channels_per_track > 0) channel %= channels_per_track;
-    return channel & 0xF;
-}
-
-
-int Alg_smf_write::to_track(int channel)
-{
-    if (channel == -1) return 0;
-    return channel / channels_per_track;
-}
-
-
-static char hex_to_nibble(char c)
-{
-    if (isalpha(c)) {
-        return 10 + (toupper(c) - 'A');
-    } else {
-        return c - '0';
-    }
-}
-
-
-static char hex_to_char(const char *s)
-{
-    return (hex_to_nibble(s[0]) << 4) + hex_to_nibble(s[1]);
-}
-
-
-void Alg_smf_write::write_binary(int type_byte, const char *msg)
-{
-    int len = strlen(msg) / 2;
-    out_file->put(type_byte);
-    write_varinum(len);
-    for (int i = 0; i < len; i++) {
-        out_file->put(hex_to_char(msg));
-        msg += 2;
-    }
-}
-
-
-void Alg_smf_write::write_update(Alg_update_ptr update)
-{
-    const char *name = update->parameter.attr_name();
-
-    /****Non-Meta Events****/
-    if (!strcmp(name, "pressurer")) {
-        write_delta(update->time);
-        if (update->get_identifier() < 0) { // channel pressure message
-            out_file->put(0xD0 + to_midi_channel(update->chan));
-            write_data((int)(update->parameter.r * 127));
-        } else { // just 1 key -- poly pressure
-            out_file->put(0xA0 + to_midi_channel(update->chan));
-            write_data(update->get_identifier());
-            write_data((int)(update->parameter.r * 127));
-        }
-    } else if (!strcmp(name, "programi")) {
-        write_delta(update->time);
-        out_file->put(0xC0 + to_midi_channel(update->chan));
-        write_data(update->parameter.i);
-    } else if (!strcmp(name, "bendr")) {
-        int temp = ROUND(0x2000 * (update->parameter.r + 1));
-        if (temp > 0x3fff) temp = 0x3fff; // 14 bits maximum
-        if (temp < 0) temp = 0;
-        int c1 = temp & 0x7F; // low 7 bits
-        int c2 = temp >> 7;   // high 7 bits
-        write_delta(update->time);
-        out_file->put(0xE0 + to_midi_channel(update->chan));
-        write_data(c1);
-        write_data(c2);
-    } else if (!strncmp(name, "control", 7) && 
-               update->parameter.attr_type() == 'r') {
-      int ctrlnum = atoi(name + 7);
-      int val = ROUND(update->parameter.r * 127);
-      write_delta(update->time);
-      out_file->put(0xB0 + to_midi_channel(update->chan));
-      write_data(ctrlnum);
-      write_data(val);
-    } else if (!strcmp(name, "sysexs") &&
-               update->parameter.attr_type() == 's') {
-        const char *s = update->parameter.s;
-        if (s[0] && s[1] && toupper(s[0]) == 'F' && s[1] == '0') {
-            s += 2; // skip the initial "F0" byte in message: it is implied
-        }
-        write_delta(update->time);
-        write_binary(0xF0, s);
-    } else if (!strcmp(name, "sqspecifics") &&
-               update->parameter.attr_type() == 's') {
-        const char *s = update->parameter.s;
-        write_delta(update->time);
-        out_file->put('\xFF');
-        write_binary(0x7F, s);
-
-    /****Text Events****/
-    } else if (!strcmp(name, "texts")) {
-        write_text(update, 0x01);
-    } else if (!strcmp(name, "copyrights")) {
-        write_text(update, 0x02);
-    } else if (!strcmp(name, "seqnames") || !strcmp(name, "tracknames")) {
-        write_text(update, 0x03);
-    } else if (!strcmp(name, "instruments")) {
-        write_text(update, 0x04);
-    } else if (!strcmp(name, "lyrics")) {
-        write_text(update, 0x05);
-    } else if (!strcmp(name, "markers")) {
-        write_text(update, 0x06);
-    } else if (!strcmp(name, "cues")) {
-        write_text(update, 0x07);
-    } else if (!strcmp(name, "miscs")) {
-        write_text(update, 0x08);
-
-    /****Other Events****/
-    } else if (!strcmp(name, "smpteoffsets")) {
-#define decimal(p) (((p)[0] - '0') * 10 + ((p)[1] - '0'))
-        // smpteoffset is specified as "24fps:00h:10m:00s:11.00f"
-        // the following simple parser does not reject all badly
-        // formatted strings, but it should parse good strings ok
-        const char *s = update->parameter.s;
-        int len = strlen(s);
-        char smpteoffset[5];
-        if (len < 24) return; // not long enough, must be bad format
-        int fps;
-        if (s[0] == '2') {
-            if (s[1] == '4') fps = 0;
-            else if (s[1] == '5') fps = 1;
-            else if (s[1] == '9') {
-                fps = 2;
-                if (len != 27) return; // not right length
-                s += 3; // cancel effect of longer string
-            }
-        } else fps = 3;
-        s += 6;   int hours = decimal(s);
-        s += 4;   int mins = decimal(s);
-        s += 4;   int secs = decimal(s);
-        s += 4;   int frames = decimal(s);
-        s += 3;   int subframes = decimal(s);
-        smpteoffset[0] = (fps << 6) + hours;
-        smpteoffset[1] = mins;
-        smpteoffset[2] = secs;
-        smpteoffset[3] = frames;
-        smpteoffset[4] = subframes;
-        write_smpteoffset(update, smpteoffset);
-
-    // key signature is special because it takes two events in the Alg_seq
-    // structure to make one midi file event. When we encounter one or 
-    // the other event, we'll just record it in the Alg_smf_write object.
-    // After both events are seen, we write the data. (See below.)
-    } else if (!strcmp(name, "keysigi")) {
-        keysig = update->parameter.i;
-        keysig_when = update->time;
-    } else if (!strcmp(name, "modea")) {
-        if (!strcmp(alg_attr_name(update->parameter.a), "major"))
-            keysig_mode = 'M';
-        else keysig_mode = 'm';
-        keysig_when = update->time;
-    }
-    if (keysig != -99 && keysig_mode) { // write when both are defined
-        write_delta(keysig_when);
-        out_file->put('\xFF');
-        out_file->put('\x59');
-        out_file->put(2);
-        // mask off high bits so that this value appears to be positive
-        // i.e. -1 -> 0xFF (otherwise, write_data will clip -1 to 0)
-        out_file->put(keysig & 0xFF);
-        out_file->put(keysig_mode == 'm');
-        keysig = -99;
-        keysig_mode = false;
-    }
-    //printf("Update: %s, key: %g\n", update->parameter.attr_name(), update->key);
-}
-
-
-// see notes on event_queue::push, TICK_TIME converts from beat to
-// the number of the nearest tick. The second parameter is an offset in
-// quarter ticks. By scheduling with -1, note-offs should get dispatched
-// first. Note that TICK_TIME only determines the order of events, so
-// it is ok to change units from beats to ticks, saving a divide.
-#define TICK_TIME(t, o) (ROUND((t) * division) + 0.25 * (o))
-
-void Alg_smf_write::write_track(int i)
-{
-    int j = 0; // note index
-    Alg_events &notes = seq->track_list[i];
-    event_queue *pending = NULL;
-    if (notes.length() > 0) {
-        pending = new event_queue('n', TICK_TIME(notes[j]->time, 0), 0, NULL);
-    }
-    if (i == 0) { // track 0 may have tempo and timesig info
-        if (seq->get_time_map()->last_tempo_flag || seq->get_time_map()->beats.len > 0) {
-            pending = push(pending, new event_queue('c', 0.0, 0, NULL));
-        }
-        if (seq->time_sig.length() > 0) {
-            pending = push(pending, new event_queue('s', 
-                           TICK_TIME(seq->time_sig[0].beat, 0), 0, NULL));
-        }
-    }
-    while (pending) {
-        event_queue *current = pending;
-        pending = pending->next;
-        if (current->type == 'n') {
-            Alg_note_ptr n = (Alg_note_ptr) notes[current->index];
-            if (n->is_note()) {
-                write_note(n, true);
-                pending = push(pending, new event_queue('o',
-                      TICK_TIME(n->time + n->dur, -1), current->index, NULL));
-            } else if (n->is_update()) {
-                Alg_update_ptr u = (Alg_update_ptr) n;
-                write_update(u);
-            }
-            int next = current->index + 1;
-            if (next < notes.length()) {
-                current->time = TICK_TIME(notes[next]->time, 0);
-                current->index = next;
-                pending = push(pending, current);
-            }
-        } else if (current->type == 'o') { //note-off
-            Alg_note_ptr n = (Alg_note_ptr) notes[current->index];
-            write_note(n, false);
-            delete current;
-        } else if (current->type == 'c') { // tempo change
-            write_tempo_change(current->index);
-            current->index++; // -R
-            if (current->index < seq->get_time_map()->beats.len) {
-                current->time = 
-                    TICK_TIME(seq->get_time_map()->
-                              beats[current->index].beat, 0);
-                pending = push(pending, current);
-            } else {
-                delete current;
-            }
-        } else if (current->type == 's') { // time sig
-            write_time_signature(current->index);
-            current->index++;
-            if (current->index < seq->time_sig.length()) {
-                current->time = 
-                    TICK_TIME(seq->time_sig[current->index].beat, 0);
-                pending = push(pending, current);
-            } else {
-                delete current;
-            }
-        }
-    }
-}
-
-
-void Alg_smf_write::write_tempo(int divs, int tempo)
-{
-    //    printf("Inserting tempo %f after %f clocks.\n", tempo, delta);
-    write_varinum(divs - previous_divs);
-    previous_divs = divs;
-    out_file->put('\xFF');
-    out_file->put('\x51');
-    out_file->put('\x03');
-    write_24bit((int)tempo);
-}
-
-
-void Alg_smf_write::write_tempo_change(int i)
-    //  i is index of tempo map
-{
-    // extract tempo map
-    Alg_beats &b = seq->get_time_map()->beats;
-    double tempo;
-    long divs;
-    if (i < seq->get_time_map()->beats.len - 1) {
-        tempo = 1000000 * ((b[i+1].time - b[i].time) / 
-                           (b[i+1].beat - b[i].beat));
-        divs = ROUND(b[i].beat * division);
-        write_tempo(divs, ROUND(tempo));
-    } else if (seq->get_time_map()->last_tempo_flag) { // write the final tempo
-        divs = ROUND(division * b[i].beat);
-        tempo = (1000000.0 / seq->get_time_map()->last_tempo);
-        write_tempo(divs, ROUND(tempo));
-    }    
-}
-
-
-void Alg_smf_write::write_time_signature(int i)
-{
-    Alg_time_sigs &ts = seq->time_sig;
-    write_delta(ts[i].beat);
-    // write the time signature
-    out_file->put('\xFF');
-    out_file->put('\x58');  // time signature
-    out_file->put('\x04');     // length of message
-    out_file->put(ROUND(ts[i].num));
-    int den = ROUND(ts[i].den);
-    int den_byte = 0;
-    while (den > 1) { // compute the log2 of denominator
-        den_byte++;
-        den >>= 1;
-    }
-    out_file->put(den_byte);
-    out_file->put(24); // clocks per quarter
-    out_file->put(8);  // 32nd notes per 24 clocks
-}
-
-
-
-void Alg_smf_write::write(ostream &file)
-{
-    int track_len_offset;
-    int track_end_offset;
-    int track_len;
-
-    out_file = &file;
-
-    // Header
-    file << "MThd";
-
-    write_32bit(6); // chunk length
-
-    write_16bit(1); // format 1 MIDI file
-
-    write_16bit(seq->tracks()); // number of tracks
-    write_16bit(division); // divisions per quarter note
-
-
-    // write_ all tracks
-    seq->convert_to_beats();
-    int i;
-    for (i = 0; i < seq->tracks(); i++) {
-        previous_divs = 0;
-        *out_file << "MTrk";
-        track_len_offset = out_file->tellp();
-        write_32bit(0); // track len placeholder
-        
-        write_track(i);
-
-        // End of track event
-        write_varinum(0);           // delta time
-        out_file->put('\xFF');
-        out_file->put('\x2F');
-        out_file->put('\x00');
-
-        // Go back and write in the length of the track
-        track_end_offset = out_file->tellp();
-        track_len = track_end_offset - track_len_offset - 4;
-        out_file->seekp(track_len_offset);
-        write_32bit(track_len);
-        out_file->seekp(track_end_offset);
-    }
-}
-
-
-void Alg_smf_write::write_16bit(int num)
-{
-    out_file->put((num & 0xFF00) >> 8);
-    out_file->put(num & 0xFF);
-}
-
-void Alg_smf_write::write_24bit(int num)
-{
-    out_file->put((num & 0xFF0000) >> 16);
-    out_file->put((num & 0xFF00) >> 8);
-    out_file->put((num & 0xFF));
-}
-
-void Alg_smf_write::write_32bit(int num)
-{
-    out_file->put((num & 0xFF000000) >> 24);
-    out_file->put((num & 0xFF0000) >> 16);
-    out_file->put((num & 0xFF00) >> 8);
-    out_file->put((num & 0xFF));
-}
-
-
-void Alg_smf_write::write_delta(double event_time)
-{
-    // divisions is ideal absolute time in divisions
-    long divisions = ROUND(division * event_time);
-    long delta_divs = divisions - previous_divs;
-    write_varinum(delta_divs);
-    previous_divs = divisions;    
-}
-
-
-void Alg_smf_write::write_varinum(int value)
-{
-  if(value<0) value=0;//this line should not have to be here!
-  int buffer;
-
-  buffer = value & 0x7f;
-  while ((value >>= 7) > 0) {
-    buffer <<= 8;
-    buffer |= 0x80;
-    buffer += (value & 0x7f);
-  }
-
-  for(;;) {
-    out_file->put(buffer);
-    if (buffer & 0x80)
-      buffer >>= 8;
-    else
-      break;
-  }
-}
-
-
-void Alg_seq::smf_write(ostream &file)
-{
-    Alg_smf_write writer(this);
-    writer.write(file);
-}
-
-bool Alg_seq::smf_write(const char *filename)
-{
-    ofstream outf(filename, ios::binary | ios::out);
-    if (outf.fail()) return false;
-    smf_write(outf);
-    outf.close();
-    return true;
-}
+// allegrosmfwr.cpp -- Allegro Standard Midi File Write
+
+#include <stdlib.h>
+#include <string.h>
+#include <math.h>
+#include <errno.h>
+#include <string>
+#include <iostream>
+#include <fstream>
+using namespace std;
+#include "allegro.h"
+
+// event_queue is a list element that keeps track of pending
+// things to write to a track, including note-ons, note-offs,
+// updates, tempo changes, and time signatures
+//
+class event_queue{
+public:
+  char type;//'n' for note, 'o' for off, 's' for time signature,
+            // 'c' for tempo changes
+  double time;
+  long index; //of the event in mSeq->notes
+  class event_queue *next;
+  event_queue(char t, double when, long x, class event_queue *n) {
+        type = t; time = when; index = x; next = n; }
+};
+
+
+class Alg_smf_write {
+public:
+    Alg_smf_write(Alg_seq_ptr seq);
+    ~Alg_smf_write();
+    long channels_per_track; // used to encode track number into chan field
+    // chan is actual_channel + channels_per_track * track_number
+    // default is 100, set this to 0 to merge all tracks to 16 channels
+
+    void write(ostream &file /* , midiFileFormat = 1 */);
+
+private:
+    long previous_divs; // time in ticks of most recently written event
+
+    void write_track(int i);
+    void write_tempo(int divs, int tempo);
+    void write_tempo_change(int i);
+    void write_time_signature(int i);
+    void write_note(Alg_note_ptr note, bool on);
+    void write_update(Alg_update_ptr update);
+    void write_text(Alg_update_ptr update, char type);
+    void write_binary(int type_byte, const char *msg);
+    void write_midi_channel_prefix(Alg_update_ptr update);
+    void write_smpteoffset(Alg_update_ptr update, char *s);
+    void write_data(int data);
+    int to_midi_channel(int channel);
+    int to_track(int channel);
+
+    ostream *out_file;
+
+    Alg_seq_ptr seq;
+
+    int num_tracks; // number of tracks not counting tempo track
+    int division; // divisions per quarter note, default = 120
+    int initial_tempo;
+
+    int timesig_num; // numerator of time signature
+    int timesig_den; // denominator of time signature
+    double timesig_when; // time of time signature
+
+    int keysig;          // number of sharps (+) or flats (-), -99 for undefined
+    char keysig_mode; // 'M' or 'm' for major/minor
+    double keysig_when;    // time of key signature
+
+    void write_delta(double event_time);
+    void write_varinum(int num);
+    void write_16bit(int num);
+    void write_24bit(int num);
+    void write_32bit(int num);
+};
+
+#define ROUND(x) (int) ((x)+0.5)
+
+Alg_smf_write::Alg_smf_write(Alg_seq_ptr a_seq)
+{
+    out_file = NULL;
+
+    // at 100bpm (a nominal tempo value), we would like a division
+    // to represent 1ms of time. So
+    // d ticks/beat * 100 beats/min = 60,000 ms/min * 1 tick/ms
+    // solving for d, d = 600
+    division = 600;         // divisions per quarter note
+    timesig_num = timesig_den = 0; // initially undefined
+    keysig = -99;
+    keysig_mode = 0;
+    initial_tempo = 500000;
+
+    seq = a_seq;
+
+    previous_divs = 0; // used to compute deltas for midifile
+}
+
+
+Alg_smf_write::~Alg_smf_write()
+{
+}
+
+
+// sorting is quite subtle due to rounding
+// For example, suppose times from a MIDI file are exact, but in
+// decimal round to TW0.4167 Q0.3333. Since the time in whole notes
+// rounded up, this note will start late. Even though the duration
+// rounded down, the amount is 1/4 as much because units are quarter
+// notes. Therefore, the total roundup is 0.0001 beats. This is 
+// enough to cause the note to sort later in the queue, perhaps
+// coming after a new note-on on the same pitch, and resulting in 
+// a turning on-off, on-off into on, on, off, off if data is moved
+// to Allegro (ascii) format with rounding and then back to SMF.
+//
+// The solution here is to consider things that round to the same
+// tick to be simultaneous. Then, be sure to deal with note-offs
+// before note-ons. We're going to do that by using event_queue
+// times that are rounded to the nearest tick time. Except note-offs
+// are going to go in with times that are 1/4 tick earlier so they
+// get scheduled first, but still end up on the same tick.
+//
+event_queue* push(event_queue *queue, event_queue *event)
+{
+    // printf("push: %.6g, %c, %d\n", event->time, event->type, event->index);
+    if (queue == NULL) {
+        event->next = NULL;
+        return event;
+    }
+   
+    event_queue *marker1 = NULL;
+    event_queue *marker2 = queue;
+    while (marker2 != NULL && marker2->time <= event->time) {
+        marker1 = marker2;
+        marker2 = marker2->next;
+    }
+    event->next = marker2;
+    if (marker1 != NULL) {
+        marker1->next=event;
+        return queue;
+    } else return event;
+}
+
+
+void print_queue(event_queue *q)
+{
+    printf("Printing queue. . .\n");
+    event_queue *q2=q;
+    while (q2) {
+        printf("%c at %f ;", q2->type, q2->time);
+        q2 = q2->next;
+    }
+    printf("\nDone printing.\n");
+}
+
+
+void Alg_smf_write::write_note(Alg_note_ptr note, bool on)
+{
+    double event_time = (on ? note->time : note->time + note->dur);
+    write_delta(event_time);
+
+    //printf("deltaDivisions: %d, beats elapsed: %g, on? %c\n", deltaDivisions, note->time, on);
+
+    char chan = char(note->chan & 15);
+    int pitch = int(note->pitch + 0.5);
+    if (pitch < 0) {
+          pitch = pitch % 12;
+    } else if (pitch > 127) {
+        pitch = (pitch % 12) + 120; // put pitch in 10th octave
+        if (pitch > 127) pitch -= 12; // or 9th octave
+    }
+    out_file->put(0x90 + chan);
+    out_file->put(pitch);
+    if (on) {
+        int vel = (int) note->loud;
+        if (vel <= 0) vel = 1;
+        write_data(vel);
+    } else out_file->put(0); // note-off indicated by velocty zero
+}
+
+
+void Alg_smf_write::write_midi_channel_prefix(Alg_update_ptr update)
+{
+   if (update->chan >= 0) { // write MIDI Channel Prefix
+        write_delta(update->time);
+        out_file->put('\xFF'); // Meta Event
+        out_file->put('\x20'); // Type code for MIDI Channel Prefix
+        out_file->put(1); // length
+        out_file->put(to_midi_channel(update->chan));
+        // one thing odd about the Std MIDI File spec is that once
+        // you turn on MIDI Channel Prefix, there seems to be no
+        // way to cancel it unless a non-Meta event shows up. We
+        // don't do any analysis to avoid assigning channels to
+        // meta events.
+    }
+}
+
+
+void Alg_smf_write::write_text(Alg_update_ptr update, char type)
+{
+    write_midi_channel_prefix(update);
+    write_delta(update->time);
+    out_file->put('\xFF');
+    out_file->put(type);
+    out_file->put((char) strlen(update->parameter.s));
+    *out_file << update->parameter.s;
+}
+
+
+void Alg_smf_write::write_smpteoffset(Alg_update_ptr update, char *s)
+{
+    write_midi_channel_prefix(update);
+    write_delta(update->time);
+    out_file->put('\xFF'); // meta event
+    out_file->put('\x54'); // smpte offset type code
+    out_file->put(5); // length
+    for (int i = 0; i < 5; i++) *out_file << s[i];
+}
+
+
+// write_data - limit data to the range of [0...127] and write it
+void Alg_smf_write::write_data(int data)
+{
+    if (data < 0) data = 0;
+    else if (data > 0x7F) data = 0x7F;
+
+    out_file->put(data);
+}
+
+
+int Alg_smf_write::to_midi_channel(int channel)
+{
+    // allegro track number is stored as multiple of 100
+    // also mask off all but 4 channel bits just in case
+    if (channels_per_track > 0) channel %= channels_per_track;
+    return channel & 0xF;
+}
+
+
+int Alg_smf_write::to_track(int channel)
+{
+    if (channel == -1) return 0;
+    return channel / channels_per_track;
+}
+
+
+static char hex_to_nibble(char c)
+{
+    if (isalpha(c)) {
+        return 10 + (toupper(c) - 'A');
+    } else {
+        return c - '0';
+    }
+}
+
+
+static char hex_to_char(const char *s)
+{
+    return (hex_to_nibble(s[0]) << 4) + hex_to_nibble(s[1]);
+}
+
+
+void Alg_smf_write::write_binary(int type_byte, const char *msg)
+{
+    int len = strlen(msg) / 2;
+    out_file->put(type_byte);
+    write_varinum(len);
+    for (int i = 0; i < len; i++) {
+        out_file->put(hex_to_char(msg));
+        msg += 2;
+    }
+}
+
+
+void Alg_smf_write::write_update(Alg_update_ptr update)
+{
+    const char *name = update->parameter.attr_name();
+
+    /****Non-Meta Events****/
+    if (!strcmp(name, "pressurer")) {
+        write_delta(update->time);
+        if (update->get_identifier() < 0) { // channel pressure message
+            out_file->put(0xD0 + to_midi_channel(update->chan));
+            write_data((int)(update->parameter.r * 127));
+        } else { // just 1 key -- poly pressure
+            out_file->put(0xA0 + to_midi_channel(update->chan));
+            write_data(update->get_identifier());
+            write_data((int)(update->parameter.r * 127));
+        }
+    } else if (!strcmp(name, "programi")) {
+        write_delta(update->time);
+        out_file->put(0xC0 + to_midi_channel(update->chan));
+        write_data(update->parameter.i);
+    } else if (!strcmp(name, "bendr")) {
+        int temp = ROUND(0x2000 * (update->parameter.r + 1));
+        if (temp > 0x3fff) temp = 0x3fff; // 14 bits maximum
+        if (temp < 0) temp = 0;
+        int c1 = temp & 0x7F; // low 7 bits
+        int c2 = temp >> 7;   // high 7 bits
+        write_delta(update->time);
+        out_file->put(0xE0 + to_midi_channel(update->chan));
+        write_data(c1);
+        write_data(c2);
+    } else if (!strncmp(name, "control", 7) && 
+               update->parameter.attr_type() == 'r') {
+      int ctrlnum = atoi(name + 7);
+      int val = ROUND(update->parameter.r * 127);
+      write_delta(update->time);
+      out_file->put(0xB0 + to_midi_channel(update->chan));
+      write_data(ctrlnum);
+      write_data(val);
+    } else if (!strcmp(name, "sysexs") &&
+               update->parameter.attr_type() == 's') {
+        const char *s = update->parameter.s;
+        if (s[0] && s[1] && toupper(s[0]) == 'F' && s[1] == '0') {
+            s += 2; // skip the initial "F0" byte in message: it is implied
+        }
+        write_delta(update->time);
+        write_binary(0xF0, s);
+    } else if (!strcmp(name, "sqspecifics") &&
+               update->parameter.attr_type() == 's') {
+        const char *s = update->parameter.s;
+        write_delta(update->time);
+        out_file->put('\xFF');
+        write_binary(0x7F, s);
+
+    /****Text Events****/
+    } else if (!strcmp(name, "texts")) {
+        write_text(update, 0x01);
+    } else if (!strcmp(name, "copyrights")) {
+        write_text(update, 0x02);
+    } else if (!strcmp(name, "seqnames") || !strcmp(name, "tracknames")) {
+        write_text(update, 0x03);
+    } else if (!strcmp(name, "instruments")) {
+        write_text(update, 0x04);
+    } else if (!strcmp(name, "lyrics")) {
+        write_text(update, 0x05);
+    } else if (!strcmp(name, "markers")) {
+        write_text(update, 0x06);
+    } else if (!strcmp(name, "cues")) {
+        write_text(update, 0x07);
+    } else if (!strcmp(name, "miscs")) {
+        write_text(update, 0x08);
+
+    /****Other Events****/
+    } else if (!strcmp(name, "smpteoffsets")) {
+#define decimal(p) (((p)[0] - '0') * 10 + ((p)[1] - '0'))
+        // smpteoffset is specified as "24fps:00h:10m:00s:11.00f"
+        // the following simple parser does not reject all badly
+        // formatted strings, but it should parse good strings ok
+        const char *s = update->parameter.s;
+        int len = strlen(s);
+        char smpteoffset[5];
+        if (len < 24) return; // not long enough, must be bad format
+        int fps;
+        if (s[0] == '2') {
+            if (s[1] == '4') fps = 0;
+            else if (s[1] == '5') fps = 1;
+            else if (s[1] == '9') {
+                fps = 2;
+                if (len != 27) return; // not right length
+                s += 3; // cancel effect of longer string
+            }
+        } else fps = 3;
+        s += 6;   int hours = decimal(s);
+        s += 4;   int mins = decimal(s);
+        s += 4;   int secs = decimal(s);
+        s += 4;   int frames = decimal(s);
+        s += 3;   int subframes = decimal(s);
+        smpteoffset[0] = (fps << 6) + hours;
+        smpteoffset[1] = mins;
+        smpteoffset[2] = secs;
+        smpteoffset[3] = frames;
+        smpteoffset[4] = subframes;
+        write_smpteoffset(update, smpteoffset);
+
+    // key signature is special because it takes two events in the Alg_seq
+    // structure to make one midi file event. When we encounter one or 
+    // the other event, we'll just record it in the Alg_smf_write object.
+    // After both events are seen, we write the data. (See below.)
+    } else if (!strcmp(name, "keysigi")) {
+        keysig = update->parameter.i;
+        keysig_when = update->time;
+    } else if (!strcmp(name, "modea")) {
+        if (!strcmp(alg_attr_name(update->parameter.a), "major"))
+            keysig_mode = 'M';
+        else keysig_mode = 'm';
+        keysig_when = update->time;
+    }
+    if (keysig != -99 && keysig_mode) { // write when both are defined
+        write_delta(keysig_when);
+        out_file->put('\xFF');
+        out_file->put('\x59');
+        out_file->put(2);
+        // mask off high bits so that this value appears to be positive
+        // i.e. -1 -> 0xFF (otherwise, write_data will clip -1 to 0)
+        out_file->put(keysig & 0xFF);
+        out_file->put(keysig_mode == 'm');
+        keysig = -99;
+        keysig_mode = false;
+    }
+    //printf("Update: %s, key: %g\n", update->parameter.attr_name(), update->key);
+}
+
+
+// see notes on event_queue::push, TICK_TIME converts from beat to
+// the number of the nearest tick. The second parameter is an offset in
+// quarter ticks. By scheduling with -1, note-offs should get dispatched
+// first. Note that TICK_TIME only determines the order of events, so
+// it is ok to change units from beats to ticks, saving a divide.
+#define TICK_TIME(t, o) (ROUND((t) * division) + 0.25 * (o))
+
+void Alg_smf_write::write_track(int i)
+{
+    int j = 0; // note index
+    Alg_events &notes = seq->track_list[i];
+    event_queue *pending = NULL;
+    if (notes.length() > 0) {
+        pending = new event_queue('n', TICK_TIME(notes[j]->time, 0), 0, NULL);
+    }
+    if (i == 0) { // track 0 may have tempo and timesig info
+        if (seq->get_time_map()->last_tempo_flag || seq->get_time_map()->beats.len > 0) {
+            pending = push(pending, new event_queue('c', 0.0, 0, NULL));
+        }
+        if (seq->time_sig.length() > 0) {
+            pending = push(pending, new event_queue('s', 
+                           TICK_TIME(seq->time_sig[0].beat, 0), 0, NULL));
+        }
+    }
+    while (pending) {
+        event_queue *current = pending;
+        pending = pending->next;
+        if (current->type == 'n') {
+            Alg_note_ptr n = (Alg_note_ptr) notes[current->index];
+            if (n->is_note()) {
+                write_note(n, true);
+                pending = push(pending, new event_queue('o',
+                      TICK_TIME(n->time + n->dur, -1), current->index, NULL));
+            } else if (n->is_update()) {
+                Alg_update_ptr u = (Alg_update_ptr) n;
+                write_update(u);
+            }
+            int next = current->index + 1;
+            if (next < notes.length()) {
+                current->time = TICK_TIME(notes[next]->time, 0);
+                current->index = next;
+                pending = push(pending, current);
+            }
+        } else if (current->type == 'o') { //note-off
+            Alg_note_ptr n = (Alg_note_ptr) notes[current->index];
+            write_note(n, false);
+            delete current;
+        } else if (current->type == 'c') { // tempo change
+            write_tempo_change(current->index);
+            current->index++; // -R
+            if (current->index < seq->get_time_map()->beats.len) {
+                current->time = 
+                    TICK_TIME(seq->get_time_map()->
+                              beats[current->index].beat, 0);
+                pending = push(pending, current);
+            } else {
+                delete current;
+            }
+        } else if (current->type == 's') { // time sig
+            write_time_signature(current->index);
+            current->index++;
+            if (current->index < seq->time_sig.length()) {
+                current->time = 
+                    TICK_TIME(seq->time_sig[current->index].beat, 0);
+                pending = push(pending, current);
+            } else {
+                delete current;
+            }
+        }
+    }
+}
+
+
+void Alg_smf_write::write_tempo(int divs, int tempo)
+{
+    //    printf("Inserting tempo %f after %f clocks.\n", tempo, delta);
+    write_varinum(divs - previous_divs);
+    previous_divs = divs;
+    out_file->put('\xFF');
+    out_file->put('\x51');
+    out_file->put('\x03');
+    write_24bit((int)tempo);
+}
+
+
+void Alg_smf_write::write_tempo_change(int i)
+    //  i is index of tempo map
+{
+    // extract tempo map
+    Alg_beats &b = seq->get_time_map()->beats;
+    double tempo;
+    long divs;
+    if (i < seq->get_time_map()->beats.len - 1) {
+        tempo = 1000000 * ((b[i+1].time - b[i].time) / 
+                           (b[i+1].beat - b[i].beat));
+        divs = ROUND(b[i].beat * division);
+        write_tempo(divs, ROUND(tempo));
+    } else if (seq->get_time_map()->last_tempo_flag) { // write the final tempo
+        divs = ROUND(division * b[i].beat);
+        tempo = (1000000.0 / seq->get_time_map()->last_tempo);
+        write_tempo(divs, ROUND(tempo));
+    }    
+}
+
+
+void Alg_smf_write::write_time_signature(int i)
+{
+    Alg_time_sigs &ts = seq->time_sig;
+    write_delta(ts[i].beat);
+    // write the time signature
+    out_file->put('\xFF');
+    out_file->put('\x58');  // time signature
+    out_file->put('\x04');     // length of message
+    out_file->put(ROUND(ts[i].num));
+    int den = ROUND(ts[i].den);
+    int den_byte = 0;
+    while (den > 1) { // compute the log2 of denominator
+        den_byte++;
+        den >>= 1;
+    }
+    out_file->put(den_byte);
+    out_file->put(24); // clocks per quarter
+    out_file->put(8);  // 32nd notes per 24 clocks
+}
+
+
+
+void Alg_smf_write::write(ostream &file)
+{
+    int track_len_offset;
+    int track_end_offset;
+    int track_len;
+
+    out_file = &file;
+
+    // Header
+    file << "MThd";
+
+    write_32bit(6); // chunk length
+
+    write_16bit(1); // format 1 MIDI file
+
+    write_16bit(seq->tracks()); // number of tracks
+    write_16bit(division); // divisions per quarter note
+
+
+    // write_ all tracks
+    seq->convert_to_beats();
+    int i;
+    for (i = 0; i < seq->tracks(); i++) {
+        previous_divs = 0;
+        *out_file << "MTrk";
+        track_len_offset = out_file->tellp();
+        write_32bit(0); // track len placeholder
+        
+        write_track(i);
+
+        // End of track event
+        write_varinum(0);           // delta time
+        out_file->put('\xFF');
+        out_file->put('\x2F');
+        out_file->put('\x00');
+
+        // Go back and write in the length of the track
+        track_end_offset = out_file->tellp();
+        track_len = track_end_offset - track_len_offset - 4;
+        out_file->seekp(track_len_offset);
+        write_32bit(track_len);
+        out_file->seekp(track_end_offset);
+    }
+}
+
+
+void Alg_smf_write::write_16bit(int num)
+{
+    out_file->put((num & 0xFF00) >> 8);
+    out_file->put(num & 0xFF);
+}
+
+void Alg_smf_write::write_24bit(int num)
+{
+    out_file->put((num & 0xFF0000) >> 16);
+    out_file->put((num & 0xFF00) >> 8);
+    out_file->put((num & 0xFF));
+}
+
+void Alg_smf_write::write_32bit(int num)
+{
+    out_file->put((num & 0xFF000000) >> 24);
+    out_file->put((num & 0xFF0000) >> 16);
+    out_file->put((num & 0xFF00) >> 8);
+    out_file->put((num & 0xFF));
+}
+
+
+void Alg_smf_write::write_delta(double event_time)
+{
+    // divisions is ideal absolute time in divisions
+    long divisions = ROUND(division * event_time);
+    long delta_divs = divisions - previous_divs;
+    write_varinum(delta_divs);
+    previous_divs = divisions;    
+}
+
+
+void Alg_smf_write::write_varinum(int value)
+{
+  if(value<0) value=0;//this line should not have to be here!
+  int buffer;
+
+  buffer = value & 0x7f;
+  while ((value >>= 7) > 0) {
+    buffer <<= 8;
+    buffer |= 0x80;
+    buffer += (value & 0x7f);
+  }
+
+  for(;;) {
+    out_file->put(buffer);
+    if (buffer & 0x80)
+      buffer >>= 8;
+    else
+      break;
+  }
+}
+
+
+void Alg_seq::smf_write(ostream &file)
+{
+    Alg_smf_write writer(this);
+    writer.write(file);
+}
+
+bool Alg_seq::smf_write(const char *filename)
+{
+    ofstream outf(filename, ios::binary | ios::out);
+    if (outf.fail()) return false;
+    smf_write(outf);
+    outf.close();
+    return true;
+}
diff --git a/allegrowr.cpp b/allegrowr.cpp
index 3142cfd..54bf601 100755
--- a/allegrowr.cpp
+++ b/allegrowr.cpp
@@ -1,183 +1,183 @@
-// allegrowr.cpp -- write sequence to an Allegro file (text)
-
-#include "assert.h"
-#include "stdlib.h"
-#include <iostream>
-#include <fstream>
-#include <iomanip>
-#include <errno.h>
-#include <string>
-#include "memory.h"
-using namespace std;
-#include "strparse.h"
-#include "allegro.h"
-
-// Note about precision: %g prints 6 significant digits. For 1ms precision, 
-// the maximum magnitude is 999.999, i.e. 1000s < 17minutes. For anything
-// over 1000s, time in seconds will be printed with 10ms precision, which
-// is not good. Therefore, times and durations are printed as %.4d, which 
-// gives 100us precision.
-// The following define allows you to change this decision:
-/* #define TIMFMT "%.4d" */
-#define TIMPREC 4
-#define TIMFMT fixed << setprecision(TIMPREC)
-#define GFMT resetiosflags(ios::floatfield) << setprecision(6)
-
-void parameter_print(ostream &file, Alg_parameter_ptr p)
-{
-    file << " -" << p->attr_name() << ":";
-    switch (p->attr_type()) {
-    case 'a':
-        file << "'" << alg_attr_name(p->a) << "'";
-        break;
-    case 'i':
-        file << p->i;
-        break;
-    case 'l':
-        file << (p->l ? "true" : "false");
-        break;
-    case 'r':
-        file << p->r;
-        break;
-    case 's': {
-        string str;
-        string_escape(str, p->s, "\"");
-        file << str;
-        break;
-    }
-    }
-}
-
-Alg_event_ptr Alg_seq::write_track_name(ostream &file, int n, 
-                                        Alg_events &events)
-// write #track <n> <trackname-or-sequencename>
-// if we write the name on the "#track" line, then we do *not* want
-// to write again as an update: "-seqnames:"Jordu", so if we do
-// find a name and write it, return a pointer to it so the track
-// writer knows what update (if any) to skip
-{
-    Alg_event_ptr e = NULL; // e is the result, default is NULL
-    file << "#track " << n;
-    const char *attr = symbol_table.insert_string(
-                               n == 0 ? "seqnames" : "tracknames");
-    // search for name in events with timestamp of 0
-    for (int i = 0; i < events.length(); i++) {
-        Alg_event_ptr ue = events[i];
-        if (ue->time > 0) break;
-        if (ue->is_update()) {
-            Alg_update_ptr u = (Alg_update_ptr) ue;
-            if (u->parameter.attr == attr) {
-                file << " " << u->parameter.s;
-                e = ue; // return the update event we found
-                break;
-            }
-        }
-    }
-    file << endl; // end of line containing #track [<name>]
-    return e; // return parameter event with name if one was found
-}
-
-
-void Alg_seq::write(ostream &file, bool in_secs, double offset)
-{
-    int i, j;
-    if (in_secs) convert_to_seconds();
-    else convert_to_beats();
-    file << "#offset " << offset << endl;
-    Alg_event_ptr update_to_skip = write_track_name(file, 0, track_list[0]);
-    Alg_beats &beats = time_map->beats;
-    for (i = 0; i < beats.len - 1; i++) {
-        Alg_beat_ptr b = &(beats[i]);
-        if (in_secs) {
-            file << "T" << TIMFMT << b->time;
-        } else {
-            file << "TW" << TIMFMT << b->beat / 4;
-        }
-        double tempo = (beats[i + 1].beat - b->beat) /
-                       (beats[i + 1].time - beats[i].time);
-        file << " -tempor:" << GFMT << tempo * 60 << "\n";
-    }
-    if (time_map->last_tempo_flag) { // we have final tempo:
-        Alg_beat_ptr b = &(beats[beats.len - 1]);
-        if (in_secs) {
-            file << "T" << TIMFMT << b->time;
-        } else {
-            file << "TW" << TIMFMT << b->beat / 4;
-        }
-        file << " -tempor:" << GFMT << time_map->last_tempo * 60.0 << "\n";
-    }
-
-    // write the time signatures
-    for (i = 0; i < time_sig.length(); i++) {
-        Alg_time_sig &ts = time_sig[i];
-        double time = ts.beat;
-        if (in_secs) {
-            file << "T" << TIMFMT << time << " V- -timesig_numr:" << 
-                    GFMT << ts.num << "\n";
-            file << "T" << TIMFMT << time << " V- -timesig_denr:" << 
-                    GFMT << ts.den << "\n";
-        } else {
-            double wholes = ts.beat / 4;
-            file << "TW" << TIMFMT << wholes << " V- -timesig_numr:" <<
-                    GFMT << ts.num << "\n";
-            file << "TW" << TIMFMT << wholes << " V- -timesig_denr:" <<
-                    GFMT << ts.den << "\n";
-        }
-    }
-
-    for (j = 0; j < track_list.length(); j++) {
-        Alg_events &notes = track_list[j];
-        if (j != 0) update_to_skip = write_track_name(file, j, notes);
-        // now write the notes at beat positions
-        for (i = 0; i < notes.length(); i++) {
-            Alg_event_ptr e = notes[i];
-            // if we already wrote this event as a track or sequence name,
-            // do not write it again
-            if (e == update_to_skip) continue;
-            double start = e->time;
-            if (in_secs) {
-                file << "T" << TIMFMT << start;
-            } else {
-                file << "TW" << TIMFMT << start / 4;
-            }
-            // write the channel as Vn or V-
-            if (e->chan == -1) file << " V-";
-            else file << " V" << e->chan;
-            // write the note or update data
-            if (e->is_note()) {
-                Alg_note_ptr n = (Alg_note_ptr) e;
-                double dur = n->dur;
-                file << " K" << n->get_identifier() << 
-                        " P" << GFMT << n->pitch;
-                if (in_secs) {
-                    file << " U" << TIMFMT << dur;
-                } else {
-                    file << " Q" << TIMFMT << dur;
-                }
-                file << " L" << GFMT << n->loud; 
-                Alg_parameters_ptr p = n->parameters;
-                while (p) {
-                    parameter_print(file, &(p->parm));
-                    p = p->next;
-                }
-            } else { // an update
-                assert(e->is_update());
-                Alg_update_ptr u = (Alg_update_ptr) e;
-                if (u->get_identifier() != -1) {
-                    file << " K" << u->get_identifier();
-                }
-                parameter_print(file, &(u->parameter));
-            }
-            file << "\n";
-        }
-    }
-}
-
-bool Alg_seq::write(const char *filename, double offset)
-{
-    ofstream file(filename);
-    if (file.fail()) return false;
-    write(file, units_are_seconds, offset);
-    file.close();
-    return true;
-}
+// allegrowr.cpp -- write sequence to an Allegro file (text)
+
+#include "assert.h"
+#include "stdlib.h"
+#include <iostream>
+#include <fstream>
+#include <iomanip>
+#include <errno.h>
+#include <string>
+#include "memory.h"
+using namespace std;
+#include "strparse.h"
+#include "allegro.h"
+
+// Note about precision: %g prints 6 significant digits. For 1ms precision, 
+// the maximum magnitude is 999.999, i.e. 1000s < 17minutes. For anything
+// over 1000s, time in seconds will be printed with 10ms precision, which
+// is not good. Therefore, times and durations are printed as %.4d, which 
+// gives 100us precision.
+// The following define allows you to change this decision:
+/* #define TIMFMT "%.4d" */
+#define TIMPREC 4
+#define TIMFMT fixed << setprecision(TIMPREC)
+#define GFMT resetiosflags(ios::floatfield) << setprecision(6)
+
+void parameter_print(ostream &file, Alg_parameter_ptr p)
+{
+    file << " -" << p->attr_name() << ":";
+    switch (p->attr_type()) {
+    case 'a':
+        file << "'" << alg_attr_name(p->a) << "'";
+        break;
+    case 'i':
+        file << p->i;
+        break;
+    case 'l':
+        file << (p->l ? "true" : "false");
+        break;
+    case 'r':
+        file << p->r;
+        break;
+    case 's': {
+        string str;
+        string_escape(str, p->s, "\"");
+        file << str;
+        break;
+    }
+    }
+}
+
+Alg_event_ptr Alg_seq::write_track_name(ostream &file, int n, 
+                                        Alg_events &events)
+// write #track <n> <trackname-or-sequencename>
+// if we write the name on the "#track" line, then we do *not* want
+// to write again as an update: "-seqnames:"Jordu", so if we do
+// find a name and write it, return a pointer to it so the track
+// writer knows what update (if any) to skip
+{
+    Alg_event_ptr e = NULL; // e is the result, default is NULL
+    file << "#track " << n;
+    const char *attr = symbol_table.insert_string(
+                               n == 0 ? "seqnames" : "tracknames");
+    // search for name in events with timestamp of 0
+    for (int i = 0; i < events.length(); i++) {
+        Alg_event_ptr ue = events[i];
+        if (ue->time > 0) break;
+        if (ue->is_update()) {
+            Alg_update_ptr u = (Alg_update_ptr) ue;
+            if (u->parameter.attr == attr) {
+                file << " " << u->parameter.s;
+                e = ue; // return the update event we found
+                break;
+            }
+        }
+    }
+    file << endl; // end of line containing #track [<name>]
+    return e; // return parameter event with name if one was found
+}
+
+
+void Alg_seq::write(ostream &file, bool in_secs, double offset)
+{
+    int i, j;
+    if (in_secs) convert_to_seconds();
+    else convert_to_beats();
+    file << "#offset " << offset << endl;
+    Alg_event_ptr update_to_skip = write_track_name(file, 0, track_list[0]);
+    Alg_beats &beats = time_map->beats;
+    for (i = 0; i < beats.len - 1; i++) {
+        Alg_beat_ptr b = &(beats[i]);
+        if (in_secs) {
+            file << "T" << TIMFMT << b->time;
+        } else {
+            file << "TW" << TIMFMT << b->beat / 4;
+        }
+        double tempo = (beats[i + 1].beat - b->beat) /
+                       (beats[i + 1].time - beats[i].time);
+        file << " -tempor:" << GFMT << tempo * 60 << "\n";
+    }
+    if (time_map->last_tempo_flag) { // we have final tempo:
+        Alg_beat_ptr b = &(beats[beats.len - 1]);
+        if (in_secs) {
+            file << "T" << TIMFMT << b->time;
+        } else {
+            file << "TW" << TIMFMT << b->beat / 4;
+        }
+        file << " -tempor:" << GFMT << time_map->last_tempo * 60.0 << "\n";
+    }
+
+    // write the time signatures
+    for (i = 0; i < time_sig.length(); i++) {
+        Alg_time_sig &ts = time_sig[i];
+        double time = ts.beat;
+        if (in_secs) {
+            file << "T" << TIMFMT << time << " V- -timesig_numr:" << 
+                    GFMT << ts.num << "\n";
+            file << "T" << TIMFMT << time << " V- -timesig_denr:" << 
+                    GFMT << ts.den << "\n";
+        } else {
+            double wholes = ts.beat / 4;
+            file << "TW" << TIMFMT << wholes << " V- -timesig_numr:" <<
+                    GFMT << ts.num << "\n";
+            file << "TW" << TIMFMT << wholes << " V- -timesig_denr:" <<
+                    GFMT << ts.den << "\n";
+        }
+    }
+
+    for (j = 0; j < track_list.length(); j++) {
+        Alg_events &notes = track_list[j];
+        if (j != 0) update_to_skip = write_track_name(file, j, notes);
+        // now write the notes at beat positions
+        for (i = 0; i < notes.length(); i++) {
+            Alg_event_ptr e = notes[i];
+            // if we already wrote this event as a track or sequence name,
+            // do not write it again
+            if (e == update_to_skip) continue;
+            double start = e->time;
+            if (in_secs) {
+                file << "T" << TIMFMT << start;
+            } else {
+                file << "TW" << TIMFMT << start / 4;
+            }
+            // write the channel as Vn or V-
+            if (e->chan == -1) file << " V-";
+            else file << " V" << e->chan;
+            // write the note or update data
+            if (e->is_note()) {
+                Alg_note_ptr n = (Alg_note_ptr) e;
+                double dur = n->dur;
+                file << " K" << n->get_identifier() << 
+                        " P" << GFMT << n->pitch;
+                if (in_secs) {
+                    file << " U" << TIMFMT << dur;
+                } else {
+                    file << " Q" << TIMFMT << dur;
+                }
+                file << " L" << GFMT << n->loud; 
+                Alg_parameters_ptr p = n->parameters;
+                while (p) {
+                    parameter_print(file, &(p->parm));
+                    p = p->next;
+                }
+            } else { // an update
+                assert(e->is_update());
+                Alg_update_ptr u = (Alg_update_ptr) e;
+                if (u->get_identifier() != -1) {
+                    file << " K" << u->get_identifier();
+                }
+                parameter_print(file, &(u->parameter));
+            }
+            file << "\n";
+        }
+    }
+}
+
+bool Alg_seq::write(const char *filename, double offset)
+{
+    ofstream file(filename);
+    if (file.fail()) return false;
+    write(file, units_are_seconds, offset);
+    file.close();
+    return true;
+}
diff --git a/configure.ac b/configure.ac
index 0e605aa..ea873c3 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1,136 +1,136 @@
-dnl
-dnl portSMF configure.in script - version not using libtool
-dnl
-dnl Joshua Haberman
-dnl Dominic Mazzoni
-dnl Richard Ash
-dnl
-
-dnl
-dnl Instructions: to create "configure" from "configure.in", run:
-dnl aclocal
-dnl autoconf
-
-dnl Process this file with autoconf to produce a configure script.
-
-dnl Require autoconf >= 2.61
-AC_PREREQ(2.61)
-
-dnl Init autoconf and automake
-AC_INIT([portSMF],[0.1])
-dnl check that we have some source code
-AC_CONFIG_SRCDIR([allegro.h])
-dnl keep autools files in a subdirectory
-AC_CONFIG_AUX_DIR(autotools)
-# which also contains a subdir containing macros
-AC_CONFIG_MACRO_DIR([autotools/m4])
-dnl set up automake
-AM_INIT_AUTOMAKE([-Wall foreign])
-dnl Audacity policy: don't enable automatic rebuild of configure et al if 
-dnl sources change
-AM_MAINTAINER_MODE([enabled])
-
-dnl -------------------------------------------------------
-dnl Checks for programs.
-dnl -------------------------------------------------------
-dnl save $CFLAGS etc. since AC_PROG_CC likes to insert "-g -O2"
-dnl if $CFLAGS is blank and it finds GCC
-cflags_save="$CFLAGS"
-cppflags_save="$CPPFLAGS"
-cxxflags_save="$CXXFLAGS"
-AC_PROG_CC
-AC_LANG([C++])
-AC_PROG_CXX
-AC_PROG_CXXCPP
-CFLAGS="$cflags_save"
-CPPFLAGS="$cppflags_save"
-CXXFLAGS="$cxxflags_save"
-
-dnl we will need an "install" program to be available
-AC_PROG_INSTALL
-dnl and ranlib for static libraries
-AC_PROG_RANLIB
-
-dnl Make the install prefix available to the program so that the pkg-config file
-dnl can be created correctly
-AC_PREFIX_DEFAULT(/usr/local)
-if [[ $prefix = "NONE" ]] ; then
-  AC_DEFINE(INSTALL_PREFIX, "/usr/local",
-      [define as prefix where Audacity is installed])
-else
-  AC_DEFINE_UNQUOTED(INSTALL_PREFIX, "$prefix")
-fi
-
-dnl Build Options
-
-AC_ARG_ENABLE(debug,
-            [AS_HELP_STRING([--enable-debug],
-                            [enable debug support [default=no]])],
-            debug_preference="$enableval",
-            debug_preference="no")
-
-dnl ----------------------------------------------------
-dnl If user asked for debug, put debug in compiler flags
-dnl ----------------------------------------------------
-
-if test x"$debug_preference" = "xyes" ; then
-   dnl we want debuging on
-   AC_MSG_NOTICE([Adding -g for debugging to CFLAGS and CXXFLAGS ...])
-   CFLAGS="${CFLAGS} -g "
-   CXXFLAGS="${CXXFLAGS} -g "
-fi
-
-dnl --------------------------------------------------------------------------
-dnl We would like warnings enabled on the builds, but different compilers need
-dnl different options for these. This bit tries to work out what flags we 
-dnl should add to the compiler we are using.
-dnl --------------------------------------------------------------------------
-
-dnl Strict prototypes flags for C (only C because doesn't work for C++)
-AX_CFLAGS_STRICT_PROTOTYPES(CFLAGS)
-
-dnl Sensible warnings for C
-AX_CFLAGS_WARN_ALL(wall_flags)
-CFLAGS="${CFLAGS} $wall_flags"
-dnl try and use it on C++ as well
-AX_CXX_CHECK_FLAG([$wall_flags], [[int foo;]], [[foo = 1;]], cxx_does_wall="yes", cxx_does_wall="no")
-if test "x$cxx_does_wall" = "xyes" ; then
-   dnl can use all warnings flag on the C++ compiler
-   CXXFLAGS="${CXXFLAGS} $wall_flags"
-fi
-AX_CXXCPP_CHECK_FLAG([$wall_flags], [[int foo;]], [[foo = 1;]], cpp_does_wall="yes", cpp_does_wall="no")
-if test "x$cpp_does_wall" = "xyes" ; then
-   dnl can use all warnings flag on the C++ pre-processor
-   CPPFLAGS="${CPPFLAGS} $wall_flags"
-fi
-
-dnl --- check for required libraries ---
-dnl system libraries
-AC_CHECK_FUNCS([strchr memmove])
-AC_FUNC_MALLOC
-AC_HEADER_STDBOOL
-
-dnl Checks for header files.
-AC_HEADER_STDC
-AC_CHECK_HEADERS([stdlib.h string.h])
-
-dnl Checks for typedefs, structures, and compiler characteristics.
-AC_C_CONST
-AC_TYPE_SIZE_T
-
-AC_CONFIG_FILES([Makefile portSMF.pc portSMF-uninstalled.pc])
-
-AC_OUTPUT
-
-echo ""
-echo "Run 'configure --help' for an explanation of the possible options,"
-echo "otherwise run 'make' to build portSMF."
-
-dnl Indentation settings for Vim and Emacs and unique identifier for Arch, a
-dnl version control system. Please do not modify past this point.
-# Local Variables:
-# c-basic-offset: 3
-# indent-tabs-mode: nil
-# End:
-#
-# vim: et sts=3 sw=3
+dnl
+dnl portSMF configure.in script - version not using libtool
+dnl
+dnl Joshua Haberman
+dnl Dominic Mazzoni
+dnl Richard Ash
+dnl
+
+dnl
+dnl Instructions: to create "configure" from "configure.in", run:
+dnl aclocal
+dnl autoconf
+
+dnl Process this file with autoconf to produce a configure script.
+
+dnl Require autoconf >= 2.61
+AC_PREREQ(2.61)
+
+dnl Init autoconf and automake
+AC_INIT([portSMF],[0.1])
+dnl check that we have some source code
+AC_CONFIG_SRCDIR([allegro.h])
+dnl keep autools files in a subdirectory
+AC_CONFIG_AUX_DIR(autotools)
+# which also contains a subdir containing macros
+AC_CONFIG_MACRO_DIR([autotools/m4])
+dnl set up automake
+AM_INIT_AUTOMAKE([-Wall foreign])
+dnl Audacity policy: don't enable automatic rebuild of configure et al if 
+dnl sources change
+AM_MAINTAINER_MODE([enabled])
+
+dnl -------------------------------------------------------
+dnl Checks for programs.
+dnl -------------------------------------------------------
+dnl save $CFLAGS etc. since AC_PROG_CC likes to insert "-g -O2"
+dnl if $CFLAGS is blank and it finds GCC
+cflags_save="$CFLAGS"
+cppflags_save="$CPPFLAGS"
+cxxflags_save="$CXXFLAGS"
+AC_PROG_CC
+AC_LANG([C++])
+AC_PROG_CXX
+AC_PROG_CXXCPP
+CFLAGS="$cflags_save"
+CPPFLAGS="$cppflags_save"
+CXXFLAGS="$cxxflags_save"
+
+dnl we will need an "install" program to be available
+AC_PROG_INSTALL
+dnl and ranlib for static libraries
+AC_PROG_RANLIB
+
+dnl Make the install prefix available to the program so that the pkg-config file
+dnl can be created correctly
+AC_PREFIX_DEFAULT(/usr/local)
+if [[ $prefix = "NONE" ]] ; then
+  AC_DEFINE(INSTALL_PREFIX, "/usr/local",
+      [define as prefix where Audacity is installed])
+else
+  AC_DEFINE_UNQUOTED(INSTALL_PREFIX, "$prefix")
+fi
+
+dnl Build Options
+
+AC_ARG_ENABLE(debug,
+            [AS_HELP_STRING([--enable-debug],
+                            [enable debug support [default=no]])],
+            debug_preference="$enableval",
+            debug_preference="no")
+
+dnl ----------------------------------------------------
+dnl If user asked for debug, put debug in compiler flags
+dnl ----------------------------------------------------
+
+if test x"$debug_preference" = "xyes" ; then
+   dnl we want debuging on
+   AC_MSG_NOTICE([Adding -g for debugging to CFLAGS and CXXFLAGS ...])
+   CFLAGS="${CFLAGS} -g "
+   CXXFLAGS="${CXXFLAGS} -g "
+fi
+
+dnl --------------------------------------------------------------------------
+dnl We would like warnings enabled on the builds, but different compilers need
+dnl different options for these. This bit tries to work out what flags we 
+dnl should add to the compiler we are using.
+dnl --------------------------------------------------------------------------
+
+dnl Strict prototypes flags for C (only C because doesn't work for C++)
+AX_CFLAGS_STRICT_PROTOTYPES(CFLAGS)
+
+dnl Sensible warnings for C
+AX_CFLAGS_WARN_ALL(wall_flags)
+CFLAGS="${CFLAGS} $wall_flags"
+dnl try and use it on C++ as well
+AX_CXX_CHECK_FLAG([$wall_flags], [[int foo;]], [[foo = 1;]], cxx_does_wall="yes", cxx_does_wall="no")
+if test "x$cxx_does_wall" = "xyes" ; then
+   dnl can use all warnings flag on the C++ compiler
+   CXXFLAGS="${CXXFLAGS} $wall_flags"
+fi
+AX_CXXCPP_CHECK_FLAG([$wall_flags], [[int foo;]], [[foo = 1;]], cpp_does_wall="yes", cpp_does_wall="no")
+if test "x$cpp_does_wall" = "xyes" ; then
+   dnl can use all warnings flag on the C++ pre-processor
+   CPPFLAGS="${CPPFLAGS} $wall_flags"
+fi
+
+dnl --- check for required libraries ---
+dnl system libraries
+AC_CHECK_FUNCS([strchr memmove])
+AC_FUNC_MALLOC
+AC_HEADER_STDBOOL
+
+dnl Checks for header files.
+AC_HEADER_STDC
+AC_CHECK_HEADERS([stdlib.h string.h])
+
+dnl Checks for typedefs, structures, and compiler characteristics.
+AC_C_CONST
+AC_TYPE_SIZE_T
+
+AC_CONFIG_FILES([Makefile portSMF.pc portSMF-uninstalled.pc])
+
+AC_OUTPUT
+
+echo ""
+echo "Run 'configure --help' for an explanation of the possible options,"
+echo "otherwise run 'make' to build portSMF."
+
+dnl Indentation settings for Vim and Emacs and unique identifier for Arch, a
+dnl version control system. Please do not modify past this point.
+# Local Variables:
+# c-basic-offset: 3
+# indent-tabs-mode: nil
+# End:
+#
+# vim: et sts=3 sw=3
diff --git a/mfmidi.cpp b/mfmidi.cpp
index eba292f..6aa2529 100755
--- a/mfmidi.cpp
+++ b/mfmidi.cpp
@@ -1,486 +1,486 @@
-/*
- * Read a Standard MIDI File.  Externally-assigned function pointers are
- * called upon recognizing things in the file.  See midifile(3).
- */
-
-/*****************************************************************************
-*       Change Log
-*       Date    | who : Change
-*-----------+-----------------------------------------------------------------
-*  2-Mar-92 | GWL : created changelog; MIDIFILE_ERROR to satisfy compiler
-*****************************************************************************/
-
-#include "stdio.h"
-#include "mfmidi.h"
-#include "string.h"
-#include "assert.h"
-
-#define MIDIFILE_ERROR -1
-
-/* public stuff */
-extern int abort_flag;
-
-
-void Midifile_reader::midifile()
-{
-    int ntrks;
-    midifile_error = 0;
-
-    ntrks = readheader();
-    if (midifile_error) return;
-    if (ntrks <= 0) {
-        mferror("No tracks!");
-        /* no need to return since midifile_error is set */
-    }
-    while (ntrks-- > 0 && !midifile_error) readtrack();
-}
-
-int Midifile_reader::readmt(char *s, int skip)
-    /* read through the "MThd" or "MTrk" header string */
-    /* if skip == 1, we attempt to skip initial garbage. */
-{
-    assert(strlen(s) == 4); // must be "MThd" or "MTrk"
-    int nread = 0;
-    char b[4];
-    char buff[32];
-    int c;
-    char *errmsg = "expecting ";
-
-    retry:
-    while ( nread<4 ) {
-        c = Mf_getc();
-        if ( c == EOF ) {
-            errmsg = "EOF while expecting ";
-            goto err;
-        }
-        b[nread++] = c;
-    }
-    /* See if we found the 4 characters we're looking for */
-    if ( s[0]==b[0] && s[1]==b[1] && s[2]==b[2] && s[3]==b[3] )
-        return(0);
-    if ( skip ) {
-        /* If we are supposed to skip initial garbage, */
-        /* try again with the next character. */
-        b[0]=b[1];
-        b[1]=b[2];
-        b[2]=b[3];
-        nread = 3;
-        goto retry;
-    }
-    err:
-#pragma warning(disable: 4996) // strcpy is safe since strings have known lengths
-    (void) strcpy(buff,errmsg);
-    (void) strcat(buff,s);
-#pragma warning(default: 4996) // turn it back on
-    mferror(buff);
-    return(0);
-}
-
-int Midifile_reader::egetc()
-    /* read a single character and abort on EOF */
-{
-    int c = Mf_getc();
-
-    if ( c == EOF ) {
-        mferror("premature EOF");
-        return EOF;
-    }
-    Mf_toberead--;
-    return(c);
-}
-
-int Midifile_reader::readheader()
-    /* read a header chunk */
-{
-    int format, ntrks, division;
-
-    if ( readmt("MThd",Mf_skipinit) == EOF )
-        return(0);
-
-    Mf_toberead = read32bit();
-    if (midifile_error) return MIDIFILE_ERROR;
-    format = read16bit();
-    if (midifile_error) return MIDIFILE_ERROR;
-    ntrks = read16bit();
-    if (midifile_error) return MIDIFILE_ERROR;
-    division = read16bit();
-    if (midifile_error) return MIDIFILE_ERROR;
-
-    Mf_header(format,ntrks,division);
-
-    /* flush any extra stuff, in case the length of header is not 6 */
-    while ( Mf_toberead > 0 && !midifile_error)
-        (void) egetc();
-    return(ntrks);
-}
-
-void Midifile_reader::readtrack()
-    /* read a track chunk */
-{
-    /* This array is indexed by the high half of a status byte.  It's */
-    /* value is either the number of bytes needed (1 or 2) for a channel */
-    /* message, or 0 (meaning it's not  a channel message). */
-    static int chantype[] = {
-        0, 0, 0, 0, 0, 0, 0, 0,       /* 0x00 through 0x70 */
-        2, 2, 2, 2, 1, 1, 2, 0        /* 0x80 through 0xf0 */
-    };
-    long lookfor, lng;
-    int c, c1, type;
-    int sysexcontinue = 0;  /* 1 if last message was an unfinished sysex */
-    int running = 0;        /* 1 when running status used */
-    int status = 0;         /* (possibly running) status byte */
-    int needed;
-
-    if ( readmt("MTrk",0) == EOF )
-        return;
-
-    Mf_toberead = read32bit();
-
-    if (midifile_error) return;
-
-    Mf_currtime = 0L;
-
-    Mf_starttrack();
-
-    while ( Mf_toberead > 0 ) {
-
-        Mf_currtime += readvarinum();   /* delta time */
-        if (midifile_error) return;
-
-        c = egetc();
-       if (midifile_error) return;
-
-        if ( sysexcontinue && c != 0xf7 ) {
-            mferror("didn't find expected continuation of a sysex");
-            return;
-        }
-        if ( (c & 0x80) == 0 ) {        /* running status? */
-            if ( status == 0 ) {
-                mferror("unexpected running status");
-                return;
-            }
-            running = 1;
-       } else {
-            status = c;
-            running = 0;
-        }
-
-        needed = chantype[ (status>>4) & 0xf ];
-
-        if ( needed ) {        /* ie. is it a channel message? */
-
-            if ( running )
-                c1 = c;
-            else {
-                c1 = egetc();
-                if (midifile_error) return;
-            }
-            chanmessage( status, c1, (needed>1) ? egetc() : 0 );
-            if (midifile_error) return;
-            continue;;
-        }
-
-        switch ( c ) {
-
-        case 0xff:                  /* meta event */
-
-            type = egetc();
-            if (midifile_error) return;
-            /* watch out - Don't combine the next 2 statements */
-            lng = readvarinum();
-            if (midifile_error) return;
-            lookfor = Mf_toberead - lng;
-            msginit();
-
-            while ( Mf_toberead > lookfor ) {
-                unsigned char c = egetc();
-                if (midifile_error) return;
-                msgadd(c);
-            }
-            metaevent(type);
-            break;
-
-        case 0xf0:            /* start of system exclusive */
-
-            /* watch out - Don't combine the next 2 statements */
-            lng = readvarinum();
-            if (midifile_error) return;
-            lookfor = Mf_toberead - lng;
-            msginit();
-            msgadd(0xf0);
-
-            while ( Mf_toberead > lookfor ) {
-                c = egetc();
-                if (midifile_error) return;
-                msgadd(c);
-            }
-            if ( c==0xf7 || Mf_nomerge==0 )
-                sysex();
-            else
-                sysexcontinue = 1;  /* merge into next msg */
-            break;
-
-        case 0xf7:     /* sysex continuation or arbitrary stuff */
-
-            /* watch out - Don't combine the next 2 statements */
-            lng = readvarinum();
-            if (midifile_error) return;
-            lookfor = Mf_toberead - lng;
-
-            if ( ! sysexcontinue )
-                msginit();
-
-            while ( Mf_toberead > lookfor ) {
-                c = egetc();
-                if (midifile_error) return;
-                msgadd(c);
-            }
-            if ( ! sysexcontinue ) {
-                    Mf_arbitrary(msgleng(), msg());
-            }
-            else if ( c == 0xf7 ) {
-                sysex();
-                sysexcontinue = 0;
-            }
-            break;
-        default:
-
-            badbyte(c);
-
-            break;
-        }
-    }
-        Mf_endtrack();
-    return;
-}
-
-void Midifile_reader::badbyte(int c)
-{
-    char buff[32];
-#pragma warning(disable: 4996) // safe in this case
-    (void) sprintf(buff,"unexpected byte: 0x%02x",c);
-#pragma warning(default: 4996)
-    mferror(buff);
-}
-
-void Midifile_reader::metaevent(int type)
-{
-    int leng = msgleng();
-    // made this unsigned to avoid sign extend
-    unsigned char *m = msg();
-
-    switch ( type ) {
-    case 0x00:
-        Mf_seqnum(to16bit(m[0],m[1]));
-        break;
-    case 0x01:     /* Text event */
-    case 0x02:     /* Copyright notice */
-    case 0x03:     /* Sequence/Track name */
-    case 0x04:     /* Instrument name */
-    case 0x05:     /* Lyric */
-    case 0x06:     /* Marker */
-    case 0x07:     /* Cue point */
-    case 0x08:
-    case 0x09:
-    case 0x0a:
-    case 0x0b:
-    case 0x0c:
-    case 0x0d:
-    case 0x0e:
-    case 0x0f:
-        /* These are all text events */
-        Mf_text(type,leng,m);
-        break;
-    case 0x20:
-        Mf_chanprefix(m[0]);
-        break;
-    case 0x21:
-        Mf_portprefix(m[0]);
-        break;
-    case 0x2f:     /* End of Track */
-        Mf_eot();
-        break;
-    case 0x51:     /* Set tempo */
-        Mf_tempo(to32bit(0,m[0],m[1],m[2]));
-        break;
-    case 0x54:
-        Mf_smpte(m[0],m[1],m[2],m[3],m[4]);
-        break;
-    case 0x58:
-        Mf_timesig(m[0],m[1],m[2],m[3]);
-        break;
-    case 0x59:
-        Mf_keysig(m[0],m[1]);
-        break;
-    case 0x7f:
-        Mf_sqspecific(leng,m);
-        break;
-    default:
-        Mf_metamisc(type,leng,m);
-    }
-}
-
-
-void Midifile_reader::sysex()
-{
-    Mf_sysex(msgleng(), msg());
-}
-
-
-void Midifile_reader::chanmessage(int status, int c1, int c2)
-{
-    int chan = status & 0xf;
-
-    switch ( status & 0xf0 ) {
-    case NOTEOFF:
-        Mf_off(chan,c1,c2);
-        break;
-    case NOTEON:
-        Mf_on(chan,c1,c2);
-        break;
-    case PRESSURE:
-        Mf_pressure(chan,c1,c2);
-        break;
-    case CONTROLLER:
-        Mf_controller(chan,c1,c2);
-        break;
-    case PITCHBEND:
-        Mf_pitchbend(chan,c1,c2);
-        break;
-    case PROGRAM:
-        Mf_program(chan,c1);
-        break;
-    case CHANPRESSURE:
-        Mf_chanpressure(chan,c1);
-        break;
-    }
-}
-
-/* readvarinum - read a varying-length number, and return the */
-/* number of characters it took. */
-
-long Midifile_reader::readvarinum()
-{
-    long value;
-    int c;
-
-    c = egetc();
-    if (midifile_error) return 0;
-
-    value = (long) c;
-    if ( c & 0x80 ) {
-        value &= 0x7f;
-        do {
-            c = egetc();
-            if (midifile_error) return 0;
-            value = (value << 7) + (c & 0x7f);
-        } while (c & 0x80);
-    }
-    return (value);
-}
-
-long Midifile_reader::to32bit(int c1, int c2, int c3, int c4)
-{
-    long value = 0L;
-
-    value = (c1 & 0xff);
-    value = (value<<8) + (c2 & 0xff);
-    value = (value<<8) + (c3 & 0xff);
-    value = (value<<8) + (c4 & 0xff);
-    return (value);
-}
-
-int Midifile_reader::to16bit(int c1, int c2)
-{
-    return ((c1 & 0xff ) << 8) + (c2 & 0xff);
-}
-
-long Midifile_reader::read32bit()
-{
-    int c1, c2, c3, c4;
-
-    c1 = egetc(); if (midifile_error) return 0;
-    c2 = egetc(); if (midifile_error) return 0;
-    c3 = egetc(); if (midifile_error) return 0;
-    c4 = egetc(); if (midifile_error) return 0;
-    return to32bit(c1,c2,c3,c4);
-}
-
-int Midifile_reader::read16bit()
-{
-    int c1, c2;
-    c1 = egetc(); if (midifile_error) return 0;
-    c2 = egetc(); if (midifile_error) return 0;
-    return to16bit(c1,c2);
-}
-
-void Midifile_reader::mferror(char *s)
-{
-    Mf_error(s);
-    midifile_error = 1;
-}
-
-/* The code below allows collection of a system exclusive message of */
-/* arbitrary length.  The Msgbuff is expanded as necessary.  The only */
-/* visible data/routines are msginit(), msgadd(), msg(), msgleng(). */
-
-#define MSGINCREMENT 128
-
-Midifile_reader::Midifile_reader()
-{
-    Mf_nomerge = 0;
-    Mf_currtime = 0L;
-    Mf_skipinit = 0;
-    Mf_toberead = 0;
-
-    Msgbuff = 0;      /* message buffer */
-    Msgsize = 0;        /* Size of currently allocated Msg */
-    Msgindex = 0;       /* index of next available location in Msg */
-}
-
-void Midifile_reader::finalize()
-{
-    if (Msgbuff) Mf_free(Msgbuff, Msgsize);
-    Msgbuff = NULL;
-}
-
-
-void Midifile_reader::msginit()
-{
-    Msgindex = 0;
-}
-
-unsigned char *Midifile_reader::msg()
-{
-    return(Msgbuff);
-}
-
-int Midifile_reader::msgleng()
-{
-    return(Msgindex);
-}
-
-void Midifile_reader::msgadd(int c)
-{
-    /* If necessary, allocate larger message buffer. */
-    if ( Msgindex >= Msgsize )
-        msgenlarge();
-    Msgbuff[Msgindex++] = c;
-}
-
-void Midifile_reader::msgenlarge()
-{
-    unsigned char *newmess;
-    unsigned char *oldmess = Msgbuff;
-    int oldleng = Msgsize;
-
-    Msgsize += MSGINCREMENT;
-    newmess = (unsigned char *) Mf_malloc((sizeof(unsigned char) * Msgsize) );
-
-    /* copy old message into larger new one */
-    if ( oldmess != 0 ) {
-        memcpy(newmess, oldmess, oldleng);
-        Mf_free(oldmess, oldleng);
-    }
-    Msgbuff = newmess;
-}
+/*
+ * Read a Standard MIDI File.  Externally-assigned function pointers are
+ * called upon recognizing things in the file.  See midifile(3).
+ */
+
+/*****************************************************************************
+*       Change Log
+*       Date    | who : Change
+*-----------+-----------------------------------------------------------------
+*  2-Mar-92 | GWL : created changelog; MIDIFILE_ERROR to satisfy compiler
+*****************************************************************************/
+
+#include "stdio.h"
+#include "mfmidi.h"
+#include "string.h"
+#include "assert.h"
+
+#define MIDIFILE_ERROR -1
+
+/* public stuff */
+extern int abort_flag;
+
+
+void Midifile_reader::midifile()
+{
+    int ntrks;
+    midifile_error = 0;
+
+    ntrks = readheader();
+    if (midifile_error) return;
+    if (ntrks <= 0) {
+        mferror("No tracks!");
+        /* no need to return since midifile_error is set */
+    }
+    while (ntrks-- > 0 && !midifile_error) readtrack();
+}
+
+int Midifile_reader::readmt(char *s, int skip)
+    /* read through the "MThd" or "MTrk" header string */
+    /* if skip == 1, we attempt to skip initial garbage. */
+{
+    assert(strlen(s) == 4); // must be "MThd" or "MTrk"
+    int nread = 0;
+    char b[4];
+    char buff[32];
+    int c;
+    char *errmsg = "expecting ";
+
+    retry:
+    while ( nread<4 ) {
+        c = Mf_getc();
+        if ( c == EOF ) {
+            errmsg = "EOF while expecting ";
+            goto err;
+        }
+        b[nread++] = c;
+    }
+    /* See if we found the 4 characters we're looking for */
+    if ( s[0]==b[0] && s[1]==b[1] && s[2]==b[2] && s[3]==b[3] )
+        return(0);
+    if ( skip ) {
+        /* If we are supposed to skip initial garbage, */
+        /* try again with the next character. */
+        b[0]=b[1];
+        b[1]=b[2];
+        b[2]=b[3];
+        nread = 3;
+        goto retry;
+    }
+    err:
+#pragma warning(disable: 4996) // strcpy is safe since strings have known lengths
+    (void) strcpy(buff,errmsg);
+    (void) strcat(buff,s);
+#pragma warning(default: 4996) // turn it back on
+    mferror(buff);
+    return(0);
+}
+
+int Midifile_reader::egetc()
+    /* read a single character and abort on EOF */
+{
+    int c = Mf_getc();
+
+    if ( c == EOF ) {
+        mferror("premature EOF");
+        return EOF;
+    }
+    Mf_toberead--;
+    return(c);
+}
+
+int Midifile_reader::readheader()
+    /* read a header chunk */
+{
+    int format, ntrks, division;
+
+    if ( readmt("MThd",Mf_skipinit) == EOF )
+        return(0);
+
+    Mf_toberead = read32bit();
+    if (midifile_error) return MIDIFILE_ERROR;
+    format = read16bit();
+    if (midifile_error) return MIDIFILE_ERROR;
+    ntrks = read16bit();
+    if (midifile_error) return MIDIFILE_ERROR;
+    division = read16bit();
+    if (midifile_error) return MIDIFILE_ERROR;
+
+    Mf_header(format,ntrks,division);
+
+    /* flush any extra stuff, in case the length of header is not 6 */
+    while ( Mf_toberead > 0 && !midifile_error)
+        (void) egetc();
+    return(ntrks);
+}
+
+void Midifile_reader::readtrack()
+    /* read a track chunk */
+{
+    /* This array is indexed by the high half of a status byte.  It's */
+    /* value is either the number of bytes needed (1 or 2) for a channel */
+    /* message, or 0 (meaning it's not  a channel message). */
+    static int chantype[] = {
+        0, 0, 0, 0, 0, 0, 0, 0,       /* 0x00 through 0x70 */
+        2, 2, 2, 2, 1, 1, 2, 0        /* 0x80 through 0xf0 */
+    };
+    long lookfor, lng;
+    int c, c1, type;
+    int sysexcontinue = 0;  /* 1 if last message was an unfinished sysex */
+    int running = 0;        /* 1 when running status used */
+    int status = 0;         /* (possibly running) status byte */
+    int needed;
+
+    if ( readmt("MTrk",0) == EOF )
+        return;
+
+    Mf_toberead = read32bit();
+
+    if (midifile_error) return;
+
+    Mf_currtime = 0L;
+
+    Mf_starttrack();
+
+    while ( Mf_toberead > 0 ) {
+
+        Mf_currtime += readvarinum();   /* delta time */
+        if (midifile_error) return;
+
+        c = egetc();
+       if (midifile_error) return;
+
+        if ( sysexcontinue && c != 0xf7 ) {
+            mferror("didn't find expected continuation of a sysex");
+            return;
+        }
+        if ( (c & 0x80) == 0 ) {        /* running status? */
+            if ( status == 0 ) {
+                mferror("unexpected running status");
+                return;
+            }
+            running = 1;
+       } else {
+            status = c;
+            running = 0;
+        }
+
+        needed = chantype[ (status>>4) & 0xf ];
+
+        if ( needed ) {        /* ie. is it a channel message? */
+
+            if ( running )
+                c1 = c;
+            else {
+                c1 = egetc();
+                if (midifile_error) return;
+            }
+            chanmessage( status, c1, (needed>1) ? egetc() : 0 );
+            if (midifile_error) return;
+            continue;;
+        }
+
+        switch ( c ) {
+
+        case 0xff:                  /* meta event */
+
+            type = egetc();
+            if (midifile_error) return;
+            /* watch out - Don't combine the next 2 statements */
+            lng = readvarinum();
+            if (midifile_error) return;
+            lookfor = Mf_toberead - lng;
+            msginit();
+
+            while ( Mf_toberead > lookfor ) {
+                unsigned char c = egetc();
+                if (midifile_error) return;
+                msgadd(c);
+            }
+            metaevent(type);
+            break;
+
+        case 0xf0:            /* start of system exclusive */
+
+            /* watch out - Don't combine the next 2 statements */
+            lng = readvarinum();
+            if (midifile_error) return;
+            lookfor = Mf_toberead - lng;
+            msginit();
+            msgadd(0xf0);
+
+            while ( Mf_toberead > lookfor ) {
+                c = egetc();
+                if (midifile_error) return;
+                msgadd(c);
+            }
+            if ( c==0xf7 || Mf_nomerge==0 )
+                sysex();
+            else
+                sysexcontinue = 1;  /* merge into next msg */
+            break;
+
+        case 0xf7:     /* sysex continuation or arbitrary stuff */
+
+            /* watch out - Don't combine the next 2 statements */
+            lng = readvarinum();
+            if (midifile_error) return;
+            lookfor = Mf_toberead - lng;
+
+            if ( ! sysexcontinue )
+                msginit();
+
+            while ( Mf_toberead > lookfor ) {
+                c = egetc();
+                if (midifile_error) return;
+                msgadd(c);
+            }
+            if ( ! sysexcontinue ) {
+                    Mf_arbitrary(msgleng(), msg());
+            }
+            else if ( c == 0xf7 ) {
+                sysex();
+                sysexcontinue = 0;
+            }
+            break;
+        default:
+
+            badbyte(c);
+
+            break;
+        }
+    }
+        Mf_endtrack();
+    return;
+}
+
+void Midifile_reader::badbyte(int c)
+{
+    char buff[32];
+#pragma warning(disable: 4996) // safe in this case
+    (void) sprintf(buff,"unexpected byte: 0x%02x",c);
+#pragma warning(default: 4996)
+    mferror(buff);
+}
+
+void Midifile_reader::metaevent(int type)
+{
+    int leng = msgleng();
+    // made this unsigned to avoid sign extend
+    unsigned char *m = msg();
+
+    switch ( type ) {
+    case 0x00:
+        Mf_seqnum(to16bit(m[0],m[1]));
+        break;
+    case 0x01:     /* Text event */
+    case 0x02:     /* Copyright notice */
+    case 0x03:     /* Sequence/Track name */
+    case 0x04:     /* Instrument name */
+    case 0x05:     /* Lyric */
+    case 0x06:     /* Marker */
+    case 0x07:     /* Cue point */
+    case 0x08:
+    case 0x09:
+    case 0x0a:
+    case 0x0b:
+    case 0x0c:
+    case 0x0d:
+    case 0x0e:
+    case 0x0f:
+        /* These are all text events */
+        Mf_text(type,leng,m);
+        break;
+    case 0x20:
+        Mf_chanprefix(m[0]);
+        break;
+    case 0x21:
+        Mf_portprefix(m[0]);
+        break;
+    case 0x2f:     /* End of Track */
+        Mf_eot();
+        break;
+    case 0x51:     /* Set tempo */
+        Mf_tempo(to32bit(0,m[0],m[1],m[2]));
+        break;
+    case 0x54:
+        Mf_smpte(m[0],m[1],m[2],m[3],m[4]);
+        break;
+    case 0x58:
+        Mf_timesig(m[0],m[1],m[2],m[3]);
+        break;
+    case 0x59:
+        Mf_keysig(m[0],m[1]);
+        break;
+    case 0x7f:
+        Mf_sqspecific(leng,m);
+        break;
+    default:
+        Mf_metamisc(type,leng,m);
+    }
+}
+
+
+void Midifile_reader::sysex()
+{
+    Mf_sysex(msgleng(), msg());
+}
+
+
+void Midifile_reader::chanmessage(int status, int c1, int c2)
+{
+    int chan = status & 0xf;
+
+    switch ( status & 0xf0 ) {
+    case NOTEOFF:
+        Mf_off(chan,c1,c2);
+        break;
+    case NOTEON:
+        Mf_on(chan,c1,c2);
+        break;
+    case PRESSURE:
+        Mf_pressure(chan,c1,c2);
+        break;
+    case CONTROLLER:
+        Mf_controller(chan,c1,c2);
+        break;
+    case PITCHBEND:
+        Mf_pitchbend(chan,c1,c2);
+        break;
+    case PROGRAM:
+        Mf_program(chan,c1);
+        break;
+    case CHANPRESSURE:
+        Mf_chanpressure(chan,c1);
+        break;
+    }
+}
+
+/* readvarinum - read a varying-length number, and return the */
+/* number of characters it took. */
+
+long Midifile_reader::readvarinum()
+{
+    long value;
+    int c;
+
+    c = egetc();
+    if (midifile_error) return 0;
+
+    value = (long) c;
+    if ( c & 0x80 ) {
+        value &= 0x7f;
+        do {
+            c = egetc();
+            if (midifile_error) return 0;
+            value = (value << 7) + (c & 0x7f);
+        } while (c & 0x80);
+    }
+    return (value);
+}
+
+long Midifile_reader::to32bit(int c1, int c2, int c3, int c4)
+{
+    long value = 0L;
+
+    value = (c1 & 0xff);
+    value = (value<<8) + (c2 & 0xff);
+    value = (value<<8) + (c3 & 0xff);
+    value = (value<<8) + (c4 & 0xff);
+    return (value);
+}
+
+int Midifile_reader::to16bit(int c1, int c2)
+{
+    return ((c1 & 0xff ) << 8) + (c2 & 0xff);
+}
+
+long Midifile_reader::read32bit()
+{
+    int c1, c2, c3, c4;
+
+    c1 = egetc(); if (midifile_error) return 0;
+    c2 = egetc(); if (midifile_error) return 0;
+    c3 = egetc(); if (midifile_error) return 0;
+    c4 = egetc(); if (midifile_error) return 0;
+    return to32bit(c1,c2,c3,c4);
+}
+
+int Midifile_reader::read16bit()
+{
+    int c1, c2;
+    c1 = egetc(); if (midifile_error) return 0;
+    c2 = egetc(); if (midifile_error) return 0;
+    return to16bit(c1,c2);
+}
+
+void Midifile_reader::mferror(char *s)
+{
+    Mf_error(s);
+    midifile_error = 1;
+}
+
+/* The code below allows collection of a system exclusive message of */
+/* arbitrary length.  The Msgbuff is expanded as necessary.  The only */
+/* visible data/routines are msginit(), msgadd(), msg(), msgleng(). */
+
+#define MSGINCREMENT 128
+
+Midifile_reader::Midifile_reader()
+{
+    Mf_nomerge = 0;
+    Mf_currtime = 0L;
+    Mf_skipinit = 0;
+    Mf_toberead = 0;
+
+    Msgbuff = 0;      /* message buffer */
+    Msgsize = 0;        /* Size of currently allocated Msg */
+    Msgindex = 0;       /* index of next available location in Msg */
+}
+
+void Midifile_reader::finalize()
+{
+    if (Msgbuff) Mf_free(Msgbuff, Msgsize);
+    Msgbuff = NULL;
+}
+
+
+void Midifile_reader::msginit()
+{
+    Msgindex = 0;
+}
+
+unsigned char *Midifile_reader::msg()
+{
+    return(Msgbuff);
+}
+
+int Midifile_reader::msgleng()
+{
+    return(Msgindex);
+}
+
+void Midifile_reader::msgadd(int c)
+{
+    /* If necessary, allocate larger message buffer. */
+    if ( Msgindex >= Msgsize )
+        msgenlarge();
+    Msgbuff[Msgindex++] = c;
+}
+
+void Midifile_reader::msgenlarge()
+{
+    unsigned char *newmess;
+    unsigned char *oldmess = Msgbuff;
+    int oldleng = Msgsize;
+
+    Msgsize += MSGINCREMENT;
+    newmess = (unsigned char *) Mf_malloc((sizeof(unsigned char) * Msgsize) );
+
+    /* copy old message into larger new one */
+    if ( oldmess != 0 ) {
+        memcpy(newmess, oldmess, oldleng);
+        Mf_free(oldmess, oldleng);
+    }
+    Msgbuff = newmess;
+}
diff --git a/mfmidi.h b/mfmidi.h
index 4c86202..a7f5c50 100755
--- a/mfmidi.h
+++ b/mfmidi.h
@@ -1,98 +1,98 @@
-#define NOTEOFF 0x80
-#define NOTEON 0x90
-#define PRESSURE 0xa0
-#define CONTROLLER 0xb0
-#define PITCHBEND 0xe0
-#define PROGRAM 0xc0
-#define CHANPRESSURE 0xd0
-
-/* These are the strings used in keynote to identify Standard MIDI File */
-/* meta text messages. */
-
-#define METATEXT                "Text Event"
-#define METACOPYRIGHT           "Copyright Notice"
-#define METASEQUENCE            "Sequence/Track Name"
-#define METAINSTRUMENT          "Instrument Name"
-#define METALYRIC               "Lyric"
-#define METAMARKER              "Marker"
-#define METACUE                 "Cue Point"
-#define METAUNRECOGNIZED        "Unrecognized"
-
-
-class Midifile_reader {
-public:
-    void midifile();
-    int Mf_nomerge; /* 1 => continue'ed system exclusives are */
-				        /* not collapsed. */
-    long Mf_currtime; /* current time in delta-time units */
-    int Mf_skipinit;   /* 1 if initial garbage should be skipped */
-    Midifile_reader();
-	// call finalize() when done or you may leak memory.
-	void finalize();  /* clean up before deletion */
-	// Note: rather than finalize, we should have ~Midifile_reader(),
-	// but at least VC++ complains that there is no Mf_free(), even
-	// though Mf_free is declared as virtual and this is an abstract
-	// class. I don't understand this, so finalize() is a workaround. -RBD
-
-protected:
-    int midifile_error;
-
-    virtual void *Mf_malloc(size_t size) = 0; /* malloc() */
-    virtual void Mf_free(void *obj, size_t size) = 0; /* free() */
-    /* Methods to be called while processing the MIDI file. */
-    virtual void Mf_starttrack() = 0;
-    virtual void Mf_endtrack() = 0;
-    virtual int Mf_getc() = 0;
-    virtual void Mf_chanprefix(int) = 0;
-    virtual void Mf_portprefix(int) = 0;
-    virtual void Mf_eot() = 0;
-    virtual void Mf_error(char *) = 0;
-    virtual void Mf_header(int,int,int) = 0;
-    virtual void Mf_on(int,int,int) = 0;
-    virtual void Mf_off(int,int,int) = 0;
-    virtual void Mf_pressure(int,int,int) = 0;
-    virtual void Mf_controller(int,int,int) = 0;
-    virtual void Mf_pitchbend(int,int,int) = 0;
-    virtual void Mf_program(int,int) = 0;
-    virtual void Mf_chanpressure(int,int) = 0;
-    virtual void Mf_sysex(int,unsigned char*) = 0;
-    virtual void Mf_arbitrary(int,unsigned char*) = 0;
-    virtual void Mf_metamisc(int,int,unsigned char*) = 0;
-    virtual void Mf_seqnum(int) = 0;
-    virtual void Mf_smpte(int,int,int,int,int) = 0;
-    virtual void Mf_timesig(int,int,int,int) = 0;
-    virtual void Mf_tempo(int) = 0;
-    virtual void Mf_keysig(int,int) = 0;
-    virtual void Mf_sqspecific(int,unsigned char*) = 0;
-    virtual void Mf_text(int,int,unsigned char*) = 0;
-
-private:
-    long Mf_toberead;
-
-    long readvarinum();
-    long read32bit();
-    int read16bit();
-    void msgenlarge();
-    unsigned char *msg();
-    int readheader();
-    void readtrack();
-    void sysex();
-    void msginit();
-    int egetc();
-    int msgleng();
-
-    int readmt(char*,int);
-    long to32bit(int,int,int,int);
-    int to16bit(int,int);
-    void mferror(char *);
-    void badbyte(int);
-    void metaevent(int);
-    void msgadd(int);
-    void chanmessage(int,int,int);
-
-    unsigned char *Msgbuff;
-    long Msgsize;
-    long Msgindex;
-};
-
-
+#define NOTEOFF 0x80
+#define NOTEON 0x90
+#define PRESSURE 0xa0
+#define CONTROLLER 0xb0
+#define PITCHBEND 0xe0
+#define PROGRAM 0xc0
+#define CHANPRESSURE 0xd0
+
+/* These are the strings used in keynote to identify Standard MIDI File */
+/* meta text messages. */
+
+#define METATEXT                "Text Event"
+#define METACOPYRIGHT           "Copyright Notice"
+#define METASEQUENCE            "Sequence/Track Name"
+#define METAINSTRUMENT          "Instrument Name"
+#define METALYRIC               "Lyric"
+#define METAMARKER              "Marker"
+#define METACUE                 "Cue Point"
+#define METAUNRECOGNIZED        "Unrecognized"
+
+
+class Midifile_reader {
+public:
+    void midifile();
+    int Mf_nomerge; /* 1 => continue'ed system exclusives are */
+				        /* not collapsed. */
+    long Mf_currtime; /* current time in delta-time units */
+    int Mf_skipinit;   /* 1 if initial garbage should be skipped */
+    Midifile_reader();
+	// call finalize() when done or you may leak memory.
+	void finalize();  /* clean up before deletion */
+	// Note: rather than finalize, we should have ~Midifile_reader(),
+	// but at least VC++ complains that there is no Mf_free(), even
+	// though Mf_free is declared as virtual and this is an abstract
+	// class. I don't understand this, so finalize() is a workaround. -RBD
+
+protected:
+    int midifile_error;
+
+    virtual void *Mf_malloc(size_t size) = 0; /* malloc() */
+    virtual void Mf_free(void *obj, size_t size) = 0; /* free() */
+    /* Methods to be called while processing the MIDI file. */
+    virtual void Mf_starttrack() = 0;
+    virtual void Mf_endtrack() = 0;
+    virtual int Mf_getc() = 0;
+    virtual void Mf_chanprefix(int) = 0;
+    virtual void Mf_portprefix(int) = 0;
+    virtual void Mf_eot() = 0;
+    virtual void Mf_error(char *) = 0;
+    virtual void Mf_header(int,int,int) = 0;
+    virtual void Mf_on(int,int,int) = 0;
+    virtual void Mf_off(int,int,int) = 0;
+    virtual void Mf_pressure(int,int,int) = 0;
+    virtual void Mf_controller(int,int,int) = 0;
+    virtual void Mf_pitchbend(int,int,int) = 0;
+    virtual void Mf_program(int,int) = 0;
+    virtual void Mf_chanpressure(int,int) = 0;
+    virtual void Mf_sysex(int,unsigned char*) = 0;
+    virtual void Mf_arbitrary(int,unsigned char*) = 0;
+    virtual void Mf_metamisc(int,int,unsigned char*) = 0;
+    virtual void Mf_seqnum(int) = 0;
+    virtual void Mf_smpte(int,int,int,int,int) = 0;
+    virtual void Mf_timesig(int,int,int,int) = 0;
+    virtual void Mf_tempo(int) = 0;
+    virtual void Mf_keysig(int,int) = 0;
+    virtual void Mf_sqspecific(int,unsigned char*) = 0;
+    virtual void Mf_text(int,int,unsigned char*) = 0;
+
+private:
+    long Mf_toberead;
+
+    long readvarinum();
+    long read32bit();
+    int read16bit();
+    void msgenlarge();
+    unsigned char *msg();
+    int readheader();
+    void readtrack();
+    void sysex();
+    void msginit();
+    int egetc();
+    int msgleng();
+
+    int readmt(char*,int);
+    long to32bit(int,int,int,int);
+    int to16bit(int,int);
+    void mferror(char *);
+    void badbyte(int);
+    void metaevent(int);
+    void msgadd(int);
+    void chanmessage(int,int,int);
+
+    unsigned char *Msgbuff;
+    long Msgsize;
+    long Msgindex;
+};
+
+
diff --git a/notes.txt b/notes.txt
index f894f5c..ede0432 100755
--- a/notes.txt
+++ b/notes.txt
@@ -1,34 +1,34 @@
-merged track is not in order
-
-notes:
-75 bpm @ beat 0
-150 bpm @ beat 1 @ time 0.8
-100 bpm @ beat 2 @ time 1.2
-300 bpm @ beat 3 @ time 1.8
-
-units are beats
-
-...output...
-#track 0
-TW0 -tempor:75
-TW0.25 -tempor:150
-TW0.5 -tempor:100
-TW0.75 -tempor:300
-TW0 V0 -attackr:0.007
-TW0 V0 K63 P63 Q1 L105
-TW0.25 V0 K65 P65 Q1 L107
-TW0.5 V0 K67 P67 Q1 L107
-TW0.75 V0 K69 P69 Q1 L109
-Writing MIDI file...
-track_len 64
-Done
-#track 0
-TW0 -tempor:75
-TW0.25 -tempor:150
-TW0.5 -tempor:100
-TW3 -tempor:300
-TW0 V0 K63 P63 Q0.8 L105
-TW0.2 V0 K65 P65 Q0.4 L107
-TW0.3 V0 K67 P67 Q0.6 L107
-TW0.45 V0 K69 P69 Q0.2 L109
-done, type return to exit
+merged track is not in order
+
+notes:
+75 bpm @ beat 0
+150 bpm @ beat 1 @ time 0.8
+100 bpm @ beat 2 @ time 1.2
+300 bpm @ beat 3 @ time 1.8
+
+units are beats
+
+...output...
+#track 0
+TW0 -tempor:75
+TW0.25 -tempor:150
+TW0.5 -tempor:100
+TW0.75 -tempor:300
+TW0 V0 -attackr:0.007
+TW0 V0 K63 P63 Q1 L105
+TW0.25 V0 K65 P65 Q1 L107
+TW0.5 V0 K67 P67 Q1 L107
+TW0.75 V0 K69 P69 Q1 L109
+Writing MIDI file...
+track_len 64
+Done
+#track 0
+TW0 -tempor:75
+TW0.25 -tempor:150
+TW0.5 -tempor:100
+TW3 -tempor:300
+TW0 V0 K63 P63 Q0.8 L105
+TW0.2 V0 K65 P65 Q0.4 L107
+TW0.3 V0 K67 P67 Q0.6 L107
+TW0.45 V0 K69 P69 Q0.2 L109
+done, type return to exit
diff --git a/portSMF-uninstalled.pc.in b/portSMF-uninstalled.pc.in
index 716b9f2..7d7806a 100644
--- a/portSMF-uninstalled.pc.in
+++ b/portSMF-uninstalled.pc.in
@@ -1,16 +1,16 @@
-# This pkg-config file lets you use the compiled lib without having to first
-# install it anywhere. Simply put the directory the pkg-config file is in on the
-# PKG_CONFIG_PATH and look for portSMF as normal - the uninstalled file 
-# is prefered to the installed one if both are found
-libdir=@abs_builddir@
-# The library always ends up in the build dir.
-includedir=@abs_srcdir@
-# The headers are always in the source dir
-
-Name: portSMF
-Description: Portmedia Simple Midi File library
-Requires: 
-Version: 0.1
-
-Libs: -L${libdir} -lportSMF @LIBS@
-Cflags: -I${includedir} @CXXFLAGS@
+# This pkg-config file lets you use the compiled lib without having to first
+# install it anywhere. Simply put the directory the pkg-config file is in on the
+# PKG_CONFIG_PATH and look for portSMF as normal - the uninstalled file 
+# is prefered to the installed one if both are found
+libdir=@abs_builddir@
+# The library always ends up in the build dir.
+includedir=@abs_srcdir@
+# The headers are always in the source dir
+
+Name: portSMF
+Description: Portmedia Simple Midi File library
+Requires: 
+Version: 0.1
+
+Libs: -L${libdir} -lportSMF @LIBS@
+Cflags: -I${includedir} @CXXFLAGS@
diff --git a/portSMF.pc.in b/portSMF.pc.in
index f144ad7..cf5c8e0 100644
--- a/portSMF.pc.in
+++ b/portSMF.pc.in
@@ -1,10 +1,10 @@
-libdir=@libdir@
-includedir=@includedir@
-
-Name: portSMF
-Description: Portmedia Simple Midi File library
-Requires: 
-Version: 0.1
-
-Libs: -L${libdir} -lportSMF @LIBS@
-Cflags: -I${includedir} @CXXFLAGS@
+libdir=@libdir@
+includedir=@includedir@
+
+Name: portSMF
+Description: Portmedia Simple Midi File library
+Requires: 
+Version: 0.1
+
+Libs: -L${libdir} -lportSMF @LIBS@
+Cflags: -I${includedir} @CXXFLAGS@
diff --git a/portsmf-VC8.sln b/portsmf-VC8.sln
index e76f873..1c5f2db 100644
--- a/portsmf-VC8.sln
+++ b/portsmf-VC8.sln
@@ -1,29 +1,29 @@
-
-Microsoft Visual Studio Solution File, Format Version 9.00
-# Visual C++ Express 2005
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "portsmf", "portsmf-VC8.vcproj", "{D035BCF8-CF15-4456-A4E1-C7E6ACD79346}"
-EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "portsmf_test", "portsmf_test\portsmf_test-VC8.vcproj", "{AF00107F-E436-4EBC-A1F3-CB176E7D1F84}"
-	ProjectSection(ProjectDependencies) = postProject
-		{D035BCF8-CF15-4456-A4E1-C7E6ACD79346} = {D035BCF8-CF15-4456-A4E1-C7E6ACD79346}
-	EndProjectSection
-EndProject
-Global
-	GlobalSection(SolutionConfigurationPlatforms) = preSolution
-		Debug|Win32 = Debug|Win32
-		Release|Win32 = Release|Win32
-	EndGlobalSection
-	GlobalSection(ProjectConfigurationPlatforms) = postSolution
-		{D035BCF8-CF15-4456-A4E1-C7E6ACD79346}.Debug|Win32.ActiveCfg = Debug|Win32
-		{D035BCF8-CF15-4456-A4E1-C7E6ACD79346}.Debug|Win32.Build.0 = Debug|Win32
-		{D035BCF8-CF15-4456-A4E1-C7E6ACD79346}.Release|Win32.ActiveCfg = Release|Win32
-		{D035BCF8-CF15-4456-A4E1-C7E6ACD79346}.Release|Win32.Build.0 = Release|Win32
-		{AF00107F-E436-4EBC-A1F3-CB176E7D1F84}.Debug|Win32.ActiveCfg = Debug|Win32
-		{AF00107F-E436-4EBC-A1F3-CB176E7D1F84}.Debug|Win32.Build.0 = Debug|Win32
-		{AF00107F-E436-4EBC-A1F3-CB176E7D1F84}.Release|Win32.ActiveCfg = Release|Win32
-		{AF00107F-E436-4EBC-A1F3-CB176E7D1F84}.Release|Win32.Build.0 = Release|Win32
-	EndGlobalSection
-	GlobalSection(SolutionProperties) = preSolution
-		HideSolutionNode = FALSE
-	EndGlobalSection
-EndGlobal
+
+Microsoft Visual Studio Solution File, Format Version 9.00
+# Visual C++ Express 2005
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "portsmf", "portsmf-VC8.vcproj", "{D035BCF8-CF15-4456-A4E1-C7E6ACD79346}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "portsmf_test", "portsmf_test\portsmf_test-VC8.vcproj", "{AF00107F-E436-4EBC-A1F3-CB176E7D1F84}"
+	ProjectSection(ProjectDependencies) = postProject
+		{D035BCF8-CF15-4456-A4E1-C7E6ACD79346} = {D035BCF8-CF15-4456-A4E1-C7E6ACD79346}
+	EndProjectSection
+EndProject
+Global
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Debug|Win32 = Debug|Win32
+		Release|Win32 = Release|Win32
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{D035BCF8-CF15-4456-A4E1-C7E6ACD79346}.Debug|Win32.ActiveCfg = Debug|Win32
+		{D035BCF8-CF15-4456-A4E1-C7E6ACD79346}.Debug|Win32.Build.0 = Debug|Win32
+		{D035BCF8-CF15-4456-A4E1-C7E6ACD79346}.Release|Win32.ActiveCfg = Release|Win32
+		{D035BCF8-CF15-4456-A4E1-C7E6ACD79346}.Release|Win32.Build.0 = Release|Win32
+		{AF00107F-E436-4EBC-A1F3-CB176E7D1F84}.Debug|Win32.ActiveCfg = Debug|Win32
+		{AF00107F-E436-4EBC-A1F3-CB176E7D1F84}.Debug|Win32.Build.0 = Debug|Win32
+		{AF00107F-E436-4EBC-A1F3-CB176E7D1F84}.Release|Win32.ActiveCfg = Release|Win32
+		{AF00107F-E436-4EBC-A1F3-CB176E7D1F84}.Release|Win32.Build.0 = Release|Win32
+	EndGlobalSection
+	GlobalSection(SolutionProperties) = preSolution
+		HideSolutionNode = FALSE
+	EndGlobalSection
+EndGlobal
diff --git a/portsmf-VC8.vcproj b/portsmf-VC8.vcproj
index 9e9bde2..4838794 100644
--- a/portsmf-VC8.vcproj
+++ b/portsmf-VC8.vcproj
@@ -1,213 +1,213 @@
-<?xml version="1.0" encoding="Windows-1252"?>
-<VisualStudioProject
-	ProjectType="Visual C++"
-	Version="8.00"
-	Name="portsmf"
-	ProjectGUID="{D035BCF8-CF15-4456-A4E1-C7E6ACD79346}"
-	RootNamespace="allegro"
-	Keyword="Win32Proj"
-	>
-	<Platforms>
-		<Platform
-			Name="Win32"
-		/>
-	</Platforms>
-	<ToolFiles>
-	</ToolFiles>
-	<Configurations>
-		<Configuration
-			Name="Debug|Win32"
-			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
-			IntermediateDirectory="$(ConfigurationName)"
-			ConfigurationType="4"
-			CharacterSet="1"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				PreprocessorDefinitions="WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_DEPRECATE"
-				MinimalRebuild="true"
-				BasicRuntimeChecks="3"
-				RuntimeLibrary="3"
-				UsePrecompiledHeader="0"
-				WarningLevel="0"
-				Detect64BitPortabilityProblems="true"
-				DebugInformationFormat="4"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLibrarianTool"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|Win32"
-			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
-			IntermediateDirectory="$(ConfigurationName)"
-			ConfigurationType="4"
-			CharacterSet="1"
-			WholeProgramOptimization="1"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				PreprocessorDefinitions="WIN32;NDEBUG;_LIB"
-				RuntimeLibrary="2"
-				UsePrecompiledHeader="0"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="true"
-				DebugInformationFormat="3"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLibrarianTool"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-	</Configurations>
-	<References>
-	</References>
-	<Files>
-		<Filter
-			Name="Source Files"
-			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
-			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
-			>
-			<File
-				RelativePath=".\allegro.cpp"
-				>
-			</File>
-			<File
-				RelativePath=".\allegrord.cpp"
-				>
-			</File>
-			<File
-				RelativePath=".\allegrosmfrd.cpp"
-				>
-			</File>
-			<File
-				RelativePath=".\allegrosmfwr.cpp"
-				>
-			</File>
-			<File
-				RelativePath=".\allegrowr.cpp"
-				>
-			</File>
-			<File
-				RelativePath=".\mfmidi.cpp"
-				>
-			</File>
-			<File
-				RelativePath=".\strparse.cpp"
-				>
-			</File>
-			<File
-				RelativePath=".\trace.cpp"
-				>
-			</File>
-		</Filter>
-		<Filter
-			Name="Header Files"
-			Filter="h;hpp;hxx;hm;inl;inc;xsd"
-			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
-			>
-			<File
-				RelativePath=".\allegro.h"
-				>
-			</File>
-			<File
-				RelativePath=".\mfmidi.h"
-				>
-			</File>
-			<File
-				RelativePath=".\strparse.h"
-				>
-			</File>
-			<File
-				RelativePath=".\trace.h"
-				>
-			</File>
-		</Filter>
-		<Filter
-			Name="Resource Files"
-			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav"
-			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}"
-			>
-		</Filter>
-	</Files>
-	<Globals>
-	</Globals>
-</VisualStudioProject>
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="8.00"
+	Name="portsmf"
+	ProjectGUID="{D035BCF8-CF15-4456-A4E1-C7E6ACD79346}"
+	RootNamespace="allegro"
+	Keyword="Win32Proj"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="4"
+			CharacterSet="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				PreprocessorDefinitions="WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_DEPRECATE"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				UsePrecompiledHeader="0"
+				WarningLevel="0"
+				Detect64BitPortabilityProblems="true"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="4"
+			CharacterSet="1"
+			WholeProgramOptimization="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				PreprocessorDefinitions="WIN32;NDEBUG;_LIB"
+				RuntimeLibrary="2"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="true"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
+			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
+			>
+			<File
+				RelativePath=".\allegro.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\allegrord.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\allegrosmfrd.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\allegrosmfwr.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\allegrowr.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\mfmidi.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\strparse.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\trace.cpp"
+				>
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl;inc;xsd"
+			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
+			>
+			<File
+				RelativePath=".\allegro.h"
+				>
+			</File>
+			<File
+				RelativePath=".\mfmidi.h"
+				>
+			</File>
+			<File
+				RelativePath=".\strparse.h"
+				>
+			</File>
+			<File
+				RelativePath=".\trace.h"
+				>
+			</File>
+		</Filter>
+		<Filter
+			Name="Resource Files"
+			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav"
+			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}"
+			>
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff --git a/portsmf.sln b/portsmf.sln
index 174208b..245f000 100644
--- a/portsmf.sln
+++ b/portsmf.sln
@@ -1,35 +1,35 @@
-
-Microsoft Visual Studio Solution File, Format Version 10.00
-# Visual C++ Express 2008
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "portsmf", "portsmf.vcproj", "{D035BCF8-CF15-4456-A4E1-C7E6ACD79346}"
-EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "portsmf_test", "portsmf_test\portsmf_test.vcproj", "{AF00107F-E436-4EBC-A1F3-CB176E7D1F84}"
-	ProjectSection(ProjectDependencies) = postProject
-		{D035BCF8-CF15-4456-A4E1-C7E6ACD79346} = {D035BCF8-CF15-4456-A4E1-C7E6ACD79346}
-	EndProjectSection
-EndProject
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "allegroconvert", "apps\allegroconvert.vcproj", "{3CF9F99C-ADB3-4CD2-A6F9-2472C2083324}"
-EndProject
-Global
-	GlobalSection(SolutionConfigurationPlatforms) = preSolution
-		Debug|Win32 = Debug|Win32
-		Release|Win32 = Release|Win32
-	EndGlobalSection
-	GlobalSection(ProjectConfigurationPlatforms) = postSolution
-		{D035BCF8-CF15-4456-A4E1-C7E6ACD79346}.Debug|Win32.ActiveCfg = Debug|Win32
-		{D035BCF8-CF15-4456-A4E1-C7E6ACD79346}.Debug|Win32.Build.0 = Debug|Win32
-		{D035BCF8-CF15-4456-A4E1-C7E6ACD79346}.Release|Win32.ActiveCfg = Release|Win32
-		{D035BCF8-CF15-4456-A4E1-C7E6ACD79346}.Release|Win32.Build.0 = Release|Win32
-		{AF00107F-E436-4EBC-A1F3-CB176E7D1F84}.Debug|Win32.ActiveCfg = Debug|Win32
-		{AF00107F-E436-4EBC-A1F3-CB176E7D1F84}.Debug|Win32.Build.0 = Debug|Win32
-		{AF00107F-E436-4EBC-A1F3-CB176E7D1F84}.Release|Win32.ActiveCfg = Release|Win32
-		{AF00107F-E436-4EBC-A1F3-CB176E7D1F84}.Release|Win32.Build.0 = Release|Win32
-		{3CF9F99C-ADB3-4CD2-A6F9-2472C2083324}.Debug|Win32.ActiveCfg = Debug|Win32
-		{3CF9F99C-ADB3-4CD2-A6F9-2472C2083324}.Debug|Win32.Build.0 = Debug|Win32
-		{3CF9F99C-ADB3-4CD2-A6F9-2472C2083324}.Release|Win32.ActiveCfg = Debug|Win32
-		{3CF9F99C-ADB3-4CD2-A6F9-2472C2083324}.Release|Win32.Build.0 = Debug|Win32
-	EndGlobalSection
-	GlobalSection(SolutionProperties) = preSolution
-		HideSolutionNode = FALSE
-	EndGlobalSection
-EndGlobal
+
+Microsoft Visual Studio Solution File, Format Version 10.00
+# Visual C++ Express 2008
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "portsmf", "portsmf.vcproj", "{D035BCF8-CF15-4456-A4E1-C7E6ACD79346}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "portsmf_test", "portsmf_test\portsmf_test.vcproj", "{AF00107F-E436-4EBC-A1F3-CB176E7D1F84}"
+	ProjectSection(ProjectDependencies) = postProject
+		{D035BCF8-CF15-4456-A4E1-C7E6ACD79346} = {D035BCF8-CF15-4456-A4E1-C7E6ACD79346}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "allegroconvert", "apps\allegroconvert.vcproj", "{3CF9F99C-ADB3-4CD2-A6F9-2472C2083324}"
+EndProject
+Global
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Debug|Win32 = Debug|Win32
+		Release|Win32 = Release|Win32
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{D035BCF8-CF15-4456-A4E1-C7E6ACD79346}.Debug|Win32.ActiveCfg = Debug|Win32
+		{D035BCF8-CF15-4456-A4E1-C7E6ACD79346}.Debug|Win32.Build.0 = Debug|Win32
+		{D035BCF8-CF15-4456-A4E1-C7E6ACD79346}.Release|Win32.ActiveCfg = Release|Win32
+		{D035BCF8-CF15-4456-A4E1-C7E6ACD79346}.Release|Win32.Build.0 = Release|Win32
+		{AF00107F-E436-4EBC-A1F3-CB176E7D1F84}.Debug|Win32.ActiveCfg = Debug|Win32
+		{AF00107F-E436-4EBC-A1F3-CB176E7D1F84}.Debug|Win32.Build.0 = Debug|Win32
+		{AF00107F-E436-4EBC-A1F3-CB176E7D1F84}.Release|Win32.ActiveCfg = Release|Win32
+		{AF00107F-E436-4EBC-A1F3-CB176E7D1F84}.Release|Win32.Build.0 = Release|Win32
+		{3CF9F99C-ADB3-4CD2-A6F9-2472C2083324}.Debug|Win32.ActiveCfg = Debug|Win32
+		{3CF9F99C-ADB3-4CD2-A6F9-2472C2083324}.Debug|Win32.Build.0 = Debug|Win32
+		{3CF9F99C-ADB3-4CD2-A6F9-2472C2083324}.Release|Win32.ActiveCfg = Debug|Win32
+		{3CF9F99C-ADB3-4CD2-A6F9-2472C2083324}.Release|Win32.Build.0 = Debug|Win32
+	EndGlobalSection
+	GlobalSection(SolutionProperties) = preSolution
+		HideSolutionNode = FALSE
+	EndGlobalSection
+EndGlobal
diff --git a/portsmf.vcproj b/portsmf.vcproj
index 8f6d864..efb1e3d 100644
--- a/portsmf.vcproj
+++ b/portsmf.vcproj
@@ -1,214 +1,214 @@
-<?xml version="1.0" encoding="Windows-1252"?>
-<VisualStudioProject
-	ProjectType="Visual C++"
-	Version="9.00"
-	Name="portsmf"
-	ProjectGUID="{D035BCF8-CF15-4456-A4E1-C7E6ACD79346}"
-	RootNamespace="allegro"
-	Keyword="Win32Proj"
-	TargetFrameworkVersion="131072"
-	>
-	<Platforms>
-		<Platform
-			Name="Win32"
-		/>
-	</Platforms>
-	<ToolFiles>
-	</ToolFiles>
-	<Configurations>
-		<Configuration
-			Name="Debug|Win32"
-			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
-			IntermediateDirectory="$(ConfigurationName)"
-			ConfigurationType="4"
-			CharacterSet="1"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				PreprocessorDefinitions="WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_DEPRECATE"
-				MinimalRebuild="true"
-				BasicRuntimeChecks="3"
-				RuntimeLibrary="3"
-				UsePrecompiledHeader="0"
-				WarningLevel="0"
-				Detect64BitPortabilityProblems="false"
-				DebugInformationFormat="4"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLibrarianTool"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|Win32"
-			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
-			IntermediateDirectory="$(ConfigurationName)"
-			ConfigurationType="4"
-			CharacterSet="1"
-			WholeProgramOptimization="1"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				PreprocessorDefinitions="WIN32;NDEBUG;_LIB"
-				RuntimeLibrary="0"
-				UsePrecompiledHeader="0"
-				WarningLevel="3"
-				Detect64BitPortabilityProblems="false"
-				DebugInformationFormat="3"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLibrarianTool"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-	</Configurations>
-	<References>
-	</References>
-	<Files>
-		<Filter
-			Name="Source Files"
-			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
-			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
-			>
-			<File
-				RelativePath=".\allegro.cpp"
-				>
-			</File>
-			<File
-				RelativePath=".\allegrord.cpp"
-				>
-			</File>
-			<File
-				RelativePath=".\allegrosmfrd.cpp"
-				>
-			</File>
-			<File
-				RelativePath=".\allegrosmfwr.cpp"
-				>
-			</File>
-			<File
-				RelativePath=".\allegrowr.cpp"
-				>
-			</File>
-			<File
-				RelativePath=".\mfmidi.cpp"
-				>
-			</File>
-			<File
-				RelativePath=".\strparse.cpp"
-				>
-			</File>
-			<File
-				RelativePath=".\trace.cpp"
-				>
-			</File>
-		</Filter>
-		<Filter
-			Name="Header Files"
-			Filter="h;hpp;hxx;hm;inl;inc;xsd"
-			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
-			>
-			<File
-				RelativePath=".\allegro.h"
-				>
-			</File>
-			<File
-				RelativePath=".\mfmidi.h"
-				>
-			</File>
-			<File
-				RelativePath=".\strparse.h"
-				>
-			</File>
-			<File
-				RelativePath=".\trace.h"
-				>
-			</File>
-		</Filter>
-		<Filter
-			Name="Resource Files"
-			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav"
-			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}"
-			>
-		</Filter>
-	</Files>
-	<Globals>
-	</Globals>
-</VisualStudioProject>
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="9.00"
+	Name="portsmf"
+	ProjectGUID="{D035BCF8-CF15-4456-A4E1-C7E6ACD79346}"
+	RootNamespace="allegro"
+	Keyword="Win32Proj"
+	TargetFrameworkVersion="131072"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="4"
+			CharacterSet="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				PreprocessorDefinitions="WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_DEPRECATE"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				UsePrecompiledHeader="0"
+				WarningLevel="0"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="4"
+			CharacterSet="1"
+			WholeProgramOptimization="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				PreprocessorDefinitions="WIN32;NDEBUG;_LIB"
+				RuntimeLibrary="0"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
+			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
+			>
+			<File
+				RelativePath=".\allegro.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\allegrord.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\allegrosmfrd.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\allegrosmfwr.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\allegrowr.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\mfmidi.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\strparse.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\trace.cpp"
+				>
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl;inc;xsd"
+			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
+			>
+			<File
+				RelativePath=".\allegro.h"
+				>
+			</File>
+			<File
+				RelativePath=".\mfmidi.h"
+				>
+			</File>
+			<File
+				RelativePath=".\strparse.h"
+				>
+			</File>
+			<File
+				RelativePath=".\trace.h"
+				>
+			</File>
+		</Filter>
+		<Filter
+			Name="Resource Files"
+			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav"
+			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}"
+			>
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff --git a/strparse.cpp b/strparse.cpp
index 592a21d..547424e 100755
--- a/strparse.cpp
+++ b/strparse.cpp
@@ -1,87 +1,87 @@
-#include <string>
-#include <cstring>
-// #include <iostream>  -- for debugging (cout)
-#include "ctype.h"
-using namespace std;
-#include "strparse.h"
-
-void String_parse::skip_space()
-{
-    while ((*str)[pos] && isspace((*str)[pos])) {
-        pos = pos + 1;
-    }
-}
-
-
-char String_parse::peek()
-{
-    return (*str)[pos];
-}
-
-
-void String_parse::get_nonspace_quoted(string &field)
-{
-    field.clear();
-    skip_space();
-    bool quoted = false;
-    if ((*str)[pos] == '"') {
-        quoted = true;
-        field.append(1, '"');
-        pos = pos + 1;
-    }
-    while ((*str)[pos] && (quoted || !isspace((*str)[pos]))) {
-        if ((*str)[pos] == '"') {
-            if (quoted) {
-                field.append(1, '"');
-                pos = pos + 1;
-            }
-            return;
-        }
-        if ((*str)[pos] == '\\') {
-            pos = pos + 1;
-        }
-        if ((*str)[pos]) {
-            field.append(1, (*str)[pos]);
-            pos = pos + 1;    
-        }
-    }
-}
-
-
-static const char *const escape_chars[] = {"\\n", "\\t", "\\\\", "\\r", "\\\""};
-
-
-void string_escape(string &result, const char *str, const char *quote)
-{
-    int length = (int) strlen(str);
-    if (quote[0]) {
-        result.append(1, quote[0]);
-    }
-    for (int i = 0; i < length; i++) {
-        if (!isalnum((unsigned char) str[i])) {
-            const char *const chars = "\n\t\\\r\"";
-            const char *const special = strchr(chars, str[i]);
-            if (special) {
-                result.append(escape_chars[special - chars]);
-            } else {
-                result.append(1, str[i]);
-            }
-        } else {
-            result.append(1, str[i]);
-        }
-    }
-    result.append(1, quote[0]);
-}
-
-void String_parse::get_remainder(std::string &field)
-{
-    field.clear();
-    skip_space();
-    int len = str->length() - pos;
-    if ((len > 0) && ((*str)[len - 1] == '\n')) { // if str ends in newline, 
-        len--; // reduce length to ignore newline
-    }
-    field.insert(0, *str, pos, len);
-}
-
-    
+#include <string>
+#include <cstring>
+// #include <iostream>  -- for debugging (cout)
+#include "ctype.h"
+using namespace std;
+#include "strparse.h"
+
+void String_parse::skip_space()
+{
+    while ((*str)[pos] && isspace((*str)[pos])) {
+        pos = pos + 1;
+    }
+}
+
+
+char String_parse::peek()
+{
+    return (*str)[pos];
+}
+
+
+void String_parse::get_nonspace_quoted(string &field)
+{
+    field.clear();
+    skip_space();
+    bool quoted = false;
+    if ((*str)[pos] == '"') {
+        quoted = true;
+        field.append(1, '"');
+        pos = pos + 1;
+    }
+    while ((*str)[pos] && (quoted || !isspace((*str)[pos]))) {
+        if ((*str)[pos] == '"') {
+            if (quoted) {
+                field.append(1, '"');
+                pos = pos + 1;
+            }
+            return;
+        }
+        if ((*str)[pos] == '\\') {
+            pos = pos + 1;
+        }
+        if ((*str)[pos]) {
+            field.append(1, (*str)[pos]);
+            pos = pos + 1;    
+        }
+    }
+}
+
+
+static const char *const escape_chars[] = {"\\n", "\\t", "\\\\", "\\r", "\\\""};
+
+
+void string_escape(string &result, const char *str, const char *quote)
+{
+    int length = (int) strlen(str);
+    if (quote[0]) {
+        result.append(1, quote[0]);
+    }
+    for (int i = 0; i < length; i++) {
+        if (!isalnum((unsigned char) str[i])) {
+            const char *const chars = "\n\t\\\r\"";
+            const char *const special = strchr(chars, str[i]);
+            if (special) {
+                result.append(escape_chars[special - chars]);
+            } else {
+                result.append(1, str[i]);
+            }
+        } else {
+            result.append(1, str[i]);
+        }
+    }
+    result.append(1, quote[0]);
+}
+
+void String_parse::get_remainder(std::string &field)
+{
+    field.clear();
+    skip_space();
+    int len = str->length() - pos;
+    if ((len > 0) && ((*str)[len - 1] == '\n')) { // if str ends in newline, 
+        len--; // reduce length to ignore newline
+    }
+    field.insert(0, *str, pos, len);
+}
+
+    
diff --git a/strparse.h b/strparse.h
index 0c64b07..046b1dd 100755
--- a/strparse.h
+++ b/strparse.h
@@ -1,18 +1,18 @@
-// strparse.h -- header for String_parse class
-
-class String_parse {
-public:
-    int pos;
-    std::string *str;
-    void init(std::string *s) {
-        str = s;
-        pos = 0;
-    }
-    void skip_space();
-    char peek();
-    void get_nonspace_quoted(std::string &field);
-    // get the remaining characters, skipping initial spaces and final return
-    void get_remainder(std::string &field);
-};
-
-void string_escape(std::string &result, const char *s, const char *quote);
+// strparse.h -- header for String_parse class
+
+class String_parse {
+public:
+    int pos;
+    std::string *str;
+    void init(std::string *s) {
+        str = s;
+        pos = 0;
+    }
+    void skip_space();
+    char peek();
+    void get_nonspace_quoted(std::string &field);
+    // get the remaining characters, skipping initial spaces and final return
+    void get_remainder(std::string &field);
+};
+
+void string_escape(std::string &result, const char *s, const char *quote);
diff --git a/todo.txt b/todo.txt
index c55db11..d94c328 100755
--- a/todo.txt
+++ b/todo.txt
@@ -1,4 +1,4 @@
-TODO:
-
-continue translating serpent code (in comments in allegro_test.cpp)
-to C++ and running tests.
+TODO:
+
+continue translating serpent code (in comments in allegro_test.cpp)
+to C++ and running tests.
diff --git a/trace.cpp b/trace.cpp
index 38c050f..5070753 100755
--- a/trace.cpp
+++ b/trace.cpp
@@ -1,25 +1,25 @@
-// trace.cpp -- debugging print function
-//
-// (I think this was created to provide a generic print function
-// for use in non-command-line Windows applications where printf
-// does not work. Currently, it is not used, but kept around for
-// possible debugging needs. -RBD)
-
-#include "stdarg.h"
-#include "stdio.h"
-#include "crtdbg.h"
-
-
-void trace(char *format, ...)
-{
-    char msg[256];
-    va_list args;
-    va_start(args, format);
-    _vsnprintf_s(msg, 256, _TRUNCATE, format, args);
-    va_end(args);
-#ifdef _DEBUG
-    _CrtDbgReport(_CRT_WARN, NULL, NULL, NULL, msg);
-#else
-    printf(msg);
-#endif
-}
+// trace.cpp -- debugging print function
+//
+// (I think this was created to provide a generic print function
+// for use in non-command-line Windows applications where printf
+// does not work. Currently, it is not used, but kept around for
+// possible debugging needs. -RBD)
+
+#include "stdarg.h"
+#include "stdio.h"
+#include "crtdbg.h"
+
+
+void trace(char *format, ...)
+{
+    char msg[256];
+    va_list args;
+    va_start(args, format);
+    _vsnprintf_s(msg, 256, _TRUNCATE, format, args);
+    va_end(args);
+#ifdef _DEBUG
+    _CrtDbgReport(_CRT_WARN, NULL, NULL, NULL, msg);
+#else
+    printf(msg);
+#endif
+}
diff --git a/trace.h b/trace.h
index 5726f0c..52a23a6 100755
--- a/trace.h
+++ b/trace.h
@@ -1,2 +1,2 @@
-void trace(char *format, ...);
-
+void trace(char *format, ...);
+
-- 
2.43.0

