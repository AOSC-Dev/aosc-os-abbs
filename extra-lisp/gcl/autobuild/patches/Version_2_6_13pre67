Description: <short summary of the patch>
 TODO: Put a short summary on the line above and replace this paragraph
 with a longer explanation of this change. Complete the meta-information
 with other relevant fields (see below for details). To make it easier, the
 information below has been extracted from the changelog. Adjust it or drop
 it.
 .
 gcl (2.6.12-76) unstable; urgency=medium
 .
   * Version_2_6_13pre66
Author: Camm Maguire <camm@debian.org>

---
The information above should follow the Patch Tagging Guidelines, please
checkout http://dep.debian.net/deps/dep3/ to learn about the format. Here
are templates for supplementary fields that you might want to add:

Origin: <vendor|upstream|other>, <url of original patch>
Bug: <url in upstream bugtracker>
Bug-Debian: https://bugs.debian.org/<bugnumber>
Bug-Ubuntu: https://launchpad.net/bugs/<bugnumber>
Forwarded: <no|not-needed|url proving that it has been forwarded>
Reviewed-By: <name and email of someone who approved the patch>
Last-Update: 2018-03-26

--- gcl-2.6.12.orig/configure
+++ gcl-2.6.12/configure
@@ -4121,7 +4121,6 @@ $as_echo_n "checking working gprof... "
 		       s390*) enableval="no";;#mcount smashes float args in make_shortfloat 20180313
 		       sh4*)  enableval="no";;
 		       ia64*) enableval="no";;
-		       alpha*) enableval="no";;#write_stub currently depends on t12 set in call
 		       hppa*) enableval="no";;
 		       arm*)  enableval="no";;#FIXME mcount compiled as a 24/22 bit reloc even with -mlong-calls, marginally accessible
 		       aarch64*) enableval="no";;#unreproducible buildd bug 20170824
--- gcl-2.6.12.orig/configure.in
+++ gcl-2.6.12/configure.in
@@ -334,7 +334,6 @@ AC_ARG_ENABLE([gprof],[  --enable-gprof
 		       s390*) enableval="no";;#mcount smashes float args in make_shortfloat 20180313
 		       sh4*)  enableval="no";;
 		       ia64*) enableval="no";;
-		       alpha*) enableval="no";;#write_stub currently depends on t12 set in call
 		       hppa*) enableval="no";;
 		       arm*)  enableval="no";;#FIXME mcount compiled as a 24/22 bit reloc even with -mlong-calls, marginally accessible
 		       aarch64*) enableval="no";;#unreproducible buildd bug 20170824
--- gcl-2.6.12.orig/h/elf64_alpha_reloc.h
+++ gcl-2.6.12/h/elf64_alpha_reloc.h
@@ -1,14 +1,14 @@
     case R_ALPHA_GPDISP:
-      gotoff=(ul)(got+(a>>32)-1);
+      gotoff=(ul)(got+HIGH(a)-1);
       s=gotoff-p;
       store_val(where,MASK(16),(s-(short)s)>>16);
-      store_val((void *)where+(a&MASK(32)),MASK(16),s);
+      store_val((void *)where+LOW(a),MASK(16),s);
       break;
     case R_ALPHA_SREL32:
       store_val(where,MASK(32),s+a-p);
       break;
     case R_ALPHA_GPREL32:
-      store_val(where,MASK(32),s+a-gotoff);
+      store_val(where,MASK(32),s+LOW(a)-(ul)(got+HIGH(a)-1));
       break;
     case R_ALPHA_LITUSE:
     case R_ALPHA_HINT:
@@ -20,8 +20,8 @@
       store_val(where,MASK(32),s+a);
       break;
     case R_ALPHA_LITERAL:
-      s+=a&MASK(32);
-      a=(a>>32)-1;
+      s+=LOW(a);
+      a=HIGH(a)-1;
       if (s>=ggot1 && s<ggote) {
         massert(!write_stub(s,got+a));
       } else 
--- gcl-2.6.12.orig/h/elf64_alpha_reloc_special.h
+++ gcl-2.6.12/h/elf64_alpha_reloc_special.h
@@ -1,10 +1,32 @@
-static ul ggot1,ggote,gotoff;
+static ul ggot1,ggote,gotoff,mcount;
+
+static int
+write_stub_mcount(ul s,ul *gote) {
+
+  unsigned int *goti;
+
+  /*mcount calls written using at register, address not available in stub*/
+  /*mcount guaranteed to be within 32bits*/
+  *gote=(ul)(goti=(void *)(gote+1));
+  *goti++=(0x9<<26)|(0x1b<<21)|(0x1f<<16)|((s-(short)s)>>16); /*ldah	t12,(symhigh)(zero)*/
+  *goti++=(0x8<<26)|(0x1b<<21)|(0x1b<<16)|(s&MASK(16));       /*lda	t12,(symlow)(t12)*/
+  *goti++=(0x29<<26)|(0x1b<<21)|(0x1b<<16)|0;                 /*ldq	t12,0(t12)*/
+  *goti++=(0x1a<<26)|(0x1f<<21)|(0x1b<<16)|0x4000;            /*jsr	zero,(t12),$pc+4*/
+  *goti++=0;                                                  /*halt*/
+  *goti++=0;                                                  /*halt*/
+
+  return 0;
+
+}
 
 static int
 write_stub(ul s,ul *gote) {
 
   unsigned int *goti;
 
+  if (s==mcount)
+    return write_stub_mcount(mcount,gote);
+
   *gote=(ul)(goti=(void *)(gote+2));
   *++gote=s;
   *goti++=(0x29<<26)|(0x1b<<21)|(0x1b<<16)|0xfff8; /*ldq	t12,-8(t12)*/
@@ -35,15 +57,19 @@ static int
 find_special_params(void *v,Shdr *sec1,Shdr *sece,const char *sn,
 		    const char *st1,Sym *ds1,Sym *dse,Sym *sym1,Sym *syme) {
 
+  Sym *sym;
   Shdr *sec;
   Rela *r;
-  void *ve;
+  void *ve,*dst1;
 
   massert((sec=get_section(".got",sec1,sece,sn)));
 
   ggot1=sec->sh_addr;
   ggote=ggot1+sec->sh_size;
 
+  massert(sec=get_section(".dynstr",sec1,sece,sn));/*FIXME pass as parameter*/
+  dst1=v+sec->sh_offset;
+
   massert((sec=get_section(".rel.dyn",sec1,sece,sn))||
 	  (sec=get_section(".rela.dyn",sec1,sece,sn)));
 
@@ -51,13 +77,20 @@ find_special_params(void *v,Shdr *sec1,S
   ve=v+sec->sh_size;
 
   for (r=v;v<ve;v+=sec->sh_entsize,r=v) 
-    if (ELF_R_TYPE(r->r_info) && !ds1[ELF_R_SYM(r->r_info)].st_value)
-      ds1[ELF_R_SYM(r->r_info)].st_value=r->r_offset;
+    if (ELF_R_TYPE(r->r_info) && !(sym=ds1+ELF_R_SYM(r->r_info))->st_value) {
+      sym->st_value=r->r_offset;
+      if (!strncmp("_mcount",dst1+sym->st_name,7))
+	mcount=sym->st_value;
+    }
 
   return 0;
 
 }
 
+#define HIGH(a_) ((a_)>>32)
+#define LOW(a_)  ((a_)&MASK(32))
+#define SET_HIGH(a_,b_) ({ul _a=(a_);(a_)=((b_)<<32)|LOW(_a);})
+
 static int
 label_got_symbols(void *v1,Shdr *sec1,Shdr *sece,Sym *sym1,Sym *syme,const char *st1,const char *sn,ul *gs) {
 
@@ -67,12 +100,18 @@ label_got_symbols(void *v1,Shdr *sec1,Sh
   void *v,*ve;
   ul q,gotp;
 
-  for (sym=sym1;sym<syme;sym++)
-    sym->st_size=0;
+  for (sym=sym1;sym<syme;sym++) {
+    massert(!HIGH(sym->st_value));
+    massert(!HIGH(sym->st_size));
+  }
 
   for (*gs=gotp=0,sec=sec1;sec<sece;sec++)
     if (sec->sh_type==SHT_RELA)
-      for (v=v1+sec->sh_offset,ve=v+sec->sh_size,r=v;v<ve;v+=sec->sh_entsize,r=v)
+      for (v=v1+sec->sh_offset,ve=v+sec->sh_size,r=v;v<ve;v+=sec->sh_entsize,r=v) {
+
+	if (HIGH(r->r_addend))
+	  fprintf(stderr,"zeroing high addend %lx\n",HIGH(r->r_addend));/*never reached fix(Cnil) code, to be eliminated*/
+	SET_HIGH(r->r_addend,0UL);
 
 	switch(ELF_R_TYPE(r->r_info)) {
 
@@ -81,49 +120,60 @@ label_got_symbols(void *v1,Shdr *sec1,Sh
 	  if (!r->r_addend) {
 
 	    sym=sym1+ELF_R_SYM(r->r_info);
-	    q=(gotp-sym->st_size)*sizeof(*gs);
+	    q=(HIGH(sym->st_size)-gotp)*sizeof(*gs);
 
-	    if (!sym->st_size || q!=(short)q) {
-	      sym->st_size=++*gs;
+	    if (!HIGH(sym->st_size) || q!=(short)q) {/*new cached got entry if first or out of range*/
+	      SET_HIGH(sym->st_size,++*gs);
 	      massert(!make_got_room_for_stub(sec1,sece,sym,st1,gs));
 	    }
 
-	    q=sym->st_size;
+	    q=HIGH(sym->st_size);
 
 	  } else
 
 	    q=++*gs;
 
-	  if (r->r_addend>>32)
-	    fprintf(stderr,"zeroing high addend %lx\n",r->r_addend>>32);
-	  r->r_addend&=0xffffffff;
-	  massert((q&0xffffffff)==q);
-	  r->r_addend|=(q<<32);
+	  SET_HIGH(r->r_addend,q);
 
-	  q=(q-gotp)*sizeof(*gs);
+	  q=(q-gotp)*sizeof(*gs);/*check 16bit range gprel address in range*/
 	  massert(q==(short)q);
 
 	  break;
 
 	case R_ALPHA_GPDISP:
 
-	  for (sym=fsym;sym<syme && (sym->st_shndx!=1 || sym->st_value!=r->r_offset);sym++);
+	  for (sym=fsym;sym<syme && (sym->st_shndx!=1 || LOW(sym->st_value)!=r->r_offset);sym++);/*ordered search*/
 
 	  if (sym<syme) {
 	    fsym=sym;
-	    gotp=*gs+1;
+	    SET_HIGH(fsym->st_value,gotp=*gs+1);
 	  }
 
-	  if (r->r_addend>>32)
-	    fprintf(stderr,"zeroing high addend %lx\n",r->r_addend>>32);
-	  r->r_addend&=0xffffffff;
-	  massert((gotp&0xffffffff)==gotp);
-	  r->r_addend|=(gotp<<32);
+	  SET_HIGH(r->r_addend,gotp);
+
+	  break;
+
+	case R_ALPHA_GPREL32:
+
+	  q=LOW(sym1[ELF_R_SYM(r->r_info)].st_value)+r->r_addend;
+
+	  /*unordered search*/
+	  for (sym=sym1;sym<syme && (sym->st_shndx!=1 || LOW(sym->st_value)>q || LOW(sym->st_value)+LOW(sym->st_size)<q);sym++);
+	  massert(sym<syme);
+
+	  SET_HIGH(r->r_addend,HIGH(sym->st_value));
 
 	  break;
 
 	}
 
+      }
+
+  for (sym=sym1;sym<syme;sym++) {
+    SET_HIGH(sym->st_value,0UL);
+    SET_HIGH(sym->st_size,0UL);
+  }
+
   return 0;
   
 }
