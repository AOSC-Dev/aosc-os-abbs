diff -r 563557a923d0 COPYING
--- a/COPYING	Tue Oct 27 11:25:59 2009 -0400
+++ b/COPYING	Fri Feb 22 08:54:29 2013 -0300
@@ -1,4 +1,4 @@
-The ZBar Bar Code Reader is Copyright (C) 2007-2009 Jeff Brown
+The ZBar Bar Code Reader is Copyright (C) 2007-2011 Jeff Brown
  <spadix@users.sourceforge.net>
 The QR Code reader is Copyright (C) 1999-2009 Timothy B. Terriberry
  <tterribe@xiph.org>
diff -r 563557a923d0 ChangeLog
--- a/ChangeLog	Tue Oct 27 11:25:59 2009 -0400
+++ b/ChangeLog	Fri Feb 22 08:54:29 2013 -0300
@@ -1,3 +1,95 @@
+current:
+  * Codabar reliability enhancements
+    - fix missing check
+    - require minimum quality
+    - bump default uncertainty
+  * tweak Codabar bar/space ratio validation
+  * finish Codabar support for python, perl, java and iPhone interfaces
+    - reduce Codabar uncertainty to minimum
+  * add core support for Codabar symbology
+    - TBD: python, perl, java and iPhone interfaces
+  * fix v4l config and build variations (bug #3348888)
+    - thanks to jarekczek for reporting this!
+    - NB v4l1 removed from kernel as of 2.6.38
+  * fix missing python thread initialization (bug #3349199)
+    - thanks to jarekczek for reporting this problem!
+  * fix missing configure check for Python.h (bug #3092663)
+    - thanks to Zoltan Kovacs for reporting this problem!
+  * fix C++ wrapper missing Symbol.quality (bug #3076524)
+    - thanks to Rudy Melli for pointing this out!
+  * fix C++ wrapper bugs (bug #3396068)
+    - thanks to anotheruser1 for reporting this!
+    - add new C++ wrapper test
+  * fix avoid compositing ISBN10 data
+  * add support for GraphicsMagick as ImageMagick alternative
+  * mention xmlto in HACKING (patch #3297039)
+    - thanks to jarekczek for the patch!
+  * disable addons by default until synchronization with main symbol is working
+  * fix image scanner min quality filtering
+  * fix i25 buffer overrun corner case
+  * fix EAN addon enables
+  * fix zbarimg to accept autodetected stdin (lone dash)
+  * fix Qt 4.6.3 compilation error (patch #3178244)
+    - thanks to hrhristov for the patch!
+  * add Python Processor support for request_size interface
+  * fix Python Processor support for GIL, allowing asynchronous scanning
+  * fix jpeg decoder skip handling
+    - thanks to jarekczek for the patch!
+  * rename dprintf macro to avoid conflicts (patch #3128538)
+    - thanks to maurochehab for the patch!
+  * add support for EAN/UPC 2 and 5 digit add-on symbols
+    - deprecate original, unfinished add-on APIs
+    - add self-checking to test_decode
+  * fix support for GS1 AIs
+    - thanks to jockusch for a patch!
+    - add decoder/symbol "modifier" flags and config read access
+    - set flags or emit GS appropriately for Code 128 FNC1
+    - add iphone, java, perl, python bindings for modifiers and configs
+  * add support for Code 93 symbology
+  * add video size request to (Py)GTK widget (req #3034522)
+    - thanks to Jerome Charaoui for the patch!
+  * add support for GS1 DataBar Expanded (RSS Expanded) symbology
+  * add language bindings for DataBar
+  * add preliminary support for GS1 DataBar (RSS-14) symbology
+  * enhance decoder reliability (EAN, Code 39, Code 128)
+    - enhance decoder test
+  * fix documentation of command exit codes (bug #3017322)
+  * fix C++ video callback bug
+    - add C and C++ processor examples
+  * add per-symbology cache consistency
+    - reliable symbologies decode immediately by default
+    - no more need to disable cache with video
+    - also fix crop bugs w/video scanning
+  * add support for scanning partial images (cropping)
+    - update c++, python, perl, java bindings and tests
+  * fix couple of leaks
+  * remove doc hints about GFDL (bug #3004411)
+    - apply LGPL to API docs
+  * relax Code 39 width ratio checks
+  * core library portability improvements
+    - remove some unnecessary C99 syntax
+    - add configure checks for errno
+    - enhance C++ Symbol interface
+  * adjust Python module README (add examples and note DLL in path)
+  * fix QR Code missing from man pages (bug #2969857)
+  * cleanup decoder assertions and locking (bug #2966916)
+  * add Java interface to library via JNI
+    - add Java tools and JNI build tests to configure
+    - fix compiler warnings from binary output changes
+  * fix output of binary data in zbarimg and zbarcam
+    - thanks to fukuchi for a patch!
+    - add base64 format for binary xml output
+  * add coarse symbol orientation information (patch #2913094)
+    - thanks to Anssi for a patch!
+    - add decode direction feedback to decoder
+    - update C++, Python, Perl and ObjC wrappers
+    - add orientation to test suites
+  * fix inconsistent fourcc endian handling bugs (bug #2918994)
+    - thanks to jdccdevel for a patch!
+    - add fourcc conversion and parse interfaces to zbar.h
+  * report QR immediately for video (no inter-frame consistency check)
+  * add python distutils build infrastructure
+
 version 0.10:
   * hotfix add MinGW import lib to Windows installer
   * attempt fix for Qt4 < 4.4
diff -r 563557a923d0 HACKING
--- a/HACKING	Tue Oct 27 11:25:59 2009 -0400
+++ b/HACKING	Fri Feb 22 08:54:29 2013 -0300
@@ -13,6 +13,12 @@
     GNU autoconf 2.61
     GNU automake 1.10.1
     GNU libtool 2.2.6
+    GNU gettext 0.18.1.1
+    GNU pkg-config 0.25
+    xmlto 0.0.20-5 (for docs building)
+all above mentioned tools (except xmlto) must be installed in the same
+prefix. mixing prefixes (i.g. /usr/bin and /usr/local/bin) may lead to
+errors in configuration stages
 
 when you're done hacking and want to make your patch, run:
 
diff -r 563557a923d0 Makefile.am
--- a/Makefile.am	Tue Oct 27 11:25:59 2009 -0400
+++ b/Makefile.am	Fri Feb 22 08:54:29 2013 -0300
@@ -1,6 +1,3 @@
-AM_CPPFLAGS = -I$(srcdir)/include
-AM_CFLAGS = -Wall -Wno-parentheses
-AM_CXXFLAGS = $(AM_CFLAGS)
 ACLOCAL_AMFLAGS = -I config
 bin_PROGRAMS =
 check_PROGRAMS =
@@ -9,8 +6,10 @@
 pyexec_LTLIBRARIES =
 CLEANFILES =
 DISTCLEANFILES =
+MAINTAINERCLEANFILES =
 BUILT_SOURCES =
 EXTRA_DIST =
+SUBDIRS = .
 
 pkgconfigdir = $(libdir)/pkgconfig
 pkgconfig_DATA = zbar.pc
@@ -39,6 +38,9 @@
 include $(srcdir)/qt/Makefile.am.inc
 pkgconfig_DATA += zbar-qt.pc
 endif
+if HAVE_JAVA
+SUBDIRS += java
+endif
 if HAVE_NPAPI
 include $(srcdir)/plugin/Makefile.am.inc
 endif
@@ -47,11 +49,8 @@
 
 EXTRA_DIST += zbar.ico zbar.nsi
 
-EXTRA_DIST += examples/upcrpc.pl examples/upcrpc.py examples/paginate.pl \
-    examples/barcode.png examples/processor.pl examples/processor.py \
-    examples/read_one.py examples/read_one.pl \
-    examples/scan_image.c examples/scan_image.cpp examples/scan_image.pl \
-    examples/scan_image.py examples/scan_image.vcproj
+EXTRA_DIST += examples/barcode.png examples/upcrpc.py examples/upcrpc.pl \
+    examples/scan_image.c examples/scan_image.cpp examples/scan_image.vcproj
 
 EXTRA_DIST += perl/MANIFEST perl/README perl/Changes perl/COPYING.LIB \
     perl/Makefile.PL perl/typemap perl/ZBar.xs perl/ppport.h \
diff -r 563557a923d0 README
--- a/README	Tue Oct 27 11:25:59 2009 -0400
+++ b/README	Fri Feb 22 08:54:29 2013 -0300
@@ -4,9 +4,9 @@
 ZBar Bar Code Reader is an open source software suite for reading bar
 codes from various sources, such as video streams, image files and raw
 intensity sensors. It supports EAN-13/UPC-A, UPC-E, EAN-8, Code 128,
-Code 39, Interleaved 2 of 5 and QR Code.  Included with the library
-are basic applications for decoding captured bar code images and using
-a video device (eg, webcam) as a bar code scanner.  For application
+Code 39, Codabar, Interleaved 2 of 5 and QR Code.  Included with the
+library are basic applications for decoding captured bar code images and
+using a video device (eg, webcam) as a bar code scanner.  For application
 developers, language bindings are included for C, C++, Python and Perl
 as well as GUI widgets for Qt, GTK and PyGTK.
 
diff -r 563557a923d0 README.windows
--- a/README.windows	Tue Oct 27 11:25:59 2009 -0400
+++ b/README.windows	Fri Feb 22 08:54:29 2013 -0300
@@ -3,8 +3,8 @@
 
 ZBar Bar Code Reader is an open source software suite for reading bar codes
 from various sources, such as video streams, image files and raw intensity
-sensors. It supports EAN-13/UPC-A, UPC-E, EAN-8, Code 128, Code 39,
-Interleaved 2 of 5 and QR Code.  Included with the library are basic
+sensors. It supports EAN-13/UPC-A, UPC-E, EAN-8, Code 128, Code 93, Code 39,
+Codabar, Interleaved 2 of 5 and QR Code.  Included with the library are basic
 applications for decoding captured bar code images and using a video device
 (eg, webcam) as a bar code scanner.  For application developers, language
 bindings are included for C, C++, Python and Perl as well as GUI widgets for
diff -r 563557a923d0 TODO
--- a/TODO	Tue Oct 27 11:25:59 2009 -0400
+++ b/TODO	Fri Feb 22 08:54:29 2013 -0300
@@ -25,7 +25,6 @@
   * Code 39, i25 optional features (check digit and ASCII escapes)
   * handle Code 128 function characters (FNC1-4)
   * Code 128 trailing quiet zone checks
-  * finish addon decoding
 
 decoder:
   * start/stop/abort and location detail APIs (PDF417, OMR)
diff -r 563557a923d0 android/AndroidManifest.xml
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/AndroidManifest.xml	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,15 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+      package="net.sourceforge.zbar.android"
+      android:versionCode="1"
+      android:versionName="1.0">
+    <application android:label="@string/app_name" >
+        <activity android:name="ACTIVITY_ENTRY_NAME"
+                  android:label="@string/app_name">
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN" />
+                <category android:name="android.intent.category.LAUNCHER" />
+            </intent-filter>
+        </activity>
+    </application>
+</manifest> 
diff -r 563557a923d0 android/ChangeLog
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/ChangeLog	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,2 @@
+version 0.1:
+  * Add initial support for Android platform
diff -r 563557a923d0 android/README
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/README	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,112 @@
+ZBar Android SDK
+================
+
+ZBar Bar Code Reader is an open source software suite for reading bar
+codes from various sources, such as video streams, image files and raw
+intensity sensors. It supports EAN-13/UPC-A, UPC-E, EAN-8, Code 128,
+Code 93, Code 39, Codabar, Interleaved 2 of 5, QR Code and
+DataBar. These are the JNI wrappers for developing the library on
+Android platform.
+
+Check the ZBar home page for the latest release, mailing lists, etc.
+    http://zbar.sourceforge.net/
+
+Copyright and License
+---------------------
+Licensed under the GNU Lesser General Public License, version 2.1.
+http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt
+
+Copyright 2008-2012 © Jeff Brown <spadix@users.sourceforge.net> et al
+
+The Android distribution also includes pre-compiled binaries of
+supporting libaries, for which copyright, license and source code
+locations are as follows:
+  * The GNU libiconv character set conversion library
+    Copyright (C) 1999-2011 Free Software Foundation, Inc.
+    This distribution includes GNU libiconv version 1.14, licensed under
+    the LGPL version 2.  The source code is available from
+        http://www.gnu.org/software/libiconv
+
+See included files COPYING and LICENSE for details.
+
+
+Installation
+------------
+
+After downloading the ZBar-Android-Lib-<version>.zip file, you need to
+unzip the file and add it to your Android project. Unzip the file
+using your favorite method (ie: command-line, finder, windows
+explorer...)
+
+Follow one of the two options.
+Option 1 - via command line
+  cd <android project>
+  cp -r ZBar-Android-SDK-<version>/libs .
+
+Option 2 - via Eclipse
+  Right click on Android Project
+  Select "Import" -> "File System"
+  Select "Browse" (next to "From directory File" and select the
+    ZBar-Android-SDK-<verion>/libs directory and click "Open".
+  Click the check box next to "libs" and the "Options" "Create top-level folder"
+  check box (below).
+  Then click "Finish".
+      
+  You should then see a "libs" folder under your project.
+
+Building
+--------
+
+Via Eclipse
+You have to add the zbar.jar file to your build path
+  1) select zbar.jar under libs
+  2) right-click, select "Build Path" -> "Add to Build Path"
+  
+Via command-line
+You are all set; ant will automatcially find jar files under the "libs"
+subdirectory.
+
+Documentation
+-------------
+   TDB
+
+Examples
+--------
+
+You should be able to open and build the examples directly from the
+unzipped directory. You will need to run the android tools to setup
+the local.properties file which sets sdk.dir.
+  1) cd <unzip dir>/examples/CameraTest
+  2) android update project --path .
+  3) ant debug install
+
+If you have problems with this, please create a new Android project
+and copy the necessary files from the examples.
+
+examples/CameraTest is a simple demonstration of how to integrate the
+ZBar image scanner with the camera.
+
+Manually building ZBar JNI library
+----------------------------------
+First download and unzip the iconv library source from 
+  http://www.gnu.org/software/libiconv/
+
+Then kick off the build from the ZBar android directory. You will
+need to run the android tools to setup the local.properties file which
+setups sdk.dir.
+
+  1) cd <zbar project>/android
+  2) android update project --path . 
+  3) ant -Dndk.dir=<NDK path> -Diconv.src=<iconv library src> zbar-all
+
+This will rebuild all source files, create zbar.jar and
+ZBarAndroidSDK.zip file (which bundles the jar and shared
+libraries). From here, you can follow the steps for "Integrating ZBar
+JNI library in Android project".
+
+To clean run:
+  ant -Dndk.dir=<NDK path> zbar-clean
+
+See build-ndk.xml for additional target options.
+
+
diff -r 563557a923d0 android/ant.properties
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/ant.properties	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,17 @@
+# This file is used to override default values used by the Ant build system.
+#
+# This file must be checked in Version Control Systems, as it is
+# integral to the build system of your project.
+
+# This file is only used by the Ant script.
+
+# You can use this to override default values such as
+#  'source.dir' for the location of your java source folder and
+#  'out.dir' for the location of your output folder.
+
+# You can also use it define how the release builds are signed by declaring
+# the following properties:
+#  'key.store' for the location of your keystore and
+#  'key.alias' for the name of the key to use.
+# The password will be asked during the build when you use the 'release' target.
+
diff -r 563557a923d0 android/build-ndk.xml
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/build-ndk.xml	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,66 @@
+<!-- 
+Ant build file to compile the ZBar JNI files using Android NDK tool
+targets:
+  zbar-clean     - removes build generated files, build dir, jar and zip files
+  zbar-ndk-build - builds the zbarjni and iconv shared libraries
+  zbar-compile   - builds the zbar java files
+  zbar-jar       - builds and jars the zbar java files
+  zbar-zip       - Creates ZBarAndroidSDK-x.y.zip of jar, .so, etc
+  zbar-all       - performs all the above :)
+-->
+<project name="zbar">
+  <property name="project.name" value="zbar" />
+  <property name="project.sdk.name" value="ZBarAndroidSDK" />
+
+  <target name="zbar-clean">
+      <delete dir="../java/build"/>
+      <delete file="libs/${project.name}.jar"/>
+      <delete file="${ant.project.name}.zip"/>
+      <exec executable="${ndk.dir}/ndk-build" failonerror="true">
+          <arg value="clean"/>
+      </exec>
+  </target>
+
+  <target name="zbar-ndk-build">
+      <exec executable="${ndk.dir}/ndk-build" failonerror="true">
+          <arg value="ICONV_SRC=${iconv.src}" />
+      </exec>
+  </target>
+
+  <target name="zbar-compile" depends="zbar-ndk-build">
+      <mkdir dir="../java/build" />
+      <javac srcdir="../java/net" destdir="../java/build" />
+  </target>
+
+  <target name="zbar-jar" depends="zbar-compile">
+      <jar destfile="libs/${project.name}.jar" basedir="../java/build">
+      </jar>
+  </target>
+
+  <target name="zbar-zip">
+      <if><condition><not><isset property="version"/></not></condition><then>
+         <property name="version" value="0.2" />
+      </then></if>
+      <zip destfile="${project.sdk.name}-${version}.zip" >
+          <zipfileset dir="../" prefix="${project.sdk.name}-${version}" includes="COPYING, LICENSE"/>
+          <zipfileset dir="." prefix="${project.sdk.name}-${version}" includes="README"/>
+          <zipfileset dir="libs" prefix="${project.sdk.name}-${version}/libs"/>
+          <zipfileset dir="examples" prefix="${project.sdk.name}-${version}/examples"/>
+          <zipfileset dir="libs" prefix="${project.sdk.name}-${version}/examples/CameraTest/libs"/>
+      </zip>
+  </target>
+
+  <target name="zbar-all" depends="zbar-jar">
+      <if><condition><not><isset property="version"/></not></condition><then>
+         <property name="version" value="0.2" />
+      </then></if>
+      <zip destfile="${project.sdk.name}-${version}.zip" >
+          <zipfileset dir="../" prefix="${project.sdk.name}-${version}" includes="COPYING, LICENSE"/>
+          <zipfileset dir="." prefix="${project.sdk.name}-${version}" includes="README"/>
+          <zipfileset dir="libs" prefix="${project.sdk.name}-${version}/libs"/>
+          <zipfileset dir="examples" prefix="${project.sdk.name}-${version}/examples"/>
+          <zipfileset dir="libs" prefix="${project.sdk.name}-${version}/examples/CameraTest/libs"/>
+      </zip>
+  </target>
+</project>
+
diff -r 563557a923d0 android/build.xml
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/build.xml	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,86 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project name="ZBarAndroidSDK" default="help">
+
+    <!-- The local.properties file is created and updated by the 'android' tool.
+         It contains the path to the SDK. It should *NOT* be checked into
+         Version Control Systems. -->
+    <property file="local.properties" />
+
+    <!-- The ant.properties file can be created by you. It is only edited by the
+         'android' tool to add properties to it.
+         This is the place to change some Ant specific build properties.
+         Here are some properties you may want to change/update:
+
+         source.dir
+             The name of the source directory. Default is 'src'.
+         out.dir
+             The name of the output directory. Default is 'bin'.
+
+         For other overridable properties, look at the beginning of the rules
+         files in the SDK, at tools/ant/build.xml
+
+         Properties related to the SDK location or the project target should
+         be updated using the 'android' tool with the 'update' action.
+
+         This file is an integral part of the build system for your
+         application and should be checked into Version Control Systems.
+
+         -->
+    <property file="ant.properties" />
+
+    <!-- The project.properties file is created and updated by the 'android'
+         tool, as well as ADT.
+
+         This contains project specific properties such as project target, and library
+         dependencies. Lower level build properties are stored in ant.properties
+         (or in .classpath for Eclipse projects).
+
+         This file is an integral part of the build system for your
+         application and should be checked into Version Control Systems. -->
+    <loadproperties srcFile="project.properties" />
+
+    <!-- quick check on sdk.dir -->
+    <fail
+            message="sdk.dir is missing. Make sure to generate local.properties using 'android update project' or to inject it through an env var"
+            unless="sdk.dir"
+    />
+
+
+<!-- extension targets. Uncomment the ones where you want to do custom work
+     in between standard targets -->
+<!--
+    <target name="-pre-build">
+    </target>
+    <target name="-pre-compile">
+    </target>
+
+    /* This is typically used for code obfuscation.
+       Compiled code location: ${out.classes.absolute.dir}
+       If this is not done in place, override ${out.dex.input.absolute.dir} */
+    <target name="-post-compile">
+      <copy file="${out.absolute.dir}/classes.jar" tofile="${jar.libs.dir}/zbar_android.jar" />
+    </target>
+-->
+
+    <!-- Import the actual build file.
+
+         To customize existing targets, there are two options:
+         - Customize only one target:
+             - copy/paste the target into this file, *before* the
+               <import> task.
+             - customize it to your needs.
+         - Customize the whole content of build.xml
+             - copy/paste the content of the rules files (minus the top node)
+               into this file, replacing the <import> task.
+             - customize to your needs.
+
+         ***********************
+         ****** IMPORTANT ******
+         ***********************
+         In all cases you must update the value of version-tag below to read 'custom' instead of an integer,
+         in order to avoid having your file be overridden by tools such as "android update project"
+    -->
+    <!-- version-tag: 1 -->
+    <import file="build-ndk.xml" />
+    <import file="${sdk.dir}/tools/ant/build.xml" />
+</project>
diff -r 563557a923d0 android/examples/CameraTest/AndroidManifest.xml
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/examples/CameraTest/AndroidManifest.xml	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+      package="net.sourceforge.zbar.android.CameraTest"
+      android:versionCode="1"
+      android:versionName="1.0">
+    <uses-sdk android:minSdkVersion="8" />
+    <uses-permission android:name="android.permission.CAMERA" />
+    <uses-feature android:name="android.hardware.camera" />
+    <uses-feature android:name="android.hardware.camera.autofocus" />
+    <application android:label="@string/app_name" >
+        <activity android:name="CameraTestActivity"
+                  android:label="@string/app_name">
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN" />
+                <category android:name="android.intent.category.LAUNCHER" />
+            </intent-filter>
+        </activity>
+    </application>
+</manifest> 
diff -r 563557a923d0 android/examples/CameraTest/ant.properties
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/examples/CameraTest/ant.properties	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,17 @@
+# This file is used to override default values used by the Ant build system.
+#
+# This file must be checked in Version Control Systems, as it is
+# integral to the build system of your project.
+
+# This file is only used by the Ant script.
+
+# You can use this to override default values such as
+#  'source.dir' for the location of your java source folder and
+#  'out.dir' for the location of your output folder.
+
+# You can also use it define how the release builds are signed by declaring
+# the following properties:
+#  'key.store' for the location of your keystore and
+#  'key.alias' for the name of the key to use.
+# The password will be asked during the build when you use the 'release' target.
+
diff -r 563557a923d0 android/examples/CameraTest/build.xml
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/examples/CameraTest/build.xml	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,85 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project name="CameraTest" default="help">
+
+    <!-- The local.properties file is created and updated by the 'android' tool.
+         It contains the path to the SDK. It should *NOT* be checked into
+         Version Control Systems. -->
+    <property file="local.properties" />
+
+    <!-- The ant.properties file can be created by you. It is only edited by the
+         'android' tool to add properties to it.
+         This is the place to change some Ant specific build properties.
+         Here are some properties you may want to change/update:
+
+         source.dir
+             The name of the source directory. Default is 'src'.
+         out.dir
+             The name of the output directory. Default is 'bin'.
+
+         For other overridable properties, look at the beginning of the rules
+         files in the SDK, at tools/ant/build.xml
+
+         Properties related to the SDK location or the project target should
+         be updated using the 'android' tool with the 'update' action.
+
+         This file is an integral part of the build system for your
+         application and should be checked into Version Control Systems.
+
+         -->
+    <property file="ant.properties" />
+
+    <!-- The project.properties file is created and updated by the 'android'
+         tool, as well as ADT.
+
+         This contains project specific properties such as project target, and library
+         dependencies. Lower level build properties are stored in ant.properties
+         (or in .classpath for Eclipse projects).
+
+         This file is an integral part of the build system for your
+         application and should be checked into Version Control Systems. -->
+    <loadproperties srcFile="project.properties" />
+
+    <!-- quick check on sdk.dir -->
+    <fail
+            message="sdk.dir is missing. Make sure to generate local.properties using 'android update project' or to inject it through an env var"
+            unless="sdk.dir"
+    />
+
+
+<!-- extension targets. Uncomment the ones where you want to do custom work
+     in between standard targets -->
+<!--
+    <target name="-pre-build">
+    </target>
+    <target name="-pre-compile">
+    </target>
+
+    /* This is typically used for code obfuscation.
+       Compiled code location: ${out.classes.absolute.dir}
+       If this is not done in place, override ${out.dex.input.absolute.dir} */
+    <target name="-post-compile">
+    </target>
+-->
+
+    <!-- Import the actual build file.
+
+         To customize existing targets, there are two options:
+         - Customize only one target:
+             - copy/paste the target into this file, *before* the
+               <import> task.
+             - customize it to your needs.
+         - Customize the whole content of build.xml
+             - copy/paste the content of the rules files (minus the top node)
+               into this file, replacing the <import> task.
+             - customize to your needs.
+
+         ***********************
+         ****** IMPORTANT ******
+         ***********************
+         In all cases you must update the value of version-tag below to read 'custom' instead of an integer,
+         in order to avoid having your file be overridden by tools such as "android update project"
+    -->
+    <!-- version-tag: 1 -->
+    <import file="${sdk.dir}/tools/ant/build.xml" />
+
+</project>
diff -r 563557a923d0 android/examples/CameraTest/proguard.cfg
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/examples/CameraTest/proguard.cfg	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,40 @@
+-optimizationpasses 5
+-dontusemixedcaseclassnames
+-dontskipnonpubliclibraryclasses
+-dontpreverify
+-verbose
+-optimizations !code/simplification/arithmetic,!field/*,!class/merging/*
+
+-keep public class * extends android.app.Activity
+-keep public class * extends android.app.Application
+-keep public class * extends android.app.Service
+-keep public class * extends android.content.BroadcastReceiver
+-keep public class * extends android.content.ContentProvider
+-keep public class * extends android.app.backup.BackupAgentHelper
+-keep public class * extends android.preference.Preference
+-keep public class com.android.vending.licensing.ILicensingService
+
+-keepclasseswithmembernames class * {
+    native <methods>;
+}
+
+-keepclasseswithmembers class * {
+    public <init>(android.content.Context, android.util.AttributeSet);
+}
+
+-keepclasseswithmembers class * {
+    public <init>(android.content.Context, android.util.AttributeSet, int);
+}
+
+-keepclassmembers class * extends android.app.Activity {
+   public void *(android.view.View);
+}
+
+-keepclassmembers enum * {
+    public static **[] values();
+    public static ** valueOf(java.lang.String);
+}
+
+-keep class * implements android.os.Parcelable {
+  public static final android.os.Parcelable$Creator *;
+}
diff -r 563557a923d0 android/examples/CameraTest/project.properties
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/examples/CameraTest/project.properties	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,11 @@
+# This file is automatically generated by Android Tools.
+# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
+#
+# This file must be checked in Version Control Systems.
+#
+# To customize properties used by the Ant build system use,
+# "ant.properties", and override values to adapt the script to your
+# project structure.
+
+# Project target.
+target=android-15
diff -r 563557a923d0 android/examples/CameraTest/res/layout/main.xml
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/examples/CameraTest/res/layout/main.xml	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,28 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout
+  xmlns:android="http://schemas.android.com/apk/res/android"
+  android:orientation="vertical"
+  android:layout_width="match_parent"
+  android:layout_height="match_parent">
+
+  <FrameLayout
+    android:id="@+id/cameraPreview"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:layout_weight="1"
+  />
+
+  <TextView
+    android:id="@+id/scanText"
+    android:text="Scanning..."
+    android:layout_height="wrap_content" 
+    android:layout_width="match_parent">
+  </TextView>
+  <Button
+    android:id="@+id/ScanButton"
+    android:text="Scan"
+    android:layout_width="wrap_content"
+    android:layout_height="wrap_content"
+    android:layout_gravity="center"
+  />
+</LinearLayout>
diff -r 563557a923d0 android/examples/CameraTest/res/values/strings.xml
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/examples/CameraTest/res/values/strings.xml	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,4 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <string name="app_name">ZBar CameraTest</string>
+</resources>
diff -r 563557a923d0 android/examples/CameraTest/src/net/sourceforge/zbar/android/CameraTest/CameraPreview.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/examples/CameraTest/src/net/sourceforge/zbar/android/CameraTest/CameraPreview.java	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,108 @@
+/*
+ * Barebones implementation of displaying camera preview.
+ * 
+ * Created by lisah0 on 2012-02-24
+ */
+package net.sourceforge.zbar.android.CameraTest;
+
+import java.io.IOException;
+
+import android.app.Activity;
+import android.os.Bundle;
+
+import android.util.Log;
+
+import android.view.View;
+import android.view.Surface;
+import android.view.SurfaceView;
+import android.view.SurfaceHolder;
+
+import android.content.Context;
+
+import android.hardware.Camera;
+import android.hardware.Camera.PreviewCallback;
+import android.hardware.Camera.AutoFocusCallback;
+import android.hardware.Camera.Parameters;
+
+/** A basic Camera preview class */
+public class CameraPreview extends SurfaceView implements SurfaceHolder.Callback {
+    private SurfaceHolder mHolder;
+    private Camera mCamera;
+    private PreviewCallback previewCallback;
+    private AutoFocusCallback autoFocusCallback;
+
+    public CameraPreview(Context context, Camera camera,
+                         PreviewCallback previewCb,
+                         AutoFocusCallback autoFocusCb) {
+        super(context);
+        mCamera = camera;
+        previewCallback = previewCb;
+        autoFocusCallback = autoFocusCb;
+
+        /* 
+         * Set camera to continuous focus if supported, otherwise use
+         * software auto-focus. Only works for API level >=9.
+         */
+        /*
+        Camera.Parameters parameters = camera.getParameters();
+        for (String f : parameters.getSupportedFocusModes()) {
+            if (f == Parameters.FOCUS_MODE_CONTINUOUS_PICTURE) {
+                mCamera.setFocusMode(Parameters.FOCUS_MODE_CONTINUOUS_PICTURE);
+                autoFocusCallback = null;
+                break;
+            }
+        }
+        */
+
+        // Install a SurfaceHolder.Callback so we get notified when the
+        // underlying surface is created and destroyed.
+        mHolder = getHolder();
+        mHolder.addCallback(this);
+
+        // deprecated setting, but required on Android versions prior to 3.0
+        mHolder.setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS);
+    }
+
+    public void surfaceCreated(SurfaceHolder holder) {
+        // The Surface has been created, now tell the camera where to draw the preview.
+        try {
+            mCamera.setPreviewDisplay(holder);
+        } catch (IOException e) {
+            Log.d("DBG", "Error setting camera preview: " + e.getMessage());
+        }
+    }
+
+    public void surfaceDestroyed(SurfaceHolder holder) {
+        // Camera preview released in activity
+    }
+
+    public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) {
+        /*
+         * If your preview can change or rotate, take care of those events here.
+         * Make sure to stop the preview before resizing or reformatting it.
+         */
+        if (mHolder.getSurface() == null){
+          // preview surface does not exist
+          return;
+        }
+
+        // stop preview before making changes
+        try {
+            mCamera.stopPreview();
+        } catch (Exception e){
+          // ignore: tried to stop a non-existent preview
+        }
+
+        try {
+            // Hard code camera surface rotation 90 degs to match Activity view in portrait
+            mCamera.setDisplayOrientation(90);
+
+            mCamera.setPreviewDisplay(mHolder);
+            mCamera.setPreviewCallback(previewCallback);
+            mCamera.startPreview();
+            mCamera.autoFocus(autoFocusCallback);
+        } catch (Exception e){
+            Log.d("DBG", "Error starting camera preview: " + e.getMessage());
+        }
+    }
+}
diff -r 563557a923d0 android/examples/CameraTest/src/net/sourceforge/zbar/android/CameraTest/CameraTestActivity.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/examples/CameraTest/src/net/sourceforge/zbar/android/CameraTest/CameraTestActivity.java	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,155 @@
+/*
+ * Basic no frills app which integrates the ZBar barcode scanner with
+ * the camera.
+ * 
+ * Created by lisah0 on 2012-02-24
+ */
+package net.sourceforge.zbar.android.CameraTest;
+
+import net.sourceforge.zbar.android.CameraTest.CameraPreview;
+
+import android.app.Activity;
+import android.content.pm.ActivityInfo;
+import android.os.Bundle;
+import android.os.Handler;
+import android.util.Log;
+
+import android.view.View;
+import android.view.View.OnClickListener;
+import android.view.Window;
+import android.widget.FrameLayout;
+import android.widget.Button;
+
+import android.hardware.Camera;
+import android.hardware.Camera.PreviewCallback;
+import android.hardware.Camera.AutoFocusCallback;
+import android.hardware.Camera.Parameters;
+import android.hardware.Camera.Size;
+
+import android.widget.TextView;
+import android.graphics.ImageFormat;
+
+/* Import ZBar Class files */
+import net.sourceforge.zbar.ImageScanner;
+import net.sourceforge.zbar.Image;
+import net.sourceforge.zbar.Symbol;
+import net.sourceforge.zbar.SymbolSet;
+import net.sourceforge.zbar.Config;
+
+public class CameraTestActivity extends Activity
+{
+    private Camera mCamera;
+    private CameraPreview mPreview;
+    private Handler autoFocusHandler;
+
+    TextView scanText;
+    Button scanButton;
+
+    ImageScanner scanner;
+
+    private boolean barcodeScanned = false;
+    private boolean previewing = true;
+
+    static {
+        System.loadLibrary("iconv");
+    } 
+
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+
+        setContentView(R.layout.main);
+
+        setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
+
+        autoFocusHandler = new Handler();
+        mCamera = getCameraInstance();
+
+        /* Instance barcode scanner */
+        scanner = new ImageScanner();
+        scanner.setConfig(0, Config.X_DENSITY, 3);
+        scanner.setConfig(0, Config.Y_DENSITY, 3);
+
+        mPreview = new CameraPreview(this, mCamera, previewCb, autoFocusCB);
+        FrameLayout preview = (FrameLayout)findViewById(R.id.cameraPreview);
+        preview.addView(mPreview);
+
+        scanText = (TextView)findViewById(R.id.scanText);
+
+        scanButton = (Button)findViewById(R.id.ScanButton);
+
+        scanButton.setOnClickListener(new OnClickListener() {
+                public void onClick(View v) {
+                    if (barcodeScanned) {
+                        barcodeScanned = false;
+                        scanText.setText("Scanning...");
+                        mCamera.setPreviewCallback(previewCb);
+                        mCamera.startPreview();
+                        previewing = true;
+                        mCamera.autoFocus(autoFocusCB);
+                    }
+                }
+            });
+    }
+
+    public void onPause() {
+        super.onPause();
+        releaseCamera();
+    }
+
+    /** A safe way to get an instance of the Camera object. */
+    public static Camera getCameraInstance(){
+        Camera c = null;
+        try {
+            c = Camera.open();
+        } catch (Exception e){
+        }
+        return c;
+    }
+
+    private void releaseCamera() {
+        if (mCamera != null) {
+            previewing = false;
+            mCamera.setPreviewCallback(null);
+            mCamera.release();
+            mCamera = null;
+        }
+    }
+
+    private Runnable doAutoFocus = new Runnable() {
+            public void run() {
+                if (previewing)
+                    mCamera.autoFocus(autoFocusCB);
+            }
+        };
+
+    PreviewCallback previewCb = new PreviewCallback() {
+            public void onPreviewFrame(byte[] data, Camera camera) {
+                Camera.Parameters parameters = camera.getParameters();
+                Size size = parameters.getPreviewSize();
+
+                Image barcode = new Image(size.width, size.height, "Y800");
+                barcode.setData(data);
+
+                int result = scanner.scanImage(barcode);
+                
+                if (result != 0) {
+                    previewing = false;
+                    mCamera.setPreviewCallback(null);
+                    mCamera.stopPreview();
+                    
+                    SymbolSet syms = scanner.getResults();
+                    for (Symbol sym : syms) {
+                        scanText.setText("barcode result " + sym.getData());
+                        barcodeScanned = true;
+                    }
+                }
+            }
+        };
+
+    // Mimic continuous auto-focusing
+    AutoFocusCallback autoFocusCB = new AutoFocusCallback() {
+            public void onAutoFocus(boolean success, Camera camera) {
+                autoFocusHandler.postDelayed(doAutoFocus, 1000);
+            }
+        };
+}
diff -r 563557a923d0 android/jni/Android.mk
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/jni/Android.mk	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,76 @@
+#
+# Android NDK makefile 
+#
+# build - <ndk path>/ndk-build ICONV_SRC=<iconv library src> 
+# clean -  <ndk path>/ndk-build clean
+#
+MY_LOCAL_PATH := $(call my-dir)
+
+# libiconv
+include $(CLEAR_VARS)
+LOCAL_PATH := $(ICONV_SRC)
+
+LOCAL_MODULE := libiconv
+
+LOCAL_CFLAGS := \
+    -Wno-multichar \
+    -D_ANDROID \
+    -DLIBDIR="c" \
+    -DBUILDING_LIBICONV \
+    -DBUILDING_LIBCHARSET \
+    -DIN_LIBRARY
+
+LOCAL_SRC_FILES := \
+	lib/iconv.c \
+	libcharset/lib/localcharset.c \
+	lib/relocatable.c
+
+LOCAL_C_INCLUDES := \
+	$(ICONV_SRC)/include \
+	$(ICONV_SRC)/libcharset \
+	$(ICONV_SRC)/libcharset/include
+
+include $(BUILD_SHARED_LIBRARY)
+
+LOCAL_LDLIBS := -llog -lcharset
+
+# libzbarjni
+include $(CLEAR_VARS)
+
+LOCAL_PATH := $(MY_LOCAL_PATH)
+LOCAL_MODULE := zbarjni
+LOCAL_SRC_FILES := ../../java/zbarjni.c \
+		   ../../zbar/img_scanner.c \
+		   ../../zbar/decoder.c \
+		   ../../zbar/image.c \
+		   ../../zbar/symbol.c \
+		   ../../zbar/convert.c \
+		   ../../zbar/config.c \
+		   ../../zbar/scanner.c \
+		   ../../zbar/error.c \
+		   ../../zbar/refcnt.c \
+		   ../../zbar/video.c \
+		   ../../zbar/video/null.c \
+		   ../../zbar/decoder/code128.c \
+		   ../../zbar/decoder/code39.c \
+		   ../../zbar/decoder/code93.c \
+		   ../../zbar/decoder/codabar.c \
+		   ../../zbar/decoder/databar.c \
+		   ../../zbar/decoder/ean.c \
+		   ../../zbar/decoder/i25.c \
+		   ../../zbar/decoder/qr_finder.c \
+		   ../../zbar/qrcode/bch15_5.c \
+		   ../../zbar/qrcode/binarize.c \
+		   ../../zbar/qrcode/isaac.c \
+		   ../../zbar/qrcode/qrdec.c \
+		   ../../zbar/qrcode/qrdectxt.c \
+		   ../../zbar/qrcode/rs.c \
+		   ../../zbar/qrcode/util.c
+
+LOCAL_C_INCLUDES := ../include \
+		    ../zbar \
+		    $(ICONV_SRC)/include 
+
+LOCAL_SHARED_LIBRARIES := libiconv
+
+include $(BUILD_SHARED_LIBRARY)
\ No newline at end of file
diff -r 563557a923d0 android/jni/Application.mk
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/jni/Application.mk	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,1 @@
+APP_ABI := armeabi armeabi-v7a x86
diff -r 563557a923d0 android/jni/config.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/jni/config.h	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,236 @@
+/* manually customized for iPhone platform */
+
+#define HAVE_LANGINFO_CODESET 0
+
+/* whether to build support for Code 128 symbology */
+#define ENABLE_CODE128 1
+
+/* whether to build support for Code 93 symbology */
+#define ENABLE_CODE93 1
+
+/* whether to build support for Code 39 symbology */
+#define ENABLE_CODE39 1
+
+/* whether to build support for Codabar symbology */
+#define ENABLE_CODABAR 1
+
+/* whether to build support for DataBar symbology */
+#define ENABLE_DATABAR 1
+
+/* whether to build support for EAN symbologies */
+#define ENABLE_EAN 1
+
+/* whether to build support for Interleaved 2 of 5 symbology */
+#define ENABLE_I25 1
+
+/* whether to build support for PDF417 symbology */
+#undef ENABLE_PDF417
+
+/* whether to build support for QR Code */
+#define ENABLE_QRCODE 1
+
+/* Define to 1 if you have the `atexit' function. */
+#undef HAVE_ATEXIT
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#undef HAVE_DLFCN_H
+
+/* Define to 1 if you have the <fcntl.h> header file. */
+#undef HAVE_FCNTL_H
+
+/* Define to 1 if you have the <features.h> header file. */
+#undef HAVE_FEATURES_H
+
+/* Define to 1 if you have the `getpagesize' function. */
+#undef HAVE_GETPAGESIZE
+
+/* Define if you have the iconv() function and it works. */
+#undef HAVE_ICONV
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#define HAVE_INTTYPES_H 1
+
+/* Define to 1 if you have the <jpeglib.h> header file. */
+#undef HAVE_JPEGLIB_H
+
+/* Define to 1 if you have the `jpeg' library (-ljpeg). */
+#undef HAVE_LIBJPEG
+
+/* Define to 1 if you have the `pthread' library (-lpthread). */
+#undef HAVE_LIBPTHREAD
+
+/* Define to 1 if you have the <linux/videodev2.h> header file. */
+#undef HAVE_LINUX_VIDEODEV2_H
+
+/* Define to 1 if you have the <linux/videodev.h> header file. */
+#undef HAVE_LINUX_VIDEODEV_H
+
+/* Define to 1 if you have the <memory.h> header file. */
+#undef HAVE_MEMORY_H
+
+/* Define to 1 if you have the `memset' function. */
+#define HAVE_MEMSET 1
+
+/* Define to 1 if you have a working `mmap' system call. */
+#undef HAVE_MMAP
+
+/* Define to 1 if you have the <poll.h> header file. */
+#undef HAVE_POLL_H
+
+/* Define to 1 if you have the <pthread.h> header file. */
+#undef HAVE_PTHREAD_H
+
+/* Define to 1 if you have the `setenv' function. */
+#undef HAVE_SETENV
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#define HAVE_STDINT_H 1
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#define HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the <strings.h> header file. */
+#define HAVE_STRINGS_H 1
+
+/* Define to 1 if you have the <string.h> header file. */
+#define HAVE_STRING_H 1
+
+/* Define to 1 if you have the <sys/ioctl.h> header file. */
+#undef HAVE_SYS_IOCTL_H
+
+/* Define to 1 if you have the <sys/ipc.h> header file. */
+#undef HAVE_SYS_IPC_H
+
+/* Define to 1 if you have the <sys/mman.h> header file. */
+#undef HAVE_SYS_MMAN_H
+
+/* Define to 1 if you have the <sys/shm.h> header file. */
+#undef HAVE_SYS_SHM_H
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/times.h> header file. */
+#define HAVE_SYS_TIMES_H 1
+
+/* Define to 1 if you have the <sys/time.h> header file. */
+#define HAVE_SYS_TIME_H 1
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if the system has the type `uintptr_t'. */
+#define HAVE_UINTPTR_T 1
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#define HAVE_UNISTD_H 1
+
+/* Define to 1 if you have the <vfw.h> header file. */
+#undef HAVE_VFW_H
+
+/* Define to 1 if you have the <X11/extensions/XShm.h> header file. */
+#undef HAVE_X11_EXTENSIONS_XSHM_H
+
+/* Define to 1 if you have the <X11/extensions/Xvlib.h> header file. */
+#undef HAVE_X11_EXTENSIONS_XVLIB_H
+
+/* Define as const if the declaration of iconv() needs const. */
+#undef ICONV_CONST
+
+/* Library major version */
+#define LIB_VERSION_MAJOR 0
+
+/* Library minor version */
+#define LIB_VERSION_MINOR 2
+
+/* Library revision */
+#define LIB_VERSION_REVISION 0
+
+/* Define to the sub-directory in which libtool stores uninstalled libraries.
+   */
+#undef LT_OBJDIR
+
+/* Define to 1 if assertions should be disabled. */
+//#undef NDEBUG
+
+/* Define to 1 if your C compiler doesn't accept -c and -o together. */
+#undef NO_MINUS_C_MINUS_O
+
+/* Name of package */
+#define PACKAGE "zbar"
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT "spadix@users.sourceforge.net"
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME "zbar"
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING "zbar 0.10"
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME "zbar"
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION "0.10"
+
+/* Define to 1 if you have the ANSI C header files. */
+#define STDC_HEADERS 1
+
+/* Version number of package */
+#define VERSION "0.10"
+
+/* Define to 1 if the X Window System is missing or not being used. */
+#define X_DISPLAY_MISSING 1
+
+/* Program major version (before the '.') as a number */
+#define ZBAR_VERSION_MAJOR 0
+
+/* Program minor version (after '.') as a number */
+#define ZBAR_VERSION_MINOR 10
+
+/* Define for Solaris 2.5.1 so the uint32_t typedef from <sys/synch.h>,
+   <pthread.h>, or <semaphore.h> is not used. If the typedef were allowed, the
+   #define below would cause a syntax error. */
+#undef _UINT32_T
+
+/* Define for Solaris 2.5.1 so the uint8_t typedef from <sys/synch.h>,
+   <pthread.h>, or <semaphore.h> is not used. If the typedef were allowed, the
+   #define below would cause a syntax error. */
+#undef _UINT8_T
+
+/* Minimum Windows API version */
+#undef _WIN32_WINNT
+
+/* used only for pthread debug attributes */
+#undef __USE_UNIX98
+
+/* Define to empty if `const' does not conform to ANSI C. */
+#undef const
+
+/* Define to `__inline__' or `__inline' if that's what the C compiler
+   calls it, or to nothing if 'inline' is not supported under any name.  */
+#ifndef __cplusplus
+#undef inline
+#endif
+
+/* Define to the type of a signed integer type of width exactly 32 bits if
+   such a type exists and the standard includes do not define it. */
+#undef int32_t
+
+/* Define to the type of an unsigned integer type of width exactly 32 bits if
+   such a type exists and the standard includes do not define it. */
+#undef uint32_t
+
+/* Define to the type of an unsigned integer type of width exactly 8 bits if
+   such a type exists and the standard includes do not define it. */
+#undef uint8_t
+
+/* Define to the type of an unsigned integer type wide enough to hold a
+   pointer, if such a type exists, and if the system does not define it. */
+#undef uintptr_t
+
+#ifndef X_DISPLAY_MISSING
+# define HAVE_X
+#endif
+
diff -r 563557a923d0 android/proguard.cfg
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/proguard.cfg	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,40 @@
+-optimizationpasses 5
+-dontusemixedcaseclassnames
+-dontskipnonpubliclibraryclasses
+-dontpreverify
+-verbose
+-optimizations !code/simplification/arithmetic,!field/*,!class/merging/*
+
+-keep public class * extends android.app.Activity
+-keep public class * extends android.app.Application
+-keep public class * extends android.app.Service
+-keep public class * extends android.content.BroadcastReceiver
+-keep public class * extends android.content.ContentProvider
+-keep public class * extends android.app.backup.BackupAgentHelper
+-keep public class * extends android.preference.Preference
+-keep public class com.android.vending.licensing.ILicensingService
+
+-keepclasseswithmembernames class * {
+    native <methods>;
+}
+
+-keepclasseswithmembers class * {
+    public <init>(android.content.Context, android.util.AttributeSet);
+}
+
+-keepclasseswithmembers class * {
+    public <init>(android.content.Context, android.util.AttributeSet, int);
+}
+
+-keepclassmembers class * extends android.app.Activity {
+   public void *(android.view.View);
+}
+
+-keepclassmembers enum * {
+    public static **[] values();
+    public static ** valueOf(java.lang.String);
+}
+
+-keep class * implements android.os.Parcelable {
+  public static final android.os.Parcelable$Creator *;
+}
diff -r 563557a923d0 android/project.properties
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/project.properties	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,12 @@
+# This file is automatically generated by Android Tools.
+# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
+#
+# This file must be checked in Version Control Systems.
+#
+# To customize properties used by the Ant build system use,
+# "ant.properties", and override values to adapt the script to your
+# project structure.
+
+android.library=true
+# Project target.
+target=android-8
diff -r 563557a923d0 android/res/layout/main.xml
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/res/layout/main.xml	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,13 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:orientation="vertical"
+    android:layout_width="fill_parent"
+    android:layout_height="fill_parent"
+    >
+<TextView  
+    android:layout_width="fill_parent" 
+    android:layout_height="wrap_content" 
+    android:text="Hello World, ACTIVITY_ENTRY_NAME"
+    />
+</LinearLayout>
+
diff -r 563557a923d0 android/res/values/strings.xml
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/android/res/values/strings.xml	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,4 @@
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+    <string name="app_name">ACTIVITY_ENTRY_NAME</string>
+</resources>
diff -r 563557a923d0 configure.ac
--- a/configure.ac	Tue Oct 27 11:25:59 2009 -0400
+++ b/configure.ac	Fri Feb 22 08:54:29 2013 -0300
@@ -46,6 +46,13 @@
   [[`echo "$LIB_VERSION" | sed -e 's/^[^:]*:\([^:]*\):.*$/\1/'`]],
   [Library revision])
 
+AM_CPPFLAGS="-I$srcdir/include"
+AM_CFLAGS="-Wall -Wno-parentheses -Werror"
+AM_CXXFLAGS="$AM_CFLAGS"
+AC_SUBST([AM_CPPFLAGS])
+AC_SUBST([AM_CFLAGS])
+AC_SUBST([AM_CXXFLAGS])
+
 dnl windows build
 
 AC_CANONICAL_HOST
@@ -73,13 +80,36 @@
 AC_ARG_VAR([XMLTOFLAGS], [additional arguments for xmlto])
 AC_CHECK_PROGS([XMLTO], [xmlto], [:])
 
+have_java="maybe"
+AC_ARG_VAR([JAVA_HOME], [root location of JDK])
+AS_IF([test "x$JAVA_HOME" = "x"],
+  [JAVA_PATH="$PATH"],
+  [JAVA_PATH="$JAVA_HOME/bin$PATH_SEPARATOR$PATH"])
+
+AC_ARG_VAR([JAVAC], [location of Java language compiler])
+AC_PATH_PROGS([JAVAC], [javac jikes ecj gcj], [:], [$JAVA_PATH])
+AS_IF([test "x$JAVAC" = "x:"], [have_java="no"])
+
+AC_ARG_VAR([JAVAH], [location of Java header generator])
+AC_PATH_PROGS([JAVAH], [javah], [/bin/false], [$JAVA_PATH])
+
+AC_ARG_VAR([JAR], [location of Java archive tool])
+AC_PATH_PROGS([JAR], [jar], [:], [$JAVA_PATH])
+AS_IF([test "x$JAR" = "x:"], [have_java="no"])
+
+AC_ARG_VAR([JAVA], [location of Java application launcher])
+AC_PATH_PROGS([JAVA], [java], [/bin/false], [$JAVA_PATH])
+
+AC_ARG_VAR([CLASSPATH], [Java class path (include JUnit to run java tests)])
+AS_IF([test "x$CLASSPATH" = "x"], [CLASSPATH="."])
+
 dnl symbologies
 
 AC_ARG_ENABLE([codes],
   [AS_HELP_STRING([--enable-codes=SYMS],
-    [select symbologies to compile [default=ean,i25,code39,code128,qrcode]])],
+    [select symbologies to compile [default=ean,databar,code128,code93,code39,codabar,i25,qrcode]])],
   [],
-  [enable_codes="ean,code39,code128,i25,qrcode"]) dnl pdf417
+  [enable_codes="ean,databar,code128,code93,code39,codabar,i25,qrcode"])
 
 AC_DEFUN([ZBAR_CHK_CODE], [
   AC_MSG_CHECKING([whether to build $2])
@@ -97,11 +127,14 @@
 ])dnl
 
 ZBAR_CHK_CODE([ean], [EAN symbologies])
+ZBAR_CHK_CODE([databar], [DataBar symbology])
 ZBAR_CHK_CODE([code128], [Code 128 symbology])
+ZBAR_CHK_CODE([code93], [Code 93 symbology])
 ZBAR_CHK_CODE([code39], [Code 39 symbology])
-ZBAR_CHK_CODE([pdf417], [PDF417 symbology])
+ZBAR_CHK_CODE([codabar], [Codabar symbology])
 ZBAR_CHK_CODE([i25], [Interleaved 2 of 5 symbology])
 ZBAR_CHK_CODE([qrcode], [QR Code])
+ZBAR_CHK_CODE([pdf417], [PDF417 symbology])
 
 dnl libraries
 
@@ -144,23 +177,26 @@
   [],
   [enable_video="yes"])
 
-with_video="no"
-AS_IF([test "x$enable_video" != "xno"],
-  [AS_IF([test "x$win32" = "xno"],
-    [AC_CHECK_HEADERS([linux/videodev.h], [with_video="v4l1"],
-      [AC_MSG_FAILURE([test for video support failed!
+have_v4l1="no"
+have_v4l2="no"
+AS_IF([test "x$enable_video" = "xno"],
+  [],
+  [test "x$win32" = "xno"],
+  [AC_CHECK_HEADERS([linux/videodev.h], [have_v4l1="yes"])
+   AC_CHECK_HEADERS([linux/videodev2.h], [have_v4l2="yes"])
+   AS_IF([test "x$have_v4l2" = "xno" && test "x$have_v4l1" = "xno"],
+     [AC_MSG_FAILURE([test for video support failed!
 rebuild your kernel to include video4linux support or
-configure --disable-video to skip building video support.])])
-       AC_CHECK_HEADERS([linux/videodev2.h], [with_video="v4l2"],
-         [AC_MSG_WARN([v4l2 API not detected, upgrade your kernel!])])],
-    [AC_CHECK_HEADERS([vfw.h], [with_video="vfw"],
-      [AC_MSG_FAILURE([test for VfW video support failed!
-configure --disable-video to skip building vidoe support.])])])
-])
+configure --disable-video to skip building video support.])],
+     [test "x$have_v4l2" = "xno"],
+     [AC_MSG_WARN([v4l2 API not detected, upgrade your kernel!])])],
+  [AC_CHECK_HEADERS([vfw.h], [with_video="vfw"],
+    [AC_MSG_FAILURE([test for VfW video support failed!
+configure --disable-video to skip building video support.])])])
+
 AM_CONDITIONAL([HAVE_VIDEO], [test "x$enable_video" != "xno"])
-AM_CONDITIONAL([HAVE_V4L1],
-  [test "x$with_video" = "xv4l1" || test "x$with_video" = "xv4l2"])
-AM_CONDITIONAL([HAVE_V4L2], [test "x$with_video" = "xv4l2"])
+AM_CONDITIONAL([HAVE_V4L1], [test "x$have_v4l1" != "xno"])
+AM_CONDITIONAL([HAVE_V4L2], [test "x$have_v4l2" != "xno"])
 
 dnl X
 AC_ARG_VAR([XSHM_LIBS], [linker flags for X shared memory extension])
@@ -252,51 +288,105 @@
 ])
 AM_CONDITIONAL([HAVE_JPEG], [test "x$with_jpeg" = "xyes"])
 
-dnl ImageMagick
+dnl ImageMagick or GraphicsMagick
+dnl disable both if IM is explicitly disabled to preserve old behavior
+
 AC_ARG_WITH([imagemagick],
   [AS_HELP_STRING([--without-imagemagick],
-    [disable support for scanning images using ImageMagick])],
+    [disable support for scanning images with ImageMagick])],
   [],
-  [with_imagemagick="yes"])
+  [with_imagemagick="check"])
 
-AS_IF([test "x$with_imagemagick" != "xno"],
-  [PKG_CHECK_MODULES([MAGICK], [MagickWand >= 6.2.6], [],
-     [dnl Wand is deprecated in favor of MagickWand,
-      dnl but the latter doesn't exist in older verisons (bug #2848437)
+AC_ARG_WITH([graphicsmagick],
+  [AS_HELP_STRING([--with-graphicsmagick],
+    [use GraphicsMagick alternative to ImageMagick])],
+  [],
+  [with_graphicsmagick="check"])
+
+magick="UnknownMagick"
+have_IM="maybe"
+AS_IF([test "x$with_imagemagick" = "xno"], [],
+      [test "x$with_imagemagick" = "xyes" || \
+       test "x$with_graphicsmagick" != "xyes"],
+  [looked_for="ImageMagick >= 6.2.6"
+   PKG_CHECK_MODULES([MAGICK], [MagickWand >= 6.2.6],
+     [MAGICK_VERSION=`$PKG_CONFIG MagickWand --modversion`],
+     [dnl
+dnl Wand is deprecated in favor of MagickWand,
+dnl but the latter doesn't exist in older verisons (bug #2848437)
       saved_error=$MAGICK_PKG_ERRORS
-      PKG_CHECK_MODULES([MAGICK], [Wand >= 6.2.6], [],
-        [AC_MSG_FAILURE([dnl
-Unable to find ImageMagick >= 6.2.6:
+      PKG_CHECK_MODULES([MAGICK], [Wand >= 6.2.6],
+        [MAGICK_VERSION=`$PKG_CONFIG Wand --modversion`],
+        [have_IM="no"])])
+   AS_IF([test "x$have_IM" != "xno"],
+     [magick="ImageMagick"
+      AC_MSG_NOTICE([trying ImageMagick version $MAGICK_VERSION])
+dnl double check ImageMagick install (bug #2582232)
+      CPPFLAGS_save="$CPPFLAGS"
+      CPPFLAGS="$CPPFLAGS $MAGICK_CFLAGS"
+      AC_CHECK_HEADER([wand/MagickWand.h],
+        [have_IM="yes"],
+        [have_IM="broken"])
+      CPPFLAGS="$CPPFLAGS_save"])])
+
+have_GM="maybe"
+AS_IF([test "x$have_IM" = "xyes"], [],
+      [test "x$with_graphicsmagick" = "xno"], [],
+      [test "x$with_graphicsmagick" = "xyes" || \
+       test "x$with_imagemagick" = "xcheck"],
+  [AS_IF([test "x$looked_for" = "x"],
+     [looked_for="GraphicsMagick"],
+     [looked_for="$looked_for or GraphicsMagick"])
+   PKG_CHECK_MODULES([MAGICK], [GraphicsMagickWand],
+     [have_GM="yes"
+      magick="GraphicsMagick"
+      MAGICK_VERSION=`$PKG_CONFIG GraphicsMagickWand --modversion`],
+     [have_GM="no"
+      AS_IF([test "x$saved_error" = "x"],
+        [saved_error=$MAGICK_PKG_ERRORS])])])
+
+dnl now that we have collected all the info abt what Magick is available
+dnl let the user know what we will or can't do
+AS_IF([test "x$have_IM" = "xbroken" && test "x$have_GM" = "xyes"],
+  [AC_MSG_WARN([Your ImageMagick install is broken, using GraphicsMagick instead])])
+
+AS_IF([test "x$have_IM" = "xyes" || test "x$have_GM" = "xyes"],
+  [AC_MSG_NOTICE([using $magick version $MAGICK_VERSION])],
+  [test "x$with_imagemagick" = "xno" && \
+   test "x$with_graphicsmagick" != "xyes"],
+  [AC_MSG_NOTICE([image scanning disabled -- zbarimg will *not* be built])],
+  [test "x$have_IM" = "xbroken"],
+  [AC_MSG_FAILURE([$magick package found but wand/MagickWand.h not installed?!
+this is a problem with your $magick install, please try again after
+resolving the inconsistency or installing GraphicsMagick alternative...])],
+  [AC_MSG_FAILURE([dnl
+Unable to find $looked_for:
 
 $saved_error
 
-* Ensure that you installed any "development" packages for ImageMagick.
+* Ensure that you installed any "development" packages for ImageMagick or
+  GraphicsMagick.
 * Consider adjusting the PKG_CONFIG_PATH environment variable if you
   installed software in a non-standard prefix.
 * You may set the environment variables MAGICK_CFLAGS and MAGICK_LIBS
   to avoid the need to call pkg-config.
   See the pkg-config man page for more details.
-* To avoid using ImageMagick altogether you may add the --without-imagemagick
-  flag to the configure command; the zbarimg program will not be built.
-])])])
-   MAGICK_VERSION=`$PKG_CONFIG MagickWand --modversion`
-   AC_MSG_NOTICE([using ImageMagick version $MAGICK_VERSION])
+* To avoid using ImageMagick or GraphicsMagick altogether you may add the
+  --without-imagemagick flag to the configure command; the zbarimg program
+  will *not* be built.
+])])
 
-dnl double check ImageMagick install (bug #2582232)
-   CPPFLAGS_save="$CPPFLAGS"
-   CPPFLAGS="$CPPFLAGS $MAGICK_CFLAGS"
-   AC_CHECK_HEADER([wand/MagickWand.h], [],
-     [AC_MSG_FAILURE([ImageMagick package found but wand/MagickWand.h not installed?!
-this is a problem with your ImageMagick install,
-please resolve the inconsistency and try again...])])
-   CPPFLAGS="$CPPFLAGS_save"])
-
-AM_CONDITIONAL([HAVE_MAGICK], [test "x$with_imagemagick" = "xyes"])
+AS_IF([test "x$have_IM" = "xyes"],
+  [AC_DEFINE([HAVE_IMAGEMAGICK], [1], [Define to 1 to use ImageMagick])],
+  [test "x$have_GM" = "xyes"],
+  [AC_DEFINE([HAVE_GRAPHICSMAGICK], [1], [Define to 1 to use GraphicsMagick])])
+AM_CONDITIONAL([HAVE_MAGICK],
+  [test "x$have_IM" = "xyes" || test "x$have_GM" = "xyes"])
 
 dnl Mozilla NPAPI
 AC_ARG_WITH([npapi],
   [AS_HELP_STRING([--with-npapi],
-    [enable support for Firefox/Mozilla/OpenOffice NPAPI plugin])],
+    [enable support for Firefox/Mozilla/OpenOffice plugin])],
   [],
   [with_npapi="no"])
 
@@ -350,7 +440,16 @@
      [test -x "$PYTHON-config"],
      [PYTHON_CFLAGS=`$PYTHON-config --cflags`],
      [PYTHON_CFLAGS=`$PYTHON -c 'import distutils.sysconfig as s; print " ".join(s.get_config_vars("CFLAGS")) + " -I"+s.get_python_inc() + " -I"+s.get_python_inc(plat_specific=True)'`])
-dnl FIXME now should check that #include <Python.h> compiles
+
+dnl check that #include <Python.h> compiles (bug #3092663)
+   CPPFLAGS_save="$CPPFLAGS"
+   CPPFLAGS="$CPPFLAGS $PYTHON_CFLAGS"
+   AC_CHECK_HEADER([Python.h], [], [AC_MSG_ERROR([dnl
+Python module enabled, but unable to compile Python.h.
+Install the development package for python-$am_cv_python_version, or configure
+--without-python to disable the python bindings.dnl
+])])
+   CPPFLAGS="$CPPFLAGS_save"
 
    AS_IF([test "x$with_gtk" = "xyes"],
      [PKG_CHECK_MODULES([PYGTK], [pygtk-2.0])
@@ -383,13 +482,39 @@
 
 AM_CONDITIONAL([HAVE_QT], [test "x$with_qt" = "xyes"])
 
+dnl Java
+AC_ARG_WITH([java],
+  [AS_HELP_STRING([--without-java],
+    [disable support for Java interface])],
+  [],
+  [with_java="check"])
+
+AC_ARG_VAR([JAVA_CFLAGS], [compiler flags for building JNI extensions])
+AS_IF([test "x$JAVA_CFLAGS" = "x" && test "x$JAVA_HOME" != "x"],
+  [JAVA_CFLAGS="-I$JAVA_HOME/include"])
+
+AS_IF([test "x$with_java" != "xno"],
+  [CPPFLAGS_save="$CPPFLAGS"
+   CPPFLAGS="$CPPFLAGS $JAVA_CFLAGS"
+   AC_CHECK_HEADER([jni.h], [], [have_java="no"])
+   CPPFLAGS="$CPPFLAGS_save"
+   AS_IF([test "x$have_java" != "xno"],
+     [with_java="yes"],
+     [test "x$with_java" = "xyes"],
+     [AC_MSG_FAILURE([unable to find Java JNI! ensure CFLAGS are set
+appropriately or configure --without-java])],
+     [with_java="no"])
+])
+AM_CONDITIONAL([HAVE_JAVA], [test "x$with_java" = "xyes"])
+
 
 dnl header files
 
 dnl FIXME switches for shm, mmap
 AC_HEADER_ASSERT
-AC_CHECK_HEADERS([fcntl.h features.h inttypes.h stdlib.h string.h unistd.h \
-  sys/ioctl.h sys/time.h sys/times.h sys/ipc.h sys/shm.h sys/mman.h])
+AC_CHECK_HEADERS([errno.h fcntl.h features.h inttypes.h stdlib.h string.h \
+  unistd.h sys/types.h sys/stat.h sys/ioctl.h sys/time.h sys/times.h \
+  sys/ipc.h sys/shm.h sys/mman.h])
 
 dnl types
 
@@ -428,6 +553,7 @@
 
 AC_CONFIG_FILES([
 Makefile
+java/Makefile
 zbar.pc
 zbar-gtk.pc
 zbar-qt.pc
@@ -448,8 +574,10 @@
 echo "jpeg              --with-jpeg=$with_jpeg"
 AS_IF([test "x$with_jpeg" != "xyes"],
   [echo "        => JPEG image conversions will *NOT* be supported"])
-echo "Magick++          --with-imagemagick=$with_imagemagick"
-AS_IF([test "x$with_imagemagick" != "xyes"],
+AS_IF([test "x$have_GM" = "xyes"],
+  [echo "GraphicsMagick    --with-graphicsmagick=yes"],
+  [echo "ImageMagick       --with-imagemagick=$with_imagemagick"])
+AS_IF([test "x$have_IM" != "xyes" && test "x$have_GM" != "xyes"],
   [echo "        => the zbarimg file scanner will *NOT* be built"])
 echo "Python            --with-python=$with_python"
 echo "GTK+              --with-gtk=$with_gtk"
@@ -460,6 +588,9 @@
 echo "Qt4               --with-qt=$with_qt"
 AS_IF([test "x$with_qt" != "xyes"],
   [echo "        => the Qt4 widget will *NOT* be built"])
+echo "Java              --with-java=$with_java"
+AS_IF([test "x$with_java" != "xyes"],
+  [echo "        => the Java interface will *NOT* be built"])
 #echo "NPAPI Plugin     --with-npapi=$with_npapi"
 #AS_IF([test "x$with_mozilla" != "xyes"],
 #  [echo "       => the Mozilla/Firefox/OpenOffice plugin will *NOT* be built"])
diff -r 563557a923d0 doc/Makefile.am.inc
--- a/doc/Makefile.am.inc	Tue Oct 27 11:25:59 2009 -0400
+++ b/doc/Makefile.am.inc	Fri Feb 22 08:54:29 2013 -0300
@@ -2,6 +2,7 @@
 DOCSOURCES = doc/manual.xml doc/version.xml doc/reldate.xml \
     doc/ref/zbarimg.xml doc/ref/zbarcam.xml doc/ref/commonoptions.xml
 
+MAINTAINERCLEANFILES += doc/man/man.stamp doc/version.xml doc/reldate.xml
 
 # man page targets to distribute and install
 dist_man_MANS =
diff -r 563557a923d0 doc/api/footer.html
--- a/doc/api/footer.html	Tue Oct 27 11:25:59 2009 -0400
+++ b/doc/api/footer.html	Fri Feb 22 08:54:29 2013 -0300
@@ -9,9 +9,12 @@
 
 <address><a href="mailto:spadix@users.sourceforge.net">spadix@users.sourceforge.net</a></address>
 
-<p>Copyright 2008-2009 (c) Jeff Brown - All Rights Reserved.</p>
-<p>Verbatim copying and distribution of this entire article are
-  permitted worldwide, without royalty, in any medium, provided this
-  notice, and the copyright notice, are preserved.</p>
+<p>Copyright 2008-2010 (c) Jeff Brown</p>
+<p>This documentation is part of the ZBar Barcode Reader; you can
+redistribute it and/or modify it under the terms of the
+<a href="http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html">GNU
+Lesser General Public License</a> as published by the Free Software
+Foundation; either version 2.1 of the License, or (at your option) any
+later version.</p>
 
 </body></html>
diff -r 563557a923d0 doc/manual.xml
--- a/doc/manual.xml	Tue Oct 27 11:25:59 2009 -0400
+++ b/doc/manual.xml	Fri Feb 22 08:54:29 2013 -0300
@@ -29,10 +29,10 @@
       <year>2007</year>
       <year>2008</year>
       <year>2009</year>
+      <year>2010</year>
       <holder>Jeff Brown</holder>
     </copyright>
     <legalnotice><para>All Rights Reserved</para></legalnotice>
-    <!-- <legalnotice><para>insert GNU FDL header?</para></legalnotice> -->
   </bookinfo>
 
   <chapter id="intro">
@@ -47,7 +47,4 @@
     &refzbarimg;
 
   </reference>
-
-  <!-- insert GNU FDL? -->
-
 </book>
diff -r 563557a923d0 doc/ref/commonoptions.xml
--- a/doc/ref/commonoptions.xml	Tue Oct 27 11:25:59 2009 -0400
+++ b/doc/ref/commonoptions.xml	Fri Feb 22 08:54:29 2013 -0300
@@ -47,8 +47,9 @@
       <option>ean13</option>, <option>ean8</option>,
       <option>upca</option>, <option>upce</option>,
       <option>isbn13</option>, <option>isbn10</option>,
-      <option>i25</option>, <option>code39</option>,
-      <option>code128</option> or the special value <option>*</option>.
+      <option>i25</option>, <option>codabar</option>, <option>code39</option>,
+      <option>code93</option>, <option>code128</option>,
+      <option>qrcode</option> or the special value <option>*</option>.
       If <replaceable class="parameter">symbology</replaceable> is
       omitted or <option>*</option>, the <replaceable
       class="parameter">config</replaceable> will be set for all
@@ -128,11 +129,12 @@
           If a decode result is outside the configured min/max range
           (inclusive), it will not be reported.  Set to 0 to disable the
           corresponding check.  This setting applies to variable-length
-          symbologies: <option>i25</option>, <option>code39</option>,
-          <option>code128</option> and <option>pdf417</option>.
-          <option>min-length</option> defaults to 6 for <option>i25</option>
-          and 1 for <option>code39</option> (per Code 39 autodiscrimination
-          recommendation); all others default to 0</simpara>
+          symbologies: <option>i25</option>, <option>codabar</option>,
+          <option>code39</option>, <option>code128</option> and
+          <option>pdf417</option>. <option>min-length</option> defaults to 6
+          for <option>i25</option> and 1 for <option>code39</option> (per Code
+          39 autodiscrimination recommendation); all others default to
+          0</simpara>
         </listitem>
       </varlistentry>
 
diff -r 563557a923d0 doc/ref/zbarcam.xml
--- a/doc/ref/zbarcam.xml	Tue Oct 27 11:25:59 2009 -0400
+++ b/doc/ref/zbarcam.xml	Fri Feb 22 08:54:29 2013 -0300
@@ -60,9 +60,10 @@
     <filename>/dev/video0</filename></para>
 
     <para>The underlying library currently supports EAN-13 (including
-    UPC and ISBN subsets), EAN-8, Code 128, Code 39, and Interleaved
-    2 of 5 symbologies.  The specific type of each detected symbol is
-    printed with the decoded data.</para>
+    UPC and ISBN subsets), EAN-8, DataBar, DataBar Expanded, Code 128,
+    Code 93, Code 39, Codabar, Interleaved 2 of 5 and QR Code symbologies.
+    The specific type of each detected symbol is printed with the decoded
+    data.</para>
 
   </refsection>
 
@@ -160,6 +161,37 @@
   </refsection>
 
   <refsection>
+    <title>Exit Status</title>
+
+    <para><command>zbarcam</command> returns an exit code to indicate the
+    status of the program execution. Current exit codes are:</para>
+
+    <variablelist>
+      <varlistentry>
+        <term>0</term>
+        <listitem>
+          <para>Successful program completion.</para>
+        </listitem>
+      </varlistentry>
+
+      <varlistentry>
+        <term>1</term>
+        <listitem>
+          <para>An error occurred.  This includes bad arguments and I/O
+          errors.</para>
+        </listitem>
+      </varlistentry>
+
+      <varlistentry>
+        <term>2</term>
+        <listitem>
+          <para>A fatal error occurred.</para>
+        </listitem>
+      </varlistentry>
+    </variablelist>
+  </refsection>
+
+  <refsection>
     <title>See Also</title>
     <para><xref linkend="zbarimg"/></para>
     <para><link xlink:href="http://zbar.sf.net/"/></para>
diff -r 563557a923d0 doc/ref/zbarimg.xml
--- a/doc/ref/zbarimg.xml	Tue Oct 27 11:25:59 2009 -0400
+++ b/doc/ref/zbarimg.xml	Fri Feb 22 08:54:29 2013 -0300
@@ -59,9 +59,10 @@
     displayed to the screen.</para>
 
     <para>The underlying library currently supports EAN-13 (including
-    UPC and ISBN subsets), EAN-8, Code 128, Code 39, and Interleaved
-    2 of 5 symbologies.  The specific type of each detected symbol is
-    printed with the decoded data.</para>
+    UPC and ISBN subsets), EAN-8, DataBar, DataBar Expanded, Code 128,
+    Code 93, Code 39, Codabar, Interleaved 2 of 5 and QR Code symbologies.
+    The specific type of each detected symbol is printed with the decoded
+    data.</para>
 
     <para>Note that "<filename><replaceable>image</replaceable></filename>"
 
@@ -166,6 +167,56 @@
   </refsection>
 
   <refsection>
+    <title>Exit Status</title>
+
+    <para><command>zbarimg</command> returns an exit code to indicate the
+    status of the program execution. Current exit codes are:</para>
+
+    <variablelist>
+      <varlistentry>
+        <term>0</term>
+        <listitem>
+          <para>Barcodes successfully detected in all images. Warnings may
+          have been generated, but no errors.</para>
+        </listitem>
+      </varlistentry>
+
+      <varlistentry>
+        <term>1</term>
+        <listitem>
+          <para>An error occurred while processing some image(s).  This
+          includes bad arguments, I/O errors and image handling errors from
+          ImageMagick.</para>
+        </listitem>
+      </varlistentry>
+
+      <varlistentry>
+        <term>2</term>
+        <listitem>
+          <para>ImageMagick fatal error.</para>
+        </listitem>
+      </varlistentry>
+
+      <varlistentry>
+        <term>3</term>
+        <listitem>
+          <para>The user quit the program before all images were scanned.
+          Only applies when running in interactive mode
+          (with <option>--display</option>)</para>
+        </listitem>
+      </varlistentry>
+
+      <varlistentry>
+        <term>4</term>
+        <listitem>
+          <para>No barcode was detected in one or more of the images.  No
+          other errors occurred.</para>
+        </listitem>
+      </varlistentry>
+    </variablelist>
+  </refsection>
+
+  <refsection>
     <title>See Also</title>
     <para><xref linkend="zbarcam"/></para>
     <para><link xlink:href="http://zbar.sf.net/"/></para>
diff -r 563557a923d0 examples/paginate.pl
--- a/examples/paginate.pl	Tue Oct 27 11:25:59 2009 -0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,71 +0,0 @@
-#!/usr/bin/perl
-#------------------------------------------------------------------------
-#  Copyright 2009 (c) Jeff Brown <spadix@users.sourceforge.net>
-#
-#  This file is part of the ZBar Bar Code Reader.
-#
-#  The ZBar Bar Code Reader is free software; you can redistribute it
-#  and/or modify it under the terms of the GNU Lesser Public License as
-#  published by the Free Software Foundation; either version 2.1 of
-#  the License, or (at your option) any later version.
-#
-#  The ZBar Bar Code Reader is distributed in the hope that it will be
-#  useful, but WITHOUT ANY WARRANTY; without even the implied warranty
-#  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-#  GNU Lesser Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser Public License
-#  along with the ZBar Bar Code Reader; if not, write to the Free
-#  Software Foundation, Inc., 51 Franklin St, Fifth Floor,
-#  Boston, MA  02110-1301  USA
-#
-#  http://sourceforge.net/projects/zbar
-#------------------------------------------------------------------------
-use warnings;
-use strict;
-
-use Barcode::ZBar;
-use Image::Magick;
-
-warn("no input files specified?\n") if(!@ARGV);
-
-# running output document
-my $out = undef;
-
-# barcode scanner
-my $scanner = Barcode::ZBar::ImageScanner->new();
-
-foreach my $file (@ARGV) {
-    print "scanning from \"$file\"\n";
-    my $imseq = Image::Magick->new();
-    my $err = $imseq->Read($file);
-    warn($err) if($err);
-
-    foreach my $page (@$imseq) {
-        # convert ImageMagick page to ZBar image
-        my $zimg = Barcode::ZBar::Image->new();
-        $zimg->set_format('Y800');
-        $zimg->set_size($page->Get(qw(columns rows)));
-        $zimg->set_data($page->Clone()->ImageToBlob(magick => 'GRAY', depth => 8));
-
-        # scan for barcodes
-        if($scanner->scan_image($zimg)) {
-            # write out previous document
-            $out->write() if($out);
-
-            # use first symbol found to name next image (FIXME sanitize)
-            my $data = ($zimg->get_symbols())[0]->get_data();
-            my $idx = $page->Get('scene') + 1;
-            print "splitting $data from page $idx\n";
-
-            # create new output document
-            $out = Image::Magick->new(filename => $data);
-        }
-
-        # append this page to current output
-        push(@$out, $page) if($out);
-    }
-
-    # write out final document
-    $out->write() if($out);
-}
diff -r 563557a923d0 examples/processor.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/examples/processor.c	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,47 @@
+#include <stdio.h>
+#include <zbar.h>
+
+static void my_handler (zbar_image_t *image,
+                        const void *userdata)
+{
+    /* extract results */
+    const zbar_symbol_t *symbol = zbar_image_first_symbol(image);
+    for(; symbol; symbol = zbar_symbol_next(symbol)) {
+        /* do something useful with results */
+        zbar_symbol_type_t typ = zbar_symbol_get_type(symbol);
+        const char *data = zbar_symbol_get_data(symbol);
+        printf("decoded %s symbol \"%s\"\n",
+               zbar_get_symbol_name(typ), data);
+    }
+}
+
+int main (int argc, char **argv)
+{
+    const char *device = "/dev/video0";
+
+    /* create a Processor */
+    zbar_processor_t *proc = zbar_processor_create(1);
+
+    /* configure the Processor */
+    zbar_processor_set_config(proc, 0, ZBAR_CFG_ENABLE, 1);
+
+    /* initialize the Processor */
+    if(argc > 1)
+        device = argv[1];
+    zbar_processor_init(proc, device, 1);
+
+    /* setup a callback */
+    zbar_processor_set_data_handler(proc, my_handler, NULL);
+
+    /* enable the preview window */
+    zbar_processor_set_visible(proc, 1);
+    zbar_processor_set_active(proc, 1);
+
+    /* keep scanning until user provides key/mouse input */
+    zbar_processor_user_wait(proc, -1);
+
+    /* clean up */
+    zbar_processor_destroy(proc);
+
+    return(0);
+}
diff -r 563557a923d0 examples/processor.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/examples/processor.cpp	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,45 @@
+#include <iostream>
+#include <zbar.h>
+
+using namespace std;
+using namespace zbar;
+
+class MyHandler : public Image::Handler
+{
+    void image_callback (Image &image)
+    {
+        for(SymbolIterator symbol = image.symbol_begin();
+            symbol != image.symbol_end();
+            ++symbol)
+            cout << "decoded " << symbol->get_type_name() << " symbol "
+                 << "\"" << symbol->get_data() << "\"" << endl;
+    }
+};
+
+int main (int argc, char **argv)
+{
+    // create and initialize a Processor
+    const char *device = "/dev/video0";
+    if(argc > 1)
+        device = argv[1];
+    Processor proc(true, device);
+
+    // configure the Processor
+    proc.set_config(ZBAR_NONE, ZBAR_CFG_ENABLE, 1);
+
+    // setup a callback
+    MyHandler my_handler;
+    proc.set_handler(my_handler);
+
+    // enable the preview window
+    proc.set_visible();
+    proc.set_active();
+
+    try {
+        // keep scanning until user provides key/mouse input
+        proc.user_wait();
+    }
+    catch(ClosedError &e) {
+    }
+    return(0);
+}
diff -r 563557a923d0 examples/processor.pl
--- a/examples/processor.pl	Tue Oct 27 11:25:59 2009 -0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,35 +0,0 @@
-#!/usr/bin/env perl
-use warnings;
-use strict;
-require Barcode::ZBar;
-
-# create a Processor
-my $proc = Barcode::ZBar::Processor->new();
-
-# configure the Processor
-$proc->parse_config("enable");
-
-# initialize the Processor
-$proc->init($ARGV[0] || '/dev/video0');
-
-# setup a callback
-sub my_handler {
-    my ($proc, $image, $closure) = @_;
-
-    # extract results
-    foreach my $symbol ($proc->get_results()) {
-        # do something useful with results
-        print('decoded ' . $symbol->get_type() .
-              ' symbol "' . $symbol->get_data() . "\"\n");
-    }
-}
-$proc->set_data_handler(\&my_handler);
-
-# enable the preview window
-$proc->set_visible();
-
-# initiate scanning
-$proc->set_active();
-
-# keep scanning until user provides key/mouse input
-$proc->user_wait();
diff -r 563557a923d0 examples/processor.py
--- a/examples/processor.py	Tue Oct 27 11:25:59 2009 -0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,35 +0,0 @@
-#!/usr/bin/python
-from sys import argv
-import zbar
-
-# create a Processor
-proc = zbar.Processor()
-
-# configure the Processor
-proc.parse_config('enable')
-
-# initialize the Processor
-device = '/dev/video0'
-if len(argv) > 1:
-    device = argv[1]
-proc.init(device)
-
-# setup a callback
-def my_handler(proc, image, closure):
-    # extract results
-    for symbol in image.symbols:
-        # do something useful with results
-        print 'decoded', symbol.type, 'symbol', '"%s"' % symbol.data
-
-proc.set_data_handler(my_handler)
-
-# enable the preview window
-proc.visible = True
-
-# initiate scanning
-proc.active = True
-try:
-    # keep scanning until user provides key/mouse input
-    proc.user_wait()
-except zbar.WindowClosed, e:
-    pass
diff -r 563557a923d0 examples/read_one.pl
--- a/examples/read_one.pl	Tue Oct 27 11:25:59 2009 -0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,29 +0,0 @@
-#!/usr/bin/env perl
-use warnings;
-use strict;
-require Barcode::ZBar;
-
-# create a Processor
-my $proc = Barcode::ZBar::Processor->new();
-
-# configure the Processor
-$proc->parse_config("enable");
-
-# initialize the Processor
-$proc->init($ARGV[0] || '/dev/video0');
-
-# enable the preview window
-$proc->set_visible();
-
-# read at least one barcode (or until window closed)
-$proc->process_one();
-
-# hide the preview window
-$proc->set_visible(0);
-
-# extract results
-foreach my $symbol ($proc->get_results()) {
-  # do something useful with results
-  print('decoded ' . $symbol->get_type() .
-        ' symbol "' . $symbol->get_data() . "\"\n");
-}
diff -r 563557a923d0 examples/read_one.py
--- a/examples/read_one.py	Tue Oct 27 11:25:59 2009 -0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,29 +0,0 @@
-#!/usr/bin/python
-from sys import argv
-import zbar
-
-# create a Processor
-proc = zbar.Processor()
-
-# configure the Processor
-proc.parse_config('enable')
-
-# initialize the Processor
-device = '/dev/video0'
-if len(argv) > 1:
-    device = argv[1]
-proc.init(device)
-
-# enable the preview window
-proc.visible = True
-
-# read at least one barcode (or until window closed)
-proc.process_one()
-
-# hide the preview window
-proc.visible = False
-
-# extract results
-for symbol in proc.results:
-    # do something useful with results
-    print 'decoded', symbol.type, 'symbol', '"%s"' % symbol.data
diff -r 563557a923d0 examples/scan_image.c
--- a/examples/scan_image.c	Tue Oct 27 11:25:59 2009 -0400
+++ b/examples/scan_image.c	Fri Feb 22 08:54:29 2013 -0300
@@ -3,6 +3,20 @@
 #include <png.h>
 #include <zbar.h>
 
+#if !defined(PNG_LIBPNG_VER) || \
+    PNG_LIBPNG_VER < 10018 ||   \
+    (PNG_LIBPNG_VER > 10200 &&  \
+     PNG_LIBPNG_VER < 10209)
+  /* Changes to Libpng from version 1.2.42 to 1.4.0 (January 4, 2010)
+   * ...
+   * 2. m. The function png_set_gray_1_2_4_to_8() was removed. It has been
+   *       deprecated since libpng-1.0.18 and 1.2.9, when it was replaced with
+   *       png_set_expand_gray_1_2_4_to_8() because the former function also
+   *       expanded palette images.
+   */
+# define png_set_expand_gray_1_2_4_to_8 png_set_gray_1_2_4_to_8
+#endif
+
 zbar_image_scanner_t *scanner = NULL;
 
 /* to complete a runnable example, this abbreviated implementation of
@@ -30,7 +44,7 @@
     if(color & PNG_COLOR_TYPE_PALETTE)
         png_set_palette_to_rgb(png);
     if(color == PNG_COLOR_TYPE_GRAY && bits < 8)
-        png_set_gray_1_2_4_to_8(png);
+        png_set_expand_gray_1_2_4_to_8(png);
     if(bits == 16)
         png_set_strip_16(png);
     if(color & PNG_COLOR_MASK_ALPHA)
@@ -65,7 +79,7 @@
 
     /* wrap image data */
     zbar_image_t *image = zbar_image_create();
-    zbar_image_set_format(image, *(int*)"Y800");
+    zbar_image_set_format(image, zbar_fourcc('Y','8','0','0'));
     zbar_image_set_size(image, width, height);
     zbar_image_set_data(image, raw, width * height, zbar_image_free_data);
 
diff -r 563557a923d0 examples/scan_image.pl
--- a/examples/scan_image.pl	Tue Oct 27 11:25:59 2009 -0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,37 +0,0 @@
-#!/usr/bin/perl
-use warnings;
-use strict;
-require Image::Magick;
-require Barcode::ZBar;
-
-$ARGV[0] || die;
-
-# create a reader
-my $scanner = Barcode::ZBar::ImageScanner->new();
-
-# configure the reader
-$scanner->parse_config("enable");
-
-# obtain image data
-my $magick = Image::Magick->new();
-$magick->Read($ARGV[0]) && die;
-my $raw = $magick->ImageToBlob(magick => 'GRAY', depth => 8);
-
-# wrap image data
-my $image = Barcode::ZBar::Image->new();
-$image->set_format('Y800');
-$image->set_size($magick->Get(qw(columns rows)));
-$image->set_data($raw);
-
-# scan the image for barcodes
-my $n = $scanner->scan_image($image);
-
-# extract results
-foreach my $symbol ($image->get_symbols()) {
-    # do something useful with results
-    print('decoded ' . $symbol->get_type() .
-          ' symbol "' . $symbol->get_data() . "\"\n");
-}
-
-# clean up
-undef($image);
diff -r 563557a923d0 examples/scan_image.py
--- a/examples/scan_image.py	Tue Oct 27 11:25:59 2009 -0400
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,31 +0,0 @@
-#!/usr/bin/python
-from sys import argv
-import zbar
-import Image
-
-if len(argv) < 2: exit(1)
-
-# create a reader
-scanner = zbar.ImageScanner()
-
-# configure the reader
-scanner.parse_config('enable')
-
-# obtain image data
-pil = Image.open(argv[1]).convert('L')
-width, height = pil.size
-raw = pil.tostring()
-
-# wrap image data
-image = zbar.Image(width, height, 'Y800', raw)
-
-# scan the image for barcodes
-scanner.scan(image)
-
-# extract results
-for symbol in image:
-    # do something useful with results
-    print 'decoded', symbol.type, 'symbol', '"%s"' % symbol.data
-
-# clean up
-del(image)
diff -r 563557a923d0 examples/upcrpc.pl
--- a/examples/upcrpc.pl	Tue Oct 27 11:25:59 2009 -0400
+++ b/examples/upcrpc.pl	Fri Feb 22 08:54:29 2013 -0300
@@ -3,7 +3,7 @@
 use strict;
 use Frontier::Client;
 use Data::Dumper;
-my $s = Frontier::Client->new('url' => 'http://dev.upcdatabase.com/rpc');
+my $s = Frontier::Client->new('url' => 'http://www.upcdatabase.com/rpc');
 
 $| = 1; # autoflush
 
diff -r 563557a923d0 examples/upcrpc.py
--- a/examples/upcrpc.py	Tue Oct 27 11:25:59 2009 -0400
+++ b/examples/upcrpc.py	Fri Feb 22 08:54:29 2013 -0300
@@ -2,7 +2,7 @@
 from xmlrpclib import ServerProxy
 import sys, re
 
-server = ServerProxy("http://dev.upcdatabase.com/rpc")
+server = ServerProxy("http://www.upcdatabase.com/rpc")
 ean_re = re.compile(r'^(UPC-A:|EAN-13:)?(\d{11,13})$', re.M)
 
 def lookup(decode):
diff -r 563557a923d0 gtk/zbargtk.c
--- a/gtk/zbargtk.c	Tue Oct 27 11:25:59 2009 -0400
+++ b/gtk/zbargtk.c	Fri Feb 22 08:54:29 2013 -0300
@@ -1,5 +1,5 @@
 /*------------------------------------------------------------------------
- *  Copyright 2008-2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *  Copyright 2008-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
  *
  *  This file is part of the ZBar Bar Code Reader.
  *
@@ -35,11 +35,6 @@
 #define DEFAULT_WIDTH 640
 #define DEFAULT_HEIGHT 480
 
-/* adapted from v4l2 spec */
-#define fourcc(a, b, c, d)                      \
-    ((long)(a) | ((long)(b) << 8) |             \
-     ((long)(c) << 16) | ((long)(d) << 24))
-
 enum {
     DECODED,
     DECODED_TEXT,
@@ -88,15 +83,15 @@
 
     /* these are all guesses... */
     if(nchannels == 3 && bps == 8)
-        type = fourcc('R','G','B','3');
+        type = zbar_fourcc('R','G','B','3');
     else if(nchannels == 4 && bps == 8)
-        type = fourcc('B','G','R','4'); /* FIXME alpha flipped?! */
+        type = zbar_fourcc('B','G','R','4'); /* FIXME alpha flipped?! */
     else if(nchannels == 1 && bps == 8)
-        type = fourcc('Y','8','0','0');
+        type = zbar_fourcc('Y','8','0','0');
     else if(nchannels == 3 && bps == 5)
-        type = fourcc('R','G','B','R');
+        type = zbar_fourcc('R','G','B','R');
     else if(nchannels == 3 && bps == 4)
-        type = fourcc('R','4','4','4'); /* FIXME maybe? */
+        type = zbar_fourcc('R','4','4','4'); /* FIXME maybe? */
     else {
         g_warning("unsupported combination: nchannels=%d bps=%d\n",
                   nchannels, bps);
@@ -142,10 +137,6 @@
 
     gdk_threads_enter();
 
-    zbar->req_width = DEFAULT_WIDTH;
-    zbar->req_height = DEFAULT_HEIGHT;
-    gtk_widget_queue_resize(GTK_WIDGET(self));
-
     zbar->video_opened = FALSE;
     if(zbar->thread)
         g_object_notify(G_OBJECT(self), "video-opened");
@@ -184,6 +175,10 @@
          */
         gdk_threads_enter();
 
+        if(zbar->video_width && zbar->video_height)
+            zbar_video_request_size(zbar->video,
+                                    zbar->video_width, zbar->video_height);
+
         video_opened = !zbar_negotiate_format(zbar->video, zbar->window);
 
         if(video_opened) {
@@ -209,7 +204,7 @@
     if(!image)
         return(-1);
 
-    zbar_image_t *tmp = zbar_image_convert(image, fourcc('Y','8','0','0'));
+    zbar_image_t *tmp = zbar_image_convert(image, zbar_fourcc('Y','8','0','0'));
     if(!tmp)
         return(-1);
 
@@ -236,7 +231,6 @@
 
                 /* FIXME skip this when unconnected? */
                 gchar *text = g_strconcat(zbar_get_symbol_name(type),
-                                          zbar_get_addon_name(type),
                                           ":",
                                           data,
                                           NULL);
@@ -560,6 +554,19 @@
     return(zbar->video_opened);
 }
 
+void zbar_gtk_request_video_size (ZBarGtk *self,
+                                  int width,
+                                  int height)
+{
+    if(!self->_private || width < 0 || height < 0)
+        return;
+    ZBarGtkPrivate *zbar = ZBAR_GTK_PRIVATE(self->_private);
+
+    zbar->req_width = zbar->video_width = width;
+    zbar->req_height = zbar->video_height = height;
+    gtk_widget_queue_resize(GTK_WIDGET(self));
+}
+
 static void zbar_gtk_set_property (GObject *object,
                                    guint prop_id,
                                    const GValue *value,
@@ -613,8 +620,8 @@
     zbar->window = zbar_window_create();
     g_assert(zbar->window);
 
-    zbar->req_width = DEFAULT_WIDTH;
-    zbar->req_height = DEFAULT_HEIGHT;
+    zbar->req_width = zbar->video_width = DEFAULT_WIDTH;
+    zbar->req_height = zbar->video_width = DEFAULT_HEIGHT;
 
     /* spawn a thread to handle decoding and video */
     zbar->queue = g_async_queue_new();
diff -r 563557a923d0 gtk/zbargtkprivate.h
--- a/gtk/zbargtkprivate.h	Tue Oct 27 11:25:59 2009 -0400
+++ b/gtk/zbargtkprivate.h	Fri Feb 22 08:54:29 2013 -0300
@@ -71,6 +71,7 @@
      * protected by main gui lock
      */
     unsigned req_width, req_height;
+    unsigned video_width, video_height;
     gboolean video_opened;
 
     /* window is shared: owned by main gui thread.
diff -r 563557a923d0 include/zbar.h
--- a/include/zbar.h	Tue Oct 27 11:25:59 2009 -0400
+++ b/include/zbar.h	Fri Feb 22 08:54:29 2013 -0300
@@ -1,5 +1,5 @@
 /*------------------------------------------------------------------------
- *  Copyright 2007-2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *  Copyright 2007-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
  *
  *  This file is part of the ZBar Bar Code Reader.
  *
@@ -86,23 +86,58 @@
 typedef enum zbar_symbol_type_e {
     ZBAR_NONE        =      0,  /**< no symbol decoded */
     ZBAR_PARTIAL     =      1,  /**< intermediate status */
+    ZBAR_EAN2        =      2,  /**< GS1 2-digit add-on */
+    ZBAR_EAN5        =      5,  /**< GS1 5-digit add-on */
     ZBAR_EAN8        =      8,  /**< EAN-8 */
     ZBAR_UPCE        =      9,  /**< UPC-E */
     ZBAR_ISBN10      =     10,  /**< ISBN-10 (from EAN-13). @since 0.4 */
     ZBAR_UPCA        =     12,  /**< UPC-A */
     ZBAR_EAN13       =     13,  /**< EAN-13 */
     ZBAR_ISBN13      =     14,  /**< ISBN-13 (from EAN-13). @since 0.4 */
+    ZBAR_COMPOSITE   =     15,  /**< EAN/UPC composite */
     ZBAR_I25         =     25,  /**< Interleaved 2 of 5. @since 0.4 */
+    ZBAR_DATABAR     =     34,  /**< GS1 DataBar (RSS). @since 0.11 */
+    ZBAR_DATABAR_EXP =     35,  /**< GS1 DataBar Expanded. @since 0.11 */
+    ZBAR_CODABAR     =     38,  /**< Codabar. @since 0.11 */
     ZBAR_CODE39      =     39,  /**< Code 39. @since 0.4 */
     ZBAR_PDF417      =     57,  /**< PDF417. @since 0.6 */
     ZBAR_QRCODE      =     64,  /**< QR Code. @since 0.10 */
+    ZBAR_CODE93      =     93,  /**< Code 93. @since 0.11 */
     ZBAR_CODE128     =    128,  /**< Code 128 */
-    ZBAR_SYMBOL      = 0x00ff,  /**< mask for base symbol type */
-    ZBAR_ADDON2      = 0x0200,  /**< 2-digit add-on flag */
-    ZBAR_ADDON5      = 0x0500,  /**< 5-digit add-on flag */
-    ZBAR_ADDON       = 0x0700,  /**< add-on flag mask */
+
+    /** mask for base symbol type.
+     * @deprecated in 0.11, remove this from existing code
+     */
+    ZBAR_SYMBOL      = 0x00ff,
+    /** 2-digit add-on flag.
+     * @deprecated in 0.11, a ::ZBAR_EAN2 component is used for
+     * 2-digit GS1 add-ons
+     */
+    ZBAR_ADDON2      = 0x0200,
+    /** 5-digit add-on flag.
+     * @deprecated in 0.11, a ::ZBAR_EAN5 component is used for
+     * 5-digit GS1 add-ons
+     */
+    ZBAR_ADDON5      = 0x0500,
+    /** add-on flag mask.
+     * @deprecated in 0.11, GS1 add-ons are represented using composite
+     * symbols of type ::ZBAR_COMPOSITE; add-on components use ::ZBAR_EAN2
+     * or ::ZBAR_EAN5
+     */
+    ZBAR_ADDON       = 0x0700,
 } zbar_symbol_type_t;
 
+/** decoded symbol coarse orientation.
+ * @since 0.11
+ */
+typedef enum zbar_orientation_e {
+    ZBAR_ORIENT_UNKNOWN = -1,   /**< unable to determine orientation */
+    ZBAR_ORIENT_UP,             /**< upright, read left to right */
+    ZBAR_ORIENT_RIGHT,          /**< sideways, read top to bottom */
+    ZBAR_ORIENT_DOWN,           /**< upside-down, read right to left */
+    ZBAR_ORIENT_LEFT,           /**< sideways, read bottom to top */
+} zbar_orientation_t;
+
 /** error codes. */
 typedef enum zbar_error_e {
     ZBAR_OK = 0,                /**< no error */
@@ -133,12 +168,33 @@
     ZBAR_CFG_MIN_LEN = 0x20,    /**< minimum data length for valid decode */
     ZBAR_CFG_MAX_LEN,           /**< maximum data length for valid decode */
 
+    ZBAR_CFG_UNCERTAINTY = 0x40,/**< required video consistency frames */
+
     ZBAR_CFG_POSITION = 0x80,   /**< enable scanner to collect position data */
 
     ZBAR_CFG_X_DENSITY = 0x100, /**< image scanner vertical scan density */
     ZBAR_CFG_Y_DENSITY,         /**< image scanner horizontal scan density */
 } zbar_config_t;
 
+/** decoder symbology modifier flags.
+ * @since 0.11
+ */
+typedef enum zbar_modifier_e {
+    /** barcode tagged as GS1 (EAN.UCC) reserved
+     * (eg, FNC1 before first data character).
+     * data may be parsed as a sequence of GS1 AIs
+     */
+    ZBAR_MOD_GS1 = 0,
+
+    /** barcode tagged as AIM reserved
+     * (eg, FNC1 after first character or digit pair)
+     */
+    ZBAR_MOD_AIM,
+
+    /** number of modifiers */
+    ZBAR_MOD_NUM,
+} zbar_modifier_t;
+
 /** retrieve runtime library version information.
  * @param major set to the running major version (unless NULL)
  * @param minor set to the running minor version (unless NULL)
@@ -168,9 +224,32 @@
  * @param sym symbol type encoding
  * @returns static string name for any addon, or the empty string
  * if no addons were decoded
+ * @deprecated in 0.11
  */
 extern const char *zbar_get_addon_name(zbar_symbol_type_t sym);
 
+/** retrieve string name for configuration setting.
+ * @param config setting to name
+ * @returns static string name for config,
+ * or the empty string if value is not a known config
+ */
+extern const char *zbar_get_config_name(zbar_config_t config);
+
+/** retrieve string name for modifier.
+ * @param modifier flag to name
+ * @returns static string name for modifier,
+ * or the empty string if the value is not a known flag
+ */
+extern const char *zbar_get_modifier_name(zbar_modifier_t modifier);
+
+/** retrieve string name for orientation.
+ * @param orientation orientation encoding
+ * @returns the static string name for the specified orientation,
+ * or "UNKNOWN" if the orientation is not recognized
+ * @since 0.11
+ */
+extern const char *zbar_get_orientation_name(zbar_orientation_t orientation);
+
 /** parse a configuration string of the form "[symbology.]config[=value]".
  * the config must match one of the recognized names.
  * the symbology, if present, must match one of the recognized names.
@@ -184,6 +263,30 @@
                              zbar_config_t *config,
                              int *value);
 
+/** consistently compute fourcc values across architectures
+ * (adapted from v4l2 specification)
+ * @since 0.11
+ */
+#define zbar_fourcc(a, b, c, d)                 \
+        ((unsigned long)(a) |                   \
+         ((unsigned long)(b) << 8) |            \
+         ((unsigned long)(c) << 16) |           \
+         ((unsigned long)(d) << 24))
+
+/** parse a fourcc string into its encoded integer value.
+ * @since 0.11
+ */
+static inline unsigned long zbar_fourcc_parse (const char *format)
+{
+    unsigned long fourcc = 0;
+    if(format) {
+        int i;
+        for(i = 0; i < 4 && format[i]; i++)
+            fourcc |= ((unsigned long)format[i]) << (i * 8);
+    }
+    return(fourcc);
+}
+
 /** @internal type unsafe error API (don't use) */
 extern int _zbar_error_spew(const void *object,
                             int verbosity);
@@ -229,6 +332,20 @@
  */
 extern zbar_symbol_type_t zbar_symbol_get_type(const zbar_symbol_t *symbol);
 
+/** retrieve symbology boolean config settings.
+ * @returns a bitmask indicating which configs were set for the detected
+ * symbology during decoding.
+ * @since 0.11
+ */
+extern unsigned int zbar_symbol_get_configs(const zbar_symbol_t *symbol);
+
+/** retrieve symbology modifier flag settings.
+ * @returns a bitmask indicating which characteristics were detected
+ * during decoding.
+ * @since 0.11
+ */
+extern unsigned int zbar_symbol_get_modifiers(const zbar_symbol_t *symbol);
+
 /** retrieve data decoded from symbol.
  * @returns the data string
  */
@@ -284,6 +401,14 @@
 extern int zbar_symbol_get_loc_y(const zbar_symbol_t *symbol,
                                  unsigned index);
 
+/** retrieve general orientation of decoded symbol.
+ * @returns a coarse, axis-aligned indication of symbol orientation or
+ * ::ZBAR_ORIENT_UNKNOWN if unknown
+ * @since 0.11
+ */
+extern zbar_orientation_t
+zbar_symbol_get_orientation(const zbar_symbol_t *symbol);
+
 /** iterate the set to which this symbol belongs (there can be only one).
  * @returns the next symbol in the set, or
  * @returns NULL when no more results are available
@@ -357,6 +482,14 @@
 extern const zbar_symbol_t*
 zbar_symbol_set_first_symbol(const zbar_symbol_set_t *symbols);
 
+/** raw result iterator.
+ * @returns the first decoded symbol result in a set, *before* filtering
+ * @returns NULL if the set is empty
+ * @since 0.11
+ */
+extern const zbar_symbol_t*
+zbar_symbol_set_first_unfiltered(const zbar_symbol_set_t *symbols);
+
 /*@}*/
 
 /*------------------------------------------------------------*/
@@ -456,6 +589,25 @@
  */
 extern unsigned zbar_image_get_height(const zbar_image_t *image);
 
+/** retrieve both dimensions of the image.
+ * fills in the width and height in samples
+ */
+extern void zbar_image_get_size(const zbar_image_t *image,
+                                unsigned *width,
+                                unsigned *height);
+
+/** retrieve the crop rectangle.
+ * fills in the image coordinates of the upper left corner and size
+ * of an axis-aligned rectangular area of the image that will be scanned.
+ * defaults to the full image
+ * @since 0.11
+ */
+extern void zbar_image_get_crop(const zbar_image_t *image,
+                                unsigned *x,
+                                unsigned *y,
+                                unsigned *width,
+                                unsigned *height);
+
 /** return the image sample data.  the returned data buffer is only
  * valid until zbar_image_destroy() is called
  */
@@ -505,12 +657,24 @@
                                     unsigned sequence_num);
 
 /** specify the pixel size of the image.
+ * @note this also resets the crop rectangle to the full image
+ * (0, 0, width, height)
  * @note this does not affect the data!
  */
 extern void zbar_image_set_size(zbar_image_t *image,
                                 unsigned width,
                                 unsigned height);
 
+/** specify a rectangular region of the image to scan.
+ * the rectangle will be clipped to the image boundaries.
+ * defaults to the full image specified by zbar_image_set_size()
+ */
+extern void zbar_image_set_crop(zbar_image_t *image,
+                                unsigned x,
+                                unsigned y,
+                                unsigned width,
+                                unsigned height);
+
 /** specify image sample data.  when image data is no longer needed by
  * the library the specific data cleanup handler will be called
  * (unless NULL)
@@ -1148,6 +1312,14 @@
            zbar_decoder_set_config(decoder, sym, cfg, val));
 }
 
+/** retrieve symbology boolean config settings.
+ * @returns a bitmask indicating which configs are currently set for the
+ * specified symbology.
+ * @since 0.11
+ */
+extern unsigned int zbar_decoder_get_configs(const zbar_decoder_t *decoder,
+                                             zbar_symbol_type_t symbology);
+
 /** clear all decoder state.
  * any partial symbols are flushed
  */
@@ -1195,6 +1367,20 @@
 extern zbar_symbol_type_t
 zbar_decoder_get_type(const zbar_decoder_t *decoder);
 
+/** retrieve modifier flags for the last decoded symbol.
+ * @returns a bitmask indicating which characteristics were detected
+ * during decoding.
+ * @since 0.11
+ */
+extern unsigned int zbar_decoder_get_modifiers(const zbar_decoder_t *decoder);
+
+/** retrieve last decode direction.
+ * @returns 1 for forward and -1 for reverse
+ * @returns 0 if the decode direction is unknown or does not apply
+ * @since 0.11
+ */
+extern int zbar_decoder_get_direction(const zbar_decoder_t *decoder);
+
 /** setup data handler callback.
  * the registered function will be called by the decoder
  * just before zbar_decode_width() returns a non-zero value.
diff -r 563557a923d0 include/zbar/Decoder.h
--- a/include/zbar/Decoder.h	Tue Oct 27 11:25:59 2009 -0400
+++ b/include/zbar/Decoder.h	Fri Feb 22 08:54:29 2013 -0300
@@ -1,5 +1,5 @@
 //------------------------------------------------------------------------
-//  Copyright 2007-2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+//  Copyright 2007-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
 //
 //  This file is part of the ZBar Bar Code Reader.
 //
@@ -115,6 +115,7 @@
 
     /// retrieve string name for last decode addon.
     /// see zbar_get_addon_name()
+    /// @deprecated in 0.11
     const char *get_addon_name () const
     {
         return(zbar_get_addon_name(zbar_decoder_get_type(_decoder)));
@@ -149,6 +150,14 @@
         return(zbar_decoder_get_data_length(_decoder));
     }
 
+    /// retrieve last decode direction.
+    /// see zbar_decoder_get_direction()
+    /// @since 0.11
+    int get_direction() const
+    {
+        return(zbar_decoder_get_direction(_decoder));
+    }
+
     /// setup callback to handle result data.
     void set_handler (Handler &handler)
     {
diff -r 563557a923d0 include/zbar/Image.h
--- a/include/zbar/Image.h	Tue Oct 27 11:25:59 2009 -0400
+++ b/include/zbar/Image.h	Fri Feb 22 08:54:29 2013 -0300
@@ -1,5 +1,5 @@
 //------------------------------------------------------------------------
-//  Copyright 2007-2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+//  Copyright 2007-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
 //
 //  This file is part of the ZBar Bar Code Reader.
 //
@@ -67,7 +67,12 @@
         {
             if(userdata) {
                 Image *image = (Image*)zbar_image_get_userdata(zimg);
-                ((Handler*)userdata)->image_callback(*image);
+                if(image)
+                    ((Handler*)userdata)->image_callback(*image);
+                else {
+                    Image tmp(zimg, 1);
+                    ((Handler*)userdata)->image_callback(tmp);
+                }
             }
         }
     };
@@ -110,6 +115,8 @@
 
     ~Image ()
     {
+        if(zbar_image_get_userdata(_img) == this)
+            zbar_image_set_userdata(_img, NULL);
         zbar_image_ref(_img, -1);
     }
 
@@ -143,12 +150,7 @@
     /// see zbar_image_set_format()
     void set_format (const std::string& format)
     {
-        if(format.length() != 4)
-            throw FormatError();
-        unsigned long fourcc = ((format[0] & 0xff) |
-                                ((format[1] & 0xff) << 8) |
-                                ((format[2] & 0xff) << 16) |
-                                ((format[3] & 0xff) << 24));
+        unsigned long fourcc = zbar_fourcc_parse(format.c_str());
         zbar_image_set_format(_img, fourcc);
     }
 
@@ -183,6 +185,15 @@
         return(zbar_image_get_height(_img));
     }
 
+    /// retrieve both dimensions of the image.
+    /// see zbar_image_get_size()
+    /// @since 0.11
+    void get_size (unsigned &width,
+                   unsigned &height) const
+    {
+        zbar_image_get_size(_img, &width, &height);
+    }
+
     /// specify the pixel size of the image.
     /// see zbar_image_set_size()
     void set_size (unsigned width,
@@ -191,6 +202,26 @@
         zbar_image_set_size(_img, width, height);
     }
 
+    /// retrieve the scan crop rectangle.
+    /// see zbar_image_get_crop()
+    void get_crop (unsigned &x,
+                   unsigned &y,
+                   unsigned &width,
+                   unsigned &height) const
+    {
+        zbar_image_get_crop(_img, &x, &y, &width, &height);
+    }
+
+    /// set the scan crop rectangle.
+    /// see zbar_image_set_crop()
+    void set_crop (unsigned x,
+                   unsigned y,
+                   unsigned width,
+                   unsigned height)
+    {
+        zbar_image_set_crop(_img, x, y, width, height);
+    }
+
     /// return the image sample data.
     /// see zbar_image_get_data()
     const void *get_data () const
@@ -224,6 +255,15 @@
         throw FormatError();
     }
 
+    /// image format conversion.
+    /// see zbar_image_convert()
+    /// @since 0.11
+    Image convert (std::string format) const
+    {
+        unsigned long fourcc = zbar_fourcc_parse(format.c_str());
+        return(convert(fourcc));
+    }
+
     /// image format conversion with crop/pad.
     /// see zbar_image_convert_resize()
     /// @since 0.4
@@ -278,7 +318,6 @@
     {
         // by default nothing is cleaned
         assert(img);
-        assert(zbar_image_get_userdata(img));
     }
 
 private:
diff -r 563557a923d0 include/zbar/Processor.h
--- a/include/zbar/Processor.h	Tue Oct 27 11:25:59 2009 -0400
+++ b/include/zbar/Processor.h	Fri Feb 22 08:54:29 2013 -0300
@@ -1,5 +1,5 @@
 //------------------------------------------------------------------------
-//  Copyright 2007-2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+//  Copyright 2007-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
 //
 //  This file is part of the ZBar Bar Code Reader.
 //
@@ -183,8 +183,8 @@
     void force_format (std::string& input_format,
                        std::string& output_format)
     {
-        unsigned long ifourcc = *(unsigned long*)input_format.c_str();
-        unsigned long ofourcc = *(unsigned long*)output_format.c_str();
+        unsigned long ifourcc = zbar_fourcc_parse(input_format.c_str());
+        unsigned long ofourcc = zbar_fourcc_parse(output_format.c_str());
         if(zbar_processor_force_format(_processor, ifourcc, ofourcc))
             throw_exception(_processor);
     }
diff -r 563557a923d0 include/zbar/QZBarImage.h
--- a/include/zbar/QZBarImage.h	Tue Oct 27 11:25:59 2009 -0400
+++ b/include/zbar/QZBarImage.h	Fri Feb 22 08:54:29 2013 -0300
@@ -1,5 +1,5 @@
 //------------------------------------------------------------------------
-//  Copyright 2008-2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+//  Copyright 2008-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
 //
 //  This file is part of the ZBar Bar Code Reader.
 //
@@ -53,7 +53,7 @@
         unsigned width = bpl / 4;
         unsigned height = qimg.height();
         set_size(width, height);
-        set_format('B' | ('G' << 8) | ('R' << 16) | ('4' << 24));
+        set_format(zbar_fourcc('B','G','R','4'));
         unsigned long datalen = qimg.numBytes();
         set_data(qimg.bits(), datalen);
 
diff -r 563557a923d0 include/zbar/Symbol.h
--- a/include/zbar/Symbol.h	Tue Oct 27 11:25:59 2009 -0400
+++ b/include/zbar/Symbol.h	Fri Feb 22 08:54:29 2013 -0300
@@ -1,5 +1,5 @@
 //------------------------------------------------------------------------
-//  Copyright 2007-2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+//  Copyright 2007-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
 //
 //  This file is part of the ZBar Bar Code Reader.
 //
@@ -64,6 +64,21 @@
         ref(-1);
     }
 
+    /// assignment.
+    SymbolSet& operator= (const SymbolSet& syms)
+    {
+        syms.ref();
+        ref(-1);
+        _syms = syms._syms;
+        return(*this);
+    }
+
+    /// truth testing.
+    bool operator! () const
+    {
+        return(!_syms || !get_size());
+    }
+
     /// manipulate reference count.
     void ref (int delta = 1) const
     {
@@ -77,7 +92,7 @@
         return(_syms);
     }
 
-    int get_size ()
+    int get_size () const
     {
         return((_syms) ? zbar_symbol_set_get_size(_syms) : 0);
     }
@@ -112,9 +127,16 @@
 
         /// copy constructor.
         Point (const Point& pt)
+            : x(pt.x),
+              y(pt.y)
+        { }
+
+        /// assignment.
+        Point& operator= (const Point& pt)
         {
             x = pt.x;
             y = pt.y;
+            return(*this);
         }
     };
 
@@ -129,31 +151,52 @@
             : _sym(sym),
               _index(index)
         {
-            sym->ref(1);
+            if(sym)
+                sym->ref(1);
             if(!sym ||
                (unsigned)_index >= zbar_symbol_get_loc_size(*_sym))
                 _index = -1;
         }
 
-        /// constructor.
+        /// copy constructor.
         PointIterator (const PointIterator& iter)
             : _sym(iter._sym),
               _index(iter._index)
         {
-            _sym->ref();
+            if(_sym)
+                _sym->ref();
         }
 
         /// destructor.
         ~PointIterator ()
         {
-            _sym->ref(-1);
+            if(_sym)
+                _sym->ref(-1);
+        }
+
+        /// assignment.
+        PointIterator& operator= (const PointIterator& iter)
+        {
+            if(iter._sym)
+                iter._sym->ref();
+            if(_sym)
+                _sym->ref(-1);
+            _sym = iter._sym;
+            _index = iter._index;
+            return(*this);
+        }
+
+        /// truth testing.
+        bool operator! () const
+        {
+            return(!_sym || _index < 0);
         }
 
         /// advance iterator to next Point.
         PointIterator& operator++ ()
         {
             unsigned int i = ++_index;
-            if(i >= zbar_symbol_get_loc_size(*_sym))
+            if(!_sym || i >= zbar_symbol_get_loc_size(*_sym))
                 _index = -1;
             return(*this);
         }
@@ -161,7 +204,9 @@
         /// retrieve currently referenced Point.
         const Point operator* () const
         {
-            assert(_index >= 0);
+            assert(!!*this);
+            if(!*this)
+                return(Point());
             return(Point(zbar_symbol_get_loc_x(*_sym, _index),
                          zbar_symbol_get_loc_y(*_sym, _index)));
         }
@@ -213,6 +258,32 @@
         ref(-1);
     }
 
+    /// assignment.
+    Symbol& operator= (const Symbol& sym)
+    {
+        sym.ref(1);
+        ref(-1);
+        _sym = sym._sym;
+        _type = sym._type;
+        _data = sym._data;
+        return(*this);
+    }
+
+    Symbol& operator= (const zbar_symbol_t *sym)
+    {
+        if(sym)
+            zbar_symbol_ref(sym, 1);
+        ref(-1);
+        init(sym);
+        return(*this);
+    }
+
+    /// truth testing.
+    bool operator! () const
+    {
+        return(!_sym);
+    }
+
     void ref (int delta = 1) const
     {
         if(_sym)
@@ -250,6 +321,7 @@
     }
 
     /// retrieve the string name for any addon.
+    /// @deprecated in 0.11
     const std::string get_addon_name () const
     {
         return(zbar_get_addon_name(_type));
@@ -269,12 +341,20 @@
 
     /// retrieve inter-frame coherency count.
     /// see zbar_symbol_get_count()
-    /// @since 1.5
+    /// @since 0.5
     int get_count () const
     {
         return((_sym) ? zbar_symbol_get_count(_sym) : -1);
     }
 
+    /// retrieve loosely defined relative quality metric.
+    /// see zbar_symbol_get_quality()
+    /// @since 0.11
+    int get_quality () const
+    {
+        return((_sym) ? zbar_symbol_get_quality(_sym) : 0);
+    }
+
     SymbolSet get_components () const
     {
         return(SymbolSet((_sym) ? zbar_symbol_get_components(_sym) : NULL));
@@ -311,6 +391,13 @@
         return((_sym) ? zbar_symbol_get_loc_y(_sym, index) : -1);
     }
 
+    /// see zbar_symbol_get_orientation().
+    /// @since 0.11
+    int get_orientation () const
+    {
+        return(zbar_symbol_get_orientation(_sym));
+    }
+
     /// see zbar_symbol_xml().
     const std::string xml () const
     {
@@ -320,9 +407,6 @@
     }
 
 protected:
-
-    friend class SymbolIterator;
-
     /// (re)initialize Symbol from C symbol object.
     void init (const zbar_symbol_t *sym = NULL)
     {
@@ -361,7 +445,7 @@
     {
         const zbar_symbol_set_t *zsyms = _syms;
         if(zsyms)
-            _sym.init(zbar_symbol_set_first_symbol(zsyms));
+            _sym = zbar_symbol_set_first_symbol(zsyms);
     }
 
     /// copy constructor.
@@ -370,25 +454,33 @@
     {
         const zbar_symbol_set_t *zsyms = _syms;
         if(zsyms)
-            _sym.init(zbar_symbol_set_first_symbol(zsyms));
+            _sym = zbar_symbol_set_first_symbol(zsyms);
     }
 
     ~SymbolIterator ()
     {
-        _sym.init();
+    }
+
+    /// assignment.
+    SymbolIterator& operator= (const SymbolIterator& iter)
+    {
+        _syms = iter._syms;
+        _sym = iter._sym;
+        return(*this);
+    }
+
+    bool operator! () const
+    {
+        return(!_syms || !_sym);
     }
 
     /// advance iterator to next Symbol.
     SymbolIterator& operator++ ()
     {
-        const zbar_symbol_t *zsym = _sym;
-        if(zsym)
-            _sym.init(zbar_symbol_next(zsym));
-        else {
-            const zbar_symbol_set_t *zsyms = _syms;
-            if(zsyms)
-                _sym.init(zbar_symbol_set_first_symbol(zsyms));
-        }
+        if(!!_sym)
+            _sym = zbar_symbol_next(_sym);
+        else if(!!_syms)
+            _sym = zbar_symbol_set_first_symbol(_syms);
         return(*this);
     }
 
@@ -440,9 +532,7 @@
 static inline std::ostream& operator<< (std::ostream& out,
                                         const Symbol& sym)
 {
-    out << sym.get_type_name()
-        << sym.get_addon_name()
-        << ":" << sym.get_data();
+    out << sym.get_type_name() << ":" << sym.get_data();
     return(out);
 }
 
diff -r 563557a923d0 include/zbar/Video.h
--- a/include/zbar/Video.h	Tue Oct 27 11:25:59 2009 -0400
+++ b/include/zbar/Video.h	Fri Feb 22 08:54:29 2013 -0300
@@ -1,5 +1,5 @@
 //------------------------------------------------------------------------
-//  Copyright 2007-2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+//  Copyright 2007-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
 //
 //  This file is part of the ZBar Bar Code Reader.
 //
@@ -92,7 +92,7 @@
     /// see zbar_video_init()
     void init (std::string& format)
     {
-        unsigned int fourcc = *(unsigned int*)format.c_str();
+        unsigned int fourcc = zbar_fourcc_parse(format.c_str());
         if(zbar_video_init(_video, fourcc))
             throw_exception(_video);
     }
diff -r 563557a923d0 include/zbar/zbargtk.h
--- a/include/zbar/zbargtk.h	Tue Oct 27 11:25:59 2009 -0400
+++ b/include/zbar/zbargtk.h	Fri Feb 22 08:54:29 2013 -0300
@@ -136,7 +136,7 @@
 
 GType zbar_gtk_get_type(void) G_GNUC_CONST;
 
-/** 
+/**
  * zbar_gtk_new:
  * create a new barcode reader widget instance.
  * initially has no associated video device or image.
@@ -189,7 +189,17 @@
  */
 gboolean zbar_gtk_get_video_opened(ZBarGtk *zbar);
 
-/** 
+/** set video camera resolution.
+ * @width: width in pixels
+ * @height: height in pixels
+ *
+ * @note this call must be made before video is initialized
+ */
+void zbar_gtk_request_video_size(ZBarGtk *zbar,
+                                 int width,
+                                 int height);
+
+/**
  * utility function to populate a zbar_image_t from a GdkPixbuf.
  * @image: the zbar library image destination to populate
  * @pixbuf: the GdkPixbuf source
diff -r 563557a923d0 iphone/ChangeLog
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/ChangeLog	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,138 @@
+version 1.3.1:
+  * fix examples
+    - fix EmbedReader initial iPad orientation
+    - fix TabReader shouldn't show controls
+  * add retry workaround when device lock fails
+    - add iPhone 5 launch image to examples
+    - doc updates
+  * Lion and Xcode updates
+    - fix new warnings/errors
+    - find missing buddy
+    - fix SDK bg image: force resoution to 72dpi
+  * Fix EmbedReader example rotation interaction
+
+version 1.2.2:
+  * reduce controller present and dismiss latency
+    - add simple shutter to mask video start
+
+version 1.2.1:
+  * fix overlay resizing bug
+
+version 1.2:
+  * release updates
+
+version 1.1.3:
+  * fix UITabViewController rotation interaction
+
+version 1.1.2:
+  * add maxZoom for increasing zoom range
+    - workaround camera preview initial location/size bug
+  * add emulation for UI videoQuality to adjust camera resolution
+  * fix several simulator-related bugs
+    - fix device property missing from simulated ZBarReaderView
+    - fix AVCaptureDevice referenced from ZBarReaderViewController
+    - fix simulated camera gesture multiple recognition
+
+version 1.1.1:
+  * fix ReaderSample project path to ZBarSDK
+  * README document new examples
+    - make ReaderSample scheme public
+  * documentation updates
+  * add emulation for UI camera device and flash mode properties
+  * workaround orientation bugs in parent controllers
+    - enable orientation and iPad support for all examples
+  * add orientation detection fall back
+  * fix captureReader not exposed to simulator
+  * fix camera preview stale rotation corner
+    - fix ZBarReaderViewController toolbar layout accomodation
+    - switch pre-release samples to use debug library
+  * update docs to note possible link order dependency
+  * add missing references to new samples
+  * add IB support to ZBarReaderViewController
+    - add tabbed reader sample
+  * add embedded reader sample
+    - factor out camera simulation logic
+  * fix readertest max quality result filtering
+    - thanks to John Boydon for finding this!
+  * improve support for resizing, rotating and embedding the reader
+  * add readertest fixed zoom stops
+  * add manual frame capture
+    - readertest save as PNG
+  * enhance readertest to support default/demo pre-config and distribution
+  * updates for Xcode 4
+  * expose tracking box color
+
+version 1.1:
+  * fix doc typo (bug #3139087)
+    - add modifier bit docs
+
+version 1.0.1:
+  * hotfix broken ZBarHelpController back button
+  * release updates
+    - update docs
+  * fix support for GS1 AIs
+  * fix simulated camera image orientation/scaling
+  * cleanup and expose ZBarHelpController
+  * expose enable for reader capture processing
+  * workaround iOS 4.2 hang
+    - update to use latest SDK
+  * add support for Code 93 symbology
+
+version 1.0:
+  * update to SDK 4.1, clean out LLVM warnings
+  * fix camera simulation gesture
+
+version 0.1.2:
+  * fix missing header dependency
+  * doc enhancements
+  * force controls to front when showsZBarControls is enabled
+  * fix initial zoom crop (performance bug)
+  * workaround iPhone quartz access past image data
+
+version 0.1.1:
+  * migrate to binary iPhone SDK distribution (NB backward incompatibilities!)
+    - restructure headers
+
+version 0.1:
+  * workaround for iPhone simulator builds
+    - refactor ZBarReaderView for capture/simulator specific implementations
+    - fix tracking calculations
+    - fix captured video frame color conversion
+  * fix for poor iPhone 4 performance
+  * enable torch for iPhone 4
+  * fix iPhone circular ref bug
+  * add iPhone cache flush, change new libs to weak refs
+  * fix iPhone async ref bug
+  * enhance iPhone readertest w/more options
+  * add iPhone zoom support, integrate with crop
+  * add iPhone OS 4.0 video capture support
+    - replacement view controller for new camera reader
+    - separate view for use without controller
+    - separate capture delegate for use standalone
+    - add continuous autofocus
+  * cleanup and expose iphone help display API
+  * fixes to new iphone help display
+  * migrate iphone help display to integrated web page (NB resource updates!)
+    - allows easier customization
+    - local links open directly, external links confirm and jump out to Safari
+    - JavaScript hook for help context customization
+    - also enhanced default help (note this changes the required resources)
+    - fix to disable scanning during help overlay
+    - thanks to iafanasyev and others for detailed suggestions
+  * fix iphone custom overlay response (bug #2959617)
+    - thanks to an anonymous user for the patch!
+  * iphone widget performance tuning enhancements
+    - fix crop calculation bug in ZBarImage
+    - add properties to control pre-scan image cropping and scaling
+    - add property for scanner cache control
+    - enable some scanner density control (FIXME should be property)
+    - fix ifdef for quality control (FIXME should be property)
+    - add "sequence" mode test (not actually so useful)
+  * realtime scanning for iphone widget
+    - uses UIGetScreenImage() (NB private)
+    - ZBarImage from CGImage (instead of UIImage)
+    - add crop to scaling step
+    - expose symbol set unfiltered results
+  * iphone widget back compat updates, add basic test app
+  * add Obj-C wrapper
+  * first pass working iPhone "widget"
diff -r 563557a923d0 iphone/README
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/README	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,66 @@
+ZBar iOS SDK
+============
+
+ZBar Bar Code Reader is an open source software suite for reading bar
+codes from various sources, such as video streams, image files and raw
+intensity sensors. It supports EAN-13/UPC-A, UPC-E, EAN-8, DataBar,
+Code 128, Code 93, Code 39, Codabar, Interleaved 2 of 5 and QR Code.
+These are the Objective C wrappers and integrated widget for developing
+with the library on the iOS platform.
+
+Check the ZBar project home page for the latest release, forums, etc.
+
+* http://zbar.sourceforge.net/iphone
+
+Installation
+------------
+
+If you are migrating from a pre-SDK source version of the library,
+first make sure you remove all of the old references to zbar.xcodeproj
+and libzbar.a and revert any related build settings.
+
+To add the SDK to an Xcode project:
+
+   1. Drag ZBarSDK into your Xcode project.
+   3. Add these system frameworks to your project:
+      * AVFoundation.framework (weak)
+      * CoreMedia.framework (weak)
+      * CoreVideo.framework (weak)
+      * QuartzCore.framework
+      * libiconv.dylib
+
+Documentation
+-------------
+
+See Documentation.html for complete SDK documentation.
+
+Examples
+--------
+
+You should be able to open and build the examples directly from the
+disk image (ignore warnings about the read-only volume).  If you have
+problems with this, please copy the examples to your local drive
+instead and build from there.
+
+A tutorial that walks through installing and using the SDK is
+available in the documentation.  The SDK disk image also contains the
+resulting Xcode project at Examples/ReaderSample.
+
+Examples/readertest demonstrates most of the configuration options
+available for the reader.
+
+Examples/TabReader shows how you can use Interface Builder to add the
+reader as a tab in a UITabBarController.
+
+Examples/EmbedReader shows how a ZBarReaderView may be embedded
+directly in the application view hierarchy.
+
+Copyright and License
+---------------------
+
+Licensed under the GNU Lesser General Public License, version 2.1.
+http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt
+
+Copyright 2008-2011 © Jeff Brown <spadix@users.sourceforge.net> et al
+
+See the included files COPYING and LICENSE for details
diff -r 563557a923d0 iphone/ZBarCVImage.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/ZBarCVImage.h	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,43 @@
+//------------------------------------------------------------------------
+//  Copyright 2010 (c) Jeff Brown <spadix@users.sourceforge.net>
+//
+//  This file is part of the ZBar Bar Code Reader.
+//
+//  The ZBar Bar Code Reader is free software; you can redistribute it
+//  and/or modify it under the terms of the GNU Lesser Public License as
+//  published by the Free Software Foundation; either version 2.1 of
+//  the License, or (at your option) any later version.
+//
+//  The ZBar Bar Code Reader is distributed in the hope that it will be
+//  useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+//  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU Lesser Public License for more details.
+//
+//  You should have received a copy of the GNU Lesser Public License
+//  along with the ZBar Bar Code Reader; if not, write to the Free
+//  Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+//  Boston, MA  02110-1301  USA
+//
+//  http://sourceforge.net/projects/zbar
+//------------------------------------------------------------------------
+
+#import <ZBarSDK/ZBarImage.h>
+#import <CoreVideo/CoreVideo.h>
+
+// ZBarImage referring to a CVPixelBuffer.  used internally to handle
+// asynchronous conversion to UIImage
+
+@interface ZBarCVImage
+    : ZBarImage
+{
+    CVPixelBufferRef pixelBuffer;
+    void *rgbBuffer;
+    NSInvocationOperation *conversion;
+}
+
+- (void) waitUntilConverted;
+
+@property (nonatomic) CVPixelBufferRef pixelBuffer;
+@property (nonatomic, readonly) void *rgbBuffer;
+
+@end
diff -r 563557a923d0 iphone/ZBarCVImage.m
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/ZBarCVImage.m	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,195 @@
+//------------------------------------------------------------------------
+//  Copyright 2010 (c) Jeff Brown <spadix@users.sourceforge.net>
+//
+//  This file is part of the ZBar Bar Code Reader.
+//
+//  The ZBar Bar Code Reader is free software; you can redistribute it
+//  and/or modify it under the terms of the GNU Lesser Public License as
+//  published by the Free Software Foundation; either version 2.1 of
+//  the License, or (at your option) any later version.
+//
+//  The ZBar Bar Code Reader is distributed in the hope that it will be
+//  useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+//  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU Lesser Public License for more details.
+//
+//  You should have received a copy of the GNU Lesser Public License
+//  along with the ZBar Bar Code Reader; if not, write to the Free
+//  Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+//  Boston, MA  02110-1301  USA
+//
+//  http://sourceforge.net/projects/zbar
+//------------------------------------------------------------------------
+
+#import "ZBarCVImage.h"
+#define MODULE ZBarCVImage
+#import "debug.h"
+
+static NSOperationQueue *conversionQueue;
+
+static const void*
+asyncProvider_getBytePointer (void *info)
+{
+    // block until data is available
+    ZBarCVImage *image = info;
+    assert(image);
+    [image waitUntilConverted];
+    void *buf = image.rgbBuffer;
+    assert(buf);
+    return(buf);
+}
+
+static const CGDataProviderDirectCallbacks asyncProvider = {
+    .version = 0,
+    .getBytePointer = asyncProvider_getBytePointer,
+    .releaseBytePointer = NULL,
+    .getBytesAtPosition = NULL,
+    .releaseInfo = (void*)CFRelease,
+};
+
+@implementation ZBarCVImage
+
+@synthesize pixelBuffer, rgbBuffer;
+
+- (void) dealloc
+{
+    self.pixelBuffer = NULL;
+    if(rgbBuffer) {
+        free(rgbBuffer);
+        rgbBuffer = NULL;
+    }
+    [conversion release];
+    conversion = nil;
+    [super dealloc];
+}
+
+- (void) setPixelBuffer: (CVPixelBufferRef) newbuf
+{
+    CVPixelBufferRef oldbuf = pixelBuffer;
+    if(newbuf)
+        CVPixelBufferRetain(newbuf);
+    pixelBuffer = newbuf;
+    if(oldbuf)
+        CVPixelBufferRelease(oldbuf);
+}
+
+- (void) waitUntilConverted
+{
+    // operation will at least have been queued already
+    NSOperation *op = [conversion retain];
+    if(!op)
+        return;
+    [op waitUntilFinished];
+    [op release];
+}
+
+- (UIImage*) UIImageWithOrientation: (UIImageOrientation) orient
+{
+    if(!conversion && !rgbBuffer) {
+        // start format conversion in separate thread
+        NSOperationQueue *queue = conversionQueue;
+        if(!queue) {
+            queue = conversionQueue = [NSOperationQueue new];
+            queue.maxConcurrentOperationCount = 1;
+        }
+        else
+            [queue waitUntilAllOperationsAreFinished];
+
+        conversion = [[NSInvocationOperation alloc]
+                         initWithTarget: self
+                         selector: @selector(convertCVtoRGB)
+                         object: nil];
+        [queue addOperation: conversion];
+        [conversion release];
+    }
+
+    // create UIImage before converted data is available
+    CGSize size = self.size;
+    int w = size.width;
+    int h = size.height;
+
+    CGDataProviderRef datasrc =
+        CGDataProviderCreateDirect([self retain], 3 * w * h, &asyncProvider);
+    CGColorSpaceRef cs = CGColorSpaceCreateDeviceRGB();
+    CGImageRef cgimg =
+        CGImageCreate(w, h, 8, 24, 3 * w, cs,
+                      kCGBitmapByteOrderDefault, datasrc,
+                      NULL, YES, kCGRenderingIntentDefault);
+    CGColorSpaceRelease(cs);
+    CGDataProviderRelease(datasrc);
+
+    UIImage *uiimg =
+        [UIImage imageWithCGImage: cgimg
+                 scale: 1
+                 orientation: orient];
+    CGImageRelease(cgimg);
+
+    return(uiimg);
+}
+
+// convert video frame to a CGImage compatible RGB format
+// FIXME this is temporary until we can find the native way...
+- (void) convertCVtoRGB
+{
+    timer_start;
+    unsigned long format = self.format;
+    assert(format == zbar_fourcc('C','V','2','P'));
+    if(format != zbar_fourcc('C','V','2','P'))
+        return;
+
+    CVPixelBufferLockBaseAddress(pixelBuffer, kCVPixelBufferLock_ReadOnly);
+    int w = CVPixelBufferGetWidth(pixelBuffer);
+    int h = CVPixelBufferGetHeight(pixelBuffer);
+    int dy = CVPixelBufferGetBytesPerRowOfPlane(pixelBuffer, 0);
+    int duv = CVPixelBufferGetBytesPerRowOfPlane(pixelBuffer, 1);
+    uint8_t *py = CVPixelBufferGetBaseAddressOfPlane(pixelBuffer, 0);
+    uint8_t *puv = CVPixelBufferGetBaseAddressOfPlane(pixelBuffer, 1);
+    if(!py || !puv || dy < w || duv < w)
+        goto error;
+
+    int datalen = 3 * w * h;
+    // Quartz accesses some undocumented amount past allocated data?
+    // ...allocate extra to compensate
+    uint8_t *pdst = rgbBuffer = malloc(datalen + 3 * w);
+    if(!pdst)
+        goto error;
+    [self setData: rgbBuffer
+          withLength: datalen];
+
+    for(int y = 0; y < h; y++) {
+        const uint8_t *qy = py;
+        const uint8_t *quv = puv;
+        for(int x = 0; x < w; x++) {
+            int Y1 = *(qy++) - 16;
+            int Cb = *(quv) - 128;
+            int Cr = *(quv + 1) - 128;
+            Y1 *= 4769;
+            quv += (x & 1) << 1;
+            int r = (Y1 + 6537 * Cr + 2048) / 4096;
+            int g = (Y1 - 1604 * Cb - 3329 * Cr + 2048) / 4096;
+            int b = (Y1 + 8263 * Cb + 2048) / 4096;
+
+            r = (r | -!!(r >> 8)) & -((r >> 8) >= 0);
+            g = (g | -!!(g >> 8)) & -((g >> 8) >= 0);
+            b = (b | -!!(b >> 8)) & -((b >> 8) >= 0);
+
+            *(pdst++) = r;
+            *(pdst++) = g;
+            *(pdst++) = b;
+        }
+        py += dy;
+        if(y & 1)
+            puv += duv;
+    }
+
+error:
+    CVPixelBufferUnlockBaseAddress(pixelBuffer, kCVPixelBufferLock_ReadOnly);
+    zlog(@"convert time %gs", timer_elapsed(t_start, timer_now()));
+
+    // release buffer as soon as conversion is complete
+    self.pixelBuffer = NULL;
+
+    conversion = nil;
+}
+
+@end
diff -r 563557a923d0 iphone/ZBarCameraSimulator.m
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/ZBarCameraSimulator.m	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,120 @@
+//------------------------------------------------------------------------
+//  Copyright 2010-2011 (c) Jeff Brown <spadix@users.sourceforge.net>
+//
+//  This file is part of the ZBar Bar Code Reader.
+//
+//  The ZBar Bar Code Reader is free software; you can redistribute it
+//  and/or modify it under the terms of the GNU Lesser Public License as
+//  published by the Free Software Foundation; either version 2.1 of
+//  the License, or (at your option) any later version.
+//
+//  The ZBar Bar Code Reader is distributed in the hope that it will be
+//  useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+//  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU Lesser Public License for more details.
+//
+//  You should have received a copy of the GNU Lesser Public License
+//  along with the ZBar Bar Code Reader; if not, write to the Free
+//  Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+//  Boston, MA  02110-1301  USA
+//
+//  http://sourceforge.net/projects/zbar
+//------------------------------------------------------------------------
+
+#import <ZBarSDK/ZBarCameraSimulator.h>
+#import <ZBarSDK/ZBarReaderView.h>
+
+// hack around missing simulator support for AVCapture interfaces
+
+@implementation ZBarCameraSimulator
+
+@synthesize readerView;
+
+- (id) initWithViewController: (UIViewController*) vc
+{
+    if(!TARGET_IPHONE_SIMULATOR) {
+        [self release];
+        return(nil);
+    }
+    self = [super init];
+    if(!self)
+        return(nil);
+
+    viewController = vc;
+
+    return(self);
+}
+
+- (void) dealloc
+{
+    viewController = nil;
+    readerView = nil;
+    [picker release];
+    picker = nil;
+    [pickerPopover release];
+    pickerPopover = nil;
+    [super dealloc];
+}
+
+- (void) setReaderView: (ZBarReaderView*) view
+{
+    ZBarReaderView *oldView = readerView;
+    readerView = [view retain];
+    [oldView release];
+
+    UILongPressGestureRecognizer *gesture =
+        [[UILongPressGestureRecognizer alloc]
+            initWithTarget: self
+            action: @selector(didLongPress:)];
+    gesture.numberOfTouchesRequired = 2;
+    [view addGestureRecognizer: gesture];
+    [gesture release];
+}
+
+- (void) didLongPress: (UILongPressGestureRecognizer*) gesture
+{
+    if(gesture.state == UIGestureRecognizerStateBegan)
+        [self takePicture];
+}
+
+- (void) takePicture
+{
+    if(!picker) {
+        picker = [UIImagePickerController new];
+        picker.delegate = self;
+    }
+    if(UI_USER_INTERFACE_IDIOM() == UIUserInterfaceIdiomPad) {
+        if(!pickerPopover)
+            pickerPopover = [[UIPopoverController alloc]
+                                initWithContentViewController: picker];
+        [pickerPopover presentPopoverFromRect: CGRectZero
+                       inView: readerView
+                       permittedArrowDirections: UIPopoverArrowDirectionAny
+                       animated: YES];
+    }
+    else
+        [viewController presentModalViewController: picker
+                        animated: YES];
+}
+
+- (void)  imagePickerController: (UIImagePickerController*) _picker
+  didFinishPickingMediaWithInfo: (NSDictionary*) info
+{
+    UIImage *image = [info objectForKey: UIImagePickerControllerOriginalImage];
+
+    if(UI_USER_INTERFACE_IDIOM() == UIUserInterfaceIdiomPad)
+        [pickerPopover dismissPopoverAnimated: YES];
+    else
+        [_picker dismissModalViewControllerAnimated: YES];
+
+    [readerView performSelector: @selector(scanImage:)
+                withObject: image
+                afterDelay: .1];
+}
+
+- (void) imagePickerControllerDidCancel: (UIImagePickerController*) _picker
+{
+    [_picker dismissModalViewControllerAnimated: YES];
+}
+
+@end
diff -r 563557a923d0 iphone/ZBarCaptureReader.m
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/ZBarCaptureReader.m	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,370 @@
+//------------------------------------------------------------------------
+//  Copyright 2010 (c) Jeff Brown <spadix@users.sourceforge.net>
+//
+//  This file is part of the ZBar Bar Code Reader.
+//
+//  The ZBar Bar Code Reader is free software; you can redistribute it
+//  and/or modify it under the terms of the GNU Lesser Public License as
+//  published by the Free Software Foundation; either version 2.1 of
+//  the License, or (at your option) any later version.
+//
+//  The ZBar Bar Code Reader is distributed in the hope that it will be
+//  useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+//  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU Lesser Public License for more details.
+//
+//  You should have received a copy of the GNU Lesser Public License
+//  along with the ZBar Bar Code Reader; if not, write to the Free
+//  Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+//  Boston, MA  02110-1301  USA
+//
+//  http://sourceforge.net/projects/zbar
+//------------------------------------------------------------------------
+
+#import <libkern/OSAtomic.h>
+#import <AVFoundation/AVFoundation.h>
+#import <CoreMedia/CoreMedia.h>
+#import <CoreVideo/CoreVideo.h>
+#import <ZBarSDK/ZBarCaptureReader.h>
+#import <ZBarSDK/ZBarImageScanner.h>
+#import "ZBarCVImage.h"
+
+#define MODULE ZBarCaptureReader
+#import "debug.h"
+
+enum {
+    STOPPED = 0,
+    RUNNING = 1,
+    PAUSED = 2,
+    CAPTURE = 4,
+};
+
+@implementation ZBarCaptureReader
+
+@synthesize captureOutput, captureDelegate, scanner, scanCrop, size,
+    framesPerSecond, enableCache;
+@dynamic enableReader;
+
+- (void) initResult
+{
+    [result release];
+    result = [ZBarCVImage new];
+    result.format = [ZBarImage fourcc: @"CV2P"];
+}
+
+- (id) initWithImageScanner: (ZBarImageScanner*) _scanner
+{
+    self = [super init];
+    if(!self)
+        return(nil);
+
+    t_fps = t_frame = timer_now();
+    enableCache = YES;
+
+    scanner = [_scanner retain];
+    scanCrop = CGRectMake(0, 0, 1, 1);
+    image = [ZBarImage new];
+    image.format = [ZBarImage fourcc: @"Y800"];
+    [self initResult];
+
+    captureOutput = [AVCaptureVideoDataOutput new];
+    captureOutput.alwaysDiscardsLateVideoFrames = YES;
+
+#ifdef FIXED_8697526
+    /* iOS 4.2 introduced a bug that causes [session startRunning] to
+     * hang if the session has a preview layer and this property is
+     * specified at the output.  As this happens to be the default
+     * setting for the currently supported devices, it can be omitted
+     * without causing a functional problem (for now...).  Of course,
+     * we still have no idea what the real problem is, or how robust
+     * this is as a workaround...
+     */
+    captureOutput.videoSettings = 
+        [NSDictionary
+            dictionaryWithObject:
+                [NSNumber numberWithInt:
+                    kCVPixelFormatType_420YpCbCr8BiPlanarVideoRange]
+            forKey: (NSString*)kCVPixelBufferPixelFormatTypeKey];
+#endif
+
+    queue = dispatch_queue_create("ZBarCaptureReader", NULL);
+    [captureOutput setSampleBufferDelegate:
+                       (id<AVCaptureVideoDataOutputSampleBufferDelegate>)self
+                   queue: queue];
+
+    return(self);
+}
+
+- (id) init
+{
+    self = [self initWithImageScanner:
+               [[ZBarImageScanner new]
+                   autorelease]];
+    if(!self)
+        return(nil);
+
+    [scanner setSymbology: 0
+             config: ZBAR_CFG_X_DENSITY
+             to: 3];
+    [scanner setSymbology: 0
+             config: ZBAR_CFG_Y_DENSITY
+             to: 3];
+    return(self);
+}
+
+- (void) dealloc
+{
+    captureDelegate = nil;
+
+    // queue continues to run after stopping (NB even after DidStopRunning!);
+    // ensure released delegate is not called. (also NB that the queue
+    // may not be null, even in this case...)
+    [captureOutput setSampleBufferDelegate: nil
+                   queue: queue];
+    [captureOutput release];
+    captureOutput = nil;
+    dispatch_release(queue);
+
+    [image release];
+    image = nil;
+    [result release];
+    result = nil;
+    [scanner release];
+    scanner = nil;
+    [super dealloc];
+}
+
+- (BOOL) enableReader
+{
+    return(OSAtomicOr32Barrier(0, &state) & RUNNING);
+}
+
+- (void) setEnableReader: (BOOL) enable
+{
+    if(!enable)
+        OSAtomicAnd32Barrier(STOPPED, &state);
+    else if(!(OSAtomicOr32OrigBarrier(RUNNING, &state) & RUNNING)) {
+        OSAtomicAnd32Barrier(~PAUSED, &state);
+        @synchronized(scanner) {
+            scanner.enableCache = enableCache;
+        }
+    }
+}
+
+- (void) willStartRunning
+{
+    self.enableReader = YES;
+}
+
+- (void) willStopRunning
+{
+    self.enableReader = NO;
+}
+
+- (void) flushCache
+{
+    @synchronized(scanner) {
+        scanner.enableCache = enableCache;
+    }
+}
+
+- (void) captureFrame
+{
+    OSAtomicOr32(CAPTURE, &state);
+}
+
+- (void) setCaptureDelegate: (id<ZBarCaptureDelegate>) delegate
+{
+    @synchronized(scanner) {
+        captureDelegate = delegate;
+    }
+}
+
+- (void) cropUpdate
+{
+    @synchronized(scanner) {
+        image.crop = CGRectMake(scanCrop.origin.x * width,
+                                scanCrop.origin.y * height,
+                                scanCrop.size.width * width,
+                                scanCrop.size.height * height);
+    }
+}
+
+- (void) setScanCrop: (CGRect) crop
+{
+    if(CGRectEqualToRect(scanCrop, crop))
+        return;
+    scanCrop = crop;
+    [self cropUpdate];
+}
+
+- (void) didTrackSymbols: (ZBarSymbolSet*) syms
+{
+    [captureDelegate
+        captureReader: self
+        didTrackSymbols: syms];
+}
+
+- (void) didReadNewSymbolsFromImage: (ZBarImage*) img
+{
+    timer_start;
+    [captureDelegate
+        captureReader: self
+        didReadNewSymbolsFromImage: img];
+    OSAtomicAnd32Barrier(~PAUSED, &state);
+    zlog(@"latency: delegate=%gs total=%gs",
+         timer_elapsed(t_start, timer_now()),
+         timer_elapsed(t_scan, timer_now()));
+}
+
+- (void) setFramesPerSecond: (CGFloat) fps
+{
+    framesPerSecond = fps;
+}
+
+- (void) updateFPS: (NSNumber*) val
+{
+    [self setFramesPerSecond: val.doubleValue];
+}
+
+- (void) setSize: (CGSize) _size
+{
+    size = _size;
+}
+
+- (void) updateSize: (CFDictionaryRef) val
+{
+    CGSize _size;
+    if(CGSizeMakeWithDictionaryRepresentation(val, &_size))
+        [self setSize: _size];
+}
+
+- (void)  captureOutput: (AVCaptureOutput*) output
+  didOutputSampleBuffer: (CMSampleBufferRef) samp
+         fromConnection: (AVCaptureConnection*) conn
+{
+    // queue is apparently not flushed when stopping;
+    // only process when running
+    uint32_t _state = OSAtomicOr32Barrier(0, &state);
+    if((_state & (PAUSED | RUNNING)) != RUNNING)
+        return;
+
+    NSAutoreleasePool *pool = [NSAutoreleasePool new];
+    image.sequence = framecnt++;
+
+    uint64_t now = timer_now();
+    double dt = timer_elapsed(t_frame, now);
+    t_frame = now;
+    if(dt > 2) {
+        t_fps = now;
+        dt_frame = 0;
+    }
+    else if(!dt_frame)
+        dt_frame = dt;
+    dt_frame = (dt_frame + dt) / 2;
+    if(timer_elapsed(t_fps, now) >= 1) {
+        [self performSelectorOnMainThread: @selector(updateFPS:)
+              withObject: [NSNumber numberWithDouble: 1 / dt_frame]
+              waitUntilDone: NO];
+        t_fps = now;
+    }
+
+    CVImageBufferRef buf = CMSampleBufferGetImageBuffer(samp);
+    if(CMSampleBufferGetNumSamples(samp) != 1 ||
+       !CMSampleBufferIsValid(samp) ||
+       !CMSampleBufferDataIsReady(samp) ||
+       !buf) {
+        zlog(@"ERROR: invalid sample");
+        goto error;
+    }
+
+    OSType format = CVPixelBufferGetPixelFormatType(buf);
+    int planes = CVPixelBufferGetPlaneCount(buf);
+
+    if(format != kCVPixelFormatType_420YpCbCr8BiPlanarVideoRange ||
+       !planes) {
+        zlog(@"ERROR: invalid buffer format");
+        goto error;
+    }
+
+    int w = CVPixelBufferGetBytesPerRowOfPlane(buf, 0);
+    int h = CVPixelBufferGetHeightOfPlane(buf, 0);
+    CVReturn rc =
+        CVPixelBufferLockBaseAddress(buf, kCVPixelBufferLock_ReadOnly);
+    if(!w || !h || rc) {
+        zlog(@"ERROR: invalid buffer data");
+        goto error;
+    }
+
+    void *data = CVPixelBufferGetBaseAddressOfPlane(buf, 0);
+    if(data) {
+        [image setData: data
+               withLength: w * h];
+
+        BOOL doTrack = NO;
+        int ngood = 0;
+        ZBarSymbolSet *syms = nil;
+        @synchronized(scanner) {
+            if(width != w || height != h) {
+                width = w;
+                height = h;
+                CGSize _size = CGSizeMake(w, h);
+                CFDictionaryRef sized =
+                    CGSizeCreateDictionaryRepresentation(_size);
+                if(sized) {
+                    [self performSelectorOnMainThread: @selector(updateSize:)
+                          withObject: (id)sized
+                          waitUntilDone: NO];
+                    CFRelease(sized);
+                }
+                image.size = _size;
+                [self cropUpdate];
+            }
+
+            ngood = [scanner scanImage: image];
+            syms = scanner.results;
+            doTrack = [captureDelegate respondsToSelector:
+                          @selector(captureReader:didTrackSymbols:)];
+        }
+        now = timer_now();
+
+        if(ngood >= 0) {
+            // return unfiltered results for tracking feedback
+            syms.filterSymbols = NO;
+            int nraw = syms.count;
+            if(nraw > 0 || (_state & CAPTURE))
+                zlog(@"scan image: %dx%d crop=%@ ngood=%d nraw=%d st=%d",
+                     w, h, NSStringFromCGRect(image.crop), ngood, nraw, _state);
+
+            if(ngood || (_state & CAPTURE)) {
+                // copy image data so we can release the buffer
+                result.size = CGSizeMake(w, h);
+                result.pixelBuffer = buf;
+                result.symbols = syms;
+                t_scan = now;
+                OSAtomicXor32Barrier((_state & CAPTURE) | PAUSED, &state);
+                [self performSelectorOnMainThread:
+                          @selector(didReadNewSymbolsFromImage:)
+                      withObject: result
+                      waitUntilDone: NO];
+                [self initResult];
+            }
+
+            if(nraw && doTrack)
+                [self performSelectorOnMainThread:
+                          @selector(didTrackSymbols:)
+                      withObject: syms
+                      waitUntilDone: NO];
+        }
+        [image setData: NULL
+               withLength: 0];
+    }
+    else
+        zlog(@"ERROR: invalid data");
+    CVPixelBufferUnlockBaseAddress(buf, kCVPixelBufferLock_ReadOnly);
+
+ error:
+    [pool release];
+}
+
+@end
diff -r 563557a923d0 iphone/ZBarHelpController.m
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/ZBarHelpController.m	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,267 @@
+//------------------------------------------------------------------------
+//  Copyright 2009-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
+//
+//  This file is part of the ZBar Bar Code Reader.
+//
+//  The ZBar Bar Code Reader is free software; you can redistribute it
+//  and/or modify it under the terms of the GNU Lesser Public License as
+//  published by the Free Software Foundation; either version 2.1 of
+//  the License, or (at your option) any later version.
+//
+//  The ZBar Bar Code Reader is distributed in the hope that it will be
+//  useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+//  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU Lesser Public License for more details.
+//
+//  You should have received a copy of the GNU Lesser Public License
+//  along with the ZBar Bar Code Reader; if not, write to the Free
+//  Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+//  Boston, MA  02110-1301  USA
+//
+//  http://sourceforge.net/projects/zbar
+//------------------------------------------------------------------------
+
+#import <ZBarSDK/ZBarHelpController.h>
+
+#define MODULE ZBarHelpController
+#import "debug.h"
+
+@implementation ZBarHelpController
+
+@synthesize delegate;
+
+- (id) initWithReason: (NSString*) _reason
+{
+    self = [super init];
+    if(!self)
+        return(nil);
+
+    if(!_reason)
+        _reason = @"INFO";
+    reason = [_reason retain];
+    return(self);
+}
+
+- (id) init
+{
+    return([self initWithReason: nil]);
+}
+
+- (void) cleanup
+{
+    [toolbar release];
+    toolbar = nil;
+    [webView release];
+    webView = nil;
+    [doneBtn release];
+    doneBtn = nil;
+    [backBtn release];
+    backBtn = nil;
+    [space release];
+    space = nil;
+}
+
+- (void) dealloc
+{
+    [self cleanup];
+    [reason release];
+    reason = nil;
+    [linkURL release];
+    linkURL = nil;
+    [super dealloc];
+}
+
+- (void) viewDidLoad
+{
+    [super viewDidLoad];
+
+    UIView *view = self.view;
+    CGRect bounds = self.view.bounds;
+    if(!bounds.size.width || !bounds.size.height)
+        view.frame = bounds = CGRectMake(0, 0, 320, 480);
+    view.backgroundColor = [UIColor colorWithWhite: .125f
+                                    alpha: 1];
+    view.autoresizingMask = (UIViewAutoresizingFlexibleWidth |
+                             UIViewAutoresizingFlexibleHeight);
+
+    webView = [[UIWebView alloc]
+                  initWithFrame: CGRectMake(0, 0,
+                                            bounds.size.width,
+                                            bounds.size.height - 44)];
+    webView.delegate = self;
+    webView.backgroundColor = [UIColor colorWithWhite: .125f
+                                       alpha: 1];
+    webView.autoresizingMask = (UIViewAutoresizingFlexibleWidth |
+                                UIViewAutoresizingFlexibleHeight |
+                                UIViewAutoresizingFlexibleBottomMargin);
+    webView.hidden = YES;
+    [view addSubview: webView];
+
+    toolbar = [[UIToolbar alloc]
+                  initWithFrame: CGRectMake(0, bounds.size.height - 44,
+                                            bounds.size.width, 44)];
+    toolbar.barStyle = UIBarStyleBlackOpaque;
+    toolbar.autoresizingMask = (UIViewAutoresizingFlexibleWidth |
+                                UIViewAutoresizingFlexibleHeight |
+                                UIViewAutoresizingFlexibleTopMargin);
+
+    doneBtn = [[UIBarButtonItem alloc]
+                  initWithBarButtonSystemItem: UIBarButtonSystemItemDone
+                  target: self
+                  action: @selector(dismiss)];
+
+    backBtn = [[UIBarButtonItem alloc]
+                  initWithImage: [UIImage imageNamed: @"zbar-back.png"]
+                  style: UIBarButtonItemStylePlain
+                  target: webView
+                  action: @selector(goBack)];
+
+    space = [[UIBarButtonItem alloc]
+                initWithBarButtonSystemItem:
+                    UIBarButtonSystemItemFlexibleSpace
+                target: nil
+                action: nil];
+
+    toolbar.items = [NSArray arrayWithObjects: space, doneBtn, nil];
+
+    [view addSubview: toolbar];
+
+    NSString *path = [[NSBundle mainBundle]
+                         pathForResource: @"zbar-help"
+                         ofType: @"html"];
+
+    NSURLRequest *req = nil;
+    if(path) {
+        NSURL *url = [NSURL fileURLWithPath: path
+                            isDirectory: NO];
+        if(url)
+            req = [NSURLRequest requestWithURL: url];
+    }
+    if(req)
+        [webView loadRequest: req];
+    else
+        NSLog(@"ERROR: unable to load zbar-help.html from bundle");
+}
+
+- (void) viewDidUnload
+{
+    [self cleanup];
+    [super viewDidUnload];
+}
+
+- (void) viewWillAppear: (BOOL) animated
+{
+    assert(webView);
+    if(webView.loading)
+        webView.hidden = YES;
+    webView.delegate = self;
+    [super viewWillAppear: animated];
+}
+
+- (void) viewWillDisappear: (BOOL) animated
+{
+    [webView stopLoading];
+    webView.delegate = nil;
+    [super viewWillDisappear: animated];
+}
+
+- (BOOL) shouldAutorotateToInterfaceOrientation: (UIInterfaceOrientation) orient
+{
+    return([self isInterfaceOrientationSupported: orient]);
+}
+
+- (void) willAnimateRotationToInterfaceOrientation: (UIInterfaceOrientation) orient
+                                          duration: (NSTimeInterval) duration
+{
+    [webView reload];
+}
+
+- (void) didRotateFromInterfaceOrientation: (UIInterfaceOrientation) orient
+{
+    zlog(@"frame=%@ webView.frame=%@ toolbar.frame=%@",
+         NSStringFromCGRect(self.view.frame),
+         NSStringFromCGRect(webView.frame),
+         NSStringFromCGRect(toolbar.frame));
+}
+
+- (BOOL) isInterfaceOrientationSupported: (UIInterfaceOrientation) orient
+{
+    UIViewController *parent = self.parentViewController;
+    if(parent && !orientations)
+        return([parent shouldAutorotateToInterfaceOrientation: orient]);
+    return((orientations >> orient) & 1);
+}
+
+- (void) setInterfaceOrientation: (UIInterfaceOrientation) orient
+                       supported: (BOOL) supported
+{
+    NSUInteger mask = 1 << orient;
+    if(supported)
+        orientations |= mask;
+    else
+        orientations &= ~mask;
+}
+
+- (void) dismiss
+{
+    if([delegate respondsToSelector: @selector(helpControllerDidFinish:)])
+        [delegate helpControllerDidFinish: self];
+    else
+        [self dismissModalViewControllerAnimated: YES];
+}
+
+- (void) webViewDidFinishLoad: (UIWebView*) view
+{
+    if(view.hidden) {
+        [view stringByEvaluatingJavaScriptFromString:
+            [NSString stringWithFormat:
+                @"onZBarHelp({reason:\"%@\"});", reason]];
+        [UIView beginAnimations: @"ZBarHelp"
+                context: nil];
+        view.hidden = NO;
+        [UIView commitAnimations];
+    }
+
+    BOOL canGoBack = [view canGoBack];
+    NSArray *items = toolbar.items;
+    if(canGoBack != ([items objectAtIndex: 0] == backBtn)) {
+        if(canGoBack)
+            items = [NSArray arrayWithObjects: backBtn, space, doneBtn, nil];
+        else
+            items = [NSArray arrayWithObjects: space, doneBtn, nil];
+        [toolbar setItems: items
+                 animated: YES];
+    }
+}
+
+- (BOOL)             webView: (UIWebView*) view
+  shouldStartLoadWithRequest: (NSURLRequest*) req
+              navigationType: (UIWebViewNavigationType) nav
+{
+    NSURL *url = [req URL];
+    if([url isFileURL])
+        return(YES);
+
+    linkURL = [url retain];
+    UIAlertView *alert =
+        [[UIAlertView alloc]
+            initWithTitle: @"Open External Link"
+            message: @"Close this application and open link in Safari?"
+            delegate: nil
+            cancelButtonTitle: @"Cancel"
+            otherButtonTitles: @"OK", nil];
+    alert.delegate = self;
+    [alert show];
+    [alert release];
+    return(NO);
+}
+
+- (void)     alertView: (UIAlertView*) view
+  clickedButtonAtIndex: (NSInteger) idx
+{
+    if(idx)
+        [[UIApplication sharedApplication]
+            openURL: linkURL];
+}
+
+@end
diff -r 563557a923d0 iphone/ZBarImage.m
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/ZBarImage.m	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,306 @@
+//------------------------------------------------------------------------
+//  Copyright 2009-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
+//
+//  This file is part of the ZBar Bar Code Reader.
+//
+//  The ZBar Bar Code Reader is free software; you can redistribute it
+//  and/or modify it under the terms of the GNU Lesser Public License as
+//  published by the Free Software Foundation; either version 2.1 of
+//  the License, or (at your option) any later version.
+//
+//  The ZBar Bar Code Reader is distributed in the hope that it will be
+//  useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+//  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU Lesser Public License for more details.
+//
+//  You should have received a copy of the GNU Lesser Public License
+//  along with the ZBar Bar Code Reader; if not, write to the Free
+//  Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+//  Boston, MA  02110-1301  USA
+//
+//  http://sourceforge.net/projects/zbar
+//------------------------------------------------------------------------
+
+#import <UIKit/UIKit.h>
+#import <ZBarSDK/ZBarImage.h>
+#import "debug.h"
+
+static void image_cleanup(zbar_image_t *zimg)
+{
+    ZBarImage *image = zbar_image_get_userdata(zimg);
+    [image cleanup];
+}
+
+@implementation ZBarImage
+
+@dynamic format, sequence, size, crop, data, dataLength, symbols, zbarImage,
+    UIImage;
+
++ (unsigned long) fourcc: (NSString*) format
+{
+    return(zbar_fourcc_parse([format UTF8String]));
+}
+
+- (id) initWithImage: (zbar_image_t*) image
+{
+    if(!image) {
+        [self release];
+        return(nil);
+    }
+    if(self = [super init]) {
+        zimg = image;
+        zbar_image_ref(image, 1);
+        zbar_image_set_userdata(zimg, self);
+    }
+    return(self);
+}
+
+- (id) init
+{
+    zbar_image_t *image = zbar_image_create();
+    self = [self initWithImage: image];
+    zbar_image_ref(image, -1);
+    return(self);
+}
+
+- (void) dealloc
+{
+    if(zimg) {
+        zbar_image_ref(zimg, -1);
+        zimg = NULL;
+    }
+    [super dealloc];
+}
+
+- (id) initWithCGImage: (CGImageRef) image
+                  crop: (CGRect) crop
+                  size: (CGSize) size
+{
+    if(!(self = [self init]))
+        return(nil);
+    uint64_t t_start = timer_now();
+
+    unsigned int w = size.width + 0.5;
+    unsigned int h = size.height + 0.5;
+
+    unsigned long datalen = w * h;
+    uint8_t *raw = malloc(datalen);
+    if(!raw) {
+        [self release];
+        return(nil);
+    }
+
+    zbar_image_set_data(zimg, raw, datalen, zbar_image_free_data);
+    zbar_image_set_format(zimg, zbar_fourcc('Y','8','0','0'));
+    zbar_image_set_size(zimg, w, h);
+
+    // scale and crop simultaneously
+    CGFloat scale = size.width / crop.size.width;
+    crop.origin.x *= -scale;
+    crop.size.width = scale * (CGFloat)CGImageGetWidth(image);
+    scale = size.height / crop.size.height;
+    CGFloat height = CGImageGetHeight(image);
+    // compensate for wacky origin
+    crop.origin.y = height - crop.origin.y - crop.size.height;
+    crop.origin.y *= -scale;
+    crop.size.height = scale * height;
+
+    // generate grayscale image data
+    CGColorSpaceRef cs = CGColorSpaceCreateDeviceGray();
+    CGContextRef ctx =
+        CGBitmapContextCreate(raw, w, h, 8, w, cs, kCGImageAlphaNone);
+    CGColorSpaceRelease(cs);
+    CGContextSetAllowsAntialiasing(ctx, 0);
+
+    CGContextDrawImage(ctx, crop, image);
+
+#if 0
+    zlog(@"convert image %dx%d: crop %g,%g %gx%g size %gx%g (%dx%d)",
+         CGImageGetWidth(image), CGImageGetHeight(image),
+         crop.origin.x, crop.origin.y, crop.size.width, crop.size.height,
+         size.width, size.height, w, h);
+    CGImageRef cgdump = CGBitmapContextCreateImage(ctx);
+    UIImage *uidump = [[UIImage alloc]
+                          initWithCGImage: cgdump];
+    CGImageRelease(cgdump);
+    UIImageWriteToSavedPhotosAlbum(uidump, nil, nil, NULL);
+    [uidump release];
+#endif
+
+    CGContextRelease(ctx);
+
+    t_convert = timer_elapsed(t_start, timer_now());
+    return(self);
+}
+
+- (id) initWithCGImage: (CGImageRef) image
+                  size: (CGSize) size
+{
+    CGRect crop = CGRectMake(0, 0,
+                             CGImageGetWidth(image),
+                             CGImageGetHeight(image));
+    return([self initWithCGImage: image
+                 crop: crop
+                 size: size]);
+}
+
+- (id) initWithCGImage: (CGImageRef) image
+{
+    CGRect crop = CGRectMake(0, 0,
+                             CGImageGetWidth(image),
+                             CGImageGetHeight(image));
+    return([self initWithCGImage: image
+                 crop: crop
+                 size: crop.size]);
+}
+
+- (zbar_image_t*) image
+{
+    return(zimg);
+}
+
+- (unsigned long) format
+{
+    return(zbar_image_get_format(zimg));
+}
+
+- (void) setFormat: (unsigned long) format
+{
+    zbar_image_set_format(zimg, format);
+}
+
+- (unsigned) sequence
+{
+    return(zbar_image_get_sequence(zimg));
+}
+
+- (void) setSequence: (unsigned) seq
+{
+    zbar_image_set_sequence(zimg, seq);
+}
+
+- (CGSize) size
+{
+    unsigned w, h;
+    zbar_image_get_size(zimg, &w, &h);
+    return(CGSizeMake(w, h));
+}
+
+- (void) setSize: (CGSize) size
+{
+    zbar_image_set_size(zimg, size.width + .5, size.height + .5);
+}
+
+- (CGRect) crop
+{
+    unsigned x, y, w, h;
+    zbar_image_get_crop(zimg, &x, &y, &w, &h);
+    return(CGRectMake(x, y, w, h));
+}
+
+- (void) setCrop: (CGRect) crop
+{
+    zbar_image_set_crop(zimg, crop.origin.x + .5, crop.origin.y + .5,
+                        crop.size.width + .5, crop.size.height + .5);
+}
+
+- (ZBarSymbolSet*) symbols
+{
+    return([[[ZBarSymbolSet alloc]
+                initWithSymbolSet: zbar_image_get_symbols(zimg)]
+               autorelease]);
+}
+
+- (void) setSymbols: (ZBarSymbolSet*) symbols
+{
+    zbar_image_set_symbols(zimg, [symbols zbarSymbolSet]);
+}
+
+- (const void*) data
+{
+    return(zbar_image_get_data(zimg));
+}
+
+- (unsigned long) dataLength
+{
+    return(zbar_image_get_data_length(zimg));
+}
+
+- (void) setData: (const void*) data
+      withLength: (unsigned long) length
+{
+    zbar_image_set_data(zimg, data, length, image_cleanup);
+}
+
+- (zbar_image_t*) zbarImage
+{
+    return(zimg);
+}
+
+- (UIImage*) UIImageWithOrientation: (UIImageOrientation) orient
+{
+    unsigned long format = self.format;
+    size_t bpc, bpp;
+    switch(format)
+    {
+    case zbar_fourcc('R','G','B','3'):
+        bpc = 8;
+        bpp = 24;
+        break;
+    case zbar_fourcc('R','G','B','4'):
+        bpc = 8;
+        bpp = 32;
+        break;
+    case zbar_fourcc('R','G','B','Q'):
+        bpc = 5;
+        bpp = 16;
+        break;
+    default:
+        NSLog(@"ERROR: format %.4s(%08lx) is unsupported",
+              (char*)&format, format);
+        assert(0);
+        return(nil);
+    };
+
+    unsigned w = zbar_image_get_width(zimg);
+    unsigned h = zbar_image_get_height(zimg);
+    const void *data = zbar_image_get_data(zimg);
+    size_t datalen = zbar_image_get_data_length(zimg);
+    CGDataProviderRef datasrc =
+        CGDataProviderCreateWithData(self, data, datalen, (void*)CFRelease);
+    CGColorSpaceRef cs = CGColorSpaceCreateDeviceRGB();
+    CGImageRef cgimg =
+        CGImageCreate(w, h, bpc, bpp, ((bpp + 7) >> 3) * w, cs,
+                      kCGBitmapByteOrderDefault |
+                      kCGImageAlphaNoneSkipFirst,
+                      datasrc, NULL, YES, kCGRenderingIntentDefault);
+    CGColorSpaceRelease(cs);
+    CGDataProviderRelease(datasrc);
+
+    UIImage *uiimg =
+        [UIImage imageWithCGImage: cgimg
+                 scale: 1
+                 orientation: orient];
+    CGImageRelease(cgimg);
+    return(uiimg);
+}
+
+- (UIImage*) UIImage
+{
+    return([self UIImageWithOrientation: UIImageOrientationUp]);
+}
+
+- (void) cleanup
+{
+}
+
+#if 0
+- (ZBarImage*) convertToFormat: (unsigned long) format
+{
+    zbar_image_t *zdst = zbar_image_convert(zimg, format);
+    ZBarImage *image = ;
+    return([[[ZBarImage alloc] initWithImage: zdst] autorelease]);
+}
+#endif
+
+@end
diff -r 563557a923d0 iphone/ZBarImageScanner.m
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/ZBarImageScanner.m	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,85 @@
+//------------------------------------------------------------------------
+//  Copyright 2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+//
+//  This file is part of the ZBar Bar Code Reader.
+//
+//  The ZBar Bar Code Reader is free software; you can redistribute it
+//  and/or modify it under the terms of the GNU Lesser Public License as
+//  published by the Free Software Foundation; either version 2.1 of
+//  the License, or (at your option) any later version.
+//
+//  The ZBar Bar Code Reader is distributed in the hope that it will be
+//  useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+//  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU Lesser Public License for more details.
+//
+//  You should have received a copy of the GNU Lesser Public License
+//  along with the ZBar Bar Code Reader; if not, write to the Free
+//  Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+//  Boston, MA  02110-1301  USA
+//
+//  http://sourceforge.net/projects/zbar
+//------------------------------------------------------------------------
+
+#import <ZBarSDK/ZBarImageScanner.h>
+#import "debug.h"
+
+@implementation ZBarImageScanner
+
+@dynamic enableCache, results;
+
+- (id) init
+{
+    if(self = [super init]) {
+        scanner = zbar_image_scanner_create();
+    }
+    return(self);
+}
+
+- (void) dealloc
+{
+    if(scanner) {
+        zbar_image_scanner_destroy(scanner);
+        scanner = NULL;
+    }
+    [super dealloc];
+}
+
+- (BOOL) enableCache
+{
+    assert(0); // FIXME
+    return(NO);
+}
+
+- (void) setEnableCache: (BOOL) enable
+{
+    zbar_image_scanner_enable_cache(scanner, enable);
+}
+
+- (ZBarSymbolSet*) results
+{
+    const zbar_symbol_set_t *set = zbar_image_scanner_get_results(scanner);
+    return([[[ZBarSymbolSet alloc] initWithSymbolSet: set] autorelease]);
+}
+
+// image scanner config wrappers
+- (void) parseConfig: (NSString*) cfg
+{
+    zbar_image_scanner_parse_config(scanner, [cfg UTF8String]);
+    // FIXME throw errors
+}
+
+- (void) setSymbology: (zbar_symbol_type_t) sym
+               config: (zbar_config_t) cfg
+                   to: (int) val
+{
+    zbar_image_scanner_set_config(scanner, sym, cfg, val);
+    // FIXME throw errors
+}
+
+- (NSInteger) scanImage: (ZBarImage*) image
+{
+    return(zbar_scan_image(scanner, image.zbarImage));
+}
+
+@end
diff -r 563557a923d0 iphone/ZBarReaderController.m
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/ZBarReaderController.m	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,747 @@
+//------------------------------------------------------------------------
+//  Copyright 2009-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
+//
+//  This file is part of the ZBar Bar Code Reader.
+//
+//  The ZBar Bar Code Reader is free software; you can redistribute it
+//  and/or modify it under the terms of the GNU Lesser Public License as
+//  published by the Free Software Foundation; either version 2.1 of
+//  the License, or (at your option) any later version.
+//
+//  The ZBar Bar Code Reader is distributed in the hope that it will be
+//  useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+//  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU Lesser Public License for more details.
+//
+//  You should have received a copy of the GNU Lesser Public License
+//  along with the ZBar Bar Code Reader; if not, write to the Free
+//  Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+//  Boston, MA  02110-1301  USA
+//
+//  http://sourceforge.net/projects/zbar
+//------------------------------------------------------------------------
+
+#import <ZBarSDK/ZBarReaderController.h>
+#import <ZBarSDK/ZBarHelpController.h>
+#import "debug.h"
+
+/* the use of UIGetScreenImage() may no longer be sanctioned, even
+ * though it was previously "allowed".  define this to 0 to rip it out
+ * and fall back to cameraMode=Default (manual capture)
+ */
+#ifndef USE_PRIVATE_APIS
+# define USE_PRIVATE_APIS 0
+#endif
+
+#ifndef MIN_QUALITY
+# define MIN_QUALITY 10
+#endif
+
+NSString* const ZBarReaderControllerResults = @"ZBarReaderControllerResults";
+
+#if USE_PRIVATE_APIS
+// expose undocumented API
+CF_RETURNS_RETAINED
+CGImageRef UIGetScreenImage(void);
+#endif
+
+@implementation ZBarReaderController
+
+@synthesize scanner, readerDelegate, cameraMode, scanCrop, maxScanDimension,
+    showsHelpOnFail, takesPicture, enableCache, tracksSymbols;
+@dynamic showsZBarControls;
+
+- (id) init
+{
+    if(self = [super init]) {
+        showsHelpOnFail = YES;
+        hasOverlay = showsZBarControls =
+            [self respondsToSelector: @selector(cameraOverlayView)];
+        enableCache = tracksSymbols = YES;
+        scanCrop = CGRectMake(0, 0, 1, 1);
+        maxScanDimension = 640;
+
+        scanner = [ZBarImageScanner new];
+        [scanner setSymbology: 0
+                 config: ZBAR_CFG_X_DENSITY
+                 to: 2];
+        [scanner setSymbology: 0
+                 config: ZBAR_CFG_Y_DENSITY
+                 to: 2];
+
+        if([UIImagePickerController
+               isSourceTypeAvailable: UIImagePickerControllerSourceTypeCamera])
+            self.sourceType = UIImagePickerControllerSourceTypeCamera;
+
+#if USE_PRIVATE_APIS
+        cameraMode = ZBarReaderControllerCameraModeSampling;
+#else
+        cameraMode = ZBarReaderControllerCameraModeDefault;
+#endif
+    }
+    return(self);
+}
+
+- (void) initOverlay
+{
+    CGRect bounds = self.view.bounds;
+    overlay = [[UIView alloc] initWithFrame: bounds];
+    overlay.backgroundColor = [UIColor clearColor];
+
+    CGRect r = bounds;
+    r.size.height -= 54;
+    boxView = [[UIView alloc] initWithFrame: r];
+
+    boxLayer = [CALayer new];
+    boxLayer.frame = r;
+    boxLayer.borderWidth = 1;
+    boxLayer.borderColor = [UIColor greenColor].CGColor;
+    [boxView.layer addSublayer: boxLayer];
+
+    toolbar = [UIToolbar new];
+    toolbar.barStyle = UIBarStyleBlackOpaque;
+    r.origin.y = r.size.height;
+    r.size.height = 54;
+    toolbar.frame = r;
+
+    cancelBtn = [[UIBarButtonItem alloc]
+                    initWithBarButtonSystemItem: UIBarButtonSystemItemCancel
+                    target: self
+                    action: @selector(cancel)];
+    cancelBtn.width = r.size.width / 4 - 16;
+
+    scanBtn = [[UIBarButtonItem alloc]
+                  initWithTitle: @"Scan!"
+                  style: UIBarButtonItemStyleDone
+                  target: self
+                  action: @selector(scan)];
+    scanBtn.width = r.size.width / 2 - 16;
+
+    for(int i = 0; i < 2; i++)
+        space[i] = [[UIBarButtonItem alloc]
+                       initWithBarButtonSystemItem:
+                           UIBarButtonSystemItemFlexibleSpace
+                       target: nil
+                       action: nil];
+
+    space[2] = [[UIBarButtonItem alloc]
+                    initWithBarButtonSystemItem:
+                        UIBarButtonSystemItemFixedSpace
+                    target: nil
+                    action: nil];
+    space[2].width = r.size.width / 4 - 16;
+
+    infoBtn = [[UIButton buttonWithType: UIButtonTypeInfoLight] retain];
+    r.origin.x = r.size.width - 54;
+    r.size.width = 54;
+    infoBtn.frame = r;
+    [infoBtn addTarget: self
+             action: @selector(info)
+             forControlEvents: UIControlEventTouchUpInside];
+}
+
+- (void) viewDidLoad
+{
+    [super viewDidLoad];
+    [super setDelegate: self];
+    if(hasOverlay)
+        [self initOverlay];
+}
+
+- (void) cleanup
+{
+    [overlay release];
+    overlay = nil;
+    [boxView release];
+    boxView = nil;
+    [boxLayer release];
+    boxLayer = nil;
+    [toolbar release];
+    toolbar = nil;
+    [cancelBtn release];
+    cancelBtn = nil;
+    [scanBtn release];
+    scanBtn = nil;
+    for(int i = 0; i < 3; i++) {
+        [space[i] release];
+        space[i] = nil;
+    }
+    [infoBtn release];
+    infoBtn = nil;
+    [help release];
+    help = nil;
+}
+
+- (void) viewDidUnload
+{
+    [self cleanup];
+    [super viewDidUnload];
+}
+
+- (void) dealloc
+{
+    [self cleanup];
+    [scanner release];
+    scanner = nil;
+    [super dealloc];
+}
+
+- (void) scan
+{
+    scanBtn.enabled = NO;
+    self.view.userInteractionEnabled = NO;
+    [self takePicture];
+}
+
+- (void) cancel
+{
+    [self performSelector: @selector(imagePickerControllerDidCancel:)
+          withObject: self
+          afterDelay: 0.1];
+}
+
+- (void) reenable
+{
+    scanBtn.enabled = YES;
+    self.view.userInteractionEnabled = YES;
+}
+
+- (void) initScanning
+{
+    if(hasOverlay &&
+       self.sourceType == UIImagePickerControllerSourceTypeCamera) {
+        if(showsZBarControls || ![self cameraOverlayView])
+            [self setCameraOverlayView: overlay];
+
+        UIView *activeOverlay = [self cameraOverlayView];
+
+        if(showsZBarControls) {
+            if(!toolbar.superview) {
+                [overlay addSubview: toolbar];
+                [overlay addSubview: infoBtn];
+            }
+            [self setShowsCameraControls: NO];
+        }
+        else {
+            [toolbar removeFromSuperview];
+            [infoBtn removeFromSuperview];
+            if(activeOverlay == overlay)
+                [self setShowsCameraControls: YES];
+        }
+
+        self.view.userInteractionEnabled = YES;
+
+        sampling = (cameraMode == ZBarReaderControllerCameraModeSampling ||
+                    cameraMode == ZBarReaderControllerCameraModeSequence);
+
+        if(sampling) {
+            toolbar.items = [NSArray arrayWithObjects:
+                                cancelBtn, space[0], nil];
+
+            t_frame = timer_now();
+            dt_frame = 0;
+            boxLayer.opacity = 0;
+            if(boxView.superview != activeOverlay)
+                [boxView removeFromSuperview];
+            if(!boxView.superview)
+                [activeOverlay insertSubview: boxView atIndex:0];
+            scanner.enableCache = enableCache;
+
+            SEL meth = nil;
+            if(cameraMode == ZBarReaderControllerCameraModeSampling) {
+                // ensure crop rect does not include controls
+                if(scanCrop.origin.x + scanCrop.size.width > .8875)
+                    scanCrop.size.width = .8875 - scanCrop.origin.x;
+
+                meth = @selector(scanScreen);
+            }
+            else
+                meth = @selector(takePicture);
+
+            [self performSelector: meth
+                  withObject: nil
+                  afterDelay: 2];
+#ifdef DEBUG_OBJC
+            [self performSelector: @selector(dumpFPS)
+                  withObject: nil
+                  afterDelay: 4];
+#endif
+        }
+        else {
+            scanBtn.enabled = NO;
+            toolbar.items = [NSArray arrayWithObjects:
+                        cancelBtn, space[0], scanBtn, space[1], space[2], nil];
+
+            [self performSelector: @selector(reenable)
+                  withObject: nil
+                  afterDelay: .5];
+
+            [boxView removeFromSuperview];
+        }
+    }
+}
+
+- (void) viewWillAppear: (BOOL) animated
+{
+    [self initScanning];
+    [super viewWillAppear: animated];
+}
+
+- (void) viewWillDisappear: (BOOL) animated
+{
+    sampling = NO;
+    scanner.enableCache = NO;
+    [super viewWillDisappear: animated];
+}
+
+- (BOOL) showsZBarControls
+{
+    return(showsZBarControls);
+}
+
+- (void) setCameraMode: (ZBarReaderControllerCameraMode) mode
+{
+#if !USE_PRIVATE_APIS
+    if(mode == ZBarReaderControllerCameraModeSampling)
+        [NSException raise: NSInvalidArgumentException
+            format: @"ZBarReaderController cannot set cameraMode=Sampling"
+                    @" when USE_PRIVATE_APIS=0"];
+#endif
+    cameraMode = mode;
+}
+
+- (void) setShowsZBarControls: (BOOL) show
+{
+    if(show && !hasOverlay)
+        [NSException raise: NSInvalidArgumentException
+            format: @"ZBarReaderController cannot set showsZBarControls=YES for OS<3.1"];
+
+    showsZBarControls = show;
+}
+
+// intercept delegate as readerDelegate
+
+- (void) setDelegate: (id <UINavigationControllerDelegate,
+                           UIImagePickerControllerDelegate>) delegate
+{
+    self.readerDelegate = (id <ZBarReaderDelegate>)delegate;
+}
+
+
+#ifdef DEBUG_OBJC
+- (void) dumpFPS
+{
+    if(!sampling)
+        return;
+    [self performSelector: @selector(dumpFPS)
+          withObject: nil
+          afterDelay: 2];
+    zlog(@"fps=%g", 1 / dt_frame);
+}
+#endif
+
+- (NSInteger) scanImage: (CGImageRef) image
+            withScaling: (CGFloat) scale
+{
+    uint64_t now = timer_now();
+    if(dt_frame)
+        dt_frame = (dt_frame + timer_elapsed(t_frame, now)) / 2;
+    else
+        dt_frame = timer_elapsed(t_frame, now);
+    t_frame = now;
+
+    int w = CGImageGetWidth(image);
+    int h = CGImageGetHeight(image);
+    CGRect crop;
+    if(w >= h)
+        crop = CGRectMake(scanCrop.origin.x * w, scanCrop.origin.y * h,
+                          scanCrop.size.width * w, scanCrop.size.height * h);
+    else
+        crop = CGRectMake(scanCrop.origin.y * w, scanCrop.origin.x * h,
+                          scanCrop.size.height * w, scanCrop.size.width * h);
+
+    CGSize size;
+    if(crop.size.width >= crop.size.height &&
+       crop.size.width > maxScanDimension)
+        size = CGSizeMake(maxScanDimension,
+                          crop.size.height * maxScanDimension / crop.size.width);
+    else if(crop.size.height > maxScanDimension)
+        size = CGSizeMake(crop.size.width * maxScanDimension / crop.size.height,
+                          maxScanDimension);
+    else
+        size = crop.size;
+
+    if(scale) {
+        size.width *= scale;
+        size.height *= scale;
+    }
+
+    if(self.sourceType != UIImagePickerControllerSourceTypeCamera ||
+       cameraMode == ZBarReaderControllerCameraModeDefault) {
+        // limit the maximum number of scan passes
+        int density;
+        if(size.width > 720)
+            density = (size.width / 240 + 1) / 2;
+        else
+            density = 1;
+        [scanner setSymbology: 0
+                 config: ZBAR_CFG_X_DENSITY
+                 to: density];
+
+        if(size.height > 720)
+            density = (size.height / 240 + 1) / 2;
+        else
+            density = 1;
+        [scanner setSymbology: 0
+                 config: ZBAR_CFG_Y_DENSITY
+                 to: density];
+    }
+
+    ZBarImage *zimg = [[ZBarImage alloc]
+                          initWithCGImage: image
+                          crop: crop
+                          size: size];
+    int nsyms = [scanner scanImage: zimg];
+    [zimg release];
+
+    return(nsyms);
+}
+
+- (ZBarSymbol*) extractBestResult: (BOOL) filter
+{
+    ZBarSymbol *sym = nil;
+    ZBarSymbolSet *results = scanner.results;
+    results.filterSymbols = filter;
+    for(ZBarSymbol *s in results)
+        if(!sym || sym.quality < s.quality)
+            sym = s;
+    return(sym);
+}
+
+- (void) updateBox: (ZBarSymbol*) sym
+         imageSize: (CGSize) size
+{
+    [CATransaction begin];
+    [CATransaction setAnimationDuration: .3];
+    [CATransaction setAnimationTimingFunction:
+        [CAMediaTimingFunction functionWithName:
+            kCAMediaTimingFunctionLinear]];
+
+    CGFloat alpha = boxLayer.opacity;
+    if(sym) {
+        CGRect r = sym.bounds;
+        if(r.size.width > 16 && r.size.height > 16) {
+            r.origin.x += scanCrop.origin.y * size.width;
+            r.origin.y += scanCrop.origin.x * size.height;
+            r = CGRectInset(r, -16, -16);
+            if(alpha > .25) {
+                CGRect frame = boxLayer.frame;
+                r.origin.x = (r.origin.x * 3 + frame.origin.x) / 4;
+                r.origin.y = (r.origin.y * 3 + frame.origin.y) / 4;
+                r.size.width = (r.size.width * 3 + frame.size.width) / 4;
+                r.size.height = (r.size.height * 3 + frame.size.height) / 4;
+            }
+            boxLayer.frame = r;
+            boxLayer.opacity = 1;
+        }
+    }
+    else {
+        if(alpha > .1)
+            boxLayer.opacity = alpha / 2;
+        else if(alpha)
+            boxLayer.opacity = 0;
+    }
+    [CATransaction commit];
+}
+
+#if USE_PRIVATE_APIS
+
+- (void) scanScreen
+{
+    if(!sampling)
+        return;
+
+    // FIXME ugly hack: use private API to sample screen
+    CGImageRef image = UIGetScreenImage();
+
+    [self scanImage: image
+          withScaling: 0];
+    CGSize size = CGSizeMake(CGImageGetWidth(image), CGImageGetHeight(image));
+    CGImageRelease(image);
+
+    ZBarSymbol *sym = [self extractBestResult: NO];
+
+    if(sym && !sym.count) {
+        SEL cb = @selector(imagePickerController:didFinishPickingMediaWithInfo:);
+        if(takesPicture) {
+            symbol = [sym retain];
+            [self takePicture];
+        }
+        else if([readerDelegate respondsToSelector: cb]) {
+            symbol = [sym retain];
+
+            [CATransaction begin];
+            [CATransaction setDisableActions: YES];
+            boxLayer.opacity = 0;
+            [CATransaction commit];
+
+            // capture preview image and send to delegate
+            // after box has been hidden
+            [self performSelector: @selector(captureScreen)
+                  withObject: nil
+                  afterDelay: 0.001];
+            return;
+        }
+    }
+
+    // reschedule
+    [self performSelector: @selector(scanScreen)
+          withObject: nil
+          afterDelay: 0.001];
+
+    if(tracksSymbols)
+        [self updateBox: sym
+              imageSize: size];
+}
+
+- (void) captureScreen
+{
+    CGImageRef screen = UIGetScreenImage();
+
+    CGRect r = CGRectMake(0, 0,
+                          CGImageGetWidth(screen), CGImageGetHeight(screen));
+    if(r.size.width > r.size.height)
+        r.size.width -= 54;
+    else
+        r.size.height -= 54;
+    CGImageRef preview = CGImageCreateWithImageInRect(screen, r);
+    CGImageRelease(screen);
+
+    UIImage *image = [UIImage imageWithCGImage: preview];
+    CGImageRelease(preview);
+
+    [readerDelegate
+        imagePickerController: self
+        didFinishPickingMediaWithInfo:
+            [NSDictionary dictionaryWithObjectsAndKeys:
+                image, UIImagePickerControllerOriginalImage,
+                [NSArray arrayWithObject: symbol],
+                    ZBarReaderControllerResults,
+                nil]];
+    [symbol release];
+    symbol = nil;
+
+    // continue scanning until dismissed
+    [self performSelector: @selector(scanScreen)
+          withObject: nil
+          afterDelay: 0.001];
+}
+
+#endif /* USE_PRIVATE_APIS */
+
+- (void) scanSequence: (UIImage*) image
+{
+    if(!sampling) {
+        [image release];
+        return;
+    }
+
+    int nsyms = [self scanImage: image.CGImage
+                      withScaling: 0];
+
+    ZBarSymbol *sym = nil;
+    if(nsyms)
+        [self extractBestResult: NO];
+
+    SEL cb = @selector(imagePickerController:didFinishPickingMediaWithInfo:);
+    if(sym && !sym.count &&
+       [readerDelegate respondsToSelector: cb])
+        [readerDelegate
+            imagePickerController: self
+            didFinishPickingMediaWithInfo:
+                [NSDictionary dictionaryWithObjectsAndKeys:
+                    image, UIImagePickerControllerOriginalImage,
+                    [NSArray arrayWithObject: sym],
+                        ZBarReaderControllerResults,
+                    nil]];
+    CGSize size = image.size;
+    [image release];
+
+    // reschedule
+    [self performSelector: @selector(takePicture)
+          withObject: nil
+          afterDelay: 0.001];
+
+    if(tracksSymbols)
+        [self updateBox: sym
+              imageSize: size];
+}
+
+- (void) showHelpWithReason: (NSString*) reason
+{
+    if(help) {
+        [help.view removeFromSuperview];
+        [help release];
+    }
+    help = [[ZBarHelpController alloc]
+               initWithReason: reason];
+    help.delegate = (id<ZBarHelpDelegate>)self;
+
+    if(self.sourceType != UIImagePickerControllerSourceTypeCamera) {
+        [self presentModalViewController: help
+              animated: YES];
+        return;
+    }
+
+    // show help as overlay view to workaround controller bugs
+    sampling = NO;
+    scanner.enableCache = NO;
+    help.wantsFullScreenLayout = YES;
+    help.view.alpha = 0;
+
+    UIView *activeOverlay = [self cameraOverlayView];
+    help.view.frame = [activeOverlay
+                          convertRect: CGRectMake(0, 0, 320, 480)
+                          fromView: nil];
+    [activeOverlay addSubview: help.view];
+    [UIView beginAnimations: @"ZBarHelp"
+            context: nil];
+    help.view.alpha = 1;
+    [UIView commitAnimations];
+}
+
+- (void) info
+{
+    [self showHelpWithReason: @"INFO"];
+}
+
+- (void)  imagePickerController: (UIImagePickerController*) picker
+  didFinishPickingMediaWithInfo: (NSDictionary*) info
+{
+    UIImage *img = [info objectForKey: UIImagePickerControllerOriginalImage];
+
+    id results = nil;
+    if(self.sourceType == UIImagePickerControllerSourceTypeCamera &&
+       cameraMode == ZBarReaderControllerCameraModeSequence) {
+        if(sampling)
+            [self performSelector: @selector(scanSequence:)
+                  withObject: [img retain]
+                  afterDelay: 0.001];
+        return;
+    }
+    else if(!sampling)
+        results = [self scanImage: img.CGImage];
+    else {
+        results = [NSArray arrayWithObject: symbol];
+        [symbol release];
+        symbol = nil;
+    }
+
+    [self performSelector: @selector(reenable)
+         withObject: nil
+         afterDelay: .25];
+
+    if(results) {
+        NSMutableDictionary *newinfo = [info mutableCopy];
+        [newinfo setObject: results
+                 forKey: ZBarReaderControllerResults];
+        SEL cb = @selector(imagePickerController:didFinishPickingMediaWithInfo:);
+        if([readerDelegate respondsToSelector: cb])
+            [readerDelegate imagePickerController: self
+                            didFinishPickingMediaWithInfo: newinfo];
+        else
+            [self dismissModalViewControllerAnimated: YES];
+        [newinfo release];
+        return;
+    }
+
+    BOOL camera = (self.sourceType == UIImagePickerControllerSourceTypeCamera);
+    BOOL retry = !camera || (hasOverlay && ![self showsCameraControls]);
+    if(showsHelpOnFail && retry)
+        [self showHelpWithReason: @"FAIL"];
+
+    SEL cb = @selector(readerControllerDidFailToRead:withRetry:);
+    if([readerDelegate respondsToSelector: cb])
+        // assume delegate dismisses controller if necessary
+        [readerDelegate readerControllerDidFailToRead: self
+                        withRetry: retry];
+    else if(!retry)
+        // must dismiss stock controller
+        [self dismissModalViewControllerAnimated: YES];
+}
+
+- (void) imagePickerControllerDidCancel: (UIImagePickerController*) picker
+{
+    SEL cb = @selector(imagePickerControllerDidCancel:);
+    if([readerDelegate respondsToSelector: cb])
+        [readerDelegate imagePickerControllerDidCancel: self];
+    else
+        [self dismissModalViewControllerAnimated: YES];
+}
+
+// ZBarHelpDelegate
+
+- (void) helpControllerDidFinish: (ZBarHelpController*) hlp
+{
+    if(self.sourceType == UIImagePickerControllerSourceTypeCamera) {
+        [UIView beginAnimations: @"ZBarHelp"
+                context: nil];
+        hlp.view.alpha = 0;
+        [UIView commitAnimations];
+        [self initScanning];
+    }
+    else
+        [hlp dismissModalViewControllerAnimated: YES];
+}
+
+- (id <NSFastEnumeration>) scanImage: (CGImageRef) image
+{
+    timer_start;
+
+    int nsyms = [self scanImage: image
+                      withScaling: 0];
+
+    if(!nsyms &&
+       CGImageGetWidth(image) >= 640 &&
+       CGImageGetHeight(image) >= 640)
+        // make one more attempt for close up, grainy images
+        nsyms = [self scanImage: image
+                      withScaling: .5];
+
+    NSMutableArray *syms = nil;
+    if(nsyms) {
+        // quality/type filtering
+        int max_quality = MIN_QUALITY;
+        for(ZBarSymbol *sym in scanner.results) {
+            zbar_symbol_type_t type = sym.type;
+            int quality;
+            if(type == ZBAR_QRCODE)
+                quality = INT_MAX;
+            else
+                quality = sym.quality;
+
+            if(quality < max_quality) {
+                zlog(@"    type=%d quality=%d < %d\n",
+                     type, quality, max_quality);
+                continue;
+            }
+
+            if(max_quality < quality) {
+                max_quality = quality;
+                if(syms)
+                    [syms removeAllObjects];
+            }
+            zlog(@"    type=%d quality=%d\n", type, quality);
+            if(!syms)
+                syms = [NSMutableArray arrayWithCapacity: 1];
+
+            [syms addObject: sym];
+        }
+    }
+
+    zlog(@"read %d filtered symbols in %gs total\n",
+          (!syms) ? 0 : [syms count], timer_elapsed(t_start, timer_now()));
+    return(syms);
+}
+
+@end
diff -r 563557a923d0 iphone/ZBarReaderView.m
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/ZBarReaderView.m	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,596 @@
+//------------------------------------------------------------------------
+//  Copyright 2010 (c) Jeff Brown <spadix@users.sourceforge.net>
+//
+//  This file is part of the ZBar Bar Code Reader.
+//
+//  The ZBar Bar Code Reader is free software; you can redistribute it
+//  and/or modify it under the terms of the GNU Lesser Public License as
+//  published by the Free Software Foundation; either version 2.1 of
+//  the License, or (at your option) any later version.
+//
+//  The ZBar Bar Code Reader is distributed in the hope that it will be
+//  useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+//  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU Lesser Public License for more details.
+//
+//  You should have received a copy of the GNU Lesser Public License
+//  along with the ZBar Bar Code Reader; if not, write to the Free
+//  Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+//  Boston, MA  02110-1301  USA
+//
+//  http://sourceforge.net/projects/zbar
+//------------------------------------------------------------------------
+
+#import <ZBarSDK/ZBarReaderView.h>
+
+#define MODULE ZBarReaderView
+#import "debug.h"
+
+// silence warning
+@interface ZBarReaderViewImpl : NSObject
+@end
+
+@implementation ZBarReaderView
+
+@synthesize readerDelegate, tracksSymbols, trackingColor, torchMode, showsFPS,
+    zoom, maxZoom, scanCrop, previewTransform, captureReader;
+@dynamic scanner, allowsPinchZoom, enableCache, device, session;
+
++ (id) alloc
+{
+    if(self == [ZBarReaderView class]) {
+        // this is an abstract wrapper for implementation selected
+        // at compile time.  replace with concrete subclass.
+        return((id)[ZBarReaderViewImpl alloc]);
+    }
+    return([super alloc]);
+}
+
+- (void) initSubviews
+{
+    assert(preview);
+
+    overlay = [CALayer new];
+    overlay.backgroundColor = [UIColor clearColor].CGColor;
+    [preview addSublayer: overlay];
+
+#ifndef NDEBUG
+    overlay.borderWidth = 2;
+    overlay.borderColor = [UIColor colorWithRed: 1
+                                   green: 0
+                                   blue: 0
+                                   alpha: .5].CGColor;
+    cropLayer = [CALayer new];
+    cropLayer.backgroundColor = [UIColor clearColor].CGColor;
+    cropLayer.borderWidth = 2;
+    cropLayer.borderColor = [UIColor colorWithRed: 0
+                                     green: 0
+                                     blue: 1
+                                     alpha: .5].CGColor;
+    [overlay addSublayer: cropLayer];
+#endif
+
+    tracking = [CALayer new];
+    tracking.opacity = 0;
+    tracking.borderWidth = 1;
+    tracking.backgroundColor = [UIColor clearColor].CGColor;
+    [overlay addSublayer: tracking];
+
+    trackingColor = [[UIColor greenColor]
+                        retain];
+    tracking.borderColor = trackingColor.CGColor;
+
+    fpsView = [UIView new];
+    fpsView.backgroundColor = [UIColor colorWithWhite: 0
+                                       alpha: .333];
+    fpsView.layer.cornerRadius = 12;
+    fpsView.hidden = YES;
+    [self addSubview: fpsView];
+
+    fpsLabel = [[UILabel alloc]
+                   initWithFrame: CGRectMake(0, 0, 80, 32)];
+    fpsLabel.backgroundColor = [UIColor clearColor];
+    fpsLabel.textColor = [UIColor colorWithRed: .333
+                                  green: .666
+                                  blue: 1
+                                  alpha: 1];
+    fpsLabel.font = [UIFont systemFontOfSize: 18];
+    fpsLabel.textAlignment = UITextAlignmentRight;
+    [fpsView addSubview: fpsLabel];
+
+    self.zoom = 1.25;
+}
+
+- (void) _initWithImageScanner: (ZBarImageScanner*) scanner
+{
+    assert(scanner);
+
+    tracksSymbols = YES;
+    interfaceOrientation = UIInterfaceOrientationPortrait;
+    torchMode = 2; // AVCaptureTorchModeAuto
+    scanCrop = effectiveCrop = CGRectMake(0, 0, 1, 1);
+    imageScale = 1;
+    previewTransform = CGAffineTransformIdentity;
+    maxZoom = 2;
+
+    pinch = [[UIPinchGestureRecognizer alloc]
+                initWithTarget: self
+                action: @selector(handlePinch)];
+    [self addGestureRecognizer: pinch];
+}
+
+- (id) initWithImageScanner: (ZBarImageScanner*) scanner
+{
+    self = [super initWithFrame: CGRectMake(0, 0, 320, 426)];
+    if(!self)
+        return(nil);
+
+    self.backgroundColor = [UIColor blackColor];
+    self.contentMode = UIViewContentModeScaleAspectFill;
+    self.clipsToBounds = YES;
+    self.autoresizingMask =
+        UIViewAutoresizingFlexibleWidth |
+        UIViewAutoresizingFlexibleHeight;
+
+    [self _initWithImageScanner: scanner];
+    return(self);
+}
+
+- (id) init
+{
+    ZBarImageScanner *scanner =
+        [[ZBarImageScanner new]
+            autorelease];
+    self = [self initWithImageScanner: scanner];
+    if(!self)
+        return(nil);
+
+    [scanner setSymbology: 0
+             config: ZBAR_CFG_X_DENSITY
+             to: 3];
+    [scanner setSymbology: 0
+             config: ZBAR_CFG_Y_DENSITY
+             to: 3];
+    return(self);
+}
+
+- (id) initWithCoder: (NSCoder*) decoder
+{
+    self = [super initWithCoder: decoder];
+    if(!self)
+        return(nil);
+    ZBarImageScanner *scanner =
+        [[ZBarImageScanner new]
+            autorelease];
+    [self _initWithImageScanner: scanner];
+
+    [scanner setSymbology: 0
+             config: ZBAR_CFG_X_DENSITY
+             to: 3];
+    [scanner setSymbology: 0
+             config: ZBAR_CFG_Y_DENSITY
+             to: 3];
+    return(self);
+}
+
+- (void) dealloc
+{
+    [preview removeFromSuperlayer];
+    [preview release];
+    preview = nil;
+    [overlay release];
+    overlay = nil;
+    [cropLayer release];
+    cropLayer = nil;
+    [tracking release];
+    tracking = nil;
+    [trackingColor release];
+    trackingColor = nil;
+    [fpsLabel release];
+    fpsLabel = nil;
+    [fpsView release];
+    fpsView = nil;
+    [pinch release];
+    pinch = nil;
+    [super dealloc];
+}
+
+- (void) resetTracking
+{
+    [tracking removeAllAnimations];
+    [CATransaction begin];
+    [CATransaction setDisableActions: YES];
+    CGSize size = overlay.bounds.size;
+    CGRect crop = effectiveCrop;
+    tracking.frame = CGRectMake(crop.origin.x * size.width,
+                                crop.origin.y * size.height,
+                                crop.size.width * size.width,
+                                crop.size.height * size.height);
+    tracking.opacity = 0;
+    [CATransaction commit];
+}
+
+- (void) updateCrop
+{
+}
+
+static inline CGFloat rotationForInterfaceOrientation (int orient)
+{
+    // resolve camera/device image orientation to view/interface orientation
+    switch(orient)
+    {
+    case UIInterfaceOrientationLandscapeLeft:
+        return(M_PI_2);
+    case UIInterfaceOrientationPortraitUpsideDown:
+        return(M_PI);
+    case UIInterfaceOrientationLandscapeRight:
+        return(3 * M_PI_2);
+    case UIInterfaceOrientationPortrait:
+        return(2 * M_PI);
+    }
+    return(0);
+}
+
+- (void) layoutSubviews
+{
+    CGRect bounds = self.bounds;
+    if(!bounds.size.width || !bounds.size.height)
+        return;
+
+    [CATransaction begin];
+    if(animationDuration) {
+        [CATransaction setAnimationDuration: animationDuration];
+        [CATransaction setAnimationTimingFunction:
+            [CAMediaTimingFunction functionWithName:
+                kCAMediaTimingFunctionEaseInEaseOut]];
+    }
+    else
+        [CATransaction setDisableActions: YES];
+
+    [super layoutSubviews];
+    fpsView.frame = CGRectMake(bounds.size.width - 80, bounds.size.height - 32,
+                               80 + 12, 32 + 12);
+
+    // orient view bounds to match camera image
+    CGSize psize;
+    if(UIInterfaceOrientationIsPortrait(interfaceOrientation))
+        psize = CGSizeMake(bounds.size.height, bounds.size.width);
+    else
+        psize = bounds.size;
+
+    // calculate scale from view coordinates to image coordinates
+    // FIXME assumes AVLayerVideoGravityResizeAspectFill
+    CGFloat scalex = imageSize.width / psize.width;
+    CGFloat scaley = imageSize.height / psize.height;
+    imageScale = (scalex < scaley) ? scalex : scaley;
+    if(!imageScale)
+        imageScale = 1;
+    // apply zoom
+    imageScale /= zoom;
+
+    // scale crop by zoom factor
+    CGFloat z = 1 / zoom;
+    CGFloat t = (1 - z) / 2;
+    CGRect zoomCrop =
+        CGRectMake(scanCrop.origin.x * z + t,
+                   scanCrop.origin.y * z + t,
+                   scanCrop.size.width * z,
+                   scanCrop.size.height * z);
+
+    // convert effective preview area to normalized image coordinates
+    CGRect previewCrop;
+    if(scalex < scaley && imageSize.height)
+        previewCrop.size =
+            CGSizeMake(z, psize.height * imageScale / imageSize.height);
+    else if(imageSize.width)
+        previewCrop.size =
+            CGSizeMake(psize.width * imageScale / imageSize.width, z);
+    else
+        previewCrop.size = CGSizeMake(1, 1);
+    previewCrop.origin = CGPointMake((1 - previewCrop.size.width) / 2,
+                                     (1 - previewCrop.size.height) / 2);
+
+    // clip crop to visible preview area
+    effectiveCrop = CGRectIntersection(zoomCrop, previewCrop);
+    if(CGRectIsNull(effectiveCrop))
+        effectiveCrop = zoomCrop;
+
+    // size preview to match image in view coordinates
+    CGFloat viewScale = 1 / imageScale;
+    if(imageSize.width && imageSize.height)
+        psize = CGSizeMake(imageSize.width * viewScale,
+                           imageSize.height * viewScale);
+
+    preview.bounds = CGRectMake(0, 0, psize.height, psize.width);
+    // center preview in view
+    preview.position = CGPointMake(bounds.size.width / 2,
+                                   bounds.size.height / 2);
+
+    CGFloat angle = rotationForInterfaceOrientation(interfaceOrientation);
+    CATransform3D xform =
+        CATransform3DMakeAffineTransform(previewTransform);
+    preview.transform = CATransform3DRotate(xform, angle, 0, 0, 1);
+
+    // scale overlay to match actual image
+    if(imageSize.width && imageSize.height)
+        overlay.bounds = CGRectMake(0, 0, imageSize.width, imageSize.height);
+    else
+        overlay.bounds = CGRectMake(0, 0, psize.width, psize.height);
+    // center overlay in preview
+    overlay.position = CGPointMake(psize.height / 2, psize.width / 2);
+
+    // image coordinates rotated from preview
+    xform = CATransform3DMakeRotation(M_PI_2, 0, 0, 1);
+    overlay.transform = CATransform3DScale(xform, viewScale, viewScale, 1);
+    tracking.borderWidth = imageScale;
+
+#ifndef NDEBUG
+    preview.backgroundColor = [UIColor yellowColor].CGColor;
+    overlay.borderWidth = 2 * imageScale;
+    cropLayer.borderWidth = 2 * imageScale;
+    cropLayer.frame = CGRectMake(effectiveCrop.origin.x * imageSize.width,
+                                 effectiveCrop.origin.y * imageSize.height,
+                                 effectiveCrop.size.width * imageSize.width,
+                                 effectiveCrop.size.height * imageSize.height);
+    zlog(@"layoutSubviews: bounds=%@ orient=%d image=%@ crop=%@ zoom=%g\n"
+         @"=> preview=%@ crop=(z%@ p%@ %@ i%@) scale=%g %c %g = 1/%g",
+         NSStringFromCGSize(bounds.size), interfaceOrientation,
+         NSStringFromCGSize(imageSize), NSStringFromCGRect(scanCrop), zoom,
+         NSStringFromCGSize(psize), NSStringFromCGRect(zoomCrop),
+         NSStringFromCGRect(previewCrop), NSStringFromCGRect(effectiveCrop),
+         NSStringFromCGRect(cropLayer.frame),
+         scalex, (scalex > scaley) ? '>' : '<', scaley, viewScale);
+#endif
+
+    [self resetTracking];
+    [self updateCrop];
+
+    [CATransaction commit];
+    animationDuration = 0;
+}
+
+- (void) setImageSize: (CGSize) size
+{
+    zlog(@"imageSize=%@", NSStringFromCGSize(size));
+    imageSize = size;
+
+    // FIXME bug in AVCaptureVideoPreviewLayer fails to update preview location
+    preview.bounds = CGRectMake(0, 0, size.width, size.height);
+
+    [self setNeedsLayout];
+}
+
+- (void) willRotateToInterfaceOrientation: (UIInterfaceOrientation) orient
+                                 duration: (NSTimeInterval) duration
+{
+    if(interfaceOrientation != orient) {
+        zlog(@"orient=%d #%g", orient, duration);
+        interfaceOrientation = orient;
+        animationDuration = duration;
+    }
+}
+
+- (void) setScanCrop: (CGRect) r
+{
+    if(CGRectEqualToRect(scanCrop, r))
+        return;
+    scanCrop = r;
+    [self setNeedsLayout];
+}
+
+- (void) setTracksSymbols: (BOOL) track
+{
+    if(track == tracksSymbols)
+        return;
+    tracksSymbols = track;
+    [self resetTracking];
+}
+
+- (BOOL) allowsPinchZoom
+{
+    return(pinch.enabled);
+}
+
+- (void) setAllowsPinchZoom: (BOOL) enabled
+{
+    pinch.enabled = enabled;
+}
+
+- (void) setTrackingColor: (UIColor*) color
+{
+    if(!color)
+        return;
+    [color retain];
+    [trackingColor release];
+    trackingColor = color;
+    tracking.borderColor = color.CGColor;
+}
+
+- (void) setShowsFPS: (BOOL) show
+{
+    if(show == showsFPS)
+        return;
+    fpsView.hidden = !show;
+}
+
+- (void) setZoom: (CGFloat) z
+{
+    if(z < 1.0)
+        z = 1.0;
+    if(z > maxZoom)
+        z = maxZoom;
+    if(z == zoom)
+        return;
+    zoom = z;
+
+    [self setNeedsLayout];
+}
+
+- (void) setZoom: (CGFloat) z
+        animated: (BOOL) animated
+{
+    [CATransaction begin];
+    if(animated) {
+        [CATransaction setAnimationDuration: .1];
+        [CATransaction setAnimationTimingFunction:
+            [CAMediaTimingFunction functionWithName:
+                kCAMediaTimingFunctionLinear]];
+    }
+    else
+        [CATransaction setDisableActions: YES];
+    // FIXME animate from current value
+    self.zoom = z;
+    [self layoutIfNeeded];
+    [CATransaction commit];
+}
+
+- (void) setPreviewTransform: (CGAffineTransform) xfrm
+{
+    previewTransform = xfrm;
+    [self setNeedsLayout];
+}
+
+- (void) start
+{
+    if(started)
+        return;
+    started = YES;
+
+    [self resetTracking];
+    fpsLabel.text = @"--- fps ";
+
+    [[UIDevice currentDevice]
+        beginGeneratingDeviceOrientationNotifications];
+}
+
+- (void) stop
+{
+    if(!started)
+        return;
+    started = NO;
+
+    [[UIDevice currentDevice]
+        endGeneratingDeviceOrientationNotifications];
+}
+
+- (void) flushCache
+{
+}
+
+// UIGestureRecognizer callback
+
+- (void) handlePinch
+{
+    if(pinch.state == UIGestureRecognizerStateBegan)
+        zoom0 = zoom;
+    CGFloat z = zoom0 * pinch.scale;
+    [self setZoom: z
+          animated: YES];
+
+    if((zoom < 1.5) != (z < 1.5)) {
+        int d = (z < 1.5) ? 3 : 2;
+        ZBarImageScanner *scanner = self.scanner;
+        @synchronized(scanner) {
+            [scanner setSymbology: 0
+                     config: ZBAR_CFG_X_DENSITY
+                     to: d];
+            [scanner setSymbology: 0
+                     config: ZBAR_CFG_Y_DENSITY
+                     to: d];
+        }
+    }
+}
+
+- (void) updateTracking: (CALayer*) trk
+             withSymbol: (ZBarSymbol*) sym
+{
+    if(!sym)
+        return;
+
+    CGRect r = sym.bounds;
+    if(r.size.width <= 32 && r.size.height <= 32)
+        return;
+    r = CGRectInset(r, -24, -24);
+
+    CALayer *current = trk.presentationLayer;
+    CGPoint cp = current.position;
+    CGPoint p = CGPointMake(CGRectGetMidX(r), CGRectGetMidY(r));
+    p = CGPointMake((p.x * 3 + cp.x) / 4, (p.y * 3 + cp.y) / 4);
+
+    CGRect cr = current.bounds;
+    r.origin = cr.origin;
+    r.size.width = (r.size.width * 3 + cr.size.width) / 4;
+    r.size.height = (r.size.height * 3 + cr.size.height) / 4;
+
+    CAMediaTimingFunction *linear =
+        [CAMediaTimingFunction functionWithName: kCAMediaTimingFunctionLinear];
+
+    CABasicAnimation *resize =
+        [CABasicAnimation animationWithKeyPath: @"bounds"];
+    resize.fromValue = [NSValue valueWithCGRect: cr];
+    resize.toValue = [NSValue valueWithCGRect: r];
+    resize.duration = .2;
+    resize.timingFunction = linear;
+    resize.fillMode = kCAFillModeForwards;
+    resize.removedOnCompletion = NO;
+
+    CABasicAnimation *move =
+        [CABasicAnimation animationWithKeyPath: @"position"];
+    move.fromValue = [NSValue valueWithCGPoint: cp];
+    move.toValue = [NSValue valueWithCGPoint: p];
+    move.duration = .2;
+    move.timingFunction = linear;
+    move.fillMode = kCAFillModeForwards;
+    move.removedOnCompletion = NO;
+
+    CABasicAnimation *on =
+        [CABasicAnimation animationWithKeyPath: @"opacity"];
+    on.fromValue = [NSNumber numberWithDouble: current.opacity];
+    on.toValue = [NSNumber numberWithDouble: 1];
+    on.duration = .2;
+    on.timingFunction = linear;
+    on.fillMode = kCAFillModeForwards;
+    on.removedOnCompletion = NO;
+
+    CABasicAnimation *off = nil;
+    if(!TARGET_IPHONE_SIMULATOR) {
+        off = [CABasicAnimation animationWithKeyPath: @"opacity"];
+        off.fromValue = [NSNumber numberWithDouble: 1];
+        off.toValue = [NSNumber numberWithDouble: 0];
+        off.beginTime = .5;
+        off.duration = .5;
+        off.timingFunction = linear;
+    }
+
+    CAAnimationGroup *group = [CAAnimationGroup animation];
+    group.animations = [NSArray arrayWithObjects: resize, move, on, off, nil];
+    group.duration = 1;
+    group.fillMode = kCAFillModeForwards;
+    group.removedOnCompletion = !TARGET_IPHONE_SIMULATOR;
+    [trk addAnimation: group
+         forKey: @"tracking"];
+}
+
+- (void) didTrackSymbols: (ZBarSymbolSet*) syms
+{
+    if(!tracksSymbols)
+        return;
+
+    int n = syms.count;
+    assert(n);
+    if(!n)
+        return;
+
+    ZBarSymbol *sym = nil;
+    for(ZBarSymbol *s in syms)
+        if(!sym || s.type == ZBAR_QRCODE || s.quality > sym.quality)
+            sym = s;
+    assert(sym);
+    if(!sym)
+        return;
+
+    [self updateTracking: tracking
+          withSymbol: sym];
+}
+
+@end
diff -r 563557a923d0 iphone/ZBarReaderViewController.m
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/ZBarReaderViewController.m	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,699 @@
+//------------------------------------------------------------------------
+//  Copyright 2010 (c) Jeff Brown <spadix@users.sourceforge.net>
+//
+//  This file is part of the ZBar Bar Code Reader.
+//
+//  The ZBar Bar Code Reader is free software; you can redistribute it
+//  and/or modify it under the terms of the GNU Lesser Public License as
+//  published by the Free Software Foundation; either version 2.1 of
+//  the License, or (at your option) any later version.
+//
+//  The ZBar Bar Code Reader is distributed in the hope that it will be
+//  useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+//  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU Lesser Public License for more details.
+//
+//  You should have received a copy of the GNU Lesser Public License
+//  along with the ZBar Bar Code Reader; if not, write to the Free
+//  Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+//  Boston, MA  02110-1301  USA
+//
+//  http://sourceforge.net/projects/zbar
+//------------------------------------------------------------------------
+
+#import <ZBarSDK/ZBarReaderViewController.h>
+#import <ZBarSDK/ZBarReaderView.h>
+#import <ZBarSDK/ZBarCaptureReader.h>
+#import <ZBarSDK/ZBarHelpController.h>
+#import <ZBarSDK/ZBarCameraSimulator.h>
+
+#define MODULE ZBarReaderViewController
+#import "debug.h"
+
+static inline AVCaptureDevicePosition
+AVPositionForUICamera (UIImagePickerControllerCameraDevice camera)
+{
+    switch(camera) {
+    case UIImagePickerControllerCameraDeviceRear:
+        return(AVCaptureDevicePositionBack);
+    case UIImagePickerControllerCameraDeviceFront:
+        return(AVCaptureDevicePositionFront);
+    }
+    return(-1);
+}
+
+static inline UIImagePickerControllerCameraDevice
+UICameraForAVPosition (AVCaptureDevicePosition position)
+{
+    switch(position)
+    {
+    case AVCaptureDevicePositionBack:
+        return(UIImagePickerControllerCameraDeviceRear);
+    case AVCaptureDevicePositionFront:
+        return(UIImagePickerControllerCameraDeviceFront);
+    }
+    return(-1);
+}
+
+static inline AVCaptureDevice*
+AVDeviceForUICamera (UIImagePickerControllerCameraDevice camera)
+{
+    AVCaptureDevicePosition position = AVPositionForUICamera(camera);
+    if(position < 0)
+        return(nil);
+
+#if !TARGET_IPHONE_SIMULATOR
+    NSArray *allDevices =
+        [AVCaptureDevice devicesWithMediaType: AVMediaTypeVideo];
+    for(AVCaptureDevice *device in allDevices)
+        // FIXME how to quantify "best" of several (theoretical) possibilities
+        if(device.position == position)
+            return(device);
+#endif
+    return(nil);
+}
+
+static inline AVCaptureTorchMode
+AVTorchModeForUIFlashMode (UIImagePickerControllerCameraFlashMode mode)
+{
+    switch(mode)
+    {
+    case UIImagePickerControllerCameraFlashModeAuto:
+        return(AVCaptureTorchModeAuto);
+    case UIImagePickerControllerCameraFlashModeOn:
+        return(AVCaptureTorchModeOn);
+    case UIImagePickerControllerCameraFlashModeOff:
+        break;
+    }
+    return(AVCaptureTorchModeOff);
+}
+
+static inline NSString*
+AVSessionPresetForUIVideoQuality (UIImagePickerControllerQualityType quality)
+{
+#if !TARGET_IPHONE_SIMULATOR
+    switch(quality)
+    {
+    case UIImagePickerControllerQualityTypeHigh:
+        return(AVCaptureSessionPresetHigh);
+    case UIImagePickerControllerQualityType640x480:
+        return(AVCaptureSessionPreset640x480);
+    case UIImagePickerControllerQualityTypeMedium:
+        return(AVCaptureSessionPresetMedium);
+    case UIImagePickerControllerQualityTypeLow:
+        return(AVCaptureSessionPresetLow);
+    case UIImagePickerControllerQualityTypeIFrame1280x720:
+        return(AVCaptureSessionPresetiFrame1280x720);
+    case UIImagePickerControllerQualityTypeIFrame960x540:
+        return(AVCaptureSessionPresetiFrame960x540);
+    }
+#endif
+    return(nil);
+}
+
+
+@implementation ZBarReaderViewController
+
+@synthesize scanner, readerDelegate, showsZBarControls,
+    supportedOrientationsMask, tracksSymbols, enableCache, cameraOverlayView,
+    cameraViewTransform, cameraDevice, cameraFlashMode, videoQuality,
+    readerView, scanCrop;
+@dynamic sourceType, allowsEditing, allowsImageEditing, showsCameraControls,
+    showsHelpOnFail, cameraMode, takesPicture, maxScanDimension;
+
++ (BOOL) isSourceTypeAvailable: (UIImagePickerControllerSourceType) sourceType
+{
+    if(sourceType != UIImagePickerControllerSourceTypeCamera)
+        return(NO);
+    return(TARGET_IPHONE_SIMULATOR ||
+           [UIImagePickerController isSourceTypeAvailable: sourceType]);
+}
+
++ (BOOL) isCameraDeviceAvailable: (UIImagePickerControllerCameraDevice) camera
+{
+    return(TARGET_IPHONE_SIMULATOR ||
+           [UIImagePickerController isCameraDeviceAvailable: camera]);
+}
+
++ (BOOL) isFlashAvailableForCameraDevice: (UIImagePickerControllerCameraDevice) camera
+{
+    return(TARGET_IPHONE_SIMULATOR ||
+           [UIImagePickerController isFlashAvailableForCameraDevice: camera]);
+}
+
++ (NSArray*) availableCaptureModesForCameraDevice: (UIImagePickerControllerCameraDevice) camera
+{
+    if(![self isCameraDeviceAvailable: camera])
+        return([NSArray array]);
+
+    // current reader only supports automatic detection
+    return([NSArray arrayWithObject:
+               [NSNumber numberWithInteger:
+                   UIImagePickerControllerCameraCaptureModeVideo]]);
+}
+
+- (void) _init
+{
+    supportedOrientationsMask =
+        ZBarOrientationMask(UIInterfaceOrientationPortrait);
+    showsZBarControls = tracksSymbols = enableCache = YES;
+    scanCrop = CGRectMake(0, 0, 1, 1);
+    cameraViewTransform = CGAffineTransformIdentity;
+
+    cameraFlashMode = UIImagePickerControllerCameraFlashModeAuto;
+    videoQuality = UIImagePickerControllerQualityType640x480;
+    AVCaptureDevice *device = nil;
+#if !TARGET_IPHONE_SIMULATOR
+    device = [AVCaptureDevice defaultDeviceWithMediaType: AVMediaTypeVideo];
+#endif
+    if(device)
+        cameraDevice = UICameraForAVPosition(device.position);
+    else
+        cameraDevice = UIImagePickerControllerCameraDeviceRear;
+
+    // create our own scanner to store configuration,
+    // independent of whether view is loaded
+    scanner = [ZBarImageScanner new];
+    [scanner setSymbology: 0
+             config: ZBAR_CFG_X_DENSITY
+             to: 3];
+    [scanner setSymbology: 0
+             config: ZBAR_CFG_Y_DENSITY
+             to: 3];
+}
+
+- (id) init
+{
+    if(!TARGET_IPHONE_SIMULATOR &&
+       !NSClassFromString(@"AVCaptureSession")) {
+        // fallback to old interface
+        zlog(@"Falling back to ZBarReaderController");
+        [self release];
+        return((id)[ZBarReaderController new]);
+    }
+
+    self = [super init];
+    if(!self)
+        return(nil);
+
+    self.wantsFullScreenLayout = YES;
+    [self _init];
+    return(self);
+}
+
+- (id) initWithCoder: (NSCoder*) decoder
+{
+    self = [super initWithCoder: decoder];
+    if(!self)
+        return(nil);
+
+    [self _init];
+    return(self);
+}
+
+- (void) cleanup
+{
+    [cameraOverlayView removeFromSuperview];
+    cameraSim.readerView = nil;
+    [cameraSim release];
+    cameraSim = nil;
+    readerView.readerDelegate = nil;
+    [readerView release];
+    readerView = nil;
+    [controls release];
+    controls = nil;
+    [shutter release];
+    shutter = nil;
+}
+
+- (void) dealloc
+{
+    [self cleanup];
+    [cameraOverlayView release];
+    cameraOverlayView = nil;
+    [scanner release];
+    scanner = nil;
+    [super dealloc];
+}
+
+- (void) initControls
+{
+    if(!showsZBarControls && controls) {
+        [controls removeFromSuperview];
+        [controls release];
+        controls = nil;
+    }
+    if(!showsZBarControls)
+        return;
+
+    UIView *view = self.view;
+    if(controls) {
+        assert(controls.superview == view);
+        [view bringSubviewToFront: controls];
+        return;
+    }
+
+    CGRect r = view.bounds;
+    r.origin.y = r.size.height - 54;
+    r.size.height = 54;
+    controls = [[UIView alloc]
+                   initWithFrame: r];
+    controls.autoresizingMask =
+        UIViewAutoresizingFlexibleWidth |
+        UIViewAutoresizingFlexibleHeight |
+        UIViewAutoresizingFlexibleTopMargin;
+    controls.backgroundColor = [UIColor blackColor];
+
+    UIToolbar *toolbar =
+        [UIToolbar new];
+    r.origin.y = 0;
+    toolbar.frame = r;
+    toolbar.barStyle = UIBarStyleBlackOpaque;
+    toolbar.autoresizingMask =
+        UIViewAutoresizingFlexibleWidth |
+        UIViewAutoresizingFlexibleHeight;
+
+    UIButton *info =
+        [UIButton buttonWithType: UIButtonTypeInfoLight];
+    [info addTarget: self
+          action: @selector(info)
+          forControlEvents: UIControlEventTouchUpInside];
+
+    toolbar.items =
+        [NSArray arrayWithObjects:
+            [[[UIBarButtonItem alloc]
+                 initWithBarButtonSystemItem: UIBarButtonSystemItemCancel
+                 target: self
+                 action: @selector(cancel)]
+                autorelease],
+            [[[UIBarButtonItem alloc]
+                 initWithBarButtonSystemItem: UIBarButtonSystemItemFlexibleSpace
+                 target: nil
+                 action: nil]
+                autorelease],
+            [[[UIBarButtonItem alloc]
+                 initWithCustomView: info]
+                autorelease],
+            nil];
+    [controls addSubview: toolbar];
+    [toolbar release];
+
+    [view addSubview: controls];
+}
+
+- (void) initVideoQuality
+{
+    if(!readerView) {
+        assert(0);
+        return;
+    }
+
+    AVCaptureSession *session = readerView.session;
+    NSString *preset = AVSessionPresetForUIVideoQuality(videoQuality);
+    if(session && preset && [session canSetSessionPreset: preset]) {
+        zlog(@"set session preset=%@", preset);
+        session.sessionPreset = preset;
+    }
+    else
+        zlog(@"unable to set session preset=%@", preset);
+}
+
+- (void) loadView
+{
+    self.view = [[UIView alloc]
+                    initWithFrame: CGRectMake(0, 0, 320, 480)];
+}
+
+- (void) viewDidLoad
+{
+    [super viewDidLoad];
+    UIView *view = self.view;
+    view.backgroundColor = [UIColor blackColor];
+    view.autoresizingMask =
+        UIViewAutoresizingFlexibleWidth |
+        UIViewAutoresizingFlexibleHeight;
+
+    readerView = [[ZBarReaderView alloc]
+                     initWithImageScanner: scanner];
+    CGRect bounds = view.bounds;
+    CGRect r = bounds;
+    NSUInteger autoresize =
+        UIViewAutoresizingFlexibleWidth |
+        UIViewAutoresizingFlexibleHeight;
+
+    if(showsZBarControls ||
+       self.parentViewController.modalViewController == self)
+    {
+        autoresize |= UIViewAutoresizingFlexibleBottomMargin;
+        r.size.height -= 54;
+    }
+    readerView.frame = r;
+    readerView.autoresizingMask = autoresize;
+    AVCaptureDevice *device = AVDeviceForUICamera(cameraDevice);
+    if(device && device != readerView.device)
+        readerView.device = device;
+    readerView.torchMode = AVTorchModeForUIFlashMode(cameraFlashMode);
+    [self initVideoQuality];
+
+    readerView.readerDelegate = (id<ZBarReaderViewDelegate>)self;
+    readerView.scanCrop = scanCrop;
+    readerView.previewTransform = cameraViewTransform;
+    readerView.tracksSymbols = tracksSymbols;
+    readerView.enableCache = enableCache;
+    [view addSubview: readerView];
+
+    shutter = [[UIView alloc]
+                  initWithFrame: r];
+    shutter.backgroundColor = [UIColor blackColor];
+    shutter.opaque = NO;
+    shutter.autoresizingMask =
+        UIViewAutoresizingFlexibleWidth |
+        UIViewAutoresizingFlexibleHeight;
+    [view addSubview: shutter];
+
+    if(cameraOverlayView) {
+        assert(!cameraOverlayView.superview);
+        [cameraOverlayView removeFromSuperview];
+        [view addSubview: cameraOverlayView];
+    }
+
+    [self initControls];
+
+    if(TARGET_IPHONE_SIMULATOR) {
+        cameraSim = [[ZBarCameraSimulator alloc]
+                        initWithViewController: self];
+        cameraSim.readerView = readerView;
+    }
+}
+
+- (void) viewDidUnload
+{
+    [cameraOverlayView removeFromSuperview];
+    [self cleanup];
+    [super viewDidUnload];
+}
+
+- (void) viewWillAppear: (BOOL) animated
+{
+    zlog(@"willAppear: anim=%d orient=%d",
+         animated, self.interfaceOrientation);
+    [self initControls];
+    [super viewWillAppear: animated];
+
+    [readerView willRotateToInterfaceOrientation: self.interfaceOrientation
+                duration: 0];
+    [readerView performSelector: @selector(start)
+                withObject: nil
+                afterDelay: .001];
+    shutter.alpha = 1;
+    shutter.hidden = NO;
+
+    UIApplication *app = [UIApplication sharedApplication];
+    BOOL willHideStatusBar =
+        !didHideStatusBar && self.wantsFullScreenLayout && !app.statusBarHidden;
+    if(willHideStatusBar)
+        [app setStatusBarHidden: YES
+             withAnimation: UIStatusBarAnimationFade];
+    didHideStatusBar = didHideStatusBar || willHideStatusBar;
+}
+
+- (void) dismissModalViewControllerAnimated: (BOOL) animated
+{
+    if(didHideStatusBar) {
+        [[UIApplication sharedApplication]
+            setStatusBarHidden: NO
+            withAnimation: UIStatusBarAnimationFade];
+        didHideStatusBar = NO;
+    }
+    [super dismissModalViewControllerAnimated: animated];
+}
+
+- (void) viewWillDisappear: (BOOL) animated
+{
+    readerView.captureReader.enableReader = NO;
+
+    if(didHideStatusBar) {
+        [[UIApplication sharedApplication]
+            setStatusBarHidden: NO
+            withAnimation: UIStatusBarAnimationFade];
+        didHideStatusBar = NO;
+    }
+
+    [super viewWillDisappear: animated];
+}
+
+- (void) viewDidDisappear: (BOOL) animated
+{
+    // stopRunning can take a really long time (>1s observed),
+    // so defer until the view transitions are complete
+    [readerView stop];
+}
+
+- (BOOL) shouldAutorotateToInterfaceOrientation: (UIInterfaceOrientation) orient
+{
+    return((supportedOrientationsMask >> orient) & 1);
+}
+
+- (void) willRotateToInterfaceOrientation: (UIInterfaceOrientation) orient
+                                 duration: (NSTimeInterval) duration
+{
+    zlog(@"willRotate: orient=%d #%g", orient, duration);
+    rotating = YES;
+    if(readerView)
+        [readerView willRotateToInterfaceOrientation: orient
+                    duration: duration];
+}
+
+- (void) willAnimateRotationToInterfaceOrientation: (UIInterfaceOrientation) orient
+                                          duration: (NSTimeInterval) duration
+{
+    zlog(@"willAnimateRotation: orient=%d #%g", orient, duration);
+    if(helpController)
+        [helpController willAnimateRotationToInterfaceOrientation: orient
+                        duration: duration];
+    if(readerView)
+        [readerView setNeedsLayout];
+}
+
+- (void) didRotateFromInterfaceOrientation: (UIInterfaceOrientation) orient
+{
+    zlog(@"didRotate(%d): orient=%d", rotating, orient);
+    if(!rotating && readerView) {
+        // work around UITabBarController bug: willRotate is not called
+        // for non-portrait initial interface orientation
+        [readerView willRotateToInterfaceOrientation: self.interfaceOrientation
+                    duration: 0];
+        [readerView setNeedsLayout];
+    }
+    rotating = NO;
+}
+
+- (ZBarReaderView*) readerView
+{
+    // force view to load
+    (void)self.view;
+    assert(readerView);
+    return(readerView);
+}
+
+- (void) setTracksSymbols: (BOOL) track
+{
+    tracksSymbols = track;
+    if(readerView)
+        readerView.tracksSymbols = track;
+}
+
+- (void) setEnableCache: (BOOL) enable
+{
+    enableCache = enable;
+    if(readerView)
+        readerView.enableCache = enable;
+}
+
+- (void) setScanCrop: (CGRect) r
+{
+    scanCrop = r;
+    if(readerView)
+        readerView.scanCrop = r;
+}
+
+- (void) setCameraOverlayView: (UIView*) newview
+{
+    UIView *oldview = cameraOverlayView;
+    [oldview removeFromSuperview];
+
+    cameraOverlayView = [newview retain];
+    if([self isViewLoaded] && newview)
+        [self.view addSubview: newview];
+
+    [oldview release];
+}
+
+- (void) setCameraViewTransform: (CGAffineTransform) xfrm
+{
+    cameraViewTransform = xfrm;
+    if(readerView)
+        readerView.previewTransform = xfrm;
+}
+
+- (void) cancel
+{
+    if(!readerDelegate)
+        return;
+    SEL cb = @selector(imagePickerControllerDidCancel:);
+    if([readerDelegate respondsToSelector: cb])
+        [readerDelegate
+            imagePickerControllerDidCancel: (UIImagePickerController*)self];
+    else
+        [self dismissModalViewControllerAnimated: YES];
+}
+
+- (void) info
+{
+    [self showHelpWithReason: @"INFO"];
+}
+
+- (void) showHelpWithReason: (NSString*) reason
+{
+    if(helpController)
+        return;
+    helpController = [[ZBarHelpController alloc]
+                         initWithReason: reason];
+    helpController.delegate = (id<ZBarHelpDelegate>)self;
+    helpController.wantsFullScreenLayout = YES;
+    UIView *helpView = helpController.view;
+    helpView.alpha = 0;
+    helpView.frame = self.view.bounds;
+    [helpController viewWillAppear: YES];
+    [self.view addSubview: helpView];
+    [UIView beginAnimations: @"ZBarHelp"
+            context: nil];
+    helpController.view.alpha = 1;
+    [UIView commitAnimations];
+}
+
+- (void) takePicture
+{
+    if(TARGET_IPHONE_SIMULATOR) {
+        [cameraSim takePicture];
+        // FIXME return selected image
+    }
+    else if(readerView)
+        [readerView.captureReader captureFrame];
+}
+
+- (void) setCameraDevice: (UIImagePickerControllerCameraDevice) camera
+{
+    cameraDevice = camera;
+    if(readerView) {
+        AVCaptureDevice *device = AVDeviceForUICamera(camera);
+        if(device)
+            readerView.device = device;
+    }
+}
+
+- (void) setCameraFlashMode: (UIImagePickerControllerCameraFlashMode) mode
+{
+    cameraFlashMode = mode;
+    if(readerView)
+        readerView.torchMode = AVTorchModeForUIFlashMode(mode);
+}
+
+- (UIImagePickerControllerCameraCaptureMode) cameraCaptureMode
+{
+    return(UIImagePickerControllerCameraCaptureModeVideo);
+}
+
+- (void) setCameraCaptureMode: (UIImagePickerControllerCameraCaptureMode) mode
+{
+    NSAssert2(mode == UIImagePickerControllerCameraCaptureModeVideo,
+              @"attempt to set unsupported value (%d)"
+              @" for %@ property", mode, @"cameraCaptureMode");
+}
+
+- (void) setVideoQuality: (UIImagePickerControllerQualityType) quality
+{
+    videoQuality = quality;
+    if(readerView)
+        [self initVideoQuality];
+}
+
+
+// ZBarHelpDelegate
+
+- (void) helpControllerDidFinish: (ZBarHelpController*) help
+{
+    assert(help == helpController);
+    [help viewWillDisappear: YES];
+    [UIView beginAnimations: @"ZBarHelp"
+            context: NULL];
+    [UIView setAnimationDelegate: self];
+    [UIView setAnimationDidStopSelector: @selector(removeHelp:done:context:)];
+    help.view.alpha = 0;
+    [UIView commitAnimations];
+}
+
+- (void) removeHelp: (NSString*) tag
+               done: (NSNumber*) done
+            context: (void*) ctx
+{
+    if([tag isEqualToString: @"ZBarHelp"] && helpController) {
+        [helpController.view removeFromSuperview];
+        [helpController release];
+        helpController = nil;
+    }
+}
+
+
+// ZBarReaderViewDelegate
+
+- (void) readerView: (ZBarReaderView*) readerView
+     didReadSymbols: (ZBarSymbolSet*) syms
+          fromImage: (UIImage*) image
+{
+    [readerDelegate
+        imagePickerController: (UIImagePickerController*)self
+        didFinishPickingMediaWithInfo:
+            [NSDictionary dictionaryWithObjectsAndKeys:
+                image, UIImagePickerControllerOriginalImage,
+                syms, ZBarReaderControllerResults,
+                nil]];
+}
+
+- (void) readerViewDidStart: (ZBarReaderView*) readerView
+{
+    if(!shutter.hidden)
+        [UIView animateWithDuration: .25
+                animations: ^{
+                    shutter.alpha = 0;
+                }
+                completion: ^(BOOL finished) {
+                    shutter.hidden = YES;
+                }];
+}
+
+
+// "deprecated" properties
+
+#define DEPRECATED_PROPERTY(getter, setter, type, val, ignore) \
+    - (type) getter                                    \
+    {                                                  \
+        return(val);                                   \
+    }                                                  \
+    - (void) setter: (type) v                          \
+    {                                                  \
+        NSAssert2(ignore || v == val,                  \
+                  @"attempt to set unsupported value (%d)" \
+                  @" for %@ property", val, @#getter); \
+    }
+
+DEPRECATED_PROPERTY(sourceType, setSourceType, UIImagePickerControllerSourceType, UIImagePickerControllerSourceTypeCamera, NO)
+DEPRECATED_PROPERTY(allowsEditing, setAllowsEditing, BOOL, NO, NO)
+DEPRECATED_PROPERTY(allowsImageEditing, setAllowsImageEditing, BOOL, NO, NO)
+DEPRECATED_PROPERTY(showsCameraControls, setShowsCameraControls, BOOL, NO, NO)
+DEPRECATED_PROPERTY(showsHelpOnFail, setShowsHelpOnFail, BOOL, NO, YES)
+DEPRECATED_PROPERTY(cameraMode, setCameraMode, ZBarReaderControllerCameraMode, ZBarReaderControllerCameraModeSampling, NO)
+DEPRECATED_PROPERTY(takesPicture, setTakesPicture, BOOL, NO, NO)
+DEPRECATED_PROPERTY(maxScanDimension, setMaxScanDimension, NSInteger, 640, YES)
+
+@end
diff -r 563557a923d0 iphone/ZBarReaderViewImpl_Capture.m
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/ZBarReaderViewImpl_Capture.m	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,402 @@
+//------------------------------------------------------------------------
+//  Copyright 2010 (c) Jeff Brown <spadix@users.sourceforge.net>
+//
+//  This file is part of the ZBar Bar Code Reader.
+//
+//  The ZBar Bar Code Reader is free software; you can redistribute it
+//  and/or modify it under the terms of the GNU Lesser Public License as
+//  published by the Free Software Foundation; either version 2.1 of
+//  the License, or (at your option) any later version.
+//
+//  The ZBar Bar Code Reader is distributed in the hope that it will be
+//  useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+//  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU Lesser Public License for more details.
+//
+//  You should have received a copy of the GNU Lesser Public License
+//  along with the ZBar Bar Code Reader; if not, write to the Free
+//  Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+//  Boston, MA  02110-1301  USA
+//
+//  http://sourceforge.net/projects/zbar
+//------------------------------------------------------------------------
+
+#import <AVFoundation/AVFoundation.h>
+#import <CoreMedia/CoreMedia.h>
+#import <CoreVideo/CoreVideo.h>
+#import <ZBarSDK/ZBarReaderView.h>
+#import <ZBarSDK/ZBarCaptureReader.h>
+
+#define MODULE ZBarReaderView
+#import "debug.h"
+
+// protected APIs
+@interface ZBarReaderView()
+- (void) _initWithImageScanner: (ZBarImageScanner*) _scanner;
+- (void) initSubviews;
+- (void) updateCrop;
+- (void) setImageSize: (CGSize) size;
+- (void) didTrackSymbols: (ZBarSymbolSet*) syms;
+@end
+
+@interface ZBarReaderViewImpl
+    : ZBarReaderView
+{
+    AVCaptureSession *session;
+    AVCaptureDevice *device;
+    AVCaptureInput *input;
+}
+
+@end
+
+@implementation ZBarReaderViewImpl
+
+@synthesize device, session;
+
+- (void) _initWithImageScanner: (ZBarImageScanner*) scanner
+{
+    [super _initWithImageScanner: scanner];
+
+    session = [AVCaptureSession new];
+    NSNotificationCenter *notify =
+        [NSNotificationCenter defaultCenter];
+    [notify addObserver: self
+            selector: @selector(onVideoError:)
+            name: AVCaptureSessionRuntimeErrorNotification
+            object: session];
+    [notify addObserver: self
+            selector: @selector(onVideoStart:)
+            name: AVCaptureSessionDidStartRunningNotification
+            object: session];
+    [notify addObserver: self
+            selector: @selector(onVideoStop:)
+            name: AVCaptureSessionDidStopRunningNotification
+            object: session];
+    [notify addObserver: self
+            selector: @selector(onVideoStop:)
+            name: AVCaptureSessionWasInterruptedNotification
+            object: session];
+    [notify addObserver: self
+            selector: @selector(onVideoStart:)
+            name: AVCaptureSessionInterruptionEndedNotification
+            object: session];
+
+    self.device = [AVCaptureDevice
+                      defaultDeviceWithMediaType: AVMediaTypeVideo];
+
+    captureReader = [[ZBarCaptureReader alloc]
+                        initWithImageScanner: scanner];
+    captureReader.captureDelegate = (id<ZBarCaptureDelegate>)self;
+    [session addOutput: captureReader.captureOutput];
+
+    if([session canSetSessionPreset: AVCaptureSessionPreset640x480])
+        session.sessionPreset = AVCaptureSessionPreset640x480;
+
+    [captureReader addObserver: self
+                   forKeyPath: @"size"
+                   options: 0
+                   context: NULL];
+
+    [self initSubviews];
+}
+
+- (void) initSubviews
+{
+    AVCaptureVideoPreviewLayer *videoPreview =
+        [[AVCaptureVideoPreviewLayer
+             layerWithSession: session]
+            retain];
+    preview = videoPreview;
+    CGRect bounds = self.bounds;
+    bounds.origin = CGPointZero;
+    preview.bounds = bounds;
+    preview.position = CGPointMake(bounds.size.width / 2,
+                                   bounds.size.height / 2);
+    videoPreview.videoGravity = AVLayerVideoGravityResizeAspectFill;
+    [self.layer addSublayer: preview];
+
+    [super initSubviews];
+}
+
+- (void) dealloc
+{
+    [[NSNotificationCenter defaultCenter]
+        removeObserver: self];
+    if(showsFPS) {
+        @try {
+            [captureReader removeObserver: self
+                           forKeyPath: @"framesPerSecond"];
+        }
+        @catch(...) { }
+    }
+    @try {
+        [captureReader removeObserver: self
+                       forKeyPath: @"size"];
+    }
+    @catch(...) { }
+    captureReader.captureDelegate = nil;
+    [captureReader release];
+    captureReader = nil;
+    [device release];
+    device = nil;
+    [input release];
+    input = nil;
+    [session release];
+    session = nil;
+    [super dealloc];
+}
+
+- (void) updateCrop
+{
+    [super updateCrop];
+    captureReader.scanCrop = effectiveCrop;
+}
+
+- (ZBarImageScanner*) scanner
+{
+    return(captureReader.scanner);
+}
+
+- (void) setDevice: (AVCaptureDevice*) newdev
+{
+    id olddev = device;
+    AVCaptureInput *oldinput = input;
+    assert(!olddev == !oldinput);
+
+    NSError *error = nil;
+    device = [newdev retain];
+    if(device) {
+        assert([device hasMediaType: AVMediaTypeVideo]);
+        input = [[AVCaptureDeviceInput alloc]
+                    initWithDevice: newdev
+                    error: &error];
+        assert(input);
+    }
+    else
+        input = nil;
+
+    [session beginConfiguration];
+    if(oldinput)
+        [session removeInput: oldinput];
+    if(input)
+        [session addInput: input];
+    [session commitConfiguration];
+
+    [olddev release];
+    [oldinput release];
+}
+
+- (BOOL) enableCache
+{
+    return(captureReader.enableCache);
+}
+
+- (void) setEnableCache: (BOOL) enable
+{
+    captureReader.enableCache = enable;
+}
+
+- (void) setTorchMode: (NSInteger) mode
+{
+    [super setTorchMode: mode];
+    if(running && [device isTorchModeSupported: mode])
+        @try {
+            device.torchMode = mode;
+        }
+        @catch(...) { }
+}
+
+- (void) setShowsFPS: (BOOL) show
+{
+    [super setShowsFPS: show];
+    @try {
+        if(show)
+            [captureReader addObserver: self
+                           forKeyPath: @"framesPerSecond"
+                           options: 0
+                           context: NULL];
+        else
+            [captureReader removeObserver: self
+                           forKeyPath: @"framesPerSecond"];
+    }
+    @catch(...) { }
+}
+
+- (void) start
+{
+    if(started)
+        return;
+    [super start];
+
+    [session startRunning];
+    captureReader.enableReader = YES;
+}
+
+- (void) stop
+{
+    if(!started)
+        return;
+    [super stop];
+
+    captureReader.enableReader = NO;
+    [session stopRunning];
+}
+
+- (void) flushCache
+{
+    [captureReader flushCache];
+}
+
+- (void) configureDevice
+{
+    if([device isFocusModeSupported: AVCaptureFocusModeContinuousAutoFocus])
+        device.focusMode = AVCaptureFocusModeContinuousAutoFocus;
+    if([device isTorchModeSupported: torchMode])
+        device.torchMode = torchMode;
+}
+
+- (void) lockDevice
+{
+    if(!running || locked) {
+        assert(0);
+        return;
+    }
+
+    // lock device and set focus mode
+    NSError *error = nil;
+    if([device lockForConfiguration: &error]) {
+        locked = YES;
+        [self configureDevice];
+    }
+    else {
+        zlog(@"failed to lock device: %@", error);
+        // just keep trying
+        [self performSelector: @selector(lockDevice)
+              withObject: nil
+              afterDelay: .5];
+    }
+}
+
+
+// AVCaptureSession notifications
+
+- (void) onVideoStart: (NSNotification*) note
+{
+    zlog(@"onVideoStart: running=%d %@", running, note);
+    if(running)
+        return;
+    running = YES;
+    locked = NO;
+
+    [self lockDevice];
+
+    if([readerDelegate respondsToSelector: @selector(readerViewDidStart:)])
+        [readerDelegate readerViewDidStart: self];
+}
+
+- (void) onVideoStop: (NSNotification*) note
+{
+    zlog(@"onVideoStop: %@", note);
+    if(!running)
+        return;
+    running = NO;
+
+    if(locked)
+        [device unlockForConfiguration];
+    else
+        [NSObject cancelPreviousPerformRequestsWithTarget: self
+                  selector: @selector(lockDevice)
+                  object: nil];
+    locked = NO;
+
+    if([readerDelegate respondsToSelector:
+                           @selector(readerView:didStopWithError:)])
+        [readerDelegate readerView: self
+                        didStopWithError: nil];
+}
+
+- (void) onVideoError: (NSNotification*) note
+{
+    zlog(@"onVideoError: %@", note);
+    if(running) {
+        // FIXME does session always stop on error?
+        running = started = NO;
+        [device unlockForConfiguration];
+    }
+    NSError *err =
+        [note.userInfo objectForKey: AVCaptureSessionErrorKey];
+
+    if([readerDelegate respondsToSelector:
+                           @selector(readerView:didStopWithError:)])
+        [readerDelegate readerView: self
+                        didStopWithError: err];
+    else
+        NSLog(@"ZBarReaderView: ERROR during capture: %@: %@",
+              [err localizedDescription],
+              [err localizedFailureReason]);
+}
+
+// NSKeyValueObserving
+
+- (void) observeValueForKeyPath: (NSString*) path
+                       ofObject: (id) obj
+                         change: (NSDictionary*) info
+                        context: (void*) ctx
+{
+    if(obj == captureReader &&
+       [path isEqualToString: @"size"])
+        // adjust preview to match image size
+        [self setImageSize: captureReader.size];
+    else if(obj == captureReader &&
+       [path isEqualToString: @"framesPerSecond"])
+        fpsLabel.text = [NSString stringWithFormat: @"%.2ffps ",
+                                  captureReader.framesPerSecond];
+}
+
+// ZBarCaptureDelegate
+
+- (void) captureReader: (ZBarCaptureReader*) reader
+       didTrackSymbols: (ZBarSymbolSet*) syms
+{
+    [self didTrackSymbols: syms];
+}
+
+- (void)       captureReader: (ZBarCaptureReader*) reader
+  didReadNewSymbolsFromImage: (ZBarImage*) zimg
+{
+    zlog(@"scanned %d symbols: %@", zimg.symbols.count, zimg);
+    if(!readerDelegate)
+        return;
+
+    UIImageOrientation orient = [UIDevice currentDevice].orientation;
+    if(!UIDeviceOrientationIsValidInterfaceOrientation(orient)) {
+        orient = interfaceOrientation;
+        if(orient == UIInterfaceOrientationLandscapeLeft)
+            orient = UIDeviceOrientationLandscapeLeft;
+        else if(orient == UIInterfaceOrientationLandscapeRight)
+            orient = UIDeviceOrientationLandscapeRight;
+    }
+    switch(orient)
+    {
+    case UIDeviceOrientationPortraitUpsideDown:
+        orient = UIImageOrientationLeft;
+        break;
+    case UIDeviceOrientationLandscapeLeft:
+        orient = UIImageOrientationUp;
+        break;
+    case UIDeviceOrientationLandscapeRight:
+        orient = UIImageOrientationDown;
+        break;
+    default:
+        orient = UIImageOrientationRight;
+        break;
+    }
+
+    UIImage *uiimg = [zimg UIImageWithOrientation: orient];
+    [readerDelegate
+        readerView: self
+        didReadSymbols: zimg.symbols
+        fromImage: uiimg];
+}
+
+@end
diff -r 563557a923d0 iphone/ZBarReaderViewImpl_Simulator.m
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/ZBarReaderViewImpl_Simulator.m	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,219 @@
+//------------------------------------------------------------------------
+//  Copyright 2010 (c) Jeff Brown <spadix@users.sourceforge.net>
+//
+//  This file is part of the ZBar Bar Code Reader.
+//
+//  The ZBar Bar Code Reader is free software; you can redistribute it
+//  and/or modify it under the terms of the GNU Lesser Public License as
+//  published by the Free Software Foundation; either version 2.1 of
+//  the License, or (at your option) any later version.
+//
+//  The ZBar Bar Code Reader is distributed in the hope that it will be
+//  useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+//  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU Lesser Public License for more details.
+//
+//  You should have received a copy of the GNU Lesser Public License
+//  along with the ZBar Bar Code Reader; if not, write to the Free
+//  Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+//  Boston, MA  02110-1301  USA
+//
+//  http://sourceforge.net/projects/zbar
+//------------------------------------------------------------------------
+
+#import <ZBarSDK/ZBarReaderView.h>
+#import <ZBarSDK/ZBarReaderViewController.h>
+
+#define MODULE ZBarReaderView
+#import "debug.h"
+
+// hack around missing simulator support for AVCapture interfaces
+
+// protected APIs
+@interface ZBarReaderView()
+- (void) _initWithImageScanner: (ZBarImageScanner*) _scanner;
+- (void) initSubviews;
+- (void) setImageSize: (CGSize) size;
+- (void) didTrackSymbols: (ZBarSymbolSet*) syms;
+@end
+
+@interface ZBarReaderViewImpl
+    : ZBarReaderView
+{
+    ZBarImageScanner *scanner;
+    UILabel *simLabel;
+    UIImage *scanImage;
+    CALayer *previewImage;
+    BOOL enableCache;
+}
+@end
+
+@implementation ZBarReaderViewImpl
+
+@synthesize scanner, enableCache;
+
+- (void) _initWithImageScanner: (ZBarImageScanner*) _scanner
+{
+    [super _initWithImageScanner: _scanner];
+    scanner = [_scanner retain];
+
+    [self initSubviews];
+}
+
+- (void) initSubviews
+{
+    simLabel = [UILabel new];
+    simLabel.backgroundColor = [UIColor clearColor];
+    simLabel.textColor = [UIColor whiteColor];
+    simLabel.font = [UIFont boldSystemFontOfSize: 20];
+    simLabel.numberOfLines = 4;
+    simLabel.textAlignment = UITextAlignmentCenter;
+    simLabel.text = @"Camera Simulation\n\n"
+        @"Tap and hold with two \"fingers\" to select image";
+    simLabel.autoresizingMask =
+        UIViewAutoresizingFlexibleWidth |
+        UIViewAutoresizingFlexibleHeight;
+    [self addSubview: simLabel];
+
+    preview = [CALayer new];
+    [self.layer addSublayer: preview];
+
+    previewImage = [CALayer new];
+    [preview addSublayer: previewImage];
+
+    [super initSubviews];
+}
+
+- (void) dealloc
+{
+    [scanner release];
+    scanner = nil;
+    [simLabel release];
+    simLabel = nil;
+    [previewImage release];
+    previewImage = nil;
+    [super dealloc];
+}
+
+- (AVCaptureDevice*) device
+{
+    return(nil);
+}
+
+- (void) setDevice: (AVCaptureDevice*) device
+{
+    // simulated camera does nothing with this
+}
+
+- (AVCaptureSession*) session
+{
+    return(nil);
+}
+
+- (void) updateCrop
+{
+    previewImage.frame = preview.bounds;
+    CGRect bounds = self.bounds;
+    simLabel.frame = CGRectInset(bounds,
+                                 bounds.size.width * .05,
+                                 bounds.size.height * .05);
+}
+
+- (void) start
+{
+    if(started)
+        return;
+    [super start];
+    running = YES;
+
+    [self performSelector: @selector(onVideoStart)
+          withObject: nil
+          afterDelay: 0.5];
+}
+
+- (void) stop
+{
+    if(!started)
+        return;
+    [super stop];
+    running = NO;
+
+    [self performSelector: @selector(onVideoStop)
+          withObject: nil
+          afterDelay: 0.5];
+}
+
+- (void) scanImage: (UIImage*) image
+{
+    // strip EXIF info
+    CGImageRef cgimage = image.CGImage;
+    image = [[UIImage alloc]
+                initWithCGImage: cgimage
+                scale: 1.0
+                orientation: UIImageOrientationUp];
+
+    [self setImageSize: image.size];
+    [self layoutIfNeeded];
+
+    [CATransaction begin];
+    [CATransaction setDisableActions: YES];
+    previewImage.contentsGravity = kCAGravityResizeAspectFill;
+    previewImage.transform = CATransform3DMakeRotation(M_PI_2, 0, 0, 1);
+    previewImage.contents = (id)cgimage;
+    [CATransaction commit];
+
+    ZBarImage *zimg =
+        [[ZBarImage alloc]
+            initWithCGImage: cgimage];
+
+    CGSize size = zimg.size;
+    zimg.crop = CGRectMake(effectiveCrop.origin.x * size.width,
+                           effectiveCrop.origin.y * size.height,
+                           effectiveCrop.size.width * size.width,
+                           effectiveCrop.size.height * size.height);
+
+    int nsyms = [scanner scanImage: zimg];
+    zlog(@"scan image: %@ crop=%@ nsyms=%d",
+         NSStringFromCGSize(size), NSStringFromCGRect(zimg.crop), nsyms);
+    [zimg release];
+
+    if(nsyms > 0) {
+        scanImage = [image retain];
+        ZBarSymbolSet *syms = scanner.results;
+        [self performSelector: @selector(didReadSymbols:)
+              withObject: syms
+              afterDelay: .4];
+        [self performSelector: @selector(didTrackSymbols:)
+              withObject: syms
+              afterDelay: .001];
+    }
+    [image release];
+}
+
+- (void) didReadSymbols: (ZBarSymbolSet*) syms
+{
+    [readerDelegate
+        readerView: self
+        didReadSymbols: syms
+        fromImage: scanImage];
+    [scanImage release];
+    scanImage = nil;
+}
+
+- (void) onVideoStart
+{
+    if(running &&
+       [readerDelegate respondsToSelector: @selector(readerViewDidStart:)])
+        [readerDelegate readerViewDidStart: self];
+}
+
+- (void) onVideoStop
+{
+    if(!running &&
+       [readerDelegate respondsToSelector:
+                           @selector(readerView:didStopWithError:)])
+        [readerDelegate readerView: self
+                        didStopWithError: nil];
+}
+
+@end
diff -r 563557a923d0 iphone/ZBarSymbol.m
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/ZBarSymbol.m	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,197 @@
+//------------------------------------------------------------------------
+//  Copyright 2009-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
+//
+//  This file is part of the ZBar Bar Code Reader.
+//
+//  The ZBar Bar Code Reader is free software; you can redistribute it
+//  and/or modify it under the terms of the GNU Lesser Public License as
+//  published by the Free Software Foundation; either version 2.1 of
+//  the License, or (at your option) any later version.
+//
+//  The ZBar Bar Code Reader is distributed in the hope that it will be
+//  useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+//  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU Lesser Public License for more details.
+//
+//  You should have received a copy of the GNU Lesser Public License
+//  along with the ZBar Bar Code Reader; if not, write to the Free
+//  Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+//  Boston, MA  02110-1301  USA
+//
+//  http://sourceforge.net/projects/zbar
+//------------------------------------------------------------------------
+
+#import <ZBarSDK/ZBarSymbol.h>
+
+@implementation ZBarSymbol
+
+@dynamic type, typeName, configMask, modifierMask, data, quality, count,
+    zbarSymbol;
+
++ (NSString*) nameForType: (zbar_symbol_type_t) type
+{
+    return([NSString stringWithUTF8String: zbar_get_symbol_name(type)]);
+}
+
+- (id) initWithSymbol: (const zbar_symbol_t*) sym
+{
+    if(self = [super init]) {
+        symbol = sym;
+        zbar_symbol_ref(sym, 1);
+    }
+    return(self);
+}
+
+- (void) dealloc
+{
+    if(symbol) {
+        zbar_symbol_ref(symbol, -1);
+        symbol = NULL;
+    }
+    [super dealloc];
+}
+
+- (zbar_symbol_type_t) type
+{
+    return(zbar_symbol_get_type(symbol));
+}
+
+- (NSString*) typeName
+{
+    return([[self class] nameForType: zbar_symbol_get_type(symbol)]);
+}
+
+- (NSUInteger) configMask
+{
+    return(zbar_symbol_get_configs(symbol));
+}
+
+- (NSUInteger) modifierMask
+{
+    return(zbar_symbol_get_modifiers(symbol));
+}
+
+- (NSString*) data
+{
+    return([NSString stringWithUTF8String: zbar_symbol_get_data(symbol)]);
+}
+
+- (int) quality
+{
+    return(zbar_symbol_get_quality(symbol));
+}
+
+- (int) count
+{
+    return(zbar_symbol_get_count(symbol));
+}
+
+- (zbar_orientation_t) orientation
+{
+    return(zbar_symbol_get_orientation(symbol));
+}
+
+- (const zbar_symbol_t*) zbarSymbol
+{
+    return(symbol);
+}
+
+- (ZBarSymbolSet*) components
+{
+    return([[[ZBarSymbolSet alloc]
+                initWithSymbolSet: zbar_symbol_get_components(symbol)]
+               autorelease]);
+}
+
+- (CGRect) bounds
+{
+    int n = zbar_symbol_get_loc_size(symbol);
+    if(!n)
+        return(CGRectNull);
+
+    int xmin = INT_MAX, xmax = INT_MIN;
+    int ymin = INT_MAX, ymax = INT_MIN;
+
+    for(int i = 0; i < n; i++) {
+        int t = zbar_symbol_get_loc_x(symbol, i);
+        if(xmin > t) xmin = t;
+        if(xmax < t) xmax = t;
+        t = zbar_symbol_get_loc_y(symbol, i);
+        if(ymin > t) ymin = t;
+        if(ymax < t) ymax = t;
+    }
+    return(CGRectMake(xmin, ymin, xmax - xmin, ymax - ymin));
+}
+
+@end
+
+
+@implementation ZBarSymbolSet
+
+@dynamic count, zbarSymbolSet;
+@synthesize filterSymbols;
+
+- (id) initWithSymbolSet: (const zbar_symbol_set_t*) s
+{
+    if(!s) {
+        [self release];
+        return(nil);
+    }
+    if(self = [super init]) {
+        set = s;
+        zbar_symbol_set_ref(s, 1);
+        filterSymbols = YES;
+    }
+    return(self);
+}
+
+- (void) dealloc
+{
+    if(set) {
+        zbar_symbol_set_ref(set, -1);
+        set = NULL;
+    }
+    [super dealloc];
+}
+
+- (int) count
+{
+    if(filterSymbols)
+        return(zbar_symbol_set_get_size(set));
+
+    int n = 0;
+    const zbar_symbol_t *sym = zbar_symbol_set_first_unfiltered(set);
+    for(; sym; sym = zbar_symbol_next(sym))
+        n++;
+    return(n);
+}
+
+- (const zbar_symbol_set_t*) zbarSymbolSet
+{
+    return(set);
+}
+
+- (NSUInteger) countByEnumeratingWithState: (NSFastEnumerationState*) state
+                                   objects: (id*) stackbuf
+                                     count: (NSUInteger) len
+{
+    const zbar_symbol_t *sym = (void*)state->state; // FIXME
+    if(sym)
+        sym = zbar_symbol_next(sym);
+    else if(set && filterSymbols)
+        sym = zbar_symbol_set_first_symbol(set);
+    else if(set)
+        sym = zbar_symbol_set_first_unfiltered(set);
+
+    if(sym)
+        *stackbuf = [[[ZBarSymbol alloc]
+                         initWithSymbol: sym]
+                        autorelease];
+
+    state->state = (unsigned long)sym; // FIXME
+    state->itemsPtr = stackbuf;
+    state->mutationsPtr = (void*)self;
+    return((sym) ? 1 : 0);
+}
+
+@end
diff -r 563557a923d0 iphone/bin/BuildUniversal.sh
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/bin/BuildUniversal.sh	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,23 @@
+#!/bin/sh
+set -ux
+SUBTARGET=${1:?}
+OUTDIR=${2:-$TARGET_BUILD_DIR}
+
+# build library for device and simulator
+xcodebuild -target $SUBTARGET -configuration $CONFIGURATION -sdk iphoneos BUILD_DIR=$BUILD_DIR BUILD_ROOT=$BUILD_ROOT\
+    || exit 1
+xcodebuild -target $SUBTARGET -configuration $CONFIGURATION -sdk iphonesimulator BUILD_DIR=$BUILD_DIR BUILD_ROOT=$BUILD_ROOT\
+    || exit 1
+
+mkdir -p $OUTDIR
+
+# combine device and simulator libs into single fat lib.
+# others have indicated that this approach is "wrong", but for us
+# the ease of including the universal lib in a project without complicated
+# changes to build settings outweighs any lack of purity in the approach
+# ...we can always fix things later, if necessary
+lipo -create \
+    $BUILD_ROOT/$CONFIGURATION-iphoneos/$SUBTARGET.a \
+    $BUILD_ROOT/$CONFIGURATION-iphonesimulator/$SUBTARGET.a \
+    -output $OUTDIR/$SUBTARGET.a \
+    || exit 1
diff -r 563557a923d0 iphone/bin/CreateDMG.sh
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/bin/CreateDMG.sh	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,44 @@
+#!/bin/sh
+set -ux
+VOLNAME=${1:?}
+shift
+RES=$SOURCE_ROOT/res
+BUDDY=/usr/libexec/PlistBuddy
+if [ ! -x "$BUDDY" ]; then
+    BUDDY=$(xcrun -find PlistBuddy) \
+        || exit 1
+fi
+VERSION=$($BUDDY -c 'Print :CFBundleVersion' $RES/$VOLNAME-Info.plist) \
+    || exit 1
+DMG=$VOLNAME-$VERSION
+
+mkdir -p $TARGET_BUILD_DIR/.background \
+    || exit 1
+cp -af $RES/$VOLNAME.DS_Store $TARGET_BUILD_DIR/.DS_Store
+cp -af $RES/$VOLNAME-bg.png $TARGET_BUILD_DIR/.background/
+
+# copy remaining arguments to image directly
+for content
+do
+    cp -af $content $TARGET_BUILD_DIR/ \
+        || exit 1
+done
+
+# prepare examples for distribution
+for example in $(find $TARGET_BUILD_DIR/Examples -depth 1 -not -name '.*')
+do
+    rm -rf $example/{build,*.xcodeproj/{*.{mode1v3,pbxuser},project.xcworkspace,xcuserdata},ZBarSDK}
+    cp -af $BUILT_PRODUCTS_DIR/ZBarSDK $example/
+done
+
+# override subdir .DS_Stores
+for dir in $(find $TARGET_BUILD_DIR -type d -depth 1)
+do
+    cp -af $RES/Columns.DS_Store $dir/.DS_Store
+done
+
+hdiutil create -ov -fs HFS+ -format UDZO -imagekey zlib-level=9 \
+    -volname $VOLNAME \
+    -srcdir $TARGET_BUILD_DIR \
+    $BUILT_PRODUCTS_DIR/$DMG.dmg \
+    || exit 1
diff -r 563557a923d0 iphone/bin/CreateDSStore.pl
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/bin/CreateDSStore.pl	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,72 @@
+#!/usr/bin/perl
+
+# Quick hack script to generate the .DS_Store for the DMG, which
+#   * allows us to precisely position the window and icons
+#   * is more usefully versioned
+#   * avoids references to my local HD(!?)
+
+use warnings;
+use strict;
+
+BEGIN {
+  use File::Spec::Functions qw(rel2abs splitpath);
+  use lib (splitpath(rel2abs($0)))[1];
+}
+
+use Data::Plist::BinaryWriter;
+use Mac::Finder::DSStore qw(writeDSDBEntries makeEntries);
+use Mac::Finder::AliasRecord;
+
+$Mac::Finder::DSStore::Entry::types{bwsp} = 'blob';
+$Mac::Finder::DSStore::Entry::types{icvp} = 'blob';
+
+writeDSDBEntries($ARGV[0] || "DS_Store",
+    makeEntries(".",
+        bwsp => Data::Plist::BinaryWriter->new(serialize => 0)->write([
+            dict => {
+                WindowBounds => [
+                    string => sprintf('{{%d, %d}, {%d, %d}}',
+                                      512, 128, 512, 608 + 22)
+                ],
+                SidebarWidth => [integer => 0],
+                ShowToolbar => [false => 0],
+                ShowSidebar => [false => 0],
+                ShowPathbar => [false => 0],
+                ShowStatusBar => [false => 0],
+            }
+        ]),
+        icvp => Data::Plist::BinaryWriter->new(serialize => 0)->write([
+            dict => {
+                viewOptionsVersion => [integer => 0],
+                arrangeBy => [string => "none"],
+                iconSize => [real => 64],
+                textSize => [real => 12],
+                labelOnBottom => [true => 1],
+                gridSpacing => [real => 100],
+                gridOffsetX => [real => 0],
+                gridOffsetY => [real => 0],
+                showItemInfo => [false => 0],
+                showIconPreview => [false => 0],
+                backgroundType => [integer => 2],
+                backgroundColorRed => [real => 0],
+                backgroundColorGreen => [real => 0],
+                backgroundColorBlue => [real => .5],
+                backgroundImageAlias => [
+                    data => Mac::Finder::AliasRecord->new(
+                        path => 'ZBarSDK:.background:ZBarSDK-bg.png',
+                        volumeFS => 'HFS+')->write()
+                ],
+            },
+        ]),
+        vstl => "icnv",
+    ),
+    makeEntries("README",       Iloc_xy => [ 4.5 * 32,  2.5  * 32 ]),
+    makeEntries("ZBarSDK",      Iloc_xy => [ 4.5 * 32,  7.5  * 32 ]),
+    makeEntries("ChangeLog",    Iloc_xy => [  4  * 32, 12.5  * 32 ]),
+    makeEntries("Documentation.html",
+                                Iloc_xy => [  8  * 32, 12.5  * 32 ]),
+    makeEntries("Examples",     Iloc_xy => [ 12  * 32, 12.5  * 32 ]),
+    makeEntries("COPYING",      Iloc_xy => [  4  * 32,  16   * 32 ]),
+    makeEntries("LICENSE",      Iloc_xy => [  8  * 32,  16   * 32 ]),
+    makeEntries("Documentation",Iloc_xy => [ 12  * 32,  16   * 32 ]),
+);
diff -r 563557a923d0 iphone/bin/Mac/Finder/AliasRecord.pm
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/bin/Mac/Finder/AliasRecord.pm	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,169 @@
+package Mac::Finder::AliasRecord;
+
+# Generate(/Parse) a Mac "alias record" binary string/file.
+#
+# Currently just enough is implemented to satisfy immediate requirements
+# (ie, write backgroundImageAlias to .DS_Store for DMG)
+#
+# based on these documents:
+# http://www.geocities.com/xhelmboyx/quicktime/formats/alias-layout.txt
+# http://sebastien.kirche.free.fr/python_stuff/MacOS-aliases.txt
+#
+# FIXME interface is very poor...
+
+use warnings;
+use strict;
+use DateTime;
+use File::Spec;
+use File::Spec::Mac;
+use Encode qw(encode);
+require Exporter;
+
+our $VERSION = '0.1';
+our @ISA = qw(Exporter);
+
+my %FSEncodings = (
+  MacFS   => ['RW', ''],
+  MFS     => ['RW', ''],
+  HFS     => ['BD', ''],
+  'HFS+'  => ['H+', ''],
+
+  AudioCD => ['', 'JH'],
+  ISO9660 => ['', 'AG'],
+  FAT     => ['', 'IS'],
+  Joliet  => ['', 'Jo'],
+  'ISO9660+Joliet' => ['', 'Jo'],
+);
+
+my %DiskEncodings = (
+  HD          => 0,
+  FixedHD     => 0,
+  Network     => 1,
+  NetworkDisk => 1,
+  Floppy      => 4,
+  Floppy1440  => 4,
+  Other       => 5,
+  OtherDisk   => 5,
+);
+
+my %RecordEncodings = (
+  parentDir     => 0x00,
+  absolutePath  => 0x02,
+  unicodeFile   => 0x0e,
+  unicodeVolume => 0x0f,
+  volumePath    => 0x12,
+);
+
+sub new {
+  my $class = shift || __PACKAGE__;
+  my $self = {
+    aliasCreator => '',
+    aliasVersion => 2,
+    aliasType => 'file',
+    volume => '',
+    volumeCreated => 0,
+    volumeFS => 'HFS',
+    volumeDisk => undef,
+    volumeAttrs => 0,
+    directoryID => 0,
+    file => '',
+    fileID => 0,
+    fileCreated => 0,
+    fileType => '',
+    fileCreator => '',
+    nlvlFrom => -1,
+    nlvlTo => -1,
+    records => { },
+    @_
+  };
+  if(exists($self->{path})) {
+    my $path = $self->{path};
+    my ($vol, $dir, $file) = File::Spec::Mac->splitpath($path);
+    $vol =~ s/:$//;
+    my @dir = File::Spec::Mac->splitdir($dir);
+    while(@dir && !$dir[0]) {
+      shift(@dir);
+    }
+    while(@dir && !$dir[-1]) {
+      pop(@dir);
+    }
+    $self->{volume} ||= $vol;
+    $self->{records}{unicodeVolume} ||=
+      pack('na*', length($vol), encode('utf-16be', $vol));
+
+    $self->{file} ||= $file;
+    $self->{records}{parentDir} ||= $dir[-1]
+      if(@dir);
+    $self->{records}{absolutePath} ||= $path;
+    $self->{records}{volumePath} ||= File::Spec->catfile('', @dir, $file);
+    $self->{records}{unicodeFile} ||=
+      pack('na*', length($file), encode('utf-16be', $file));
+  }
+  return(bless($self, ref($class) || $class));
+}
+
+sub toFSTime {
+  my $val = shift;
+  if(ref($val) && $val->isa("DateTime")) {
+    $val = $val->epoch - DateTime->new(year => 1904)->epoch();
+  }
+  return($val);
+}
+
+sub write {
+  my ($self, $out) = @_;
+
+  my $aliasType = $self->{aliasType};
+  $aliasType = (($aliasType =~ /^d(ir(ectory)?)?$/i && 1) ||
+                ($aliasType !~ /^f(ile)?$/ && $aliasType) || 0);
+
+  my $volumeCreated = toFSTime($self->{volumeCreated});
+  my $volumeFS = $self->{volumeFS};
+  if(ref($volumeFS) ne 'ARRAY') {
+    $volumeFS = $FSEncodings{$volumeFS} || ['', ''];
+  }
+
+  my $volumeDisk = $self->{volumeDisk};
+  if(!defined($volumeDisk)) {
+    if($volumeFS->[0] eq 'H+') {
+      $volumeDisk = 'Floppy';
+    }
+    elsif($volumeFS->[0]) {
+      $volumeDisk = 'HD';
+    }
+    else {
+      $volumeDisk = 'Other';
+    }
+  }
+  $volumeDisk = (exists($DiskEncodings{$volumeDisk})
+                 ? $DiskEncodings{$volumeDisk}
+                 : $volumeDisk);
+
+  my $fileCreated = toFSTime($self->{fileCreated});
+
+  my $buf =
+    pack('nn (C/a @28)Na2n N(C/a @64)NNa4a4 n!n!Na2 x10 (n!n/ax!2)*',
+         $self->{aliasVersion}, $aliasType,
+         $self->{volume}, $volumeCreated, $volumeFS->[0], $volumeDisk,
+         $self->{directoryID}, $self->{file}, $self->{fileID}, $fileCreated,
+         $self->{fileType}, $self->{fileCreator}, $self->{nlvlFrom},
+         $self->{nlvlTo}, $self->{volumeAttrs}, $volumeFS->[1],
+         map(((exists($RecordEncodings{$_}) ? $RecordEncodings{$_} : $_)
+              => $self->{records}{$_}),
+             keys(%{$self->{records}})),
+         (-1, ''));
+  $buf = pack('a4n', $self->{aliasCreator}, length($buf) + 6) . $buf;
+
+  if(!$out) {
+    return($buf);
+  }
+  elsif(ref($out) eq 'GLOB') {
+    print $out $buf;
+  }
+  else {
+    open(my $outfh, '>', $out) || die;
+    print $outfh $buf;
+  }
+}
+
+1;
diff -r 563557a923d0 iphone/debug.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/debug.h	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,53 @@
+//------------------------------------------------------------------------
+//  Copyright 2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+//
+//  This file is part of the ZBar Bar Code Reader.
+//
+//  The ZBar Bar Code Reader is free software; you can redistribute it
+//  and/or modify it under the terms of the GNU Lesser Public License as
+//  published by the Free Software Foundation; either version 2.1 of
+//  the License, or (at your option) any later version.
+//
+//  The ZBar Bar Code Reader is distributed in the hope that it will be
+//  useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+//  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU Lesser Public License for more details.
+//
+//  You should have received a copy of the GNU Lesser Public License
+//  along with the ZBar Bar Code Reader; if not, write to the Free
+//  Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+//  Boston, MA  02110-1301  USA
+//
+//  http://sourceforge.net/projects/zbar
+//------------------------------------------------------------------------
+
+#include <mach/mach_time.h>
+#define xNSSTR(s) @#s
+#define NSSTR(s) xNSSTR(s)
+
+#ifdef DEBUG_OBJC
+# ifndef MODULE
+#  define MODULE ZBarReaderController
+# endif
+# define zlog(fmt, ...) \
+    NSLog(NSSTR(MODULE) @": " fmt , ##__VA_ARGS__)
+
+#define timer_start \
+    uint64_t t_start = timer_now();
+
+#else
+# define zlog(...) while(0)
+# define timer_start
+#endif
+
+static inline uint64_t timer_now ()
+{
+    return(mach_absolute_time());
+}
+
+static inline double timer_elapsed (uint64_t start, uint64_t end)
+{
+    mach_timebase_info_data_t info;
+    mach_timebase_info(&info);
+    return((double)(end - start) * info.numer / (info.denom * 1000000000.));
+}
diff -r 563557a923d0 iphone/doc/Documentation.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/doc/Documentation.html	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,11 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
+  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
+<meta http-equiv="Refresh" content="0; url=Documentation/index.html"/>
+</head>
+<body>
+<p>redirecting to <a href="Documentation/index.html">Documentation/index.html</a></p>
+</body>
+</html>
diff -r 563557a923d0 iphone/doc/ReaderSample.png
Binary file iphone/doc/ReaderSample.png has changed
diff -r 563557a923d0 iphone/doc/ZBarImage.rst
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/doc/ZBarImage.rst	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,150 @@
+ZBarImage Class Reference
+=========================
+
+.. class:: ZBarImage
+
+   :Inherits from: :class:`NSObject`
+
+   A :class:`ZBarImage` is a wrapper for images passed to the barcode reader.
+   It encapsulates raw image data with the format and size metadata necessary
+   to interpret it.
+
+   An image must be wrapped in a :class:`ZBarImage` in order to be scanned by
+   the library.  At least the format, size and data must be set.  There are
+   also initialization methods for automatically extracting the data and
+   format from a `CGImage`.
+
+   This class is a wrapper around a :type:`zbar_image_t` C object (q.v.)
+
+
+Properties
+----------
+
+   .. member:: unsigned long format
+
+      The image format four-charcter code (fourcc) as a 4-byte integer.  Use
+      :ref:`fourcc:<fourcc:>` to create a fourcc value from a string.
+
+   .. member:: unsigned sequence
+
+      A "sequence number" associated with the image.  This reference value is
+      unused by the library.
+
+   .. member:: CGSize size
+
+      The size of the image in pixels.
+
+      .. note::
+
+         There is no separate "bytesPerLine" property, the width must match
+         the image data (which is not always the logical image width).
+
+   .. member:: CGRect crop
+
+      Optionally limit the scan region to this rectangle without having to
+      generate a cropped image.
+
+   .. member:: const void *data
+
+      Obtain a pointer to the raw image data.  This property is read-only, use
+      :ref:`setData:withLength:<setData:withLength:>` to set the image data.
+
+   .. member:: unsigned long dataLength
+
+      Byte length of the raw image data.  This property is read-only, use 
+      :ref:`setData:withLength:<setData:withLength:>` to set the image data.
+
+   .. member:: ZBarSymbolSet *symbols
+
+      Barcode results from the last scan.
+
+   .. member:: zbar_image_t *zbarImage
+
+      Retrieve the underlying C object instance. (read-only)
+
+   .. member:: UIImage *UIImage
+
+      Convert the image to a UIImage.  Only certain image formats are
+      supported for conversion (read-only)
+
+      :See also: :ref:`UIImageWithOrientation:<UIImageWithOrientation:>`
+
+
+Class Methods
+-------------
+
+   .. _`fourcc:`:
+   .. describe:: + (unsigned long) fourcc:(NSString*)format
+
+      Parse the integer four-character code from a string.  Alternatively use
+      the :func:`zbar_fourcc` macro to create a constant expression.
+
+      :format: A four character string representing an image format.
+      :Returns: The corresponding 4-byte integer format code.
+
+
+Instance Methods
+----------------
+
+   .. _`initWithImage:`:
+   .. describe:: - (id) initWithImage:(zbar_image_t*)image
+
+      Initialize an image wrapper, given the C object to wrap.
+
+      :image: The C object to wrap.
+      :Returns: The initialized :class:`ZBarImage`.
+
+   .. _`initWithCGImage:`:
+   .. describe:: - (id) initWithCGImage:(CGImageRef)image
+
+      Initialize a :class:`ZBarImage` from the data and metadata extracted
+      from a `CGImage`.  The image is converted to `Y800` (grayscale) format.
+
+      :image: A `CGImage` to source the data and metadata.
+      :Returns: The initialized :class:`ZBarImage`.
+      :See also: :ref:`initWithCGImage:size:<initWithCGImage:size:>`
+
+   .. _`initWithCGImage:size:`:
+   .. describe:: - (id) initWithCGImage:(CGImageRef)image size:(CGSize)size
+
+      Initialize a :class:`ZBarImage` from the data and metadata extracted
+      from a `CGImage`.  The image is converted to `Y800` (grayscale) format
+      and scaled to the specified size.
+
+      :image: A `CGImage` to source the data and metadata.
+      :size: The pixel size of the resulting ZBarImage.
+      :Returns: The initialized :class:`ZBarImage`.
+      :See also: :ref:`initWithCGImage:crop:size:<initWithCGImage:crop:size:>`
+
+   .. _`initWithCGImage:crop:size:`:
+   .. describe:: - (id) initWithCGImage:(CGImageRef)image crop:(CGRect)crop size:(CGSize)size
+
+      Initialize a :class:`ZBarImage` from the data and metadata extracted
+      from a `CGImage`.  The image is simultaneously converted to `Y800`
+      (grayscale) format, cropped and scaled to the specified size.
+
+      :image: A `CGImage` to source the data and metadata.
+      :crop: The region to convert, in image coordinates.
+      :size: The pixel size of the resulting ZBarImage.
+      :Returns: The initialized :class:`ZBarImage`.
+
+   .. _`setData:withLength:`:
+   .. describe:: - (void) setData:(const void*)data withLength:(unsigned long)length
+
+      Specify a pointer to the raw image data, for the image format and size.
+      The length of the data must also be provided.  Note that the data must
+      remain valid as long as the image has a reference to it.  Set data to
+      ``NULL`` to clear a previous reference.
+
+      :data: A pointer to a raw image data buffer.
+      :length: The size of the image data buffer.
+
+   .. _`UIImageWithOrientation:`:
+   .. describe:: - (UIImage*) UIImageWithOrientation:(UIImageOrientation)orient
+
+      Convert the image to a UIImage with the specified orientation.  Only
+      certain image formats are supported for conversion.  (currently
+      ``RGB3``, ``RGB4``, ``RGBQ``)
+
+      :orient: Desired orientation of the image.
+      :Returns: A new :class:`UIImage`, or ``nil`` in case of error.
diff -r 563557a923d0 iphone/doc/ZBarImageScanner.rst
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/doc/ZBarImageScanner.rst	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,99 @@
+ZBarImageScanner Class Reference
+================================
+
+.. class:: ZBarImageScanner
+
+   :Inherits from: :class:`NSObject`
+
+   This is a low-level interface for programmatically scanning images without
+   a user interface.  If you want to scan images manually selected by the user
+   (from the photo library or using the camera), you may prefer to use a
+   :class:`ZBarReaderController` instead.
+
+   This class is a wrapper around a :type:`zbar_image_scanner_t` C object
+   (q.v.)
+
+
+Properties
+----------
+
+   .. member:: BOOL enableCache
+
+      Enable the inter-frame consistency cache.  Set to ``YES`` for scanning
+      video or ``NO`` for scanning images.
+
+   .. member:: ZBarSymbolSet results
+
+      Decoded symbols resulting from the last scan.
+
+
+Instance Methods
+----------------
+
+   .. _`parseConfig:`:
+   .. describe:: - (void) parseConfig:(NSString*)config
+
+      Apply scanner/decoder configuration parsed from a string.
+
+      :config: A configuration setting of the form: `symbology.config[=value]`.
+
+   .. _`setSymbology:config:to:`:
+   .. describe:: - (void) setSymbology:(zbar_symbol_type_t)symbology config:(zbar_config_t)config to:(int)value
+
+      Apply generic scanner/decoder configuration.
+
+      :symbology: The symbology to effect, or 0 for all.
+      :config: The configuration setting to adjust.
+      :value: The value to set for the specific configuration/symbology.
+
+   .. _`scanImage:`:
+   .. describe:: - (NSInteger) scanImage:(ZBarImage*)image
+
+      Scan an image for barcodes using the current configuration.  The image
+      must be in ``Y800`` format (8-bpp graysale).
+
+      :image: The :class:`ZBarImage` to scan.
+      :Returns: The number of barcode symbols decoded in the image.
+
+
+Constants
+---------
+
+.. type:: zbar_config_t
+
+   ZBAR_CFG_ENABLE
+      Control whether specific symbologies will be recognized.  Disabling
+      unused symbologies improves performance and prevents bad scans.
+
+   ZBAR_CFG_EMIT_CHECK
+      Whether to include the check digit in the result data string.  This
+      value may be set individually for symbologies where it makes sense.
+
+   ZBAR_CFG_MIN_LEN
+      The minimum data length for a symbol to be valid, set to 0 to disable.
+      Use with eg, I2/5 to avoid short scans.  This value may be set
+      individually for variable-length symbologies.
+
+   ZBAR_CFG_MAX_LEN
+      The maximum data length for which a symbol is valid, set to 0 to
+      disable.  Use with eg, I2/5 to enforce a specific range of data lengths.
+      This value may be set individually for variable-length symbologies.
+
+   ZBAR_CFG_UNCERTAINTY
+      Number of "nearby" frames that must contain a symbol before it will be
+      considered valid.  This value may be set for individual symbologies.
+
+   ZBAR_CFG_POSITION
+      Whether to track position information.  
+
+   ZBAR_CFG_X_DENSITY
+      The stride to use for scanning vertical columns of the image.  This many
+      pixel columns will be skipped between vertical scan passes.  Useful for
+      trading off between resolution and performance.  This is a scanner
+      setting (use 0 for the symbology).
+
+   ZBAR_CFG_Y_DENSITY
+      The stride to use for scanning horizontal columns of the image.  This
+      many pixel rows will be skipped between horizontal scan passes.  Useful
+      for trading off between resolution and performance.  This is a scanner
+      setting (use 0 for the symbology).
diff -r 563557a923d0 iphone/doc/ZBarReaderController.rst
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/doc/ZBarReaderController.rst	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,156 @@
+ZBarReaderController Class Reference
+====================================
+
+.. class:: ZBarReaderController
+
+   :Inherits from: :class:`UIImagePickerController`
+
+   This is the controller to use for scanning images selected by a
+   :class:`UIImagePickerController` either captured manually using the camera,
+   or selected from the Photo Library.  For more information, see
+   :doc:`picker`.
+
+   It can support automatic capture from the camera only if the library is
+   re-built to use private APIs (see :doc:`compat`).
+
+
+Properties
+----------
+
+   .. member:: ZBarImageScanner *scanner
+
+      Access to the image scanner for configuration. (read-only)
+
+   .. member:: id<ZBarReaderDelegate> readerDelegate
+
+      The delegate that will be notified when new barcode results are
+      available.
+
+   .. member:: BOOL showsZBarControls
+
+      Whether to display a default control set consisting of cancel, scan and
+      info buttons.  Disable these if you provide your own controls using the
+      :member:`cameraOverlayView`.  Enabling this automatically disables the
+      system controls :member:`showsCameraControls`.  (Default ``YES``).
+
+   .. member:: BOOL showsHelpOnFail
+
+      Whether to automatically display the integrated help viewer when an
+      image fails to decode.  Even if this is disabled, the integrated help
+      may still be presented manually using ``showHelpWithReason:``.
+      (Default ``YES``)
+
+   .. member:: ZBarReaderControllerCameraMode cameraMode
+
+      Scanning mode to use with the camera.  It is generally appropriate to
+      leave this at the default.
+
+   .. member:: BOOL tracksSymbols
+
+      Whether to display the tracking rectangle around detected barcodes.
+
+   .. member:: BOOL takesPicture
+
+      Whether to take a full picture (with ``takePicture``) when a barcode
+      is detected with ``ZBarReaderControllerCameraModeSampling``.  The
+      resulting image will be delayed from the actual decode.
+
+   .. member:: BOOL enableCache
+
+      This property is deprecated and should not be modified.
+
+   .. member:: CGRect scanCrop
+
+      Crop images before scanning.  The original image will be cropped to this
+      rectangle, which should be in normalized image coordinates, x-axis
+      major.  Defaults to the full image ``{{0, 0}, {1, 1}}``.
+
+   .. member:: NSInteger maxScanDimension
+
+      Scale image to scan.  After cropping, the image will be scaled if
+      necessary, such that neither of its dimensions exceed this value.
+      Defaults to 640.
+
+   .. note::
+
+      The remaining properties are inherited from
+      :class:`UIImagePickerController`.
+
+   .. member:: UIImagePickerControllerSourceType sourceType
+
+      Image source.  Use to select between the camera and photo library.
+
+   .. member:: BOOL showsCameraControls
+
+      Whether to display the system camera controls.  Overridden to ``NO``
+      when :member:`showsZBarControls` is ``YES``.
+
+   .. member:: UIView *cameraOverlayView
+
+      A custom view to display over the camera preview.  The tracking layer
+      and default controls will be added to this view if they are enabled.
+
+   .. member:: CGAffineTransform cameraViewTransform
+
+      A transform to apply to the camera preview.  Ignored by the reader.
+      Possibly useful for eg, a digital zoom effect.
+
+   .. member:: BOOL allowsEditing
+
+      Whether to enable the system image editing dialog after a picture is
+      taken.  Possibly useful to improve reader results in some cases using
+      manual intervention.
+
+
+Instance Methods
+----------------
+
+   .. _`showHelpWithReason:`:
+   .. describe:: - (void) showHelpWithReason:(NSString*)reason
+
+      Display the integrated help browser.  Use this with custom overlays if
+      you don't also want to create your own help view.  Should only be called
+      when the reader is displayed.  The ``reason`` argument will be passed to
+      the :func:`onZBarHelp` javascript function.
+
+      :reason: A string parameter passed to javascript.
+
+   .. _`scanImage:`:
+   .. describe:: - (id <NSFastEnumeration>) scanImage:(CGImageRef)image
+
+      Scan an image for barcodes.  This is a wrapper around
+      ``scanner.scanImage`` that applies scanCrop and maxScanDimension.  Some
+      additional result filtering is also performed.
+
+      :image: A :class:`CGImage` to scan.
+      :Returns: The result set containing :class:`ZBarSymbol` objects.
+
+
+Constants
+---------
+
+.. type:: ZBarReaderControllerCameraMode
+
+   The scanning mode to use with the camera.
+
+   ZBarReaderControllerCameraModeDefault
+      The standard mode provided by UIImagePickerController - the user
+      manually captures an image by tapping a control.  This is the default
+      unless private APIs are enabled.
+
+   ZBarReaderControllerCameraModeSampling
+      Automatically capture by taking screenshots with
+      :func:`UIGetScreenImage`.  Resolution is limited to the screen
+      resolution, so this mode is inappropriate for longer codes.  Only
+      available when private APIs are enabled, and becomes the default mode in
+      that case.
+
+   ZBarReaderControllerCameraModeSequence
+      Experimental mode that automatically scans by "rapidly" scanning
+      pictures captured with ``takePicture``.  Not recommended for serious
+      use.
+
+.. c:var:: NSString *ZBarReaderControllerResults
+
+   The info dictionary key used to return decode results to
+   ``imagePickerController:didFinishPickingMediaWithInfo:``
diff -r 563557a923d0 iphone/doc/ZBarReaderDelegate.rst
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/doc/ZBarReaderDelegate.rst	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,70 @@
+ZBarReaderDelegate Protocol Reference
+=====================================
+
+.. class:: ZBarReaderDelegate
+
+   :Inherits from: :class:`UIImagePickerControllerDelegate`
+
+   This protocol must be implemented by the
+   :member:`~ZBarReaderViewController::readerDelegate` provided to a
+   :class:`ZBarReaderViewController` or :class:`ZBarReaderController`.  It is
+   used to notify the delegate of new decode results, when an image fails to
+   decode, or when the user dismisses the reader with the built-in controls.
+
+
+Instance Methods
+----------------
+
+   .. describe:: - (void) imagePickerController:(UIImagePickerController*)picker didFinishPickingMediaWithInfo:(NSDictionary*)info
+
+      This inherited delegate method is called when a barcode is successfully
+      decoded.  The decoded symbols are available from the dictionary as a
+      :class:`ZBarSymbolSet` using the :c:data:`ZBarReaderControllerResults`
+      key.  The image from which the barcodes were scanned is available using
+      the :c:data:`UIImagePickerControllerOriginalImage` key.  No other keys
+      are guaranteed to be valid.
+
+      .. note::
+
+         The ``picker`` parameter will be the reader controller instance that
+         read the barcodes - not necessarily a
+         :class:`UIImagePickerController` instance.  You should cast it to the
+         correct type for anything other than basic view controller access.
+
+      :picker: The reader controller that scanned the barcode(s).
+      :info: A dictionary containing the image and decode results.
+
+   .. describe:: - (void) imagePickerControllerDidCancel:(UIImagePickerController*)picker
+
+      Called when the user taps the "Cancel" button provided by the built-in
+      controls (when :member:`showsZBarControls`\ ``=YES``).  The default
+      implementation dismisses the reader.  If this method is implemented, it
+      should do the same.
+
+      .. note::
+
+         The ``picker`` parameter will be the reader controller instance that
+         read the barcodes - not necessarily a
+         :class:`UIImagePickerController` instance.  You should cast it to the
+         correct type for anything other than basic view controller access.
+
+      :picker: The reader controller that scanned the barcode(s).
+
+   .. describe:: - (void) readerControllerDidFailToRead:(ZBarReaderController*)reader withRetry:(BOOL)retry
+
+      Called when an image, manually captured or selected from the photo
+      library, is scanned and no barcodes were detected.
+
+      If the ``retry`` parameter is ``NO``, the controller must be dismissed
+      before this method returns.  Otherwise, another scan may be attempted
+      without re-presenting the controller.
+
+      If the :member:`~ZBarReaderController::showsHelpOnFail` is ``YES`` *and*
+      ``retry`` is ``YES``, the integrated help viewer will already be
+      presenting.
+
+      If this method is not implemented, the controller will be dismissed iff
+      ``retry`` is ``NO``.
+
+      :reader: The :class:`ZBarReaderController` that scanned the barcode(s).
+      :retry: Whether another scan may be attempted.
diff -r 563557a923d0 iphone/doc/ZBarReaderView.rst
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/doc/ZBarReaderView.rst	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,126 @@
+ZBarReaderView Class Reference
+==============================
+
+.. class:: ZBarReaderView
+
+   :Inherits from: :class:`UIView`
+
+   This is a barcode reader encapsulted in a UIView.  It manages an
+   :class:`AVCaptureSession` with a camera device and a
+   :class:`ZBarCaptureReader`, presents the video preview and optionally
+   tracks detected barcode symbols.  A delegate will usually be assigned for
+   notification of new decode results.
+
+
+Properties
+----------
+
+   .. member:: id<ZBarReaderViewDelegate> readerDelegate
+
+      The delegate that will be notified of new decode results.
+
+   .. member:: ZBarImageScanner *scanner
+
+      Access to the image scanner is provided for configuration. (read-only)
+
+   .. member:: BOOL tracksSymbols
+
+      Whether to display the tracking annotation (default ``YES``).
+
+   .. member:: UIColor *trackingColor
+
+      The color of the tracking annotation (default green).
+
+   .. member:: BOOL allowsPinchZoom
+
+      Enable pinch gesture recognition for manually zooming the preview/decode
+      (default ``YES``).
+
+   .. member:: NSInteger torchMode
+
+      An :type:`AVCaptureTorchMode` value that will be applied if/when
+      appropriate.  (default Auto)
+
+   .. member:: BOOL showsFPS
+
+      Overlay the decode frame rate on the preview to help with performance
+      optimization.  This is for *debug only* and should not be set for
+      production.  (default ``NO``)
+
+   .. member:: CGFloat zoom
+
+      Zoom scale factor applied to the video preview *and* scanCrop.  This
+      value is also updated by the pinch-zoom gesture.  Valid values are in
+      the range [1,maxZoom].  (default 1.25)
+
+   .. member:: CGFloat maxZoom
+
+      Maximum settable zoom level.  The zoom property will be clipped to this
+      value.
+
+   .. member:: CGRect scanCrop
+
+      The region of the video image that will be scanned, in normalized image
+      coordinates.  Note that the video image is in landscape mode (default
+      {{0, 0}, {1, 1}})
+
+   .. member:: CGAffineTransform previewTransform
+
+      Additional transform that will be applied to the video preview.  Note
+      that this transform is *not* applied to scanCrop.
+
+   .. member:: AVCaptureDevice *device
+
+      The capture device may be manipulated or replaced.
+
+   .. member:: AVCaptureSession *session
+
+      Direct access to the capture session.  Warranty void if opened.
+      (read-only)
+
+   .. member:: ZBarCaptureReader *captureReader
+
+      Direct access to the capture reader.  Warranty void if opened.
+      (read-only)
+
+   .. member:: BOOL enableCache
+
+      :Deprecated:
+
+      Whether to use the inter-frame consistency cache.  This should always be
+      set to ``YES``.
+
+
+Instance Methods
+----------------
+
+   .. describe:: - (id) initWithImageScanner:(ZBarImageScanner*)imageScanner
+
+      :imageScanner: A pre-configured :class:`ZBarImageScanner` to use for scanning
+      :Returns: The initialized :class:`ZBarReaderView`
+
+   .. describe:: - (void) start
+
+      Begin/resume scanning after a call to ``stop``.
+
+   .. describe:: - (void) stop
+
+      Stop scanning and pause the video feed.
+
+   .. describe:: - (void) flushCache
+
+      Flush the inter-frame consistency cache.  Any barcodes in the frame will
+      be re-recognized in subsequent frames.
+
+   .. _`setZoom:animated:`:
+   .. describe:: - (void) setZoom:(CGFloat)zoom animated:(BOOL)animated
+
+      Set the zoom property with optional animation.
+
+   .. _`willRotateTointerfaceOrientation:duration:`:
+   .. describe:: - (void) willRotateToInterfaceOrientation:(UIInterfaceOrientation)interfaceOrientation duration:(NSTimeInterval)duration
+
+      Compensate for device / camera / interface orientation.  Must be called
+      by containing view controller that supports any non-portrait orientation
+      to restore the camera preview to the correct orientation.  Call from
+      view controller method of the same name for correct animation.
diff -r 563557a923d0 iphone/doc/ZBarReaderViewController.rst
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/doc/ZBarReaderViewController.rst	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,190 @@
+ZBarReaderViewController Class Reference
+========================================
+
+.. class:: ZBarReaderViewController
+
+   :Inherits from: :class:`UIViewController`
+
+   This is the controller to use for live scanning from the camera feed with
+   automatic capture.  For scanning from image files or with manual capture,
+   see :class:`ZBarReaderController`.
+
+
+Properties
+----------
+
+   .. member:: ZBarImageScanner *scanner
+
+      Access to the image scanner for configuration. (read-only)
+
+   .. member:: id <ZBarReaderDelegate> readerDelegate
+
+      The delegate that will be notified when new barcode results are
+      available.
+
+   .. member:: BOOL showsZBarControls
+
+      Whether to display a default control set consisting of cancel, scan and
+      info buttons.  Disable these if you provide your own controls using the
+      :member:`cameraOverlayView`.  (Default ``YES``).
+
+   .. member:: BOOL tracksSymbols
+
+      Whether to display the tracking rectangle around detected barcodes.
+
+   .. member:: NSUInteger supportedOrientationsMask
+
+      Set of interface orientations that the controller should support.  Use
+      :func:`ZBarOrientationMask` or ``ZBarOrientationMaskAll`` to
+      generate the mask.
+
+   .. member:: CGRect scanCrop
+
+      Crop images before scanning.  The original image will be cropped to this
+      rectangle, which should be in normalized image coordinates (NB the
+      camera image x-axis is *vertical* on the screen).  Defaults to the full
+      image ``{{0, 0}, {1, 1}}``.
+
+   .. member:: UIView *cameraOverlayView
+
+      A custom view to display over the camera preview.
+
+   .. member:: CGAffineTransform cameraViewTransform
+
+      A transform to apply to the camera preview.  Ignored by the reader.
+
+   .. member:: UIImagePickerControllerCameraDevice cameraDevice
+
+      The camera device to use for scanning.  Defaults to the system default
+      camera.
+
+   .. member:: UIImagePickerControllerCameraFlashMode cameraFlashMode
+
+      The "flash" (aka torch) mode to use while scanning.  Defaults to
+      UIImagePickerControllerCameraFlashModeAuto.
+
+   .. member:: UIImagePickerControllerQualityType videoQuality
+
+      The resolution to use while scanning.  Defaults to
+      UIImagePickerControllerQuality640x480.
+
+   .. member:: ZBarReaderView *readerView
+
+      View that presents the camera preview and performs the scanning.  This
+      view has other properties you may use to control the appearance and
+      behavior of the reader.
+
+      Note that this view may be released when it is not displayed (eg, under
+      low memory conditions).  You should apply any configuration just before
+      you present the reader.
+
+   .. member:: BOOL enableCache
+
+      This property is deprecated and should not be modified.
+
+   .. warning::
+
+      The remaining properties are deprecated, they are only present for
+      backward compatibility with :class:`ZBarReaderController` and will raise
+      an exception if inappropriate/unsupported values are set.
+
+   .. member:: UIImagePickerControllerSourceType sourceType
+
+      Raises an exception if anything other than
+      ``UIImagePickerControllerSourceTypeCamera`` is set.  If you want to scan
+      images, use a :class:`ZBarReaderController` instead of this class.
+
+   .. member:: UIImagePickerControllerCameraCaptureMode cameraCaptureMode
+
+      Raises an exception if anything other than
+      ``UIImagePickerControllerCameraCaptureModeVideo`` is set.
+
+   .. member:: BOOL allowsEditing
+
+      Raises an exception if anything other than ``NO`` is set.
+
+   .. member:: BOOL showsCameraControls
+
+      Raises an exception if anything other than ``NO`` is set.  Use
+      :member:`showsZBarControls` to disable the buit-in overlay.
+
+   .. member:: BOOL showsHelpOnFail
+
+      Any value set to this property is ignored.  It is only useful for
+      scanning images, for which you should use :class:`ZBarReaderController`.
+
+   .. member:: ZBarReaderControllerCameraMode cameraMode
+
+      This reader only supports scanning from the camera feed.  If you want to
+      scan manually captured images, use a :class:`ZBarReaderController`
+      instead of this class.
+
+   .. member:: BOOL takesPicture
+
+      Raises an exception if anything other than ``NO`` is set.  This
+      controller automatically returns the scanned camera frame and does not
+      support capturing a separate image.
+
+   .. member:: NSInteger maxScanDimension
+
+      Any value set to this property is ignored.  It is only useful for
+      scanning images, for which you should use :class:`ZBarReaderController`.
+
+
+Class Methods
+-------------
+
+   .. describe:: + (BOOL) isSourceTypeAvailable:(UIImagePickerControllerSourceType)source
+
+      Returns ``YES`` only if ``source`` is ``Camera`` and the
+      :class:`UImagePickerController` method of the same name also returns
+      ``YES``.
+
+   .. describe:: + (BOOL) isCameraDeviceAvailable:(UIImagePickerControllerCameraDevice)cameraDevice
+
+      See the :class:`UImagePickerController` method of the same name.
+
+   .. describe:: + (BOOL) isFlashAvailableForCameraDevice:(UIImagePickerControllerCameraDevice)cameraDevice
+
+      See the :class:`UImagePickerController` method of the same name.
+
+   .. describe:: + (NSArray*) availableCaptureModesForCameraDevice:(UIImagePickerControllerCameraDevice)cameraDevice
+
+      Returns an array with the single element
+      ``UIImagePickerControllerCameraCaptureModeVideo`` if the device is
+      avilable, otherwise returns an empty array.
+
+
+Instance Methods
+----------------
+
+   .. _`showHelpWithReason:`:
+   .. describe:: - (void) showHelpWithReason:(NSString*)reason
+
+      Display the integrated help browser.  Use this with custom overlays if
+      you don't also want to create your own help view.  Should only be called
+      when the reader is displayed.  The ``reason`` argument will be passed to
+      the :func:`onZBarHelp` javascript function.
+
+      :reason: A string parameter passed to javascript.
+
+   .. _`takePicture`:
+   .. describe:: - (void) takePicture
+
+      Capture the next available frame and send it over the usual delegate
+      path.
+
+
+Macros
+------
+
+   .. function:: ZBarOrientationMask(interfaceOrientation)
+
+      Generate a bit-mask for the specified interface orientation, suitable
+      for setting :member:`supportedOrientationsMask`.
+
+   .. describe:: ZBarOrientationMaskAll
+
+      Combination of :func:`ZBarOrientationMask` for all interface
+      orientations (Portrait, PortraitUpsideDown, LandscapeLeft and
+      LandscapeRight)
diff -r 563557a923d0 iphone/doc/ZBarReaderViewDelegate.rst
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/doc/ZBarReaderViewDelegate.rst	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,26 @@
+ZBarReaderViewDelegate Protocol Reference
+=========================================
+
+.. class:: ZBarReaderViewDelegate
+
+   :Inherits from: :class:`NSObject`
+
+   This protocol, which must be implemented by the `readerDelegate` provided
+   to a :class:`ZBarReaderView`, is used to notify the delegate of new decode
+   results.
+
+
+Instance Methods
+----------------
+
+   .. describe:: - (void) readerView:(ZBarReaderView*)readerView didReadSymbols:(ZBarSymbolSet*)symbols fromImage:(UIImage*)image
+
+      Called to notify the delegate of new decode results.
+
+      Note that the referenced image is a proxy for a video buffer that is
+      asynchronously being converted to a :class:`UIImage`, attempting to
+      access the data will block until the conversion is complete.
+
+      :readerView: :class:`ZBarReaderView` that scanned the barcode(s).
+      :symbols: :class:`ZBarSymbolSet` containing the decode results.
+      :image: :class:`UIImage` from which the barcode(s) were scanned.
diff -r 563557a923d0 iphone/doc/ZBarSymbol.rst
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/doc/ZBarSymbol.rst	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,186 @@
+ZBarSymbol Class Reference
+==========================
+
+.. class:: ZBarSymbol
+
+   :Inherits from: :class:`NSObject`
+
+   A symbol wraps all of the information the library has about a decoded
+   barcode.  Use the available properties to retrieve the barcode data, the
+   symbology (type of barcode), location and more.
+
+   This class is a simple wrapper around a :type:`zbar_symbol_t` C object
+   (q.v.)
+
+
+Properties
+----------
+
+   .. member:: zbar_symbol_type_t type
+
+      The type of symbology that was decoded. (read-only)
+
+   .. member:: NSString *typeName
+
+      The canonical name used by the library to represent the symbology.
+      (read-only)
+
+   .. member:: NSUInteger configMask
+
+      Bitmask of symbology config settings used during decode.
+
+   .. member:: NSUInteger modifierMask
+
+      Bitmask of symbology characteristics detected during decode.  See
+      :type:`zbar_modifier_t` for the currently defined modifier bits.
+
+   .. member:: NSString *data
+
+      The raw decoded barcode data. (read-only)
+
+   .. member:: int quality
+
+      A relative metric indicating rough confidence in the decoded value.
+      Larger values are better than smaller values. (read-only)
+
+   .. member:: zbar_orientation_t orientation
+
+      The general, axis-aligned orientation of the symbol, or
+      ZBAR_ORIENT_UNKNOWN if unknown. (read-only)
+
+   .. member:: ZBarSymbolSet *components
+
+      The components of a composite symbol. (read-only)
+
+   .. member:: const zbar_symbol_t *zbarSymbol
+
+      Retrieve the underlying C object instance. (read-only)
+
+   .. member:: CGRect bounds
+
+      Calculate a rough bounding box for the symbol. (read-only)
+
+      .. note::
+
+         Coordinates are relative to the image *data*, which may not match a
+         displayed UIImage.  Make sure to account for the UIImage orientation
+         when using these values.
+
+
+Class Methods
+-------------
+
+   .. _`nameForType:`:
+   .. describe:: + (NSString*) nameForType:(zbar_symbol_type_t)type
+
+      Retrieve the canonical name for a symbology used by the library, given
+      its enumerated value.
+
+      :type: The :type:`zbar_symbol_type_t` enumerated symbology value.
+      :Returns: A short string name for the symbology.
+
+
+Instance Methods
+----------------
+
+   .. _`initWithSymbol:`:
+   .. describe:: - (id) initWithSymbol:(const zbar_symbol_t*)symbol
+
+      Initialize a symbol wrapper, given the C object to wrap.
+
+      :symbol: The C object to wrap.
+      :Returns: The initialized symbol, or nil if an error occurred.
+
+
+Constants
+---------
+
+.. type:: zbar_symbol_type_t
+
+   Symbology identifiers.
+
+   ZBAR_NONE
+      No symbol was decoded.
+
+   ZBAR_PARTIAL
+      Intermediate status.
+
+   ZBAR_EAN8
+      EAN-8
+
+   ZBAR_UPCE
+      UPC-E
+
+   ZBAR_ISBN10
+      ISBN-10, converted from EAN-13
+
+   ZBAR_UPCA
+      UPC-A
+
+   ZBAR_EAN13
+      EAN-13
+
+   ZBAR_ISBN13
+      ISBN-13, converted from EAN-13
+
+   ZBAR_I25
+      Interleaved 2 of 5
+
+   ZBAR_DATABAR
+      GS1 DataBar (RSS)
+
+   ZBAR_DATABAR_EXP
+      GS1 DataBar Expanded
+
+   ZBAR_CODABAR
+      Codabar
+
+   ZBAR_CODE39
+      Code 39 (3 of 9)
+
+   ZBAR_QRCODE
+      QR Code
+
+   ZBAR_CODE128
+      Code 128
+
+.. type:: zbar_orientation_t
+
+   The coarse orientation of a symbol.
+
+   .. note::
+
+      Orientation is relative to the image *data*, which may not match a
+      displayed UIImage.  Make sure to account for the UIImage orientation
+      when using these values.
+
+   ZBAR_ORIENT_UNKNOWN
+      Unable to determine orientation.
+
+   ZBAR_ORIENT_UP
+      Upright, read left to right
+
+   ZBAR_ORIENT_RIGHT
+      Sideways, read top to bottom
+
+   ZBAR_ORIENT_DOWN
+      Upside-down, read right to left
+
+   ZBAR_ORIENT_LEFT
+      Sideways, read bottom to top
+
+.. type:: zbar_modifier_t
+
+   Decoder symbology modifier flags.
+
+   .. note::
+
+      These are bit indices, use eg, (1 << ZBAR_MOD_GS1) to test the
+      modifierMask property.
+
+   ZBAR_MOD_GS1
+      Barcode tagged as GS1 (EAN.UCC) reserved (eg, FNC1 before first data
+      character).  Data may be parsed as a sequence of GS1 AIs.
+
+   ZBAR_MOD_AIM
+      Barcode tagged as AIM reserved.
diff -r 563557a923d0 iphone/doc/ZBarSymbolSet.rst
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/doc/ZBarSymbolSet.rst	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,43 @@
+ZBarSymbolSet Class Reference
+=============================
+
+.. class:: ZBarSymbolSet
+
+   :Inherits from: :class:`NSObject`
+   :Conforms to: :class:`NSFastEnumeration`
+
+   A symbol set is a simple container for the symbols scanned from an image.
+   It supports :class:`NSFastEnumeration`, and not much else...  Use it to
+   iterate through the :class:`ZBarSymbol` objects in a decode result set::
+
+      ZBarSymbolSet *symbols = image.symbols;
+      for(ZBarSymbol *symbol in symbols) {
+          // process result
+      }
+
+   This class is a simple wrapper around a :type:`zbar_symbol_set_t` C object
+   (q.v.)
+
+
+Properties
+----------
+
+   .. member:: int count
+
+      The number of symbols in the set. (read-only)
+
+   .. member:: const zbar_symbol_set_t *zbarSymbolSet
+
+      Retrieve the underlying C object instance. (read-only)
+
+
+Instance Methods
+----------------
+
+   .. _`initWithSymbolSet:`:
+   .. describe:: - (id) initWithSymbolSet:(const zbar_symbol_set_t*)set
+
+      Initialize a symbol set wrapper, given the C object to wrap.
+
+      :set: The C object to wrap.
+      :Returns: The initialized symbol set, or nil if an error occurred.
diff -r 563557a923d0 iphone/doc/apiref.rst
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/doc/apiref.rst	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,16 @@
+*******************
+   API Reference
+*******************
+
+.. toctree::
+   :maxdepth: 1
+
+   ZBarImage
+   ZBarImageScanner
+   ZBarReaderController
+   ZBarReaderDelegate
+   ZBarReaderView
+   ZBarReaderViewController
+   ZBarReaderViewDelegate
+   ZBarSymbol
+   ZBarSymbolSet
diff -r 563557a923d0 iphone/doc/camera.rst
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/doc/camera.rst	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,130 @@
+Scanning From the Camera Feed
+=============================
+
+Many iOS developers want their application to support automatic recognition of
+barcodes from the camera feed in real-time.  ZBar makes this easy!
+
+There are three levels that you may choose to integrate at, from least complex
+(recommended) to most complex these are:
+
+* Use the fully integrated view controller - this is very easy to implement
+  and is the recommended approach.
+* Use the reader view with your own controller - this more advanced approach
+  allows you to embed the view directly in your view hierarchy.
+* Use the capture component with your own AVCapture session - this is not
+  supported and only provided for advanced developers with special needs who
+  are already familiar with AVCapture.
+
+
+Using a ZBarReaderViewController
+--------------------------------
+
+This is the fastest, easiest and recommend way to get the barcode reader into
+your application.  The procedure is the same as using a
+UIImagePickerController to take a picture with the camera, so it will help if
+you are familiar with that.  Basically you:
+
+1. Create the reader.
+
+   This is as simple as creating a new :class:`ZBarReaderViewController`::
+
+      ZBarReaderViewController *reader = [[ZBarReaderViewController alloc] init];
+
+2. Setup a delegate to receive the results.
+
+   The delegate should implement the :class:`ZBarReaderDelegate` protocol,
+   which inherits from :class:`UIImagePickerControllerDelegate`::
+
+      reader.readerDelegate = self;
+
+3. Configure the reader.
+
+   Aside from the properties of the reader itself, you can configure the
+   decoder via the :member:`~ZBarReaderViewController::scanner` property and
+   further customize the view via the
+   :member:`~ZBarReaderViewController::readerView` property::
+
+      // disable QR Code
+      [reader.scanner setSymbology: ZBAR_QRCODE
+                      config: ZBAR_CFG_ENABLE
+                      to: 0];
+      reader.readerView.zoom = 1.0;
+
+   See :doc:`custom` and :doc:`optimizing` for more details.
+
+4. Present the reader to the user.
+
+   Typically the controller is presented modally::
+
+      [self presentModalViewController: reader
+            animated: YES];
+
+   Alternatively, it may be added to a container controller.
+
+5. Process the results.
+
+   The controller will call the
+   ``imagePickerController:didFinishPickingMediaWithInfo:`` method of
+   your delegate every time new results become available.  The barcode data
+   can be obtained using the :c:data:`ZBarReaderControllerResults` key of the
+   info dictionary.  This key will return "something enumerable"; keep in mind
+   that there may be multiple results.  You may also retrieve the
+   corresponding image with :c:data:`UIImagePickerControllerOriginalImage` as
+   usual::
+
+      - (void) imagePickerController: (UIImagePickerController*) reader
+       didFinishPickingMediaWithInfo: (NSDictionary*) info
+      {
+          id<NSFastEnumeration> results =
+              [info objectForKey: ZBarReaderControllerResults];
+          UIImage *image =
+              [info objectForKey: UIImagePickerControllerOriginalImage];
+          ...
+
+   The ``reader`` parameter will be the actual type of the reader (not
+   necessarily a :class:`UIImagePickerController`).
+
+   .. note::
+
+      The delegate method should queue the interface response and return as
+      soon as possible; any processing of the results should be deferred until
+      later, otherwise the user will experience unacceptable latency between
+      the actual scan completion and the visual interface feedback.
+
+6. Dismiss the reader (or not).
+
+   Once you have the results you may dismiss the reader::
+
+      [reader dismissModalViewControllerAnimated: YES];
+
+   .. warning::
+
+      It is very important to dismiss from the *reader* (not the presenting
+      controller) to avoid corrupting the interface.
+
+   Alternatively, you may choose to continue scanning and provide visual
+   feedback another way (eg, maybe by updating your custom overlay with the
+   results).  The "continuous" mode of the readertest example does this.
+
+
+Using a ZBarReaderView
+----------------------
+
+:class:`ZBarReaderViewController` is a relatively thin wrapper around a
+:class:`ZBarReaderView`; it is possible to use the view directly, even from
+Interface Builder.  You lose only some of the simulator and rotation hooks.
+The documentation is also less complete, so you need to be able to UTSL.  See
+the :file:`EmbedReader` sample for a working example.
+
+
+Using the ZBarCaptureReader
+---------------------------
+
+If you have special requirements for the capture session or just want to use
+your own preview, you can add your own :class:`ZBarCaptureReader` to your
+session.  You must have a solid understanding of the AVCapture infrastructure
+if you plan to use this approach.
+
+.. admonition:: TBD
+
+   sorry, you're on your own here - UTSL  :)
diff -r 563557a923d0 iphone/doc/compat.rst
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/doc/compat.rst	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,190 @@
+Backward Compatibility
+======================
+
+Generally speaking, we take great care to ensure that each release of the
+library is backward compatible with previous versions - upgrading the library
+should not require any changes to your code and will continue to provide
+equivalent functionality.  The notable exception to this is the iOS 4 upgrade
+and associated "deprecation" of the former automatic capture method by our
+vendor.
+
+
+.. warning::
+
+   Versions before iOS 4 are no longer supported by the library.  We are no
+   longer able to test anything in this section, so you're on your own if you
+   try to make use of it.
+
+
+The Private API
+---------------
+
+The API that we use for automatic capture with iOS 3.x (namely
+:func:`UIGetScreenImage`) has an interesting history.  It has changed status
+several times, starting with "Private, unless we like you" moving to
+"reluctantly Public but undocumeted" by popular demand and reverting to
+"strictly Private" as of iOS 4.  The current story: if you want to distribute
+on the App Store, you had better not be using it - IOW, no automatic capture
+for you with iOS 3.x.
+
+Since App Store distribution is the most common use for the library, the
+default configuration, and thus the binary SDK, does *not* use any private
+APIs.
+
+Users targeting ad-hoc or enterprise distribution may not care about the
+status of the API and may prefer to continue supporting automatic capture for
+iOS 3.x.  To do this you will need to rebuild the library with the following
+define set for all configurations:
+
+.. sourcecode:: sh
+
+   USE_PRIVATE_APIS=1
+
+For reference, you can check whether your app refers to the offensive function
+with this command:
+
+.. sourcecode:: sh
+
+   $ otool -vI MyApp.app/MyApp | grep UIGetScreenImage
+
+If there is any output, then the executable includes the private API and is
+bound to be rejected if submitted for review.  Otherwise it is "clean" as far
+as this library is concerned.
+
+
+Upgrading to iOS 4
+------------------
+
+If you were using the reader before iOS 4 was introduced, you will want to
+upgrade to the new reader controller.  The performance has improved quite a
+bit, and you can continue to support automatic capture on the App Store.
+
+.. note::
+
+   This discussion only applies to automatic capture from the camera.  If you
+   are only scanning image files, or prefer/need to use manual capture, you
+   should not change anything.
+
+Basically just replace your old :class:`ZBarReaderController` with a new
+:class:`ZBarReaderViewController` and you're done!  See the reference and the
+next section for compatibility between the two classes.
+
+Also see the :doc:`install` instructions for details about upgrading the
+header references to use the SDK.
+
+
+Supporting iOS 3.x
+------------------
+
+The new :class:`ZBarReaderViewController` is intentionally designed to be
+compatible with the old :class:`ZBarReaderController` in most aspects that
+relate to reading barcodes.  When a :class:`ZBarReaderViewController` is
+initialized under iOS 3.x, it will *replace* itself with a
+:class:`ZBarReaderController`.  You can leverage the compatibility of these
+controllers to continue supporting iOS 3.x.
+
+The following properties and methods should be equivalent across
+implementations.  You may use them without regard for the actual instance
+type.
+
+========================================================  ====
+Equivalent Members
+========================================================  ====
+:member:`~ZBarReaderViewController::cameraOverlayView`
+:member:`~ZBarReaderViewController::cameraViewTransform`
+:member:`~ZBarReaderViewController::enableCache`
+:member:`~ZBarReaderViewController::scanner`
+:member:`~ZBarReaderViewController::readerDelegate`
+:member:`~ZBarReaderViewController::scanCrop`
+``showHelpWithReason:``
+:member:`~ZBarReaderViewController::showsZBarControls`
+:member:`~ZBarReaderViewController::tracksSymbols`
+========================================================  ====
+
+Some properties are available with :class:`ZBarReaderViewController` only for
+backward compatibility.  If these are configured, they must be set as
+indicated; attempts to set another value will raise an exception.
+
+====================================================  =======================================
+:class:`ZBarReaderController` Property                :class:`ZBarReaderViewController` Value
+====================================================  =======================================
+:member:`~ZBarReaderController::allowsEditing`        ``NO``
+:member:`~ZBarReaderController::cameraMode`           ``Sampling``
+:member:`~ZBarReaderController::maxScanDimension`     (ignored)
+:member:`~ZBarReaderController::showsCameraControls`  ``NO``
+:member:`~ZBarReaderController::showsHelpOnFail`      (ignored)
+:member:`~ZBarReaderController::sourceType`           ``Camera``
+:member:`~ZBarReaderController::takesPicture`         ``NO``
+====================================================  =======================================
+
+Also, the ``isSourceTypeAvailable:`` class method of
+:class:`ZBarReaderViewController` will return ``YES`` only for the ``Camera``
+source.
+
+All other members of :class:`ZBarReaderController`, including those inherited
+from :class:`UIImagePickerController` are not supported by
+:class:`ZBarReaderViewController`.  This includes ``takePicture`` and
+``scanImage:``, among others.
+
+Remaining members of :class:`ZBarReaderViewController`: are only available
+with the new implementation.  At the moment this is only
+:member:`~ZBarReaderViewController::readerView`, but any new properties or
+methods not listed here will also fall in this category.
+
+To access settings that may not be available in a potential fallback
+environment, you must verify that they exist and may be set as desired - eg,
+by testing the specific reader subtype.
+
+Weak Linking
+^^^^^^^^^^^^
+
+When leveraging fallbacks to iOS 3.x, it is important that features introduced
+in iOS 4 are referenced using *weak* links.  You must configure your project
+correctly to support this:
+
+* Make sure the iOS 4 frameworks are set to *Weak*.  Specifically, these are
+  AVCapture, CoreMedia and CoreVideo.
+
+* Build with the latest SDK - do *not* use the "Base SDK" setting to target
+  earlier devices.
+
+* Set the correct iOS 3.x version for the "iPhone OS Deployment Target"
+  build setting.
+
+
+Example: Fallback to Manual Capture
+-----------------------------------
+
+This code example will configure the reader for automatic capture from the
+camera for iOS 4 and fall back to manual or automatic capture for iOS 3.x,
+depending on whether the library was compiled to use private APIs::
+
+   if(![ZBarReaderController isSourceTypeAvailable:
+                                 UIImagePickerControllerSourceTypeCamera]) {
+       // camera unavailable: display warning and abort
+       // or resort to keypad entry, etc...
+       return;
+   }
+   
+   ZBarReaderViewController *reader = [ZBarReaderViewController new];
+   // reader will be a ZBarReaderController for iOS 3.x
+   // or a ZBarReaderViewController for iOS 4
+   
+   reader.readerDelegate = self;
+   reader.sourceType = UIImagePickerControllerSourceTypeCamera;
+   reader.showsZBarControls = YES;
+   
+   if(reader.cameraMode == ZBarReaderControllerCameraModeSampling) {
+       // additional automatic capture configuration here
+   }
+   else {
+       // additional manual capture configuration here
+   }
+   
+   [self presentModalViewController: reader
+         animated: YES];
+
+If you are using a custom control set
+(:member:`~ZBarReaderViewController::showsZBarControls`\ ``=NO``), you will
+want to provide a button attached to ``takePicture`` for the manual capture
+case.  The built-in controls do this automatically.
diff -r 563557a923d0 iphone/doc/conf.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/doc/conf.py	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,77 @@
+import sys, os
+from plistlib import readPlist
+
+# General configuration
+
+extensions = []
+templates_path = ['ext']
+source_suffix = '.rst'
+master_doc = 'index'
+exclude_patterns = ['.#*']
+
+project = u'ZBar iPhone SDK'
+copyright = u'2010-2012, Jeff Brown et al'
+
+today_fmt = '%Y-%m-%d'
+info = readPlist('../res/ZBarSDK-Info.plist')
+version = 'X.Y'
+if info:
+    version = info['CFBundleVersion']
+release = version
+
+#add_module_names = False
+
+pygments_style = 'sphinx'
+highlight_language = 'objc'
+primary_domain = 'cpp'
+
+# Options for HTML output
+
+html_theme = 'default'
+html_theme_options = {
+    'bgcolor': 'white',
+    'textcolor': 'black',
+    'linkcolor': '#247',
+    'headbgcolor': '#edeff0',
+    'headtextcolor': '#247',
+    'headlinkcolor': '#c11',
+    'sidebarbgcolor': '#247',
+    'sidebartextcolor': 'white',
+    'sidebarlinkcolor': '#cde',
+    'relbarbgcolor': '#247',
+    'relbartextcolor': '#ccc',
+    'relbarlinkcolor': 'white',
+    'footerbgcolor': 'white',
+    'footertextcolor': 'black',
+    'codebgcolor': '#dfe',
+    'codetextcolor': 'black',
+}
+
+html_short_title = 'ZBarSDK ' + version
+html_title = 'ZBar iPhone SDK Documentation'
+html_static_path = ['static']
+html_favicon = '../../zbar.ico'
+html_style = 'style.css'
+html_use_modindex = False
+html_use_index = False
+html_copy_source = False
+html_show_sourcelink = False
+htmlhelp_basename = 'doc'
+
+# Options for LaTeX output
+
+latex_paper_size = 'letter'
+latex_font_size = '10pt'
+
+# Grouping the document tree into LaTeX files. List of tuples
+# (source start file, target name, title, author, documentclass [howto/manual])
+latex_documents = [
+  ('index', 'ZBarSDK.tex', u'ZBar iPhone SDK Documentation',
+   u'Jeff Brown', 'manual'),
+]
+
+#latex_logo = ''
+#latex_use_parts = False
+#latex_preamble = ''
+#latex_appendices = []
+#latex_use_modindex = False
diff -r 563557a923d0 iphone/doc/custom.rst
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/doc/custom.rst	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,70 @@
+Customizing the Interface
+=========================
+
+The reader supports customization of the camera overlay and the integrated
+help that is displayed.
+
+
+Customizing the Overlay
+-----------------------
+
+If you are scanning with the camera, whether using a
+:class:`ZBarReaderViewController` for automatic capture or manually with
+:class:`ZBarReaderController`, you may want to customize the appearance of the
+reader.  You do this mainly by setting a
+:member:`~ZBarReaderViewController::cameraOverlayView`.
+
+Note that if you are scanning images from the photo library, there is no
+customization - you are limited to the system picker interface provided by the
+:class:`UIImagePickerController`.
+
+If you are using a :class:`ZBarReaderViewController` and just want to add to
+the existing controls, you can simply set your overlay to include the
+additional view hierarchy::
+
+   reader.cameraOverlayView = myLogoImageView;
+
+Otherwise, if you are using a :class:`ZBarReaderController` or prefer to
+completely replace the default controls, you should disable those first.  Note
+that you will need to provide your own controls, which should at least include
+a way to dismiss the reader::
+
+   reader.showsCameraControls = NO;  // for UIImagePickerController
+   reader.showsZBarControls = NO;
+   reader.cameraOverlayView = myControlView;
+
+For manual capture with :class:`ZBarReaderController`, you should also include
+a control connected to :member:`~ZBarReaderController::takePicture`.
+
+In either case, the overlay view may be loaded from a NIB, or simply created
+programmatically.
+
+You can also disable the tracking rectangle that highlights barcodes with
+:member:`~ZBarReaderViewController::tracksSymbols`.
+
+
+Presenting Help
+---------------
+
+If you have set ``showsZBarControls = NO`` and replaced the default controls,
+you may still present the built-in help viewer.  Just hook your custom control
+to the ``showsHelpWithReason:`` method of the controller.  You should only
+call this method when the reader is actually presented.
+
+The default reader controls invoke ``showsHelpWithReason:`` with a reason
+parameter of ``"INFO"`` when the info button is tapped.
+
+
+Customizing the Help Content
+----------------------------
+
+Whether you use the default controls or provide your own, you can still
+customize the content of the help that is displayed.  The integrated viewer
+uses a UIWebView to display the contents of :file:`zbar-help.html` that we
+copied into your Resources.  You should hack this up as you see fit to give
+your users the best help experience.
+
+To allow for runtime customization based on the reason for presenting help,
+the javascript function ``onZBarHelp`` will be called just before the page is
+displayed, with the ``reason`` argument set as provided to
+``showsHelpWithReason:``.
diff -r 563557a923d0 iphone/doc/devguide.rst
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/doc/devguide.rst	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,13 @@
+***********************
+   Developer's Guide
+***********************
+
+.. toctree::
+   :maxdepth: 2
+
+   camera
+   picker
+   custom
+   optimizing
+   compat
+   licensing
diff -r 563557a923d0 iphone/doc/faq.rst
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/doc/faq.rst	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,101 @@
+Frequently Asked Questions (FAQ)
+================================
+
+This is the ever-growing list of answers to commonly asked questions.  Please
+feel free to post you question in our `iPhone Developers forum`_ if you do not
+find the information you need in this documentation.
+
+.. _`iPhone Developers Forum`:
+   http://sourceforge.net/projects/zbar/forums/forum/1072195
+
+
+General
+-------
+
+This looks great...  Where can I get it?
+   You can download the latest version of the SDK from
+   http://zbar.sf.net/iphone
+
+
+Compatibility
+-------------
+
+Which iPhone devices does this library support?
+   The library works *only* with iOS devices that have an auto-focus camera.
+   Currently, the iPhone 3GS, iPhone 4 and newer devices.  The iPad 2 and iPad
+   3 will also work in many cases, *iff* the barcode is printed large enough
+   to achieve good focus.
+
+Will you make it work with the iPhone 3G?
+   *No* - the 3G it is not supported and is unlikely to ever be supported.
+
+   To be fair, you *can* use the 3G to scan image files, as long as they're in
+   focus (ie, *not* images taken by the built-in fixed-focus camera).  There
+   is at least one application that found a use for this...
+
+What target iOS versions does this library work with?
+   iOS 4, 5 and 6 are fully supported, including the latest video streaming
+   interfaces.  Since Apple has dropped support for earlier versions of iOS on
+   the App Store, we recommend that you target only iOS 4 and later for reading
+   barcodes.
+
+   Note that iOS 3.1 is no longer supported; if you really think you need
+   that, you should still be able to get it working...  See :doc:`compat` for
+   details about iOS version fallbacks.
+
+   In all cases you should use the latest SDK to build.
+
+Are any private APIs in use?
+   No - the binary release of the SDK does not use any private APIs.
+
+Does this support "automatic" barcode capture?
+   Yes - with recent iOS versions, the default configuration will capture
+   barcodes automatically from the video stream.
+
+
+Building
+--------
+
+I get "Undefined symbols" errors when I try to build?
+   Most likely you did not add all of the necessary framework dependencies.
+   See :doc:`tutorial` or :doc:`install` for the list of frameworks you need
+   to link against.
+
+
+Licensing
+---------
+
+Please refer to :doc:`licensing` for questions about licensing.
+
+
+Barcodes
+--------
+
+Why do my UPC barcodes have an extra 0 at the front?
+   The UPC-A_ symbology is the subset of EAN-13_ that starts with a leading 0.
+   The ZBar decoder enables only EAN-13_ by default, so GTIN-13_ product codes
+   are consistently reported.  You can choose to receive the 12-digit results
+   instead by explicitly enabling UPC-A_.
+
+   The :member:`~ZBarSymbol::type` property of the symbol can be used to see
+   which type of barcode is reported.
+
+   See EAN-13_ and UPC-A_ for more information.
+
+Why does my UPC-E (short version) barcode data look completely wrong?
+   UPC-E_ is a "zero compressed" version of UPC-A_; certain of the zeros are
+   removed from the UPC-A_ data to generate the UPC-E_ barcode.  The ZBar
+   decoder *expands* this compression by default, again to consistently report
+   GTIN-13_ product codes.  You can choose to receive the compressed 8-digit
+   results instead by explicitly enabling UPC-E_.
+
+   The :member:`~ZBarSymbol::type` property of the symbol can be used to see
+   which type of barcode is reported.
+
+   See UPC-E_ for more information.
+
+.. _GTIN-13:
+.. _GTIN: http://wikipedia.org/wiki/GTIN
+.. _EAN-13: http://wikipedia.org/wiki/EAN-13
+.. _UPC-A: http://wikipedia.org/wiki/UPC-A
+.. _UPC-E: http://wikipedia.org/wiki/UPC-E#UPC-E
diff -r 563557a923d0 iphone/doc/getstarted.rst
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/doc/getstarted.rst	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,12 @@
+*********************
+   Getting Started
+*********************
+
+.. toctree::
+   :maxdepth: 2
+   :numbered:
+
+   install
+   tutorial
+   faq
+   support
diff -r 563557a923d0 iphone/doc/index.rst
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/doc/index.rst	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,20 @@
+################
+  ZBar iOS SDK
+################
+
+Welcome to the ZBar SDK for iOS!
+
+This documentation covers all aspects of developing with the SDK: from adding
+the SDK to your project, to writing code that uses it, even licensing the
+library with your app.
+
+Please let us know if you find anything inaccurate or lacking (even better,
+send doc patches!)
+
+.. toctree::
+   :maxdepth: 2
+   :numbered:
+
+   getstarted
+   devguide
+   apiref
diff -r 563557a923d0 iphone/doc/install.rst
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/doc/install.rst	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,141 @@
+Installing the SDK
+==================
+
+These are the basic instructions for obtaining the SDK and adding it to an
+Xcode project.
+
+You may want to try things out with the :doc:`tutorial` before hacking at your
+own project.
+
+
+Requirements
+------------
+
+You will need *all* of the following to develop iPhone applications
+using this SDK:
+
+* Mac OS X >= 10.6.x (Snow Leopard)
+* Xcode >= 4.5.1
+* iPhone SDK >= 4.0
+* An iPhone 3GS, iPhone 4 or newer iOS device with an auto-focus camera
+* iOS >= 4.0 running on the device
+
+.. warning::
+
+   *Only* the iPhone 3GS, iPhone 4 and newer models are supported, as they
+   have a camera with auto-focus.  The iPad 2 and iPad 3 will also work, *iff*
+   the barcode is printed large enough to achieve good focus.  The ZBar
+   library does not support the iPhone 3G and is unlikely to ever support it.
+
+
+Downloading
+-----------
+
+Download the latest binary release of the ZBar SDK from
+
+http://zbar.sourceforge.net/iphone
+
+
+Integration
+-----------
+
+The recommended installation method is to simply copy the SDK into your
+Xcode project:
+
+1. Open ZBarSDK-|version|.dmg in the Finder.
+
+2. Drag the :file:`ZBarSDK` folder into your Xcode project.  In the dialog
+   that appears, you should choose to **copy** the SDK into your project by
+   checking the box.  The target that you want to link with the library should
+   also be selected in the target list.
+
+3. Link the following additional frameworks to any targets that link with the
+   ZBarSDK.  You should set the first three to use weak references and
+   configure an appropriate deployment target if you still need to support
+   iOS 3:
+
+   * :file:`AVFoundation.framework` (weak)
+   * :file:`CoreMedia.framework` (weak)
+   * :file:`CoreVideo.framework` (weak)
+   * :file:`QuartzCore.framework`
+   * :file:`libiconv.dylib`
+
+   If you check "Link Binary With Libraries" for the target(s), you should see
+   all of these frameworks followed by :file:`libzbar.a`.
+
+   .. note::
+
+      Link order may be important for some versions of Xcode; the referenced
+      libraries should be listed *before* :file:`libzbar.a` in the link order.
+
+4. Import the SDK header from your prefix header to make the barcode reader
+   APIs available::
+
+      #import "ZBarSDK.h"
+
+Proceed to :doc:`camera` or :doc:`picker` to learn about using the reader APIs
+to scan barcodes.  Use the :doc:`apiref` for specific interface details.
+
+
+Upgrading from an Older Version
+-------------------------------
+
+If you are using an older version of the *SDK* (NB, skip to the next section
+if you are currently using Mercurial), upgrading is straightforward:
+
+1. Delete the current ZBarSDK group from your project.  You should choose
+   to delete the files if you copied them into your project.
+2. Drag the new ZBarSDK from the DMG into your project.
+
+Clean out and rebuild your project with the new version.
+
+
+Upgrading a Pre-SDK Integration
+-------------------------------
+
+If your project was using the library directly from the Mercurial repository,
+before the SDK was introduced, there are a few incompatibilities that you must
+resolve in order to upgrade.  Don't worry - all of your source stays the same,
+you just need to update how the library is included in the project and how the
+headers are imported.
+
+Switching to the Binary Distribution
+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+
+This approach is recommended - the binary releases provide you with a stable
+development platform, isolating you from temporary instability and transient
+problems that may occur at the bleeding edge.
+
+The first task is to reverse the previous ZBar integration:
+
+1. Remove the reference to zbar.xcodeproj from your project.
+2. Remove any :file:`zbar-*` files from your Resources.
+3. In the target build settings, remove any "Header Search Paths" that
+   reference zbar.
+4. Remove any references to zbar headers in your :file:`prefix.pch` or source
+   files.
+
+Now just continue with the `integration`_ instructions above and you should be
+back up and running!
+
+Continuing with Mercurial
+^^^^^^^^^^^^^^^^^^^^^^^^^
+
+Alternatively, you may still prefer to select Mercurial revisions.  You have a
+few choices for this:
+
+* You may build your own ZBarSDK and copy/link it into your project.  This is
+  the same as `Switching to the Binary Distribution`_, except that you use
+  your own version of the SDK.  In this case you need to manually rebuild the
+  SDK when you update it.
+* You may leave zbar.xcodeproj as a project dependency and pull the SDK into
+  your project.  This is not well tested, so ymmv.
+* You may leave zbar.xcodeproj as a project dependency and just link libzbar.a
+  into your project, as before.  You will need to update the target dependency
+  (the library target changed names to libzbar) and add the
+  :file:`iphone/include/ZBarSDK` directory to "Header Search Paths"
+
+In any case, you should remove the references to the zbar headers from
+:file:`prefix.pch` (or your source files) and replace them with::
+
+   #import "ZBarSDK.h"
diff -r 563557a923d0 iphone/doc/licensing.rst
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/doc/licensing.rst	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,187 @@
+Licensing the Library
+=====================
+
+First of all, the big disclaimer:
+
+.. warning::
+
+   We are *not* lawyers; we cannot help you decide if you should use the
+   library or how to apply the license, only your lawyer can advise you
+   concerning legal matters.
+
+That said, it should also be noted that we have neither the resources (time,
+cash, etc) nor the patience to enforce the license (at all); the reality is
+that all of this is left to your discretion.
+
+If you prefer to leave the lawyers out of it, the rest of this section will
+help you apply the license to your application.
+
+
+Licensing FAQ
+-------------
+
+Can I use this library with my proprietary (closed source) application?
+   Yes, that is our intent and we do not believe there is any problem
+   regarding the license.
+
+Will I need to open source my entire app?
+    No, it is not required by the license.
+
+Will I need to distribute all of my "object files" on the App Store?
+    No, this is also not required by the license, although you should offer to
+    provide them upon request.  See below for more detail.
+
+But I read somewhere that "iPhone apps may not use LGPL code"?
+   That statement is an over-generalization that does not apply in this case.
+   Most likely your source is either:
+
+   * referring to the GPL, which is significantly different from the
+     *L*\ GPL
+   * referring to a different version of the LGPL; we intentionally use
+     version 2.1, which has specific static linking exceptions.
+   * not a lawyer either and too lazy to read the whole license
+
+   Basically, if you leverage the appropriate sections of the license, it
+   should be fully compatible with the App Store restrictions and
+   requirements.
+
+This is too complicated, can I just pay for an easier license?
+   No, it is not possible.  There are multiple problems with this approach,
+   some brief highlights:
+
+   * Most open source projects (including this one) do not have a single
+     author.  Tracking down every contributor and getting their approval could
+     be quite a challenge.
+   * The license is meant to protect users' rights to the software.  Giving
+     you special treatment bypasses the protection we offered them,
+     effectively revoking their rights.  This would be a violation of their
+     trust and completely defeats the purpose of the license.
+
+   You may think of this as the "price" you pay for using our open source
+   library.  If you want to make your life easier, you should be petitioning
+   Apple for shared library support...
+
+What if you add a clause that lets me do whatever I want?
+   No, also not possible.  In addition to the problems mentioned above, there
+   are even more problems with this:
+
+   * Sourceforge requires an OSI approved license for hosting our project;
+     an altered license would no longer be approved.
+   * Again we are not lawyers and therefore not qualified to change the
+     license, we would have to pay one of those slimy buggers to do it.
+
+Do I need to add an "about" dialog to display your copyright/license?
+   No, not as such.  We won't discourage you from plugging the library if you
+   like, but it is not a requirement.  You should think of our license as a
+   supplement to your own software license, therefore it is appropriate to
+   display it where (and only where) you display your own:
+
+   * If you follow Apple's recommendation, the App Store is the only place
+     that the user accesses your license, so it should also be the only place
+     where the library supplement is available.
+   * If your app already has some kind of "about" view that displays your
+     copyright/license information, it is also appropriate to display the same
+     information for the library.
+
+Do I need to include the entire library in my application bundle?
+   No, it is not necessary:
+
+   * If you have not modified the library, it is sufficient to provide a link
+     to the project and the version information.
+   * If you are using a modified version, you may provide a link to download
+     that instead of including it in the bundle.
+
+
+Modifications
+-------------
+
+What is a "modification"?  Again, we leave it to your discretion with this
+guidance:
+
+* If you use the distributed binary SDK you have certainly not modified the
+  library.
+* If you are working from Mercurial, *any* change you have made to the
+  "source code" of the library is a modification, it does not matter how
+  trivial.  You can see what changes have been made by running
+  ``hg status -mard``; if this command outputs anything, you have modified
+  the library.
+
+If you find that you have made changes to the library, you should carefully
+consider how far you want to proceed down that path.  Once you publish your
+changes you have created a "fork" of the project which you now need to
+maintain.  Are you prepared to merge every time the library is updated?
+
+If your change adds a useful feature to the library, we absolutely encourage
+you to submit patches.  Assuming you can get your patch into the project, then
+you will no longer need to use a modified version!  When submitting patches,
+ensure that your changes are appropriate for all of our users.  Specifically,
+we are not interested in patches that simply hack up the library to work the
+way you want.  Compare a patch that changes the default behavior to your
+preference (probably not acceptable), to a patch that adds a new configuration
+to support the feature you have added (probably fine).
+
+
+Object File Distribution
+------------------------
+
+Section 6 of the LGPL v2.1 specifically permits static linking with the
+library.  If your project is not open source, this section does require that
+you make your object files available to your users.  The intent, as indicated
+in the license, is that a user who has obtained your software may exercise
+their right to modify the library and then re-link their modified version into
+your application.
+
+We recommend that you apply Subsection 6c, which only requires that you make a
+written offer to provide the object files.  Now...if you consider the actual
+utility of this mechanism - that it is only applicable to developers, and only
+those with in depth knowledge of the tools, the time required for development
+- all to have a new barcode reader in a specific version of your application
+that only they can use, the reality is that no one is going to request this.
+You probably should not even waste time preparing for it until a request is
+made.
+
+Additionally, to avoid "casual requests" from nefarious types that just want
+to inconvenience you, also consider charging a fee for the distribution of
+this material (as permitted by the license); just add up the cost of burning
+and shipping a disk.  If this cost is "large" compared to the price of your
+app, the likelyhood of a request is reduced even further.
+
+
+Using the Unmodified Library
+----------------------------
+
+Applying the license in this case is somewhat simpler.  These are the basic
+steps you can follow:
+
+1. Verify that the rest of your software license is compatible with the LGPL.
+   You cannot use the library if they are incompatible.
+
+   For those using the default App Store license, we have reviewed this and
+   believe it is compatible with the LGPL.
+
+2. At the end of your license text, in an annex or supplement, start by
+   declaring your use of the library and offering a link to the project.
+   Something like this:
+
+      This software uses the open source ZBar Barcode Reader library, version
+      |version|, which is available from http://zbar.sourceforge.net/iphone
+
+   If you built your own version of the library, replace the version callout
+   with eg, "cloned from Mercurial revision xxxxxxxx"
+
+3. Then append the contents of the text file COPYING, included with the
+   library.  This is all of the copyright information for the library.
+
+4. Then append the contents of the text file LICENSE, also included with the
+   library.  This is just the LGPL version 2.1 which you may also obtain from
+   http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
+
+5. You may choose to make the written offer for the object files explicit.
+   Provide some text and whatever link or email address is appropriate.
+
+
+Using a Modified Library
+------------------------
+
+We intentionally leave this option vague and force you to refer to the license
+as an underhanded way of encouraging you to contribute back to the project ;)
diff -r 563557a923d0 iphone/doc/optimizing.rst
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/doc/optimizing.rst	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,435 @@
+Optimizing the Reader
+=====================
+
+As good as the iPhone performance is for a mobile device, the reality from an
+image processing perspective is that it represents a lower performance target.
+While the default configuration of the iPhone reader has been carefully tuned
+for the general case, you can often obtain much better results if you optimize
+for your specific application.
+
+.. note::
+
+   Performance is a complex topic.  The only way to tune performance is by
+   changing settings and comparing measured results.  If you are not
+   comfortable with the concepts presented here, it is recommended that you
+   leave the settings at the defaults and avoid compromising reliability.
+
+Performance of the barcode reader is generally evaluated by two factors:
+
+* The **latency** - how quickly it "recognizes" a barcode.  Specifically this
+  is the time from when the user puts a barcode in the frame or selects an
+  image until a response is indicated back to the them.
+
+* The **reliability** - it does not matter how quickly an image is scanned if
+  an incorrect result is returned.  That may seem obvious, but bad decodes
+  *are* possible and you need to keep this in mind when changing settings that
+  affect the reliability of the reader.
+
+Basically our goal is to optimize the latency without sacrificing reliability.
+There are several factors that contribue to latency:
+
+* The **quality** of the barcode image.  Quality includes the available
+  resolution, focus, lighting, noise, etc.  We have more control over some of
+  these than others.
+
+* The **camera**.  When scanning from the camera, the time for the
+  autoexposure and autofocus to converge on an image that can be decoded is a
+  significant contribution to the overall latency.
+
+* The **frame rate** of the reader - this translates to the time it takes the
+  scanner to process an image.
+
+* The **effort level** of the reader - some of the available settings control
+  "how hard" the reader tries to find barcodes in each frame.
+
+* The **delegate latency** - the time spent in your application after a
+  barcode has been detected until the user is notified.
+
+Most of these factors are interrelated.  We will discuss those we can control
+in detail, as well the settings you use to affect them.  Then we will provide
+a few specific case examples.
+
+
+Measuring Performance
+---------------------
+
+Subjective response times are a good place to start (does it "feel" responsive
+to you?), and possibly the only way to evaluate the overall experience, but to
+compare incremental changes to interrelated settings and have meaningful
+performance discussions with others, we need a more quantitative approach.
+
+The :func:`mach_absolute_time` function is a good tool for accurately
+measuring small delays.  Research this function and learn how to apply it.  As
+when measuring any real-world value, keep in mind that some variance is to be
+expected - even if you perform exactly the same operation multiple times, you
+will not see exactly the same measurement.  You should collect several
+samples, discard any obvious outliers, and average the remaining measurements.
+
+One way that the overall reader latency may be evaluated is by manually
+marking the time when the barcode is presented to the reader.  Add a control
+to your overlay that captures the start time when tapped and compare this to
+the end time, just before your delegate returns.
+
+The reader continually monitors the frame rate at which it is running.  The
+measured value may be displayed for debugging purposes by enabling the
+:member:`~ZBarReaderView::showsFPS` property.  The readertest example does
+this and also provides control over many of the available settings, so you can
+quickly test how each setting affects the frame rate.  You should target your
+optimization efforts to achieve a frame rate of at least 8-10fps, although
+12-15fps is preferable.
+
+You can measure the latency of your delegate using :func:`mach_absolute_time`.
+The measured value should be less than about 100ms, the smaller the better, to
+avoid noticeable lag.
+
+The readertest is a good tool for testing the performance of the reader.  You
+can tune the settings appropriately for your application and evaluate the
+effect each change has on the performance.
+
+
+Delegate Latency
+----------------
+
+This latency contributor is the easiest for you to effect (and sometimes the
+easiest to overlook).  Your delegate method should update the interface -
+dismiss the controller or update your overlay to indicate success - and
+*nothing* else.  All other processing should be deferred until after the
+animations have started.
+
+
+Image Quality
+-------------
+
+Resolution
+^^^^^^^^^^
+
+One might think that "more is better" in terms of resolution, but this is not
+necessarily the case.  Given average image quality, the ideal resolution for
+scanning is right around three pixels per barcode "module" (the width of the
+smallest bar or space).  Note that this measure is not an absolute image size
+or even a measure of the physical dimensions represented by a pixel sample, it
+*only* describes the sampled size of the barcode in the image.
+
+As the resolution decreases below about two pixels per module, edge fidelity
+is lost and the bars and spaces start to merge together, making it impossible
+(for this library) to scan.  This affects the density (feature size) and
+maximum size (data capacity) of the barcodes that can be detected.
+Conversely, as the resolution increases above about 4 pixels per module, noise
+can interfere with the edge detection and images will take longer to process.
+
+Other quality factors, such as poor focus, bad lighting or even excessive
+noise, can increase (or decrease) the resolution requirement.
+
+When scanning from the camera, the reader defaults to 640x480, which is good
+for most applications.  On newer devices, you can increase this using a capture
+:member:`~ZBarReaderView::session` preset.  Some older devices do not have a
+higher resolution option available.
+
+For scanning images, you can use
+:member:`~ZBarReaderController::maxScanDimension` to control the scaled size
+of the converted image, or resort to converting them yourself.
+
+If you want to read long linear barcodes or dense 2-D symbols, you will
+probably want to increase the resolution by adjusting these settings.
+
+Keep in mind that more pixels will take longer to scan, refer to the `frame
+rate`_ discussion for ways to compensate.
+
+Focus
+^^^^^
+
+Ideally we would fix the focus at a calculated optimum distance and optimize
+the aperture selection to maximize the depth of field.  Unfortunately the APIs
+do not currently give us control over any of these settings, the best we can
+do (as of iOS 4) is continuous auto-focus mode - this mode is configured by
+the reader automatically.  It can still take the device as long as 1-2 seconds
+to find the appropriate macro focus setting, but again, there is currently no
+way to reduce this delay.
+
+Lighting and Exposure
+^^^^^^^^^^^^^^^^^^^^^
+
+An image that is too bright or overexposed can completely wash out any
+barcodes.  An image that is too dark or underexposed will not provide
+sufficient contrast for the scanner.  Low light levels also tend to produce
+noisier images, possibly because the driver uses a faster "ISO" setting to
+compensate for the lighting.
+
+The camera defaults to continuous automatic exposure and white balance.  Since
+there are no other useful values, the reader leaves these unchanged from their
+default setting.
+
+For some devices, the "torch" can be enabled to provide additional
+illumination for the camera in low-light conditions.  The reader sets the
+torch to automatic by default, so it should turn on only when needeed...
+There have been some reports that the torch turns on inappropriately, washing
+out the image.  If you find that this occurs, you should instead set the
+:member:`~ZBarReaderView::torchMode` property of the :class:`ZBarReaderView`
+to ``Off``.
+
+For scanning images from another source, you are again stuck with the
+available image quality.  If you have any control over the image source, you
+should do what you can to fix quality problems there.
+
+Noise
+^^^^^
+
+Some level of noise is filtered by the reader, but excessive noise levels
+create additional edges in the image which corrupt barcodes and increase
+scanning time (decreasing the frame rate).
+
+As mentioned with `lighting and exposure`_, noise mostly becomes a problem
+when the light-level is too low, but high-resolution images may also increase
+exposure to sensor noise.
+
+We compensate for noise by *reducing* the `resolution`_ from the sensor
+maximum.  Scaling the image down has the effect of averaging several pixels
+into one value, filtering out the high-frequency noise component.
+
+
+Frame Rate
+----------
+
+The time it takes to scan and decode an image/frame is roughly proportional to
+the number of pixels that are processed.  The number and type of enabled
+symbologies and image noise can also affect the processing time.
+
+We have several knobs available that affect the frame rate.  Most of these are
+geared toward reducing the number of image pixels that are scanned.
+
+Decrease the Resolution
+^^^^^^^^^^^^^^^^^^^^^^^
+
+Adjusting the resolution of the image is an easy way to quickly reduce the
+number of pixels.  Smaller images also mean there is less data to carry
+around, which helps performance in other ways.  For example, reducing each
+image dimension by 30% (eg, from 640x480 to 448x336) will about double the
+speed of the reader (to a point).  [FIXME verify!]
+
+Adjusting the resolution is `described above <resolution>`_.  As mentioned
+there, reducing the resolution will negatively impact the minimum feature size
+and maximum barcode size that can be scanned, but it will help filter noise.
+
+Crop the Scan Region
+^^^^^^^^^^^^^^^^^^^^
+
+It may not always be necessary for an application to scan all the way to the
+edges of the image.  By cropping the scan area, you can get most of the
+benefits of reduced resolution without sacrificing the minimum feature size.
+Cropping will also not affect image noise, but similar to decreasing the
+resolution, it does affect the maximum size barcode that can be scanned.
+
+For all cases you set the crop rectangle
+:class:`~ZBarReaderViewController::scanCrop` property.  Note that the
+rectangle provided to the controller is *normalized* across image size and
+rotation.  This means that the coordinates range from 0 to 1 and the axes will
+be arranged such that the x-axis of the crop rectangle corresponds to the
+major (longer) image axis.
+
+Your interface will typically need to indicate the cropped scan area to the
+user with visual queues.  Use the
+:class:`~ZBarReaderViewController::cameraOverlayView` to provide this.
+
+By default, the :class:`ZBarReaderView` recognizes a pinch gesture to
+digitally zoom the preview around the center of the image.  This zoom does not
+affect the resolution of the image, but it does crop the scan region to the
+visible area.  You can also disable the pinch gesture and set the
+:class:`~ZBarReaderView::zoom` programmatically.
+
+Limit the Scan Density
+^^^^^^^^^^^^^^^^^^^^^^
+
+The scanner works by making scan passes across the pixel rows and colums of
+the image.  The density of the passes is configured at the scanner as a pixel
+stride for each axis.  ``ZBAR_CFG_Y_DENSITY`` (``ZBAR_CFG_X_DENSITY``)
+controls the number of pixel rows (columns) that are skipped between
+successive horizontal (vertical) scan passes.  (Note that "density" is really
+not a good name for the configuation settings... "stride" might be more
+appropriate.)
+
+Decreasing the scan density (by increasing the stride setting) is a great way
+to limit the processing (increasing the frame rate) without sacrificing scan
+resolution - each scan pass is still made at full image resolution, there are
+just fewer passes (less redundancy).
+
+Setting the stride value to 0 completely disables scanning in that direction.
+This is very useful when reading linear codes with a visual alignment guide -
+scanning parallel to the bars is a waste of cycles which may be better applied
+to support higher resolution or increased density of scans across the symbol.
+Note that some 2-D symbologies (QR Code) require scans in both directions.
+
+Setting the stride to a very large value will generate a single scan pass
+through the center of the image.  Note that some symbologies will not be
+detected without multiple successful passes; it is usually better to combine
+this setting with cropping to generate a number of closely clustered scan
+passes in the target area.
+
+Note that the density also affects the aspect ratio and rotation that can be
+tolerated.  If you set it too large, some barcodes will become more difficult
+to read.
+
+In general, 2 to 4 is a good target for the stride setting, unless you have
+very high or low resolution images.
+
+Disable unused symbologies
+^^^^^^^^^^^^^^^^^^^^^^^^^^
+
+Limiting the symbologies to the set of interest should provide a small
+performance boost.  It also improves decode reliability - it is impossible to
+receive an incorrect or unexpected decode result from a symbology that is
+disabled.
+
+The reader does support full auto-discrimination among the supported
+symbologies, but with all of them enabled you may need to compensate elsewhere
+to get a good frame rate.
+
+For example, if you are only interested in QR codes, disable the others.  The
+robust way to do this is by disabling *all* symbologies and then reenabling
+only those you want.  This helps isolate you from encountering new symbologies
+that may be added in future versions of the library until you are ready to
+handle them::
+
+   [scanner setSymbology: 0
+            config: ZBAR_CFG_ENABLE
+            to: 0];
+   [scanner setSymbology: ZBAR_QRCODE
+            config: ZBAR_CFG_ENABLE
+            to: 1];
+
+Even if you would like your application to support multiple symbologies, you
+may consider if there is a way to limit the enabled subset based on the
+scanning context, etc...
+
+
+Examples
+--------
+
+These examples demonstrate several scenarios for scanning from the camera with
+automatic capture.  You can try them yourself using the readertest.  For each
+example, start with the default settings (by tapping the
+``ZBarReaderViewController`` class), then enable continuous mode and the
+custom overlay (by disabling
+:member:`~ZBarReaderViewController::showsZBarControls`).  You should also use
+a release build and avoid running in the debugger.
+
+Frame rates are approximate, measured on an iPhone 3GS running iOS 4.0.1 in a
+well lit room.  Two measurements are taken for each sample: the rate with the
+camera pointed at a blank white page such that it fills the frame, and the
+rate while continuously decoding the provided example.  For best results, it
+is recommended that you print the examples rather than scanning them from the
+screen.
+
+For reference, the base frame rates with default settings are 12fps for a
+blank white page, 7.5fps for this `basic EAN symbol`_ and 2.2fps for this
+`basic QR symbol`_.
+
+.. _`basic EAN symbol`:
+   http://zbar.sf.net/test/ean13/9876543210128.png
+.. _`basic QR symbol`:
+   http://chart.apis.google.com/chart?cht=qr&chs=512x512&chl=http://zbar.sf.net/iphone
+
+Long Linear Symbols
+^^^^^^^^^^^^^^^^^^^
+
+For this example, we will use a relatively `long Code 128 barcode`_.
+
+.. _`long Code 128 barcode`:
+   http://zbar.sf.net/test/code128/ALPHA.png
+
+While it should be possible to read this symbol with the default settings, you
+may notice that it is not very reliable.  You will have to stretch the symbol
+across the entire screen, and even then the default settings will only give
+you about 1.6 pixels per module, well below the ideal target of 3.  To improve
+these results, we want to maximize scanning resolution for the long image
+axis.
+
+1. Disable the default zoom/crop - zoom all the way out by hitting "Scan" and
+   pinching the preview; the frame rate immediately drops to 8fps / 4.8fps.
+
+We should compensate for this reduction in the frame rate:
+
+2. Crop the image to a long, skinny rectangle - set the
+   :member:`~ZBarReaderViewController::scanCrop` setting to
+   ``{{0, 0.3}, {1, 0.4}}``;  The frame rate jumps up to 18fps / 8.7fps.
+
+3. Disable scans across the short image axis - set the ``CFG_X_DENSITY``
+   setting to 0.  The frame rate goes all the way to 30fps / 13fps.
+
+Since we have plenty of margin with the frame rate, we can minimize the total
+decode latency by performing more scan passes through the symbol:
+
+4. Increase the scan density - set the ``CFG_Y_DENSITY`` setting to 1 (13.5fps
+   / 5fps) or 2 (24fps / 9fps).
+
+You should now be able to quickly and reliably decode long linear symbols.
+
+If have a newer device, you may also try increasing the resolution to support
+even longer symbols.  You may have to compensate elsewhere to bring the frame
+rate back to a reasonable level.
+
+High Density QR Symbols
+^^^^^^^^^^^^^^^^^^^^^^^
+
+For this example we will use a `version 29 QR Code symbol`_.
+
+.. _`version 29 QR Code symbol`:
+   http://www.qrcomic.com/images/5.png
+
+In this case we still want to maximize the resolution, but we also need to
+increase the scan density to reliably pick up the small finder patterns:
+
+1. Maximize scan density in both directions - set the ``CFG_X_DENSITY`` and
+   ``CFG_Y_DENSITY`` settings both to 1.  You should be able to scan the symbol
+   now, although the frame rate drops to 4.5fps / 1fps
+
+2. Disable the default zoom/crop - zoom all the way out by hitting "Scan" and
+   pinching the preview; the frame rate drops further to 3fps / 0.7fps
+
+We can compensate somewhat for the reduced frame rate:
+
+3. Crop the image to a square - set ``scanCrop`` to ``{{0.125, 0}, {.75, 1}}``.
+   This boosts the frame rate slightly to 3.7fps / 0.75fps.
+
+4. Disable linear symbologies - set the symbologies such that only QR Code is
+   enabled (4fps / 1fps)
+
+Even though the frame rate is still pretty bad, the QR recognition latency
+should be acceptable.
+
+If have an iPhone 4, you may also try increasing the resolution to support
+even denser QR symbols. You may have to compensate elsewhere to bring the
+frame rate back to a reasonable level.
+
+Small DataBar Symbols
+^^^^^^^^^^^^^^^^^^^^^
+
+For this example we will use a `DataBar symbol`_ printed with a small feature
+size, typical of the stickers used to tag produce.  Scale it when printing
+such that the printed dimensions are about 1cm square.  This symbol should
+scan with the default settings, but we will attempt to optimize the scan
+latency for this case.
+
+.. _`DataBar symbol`:
+   http://zbar.sf.net/test/databar/0109876543210128-so.png
+
+As well as high barcode resolution, we also want high density passes in both
+directions to minimize sensitivity to rotation:
+
+1. Maximize scan density in both directions - set the ``CFG_X_DENSITY`` and
+   ``CFG_Y_DENSITY`` settings both to 1.  The frame rate drops to 4.5fps /
+   3fps.
+
+Compensate for the reduction in frame rate by zooming in on the small symbol,
+which crops the scanned image.  Zooming also helps the user see the small
+barcode:
+
+2. Zoom all the way in - hit "Scan" and un-pinch the preview.  The frame rate
+   recovers to 11fps / 6.2fps.
+
+3. Crop the image to a square - set ``scanCrop`` to ``{{0.125, 0}, {0.75, 1}}``
+   (14fps / 7.5fps)
+
+4. Disable all symbologies except DataBar and DataBar Expanded (14.5fps / 9fps)
+
+The reader should now be very sensitive to DataBar, even when scanned at an
+angle.
diff -r 563557a923d0 iphone/doc/picker.rst
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/doc/picker.rst	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,104 @@
+Scanning a User-Selected Image
+==============================
+
+Some applications may need the full resolution offered by camera snapshots, or
+need to scan an image or document from the user's photo library.  In these
+cases you use a :class:`ZBarReaderController`.  This reader is a *subclass* of
+:class:`UIImagePickerController`, and you use it the same way.  See the
+documentation for :class:`UIImagePickerController` for more detais.
+
+1. Create the reader.
+
+   This is as simple as creating a new :class:`ZBarReaderController`::
+
+      ZBarReaderController *reader = [[ZBarReaderController alloc] init];
+
+2. Setup a delegate to receive the results.
+
+   The delegate should implement the :class:`ZBarReaderDelegate` protocol,
+   which inherits from :class:`UIImagePickerControllerDelegate`::
+
+      reader.readerDelegate = self;
+
+3. Configure the reader.
+
+   You will need to set the :member:`~ZBarReaderController::sourceType`
+   appropriately.  Aside from the properties of the reader itself, you can
+   configure the decoder via the :member:`~ZBarReaderController::scanner`
+   property::
+
+      if([ZBarReaderController isSourceTypeAvailable:
+                                   UIImagePickerControllerSourceTypeCamera])
+          reader.sourceType = UIImagePickerControllerSourceTypeCamera;
+      [reader.scanner setSymbology: ZBAR_I25
+                      config: ZBAR_CFG_ENABLE
+                      to: 0];
+
+   See :doc:`custom` and :doc:`optimizing` for more details.
+
+4. Present the reader to the user.
+
+   As the reader is a UIImagePickerController, it must be presented modally::
+
+      [self presentModalViewController: reader
+            animated: YES];
+
+5. Process the results.
+
+   The controller will call the
+   ``imagePickerController:didFinishPickingMediaWithInfo:`` method of
+   your delegate for a successful decode (NB *not* every time the user takes a
+   picture or selects an image).  The barcode data can be obtained using the
+   :c:data:`ZBarReaderControllerResults` key of the info dictionary.  This key
+   will return "something enumerable"; keep in mind that there may be multiple
+   results.  You may also retrieve the corresponding image with
+   :c:data:`UIImagePickerControllerOriginalImage` as usual::
+
+      - (void) imagePickerController: (UIImagePickerController*) reader
+       didFinishPickingMediaWithInfo: (NSDictionary*) info
+      {
+          id<NSFastEnumeration> results =
+              [info objectForKey: ZBarReaderControllerResults];
+          UIImage *image =
+              [info objectForKey: UIImagePickerControllerOriginalImage];
+          ...
+
+   The ``reader`` parameter will be the actual :class:`ZBarReaderController`
+   (again, a subclass :class:`UIImagePickerController`).
+
+   .. note::
+
+      The delegate method should dismiss the reader and return as soon as
+      possible; any processing of the results should be deferred until later,
+      otherwise the user will experience unacceptable latency between the
+      actual scan completion and the visual interface feedback.
+
+6. Dismiss the reader.
+
+   Once you have the results you should dismiss the reader::
+
+      [reader dismissModalViewControllerAnimated: YES];
+
+   .. warning::
+
+      It is very important to dismiss from the *reader* (not the presenting
+      controller) to avoid corrupting the interface.
+
+
+Handling Failure
+----------------
+
+It is always possible the user selects/takes an image that does not contain
+barcodes, or that the image quality is not sufficient for the ZBar library to
+scan successfully.
+
+In this case, and if :member:`~ZBarReaderController::showsHelpOnFail` is
+``YES``, the integrated help controller will automatically be displayed with
+reason set to ``"FAIL"``.
+
+Your delegate may also choose to implement the optional
+``readerControllerDidFailToRead:withRetry:`` method to explicitly handle
+failures.  If the ``retry`` parameter is ``NO``, you *must* dismiss the reader
+before returning, otherwise you may continue and allow the user to retry the
+operation.  Note that, if it is enabled, the integrated help will be displayed
+when this delegate method is invoked.
diff -r 563557a923d0 iphone/doc/static/style.css
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/doc/static/style.css	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,36 @@
+@import url("default.css");
+
+h1, h2, h3, h4, h5, h6 {
+    clear: both;
+}
+
+img.logo {
+    vertical-align: middle;
+}
+
+img.floatright {
+    float: right;
+    clear: both;
+    margin-left: 2em;
+    margin-right: 2em;
+}
+
+dl.docutils dt {
+    font-weight: bold;
+}
+dl.docutils dd {
+    margin-top: 1em;
+    margin-bottom: 1em;
+}
+
+table.docutils {
+    margin-left: auto;
+    margin-right: auto;
+}
+table.docutils th, table.docutils td {
+    padding: .25em .5em;
+}
+
+table.docutils.field-list {
+    margin-left: 0;
+}
diff -r 563557a923d0 iphone/doc/support.rst
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/doc/support.rst	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,19 @@
+Obtaining Support
+=================
+
+If this documentation does not address your question/problem and you need
+support, please feel free to post in our `iPhone Developers Forum`_.
+
+.. _`iPhone Developers Forum`:
+   http://sourceforge.net/projects/zbar/forums/forum/1072195
+
+When posting, please:
+
+* Check the :doc:`faq` and the rest of this documentation first.
+* Start a new thread for a new question - do not "hijack" an unrelated thread.
+* Post complete details of your problem - complete error messages as well as
+  relevant source code and images.
+* Log-in to receive email, or check back within a day or so - you will almost
+  always get a response.
+
+For the latest support information, please see http://zbar.sf.net/iphone
diff -r 563557a923d0 iphone/doc/tutorial.rst
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/doc/tutorial.rst	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,228 @@
+ZBar SDK Integration Tutorial
+=============================
+
+.. image:: ReaderSample.png
+   :alt: Screenshot of the ReaderSample app
+   :width: 414
+   :height: 770
+   :scale: 40
+   :class: floatright
+
+This tutorial will quickly get you up and running with the ZBar iPhone SDK.
+
+We will develop a very simple app that presents a button the user can tap to
+invoke the barcode reader and then displays the results.  Interface Builder
+will be used to create the interface.
+
+The completed project is also available with the distributed SDK under
+:file:`Examples/ReaderSample`.
+
+
+Create the App
+--------------
+
+1. Open Xcode; you must have version 4.5.1 or later.
+
+2. Create a new project using the "View-based Application" template.  Name the
+   project "ReaderSample".  Save it wherever you like.
+
+3. Open :file:`ReaderSampleViewController.xib`
+
+4. Drag a Round Rect Button onto the view and title it "Scan".  Customize the
+   placement and appearance as you like.
+
+5. Drag an Image View onto the view.  Size it to fill about half of the
+   remaining space.  Change the view mode to Aspect Fit.
+
+6. Drag a Text View onto the view and size it to fill the remaining space.
+   Change the default text to "No barcode scanned" or something.  De-select
+   "Editable"
+
+7. Add connections to the interface elements in the code; open
+   :file:`ReaderSampleViewController.h` and change the interface to::
+
+      @interface ReaderSampleViewController : UIViewController
+      {
+          UIImageView *resultImage;
+          UITextView *resultText;
+      }
+      @property (nonatomic, retain) IBOutlet UIImageView *resultImage;
+      @property (nonatomic, retain) IBOutlet UITextView *resultText;
+      - (IBAction) scanButtonTapped;
+      @end
+
+8. Now we can finish the interface connections - open
+   :file:`ReaderSampleViewController.xib` and make these connections:
+
+   * Connect ReaderSampleViewController ``resultImage`` outlet to the
+     ImageView.
+   * Connect ReaderSampleViewController ``resultText`` outlet to the TextView.
+   * Connect ReaderSampleViewController ``scanButtonTapped`` action to the
+     RoundedRectButton(Scan) event ``TouchUpInside``.
+
+   Consult the Xcode documentation if you need help making these connections.
+   Make sure you save the XIB once they are finished.
+
+9. Finish the implementation in :file:`ReaderSampleViewController.m`::
+
+      @synthesize resultImage, resultText;
+      
+      - (IBAction) scanButtonTapped
+      {
+          NSLog(@"TBD: scan barcode here...");
+      }
+      
+      - (void) dealloc
+      {
+          self.resultImage = nil;
+          self.resultText = nil;
+          [super dealloc];
+      }
+      
+      - (BOOL) shouldAutorotateToInterfaceOrientation: (UIInterfaceOrientation) interfaceOrientation
+      {
+          return(YES);
+      }
+
+   This stub for scanButtonTapped is temporary, we'll fix it in a minute...
+
+Although it doesn't do much yet, you should now have a working skeleton app
+that you can build and run.
+
+
+Integrate the Reader
+--------------------
+
+Now for the exciting part - let's add a barcode reader!
+
+1. If you have not done so already, download the latest SDK from
+   http://zbar.sourceforge.net/iphone
+
+2. Double-click the disk image, ZBarSDK-|version|.dmg in the Finder to open it.
+
+3. Drag the :file:`ZBarSDK` folder into your Xcode project.  Make sure that
+   the "Copy Items into destination group's folder" checkbox is checked.
+
+4. Open the target build settings and find ``Link Binary With Libraries``.
+   Click the ``+`` and add each of these (NB hold down command for multiple
+   selection):
+
+   * AVFoundation.framework
+   * CoreMedia.framework
+   * CoreVideo.framework
+   * QuartzCore.framework
+   * libiconv.dylib
+
+   .. warning::
+
+      Link order may be important for some versions of Xcode; the libraries
+      referenced above should be listed *before* :file:`libzbar.a` in the
+      link order.
+
+5. Import the SDK header.  You will usually want to prefix it, so add it to
+   :file:`ReaderSample-prefix.pch`::
+
+      // ADD: import barcode reader APIs
+      #import "ZBarSDK.h"
+
+6. Declare support for the delegate protocol in
+   :file:`ReaderSampleViewController.h`::
+
+      @interface ReaderSampleViewController : UIViewController
+          // ADD: delegate protocol
+          < ZBarReaderDelegate >
+      {
+      ...
+
+7. Re-implement scanButtonTapped to present a barcode reader when the user
+   taps the Scan button.  In :file:`ReaderSampleViewController.m`::
+
+      - (IBAction) scanButtonTapped
+      {
+          // ADD: present a barcode reader that scans from the camera feed
+          ZBarReaderViewController *reader = [[ZBarReaderViewController alloc] init];
+          reader.readerDelegate = self;
+          reader.supportedOrientationsMask = ZBarOrientationMaskAll;
+      
+          ZBarImageScanner *scanner = reader.scanner;
+          // TODO: (optional) additional reader configuration here
+      
+          // EXAMPLE: disable rarely used I2/5 to improve performance
+          [scanner setSymbology: ZBAR_I25
+                   config: ZBAR_CFG_ENABLE
+                   to: 0];
+      
+          // present and release the controller
+          [self presentModalViewController: reader
+                animated: YES];
+          [reader release];
+      }
+
+8. Finally, implement the delegate method to do something useful with the
+   results.  Still in :file:`ReaderSampleViewController.m`::
+
+      - (void) imagePickerController: (UIImagePickerController*) reader
+       didFinishPickingMediaWithInfo: (NSDictionary*) info
+      {
+          // ADD: get the decode results
+          id<NSFastEnumeration> results =
+              [info objectForKey: ZBarReaderControllerResults];
+          ZBarSymbol *symbol = nil;
+          for(symbol in results)
+              // EXAMPLE: just grab the first barcode
+              break;
+      
+          // EXAMPLE: do something useful with the barcode data
+          resultText.text = symbol.data;
+      
+          // EXAMPLE: do something useful with the barcode image
+          resultImage.image =
+              [info objectForKey: UIImagePickerControllerOriginalImage];
+      
+          // ADD: dismiss the controller (NB dismiss from the *reader*!)
+          [reader dismissModalViewControllerAnimated: YES];
+      }
+
+And that's it!
+
+
+Testing
+-------
+
+1. Save everything (don't forget to save MyAppViewController.xib).
+
+2. Build and Run the project.
+
+3. Tap the Scan button.
+
+4. Aim at barcode.
+
+5. Enjoy the sweet fruits of your minimal labor
+
+
+Where to go from here
+---------------------
+
+You can learn more about using the reader APIs to scan barcodes from
+:doc:`camera` or :doc:`picker`.  Use the :doc:`apiref` to find details about a
+particular interface.
+
+
+Troubleshooting
+---------------
+
+We take great care to ensure this tutorial is working as described.  However,
+if you do have a problem
+
+1. Make sure you followed the instructions exactly - every detail is
+   important.
+2. Start from scratch with a new project and follow the instructions
+   *exactly*.
+3. Try the ReaderSample distributed with the SDK and compare your work with
+   that.
+4. If you are unable to get things working, you may post your frustrations in
+   the project `iPhone Developers Forum`_.  Please be very specific about your
+   problem, post the complete text of any errors, etc.
+
+.. _`iPhone Developers Forum`:
+   http://sourceforge.net/projects/zbar/forums/forum/1072195
diff -r 563557a923d0 iphone/examples/EmbedReader/Default-568h@2x.png
Binary file iphone/examples/EmbedReader/Default-568h@2x.png has changed
diff -r 563557a923d0 iphone/examples/EmbedReader/EmbedReader.xcodeproj/project.pbxproj
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/examples/EmbedReader/EmbedReader.xcodeproj/project.pbxproj	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,416 @@
+// !$*UTF8*$!
+{
+	archiveVersion = 1;
+	classes = {
+	};
+	objectVersion = 46;
+	objects = {
+
+/* Begin PBXBuildFile section */
+		DC824612162B5E140010B2E6 /* Default-568h@2x.png in Resources */ = {isa = PBXBuildFile; fileRef = DC824611162B5E140010B2E6 /* Default-568h@2x.png */; };
+		DCFB4494136F7202004B3EE0 /* UIKit.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = DCFB4493136F7202004B3EE0 /* UIKit.framework */; };
+		DCFB4496136F7202004B3EE0 /* Foundation.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = DCFB4495136F7202004B3EE0 /* Foundation.framework */; };
+		DCFB4498136F7202004B3EE0 /* CoreGraphics.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = DCFB4497136F7202004B3EE0 /* CoreGraphics.framework */; };
+		DCFB449E136F7203004B3EE0 /* InfoPlist.strings in Resources */ = {isa = PBXBuildFile; fileRef = DCFB449C136F7203004B3EE0 /* InfoPlist.strings */; };
+		DCFB44A1136F7203004B3EE0 /* main.m in Sources */ = {isa = PBXBuildFile; fileRef = DCFB44A0136F7203004B3EE0 /* main.m */; };
+		DCFB44A4136F7203004B3EE0 /* EmbedReaderAppDelegate.m in Sources */ = {isa = PBXBuildFile; fileRef = DCFB44A3136F7203004B3EE0 /* EmbedReaderAppDelegate.m */; };
+		DCFB44A7136F7203004B3EE0 /* MainWindow.xib in Resources */ = {isa = PBXBuildFile; fileRef = DCFB44A5136F7203004B3EE0 /* MainWindow.xib */; };
+		DCFB44AA136F7203004B3EE0 /* EmbedReaderViewController.m in Sources */ = {isa = PBXBuildFile; fileRef = DCFB44A9136F7203004B3EE0 /* EmbedReaderViewController.m */; };
+		DCFB44AD136F7203004B3EE0 /* EmbedReaderViewController.xib in Resources */ = {isa = PBXBuildFile; fileRef = DCFB44AB136F7203004B3EE0 /* EmbedReaderViewController.xib */; };
+		DCFB44D0136F722A004B3EE0 /* libzbar.a in Frameworks */ = {isa = PBXBuildFile; fileRef = DCFB44CA136F722A004B3EE0 /* libzbar.a */; };
+		DCFB44D1136F722A004B3EE0 /* zbar-back.png in Resources */ = {isa = PBXBuildFile; fileRef = DCFB44CC136F722A004B3EE0 /* zbar-back.png */; };
+		DCFB44D2136F722A004B3EE0 /* zbar-help.html in Resources */ = {isa = PBXBuildFile; fileRef = DCFB44CD136F722A004B3EE0 /* zbar-help.html */; };
+		DCFB44D3136F722A004B3EE0 /* zbar-helpicons.png in Resources */ = {isa = PBXBuildFile; fileRef = DCFB44CE136F722A004B3EE0 /* zbar-helpicons.png */; };
+		DCFB44D4136F722A004B3EE0 /* zbar-samples.png in Resources */ = {isa = PBXBuildFile; fileRef = DCFB44CF136F722A004B3EE0 /* zbar-samples.png */; };
+		DCFB44DA136F72D3004B3EE0 /* AVFoundation.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = DCFB44D5136F72D3004B3EE0 /* AVFoundation.framework */; };
+		DCFB44DB136F72D3004B3EE0 /* CoreMedia.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = DCFB44D6136F72D3004B3EE0 /* CoreMedia.framework */; };
+		DCFB44DC136F72D3004B3EE0 /* CoreVideo.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = DCFB44D7136F72D3004B3EE0 /* CoreVideo.framework */; };
+		DCFB44DD136F72D3004B3EE0 /* libiconv.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = DCFB44D8136F72D3004B3EE0 /* libiconv.dylib */; };
+		DCFB44DE136F72D3004B3EE0 /* QuartzCore.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = DCFB44D9136F72D3004B3EE0 /* QuartzCore.framework */; };
+/* End PBXBuildFile section */
+
+/* Begin PBXFileReference section */
+		DC824611162B5E140010B2E6 /* Default-568h@2x.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; path = "Default-568h@2x.png"; sourceTree = SOURCE_ROOT; };
+		DCFB448F136F7202004B3EE0 /* EmbedReader.app */ = {isa = PBXFileReference; explicitFileType = wrapper.application; includeInIndex = 0; path = EmbedReader.app; sourceTree = BUILT_PRODUCTS_DIR; };
+		DCFB4493136F7202004B3EE0 /* UIKit.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = UIKit.framework; path = System/Library/Frameworks/UIKit.framework; sourceTree = SDKROOT; };
+		DCFB4495136F7202004B3EE0 /* Foundation.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = Foundation.framework; path = System/Library/Frameworks/Foundation.framework; sourceTree = SDKROOT; };
+		DCFB4497136F7202004B3EE0 /* CoreGraphics.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = CoreGraphics.framework; path = System/Library/Frameworks/CoreGraphics.framework; sourceTree = SDKROOT; };
+		DCFB449B136F7202004B3EE0 /* EmbedReader-Info.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist.xml; path = "EmbedReader-Info.plist"; sourceTree = "<group>"; };
+		DCFB449D136F7203004B3EE0 /* en */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = en; path = en.lproj/InfoPlist.strings; sourceTree = "<group>"; };
+		DCFB449F136F7203004B3EE0 /* EmbedReader-Prefix.pch */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = "EmbedReader-Prefix.pch"; sourceTree = "<group>"; };
+		DCFB44A0136F7203004B3EE0 /* main.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = main.m; sourceTree = "<group>"; };
+		DCFB44A2136F7203004B3EE0 /* EmbedReaderAppDelegate.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = EmbedReaderAppDelegate.h; sourceTree = "<group>"; };
+		DCFB44A3136F7203004B3EE0 /* EmbedReaderAppDelegate.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = EmbedReaderAppDelegate.m; sourceTree = "<group>"; };
+		DCFB44A6136F7203004B3EE0 /* en */ = {isa = PBXFileReference; lastKnownFileType = file.xib; name = en; path = en.lproj/MainWindow.xib; sourceTree = "<group>"; };
+		DCFB44A8136F7203004B3EE0 /* EmbedReaderViewController.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = EmbedReaderViewController.h; sourceTree = "<group>"; };
+		DCFB44A9136F7203004B3EE0 /* EmbedReaderViewController.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = EmbedReaderViewController.m; sourceTree = "<group>"; };
+		DCFB44AC136F7203004B3EE0 /* en */ = {isa = PBXFileReference; lastKnownFileType = file.xib; name = en; path = en.lproj/EmbedReaderViewController.xib; sourceTree = "<group>"; };
+		DCFB44B7136F722A004B3EE0 /* Decoder.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Decoder.h; sourceTree = "<group>"; };
+		DCFB44B8136F722A004B3EE0 /* Exception.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Exception.h; sourceTree = "<group>"; };
+		DCFB44B9136F722A004B3EE0 /* Image.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Image.h; sourceTree = "<group>"; };
+		DCFB44BA136F722A004B3EE0 /* ImageScanner.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ImageScanner.h; sourceTree = "<group>"; };
+		DCFB44BB136F722A004B3EE0 /* Processor.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Processor.h; sourceTree = "<group>"; };
+		DCFB44BC136F722A004B3EE0 /* Scanner.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Scanner.h; sourceTree = "<group>"; };
+		DCFB44BD136F722A004B3EE0 /* Symbol.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Symbol.h; sourceTree = "<group>"; };
+		DCFB44BE136F722A004B3EE0 /* Video.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Video.h; sourceTree = "<group>"; };
+		DCFB44BF136F722A004B3EE0 /* Window.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Window.h; sourceTree = "<group>"; };
+		DCFB44C0136F722A004B3EE0 /* zbar.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = zbar.h; sourceTree = "<group>"; };
+		DCFB44C1136F722A004B3EE0 /* ZBarCaptureReader.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ZBarCaptureReader.h; sourceTree = "<group>"; };
+		DCFB44C2136F722A004B3EE0 /* ZBarHelpController.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ZBarHelpController.h; sourceTree = "<group>"; };
+		DCFB44C3136F722A004B3EE0 /* ZBarImage.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ZBarImage.h; sourceTree = "<group>"; };
+		DCFB44C4136F722A004B3EE0 /* ZBarImageScanner.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ZBarImageScanner.h; sourceTree = "<group>"; };
+		DCFB44C5136F722A004B3EE0 /* ZBarReaderController.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ZBarReaderController.h; sourceTree = "<group>"; };
+		DCFB44C6136F722A004B3EE0 /* ZBarReaderView.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ZBarReaderView.h; sourceTree = "<group>"; };
+		DCFB44C7136F722A004B3EE0 /* ZBarReaderViewController.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ZBarReaderViewController.h; sourceTree = "<group>"; };
+		DCFB44C8136F722A004B3EE0 /* ZBarSDK.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ZBarSDK.h; sourceTree = "<group>"; };
+		DCFB44C9136F722A004B3EE0 /* ZBarSymbol.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ZBarSymbol.h; sourceTree = "<group>"; };
+		DCFB44CA136F722A004B3EE0 /* libzbar.a */ = {isa = PBXFileReference; lastKnownFileType = archive.ar; path = libzbar.a; sourceTree = "<group>"; };
+		DCFB44CC136F722A004B3EE0 /* zbar-back.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; path = "zbar-back.png"; sourceTree = "<group>"; };
+		DCFB44CD136F722A004B3EE0 /* zbar-help.html */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.html; path = "zbar-help.html"; sourceTree = "<group>"; };
+		DCFB44CE136F722A004B3EE0 /* zbar-helpicons.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; path = "zbar-helpicons.png"; sourceTree = "<group>"; };
+		DCFB44CF136F722A004B3EE0 /* zbar-samples.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; path = "zbar-samples.png"; sourceTree = "<group>"; };
+		DCFB44D5136F72D3004B3EE0 /* AVFoundation.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = AVFoundation.framework; path = System/Library/Frameworks/AVFoundation.framework; sourceTree = SDKROOT; };
+		DCFB44D6136F72D3004B3EE0 /* CoreMedia.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = CoreMedia.framework; path = System/Library/Frameworks/CoreMedia.framework; sourceTree = SDKROOT; };
+		DCFB44D7136F72D3004B3EE0 /* CoreVideo.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = CoreVideo.framework; path = System/Library/Frameworks/CoreVideo.framework; sourceTree = SDKROOT; };
+		DCFB44D8136F72D3004B3EE0 /* libiconv.dylib */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.dylib"; name = libiconv.dylib; path = usr/lib/libiconv.dylib; sourceTree = SDKROOT; };
+		DCFB44D9136F72D3004B3EE0 /* QuartzCore.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = QuartzCore.framework; path = System/Library/Frameworks/QuartzCore.framework; sourceTree = SDKROOT; };
+/* End PBXFileReference section */
+
+/* Begin PBXFrameworksBuildPhase section */
+		DCFB448C136F7202004B3EE0 /* Frameworks */ = {
+			isa = PBXFrameworksBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				DCFB4494136F7202004B3EE0 /* UIKit.framework in Frameworks */,
+				DCFB4496136F7202004B3EE0 /* Foundation.framework in Frameworks */,
+				DCFB4498136F7202004B3EE0 /* CoreGraphics.framework in Frameworks */,
+				DCFB44DE136F72D3004B3EE0 /* QuartzCore.framework in Frameworks */,
+				DCFB44DB136F72D3004B3EE0 /* CoreMedia.framework in Frameworks */,
+				DCFB44DC136F72D3004B3EE0 /* CoreVideo.framework in Frameworks */,
+				DCFB44DA136F72D3004B3EE0 /* AVFoundation.framework in Frameworks */,
+				DCFB44DD136F72D3004B3EE0 /* libiconv.dylib in Frameworks */,
+				DCFB44D0136F722A004B3EE0 /* libzbar.a in Frameworks */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+/* End PBXFrameworksBuildPhase section */
+
+/* Begin PBXGroup section */
+		DCFB4484136F7202004B3EE0 = {
+			isa = PBXGroup;
+			children = (
+				DCFB4499136F7202004B3EE0 /* EmbedReader */,
+				DCFB44B3136F722A004B3EE0 /* ZBarSDK */,
+				DCFB4492136F7202004B3EE0 /* Frameworks */,
+				DCFB4490136F7202004B3EE0 /* Products */,
+			);
+			sourceTree = "<group>";
+		};
+		DCFB4490136F7202004B3EE0 /* Products */ = {
+			isa = PBXGroup;
+			children = (
+				DCFB448F136F7202004B3EE0 /* EmbedReader.app */,
+			);
+			name = Products;
+			sourceTree = "<group>";
+		};
+		DCFB4492136F7202004B3EE0 /* Frameworks */ = {
+			isa = PBXGroup;
+			children = (
+				DCFB4493136F7202004B3EE0 /* UIKit.framework */,
+				DCFB4495136F7202004B3EE0 /* Foundation.framework */,
+				DCFB4497136F7202004B3EE0 /* CoreGraphics.framework */,
+				DCFB44D9136F72D3004B3EE0 /* QuartzCore.framework */,
+				DCFB44D6136F72D3004B3EE0 /* CoreMedia.framework */,
+				DCFB44D7136F72D3004B3EE0 /* CoreVideo.framework */,
+				DCFB44D5136F72D3004B3EE0 /* AVFoundation.framework */,
+				DCFB44D8136F72D3004B3EE0 /* libiconv.dylib */,
+			);
+			name = Frameworks;
+			sourceTree = "<group>";
+		};
+		DCFB4499136F7202004B3EE0 /* EmbedReader */ = {
+			isa = PBXGroup;
+			children = (
+				DCFB44A2136F7203004B3EE0 /* EmbedReaderAppDelegate.h */,
+				DCFB44A3136F7203004B3EE0 /* EmbedReaderAppDelegate.m */,
+				DCFB44A5136F7203004B3EE0 /* MainWindow.xib */,
+				DCFB44A8136F7203004B3EE0 /* EmbedReaderViewController.h */,
+				DCFB44A9136F7203004B3EE0 /* EmbedReaderViewController.m */,
+				DCFB44AB136F7203004B3EE0 /* EmbedReaderViewController.xib */,
+				DCFB449A136F7202004B3EE0 /* Supporting Files */,
+			);
+			path = EmbedReader;
+			sourceTree = "<group>";
+		};
+		DCFB449A136F7202004B3EE0 /* Supporting Files */ = {
+			isa = PBXGroup;
+			children = (
+				DCFB449B136F7202004B3EE0 /* EmbedReader-Info.plist */,
+				DCFB449C136F7203004B3EE0 /* InfoPlist.strings */,
+				DC824611162B5E140010B2E6 /* Default-568h@2x.png */,
+				DCFB449F136F7203004B3EE0 /* EmbedReader-Prefix.pch */,
+				DCFB44A0136F7203004B3EE0 /* main.m */,
+			);
+			name = "Supporting Files";
+			sourceTree = "<group>";
+		};
+		DCFB44B3136F722A004B3EE0 /* ZBarSDK */ = {
+			isa = PBXGroup;
+			children = (
+				DCFB44B4136F722A004B3EE0 /* Headers */,
+				DCFB44CA136F722A004B3EE0 /* libzbar.a */,
+				DCFB44CB136F722A004B3EE0 /* Resources */,
+			);
+			path = ZBarSDK;
+			sourceTree = "<group>";
+		};
+		DCFB44B4136F722A004B3EE0 /* Headers */ = {
+			isa = PBXGroup;
+			children = (
+				DCFB44B5136F722A004B3EE0 /* ZBarSDK */,
+			);
+			path = Headers;
+			sourceTree = "<group>";
+		};
+		DCFB44B5136F722A004B3EE0 /* ZBarSDK */ = {
+			isa = PBXGroup;
+			children = (
+				DCFB44B6136F722A004B3EE0 /* zbar */,
+				DCFB44C0136F722A004B3EE0 /* zbar.h */,
+				DCFB44C1136F722A004B3EE0 /* ZBarCaptureReader.h */,
+				DCFB44C2136F722A004B3EE0 /* ZBarHelpController.h */,
+				DCFB44C3136F722A004B3EE0 /* ZBarImage.h */,
+				DCFB44C4136F722A004B3EE0 /* ZBarImageScanner.h */,
+				DCFB44C5136F722A004B3EE0 /* ZBarReaderController.h */,
+				DCFB44C6136F722A004B3EE0 /* ZBarReaderView.h */,
+				DCFB44C7136F722A004B3EE0 /* ZBarReaderViewController.h */,
+				DCFB44C8136F722A004B3EE0 /* ZBarSDK.h */,
+				DCFB44C9136F722A004B3EE0 /* ZBarSymbol.h */,
+			);
+			path = ZBarSDK;
+			sourceTree = "<group>";
+		};
+		DCFB44B6136F722A004B3EE0 /* zbar */ = {
+			isa = PBXGroup;
+			children = (
+				DCFB44B7136F722A004B3EE0 /* Decoder.h */,
+				DCFB44B8136F722A004B3EE0 /* Exception.h */,
+				DCFB44B9136F722A004B3EE0 /* Image.h */,
+				DCFB44BA136F722A004B3EE0 /* ImageScanner.h */,
+				DCFB44BB136F722A004B3EE0 /* Processor.h */,
+				DCFB44BC136F722A004B3EE0 /* Scanner.h */,
+				DCFB44BD136F722A004B3EE0 /* Symbol.h */,
+				DCFB44BE136F722A004B3EE0 /* Video.h */,
+				DCFB44BF136F722A004B3EE0 /* Window.h */,
+			);
+			path = zbar;
+			sourceTree = "<group>";
+		};
+		DCFB44CB136F722A004B3EE0 /* Resources */ = {
+			isa = PBXGroup;
+			children = (
+				DCFB44CC136F722A004B3EE0 /* zbar-back.png */,
+				DCFB44CD136F722A004B3EE0 /* zbar-help.html */,
+				DCFB44CE136F722A004B3EE0 /* zbar-helpicons.png */,
+				DCFB44CF136F722A004B3EE0 /* zbar-samples.png */,
+			);
+			path = Resources;
+			sourceTree = "<group>";
+		};
+/* End PBXGroup section */
+
+/* Begin PBXNativeTarget section */
+		DCFB448E136F7202004B3EE0 /* EmbedReader */ = {
+			isa = PBXNativeTarget;
+			buildConfigurationList = DCFB44B0136F7203004B3EE0 /* Build configuration list for PBXNativeTarget "EmbedReader" */;
+			buildPhases = (
+				DCFB448B136F7202004B3EE0 /* Sources */,
+				DCFB448C136F7202004B3EE0 /* Frameworks */,
+				DCFB448D136F7202004B3EE0 /* Resources */,
+			);
+			buildRules = (
+			);
+			dependencies = (
+			);
+			name = EmbedReader;
+			productName = EmbedReader;
+			productReference = DCFB448F136F7202004B3EE0 /* EmbedReader.app */;
+			productType = "com.apple.product-type.application";
+		};
+/* End PBXNativeTarget section */
+
+/* Begin PBXProject section */
+		DCFB4486136F7202004B3EE0 /* Project object */ = {
+			isa = PBXProject;
+			buildConfigurationList = DCFB4489136F7202004B3EE0 /* Build configuration list for PBXProject "EmbedReader" */;
+			compatibilityVersion = "Xcode 3.2";
+			developmentRegion = English;
+			hasScannedForEncodings = 0;
+			knownRegions = (
+				en,
+			);
+			mainGroup = DCFB4484136F7202004B3EE0;
+			productRefGroup = DCFB4490136F7202004B3EE0 /* Products */;
+			projectDirPath = "";
+			projectRoot = "";
+			targets = (
+				DCFB448E136F7202004B3EE0 /* EmbedReader */,
+			);
+		};
+/* End PBXProject section */
+
+/* Begin PBXResourcesBuildPhase section */
+		DCFB448D136F7202004B3EE0 /* Resources */ = {
+			isa = PBXResourcesBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				DCFB449E136F7203004B3EE0 /* InfoPlist.strings in Resources */,
+				DCFB44A7136F7203004B3EE0 /* MainWindow.xib in Resources */,
+				DCFB44AD136F7203004B3EE0 /* EmbedReaderViewController.xib in Resources */,
+				DCFB44D1136F722A004B3EE0 /* zbar-back.png in Resources */,
+				DCFB44D2136F722A004B3EE0 /* zbar-help.html in Resources */,
+				DCFB44D3136F722A004B3EE0 /* zbar-helpicons.png in Resources */,
+				DCFB44D4136F722A004B3EE0 /* zbar-samples.png in Resources */,
+				DC824612162B5E140010B2E6 /* Default-568h@2x.png in Resources */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+/* End PBXResourcesBuildPhase section */
+
+/* Begin PBXSourcesBuildPhase section */
+		DCFB448B136F7202004B3EE0 /* Sources */ = {
+			isa = PBXSourcesBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				DCFB44A1136F7203004B3EE0 /* main.m in Sources */,
+				DCFB44A4136F7203004B3EE0 /* EmbedReaderAppDelegate.m in Sources */,
+				DCFB44AA136F7203004B3EE0 /* EmbedReaderViewController.m in Sources */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+/* End PBXSourcesBuildPhase section */
+
+/* Begin PBXVariantGroup section */
+		DCFB449C136F7203004B3EE0 /* InfoPlist.strings */ = {
+			isa = PBXVariantGroup;
+			children = (
+				DCFB449D136F7203004B3EE0 /* en */,
+			);
+			name = InfoPlist.strings;
+			sourceTree = "<group>";
+		};
+		DCFB44A5136F7203004B3EE0 /* MainWindow.xib */ = {
+			isa = PBXVariantGroup;
+			children = (
+				DCFB44A6136F7203004B3EE0 /* en */,
+			);
+			name = MainWindow.xib;
+			sourceTree = "<group>";
+		};
+		DCFB44AB136F7203004B3EE0 /* EmbedReaderViewController.xib */ = {
+			isa = PBXVariantGroup;
+			children = (
+				DCFB44AC136F7203004B3EE0 /* en */,
+			);
+			name = EmbedReaderViewController.xib;
+			sourceTree = "<group>";
+		};
+/* End PBXVariantGroup section */
+
+/* Begin XCBuildConfiguration section */
+		DCFB44AE136F7203004B3EE0 /* Debug */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				ARCHS = "$(ARCHS_STANDARD_32_BIT)";
+				"CODE_SIGN_IDENTITY[sdk=iphoneos*]" = "iPhone Developer";
+				GCC_C_LANGUAGE_STANDARD = gnu99;
+				GCC_OPTIMIZATION_LEVEL = 0;
+				GCC_PREPROCESSOR_DEFINITIONS = DEBUG;
+				GCC_SYMBOLS_PRIVATE_EXTERN = NO;
+				GCC_VERSION = com.apple.compilers.llvmgcc42;
+				GCC_WARN_ABOUT_RETURN_TYPE = YES;
+				GCC_WARN_UNUSED_VARIABLE = YES;
+				IPHONEOS_DEPLOYMENT_TARGET = 4.0;
+				SDKROOT = iphoneos;
+			};
+			name = Debug;
+		};
+		DCFB44AF136F7203004B3EE0 /* Release */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				ARCHS = "$(ARCHS_STANDARD_32_BIT)";
+				"CODE_SIGN_IDENTITY[sdk=iphoneos*]" = "iPhone Developer";
+				GCC_C_LANGUAGE_STANDARD = gnu99;
+				GCC_VERSION = com.apple.compilers.llvmgcc42;
+				GCC_WARN_ABOUT_RETURN_TYPE = YES;
+				GCC_WARN_UNUSED_VARIABLE = YES;
+				IPHONEOS_DEPLOYMENT_TARGET = 4.0;
+				OTHER_CFLAGS = "-DNS_BLOCK_ASSERTIONS=1";
+				SDKROOT = iphoneos;
+			};
+			name = Release;
+		};
+		DCFB44B1136F7203004B3EE0 /* Debug */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				ALWAYS_SEARCH_USER_PATHS = NO;
+				COPY_PHASE_STRIP = NO;
+				GCC_DYNAMIC_NO_PIC = NO;
+				GCC_PRECOMPILE_PREFIX_HEADER = YES;
+				GCC_PREFIX_HEADER = "EmbedReader/EmbedReader-Prefix.pch";
+				INFOPLIST_FILE = "EmbedReader/EmbedReader-Info.plist";
+				LIBRARY_SEARCH_PATHS = (
+					"$(inherited)",
+					"\"$(SRCROOT)/ZBarSDK\"",
+				);
+				PRODUCT_NAME = "$(TARGET_NAME)";
+				TARGETED_DEVICE_FAMILY = "1,2";
+				WRAPPER_EXTENSION = app;
+			};
+			name = Debug;
+		};
+		DCFB44B2136F7203004B3EE0 /* Release */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				ALWAYS_SEARCH_USER_PATHS = NO;
+				COPY_PHASE_STRIP = YES;
+				GCC_PRECOMPILE_PREFIX_HEADER = YES;
+				GCC_PREFIX_HEADER = "EmbedReader/EmbedReader-Prefix.pch";
+				INFOPLIST_FILE = "EmbedReader/EmbedReader-Info.plist";
+				LIBRARY_SEARCH_PATHS = (
+					"$(inherited)",
+					"\"$(SRCROOT)/ZBarSDK\"",
+				);
+				PRODUCT_NAME = "$(TARGET_NAME)";
+				TARGETED_DEVICE_FAMILY = "1,2";
+				VALIDATE_PRODUCT = YES;
+				WRAPPER_EXTENSION = app;
+			};
+			name = Release;
+		};
+/* End XCBuildConfiguration section */
+
+/* Begin XCConfigurationList section */
+		DCFB4489136F7202004B3EE0 /* Build configuration list for PBXProject "EmbedReader" */ = {
+			isa = XCConfigurationList;
+			buildConfigurations = (
+				DCFB44AE136F7203004B3EE0 /* Debug */,
+				DCFB44AF136F7203004B3EE0 /* Release */,
+			);
+			defaultConfigurationIsVisible = 0;
+			defaultConfigurationName = Release;
+		};
+		DCFB44B0136F7203004B3EE0 /* Build configuration list for PBXNativeTarget "EmbedReader" */ = {
+			isa = XCConfigurationList;
+			buildConfigurations = (
+				DCFB44B1136F7203004B3EE0 /* Debug */,
+				DCFB44B2136F7203004B3EE0 /* Release */,
+			);
+			defaultConfigurationIsVisible = 0;
+			defaultConfigurationName = Release;
+		};
+/* End XCConfigurationList section */
+	};
+	rootObject = DCFB4486136F7202004B3EE0 /* Project object */;
+}
diff -r 563557a923d0 iphone/examples/EmbedReader/EmbedReader.xcodeproj/xcshareddata/xcschemes/EmbedReader.xcscheme
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/examples/EmbedReader/EmbedReader.xcodeproj/xcshareddata/xcschemes/EmbedReader.xcscheme	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,76 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<Scheme
+   version = "1.3">
+   <BuildAction
+      parallelizeBuildables = "YES"
+      buildImplicitDependencies = "YES">
+      <BuildActionEntries>
+         <BuildActionEntry
+            buildForTesting = "YES"
+            buildForRunning = "YES"
+            buildForProfiling = "YES"
+            buildForArchiving = "YES"
+            buildForAnalyzing = "YES">
+            <BuildableReference
+               BuildableIdentifier = "primary"
+               BlueprintIdentifier = "DCFB448E136F7202004B3EE0"
+               BuildableName = "EmbedReader.app"
+               BlueprintName = "EmbedReader"
+               ReferencedContainer = "container:EmbedReader.xcodeproj">
+            </BuildableReference>
+         </BuildActionEntry>
+      </BuildActionEntries>
+   </BuildAction>
+   <TestAction
+      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.GDB"
+      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.GDB"
+      shouldUseLaunchSchemeArgsEnv = "YES"
+      buildConfiguration = "Debug">
+      <Testables>
+      </Testables>
+   </TestAction>
+   <LaunchAction
+      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.GDB"
+      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.GDB"
+      displayScaleIsEnabled = "NO"
+      displayScale = "1.00"
+      launchStyle = "0"
+      useCustomWorkingDirectory = "NO"
+      buildConfiguration = "Debug">
+      <BuildableProductRunnable>
+         <BuildableReference
+            BuildableIdentifier = "primary"
+            BlueprintIdentifier = "DCFB448E136F7202004B3EE0"
+            BuildableName = "EmbedReader.app"
+            BlueprintName = "EmbedReader"
+            ReferencedContainer = "container:EmbedReader.xcodeproj">
+         </BuildableReference>
+      </BuildableProductRunnable>
+      <AdditionalOptions>
+      </AdditionalOptions>
+   </LaunchAction>
+   <ProfileAction
+      displayScaleIsEnabled = "NO"
+      displayScale = "1.00"
+      shouldUseLaunchSchemeArgsEnv = "YES"
+      savedToolIdentifier = ""
+      useCustomWorkingDirectory = "NO"
+      buildConfiguration = "Release">
+      <BuildableProductRunnable>
+         <BuildableReference
+            BuildableIdentifier = "primary"
+            BlueprintIdentifier = "DCFB448E136F7202004B3EE0"
+            BuildableName = "EmbedReader.app"
+            BlueprintName = "EmbedReader"
+            ReferencedContainer = "container:EmbedReader.xcodeproj">
+         </BuildableReference>
+      </BuildableProductRunnable>
+   </ProfileAction>
+   <AnalyzeAction
+      buildConfiguration = "Debug">
+   </AnalyzeAction>
+   <ArchiveAction
+      buildConfiguration = "Release"
+      revealArchiveInOrganizer = "YES">
+   </ArchiveAction>
+</Scheme>
diff -r 563557a923d0 iphone/examples/EmbedReader/EmbedReader/EmbedReader-Info.plist
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/examples/EmbedReader/EmbedReader/EmbedReader-Info.plist	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,39 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
+<plist version="1.0">
+<dict>
+	<key>CFBundleDevelopmentRegion</key>
+	<string>en</string>
+	<key>CFBundleDisplayName</key>
+	<string>${PRODUCT_NAME}</string>
+	<key>CFBundleExecutable</key>
+	<string>${EXECUTABLE_NAME}</string>
+	<key>CFBundleIconFile</key>
+	<string></string>
+	<key>CFBundleIdentifier</key>
+	<string>net.sourceforge.zbar.${PRODUCT_NAME:rfc1034identifier}</string>
+	<key>CFBundleInfoDictionaryVersion</key>
+	<string>6.0</string>
+	<key>CFBundleName</key>
+	<string>${PRODUCT_NAME}</string>
+	<key>CFBundlePackageType</key>
+	<string>APPL</string>
+	<key>CFBundleShortVersionString</key>
+	<string>1.0</string>
+	<key>CFBundleSignature</key>
+	<string>????</string>
+	<key>CFBundleVersion</key>
+	<string>1.0</string>
+	<key>LSRequiresIPhoneOS</key>
+	<true/>
+	<key>NSMainNibFile</key>
+	<string>MainWindow</string>
+	<key>UISupportedInterfaceOrientations</key>
+	<array>
+		<string>UIInterfaceOrientationPortrait</string>
+		<string>UIInterfaceOrientationLandscapeLeft</string>
+		<string>UIInterfaceOrientationLandscapeRight</string>
+		<string>UIInterfaceOrientationPortraitUpsideDown</string>
+	</array>
+</dict>
+</plist>
diff -r 563557a923d0 iphone/examples/EmbedReader/EmbedReader/EmbedReader-Prefix.pch
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/examples/EmbedReader/EmbedReader/EmbedReader-Prefix.pch	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,11 @@
+#import <Availability.h>
+
+#ifndef __IPHONE_3_0
+#warning "This project uses features only available in iPhone SDK 3.0 and later."
+#endif
+
+#ifdef __OBJC__
+# import <UIKit/UIKit.h>
+# import <Foundation/Foundation.h>
+# import "ZBarSDK.h"
+#endif
diff -r 563557a923d0 iphone/examples/EmbedReader/EmbedReader/EmbedReaderAppDelegate.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/examples/EmbedReader/EmbedReader/EmbedReaderAppDelegate.h	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,21 @@
+//
+//  EmbedReaderAppDelegate.h
+//  EmbedReader
+//
+//  Created by spadix on 5/2/11.
+//
+
+#import <UIKit/UIKit.h>
+
+@class EmbedReaderViewController;
+
+@interface EmbedReaderAppDelegate
+    : NSObject
+    < UIApplicationDelegate >
+{
+}
+
+@property (nonatomic, retain) IBOutlet UIWindow *window;
+@property (nonatomic, retain) IBOutlet EmbedReaderViewController *viewController;
+
+@end
diff -r 563557a923d0 iphone/examples/EmbedReader/EmbedReader/EmbedReaderAppDelegate.m
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/examples/EmbedReader/EmbedReader/EmbedReaderAppDelegate.m	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,34 @@
+//
+//  EmbedReaderAppDelegate.m
+//  EmbedReader
+//
+//  Created by spadix on 5/2/11.
+//
+
+#import "EmbedReaderAppDelegate.h"
+#import "EmbedReaderViewController.h"
+
+@implementation EmbedReaderAppDelegate
+@synthesize window=_window;
+@synthesize viewController=_viewController;
+
+- (BOOL)            application: (UIApplication*) application
+  didFinishLaunchingWithOptions: (NSDictionary*) launchOptions
+{
+    self.window.rootViewController = self.viewController;
+    [self.window makeKeyAndVisible];
+
+    // force view class to load so it may be referenced directly from NIB
+    [ZBarReaderView class];
+
+    return(YES);
+}
+
+- (void) dealloc
+{
+    [_window release];
+    [_viewController release];
+    [super dealloc];
+}
+
+@end
diff -r 563557a923d0 iphone/examples/EmbedReader/EmbedReader/EmbedReaderViewController.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/examples/EmbedReader/EmbedReader/EmbedReaderViewController.h	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,22 @@
+//
+//  EmbedReaderViewController.h
+//  EmbedReader
+//
+//  Created by spadix on 5/2/11.
+//
+
+#import <UIKit/UIKit.h>
+
+@interface EmbedReaderViewController
+    : UIViewController
+    < ZBarReaderViewDelegate >
+{
+    ZBarReaderView *readerView;
+    UITextView *resultText;
+    ZBarCameraSimulator *cameraSim;
+}
+
+@property (nonatomic, retain) IBOutlet ZBarReaderView *readerView;
+@property (nonatomic, retain) IBOutlet UITextView *resultText;
+
+@end
diff -r 563557a923d0 iphone/examples/EmbedReader/EmbedReader/EmbedReaderViewController.m
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/examples/EmbedReader/EmbedReader/EmbedReaderViewController.m	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,101 @@
+//
+//  EmbedReaderViewController.m
+//  EmbedReader
+//
+//  Created by spadix on 5/2/11.
+//
+
+#import "EmbedReaderViewController.h"
+
+@implementation EmbedReaderViewController
+
+@synthesize readerView, resultText;
+
+- (void) cleanup
+{
+    [cameraSim release];
+    cameraSim = nil;
+    readerView.readerDelegate = nil;
+    [readerView release];
+    readerView = nil;
+    [resultText release];
+    resultText = nil;
+}
+
+- (void) dealloc
+{
+    [self cleanup];
+    [super dealloc];
+}
+
+- (void) viewDidLoad
+{
+    [super viewDidLoad];
+
+    // the delegate receives decode results
+    readerView.readerDelegate = self;
+
+    // ensure initial camera orientation is correctly set
+    UIApplication *app = [UIApplication sharedApplication];
+    [readerView willRotateToInterfaceOrientation: app.statusBarOrientation
+                                        duration: 0];
+
+    // you can use this to support the simulator
+    if(TARGET_IPHONE_SIMULATOR) {
+        cameraSim = [[ZBarCameraSimulator alloc]
+                        initWithViewController: self];
+        cameraSim.readerView = readerView;
+    }
+}
+
+- (void) viewDidUnload
+{
+    [self cleanup];
+    [super viewDidUnload];
+}
+
+- (BOOL) shouldAutorotateToInterfaceOrientation: (UIInterfaceOrientation) orient
+{
+    // auto-rotation is supported
+    return(YES);
+}
+
+- (void) willRotateToInterfaceOrientation: (UIInterfaceOrientation) orient
+                                 duration: (NSTimeInterval) duration
+{
+    // compensate for view rotation so camera preview is not rotated
+    [readerView willRotateToInterfaceOrientation: orient
+                                        duration: duration];
+}
+
+- (void) willAnimateRotationToInterfaceOrientation: (UIInterfaceOrientation) orient
+                                          duration: (NSTimeInterval) duration
+{
+    // perform rotation in animation loop so camera preview does not move
+    // wrt device orientation
+    [readerView setNeedsLayout];
+}
+
+- (void) viewDidAppear: (BOOL) animated
+{
+    // run the reader when the view is visible
+    [readerView start];
+}
+
+- (void) viewWillDisappear: (BOOL) animated
+{
+    [readerView stop];
+}
+
+- (void) readerView: (ZBarReaderView*) view
+     didReadSymbols: (ZBarSymbolSet*) syms
+          fromImage: (UIImage*) img
+{
+    // do something useful with results
+    for(ZBarSymbol *sym in syms) {
+        resultText.text = sym.data;
+        break;
+    }
+}
+
+@end
diff -r 563557a923d0 iphone/examples/EmbedReader/EmbedReader/en.lproj/EmbedReaderViewController.xib
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/examples/EmbedReader/EmbedReader/en.lproj/EmbedReaderViewController.xib	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,336 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<archive type="com.apple.InterfaceBuilder3.CocoaTouch.XIB" version="7.10">
+	<data>
+		<int key="IBDocument.SystemTarget">1056</int>
+		<string key="IBDocument.SystemVersion">10J869</string>
+		<string key="IBDocument.InterfaceBuilderVersion">1306</string>
+		<string key="IBDocument.AppKitVersion">1038.35</string>
+		<string key="IBDocument.HIToolboxVersion">461.00</string>
+		<object class="NSMutableDictionary" key="IBDocument.PluginVersions">
+			<string key="NS.key.0">com.apple.InterfaceBuilder.IBCocoaTouchPlugin</string>
+			<string key="NS.object.0">301</string>
+		</object>
+		<object class="NSArray" key="IBDocument.IntegratedClassDependencies">
+			<bool key="EncodedWithXMLCoder">YES</bool>
+			<string>IBUINavigationItem</string>
+			<string>IBUIToolbar</string>
+			<string>IBUITextView</string>
+			<string>IBUIView</string>
+			<string>IBUINavigationBar</string>
+			<string>IBProxyObject</string>
+		</object>
+		<object class="NSArray" key="IBDocument.PluginDependencies">
+			<bool key="EncodedWithXMLCoder">YES</bool>
+			<string>com.apple.InterfaceBuilder.IBCocoaTouchPlugin</string>
+		</object>
+		<object class="NSMutableDictionary" key="IBDocument.Metadata">
+			<bool key="EncodedWithXMLCoder">YES</bool>
+			<object class="NSArray" key="dict.sortedKeys" id="0">
+				<bool key="EncodedWithXMLCoder">YES</bool>
+			</object>
+			<reference key="dict.values" ref="0"/>
+		</object>
+		<object class="NSMutableArray" key="IBDocument.RootObjects" id="1000">
+			<bool key="EncodedWithXMLCoder">YES</bool>
+			<object class="IBProxyObject" id="372490531">
+				<string key="IBProxiedObjectIdentifier">IBFilesOwner</string>
+				<string key="targetRuntimeIdentifier">IBCocoaTouchFramework</string>
+			</object>
+			<object class="IBProxyObject" id="843779117">
+				<string key="IBProxiedObjectIdentifier">IBFirstResponder</string>
+				<string key="targetRuntimeIdentifier">IBCocoaTouchFramework</string>
+			</object>
+			<object class="IBUIView" id="774585933">
+				<reference key="NSNextResponder"/>
+				<int key="NSvFlags">274</int>
+				<object class="NSMutableArray" key="NSSubviews">
+					<bool key="EncodedWithXMLCoder">YES</bool>
+					<object class="IBUIView" id="461611788">
+						<reference key="NSNextResponder" ref="774585933"/>
+						<int key="NSvFlags">306</int>
+						<string key="NSFrame">{{8, 52}, {304, 228}}</string>
+						<reference key="NSSuperview" ref="774585933"/>
+						<reference key="NSWindow"/>
+						<reference key="NSNextKeyView" ref="971445553"/>
+						<object class="NSColor" key="IBUIBackgroundColor">
+							<int key="NSColorSpace">3</int>
+							<bytes key="NSWhite">MAA</bytes>
+						</object>
+						<bool key="IBUIClipsSubviews">YES</bool>
+						<bool key="IBUIMultipleTouchEnabled">YES</bool>
+						<string key="targetRuntimeIdentifier">IBCocoaTouchFramework</string>
+					</object>
+					<object class="IBUINavigationBar" id="583656854">
+						<reference key="NSNextResponder" ref="774585933"/>
+						<int key="NSvFlags">290</int>
+						<string key="NSFrameSize">{320, 44}</string>
+						<reference key="NSSuperview" ref="774585933"/>
+						<reference key="NSWindow"/>
+						<reference key="NSNextKeyView" ref="461611788"/>
+						<string key="targetRuntimeIdentifier">IBCocoaTouchFramework</string>
+						<object class="NSArray" key="IBUIItems">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<object class="IBUINavigationItem" id="889758731">
+								<reference key="IBUINavigationBar" ref="583656854"/>
+								<string key="IBUITitle">EmbedReader</string>
+								<string key="targetRuntimeIdentifier">IBCocoaTouchFramework</string>
+							</object>
+						</object>
+					</object>
+					<object class="IBUIToolbar" id="89745263">
+						<reference key="NSNextResponder" ref="774585933"/>
+						<int key="NSvFlags">266</int>
+						<string key="NSFrame">{{0, 416}, {320, 44}}</string>
+						<reference key="NSSuperview" ref="774585933"/>
+						<reference key="NSWindow"/>
+						<reference key="NSNextKeyView"/>
+						<bool key="IBUIOpaque">NO</bool>
+						<bool key="IBUIClearsContextBeforeDrawing">NO</bool>
+						<string key="targetRuntimeIdentifier">IBCocoaTouchFramework</string>
+						<object class="NSMutableArray" key="IBUIItems">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+						</object>
+					</object>
+					<object class="IBUITextView" id="971445553">
+						<reference key="NSNextResponder" ref="774585933"/>
+						<int key="NSvFlags">314</int>
+						<string key="NSFrame">{{8, 300}, {304, 94}}</string>
+						<reference key="NSSuperview" ref="774585933"/>
+						<reference key="NSWindow"/>
+						<reference key="NSNextKeyView" ref="89745263"/>
+						<object class="NSColor" key="IBUIBackgroundColor">
+							<int key="NSColorSpace">3</int>
+							<bytes key="NSWhite">MCAwAA</bytes>
+						</object>
+						<bool key="IBUIClipsSubviews">YES</bool>
+						<bool key="IBUIMultipleTouchEnabled">YES</bool>
+						<string key="targetRuntimeIdentifier">IBCocoaTouchFramework</string>
+						<bool key="IBUIEditable">NO</bool>
+						<string key="IBUIText">No barcode scanned...</string>
+						<object class="NSFont" key="IBUIFont">
+							<string key="NSName">Helvetica</string>
+							<double key="NSSize">17</double>
+							<int key="NSfFlags">16</int>
+						</object>
+						<object class="IBUITextInputTraits" key="IBUITextInputTraits">
+							<string key="targetRuntimeIdentifier">IBCocoaTouchFramework</string>
+						</object>
+					</object>
+				</object>
+				<string key="NSFrame">{{0, 20}, {320, 460}}</string>
+				<reference key="NSSuperview"/>
+				<reference key="NSWindow"/>
+				<reference key="NSNextKeyView" ref="583656854"/>
+				<object class="NSColor" key="IBUIBackgroundColor">
+					<int key="NSColorSpace">3</int>
+					<bytes key="NSWhite">MC43NQA</bytes>
+					<object class="NSColorSpace" key="NSCustomColorSpace">
+						<int key="NSID">2</int>
+					</object>
+				</object>
+				<bool key="IBUIClearsContextBeforeDrawing">NO</bool>
+				<object class="IBUISimulatedStatusBarMetrics" key="IBUISimulatedStatusBarMetrics"/>
+				<string key="targetRuntimeIdentifier">IBCocoaTouchFramework</string>
+			</object>
+		</object>
+		<object class="IBObjectContainer" key="IBDocument.Objects">
+			<object class="NSMutableArray" key="connectionRecords">
+				<bool key="EncodedWithXMLCoder">YES</bool>
+				<object class="IBConnectionRecord">
+					<object class="IBCocoaTouchOutletConnection" key="connection">
+						<string key="label">view</string>
+						<reference key="source" ref="372490531"/>
+						<reference key="destination" ref="774585933"/>
+					</object>
+					<int key="connectionID">7</int>
+				</object>
+				<object class="IBConnectionRecord">
+					<object class="IBCocoaTouchOutletConnection" key="connection">
+						<string key="label">readerView</string>
+						<reference key="source" ref="372490531"/>
+						<reference key="destination" ref="461611788"/>
+					</object>
+					<int key="connectionID">16</int>
+				</object>
+				<object class="IBConnectionRecord">
+					<object class="IBCocoaTouchOutletConnection" key="connection">
+						<string key="label">resultText</string>
+						<reference key="source" ref="372490531"/>
+						<reference key="destination" ref="971445553"/>
+					</object>
+					<int key="connectionID">17</int>
+				</object>
+			</object>
+			<object class="IBMutableOrderedSet" key="objectRecords">
+				<object class="NSArray" key="orderedObjects">
+					<bool key="EncodedWithXMLCoder">YES</bool>
+					<object class="IBObjectRecord">
+						<int key="objectID">0</int>
+						<reference key="object" ref="0"/>
+						<reference key="children" ref="1000"/>
+						<nil key="parent"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">-1</int>
+						<reference key="object" ref="372490531"/>
+						<reference key="parent" ref="0"/>
+						<string key="objectName">File's Owner</string>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">-2</int>
+						<reference key="object" ref="843779117"/>
+						<reference key="parent" ref="0"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">6</int>
+						<reference key="object" ref="774585933"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="583656854"/>
+							<reference ref="89745263"/>
+							<reference ref="971445553"/>
+							<reference ref="461611788"/>
+						</object>
+						<reference key="parent" ref="0"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">8</int>
+						<reference key="object" ref="461611788"/>
+						<reference key="parent" ref="774585933"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">11</int>
+						<reference key="object" ref="583656854"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="889758731"/>
+						</object>
+						<reference key="parent" ref="774585933"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">12</int>
+						<reference key="object" ref="889758731"/>
+						<reference key="parent" ref="583656854"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">13</int>
+						<reference key="object" ref="89745263"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+						</object>
+						<reference key="parent" ref="774585933"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">15</int>
+						<reference key="object" ref="971445553"/>
+						<reference key="parent" ref="774585933"/>
+					</object>
+				</object>
+			</object>
+			<object class="NSMutableDictionary" key="flattenedProperties">
+				<bool key="EncodedWithXMLCoder">YES</bool>
+				<object class="NSArray" key="dict.sortedKeys">
+					<bool key="EncodedWithXMLCoder">YES</bool>
+					<string>-1.CustomClassName</string>
+					<string>-2.CustomClassName</string>
+					<string>11.IBPluginDependency</string>
+					<string>12.IBPluginDependency</string>
+					<string>13.IBPluginDependency</string>
+					<string>15.IBPluginDependency</string>
+					<string>6.IBEditorWindowLastContentRect</string>
+					<string>6.IBPluginDependency</string>
+					<string>8.CustomClassName</string>
+					<string>8.IBPluginDependency</string>
+				</object>
+				<object class="NSMutableArray" key="dict.values">
+					<bool key="EncodedWithXMLCoder">YES</bool>
+					<string>EmbedReaderViewController</string>
+					<string>UIResponder</string>
+					<string>com.apple.InterfaceBuilder.IBCocoaTouchPlugin</string>
+					<string>com.apple.InterfaceBuilder.IBCocoaTouchPlugin</string>
+					<string>com.apple.InterfaceBuilder.IBCocoaTouchPlugin</string>
+					<string>com.apple.InterfaceBuilder.IBCocoaTouchPlugin</string>
+					<string>{{239, 654}, {320, 480}}</string>
+					<string>com.apple.InterfaceBuilder.IBCocoaTouchPlugin</string>
+					<string>ZBarReaderView</string>
+					<string>com.apple.InterfaceBuilder.IBCocoaTouchPlugin</string>
+				</object>
+			</object>
+			<object class="NSMutableDictionary" key="unlocalizedProperties">
+				<bool key="EncodedWithXMLCoder">YES</bool>
+				<reference key="dict.sortedKeys" ref="0"/>
+				<reference key="dict.values" ref="0"/>
+			</object>
+			<nil key="activeLocalization"/>
+			<object class="NSMutableDictionary" key="localizations">
+				<bool key="EncodedWithXMLCoder">YES</bool>
+				<reference key="dict.sortedKeys" ref="0"/>
+				<reference key="dict.values" ref="0"/>
+			</object>
+			<nil key="sourceID"/>
+			<int key="maxID">18</int>
+		</object>
+		<object class="IBClassDescriber" key="IBDocument.Classes">
+			<object class="NSMutableArray" key="referencedPartialClassDescriptions">
+				<bool key="EncodedWithXMLCoder">YES</bool>
+				<object class="IBPartialClassDescription">
+					<string key="className">EmbedReaderViewController</string>
+					<string key="superclassName">UIViewController</string>
+					<object class="NSMutableDictionary" key="outlets">
+						<bool key="EncodedWithXMLCoder">YES</bool>
+						<object class="NSArray" key="dict.sortedKeys">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<string>readerView</string>
+							<string>resultText</string>
+						</object>
+						<object class="NSMutableArray" key="dict.values">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<string>ZBarReaderView</string>
+							<string>UITextView</string>
+						</object>
+					</object>
+					<object class="NSMutableDictionary" key="toOneOutletInfosByName">
+						<bool key="EncodedWithXMLCoder">YES</bool>
+						<object class="NSArray" key="dict.sortedKeys">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<string>readerView</string>
+							<string>resultText</string>
+						</object>
+						<object class="NSMutableArray" key="dict.values">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<object class="IBToOneOutletInfo">
+								<string key="name">readerView</string>
+								<string key="candidateClassName">ZBarReaderView</string>
+							</object>
+							<object class="IBToOneOutletInfo">
+								<string key="name">resultText</string>
+								<string key="candidateClassName">UITextView</string>
+							</object>
+						</object>
+					</object>
+					<object class="IBClassDescriptionSource" key="sourceIdentifier">
+						<string key="majorKey">IBProjectSource</string>
+						<string key="minorKey">./Classes/EmbedReaderViewController.h</string>
+					</object>
+				</object>
+				<object class="IBPartialClassDescription">
+					<string key="className">ZBarReaderView</string>
+					<string key="superclassName">UIView</string>
+					<object class="IBClassDescriptionSource" key="sourceIdentifier">
+						<string key="majorKey">IBProjectSource</string>
+						<string key="minorKey">./Classes/ZBarReaderView.h</string>
+					</object>
+				</object>
+			</object>
+		</object>
+		<int key="IBDocument.localizationMode">0</int>
+		<string key="IBDocument.TargetRuntimeIdentifier">IBCocoaTouchFramework</string>
+		<object class="NSMutableDictionary" key="IBDocument.PluginDeclaredDevelopmentDependencies">
+			<string key="NS.key.0">com.apple.InterfaceBuilder.CocoaTouchPlugin.InterfaceBuilder3</string>
+			<integer value="3100" key="NS.object.0"/>
+		</object>
+		<bool key="IBDocument.PluginDeclaredDependenciesTrackSystemTargetVersion">YES</bool>
+		<int key="IBDocument.defaultPropertyAccessControl">3</int>
+		<string key="IBCocoaTouchPluginVersion">301</string>
+	</data>
+</archive>
diff -r 563557a923d0 iphone/examples/EmbedReader/EmbedReader/en.lproj/InfoPlist.strings
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/examples/EmbedReader/EmbedReader/en.lproj/InfoPlist.strings	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,2 @@
+/* Localized versions of Info.plist keys */
+
diff -r 563557a923d0 iphone/examples/EmbedReader/EmbedReader/en.lproj/MainWindow.xib
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/examples/EmbedReader/EmbedReader/en.lproj/MainWindow.xib	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,444 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<archive type="com.apple.InterfaceBuilder3.CocoaTouch.XIB" version="7.10">
+	<data>
+		<int key="IBDocument.SystemTarget">1024</int>
+		<string key="IBDocument.SystemVersion">10D571</string>
+		<string key="IBDocument.InterfaceBuilderVersion">786</string>
+		<string key="IBDocument.AppKitVersion">1038.29</string>
+		<string key="IBDocument.HIToolboxVersion">460.00</string>
+		<object class="NSMutableDictionary" key="IBDocument.PluginVersions">
+			<string key="NS.key.0">com.apple.InterfaceBuilder.IBCocoaTouchPlugin</string>
+			<string key="NS.object.0">112</string>
+		</object>
+		<object class="NSMutableArray" key="IBDocument.EditedObjectIDs">
+			<bool key="EncodedWithXMLCoder">YES</bool>
+			<integer value="10"/>
+		</object>
+		<object class="NSArray" key="IBDocument.PluginDependencies">
+			<bool key="EncodedWithXMLCoder">YES</bool>
+			<string>com.apple.InterfaceBuilder.IBCocoaTouchPlugin</string>
+		</object>
+		<object class="NSMutableDictionary" key="IBDocument.Metadata">
+			<bool key="EncodedWithXMLCoder">YES</bool>
+			<object class="NSArray" key="dict.sortedKeys" id="0">
+				<bool key="EncodedWithXMLCoder">YES</bool>
+			</object>
+			<object class="NSMutableArray" key="dict.values">
+				<bool key="EncodedWithXMLCoder">YES</bool>
+			</object>
+		</object>
+		<object class="NSMutableArray" key="IBDocument.RootObjects" id="1000">
+			<bool key="EncodedWithXMLCoder">YES</bool>
+			<object class="IBProxyObject" id="841351856">
+				<string key="IBProxiedObjectIdentifier">IBFilesOwner</string>
+				<string key="targetRuntimeIdentifier">IBCocoaTouchFramework</string>
+			</object>
+			<object class="IBProxyObject" id="427554174">
+				<string key="IBProxiedObjectIdentifier">IBFirstResponder</string>
+				<string key="targetRuntimeIdentifier">IBCocoaTouchFramework</string>
+			</object>
+			<object class="IBUICustomObject" id="664661524">
+				<string key="targetRuntimeIdentifier">IBCocoaTouchFramework</string>
+			</object>
+			<object class="IBUIViewController" id="943309135">
+				<string key="IBUINibName">EmbedReaderViewController</string>
+				<object class="IBUISimulatedStatusBarMetrics" key="IBUISimulatedStatusBarMetrics"/>
+				<object class="IBUISimulatedOrientationMetrics" key="IBUISimulatedOrientationMetrics">
+					<int key="interfaceOrientation">1</int>
+				</object>
+				<string key="targetRuntimeIdentifier">IBCocoaTouchFramework</string>
+				<bool key="IBUIHorizontal">NO</bool>
+			</object>
+			<object class="IBUIWindow" id="117978783">
+				<nil key="NSNextResponder"/>
+				<int key="NSvFlags">292</int>
+				<string key="NSFrameSize">{320, 480}</string>
+				<object class="NSColor" key="IBUIBackgroundColor">
+					<int key="NSColorSpace">1</int>
+					<bytes key="NSRGB">MSAxIDEAA</bytes>
+				</object>
+				<bool key="IBUIOpaque">NO</bool>
+				<bool key="IBUIClearsContextBeforeDrawing">NO</bool>
+				<object class="IBUISimulatedStatusBarMetrics" key="IBUISimulatedStatusBarMetrics"/>
+				<string key="targetRuntimeIdentifier">IBCocoaTouchFramework</string>
+				<bool key="IBUIResizesToFullScreen">YES</bool>
+			</object>
+		</object>
+		<object class="IBObjectContainer" key="IBDocument.Objects">
+			<object class="NSMutableArray" key="connectionRecords">
+				<bool key="EncodedWithXMLCoder">YES</bool>
+				<object class="IBConnectionRecord">
+					<object class="IBCocoaTouchOutletConnection" key="connection">
+						<string key="label">delegate</string>
+						<reference key="source" ref="841351856"/>
+						<reference key="destination" ref="664661524"/>
+					</object>
+					<int key="connectionID">4</int>
+				</object>
+				<object class="IBConnectionRecord">
+					<object class="IBCocoaTouchOutletConnection" key="connection">
+						<string key="label">viewController</string>
+						<reference key="source" ref="664661524"/>
+						<reference key="destination" ref="943309135"/>
+					</object>
+					<int key="connectionID">11</int>
+				</object>
+				<object class="IBConnectionRecord">
+					<object class="IBCocoaTouchOutletConnection" key="connection">
+						<string key="label">window</string>
+						<reference key="source" ref="664661524"/>
+						<reference key="destination" ref="117978783"/>
+					</object>
+					<int key="connectionID">14</int>
+				</object>
+			</object>
+			<object class="IBMutableOrderedSet" key="objectRecords">
+				<object class="NSArray" key="orderedObjects">
+					<bool key="EncodedWithXMLCoder">YES</bool>
+					<object class="IBObjectRecord">
+						<int key="objectID">0</int>
+						<reference key="object" ref="0"/>
+						<reference key="children" ref="1000"/>
+						<nil key="parent"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">-1</int>
+						<reference key="object" ref="841351856"/>
+						<reference key="parent" ref="0"/>
+						<string key="objectName">File's Owner</string>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">3</int>
+						<reference key="object" ref="664661524"/>
+						<reference key="parent" ref="0"/>
+						<string key="objectName">EmbedReader App Delegate</string>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">-2</int>
+						<reference key="object" ref="427554174"/>
+						<reference key="parent" ref="0"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">10</int>
+						<reference key="object" ref="943309135"/>
+						<reference key="parent" ref="0"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">12</int>
+						<reference key="object" ref="117978783"/>
+						<reference key="parent" ref="0"/>
+					</object>
+				</object>
+			</object>
+			<object class="NSMutableDictionary" key="flattenedProperties">
+				<bool key="EncodedWithXMLCoder">YES</bool>
+				<object class="NSArray" key="dict.sortedKeys">
+					<bool key="EncodedWithXMLCoder">YES</bool>
+					<string>-1.CustomClassName</string>
+					<string>-2.CustomClassName</string>
+					<string>10.CustomClassName</string>
+					<string>10.IBEditorWindowLastContentRect</string>
+					<string>10.IBPluginDependency</string>
+					<string>12.IBEditorWindowLastContentRect</string>
+					<string>12.IBPluginDependency</string>
+					<string>3.CustomClassName</string>
+					<string>3.IBPluginDependency</string>
+				</object>
+				<object class="NSMutableArray" key="dict.values">
+					<bool key="EncodedWithXMLCoder">YES</bool>
+					<string>UIApplication</string>
+					<string>UIResponder</string>
+					<string>EmbedReaderViewController</string>
+					<string>{{234, 376}, {320, 480}}</string>
+					<string>com.apple.InterfaceBuilder.IBCocoaTouchPlugin</string>
+					<string>{{525, 346}, {320, 480}}</string>
+					<string>com.apple.InterfaceBuilder.IBCocoaTouchPlugin</string>
+					<string>EmbedReaderAppDelegate</string>
+					<string>com.apple.InterfaceBuilder.IBCocoaTouchPlugin</string>
+				</object>
+			</object>
+			<object class="NSMutableDictionary" key="unlocalizedProperties">
+				<bool key="EncodedWithXMLCoder">YES</bool>
+				<reference key="dict.sortedKeys" ref="0"/>
+				<object class="NSMutableArray" key="dict.values">
+					<bool key="EncodedWithXMLCoder">YES</bool>
+				</object>
+			</object>
+			<nil key="activeLocalization"/>
+			<object class="NSMutableDictionary" key="localizations">
+				<bool key="EncodedWithXMLCoder">YES</bool>
+				<reference key="dict.sortedKeys" ref="0"/>
+				<object class="NSMutableArray" key="dict.values">
+					<bool key="EncodedWithXMLCoder">YES</bool>
+				</object>
+			</object>
+			<nil key="sourceID"/>
+			<int key="maxID">15</int>
+		</object>
+		<object class="IBClassDescriber" key="IBDocument.Classes">
+			<object class="NSMutableArray" key="referencedPartialClassDescriptions">
+				<bool key="EncodedWithXMLCoder">YES</bool>
+				<object class="IBPartialClassDescription">
+					<string key="className">UIWindow</string>
+					<string key="superclassName">UIView</string>
+					<object class="IBClassDescriptionSource" key="sourceIdentifier">
+						<string key="majorKey">IBUserSource</string>
+						<string key="minorKey"/>
+					</object>
+				</object>
+				<object class="IBPartialClassDescription">
+					<string key="className">EmbedReaderAppDelegate</string>
+					<string key="superclassName">NSObject</string>
+					<object class="NSMutableDictionary" key="outlets">
+						<bool key="EncodedWithXMLCoder">YES</bool>
+						<object class="NSArray" key="dict.sortedKeys">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<string>viewController</string>
+							<string>window</string>
+						</object>
+						<object class="NSMutableArray" key="dict.values">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<string>EmbedReaderViewController</string>
+							<string>UIWindow</string>
+						</object>
+					</object>
+					<object class="NSMutableDictionary" key="toOneOutletInfosByName">
+						<bool key="EncodedWithXMLCoder">YES</bool>
+						<object class="NSArray" key="dict.sortedKeys">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<string>viewController</string>
+							<string>window</string>
+						</object>
+						<object class="NSMutableArray" key="dict.values">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<object class="IBToOneOutletInfo">
+								<string key="name">viewController</string>
+								<string key="candidateClassName">EmbedReaderViewController</string>
+							</object>
+							<object class="IBToOneOutletInfo">
+								<string key="name">window</string>
+								<string key="candidateClassName">UIWindow</string>
+							</object>
+						</object>
+					</object>
+					<object class="IBClassDescriptionSource" key="sourceIdentifier">
+						<string key="majorKey">IBProjectSource</string>
+						<string key="minorKey">EmbedReaderAppDelegate.h</string>
+					</object>
+				</object>
+				<object class="IBPartialClassDescription">
+					<string key="className">EmbedReaderAppDelegate</string>
+					<string key="superclassName">NSObject</string>
+					<object class="IBClassDescriptionSource" key="sourceIdentifier">
+						<string key="majorKey">IBUserSource</string>
+						<string key="minorKey"/>
+					</object>
+				</object>
+				<object class="IBPartialClassDescription">
+					<string key="className">EmbedReaderViewController</string>
+					<string key="superclassName">UIViewController</string>
+					<object class="IBClassDescriptionSource" key="sourceIdentifier">
+						<string key="majorKey">IBProjectSource</string>
+						<string key="minorKey">EmbedReaderViewController.h</string>
+					</object>
+				</object>
+			</object>
+			<object class="NSMutableArray" key="referencedPartialClassDescriptionsV3.2+">
+				<bool key="EncodedWithXMLCoder">YES</bool>
+				<object class="IBPartialClassDescription">
+					<string key="className">NSObject</string>
+					<object class="IBClassDescriptionSource" key="sourceIdentifier">
+						<string key="majorKey">IBFrameworkSource</string>
+						<string key="minorKey">Foundation.framework/Headers/NSError.h</string>
+					</object>
+				</object>
+				<object class="IBPartialClassDescription">
+					<string key="className">NSObject</string>
+					<object class="IBClassDescriptionSource" key="sourceIdentifier">
+						<string key="majorKey">IBFrameworkSource</string>
+						<string key="minorKey">Foundation.framework/Headers/NSFileManager.h</string>
+					</object>
+				</object>
+				<object class="IBPartialClassDescription">
+					<string key="className">NSObject</string>
+					<object class="IBClassDescriptionSource" key="sourceIdentifier">
+						<string key="majorKey">IBFrameworkSource</string>
+						<string key="minorKey">Foundation.framework/Headers/NSKeyValueCoding.h</string>
+					</object>
+				</object>
+				<object class="IBPartialClassDescription">
+					<string key="className">NSObject</string>
+					<object class="IBClassDescriptionSource" key="sourceIdentifier">
+						<string key="majorKey">IBFrameworkSource</string>
+						<string key="minorKey">Foundation.framework/Headers/NSKeyValueObserving.h</string>
+					</object>
+				</object>
+				<object class="IBPartialClassDescription">
+					<string key="className">NSObject</string>
+					<object class="IBClassDescriptionSource" key="sourceIdentifier">
+						<string key="majorKey">IBFrameworkSource</string>
+						<string key="minorKey">Foundation.framework/Headers/NSKeyedArchiver.h</string>
+					</object>
+				</object>
+				<object class="IBPartialClassDescription">
+					<string key="className">NSObject</string>
+					<object class="IBClassDescriptionSource" key="sourceIdentifier">
+						<string key="majorKey">IBFrameworkSource</string>
+						<string key="minorKey">Foundation.framework/Headers/NSObject.h</string>
+					</object>
+				</object>
+				<object class="IBPartialClassDescription">
+					<string key="className">NSObject</string>
+					<object class="IBClassDescriptionSource" key="sourceIdentifier">
+						<string key="majorKey">IBFrameworkSource</string>
+						<string key="minorKey">Foundation.framework/Headers/NSRunLoop.h</string>
+					</object>
+				</object>
+				<object class="IBPartialClassDescription">
+					<string key="className">NSObject</string>
+					<object class="IBClassDescriptionSource" key="sourceIdentifier">
+						<string key="majorKey">IBFrameworkSource</string>
+						<string key="minorKey">Foundation.framework/Headers/NSThread.h</string>
+					</object>
+				</object>
+				<object class="IBPartialClassDescription">
+					<string key="className">NSObject</string>
+					<object class="IBClassDescriptionSource" key="sourceIdentifier">
+						<string key="majorKey">IBFrameworkSource</string>
+						<string key="minorKey">Foundation.framework/Headers/NSURL.h</string>
+					</object>
+				</object>
+				<object class="IBPartialClassDescription">
+					<string key="className">NSObject</string>
+					<object class="IBClassDescriptionSource" key="sourceIdentifier">
+						<string key="majorKey">IBFrameworkSource</string>
+						<string key="minorKey">Foundation.framework/Headers/NSURLConnection.h</string>
+					</object>
+				</object>
+				<object class="IBPartialClassDescription">
+					<string key="className">NSObject</string>
+					<object class="IBClassDescriptionSource" key="sourceIdentifier">
+						<string key="majorKey">IBFrameworkSource</string>
+						<string key="minorKey">UIKit.framework/Headers/UIAccessibility.h</string>
+					</object>
+				</object>
+				<object class="IBPartialClassDescription">
+					<string key="className">NSObject</string>
+					<object class="IBClassDescriptionSource" key="sourceIdentifier">
+						<string key="majorKey">IBFrameworkSource</string>
+						<string key="minorKey">UIKit.framework/Headers/UINibLoading.h</string>
+					</object>
+				</object>
+				<object class="IBPartialClassDescription">
+					<string key="className">NSObject</string>
+					<object class="IBClassDescriptionSource" key="sourceIdentifier" id="356479594">
+						<string key="majorKey">IBFrameworkSource</string>
+						<string key="minorKey">UIKit.framework/Headers/UIResponder.h</string>
+					</object>
+				</object>
+				<object class="IBPartialClassDescription">
+					<string key="className">UIApplication</string>
+					<string key="superclassName">UIResponder</string>
+					<object class="IBClassDescriptionSource" key="sourceIdentifier">
+						<string key="majorKey">IBFrameworkSource</string>
+						<string key="minorKey">UIKit.framework/Headers/UIApplication.h</string>
+					</object>
+				</object>
+				<object class="IBPartialClassDescription">
+					<string key="className">UIResponder</string>
+					<string key="superclassName">NSObject</string>
+					<reference key="sourceIdentifier" ref="356479594"/>
+				</object>
+				<object class="IBPartialClassDescription">
+					<string key="className">UISearchBar</string>
+					<string key="superclassName">UIView</string>
+					<object class="IBClassDescriptionSource" key="sourceIdentifier">
+						<string key="majorKey">IBFrameworkSource</string>
+						<string key="minorKey">UIKit.framework/Headers/UISearchBar.h</string>
+					</object>
+				</object>
+				<object class="IBPartialClassDescription">
+					<string key="className">UISearchDisplayController</string>
+					<string key="superclassName">NSObject</string>
+					<object class="IBClassDescriptionSource" key="sourceIdentifier">
+						<string key="majorKey">IBFrameworkSource</string>
+						<string key="minorKey">UIKit.framework/Headers/UISearchDisplayController.h</string>
+					</object>
+				</object>
+				<object class="IBPartialClassDescription">
+					<string key="className">UIView</string>
+					<object class="IBClassDescriptionSource" key="sourceIdentifier">
+						<string key="majorKey">IBFrameworkSource</string>
+						<string key="minorKey">UIKit.framework/Headers/UITextField.h</string>
+					</object>
+				</object>
+				<object class="IBPartialClassDescription">
+					<string key="className">UIView</string>
+					<string key="superclassName">UIResponder</string>
+					<object class="IBClassDescriptionSource" key="sourceIdentifier">
+						<string key="majorKey">IBFrameworkSource</string>
+						<string key="minorKey">UIKit.framework/Headers/UIView.h</string>
+					</object>
+				</object>
+				<object class="IBPartialClassDescription">
+					<string key="className">UIViewController</string>
+					<object class="IBClassDescriptionSource" key="sourceIdentifier">
+						<string key="majorKey">IBFrameworkSource</string>
+						<string key="minorKey">UIKit.framework/Headers/UINavigationController.h</string>
+					</object>
+				</object>
+				<object class="IBPartialClassDescription">
+					<string key="className">UIViewController</string>
+					<object class="IBClassDescriptionSource" key="sourceIdentifier">
+						<string key="majorKey">IBFrameworkSource</string>
+						<string key="minorKey">UIKit.framework/Headers/UIPopoverController.h</string>
+					</object>
+				</object>
+				<object class="IBPartialClassDescription">
+					<string key="className">UIViewController</string>
+					<object class="IBClassDescriptionSource" key="sourceIdentifier">
+						<string key="majorKey">IBFrameworkSource</string>
+						<string key="minorKey">UIKit.framework/Headers/UISplitViewController.h</string>
+					</object>
+				</object>
+				<object class="IBPartialClassDescription">
+					<string key="className">UIViewController</string>
+					<object class="IBClassDescriptionSource" key="sourceIdentifier">
+						<string key="majorKey">IBFrameworkSource</string>
+						<string key="minorKey">UIKit.framework/Headers/UITabBarController.h</string>
+					</object>
+				</object>
+				<object class="IBPartialClassDescription">
+					<string key="className">UIViewController</string>
+					<string key="superclassName">UIResponder</string>
+					<object class="IBClassDescriptionSource" key="sourceIdentifier">
+						<string key="majorKey">IBFrameworkSource</string>
+						<string key="minorKey">UIKit.framework/Headers/UIViewController.h</string>
+					</object>
+				</object>
+				<object class="IBPartialClassDescription">
+					<string key="className">UIWindow</string>
+					<string key="superclassName">UIView</string>
+					<object class="IBClassDescriptionSource" key="sourceIdentifier">
+						<string key="majorKey">IBFrameworkSource</string>
+						<string key="minorKey">UIKit.framework/Headers/UIWindow.h</string>
+					</object>
+				</object>
+			</object>
+		</object>
+		<int key="IBDocument.localizationMode">0</int>
+		<string key="IBDocument.TargetRuntimeIdentifier">IBCocoaTouchFramework</string>
+		<object class="NSMutableDictionary" key="IBDocument.PluginDeclaredDependencyDefaults">
+			<string key="NS.key.0">com.apple.InterfaceBuilder.CocoaTouchPlugin.iPhoneOS</string>
+			<integer value="1024" key="NS.object.0"/>
+		</object>
+		<object class="NSMutableDictionary" key="IBDocument.PluginDeclaredDevelopmentDependencies">
+			<string key="NS.key.0">com.apple.InterfaceBuilder.CocoaTouchPlugin.InterfaceBuilder3</string>
+			<integer value="3100" key="NS.object.0"/>
+		</object>
+		<bool key="IBDocument.PluginDeclaredDependenciesTrackSystemTargetVersion">YES</bool>
+		<string key="IBDocument.LastKnownRelativeProjectPath">EmbedReader.xcodeproj</string>
+		<int key="IBDocument.defaultPropertyAccessControl">3</int>
+		<string key="IBCocoaTouchPluginVersion">112</string>
+	</data>
+</archive>
diff -r 563557a923d0 iphone/examples/EmbedReader/EmbedReader/main.m
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/examples/EmbedReader/EmbedReader/main.m	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,16 @@
+//
+//  main.m
+//  EmbedReader
+//
+//  Created by spadix on 5/2/11.
+//
+
+#import <UIKit/UIKit.h>
+
+int main(int argc, char *argv[])
+{
+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+    int retVal = UIApplicationMain(argc, argv, nil, nil);
+    [pool release];
+    return retVal;
+}
diff -r 563557a923d0 iphone/examples/EmbedReader/ZBarSDK
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/examples/EmbedReader/ZBarSDK	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,1 @@
+../../build/Debug-iphoneos/ZBarSDK
\ No newline at end of file
diff -r 563557a923d0 iphone/examples/EmbedReader/build
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/examples/EmbedReader/build	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,1 @@
+/tmp/EmbedReader.build
\ No newline at end of file
diff -r 563557a923d0 iphone/examples/ReaderSample/Default-568h@2x.png
Binary file iphone/examples/ReaderSample/Default-568h@2x.png has changed
diff -r 563557a923d0 iphone/examples/ReaderSample/ReaderSample.xcodeproj/project.pbxproj
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/examples/ReaderSample/ReaderSample.xcodeproj/project.pbxproj	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,419 @@
+// !$*UTF8*$!
+{
+	archiveVersion = 1;
+	classes = {
+	};
+	objectVersion = 46;
+	objects = {
+
+/* Begin PBXBuildFile section */
+		DC8245F5162B549F0010B2E6 /* Default-568h@2x.png in Resources */ = {isa = PBXBuildFile; fileRef = DC8245F4162B549F0010B2E6 /* Default-568h@2x.png */; };
+		DC8F289413579EFF005B8862 /* UIKit.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = DC8F289313579EFF005B8862 /* UIKit.framework */; };
+		DC8F289613579EFF005B8862 /* Foundation.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = DC8F289513579EFF005B8862 /* Foundation.framework */; };
+		DC8F289813579EFF005B8862 /* CoreGraphics.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = DC8F289713579EFF005B8862 /* CoreGraphics.framework */; };
+		DC8F289E13579EFF005B8862 /* InfoPlist.strings in Resources */ = {isa = PBXBuildFile; fileRef = DC8F289C13579EFF005B8862 /* InfoPlist.strings */; };
+		DC8F28A113579EFF005B8862 /* main.m in Sources */ = {isa = PBXBuildFile; fileRef = DC8F28A013579EFF005B8862 /* main.m */; };
+		DC8F28A413579EFF005B8862 /* ReaderSampleAppDelegate.m in Sources */ = {isa = PBXBuildFile; fileRef = DC8F28A313579EFF005B8862 /* ReaderSampleAppDelegate.m */; };
+		DC8F28A713579EFF005B8862 /* MainWindow.xib in Resources */ = {isa = PBXBuildFile; fileRef = DC8F28A513579EFF005B8862 /* MainWindow.xib */; };
+		DC8F28AA13579EFF005B8862 /* ReaderSampleViewController.m in Sources */ = {isa = PBXBuildFile; fileRef = DC8F28A913579EFF005B8862 /* ReaderSampleViewController.m */; };
+		DC8F28AD13579F00005B8862 /* ReaderSampleViewController.xib in Resources */ = {isa = PBXBuildFile; fileRef = DC8F28AB13579EFF005B8862 /* ReaderSampleViewController.xib */; };
+		DC8F28D01357A29D005B8862 /* libzbar.a in Frameworks */ = {isa = PBXBuildFile; fileRef = DC8F28CA1357A29D005B8862 /* libzbar.a */; };
+		DC8F28D11357A29D005B8862 /* zbar-back.png in Resources */ = {isa = PBXBuildFile; fileRef = DC8F28CC1357A29D005B8862 /* zbar-back.png */; };
+		DC8F28D21357A29D005B8862 /* zbar-help.html in Resources */ = {isa = PBXBuildFile; fileRef = DC8F28CD1357A29D005B8862 /* zbar-help.html */; };
+		DC8F28D31357A29D005B8862 /* zbar-helpicons.png in Resources */ = {isa = PBXBuildFile; fileRef = DC8F28CE1357A29D005B8862 /* zbar-helpicons.png */; };
+		DC8F28D41357A29D005B8862 /* zbar-samples.png in Resources */ = {isa = PBXBuildFile; fileRef = DC8F28CF1357A29D005B8862 /* zbar-samples.png */; };
+		DC8F28DA1357A42E005B8862 /* AVFoundation.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = DC8F28D51357A42E005B8862 /* AVFoundation.framework */; };
+		DC8F28DB1357A42E005B8862 /* CoreMedia.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = DC8F28D61357A42E005B8862 /* CoreMedia.framework */; };
+		DC8F28DC1357A42E005B8862 /* CoreVideo.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = DC8F28D71357A42E005B8862 /* CoreVideo.framework */; };
+		DC8F28DD1357A42E005B8862 /* libiconv.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = DC8F28D81357A42E005B8862 /* libiconv.dylib */; };
+		DC8F28DE1357A42E005B8862 /* QuartzCore.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = DC8F28D91357A42E005B8862 /* QuartzCore.framework */; };
+/* End PBXBuildFile section */
+
+/* Begin PBXFileReference section */
+		DC8245F4162B549F0010B2E6 /* Default-568h@2x.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; path = "Default-568h@2x.png"; sourceTree = SOURCE_ROOT; };
+		DC8F288F13579EFF005B8862 /* ReaderSample.app */ = {isa = PBXFileReference; explicitFileType = wrapper.application; includeInIndex = 0; path = ReaderSample.app; sourceTree = BUILT_PRODUCTS_DIR; };
+		DC8F289313579EFF005B8862 /* UIKit.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = UIKit.framework; path = System/Library/Frameworks/UIKit.framework; sourceTree = SDKROOT; };
+		DC8F289513579EFF005B8862 /* Foundation.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = Foundation.framework; path = System/Library/Frameworks/Foundation.framework; sourceTree = SDKROOT; };
+		DC8F289713579EFF005B8862 /* CoreGraphics.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = CoreGraphics.framework; path = System/Library/Frameworks/CoreGraphics.framework; sourceTree = SDKROOT; };
+		DC8F289B13579EFF005B8862 /* ReaderSample-Info.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist.xml; path = "ReaderSample-Info.plist"; sourceTree = "<group>"; };
+		DC8F289D13579EFF005B8862 /* en */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = en; path = en.lproj/InfoPlist.strings; sourceTree = "<group>"; };
+		DC8F289F13579EFF005B8862 /* ReaderSample-Prefix.pch */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = "ReaderSample-Prefix.pch"; sourceTree = "<group>"; };
+		DC8F28A013579EFF005B8862 /* main.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = main.m; sourceTree = "<group>"; };
+		DC8F28A213579EFF005B8862 /* ReaderSampleAppDelegate.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = ReaderSampleAppDelegate.h; sourceTree = "<group>"; };
+		DC8F28A313579EFF005B8862 /* ReaderSampleAppDelegate.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = ReaderSampleAppDelegate.m; sourceTree = "<group>"; };
+		DC8F28A613579EFF005B8862 /* en */ = {isa = PBXFileReference; lastKnownFileType = file.xib; name = en; path = en.lproj/MainWindow.xib; sourceTree = "<group>"; };
+		DC8F28A813579EFF005B8862 /* ReaderSampleViewController.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = ReaderSampleViewController.h; sourceTree = "<group>"; };
+		DC8F28A913579EFF005B8862 /* ReaderSampleViewController.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = ReaderSampleViewController.m; sourceTree = "<group>"; };
+		DC8F28AC13579F00005B8862 /* en */ = {isa = PBXFileReference; lastKnownFileType = file.xib; name = en; path = en.lproj/ReaderSampleViewController.xib; sourceTree = "<group>"; };
+		DC8F28B71357A29D005B8862 /* Decoder.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Decoder.h; sourceTree = "<group>"; };
+		DC8F28B81357A29D005B8862 /* Exception.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Exception.h; sourceTree = "<group>"; };
+		DC8F28B91357A29D005B8862 /* Image.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Image.h; sourceTree = "<group>"; };
+		DC8F28BA1357A29D005B8862 /* ImageScanner.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ImageScanner.h; sourceTree = "<group>"; };
+		DC8F28BB1357A29D005B8862 /* Processor.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Processor.h; sourceTree = "<group>"; };
+		DC8F28BC1357A29D005B8862 /* Scanner.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Scanner.h; sourceTree = "<group>"; };
+		DC8F28BD1357A29D005B8862 /* Symbol.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Symbol.h; sourceTree = "<group>"; };
+		DC8F28BE1357A29D005B8862 /* Video.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Video.h; sourceTree = "<group>"; };
+		DC8F28BF1357A29D005B8862 /* Window.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Window.h; sourceTree = "<group>"; };
+		DC8F28C01357A29D005B8862 /* zbar.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = zbar.h; sourceTree = "<group>"; };
+		DC8F28C11357A29D005B8862 /* ZBarCaptureReader.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ZBarCaptureReader.h; sourceTree = "<group>"; };
+		DC8F28C21357A29D005B8862 /* ZBarHelpController.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ZBarHelpController.h; sourceTree = "<group>"; };
+		DC8F28C31357A29D005B8862 /* ZBarImage.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ZBarImage.h; sourceTree = "<group>"; };
+		DC8F28C41357A29D005B8862 /* ZBarImageScanner.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ZBarImageScanner.h; sourceTree = "<group>"; };
+		DC8F28C51357A29D005B8862 /* ZBarReaderController.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ZBarReaderController.h; sourceTree = "<group>"; };
+		DC8F28C61357A29D005B8862 /* ZBarReaderView.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ZBarReaderView.h; sourceTree = "<group>"; };
+		DC8F28C71357A29D005B8862 /* ZBarReaderViewController.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ZBarReaderViewController.h; sourceTree = "<group>"; };
+		DC8F28C81357A29D005B8862 /* ZBarSDK.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ZBarSDK.h; sourceTree = "<group>"; };
+		DC8F28C91357A29D005B8862 /* ZBarSymbol.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ZBarSymbol.h; sourceTree = "<group>"; };
+		DC8F28CA1357A29D005B8862 /* libzbar.a */ = {isa = PBXFileReference; lastKnownFileType = archive.ar; path = libzbar.a; sourceTree = "<group>"; };
+		DC8F28CC1357A29D005B8862 /* zbar-back.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; path = "zbar-back.png"; sourceTree = "<group>"; };
+		DC8F28CD1357A29D005B8862 /* zbar-help.html */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.html; path = "zbar-help.html"; sourceTree = "<group>"; };
+		DC8F28CE1357A29D005B8862 /* zbar-helpicons.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; path = "zbar-helpicons.png"; sourceTree = "<group>"; };
+		DC8F28CF1357A29D005B8862 /* zbar-samples.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; path = "zbar-samples.png"; sourceTree = "<group>"; };
+		DC8F28D51357A42E005B8862 /* AVFoundation.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = AVFoundation.framework; path = System/Library/Frameworks/AVFoundation.framework; sourceTree = SDKROOT; };
+		DC8F28D61357A42E005B8862 /* CoreMedia.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = CoreMedia.framework; path = System/Library/Frameworks/CoreMedia.framework; sourceTree = SDKROOT; };
+		DC8F28D71357A42E005B8862 /* CoreVideo.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = CoreVideo.framework; path = System/Library/Frameworks/CoreVideo.framework; sourceTree = SDKROOT; };
+		DC8F28D81357A42E005B8862 /* libiconv.dylib */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.dylib"; name = libiconv.dylib; path = usr/lib/libiconv.dylib; sourceTree = SDKROOT; };
+		DC8F28D91357A42E005B8862 /* QuartzCore.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = QuartzCore.framework; path = System/Library/Frameworks/QuartzCore.framework; sourceTree = SDKROOT; };
+/* End PBXFileReference section */
+
+/* Begin PBXFrameworksBuildPhase section */
+		DC8F288C13579EFF005B8862 /* Frameworks */ = {
+			isa = PBXFrameworksBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				DC8F28DA1357A42E005B8862 /* AVFoundation.framework in Frameworks */,
+				DC8F28DB1357A42E005B8862 /* CoreMedia.framework in Frameworks */,
+				DC8F28DC1357A42E005B8862 /* CoreVideo.framework in Frameworks */,
+				DC8F28DD1357A42E005B8862 /* libiconv.dylib in Frameworks */,
+				DC8F28DE1357A42E005B8862 /* QuartzCore.framework in Frameworks */,
+				DC8F289413579EFF005B8862 /* UIKit.framework in Frameworks */,
+				DC8F289613579EFF005B8862 /* Foundation.framework in Frameworks */,
+				DC8F289813579EFF005B8862 /* CoreGraphics.framework in Frameworks */,
+				DC8F28D01357A29D005B8862 /* libzbar.a in Frameworks */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+/* End PBXFrameworksBuildPhase section */
+
+/* Begin PBXGroup section */
+		DC8F288413579EFF005B8862 = {
+			isa = PBXGroup;
+			children = (
+				DC8F289913579EFF005B8862 /* ReaderSample */,
+				DC8F28B31357A29D005B8862 /* ZBarSDK */,
+				DC8F289213579EFF005B8862 /* Frameworks */,
+				DC8F289013579EFF005B8862 /* Products */,
+			);
+			sourceTree = "<group>";
+		};
+		DC8F289013579EFF005B8862 /* Products */ = {
+			isa = PBXGroup;
+			children = (
+				DC8F288F13579EFF005B8862 /* ReaderSample.app */,
+			);
+			name = Products;
+			sourceTree = "<group>";
+		};
+		DC8F289213579EFF005B8862 /* Frameworks */ = {
+			isa = PBXGroup;
+			children = (
+				DC8F289313579EFF005B8862 /* UIKit.framework */,
+				DC8F289513579EFF005B8862 /* Foundation.framework */,
+				DC8F289713579EFF005B8862 /* CoreGraphics.framework */,
+				DC8F28D91357A42E005B8862 /* QuartzCore.framework */,
+				DC8F28D61357A42E005B8862 /* CoreMedia.framework */,
+				DC8F28D71357A42E005B8862 /* CoreVideo.framework */,
+				DC8F28D51357A42E005B8862 /* AVFoundation.framework */,
+				DC8F28D81357A42E005B8862 /* libiconv.dylib */,
+			);
+			name = Frameworks;
+			sourceTree = "<group>";
+		};
+		DC8F289913579EFF005B8862 /* ReaderSample */ = {
+			isa = PBXGroup;
+			children = (
+				DC8F28A213579EFF005B8862 /* ReaderSampleAppDelegate.h */,
+				DC8F28A313579EFF005B8862 /* ReaderSampleAppDelegate.m */,
+				DC8F28A513579EFF005B8862 /* MainWindow.xib */,
+				DC8F28A813579EFF005B8862 /* ReaderSampleViewController.h */,
+				DC8F28A913579EFF005B8862 /* ReaderSampleViewController.m */,
+				DC8F28AB13579EFF005B8862 /* ReaderSampleViewController.xib */,
+				DC8F289A13579EFF005B8862 /* Supporting Files */,
+			);
+			path = ReaderSample;
+			sourceTree = "<group>";
+		};
+		DC8F289A13579EFF005B8862 /* Supporting Files */ = {
+			isa = PBXGroup;
+			children = (
+				DC8F289B13579EFF005B8862 /* ReaderSample-Info.plist */,
+				DC8F289C13579EFF005B8862 /* InfoPlist.strings */,
+				DC8245F4162B549F0010B2E6 /* Default-568h@2x.png */,
+				DC8F289F13579EFF005B8862 /* ReaderSample-Prefix.pch */,
+				DC8F28A013579EFF005B8862 /* main.m */,
+			);
+			name = "Supporting Files";
+			sourceTree = "<group>";
+		};
+		DC8F28B31357A29D005B8862 /* ZBarSDK */ = {
+			isa = PBXGroup;
+			children = (
+				DC8F28B41357A29D005B8862 /* Headers */,
+				DC8F28CA1357A29D005B8862 /* libzbar.a */,
+				DC8F28CB1357A29D005B8862 /* Resources */,
+			);
+			path = ZBarSDK;
+			sourceTree = "<group>";
+		};
+		DC8F28B41357A29D005B8862 /* Headers */ = {
+			isa = PBXGroup;
+			children = (
+				DC8F28B51357A29D005B8862 /* ZBarSDK */,
+			);
+			path = Headers;
+			sourceTree = "<group>";
+		};
+		DC8F28B51357A29D005B8862 /* ZBarSDK */ = {
+			isa = PBXGroup;
+			children = (
+				DC8F28B61357A29D005B8862 /* zbar */,
+				DC8F28C01357A29D005B8862 /* zbar.h */,
+				DC8F28C11357A29D005B8862 /* ZBarCaptureReader.h */,
+				DC8F28C21357A29D005B8862 /* ZBarHelpController.h */,
+				DC8F28C31357A29D005B8862 /* ZBarImage.h */,
+				DC8F28C41357A29D005B8862 /* ZBarImageScanner.h */,
+				DC8F28C51357A29D005B8862 /* ZBarReaderController.h */,
+				DC8F28C61357A29D005B8862 /* ZBarReaderView.h */,
+				DC8F28C71357A29D005B8862 /* ZBarReaderViewController.h */,
+				DC8F28C81357A29D005B8862 /* ZBarSDK.h */,
+				DC8F28C91357A29D005B8862 /* ZBarSymbol.h */,
+			);
+			path = ZBarSDK;
+			sourceTree = "<group>";
+		};
+		DC8F28B61357A29D005B8862 /* zbar */ = {
+			isa = PBXGroup;
+			children = (
+				DC8F28B71357A29D005B8862 /* Decoder.h */,
+				DC8F28B81357A29D005B8862 /* Exception.h */,
+				DC8F28B91357A29D005B8862 /* Image.h */,
+				DC8F28BA1357A29D005B8862 /* ImageScanner.h */,
+				DC8F28BB1357A29D005B8862 /* Processor.h */,
+				DC8F28BC1357A29D005B8862 /* Scanner.h */,
+				DC8F28BD1357A29D005B8862 /* Symbol.h */,
+				DC8F28BE1357A29D005B8862 /* Video.h */,
+				DC8F28BF1357A29D005B8862 /* Window.h */,
+			);
+			path = zbar;
+			sourceTree = "<group>";
+		};
+		DC8F28CB1357A29D005B8862 /* Resources */ = {
+			isa = PBXGroup;
+			children = (
+				DC8F28CC1357A29D005B8862 /* zbar-back.png */,
+				DC8F28CD1357A29D005B8862 /* zbar-help.html */,
+				DC8F28CE1357A29D005B8862 /* zbar-helpicons.png */,
+				DC8F28CF1357A29D005B8862 /* zbar-samples.png */,
+			);
+			path = Resources;
+			sourceTree = "<group>";
+		};
+/* End PBXGroup section */
+
+/* Begin PBXNativeTarget section */
+		DC8F288E13579EFF005B8862 /* ReaderSample */ = {
+			isa = PBXNativeTarget;
+			buildConfigurationList = DC8F28B013579F00005B8862 /* Build configuration list for PBXNativeTarget "ReaderSample" */;
+			buildPhases = (
+				DC8F288B13579EFF005B8862 /* Sources */,
+				DC8F288C13579EFF005B8862 /* Frameworks */,
+				DC8F288D13579EFF005B8862 /* Resources */,
+			);
+			buildRules = (
+			);
+			dependencies = (
+			);
+			name = ReaderSample;
+			productName = ReaderSample;
+			productReference = DC8F288F13579EFF005B8862 /* ReaderSample.app */;
+			productType = "com.apple.product-type.application";
+		};
+/* End PBXNativeTarget section */
+
+/* Begin PBXProject section */
+		DC8F288613579EFF005B8862 /* Project object */ = {
+			isa = PBXProject;
+			attributes = {
+				ORGANIZATIONNAME = "ZBar Consulting Services";
+			};
+			buildConfigurationList = DC8F288913579EFF005B8862 /* Build configuration list for PBXProject "ReaderSample" */;
+			compatibilityVersion = "Xcode 3.2";
+			developmentRegion = English;
+			hasScannedForEncodings = 0;
+			knownRegions = (
+				en,
+			);
+			mainGroup = DC8F288413579EFF005B8862;
+			productRefGroup = DC8F289013579EFF005B8862 /* Products */;
+			projectDirPath = "";
+			projectRoot = "";
+			targets = (
+				DC8F288E13579EFF005B8862 /* ReaderSample */,
+			);
+		};
+/* End PBXProject section */
+
+/* Begin PBXResourcesBuildPhase section */
+		DC8F288D13579EFF005B8862 /* Resources */ = {
+			isa = PBXResourcesBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				DC8F289E13579EFF005B8862 /* InfoPlist.strings in Resources */,
+				DC8F28A713579EFF005B8862 /* MainWindow.xib in Resources */,
+				DC8F28AD13579F00005B8862 /* ReaderSampleViewController.xib in Resources */,
+				DC8F28D11357A29D005B8862 /* zbar-back.png in Resources */,
+				DC8F28D21357A29D005B8862 /* zbar-help.html in Resources */,
+				DC8F28D31357A29D005B8862 /* zbar-helpicons.png in Resources */,
+				DC8F28D41357A29D005B8862 /* zbar-samples.png in Resources */,
+				DC8245F5162B549F0010B2E6 /* Default-568h@2x.png in Resources */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+/* End PBXResourcesBuildPhase section */
+
+/* Begin PBXSourcesBuildPhase section */
+		DC8F288B13579EFF005B8862 /* Sources */ = {
+			isa = PBXSourcesBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				DC8F28A113579EFF005B8862 /* main.m in Sources */,
+				DC8F28A413579EFF005B8862 /* ReaderSampleAppDelegate.m in Sources */,
+				DC8F28AA13579EFF005B8862 /* ReaderSampleViewController.m in Sources */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+/* End PBXSourcesBuildPhase section */
+
+/* Begin PBXVariantGroup section */
+		DC8F289C13579EFF005B8862 /* InfoPlist.strings */ = {
+			isa = PBXVariantGroup;
+			children = (
+				DC8F289D13579EFF005B8862 /* en */,
+			);
+			name = InfoPlist.strings;
+			sourceTree = "<group>";
+		};
+		DC8F28A513579EFF005B8862 /* MainWindow.xib */ = {
+			isa = PBXVariantGroup;
+			children = (
+				DC8F28A613579EFF005B8862 /* en */,
+			);
+			name = MainWindow.xib;
+			sourceTree = "<group>";
+		};
+		DC8F28AB13579EFF005B8862 /* ReaderSampleViewController.xib */ = {
+			isa = PBXVariantGroup;
+			children = (
+				DC8F28AC13579F00005B8862 /* en */,
+			);
+			name = ReaderSampleViewController.xib;
+			sourceTree = "<group>";
+		};
+/* End PBXVariantGroup section */
+
+/* Begin XCBuildConfiguration section */
+		DC8F28AE13579F00005B8862 /* Debug */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				ARCHS = "$(ARCHS_STANDARD_32_BIT)";
+				"CODE_SIGN_IDENTITY[sdk=iphoneos*]" = "iPhone Developer";
+				GCC_C_LANGUAGE_STANDARD = gnu99;
+				GCC_OPTIMIZATION_LEVEL = 0;
+				GCC_PREPROCESSOR_DEFINITIONS = DEBUG;
+				GCC_SYMBOLS_PRIVATE_EXTERN = NO;
+				GCC_VERSION = com.apple.compilers.llvmgcc42;
+				GCC_WARN_ABOUT_RETURN_TYPE = YES;
+				GCC_WARN_UNUSED_VARIABLE = YES;
+				IPHONEOS_DEPLOYMENT_TARGET = 4.0;
+				SDKROOT = iphoneos;
+			};
+			name = Debug;
+		};
+		DC8F28AF13579F00005B8862 /* Release */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				ARCHS = "$(ARCHS_STANDARD_32_BIT)";
+				"CODE_SIGN_IDENTITY[sdk=iphoneos*]" = "iPhone Developer";
+				GCC_C_LANGUAGE_STANDARD = gnu99;
+				GCC_VERSION = com.apple.compilers.llvmgcc42;
+				GCC_WARN_ABOUT_RETURN_TYPE = YES;
+				GCC_WARN_UNUSED_VARIABLE = YES;
+				IPHONEOS_DEPLOYMENT_TARGET = 4.0;
+				OTHER_CFLAGS = "-DNS_BLOCK_ASSERTIONS=1";
+				SDKROOT = iphoneos;
+			};
+			name = Release;
+		};
+		DC8F28B113579F00005B8862 /* Debug */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				ALWAYS_SEARCH_USER_PATHS = NO;
+				COPY_PHASE_STRIP = NO;
+				GCC_DYNAMIC_NO_PIC = NO;
+				GCC_PRECOMPILE_PREFIX_HEADER = YES;
+				GCC_PREFIX_HEADER = "ReaderSample/ReaderSample-Prefix.pch";
+				INFOPLIST_FILE = "ReaderSample/ReaderSample-Info.plist";
+				LIBRARY_SEARCH_PATHS = (
+					"$(inherited)",
+					"\"$(SRCROOT)/ZBarSDK\"",
+				);
+				PRODUCT_NAME = "$(TARGET_NAME)";
+				TARGETED_DEVICE_FAMILY = "1,2";
+				WRAPPER_EXTENSION = app;
+			};
+			name = Debug;
+		};
+		DC8F28B213579F00005B8862 /* Release */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				ALWAYS_SEARCH_USER_PATHS = NO;
+				COPY_PHASE_STRIP = YES;
+				GCC_PRECOMPILE_PREFIX_HEADER = YES;
+				GCC_PREFIX_HEADER = "ReaderSample/ReaderSample-Prefix.pch";
+				INFOPLIST_FILE = "ReaderSample/ReaderSample-Info.plist";
+				LIBRARY_SEARCH_PATHS = (
+					"$(inherited)",
+					"\"$(SRCROOT)/ZBarSDK\"",
+				);
+				PRODUCT_NAME = "$(TARGET_NAME)";
+				TARGETED_DEVICE_FAMILY = "1,2";
+				VALIDATE_PRODUCT = YES;
+				WRAPPER_EXTENSION = app;
+			};
+			name = Release;
+		};
+/* End XCBuildConfiguration section */
+
+/* Begin XCConfigurationList section */
+		DC8F288913579EFF005B8862 /* Build configuration list for PBXProject "ReaderSample" */ = {
+			isa = XCConfigurationList;
+			buildConfigurations = (
+				DC8F28AE13579F00005B8862 /* Debug */,
+				DC8F28AF13579F00005B8862 /* Release */,
+			);
+			defaultConfigurationIsVisible = 0;
+			defaultConfigurationName = Release;
+		};
+		DC8F28B013579F00005B8862 /* Build configuration list for PBXNativeTarget "ReaderSample" */ = {
+			isa = XCConfigurationList;
+			buildConfigurations = (
+				DC8F28B113579F00005B8862 /* Debug */,
+				DC8F28B213579F00005B8862 /* Release */,
+			);
+			defaultConfigurationIsVisible = 0;
+			defaultConfigurationName = Release;
+		};
+/* End XCConfigurationList section */
+	};
+	rootObject = DC8F288613579EFF005B8862 /* Project object */;
+}
diff -r 563557a923d0 iphone/examples/ReaderSample/ReaderSample.xcodeproj/xcshareddata/xcschemes/ReaderSample.xcscheme
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/examples/ReaderSample/ReaderSample.xcodeproj/xcshareddata/xcschemes/ReaderSample.xcscheme	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,76 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<Scheme
+   version = "1.3">
+   <BuildAction
+      parallelizeBuildables = "YES"
+      buildImplicitDependencies = "YES">
+      <BuildActionEntries>
+         <BuildActionEntry
+            buildForTesting = "YES"
+            buildForRunning = "YES"
+            buildForProfiling = "YES"
+            buildForArchiving = "YES"
+            buildForAnalyzing = "YES">
+            <BuildableReference
+               BuildableIdentifier = "primary"
+               BlueprintIdentifier = "DC8F288E13579EFF005B8862"
+               BuildableName = "ReaderSample.app"
+               BlueprintName = "ReaderSample"
+               ReferencedContainer = "container:ReaderSample.xcodeproj">
+            </BuildableReference>
+         </BuildActionEntry>
+      </BuildActionEntries>
+   </BuildAction>
+   <TestAction
+      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.GDB"
+      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.GDB"
+      shouldUseLaunchSchemeArgsEnv = "YES"
+      buildConfiguration = "Debug">
+      <Testables>
+      </Testables>
+   </TestAction>
+   <LaunchAction
+      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.GDB"
+      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.GDB"
+      displayScaleIsEnabled = "NO"
+      displayScale = "1.00"
+      launchStyle = "0"
+      useCustomWorkingDirectory = "NO"
+      buildConfiguration = "Debug">
+      <BuildableProductRunnable>
+         <BuildableReference
+            BuildableIdentifier = "primary"
+            BlueprintIdentifier = "DC8F288E13579EFF005B8862"
+            BuildableName = "ReaderSample.app"
+            BlueprintName = "ReaderSample"
+            ReferencedContainer = "container:ReaderSample.xcodeproj">
+         </BuildableReference>
+      </BuildableProductRunnable>
+      <AdditionalOptions>
+      </AdditionalOptions>
+   </LaunchAction>
+   <ProfileAction
+      displayScaleIsEnabled = "NO"
+      displayScale = "1.00"
+      shouldUseLaunchSchemeArgsEnv = "YES"
+      savedToolIdentifier = ""
+      useCustomWorkingDirectory = "NO"
+      buildConfiguration = "Release">
+      <BuildableProductRunnable>
+         <BuildableReference
+            BuildableIdentifier = "primary"
+            BlueprintIdentifier = "DC8F288E13579EFF005B8862"
+            BuildableName = "ReaderSample.app"
+            BlueprintName = "ReaderSample"
+            ReferencedContainer = "container:ReaderSample.xcodeproj">
+         </BuildableReference>
+      </BuildableProductRunnable>
+   </ProfileAction>
+   <AnalyzeAction
+      buildConfiguration = "Debug">
+   </AnalyzeAction>
+   <ArchiveAction
+      buildConfiguration = "Release"
+      revealArchiveInOrganizer = "YES">
+   </ArchiveAction>
+</Scheme>
diff -r 563557a923d0 iphone/examples/ReaderSample/ReaderSample/ReaderSample-Info.plist
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/examples/ReaderSample/ReaderSample/ReaderSample-Info.plist	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,38 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
+<plist version="1.0">
+<dict>
+	<key>CFBundleDevelopmentRegion</key>
+	<string>en</string>
+	<key>CFBundleDisplayName</key>
+	<string>${PRODUCT_NAME}</string>
+	<key>CFBundleExecutable</key>
+	<string>${EXECUTABLE_NAME}</string>
+	<key>CFBundleIconFile</key>
+	<string></string>
+	<key>CFBundleIdentifier</key>
+	<string>com.yourcompany.${PRODUCT_NAME:rfc1034identifier}</string>
+	<key>CFBundleInfoDictionaryVersion</key>
+	<string>6.0</string>
+	<key>CFBundleName</key>
+	<string>${PRODUCT_NAME}</string>
+	<key>CFBundlePackageType</key>
+	<string>APPL</string>
+	<key>CFBundleShortVersionString</key>
+	<string>1.0</string>
+	<key>CFBundleSignature</key>
+	<string>????</string>
+	<key>CFBundleVersion</key>
+	<string>1.0</string>
+	<key>LSRequiresIPhoneOS</key>
+	<true/>
+	<key>NSMainNibFile</key>
+	<string>MainWindow</string>
+	<key>UISupportedInterfaceOrientations</key>
+	<array>
+		<string>UIInterfaceOrientationPortrait</string>
+		<string>UIInterfaceOrientationLandscapeLeft</string>
+		<string>UIInterfaceOrientationLandscapeRight</string>
+	</array>
+</dict>
+</plist>
diff -r 563557a923d0 iphone/examples/ReaderSample/ReaderSample/ReaderSample-Prefix.pch
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/examples/ReaderSample/ReaderSample/ReaderSample-Prefix.pch	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,16 @@
+//
+// Prefix header for all source files of the 'ReaderSample' target in the 'ReaderSample' project
+//
+
+#import <Availability.h>
+
+#ifndef __IPHONE_3_0
+#warning "This project uses features only available in iPhone SDK 3.0 and later."
+#endif
+
+#ifdef __OBJC__
+    #import <UIKit/UIKit.h>
+    #import <Foundation/Foundation.h>
+    // ADD: import barcode reader APIs
+    #import "ZBarSDK.h"
+#endif
diff -r 563557a923d0 iphone/examples/ReaderSample/ReaderSample/ReaderSampleAppDelegate.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/examples/ReaderSample/ReaderSample/ReaderSampleAppDelegate.h	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,20 @@
+//
+//  ReaderSampleAppDelegate.h
+//  ReaderSample
+//
+//  Created by spadix on 4/14/11.
+//
+
+#import <UIKit/UIKit.h>
+
+@class ReaderSampleViewController;
+
+@interface ReaderSampleAppDelegate : NSObject <UIApplicationDelegate> {
+
+}
+
+@property (nonatomic, retain) IBOutlet UIWindow *window;
+
+@property (nonatomic, retain) IBOutlet ReaderSampleViewController *viewController;
+
+@end
diff -r 563557a923d0 iphone/examples/ReaderSample/ReaderSample/ReaderSampleAppDelegate.m
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/examples/ReaderSample/ReaderSample/ReaderSampleAppDelegate.m	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,67 @@
+//
+//  ReaderSampleAppDelegate.m
+//  ReaderSample
+//
+//  Created by spadix on 4/14/11.
+//
+
+#import "ReaderSampleAppDelegate.h"
+
+#import "ReaderSampleViewController.h"
+
+@implementation ReaderSampleAppDelegate
+
+
+@synthesize window=_window;
+
+@synthesize viewController=_viewController;
+
+- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
+{
+    // Override point for customization after application launch.
+     
+    self.window.rootViewController = self.viewController;
+    [self.window makeKeyAndVisible];
+    return YES;
+}
+
+- (void)applicationWillResignActive:(UIApplication *)application
+{
+    /*
+     Sent when the application is about to move from active to inactive state. This can occur for certain types of temporary interruptions (such as an incoming phone call or SMS message) or when the user quits the application and it begins the transition to the background state.
+     Use this method to pause ongoing tasks, disable timers, and throttle down OpenGL ES frame rates. Games should use this method to pause the game.
+     */
+}
+
+- (void)applicationDidEnterBackground:(UIApplication *)application
+{
+    /*
+     Use this method to release shared resources, save user data, invalidate timers, and store enough application state information to restore your application to its current state in case it is terminated later. 
+     If your application supports background execution, this method is called instead of applicationWillTerminate: when the user quits.
+     */
+}
+
+- (void)applicationWillEnterForeground:(UIApplication *)application
+{
+    /*
+     Called as part of the transition from the background to the inactive state; here you can undo many of the changes made on entering the background.
+     */
+}
+
+- (void)applicationDidBecomeActive:(UIApplication *)application
+{
+    /*
+     Restart any tasks that were paused (or not yet started) while the application was inactive. If the application was previously in the background, optionally refresh the user interface.
+     */
+}
+
+- (void)applicationWillTerminate:(UIApplication *)application
+{
+    /*
+     Called when the application is about to terminate.
+     Save data if appropriate.
+     See also applicationDidEnterBackground:.
+     */
+}
+
+@end
diff -r 563557a923d0 iphone/examples/ReaderSample/ReaderSample/ReaderSampleViewController.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/examples/ReaderSample/ReaderSample/ReaderSampleViewController.h	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,21 @@
+//
+//  ReaderSampleViewController.h
+//  ReaderSample
+//
+//  Created by spadix on 4/14/11.
+//
+
+#import <UIKit/UIKit.h>
+
+@interface ReaderSampleViewController
+    : UIViewController
+    // ADD: delegate protocol
+    < ZBarReaderDelegate >
+{
+    UIImageView *resultImage;
+    UITextView *resultText;
+}
+@property (nonatomic, retain) IBOutlet UIImageView *resultImage;
+@property (nonatomic, retain) IBOutlet UITextView *resultText;
+- (IBAction) scanButtonTapped;
+@end
diff -r 563557a923d0 iphone/examples/ReaderSample/ReaderSample/ReaderSampleViewController.m
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/examples/ReaderSample/ReaderSample/ReaderSampleViewController.m	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,68 @@
+//
+//  ReaderSampleViewController.m
+//  ReaderSample
+//
+//  Created by spadix on 4/14/11.
+//
+
+#import "ReaderSampleViewController.h"
+
+@implementation ReaderSampleViewController
+
+@synthesize resultImage, resultText;
+
+- (IBAction) scanButtonTapped
+{
+    // ADD: present a barcode reader that scans from the camera feed
+    ZBarReaderViewController *reader = [[ZBarReaderViewController alloc] init];
+    reader.readerDelegate = self;
+    reader.supportedOrientationsMask = ZBarOrientationMaskAll;
+
+    ZBarImageScanner *scanner = reader.scanner;
+    // TODO: (optional) additional reader configuration here
+
+    // EXAMPLE: disable rarely used I2/5 to improve performance
+    [scanner setSymbology: ZBAR_I25
+                   config: ZBAR_CFG_ENABLE
+                       to: 0];
+
+    // present and release the controller
+    [self presentModalViewController: reader
+                            animated: YES];
+    [reader release];
+}
+
+- (void) imagePickerController: (UIImagePickerController*) reader
+ didFinishPickingMediaWithInfo: (NSDictionary*) info
+{
+    // ADD: get the decode results
+    id<NSFastEnumeration> results =
+    [info objectForKey: ZBarReaderControllerResults];
+    ZBarSymbol *symbol = nil;
+    for(symbol in results)
+        // EXAMPLE: just grab the first barcode
+        break;
+
+    // EXAMPLE: do something useful with the barcode data
+    resultText.text = symbol.data;
+
+    // EXAMPLE: do something useful with the barcode image
+    resultImage.image =
+    [info objectForKey: UIImagePickerControllerOriginalImage];
+
+    // ADD: dismiss the controller (NB dismiss from the *reader*!)
+    [reader dismissModalViewControllerAnimated: YES];
+}
+
+- (BOOL) shouldAutorotateToInterfaceOrientation: (UIInterfaceOrientation) orient
+{
+    return(YES);
+}
+
+- (void) dealloc {
+    self.resultImage = nil;
+    self.resultText = nil;
+    [super dealloc];
+}
+
+@end
diff -r 563557a923d0 iphone/examples/ReaderSample/ReaderSample/en.lproj/InfoPlist.strings
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/examples/ReaderSample/ReaderSample/en.lproj/InfoPlist.strings	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,2 @@
+/* Localized versions of Info.plist keys */
+
diff -r 563557a923d0 iphone/examples/ReaderSample/ReaderSample/en.lproj/MainWindow.xib
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/examples/ReaderSample/ReaderSample/en.lproj/MainWindow.xib	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,444 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<archive type="com.apple.InterfaceBuilder3.CocoaTouch.XIB" version="7.10">
+	<data>
+		<int key="IBDocument.SystemTarget">1024</int>
+		<string key="IBDocument.SystemVersion">10D571</string>
+		<string key="IBDocument.InterfaceBuilderVersion">786</string>
+		<string key="IBDocument.AppKitVersion">1038.29</string>
+		<string key="IBDocument.HIToolboxVersion">460.00</string>
+		<object class="NSMutableDictionary" key="IBDocument.PluginVersions">
+			<string key="NS.key.0">com.apple.InterfaceBuilder.IBCocoaTouchPlugin</string>
+			<string key="NS.object.0">112</string>
+		</object>
+		<object class="NSMutableArray" key="IBDocument.EditedObjectIDs">
+			<bool key="EncodedWithXMLCoder">YES</bool>
+			<integer value="10"/>
+		</object>
+		<object class="NSArray" key="IBDocument.PluginDependencies">
+			<bool key="EncodedWithXMLCoder">YES</bool>
+			<string>com.apple.InterfaceBuilder.IBCocoaTouchPlugin</string>
+		</object>
+		<object class="NSMutableDictionary" key="IBDocument.Metadata">
+			<bool key="EncodedWithXMLCoder">YES</bool>
+			<object class="NSArray" key="dict.sortedKeys" id="0">
+				<bool key="EncodedWithXMLCoder">YES</bool>
+			</object>
+			<object class="NSMutableArray" key="dict.values">
+				<bool key="EncodedWithXMLCoder">YES</bool>
+			</object>
+		</object>
+		<object class="NSMutableArray" key="IBDocument.RootObjects" id="1000">
+			<bool key="EncodedWithXMLCoder">YES</bool>
+			<object class="IBProxyObject" id="841351856">
+				<string key="IBProxiedObjectIdentifier">IBFilesOwner</string>
+				<string key="targetRuntimeIdentifier">IBCocoaTouchFramework</string>
+			</object>
+			<object class="IBProxyObject" id="427554174">
+				<string key="IBProxiedObjectIdentifier">IBFirstResponder</string>
+				<string key="targetRuntimeIdentifier">IBCocoaTouchFramework</string>
+			</object>
+			<object class="IBUICustomObject" id="664661524">
+				<string key="targetRuntimeIdentifier">IBCocoaTouchFramework</string>
+			</object>
+			<object class="IBUIViewController" id="943309135">
+				<string key="IBUINibName">ReaderSampleViewController</string>
+				<object class="IBUISimulatedStatusBarMetrics" key="IBUISimulatedStatusBarMetrics"/>
+				<object class="IBUISimulatedOrientationMetrics" key="IBUISimulatedOrientationMetrics">
+					<int key="interfaceOrientation">1</int>
+				</object>
+				<string key="targetRuntimeIdentifier">IBCocoaTouchFramework</string>
+				<bool key="IBUIHorizontal">NO</bool>
+			</object>
+			<object class="IBUIWindow" id="117978783">
+				<nil key="NSNextResponder"/>
+				<int key="NSvFlags">292</int>
+				<string key="NSFrameSize">{320, 480}</string>
+				<object class="NSColor" key="IBUIBackgroundColor">
+					<int key="NSColorSpace">1</int>
+					<bytes key="NSRGB">MSAxIDEAA</bytes>
+				</object>
+				<bool key="IBUIOpaque">NO</bool>
+				<bool key="IBUIClearsContextBeforeDrawing">NO</bool>
+				<object class="IBUISimulatedStatusBarMetrics" key="IBUISimulatedStatusBarMetrics"/>
+				<string key="targetRuntimeIdentifier">IBCocoaTouchFramework</string>
+				<bool key="IBUIResizesToFullScreen">YES</bool>
+			</object>
+		</object>
+		<object class="IBObjectContainer" key="IBDocument.Objects">
+			<object class="NSMutableArray" key="connectionRecords">
+				<bool key="EncodedWithXMLCoder">YES</bool>
+				<object class="IBConnectionRecord">
+					<object class="IBCocoaTouchOutletConnection" key="connection">
+						<string key="label">delegate</string>
+						<reference key="source" ref="841351856"/>
+						<reference key="destination" ref="664661524"/>
+					</object>
+					<int key="connectionID">4</int>
+				</object>
+				<object class="IBConnectionRecord">
+					<object class="IBCocoaTouchOutletConnection" key="connection">
+						<string key="label">viewController</string>
+						<reference key="source" ref="664661524"/>
+						<reference key="destination" ref="943309135"/>
+					</object>
+					<int key="connectionID">11</int>
+				</object>
+				<object class="IBConnectionRecord">
+					<object class="IBCocoaTouchOutletConnection" key="connection">
+						<string key="label">window</string>
+						<reference key="source" ref="664661524"/>
+						<reference key="destination" ref="117978783"/>
+					</object>
+					<int key="connectionID">14</int>
+				</object>
+			</object>
+			<object class="IBMutableOrderedSet" key="objectRecords">
+				<object class="NSArray" key="orderedObjects">
+					<bool key="EncodedWithXMLCoder">YES</bool>
+					<object class="IBObjectRecord">
+						<int key="objectID">0</int>
+						<reference key="object" ref="0"/>
+						<reference key="children" ref="1000"/>
+						<nil key="parent"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">-1</int>
+						<reference key="object" ref="841351856"/>
+						<reference key="parent" ref="0"/>
+						<string key="objectName">File's Owner</string>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">3</int>
+						<reference key="object" ref="664661524"/>
+						<reference key="parent" ref="0"/>
+						<string key="objectName">ReaderSample App Delegate</string>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">-2</int>
+						<reference key="object" ref="427554174"/>
+						<reference key="parent" ref="0"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">10</int>
+						<reference key="object" ref="943309135"/>
+						<reference key="parent" ref="0"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">12</int>
+						<reference key="object" ref="117978783"/>
+						<reference key="parent" ref="0"/>
+					</object>
+				</object>
+			</object>
+			<object class="NSMutableDictionary" key="flattenedProperties">
+				<bool key="EncodedWithXMLCoder">YES</bool>
+				<object class="NSArray" key="dict.sortedKeys">
+					<bool key="EncodedWithXMLCoder">YES</bool>
+					<string>-1.CustomClassName</string>
+					<string>-2.CustomClassName</string>
+					<string>10.CustomClassName</string>
+					<string>10.IBEditorWindowLastContentRect</string>
+					<string>10.IBPluginDependency</string>
+					<string>12.IBEditorWindowLastContentRect</string>
+					<string>12.IBPluginDependency</string>
+					<string>3.CustomClassName</string>
+					<string>3.IBPluginDependency</string>
+				</object>
+				<object class="NSMutableArray" key="dict.values">
+					<bool key="EncodedWithXMLCoder">YES</bool>
+					<string>UIApplication</string>
+					<string>UIResponder</string>
+					<string>ReaderSampleViewController</string>
+					<string>{{234, 376}, {320, 480}}</string>
+					<string>com.apple.InterfaceBuilder.IBCocoaTouchPlugin</string>
+					<string>{{525, 346}, {320, 480}}</string>
+					<string>com.apple.InterfaceBuilder.IBCocoaTouchPlugin</string>
+					<string>ReaderSampleAppDelegate</string>
+					<string>com.apple.InterfaceBuilder.IBCocoaTouchPlugin</string>
+				</object>
+			</object>
+			<object class="NSMutableDictionary" key="unlocalizedProperties">
+				<bool key="EncodedWithXMLCoder">YES</bool>
+				<reference key="dict.sortedKeys" ref="0"/>
+				<object class="NSMutableArray" key="dict.values">
+					<bool key="EncodedWithXMLCoder">YES</bool>
+				</object>
+			</object>
+			<nil key="activeLocalization"/>
+			<object class="NSMutableDictionary" key="localizations">
+				<bool key="EncodedWithXMLCoder">YES</bool>
+				<reference key="dict.sortedKeys" ref="0"/>
+				<object class="NSMutableArray" key="dict.values">
+					<bool key="EncodedWithXMLCoder">YES</bool>
+				</object>
+			</object>
+			<nil key="sourceID"/>
+			<int key="maxID">15</int>
+		</object>
+		<object class="IBClassDescriber" key="IBDocument.Classes">
+			<object class="NSMutableArray" key="referencedPartialClassDescriptions">
+				<bool key="EncodedWithXMLCoder">YES</bool>
+				<object class="IBPartialClassDescription">
+					<string key="className">UIWindow</string>
+					<string key="superclassName">UIView</string>
+					<object class="IBClassDescriptionSource" key="sourceIdentifier">
+						<string key="majorKey">IBUserSource</string>
+						<string key="minorKey"/>
+					</object>
+				</object>
+				<object class="IBPartialClassDescription">
+					<string key="className">ReaderSampleAppDelegate</string>
+					<string key="superclassName">NSObject</string>
+					<object class="NSMutableDictionary" key="outlets">
+						<bool key="EncodedWithXMLCoder">YES</bool>
+						<object class="NSArray" key="dict.sortedKeys">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<string>viewController</string>
+							<string>window</string>
+						</object>
+						<object class="NSMutableArray" key="dict.values">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<string>ReaderSampleViewController</string>
+							<string>UIWindow</string>
+						</object>
+					</object>
+					<object class="NSMutableDictionary" key="toOneOutletInfosByName">
+						<bool key="EncodedWithXMLCoder">YES</bool>
+						<object class="NSArray" key="dict.sortedKeys">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<string>viewController</string>
+							<string>window</string>
+						</object>
+						<object class="NSMutableArray" key="dict.values">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<object class="IBToOneOutletInfo">
+								<string key="name">viewController</string>
+								<string key="candidateClassName">ReaderSampleViewController</string>
+							</object>
+							<object class="IBToOneOutletInfo">
+								<string key="name">window</string>
+								<string key="candidateClassName">UIWindow</string>
+							</object>
+						</object>
+					</object>
+					<object class="IBClassDescriptionSource" key="sourceIdentifier">
+						<string key="majorKey">IBProjectSource</string>
+						<string key="minorKey">ReaderSampleAppDelegate.h</string>
+					</object>
+				</object>
+				<object class="IBPartialClassDescription">
+					<string key="className">ReaderSampleAppDelegate</string>
+					<string key="superclassName">NSObject</string>
+					<object class="IBClassDescriptionSource" key="sourceIdentifier">
+						<string key="majorKey">IBUserSource</string>
+						<string key="minorKey"/>
+					</object>
+				</object>
+				<object class="IBPartialClassDescription">
+					<string key="className">ReaderSampleViewController</string>
+					<string key="superclassName">UIViewController</string>
+					<object class="IBClassDescriptionSource" key="sourceIdentifier">
+						<string key="majorKey">IBProjectSource</string>
+						<string key="minorKey">ReaderSampleViewController.h</string>
+					</object>
+				</object>
+			</object>
+			<object class="NSMutableArray" key="referencedPartialClassDescriptionsV3.2+">
+				<bool key="EncodedWithXMLCoder">YES</bool>
+				<object class="IBPartialClassDescription">
+					<string key="className">NSObject</string>
+					<object class="IBClassDescriptionSource" key="sourceIdentifier">
+						<string key="majorKey">IBFrameworkSource</string>
+						<string key="minorKey">Foundation.framework/Headers/NSError.h</string>
+					</object>
+				</object>
+				<object class="IBPartialClassDescription">
+					<string key="className">NSObject</string>
+					<object class="IBClassDescriptionSource" key="sourceIdentifier">
+						<string key="majorKey">IBFrameworkSource</string>
+						<string key="minorKey">Foundation.framework/Headers/NSFileManager.h</string>
+					</object>
+				</object>
+				<object class="IBPartialClassDescription">
+					<string key="className">NSObject</string>
+					<object class="IBClassDescriptionSource" key="sourceIdentifier">
+						<string key="majorKey">IBFrameworkSource</string>
+						<string key="minorKey">Foundation.framework/Headers/NSKeyValueCoding.h</string>
+					</object>
+				</object>
+				<object class="IBPartialClassDescription">
+					<string key="className">NSObject</string>
+					<object class="IBClassDescriptionSource" key="sourceIdentifier">
+						<string key="majorKey">IBFrameworkSource</string>
+						<string key="minorKey">Foundation.framework/Headers/NSKeyValueObserving.h</string>
+					</object>
+				</object>
+				<object class="IBPartialClassDescription">
+					<string key="className">NSObject</string>
+					<object class="IBClassDescriptionSource" key="sourceIdentifier">
+						<string key="majorKey">IBFrameworkSource</string>
+						<string key="minorKey">Foundation.framework/Headers/NSKeyedArchiver.h</string>
+					</object>
+				</object>
+				<object class="IBPartialClassDescription">
+					<string key="className">NSObject</string>
+					<object class="IBClassDescriptionSource" key="sourceIdentifier">
+						<string key="majorKey">IBFrameworkSource</string>
+						<string key="minorKey">Foundation.framework/Headers/NSObject.h</string>
+					</object>
+				</object>
+				<object class="IBPartialClassDescription">
+					<string key="className">NSObject</string>
+					<object class="IBClassDescriptionSource" key="sourceIdentifier">
+						<string key="majorKey">IBFrameworkSource</string>
+						<string key="minorKey">Foundation.framework/Headers/NSRunLoop.h</string>
+					</object>
+				</object>
+				<object class="IBPartialClassDescription">
+					<string key="className">NSObject</string>
+					<object class="IBClassDescriptionSource" key="sourceIdentifier">
+						<string key="majorKey">IBFrameworkSource</string>
+						<string key="minorKey">Foundation.framework/Headers/NSThread.h</string>
+					</object>
+				</object>
+				<object class="IBPartialClassDescription">
+					<string key="className">NSObject</string>
+					<object class="IBClassDescriptionSource" key="sourceIdentifier">
+						<string key="majorKey">IBFrameworkSource</string>
+						<string key="minorKey">Foundation.framework/Headers/NSURL.h</string>
+					</object>
+				</object>
+				<object class="IBPartialClassDescription">
+					<string key="className">NSObject</string>
+					<object class="IBClassDescriptionSource" key="sourceIdentifier">
+						<string key="majorKey">IBFrameworkSource</string>
+						<string key="minorKey">Foundation.framework/Headers/NSURLConnection.h</string>
+					</object>
+				</object>
+				<object class="IBPartialClassDescription">
+					<string key="className">NSObject</string>
+					<object class="IBClassDescriptionSource" key="sourceIdentifier">
+						<string key="majorKey">IBFrameworkSource</string>
+						<string key="minorKey">UIKit.framework/Headers/UIAccessibility.h</string>
+					</object>
+				</object>
+				<object class="IBPartialClassDescription">
+					<string key="className">NSObject</string>
+					<object class="IBClassDescriptionSource" key="sourceIdentifier">
+						<string key="majorKey">IBFrameworkSource</string>
+						<string key="minorKey">UIKit.framework/Headers/UINibLoading.h</string>
+					</object>
+				</object>
+				<object class="IBPartialClassDescription">
+					<string key="className">NSObject</string>
+					<object class="IBClassDescriptionSource" key="sourceIdentifier" id="356479594">
+						<string key="majorKey">IBFrameworkSource</string>
+						<string key="minorKey">UIKit.framework/Headers/UIResponder.h</string>
+					</object>
+				</object>
+				<object class="IBPartialClassDescription">
+					<string key="className">UIApplication</string>
+					<string key="superclassName">UIResponder</string>
+					<object class="IBClassDescriptionSource" key="sourceIdentifier">
+						<string key="majorKey">IBFrameworkSource</string>
+						<string key="minorKey">UIKit.framework/Headers/UIApplication.h</string>
+					</object>
+				</object>
+				<object class="IBPartialClassDescription">
+					<string key="className">UIResponder</string>
+					<string key="superclassName">NSObject</string>
+					<reference key="sourceIdentifier" ref="356479594"/>
+				</object>
+				<object class="IBPartialClassDescription">
+					<string key="className">UISearchBar</string>
+					<string key="superclassName">UIView</string>
+					<object class="IBClassDescriptionSource" key="sourceIdentifier">
+						<string key="majorKey">IBFrameworkSource</string>
+						<string key="minorKey">UIKit.framework/Headers/UISearchBar.h</string>
+					</object>
+				</object>
+				<object class="IBPartialClassDescription">
+					<string key="className">UISearchDisplayController</string>
+					<string key="superclassName">NSObject</string>
+					<object class="IBClassDescriptionSource" key="sourceIdentifier">
+						<string key="majorKey">IBFrameworkSource</string>
+						<string key="minorKey">UIKit.framework/Headers/UISearchDisplayController.h</string>
+					</object>
+				</object>
+				<object class="IBPartialClassDescription">
+					<string key="className">UIView</string>
+					<object class="IBClassDescriptionSource" key="sourceIdentifier">
+						<string key="majorKey">IBFrameworkSource</string>
+						<string key="minorKey">UIKit.framework/Headers/UITextField.h</string>
+					</object>
+				</object>
+				<object class="IBPartialClassDescription">
+					<string key="className">UIView</string>
+					<string key="superclassName">UIResponder</string>
+					<object class="IBClassDescriptionSource" key="sourceIdentifier">
+						<string key="majorKey">IBFrameworkSource</string>
+						<string key="minorKey">UIKit.framework/Headers/UIView.h</string>
+					</object>
+				</object>
+				<object class="IBPartialClassDescription">
+					<string key="className">UIViewController</string>
+					<object class="IBClassDescriptionSource" key="sourceIdentifier">
+						<string key="majorKey">IBFrameworkSource</string>
+						<string key="minorKey">UIKit.framework/Headers/UINavigationController.h</string>
+					</object>
+				</object>
+				<object class="IBPartialClassDescription">
+					<string key="className">UIViewController</string>
+					<object class="IBClassDescriptionSource" key="sourceIdentifier">
+						<string key="majorKey">IBFrameworkSource</string>
+						<string key="minorKey">UIKit.framework/Headers/UIPopoverController.h</string>
+					</object>
+				</object>
+				<object class="IBPartialClassDescription">
+					<string key="className">UIViewController</string>
+					<object class="IBClassDescriptionSource" key="sourceIdentifier">
+						<string key="majorKey">IBFrameworkSource</string>
+						<string key="minorKey">UIKit.framework/Headers/UISplitViewController.h</string>
+					</object>
+				</object>
+				<object class="IBPartialClassDescription">
+					<string key="className">UIViewController</string>
+					<object class="IBClassDescriptionSource" key="sourceIdentifier">
+						<string key="majorKey">IBFrameworkSource</string>
+						<string key="minorKey">UIKit.framework/Headers/UITabBarController.h</string>
+					</object>
+				</object>
+				<object class="IBPartialClassDescription">
+					<string key="className">UIViewController</string>
+					<string key="superclassName">UIResponder</string>
+					<object class="IBClassDescriptionSource" key="sourceIdentifier">
+						<string key="majorKey">IBFrameworkSource</string>
+						<string key="minorKey">UIKit.framework/Headers/UIViewController.h</string>
+					</object>
+				</object>
+				<object class="IBPartialClassDescription">
+					<string key="className">UIWindow</string>
+					<string key="superclassName">UIView</string>
+					<object class="IBClassDescriptionSource" key="sourceIdentifier">
+						<string key="majorKey">IBFrameworkSource</string>
+						<string key="minorKey">UIKit.framework/Headers/UIWindow.h</string>
+					</object>
+				</object>
+			</object>
+		</object>
+		<int key="IBDocument.localizationMode">0</int>
+		<string key="IBDocument.TargetRuntimeIdentifier">IBCocoaTouchFramework</string>
+		<object class="NSMutableDictionary" key="IBDocument.PluginDeclaredDependencyDefaults">
+			<string key="NS.key.0">com.apple.InterfaceBuilder.CocoaTouchPlugin.iPhoneOS</string>
+			<integer value="1024" key="NS.object.0"/>
+		</object>
+		<object class="NSMutableDictionary" key="IBDocument.PluginDeclaredDevelopmentDependencies">
+			<string key="NS.key.0">com.apple.InterfaceBuilder.CocoaTouchPlugin.InterfaceBuilder3</string>
+			<integer value="3100" key="NS.object.0"/>
+		</object>
+		<bool key="IBDocument.PluginDeclaredDependenciesTrackSystemTargetVersion">YES</bool>
+		<string key="IBDocument.LastKnownRelativeProjectPath">ReaderSample.xcodeproj</string>
+		<int key="IBDocument.defaultPropertyAccessControl">3</int>
+		<string key="IBCocoaTouchPluginVersion">112</string>
+	</data>
+</archive>
diff -r 563557a923d0 iphone/examples/ReaderSample/ReaderSample/en.lproj/ReaderSampleViewController.xib
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/examples/ReaderSample/ReaderSample/en.lproj/ReaderSampleViewController.xib	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,319 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<archive type="com.apple.InterfaceBuilder3.CocoaTouch.XIB" version="7.10">
+	<data>
+		<int key="IBDocument.SystemTarget">1056</int>
+		<string key="IBDocument.SystemVersion">10J869</string>
+		<string key="IBDocument.InterfaceBuilderVersion">1306</string>
+		<string key="IBDocument.AppKitVersion">1038.35</string>
+		<string key="IBDocument.HIToolboxVersion">461.00</string>
+		<object class="NSMutableDictionary" key="IBDocument.PluginVersions">
+			<string key="NS.key.0">com.apple.InterfaceBuilder.IBCocoaTouchPlugin</string>
+			<string key="NS.object.0">301</string>
+		</object>
+		<object class="NSArray" key="IBDocument.IntegratedClassDependencies">
+			<bool key="EncodedWithXMLCoder">YES</bool>
+			<string>IBUITextView</string>
+			<string>IBUIButton</string>
+			<string>IBUIImageView</string>
+			<string>IBUIView</string>
+			<string>IBProxyObject</string>
+		</object>
+		<object class="NSArray" key="IBDocument.PluginDependencies">
+			<bool key="EncodedWithXMLCoder">YES</bool>
+			<string>com.apple.InterfaceBuilder.IBCocoaTouchPlugin</string>
+		</object>
+		<object class="NSMutableDictionary" key="IBDocument.Metadata">
+			<bool key="EncodedWithXMLCoder">YES</bool>
+			<object class="NSArray" key="dict.sortedKeys" id="0">
+				<bool key="EncodedWithXMLCoder">YES</bool>
+			</object>
+			<reference key="dict.values" ref="0"/>
+		</object>
+		<object class="NSMutableArray" key="IBDocument.RootObjects" id="1000">
+			<bool key="EncodedWithXMLCoder">YES</bool>
+			<object class="IBProxyObject" id="372490531">
+				<string key="IBProxiedObjectIdentifier">IBFilesOwner</string>
+				<string key="targetRuntimeIdentifier">IBCocoaTouchFramework</string>
+			</object>
+			<object class="IBProxyObject" id="843779117">
+				<string key="IBProxiedObjectIdentifier">IBFirstResponder</string>
+				<string key="targetRuntimeIdentifier">IBCocoaTouchFramework</string>
+			</object>
+			<object class="IBUIView" id="774585933">
+				<reference key="NSNextResponder"/>
+				<int key="NSvFlags">274</int>
+				<object class="NSMutableArray" key="NSSubviews">
+					<bool key="EncodedWithXMLCoder">YES</bool>
+					<object class="IBUIButton" id="973537804">
+						<reference key="NSNextResponder" ref="774585933"/>
+						<int key="NSvFlags">282</int>
+						<string key="NSFrame">{{20, 396}, {280, 44}}</string>
+						<reference key="NSSuperview" ref="774585933"/>
+						<reference key="NSWindow"/>
+						<bool key="IBUIOpaque">NO</bool>
+						<string key="targetRuntimeIdentifier">IBCocoaTouchFramework</string>
+						<int key="IBUIContentHorizontalAlignment">0</int>
+						<int key="IBUIContentVerticalAlignment">0</int>
+						<object class="NSFont" key="IBUIFont">
+							<string key="NSName">Helvetica-Bold</string>
+							<double key="NSSize">19</double>
+							<int key="NSfFlags">16</int>
+						</object>
+						<int key="IBUIButtonType">1</int>
+						<string key="IBUINormalTitle">Scan</string>
+						<object class="NSColor" key="IBUIHighlightedTitleColor">
+							<int key="NSColorSpace">3</int>
+							<bytes key="NSWhite">MQA</bytes>
+						</object>
+						<object class="NSColor" key="IBUINormalTitleColor">
+							<int key="NSColorSpace">1</int>
+							<bytes key="NSRGB">MC4xOTYwNzg0MzQ2IDAuMzA5ODAzOTMyOSAwLjUyMTU2ODY1NgA</bytes>
+						</object>
+						<object class="NSColor" key="IBUINormalTitleShadowColor">
+							<int key="NSColorSpace">3</int>
+							<bytes key="NSWhite">MC41AA</bytes>
+						</object>
+					</object>
+					<object class="IBUIImageView" id="409141881">
+						<reference key="NSNextResponder" ref="774585933"/>
+						<int key="NSvFlags">311</int>
+						<string key="NSFrame">{{20, 20}, {280, 210}}</string>
+						<reference key="NSSuperview" ref="774585933"/>
+						<reference key="NSWindow"/>
+						<reference key="NSNextKeyView" ref="790976943"/>
+						<int key="IBUIContentMode">1</int>
+						<bool key="IBUIUserInteractionEnabled">NO</bool>
+						<string key="targetRuntimeIdentifier">IBCocoaTouchFramework</string>
+					</object>
+					<object class="IBUITextView" id="790976943">
+						<reference key="NSNextResponder" ref="774585933"/>
+						<int key="NSvFlags">282</int>
+						<string key="NSFrame">{{20, 238}, {280, 150}}</string>
+						<reference key="NSSuperview" ref="774585933"/>
+						<reference key="NSWindow"/>
+						<reference key="NSNextKeyView" ref="973537804"/>
+						<object class="NSColor" key="IBUIBackgroundColor">
+							<int key="NSColorSpace">3</int>
+							<bytes key="NSWhite">MCAwAA</bytes>
+						</object>
+						<bool key="IBUIClipsSubviews">YES</bool>
+						<bool key="IBUIMultipleTouchEnabled">YES</bool>
+						<string key="targetRuntimeIdentifier">IBCocoaTouchFramework</string>
+						<bool key="IBUIEditable">NO</bool>
+						<string key="IBUIText">No barcode scanned...</string>
+						<object class="NSFont" key="IBUIFont">
+							<string key="NSName">Helvetica</string>
+							<double key="NSSize">17</double>
+							<int key="NSfFlags">16</int>
+						</object>
+						<object class="IBUITextInputTraits" key="IBUITextInputTraits">
+							<int key="IBUIAutocapitalizationType">2</int>
+							<string key="targetRuntimeIdentifier">IBCocoaTouchFramework</string>
+						</object>
+					</object>
+				</object>
+				<string key="NSFrame">{{0, 20}, {320, 460}}</string>
+				<reference key="NSSuperview"/>
+				<reference key="NSWindow"/>
+				<reference key="NSNextKeyView" ref="409141881"/>
+				<object class="NSColor" key="IBUIBackgroundColor">
+					<int key="NSColorSpace">3</int>
+					<bytes key="NSWhite">MC43NQA</bytes>
+					<object class="NSColorSpace" key="NSCustomColorSpace">
+						<int key="NSID">2</int>
+					</object>
+				</object>
+				<bool key="IBUIClearsContextBeforeDrawing">NO</bool>
+				<object class="IBUISimulatedStatusBarMetrics" key="IBUISimulatedStatusBarMetrics"/>
+				<string key="targetRuntimeIdentifier">IBCocoaTouchFramework</string>
+			</object>
+		</object>
+		<object class="IBObjectContainer" key="IBDocument.Objects">
+			<object class="NSMutableArray" key="connectionRecords">
+				<bool key="EncodedWithXMLCoder">YES</bool>
+				<object class="IBConnectionRecord">
+					<object class="IBCocoaTouchOutletConnection" key="connection">
+						<string key="label">view</string>
+						<reference key="source" ref="372490531"/>
+						<reference key="destination" ref="774585933"/>
+					</object>
+					<int key="connectionID">7</int>
+				</object>
+				<object class="IBConnectionRecord">
+					<object class="IBCocoaTouchOutletConnection" key="connection">
+						<string key="label">resultImage</string>
+						<reference key="source" ref="372490531"/>
+						<reference key="destination" ref="409141881"/>
+					</object>
+					<int key="connectionID">11</int>
+				</object>
+				<object class="IBConnectionRecord">
+					<object class="IBCocoaTouchOutletConnection" key="connection">
+						<string key="label">resultText</string>
+						<reference key="source" ref="372490531"/>
+						<reference key="destination" ref="790976943"/>
+					</object>
+					<int key="connectionID">12</int>
+				</object>
+				<object class="IBConnectionRecord">
+					<object class="IBCocoaTouchEventConnection" key="connection">
+						<string key="label">scanButtonTapped</string>
+						<reference key="source" ref="973537804"/>
+						<reference key="destination" ref="372490531"/>
+						<int key="IBEventType">7</int>
+					</object>
+					<int key="connectionID">13</int>
+				</object>
+			</object>
+			<object class="IBMutableOrderedSet" key="objectRecords">
+				<object class="NSArray" key="orderedObjects">
+					<bool key="EncodedWithXMLCoder">YES</bool>
+					<object class="IBObjectRecord">
+						<int key="objectID">0</int>
+						<reference key="object" ref="0"/>
+						<reference key="children" ref="1000"/>
+						<nil key="parent"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">-1</int>
+						<reference key="object" ref="372490531"/>
+						<reference key="parent" ref="0"/>
+						<string key="objectName">File's Owner</string>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">-2</int>
+						<reference key="object" ref="843779117"/>
+						<reference key="parent" ref="0"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">6</int>
+						<reference key="object" ref="774585933"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="973537804"/>
+							<reference ref="409141881"/>
+							<reference ref="790976943"/>
+						</object>
+						<reference key="parent" ref="0"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">8</int>
+						<reference key="object" ref="973537804"/>
+						<reference key="parent" ref="774585933"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">9</int>
+						<reference key="object" ref="409141881"/>
+						<reference key="parent" ref="774585933"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">10</int>
+						<reference key="object" ref="790976943"/>
+						<reference key="parent" ref="774585933"/>
+					</object>
+				</object>
+			</object>
+			<object class="NSMutableDictionary" key="flattenedProperties">
+				<bool key="EncodedWithXMLCoder">YES</bool>
+				<object class="NSArray" key="dict.sortedKeys">
+					<bool key="EncodedWithXMLCoder">YES</bool>
+					<string>-1.CustomClassName</string>
+					<string>-2.CustomClassName</string>
+					<string>10.IBPluginDependency</string>
+					<string>6.IBEditorWindowLastContentRect</string>
+					<string>6.IBPluginDependency</string>
+					<string>8.IBPluginDependency</string>
+					<string>9.IBPluginDependency</string>
+				</object>
+				<object class="NSMutableArray" key="dict.values">
+					<bool key="EncodedWithXMLCoder">YES</bool>
+					<string>ReaderSampleViewController</string>
+					<string>UIResponder</string>
+					<string>com.apple.InterfaceBuilder.IBCocoaTouchPlugin</string>
+					<string>{{239, 654}, {320, 480}}</string>
+					<string>com.apple.InterfaceBuilder.IBCocoaTouchPlugin</string>
+					<string>com.apple.InterfaceBuilder.IBCocoaTouchPlugin</string>
+					<string>com.apple.InterfaceBuilder.IBCocoaTouchPlugin</string>
+				</object>
+			</object>
+			<object class="NSMutableDictionary" key="unlocalizedProperties">
+				<bool key="EncodedWithXMLCoder">YES</bool>
+				<reference key="dict.sortedKeys" ref="0"/>
+				<reference key="dict.values" ref="0"/>
+			</object>
+			<nil key="activeLocalization"/>
+			<object class="NSMutableDictionary" key="localizations">
+				<bool key="EncodedWithXMLCoder">YES</bool>
+				<reference key="dict.sortedKeys" ref="0"/>
+				<reference key="dict.values" ref="0"/>
+			</object>
+			<nil key="sourceID"/>
+			<int key="maxID">13</int>
+		</object>
+		<object class="IBClassDescriber" key="IBDocument.Classes">
+			<object class="NSMutableArray" key="referencedPartialClassDescriptions">
+				<bool key="EncodedWithXMLCoder">YES</bool>
+				<object class="IBPartialClassDescription">
+					<string key="className">ReaderSampleViewController</string>
+					<string key="superclassName">UIViewController</string>
+					<object class="NSMutableDictionary" key="actions">
+						<string key="NS.key.0">scanButtonTapped</string>
+						<string key="NS.object.0">id</string>
+					</object>
+					<object class="NSMutableDictionary" key="actionInfosByName">
+						<string key="NS.key.0">scanButtonTapped</string>
+						<object class="IBActionInfo" key="NS.object.0">
+							<string key="name">scanButtonTapped</string>
+							<string key="candidateClassName">id</string>
+						</object>
+					</object>
+					<object class="NSMutableDictionary" key="outlets">
+						<bool key="EncodedWithXMLCoder">YES</bool>
+						<object class="NSArray" key="dict.sortedKeys">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<string>resultImage</string>
+							<string>resultText</string>
+						</object>
+						<object class="NSMutableArray" key="dict.values">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<string>UIImageView</string>
+							<string>UITextView</string>
+						</object>
+					</object>
+					<object class="NSMutableDictionary" key="toOneOutletInfosByName">
+						<bool key="EncodedWithXMLCoder">YES</bool>
+						<object class="NSArray" key="dict.sortedKeys">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<string>resultImage</string>
+							<string>resultText</string>
+						</object>
+						<object class="NSMutableArray" key="dict.values">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<object class="IBToOneOutletInfo">
+								<string key="name">resultImage</string>
+								<string key="candidateClassName">UIImageView</string>
+							</object>
+							<object class="IBToOneOutletInfo">
+								<string key="name">resultText</string>
+								<string key="candidateClassName">UITextView</string>
+							</object>
+						</object>
+					</object>
+					<object class="IBClassDescriptionSource" key="sourceIdentifier">
+						<string key="majorKey">IBProjectSource</string>
+						<string key="minorKey">./Classes/ReaderSampleViewController.h</string>
+					</object>
+				</object>
+			</object>
+		</object>
+		<int key="IBDocument.localizationMode">0</int>
+		<string key="IBDocument.TargetRuntimeIdentifier">IBCocoaTouchFramework</string>
+		<object class="NSMutableDictionary" key="IBDocument.PluginDeclaredDevelopmentDependencies">
+			<string key="NS.key.0">com.apple.InterfaceBuilder.CocoaTouchPlugin.InterfaceBuilder3</string>
+			<integer value="3100" key="NS.object.0"/>
+		</object>
+		<bool key="IBDocument.PluginDeclaredDependenciesTrackSystemTargetVersion">YES</bool>
+		<int key="IBDocument.defaultPropertyAccessControl">3</int>
+		<string key="IBCocoaTouchPluginVersion">301</string>
+	</data>
+</archive>
diff -r 563557a923d0 iphone/examples/ReaderSample/ReaderSample/main.m
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/examples/ReaderSample/ReaderSample/main.m	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,16 @@
+//
+//  main.m
+//  ReaderSample
+//
+//  Created by spadix on 4/14/11.
+//
+
+#import <UIKit/UIKit.h>
+
+int main(int argc, char *argv[])
+{
+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+    int retVal = UIApplicationMain(argc, argv, nil, nil);
+    [pool release];
+    return retVal;
+}
diff -r 563557a923d0 iphone/examples/ReaderSample/ZBarSDK
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/examples/ReaderSample/ZBarSDK	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,1 @@
+../../build/Debug-iphoneos/ZBarSDK
\ No newline at end of file
diff -r 563557a923d0 iphone/examples/ReaderSample/build
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/examples/ReaderSample/build	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,1 @@
+/tmp/ReaderSample.build
\ No newline at end of file
diff -r 563557a923d0 iphone/examples/TabReader/Default-568h@2x.png
Binary file iphone/examples/TabReader/Default-568h@2x.png has changed
diff -r 563557a923d0 iphone/examples/TabReader/TabReader.xcodeproj/project.pbxproj
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/examples/TabReader/TabReader.xcodeproj/project.pbxproj	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,420 @@
+// !$*UTF8*$!
+{
+	archiveVersion = 1;
+	classes = {
+	};
+	objectVersion = 46;
+	objects = {
+
+/* Begin PBXBuildFile section */
+		DC52DED31370F5340048DADA /* AVFoundation.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = DC52DECE1370F5340048DADA /* AVFoundation.framework */; };
+		DC52DED41370F5340048DADA /* CoreMedia.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = DC52DECF1370F5340048DADA /* CoreMedia.framework */; };
+		DC52DED51370F5340048DADA /* CoreVideo.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = DC52DED01370F5340048DADA /* CoreVideo.framework */; };
+		DC52DED61370F5340048DADA /* libiconv.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = DC52DED11370F5340048DADA /* libiconv.dylib */; };
+		DC52DED71370F5340048DADA /* QuartzCore.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = DC52DED21370F5340048DADA /* QuartzCore.framework */; };
+		DC5D76D71370EE8F0069AEF5 /* UIKit.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = DC5D76D61370EE8F0069AEF5 /* UIKit.framework */; };
+		DC5D76D91370EE8F0069AEF5 /* Foundation.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = DC5D76D81370EE8F0069AEF5 /* Foundation.framework */; };
+		DC5D76DB1370EE8F0069AEF5 /* CoreGraphics.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = DC5D76DA1370EE8F0069AEF5 /* CoreGraphics.framework */; };
+		DC5D76E11370EE8F0069AEF5 /* InfoPlist.strings in Resources */ = {isa = PBXBuildFile; fileRef = DC5D76DF1370EE8F0069AEF5 /* InfoPlist.strings */; };
+		DC5D76E41370EE8F0069AEF5 /* main.m in Sources */ = {isa = PBXBuildFile; fileRef = DC5D76E31370EE8F0069AEF5 /* main.m */; };
+		DC5D76E71370EE8F0069AEF5 /* TabReaderAppDelegate.m in Sources */ = {isa = PBXBuildFile; fileRef = DC5D76E61370EE8F0069AEF5 /* TabReaderAppDelegate.m */; };
+		DC5D76EA1370EE8F0069AEF5 /* MainWindow.xib in Resources */ = {isa = PBXBuildFile; fileRef = DC5D76E81370EE8F0069AEF5 /* MainWindow.xib */; };
+		DC5D76F01370EE8F0069AEF5 /* ResultsViewController.m in Sources */ = {isa = PBXBuildFile; fileRef = DC5D76EF1370EE8F0069AEF5 /* ResultsViewController.m */; };
+		DC5D76F61370EE8F0069AEF5 /* ResultsView.xib in Resources */ = {isa = PBXBuildFile; fileRef = DC5D76F41370EE8F0069AEF5 /* ResultsView.xib */; };
+		DC5D771A1370F0E30069AEF5 /* libzbar.a in Frameworks */ = {isa = PBXBuildFile; fileRef = DC5D77141370F0E30069AEF5 /* libzbar.a */; };
+		DC5D771B1370F0E30069AEF5 /* zbar-back.png in Resources */ = {isa = PBXBuildFile; fileRef = DC5D77161370F0E30069AEF5 /* zbar-back.png */; };
+		DC5D771C1370F0E30069AEF5 /* zbar-help.html in Resources */ = {isa = PBXBuildFile; fileRef = DC5D77171370F0E30069AEF5 /* zbar-help.html */; };
+		DC5D771D1370F0E30069AEF5 /* zbar-helpicons.png in Resources */ = {isa = PBXBuildFile; fileRef = DC5D77181370F0E30069AEF5 /* zbar-helpicons.png */; };
+		DC5D771E1370F0E30069AEF5 /* zbar-samples.png in Resources */ = {isa = PBXBuildFile; fileRef = DC5D77191370F0E30069AEF5 /* zbar-samples.png */; };
+		DC82460B162B5A1D0010B2E6 /* Default-568h@2x.png in Resources */ = {isa = PBXBuildFile; fileRef = DC82460A162B5A1D0010B2E6 /* Default-568h@2x.png */; };
+/* End PBXBuildFile section */
+
+/* Begin PBXFileReference section */
+		DC52DECE1370F5340048DADA /* AVFoundation.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = AVFoundation.framework; path = System/Library/Frameworks/AVFoundation.framework; sourceTree = SDKROOT; };
+		DC52DECF1370F5340048DADA /* CoreMedia.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = CoreMedia.framework; path = System/Library/Frameworks/CoreMedia.framework; sourceTree = SDKROOT; };
+		DC52DED01370F5340048DADA /* CoreVideo.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = CoreVideo.framework; path = System/Library/Frameworks/CoreVideo.framework; sourceTree = SDKROOT; };
+		DC52DED11370F5340048DADA /* libiconv.dylib */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.dylib"; name = libiconv.dylib; path = usr/lib/libiconv.dylib; sourceTree = SDKROOT; };
+		DC52DED21370F5340048DADA /* QuartzCore.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = QuartzCore.framework; path = System/Library/Frameworks/QuartzCore.framework; sourceTree = SDKROOT; };
+		DC5D76D21370EE8F0069AEF5 /* TabReader.app */ = {isa = PBXFileReference; explicitFileType = wrapper.application; includeInIndex = 0; path = TabReader.app; sourceTree = BUILT_PRODUCTS_DIR; };
+		DC5D76D61370EE8F0069AEF5 /* UIKit.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = UIKit.framework; path = System/Library/Frameworks/UIKit.framework; sourceTree = SDKROOT; };
+		DC5D76D81370EE8F0069AEF5 /* Foundation.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = Foundation.framework; path = System/Library/Frameworks/Foundation.framework; sourceTree = SDKROOT; };
+		DC5D76DA1370EE8F0069AEF5 /* CoreGraphics.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = CoreGraphics.framework; path = System/Library/Frameworks/CoreGraphics.framework; sourceTree = SDKROOT; };
+		DC5D76DE1370EE8F0069AEF5 /* TabReader-Info.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist.xml; path = "TabReader-Info.plist"; sourceTree = "<group>"; };
+		DC5D76E01370EE8F0069AEF5 /* en */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = en; path = en.lproj/InfoPlist.strings; sourceTree = "<group>"; };
+		DC5D76E21370EE8F0069AEF5 /* TabReader-Prefix.pch */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = "TabReader-Prefix.pch"; sourceTree = "<group>"; };
+		DC5D76E31370EE8F0069AEF5 /* main.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = main.m; sourceTree = "<group>"; };
+		DC5D76E51370EE8F0069AEF5 /* TabReaderAppDelegate.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = TabReaderAppDelegate.h; sourceTree = "<group>"; };
+		DC5D76E61370EE8F0069AEF5 /* TabReaderAppDelegate.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = TabReaderAppDelegate.m; sourceTree = "<group>"; };
+		DC5D76E91370EE8F0069AEF5 /* en */ = {isa = PBXFileReference; lastKnownFileType = file.xib; name = en; path = en.lproj/MainWindow.xib; sourceTree = "<group>"; };
+		DC5D76EE1370EE8F0069AEF5 /* ResultsViewController.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = ResultsViewController.h; sourceTree = "<group>"; };
+		DC5D76EF1370EE8F0069AEF5 /* ResultsViewController.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = ResultsViewController.m; sourceTree = "<group>"; };
+		DC5D76F51370EE8F0069AEF5 /* en */ = {isa = PBXFileReference; lastKnownFileType = file.xib; name = en; path = en.lproj/ResultsView.xib; sourceTree = "<group>"; };
+		DC5D77001370F0E30069AEF5 /* Decoder.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Decoder.h; sourceTree = "<group>"; };
+		DC5D77011370F0E30069AEF5 /* Exception.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Exception.h; sourceTree = "<group>"; };
+		DC5D77021370F0E30069AEF5 /* Image.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Image.h; sourceTree = "<group>"; };
+		DC5D77031370F0E30069AEF5 /* ImageScanner.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ImageScanner.h; sourceTree = "<group>"; };
+		DC5D77041370F0E30069AEF5 /* Processor.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Processor.h; sourceTree = "<group>"; };
+		DC5D77051370F0E30069AEF5 /* Scanner.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Scanner.h; sourceTree = "<group>"; };
+		DC5D77061370F0E30069AEF5 /* Symbol.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Symbol.h; sourceTree = "<group>"; };
+		DC5D77071370F0E30069AEF5 /* Video.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Video.h; sourceTree = "<group>"; };
+		DC5D77081370F0E30069AEF5 /* Window.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Window.h; sourceTree = "<group>"; };
+		DC5D77091370F0E30069AEF5 /* zbar.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = zbar.h; sourceTree = "<group>"; };
+		DC5D770A1370F0E30069AEF5 /* ZBarCameraSimulator.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ZBarCameraSimulator.h; sourceTree = "<group>"; };
+		DC5D770B1370F0E30069AEF5 /* ZBarCaptureReader.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ZBarCaptureReader.h; sourceTree = "<group>"; };
+		DC5D770C1370F0E30069AEF5 /* ZBarHelpController.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ZBarHelpController.h; sourceTree = "<group>"; };
+		DC5D770D1370F0E30069AEF5 /* ZBarImage.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ZBarImage.h; sourceTree = "<group>"; };
+		DC5D770E1370F0E30069AEF5 /* ZBarImageScanner.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ZBarImageScanner.h; sourceTree = "<group>"; };
+		DC5D770F1370F0E30069AEF5 /* ZBarReaderController.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ZBarReaderController.h; sourceTree = "<group>"; };
+		DC5D77101370F0E30069AEF5 /* ZBarReaderView.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ZBarReaderView.h; sourceTree = "<group>"; };
+		DC5D77111370F0E30069AEF5 /* ZBarReaderViewController.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ZBarReaderViewController.h; sourceTree = "<group>"; };
+		DC5D77121370F0E30069AEF5 /* ZBarSDK.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ZBarSDK.h; sourceTree = "<group>"; };
+		DC5D77131370F0E30069AEF5 /* ZBarSymbol.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ZBarSymbol.h; sourceTree = "<group>"; };
+		DC5D77141370F0E30069AEF5 /* libzbar.a */ = {isa = PBXFileReference; lastKnownFileType = archive.ar; path = libzbar.a; sourceTree = "<group>"; };
+		DC5D77161370F0E30069AEF5 /* zbar-back.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; path = "zbar-back.png"; sourceTree = "<group>"; };
+		DC5D77171370F0E30069AEF5 /* zbar-help.html */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.html; path = "zbar-help.html"; sourceTree = "<group>"; };
+		DC5D77181370F0E30069AEF5 /* zbar-helpicons.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; path = "zbar-helpicons.png"; sourceTree = "<group>"; };
+		DC5D77191370F0E30069AEF5 /* zbar-samples.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; path = "zbar-samples.png"; sourceTree = "<group>"; };
+		DC82460A162B5A1D0010B2E6 /* Default-568h@2x.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; path = "Default-568h@2x.png"; sourceTree = SOURCE_ROOT; };
+/* End PBXFileReference section */
+
+/* Begin PBXFrameworksBuildPhase section */
+		DC5D76CF1370EE8F0069AEF5 /* Frameworks */ = {
+			isa = PBXFrameworksBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				DC52DED31370F5340048DADA /* AVFoundation.framework in Frameworks */,
+				DC52DED41370F5340048DADA /* CoreMedia.framework in Frameworks */,
+				DC52DED51370F5340048DADA /* CoreVideo.framework in Frameworks */,
+				DC52DED61370F5340048DADA /* libiconv.dylib in Frameworks */,
+				DC52DED71370F5340048DADA /* QuartzCore.framework in Frameworks */,
+				DC5D76D71370EE8F0069AEF5 /* UIKit.framework in Frameworks */,
+				DC5D76D91370EE8F0069AEF5 /* Foundation.framework in Frameworks */,
+				DC5D76DB1370EE8F0069AEF5 /* CoreGraphics.framework in Frameworks */,
+				DC5D771A1370F0E30069AEF5 /* libzbar.a in Frameworks */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+/* End PBXFrameworksBuildPhase section */
+
+/* Begin PBXGroup section */
+		DC5D76C71370EE8D0069AEF5 = {
+			isa = PBXGroup;
+			children = (
+				DC5D76DC1370EE8F0069AEF5 /* TabReader */,
+				DC5D76FC1370F0E30069AEF5 /* ZBarSDK */,
+				DC5D76D51370EE8F0069AEF5 /* Frameworks */,
+				DC5D76D31370EE8F0069AEF5 /* Products */,
+			);
+			sourceTree = "<group>";
+		};
+		DC5D76D31370EE8F0069AEF5 /* Products */ = {
+			isa = PBXGroup;
+			children = (
+				DC5D76D21370EE8F0069AEF5 /* TabReader.app */,
+			);
+			name = Products;
+			sourceTree = "<group>";
+		};
+		DC5D76D51370EE8F0069AEF5 /* Frameworks */ = {
+			isa = PBXGroup;
+			children = (
+				DC5D76D61370EE8F0069AEF5 /* UIKit.framework */,
+				DC5D76D81370EE8F0069AEF5 /* Foundation.framework */,
+				DC5D76DA1370EE8F0069AEF5 /* CoreGraphics.framework */,
+				DC52DECE1370F5340048DADA /* AVFoundation.framework */,
+				DC52DECF1370F5340048DADA /* CoreMedia.framework */,
+				DC52DED01370F5340048DADA /* CoreVideo.framework */,
+				DC52DED11370F5340048DADA /* libiconv.dylib */,
+				DC52DED21370F5340048DADA /* QuartzCore.framework */,
+			);
+			name = Frameworks;
+			sourceTree = "<group>";
+		};
+		DC5D76DC1370EE8F0069AEF5 /* TabReader */ = {
+			isa = PBXGroup;
+			children = (
+				DC5D76E51370EE8F0069AEF5 /* TabReaderAppDelegate.h */,
+				DC5D76E61370EE8F0069AEF5 /* TabReaderAppDelegate.m */,
+				DC5D76E81370EE8F0069AEF5 /* MainWindow.xib */,
+				DC5D76EE1370EE8F0069AEF5 /* ResultsViewController.h */,
+				DC5D76EF1370EE8F0069AEF5 /* ResultsViewController.m */,
+				DC5D76F41370EE8F0069AEF5 /* ResultsView.xib */,
+				DC5D76DD1370EE8F0069AEF5 /* Supporting Files */,
+			);
+			path = TabReader;
+			sourceTree = "<group>";
+		};
+		DC5D76DD1370EE8F0069AEF5 /* Supporting Files */ = {
+			isa = PBXGroup;
+			children = (
+				DC5D76DE1370EE8F0069AEF5 /* TabReader-Info.plist */,
+				DC5D76DF1370EE8F0069AEF5 /* InfoPlist.strings */,
+				DC82460A162B5A1D0010B2E6 /* Default-568h@2x.png */,
+				DC5D76E21370EE8F0069AEF5 /* TabReader-Prefix.pch */,
+				DC5D76E31370EE8F0069AEF5 /* main.m */,
+			);
+			name = "Supporting Files";
+			sourceTree = "<group>";
+		};
+		DC5D76FC1370F0E30069AEF5 /* ZBarSDK */ = {
+			isa = PBXGroup;
+			children = (
+				DC5D76FD1370F0E30069AEF5 /* Headers */,
+				DC5D77141370F0E30069AEF5 /* libzbar.a */,
+				DC5D77151370F0E30069AEF5 /* Resources */,
+			);
+			path = ZBarSDK;
+			sourceTree = "<group>";
+		};
+		DC5D76FD1370F0E30069AEF5 /* Headers */ = {
+			isa = PBXGroup;
+			children = (
+				DC5D76FE1370F0E30069AEF5 /* ZBarSDK */,
+			);
+			path = Headers;
+			sourceTree = "<group>";
+		};
+		DC5D76FE1370F0E30069AEF5 /* ZBarSDK */ = {
+			isa = PBXGroup;
+			children = (
+				DC5D76FF1370F0E30069AEF5 /* zbar */,
+				DC5D77091370F0E30069AEF5 /* zbar.h */,
+				DC5D770A1370F0E30069AEF5 /* ZBarCameraSimulator.h */,
+				DC5D770B1370F0E30069AEF5 /* ZBarCaptureReader.h */,
+				DC5D770C1370F0E30069AEF5 /* ZBarHelpController.h */,
+				DC5D770D1370F0E30069AEF5 /* ZBarImage.h */,
+				DC5D770E1370F0E30069AEF5 /* ZBarImageScanner.h */,
+				DC5D770F1370F0E30069AEF5 /* ZBarReaderController.h */,
+				DC5D77101370F0E30069AEF5 /* ZBarReaderView.h */,
+				DC5D77111370F0E30069AEF5 /* ZBarReaderViewController.h */,
+				DC5D77121370F0E30069AEF5 /* ZBarSDK.h */,
+				DC5D77131370F0E30069AEF5 /* ZBarSymbol.h */,
+			);
+			path = ZBarSDK;
+			sourceTree = "<group>";
+		};
+		DC5D76FF1370F0E30069AEF5 /* zbar */ = {
+			isa = PBXGroup;
+			children = (
+				DC5D77001370F0E30069AEF5 /* Decoder.h */,
+				DC5D77011370F0E30069AEF5 /* Exception.h */,
+				DC5D77021370F0E30069AEF5 /* Image.h */,
+				DC5D77031370F0E30069AEF5 /* ImageScanner.h */,
+				DC5D77041370F0E30069AEF5 /* Processor.h */,
+				DC5D77051370F0E30069AEF5 /* Scanner.h */,
+				DC5D77061370F0E30069AEF5 /* Symbol.h */,
+				DC5D77071370F0E30069AEF5 /* Video.h */,
+				DC5D77081370F0E30069AEF5 /* Window.h */,
+			);
+			path = zbar;
+			sourceTree = "<group>";
+		};
+		DC5D77151370F0E30069AEF5 /* Resources */ = {
+			isa = PBXGroup;
+			children = (
+				DC5D77161370F0E30069AEF5 /* zbar-back.png */,
+				DC5D77171370F0E30069AEF5 /* zbar-help.html */,
+				DC5D77181370F0E30069AEF5 /* zbar-helpicons.png */,
+				DC5D77191370F0E30069AEF5 /* zbar-samples.png */,
+			);
+			path = Resources;
+			sourceTree = "<group>";
+		};
+/* End PBXGroup section */
+
+/* Begin PBXNativeTarget section */
+		DC5D76D11370EE8F0069AEF5 /* TabReader */ = {
+			isa = PBXNativeTarget;
+			buildConfigurationList = DC5D76F91370EE900069AEF5 /* Build configuration list for PBXNativeTarget "TabReader" */;
+			buildPhases = (
+				DC5D76CE1370EE8F0069AEF5 /* Sources */,
+				DC5D76CF1370EE8F0069AEF5 /* Frameworks */,
+				DC5D76D01370EE8F0069AEF5 /* Resources */,
+			);
+			buildRules = (
+			);
+			dependencies = (
+			);
+			name = TabReader;
+			productName = TabReader;
+			productReference = DC5D76D21370EE8F0069AEF5 /* TabReader.app */;
+			productType = "com.apple.product-type.application";
+		};
+/* End PBXNativeTarget section */
+
+/* Begin PBXProject section */
+		DC5D76C91370EE8D0069AEF5 /* Project object */ = {
+			isa = PBXProject;
+			buildConfigurationList = DC5D76CC1370EE8D0069AEF5 /* Build configuration list for PBXProject "TabReader" */;
+			compatibilityVersion = "Xcode 3.2";
+			developmentRegion = English;
+			hasScannedForEncodings = 0;
+			knownRegions = (
+				en,
+			);
+			mainGroup = DC5D76C71370EE8D0069AEF5;
+			productRefGroup = DC5D76D31370EE8F0069AEF5 /* Products */;
+			projectDirPath = "";
+			projectRoot = "";
+			targets = (
+				DC5D76D11370EE8F0069AEF5 /* TabReader */,
+			);
+		};
+/* End PBXProject section */
+
+/* Begin PBXResourcesBuildPhase section */
+		DC5D76D01370EE8F0069AEF5 /* Resources */ = {
+			isa = PBXResourcesBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				DC5D76E11370EE8F0069AEF5 /* InfoPlist.strings in Resources */,
+				DC5D76EA1370EE8F0069AEF5 /* MainWindow.xib in Resources */,
+				DC5D76F61370EE8F0069AEF5 /* ResultsView.xib in Resources */,
+				DC5D771B1370F0E30069AEF5 /* zbar-back.png in Resources */,
+				DC5D771C1370F0E30069AEF5 /* zbar-help.html in Resources */,
+				DC5D771D1370F0E30069AEF5 /* zbar-helpicons.png in Resources */,
+				DC5D771E1370F0E30069AEF5 /* zbar-samples.png in Resources */,
+				DC82460B162B5A1D0010B2E6 /* Default-568h@2x.png in Resources */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+/* End PBXResourcesBuildPhase section */
+
+/* Begin PBXSourcesBuildPhase section */
+		DC5D76CE1370EE8F0069AEF5 /* Sources */ = {
+			isa = PBXSourcesBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				DC5D76E41370EE8F0069AEF5 /* main.m in Sources */,
+				DC5D76E71370EE8F0069AEF5 /* TabReaderAppDelegate.m in Sources */,
+				DC5D76F01370EE8F0069AEF5 /* ResultsViewController.m in Sources */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+/* End PBXSourcesBuildPhase section */
+
+/* Begin PBXVariantGroup section */
+		DC5D76DF1370EE8F0069AEF5 /* InfoPlist.strings */ = {
+			isa = PBXVariantGroup;
+			children = (
+				DC5D76E01370EE8F0069AEF5 /* en */,
+			);
+			name = InfoPlist.strings;
+			sourceTree = "<group>";
+		};
+		DC5D76E81370EE8F0069AEF5 /* MainWindow.xib */ = {
+			isa = PBXVariantGroup;
+			children = (
+				DC5D76E91370EE8F0069AEF5 /* en */,
+			);
+			name = MainWindow.xib;
+			sourceTree = "<group>";
+		};
+		DC5D76F41370EE8F0069AEF5 /* ResultsView.xib */ = {
+			isa = PBXVariantGroup;
+			children = (
+				DC5D76F51370EE8F0069AEF5 /* en */,
+			);
+			name = ResultsView.xib;
+			sourceTree = "<group>";
+		};
+/* End PBXVariantGroup section */
+
+/* Begin XCBuildConfiguration section */
+		DC5D76F71370EE900069AEF5 /* Debug */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				ARCHS = "$(ARCHS_STANDARD_32_BIT)";
+				"CODE_SIGN_IDENTITY[sdk=iphoneos*]" = "iPhone Developer";
+				GCC_C_LANGUAGE_STANDARD = gnu99;
+				GCC_OPTIMIZATION_LEVEL = 0;
+				GCC_PREPROCESSOR_DEFINITIONS = DEBUG;
+				GCC_SYMBOLS_PRIVATE_EXTERN = NO;
+				GCC_VERSION = com.apple.compilers.llvmgcc42;
+				GCC_WARN_ABOUT_RETURN_TYPE = YES;
+				GCC_WARN_UNUSED_VARIABLE = YES;
+				IPHONEOS_DEPLOYMENT_TARGET = 4.3;
+				SDKROOT = iphoneos;
+			};
+			name = Debug;
+		};
+		DC5D76F81370EE900069AEF5 /* Release */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				ARCHS = "$(ARCHS_STANDARD_32_BIT)";
+				"CODE_SIGN_IDENTITY[sdk=iphoneos*]" = "iPhone Developer";
+				GCC_C_LANGUAGE_STANDARD = gnu99;
+				GCC_VERSION = com.apple.compilers.llvmgcc42;
+				GCC_WARN_ABOUT_RETURN_TYPE = YES;
+				GCC_WARN_UNUSED_VARIABLE = YES;
+				IPHONEOS_DEPLOYMENT_TARGET = 4.3;
+				OTHER_CFLAGS = "-DNS_BLOCK_ASSERTIONS=1";
+				SDKROOT = iphoneos;
+			};
+			name = Release;
+		};
+		DC5D76FA1370EE900069AEF5 /* Debug */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				ALWAYS_SEARCH_USER_PATHS = NO;
+				COPY_PHASE_STRIP = NO;
+				GCC_DYNAMIC_NO_PIC = NO;
+				GCC_PRECOMPILE_PREFIX_HEADER = YES;
+				GCC_PREFIX_HEADER = "TabReader/TabReader-Prefix.pch";
+				INFOPLIST_FILE = "TabReader/TabReader-Info.plist";
+				IPHONEOS_DEPLOYMENT_TARGET = 4.0;
+				LIBRARY_SEARCH_PATHS = (
+					"$(inherited)",
+					"\"$(SRCROOT)/ZBarSDK\"",
+				);
+				PRODUCT_NAME = "$(TARGET_NAME)";
+				TARGETED_DEVICE_FAMILY = "1,2";
+				WRAPPER_EXTENSION = app;
+			};
+			name = Debug;
+		};
+		DC5D76FB1370EE900069AEF5 /* Release */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				ALWAYS_SEARCH_USER_PATHS = NO;
+				COPY_PHASE_STRIP = YES;
+				GCC_PRECOMPILE_PREFIX_HEADER = YES;
+				GCC_PREFIX_HEADER = "TabReader/TabReader-Prefix.pch";
+				INFOPLIST_FILE = "TabReader/TabReader-Info.plist";
+				IPHONEOS_DEPLOYMENT_TARGET = 4.0;
+				LIBRARY_SEARCH_PATHS = (
+					"$(inherited)",
+					"\"$(SRCROOT)/ZBarSDK\"",
+				);
+				PRODUCT_NAME = "$(TARGET_NAME)";
+				TARGETED_DEVICE_FAMILY = "1,2";
+				VALIDATE_PRODUCT = YES;
+				WRAPPER_EXTENSION = app;
+			};
+			name = Release;
+		};
+/* End XCBuildConfiguration section */
+
+/* Begin XCConfigurationList section */
+		DC5D76CC1370EE8D0069AEF5 /* Build configuration list for PBXProject "TabReader" */ = {
+			isa = XCConfigurationList;
+			buildConfigurations = (
+				DC5D76F71370EE900069AEF5 /* Debug */,
+				DC5D76F81370EE900069AEF5 /* Release */,
+			);
+			defaultConfigurationIsVisible = 0;
+			defaultConfigurationName = Release;
+		};
+		DC5D76F91370EE900069AEF5 /* Build configuration list for PBXNativeTarget "TabReader" */ = {
+			isa = XCConfigurationList;
+			buildConfigurations = (
+				DC5D76FA1370EE900069AEF5 /* Debug */,
+				DC5D76FB1370EE900069AEF5 /* Release */,
+			);
+			defaultConfigurationIsVisible = 0;
+			defaultConfigurationName = Release;
+		};
+/* End XCConfigurationList section */
+	};
+	rootObject = DC5D76C91370EE8D0069AEF5 /* Project object */;
+}
diff -r 563557a923d0 iphone/examples/TabReader/TabReader.xcodeproj/xcshareddata/xcschemes/TabReader.xcscheme
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/examples/TabReader/TabReader.xcodeproj/xcshareddata/xcschemes/TabReader.xcscheme	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,80 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<Scheme
+   version = "1.8">
+   <BuildAction
+      parallelizeBuildables = "YES"
+      buildImplicitDependencies = "YES">
+      <BuildActionEntries>
+         <BuildActionEntry
+            buildForTesting = "YES"
+            buildForRunning = "YES"
+            buildForProfiling = "YES"
+            buildForArchiving = "YES"
+            buildForAnalyzing = "YES">
+            <BuildableReference
+               BuildableIdentifier = "primary"
+               BlueprintIdentifier = "DC5D76D11370EE8F0069AEF5"
+               BuildableName = "TabReader.app"
+               BlueprintName = "TabReader"
+               ReferencedContainer = "container:TabReader.xcodeproj">
+            </BuildableReference>
+         </BuildActionEntry>
+      </BuildActionEntries>
+   </BuildAction>
+   <TestAction
+      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.GDB"
+      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.GDB"
+      shouldUseLaunchSchemeArgsEnv = "YES"
+      buildConfiguration = "Debug">
+      <Testables>
+      </Testables>
+   </TestAction>
+   <LaunchAction
+      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.GDB"
+      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.GDB"
+      displayScaleIsEnabled = "NO"
+      displayScale = "1.00"
+      launchStyle = "0"
+      useCustomWorkingDirectory = "NO"
+      buildConfiguration = "Debug"
+      ignoresPersistentStateOnLaunch = "NO"
+      debugDocumentVersioning = "YES"
+      allowLocationSimulation = "YES">
+      <BuildableProductRunnable>
+         <BuildableReference
+            BuildableIdentifier = "primary"
+            BlueprintIdentifier = "DC5D76D11370EE8F0069AEF5"
+            BuildableName = "TabReader.app"
+            BlueprintName = "TabReader"
+            ReferencedContainer = "container:TabReader.xcodeproj">
+         </BuildableReference>
+      </BuildableProductRunnable>
+      <AdditionalOptions>
+      </AdditionalOptions>
+   </LaunchAction>
+   <ProfileAction
+      displayScaleIsEnabled = "NO"
+      displayScale = "1.00"
+      shouldUseLaunchSchemeArgsEnv = "YES"
+      savedToolIdentifier = ""
+      useCustomWorkingDirectory = "NO"
+      buildConfiguration = "Release"
+      debugDocumentVersioning = "YES">
+      <BuildableProductRunnable>
+         <BuildableReference
+            BuildableIdentifier = "primary"
+            BlueprintIdentifier = "DC5D76D11370EE8F0069AEF5"
+            BuildableName = "TabReader.app"
+            BlueprintName = "TabReader"
+            ReferencedContainer = "container:TabReader.xcodeproj">
+         </BuildableReference>
+      </BuildableProductRunnable>
+   </ProfileAction>
+   <AnalyzeAction
+      buildConfiguration = "Debug">
+   </AnalyzeAction>
+   <ArchiveAction
+      buildConfiguration = "Release"
+      revealArchiveInOrganizer = "YES">
+   </ArchiveAction>
+</Scheme>
diff -r 563557a923d0 iphone/examples/TabReader/TabReader/ResultsViewController.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/examples/TabReader/TabReader/ResultsViewController.h	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,18 @@
+//
+//  SecondViewController.h
+//  TabReader
+//
+//  Created by spadix on 5/3/11.
+//
+
+#import <UIKit/UIKit.h>
+
+@interface ResultsViewController
+    : UIViewController
+{
+}
+
+@property (nonatomic, retain) IBOutlet UIImageView *resultImage;
+@property (nonatomic, retain) IBOutlet UITextView *resultText;
+
+@end
diff -r 563557a923d0 iphone/examples/TabReader/TabReader/ResultsViewController.m
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/examples/TabReader/TabReader/ResultsViewController.m	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,20 @@
+//
+//  SecondViewController.m
+//  TabReader
+//
+//  Created by spadix on 5/3/11.
+//
+
+#import "ResultsViewController.h"
+
+
+@implementation ResultsViewController
+
+@synthesize resultImage, resultText;
+
+- (BOOL) shouldAutorotateToInterfaceOrientation: (UIInterfaceOrientation) orient
+{
+    return(YES);
+}
+
+@end
diff -r 563557a923d0 iphone/examples/TabReader/TabReader/TabReader-Info.plist
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/examples/TabReader/TabReader/TabReader-Info.plist	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,38 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
+<plist version="1.0">
+<dict>
+	<key>CFBundleDevelopmentRegion</key>
+	<string>en</string>
+	<key>CFBundleDisplayName</key>
+	<string>${PRODUCT_NAME}</string>
+	<key>CFBundleExecutable</key>
+	<string>${EXECUTABLE_NAME}</string>
+	<key>CFBundleIconFile</key>
+	<string></string>
+	<key>CFBundleIdentifier</key>
+	<string>net.sourceforge.zbar.${PRODUCT_NAME:rfc1034identifier}</string>
+	<key>CFBundleInfoDictionaryVersion</key>
+	<string>6.0</string>
+	<key>CFBundleName</key>
+	<string>${PRODUCT_NAME}</string>
+	<key>CFBundlePackageType</key>
+	<string>APPL</string>
+	<key>CFBundleShortVersionString</key>
+	<string>1.0</string>
+	<key>CFBundleSignature</key>
+	<string>????</string>
+	<key>CFBundleVersion</key>
+	<string>1.0</string>
+	<key>LSRequiresIPhoneOS</key>
+	<true/>
+	<key>NSMainNibFile</key>
+	<string>MainWindow</string>
+	<key>UISupportedInterfaceOrientations</key>
+	<array>
+		<string>UIInterfaceOrientationPortrait</string>
+		<string>UIInterfaceOrientationLandscapeLeft</string>
+		<string>UIInterfaceOrientationLandscapeRight</string>
+	</array>
+</dict>
+</plist>
diff -r 563557a923d0 iphone/examples/TabReader/TabReader/TabReader-Prefix.pch
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/examples/TabReader/TabReader/TabReader-Prefix.pch	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,15 @@
+//
+// Prefix header for all source files of the 'TabReader' target in the 'TabReader' project
+//
+
+#import <Availability.h>
+
+#ifndef __IPHONE_3_0
+#warning "This project uses features only available in iPhone SDK 3.0 and later."
+#endif
+
+#ifdef __OBJC__
+# import <UIKit/UIKit.h>
+# import <Foundation/Foundation.h>
+# import "ZBarSDK.h"
+#endif
diff -r 563557a923d0 iphone/examples/TabReader/TabReader/TabReaderAppDelegate.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/examples/TabReader/TabReader/TabReaderAppDelegate.h	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,21 @@
+//
+//  TabReaderAppDelegate.h
+//  TabReader
+//
+//  Created by spadix on 5/3/11.
+//
+
+#import <UIKit/UIKit.h>
+
+@interface TabReaderAppDelegate
+    : NSObject
+    < UIApplicationDelegate,
+      UITabBarControllerDelegate,
+      ZBarReaderDelegate >
+{
+}
+
+@property (nonatomic, retain) IBOutlet UIWindow *window;
+@property (nonatomic, retain) IBOutlet UITabBarController *tabBarController;
+
+@end
diff -r 563557a923d0 iphone/examples/TabReader/TabReader/TabReaderAppDelegate.m
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/examples/TabReader/TabReader/TabReaderAppDelegate.m	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,62 @@
+//
+//  TabReaderAppDelegate.m
+//  TabReader
+//
+//  Created by spadix on 5/3/11.
+//
+
+#import "TabReaderAppDelegate.h"
+#import "ResultsViewController.h"
+
+@implementation TabReaderAppDelegate
+
+@synthesize window=_window;
+@synthesize tabBarController=_tabBarController;
+
+- (BOOL)            application: (UIApplication*) application
+  didFinishLaunchingWithOptions: (NSDictionary*) options
+{
+    // force class to load so it may be referenced directly from nib
+    [ZBarReaderViewController class];
+
+    ZBarReaderViewController *reader =
+        [self.tabBarController.viewControllers objectAtIndex: 0];
+    reader.readerDelegate = self;
+    reader.showsZBarControls = NO;
+    reader.supportedOrientationsMask = ZBarOrientationMaskAll;
+
+    self.window.rootViewController = self.tabBarController;
+    [self.window makeKeyAndVisible];
+
+    return(YES);
+}
+
+- (void) dealloc
+{
+    [_window release];
+    [_tabBarController release];
+    [super dealloc];
+}
+
+
+// ZBarReaderDelegate
+
+- (void)  imagePickerController: (UIImagePickerController*) picker
+  didFinishPickingMediaWithInfo: (NSDictionary*) info
+{
+    // do something useful with results
+    UITabBarController *tabs = self.tabBarController;
+    tabs.selectedIndex = 1;
+    ResultsViewController *results = [tabs.viewControllers objectAtIndex: 1];
+    UIImage *image = [info objectForKey: UIImagePickerControllerOriginalImage];
+    results.resultImage.image = image;
+
+    id <NSFastEnumeration> syms =
+    [info objectForKey: ZBarReaderControllerResults];
+    for(ZBarSymbol *sym in syms) {
+        results.resultText.text = sym.data;
+        break;
+    }
+}
+
+@end
diff -r 563557a923d0 iphone/examples/TabReader/TabReader/en.lproj/InfoPlist.strings
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/examples/TabReader/TabReader/en.lproj/InfoPlist.strings	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,2 @@
+/* Localized versions of Info.plist keys */
+
diff -r 563557a923d0 iphone/examples/TabReader/TabReader/en.lproj/MainWindow.xib
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/examples/TabReader/TabReader/en.lproj/MainWindow.xib	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,411 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<archive type="com.apple.InterfaceBuilder3.CocoaTouch.XIB" version="7.10">
+	<data>
+		<int key="IBDocument.SystemTarget">1024</int>
+		<string key="IBDocument.SystemVersion">10J869</string>
+		<string key="IBDocument.InterfaceBuilderVersion">1306</string>
+		<string key="IBDocument.AppKitVersion">1038.35</string>
+		<string key="IBDocument.HIToolboxVersion">461.00</string>
+		<object class="NSMutableDictionary" key="IBDocument.PluginVersions">
+			<string key="NS.key.0">com.apple.InterfaceBuilder.IBCocoaTouchPlugin</string>
+			<string key="NS.object.0">301</string>
+		</object>
+		<object class="NSArray" key="IBDocument.IntegratedClassDependencies">
+			<bool key="EncodedWithXMLCoder">YES</bool>
+			<string>IBProxyObject</string>
+			<string>IBUITabBarItem</string>
+			<string>IBUIViewController</string>
+			<string>IBUICustomObject</string>
+			<string>IBUITabBarController</string>
+			<string>IBUIWindow</string>
+			<string>IBUITabBar</string>
+		</object>
+		<object class="NSArray" key="IBDocument.PluginDependencies">
+			<bool key="EncodedWithXMLCoder">YES</bool>
+			<string>com.apple.InterfaceBuilder.IBCocoaTouchPlugin</string>
+		</object>
+		<object class="NSMutableDictionary" key="IBDocument.Metadata">
+			<bool key="EncodedWithXMLCoder">YES</bool>
+			<object class="NSArray" key="dict.sortedKeys" id="0">
+				<bool key="EncodedWithXMLCoder">YES</bool>
+			</object>
+			<reference key="dict.values" ref="0"/>
+		</object>
+		<object class="NSMutableArray" key="IBDocument.RootObjects" id="1000">
+			<bool key="EncodedWithXMLCoder">YES</bool>
+			<object class="IBProxyObject" id="841351856">
+				<string key="IBProxiedObjectIdentifier">IBFilesOwner</string>
+				<string key="targetRuntimeIdentifier">IBCocoaTouchFramework</string>
+			</object>
+			<object class="IBProxyObject" id="532797962">
+				<string key="IBProxiedObjectIdentifier">IBFirstResponder</string>
+				<string key="targetRuntimeIdentifier">IBCocoaTouchFramework</string>
+			</object>
+			<object class="IBUICustomObject" id="664661524">
+				<string key="targetRuntimeIdentifier">IBCocoaTouchFramework</string>
+			</object>
+			<object class="IBUIWindow" id="380026005">
+				<reference key="NSNextResponder"/>
+				<int key="NSvFlags">1316</int>
+				<object class="NSPSMatrix" key="NSFrameMatrix"/>
+				<string key="NSFrameSize">{320, 480}</string>
+				<reference key="NSSuperview"/>
+				<reference key="NSWindow"/>
+				<object class="NSColor" key="IBUIBackgroundColor">
+					<int key="NSColorSpace">1</int>
+					<bytes key="NSRGB">MSAxIDEAA</bytes>
+				</object>
+				<bool key="IBUIOpaque">NO</bool>
+				<bool key="IBUIClearsContextBeforeDrawing">NO</bool>
+				<object class="IBUISimulatedStatusBarMetrics" key="IBUISimulatedStatusBarMetrics"/>
+				<string key="targetRuntimeIdentifier">IBCocoaTouchFramework</string>
+				<bool key="IBUIResizesToFullScreen">YES</bool>
+			</object>
+			<object class="IBUITabBarController" id="1034742383">
+				<object class="IBUISimulatedTabBarMetrics" key="IBUISimulatedBottomBarMetrics"/>
+				<object class="IBUISimulatedStatusBarMetrics" key="IBUISimulatedStatusBarMetrics"/>
+				<object class="IBUISimulatedOrientationMetrics" key="IBUISimulatedOrientationMetrics">
+					<int key="IBUIInterfaceOrientation">1</int>
+					<int key="interfaceOrientation">1</int>
+				</object>
+				<string key="targetRuntimeIdentifier">IBCocoaTouchFramework</string>
+				<bool key="IBUIHorizontal">NO</bool>
+				<object class="IBUIViewController" key="IBUISelectedViewController" id="538989659">
+					<object class="IBUITabBarItem" key="IBUITabBarItem" id="896756232">
+						<string key="IBUITitle">Scan</string>
+						<string key="targetRuntimeIdentifier">IBCocoaTouchFramework</string>
+						<reference key="IBUITabBar" ref="795333663"/>
+					</object>
+					<reference key="IBUIParentViewController" ref="1034742383"/>
+					<object class="IBUISimulatedStatusBarMetrics" key="IBUISimulatedStatusBarMetrics"/>
+					<object class="IBUISimulatedOrientationMetrics" key="IBUISimulatedOrientationMetrics">
+						<int key="IBUIInterfaceOrientation">1</int>
+						<int key="interfaceOrientation">1</int>
+					</object>
+					<string key="targetRuntimeIdentifier">IBCocoaTouchFramework</string>
+					<bool key="IBUIHorizontal">NO</bool>
+				</object>
+				<object class="NSMutableArray" key="IBUIViewControllers">
+					<bool key="EncodedWithXMLCoder">YES</bool>
+					<reference ref="538989659"/>
+					<object class="IBUIViewController" id="268481961">
+						<object class="IBUITabBarItem" key="IBUITabBarItem" id="807309489">
+							<string key="IBUITitle">Results</string>
+							<string key="targetRuntimeIdentifier">IBCocoaTouchFramework</string>
+							<reference key="IBUITabBar" ref="795333663"/>
+						</object>
+						<reference key="IBUIParentViewController" ref="1034742383"/>
+						<string key="IBUINibName">ResultsView</string>
+						<object class="IBUISimulatedOrientationMetrics" key="IBUISimulatedOrientationMetrics">
+							<int key="IBUIInterfaceOrientation">1</int>
+							<int key="interfaceOrientation">1</int>
+						</object>
+						<string key="targetRuntimeIdentifier">IBCocoaTouchFramework</string>
+						<bool key="IBUIHorizontal">NO</bool>
+					</object>
+				</object>
+				<object class="IBUITabBar" key="IBUITabBar" id="795333663">
+					<reference key="NSNextResponder"/>
+					<int key="NSvFlags">266</int>
+					<string key="NSFrame">{{0, 431}, {320, 49}}</string>
+					<reference key="NSSuperview"/>
+					<reference key="NSWindow"/>
+					<object class="NSColor" key="IBUIBackgroundColor">
+						<int key="NSColorSpace">3</int>
+						<bytes key="NSWhite">MCAwAA</bytes>
+					</object>
+					<bool key="IBUIClearsContextBeforeDrawing">NO</bool>
+					<string key="targetRuntimeIdentifier">IBCocoaTouchFramework</string>
+					<object class="NSMutableArray" key="IBUIItems">
+						<bool key="EncodedWithXMLCoder">YES</bool>
+						<reference ref="896756232"/>
+						<reference ref="807309489"/>
+					</object>
+					<reference key="IBUISelectedItem" ref="896756232"/>
+				</object>
+			</object>
+		</object>
+		<object class="IBObjectContainer" key="IBDocument.Objects">
+			<object class="NSMutableArray" key="connectionRecords">
+				<bool key="EncodedWithXMLCoder">YES</bool>
+				<object class="IBConnectionRecord">
+					<object class="IBCocoaTouchOutletConnection" key="connection">
+						<string key="label">window</string>
+						<reference key="source" ref="664661524"/>
+						<reference key="destination" ref="380026005"/>
+					</object>
+					<int key="connectionID">9</int>
+				</object>
+				<object class="IBConnectionRecord">
+					<object class="IBCocoaTouchOutletConnection" key="connection">
+						<string key="label">delegate</string>
+						<reference key="source" ref="841351856"/>
+						<reference key="destination" ref="664661524"/>
+					</object>
+					<int key="connectionID">99</int>
+				</object>
+				<object class="IBConnectionRecord">
+					<object class="IBCocoaTouchOutletConnection" key="connection">
+						<string key="label">tabBarController</string>
+						<reference key="source" ref="664661524"/>
+						<reference key="destination" ref="1034742383"/>
+					</object>
+					<int key="connectionID">113</int>
+				</object>
+				<object class="IBConnectionRecord">
+					<object class="IBCocoaTouchOutletConnection" key="connection">
+						<string key="label">delegate</string>
+						<reference key="source" ref="1034742383"/>
+						<reference key="destination" ref="664661524"/>
+					</object>
+					<int key="connectionID">127</int>
+				</object>
+			</object>
+			<object class="IBMutableOrderedSet" key="objectRecords">
+				<object class="NSArray" key="orderedObjects">
+					<bool key="EncodedWithXMLCoder">YES</bool>
+					<object class="IBObjectRecord">
+						<int key="objectID">0</int>
+						<reference key="object" ref="0"/>
+						<reference key="children" ref="1000"/>
+						<nil key="parent"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">2</int>
+						<reference key="object" ref="380026005"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+						</object>
+						<reference key="parent" ref="0"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">-1</int>
+						<reference key="object" ref="841351856"/>
+						<reference key="parent" ref="0"/>
+						<string key="objectName">File's Owner</string>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">3</int>
+						<reference key="object" ref="664661524"/>
+						<reference key="parent" ref="0"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">106</int>
+						<reference key="object" ref="1034742383"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="795333663"/>
+							<reference ref="538989659"/>
+							<reference ref="268481961"/>
+						</object>
+						<reference key="parent" ref="0"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">107</int>
+						<reference key="object" ref="795333663"/>
+						<reference key="parent" ref="1034742383"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">-2</int>
+						<reference key="object" ref="532797962"/>
+						<reference key="parent" ref="0"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">125</int>
+						<reference key="object" ref="538989659"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="896756232"/>
+						</object>
+						<reference key="parent" ref="1034742383"/>
+						<string key="objectName">Barcode Reader Controller</string>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">126</int>
+						<reference key="object" ref="896756232"/>
+						<reference key="parent" ref="538989659"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">109</int>
+						<reference key="object" ref="268481961"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="807309489"/>
+						</object>
+						<reference key="parent" ref="1034742383"/>
+						<string key="objectName">Barcode Results Controller</string>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">110</int>
+						<reference key="object" ref="807309489"/>
+						<reference key="parent" ref="268481961"/>
+					</object>
+				</object>
+			</object>
+			<object class="NSMutableDictionary" key="flattenedProperties">
+				<bool key="EncodedWithXMLCoder">YES</bool>
+				<object class="NSArray" key="dict.sortedKeys">
+					<bool key="EncodedWithXMLCoder">YES</bool>
+					<string>-1.CustomClassName</string>
+					<string>-2.CustomClassName</string>
+					<string>106.IBEditorWindowLastContentRect</string>
+					<string>106.IBPluginDependency</string>
+					<string>107.IBPluginDependency</string>
+					<string>109.CustomClassName</string>
+					<string>109.IBPluginDependency</string>
+					<string>110.IBPluginDependency</string>
+					<string>125.CustomClassName</string>
+					<string>125.IBPluginDependency</string>
+					<string>126.IBPluginDependency</string>
+					<string>2.IBAttributePlaceholdersKey</string>
+					<string>2.IBEditorWindowLastContentRect</string>
+					<string>2.IBPluginDependency</string>
+					<string>3.CustomClassName</string>
+					<string>3.IBPluginDependency</string>
+				</object>
+				<object class="NSMutableArray" key="dict.values">
+					<bool key="EncodedWithXMLCoder">YES</bool>
+					<string>UIApplication</string>
+					<string>UIResponder</string>
+					<string>{{1323, 676}, {320, 480}}</string>
+					<string>com.apple.InterfaceBuilder.IBCocoaTouchPlugin</string>
+					<string>com.apple.InterfaceBuilder.IBCocoaTouchPlugin</string>
+					<string>ResultsViewController</string>
+					<string>com.apple.InterfaceBuilder.IBCocoaTouchPlugin</string>
+					<string>com.apple.InterfaceBuilder.IBCocoaTouchPlugin</string>
+					<string>ZBarReaderViewController</string>
+					<string>com.apple.InterfaceBuilder.IBCocoaTouchPlugin</string>
+					<string>com.apple.InterfaceBuilder.IBCocoaTouchPlugin</string>
+					<object class="NSMutableDictionary">
+						<bool key="EncodedWithXMLCoder">YES</bool>
+						<reference key="dict.sortedKeys" ref="0"/>
+						<reference key="dict.values" ref="0"/>
+					</object>
+					<string>{{229, 373}, {320, 480}}</string>
+					<string>com.apple.InterfaceBuilder.IBCocoaTouchPlugin</string>
+					<string>TabReaderAppDelegate</string>
+					<string>com.apple.InterfaceBuilder.IBCocoaTouchPlugin</string>
+				</object>
+			</object>
+			<object class="NSMutableDictionary" key="unlocalizedProperties">
+				<bool key="EncodedWithXMLCoder">YES</bool>
+				<reference key="dict.sortedKeys" ref="0"/>
+				<reference key="dict.values" ref="0"/>
+			</object>
+			<nil key="activeLocalization"/>
+			<object class="NSMutableDictionary" key="localizations">
+				<bool key="EncodedWithXMLCoder">YES</bool>
+				<reference key="dict.sortedKeys" ref="0"/>
+				<reference key="dict.values" ref="0"/>
+			</object>
+			<nil key="sourceID"/>
+			<int key="maxID">127</int>
+		</object>
+		<object class="IBClassDescriber" key="IBDocument.Classes">
+			<object class="NSMutableArray" key="referencedPartialClassDescriptions">
+				<bool key="EncodedWithXMLCoder">YES</bool>
+				<object class="IBPartialClassDescription">
+					<string key="className">ResultsViewController</string>
+					<string key="superclassName">UIViewController</string>
+					<object class="NSMutableDictionary" key="outlets">
+						<bool key="EncodedWithXMLCoder">YES</bool>
+						<object class="NSArray" key="dict.sortedKeys">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<string>resultImage</string>
+							<string>resultText</string>
+						</object>
+						<object class="NSMutableArray" key="dict.values">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<string>UIImageView</string>
+							<string>UITextView</string>
+						</object>
+					</object>
+					<object class="NSMutableDictionary" key="toOneOutletInfosByName">
+						<bool key="EncodedWithXMLCoder">YES</bool>
+						<object class="NSArray" key="dict.sortedKeys">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<string>resultImage</string>
+							<string>resultText</string>
+						</object>
+						<object class="NSMutableArray" key="dict.values">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<object class="IBToOneOutletInfo">
+								<string key="name">resultImage</string>
+								<string key="candidateClassName">UIImageView</string>
+							</object>
+							<object class="IBToOneOutletInfo">
+								<string key="name">resultText</string>
+								<string key="candidateClassName">UITextView</string>
+							</object>
+						</object>
+					</object>
+					<object class="IBClassDescriptionSource" key="sourceIdentifier">
+						<string key="majorKey">IBProjectSource</string>
+						<string key="minorKey">./Classes/ResultsViewController.h</string>
+					</object>
+				</object>
+				<object class="IBPartialClassDescription">
+					<string key="className">TabReaderAppDelegate</string>
+					<string key="superclassName">NSObject</string>
+					<object class="NSMutableDictionary" key="outlets">
+						<bool key="EncodedWithXMLCoder">YES</bool>
+						<object class="NSArray" key="dict.sortedKeys">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<string>tabBarController</string>
+							<string>window</string>
+						</object>
+						<object class="NSMutableArray" key="dict.values">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<string>UITabBarController</string>
+							<string>UIWindow</string>
+						</object>
+					</object>
+					<object class="NSMutableDictionary" key="toOneOutletInfosByName">
+						<bool key="EncodedWithXMLCoder">YES</bool>
+						<object class="NSArray" key="dict.sortedKeys">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<string>tabBarController</string>
+							<string>window</string>
+						</object>
+						<object class="NSMutableArray" key="dict.values">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<object class="IBToOneOutletInfo">
+								<string key="name">tabBarController</string>
+								<string key="candidateClassName">UITabBarController</string>
+							</object>
+							<object class="IBToOneOutletInfo">
+								<string key="name">window</string>
+								<string key="candidateClassName">UIWindow</string>
+							</object>
+						</object>
+					</object>
+					<object class="IBClassDescriptionSource" key="sourceIdentifier">
+						<string key="majorKey">IBProjectSource</string>
+						<string key="minorKey">./Classes/TabReaderAppDelegate.h</string>
+					</object>
+				</object>
+				<object class="IBPartialClassDescription">
+					<string key="className">ZBarReaderViewController</string>
+					<string key="superclassName">UIViewController</string>
+					<object class="IBClassDescriptionSource" key="sourceIdentifier">
+						<string key="majorKey">IBProjectSource</string>
+						<string key="minorKey">./Classes/ZBarReaderViewController.h</string>
+					</object>
+				</object>
+			</object>
+		</object>
+		<int key="IBDocument.localizationMode">0</int>
+		<string key="IBDocument.TargetRuntimeIdentifier">IBCocoaTouchFramework</string>
+		<object class="NSMutableDictionary" key="IBDocument.PluginDeclaredDependencyDefaults">
+			<string key="NS.key.0">com.apple.InterfaceBuilder.CocoaTouchPlugin.iPhoneOS</string>
+			<integer value="1024" key="NS.object.0"/>
+		</object>
+		<object class="NSMutableDictionary" key="IBDocument.PluginDeclaredDevelopmentDependencies">
+			<string key="NS.key.0">com.apple.InterfaceBuilder.CocoaTouchPlugin.InterfaceBuilder3</string>
+			<integer value="3100" key="NS.object.0"/>
+		</object>
+		<bool key="IBDocument.PluginDeclaredDependenciesTrackSystemTargetVersion">YES</bool>
+		<int key="IBDocument.defaultPropertyAccessControl">3</int>
+		<string key="IBCocoaTouchPluginVersion">301</string>
+	</data>
+</archive>
diff -r 563557a923d0 iphone/examples/TabReader/TabReader/en.lproj/ResultsView.xib
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/examples/TabReader/TabReader/en.lproj/ResultsView.xib	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,303 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<archive type="com.apple.InterfaceBuilder3.CocoaTouch.XIB" version="7.10">
+	<data>
+		<int key="IBDocument.SystemTarget">1024</int>
+		<string key="IBDocument.SystemVersion">10J869</string>
+		<string key="IBDocument.InterfaceBuilderVersion">1306</string>
+		<string key="IBDocument.AppKitVersion">1038.35</string>
+		<string key="IBDocument.HIToolboxVersion">461.00</string>
+		<object class="NSMutableDictionary" key="IBDocument.PluginVersions">
+			<string key="NS.key.0">com.apple.InterfaceBuilder.IBCocoaTouchPlugin</string>
+			<string key="NS.object.0">301</string>
+		</object>
+		<object class="NSArray" key="IBDocument.IntegratedClassDependencies">
+			<bool key="EncodedWithXMLCoder">YES</bool>
+			<string>IBUITextView</string>
+			<string>IBUIImageView</string>
+			<string>IBUIView</string>
+			<string>IBUILabel</string>
+			<string>IBProxyObject</string>
+		</object>
+		<object class="NSArray" key="IBDocument.PluginDependencies">
+			<bool key="EncodedWithXMLCoder">YES</bool>
+			<string>com.apple.InterfaceBuilder.IBCocoaTouchPlugin</string>
+		</object>
+		<object class="NSMutableDictionary" key="IBDocument.Metadata">
+			<bool key="EncodedWithXMLCoder">YES</bool>
+			<object class="NSArray" key="dict.sortedKeys" id="0">
+				<bool key="EncodedWithXMLCoder">YES</bool>
+			</object>
+			<reference key="dict.values" ref="0"/>
+		</object>
+		<object class="NSMutableArray" key="IBDocument.RootObjects" id="1000">
+			<bool key="EncodedWithXMLCoder">YES</bool>
+			<object class="IBProxyObject" id="372490531">
+				<string key="IBProxiedObjectIdentifier">IBFilesOwner</string>
+				<string key="targetRuntimeIdentifier">IBCocoaTouchFramework</string>
+			</object>
+			<object class="IBProxyObject" id="263589821">
+				<string key="IBProxiedObjectIdentifier">IBFirstResponder</string>
+				<string key="targetRuntimeIdentifier">IBCocoaTouchFramework</string>
+			</object>
+			<object class="IBUIView" id="191373211">
+				<reference key="NSNextResponder"/>
+				<int key="NSvFlags">274</int>
+				<object class="NSMutableArray" key="NSSubviews">
+					<bool key="EncodedWithXMLCoder">YES</bool>
+					<object class="IBUILabel" id="483052203">
+						<reference key="NSNextResponder" ref="191373211"/>
+						<int key="NSvFlags">306</int>
+						<string key="NSFrame">{{20, 20}, {280, 28}}</string>
+						<reference key="NSSuperview" ref="191373211"/>
+						<reference key="NSWindow"/>
+						<reference key="NSNextKeyView" ref="255779567"/>
+						<object class="NSColor" key="IBUIBackgroundColor">
+							<int key="NSColorSpace">3</int>
+							<bytes key="NSWhite">MQA</bytes>
+							<object class="NSColorSpace" key="NSCustomColorSpace">
+								<int key="NSID">2</int>
+							</object>
+						</object>
+						<bool key="IBUIOpaque">NO</bool>
+						<bool key="IBUIClipsSubviews">YES</bool>
+						<bool key="IBUIUserInteractionEnabled">NO</bool>
+						<string key="targetRuntimeIdentifier">IBCocoaTouchFramework</string>
+						<string key="IBUIText">Results Tab</string>
+						<object class="NSFont" key="IBUIFont">
+							<string key="NSName">Helvetica</string>
+							<double key="NSSize">24</double>
+							<int key="NSfFlags">16</int>
+						</object>
+						<object class="NSColor" key="IBUITextColor">
+							<int key="NSColorSpace">1</int>
+							<bytes key="NSRGB">MCAwIDAAA</bytes>
+						</object>
+						<nil key="IBUIHighlightedColor"/>
+						<int key="IBUIBaselineAdjustment">1</int>
+						<float key="IBUIMinimumFontSize">10</float>
+						<int key="IBUITextAlignment">1</int>
+					</object>
+					<object class="IBUITextView" id="255779567">
+						<reference key="NSNextResponder" ref="191373211"/>
+						<int key="NSvFlags">282</int>
+						<string key="NSFrame">{{20, 274}, {280, 117}}</string>
+						<reference key="NSSuperview" ref="191373211"/>
+						<reference key="NSWindow"/>
+						<bool key="IBUIOpaque">NO</bool>
+						<bool key="IBUIClipsSubviews">YES</bool>
+						<bool key="IBUIMultipleTouchEnabled">YES</bool>
+						<bool key="IBUIUserInteractionEnabled">NO</bool>
+						<string key="targetRuntimeIdentifier">IBCocoaTouchFramework</string>
+						<bool key="IBUIShowsHorizontalScrollIndicator">NO</bool>
+						<bool key="IBUIDelaysContentTouches">NO</bool>
+						<bool key="IBUICanCancelContentTouches">NO</bool>
+						<float key="IBUIMinimumZoomScale">0.0</float>
+						<float key="IBUIMaximumZoomScale">0.0</float>
+						<bool key="IBUIBouncesZoom">NO</bool>
+						<bool key="IBUIEditable">NO</bool>
+						<string key="IBUIText">No barcode scanned.</string>
+						<object class="IBUITextInputTraits" key="IBUITextInputTraits">
+							<string key="targetRuntimeIdentifier">IBCocoaTouchFramework</string>
+						</object>
+					</object>
+					<object class="IBUIImageView" id="809997790">
+						<reference key="NSNextResponder" ref="191373211"/>
+						<int key="NSvFlags">306</int>
+						<string key="NSFrame">{{20, 56}, {280, 210}}</string>
+						<reference key="NSSuperview" ref="191373211"/>
+						<reference key="NSWindow"/>
+						<int key="IBUIContentMode">1</int>
+						<bool key="IBUIUserInteractionEnabled">NO</bool>
+						<string key="targetRuntimeIdentifier">IBCocoaTouchFramework</string>
+					</object>
+				</object>
+				<string key="NSFrame">{{0, 20}, {320, 411}}</string>
+				<reference key="NSSuperview"/>
+				<reference key="NSWindow"/>
+				<reference key="NSNextKeyView" ref="483052203"/>
+				<object class="NSColor" key="IBUIBackgroundColor">
+					<int key="NSColorSpace">3</int>
+					<bytes key="NSWhite">MQA</bytes>
+				</object>
+				<object class="IBUISimulatedStatusBarMetrics" key="IBUISimulatedStatusBarMetrics"/>
+				<object class="IBUISimulatedTabBarMetrics" key="IBUISimulatedBottomBarMetrics"/>
+				<string key="targetRuntimeIdentifier">IBCocoaTouchFramework</string>
+			</object>
+		</object>
+		<object class="IBObjectContainer" key="IBDocument.Objects">
+			<object class="NSMutableArray" key="connectionRecords">
+				<bool key="EncodedWithXMLCoder">YES</bool>
+				<object class="IBConnectionRecord">
+					<object class="IBCocoaTouchOutletConnection" key="connection">
+						<string key="label">view</string>
+						<reference key="source" ref="372490531"/>
+						<reference key="destination" ref="191373211"/>
+					</object>
+					<int key="connectionID">3</int>
+				</object>
+				<object class="IBConnectionRecord">
+					<object class="IBCocoaTouchOutletConnection" key="connection">
+						<string key="label">resultImage</string>
+						<reference key="source" ref="372490531"/>
+						<reference key="destination" ref="809997790"/>
+					</object>
+					<int key="connectionID">9</int>
+				</object>
+				<object class="IBConnectionRecord">
+					<object class="IBCocoaTouchOutletConnection" key="connection">
+						<string key="label">resultText</string>
+						<reference key="source" ref="372490531"/>
+						<reference key="destination" ref="255779567"/>
+					</object>
+					<int key="connectionID">10</int>
+				</object>
+			</object>
+			<object class="IBMutableOrderedSet" key="objectRecords">
+				<object class="NSArray" key="orderedObjects">
+					<bool key="EncodedWithXMLCoder">YES</bool>
+					<object class="IBObjectRecord">
+						<int key="objectID">0</int>
+						<reference key="object" ref="0"/>
+						<reference key="children" ref="1000"/>
+						<nil key="parent"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">1</int>
+						<reference key="object" ref="191373211"/>
+						<object class="NSMutableArray" key="children">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<reference ref="255779567"/>
+							<reference ref="483052203"/>
+							<reference ref="809997790"/>
+						</object>
+						<reference key="parent" ref="0"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">-1</int>
+						<reference key="object" ref="372490531"/>
+						<reference key="parent" ref="0"/>
+						<string key="objectName">File's Owner</string>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">-2</int>
+						<reference key="object" ref="263589821"/>
+						<reference key="parent" ref="0"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">5</int>
+						<reference key="object" ref="483052203"/>
+						<reference key="parent" ref="191373211"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">7</int>
+						<reference key="object" ref="255779567"/>
+						<reference key="parent" ref="191373211"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">8</int>
+						<reference key="object" ref="809997790"/>
+						<reference key="parent" ref="191373211"/>
+					</object>
+				</object>
+			</object>
+			<object class="NSMutableDictionary" key="flattenedProperties">
+				<bool key="EncodedWithXMLCoder">YES</bool>
+				<object class="NSArray" key="dict.sortedKeys">
+					<bool key="EncodedWithXMLCoder">YES</bool>
+					<string>-1.CustomClassName</string>
+					<string>-2.CustomClassName</string>
+					<string>1.IBEditorWindowLastContentRect</string>
+					<string>1.IBPluginDependency</string>
+					<string>5.IBPluginDependency</string>
+					<string>7.IBPluginDependency</string>
+					<string>7.IBViewBoundsToFrameTransform</string>
+					<string>8.IBPluginDependency</string>
+				</object>
+				<object class="NSMutableArray" key="dict.values">
+					<bool key="EncodedWithXMLCoder">YES</bool>
+					<string>ResultsViewController</string>
+					<string>UIResponder</string>
+					<string>{{187, 376}, {320, 480}}</string>
+					<string>com.apple.InterfaceBuilder.IBCocoaTouchPlugin</string>
+					<string>com.apple.InterfaceBuilder.IBCocoaTouchPlugin</string>
+					<string>com.apple.InterfaceBuilder.IBCocoaTouchPlugin</string>
+					<object class="NSAffineTransform">
+						<bytes key="NSTransformStruct">P4AAAL+AAABA4AAAw7GAAA</bytes>
+					</object>
+					<string>com.apple.InterfaceBuilder.IBCocoaTouchPlugin</string>
+				</object>
+			</object>
+			<object class="NSMutableDictionary" key="unlocalizedProperties">
+				<bool key="EncodedWithXMLCoder">YES</bool>
+				<reference key="dict.sortedKeys" ref="0"/>
+				<reference key="dict.values" ref="0"/>
+			</object>
+			<nil key="activeLocalization"/>
+			<object class="NSMutableDictionary" key="localizations">
+				<bool key="EncodedWithXMLCoder">YES</bool>
+				<reference key="dict.sortedKeys" ref="0"/>
+				<reference key="dict.values" ref="0"/>
+			</object>
+			<nil key="sourceID"/>
+			<int key="maxID">10</int>
+		</object>
+		<object class="IBClassDescriber" key="IBDocument.Classes">
+			<object class="NSMutableArray" key="referencedPartialClassDescriptions">
+				<bool key="EncodedWithXMLCoder">YES</bool>
+				<object class="IBPartialClassDescription">
+					<string key="className">ResultsViewController</string>
+					<string key="superclassName">UIViewController</string>
+					<object class="NSMutableDictionary" key="outlets">
+						<bool key="EncodedWithXMLCoder">YES</bool>
+						<object class="NSArray" key="dict.sortedKeys">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<string>resultImage</string>
+							<string>resultText</string>
+						</object>
+						<object class="NSMutableArray" key="dict.values">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<string>UIImageView</string>
+							<string>UITextView</string>
+						</object>
+					</object>
+					<object class="NSMutableDictionary" key="toOneOutletInfosByName">
+						<bool key="EncodedWithXMLCoder">YES</bool>
+						<object class="NSArray" key="dict.sortedKeys">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<string>resultImage</string>
+							<string>resultText</string>
+						</object>
+						<object class="NSMutableArray" key="dict.values">
+							<bool key="EncodedWithXMLCoder">YES</bool>
+							<object class="IBToOneOutletInfo">
+								<string key="name">resultImage</string>
+								<string key="candidateClassName">UIImageView</string>
+							</object>
+							<object class="IBToOneOutletInfo">
+								<string key="name">resultText</string>
+								<string key="candidateClassName">UITextView</string>
+							</object>
+						</object>
+					</object>
+					<object class="IBClassDescriptionSource" key="sourceIdentifier">
+						<string key="majorKey">IBProjectSource</string>
+						<string key="minorKey">./Classes/ResultsViewController.h</string>
+					</object>
+				</object>
+			</object>
+		</object>
+		<int key="IBDocument.localizationMode">0</int>
+		<string key="IBDocument.TargetRuntimeIdentifier">IBCocoaTouchFramework</string>
+		<object class="NSMutableDictionary" key="IBDocument.PluginDeclaredDependencyDefaults">
+			<string key="NS.key.0">com.apple.InterfaceBuilder.CocoaTouchPlugin.iPhoneOS</string>
+			<integer value="1024" key="NS.object.0"/>
+		</object>
+		<object class="NSMutableDictionary" key="IBDocument.PluginDeclaredDevelopmentDependencies">
+			<string key="NS.key.0">com.apple.InterfaceBuilder.CocoaTouchPlugin.InterfaceBuilder3</string>
+			<integer value="3100" key="NS.object.0"/>
+		</object>
+		<bool key="IBDocument.PluginDeclaredDependenciesTrackSystemTargetVersion">YES</bool>
+		<int key="IBDocument.defaultPropertyAccessControl">3</int>
+		<string key="IBCocoaTouchPluginVersion">301</string>
+	</data>
+</archive>
diff -r 563557a923d0 iphone/examples/TabReader/TabReader/main.m
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/examples/TabReader/TabReader/main.m	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,16 @@
+//
+//  main.m
+//  TabReader
+//
+//  Created by spadix on 5/3/11.
+//
+
+#import <UIKit/UIKit.h>
+
+int main(int argc, char *argv[])
+{
+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+    int retVal = UIApplicationMain(argc, argv, nil, nil);
+    [pool release];
+    return retVal;
+}
diff -r 563557a923d0 iphone/examples/TabReader/ZBarSDK
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/examples/TabReader/ZBarSDK	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,1 @@
+../../build/Debug-iphoneos/ZBarSDK
\ No newline at end of file
diff -r 563557a923d0 iphone/examples/TabReader/build
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/examples/TabReader/build	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,1 @@
+/tmp/TabReader.build
\ No newline at end of file
diff -r 563557a923d0 iphone/examples/readertest/Default-568h@2x.png
Binary file iphone/examples/readertest/Default-568h@2x.png has changed
diff -r 563557a923d0 iphone/examples/readertest/ZBarSDK
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/examples/readertest/ZBarSDK	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,1 @@
+../../build/Debug-iphoneos/ZBarSDK
\ No newline at end of file
diff -r 563557a923d0 iphone/examples/readertest/build
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/examples/readertest/build	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,1 @@
+/tmp/readertest.build
\ No newline at end of file
diff -r 563557a923d0 iphone/examples/readertest/entitlements.plist
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/examples/readertest/entitlements.plist	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
+<plist version="1.0">
+<dict>
+	<key>get-task-allow</key>
+	<false/>
+</dict>
+</plist>
diff -r 563557a923d0 iphone/examples/readertest/prefix.pch
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/examples/readertest/prefix.pch	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,11 @@
+#ifdef __OBJC__
+# import <Foundation/Foundation.h>
+# import <CoreFoundation/CoreFoundation.h>
+# import <CoreGraphics/CoreGraphics.h>
+# import <UIKit/UIKit.h>
+# import <QuartzCore/QuartzCore.h>
+# import <AVFoundation/AVFoundation.h>
+# import <CoreMedia/CoreMedia.h>
+# import <CoreVideo/CoreVideo.h>
+# import "ZBarSDK.h"
+#endif
diff -r 563557a923d0 iphone/examples/readertest/readertest.m
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/examples/readertest/readertest.m	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,991 @@
+enum {
+    CLASS_SECTION = 0,
+    SOURCE_SECTION,
+    CAMODE_SECTION,
+    DEVICE_SECTION,
+    FLASH_SECTION,
+    QUALITY_SECTION,
+    CONFIG_SECTION,
+    CUSTOM_SECTION,
+    SYMBOL_SECTION,
+    RESULT_SECTION,
+    NUM_SECTIONS
+};
+
+static NSString* const section_titles[] = {
+    @"Classes",
+    @"SourceType",
+    @"CameraMode",
+    @"CaptureDevice",
+    @"CameraFlashMode",
+    @"VideoQuality",
+    @"Reader Configuration",
+    nil,
+    @"Enabled Symbologies",
+    @"Decode Results",
+};
+
+static const CGRect const crop_choices[] = {
+    { { 0, 0 }, { 1, 1 } },
+    { { .125, 0 }, { .75, 1 } },
+    { { 0, .3 }, { 1, .4 } },
+    { { 0, 0 }, { 0, 0 } }
+};
+
+static const NSInteger const density_choices[] = {
+    3, 2, 1, 0, 4, -1
+};
+
+static const CGFloat const zoom_choices[] = {
+    1, 10/9., 10/8., 8/6., 10/7., 9/6., 10/6., 7/4., 2, 0, -1
+};
+
+@interface AppDelegate
+    : UITableViewController
+    < UIApplicationDelegate,
+      UINavigationControllerDelegate,
+      UITableViewDelegate,
+      UITableViewDataSource,
+      UIActionSheetDelegate,
+      ZBarReaderDelegate >
+{
+    UIWindow *window;
+    UINavigationController *nav;
+
+    NSSet *defaultSymbologies;
+    CGFloat zoom;
+
+    NSMutableArray *sections, *symbolEnables;
+    NSInteger xDensity, yDensity;
+
+    BOOL found, paused, continuous;
+    NSInteger dataHeight;
+    UILabel *typeLabel, *dataLabel;
+    UIImageView *imageView;
+
+    ZBarReaderViewController *reader;
+    UIView *overlay;
+    UIBarButtonItem *manualBtn;
+    UILabel *typeOvl, *dataOvl;
+    NSArray *masks;
+}
+
+@end
+
+
+@implementation AppDelegate
+
+- (id) init
+{
+    return([super initWithStyle: UITableViewStyleGrouped]);
+}
+
+- (void) initReader: (NSString*) clsName
+{
+    [reader release];
+    Class cls = [[NSBundle mainBundle]
+                    classNamed: clsName];
+    assert(cls);
+    reader = [cls new];
+    assert(reader);
+    reader.readerDelegate = self;
+    xDensity = yDensity = 3;
+
+#if 0
+    // apply defaults for demo
+    ZBarImageScanner *scanner = reader.scanner;
+    continuous = NO;
+    zoom = 1;
+    reader.showsZBarControls = NO;
+    reader.scanCrop = CGRectMake(0, .35, 1, .3);
+
+    [defaultSymbologies release];
+    defaultSymbologies =
+        [[NSSet alloc]
+            initWithObjects:
+                [NSNumber numberWithInteger: ZBAR_CODE128],
+                nil];
+    [scanner setSymbology: 0
+             config: ZBAR_CFG_ENABLE
+             to: 0];
+    for(NSNumber *sym in defaultSymbologies)
+        [scanner setSymbology: sym.integerValue
+                 config: ZBAR_CFG_ENABLE
+                 to: 1];
+
+    [scanner setSymbology: 0
+             config: ZBAR_CFG_X_DENSITY
+             to: (xDensity = 0)];
+    [scanner setSymbology: 0
+             config: ZBAR_CFG_Y_DENSITY
+             to: (yDensity = 1)];
+#endif
+}
+
+- (void) initOverlay
+{
+    overlay = [[UIView alloc]
+                  initWithFrame: CGRectMake(0, 426, 320, 54)];
+    overlay.backgroundColor = [UIColor clearColor];
+
+    masks = [[NSArray alloc]
+                initWithObjects:
+                    [[[UIView alloc]
+                         initWithFrame: CGRectMake(0, -426, 320, 0)]
+                        autorelease],
+                    [[[UIView alloc]
+                         initWithFrame: CGRectMake(0, -426, 0, 426)]
+                        autorelease],
+                    [[[UIView alloc]
+                         initWithFrame: CGRectMake(0, 0, 320, 0)]
+                        autorelease],
+                    [[[UIView alloc]
+                         initWithFrame: CGRectMake(320, -426, 0, 426)]
+                        autorelease],
+                nil];
+    for(UIView *mask in masks) {
+        mask.backgroundColor = [UIColor colorWithWhite: 0
+                                        alpha: .5];
+        [overlay addSubview: mask];
+    }
+
+    UILabel *label =
+        [[UILabel alloc]
+            initWithFrame: CGRectMake(0, -426, 320, 48)];
+    label.backgroundColor = [UIColor clearColor];
+    label.textColor = [UIColor whiteColor];
+    label.font = [UIFont boldSystemFontOfSize: 24];
+    label.text = @"Custom Overlay";
+    [overlay addSubview: label];
+    [label release];
+
+    typeOvl = [[UILabel alloc]
+                  initWithFrame: CGRectMake(0, -378, 80, 24)];
+    typeOvl.backgroundColor = [UIColor clearColor];
+    typeOvl.textColor = [UIColor whiteColor];
+    typeOvl.font = [UIFont systemFontOfSize: 16];
+    typeOvl.textAlignment = UITextAlignmentCenter;
+    [overlay addSubview: typeOvl];
+
+    dataOvl = [[UILabel alloc]
+                  initWithFrame: CGRectMake(96, -378, 224, 24)];
+    dataOvl.backgroundColor = [UIColor clearColor];
+    dataOvl.textColor = [UIColor whiteColor];
+    dataOvl.font = [UIFont systemFontOfSize: 16];
+    [overlay addSubview: dataOvl];
+
+    UIToolbar *toolbar =
+        [[UIToolbar alloc]
+            initWithFrame: CGRectMake(0, 0, 320, 54)];
+    toolbar.tintColor = [UIColor colorWithRed: .5
+                                     green: 0
+                                     blue: 0
+                                     alpha: 1];
+    [manualBtn release];
+    manualBtn = [[UIBarButtonItem alloc]
+                    initWithBarButtonSystemItem: UIBarButtonSystemItemCamera
+                    target: self
+                    action: @selector(manualCapture)];
+
+
+    UIButton *info =
+        [UIButton buttonWithType: UIButtonTypeInfoLight];
+    [info addTarget: self
+          action: @selector(info)
+          forControlEvents: UIControlEventTouchUpInside];
+
+    toolbar.items =
+        [NSArray arrayWithObjects:
+            [[[UIBarButtonItem alloc]
+                 initWithTitle: @"X"
+                 style: UIBarButtonItemStylePlain
+                 target: self
+                 action: @selector(imagePickerControllerDidCancel:)]
+                autorelease],
+            [[[UIBarButtonItem alloc]
+                 initWithBarButtonSystemItem: UIBarButtonSystemItemFlexibleSpace
+                 target: nil
+                 action: nil]
+                autorelease],
+            manualBtn,
+            [[[UIBarButtonItem alloc]
+                 initWithBarButtonSystemItem: UIBarButtonSystemItemFlexibleSpace
+                 target: nil
+                 action: nil]
+                autorelease],
+            [[[UIBarButtonItem alloc]
+                 initWithBarButtonSystemItem: UIBarButtonSystemItemPause
+                 target: self
+                 action: @selector(pause)]
+                autorelease],
+            [[[UIBarButtonItem alloc]
+                 initWithBarButtonSystemItem: UIBarButtonSystemItemFlexibleSpace
+                 target: nil
+                 action: nil]
+                autorelease],
+            [[[UIBarButtonItem alloc]
+                 initWithCustomView: info]
+                autorelease],
+            nil];
+    [overlay addSubview: toolbar];
+    [toolbar release];
+}
+
+- (void) updateCropMask
+{
+    CGRect r = reader.scanCrop;
+    r.origin.x *= 426;
+    r.origin.y *= 320;
+    r.size.width *= 426;
+    r.size.height *= 320;
+    UIView *mask = [masks objectAtIndex: 0];
+    mask.frame = CGRectMake(0, -426, 320, r.origin.x);
+    mask = [masks objectAtIndex: 1];
+    mask.frame = CGRectMake(0, r.origin.x - 426, r.origin.y, r.size.width);
+
+    r.origin.y += r.size.height;
+    mask = [masks objectAtIndex: 2];
+    mask.frame = CGRectMake(r.origin.y, r.origin.x - 426,
+                            320 - r.origin.y, r.size.width);
+
+    r.origin.x += r.size.width;
+    mask = [masks objectAtIndex: 3];
+    mask.frame = CGRectMake(0, r.origin.x - 426, 320, 426 - r.origin.x);
+}
+
+- (void) setCheck: (BOOL) state
+          forCell: (UITableViewCell*) cell
+{
+    cell.accessoryType =
+        ((state)
+         ? UITableViewCellAccessoryCheckmark
+         : UITableViewCellAccessoryNone);
+}
+
+- (void) setCheckForTag: (int) tag
+              inSection: (int) section
+{
+    for(UITableViewCell *cell in [sections objectAtIndex: section])
+        [self setCheck: (cell.tag == tag)
+              forCell: cell];
+}
+
+- (void) setCheckForName: (NSString*) name
+               inSection: (int) section
+{
+    for(UITableViewCell *cell in [sections objectAtIndex: section])
+        [self setCheck: [name isEqualToString: cell.textLabel.text]
+              forCell: cell];
+}
+
+- (void) applicationDidFinishLaunching: (UIApplication*) application
+{
+    self.title = @"ZBar Reader Test";
+
+    nav = [[UINavigationController alloc]
+              initWithRootViewController: self];
+    nav.delegate = self;
+
+    window = [[UIWindow alloc] initWithFrame: [[UIScreen mainScreen] bounds]];
+    [window addSubview: nav.view];
+    [window makeKeyAndVisible];
+
+    [self initReader: @"ZBarReaderViewController"];
+}
+
+- (UITableViewCell*) cellWithTitle: (NSString*) title
+                               tag: (NSInteger) tag
+                           checked: (BOOL) checked
+{
+    UITableViewCell *cell = [UITableViewCell new];
+    cell.textLabel.text = title;
+    cell.tag = tag;
+    [self setCheck: checked
+          forCell: cell];
+    return([cell autorelease]);
+}
+
+- (void) initControlCells
+{
+    // NB don't need SourceTypeSavedPhotosAlbum
+    static NSString* const sourceNames[] = {
+        @"Library", @"Camera", @"Album", nil
+    };
+    NSMutableArray *sources = [NSMutableArray array];
+    for(int i = 0; sourceNames[i]; i++)
+        if([[reader class] isSourceTypeAvailable: i])
+            [sources addObject:
+                [self cellWithTitle: sourceNames[i]
+                      tag: i
+                      checked: (reader.sourceType == i)]];
+    [sections replaceObjectAtIndex: SOURCE_SECTION
+              withObject: sources];
+
+    static NSString* const modeNames[] = {
+        @"Default", @"Sampling", @"Sequence", nil
+    };
+    NSMutableArray *modes = [NSMutableArray array];
+    for(int i = 0; modeNames[i]; i++)
+        [modes addObject:
+            [self cellWithTitle: modeNames[i]
+                  tag: i
+                  checked: (reader.cameraMode == i)]];
+    [sections replaceObjectAtIndex: CAMODE_SECTION
+              withObject: modes];
+
+    static NSString *const deviceNames[] = {
+        @"Rear", @"Front", nil
+    };
+    NSMutableArray *devices = [NSMutableArray array];
+    for(int i = 0; deviceNames[i]; i++)
+        if([[reader class]
+               isCameraDeviceAvailable: i])
+            [devices addObject:
+                [self cellWithTitle: deviceNames[i]
+                      tag: i
+                      checked: (reader.cameraDevice == i)]];
+    assert(devices.count);
+    [sections replaceObjectAtIndex: DEVICE_SECTION
+              withObject: devices];
+
+    static NSString *const flashNames[] = {
+        @"Off", @"Auto", @"On", nil
+    };
+    NSMutableArray *flashModes = [NSMutableArray array];
+    for(int i = 0; flashNames[i]; i++)
+        [flashModes addObject:
+            [self cellWithTitle: flashNames[i]
+                  tag: i - 1
+                  checked: (reader.cameraFlashMode == i - 1)]];
+    [sections replaceObjectAtIndex: FLASH_SECTION
+              withObject: flashModes];
+
+    static NSString *const qualityNames[] = {
+        @"High", @"Medium", @"Low", @"640x480", nil
+    };
+    NSMutableArray *qualities = [NSMutableArray array];
+    for(int i = 0; qualityNames[i]; i++)
+        [qualities addObject:
+            [self cellWithTitle: qualityNames[i]
+                  tag: i
+                  checked: (reader.videoQuality == i)]];
+    [sections replaceObjectAtIndex: QUALITY_SECTION
+              withObject: qualities];
+
+    static NSString* const configNames[] = {
+        @"showsCameraControls", @"showsZBarControls", @"tracksSymbols",
+        @"enableCache", @"showsHelpOnFail", @"takesPicture",
+        nil
+    };
+    NSMutableArray *configs = [NSMutableArray array];
+    for(int i = 0; configNames[i]; i++)
+        @try {
+            BOOL checked = [[reader valueForKey: configNames[i]] boolValue];
+            [configs addObject:
+                [self cellWithTitle: configNames[i]
+                      tag: i
+                      checked: checked]];
+        }
+        @catch(...) { }
+    [sections replaceObjectAtIndex: CONFIG_SECTION
+              withObject: configs];
+
+    UITableViewCell *xDensityCell =
+        [[[UITableViewCell alloc]
+             initWithStyle: UITableViewCellStyleValue1
+             reuseIdentifier: nil]
+            autorelease];
+    xDensityCell.textLabel.text = @"CFG_X_DENSITY";
+    xDensityCell.detailTextLabel.tag = ZBAR_CFG_X_DENSITY;
+    xDensityCell.detailTextLabel.text =
+        [NSString stringWithFormat: @"%d", xDensity];
+
+    UITableViewCell *yDensityCell =
+        [[[UITableViewCell alloc]
+             initWithStyle: UITableViewCellStyleValue1
+             reuseIdentifier: nil]
+            autorelease];
+    yDensityCell.textLabel.text = @"CFG_Y_DENSITY";
+    yDensityCell.detailTextLabel.tag = ZBAR_CFG_Y_DENSITY;
+    yDensityCell.detailTextLabel.text =
+        [NSString stringWithFormat: @"%d", yDensity];
+
+    UITableViewCell *cropCell =
+        [[[UITableViewCell alloc]
+             initWithStyle: UITableViewCellStyleValue1
+             reuseIdentifier: nil]
+            autorelease];
+    cropCell.textLabel.text = @"scanCrop";
+    cropCell.detailTextLabel.text = NSStringFromCGRect(reader.scanCrop);
+
+    UITableViewCell *zoomCell =
+        [[[UITableViewCell alloc]
+             initWithStyle: UITableViewCellStyleValue1
+             reuseIdentifier: nil]
+            autorelease];
+    zoomCell.textLabel.text = @"zoom";
+    zoomCell.detailTextLabel.text =
+        [NSString stringWithFormat: @"%g", zoom];
+
+    [sections replaceObjectAtIndex: CUSTOM_SECTION
+              withObject: [NSArray arrayWithObjects:
+                              xDensityCell,
+                              yDensityCell,
+                              cropCell,
+                              zoomCell,
+                              [self cellWithTitle: @"continuous"
+                                    tag: 1
+                                    checked: continuous],
+                              nil]];
+
+    static const zbar_symbol_type_t allSymbologies[] = {
+        ZBAR_QRCODE, ZBAR_CODE128, ZBAR_CODE93, ZBAR_CODE39, ZBAR_CODABAR,
+        ZBAR_I25, ZBAR_DATABAR, ZBAR_DATABAR_EXP,
+        ZBAR_EAN13, ZBAR_EAN8, 
+        ZBAR_EAN2, ZBAR_EAN5, ZBAR_COMPOSITE,
+        ZBAR_UPCA, ZBAR_UPCE,
+        ZBAR_ISBN13, ZBAR_ISBN10,
+        0
+    };
+    NSMutableArray *symbols = [NSMutableArray array];
+    [symbolEnables release];
+    symbolEnables = [NSMutableArray new];
+    BOOL en = YES;
+    for(int i = 0; allSymbologies[i]; i++) {
+        zbar_symbol_type_t sym = allSymbologies[i];
+        if(defaultSymbologies)
+            en = !![defaultSymbologies member:
+                       [NSNumber numberWithInteger: sym]];
+        else
+            /* symbologies after ZBAR_EAN5 are disabled by default */
+            en = en && (sym != ZBAR_EAN2);
+        [symbols addObject:
+            [self cellWithTitle: [ZBarSymbol nameForType: sym]
+                  tag: sym
+                  checked: en]];
+        [symbolEnables addObject: [NSNumber numberWithBool: en]];
+    }
+    [sections replaceObjectAtIndex: SYMBOL_SECTION
+              withObject: symbols];
+
+    [self.tableView reloadData];
+}
+
+- (void) viewDidLoad
+{
+    [super viewDidLoad];
+
+    UITableView *view = self.tableView;
+    view.delegate = self;
+    view.dataSource = self;
+
+    [self initOverlay];
+    [self updateCropMask];
+
+    sections = [[NSMutableArray alloc]
+                   initWithCapacity: NUM_SECTIONS];
+    for(int i = 0; i < NUM_SECTIONS; i++)
+        [sections addObject: [NSNull null]];
+
+    NSArray *classes =
+        [NSArray arrayWithObjects:
+            [self cellWithTitle: @"ZBarReaderViewController"
+                  tag: 0
+                  checked: YES],
+            [self cellWithTitle: @"ZBarReaderController"
+                  tag: 1
+                  checked: NO],
+            nil];
+    [sections replaceObjectAtIndex: CLASS_SECTION
+              withObject: classes];
+
+    UITableViewCell *typeCell = [UITableViewCell new];
+    typeLabel = [typeCell.textLabel retain];
+    UITableViewCell *dataCell = [UITableViewCell new];
+    dataLabel = [dataCell.textLabel retain];
+    dataLabel.numberOfLines = 0;
+    dataLabel.lineBreakMode = UILineBreakModeCharacterWrap;
+    UITableViewCell *imageCell = [UITableViewCell new];
+    imageView = [UIImageView new];
+    imageView.contentMode = UIViewContentModeScaleAspectFit;
+    imageView.autoresizingMask = (UIViewAutoresizingFlexibleWidth |
+                                  UIViewAutoresizingFlexibleHeight);
+    UIView *content = imageCell.contentView;
+    imageView.frame = content.bounds;
+    [content addSubview: imageView];
+    [imageView release];
+    NSArray *results =
+        [NSArray arrayWithObjects: typeCell, dataCell, imageCell, nil];
+    [sections replaceObjectAtIndex: RESULT_SECTION
+              withObject: results];
+
+    [self initControlCells];
+}
+
+- (void) viewDidUnload
+{
+    [sections release];
+    sections = nil;
+    [symbolEnables release];
+    symbolEnables = nil;
+    [manualBtn release];
+    manualBtn = nil;
+    [typeLabel release];
+    typeLabel = nil;
+    [dataLabel release];
+    dataLabel = nil;
+    [imageView release];
+    imageView = nil;
+    [typeOvl release];
+    typeOvl = nil;
+    [dataOvl release];
+    dataOvl = nil;
+    [overlay release];
+    overlay = nil;
+    [masks release];
+    masks = nil;
+    [super viewDidUnload];
+}
+
+- (void) dealloc
+{
+    [reader release];
+    reader = nil;
+    [nav release];
+    nav = nil;
+    [window release];
+    window = nil;
+    [super dealloc];
+}
+
+- (BOOL) shouldAutorotateToInterfaceOrientation: (UIInterfaceOrientation) orient
+{
+    return(YES);
+}
+
+- (void) scan
+{
+    found = paused = NO;
+    imageView.image = nil;
+    typeLabel.text = nil;
+    dataLabel.text = nil;
+    typeOvl.text = nil;
+    dataOvl.text = nil;
+    [self.tableView reloadData];
+    if(reader.sourceType == UIImagePickerControllerSourceTypeCamera)
+        reader.cameraOverlayView = (reader.showsZBarControls) ? nil : overlay;
+    if([reader respondsToSelector: @selector(readerView)]) {
+        reader.readerView.showsFPS = YES;
+        if(zoom)
+            reader.readerView.zoom = zoom;
+        reader.supportedOrientationsMask = (reader.showsZBarControls)
+            ? ZBarOrientationMaskAll
+            : ZBarOrientationMask(UIInterfaceOrientationPortrait); // tmp disable
+    }
+    manualBtn.enabled = TARGET_IPHONE_SIMULATOR ||
+        (reader.cameraMode == ZBarReaderControllerCameraModeDefault) ||
+        [reader isKindOfClass: [ZBarReaderViewController class]];
+    [self presentModalViewController: reader
+          animated: YES];
+}
+
+- (void) help
+{
+    ZBarHelpController *help =
+        [[ZBarHelpController alloc]
+            initWithReason: @"TEST"];
+    [self presentModalViewController: help
+          animated: YES];
+    [help release];
+}
+
+- (void) info
+{
+    [reader showHelpWithReason: @"INFO"];
+}
+
+- (void) pause
+{
+    if(![reader respondsToSelector: @selector(readerView)])
+        return;
+    paused = !paused;
+    if(paused)
+        [reader.readerView stop];
+    else
+        [reader.readerView start];
+}
+
+- (void) manualCapture
+{
+    [(UIImagePickerController*)reader takePicture];
+}
+
+// UINavigationControllerDelegate
+
+- (void) navigationController: (UINavigationController*) _nav
+       willShowViewController: (UIViewController*) vc
+                     animated: (BOOL) animated
+{
+    self.navigationItem.leftBarButtonItem =
+        [[[UIBarButtonItem alloc]
+             initWithTitle: @"Help"
+             style: UIBarButtonItemStyleDone
+             target: self
+             action: @selector(help)]
+            autorelease];
+    self.navigationItem.rightBarButtonItem =
+        [[[UIBarButtonItem alloc]
+             initWithTitle: @"Scan!"
+             style: UIBarButtonItemStyleDone
+             target: self
+             action: @selector(scan)]
+            autorelease];
+}
+
+// UITableViewDataSource
+
+- (NSInteger) numberOfSectionsInTableView: (UITableView*) view
+{
+    return(sections.count - !found);
+}
+
+- (NSInteger) tableView: (UITableView*) view
+  numberOfRowsInSection: (NSInteger) idx
+{
+    NSArray *section = [sections objectAtIndex: idx];
+    return(section.count);
+}
+
+- (UITableViewCell*) tableView: (UITableView*) view
+         cellForRowAtIndexPath: (NSIndexPath*) path
+{
+    return([[sections objectAtIndex: path.section]
+               objectAtIndex: path.row]);
+}
+
+- (NSString*)  tableView: (UITableView*) view
+ titleForHeaderInSection: (NSInteger) idx
+{
+    assert(idx < NUM_SECTIONS);
+    return(section_titles[idx]);
+}
+
+// UITableViewDelegate
+
+- (NSIndexPath*) tableView: (UITableView*) view
+  willSelectRowAtIndexPath: (NSIndexPath*) path
+{
+    if(path.section == RESULT_SECTION && path.row != 2)
+        return(nil);
+    return(path);
+}
+
+- (void) alertUnsupported
+{
+    UIAlertView *alert =
+        [[UIAlertView alloc]
+            initWithTitle: @"Unsupported"
+            message: @"Setting not available for this reader"
+            @" (or with this OS on this device)"
+            delegate: nil
+            cancelButtonTitle: @"Cancel"
+            otherButtonTitles: nil];
+    [alert show];
+    [alert release];
+}
+
+- (void) advanceCrop: (UILabel*) label
+{
+    CGRect r = CGRectFromString(label.text);
+    int i;
+    for(i = 0; crop_choices[i].size.width;)
+        if(CGRectEqualToRect(r, crop_choices[i++]))
+            break;
+    if(!crop_choices[i].size.width)
+        i = 0;
+    r = crop_choices[i];
+    reader.scanCrop = r;
+    label.text = NSStringFromCGRect(r);
+
+    [self updateCropMask];
+}
+
+- (void) advanceZoom: (UILabel*) label
+{
+    int i;
+    for(i = 0; zoom_choices[i] >= 0;)
+        if(zoom == zoom_choices[i++])
+            break;
+    if(zoom_choices[i] < 0)
+        i = 0;
+    zoom = zoom_choices[i];
+    assert(zoom >= 0);
+    label.text = [NSString stringWithFormat: @"%g", zoom];
+}
+
+- (void) advanceDensity: (UILabel*) label
+                  value: (NSInteger*) value
+{
+    NSInteger d = *value;
+    int i;
+    for(i = 0; density_choices[i] >= 0;)
+        if(d == density_choices[i++])
+            break;
+    if(density_choices[i] < 0)
+        i = 0;
+    *value = d = density_choices[i];
+    assert(d >= 0);
+    [reader.scanner setSymbology: 0
+           config: label.tag
+           to: d];
+    label.text = [NSString stringWithFormat: @"%d", d];
+}
+
+- (void)       tableView: (UITableView*) view
+ didSelectRowAtIndexPath: (NSIndexPath*) path
+{
+    [view deselectRowAtIndexPath: path
+          animated: YES];
+
+    UITableViewCell *cell = [view cellForRowAtIndexPath: path];
+
+    switch(path.section)
+    {
+    case CLASS_SECTION: {
+        NSString *name = cell.textLabel.text;
+        [self initReader: name];
+        [self updateCropMask];
+        [self initControlCells];
+        [self setCheckForName: name
+              inSection: CLASS_SECTION];
+        break;
+    }
+
+    case SOURCE_SECTION:
+        [self setCheckForTag: reader.sourceType = cell.tag
+              inSection: SOURCE_SECTION];
+        break;
+
+    case CAMODE_SECTION:
+        @try {
+            reader.cameraMode = cell.tag;
+        }
+        @catch (...) {
+            [self alertUnsupported];
+        }
+        [self setCheckForTag: reader.cameraMode
+              inSection: CAMODE_SECTION];
+        break;
+
+    case DEVICE_SECTION:
+        reader.cameraDevice = cell.tag;
+        [self setCheckForTag: reader.cameraDevice
+              inSection: DEVICE_SECTION];
+        break;
+
+    case FLASH_SECTION:
+        reader.cameraFlashMode = cell.tag;
+        [self setCheckForTag: reader.cameraFlashMode
+              inSection: FLASH_SECTION];
+        break;
+
+    case QUALITY_SECTION:
+        reader.videoQuality = cell.tag;
+        [self setCheckForTag: reader.videoQuality
+              inSection: QUALITY_SECTION];
+        break;
+
+    case CONFIG_SECTION: {
+        BOOL state;
+        NSString *key = cell.textLabel.text;
+        state = ![[reader valueForKey: key] boolValue];
+        @try {
+            [reader setValue: [NSNumber numberWithBool: state]
+                    forKey: key];
+        }
+        @catch (...) {
+            [self alertUnsupported];
+        }
+
+        // read back and update current state
+        state = [[reader valueForKey: key] boolValue];
+        [self setCheck: state
+              forCell: cell];
+        break;
+    }
+
+    case CUSTOM_SECTION:
+        switch(path.row)
+        {
+        case 0:
+            [self advanceDensity: cell.detailTextLabel
+                  value: &xDensity];
+            break;
+        case 1:
+            [self advanceDensity: cell.detailTextLabel
+                  value: &yDensity];
+            break;
+        case 2:
+            [self advanceCrop: cell.detailTextLabel];
+            break;
+        case 3:
+            [self advanceZoom: cell.detailTextLabel];
+            break;
+        case 4:
+            [self setCheck: continuous = !continuous
+                  forCell: cell];
+            break;
+        default:
+            assert(0);
+        }
+        break;
+
+    case SYMBOL_SECTION: {
+        BOOL state = ![[symbolEnables objectAtIndex: path.row] boolValue];
+        [symbolEnables replaceObjectAtIndex: path.row
+                       withObject: [NSNumber numberWithBool: state]];
+        [reader.scanner setSymbology: cell.tag
+               config: ZBAR_CFG_ENABLE
+               to: state];
+        [self setCheck: state
+              forCell: cell];
+        break;
+    }
+    case RESULT_SECTION:
+        if(path.row == 2)
+            [[[[UIActionSheet alloc]
+                  initWithTitle: nil
+                  delegate: self
+                  cancelButtonTitle: @"Cancel"
+                  destructiveButtonTitle: nil
+                  otherButtonTitles: @"Save Image", nil]
+                 autorelease]
+                showInView: self.view];
+        break;
+    default:
+        assert(0);
+    }
+}
+
+- (CGFloat)    tableView: (UITableView*) view
+ heightForRowAtIndexPath: (NSIndexPath*) path
+{
+    if(path.section < RESULT_SECTION)
+        return(44);
+
+    switch(path.row) {
+    case 0: return(44);
+    case 1: return(dataHeight);
+    case 2: return(300);
+    default: assert(0);
+    }
+    return(44);
+}
+
+// UIActionSheetDelegate
+
+- (void)  actionSheet: (UIActionSheet*) sheet
+ clickedButtonAtIndex: (NSInteger) idx
+{
+    if(idx == sheet.cancelButtonIndex)
+        return;
+    idx -= sheet.firstOtherButtonIndex;
+    if(!idx) {
+        UIImage *img =
+            [UIImage imageWithData:
+                         UIImagePNGRepresentation(imageView.image)];
+        UIImageWriteToSavedPhotosAlbum(img, nil, NULL, NULL);
+    }
+}
+
+// ZBarReaderDelegate
+
+- (void)  imagePickerController: (UIImagePickerController*) picker
+  didFinishPickingMediaWithInfo: (NSDictionary*) info
+{
+    id <NSFastEnumeration> results =
+        [info objectForKey: ZBarReaderControllerResults];
+    assert(results);
+
+    UIImage *image = [info objectForKey: UIImagePickerControllerOriginalImage];
+    assert(image);
+    if(image)
+        imageView.image = image;
+
+    int quality = 0;
+    ZBarSymbol *bestResult = nil;
+    for(ZBarSymbol *sym in results) {
+        int q = sym.quality;
+        if(quality < q) {
+            quality = q;
+            bestResult = sym;
+        }
+    }
+
+    [self performSelector: @selector(presentResult:)
+          withObject: bestResult
+          afterDelay: .001];
+    if(!continuous)
+        [picker dismissModalViewControllerAnimated: YES];
+}
+
+- (void) presentResult: (ZBarSymbol*) sym
+{
+    found = sym || imageView.image;
+    NSString *typeName = @"NONE";
+    NSString *data = @"";
+    if(sym) {
+        typeName = sym.typeName;
+        data = sym.data;
+    }
+    typeLabel.text = typeName;
+    dataLabel.text = data;
+
+    if(continuous) {
+        typeOvl.text = typeName;
+        dataOvl.text = data;
+    }
+
+    NSLog(@"imagePickerController:didFinishPickingMediaWithInfo:\n");
+    NSLog(@"    type=%@ data=%@\n", typeName, data);
+
+    CGSize size = [data sizeWithFont: [UIFont systemFontOfSize: 17]
+                        constrainedToSize: CGSizeMake(288, 2000)
+                        lineBreakMode: UILineBreakModeCharacterWrap];
+    dataHeight = size.height + 26;
+    if(dataHeight > 2000)
+        dataHeight = 2000;
+
+    [self.tableView reloadData];
+    [self.tableView scrollToRowAtIndexPath:
+             [NSIndexPath indexPathForRow: 0
+                          inSection: RESULT_SECTION]
+         atScrollPosition:UITableViewScrollPositionTop
+         animated: NO];
+}
+
+- (void) imagePickerControllerDidCancel: (UIImagePickerController*) picker
+{
+    NSLog(@"imagePickerControllerDidCancel:\n");
+    [reader dismissModalViewControllerAnimated: YES];
+}
+
+- (void) readerControllerDidFailToRead: (ZBarReaderController*) _reader
+                             withRetry: (BOOL) retry
+{
+    NSLog(@"readerControllerDidFailToRead: retry=%s\n",
+          (retry) ? "YES" : "NO");
+    if(!retry)
+        [_reader dismissModalViewControllerAnimated: YES];
+}
+
+@end
+
+
+int main (int argc, char *argv[])
+{
+    NSAutoreleasePool *pool = [NSAutoreleasePool new];
+    int rc = UIApplicationMain(argc, argv, nil, @"AppDelegate");
+    [pool release];
+    return(rc);
+}
diff -r 563557a923d0 iphone/examples/readertest/readertest.plist
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/examples/readertest/readertest.plist	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,28 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
+<plist version="1.0">
+<dict>
+	<key>CFBundleDevelopmentRegion</key>
+	<string>English</string>
+	<key>CFBundleDisplayName</key>
+	<string>${PRODUCT_NAME}</string>
+	<key>CFBundleExecutable</key>
+	<string>${EXECUTABLE_NAME}</string>
+	<key>CFBundleIconFile</key>
+	<string></string>
+	<key>CFBundleIdentifier</key>
+	<string>net.sourceforge.zbar.test.readertest</string>
+	<key>CFBundleInfoDictionaryVersion</key>
+	<string>6.0</string>
+	<key>CFBundleName</key>
+	<string>${PRODUCT_NAME}</string>
+	<key>CFBundlePackageType</key>
+	<string>APPL</string>
+	<key>CFBundleSignature</key>
+	<string>????</string>
+	<key>CFBundleVersion</key>
+	<string>1.0</string>
+	<key>LSRequiresIPhoneOS</key>
+	<true/>
+</dict>
+</plist>
diff -r 563557a923d0 iphone/examples/readertest/readertest.xcodeproj/project.pbxproj
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/examples/readertest/readertest.xcodeproj/project.pbxproj	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,351 @@
+// !$*UTF8*$!
+{
+	archiveVersion = 1;
+	classes = {
+	};
+	objectVersion = 45;
+	objects = {
+
+/* Begin PBXBuildFile section */
+		1D60589F0D05DD5A006BFB54 /* Foundation.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 1D30AB110D05D00D00671497 /* Foundation.framework */; };
+		1DF5F4E00D08C38300B7A737 /* UIKit.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 1DF5F4DF0D08C38300B7A737 /* UIKit.framework */; };
+		288765FD0DF74451002DB57D /* CoreGraphics.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 288765FC0DF74451002DB57D /* CoreGraphics.framework */; };
+		DC48C4D61219E5F70047193B /* libzbar.a in Frameworks */ = {isa = PBXBuildFile; fileRef = DC48C4D01219E5F70047193B /* libzbar.a */; };
+		DC48C4D71219E5F70047193B /* zbar-back.png in Resources */ = {isa = PBXBuildFile; fileRef = DC48C4D21219E5F70047193B /* zbar-back.png */; };
+		DC48C4D81219E5F70047193B /* zbar-help.html in Resources */ = {isa = PBXBuildFile; fileRef = DC48C4D31219E5F70047193B /* zbar-help.html */; };
+		DC48C4D91219E5F70047193B /* zbar-helpicons.png in Resources */ = {isa = PBXBuildFile; fileRef = DC48C4D41219E5F70047193B /* zbar-helpicons.png */; };
+		DC48C4DA1219E5F70047193B /* zbar-samples.png in Resources */ = {isa = PBXBuildFile; fileRef = DC48C4D51219E5F70047193B /* zbar-samples.png */; };
+		DC824600162B568A0010B2E6 /* Default-568h@2x.png in Resources */ = {isa = PBXBuildFile; fileRef = DC8245FF162B568A0010B2E6 /* Default-568h@2x.png */; };
+		DCB9118510BC5DA200B907F0 /* QuartzCore.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = DCB9118410BC5DA200B907F0 /* QuartzCore.framework */; };
+		DCB9118810BC5DB500B907F0 /* libiconv.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = DCD6E13B10B0AFD4002005CD /* libiconv.dylib */; };
+		DCD6E0D010B0AD41002005CD /* readertest.m in Sources */ = {isa = PBXBuildFile; fileRef = DCD6E0CF10B0AD41002005CD /* readertest.m */; };
+		DCDC6D9B11ACA23000021380 /* CoreVideo.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = DCDC6D9A11ACA23000021380 /* CoreVideo.framework */; settings = {ATTRIBUTES = (Weak, ); }; };
+		DCDC6D9F11ACA23900021380 /* CoreMedia.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = DCDC6D9E11ACA23900021380 /* CoreMedia.framework */; settings = {ATTRIBUTES = (Weak, ); }; };
+		DCDC6DEC11ACA5B400021380 /* AVFoundation.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = DCDC6DEB11ACA5B400021380 /* AVFoundation.framework */; settings = {ATTRIBUTES = (Weak, ); }; };
+/* End PBXBuildFile section */
+
+/* Begin PBXFileReference section */
+		1D30AB110D05D00D00671497 /* Foundation.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = Foundation.framework; path = System/Library/Frameworks/Foundation.framework; sourceTree = SDKROOT; };
+		1D6058910D05DD3D006BFB54 /* readertest.app */ = {isa = PBXFileReference; explicitFileType = wrapper.application; includeInIndex = 0; path = readertest.app; sourceTree = BUILT_PRODUCTS_DIR; };
+		1DF5F4DF0D08C38300B7A737 /* UIKit.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = UIKit.framework; path = System/Library/Frameworks/UIKit.framework; sourceTree = SDKROOT; };
+		288765FC0DF74451002DB57D /* CoreGraphics.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = CoreGraphics.framework; path = System/Library/Frameworks/CoreGraphics.framework; sourceTree = SDKROOT; };
+		DC48C4BE1219E5F70047193B /* Decoder.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Decoder.h; sourceTree = "<group>"; };
+		DC48C4BF1219E5F70047193B /* Exception.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Exception.h; sourceTree = "<group>"; };
+		DC48C4C01219E5F70047193B /* Image.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Image.h; sourceTree = "<group>"; };
+		DC48C4C11219E5F70047193B /* ImageScanner.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ImageScanner.h; sourceTree = "<group>"; };
+		DC48C4C21219E5F70047193B /* Processor.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Processor.h; sourceTree = "<group>"; };
+		DC48C4C31219E5F70047193B /* Scanner.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Scanner.h; sourceTree = "<group>"; };
+		DC48C4C41219E5F70047193B /* Symbol.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Symbol.h; sourceTree = "<group>"; };
+		DC48C4C51219E5F70047193B /* Video.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Video.h; sourceTree = "<group>"; };
+		DC48C4C61219E5F70047193B /* Window.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Window.h; sourceTree = "<group>"; };
+		DC48C4C71219E5F70047193B /* zbar.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = zbar.h; sourceTree = "<group>"; };
+		DC48C4C81219E5F70047193B /* ZBarCaptureReader.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ZBarCaptureReader.h; sourceTree = "<group>"; };
+		DC48C4C91219E5F70047193B /* ZBarImage.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ZBarImage.h; sourceTree = "<group>"; };
+		DC48C4CA1219E5F70047193B /* ZBarImageScanner.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ZBarImageScanner.h; sourceTree = "<group>"; };
+		DC48C4CB1219E5F70047193B /* ZBarReaderController.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ZBarReaderController.h; sourceTree = "<group>"; };
+		DC48C4CC1219E5F70047193B /* ZBarReaderView.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ZBarReaderView.h; sourceTree = "<group>"; };
+		DC48C4CD1219E5F70047193B /* ZBarReaderViewController.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ZBarReaderViewController.h; sourceTree = "<group>"; };
+		DC48C4CE1219E5F70047193B /* ZBarSDK.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ZBarSDK.h; sourceTree = "<group>"; };
+		DC48C4CF1219E5F70047193B /* ZBarSymbol.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ZBarSymbol.h; sourceTree = "<group>"; };
+		DC48C4D01219E5F70047193B /* libzbar.a */ = {isa = PBXFileReference; lastKnownFileType = archive.ar; path = libzbar.a; sourceTree = "<group>"; };
+		DC48C4D21219E5F70047193B /* zbar-back.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; path = "zbar-back.png"; sourceTree = "<group>"; };
+		DC48C4D31219E5F70047193B /* zbar-help.html */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.html; path = "zbar-help.html"; sourceTree = "<group>"; };
+		DC48C4D41219E5F70047193B /* zbar-helpicons.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; path = "zbar-helpicons.png"; sourceTree = "<group>"; };
+		DC48C4D51219E5F70047193B /* zbar-samples.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; path = "zbar-samples.png"; sourceTree = "<group>"; };
+		DC8245FF162B568A0010B2E6 /* Default-568h@2x.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; path = "Default-568h@2x.png"; sourceTree = "<group>"; };
+		DCB9118410BC5DA200B907F0 /* QuartzCore.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = QuartzCore.framework; path = System/Library/Frameworks/QuartzCore.framework; sourceTree = SDKROOT; };
+		DCD6E0CE10B0AD41002005CD /* prefix.pch */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = prefix.pch; sourceTree = "<group>"; };
+		DCD6E0CF10B0AD41002005CD /* readertest.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = readertest.m; sourceTree = "<group>"; };
+		DCD6E0D810B0AD55002005CD /* readertest.plist */ = {isa = PBXFileReference; explicitFileType = text.plist.info; fileEncoding = 4; path = readertest.plist; sourceTree = "<group>"; };
+		DCD6E13B10B0AFD4002005CD /* libiconv.dylib */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.dylib"; name = libiconv.dylib; path = usr/lib/libiconv.dylib; sourceTree = SDKROOT; };
+		DCDC6D9A11ACA23000021380 /* CoreVideo.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = CoreVideo.framework; path = System/Library/Frameworks/CoreVideo.framework; sourceTree = SDKROOT; };
+		DCDC6D9E11ACA23900021380 /* CoreMedia.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = CoreMedia.framework; path = System/Library/Frameworks/CoreMedia.framework; sourceTree = SDKROOT; };
+		DCDC6DEB11ACA5B400021380 /* AVFoundation.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = AVFoundation.framework; path = System/Library/Frameworks/AVFoundation.framework; sourceTree = SDKROOT; };
+/* End PBXFileReference section */
+
+/* Begin PBXFrameworksBuildPhase section */
+		1D60588F0D05DD3D006BFB54 /* Frameworks */ = {
+			isa = PBXFrameworksBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				1D60589F0D05DD5A006BFB54 /* Foundation.framework in Frameworks */,
+				288765FD0DF74451002DB57D /* CoreGraphics.framework in Frameworks */,
+				1DF5F4E00D08C38300B7A737 /* UIKit.framework in Frameworks */,
+				DCB9118510BC5DA200B907F0 /* QuartzCore.framework in Frameworks */,
+				DCDC6DEC11ACA5B400021380 /* AVFoundation.framework in Frameworks */,
+				DCDC6D9F11ACA23900021380 /* CoreMedia.framework in Frameworks */,
+				DCDC6D9B11ACA23000021380 /* CoreVideo.framework in Frameworks */,
+				DCB9118810BC5DB500B907F0 /* libiconv.dylib in Frameworks */,
+				DC48C4D61219E5F70047193B /* libzbar.a in Frameworks */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+/* End PBXFrameworksBuildPhase section */
+
+/* Begin PBXGroup section */
+		19C28FACFE9D520D11CA2CBB /* Products */ = {
+			isa = PBXGroup;
+			children = (
+				1D6058910D05DD3D006BFB54 /* readertest.app */,
+			);
+			name = Products;
+			sourceTree = "<group>";
+		};
+		29B97314FDCFA39411CA2CEA /* CustomTemplate */ = {
+			isa = PBXGroup;
+			children = (
+				DCD6E0CE10B0AD41002005CD /* prefix.pch */,
+				DCD6E0CF10B0AD41002005CD /* readertest.m */,
+				DC48C4BA1219E5F70047193B /* ZBarSDK */,
+				DC3CEAC61209C07400D7A786 /* Resources */,
+				29B97323FDCFA39411CA2CEA /* Frameworks */,
+				19C28FACFE9D520D11CA2CBB /* Products */,
+			);
+			name = CustomTemplate;
+			sourceTree = "<group>";
+		};
+		29B97323FDCFA39411CA2CEA /* Frameworks */ = {
+			isa = PBXGroup;
+			children = (
+				1D30AB110D05D00D00671497 /* Foundation.framework */,
+				288765FC0DF74451002DB57D /* CoreGraphics.framework */,
+				1DF5F4DF0D08C38300B7A737 /* UIKit.framework */,
+				DCB9118410BC5DA200B907F0 /* QuartzCore.framework */,
+				DCDC6DEB11ACA5B400021380 /* AVFoundation.framework */,
+				DCDC6D9A11ACA23000021380 /* CoreVideo.framework */,
+				DCDC6D9E11ACA23900021380 /* CoreMedia.framework */,
+				DCD6E13B10B0AFD4002005CD /* libiconv.dylib */,
+			);
+			name = Frameworks;
+			sourceTree = "<group>";
+		};
+		DC3CEAC61209C07400D7A786 /* Resources */ = {
+			isa = PBXGroup;
+			children = (
+				DCD6E0D810B0AD55002005CD /* readertest.plist */,
+				DC8245FF162B568A0010B2E6 /* Default-568h@2x.png */,
+			);
+			name = Resources;
+			sourceTree = "<group>";
+		};
+		DC48C4BA1219E5F70047193B /* ZBarSDK */ = {
+			isa = PBXGroup;
+			children = (
+				DC48C4BB1219E5F70047193B /* Headers */,
+				DC48C4D01219E5F70047193B /* libzbar.a */,
+				DC48C4D11219E5F70047193B /* Resources */,
+			);
+			path = ZBarSDK;
+			sourceTree = "<group>";
+		};
+		DC48C4BB1219E5F70047193B /* Headers */ = {
+			isa = PBXGroup;
+			children = (
+				DC48C4BC1219E5F70047193B /* ZBarSDK */,
+			);
+			path = Headers;
+			sourceTree = "<group>";
+		};
+		DC48C4BC1219E5F70047193B /* ZBarSDK */ = {
+			isa = PBXGroup;
+			children = (
+				DC48C4BD1219E5F70047193B /* zbar */,
+				DC48C4C71219E5F70047193B /* zbar.h */,
+				DC48C4C81219E5F70047193B /* ZBarCaptureReader.h */,
+				DC48C4C91219E5F70047193B /* ZBarImage.h */,
+				DC48C4CA1219E5F70047193B /* ZBarImageScanner.h */,
+				DC48C4CB1219E5F70047193B /* ZBarReaderController.h */,
+				DC48C4CC1219E5F70047193B /* ZBarReaderView.h */,
+				DC48C4CD1219E5F70047193B /* ZBarReaderViewController.h */,
+				DC48C4CE1219E5F70047193B /* ZBarSDK.h */,
+				DC48C4CF1219E5F70047193B /* ZBarSymbol.h */,
+			);
+			path = ZBarSDK;
+			sourceTree = "<group>";
+		};
+		DC48C4BD1219E5F70047193B /* zbar */ = {
+			isa = PBXGroup;
+			children = (
+				DC48C4BE1219E5F70047193B /* Decoder.h */,
+				DC48C4BF1219E5F70047193B /* Exception.h */,
+				DC48C4C01219E5F70047193B /* Image.h */,
+				DC48C4C11219E5F70047193B /* ImageScanner.h */,
+				DC48C4C21219E5F70047193B /* Processor.h */,
+				DC48C4C31219E5F70047193B /* Scanner.h */,
+				DC48C4C41219E5F70047193B /* Symbol.h */,
+				DC48C4C51219E5F70047193B /* Video.h */,
+				DC48C4C61219E5F70047193B /* Window.h */,
+			);
+			path = zbar;
+			sourceTree = "<group>";
+		};
+		DC48C4D11219E5F70047193B /* Resources */ = {
+			isa = PBXGroup;
+			children = (
+				DC48C4D21219E5F70047193B /* zbar-back.png */,
+				DC48C4D31219E5F70047193B /* zbar-help.html */,
+				DC48C4D41219E5F70047193B /* zbar-helpicons.png */,
+				DC48C4D51219E5F70047193B /* zbar-samples.png */,
+			);
+			path = Resources;
+			sourceTree = "<group>";
+		};
+/* End PBXGroup section */
+
+/* Begin PBXNativeTarget section */
+		1D6058900D05DD3D006BFB54 /* readertest */ = {
+			isa = PBXNativeTarget;
+			buildConfigurationList = 1D6058960D05DD3E006BFB54 /* Build configuration list for PBXNativeTarget "readertest" */;
+			buildPhases = (
+				1D60588D0D05DD3D006BFB54 /* Resources */,
+				1D60588E0D05DD3D006BFB54 /* Sources */,
+				1D60588F0D05DD3D006BFB54 /* Frameworks */,
+			);
+			buildRules = (
+			);
+			dependencies = (
+			);
+			name = readertest;
+			productName = readertest;
+			productReference = 1D6058910D05DD3D006BFB54 /* readertest.app */;
+			productType = "com.apple.product-type.application";
+		};
+/* End PBXNativeTarget section */
+
+/* Begin PBXProject section */
+		29B97313FDCFA39411CA2CEA /* Project object */ = {
+			isa = PBXProject;
+			buildConfigurationList = C01FCF4E08A954540054247B /* Build configuration list for PBXProject "readertest" */;
+			compatibilityVersion = "Xcode 3.1";
+			developmentRegion = English;
+			hasScannedForEncodings = 1;
+			knownRegions = (
+				English,
+				Japanese,
+				French,
+				German,
+			);
+			mainGroup = 29B97314FDCFA39411CA2CEA /* CustomTemplate */;
+			projectDirPath = "";
+			projectRoot = "";
+			targets = (
+				1D6058900D05DD3D006BFB54 /* readertest */,
+			);
+		};
+/* End PBXProject section */
+
+/* Begin PBXResourcesBuildPhase section */
+		1D60588D0D05DD3D006BFB54 /* Resources */ = {
+			isa = PBXResourcesBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				DC48C4D71219E5F70047193B /* zbar-back.png in Resources */,
+				DC48C4D81219E5F70047193B /* zbar-help.html in Resources */,
+				DC48C4D91219E5F70047193B /* zbar-helpicons.png in Resources */,
+				DC48C4DA1219E5F70047193B /* zbar-samples.png in Resources */,
+				DC824600162B568A0010B2E6 /* Default-568h@2x.png in Resources */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+/* End PBXResourcesBuildPhase section */
+
+/* Begin PBXSourcesBuildPhase section */
+		1D60588E0D05DD3D006BFB54 /* Sources */ = {
+			isa = PBXSourcesBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				DCD6E0D010B0AD41002005CD /* readertest.m in Sources */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+/* End PBXSourcesBuildPhase section */
+
+/* Begin XCBuildConfiguration section */
+		1D6058940D05DD3E006BFB54 /* Debug */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				COPY_PHASE_STRIP = NO;
+				GCC_OPTIMIZATION_LEVEL = 0;
+				GCC_PRECOMPILE_PREFIX_HEADER = YES;
+				GCC_PREFIX_HEADER = prefix.pch;
+				INFOPLIST_FILE = readertest.plist;
+				LIBRARY_SEARCH_PATHS = (
+					"$(inherited)",
+					"\"$(SRCROOT)/ZBarSDK\"",
+				);
+				PRODUCT_NAME = readertest;
+			};
+			name = Debug;
+		};
+		1D6058950D05DD3E006BFB54 /* Release */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				COPY_PHASE_STRIP = YES;
+				GCC_PRECOMPILE_PREFIX_HEADER = YES;
+				GCC_PREFIX_HEADER = prefix.pch;
+				INFOPLIST_FILE = readertest.plist;
+				LIBRARY_SEARCH_PATHS = (
+					"$(inherited)",
+					"\"$(SRCROOT)/ZBarSDK\"",
+				);
+				PRODUCT_NAME = readertest;
+			};
+			name = Release;
+		};
+		C01FCF4F08A954540054247B /* Debug */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				ARCHS = "$(ARCHS_STANDARD_32_BIT)";
+				"CODE_SIGN_IDENTITY[sdk=iphoneos*]" = "iPhone Developer";
+				GCC_C_LANGUAGE_STANDARD = c99;
+				GCC_WARN_ABOUT_RETURN_TYPE = YES;
+				GCC_WARN_UNUSED_VARIABLE = YES;
+				IPHONEOS_DEPLOYMENT_TARGET = 3.1;
+				OTHER_LDFLAGS = "-all_load";
+				PREBINDING = NO;
+				SDKROOT = iphoneos;
+				SYMROOT = /tmp/readertest.build;
+			};
+			name = Debug;
+		};
+		C01FCF5008A954540054247B /* Release */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				ARCHS = "$(ARCHS_STANDARD_32_BIT)";
+				"CODE_SIGN_IDENTITY[sdk=iphoneos*]" = "iPhone Developer";
+				GCC_C_LANGUAGE_STANDARD = c99;
+				GCC_WARN_ABOUT_RETURN_TYPE = YES;
+				GCC_WARN_UNUSED_VARIABLE = YES;
+				IPHONEOS_DEPLOYMENT_TARGET = 3.1;
+				OTHER_LDFLAGS = "-all_load";
+				PREBINDING = NO;
+				SDKROOT = iphoneos;
+				SYMROOT = /tmp/readertest.build;
+			};
+			name = Release;
+		};
+/* End XCBuildConfiguration section */
+
+/* Begin XCConfigurationList section */
+		1D6058960D05DD3E006BFB54 /* Build configuration list for PBXNativeTarget "readertest" */ = {
+			isa = XCConfigurationList;
+			buildConfigurations = (
+				1D6058940D05DD3E006BFB54 /* Debug */,
+				1D6058950D05DD3E006BFB54 /* Release */,
+			);
+			defaultConfigurationIsVisible = 0;
+			defaultConfigurationName = Release;
+		};
+		C01FCF4E08A954540054247B /* Build configuration list for PBXProject "readertest" */ = {
+			isa = XCConfigurationList;
+			buildConfigurations = (
+				C01FCF4F08A954540054247B /* Debug */,
+				C01FCF5008A954540054247B /* Release */,
+			);
+			defaultConfigurationIsVisible = 0;
+			defaultConfigurationName = Release;
+		};
+/* End XCConfigurationList section */
+	};
+	rootObject = 29B97313FDCFA39411CA2CEA /* Project object */;
+}
diff -r 563557a923d0 iphone/examples/readertest/readertest.xcodeproj/xcshareddata/xcschemes/readertest.xcscheme
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/examples/readertest/readertest.xcodeproj/xcshareddata/xcschemes/readertest.xcscheme	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,76 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<Scheme
+   version = "1.3">
+   <BuildAction
+      parallelizeBuildables = "YES"
+      buildImplicitDependencies = "YES">
+      <BuildActionEntries>
+         <BuildActionEntry
+            buildForTesting = "YES"
+            buildForRunning = "YES"
+            buildForProfiling = "YES"
+            buildForArchiving = "YES"
+            buildForAnalyzing = "YES">
+            <BuildableReference
+               BuildableIdentifier = "primary"
+               BlueprintIdentifier = "1D6058900D05DD3D006BFB54"
+               BuildableName = "readertest.app"
+               BlueprintName = "readertest"
+               ReferencedContainer = "container:readertest.xcodeproj">
+            </BuildableReference>
+         </BuildActionEntry>
+      </BuildActionEntries>
+   </BuildAction>
+   <TestAction
+      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.GDB"
+      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.GDB"
+      shouldUseLaunchSchemeArgsEnv = "YES"
+      buildConfiguration = "Debug">
+      <Testables>
+      </Testables>
+   </TestAction>
+   <LaunchAction
+      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.GDB"
+      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.GDB"
+      displayScaleIsEnabled = "NO"
+      displayScale = "1.00"
+      launchStyle = "0"
+      useCustomWorkingDirectory = "NO"
+      buildConfiguration = "Debug">
+      <BuildableProductRunnable>
+         <BuildableReference
+            BuildableIdentifier = "primary"
+            BlueprintIdentifier = "1D6058900D05DD3D006BFB54"
+            BuildableName = "readertest.app"
+            BlueprintName = "readertest"
+            ReferencedContainer = "container:readertest.xcodeproj">
+         </BuildableReference>
+      </BuildableProductRunnable>
+      <AdditionalOptions>
+      </AdditionalOptions>
+   </LaunchAction>
+   <ProfileAction
+      displayScaleIsEnabled = "NO"
+      displayScale = "1.00"
+      shouldUseLaunchSchemeArgsEnv = "YES"
+      savedToolIdentifier = ""
+      useCustomWorkingDirectory = "NO"
+      buildConfiguration = "Release">
+      <BuildableProductRunnable>
+         <BuildableReference
+            BuildableIdentifier = "primary"
+            BlueprintIdentifier = "1D6058900D05DD3D006BFB54"
+            BuildableName = "readertest.app"
+            BlueprintName = "readertest"
+            ReferencedContainer = "container:readertest.xcodeproj">
+         </BuildableReference>
+      </BuildableProductRunnable>
+   </ProfileAction>
+   <AnalyzeAction
+      buildConfiguration = "Debug">
+   </AnalyzeAction>
+   <ArchiveAction
+      buildConfiguration = "Release"
+      revealArchiveInOrganizer = "YES">
+   </ArchiveAction>
+</Scheme>
diff -r 563557a923d0 iphone/include/ZBarSDK/ZBarCameraSimulator.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/include/ZBarSDK/ZBarCameraSimulator.h	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,45 @@
+//------------------------------------------------------------------------
+//  Copyright 2010-2011 (c) Jeff Brown <spadix@users.sourceforge.net>
+//
+//  This file is part of the ZBar Bar Code Reader.
+//
+//  The ZBar Bar Code Reader is free software; you can redistribute it
+//  and/or modify it under the terms of the GNU Lesser Public License as
+//  published by the Free Software Foundation; either version 2.1 of
+//  the License, or (at your option) any later version.
+//
+//  The ZBar Bar Code Reader is distributed in the hope that it will be
+//  useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+//  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU Lesser Public License for more details.
+//
+//  You should have received a copy of the GNU Lesser Public License
+//  along with the ZBar Bar Code Reader; if not, write to the Free
+//  Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+//  Boston, MA  02110-1301  USA
+//
+//  http://sourceforge.net/projects/zbar
+//------------------------------------------------------------------------
+
+@class ZBarReaderView;
+
+// hack around missing simulator support for AVCapture interfaces
+
+@interface ZBarCameraSimulator
+    : NSObject
+    < UINavigationControllerDelegate,
+      UIImagePickerControllerDelegate,
+      UIPopoverControllerDelegate >
+{
+    UIViewController *viewController;
+    ZBarReaderView *readerView;
+    UIImagePickerController *picker;
+    UIPopoverController *pickerPopover;
+}
+
+- (id) initWithViewController: (UIViewController*) viewController;
+- (void) takePicture;
+
+@property (nonatomic, assign) ZBarReaderView *readerView;
+
+@end
diff -r 563557a923d0 iphone/include/ZBarSDK/ZBarCaptureReader.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/include/ZBarSDK/ZBarCaptureReader.h	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,111 @@
+//------------------------------------------------------------------------
+//  Copyright 2010 (c) Jeff Brown <spadix@users.sourceforge.net>
+//
+//  This file is part of the ZBar Bar Code Reader.
+//
+//  The ZBar Bar Code Reader is free software; you can redistribute it
+//  and/or modify it under the terms of the GNU Lesser Public License as
+//  published by the Free Software Foundation; either version 2.1 of
+//  the License, or (at your option) any later version.
+//
+//  The ZBar Bar Code Reader is distributed in the hope that it will be
+//  useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+//  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU Lesser Public License for more details.
+//
+//  You should have received a copy of the GNU Lesser Public License
+//  along with the ZBar Bar Code Reader; if not, write to the Free
+//  Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+//  Boston, MA  02110-1301  USA
+//
+//  http://sourceforge.net/projects/zbar
+//------------------------------------------------------------------------
+
+#import <CoreGraphics/CoreGraphics.h>
+#import "ZBarImageScanner.h"
+
+@class AVCaptureVideoDataOutput, AVCaptureOutput;
+@class ZBarCaptureReader, ZBarCVImage;
+
+@protocol ZBarCaptureDelegate <NSObject>
+
+// called when a new barcode is detected.  the image refers to the
+// video buffer and must not be retained for long
+- (void)       captureReader: (ZBarCaptureReader*) captureReader
+  didReadNewSymbolsFromImage: (ZBarImage*) image;
+
+@optional
+// called when a potential/uncertain barcode is detected.  will also
+// be called *after* captureReader:didReadNewSymbolsFromImage:
+// when good barcodes are detected
+- (void) captureReader: (ZBarCaptureReader*) captureReader
+       didTrackSymbols: (ZBarSymbolSet*) symbols;
+
+@end
+
+@interface ZBarCaptureReader
+    : NSObject
+{
+#if !TARGET_IPHONE_SIMULATOR
+    AVCaptureVideoDataOutput *captureOutput;
+    id<ZBarCaptureDelegate> captureDelegate;
+    ZBarImageScanner *scanner;
+    CGRect scanCrop;
+    CGSize size;
+    CGFloat framesPerSecond;
+    BOOL enableCache;
+
+    dispatch_queue_t queue;
+    ZBarImage *image;
+    ZBarCVImage *result;
+    volatile uint32_t state;
+    int framecnt;
+    unsigned width, height;
+    uint64_t t_frame, t_fps, t_scan;
+    CGFloat dt_frame;
+#endif
+}
+
+// supply a pre-configured image scanner
+- (id) initWithImageScanner: (ZBarImageScanner*) imageScanner;
+
+// this must be called before the session is started
+- (void) willStartRunning;
+
+// this must be called *before* the session is stopped
+- (void) willStopRunning;
+
+// clear the internal result cache
+- (void) flushCache;
+
+// capture the next frame after processing.  the captured image will
+// follow the same delegate path as an image with decoded symbols.
+- (void) captureFrame;
+
+// the capture output.  add this to an instance of AVCaptureSession
+@property (nonatomic, readonly) AVCaptureOutput *captureOutput;
+
+// delegate is notified of decode results and symbol tracking.
+@property (nonatomic, assign) id<ZBarCaptureDelegate> captureDelegate;
+
+// access to image scanner for configuration.
+@property (nonatomic, readonly) ZBarImageScanner *scanner;
+
+// region of image to scan in normalized coordinates.
+// NB horizontal crop currently ignored...
+@property (nonatomic, assign) CGRect scanCrop;
+
+// size of video frames.
+@property (nonatomic, readonly) CGSize size;
+
+// (quickly) gate the reader function without interrupting the video
+// stream.  also flushes the cache when enabled.  defaults to *NO*
+@property (nonatomic) BOOL enableReader;
+
+// current frame rate (for debug/optimization).
+// only valid when running
+@property (nonatomic, readonly) CGFloat framesPerSecond;
+
+@property (nonatomic) BOOL enableCache;
+
+@end
diff -r 563557a923d0 iphone/include/ZBarSDK/ZBarHelpController.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/include/ZBarSDK/ZBarHelpController.h	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,60 @@
+//------------------------------------------------------------------------
+//  Copyright 2009-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
+//
+//  This file is part of the ZBar Bar Code Reader.
+//
+//  The ZBar Bar Code Reader is free software; you can redistribute it
+//  and/or modify it under the terms of the GNU Lesser Public License as
+//  published by the Free Software Foundation; either version 2.1 of
+//  the License, or (at your option) any later version.
+//
+//  The ZBar Bar Code Reader is distributed in the hope that it will be
+//  useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+//  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU Lesser Public License for more details.
+//
+//  You should have received a copy of the GNU Lesser Public License
+//  along with the ZBar Bar Code Reader; if not, write to the Free
+//  Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+//  Boston, MA  02110-1301  USA
+//
+//  http://sourceforge.net/projects/zbar
+//------------------------------------------------------------------------
+
+#import <UIKit/UIKit.h>
+
+@class ZBarHelpController;
+
+@protocol ZBarHelpDelegate
+@optional
+
+- (void) helpControllerDidFinish: (ZBarHelpController*) help;
+
+@end
+
+
+// failure dialog w/a few useful tips
+
+@interface ZBarHelpController : UIViewController
+                              < UIWebViewDelegate,
+                                UIAlertViewDelegate >
+{
+    NSString *reason;
+    id delegate;
+    UIWebView *webView;
+    UIToolbar *toolbar;
+    UIBarButtonItem *doneBtn, *backBtn, *space;
+    NSURL *linkURL;
+    NSUInteger orientations;
+}
+
+@property (nonatomic, assign) id<ZBarHelpDelegate> delegate;
+
+// designated initializer
+- (id) initWithReason: (NSString*) reason;
+
+- (BOOL) isInterfaceOrientationSupported: (UIInterfaceOrientation) orientation;
+- (void) setInterfaceOrientation: (UIInterfaceOrientation) orientation
+                       supported: (BOOL) supported;
+
+@end
diff -r 563557a923d0 iphone/include/ZBarSDK/ZBarImage.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/include/ZBarSDK/ZBarImage.h	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,69 @@
+//------------------------------------------------------------------------
+//  Copyright 2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+//
+//  This file is part of the ZBar Bar Code Reader.
+//
+//  The ZBar Bar Code Reader is free software; you can redistribute it
+//  and/or modify it under the terms of the GNU Lesser Public License as
+//  published by the Free Software Foundation; either version 2.1 of
+//  the License, or (at your option) any later version.
+//
+//  The ZBar Bar Code Reader is distributed in the hope that it will be
+//  useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+//  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU Lesser Public License for more details.
+//
+//  You should have received a copy of the GNU Lesser Public License
+//  along with the ZBar Bar Code Reader; if not, write to the Free
+//  Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+//  Boston, MA  02110-1301  USA
+//
+//  http://sourceforge.net/projects/zbar
+//------------------------------------------------------------------------
+
+#import <UIKit/UIKit.h>
+#import "zbar.h"
+#import "ZBarSymbol.h"
+
+#ifdef __cplusplus
+using namespace zbar;
+#endif
+
+// Obj-C wrapper for ZBar image
+
+@interface ZBarImage : NSObject
+{
+    zbar_image_t *zimg;
+    double t_convert;
+}
+
+@property (nonatomic) unsigned long format;
+@property (nonatomic) unsigned sequence;
+@property (nonatomic) CGSize size;
+@property (nonatomic) CGRect crop;
+@property (readonly, nonatomic) const void *data;
+@property (readonly, nonatomic) unsigned long dataLength;
+@property (copy, nonatomic) ZBarSymbolSet *symbols;
+@property (readonly, nonatomic) zbar_image_t *zbarImage;
+@property (readonly, nonatomic) UIImage *UIImage;
+
+- (id) initWithImage: (zbar_image_t*) image;
+- (id) initWithCGImage: (CGImageRef) image;
+- (id) initWithCGImage: (CGImageRef) image
+                  size: (CGSize) size;
+- (id) initWithCGImage: (CGImageRef) image
+                  crop: (CGRect) crop
+                  size: (CGSize) size;
+
+- (void) setData: (const void*) data
+      withLength: (unsigned long) length;
+- (UIImage*) UIImageWithOrientation: (UIImageOrientation) imageOrientation;
+- (void) cleanup;
+
++ (unsigned long) fourcc: (NSString*) format;
+
+#if 0
+- convertToFormat: (unsigned long) format;
+#endif
+
+@end
diff -r 563557a923d0 iphone/include/ZBarSDK/ZBarImageScanner.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/include/ZBarSDK/ZBarImageScanner.h	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,51 @@
+//------------------------------------------------------------------------
+//  Copyright 2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+//
+//  This file is part of the ZBar Bar Code Reader.
+//
+//  The ZBar Bar Code Reader is free software; you can redistribute it
+//  and/or modify it under the terms of the GNU Lesser Public License as
+//  published by the Free Software Foundation; either version 2.1 of
+//  the License, or (at your option) any later version.
+//
+//  The ZBar Bar Code Reader is distributed in the hope that it will be
+//  useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+//  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU Lesser Public License for more details.
+//
+//  You should have received a copy of the GNU Lesser Public License
+//  along with the ZBar Bar Code Reader; if not, write to the Free
+//  Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+//  Boston, MA  02110-1301  USA
+//
+//  http://sourceforge.net/projects/zbar
+//------------------------------------------------------------------------
+
+#import <Foundation/Foundation.h>
+#import "zbar.h"
+#import "ZBarImage.h"
+
+#ifdef __cplusplus
+using namespace zbar;
+#endif
+
+// Obj-C wrapper for ZBar image scanner
+
+@interface ZBarImageScanner : NSObject
+{
+    zbar_image_scanner_t *scanner;
+}
+
+@property (nonatomic) BOOL enableCache;
+@property (readonly, nonatomic) ZBarSymbolSet *results;
+
+// decoder configuration
+- (void) parseConfig: (NSString*) configStr;
+- (void) setSymbology: (zbar_symbol_type_t) symbology
+               config: (zbar_config_t) config
+                   to: (int) value;
+
+// image scanning interface
+- (NSInteger) scanImage: (ZBarImage*) image;
+
+@end
diff -r 563557a923d0 iphone/include/ZBarSDK/ZBarReaderController.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/include/ZBarSDK/ZBarReaderController.h	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,142 @@
+//------------------------------------------------------------------------
+//  Copyright 2009-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
+//
+//  This file is part of the ZBar Bar Code Reader.
+//
+//  The ZBar Bar Code Reader is free software; you can redistribute it
+//  and/or modify it under the terms of the GNU Lesser Public License as
+//  published by the Free Software Foundation; either version 2.1 of
+//  the License, or (at your option) any later version.
+//
+//  The ZBar Bar Code Reader is distributed in the hope that it will be
+//  useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+//  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU Lesser Public License for more details.
+//
+//  You should have received a copy of the GNU Lesser Public License
+//  along with the ZBar Bar Code Reader; if not, write to the Free
+//  Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+//  Boston, MA  02110-1301  USA
+//
+//  http://sourceforge.net/projects/zbar
+//------------------------------------------------------------------------
+
+#import <UIKit/UIKit.h>
+#import "ZBarImageScanner.h"
+
+#ifdef __cplusplus
+using namespace zbar;
+#endif
+
+typedef enum {
+    // default interface provided by UIImagePickerController - user manually
+    // captures an image by pressing a button
+    ZBarReaderControllerCameraModeDefault = 0,
+
+    // automatically scan by taking screenshots with UIGetScreenImage().
+    // resolution is limited by the screen, so this is inappropriate for
+    // longer codes
+    ZBarReaderControllerCameraModeSampling,
+
+    // automatically scan by rapidly taking pictures with takePicture.
+    // tradeoff resolution with frame rate by adjusting the crop, and size
+    // properties of the reader along with the density configs of the image
+    // scanner
+    ZBarReaderControllerCameraModeSequence,
+
+} ZBarReaderControllerCameraMode;
+
+
+@class ZBarReaderController, ZBarHelpController;
+
+@protocol ZBarReaderDelegate <UIImagePickerControllerDelegate>
+@optional
+
+// called when no barcode is found in an image selected by the user.
+// if retry is NO, the delegate *must* dismiss the controller
+- (void) readerControllerDidFailToRead: (ZBarReaderController*) reader
+                             withRetry: (BOOL) retry;
+
+@end
+
+
+@interface ZBarReaderController
+    : UIImagePickerController
+    < UINavigationControllerDelegate,
+      UIImagePickerControllerDelegate >
+{
+    ZBarImageScanner *scanner;
+    ZBarHelpController *help;
+    UIView *overlay, *boxView;
+    CALayer *boxLayer;
+
+    UIToolbar *toolbar;
+    UIBarButtonItem *cancelBtn, *scanBtn, *space[3];
+    UIButton *infoBtn;
+
+    id <ZBarReaderDelegate> readerDelegate;
+    BOOL showsZBarControls, showsHelpOnFail, takesPicture, enableCache;
+    ZBarReaderControllerCameraMode cameraMode;
+    CGRect scanCrop;
+    NSInteger maxScanDimension;
+
+    BOOL hasOverlay, sampling;
+    uint64_t t_frame;
+    double dt_frame;
+
+    ZBarSymbol *symbol;
+}
+
+// access to configure image scanner
+@property (readonly, nonatomic) ZBarImageScanner *scanner;
+
+// barcode result recipient (NB don't use delegate)
+@property (nonatomic, assign) id <ZBarReaderDelegate> readerDelegate;
+
+// whether to use alternate control set
+@property (nonatomic) BOOL showsZBarControls;
+
+// whether to display helpful information when decoding fails
+@property (nonatomic) BOOL showsHelpOnFail;
+
+// how to use the camera (when sourceType == Camera)
+@property (nonatomic) ZBarReaderControllerCameraMode cameraMode;
+
+// whether to outline symbols with the green tracking box.
+@property (nonatomic) BOOL tracksSymbols;
+
+// whether to automatically take a full picture when a barcode is detected
+// (when cameraMode == Sampling)
+@property (nonatomic) BOOL takesPicture;
+
+// whether to use the "cache" for realtime modes (default YES).  this can be
+// used to safely disable the inter-frame consistency and duplicate checks,
+// speeding up recognition, iff:
+//     1. the controller is dismissed when a barcode is read and
+//     2. unreliable symbologies are disabled (all EAN/UPC variants and I2/5)
+@property (nonatomic) BOOL enableCache;
+
+// crop images for scanning.  the original image will be cropped to this
+// rectangle before scanning.  the rectangle is normalized to the image size
+// and aspect ratio; useful values will place the rectangle between 0 and 1
+// on each axis, where the x-axis corresponds to the image major axis.
+// defaults to the full image (0, 0, 1, 1).
+@property (nonatomic) CGRect scanCrop;
+
+// scale image to scan.  after cropping, the image will be scaled if
+// necessary, such that neither of its dimensions exceed this value.
+// defaults to 640.
+@property (nonatomic) NSInteger maxScanDimension;
+
+// display the built-in help browser.  for use with custom overlays if
+// you don't also want to create your own help view.  only send this
+// message when the reader is displayed.  the argument will be passed
+// to the onZBarHelp() javascript function.
+- (void) showHelpWithReason: (NSString*) reason;
+
+// direct scanner interface - scan UIImage and return something enumerable
+- (id <NSFastEnumeration>) scanImage: (CGImageRef) image;
+
+@end
+
+extern NSString* const ZBarReaderControllerResults;
diff -r 563557a923d0 iphone/include/ZBarSDK/ZBarReaderView.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/include/ZBarSDK/ZBarReaderView.h	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,140 @@
+//------------------------------------------------------------------------
+//  Copyright 2010 (c) Jeff Brown <spadix@users.sourceforge.net>
+//
+//  This file is part of the ZBar Bar Code Reader.
+//
+//  The ZBar Bar Code Reader is free software; you can redistribute it
+//  and/or modify it under the terms of the GNU Lesser Public License as
+//  published by the Free Software Foundation; either version 2.1 of
+//  the License, or (at your option) any later version.
+//
+//  The ZBar Bar Code Reader is distributed in the hope that it will be
+//  useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+//  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU Lesser Public License for more details.
+//
+//  You should have received a copy of the GNU Lesser Public License
+//  along with the ZBar Bar Code Reader; if not, write to the Free
+//  Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+//  Boston, MA  02110-1301  USA
+//
+//  http://sourceforge.net/projects/zbar
+//------------------------------------------------------------------------
+
+#import <UIKit/UIKit.h>
+#import "ZBarImageScanner.h"
+
+@class AVCaptureSession, AVCaptureDevice;
+@class CALayer;
+@class ZBarImageScanner, ZBarCaptureReader, ZBarReaderView;
+
+// delegate is notified of decode results.
+
+@protocol ZBarReaderViewDelegate < NSObject >
+
+- (void) readerView: (ZBarReaderView*) readerView
+     didReadSymbols: (ZBarSymbolSet*) symbols
+          fromImage: (UIImage*) image;
+
+@optional
+- (void) readerViewDidStart: (ZBarReaderView*) readerView;
+- (void) readerView: (ZBarReaderView*) readerView
+   didStopWithError: (NSError*) error;
+
+@end
+
+// read barcodes from the displayed video preview.  the view maintains
+// a complete video capture session feeding a ZBarCaptureReader and
+// presents the associated preview with symbol tracking annotations.
+
+@interface ZBarReaderView
+    : UIView
+{
+    id<ZBarReaderViewDelegate> readerDelegate;
+    ZBarCaptureReader *captureReader;
+    CGRect scanCrop, effectiveCrop;
+    CGAffineTransform previewTransform;
+    CGFloat zoom, zoom0, maxZoom;
+    UIColor *trackingColor;
+    BOOL tracksSymbols, showsFPS;
+    NSInteger torchMode;
+    UIInterfaceOrientation interfaceOrientation;
+    NSTimeInterval animationDuration;
+
+    CALayer *preview, *overlay, *tracking, *cropLayer;
+    UIView *fpsView;
+    UILabel *fpsLabel;
+    UIPinchGestureRecognizer *pinch;
+    CGFloat imageScale;
+    CGSize imageSize;
+    BOOL started, running, locked;
+}
+
+// supply a pre-configured image scanner.
+- (id) initWithImageScanner: (ZBarImageScanner*) imageScanner;
+
+// start the video stream and barcode reader.
+- (void) start;
+
+// stop the video stream and barcode reader.
+- (void) stop;
+
+// clear the internal result cache
+- (void) flushCache;
+
+// compensate for device/camera/interface orientation
+- (void) willRotateToInterfaceOrientation: (UIInterfaceOrientation) orient
+                                 duration: (NSTimeInterval) duration;
+
+// delegate is notified of decode results.
+@property (nonatomic, assign) id<ZBarReaderViewDelegate> readerDelegate;
+
+// access to image scanner for configuration.
+@property (nonatomic, readonly) ZBarImageScanner *scanner;
+
+// whether to display the tracking annotation for uncertain barcodes
+// (default YES).
+@property (nonatomic) BOOL tracksSymbols;
+
+// color of the tracking box (default green)
+@property (nonatomic, retain) UIColor *trackingColor;
+
+// enable pinch gesture recognition for zooming the preview/decode
+// (default YES).
+@property (nonatomic) BOOL allowsPinchZoom;
+
+// torch mode to set automatically (default Auto).
+@property (nonatomic) NSInteger torchMode;
+
+// whether to display the frame rate for debug/configuration
+// (default NO).
+@property (nonatomic) BOOL showsFPS;
+
+// zoom scale factor applied to video preview *and* scanCrop.
+// also updated by pinch-zoom gesture.  clipped to range [1,maxZoom],
+// defaults to 1.25
+@property (nonatomic) CGFloat zoom;
+- (void) setZoom: (CGFloat) zoom
+        animated: (BOOL) animated;
+
+// maximum settable zoom factor.
+@property (nonatomic) CGFloat maxZoom;
+
+// the region of the image that will be scanned.  normalized coordinates.
+@property (nonatomic) CGRect scanCrop;
+
+// additional transform applied to video preview.
+// (NB *not* applied to scan crop)
+@property (nonatomic) CGAffineTransform previewTransform;
+
+// specify an alternate capture device.
+@property (nonatomic, retain) AVCaptureDevice *device;
+
+// direct access to the capture session.  warranty void if opened...
+@property (nonatomic, readonly) AVCaptureSession *session;
+@property (nonatomic, readonly) ZBarCaptureReader *captureReader;
+
+// this flag still works, but its use is deprecated
+@property (nonatomic) BOOL enableCache;
+
+@end
diff -r 563557a923d0 iphone/include/ZBarSDK/ZBarReaderViewController.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/include/ZBarSDK/ZBarReaderViewController.h	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,130 @@
+//------------------------------------------------------------------------
+//  Copyright 2010 (c) Jeff Brown <spadix@users.sourceforge.net>
+//
+//  This file is part of the ZBar Bar Code Reader.
+//
+//  The ZBar Bar Code Reader is free software; you can redistribute it
+//  and/or modify it under the terms of the GNU Lesser Public License as
+//  published by the Free Software Foundation; either version 2.1 of
+//  the License, or (at your option) any later version.
+//
+//  The ZBar Bar Code Reader is distributed in the hope that it will be
+//  useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+//  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU Lesser Public License for more details.
+//
+//  You should have received a copy of the GNU Lesser Public License
+//  along with the ZBar Bar Code Reader; if not, write to the Free
+//  Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+//  Boston, MA  02110-1301  USA
+//
+//  http://sourceforge.net/projects/zbar
+//------------------------------------------------------------------------
+
+#import <UIKit/UIKit.h>
+#import "ZBarReaderController.h"
+
+// orientation set support
+#define ZBarOrientationMask(orient) (1 << orient)
+#define ZBarOrientationMaskAll \
+    (ZBarOrientationMask(UIInterfaceOrientationPortrait) | \
+     ZBarOrientationMask(UIInterfaceOrientationPortraitUpsideDown) | \
+     ZBarOrientationMask(UIInterfaceOrientationLandscapeLeft) | \
+     ZBarOrientationMask(UIInterfaceOrientationLandscapeRight))
+
+@class ZBarReaderView, ZBarCameraSimulator;
+
+// drop in video scanning replacement for ZBarReaderController.
+// this is a thin controller around a ZBarReaderView that adds the UI
+// controls and select functionality offered by ZBarReaderController.
+// Automatically falls back to a ZBarReaderController if video APIs
+// are unavailable (eg for OS < 4.0)
+
+@interface ZBarReaderViewController
+    : UIViewController
+{
+    ZBarImageScanner *scanner;
+    id <ZBarReaderDelegate> readerDelegate;
+    ZBarReaderView *readerView;
+    UIView *cameraOverlayView;
+    CGAffineTransform cameraViewTransform;
+    CGRect scanCrop;
+    NSUInteger supportedOrientationsMask;
+    UIImagePickerControllerCameraDevice cameraDevice;
+    UIImagePickerControllerCameraFlashMode cameraFlashMode;
+    UIImagePickerControllerQualityType videoQuality;
+    BOOL showsZBarControls, tracksSymbols, enableCache;
+
+    ZBarHelpController *helpController;
+    UIView *controls, *shutter;
+    BOOL didHideStatusBar, rotating;
+    ZBarCameraSimulator *cameraSim;
+}
+
+// access to configure image scanner
+@property (nonatomic, readonly) ZBarImageScanner *scanner;
+
+// barcode result recipient
+@property (nonatomic, assign) id <ZBarReaderDelegate> readerDelegate;
+
+// whether to use alternate control set
+@property (nonatomic) BOOL showsZBarControls;
+
+// whether to show the green tracking box.  note that, even when
+// enabled, the box will only be visible when scanning EAN and I2/5.
+@property (nonatomic) BOOL tracksSymbols;
+
+// interface orientation support.  bit-mask of accepted orientations.
+// see eg ZBarOrientationMask() and ZBarOrientationMaskAll
+@property (nonatomic) NSUInteger supportedOrientationsMask;
+
+// crop images for scanning.  the image will be cropped to this
+// rectangle before scanning.  the rectangle is normalized to the
+// image size and aspect ratio; useful values will place the rectangle
+// between 0 and 1 on each axis, where the x-axis corresponds to the
+// image major axis.  defaults to the full image (0, 0, 1, 1).
+@property (nonatomic) CGRect scanCrop;
+
+// provide a custom overlay.  note that this can be used with
+// showsZBarControls enabled (but not if you want backward compatibility)
+@property (nonatomic, retain) UIView *cameraOverlayView;
+
+// transform applied to the preview image.
+@property (nonatomic) CGAffineTransform cameraViewTransform;
+
+// display the built-in help browser.  the argument will be passed to
+// the onZBarHelp() javascript function.
+- (void) showHelpWithReason: (NSString*) reason;
+
+// capture the next frame and send it over the usual delegate path.
+- (void) takePicture;
+
+// these attempt to emulate UIImagePickerController
++ (BOOL) isCameraDeviceAvailable: (UIImagePickerControllerCameraDevice) cameraDevice;
++ (BOOL) isFlashAvailableForCameraDevice: (UIImagePickerControllerCameraDevice) cameraDevice;
++ (NSArray*) availableCaptureModesForCameraDevice: (UIImagePickerControllerCameraDevice) cameraDevice;
+@property(nonatomic) UIImagePickerControllerCameraDevice cameraDevice;
+@property(nonatomic) UIImagePickerControllerCameraFlashMode cameraFlashMode;
+@property(nonatomic) UIImagePickerControllerCameraCaptureMode cameraCaptureMode;
+@property(nonatomic) UIImagePickerControllerQualityType videoQuality;
+
+// direct access to the ZBarReaderView
+@property (nonatomic, readonly) ZBarReaderView *readerView;
+
+// this flag still works, but its use is deprecated
+@property (nonatomic) BOOL enableCache;
+
+// these are present only for backward compatibility.
+// they will error if inappropriate/unsupported values are set
+@property (nonatomic) UIImagePickerControllerSourceType sourceType; // Camera
+@property (nonatomic) BOOL allowsEditing; // NO
+@property (nonatomic) BOOL allowsImageEditing; // NO
+@property (nonatomic) BOOL showsCameraControls; // NO
+@property (nonatomic) BOOL showsHelpOnFail; // ignored
+@property (nonatomic) ZBarReaderControllerCameraMode cameraMode; // Sampling
+@property (nonatomic) BOOL takesPicture; // NO
+@property (nonatomic) NSInteger maxScanDimension; // ignored
+
++ (BOOL) isSourceTypeAvailable: (UIImagePickerControllerSourceType) sourceType;
+
+@end
diff -r 563557a923d0 iphone/include/ZBarSDK/ZBarSDK.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/include/ZBarSDK/ZBarSDK.h	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,34 @@
+/*------------------------------------------------------------------------
+ *  Copyright 2010 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *
+ *  This file is part of the ZBar Bar Code Reader.
+ *
+ *  The ZBar Bar Code Reader is free software; you can redistribute it
+ *  and/or modify it under the terms of the GNU Lesser Public License as
+ *  published by the Free Software Foundation; either version 2.1 of
+ *  the License, or (at your option) any later version.
+ *
+ *  The ZBar Bar Code Reader is distributed in the hope that it will be
+ *  useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+ *  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser Public License
+ *  along with the ZBar Bar Code Reader; if not, write to the Free
+ *  Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ *  Boston, MA  02110-1301  USA
+ *
+ *  http://sourceforge.net/projects/zbar
+ *------------------------------------------------------------------------*/
+
+#import "zbar.h"
+
+#import "ZBarSymbol.h"
+#import "ZBarImage.h"
+#import "ZBarImageScanner.h"
+#import "ZBarReaderView.h"
+#import "ZBarReaderViewController.h"
+#import "ZBarReaderController.h"
+#import "ZBarCaptureReader.h"
+#import "ZBarHelpController.h"
+#import "ZBarCameraSimulator.h"
diff -r 563557a923d0 iphone/include/ZBarSDK/ZBarSymbol.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/include/ZBarSDK/ZBarSymbol.h	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,71 @@
+//------------------------------------------------------------------------
+//  Copyright 2009-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
+//
+//  This file is part of the ZBar Bar Code Reader.
+//
+//  The ZBar Bar Code Reader is free software; you can redistribute it
+//  and/or modify it under the terms of the GNU Lesser Public License as
+//  published by the Free Software Foundation; either version 2.1 of
+//  the License, or (at your option) any later version.
+//
+//  The ZBar Bar Code Reader is distributed in the hope that it will be
+//  useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+//  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU Lesser Public License for more details.
+//
+//  You should have received a copy of the GNU Lesser Public License
+//  along with the ZBar Bar Code Reader; if not, write to the Free
+//  Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+//  Boston, MA  02110-1301  USA
+//
+//  http://sourceforge.net/projects/zbar
+//------------------------------------------------------------------------
+
+#import <Foundation/Foundation.h>
+#import <CoreGraphics/CoreGraphics.h>
+#import "zbar.h"
+
+#ifdef __cplusplus
+using namespace zbar;
+#endif
+
+// Obj-C wrapper for ZBar result types
+
+@interface ZBarSymbolSet
+    : NSObject <NSFastEnumeration>
+{
+    const zbar_symbol_set_t *set;
+    BOOL filterSymbols;
+}
+
+@property (readonly, nonatomic) int count;
+@property (readonly, nonatomic) const zbar_symbol_set_t *zbarSymbolSet;
+@property (nonatomic) BOOL filterSymbols;
+
+- (id) initWithSymbolSet: (const zbar_symbol_set_t*) set;
+
+@end
+
+
+@interface ZBarSymbol : NSObject
+{
+    const zbar_symbol_t *symbol;
+}
+
+@property (readonly, nonatomic) zbar_symbol_type_t type;
+@property (readonly, nonatomic) NSString *typeName;
+@property (readonly, nonatomic) NSUInteger configMask;
+@property (readonly, nonatomic) NSUInteger modifierMask;
+@property (readonly, nonatomic) NSString *data;
+@property (readonly, nonatomic) int quality;
+@property (readonly, nonatomic) int count;
+@property (readonly, nonatomic) zbar_orientation_t orientation;
+@property (readonly, nonatomic) ZBarSymbolSet *components;
+@property (readonly, nonatomic) const zbar_symbol_t *zbarSymbol;
+@property (readonly, nonatomic) CGRect bounds;
+
+- (id) initWithSymbol: (const zbar_symbol_t*) symbol;
+
++ (NSString*) nameForType: (zbar_symbol_type_t) type;
+
+@end
diff -r 563557a923d0 iphone/include/config.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/include/config.h	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,234 @@
+/* manually customized for iPhone platform */
+
+/* whether to build support for Code 128 symbology */
+#define ENABLE_CODE128 1
+
+/* whether to build support for Code 93 symbology */
+#define ENABLE_CODE93 1
+
+/* whether to build support for Code 39 symbology */
+#define ENABLE_CODE39 1
+
+/* whether to build support for Codabar symbology */
+#define ENABLE_CODABAR 1
+
+/* whether to build support for DataBar symbology */
+#define ENABLE_DATABAR 1
+
+/* whether to build support for EAN symbologies */
+#define ENABLE_EAN 1
+
+/* whether to build support for Interleaved 2 of 5 symbology */
+#define ENABLE_I25 1
+
+/* whether to build support for PDF417 symbology */
+#undef ENABLE_PDF417
+
+/* whether to build support for QR Code */
+#define ENABLE_QRCODE 1
+
+/* Define to 1 if you have the `atexit' function. */
+#undef HAVE_ATEXIT
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#undef HAVE_DLFCN_H
+
+/* Define to 1 if you have the <fcntl.h> header file. */
+#undef HAVE_FCNTL_H
+
+/* Define to 1 if you have the <features.h> header file. */
+#undef HAVE_FEATURES_H
+
+/* Define to 1 if you have the `getpagesize' function. */
+#undef HAVE_GETPAGESIZE
+
+/* Define if you have the iconv() function and it works. */
+#undef HAVE_ICONV
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#define HAVE_INTTYPES_H 1
+
+/* Define to 1 if you have the <jpeglib.h> header file. */
+#undef HAVE_JPEGLIB_H
+
+/* Define to 1 if you have the `jpeg' library (-ljpeg). */
+#undef HAVE_LIBJPEG
+
+/* Define to 1 if you have the `pthread' library (-lpthread). */
+#undef HAVE_LIBPTHREAD
+
+/* Define to 1 if you have the <linux/videodev2.h> header file. */
+#undef HAVE_LINUX_VIDEODEV2_H
+
+/* Define to 1 if you have the <linux/videodev.h> header file. */
+#undef HAVE_LINUX_VIDEODEV_H
+
+/* Define to 1 if you have the <memory.h> header file. */
+#undef HAVE_MEMORY_H
+
+/* Define to 1 if you have the `memset' function. */
+#define HAVE_MEMSET 1
+
+/* Define to 1 if you have a working `mmap' system call. */
+#undef HAVE_MMAP
+
+/* Define to 1 if you have the <poll.h> header file. */
+#undef HAVE_POLL_H
+
+/* Define to 1 if you have the <pthread.h> header file. */
+#undef HAVE_PTHREAD_H
+
+/* Define to 1 if you have the `setenv' function. */
+#undef HAVE_SETENV
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#define HAVE_STDINT_H 1
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#define HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the <strings.h> header file. */
+#define HAVE_STRINGS_H 1
+
+/* Define to 1 if you have the <string.h> header file. */
+#define HAVE_STRING_H 1
+
+/* Define to 1 if you have the <sys/ioctl.h> header file. */
+#undef HAVE_SYS_IOCTL_H
+
+/* Define to 1 if you have the <sys/ipc.h> header file. */
+#undef HAVE_SYS_IPC_H
+
+/* Define to 1 if you have the <sys/mman.h> header file. */
+#undef HAVE_SYS_MMAN_H
+
+/* Define to 1 if you have the <sys/shm.h> header file. */
+#undef HAVE_SYS_SHM_H
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/times.h> header file. */
+#define HAVE_SYS_TIMES_H 1
+
+/* Define to 1 if you have the <sys/time.h> header file. */
+#define HAVE_SYS_TIME_H 1
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if the system has the type `uintptr_t'. */
+#define HAVE_UINTPTR_T 1
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#define HAVE_UNISTD_H 1
+
+/* Define to 1 if you have the <vfw.h> header file. */
+#undef HAVE_VFW_H
+
+/* Define to 1 if you have the <X11/extensions/XShm.h> header file. */
+#undef HAVE_X11_EXTENSIONS_XSHM_H
+
+/* Define to 1 if you have the <X11/extensions/Xvlib.h> header file. */
+#undef HAVE_X11_EXTENSIONS_XVLIB_H
+
+/* Define as const if the declaration of iconv() needs const. */
+#undef ICONV_CONST
+
+/* Library major version */
+#define LIB_VERSION_MAJOR 0
+
+/* Library minor version */
+#define LIB_VERSION_MINOR 2
+
+/* Library revision */
+#define LIB_VERSION_REVISION 0
+
+/* Define to the sub-directory in which libtool stores uninstalled libraries.
+   */
+#undef LT_OBJDIR
+
+/* Define to 1 if assertions should be disabled. */
+//#undef NDEBUG
+
+/* Define to 1 if your C compiler doesn't accept -c and -o together. */
+#undef NO_MINUS_C_MINUS_O
+
+/* Name of package */
+#define PACKAGE "zbar"
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT "spadix@users.sourceforge.net"
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME "zbar"
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING "zbar 0.10"
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME "zbar"
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION "0.10"
+
+/* Define to 1 if you have the ANSI C header files. */
+#define STDC_HEADERS 1
+
+/* Version number of package */
+#define VERSION "0.10"
+
+/* Define to 1 if the X Window System is missing or not being used. */
+#define X_DISPLAY_MISSING 1
+
+/* Program major version (before the '.') as a number */
+#define ZBAR_VERSION_MAJOR 0
+
+/* Program minor version (after '.') as a number */
+#define ZBAR_VERSION_MINOR 10
+
+/* Define for Solaris 2.5.1 so the uint32_t typedef from <sys/synch.h>,
+   <pthread.h>, or <semaphore.h> is not used. If the typedef were allowed, the
+   #define below would cause a syntax error. */
+#undef _UINT32_T
+
+/* Define for Solaris 2.5.1 so the uint8_t typedef from <sys/synch.h>,
+   <pthread.h>, or <semaphore.h> is not used. If the typedef were allowed, the
+   #define below would cause a syntax error. */
+#undef _UINT8_T
+
+/* Minimum Windows API version */
+#undef _WIN32_WINNT
+
+/* used only for pthread debug attributes */
+#undef __USE_UNIX98
+
+/* Define to empty if `const' does not conform to ANSI C. */
+#undef const
+
+/* Define to `__inline__' or `__inline' if that's what the C compiler
+   calls it, or to nothing if 'inline' is not supported under any name.  */
+#ifndef __cplusplus
+#undef inline
+#endif
+
+/* Define to the type of a signed integer type of width exactly 32 bits if
+   such a type exists and the standard includes do not define it. */
+#undef int32_t
+
+/* Define to the type of an unsigned integer type of width exactly 32 bits if
+   such a type exists and the standard includes do not define it. */
+#undef uint32_t
+
+/* Define to the type of an unsigned integer type of width exactly 8 bits if
+   such a type exists and the standard includes do not define it. */
+#undef uint8_t
+
+/* Define to the type of an unsigned integer type wide enough to hold a
+   pointer, if such a type exists, and if the system does not define it. */
+#undef uintptr_t
+
+#ifndef X_DISPLAY_MISSING
+# define HAVE_X
+#endif
+
diff -r 563557a923d0 iphone/include/prefix.pch
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/include/prefix.pch	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,10 @@
+#ifdef __OBJC__
+# import <Foundation/Foundation.h>
+# import <CoreFoundation/CoreFoundation.h>
+# import <CoreGraphics/CoreGraphics.h>
+# import <UIKit/UIKit.h>
+# import <QuartzCore/QuartzCore.h>
+# import <AVFoundation/AVFoundation.h>
+# import <CoreMedia/CoreMedia.h>
+# import <CoreVideo/CoreVideo.h>
+#endif
diff -r 563557a923d0 iphone/res/Columns.DS_Store
Binary file iphone/res/Columns.DS_Store has changed
diff -r 563557a923d0 iphone/res/ZBarSDK-Info.plist
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/res/ZBarSDK-Info.plist	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,16 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
+<plist version="1.0">
+<dict>
+	<key>CFBundleDevelopmentRegion</key>
+	<string>English</string>
+	<key>CFBundleName</key>
+	<string>ZBarSDK</string>
+	<key>CFBundleVersion</key>
+	<string>1.3.1</string>
+	<key>CFBundleSignature</key>
+	<string>????</string>
+	<key>NSHumanReadableCopyright</key>
+	<string>Copyright 2010 Â© Jeff Brown et al</string>
+</dict>
+</plist>
diff -r 563557a923d0 iphone/res/ZBarSDK-bg.png
Binary file iphone/res/ZBarSDK-bg.png has changed
diff -r 563557a923d0 iphone/res/ZBarSDK-bg.svg
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/res/ZBarSDK-bg.svg	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,78 @@
+<?xml version="1.0"?>
+<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
+  "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
+
+<!--
+   Copyright 2010 (c) Jeff Brown <spadix@users.sourceforge.net>
+     All Rights Reserved
+
+   icon size = 64
+   grid spacing = 32
+
+   $ java -Xmx2000m -jar batik-rasterizer.jar -w 4096 -h 4864 -d res/ZBarSDK-bg.8x.png res/ZBarSDK-bg.svg
+   $ convert -resize 12.5% res/ZBarSDK-bg.8x.png res/ZBarSDK-bg.png
+-->
+
+<svg version="1.1" id="top"
+  width="512px" height="608px"
+  viewBox="-1,-1 16,19" preserveAspectRatio="xMidYMid" overflow="visible"
+  xmlns="http://www.w3.org/2000/svg"
+  xmlns:xlink="http://www.w3.org/1999/xlink">
+
+  <title>ZBar iPhone SDK DMG Folder Background Image</title>
+
+  <defs>
+    <style type="text/css"><![CDATA[
+      path, line { fill: none; stroke-linejoin: round; stroke-linecap: round }
+      #bg { fill: url(#bg-grad) }
+      #grid { fill: none; stroke: white; stroke-opacity: .25 ; stroke-width: .05 }
+      #icons { marker: url(#icon) }
+      #icon *, .text { fill: none; stroke: red; stroke-width: .05 }
+      .section { fill: white; stroke: black; stroke-width: .1 }
+      #drag { stroke: none; fill: url(#drag-grad) }
+      text { text-anchor: middle; font-family: sans-serif; font-size: .78125 }
+      .small { font-size: 66% }
+    ]]></style>
+    <marker id="icon" overflow="visible"><rect x="-1" y="-1" width="2" height="2"/></marker>
+    <linearGradient id="bg-grad" x2="0%" y1="5%" y2="100%">
+      <stop offset="0%" stop-color="#36a"/>
+      <stop offset="100%" stop-color="#112"/>
+    </linearGradient>
+    <linearGradient id="drag-grad" x1="100%" x2="0%">
+      <stop offset="0%" stop-color="#4f8" stop-opacity="0.05"/>
+      <stop offset="72%" stop-color="#4f8" stop-opacity=".9"/>
+      <stop offset="100%" stop-color="#4f8" stop-opacity="1"/>
+    </linearGradient>
+  </defs>
+
+  <rect id="bg" x="-1" y="-1" width="16" height="19"/>
+
+  <rect class="section" x="1.5" y="-.25" width="11" height="4" rx=".5" ry=".5"/>
+  <rect class="section" x="1.5" y="4.75" width="11" height="4" rx=".5" ry=".5"/>
+  <rect class="section" x=".5" y="9.75" width="13" height="7.5" rx=".5" ry=".5"/>
+
+  <text y="1.75">
+    <tspan x="8.75" dy=".2344">Read this first</tspan>
+  </text>
+  <text y="6.75">
+    <tspan x="8.75" dy="-.75">Then drag this</tspan>
+    <tspan x="8.75" dy="1">into your</tspan>
+    <tspan x="8.75" dy="1">Xcode project</tspan>
+  </text>
+
+  <path id="drag"
+    d="M3.5,6.125 v1 h-2.75 v.3 l-1.1,-.8 l1.1,-.8 v.3z"/>
+
+<!--
+  <g id="debug">
+    <path id="grid"
+      d="M0,0h14 M0,2h14 M0,4h14 M0,6h14 M0,8h14 M0,10h14 M0,12h14 M0,14h14 M0,16h14 M0,18h14
+         M0,0v17 M2,0v17 M4,0v17 M6,0v17 M8,0v17 M10,0v17 M12,0v17 M14,0v17"/>
+    <path id="icons" d="M3.5,1.5 M3.5,6.5
+                        M3,11.5 M7,11.5 M11,11.5
+                        M3,15 M7,15 M11,15"/>
+    <rect class="text" x="5.5" y=".25" width="6.5" height="3"/>
+    <rect class="text" x="5.5" y="5.25" width="6.5" height="3"/>
+  </g>
+-->
+</svg>
diff -r 563557a923d0 iphone/res/ZBarSDK.DS_Store
Binary file iphone/res/ZBarSDK.DS_Store has changed
diff -r 563557a923d0 iphone/res/buttondown.svg
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/res/buttondown.svg	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,57 @@
+<?xml version="1.0"?>
+<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
+  "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
+
+<!--
+   Copyright 2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+     All Rights Reserved
+-->
+
+<svg version="1.1" id="top"
+  width="384px" height="384px"
+  viewBox="0,0 1,1" preserveAspectRatio="xMidYMid" overflow="visible"
+  xmlns="http://www.w3.org/2000/svg"
+  xmlns:xlink="http://www.w3.org/1999/xlink">
+
+  <title>rounded button overlay</title>
+
+  <defs>
+    <style type="text/css"><![CDATA[
+      #bg { fill: #202020 }
+      #test { fill: #d22 }
+      #button { fill: black; stroke: none; filter: url(#emboss) }
+    ]]></style>
+
+    <filter id="emboss" filterUnits="userSpaceOnUse"
+      x="-1" y="-1" width="3" height="3">
+      <feFlood flood-color="black"
+        x=".05" y=".05" width=".9" height=".9"/>
+      <feGaussianBlur result="grad" stdDeviation=".1"
+        x="-1" y="-1" width="3" height="3"/>
+
+      <feComponentTransfer>
+        <feFuncA type="linear" slope="-1" intercept="1"/>
+      </feComponentTransfer>
+
+      <feSpecularLighting surfaceScale=".25" specularConstant=".75"
+        specularExponent="16" lighting-color="#ccc">
+        <fePointLight x="6" y="-10" z="2"/>
+      </feSpecularLighting>
+      <feGaussianBlur result="spec" stdDeviation="0.015"/>
+
+      <feColorMatrix in="grad" type="matrix" values="
+0 0 0 0 0
+0 0 0 0 0
+0 0 0 0 0
+0 0 0 .8 -.3
+"/>
+      <feComposite in2="spec" operator="over"/>
+      <feComposite in2="SourceAlpha" operator="in"/>
+    </filter>
+  </defs>
+<!--
+  <rect id="bg" x="-.5" y="-.5" width="2" height="2"/>
+  <rect id="test" width="1" height="1" rx=".2" ry=".2"/>
+-->
+  <rect id="button" width="1" height="1" rx=".25" ry=".25"/>
+</svg>
diff -r 563557a923d0 iphone/res/buttonmask.svg
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/res/buttonmask.svg	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,26 @@
+<?xml version="1.0"?>
+<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
+  "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
+
+<!--
+   Copyright 2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+     All Rights Reserved
+-->
+
+<svg version="1.1" id="top"
+  width="384px" height="384px"
+  viewBox="0,0 1,1" preserveAspectRatio="xMidYMid" overflow="visible"
+  xmlns="http://www.w3.org/2000/svg"
+  xmlns:xlink="http://www.w3.org/1999/xlink">
+
+  <title>mask for button overlays</title>
+
+  <defs>
+    <style type="text/css"><![CDATA[
+      #bg { fill: white; stroke: none }
+      #mask { fill: black; stroke: none }
+    ]]></style>
+  </defs>
+  <!--<rect id="bg" x="-1" y="-1" width="3" height="3"/>-->
+  <rect id="mask" width="1" height="1" rx=".25" ry=".25"/>
+</svg>
diff -r 563557a923d0 iphone/res/buttonup.svg
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/res/buttonup.svg	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,57 @@
+<?xml version="1.0"?>
+<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
+  "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
+
+<!--
+   Copyright 2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+     All Rights Reserved
+-->
+
+<svg version="1.1" id="top"
+  width="384px" height="384px"
+  viewBox="0,0 1,1" preserveAspectRatio="xMidYMid" overflow="visible"
+  xmlns="http://www.w3.org/2000/svg"
+  xmlns:xlink="http://www.w3.org/1999/xlink">
+
+  <title>rounded button overlay</title>
+
+  <defs>
+    <style type="text/css"><![CDATA[
+      #bg { fill: #202020 }
+      #test { fill: #d22 }
+      #button { fill: black; stroke: none; filter: url(#emboss) }
+    ]]></style>
+
+    <filter id="emboss" filterUnits="userSpaceOnUse"
+      x="-1" y="-1" width="3" height="3">
+      <feFlood flood-color="black"
+        x=".05" y=".05" width=".9" height=".9"/>
+      <feGaussianBlur result="grad" stdDeviation=".1"
+        x="-1" y="-1" width="3" height="3"/>
+
+      <feSpecularLighting surfaceScale=".25" specularConstant="1"
+        specularExponent="16" lighting-color="#ccc">
+        <fePointLight x="6" y="-10" z="5"/>
+      </feSpecularLighting>
+      <feGaussianBlur result="spec" stdDeviation="0.015"/>
+
+      <feColorMatrix in="grad" type="matrix" values="
+0 0 0 0 0
+0 0 0 0 0
+0 0 0 0 0
+0 0 0 -1.05 1
+"/>
+      <feComposite in2="spec" operator="over"/>
+      <feComposite in2="SourceAlpha" operator="in" result="result"/>
+      <feFlood flood-color="black"/>
+      <feComposite in2="SourceAlpha" operator="out"/>
+      <feComposite in2="result" operator="over"/>
+    </filter>
+  </defs>
+<!--
+  <rect id="bg" x="-.5" y="-.5" width="2" height="2"/>
+
+  <rect id="test" width="1" height="1" rx=".2" ry=".2"/>
+-->
+  <rect id="button" width="1" height="1" rx=".25" ry=".25"/>
+</svg>
diff -r 563557a923d0 iphone/res/lightbulb.svg
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/res/lightbulb.svg	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,108 @@
+<?xml version="1.0"?>
+<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
+  "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
+
+<!--
+   Copyright 2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+     All Rights Reserved
+-->
+
+<svg version="1.1" id="top"
+  width="512px" height="512px"
+  viewBox="0,0 1,1" preserveAspectRatio="xMidYMid" overflow="visible"
+  xmlns="http://www.w3.org/2000/svg"
+  xmlns:xlink="http://www.w3.org/1999/xlink">
+
+  <title>lit light bulb icon</title>
+
+  <defs>
+    <style type="text/css"><![CDATA[
+      path, line { fill: none; stroke-linejoin: round; stroke-linecap: round }
+      #bg { fill: #202020 }
+      #bulb { fill: url(#bulb-on); stroke: #778; stroke-width: .06 }
+      #support { stroke: #888; stroke-width: .03; stroke-opacity: .4 }
+      #filament { stroke: #f80; stroke-width: .06; stroke-opacity: .5 }
+      #rays line { stroke: #fff; stroke-width: .1 }
+      #base { fill: #ccc; stroke: #777; stroke-width: .14 }
+      #screw { stroke: #777; stroke-width: .25 }
+      #nub { fill: #444; stroke: #444; stroke-width: .25 }
+    ]]></style>
+
+    <radialGradient id="bulb-off" gradientUnits="userSpaceOnUse" cx="0" cy="0" r="1.2">
+      <stop offset="0%" stop-color="#ccc"/>
+      <stop offset="33%" stop-color="#ccc"/>
+      <stop offset="100%" stop-color="#999"/>
+    </radialGradient>
+
+    <radialGradient id="bulb-on" gradientUnits="userSpaceOnUse" cx="0" cy="0" r="1.2">
+      <stop offset="0%" stop-color="#ffc"/>
+      <stop offset="33%" stop-color="#ffb"/>
+      <stop offset="100%" stop-color="#dda"/>
+    </radialGradient>
+  </defs>
+
+  <!--<rect id="bg" width="1" height="1"/>-->
+
+  <g transform="translate(.5,.28) scale(.27)">
+    <path id="bulb" d="
+M-.42,1.85
+C-.42,1.4 -.42,1.22 -.866,.5
+A1,1 0 1 1 .866,.5
+C.42,1.22 .42,1.4 .42,1.85
+z
+"/>
+    <path id="support" d="
+M-.42,.1
+C-.15,.9 -.15,1 -.15,1.86
+M.42,.1
+C.15,.9 .15,1 .15,1.86
+"/>
+    <path id="filament" d="
+M-.42,.1
+a.18,.15 0 1 1 .28,0
+a.18,.15 0 1 1 .28,0
+a.18,.15 0 1 1 .28,0
+"/>
+
+    <g id="rays">
+      <line x1="1.2" x2="1.8" transform="rotate(-30)"/>
+      <line x1="1.2" x2="1.8"/>
+      <line x1="1.2" x2="1.8" transform="rotate(30)"/>
+      <line x1="-1.2" x2="-1.8" transform="rotate(-30)"/>
+      <line x1="-1.2" x2="-1.8"/>
+      <line x1="-1.2" x2="-1.8" transform="rotate(30)"/>
+    </g>
+  </g>
+
+  <g transform="translate(.5,.778) scale(.11)">
+    <path id="base" d="
+M-1,-.05
+A2,.75 0 0 0 1,-.05
+V1.2
+L.55,1.6
+H-.55
+L-1,1.2
+z
+"/>
+    <clipPath id="base-clip"><use xlink:href="#base"/></clipPath>
+    <path id="screw" clip-path="url(#base-clip)" d="
+M-1,.1
+a2.2,1 0 0 0 2,-.14
+M-1,.6
+a2.2,1 0 0 0 2,-.14
+M-1,1.1
+a2.2,1 0 0 0 2,-.14
+M-1,1.6
+a2.2,1 0 0 0 2,-.14
+"/>
+  </g>
+
+  <path id="nub" transform="translate(.5,.954) scale(.06)" d="
+M-1,-.05
+A2,.333 0 0 0 1,-.05
+L.5,.5
+H-.5
+z
+"/>
+
+</svg>
diff -r 563557a923d0 iphone/res/shakyhand.svg
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/res/shakyhand.svg	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,108 @@
+<?xml version="1.0"?>
+<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
+  "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
+
+<!--
+   Copyright 2009-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
+     All Rights Reserved
+-->
+
+<svg version="1.1" id="top"
+  width="512px" height="512px"
+  viewBox="0,0 1,1" preserveAspectRatio="xMidYMid" overflow="visible"
+  xmlns="http://www.w3.org/2000/svg"
+  xmlns:xlink="http://www.w3.org/1999/xlink">
+
+  <title>unstable hand icon</title>
+
+  <defs>
+    <style type="text/css"><![CDATA[
+      path, line, circle { fill: none; stroke-linejoin: round; stroke-linecap: round }
+      #bg { fill: #202020 }
+      #hand-outline { stroke: #a76; stroke-width: .75; stroke-opacity: 1 }
+      #skin-base { fill: #db9 }
+      #skin circle { fill: url(#skin-grad);/* stroke: red; stroke-width: .01*/ }
+      #shakes { stroke: #d5f; stroke-width: .03125 } /* #f43 */
+    ]]></style>
+
+    <clipPath id="hand-clip"><use xlink:href="#hand-outline"/></clipPath>
+    <clipPath id="wrist-clip"><rect x="-20" y="3" width="40" height="42"/></clipPath>
+
+    <radialGradient id="skin-grad" r=".5" cx=".5" cy=".5">
+      <stop offset="0%" stop-color="#edc"/>
+      <stop offset="100%" stop-color="#edc" stop-opacity="0"/>
+    </radialGradient>
+  </defs>
+
+  <!--<rect id="bg" width="1" height="1"/>-->
+
+  <g id="hand" transform="translate(.5,-.025) scale(.0225)"
+    clip-path="url(#wrist-clip)">
+    <g id="skin" clip-path="url(#hand-clip)">
+      <rect id="skin-base" x="-20" y="0" width="40" height="50"/>
+
+      <circle r="10" transform="translate(4,33) rotate(-50) scale(1,.75)"/>
+      <circle r="4" transform="translate(-7,32) rotate(-8) scale(1,2)"/>
+      <circle r="4" transform="translate(-1.5,23) rotate(-8) scale(2.4,.9)"/>
+
+      <g transform="rotate(-27.44 0,40)">
+        <circle r="1.5" transform="translate(0,11.5) scale(.85,1.5)"/>
+        <circle r="1.5" transform="translate(0,15.25) scale(.85,1.5)"/>
+        <circle r="1.5" transform="translate(-.2,19) scale(.85,1.5)"/>
+      </g>
+      <g transform="rotate(-13.83 0,40) translate(0,.5)">
+        <circle r="2" transform="translate(0,6.25) scale(.85,1.75)"/>
+        <circle r="2" transform="translate(0,11.5) scale(.85,1.75)"/>
+        <circle r="2" transform="translate(0,16.75) scale(.85,1.75)"/>
+      </g>
+      <g>
+        <circle r="2" transform="translate(0,6.25) scale(.85,1.75)"/>
+        <circle r="2" transform="translate(0,11.5) scale(.85,1.75)"/>
+        <circle r="2" transform="translate(0,16.75) scale(.85,1.75)"/>
+      </g>
+      <g transform="rotate(13.83 0,40) translate(0,.5)">
+        <circle r="2" transform="translate(0,6.25) scale(.85,1.75)"/>
+        <circle r="2" transform="translate(0,11.5) scale(.85,1.75)"/>
+        <circle r="2" transform="translate(0,16.75) scale(.85,1.75)"/>
+      </g>
+      <g transform="rotate(23.025 0,49.75)">
+        <circle r="2.25" transform="translate(0,18) scale(.85,1.5)"/>
+        <circle r="2.25" transform="translate(0,24) scale(.85,1.5)"/>
+      </g>
+    </g>
+
+    <path id="hand-outline" d="
+M-8,45 V39
+C-11,36 -11,32 -11,29
+C-11,22 -11,22 -14.7,14.7
+A1.4,1.4 0 0 1 -12.2,13.2
+L-7.75,21.8
+A.6,.6 0 0 0 -6.66,21.3
+L-10,8
+A2,2 0 0 1 -6,7
+L-3,19.2
+A.5,.5 0 0 0 -2,19
+L-2,5.5
+A2,2 0 0 1 2,5.5
+L2,19
+A.5,.5 0 0 0 3,19.2
+L6,7
+A2,2 0 0 1 10,8
+C7,20 7,19 7,25.5
+A.42,.42 0 0 0 7.75,25.75
+L10.6,18.8
+A2.25,2.25 0 0 1 14.8,20.6
+C11.7,28 11.7,27.7 11,30
+C10,34 7,39 3,40
+L3,45
+"/>
+  </g>
+
+  <path id="shakes" transform="translate(.5,.5) rotate(22.5)" d="
+M.484,0 A.484,.484 0 0 0 .342,-.342
+M.39,0 A.39,.39 0 0 0 .276,-.276
+M-.484,0 A.484,.484 0 0 0 -.342,.342
+M-.39,0 A.39,.39 0 0 0 -.276,.276
+"/>
+
+</svg>
diff -r 563557a923d0 iphone/res/shakyphone.svg
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/res/shakyphone.svg	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,51 @@
+<?xml version="1.0"?>
+<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
+  "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
+
+<!--
+   Copyright 2009-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
+     All Rights Reserved
+-->
+
+<svg version="1.1" id="top"
+  width="512px" height="512px"
+  viewBox="0,0 1,1" preserveAspectRatio="xMidYMid" overflow="visible"
+  xmlns="http://www.w3.org/2000/svg"
+  xmlns:xlink="http://www.w3.org/1999/xlink">
+
+  <title>iPhone shake gesture icon</title>
+
+  <defs>
+    <style type="text/css"><![CDATA[
+      path, line, circle, rect { fill: none; stroke-linejoin: round; stroke-linecap: round }
+      #bg { fill: black }
+      #outline { fill: black; stroke: #4ef; stroke-width: .1 }
+      #screen { fill: #045; stroke: none }
+      #home { fill: #045; stroke: #4ef; stroke-width: .05 }
+      #speaker { stroke: #4ef; stroke-width: .0625 }
+    ]]></style>
+  </defs>
+
+  <!--<rect id="bg" width="1" height="1"/>-->
+
+  <use transform="translate(.5,.5) scale(.2) rotate(-15)"
+    style="opacity: .25"
+    xlink:href="#phone"/>
+
+  <use transform="translate(.5,.5) scale(.2) rotate(-5)"
+    style="opacity: .5"
+    xlink:href="#phone"/>
+
+  <use transform="translate(.5,.5) scale(.2) rotate(5)"
+    style="opacity: .75"
+    xlink:href="#phone"/>
+
+  <g transform="translate(.5,.5) scale(.2) rotate(15)">
+    <g id="phone">
+      <rect id="outline" x="-1.1875" y="-2.21875" width="2.375" height="4.4375" rx=".25" ry=".25"/>
+      <rect id="screen" x="-1" y="-1.5" width="2" height="3"/>
+      <circle id="home" cy="1.84375" r=".21875"/>
+      <line id="speaker" x1="-.25" x2=".25" y1="-1.84375" y2="-1.84375"/>
+    </g>
+  </g>
+</svg>
diff -r 563557a923d0 iphone/res/stopwatch.svg
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/res/stopwatch.svg	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,88 @@
+<?xml version="1.0"?>
+<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
+  "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
+
+<!--
+   Copyright 2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+     All Rights Reserved
+-->
+
+<svg version="1.1" id="top"
+  width="512px" height="512px"
+  viewBox="0,0 1,1" preserveAspectRatio="xMidYMid" overflow="visible"
+  xmlns="http://www.w3.org/2000/svg"
+  xmlns:xlink="http://www.w3.org/1999/xlink">
+
+  <title>stopwatch icon</title>
+
+  <defs>
+    <style type="text/css"><![CDATA[
+      path, line, circle, rect { fill: none; stroke-linejoin: round; stroke-linecap: round }
+      #bg { fill: #202020 }
+      #face { fill: url(#face-grad); stroke: none }
+      #button * { stroke: #fd0 }
+      #btn-top { stroke: url(#btn-grad); stroke-width: .45 }
+      #btn-stem { stroke-width: .5 }
+      #btn-base { fill: #fd0; stroke-width: .18 }
+      #ticks { stroke: #444; stroke-width: .06 }
+      #swoosh { fill: url(#swoosh-grad); stroke: none }
+      #hand { stroke: black; stroke-width: .1 }
+    ]]></style>
+
+    <radialGradient id="face-grad" gradientUnits="userSpaceOnUse" cx="0" cy="0" r="1">
+      <stop offset="0%" stop-color="#fff"/>
+      <stop offset="50%" stop-color="#eef"/>
+      <stop offset="85%" stop-color="#ccd"/>
+      <stop offset="85%" stop-color="#c93"/>
+      <stop offset="91.25%" stop-color="#fd0"/>
+      <stop offset="93.75%" stop-color="#fd0"/>
+      <stop offset="100%" stop-color="#c93"/>
+    </radialGradient>
+
+    <radialGradient id="btn-grad" gradientUnits="userSpaceOnUse"
+      cx="0" cy="0" r="2" gradientTransform="scale(1,.2)">
+      <stop offset="0%" stop-color="#fd0"/>
+      <stop offset="10%" stop-color="#fd0"/>
+      <stop offset="100%" stop-color="#c93"/>
+    </radialGradient>
+
+    <linearGradient id="swoosh-grad" gradientUnits="userSpaceOnUse"
+      x1="1" x2="0" gradientTransform="translate(.22) rotate(-18)"
+      spreadMethod="pad">
+      <stop offset="0%" stop-color="#45f"/>
+      <stop offset="100%" stop-color="#45f" stop-opacity="0"/>
+    </linearGradient>
+  </defs>
+
+  <!--<rect id="bg" width="1" height="1"/>-->
+
+  <g transform="translate(.5,.56) scale(.4375)">
+    <g id="button" transform="translate(0,-1.28) scale(.24) translate(0,.225)">
+      <path id="btn-stem" d="M0,.1v1"/>
+      <path id="btn-top" d="M-1,0h2"/>
+      <rect id="btn-base" x="-1" y=".8" width="2" height=".5"/>
+    </g>
+
+    <circle id="face" r="1"/>
+
+    <g id="ticks">
+      <line y2="-.15" transform="translate(0,-.6)"/>
+      <line y2="-.15" transform="rotate(36) translate(0,-.6)"/>
+      <line y2="-.15" transform="rotate(72) translate(0,-.6)"/>
+      <line y2="-.15" transform="rotate(108) translate(0,-.6)"/>
+      <line y2="-.15" transform="rotate(144) translate(0,-.6)"/>
+      <line y2="-.15" transform="rotate(180) translate(0,-.6)"/>
+      <line y2="-.15" transform="rotate(216) translate(0,-.6)"/>
+      <line y2="-.15" transform="rotate(252) translate(0,-.6)"/>
+      <line y2="-.15" transform="rotate(288) translate(0,-.6)"/>
+      <line y2="-.15" transform="rotate(324) translate(0,-.6)"/>
+    </g>
+
+    <g transform="scale(.8)">
+      <path id="swoosh"
+        d="M0,0 v-1 a1,1 0 0 1 .951,.691z"/>
+      <line id="hand" transform="scale(.975)" x2=".951" y2="-.309"/>
+    </g>
+  </g>
+
+</svg>
diff -r 563557a923d0 iphone/res/zbar-back.png
Binary file iphone/res/zbar-back.png has changed
diff -r 563557a923d0 iphone/res/zbar-back.svg
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/res/zbar-back.svg	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,31 @@
+<?xml version="1.0"?>
+<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
+  "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
+
+<!--
+   Copyright 2010 (c) Jeff Brown <spadix@users.sourceforge.net>
+     All Rights Reserved
+-->
+
+<svg version="1.1" id="top"
+  width="29px" height="24px"
+  viewBox="-.175,-.175 1.45,1.2" preserveAspectRatio="xMidYMid" overflow="visible"
+  xmlns="http://www.w3.org/2000/svg"
+  xmlns:xlink="http://www.w3.org/1999/xlink">
+
+  <title>left pointing arrow toolbar icon</title>
+
+  <defs>
+    <style type="text/css"><![CDATA[
+      path, line { fill: none; stroke-linejoin: round; stroke-linecap: round }
+      #bg { fill: #78a }
+      #arrow { fill: white;; stroke: white; stroke-width: .1 }
+    ]]></style>
+  </defs>
+
+  <!--<rect id="bg" x="-.5" y="-.5" width="2" height="2"/>-->
+
+  <g>
+    <path id="arrow" d="M.1,.5 L.9,.1 .9,.9 z"/>
+  </g>
+</svg>
diff -r 563557a923d0 iphone/res/zbar-help.html
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/res/zbar-help.html	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,89 @@
+<?xml version="1.0"?>
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
+"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
+<!--
+Copyright 2009-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
+All Rights Reserved
+-->
+<html>
+<head>
+<title>Barcode Reader Help</title>
+<style type="text/css">
+html, body { margin: 0; padding: 0; background: black; color: white; font-family: sans-serif; font-size: 16px }
+h1 { margin: .5em 0; text-align: center; font-size: 28px }
+h2 { font-size: 24px }
+hr { margin: 1em 0; height: 0; border: none; border-top: solid 1px #666 }
+.smaller { font-size: 85% }
+p { margin: .5em }
+a { color: #8af }
+p.cen { text-align: center }
+p.title { margin: 1em; clear: both; text-align: center }
+div.col { width: 50% }
+.clear { clear: both }
+.iconlist { position: relative; clear: both; margin: 4px 0; padding: 1px 0 }
+.icon { width: 64px; height: 64px; overflow: hidden; margin: 12px 16px; padding: 0; background: url("zbar-helpicons.png") no-repeat; font: bold 56px "Marker Felt"; text-align: center }
+.sample { display: block; height: 96px; overflow: hidden; margin: 12px auto; padding: 0; background: url("zbar-samples.png") no-repeat; text-align: center}
+.left { float: left }
+.right { float: right }
+.iconlist > p { margin: 10px }
+.iconlist > h2 { margin: 10px }
+</style>
+</head>
+<body>
+<h1 id="title" style="color: #f88">Barcode Reader Help</h1>
+<hr/>
+<p class="title">Recognized barcodes should look like</p>
+<div class="col left">
+<a class="sample" style="width: 118px; background-position: -96px" href="http://wikipedia.org/wiki/EAN-13"></a>
+<p class="cen"><a href="http://wikipedia.org/wiki/EAN-13">EAN/UPC<br/>Product Codes</a></p>
+</div>
+<div class="col right">
+<a class="sample" style="width: 96px" href="http://wikipedia.org/wiki/QR_Code"></a>
+<p class="cen"><a href="http://wikipedia.org/wiki/QR_Code">QR Codes</a></p>
+</div>
+<p class="clear cen smaller">Also recognized, but not shown:
+<a href="http://wikipedia.org/wiki/Code_128">Code 128</a>,
+<a href="http://wikipedia.org/wiki/DataBar">DataBar (RSS)</a>,
+<a href="http://en.wikipedia.org/wiki/Code_93">Code 93</a>,
+<a href="http://wikipedia.org/wiki/Code_39">Code 39</a> and
+<a href="http://wikipedia.org/wiki/Codabar">Codabar</a> and
+<a href="http://wikipedia.org/wiki/Interleaved_2_of_5">Interleaved 2 of 5</a></p>
+<hr/>
+<p class="clear title">Hints for successful scanning</p>
+<div class="iconlist">
+<div class="icon left"></div>
+<p>Ensure there is plenty of</p>
+<h2 style="color: #ff4">Light</h2>
+</div>
+<div class="iconlist">
+<div class="icon left" style="background: none; color: #2d4">4"</div>
+<h2 style="color: #4f6">Distance</h2>
+<p>should be about 3 to 5 inches</p>
+</div>
+<div class="iconlist">
+<div class="icon left" style="background-position: 0 -64px"></div>
+<h2 style="color: #3ee">Shake</h2>
+<p>to force the camera to focus</p>
+</div>
+<div class="iconlist">
+<div class="icon left" style="background-position: 0 -128px"></div>
+<h2 style="color: #59f">Wait</h2>
+<p>for the autofocus to finish</p>
+</div>
+<div class="iconlist">
+<div class="icon left" style="background-position: 0 -192px"></div>
+<h2 style="color: #d5f">Hold Still</h2>
+<p>while the barcode is scanned</p>
+</div>
+<script type="text/javascript">
+function onZBarHelp(argv) {
+var title;
+switch(argv.reason) {
+case "INFO": break;
+case "FAIL": title = "No Barcode Detected"; break;
+}
+if(title) document.getElementById('title').textContent = title;
+}
+</script>
+</body>
+</html>
diff -r 563557a923d0 iphone/res/zbar-helpicons.png
Binary file iphone/res/zbar-helpicons.png has changed
diff -r 563557a923d0 iphone/res/zbar-samples.png
Binary file iphone/res/zbar-samples.png has changed
diff -r 563557a923d0 iphone/zbar.xcodeproj/project.pbxproj
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/zbar.xcodeproj/project.pbxproj	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,1105 @@
+// !$*UTF8*$!
+{
+	archiveVersion = 1;
+	classes = {
+	};
+	objectVersion = 45;
+	objects = {
+
+/* Begin PBXAggregateTarget section */
+		DC1A4A4E11FF5D0500BCDA30 /* ZBarSDK.dmg */ = {
+			isa = PBXAggregateTarget;
+			buildConfigurationList = DC1A4A5311FF5D3D00BCDA30 /* Build configuration list for PBXAggregateTarget "ZBarSDK.dmg" */;
+			buildPhases = (
+				DC3CF2061218355900D7A786 /* Copy SDK */,
+				DC48C585121AC7C20047193B /* Build Documentation */,
+				DC3CF025121720B600D7A786 /* Copy Examples */,
+				DC1A4A4D11FF5D0500BCDA30 /* Make Disk Image */,
+			);
+			dependencies = (
+				DC3CF01F1216366200D7A786 /* PBXTargetDependency */,
+			);
+			name = ZBarSDK.dmg;
+			productName = Package;
+		};
+		DC3CEE821215C7EF00D7A786 /* ZBarSDK */ = {
+			isa = PBXAggregateTarget;
+			buildConfigurationList = DC3CEE851215C83500D7A786 /* Build configuration list for PBXAggregateTarget "ZBarSDK" */;
+			buildPhases = (
+				DC3CEE891215C88000D7A786 /* Build Universal Library */,
+				DC3CEE811215C7EF00D7A786 /* Copy Headers */,
+				DC3CEE9E1215C9B800D7A786 /* Copy Headers */,
+				DC3CEE9F1215C9B800D7A786 /* Copy Resources */,
+			);
+			dependencies = (
+				DC3CEE871215C85400D7A786 /* PBXTargetDependency */,
+			);
+			name = ZBarSDK;
+			productName = ZBarSDK;
+		};
+/* End PBXAggregateTarget section */
+
+/* Begin PBXBuildFile section */
+		DC26004C118631C200FA987B /* ZBarCaptureReader.m in Sources */ = {isa = PBXBuildFile; fileRef = DC26004B118631C200FA987B /* ZBarCaptureReader.m */; };
+		DC290E281351496400A9B857 /* codabar.c in Sources */ = {isa = PBXBuildFile; fileRef = DC290E261351496400A9B857 /* codabar.c */; };
+		DC299A9D1208B5E8006A023C /* libzbar.a in Frameworks */ = {isa = PBXBuildFile; fileRef = D2AAC07E0554694100DB518D /* libzbar.a */; };
+		DC299AA01208B61C006A023C /* AVFoundation.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = DC50453D1203396B009FF359 /* AVFoundation.framework */; settings = {ATTRIBUTES = (Weak, ); }; };
+		DC299AA11208B61C006A023C /* CoreMedia.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = DC50453F1203396B009FF359 /* CoreMedia.framework */; settings = {ATTRIBUTES = (Weak, ); }; };
+		DC299AA21208B61C006A023C /* CoreVideo.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = DC5045411203396B009FF359 /* CoreVideo.framework */; settings = {ATTRIBUTES = (Weak, ); }; };
+		DC299AA31208B61C006A023C /* QuartzCore.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = DC1A49C111FF537000BCDA30 /* QuartzCore.framework */; };
+		DC299AA41208B61C006A023C /* libiconv.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = DC5045431203396B009FF359 /* libiconv.dylib */; };
+		DC299AA51208B63C006A023C /* zbar-help.html in Resources */ = {isa = PBXBuildFile; fileRef = DC1A49A211FF33B300BCDA30 /* zbar-help.html */; };
+		DC299AA61208B63C006A023C /* zbar-helpicons.png in Resources */ = {isa = PBXBuildFile; fileRef = DC1A49A311FF33B300BCDA30 /* zbar-helpicons.png */; };
+		DC299AA71208B63C006A023C /* zbar-samples.png in Resources */ = {isa = PBXBuildFile; fileRef = DC1A49A411FF33B300BCDA30 /* zbar-samples.png */; };
+		DC299B061208FC11006A023C /* CoreGraphics.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = DC299B051208FC11006A023C /* CoreGraphics.framework */; };
+		DC299B311208FCA3006A023C /* UIKit.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = DC67C08210A079BE0033B702 /* UIKit.framework */; };
+		DC299B841208FCAB006A023C /* Foundation.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = AACBBE490F95108600F1A2B1 /* Foundation.framework */; };
+		DC3AAB4F11B71A040021C7B1 /* ZBarCVImage.m in Sources */ = {isa = PBXBuildFile; fileRef = DC3AAB4D11B71A040021C7B1 /* ZBarCVImage.m */; };
+		DC3CE47811FA1622008FAF88 /* ZBarReaderViewImpl_Capture.m in Sources */ = {isa = PBXBuildFile; fileRef = DC3CE47611FA1622008FAF88 /* ZBarReaderViewImpl_Capture.m */; };
+		DC3CE47911FA1622008FAF88 /* ZBarReaderViewImpl_Simulator.m in Sources */ = {isa = PBXBuildFile; fileRef = DC3CE47711FA1622008FAF88 /* ZBarReaderViewImpl_Simulator.m */; };
+		DC3CEE921215C93200D7A786 /* zbar.h in Copy Headers */ = {isa = PBXBuildFile; fileRef = DC67C11710A07A810033B702 /* zbar.h */; };
+		DC3CEE941215C97F00D7A786 /* Decoder.h in Copy Headers */ = {isa = PBXBuildFile; fileRef = DC50463512034A4C009FF359 /* Decoder.h */; };
+		DC3CEE951215C97F00D7A786 /* Exception.h in Copy Headers */ = {isa = PBXBuildFile; fileRef = DC50463612034A4C009FF359 /* Exception.h */; };
+		DC3CEE961215C97F00D7A786 /* Image.h in Copy Headers */ = {isa = PBXBuildFile; fileRef = DC50463712034A4C009FF359 /* Image.h */; };
+		DC3CEE971215C97F00D7A786 /* ImageScanner.h in Copy Headers */ = {isa = PBXBuildFile; fileRef = DC50463812034A4C009FF359 /* ImageScanner.h */; };
+		DC3CEE981215C97F00D7A786 /* Processor.h in Copy Headers */ = {isa = PBXBuildFile; fileRef = DC50463912034A4C009FF359 /* Processor.h */; };
+		DC3CEE991215C97F00D7A786 /* Scanner.h in Copy Headers */ = {isa = PBXBuildFile; fileRef = DC50463A12034A4C009FF359 /* Scanner.h */; };
+		DC3CEE9A1215C97F00D7A786 /* Symbol.h in Copy Headers */ = {isa = PBXBuildFile; fileRef = DC50463B12034A4C009FF359 /* Symbol.h */; };
+		DC3CEE9B1215C97F00D7A786 /* Video.h in Copy Headers */ = {isa = PBXBuildFile; fileRef = DC50463C12034A4C009FF359 /* Video.h */; };
+		DC3CEE9C1215C97F00D7A786 /* Window.h in Copy Headers */ = {isa = PBXBuildFile; fileRef = DC50463D12034A4C009FF359 /* Window.h */; };
+		DC3CEEA01215C9C000D7A786 /* zbar-help.html in Copy Resources */ = {isa = PBXBuildFile; fileRef = DC1A49A211FF33B300BCDA30 /* zbar-help.html */; };
+		DC3CEEA11215C9C000D7A786 /* zbar-helpicons.png in Copy Resources */ = {isa = PBXBuildFile; fileRef = DC1A49A311FF33B300BCDA30 /* zbar-helpicons.png */; };
+		DC3CEEA21215C9C000D7A786 /* zbar-samples.png in Copy Resources */ = {isa = PBXBuildFile; fileRef = DC1A49A411FF33B300BCDA30 /* zbar-samples.png */; };
+		DC3CEFB51216349700D7A786 /* ZBarCaptureReader.h in Copy Headers */ = {isa = PBXBuildFile; fileRef = DC3CEFA51216347100D7A786 /* ZBarCaptureReader.h */; };
+		DC3CEFB61216349700D7A786 /* ZBarImage.h in Copy Headers */ = {isa = PBXBuildFile; fileRef = DC3CEFA61216347100D7A786 /* ZBarImage.h */; };
+		DC3CEFB71216349700D7A786 /* ZBarImageScanner.h in Copy Headers */ = {isa = PBXBuildFile; fileRef = DC3CEFA71216347100D7A786 /* ZBarImageScanner.h */; };
+		DC3CEFB81216349700D7A786 /* ZBarReaderController.h in Copy Headers */ = {isa = PBXBuildFile; fileRef = DC3CEFA81216347100D7A786 /* ZBarReaderController.h */; };
+		DC3CEFB91216349700D7A786 /* ZBarReaderView.h in Copy Headers */ = {isa = PBXBuildFile; fileRef = DC3CEFA91216347100D7A786 /* ZBarReaderView.h */; };
+		DC3CEFBA1216349700D7A786 /* ZBarReaderViewController.h in Copy Headers */ = {isa = PBXBuildFile; fileRef = DC3CEFAA1216347100D7A786 /* ZBarReaderViewController.h */; };
+		DC3CEFBB1216349700D7A786 /* ZBarSDK.h in Copy Headers */ = {isa = PBXBuildFile; fileRef = DC3CEFAB1216347100D7A786 /* ZBarSDK.h */; };
+		DC3CEFBC1216349700D7A786 /* ZBarSymbol.h in Copy Headers */ = {isa = PBXBuildFile; fileRef = DC3CEFAC1216347100D7A786 /* ZBarSymbol.h */; };
+		DC3CF2021218353B00D7A786 /* README in Copy SDK */ = {isa = PBXBuildFile; fileRef = DC50467B12034D60009FF359 /* README */; };
+		DC3CF2031218353B00D7A786 /* ChangeLog in Copy SDK */ = {isa = PBXBuildFile; fileRef = DC3CF141121721A100D7A786 /* ChangeLog */; };
+		DC3CF2041218353B00D7A786 /* COPYING in Copy SDK */ = {isa = PBXBuildFile; fileRef = DC50467C12034D71009FF359 /* COPYING */; };
+		DC3CF2051218353B00D7A786 /* LICENSE in Copy SDK */ = {isa = PBXBuildFile; fileRef = DC50467D12034D71009FF359 /* LICENSE */; };
+		DC3CF29A1218359400D7A786 /* ReaderSample in Copy Examples */ = {isa = PBXBuildFile; fileRef = DC3CF2081218358C00D7A786 /* ReaderSample */; };
+		DC3CF29B1218359400D7A786 /* readertest in Copy Examples */ = {isa = PBXBuildFile; fileRef = DC3CF2651218358C00D7A786 /* readertest */; };
+		DC3CF2A312197A8C00D7A786 /* zbar-back.png in Copy Resources */ = {isa = PBXBuildFile; fileRef = DC3CF2A212197A7200D7A786 /* zbar-back.png */; };
+		DC3EBB2D119DDB2100107EE9 /* ZBarReaderViewController.m in Sources */ = {isa = PBXBuildFile; fileRef = DC3EBB2C119DDB2100107EE9 /* ZBarReaderViewController.m */; };
+		DC48C5341219FDDE0047193B /* zbar-back.png in Resources */ = {isa = PBXBuildFile; fileRef = DC3CF2A212197A7200D7A786 /* zbar-back.png */; };
+		DC48C5411219FE550047193B /* readertest.m in Sources */ = {isa = PBXBuildFile; fileRef = DC48C5401219FE550047193B /* readertest.m */; };
+		DC48C57D121A1F410047193B /* ZBarSDK in Copy SDK */ = {isa = PBXBuildFile; fileRef = DC48C55F121A1E7F0047193B /* ZBarSDK */; };
+		DC48C5A8121B1F910047193B /* Documentation.html in Copy SDK */ = {isa = PBXBuildFile; fileRef = DC48C5A7121B1F840047193B /* Documentation.html */; };
+		DC4920EE10A70475000E4D43 /* ZBarImage.m in Sources */ = {isa = PBXBuildFile; fileRef = DC4920EC10A70475000E4D43 /* ZBarImage.m */; };
+		DC4920EF10A70475000E4D43 /* ZBarImageScanner.m in Sources */ = {isa = PBXBuildFile; fileRef = DC4920ED10A70475000E4D43 /* ZBarImageScanner.m */; };
+		DC5D76C3136FA8C40069AEF5 /* ZBarCameraSimulator.m in Sources */ = {isa = PBXBuildFile; fileRef = DC5D76C2136FA8C40069AEF5 /* ZBarCameraSimulator.m */; };
+		DC5D76C6136FA94B0069AEF5 /* ZBarCameraSimulator.h in Copy Headers */ = {isa = PBXBuildFile; fileRef = DC5D76C5136FA8F20069AEF5 /* ZBarCameraSimulator.h */; };
+		DC67C17110A07AD30033B702 /* config.c in Sources */ = {isa = PBXBuildFile; fileRef = DC67C11F10A07AD30033B702 /* config.c */; };
+		DC67C17410A07AD30033B702 /* code128.c in Sources */ = {isa = PBXBuildFile; fileRef = DC67C12310A07AD30033B702 /* code128.c */; };
+		DC67C17610A07AD30033B702 /* code39.c in Sources */ = {isa = PBXBuildFile; fileRef = DC67C12510A07AD30033B702 /* code39.c */; };
+		DC67C17810A07AD30033B702 /* ean.c in Sources */ = {isa = PBXBuildFile; fileRef = DC67C12710A07AD30033B702 /* ean.c */; };
+		DC67C17A10A07AD30033B702 /* i25.c in Sources */ = {isa = PBXBuildFile; fileRef = DC67C12910A07AD30033B702 /* i25.c */; };
+		DC67C17F10A07AD30033B702 /* qr_finder.c in Sources */ = {isa = PBXBuildFile; fileRef = DC67C12E10A07AD30033B702 /* qr_finder.c */; };
+		DC67C18110A07AD30033B702 /* decoder.c in Sources */ = {isa = PBXBuildFile; fileRef = DC67C13010A07AD30033B702 /* decoder.c */; };
+		DC67C18310A07AD30033B702 /* error.c in Sources */ = {isa = PBXBuildFile; fileRef = DC67C13210A07AD30033B702 /* error.c */; };
+		DC67C18610A07AD30033B702 /* image.c in Sources */ = {isa = PBXBuildFile; fileRef = DC67C13510A07AD30033B702 /* image.c */; };
+		DC67C18810A07AD30033B702 /* img_scanner.c in Sources */ = {isa = PBXBuildFile; fileRef = DC67C13710A07AD30033B702 /* img_scanner.c */; };
+		DC67C19510A07AD30033B702 /* bch15_5.c in Sources */ = {isa = PBXBuildFile; fileRef = DC67C14710A07AD30033B702 /* bch15_5.c */; };
+		DC67C19710A07AD30033B702 /* binarize.c in Sources */ = {isa = PBXBuildFile; fileRef = DC67C14910A07AD30033B702 /* binarize.c */; };
+		DC67C19910A07AD30033B702 /* isaac.c in Sources */ = {isa = PBXBuildFile; fileRef = DC67C14B10A07AD30033B702 /* isaac.c */; };
+		DC67C19B10A07AD30033B702 /* qrdec.c in Sources */ = {isa = PBXBuildFile; fileRef = DC67C14D10A07AD30033B702 /* qrdec.c */; };
+		DC67C19D10A07AD30033B702 /* qrdectxt.c in Sources */ = {isa = PBXBuildFile; fileRef = DC67C14F10A07AD30033B702 /* qrdectxt.c */; };
+		DC67C19E10A07AD30033B702 /* rs.c in Sources */ = {isa = PBXBuildFile; fileRef = DC67C15010A07AD30033B702 /* rs.c */; };
+		DC67C1A010A07AD30033B702 /* util.c in Sources */ = {isa = PBXBuildFile; fileRef = DC67C15210A07AD30033B702 /* util.c */; };
+		DC67C1A310A07AD30033B702 /* refcnt.c in Sources */ = {isa = PBXBuildFile; fileRef = DC67C15510A07AD30033B702 /* refcnt.c */; };
+		DC67C1A510A07AD30033B702 /* scanner.c in Sources */ = {isa = PBXBuildFile; fileRef = DC67C15710A07AD30033B702 /* scanner.c */; };
+		DC67C1A810A07AD30033B702 /* symbol.c in Sources */ = {isa = PBXBuildFile; fileRef = DC67C15A10A07AD30033B702 /* symbol.c */; };
+		DC67C1C210A07B6B0033B702 /* ZBarHelpController.m in Sources */ = {isa = PBXBuildFile; fileRef = DC67C1BE10A07B6B0033B702 /* ZBarHelpController.m */; };
+		DC67C1C310A07B6B0033B702 /* ZBarReaderController.m in Sources */ = {isa = PBXBuildFile; fileRef = DC67C1BF10A07B6B0033B702 /* ZBarReaderController.m */; };
+		DC67C1C410A07B6B0033B702 /* ZBarSymbol.m in Sources */ = {isa = PBXBuildFile; fileRef = DC67C1C010A07B6B0033B702 /* ZBarSymbol.m */; };
+		DC8245EF1629DC340010B2E6 /* Default-568h@2x.png in Resources */ = {isa = PBXBuildFile; fileRef = DC8245EE1629DC140010B2E6 /* Default-568h@2x.png */; };
+		DCB3789B12A43CAC0059B07B /* ZBarHelpController.h in Copy Headers */ = {isa = PBXBuildFile; fileRef = DCB3789A12A43C7E0059B07B /* ZBarHelpController.h */; };
+		DCC93259137B50CB0040A82D /* EmbedReader in Copy Examples */ = {isa = PBXBuildFile; fileRef = DCC9324E137B509B0040A82D /* EmbedReader */; };
+		DCC9325A137B50CB0040A82D /* TabReader in Copy Examples */ = {isa = PBXBuildFile; fileRef = DCC9324F137B509B0040A82D /* TabReader */; };
+		DCDC6E3011ADCA8E00021380 /* ZBarReaderView.m in Sources */ = {isa = PBXBuildFile; fileRef = DCDC6E2F11ADCA8E00021380 /* ZBarReaderView.m */; };
+		DCE9900D129719F100D2655C /* code93.c in Sources */ = {isa = PBXBuildFile; fileRef = DCE9900B129719F100D2655C /* code93.c */; };
+		DCF5C9AD11EA3AD100E7DC21 /* databar.c in Sources */ = {isa = PBXBuildFile; fileRef = DCF5C9AB11EA3AD100E7DC21 /* databar.c */; };
+/* End PBXBuildFile section */
+
+/* Begin PBXContainerItemProxy section */
+		DC299A9E1208B5F1006A023C /* PBXContainerItemProxy */ = {
+			isa = PBXContainerItemProxy;
+			containerPortal = 0867D690FE84028FC02AAC07 /* Project object */;
+			proxyType = 1;
+			remoteGlobalIDString = D2AAC07D0554694100DB518D;
+			remoteInfo = libzbar;
+		};
+		DC3CEE861215C85400D7A786 /* PBXContainerItemProxy */ = {
+			isa = PBXContainerItemProxy;
+			containerPortal = 0867D690FE84028FC02AAC07 /* Project object */;
+			proxyType = 1;
+			remoteGlobalIDString = D2AAC07D0554694100DB518D;
+			remoteInfo = libzbar;
+		};
+		DC3CF01E1216366200D7A786 /* PBXContainerItemProxy */ = {
+			isa = PBXContainerItemProxy;
+			containerPortal = 0867D690FE84028FC02AAC07 /* Project object */;
+			proxyType = 1;
+			remoteGlobalIDString = DC3CEE821215C7EF00D7A786;
+			remoteInfo = ZBarSDK;
+		};
+/* End PBXContainerItemProxy section */
+
+/* Begin PBXCopyFilesBuildPhase section */
+		DC3CEE811215C7EF00D7A786 /* Copy Headers */ = {
+			isa = PBXCopyFilesBuildPhase;
+			buildActionMask = 2147483647;
+			dstPath = Headers/ZBarSDK;
+			dstSubfolderSpec = 1;
+			files = (
+				DC5D76C6136FA94B0069AEF5 /* ZBarCameraSimulator.h in Copy Headers */,
+				DC3CEFB51216349700D7A786 /* ZBarCaptureReader.h in Copy Headers */,
+				DCB3789B12A43CAC0059B07B /* ZBarHelpController.h in Copy Headers */,
+				DC3CEFB61216349700D7A786 /* ZBarImage.h in Copy Headers */,
+				DC3CEFB71216349700D7A786 /* ZBarImageScanner.h in Copy Headers */,
+				DC3CEFB81216349700D7A786 /* ZBarReaderController.h in Copy Headers */,
+				DC3CEFB91216349700D7A786 /* ZBarReaderView.h in Copy Headers */,
+				DC3CEFBA1216349700D7A786 /* ZBarReaderViewController.h in Copy Headers */,
+				DC3CEFBB1216349700D7A786 /* ZBarSDK.h in Copy Headers */,
+				DC3CEFBC1216349700D7A786 /* ZBarSymbol.h in Copy Headers */,
+				DC3CEE921215C93200D7A786 /* zbar.h in Copy Headers */,
+			);
+			name = "Copy Headers";
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		DC3CEE9E1215C9B800D7A786 /* Copy Headers */ = {
+			isa = PBXCopyFilesBuildPhase;
+			buildActionMask = 2147483647;
+			dstPath = Headers/ZBarSDK/zbar;
+			dstSubfolderSpec = 1;
+			files = (
+				DC3CEE941215C97F00D7A786 /* Decoder.h in Copy Headers */,
+				DC3CEE951215C97F00D7A786 /* Exception.h in Copy Headers */,
+				DC3CEE961215C97F00D7A786 /* Image.h in Copy Headers */,
+				DC3CEE971215C97F00D7A786 /* ImageScanner.h in Copy Headers */,
+				DC3CEE981215C97F00D7A786 /* Processor.h in Copy Headers */,
+				DC3CEE991215C97F00D7A786 /* Scanner.h in Copy Headers */,
+				DC3CEE9A1215C97F00D7A786 /* Symbol.h in Copy Headers */,
+				DC3CEE9B1215C97F00D7A786 /* Video.h in Copy Headers */,
+				DC3CEE9C1215C97F00D7A786 /* Window.h in Copy Headers */,
+			);
+			name = "Copy Headers";
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		DC3CEE9F1215C9B800D7A786 /* Copy Resources */ = {
+			isa = PBXCopyFilesBuildPhase;
+			buildActionMask = 2147483647;
+			dstPath = Resources;
+			dstSubfolderSpec = 1;
+			files = (
+				DC3CF2A312197A8C00D7A786 /* zbar-back.png in Copy Resources */,
+				DC3CEEA01215C9C000D7A786 /* zbar-help.html in Copy Resources */,
+				DC3CEEA11215C9C000D7A786 /* zbar-helpicons.png in Copy Resources */,
+				DC3CEEA21215C9C000D7A786 /* zbar-samples.png in Copy Resources */,
+			);
+			name = "Copy Resources";
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		DC3CF025121720B600D7A786 /* Copy Examples */ = {
+			isa = PBXCopyFilesBuildPhase;
+			buildActionMask = 2147483647;
+			dstPath = Examples;
+			dstSubfolderSpec = 1;
+			files = (
+				DC3CF29A1218359400D7A786 /* ReaderSample in Copy Examples */,
+				DC3CF29B1218359400D7A786 /* readertest in Copy Examples */,
+				DCC93259137B50CB0040A82D /* EmbedReader in Copy Examples */,
+				DCC9325A137B50CB0040A82D /* TabReader in Copy Examples */,
+			);
+			name = "Copy Examples";
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		DC3CF2061218355900D7A786 /* Copy SDK */ = {
+			isa = PBXCopyFilesBuildPhase;
+			buildActionMask = 2147483647;
+			dstPath = "";
+			dstSubfolderSpec = 1;
+			files = (
+				DC48C57D121A1F410047193B /* ZBarSDK in Copy SDK */,
+				DC3CF2021218353B00D7A786 /* README in Copy SDK */,
+				DC3CF2031218353B00D7A786 /* ChangeLog in Copy SDK */,
+				DC3CF2041218353B00D7A786 /* COPYING in Copy SDK */,
+				DC3CF2051218353B00D7A786 /* LICENSE in Copy SDK */,
+				DC48C5A8121B1F910047193B /* Documentation.html in Copy SDK */,
+			);
+			name = "Copy SDK";
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+/* End PBXCopyFilesBuildPhase section */
+
+/* Begin PBXFileReference section */
+		AACBBE490F95108600F1A2B1 /* Foundation.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = Foundation.framework; path = System/Library/Frameworks/Foundation.framework; sourceTree = SDKROOT; };
+		D2AAC07E0554694100DB518D /* libzbar.a */ = {isa = PBXFileReference; explicitFileType = archive.ar; includeInIndex = 0; path = libzbar.a; sourceTree = BUILT_PRODUCTS_DIR; };
+		DC1A49A211FF33B300BCDA30 /* zbar-help.html */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.html; name = "zbar-help.html"; path = "res/zbar-help.html"; sourceTree = "<group>"; };
+		DC1A49A311FF33B300BCDA30 /* zbar-helpicons.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; name = "zbar-helpicons.png"; path = "res/zbar-helpicons.png"; sourceTree = "<group>"; };
+		DC1A49A411FF33B300BCDA30 /* zbar-samples.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; name = "zbar-samples.png"; path = "res/zbar-samples.png"; sourceTree = "<group>"; };
+		DC1A49C111FF537000BCDA30 /* QuartzCore.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = QuartzCore.framework; path = System/Library/Frameworks/QuartzCore.framework; sourceTree = SDKROOT; };
+		DC26004B118631C200FA987B /* ZBarCaptureReader.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = ZBarCaptureReader.m; sourceTree = "<group>"; usesTabs = 0; };
+		DC290E261351496400A9B857 /* codabar.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = codabar.c; sourceTree = "<group>"; };
+		DC290E271351496400A9B857 /* codabar.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = codabar.h; sourceTree = "<group>"; };
+		DC299AF51208B7BD006A023C /* config.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = config.h; path = include/config.h; sourceTree = "<group>"; };
+		DC299B051208FC11006A023C /* CoreGraphics.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = CoreGraphics.framework; path = System/Library/Frameworks/CoreGraphics.framework; sourceTree = SDKROOT; };
+		DC299BEC1208FE40006A023C /* prefix.pch */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = prefix.pch; path = include/prefix.pch; sourceTree = "<group>"; };
+		DC3AAB4C11B71A040021C7B1 /* ZBarCVImage.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ZBarCVImage.h; sourceTree = "<group>"; usesTabs = 0; };
+		DC3AAB4D11B71A040021C7B1 /* ZBarCVImage.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = ZBarCVImage.m; sourceTree = "<group>"; usesTabs = 0; };
+		DC3CE47611FA1622008FAF88 /* ZBarReaderViewImpl_Capture.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = ZBarReaderViewImpl_Capture.m; sourceTree = "<group>"; usesTabs = 0; };
+		DC3CE47711FA1622008FAF88 /* ZBarReaderViewImpl_Simulator.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = ZBarReaderViewImpl_Simulator.m; sourceTree = "<group>"; usesTabs = 0; };
+		DC3CEF9D121633C500D7A786 /* readertest.app */ = {isa = PBXFileReference; explicitFileType = wrapper.application; includeInIndex = 0; path = readertest.app; sourceTree = BUILT_PRODUCTS_DIR; };
+		DC3CEFA51216347100D7A786 /* ZBarCaptureReader.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ZBarCaptureReader.h; path = include/ZBarSDK/ZBarCaptureReader.h; sourceTree = "<group>"; };
+		DC3CEFA61216347100D7A786 /* ZBarImage.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ZBarImage.h; path = include/ZBarSDK/ZBarImage.h; sourceTree = "<group>"; };
+		DC3CEFA71216347100D7A786 /* ZBarImageScanner.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ZBarImageScanner.h; path = include/ZBarSDK/ZBarImageScanner.h; sourceTree = "<group>"; };
+		DC3CEFA81216347100D7A786 /* ZBarReaderController.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ZBarReaderController.h; path = include/ZBarSDK/ZBarReaderController.h; sourceTree = "<group>"; };
+		DC3CEFA91216347100D7A786 /* ZBarReaderView.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ZBarReaderView.h; path = include/ZBarSDK/ZBarReaderView.h; sourceTree = "<group>"; };
+		DC3CEFAA1216347100D7A786 /* ZBarReaderViewController.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ZBarReaderViewController.h; path = include/ZBarSDK/ZBarReaderViewController.h; sourceTree = "<group>"; };
+		DC3CEFAB1216347100D7A786 /* ZBarSDK.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ZBarSDK.h; path = include/ZBarSDK/ZBarSDK.h; sourceTree = "<group>"; };
+		DC3CEFAC1216347100D7A786 /* ZBarSymbol.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ZBarSymbol.h; path = include/ZBarSDK/ZBarSymbol.h; sourceTree = "<group>"; };
+		DC3CF141121721A100D7A786 /* ChangeLog */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; path = ChangeLog; sourceTree = "<group>"; };
+		DC3CF2081218358C00D7A786 /* ReaderSample */ = {isa = PBXFileReference; lastKnownFileType = folder; name = ReaderSample; path = examples/ReaderSample; sourceTree = "<group>"; };
+		DC3CF2651218358C00D7A786 /* readertest */ = {isa = PBXFileReference; lastKnownFileType = folder; name = readertest; path = examples/readertest; sourceTree = "<group>"; };
+		DC3CF2A212197A7200D7A786 /* zbar-back.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; name = "zbar-back.png"; path = "res/zbar-back.png"; sourceTree = "<group>"; };
+		DC3EBB2C119DDB2100107EE9 /* ZBarReaderViewController.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = ZBarReaderViewController.m; sourceTree = "<group>"; usesTabs = 0; };
+		DC48C5401219FE550047193B /* readertest.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; name = readertest.m; path = examples/readertest/readertest.m; sourceTree = "<group>"; };
+		DC48C55F121A1E7F0047193B /* ZBarSDK */ = {isa = PBXFileReference; lastKnownFileType = folder; path = ZBarSDK; sourceTree = BUILT_PRODUCTS_DIR; };
+		DC48C5A7121B1F840047193B /* Documentation.html */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.html; name = Documentation.html; path = doc/Documentation.html; sourceTree = "<group>"; };
+		DC4920EC10A70475000E4D43 /* ZBarImage.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = ZBarImage.m; sourceTree = "<group>"; usesTabs = 0; };
+		DC4920ED10A70475000E4D43 /* ZBarImageScanner.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = ZBarImageScanner.m; sourceTree = "<group>"; usesTabs = 0; };
+		DC50453D1203396B009FF359 /* AVFoundation.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = AVFoundation.framework; path = System/Library/Frameworks/AVFoundation.framework; sourceTree = SDKROOT; };
+		DC50453F1203396B009FF359 /* CoreMedia.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = CoreMedia.framework; path = System/Library/Frameworks/CoreMedia.framework; sourceTree = SDKROOT; };
+		DC5045411203396B009FF359 /* CoreVideo.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = CoreVideo.framework; path = System/Library/Frameworks/CoreVideo.framework; sourceTree = SDKROOT; };
+		DC5045431203396B009FF359 /* libiconv.dylib */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.dylib"; name = libiconv.dylib; path = usr/lib/libiconv.dylib; sourceTree = SDKROOT; };
+		DC50463512034A4C009FF359 /* Decoder.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Decoder.h; path = ../include/zbar/Decoder.h; sourceTree = SOURCE_ROOT; };
+		DC50463612034A4C009FF359 /* Exception.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Exception.h; path = ../include/zbar/Exception.h; sourceTree = SOURCE_ROOT; };
+		DC50463712034A4C009FF359 /* Image.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Image.h; path = ../include/zbar/Image.h; sourceTree = SOURCE_ROOT; };
+		DC50463812034A4C009FF359 /* ImageScanner.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ImageScanner.h; path = ../include/zbar/ImageScanner.h; sourceTree = SOURCE_ROOT; };
+		DC50463912034A4C009FF359 /* Processor.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Processor.h; path = ../include/zbar/Processor.h; sourceTree = SOURCE_ROOT; };
+		DC50463A12034A4C009FF359 /* Scanner.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Scanner.h; path = ../include/zbar/Scanner.h; sourceTree = SOURCE_ROOT; };
+		DC50463B12034A4C009FF359 /* Symbol.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Symbol.h; path = ../include/zbar/Symbol.h; sourceTree = SOURCE_ROOT; };
+		DC50463C12034A4C009FF359 /* Video.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Video.h; path = ../include/zbar/Video.h; sourceTree = SOURCE_ROOT; };
+		DC50463D12034A4C009FF359 /* Window.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Window.h; path = ../include/zbar/Window.h; sourceTree = SOURCE_ROOT; };
+		DC50467B12034D60009FF359 /* README */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; path = README; sourceTree = "<group>"; };
+		DC50467C12034D71009FF359 /* COPYING */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; name = COPYING; path = ../COPYING; sourceTree = SOURCE_ROOT; };
+		DC50467D12034D71009FF359 /* LICENSE */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; name = LICENSE; path = ../LICENSE; sourceTree = SOURCE_ROOT; };
+		DC5D76C2136FA8C40069AEF5 /* ZBarCameraSimulator.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = ZBarCameraSimulator.m; sourceTree = "<group>"; };
+		DC5D76C5136FA8F20069AEF5 /* ZBarCameraSimulator.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ZBarCameraSimulator.h; path = include/ZBarSDK/ZBarCameraSimulator.h; sourceTree = "<group>"; };
+		DC67C08210A079BE0033B702 /* UIKit.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = UIKit.framework; path = System/Library/Frameworks/UIKit.framework; sourceTree = SDKROOT; };
+		DC67C11710A07A810033B702 /* zbar.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = zbar.h; path = ../include/zbar.h; sourceTree = SOURCE_ROOT; usesTabs = 0; };
+		DC67C11F10A07AD30033B702 /* config.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = config.c; sourceTree = "<group>"; usesTabs = 0; };
+		DC67C12110A07AD30033B702 /* debug.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = debug.h; sourceTree = "<group>"; usesTabs = 0; };
+		DC67C12310A07AD30033B702 /* code128.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = code128.c; sourceTree = "<group>"; };
+		DC67C12410A07AD30033B702 /* code128.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = code128.h; sourceTree = "<group>"; };
+		DC67C12510A07AD30033B702 /* code39.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = code39.c; sourceTree = "<group>"; };
+		DC67C12610A07AD30033B702 /* code39.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = code39.h; sourceTree = "<group>"; };
+		DC67C12710A07AD30033B702 /* ean.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = ean.c; sourceTree = "<group>"; };
+		DC67C12810A07AD30033B702 /* ean.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ean.h; sourceTree = "<group>"; };
+		DC67C12910A07AD30033B702 /* i25.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = i25.c; sourceTree = "<group>"; };
+		DC67C12A10A07AD30033B702 /* i25.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = i25.h; sourceTree = "<group>"; };
+		DC67C12E10A07AD30033B702 /* qr_finder.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = qr_finder.c; sourceTree = "<group>"; };
+		DC67C12F10A07AD30033B702 /* qr_finder.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = qr_finder.h; sourceTree = "<group>"; };
+		DC67C13010A07AD30033B702 /* decoder.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = decoder.c; sourceTree = "<group>"; usesTabs = 0; };
+		DC67C13110A07AD30033B702 /* decoder.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = decoder.h; sourceTree = "<group>"; usesTabs = 0; };
+		DC67C13210A07AD30033B702 /* error.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = error.c; sourceTree = "<group>"; usesTabs = 0; };
+		DC67C13310A07AD30033B702 /* error.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = error.h; sourceTree = "<group>"; usesTabs = 0; };
+		DC67C13510A07AD30033B702 /* image.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = image.c; sourceTree = "<group>"; usesTabs = 0; };
+		DC67C13610A07AD30033B702 /* image.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = image.h; sourceTree = "<group>"; usesTabs = 0; };
+		DC67C13710A07AD30033B702 /* img_scanner.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = img_scanner.c; sourceTree = "<group>"; usesTabs = 0; };
+		DC67C13810A07AD30033B702 /* img_scanner.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = img_scanner.h; sourceTree = "<group>"; usesTabs = 0; };
+		DC67C14710A07AD30033B702 /* bch15_5.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = bch15_5.c; sourceTree = "<group>"; };
+		DC67C14810A07AD30033B702 /* bch15_5.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = bch15_5.h; sourceTree = "<group>"; };
+		DC67C14910A07AD30033B702 /* binarize.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = binarize.c; sourceTree = "<group>"; };
+		DC67C14A10A07AD30033B702 /* binarize.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = binarize.h; sourceTree = "<group>"; };
+		DC67C14B10A07AD30033B702 /* isaac.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = isaac.c; sourceTree = "<group>"; };
+		DC67C14C10A07AD30033B702 /* isaac.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = isaac.h; sourceTree = "<group>"; };
+		DC67C14D10A07AD30033B702 /* qrdec.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = qrdec.c; sourceTree = "<group>"; };
+		DC67C14E10A07AD30033B702 /* qrdec.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = qrdec.h; sourceTree = "<group>"; };
+		DC67C14F10A07AD30033B702 /* qrdectxt.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = qrdectxt.c; sourceTree = "<group>"; };
+		DC67C15010A07AD30033B702 /* rs.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = rs.c; sourceTree = "<group>"; };
+		DC67C15110A07AD30033B702 /* rs.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = rs.h; sourceTree = "<group>"; };
+		DC67C15210A07AD30033B702 /* util.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = util.c; sourceTree = "<group>"; };
+		DC67C15310A07AD30033B702 /* util.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = util.h; sourceTree = "<group>"; };
+		DC67C15410A07AD30033B702 /* qrcode.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = qrcode.h; sourceTree = "<group>"; usesTabs = 0; };
+		DC67C15510A07AD30033B702 /* refcnt.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = refcnt.c; sourceTree = "<group>"; usesTabs = 0; };
+		DC67C15610A07AD30033B702 /* refcnt.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = refcnt.h; sourceTree = "<group>"; usesTabs = 0; };
+		DC67C15710A07AD30033B702 /* scanner.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = scanner.c; sourceTree = "<group>"; usesTabs = 0; };
+		DC67C15A10A07AD30033B702 /* symbol.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = symbol.c; sourceTree = "<group>"; usesTabs = 0; };
+		DC67C15B10A07AD30033B702 /* symbol.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = symbol.h; sourceTree = "<group>"; usesTabs = 0; };
+		DC67C1BE10A07B6B0033B702 /* ZBarHelpController.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = ZBarHelpController.m; sourceTree = "<group>"; usesTabs = 0; };
+		DC67C1BF10A07B6B0033B702 /* ZBarReaderController.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = ZBarReaderController.m; sourceTree = "<group>"; usesTabs = 0; };
+		DC67C1C010A07B6B0033B702 /* ZBarSymbol.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = ZBarSymbol.m; sourceTree = "<group>"; usesTabs = 0; };
+		DC67C1CB10A07BEE0033B702 /* svg.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = svg.h; sourceTree = "<group>"; usesTabs = 0; };
+		DC8245EE1629DC140010B2E6 /* Default-568h@2x.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; name = "Default-568h@2x.png"; path = "examples/readertest/Default-568h@2x.png"; sourceTree = "<group>"; };
+		DCB3789A12A43C7E0059B07B /* ZBarHelpController.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ZBarHelpController.h; path = include/ZBarSDK/ZBarHelpController.h; sourceTree = "<group>"; };
+		DCC9324E137B509B0040A82D /* EmbedReader */ = {isa = PBXFileReference; lastKnownFileType = folder; name = EmbedReader; path = examples/EmbedReader; sourceTree = "<group>"; };
+		DCC9324F137B509B0040A82D /* TabReader */ = {isa = PBXFileReference; lastKnownFileType = folder; name = TabReader; path = examples/TabReader; sourceTree = "<group>"; };
+		DCDC6E2F11ADCA8E00021380 /* ZBarReaderView.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = ZBarReaderView.m; sourceTree = "<group>"; usesTabs = 0; };
+		DCE9900B129719F100D2655C /* code93.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = code93.c; sourceTree = "<group>"; };
+		DCE9900C129719F100D2655C /* code93.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = code93.h; sourceTree = "<group>"; };
+		DCF5C9AB11EA3AD100E7DC21 /* databar.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = databar.c; sourceTree = "<group>"; };
+		DCF5C9AC11EA3AD100E7DC21 /* databar.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = databar.h; sourceTree = "<group>"; };
+/* End PBXFileReference section */
+
+/* Begin PBXFrameworksBuildPhase section */
+		DC299A931208B5D4006A023C /* Frameworks */ = {
+			isa = PBXFrameworksBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				DC299B841208FCAB006A023C /* Foundation.framework in Frameworks */,
+				DC299B061208FC11006A023C /* CoreGraphics.framework in Frameworks */,
+				DC299B311208FCA3006A023C /* UIKit.framework in Frameworks */,
+				DC299AA31208B61C006A023C /* QuartzCore.framework in Frameworks */,
+				DC299AA01208B61C006A023C /* AVFoundation.framework in Frameworks */,
+				DC299AA11208B61C006A023C /* CoreMedia.framework in Frameworks */,
+				DC299AA21208B61C006A023C /* CoreVideo.framework in Frameworks */,
+				DC299AA41208B61C006A023C /* libiconv.dylib in Frameworks */,
+				DC299A9D1208B5E8006A023C /* libzbar.a in Frameworks */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+/* End PBXFrameworksBuildPhase section */
+
+/* Begin PBXGroup section */
+		034768DFFF38A50411DB9C8B /* Products */ = {
+			isa = PBXGroup;
+			children = (
+				D2AAC07E0554694100DB518D /* libzbar.a */,
+				DC3CEF9D121633C500D7A786 /* readertest.app */,
+				DC48C55F121A1E7F0047193B /* ZBarSDK */,
+			);
+			name = Products;
+			sourceTree = "<group>";
+		};
+		0867D691FE84028FC02AAC07 /* zbar */ = {
+			isa = PBXGroup;
+			children = (
+				DC50467B12034D60009FF359 /* README */,
+				DC3CF141121721A100D7A786 /* ChangeLog */,
+				DC50467C12034D71009FF359 /* COPYING */,
+				DC50467D12034D71009FF359 /* LICENSE */,
+				DC48C5A7121B1F840047193B /* Documentation.html */,
+				DC299BED1208FE49006A023C /* src */,
+				DC1A49A111FF338B00BCDA30 /* Resources */,
+				DC67C11610A07A670033B702 /* include */,
+				DC3CF2071218356F00D7A786 /* Examples */,
+				DC48C5361219FE2F0047193B /* readertest */,
+				0867D69AFE84028FC02AAC07 /* Frameworks */,
+				034768DFFF38A50411DB9C8B /* Products */,
+			);
+			name = zbar;
+			sourceTree = "<group>";
+		};
+		0867D69AFE84028FC02AAC07 /* Frameworks */ = {
+			isa = PBXGroup;
+			children = (
+				AACBBE490F95108600F1A2B1 /* Foundation.framework */,
+				DC299B051208FC11006A023C /* CoreGraphics.framework */,
+				DC67C08210A079BE0033B702 /* UIKit.framework */,
+				DC1A49C111FF537000BCDA30 /* QuartzCore.framework */,
+				DC50453D1203396B009FF359 /* AVFoundation.framework */,
+				DC50453F1203396B009FF359 /* CoreMedia.framework */,
+				DC5045411203396B009FF359 /* CoreVideo.framework */,
+				DC5045431203396B009FF359 /* libiconv.dylib */,
+			);
+			name = Frameworks;
+			sourceTree = "<group>";
+		};
+		DC1A49A111FF338B00BCDA30 /* Resources */ = {
+			isa = PBXGroup;
+			children = (
+				DC3CF2A212197A7200D7A786 /* zbar-back.png */,
+				DC1A49A211FF33B300BCDA30 /* zbar-help.html */,
+				DC1A49A311FF33B300BCDA30 /* zbar-helpicons.png */,
+				DC1A49A411FF33B300BCDA30 /* zbar-samples.png */,
+			);
+			name = Resources;
+			sourceTree = "<group>";
+			usesTabs = 0;
+		};
+		DC299BE41208FE09006A023C /* ZBarSDK */ = {
+			isa = PBXGroup;
+			children = (
+				DC5D76C5136FA8F20069AEF5 /* ZBarCameraSimulator.h */,
+				DC3CEFA51216347100D7A786 /* ZBarCaptureReader.h */,
+				DCB3789A12A43C7E0059B07B /* ZBarHelpController.h */,
+				DC3CEFA61216347100D7A786 /* ZBarImage.h */,
+				DC3CEFA71216347100D7A786 /* ZBarImageScanner.h */,
+				DC3CEFA81216347100D7A786 /* ZBarReaderController.h */,
+				DC3CEFA91216347100D7A786 /* ZBarReaderView.h */,
+				DC3CEFAA1216347100D7A786 /* ZBarReaderViewController.h */,
+				DC3CEFAB1216347100D7A786 /* ZBarSDK.h */,
+				DC3CEFAC1216347100D7A786 /* ZBarSymbol.h */,
+				DC67C11710A07A810033B702 /* zbar.h */,
+				DC50463412034A1E009FF359 /* zbar */,
+			);
+			name = ZBarSDK;
+			sourceTree = "<group>";
+		};
+		DC299BED1208FE49006A023C /* src */ = {
+			isa = PBXGroup;
+			children = (
+				DC67C1C010A07B6B0033B702 /* ZBarSymbol.m */,
+				DC4920EC10A70475000E4D43 /* ZBarImage.m */,
+				DC4920ED10A70475000E4D43 /* ZBarImageScanner.m */,
+				DC3AAB4D11B71A040021C7B1 /* ZBarCVImage.m */,
+				DC26004B118631C200FA987B /* ZBarCaptureReader.m */,
+				DCDC6E2F11ADCA8E00021380 /* ZBarReaderView.m */,
+				DC3CE47611FA1622008FAF88 /* ZBarReaderViewImpl_Capture.m */,
+				DC3CE47711FA1622008FAF88 /* ZBarReaderViewImpl_Simulator.m */,
+				DC5D76C2136FA8C40069AEF5 /* ZBarCameraSimulator.m */,
+				DC67C1BE10A07B6B0033B702 /* ZBarHelpController.m */,
+				DC3EBB2C119DDB2100107EE9 /* ZBarReaderViewController.m */,
+				DC67C1BF10A07B6B0033B702 /* ZBarReaderController.m */,
+				DC67C11E10A07AD30033B702 /* zbar */,
+			);
+			name = src;
+			sourceTree = "<group>";
+		};
+		DC3CF2071218356F00D7A786 /* Examples */ = {
+			isa = PBXGroup;
+			children = (
+				DC3CF2081218358C00D7A786 /* ReaderSample */,
+				DC3CF2651218358C00D7A786 /* readertest */,
+				DCC9324E137B509B0040A82D /* EmbedReader */,
+				DCC9324F137B509B0040A82D /* TabReader */,
+			);
+			name = Examples;
+			sourceTree = "<group>";
+		};
+		DC48C5361219FE2F0047193B /* readertest */ = {
+			isa = PBXGroup;
+			children = (
+				DC8245EE1629DC140010B2E6 /* Default-568h@2x.png */,
+				DC48C5401219FE550047193B /* readertest.m */,
+			);
+			name = readertest;
+			sourceTree = "<group>";
+		};
+		DC50463412034A1E009FF359 /* zbar */ = {
+			isa = PBXGroup;
+			children = (
+				DC50463512034A4C009FF359 /* Decoder.h */,
+				DC50463612034A4C009FF359 /* Exception.h */,
+				DC50463712034A4C009FF359 /* Image.h */,
+				DC50463812034A4C009FF359 /* ImageScanner.h */,
+				DC50463912034A4C009FF359 /* Processor.h */,
+				DC50463A12034A4C009FF359 /* Scanner.h */,
+				DC50463B12034A4C009FF359 /* Symbol.h */,
+				DC50463C12034A4C009FF359 /* Video.h */,
+				DC50463D12034A4C009FF359 /* Window.h */,
+			);
+			name = zbar;
+			sourceTree = "<group>";
+		};
+		DC67C11610A07A670033B702 /* include */ = {
+			isa = PBXGroup;
+			children = (
+				DC299BEC1208FE40006A023C /* prefix.pch */,
+				DC299AF51208B7BD006A023C /* config.h */,
+				DC3AAB4C11B71A040021C7B1 /* ZBarCVImage.h */,
+				DC299BE41208FE09006A023C /* ZBarSDK */,
+			);
+			name = include;
+			sourceTree = "<group>";
+			usesTabs = 0;
+		};
+		DC67C11E10A07AD30033B702 /* zbar */ = {
+			isa = PBXGroup;
+			children = (
+				DC67C11F10A07AD30033B702 /* config.c */,
+				DC67C12110A07AD30033B702 /* debug.h */,
+				DC67C12210A07AD30033B702 /* decoder */,
+				DC67C13010A07AD30033B702 /* decoder.c */,
+				DC67C13110A07AD30033B702 /* decoder.h */,
+				DC67C13210A07AD30033B702 /* error.c */,
+				DC67C13310A07AD30033B702 /* error.h */,
+				DC67C13510A07AD30033B702 /* image.c */,
+				DC67C13610A07AD30033B702 /* image.h */,
+				DC67C13710A07AD30033B702 /* img_scanner.c */,
+				DC67C13810A07AD30033B702 /* img_scanner.h */,
+				DC67C14610A07AD30033B702 /* qrcode */,
+				DC67C15410A07AD30033B702 /* qrcode.h */,
+				DC67C15510A07AD30033B702 /* refcnt.c */,
+				DC67C15610A07AD30033B702 /* refcnt.h */,
+				DC67C15710A07AD30033B702 /* scanner.c */,
+				DC67C1CB10A07BEE0033B702 /* svg.h */,
+				DC67C15A10A07AD30033B702 /* symbol.c */,
+				DC67C15B10A07AD30033B702 /* symbol.h */,
+			);
+			name = zbar;
+			path = ../zbar;
+			sourceTree = SOURCE_ROOT;
+			usesTabs = 0;
+		};
+		DC67C12210A07AD30033B702 /* decoder */ = {
+			isa = PBXGroup;
+			children = (
+				DCF5C9AB11EA3AD100E7DC21 /* databar.c */,
+				DCF5C9AC11EA3AD100E7DC21 /* databar.h */,
+				DC67C12310A07AD30033B702 /* code128.c */,
+				DC67C12410A07AD30033B702 /* code128.h */,
+				DCE9900B129719F100D2655C /* code93.c */,
+				DCE9900C129719F100D2655C /* code93.h */,
+				DC67C12510A07AD30033B702 /* code39.c */,
+				DC67C12610A07AD30033B702 /* code39.h */,
+				DC67C12710A07AD30033B702 /* ean.c */,
+				DC67C12810A07AD30033B702 /* ean.h */,
+				DC290E261351496400A9B857 /* codabar.c */,
+				DC290E271351496400A9B857 /* codabar.h */,
+				DC67C12910A07AD30033B702 /* i25.c */,
+				DC67C12A10A07AD30033B702 /* i25.h */,
+				DC67C12E10A07AD30033B702 /* qr_finder.c */,
+				DC67C12F10A07AD30033B702 /* qr_finder.h */,
+			);
+			path = decoder;
+			sourceTree = "<group>";
+			usesTabs = 0;
+		};
+		DC67C14610A07AD30033B702 /* qrcode */ = {
+			isa = PBXGroup;
+			children = (
+				DC67C14710A07AD30033B702 /* bch15_5.c */,
+				DC67C14810A07AD30033B702 /* bch15_5.h */,
+				DC67C14910A07AD30033B702 /* binarize.c */,
+				DC67C14A10A07AD30033B702 /* binarize.h */,
+				DC67C14B10A07AD30033B702 /* isaac.c */,
+				DC67C14C10A07AD30033B702 /* isaac.h */,
+				DC67C14D10A07AD30033B702 /* qrdec.c */,
+				DC67C14E10A07AD30033B702 /* qrdec.h */,
+				DC67C14F10A07AD30033B702 /* qrdectxt.c */,
+				DC67C15010A07AD30033B702 /* rs.c */,
+				DC67C15110A07AD30033B702 /* rs.h */,
+				DC67C15210A07AD30033B702 /* util.c */,
+				DC67C15310A07AD30033B702 /* util.h */,
+			);
+			path = qrcode;
+			sourceTree = "<group>";
+			usesTabs = 0;
+		};
+/* End PBXGroup section */
+
+/* Begin PBXNativeTarget section */
+		D2AAC07D0554694100DB518D /* libzbar */ = {
+			isa = PBXNativeTarget;
+			buildConfigurationList = 1DEB921E08733DC00010E9CD /* Build configuration list for PBXNativeTarget "libzbar" */;
+			buildPhases = (
+				D2AAC07B0554694100DB518D /* Sources */,
+			);
+			buildRules = (
+			);
+			dependencies = (
+			);
+			name = libzbar;
+			productName = zbar;
+			productReference = D2AAC07E0554694100DB518D /* libzbar.a */;
+			productType = "com.apple.product-type.library.static";
+		};
+		DC299A941208B5D4006A023C /* readertest */ = {
+			isa = PBXNativeTarget;
+			buildConfigurationList = DC299A9A1208B5D5006A023C /* Build configuration list for PBXNativeTarget "readertest" */;
+			buildPhases = (
+				DC299A911208B5D4006A023C /* Resources */,
+				DC299A921208B5D4006A023C /* Sources */,
+				DC299A931208B5D4006A023C /* Frameworks */,
+			);
+			buildRules = (
+			);
+			dependencies = (
+				DC299A9F1208B5F1006A023C /* PBXTargetDependency */,
+			);
+			name = readertest;
+			productName = readertest;
+			productReference = DC3CEF9D121633C500D7A786 /* readertest.app */;
+			productType = "com.apple.product-type.application";
+		};
+/* End PBXNativeTarget section */
+
+/* Begin PBXProject section */
+		0867D690FE84028FC02AAC07 /* Project object */ = {
+			isa = PBXProject;
+			buildConfigurationList = 1DEB922208733DC00010E9CD /* Build configuration list for PBXProject "zbar" */;
+			compatibilityVersion = "Xcode 3.1";
+			developmentRegion = English;
+			hasScannedForEncodings = 1;
+			knownRegions = (
+				English,
+				Japanese,
+				French,
+				German,
+			);
+			mainGroup = 0867D691FE84028FC02AAC07 /* zbar */;
+			productRefGroup = 034768DFFF38A50411DB9C8B /* Products */;
+			projectDirPath = "";
+			projectRoot = "";
+			targets = (
+				D2AAC07D0554694100DB518D /* libzbar */,
+				DC3CEE821215C7EF00D7A786 /* ZBarSDK */,
+				DC1A4A4E11FF5D0500BCDA30 /* ZBarSDK.dmg */,
+				DC299A941208B5D4006A023C /* readertest */,
+			);
+		};
+/* End PBXProject section */
+
+/* Begin PBXResourcesBuildPhase section */
+		DC299A911208B5D4006A023C /* Resources */ = {
+			isa = PBXResourcesBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				DC299AA51208B63C006A023C /* zbar-help.html in Resources */,
+				DC299AA61208B63C006A023C /* zbar-helpicons.png in Resources */,
+				DC299AA71208B63C006A023C /* zbar-samples.png in Resources */,
+				DC48C5341219FDDE0047193B /* zbar-back.png in Resources */,
+				DC8245EF1629DC340010B2E6 /* Default-568h@2x.png in Resources */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+/* End PBXResourcesBuildPhase section */
+
+/* Begin PBXShellScriptBuildPhase section */
+		DC1A4A4D11FF5D0500BCDA30 /* Make Disk Image */ = {
+			isa = PBXShellScriptBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+			);
+			inputPaths = (
+			);
+			name = "Make Disk Image";
+			outputPaths = (
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+			shellPath = /bin/sh;
+			shellScript = "exec $SOURCE_ROOT/bin/CreateDMG.sh ZBarSDK";
+		};
+		DC3CEE891215C88000D7A786 /* Build Universal Library */ = {
+			isa = PBXShellScriptBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+			);
+			inputPaths = (
+				"$(BUILD_DIR)/$(CONFIGURATION)-iphoneos/libzbar.a",
+				"$(BUILD_DIR)/$(CONFIGURATION)-iphonesimulator/libzbar.a",
+			);
+			name = "Build Universal Library";
+			outputPaths = (
+				"$(TARGET_BUILD_DIR)/libzbar.a",
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+			shellPath = /bin/sh;
+			shellScript = "exec $SOURCE_ROOT/bin/BuildUniversal.sh libzbar";
+		};
+		DC48C585121AC7C20047193B /* Build Documentation */ = {
+			isa = PBXShellScriptBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+			);
+			inputPaths = (
+			);
+			name = "Build Documentation";
+			outputPaths = (
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+			shellPath = /bin/sh;
+			shellScript = "PATH=${PATH}:/usr/local/bin:/sw/bin\nsphinx-build -W -d $TEMP_DIR $SOURCE_ROOT/doc $TARGET_BUILD_DIR/Documentation";
+		};
+/* End PBXShellScriptBuildPhase section */
+
+/* Begin PBXSourcesBuildPhase section */
+		D2AAC07B0554694100DB518D /* Sources */ = {
+			isa = PBXSourcesBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				DC67C17110A07AD30033B702 /* config.c in Sources */,
+				DC67C17410A07AD30033B702 /* code128.c in Sources */,
+				DC67C17610A07AD30033B702 /* code39.c in Sources */,
+				DC67C17810A07AD30033B702 /* ean.c in Sources */,
+				DC67C17A10A07AD30033B702 /* i25.c in Sources */,
+				DC67C17F10A07AD30033B702 /* qr_finder.c in Sources */,
+				DC67C18110A07AD30033B702 /* decoder.c in Sources */,
+				DC67C18310A07AD30033B702 /* error.c in Sources */,
+				DC67C18610A07AD30033B702 /* image.c in Sources */,
+				DC67C18810A07AD30033B702 /* img_scanner.c in Sources */,
+				DC67C19510A07AD30033B702 /* bch15_5.c in Sources */,
+				DC67C19710A07AD30033B702 /* binarize.c in Sources */,
+				DC67C19910A07AD30033B702 /* isaac.c in Sources */,
+				DC67C19B10A07AD30033B702 /* qrdec.c in Sources */,
+				DC67C19D10A07AD30033B702 /* qrdectxt.c in Sources */,
+				DC67C19E10A07AD30033B702 /* rs.c in Sources */,
+				DC67C1A010A07AD30033B702 /* util.c in Sources */,
+				DC67C1A310A07AD30033B702 /* refcnt.c in Sources */,
+				DC67C1A510A07AD30033B702 /* scanner.c in Sources */,
+				DC67C1A810A07AD30033B702 /* symbol.c in Sources */,
+				DC67C1C210A07B6B0033B702 /* ZBarHelpController.m in Sources */,
+				DC67C1C310A07B6B0033B702 /* ZBarReaderController.m in Sources */,
+				DC67C1C410A07B6B0033B702 /* ZBarSymbol.m in Sources */,
+				DC4920EE10A70475000E4D43 /* ZBarImage.m in Sources */,
+				DC4920EF10A70475000E4D43 /* ZBarImageScanner.m in Sources */,
+				DC26004C118631C200FA987B /* ZBarCaptureReader.m in Sources */,
+				DC3EBB2D119DDB2100107EE9 /* ZBarReaderViewController.m in Sources */,
+				DCDC6E3011ADCA8E00021380 /* ZBarReaderView.m in Sources */,
+				DC3AAB4F11B71A040021C7B1 /* ZBarCVImage.m in Sources */,
+				DCF5C9AD11EA3AD100E7DC21 /* databar.c in Sources */,
+				DC3CE47811FA1622008FAF88 /* ZBarReaderViewImpl_Capture.m in Sources */,
+				DC3CE47911FA1622008FAF88 /* ZBarReaderViewImpl_Simulator.m in Sources */,
+				DCE9900D129719F100D2655C /* code93.c in Sources */,
+				DC5D76C3136FA8C40069AEF5 /* ZBarCameraSimulator.m in Sources */,
+				DC290E281351496400A9B857 /* codabar.c in Sources */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		DC299A921208B5D4006A023C /* Sources */ = {
+			isa = PBXSourcesBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				DC48C5411219FE550047193B /* readertest.m in Sources */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+/* End PBXSourcesBuildPhase section */
+
+/* Begin PBXTargetDependency section */
+		DC299A9F1208B5F1006A023C /* PBXTargetDependency */ = {
+			isa = PBXTargetDependency;
+			target = D2AAC07D0554694100DB518D /* libzbar */;
+			targetProxy = DC299A9E1208B5F1006A023C /* PBXContainerItemProxy */;
+		};
+		DC3CEE871215C85400D7A786 /* PBXTargetDependency */ = {
+			isa = PBXTargetDependency;
+			target = D2AAC07D0554694100DB518D /* libzbar */;
+			targetProxy = DC3CEE861215C85400D7A786 /* PBXContainerItemProxy */;
+		};
+		DC3CF01F1216366200D7A786 /* PBXTargetDependency */ = {
+			isa = PBXTargetDependency;
+			target = DC3CEE821215C7EF00D7A786 /* ZBarSDK */;
+			targetProxy = DC3CF01E1216366200D7A786 /* PBXContainerItemProxy */;
+		};
+/* End PBXTargetDependency section */
+
+/* Begin XCBuildConfiguration section */
+		1DEB921F08733DC00010E9CD /* Debug */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				ALWAYS_SEARCH_USER_PATHS = NO;
+				COPY_PHASE_STRIP = NO;
+				GCC_DYNAMIC_NO_PIC = NO;
+				GCC_ENABLE_FIX_AND_CONTINUE = YES;
+				GCC_MODEL_TUNING = G5;
+				GCC_OPTIMIZATION_LEVEL = 0;
+				GCC_PRECOMPILE_PREFIX_HEADER = YES;
+				GCC_PREFIX_HEADER = include/prefix.pch;
+				HEADER_SEARCH_PATHS = (
+					include,
+					../include,
+					../zbar,
+				);
+				OTHER_LDFLAGS = "";
+				PRODUCT_NAME = zbar;
+				SKIP_INSTALL = YES;
+			};
+			name = Debug;
+		};
+		1DEB922008733DC00010E9CD /* Release */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				ALWAYS_SEARCH_USER_PATHS = NO;
+				GCC_MODEL_TUNING = G5;
+				GCC_PRECOMPILE_PREFIX_HEADER = YES;
+				GCC_PREFIX_HEADER = include/prefix.pch;
+				HEADER_SEARCH_PATHS = (
+					include,
+					../include,
+					../zbar,
+				);
+				OTHER_LDFLAGS = "";
+				PRODUCT_NAME = zbar;
+				SKIP_INSTALL = YES;
+			};
+			name = Release;
+		};
+		1DEB922308733DC00010E9CD /* Debug */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				ARCHS = "$(ARCHS_STANDARD_32_BIT)";
+				CODE_SIGN_IDENTITY = "iPhone Developer";
+				EXCLUDED_SOURCE_FILE_NAMES = "";
+				"EXCLUDED_SOURCE_FILE_NAMES[sdk=iphoneos*][arch=*]" = ZBarReaderViewImpl_Simulator.m;
+				"EXCLUDED_SOURCE_FILE_NAMES[sdk=iphonesimulator*][arch=*]" = (
+					ZBarReaderViewImpl_Capture.m,
+					ZBarCaptureReader.m,
+				);
+				GCC_C_LANGUAGE_STANDARD = c99;
+				GCC_OPTIMIZATION_LEVEL = 0;
+				GCC_PREPROCESSOR_DEFINITIONS = "DEBUG_OBJC=1";
+				GCC_WARN_ABOUT_RETURN_TYPE = YES;
+				GCC_WARN_UNUSED_VARIABLE = YES;
+				IPHONEOS_DEPLOYMENT_TARGET = 3.1;
+				OTHER_LDFLAGS = "-all_load";
+				PREBINDING = NO;
+				PROVISIONING_PROFILE = "";
+				RUN_CLANG_STATIC_ANALYZER = NO;
+				SDKROOT = iphoneos;
+				USE_HEADERMAP = NO;
+			};
+			name = Debug;
+		};
+		1DEB922408733DC00010E9CD /* Release */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				ARCHS = "$(ARCHS_STANDARD_32_BIT)";
+				CODE_SIGN_IDENTITY = "iPhone Developer";
+				EXCLUDED_SOURCE_FILE_NAMES = "";
+				"EXCLUDED_SOURCE_FILE_NAMES[sdk=iphoneos*][arch=*]" = ZBarReaderViewImpl_Simulator.m;
+				"EXCLUDED_SOURCE_FILE_NAMES[sdk=iphonesimulator*][arch=*]" = (
+					ZBarReaderViewImpl_Capture.m,
+					ZBarCaptureReader.m,
+				);
+				GCC_C_LANGUAGE_STANDARD = c99;
+				GCC_PREPROCESSOR_DEFINITIONS = "NDEBUG=1";
+				GCC_WARN_ABOUT_RETURN_TYPE = YES;
+				GCC_WARN_UNUSED_VARIABLE = YES;
+				IPHONEOS_DEPLOYMENT_TARGET = 3.1;
+				OTHER_LDFLAGS = "-all_load";
+				PREBINDING = NO;
+				PROVISIONING_PROFILE = "";
+				RUN_CLANG_STATIC_ANALYZER = NO;
+				SDKROOT = iphoneos;
+				USE_HEADERMAP = NO;
+			};
+			name = Release;
+		};
+		DC1A4A4F11FF5D0500BCDA30 /* Debug */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				COPY_PHASE_STRIP = NO;
+				PRODUCT_NAME = ZBarSDK.dmg;
+				TARGET_BUILD_DIR = "$(TARGET_BUILD_DIR)/$(PRODUCT_NAME)";
+			};
+			name = Debug;
+		};
+		DC1A4A5011FF5D0500BCDA30 /* Release */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				COPY_PHASE_STRIP = NO;
+				PRODUCT_NAME = ZBarSDK.dmg;
+				TARGET_BUILD_DIR = "$(TARGET_BUILD_DIR)/$(PRODUCT_NAME)";
+			};
+			name = Release;
+		};
+		DC299A981208B5D5006A023C /* Debug */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				ALWAYS_SEARCH_USER_PATHS = NO;
+				COPY_PHASE_STRIP = NO;
+				GCC_DYNAMIC_NO_PIC = NO;
+				GCC_OPTIMIZATION_LEVEL = 0;
+				GCC_PRECOMPILE_PREFIX_HEADER = YES;
+				GCC_PREFIX_HEADER = examples/readertest/prefix.pch;
+				HEADER_SEARCH_PATHS = (
+					include/ZBarSDK,
+					../include,
+				);
+				INFOPLIST_FILE = examples/readertest/readertest.plist;
+				INSTALL_PATH = "$(HOME)/Applications";
+				IPHONEOS_DEPLOYMENT_TARGET = 4.0;
+				PREBINDING = NO;
+				PRODUCT_NAME = readertest;
+				TARGETED_DEVICE_FAMILY = "1,2";
+			};
+			name = Debug;
+		};
+		DC299A991208B5D5006A023C /* Release */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				ALWAYS_SEARCH_USER_PATHS = NO;
+				COPY_PHASE_STRIP = YES;
+				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
+				GCC_ENABLE_FIX_AND_CONTINUE = NO;
+				GCC_PRECOMPILE_PREFIX_HEADER = YES;
+				GCC_PREFIX_HEADER = examples/readertest/prefix.pch;
+				HEADER_SEARCH_PATHS = (
+					include/ZBarSDK,
+					../include,
+				);
+				INFOPLIST_FILE = examples/readertest/readertest.plist;
+				INSTALL_PATH = "$(HOME)/Applications";
+				IPHONEOS_DEPLOYMENT_TARGET = 4.0;
+				PREBINDING = NO;
+				PRODUCT_NAME = readertest;
+				TARGETED_DEVICE_FAMILY = "1,2";
+				ZERO_LINK = NO;
+			};
+			name = Release;
+		};
+		DC3748D71357BC69004E69D6 /* Distribution */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				ARCHS = "$(ARCHS_STANDARD_32_BIT)";
+				CODE_SIGN_IDENTITY = "iPhone Distribution";
+				EXCLUDED_SOURCE_FILE_NAMES = "";
+				"EXCLUDED_SOURCE_FILE_NAMES[sdk=iphoneos*][arch=*]" = ZBarReaderViewImpl_Simulator.m;
+				"EXCLUDED_SOURCE_FILE_NAMES[sdk=iphonesimulator*][arch=*]" = (
+					ZBarReaderViewImpl_Capture.m,
+					ZBarCaptureReader.m,
+				);
+				GCC_C_LANGUAGE_STANDARD = c99;
+				GCC_PREPROCESSOR_DEFINITIONS = "NDEBUG=1";
+				GCC_WARN_ABOUT_RETURN_TYPE = YES;
+				GCC_WARN_UNUSED_VARIABLE = YES;
+				IPHONEOS_DEPLOYMENT_TARGET = 3.1;
+				OTHER_LDFLAGS = "-all_load";
+				PREBINDING = NO;
+				PROVISIONING_PROFILE = "";
+				RUN_CLANG_STATIC_ANALYZER = NO;
+				SDKROOT = iphoneos;
+				USE_HEADERMAP = NO;
+			};
+			name = Distribution;
+		};
+		DC3748D81357BC69004E69D6 /* Distribution */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				ALWAYS_SEARCH_USER_PATHS = NO;
+				GCC_MODEL_TUNING = G5;
+				GCC_PRECOMPILE_PREFIX_HEADER = YES;
+				GCC_PREFIX_HEADER = include/prefix.pch;
+				HEADER_SEARCH_PATHS = (
+					include,
+					../include,
+					../zbar,
+				);
+				OTHER_LDFLAGS = "";
+				PRODUCT_NAME = zbar;
+				SKIP_INSTALL = YES;
+			};
+			name = Distribution;
+		};
+		DC3748D91357BC69004E69D6 /* Distribution */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				COPY_PHASE_STRIP = YES;
+				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
+				GCC_ENABLE_FIX_AND_CONTINUE = NO;
+				PRODUCT_NAME = ZBarSDK;
+				TARGET_BUILD_DIR = "$(TARGET_BUILD_DIR)/$(PRODUCT_NAME)";
+				ZERO_LINK = NO;
+			};
+			name = Distribution;
+		};
+		DC3748DA1357BC69004E69D6 /* Distribution */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				COPY_PHASE_STRIP = NO;
+				PRODUCT_NAME = ZBarSDK.dmg;
+				TARGET_BUILD_DIR = "$(TARGET_BUILD_DIR)/$(PRODUCT_NAME)";
+			};
+			name = Distribution;
+		};
+		DC3748DB1357BC69004E69D6 /* Distribution */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				ALWAYS_SEARCH_USER_PATHS = NO;
+				COPY_PHASE_STRIP = YES;
+				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
+				GCC_ENABLE_FIX_AND_CONTINUE = NO;
+				GCC_PRECOMPILE_PREFIX_HEADER = YES;
+				GCC_PREFIX_HEADER = examples/readertest/prefix.pch;
+				HEADER_SEARCH_PATHS = (
+					include/ZBarSDK,
+					../include,
+				);
+				INFOPLIST_FILE = examples/readertest/readertest.plist;
+				INSTALL_PATH = "$(HOME)/Applications";
+				IPHONEOS_DEPLOYMENT_TARGET = 4.0;
+				PREBINDING = NO;
+				PRODUCT_NAME = readertest;
+				TARGETED_DEVICE_FAMILY = "1,2";
+				ZERO_LINK = NO;
+			};
+			name = Distribution;
+		};
+		DC3CEE831215C7EF00D7A786 /* Debug */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				COPY_PHASE_STRIP = NO;
+				GCC_DYNAMIC_NO_PIC = NO;
+				GCC_OPTIMIZATION_LEVEL = 0;
+				PRODUCT_NAME = ZBarSDK;
+				TARGET_BUILD_DIR = "$(TARGET_BUILD_DIR)/$(PRODUCT_NAME)";
+			};
+			name = Debug;
+		};
+		DC3CEE841215C7EF00D7A786 /* Release */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				COPY_PHASE_STRIP = YES;
+				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
+				GCC_ENABLE_FIX_AND_CONTINUE = NO;
+				PRODUCT_NAME = ZBarSDK;
+				TARGET_BUILD_DIR = "$(TARGET_BUILD_DIR)/$(PRODUCT_NAME)";
+				ZERO_LINK = NO;
+			};
+			name = Release;
+		};
+/* End XCBuildConfiguration section */
+
+/* Begin XCConfigurationList section */
+		1DEB921E08733DC00010E9CD /* Build configuration list for PBXNativeTarget "libzbar" */ = {
+			isa = XCConfigurationList;
+			buildConfigurations = (
+				1DEB921F08733DC00010E9CD /* Debug */,
+				1DEB922008733DC00010E9CD /* Release */,
+				DC3748D81357BC69004E69D6 /* Distribution */,
+			);
+			defaultConfigurationIsVisible = 0;
+			defaultConfigurationName = Distribution;
+		};
+		1DEB922208733DC00010E9CD /* Build configuration list for PBXProject "zbar" */ = {
+			isa = XCConfigurationList;
+			buildConfigurations = (
+				1DEB922308733DC00010E9CD /* Debug */,
+				1DEB922408733DC00010E9CD /* Release */,
+				DC3748D71357BC69004E69D6 /* Distribution */,
+			);
+			defaultConfigurationIsVisible = 0;
+			defaultConfigurationName = Distribution;
+		};
+		DC1A4A5311FF5D3D00BCDA30 /* Build configuration list for PBXAggregateTarget "ZBarSDK.dmg" */ = {
+			isa = XCConfigurationList;
+			buildConfigurations = (
+				DC1A4A4F11FF5D0500BCDA30 /* Debug */,
+				DC1A4A5011FF5D0500BCDA30 /* Release */,
+				DC3748DA1357BC69004E69D6 /* Distribution */,
+			);
+			defaultConfigurationIsVisible = 0;
+			defaultConfigurationName = Distribution;
+		};
+		DC299A9A1208B5D5006A023C /* Build configuration list for PBXNativeTarget "readertest" */ = {
+			isa = XCConfigurationList;
+			buildConfigurations = (
+				DC299A981208B5D5006A023C /* Debug */,
+				DC299A991208B5D5006A023C /* Release */,
+				DC3748DB1357BC69004E69D6 /* Distribution */,
+			);
+			defaultConfigurationIsVisible = 0;
+			defaultConfigurationName = Distribution;
+		};
+		DC3CEE851215C83500D7A786 /* Build configuration list for PBXAggregateTarget "ZBarSDK" */ = {
+			isa = XCConfigurationList;
+			buildConfigurations = (
+				DC3CEE831215C7EF00D7A786 /* Debug */,
+				DC3CEE841215C7EF00D7A786 /* Release */,
+				DC3748D91357BC69004E69D6 /* Distribution */,
+			);
+			defaultConfigurationIsVisible = 0;
+			defaultConfigurationName = Distribution;
+		};
+/* End XCConfigurationList section */
+	};
+	rootObject = 0867D690FE84028FC02AAC07 /* Project object */;
+}
diff -r 563557a923d0 iphone/zbar.xcodeproj/xcshareddata/xcschemes/ZBarSDK.dmg.xcscheme
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/zbar.xcodeproj/xcshareddata/xcschemes/ZBarSDK.dmg.xcscheme	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,62 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<Scheme
+   version = "1.8">
+   <BuildAction
+      parallelizeBuildables = "YES"
+      buildImplicitDependencies = "YES">
+      <BuildActionEntries>
+         <BuildActionEntry
+            buildForTesting = "YES"
+            buildForRunning = "YES"
+            buildForProfiling = "YES"
+            buildForArchiving = "YES"
+            buildForAnalyzing = "YES">
+            <BuildableReference
+               BuildableIdentifier = "primary"
+               BlueprintIdentifier = "DC1A4A4E11FF5D0500BCDA30"
+               BuildableName = "ZBarSDK.dmg"
+               BlueprintName = "ZBarSDK.dmg"
+               ReferencedContainer = "container:zbar.xcodeproj">
+            </BuildableReference>
+         </BuildActionEntry>
+      </BuildActionEntries>
+   </BuildAction>
+   <TestAction
+      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.GDB"
+      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.GDB"
+      shouldUseLaunchSchemeArgsEnv = "YES"
+      buildConfiguration = "Release">
+      <Testables>
+      </Testables>
+   </TestAction>
+   <LaunchAction
+      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.GDB"
+      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.GDB"
+      displayScaleIsEnabled = "NO"
+      displayScale = "1.00"
+      launchStyle = "0"
+      useCustomWorkingDirectory = "NO"
+      buildConfiguration = "Release"
+      ignoresPersistentStateOnLaunch = "NO"
+      debugDocumentVersioning = "YES"
+      allowLocationSimulation = "YES">
+      <AdditionalOptions>
+      </AdditionalOptions>
+   </LaunchAction>
+   <ProfileAction
+      displayScaleIsEnabled = "NO"
+      displayScale = "1.00"
+      shouldUseLaunchSchemeArgsEnv = "YES"
+      savedToolIdentifier = ""
+      useCustomWorkingDirectory = "NO"
+      buildConfiguration = "Release"
+      debugDocumentVersioning = "YES">
+   </ProfileAction>
+   <AnalyzeAction
+      buildConfiguration = "Release">
+   </AnalyzeAction>
+   <ArchiveAction
+      buildConfiguration = "Release"
+      revealArchiveInOrganizer = "YES">
+   </ArchiveAction>
+</Scheme>
diff -r 563557a923d0 iphone/zbar.xcodeproj/xcshareddata/xcschemes/ZBarSDK.xcscheme
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/zbar.xcodeproj/xcshareddata/xcschemes/ZBarSDK.xcscheme	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,62 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<Scheme
+   version = "1.8">
+   <BuildAction
+      parallelizeBuildables = "YES"
+      buildImplicitDependencies = "YES">
+      <BuildActionEntries>
+         <BuildActionEntry
+            buildForTesting = "YES"
+            buildForRunning = "YES"
+            buildForProfiling = "YES"
+            buildForArchiving = "YES"
+            buildForAnalyzing = "YES">
+            <BuildableReference
+               BuildableIdentifier = "primary"
+               BlueprintIdentifier = "DC3CEE821215C7EF00D7A786"
+               BuildableName = "ZBarSDK"
+               BlueprintName = "ZBarSDK"
+               ReferencedContainer = "container:zbar.xcodeproj">
+            </BuildableReference>
+         </BuildActionEntry>
+      </BuildActionEntries>
+   </BuildAction>
+   <TestAction
+      selectedDebuggerIdentifier = ""
+      selectedLauncherIdentifier = "Xcode.IDEFoundation.Launcher.PosixSpawn"
+      shouldUseLaunchSchemeArgsEnv = "YES"
+      buildConfiguration = "Release">
+      <Testables>
+      </Testables>
+   </TestAction>
+   <LaunchAction
+      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.GDB"
+      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.GDB"
+      displayScaleIsEnabled = "NO"
+      displayScale = "1.00"
+      launchStyle = "0"
+      useCustomWorkingDirectory = "NO"
+      buildConfiguration = "Debug"
+      ignoresPersistentStateOnLaunch = "NO"
+      debugDocumentVersioning = "YES"
+      allowLocationSimulation = "YES">
+      <AdditionalOptions>
+      </AdditionalOptions>
+   </LaunchAction>
+   <ProfileAction
+      displayScaleIsEnabled = "NO"
+      displayScale = "1.00"
+      shouldUseLaunchSchemeArgsEnv = "YES"
+      savedToolIdentifier = ""
+      useCustomWorkingDirectory = "NO"
+      buildConfiguration = "Release"
+      debugDocumentVersioning = "YES">
+   </ProfileAction>
+   <AnalyzeAction
+      buildConfiguration = "Release">
+   </AnalyzeAction>
+   <ArchiveAction
+      buildConfiguration = "Release"
+      revealArchiveInOrganizer = "YES">
+   </ArchiveAction>
+</Scheme>
diff -r 563557a923d0 iphone/zbar.xcodeproj/xcshareddata/xcschemes/libzbar.xcscheme
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/zbar.xcodeproj/xcshareddata/xcschemes/libzbar.xcscheme	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,58 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<Scheme
+   version = "1.3">
+   <BuildAction
+      parallelizeBuildables = "YES"
+      buildImplicitDependencies = "YES">
+      <BuildActionEntries>
+         <BuildActionEntry
+            buildForTesting = "YES"
+            buildForRunning = "YES"
+            buildForProfiling = "YES"
+            buildForArchiving = "YES"
+            buildForAnalyzing = "YES">
+            <BuildableReference
+               BuildableIdentifier = "primary"
+               BlueprintIdentifier = "D2AAC07D0554694100DB518D"
+               BuildableName = "libzbar.a"
+               BlueprintName = "libzbar"
+               ReferencedContainer = "container:zbar.xcodeproj">
+            </BuildableReference>
+         </BuildActionEntry>
+      </BuildActionEntries>
+   </BuildAction>
+   <TestAction
+      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.GDB"
+      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.GDB"
+      shouldUseLaunchSchemeArgsEnv = "YES"
+      buildConfiguration = "Debug">
+      <Testables>
+      </Testables>
+   </TestAction>
+   <LaunchAction
+      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.GDB"
+      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.GDB"
+      displayScaleIsEnabled = "NO"
+      displayScale = "1.00"
+      launchStyle = "0"
+      useCustomWorkingDirectory = "NO"
+      buildConfiguration = "Debug">
+      <AdditionalOptions>
+      </AdditionalOptions>
+   </LaunchAction>
+   <ProfileAction
+      displayScaleIsEnabled = "NO"
+      displayScale = "1.00"
+      shouldUseLaunchSchemeArgsEnv = "YES"
+      savedToolIdentifier = ""
+      useCustomWorkingDirectory = "NO"
+      buildConfiguration = "Release">
+   </ProfileAction>
+   <AnalyzeAction
+      buildConfiguration = "Debug">
+   </AnalyzeAction>
+   <ArchiveAction
+      buildConfiguration = "Release"
+      revealArchiveInOrganizer = "YES">
+   </ArchiveAction>
+</Scheme>
diff -r 563557a923d0 iphone/zbar.xcodeproj/xcshareddata/xcschemes/readertest.xcscheme
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/iphone/zbar.xcodeproj/xcshareddata/xcschemes/readertest.xcscheme	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,83 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<Scheme
+   version = "1.3">
+   <BuildAction
+      parallelizeBuildables = "YES"
+      buildImplicitDependencies = "YES">
+      <BuildActionEntries>
+         <BuildActionEntry
+            buildForTesting = "YES"
+            buildForRunning = "YES"
+            buildForProfiling = "YES"
+            buildForArchiving = "YES"
+            buildForAnalyzing = "YES">
+            <BuildableReference
+               BuildableIdentifier = "primary"
+               BlueprintIdentifier = "DC299A941208B5D4006A023C"
+               BuildableName = "readertest.app"
+               BlueprintName = "readertest"
+               ReferencedContainer = "container:zbar.xcodeproj">
+            </BuildableReference>
+         </BuildActionEntry>
+      </BuildActionEntries>
+   </BuildAction>
+   <TestAction
+      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.GDB"
+      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.GDB"
+      shouldUseLaunchSchemeArgsEnv = "YES"
+      buildConfiguration = "Debug">
+      <Testables>
+      </Testables>
+   </TestAction>
+   <LaunchAction
+      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.GDB"
+      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.GDB"
+      displayScaleIsEnabled = "NO"
+      displayScale = "1.00"
+      launchStyle = "0"
+      useCustomWorkingDirectory = "NO"
+      buildConfiguration = "Debug">
+      <BuildableProductRunnable>
+         <BuildableReference
+            BuildableIdentifier = "primary"
+            BlueprintIdentifier = "DC299A941208B5D4006A023C"
+            BuildableName = "readertest.app"
+            BlueprintName = "readertest"
+            ReferencedContainer = "container:zbar.xcodeproj">
+         </BuildableReference>
+      </BuildableProductRunnable>
+      <EnvironmentVariables>
+         <EnvironmentVariable
+            key = "NSZombieEnabled"
+            value = "YES"
+            isEnabled = "YES">
+         </EnvironmentVariable>
+      </EnvironmentVariables>
+      <AdditionalOptions>
+      </AdditionalOptions>
+   </LaunchAction>
+   <ProfileAction
+      displayScaleIsEnabled = "NO"
+      displayScale = "1.00"
+      shouldUseLaunchSchemeArgsEnv = "YES"
+      savedToolIdentifier = ""
+      useCustomWorkingDirectory = "NO"
+      buildConfiguration = "Release">
+      <BuildableProductRunnable>
+         <BuildableReference
+            BuildableIdentifier = "primary"
+            BlueprintIdentifier = "DC299A941208B5D4006A023C"
+            BuildableName = "readertest.app"
+            BlueprintName = "readertest"
+            ReferencedContainer = "container:zbar.xcodeproj">
+         </BuildableReference>
+      </BuildableProductRunnable>
+   </ProfileAction>
+   <AnalyzeAction
+      buildConfiguration = "Debug">
+   </AnalyzeAction>
+   <ArchiveAction
+      buildConfiguration = "Distribution"
+      revealArchiveInOrganizer = "YES">
+   </ArchiveAction>
+</Scheme>
diff -r 563557a923d0 java/Makefile.am
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/java/Makefile.am	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,39 @@
+javadir = $(pkgdatadir)/lib
+
+PKG = net/sourceforge/zbar
+java_DATA = zbar.jar
+
+java_LTLIBRARIES = libzbarjni.la
+libzbarjni_la_CPPFLAGS = $(JAVA_CFLAGS) $(AM_CPPFLAGS)
+libzbarjni_la_LIBADD = $(abs_top_builddir)/zbar/libzbar.la
+
+libzbarjni_la_SOURCES = zbarjni.c zbarjni.h
+BUILT_SOURCES = zbarjni.h
+MAINTAINERCLEANFILES = zbarjni.h
+
+zbar_jar_SRCS = \
+    $(PKG)/Config.java $(PKG)/Modifier.java $(PKG)/Orientation.java \
+    $(PKG)/Symbol.java $(PKG)/SymbolIterator.java $(PKG)/SymbolSet.java \
+    $(PKG)/Image.java $(PKG)/ImageScanner.java
+
+zbar_jar_CLASSES = $(zbar_jar_SRCS:.java=.class)
+
+test_SRCS = test/TestImage.java test/TestImageScanner.java \
+    test/TestScanImage.java
+test_CLASSES = TestImage TestImageScanner TestScanImage
+
+CLEANFILES = zbar.jar $(zbar_jar_CLASSES) $(test_CLASSES:=.class)
+
+zbarjni.h: $(zbar_jar_SRCS)
+	$(MAKE) $(AM_MAKEFLAGS) zbar.jar
+	classes=`echo $(zbar_jar_CLASSES:.class=) | tr / .` ; \
+	    $(JAVAH) -o $@ $$classes
+
+zbar.jar: $(zbar_jar_SRCS)
+	cd $(abs_srcdir); $(JAVAC) -d $(abs_builddir) $(zbar_jar_SRCS)
+	$(JAR) cf $@ $(zbar_jar_CLASSES) || $(RM) $@
+
+check-local:
+	echo "making check in java"
+	cd $(abs_srcdir); $(JAVAC) -classpath $(abs_builddir)/zbar.jar:.:$(CLASSPATH) -d $(abs_builddir) $(test_SRCS)
+	$(top_builddir)/libtool -dlopen $(top_builddir)/zbar/libzbar.la -dlopen libzbarjni.la --mode=execute $(JAVA) -Xcheck:jni -classpath zbar.jar:.:$(CLASSPATH) org.junit.runner.JUnitCore $(test_CLASSES)
diff -r 563557a923d0 java/net/sourceforge/zbar/Config.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/java/net/sourceforge/zbar/Config.java	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,56 @@
+/*------------------------------------------------------------------------
+ *  Config
+ *
+ *  Copyright 2010 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *
+ *  This file is part of the ZBar Bar Code Reader.
+ *
+ *  The ZBar Bar Code Reader is free software; you can redistribute it
+ *  and/or modify it under the terms of the GNU Lesser Public License as
+ *  published by the Free Software Foundation; either version 2.1 of
+ *  the License, or (at your option) any later version.
+ *
+ *  The ZBar Bar Code Reader is distributed in the hope that it will be
+ *  useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+ *  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser Public License
+ *  along with the ZBar Bar Code Reader; if not, write to the Free
+ *  Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ *  Boston, MA  02110-1301  USA
+ *
+ *  http://sourceforge.net/projects/zbar
+ *------------------------------------------------------------------------*/
+
+package net.sourceforge.zbar;
+
+/** Decoder configuration options.
+ */
+public class Config
+{
+    /** Enable symbology/feature. */
+    public static final int ENABLE = 0;
+    /** Enable check digit when optional. */
+    public static final int ADD_CHECK = 1;
+    /** Return check digit when present. */
+    public static final int EMIT_CHECK = 2;
+    /** Enable full ASCII character set. */
+    public static final int ASCII = 3;
+
+    /** Minimum data length for valid decode. */
+    public static final int MIN_LEN = 0x20;
+    /** Maximum data length for valid decode. */
+    public static final int MAX_LEN = 0x21;
+
+    /** Required video consistency frames. */
+    public static final int UNCERTAINTY = 0x40;
+
+    /** Enable scanner to collect position data. */
+    public static final int POSITION = 0x80;
+
+    /** Image scanner vertical scan density. */
+    public static final int X_DENSITY = 0x100;
+    /** Image scanner horizontal scan density. */
+    public static final int Y_DENSITY = 0x101;
+}
diff -r 563557a923d0 java/net/sourceforge/zbar/Image.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/java/net/sourceforge/zbar/Image.java	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,163 @@
+/*------------------------------------------------------------------------
+ *  Image
+ *
+ *  Copyright 2007-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *
+ *  This file is part of the ZBar Bar Code Reader.
+ *
+ *  The ZBar Bar Code Reader is free software; you can redistribute it
+ *  and/or modify it under the terms of the GNU Lesser Public License as
+ *  published by the Free Software Foundation; either version 2.1 of
+ *  the License, or (at your option) any later version.
+ *
+ *  The ZBar Bar Code Reader is distributed in the hope that it will be
+ *  useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+ *  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser Public License
+ *  along with the ZBar Bar Code Reader; if not, write to the Free
+ *  Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ *  Boston, MA  02110-1301  USA
+ *
+ *  http://sourceforge.net/projects/zbar
+ *------------------------------------------------------------------------*/
+
+package net.sourceforge.zbar;
+
+/** stores image data samples along with associated format and size
+ * metadata.
+ */
+public class Image
+{
+    /** C pointer to a zbar_symbol_t. */
+    private long peer;
+    private Object data;
+
+    static
+    {
+        System.loadLibrary("zbarjni");
+        init();
+    }
+    private static native void init();
+
+    public Image ()
+    {
+        peer = create();
+    }
+
+    public Image (int width, int height)
+    {
+        this();
+        setSize(width, height);
+    }
+
+    public Image (int width, int height, String format)
+    {
+        this();
+        setSize(width, height);
+        setFormat(format);
+    }
+
+    public Image (String format)
+    {
+        this();
+        setFormat(format);
+    }
+
+    Image (long peer)
+    {
+        this.peer = peer;
+    }
+
+    /** Create an associated peer instance. */
+    private native long create();
+
+    protected void finalize ()
+    {
+        destroy();
+    }
+
+    /** Clean up native data associated with an instance. */
+    public synchronized void destroy ()
+    {
+        if(peer != 0) {
+            destroy(peer);
+            peer = 0;
+        }
+    }
+
+    /** Destroy the associated peer instance.  */
+    private native void destroy(long peer);
+
+    /** Image format conversion.
+     * @returns a @em new image with the sample data from the original
+     * image converted to the requested format fourcc.  the original
+     * image is unaffected.
+     */
+    public Image convert (String format)
+    {
+        long newpeer = convert(peer, format);
+        if(newpeer == 0)
+            return(null);
+        return(new Image(newpeer));
+    }
+
+    private native long convert(long peer, String format);
+
+    /** Retrieve the image format fourcc. */
+    public native String getFormat();
+
+    /** Specify the fourcc image format code for image sample data. */
+    public native void setFormat(String format);
+
+    /** Retrieve a "sequence" (page/frame) number associated with this
+     * image.
+     */
+    public native int getSequence();
+
+    /** Associate a "sequence" (page/frame) number with this image. */
+    public native void setSequence(int seq);
+
+    /** Retrieve the width of the image. */
+    public native int getWidth();
+
+    /** Retrieve the height of the image. */
+    public native int getHeight();
+
+    /** Retrieve the size of the image. */
+    public native int[] getSize();
+
+    /** Specify the pixel size of the image. */
+    public native void setSize(int width, int height);
+
+    /** Specify the pixel size of the image. */
+    public native void setSize(int[] size);
+
+    /** Retrieve the crop region of the image. */
+    public native int[] getCrop();
+
+    /** Specify the crop region of the image. */
+    public native void setCrop(int x, int y, int width, int height);
+
+    /** Specify the crop region of the image. */
+    public native void setCrop(int[] crop);
+
+    /** Retrieve the image sample data. */
+    public native byte[] getData();
+
+    /** Specify image sample data. */
+    public native void setData(byte[] data);
+
+    /** Specify image sample data. */
+    public native void setData(int[] data);
+
+    /** Retrieve the decoded results associated with this image. */
+    public SymbolSet getSymbols ()
+    {
+        return(new SymbolSet(getSymbols(peer)));
+    }
+
+    private native long getSymbols(long peer);
+
+}
diff -r 563557a923d0 java/net/sourceforge/zbar/ImageScanner.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/java/net/sourceforge/zbar/ImageScanner.java	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,98 @@
+/*------------------------------------------------------------------------
+ *  ImageScanner
+ *
+ *  Copyright 2007-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *
+ *  This file is part of the ZBar Bar Code Reader.
+ *
+ *  The ZBar Bar Code Reader is free software; you can redistribute it
+ *  and/or modify it under the terms of the GNU Lesser Public License as
+ *  published by the Free Software Foundation; either version 2.1 of
+ *  the License, or (at your option) any later version.
+ *
+ *  The ZBar Bar Code Reader is distributed in the hope that it will be
+ *  useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+ *  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser Public License
+ *  along with the ZBar Bar Code Reader; if not, write to the Free
+ *  Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ *  Boston, MA  02110-1301  USA
+ *
+ *  http://sourceforge.net/projects/zbar
+ *------------------------------------------------------------------------*/
+
+package net.sourceforge.zbar;
+
+/** Read barcodes from 2-D images.
+ */
+public class ImageScanner
+{
+    /** C pointer to a zbar_image_scanner_t. */
+    private long peer;
+
+    static
+    {
+        System.loadLibrary("zbarjni");
+        init();
+    }
+    private static native void init();
+
+    public ImageScanner ()
+    {
+        peer = create();
+    }
+
+    /** Create an associated peer instance. */
+    private native long create();
+
+    protected void finalize ()
+    {
+        destroy();
+    }
+
+    /** Clean up native data associated with an instance. */
+    public synchronized void destroy ()
+    {
+        if(peer != 0) {
+            destroy(peer);
+            peer = 0;
+        }
+    }
+
+    /** Destroy the associated peer instance.  */
+    private native void destroy(long peer);
+
+    /** Set config for indicated symbology (0 for all) to specified value.
+     */
+    public native void setConfig(int symbology, int config, int value)
+        throws IllegalArgumentException;
+
+    /** Parse configuration string and apply to image scanner. */
+    public native void parseConfig(String config);
+
+    /** Enable or disable the inter-image result cache (default disabled).
+     * Mostly useful for scanning video frames, the cache filters duplicate
+     * results from consecutive images, while adding some consistency
+     * checking and hysteresis to the results.  Invoking this method also
+     * clears the cache.
+     */
+    public native void enableCache(boolean enable);
+
+    /** Retrieve decode results for last scanned image.
+     * @returns the SymbolSet result container
+     */
+    public SymbolSet getResults ()
+    {
+        return(new SymbolSet(getResults(peer)));
+    }
+
+    private native long getResults(long peer);
+
+    /** Scan for symbols in provided Image.
+     * The image format must currently be "Y800" or "GRAY".
+     * @returns the number of symbols successfully decoded from the image.
+     */
+    public native int scanImage(Image image);
+}
diff -r 563557a923d0 java/net/sourceforge/zbar/Modifier.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/java/net/sourceforge/zbar/Modifier.java	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,42 @@
+/*------------------------------------------------------------------------
+ *  Modifier
+ *
+ *  Copyright 2010 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *
+ *  This file is part of the ZBar Bar Code Reader.
+ *
+ *  The ZBar Bar Code Reader is free software; you can redistribute it
+ *  and/or modify it under the terms of the GNU Lesser Public License as
+ *  published by the Free Software Foundation; either version 2.1 of
+ *  the License, or (at your option) any later version.
+ *
+ *  The ZBar Bar Code Reader is distributed in the hope that it will be
+ *  useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+ *  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser Public License
+ *  along with the ZBar Bar Code Reader; if not, write to the Free
+ *  Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ *  Boston, MA  02110-1301  USA
+ *
+ *  http://sourceforge.net/projects/zbar
+ *------------------------------------------------------------------------*/
+
+package net.sourceforge.zbar;
+
+/** Decoder symbology modifiers.
+ */
+public class Modifier
+{
+    /** barcode tagged as GS1 (EAN.UCC) reserved
+     * (eg, FNC1 before first data character).
+     * data may be parsed as a sequence of GS1 AIs
+     */
+    public static final int GS1 = 0;
+
+    /** barcode tagged as AIM reserved
+     * (eg, FNC1 after first character or digit pair)
+     */
+    public static final int AIM = 1;
+}
diff -r 563557a923d0 java/net/sourceforge/zbar/Orientation.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/java/net/sourceforge/zbar/Orientation.java	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,42 @@
+/*------------------------------------------------------------------------
+ *  Orientation
+ *
+ *  Copyright 2010 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *
+ *  This file is part of the ZBar Bar Code Reader.
+ *
+ *  The ZBar Bar Code Reader is free software; you can redistribute it
+ *  and/or modify it under the terms of the GNU Lesser Public License as
+ *  published by the Free Software Foundation; either version 2.1 of
+ *  the License, or (at your option) any later version.
+ *
+ *  The ZBar Bar Code Reader is distributed in the hope that it will be
+ *  useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+ *  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser Public License
+ *  along with the ZBar Bar Code Reader; if not, write to the Free
+ *  Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ *  Boston, MA  02110-1301  USA
+ *
+ *  http://sourceforge.net/projects/zbar
+ *------------------------------------------------------------------------*/
+
+package net.sourceforge.zbar;
+
+/** Decoded symbol coarse orientation.
+ */
+public class Orientation
+{
+    /** Unable to determine orientation. */
+    public static final int UNKNOWN = -1;
+    /** Upright, read left to right. */
+    public static final int UP = 0;
+    /** sideways, read top to bottom */
+    public static final int RIGHT = 1;
+    /** upside-down, read right to left */
+    public static final int DOWN = 2;
+    /** sideways, read bottom to top */
+    public static final int LEFT = 3;
+}
diff -r 563557a923d0 java/net/sourceforge/zbar/Symbol.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/java/net/sourceforge/zbar/Symbol.java	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,199 @@
+/*------------------------------------------------------------------------
+ *  Symbol
+ *
+ *  Copyright 2007-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *
+ *  This file is part of the ZBar Bar Code Reader.
+ *
+ *  The ZBar Bar Code Reader is free software; you can redistribute it
+ *  and/or modify it under the terms of the GNU Lesser Public License as
+ *  published by the Free Software Foundation; either version 2.1 of
+ *  the License, or (at your option) any later version.
+ *
+ *  The ZBar Bar Code Reader is distributed in the hope that it will be
+ *  useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+ *  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser Public License
+ *  along with the ZBar Bar Code Reader; if not, write to the Free
+ *  Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ *  Boston, MA  02110-1301  USA
+ *
+ *  http://sourceforge.net/projects/zbar
+ *------------------------------------------------------------------------*/
+
+package net.sourceforge.zbar;
+
+/** Immutable container for decoded result symbols associated with an image
+ * or a composite symbol.
+ */
+public class Symbol
+{
+    /** No symbol decoded. */
+    public static final int NONE = 0;
+    /** Symbol detected but not decoded. */
+    public static final int PARTIAL = 1;
+
+    /** EAN-8. */
+    public static final int EAN8 = 8;
+    /** UPC-E. */
+    public static final int UPCE = 9;
+    /** ISBN-10 (from EAN-13). */
+    public static final int ISBN10 = 10;
+    /** UPC-A. */
+    public static final int UPCA = 12;
+    /** EAN-13. */
+    public static final int EAN13 = 13;
+    /** ISBN-13 (from EAN-13). */
+    public static final int ISBN13 = 14;
+    /** Interleaved 2 of 5. */
+    public static final int I25 = 25;
+    /** DataBar (RSS-14). */
+    public static final int DATABAR = 34;
+    /** DataBar Expanded. */
+    public static final int DATABAR_EXP = 35;
+    /** Codabar. */
+    public static final int CODABAR = 38;
+    /** Code 39. */
+    public static final int CODE39 = 39;
+    /** PDF417. */
+    public static final int PDF417 = 57;
+    /** QR Code. */
+    public static final int QRCODE = 64;
+    /** Code 93. */
+    public static final int CODE93 = 93;
+    /** Code 128. */
+    public static final int CODE128 = 128;
+
+    /** C pointer to a zbar_symbol_t. */
+    private long peer;
+
+    /** Cached attributes. */
+    private int type;
+
+    static
+    {
+        System.loadLibrary("zbarjni");
+        init();
+    }
+    private static native void init();
+
+    /** Symbols are only created by other package methods. */
+    Symbol (long peer)
+    {
+        this.peer = peer;
+    }
+
+    protected void finalize ()
+    {
+        destroy();
+    }
+
+    /** Clean up native data associated with an instance. */
+    public synchronized void destroy ()
+    {
+        if(peer != 0) {
+            destroy(peer);
+            peer = 0;
+        }
+    }
+
+    /** Release the associated peer instance.  */
+    private native void destroy(long peer);
+
+    /** Retrieve type of decoded symbol. */
+    public int getType ()
+    {
+        if(type == 0)
+            type = getType(peer);
+        return(type);
+    }
+
+    private native int getType(long peer);
+
+    /** Retrieve symbology boolean configs settings used during decode. */
+    public native int getConfigMask();
+
+    /** Retrieve symbology characteristics detected during decode. */
+    public native int getModifierMask();
+
+    /** Retrieve data decoded from symbol as a String. */
+    public native String getData();
+
+    /** Retrieve raw data bytes decoded from symbol. */
+    public native byte[] getDataBytes();
+
+    /** Retrieve a symbol confidence metric.  Quality is an unscaled,
+     * relative quantity: larger values are better than smaller
+     * values, where "large" and "small" are application dependent.
+     */
+    public native int getQuality();
+
+    /** Retrieve current cache count.  When the cache is enabled for
+     * the image_scanner this provides inter-frame reliability and
+     * redundancy information for video streams.
+     * @returns < 0 if symbol is still uncertain
+     * @returns 0 if symbol is newly verified
+     * @returns > 0 for duplicate symbols
+     */
+    public native int getCount();
+
+    /** Retrieve an approximate, axis-aligned bounding box for the
+     * symbol.
+     */
+    public int[] getBounds ()
+    {
+        int n = getLocationSize(peer);
+        if(n <= 0)
+            return(null);
+
+        int[] bounds = new int[4];
+        int xmin = Integer.MAX_VALUE;
+        int xmax = Integer.MIN_VALUE;
+        int ymin = Integer.MAX_VALUE;
+        int ymax = Integer.MIN_VALUE;
+
+        for(int i = 0; i < n; i++) {
+            int x = getLocationX(peer, i);
+            if(xmin > x) xmin = x;
+            if(xmax < x) xmax = x;
+
+            int y = getLocationY(peer, i);
+            if(ymin > y) ymin = y;
+            if(ymax < y) ymax = y;
+        }
+        bounds[0] = xmin;
+        bounds[1] = ymin;
+        bounds[2] = xmax - xmin;
+        bounds[3] = ymax - ymin;
+        return(bounds);
+    }
+
+    private native int getLocationSize(long peer);
+    private native int getLocationX(long peer, int idx);
+    private native int getLocationY(long peer, int idx);
+
+    public int[] getLocationPoint (int idx)
+    {
+        int[] p = new int[2];
+        p[0] = getLocationX(peer, idx);
+        p[1] = getLocationY(peer, idx);
+        return(p);
+    }
+
+    /** Retrieve general axis-aligned, orientation of decoded
+     * symbol.
+     */
+    public native int getOrientation();
+
+    /** Retrieve components of a composite result. */
+    public SymbolSet getComponents ()
+    {
+        return(new SymbolSet(getComponents(peer)));
+    }
+
+    private native long getComponents(long peer);
+
+    native long next();
+}
diff -r 563557a923d0 java/net/sourceforge/zbar/SymbolIterator.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/java/net/sourceforge/zbar/SymbolIterator.java	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,70 @@
+/*------------------------------------------------------------------------
+ *  SymbolIterator
+ *
+ *  Copyright 2007-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *
+ *  This file is part of the ZBar Bar Code Reader.
+ *
+ *  The ZBar Bar Code Reader is free software; you can redistribute it
+ *  and/or modify it under the terms of the GNU Lesser Public License as
+ *  published by the Free Software Foundation; either version 2.1 of
+ *  the License, or (at your option) any later version.
+ *
+ *  The ZBar Bar Code Reader is distributed in the hope that it will be
+ *  useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+ *  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser Public License
+ *  along with the ZBar Bar Code Reader; if not, write to the Free
+ *  Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ *  Boston, MA  02110-1301  USA
+ *
+ *  http://sourceforge.net/projects/zbar
+ *------------------------------------------------------------------------*/
+
+package net.sourceforge.zbar;
+
+/** Iterator over a SymbolSet.
+ */
+public class SymbolIterator
+    implements java.util.Iterator<Symbol>
+{
+    /** Next symbol to be returned by the iterator. */
+    private Symbol current;
+
+    /** SymbolIterators are only created by internal interface methods. */
+    SymbolIterator (Symbol first)
+    {
+        current = first;
+    }
+
+    /** Returns true if the iteration has more elements. */
+    public boolean hasNext ()
+    {
+        return(current != null);
+    }
+
+    /** Retrieves the next element in the iteration. */
+    public Symbol next ()
+    {
+        if(current == null)
+            throw(new java.util.NoSuchElementException
+                  ("access past end of SymbolIterator"));
+
+        Symbol result = current;
+        long sym = current.next();
+        if(sym != 0)
+            current = new Symbol(sym);
+        else
+            current = null;
+        return(result);
+    }
+
+    /** Raises UnsupportedOperationException. */
+    public void remove ()
+    {
+        throw(new UnsupportedOperationException
+              ("SymbolIterator is immutable"));
+    }
+}
diff -r 563557a923d0 java/net/sourceforge/zbar/SymbolSet.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/java/net/sourceforge/zbar/SymbolSet.java	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,82 @@
+/*------------------------------------------------------------------------
+ *  SymbolSet
+ *
+ *  Copyright 2007-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *
+ *  This file is part of the ZBar Bar Code Reader.
+ *
+ *  The ZBar Bar Code Reader is free software; you can redistribute it
+ *  and/or modify it under the terms of the GNU Lesser Public License as
+ *  published by the Free Software Foundation; either version 2.1 of
+ *  the License, or (at your option) any later version.
+ *
+ *  The ZBar Bar Code Reader is distributed in the hope that it will be
+ *  useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+ *  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser Public License
+ *  along with the ZBar Bar Code Reader; if not, write to the Free
+ *  Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ *  Boston, MA  02110-1301  USA
+ *
+ *  http://sourceforge.net/projects/zbar
+ *------------------------------------------------------------------------*/
+
+package net.sourceforge.zbar;
+
+/** Immutable container for decoded result symbols associated with an image
+ * or a composite symbol.
+ */
+public class SymbolSet
+    extends java.util.AbstractCollection<Symbol>
+{
+    /** C pointer to a zbar_symbol_set_t. */
+    private long peer;
+
+    static
+    {
+        System.loadLibrary("zbarjni");
+        init();
+    }
+    private static native void init();
+
+    /** SymbolSets are only created by other package methods. */
+    SymbolSet (long peer)
+    {
+        this.peer = peer;
+    }
+
+    protected void finalize ()
+    {
+        destroy();
+    }
+
+    /** Clean up native data associated with an instance. */
+    public synchronized void destroy ()
+    {
+        if(peer != 0) {
+            destroy(peer);
+            peer = 0;
+        }
+    }
+
+    /** Release the associated peer instance.  */
+    private native void destroy(long peer);
+
+    /** Retrieve an iterator over the Symbol elements in this collection. */
+    public java.util.Iterator<Symbol> iterator ()
+    {
+        long sym = firstSymbol(peer);
+        if(sym == 0)
+            return(new SymbolIterator(null));
+
+        return(new SymbolIterator(new Symbol(sym)));
+    }
+
+    /** Retrieve the number of elements in the collection. */
+    public native int size();
+
+    /** Retrieve C pointer to first symbol in the set. */
+    private native long firstSymbol(long peer);
+}
diff -r 563557a923d0 java/test/TestImage.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/java/test/TestImage.java	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,175 @@
+
+import org.junit.Test;
+import org.junit.Before;
+import org.junit.After;
+import static org.junit.Assert.*;
+
+import net.sourceforge.zbar.Image;
+
+public class TestImage
+{
+    protected Image image;
+
+    @Before public void setUp ()
+    {
+        image = new Image();
+    }
+
+    @After public void tearDown ()
+    {
+        image.destroy();
+        image = null;
+    }
+
+
+    @Test public void creation ()
+    {
+        Image img0 = new Image(123, 456);
+        Image img1 = new Image("BGR3");
+        Image img2 = new Image(987, 654, "UYVY");
+
+        assertEquals(123, img0.getWidth());
+        assertEquals(456, img0.getHeight());
+        assertEquals(null, img0.getFormat());
+
+        assertEquals(0, img1.getWidth());
+        assertEquals(0, img1.getHeight());
+        assertEquals("BGR3", img1.getFormat());
+
+        assertEquals(987, img2.getWidth());
+        assertEquals(654, img2.getHeight());
+        assertEquals("UYVY", img2.getFormat());
+    }
+
+    @Test public void sequence ()
+    {
+        assertEquals(0, image.getSequence());
+        image.setSequence(42);
+        assertEquals(42, image.getSequence());
+    }
+
+    @Test public void size ()
+    {
+        assertEquals(0, image.getWidth());
+        assertEquals(0, image.getHeight());
+
+        image.setSize(640, 480);
+        int[] size0 = { 640, 480 };
+        assertArrayEquals(size0, image.getSize());
+
+        int[] size1 = { 320, 240 };
+        image.setSize(size1);
+        assertEquals(320, image.getWidth());
+        assertEquals(240, image.getHeight());
+    }
+
+    @Test public void crop ()
+    {
+        int[] zeros = { 0, 0, 0, 0 };
+        assertArrayEquals(zeros, image.getCrop());
+
+        image.setSize(123, 456);
+        int[] crop0 = { 0, 0, 123, 456 };
+        assertArrayEquals(crop0, image.getCrop());
+
+        image.setCrop(1, 2, 34, 56);
+        int[] crop1 = { 1, 2, 34, 56 };
+        assertArrayEquals(crop1, image.getCrop());
+
+        image.setCrop(-20, -20, 200, 500);
+        assertArrayEquals(crop0, image.getCrop());
+
+        int[] crop2 = { 7, 8, 90, 12};
+        image.setCrop(crop2);
+        assertArrayEquals(crop2, image.getCrop());
+
+        image.setSize(654, 321);
+        int[] crop3 = { 0, 0, 654, 321 };
+        assertArrayEquals(crop3, image.getCrop());
+
+        int[] crop4 = { -10, -10, 700, 400 };
+        image.setCrop(crop4);
+        assertArrayEquals(crop3, image.getCrop());
+    }
+
+    @Test public void format ()
+    {
+        assertNull(image.getFormat());
+        image.setFormat("Y800");
+        assertEquals("Y800", image.getFormat());
+        boolean gotException = false;
+        try {
+            image.setFormat("[]");
+        }
+        catch(IllegalArgumentException e) {
+            // expected
+            gotException = true;
+        }
+        assertTrue("Expected exception", gotException);
+        assertEquals("Y800", image.getFormat());
+    }
+
+    @Test(expected=IllegalArgumentException.class)
+        public void setFormatInvalid0 ()
+    {
+        image.setFormat(null);
+    }
+
+    @Test(expected=IllegalArgumentException.class)
+        public void setFormatInvalid1 ()
+    {
+        image.setFormat("");
+    }
+
+    @Test(expected=IllegalArgumentException.class)
+        public void setFormatInvalid2 ()
+    {
+        image.setFormat("YOMAMA");
+    }
+
+    @Test(expected=IllegalArgumentException.class)
+        public void setFormatInvalid3 ()
+    {
+        image.setFormat("foo");
+    }
+
+    @Test public void data ()
+    {
+        assertNull(image.getData());
+
+        int[] ints = new int[24];
+        image.setData(ints);
+        assertSame(ints, image.getData());
+
+        byte[] bytes = new byte[280];
+        image.setData(bytes);
+        assertSame(bytes, image.getData());
+
+        image.setData((byte[])null);
+        assertNull(image.getData());
+    }
+
+    @Test public void convert ()
+    {
+        image.setSize(4, 4);
+        image.setFormat("RGB4");
+        int[] rgb4 = new int[16];
+        byte[] exp = new byte[16];
+        for(int i = 0; i < 16; i++) {
+            int c = i * 15;
+            rgb4[i] = c | (c << 8) | (c << 16) | (c << 24);
+            exp[i] = (byte)c;
+        }
+        image.setData(rgb4);
+
+        Image gray = image.convert("Y800");
+        assertEquals(4, gray.getWidth());
+        assertEquals(4, gray.getHeight());
+        assertEquals("Y800", gray.getFormat());
+
+        byte[] y800 = gray.getData();
+        assertEquals(16, y800.length);
+
+        assertArrayEquals(exp, y800);
+    }
+}
diff -r 563557a923d0 java/test/TestImageScanner.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/java/test/TestImageScanner.java	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,53 @@
+
+import org.junit.Test;
+import org.junit.Before;
+import org.junit.After;
+import org.junit.Assert.*;
+
+import net.sourceforge.zbar.ImageScanner;
+import net.sourceforge.zbar.Config;
+
+public class TestImageScanner
+{
+    protected ImageScanner scanner;
+
+    @Before public void setUp ()
+    {
+        scanner = new ImageScanner();
+    }
+
+    @After public void tearDown ()
+    {
+        scanner.destroy();
+        scanner = null;
+    }
+
+
+    @Test public void creation ()
+    {
+        // create/destroy
+    }
+
+    @Test public void callSetConfig ()
+    {
+        scanner.setConfig(0, Config.X_DENSITY, 2);
+        scanner.setConfig(0, Config.Y_DENSITY, 4);
+    }
+
+    @Test public void callParseConfig ()
+    {
+        scanner.parseConfig("disable");
+    }
+
+    @Test(expected=IllegalArgumentException.class)
+        public void callParseConfigInvalid ()
+    {
+        scanner.parseConfig("yomama");
+    }
+
+    @Test public void callEnableCache ()
+    {
+        scanner.enableCache(true);
+        scanner.enableCache(false);
+    }
+}
diff -r 563557a923d0 java/test/TestScanImage.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/java/test/TestScanImage.java	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,183 @@
+
+import org.junit.Test;
+import org.junit.Before;
+import org.junit.After;
+import static org.junit.Assert.*;
+
+import net.sourceforge.zbar.*;
+
+import java.text.CharacterIterator;
+import java.text.StringCharacterIterator;
+import java.util.Iterator;
+
+public class TestScanImage
+{
+    protected ImageScanner scanner;
+    protected Image image;
+
+    @Before public void setUp ()
+    {
+        scanner = new ImageScanner();
+        image = new Image();
+    }
+
+    @After public void tearDown ()
+    {
+        image = null;
+        scanner = null;
+        System.gc();
+    }
+
+    public static final String encoded_widths =
+        "9 111 212241113121211311141132 11111 311213121312121332111132 111 9";
+
+    protected void generateY800 ()
+    {
+        int width = 114, height = 85;
+        image.setSize(width, height);
+        image.setFormat("Y800");
+        int datalen = width * height;
+        byte[] data = new byte[datalen];
+
+        int y = 0;
+        int p = 0;
+        for(; y < 10 && y < height; y++)
+            for(int x = 0; x < width; x++)
+                data[p++] = -1;
+
+        for(; y < height - 10; y++) {
+            int x = 0;
+            byte color = -1;
+            CharacterIterator it = new StringCharacterIterator(encoded_widths);
+            for(char c = it.first();
+                c != CharacterIterator.DONE;
+                c = it.next())
+            {
+                if(c == ' ')
+                    continue;
+                for(int dx = (int)c - 0x30; dx > 0; dx--) {
+                    data[p++] = color;
+                    x++;
+                }
+                color = (byte)~color;
+            }
+            for(; x < width; x++)
+                data[p++] = (byte)~color;
+        }
+
+        for(; y < height; y++)
+            for(int x = 0; x < width; x++)
+                data[p++] = -1;
+        assert(p == datalen);
+
+        image.setData(data);
+    }
+
+    protected void checkResults (SymbolSet syms)
+    {
+        assertNotNull(syms);
+        assert(syms.size() == 1);
+        Iterator<Symbol> it = syms.iterator();
+        assertTrue(it.hasNext());
+        Symbol sym = it.next();
+        assertNotNull(sym);
+        assertFalse(it.hasNext());
+
+        assertEquals(Symbol.EAN13, sym.getType());
+        assertEquals(sym.EAN13, sym.getType()); // cached
+
+        assertTrue(sym.getQuality() > 1);
+        assertEquals(0, sym.getCount());
+
+        SymbolSet comps = sym.getComponents();
+        assertNotNull(comps);
+        assertEquals(0, comps.size());
+        it = comps.iterator();
+        assertNotNull(it);
+        assertFalse(it.hasNext());
+
+        String data = sym.getData();
+        assertEquals("6268964977804", data);
+
+        byte[] bytes = sym.getDataBytes();
+        byte[] exp = { '6','2','6','8','9','6','4','9','7','7','8','0','4' };
+        assertArrayEquals(exp, bytes);
+
+        int[] r = sym.getBounds();
+        assertTrue(r[0] > 6);
+        assertTrue(r[1] > 6);
+        assertTrue(r[2] < 102);
+        assertTrue(r[3] < 73);
+
+        assertEquals(Orientation.UP, sym.getOrientation());
+    }
+
+    @Test public void generated ()
+    {
+        generateY800();
+        int n = scanner.scanImage(image);
+        assertEquals(1, n);
+
+        checkResults(image.getSymbols());
+        checkResults(scanner.getResults());
+    }
+
+    @Test public void config ()
+    {
+        generateY800();
+        scanner.setConfig(Symbol.EAN13, Config.ENABLE, 0);
+        int n = scanner.scanImage(image);
+        assertEquals(0, n);
+    }
+
+    @Test public void cache ()
+    {
+        generateY800();
+        scanner.enableCache(true);
+
+        int n = 0;
+        for(int i = 0; i < 10; i++) {
+            n = scanner.scanImage(image);
+            if(n > 0) {
+                assertTrue(i > 1);
+                break;
+            }
+        }
+
+        assertEquals(1, n);
+        checkResults(scanner.getResults());
+    }
+
+    @Test public void orientation()
+    {
+        generateY800();
+
+        // flip the image
+        int width = image.getWidth();
+        int height = image.getHeight();
+        byte[] data = image.getData();
+        int p = 0;
+        for(int y = 0; y < height; y++) {
+            for(int x0 = 0; x0 < width / 2; x0++) {
+                int x1 = width - x0 - 1;
+                assert(x0 < x1);
+                byte b = data[p + x0];
+                data[p + x0] = data[p + x1];
+                data[p + x1] = b;
+            }
+            p += width;
+        }
+        image.setData(data);
+
+        int n = scanner.scanImage(image);
+        assertEquals(1, n);
+
+        SymbolSet syms = scanner.getResults();
+        assert(syms.size() == 1);
+        for(Symbol sym : syms) {
+            assertEquals(Symbol.EAN13, sym.getType());
+            assertEquals("6268964977804", sym.getData());
+            assertEquals(Orientation.DOWN, sym.getOrientation());
+        }
+    }
+}
diff -r 563557a923d0 java/zbarjni.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/java/zbarjni.c	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,701 @@
+/*------------------------------------------------------------------------
+ *  Copyright 2010 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *
+ *  This file is part of the ZBar Bar Code Reader.
+ *
+ *  The ZBar Bar Code Reader is free software; you can redistribute it
+ *  and/or modify it under the terms of the GNU Lesser Public License as
+ *  published by the Free Software Foundation; either version 2.1 of
+ *  the License, or (at your option) any later version.
+ *
+ *  The ZBar Bar Code Reader is distributed in the hope that it will be
+ *  useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+ *  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser Public License
+ *  along with the ZBar Bar Code Reader; if not, write to the Free
+ *  Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ *  Boston, MA  02110-1301  USA
+ *
+ *  http://sourceforge.net/projects/zbar
+ *------------------------------------------------------------------------*/
+#include <inttypes.h>
+#include <assert.h>
+#include <zbar.h>
+#include <jni.h>
+
+static jfieldID SymbolSet_peer;
+static jfieldID Symbol_peer;
+static jfieldID Image_peer, Image_data;
+static jfieldID ImageScanner_peer;
+
+static struct {
+    int SymbolSet_create, SymbolSet_destroy;
+    int Symbol_create, Symbol_destroy;
+    int Image_create, Image_destroy;
+    int ImageScanner_create, ImageScanner_destroy;
+} stats;
+
+
+#define PEER_CAST(l) \
+    ((void*)(uintptr_t)(l))
+
+#define GET_PEER(c, o) \
+    PEER_CAST((*env)->GetLongField(env, (o), c ## _peer))
+
+
+static inline void
+throw_exc(JNIEnv *env,
+          const char *name,
+          const char *msg)
+{
+    jclass cls = (*env)->FindClass(env, name);
+    if(cls)
+        (*env)->ThrowNew(env, cls, msg);
+    (*env)->DeleteLocalRef(env, cls);
+}
+
+static inline uint32_t
+format_to_fourcc(JNIEnv *env,
+                 jstring format)
+{
+    if(!format)
+        goto invalid;
+
+    int n = (*env)->GetStringLength(env, format);
+    if(0 >= n || n > 4)
+        goto invalid;
+
+    char fmtstr[8];
+    (*env)->GetStringUTFRegion(env, format, 0, n, fmtstr);
+
+    uint32_t fourcc = 0;
+    int i;
+    for(i = 0; i < n; i++) {
+        if(fmtstr[i] < ' ' || 'Z' < fmtstr[i] ||
+           ('9' < fmtstr[i] && fmtstr[i] < 'A') ||
+           (' ' < fmtstr[i] && fmtstr[i] < '0'))
+            goto invalid;
+        fourcc |= ((uint32_t)fmtstr[i]) << (8 * i);
+    }
+    return(fourcc);
+
+invalid:
+    throw_exc(env, "java/lang/IllegalArgumentException",
+              "invalid format fourcc");
+    return(0);
+}
+
+static JavaVM *jvm = NULL;
+
+JNIEXPORT jint JNICALL
+JNI_OnLoad (JavaVM *_jvm,
+            void *reserved)
+{
+    jvm = _jvm;
+    return(JNI_VERSION_1_2);
+}
+
+JNIEXPORT void JNICALL
+JNI_OnUnload (JavaVM *_jvm,
+              void *reserved)
+{
+    assert(stats.SymbolSet_create == stats.SymbolSet_destroy);
+    assert(stats.Symbol_create == stats.Symbol_destroy);
+    assert(stats.Image_create == stats.Image_destroy);
+    assert(stats.ImageScanner_create == stats.ImageScanner_destroy);
+}
+
+
+JNIEXPORT void JNICALL
+Java_net_sourceforge_zbar_SymbolSet_init (JNIEnv *env,
+                                          jclass cls)
+{
+    SymbolSet_peer = (*env)->GetFieldID(env, cls, "peer", "J");
+}
+
+JNIEXPORT void JNICALL
+Java_net_sourceforge_zbar_SymbolSet_destroy (JNIEnv *env,
+                                             jobject obj,
+                                             jlong peer)
+{
+    zbar_symbol_set_ref(PEER_CAST(peer), -1);
+    stats.SymbolSet_destroy++;
+}
+
+JNIEXPORT jint JNICALL
+Java_net_sourceforge_zbar_SymbolSet_size (JNIEnv *env,
+                                          jobject obj)
+{
+    zbar_symbol_set_t *zsyms = GET_PEER(SymbolSet, obj);
+    if(!zsyms)
+        return(0);
+    return(zbar_symbol_set_get_size(zsyms));
+}
+
+JNIEXPORT jlong JNICALL
+Java_net_sourceforge_zbar_SymbolSet_firstSymbol (JNIEnv *env,
+                                                 jobject obj,
+                                                 jlong peer)
+{
+    if(!peer)
+        return(0);
+    const zbar_symbol_t *zsym = zbar_symbol_set_first_symbol(PEER_CAST(peer));
+    if(zsym) {
+        zbar_symbol_ref(zsym, 1);
+        stats.Symbol_create++;
+    }
+    return((intptr_t)zsym);
+}
+
+
+
+JNIEXPORT void JNICALL
+Java_net_sourceforge_zbar_Symbol_init (JNIEnv *env,
+                                       jclass cls)
+{
+    Symbol_peer = (*env)->GetFieldID(env, cls, "peer", "J");
+}
+
+JNIEXPORT void JNICALL
+Java_net_sourceforge_zbar_Symbol_destroy (JNIEnv *env,
+                                          jobject obj,
+                                          jlong peer)
+{
+    zbar_symbol_ref(PEER_CAST(peer), -1);
+    stats.Symbol_destroy++;
+}
+
+JNIEXPORT jint JNICALL
+Java_net_sourceforge_zbar_Symbol_getType (JNIEnv *env,
+                                          jobject obj,
+                                          jlong peer)
+{
+    return(zbar_symbol_get_type(PEER_CAST(peer)));
+}
+
+JNIEXPORT jint JNICALL
+Java_net_sourceforge_zbar_Symbol_getConfigMask (JNIEnv *env,
+                                                jobject obj)
+{
+    return(zbar_symbol_get_configs(GET_PEER(Symbol, obj)));
+}
+
+JNIEXPORT jint JNICALL
+Java_net_sourceforge_zbar_Symbol_getModifierMask (JNIEnv *env,
+                                                  jobject obj)
+{
+    return(zbar_symbol_get_modifiers(GET_PEER(Symbol, obj)));
+}
+
+JNIEXPORT jstring JNICALL
+Java_net_sourceforge_zbar_Symbol_getData (JNIEnv *env,
+                                          jobject obj)
+{
+    const char *data = zbar_symbol_get_data(GET_PEER(Symbol, obj));
+    return((*env)->NewStringUTF(env, data));
+}
+
+JNIEXPORT jstring JNICALL
+Java_net_sourceforge_zbar_Symbol_getDataBytes (JNIEnv *env,
+                                               jobject obj)
+{
+    const zbar_symbol_t *zsym = GET_PEER(Symbol, obj);
+    const void *data = zbar_symbol_get_data(zsym);
+    unsigned long datalen = zbar_symbol_get_data_length(zsym);
+    if(!data || !datalen)
+        return(NULL);
+
+    jbyteArray bytes = (*env)->NewByteArray(env, datalen);
+    if(!bytes)
+        return(NULL);
+
+    (*env)->SetByteArrayRegion(env, bytes, 0, datalen, data);
+    return(bytes);
+}
+
+JNIEXPORT jint JNICALL
+Java_net_sourceforge_zbar_Symbol_getQuality (JNIEnv *env,
+                                             jobject obj)
+{
+    return(zbar_symbol_get_quality(GET_PEER(Symbol, obj)));
+}
+
+JNIEXPORT jint JNICALL
+Java_net_sourceforge_zbar_Symbol_getCount (JNIEnv *env,
+                                           jobject obj)
+{
+    return(zbar_symbol_get_count(GET_PEER(Symbol, obj)));
+}
+
+JNIEXPORT jint JNICALL
+Java_net_sourceforge_zbar_Symbol_getLocationSize (JNIEnv *env,
+                                                  jobject obj,
+                                                  jlong peer)
+{
+    return(zbar_symbol_get_loc_size(PEER_CAST(peer)));
+}
+
+JNIEXPORT jint JNICALL
+Java_net_sourceforge_zbar_Symbol_getLocationX (JNIEnv *env,
+                                               jobject obj,
+                                               jlong peer,
+                                               jint idx)
+{
+    return(zbar_symbol_get_loc_x(PEER_CAST(peer), idx));
+}
+
+JNIEXPORT jint JNICALL
+Java_net_sourceforge_zbar_Symbol_getLocationY (JNIEnv *env,
+                                               jobject obj,
+                                               jlong peer,
+                                               jint idx)
+{
+    return(zbar_symbol_get_loc_y(PEER_CAST(peer), idx));
+}
+
+JNIEXPORT jint JNICALL
+Java_net_sourceforge_zbar_Symbol_getOrientation (JNIEnv *env,
+                                                 jobject obj)
+{
+    return(zbar_symbol_get_orientation(GET_PEER(Symbol, obj)));
+}
+
+JNIEXPORT jlong JNICALL
+Java_net_sourceforge_zbar_Symbol_getComponents (JNIEnv *env,
+                                                jobject obj,
+                                                jlong peer)
+{
+    const zbar_symbol_set_t *zsyms =
+        zbar_symbol_get_components(PEER_CAST(peer));
+    if(zsyms) {
+        zbar_symbol_set_ref(zsyms, 1);
+        stats.SymbolSet_create++;
+    }
+    return((intptr_t)zsyms);
+}
+
+JNIEXPORT jlong JNICALL
+Java_net_sourceforge_zbar_Symbol_next (JNIEnv *env,
+                                       jobject obj)
+{
+    const zbar_symbol_t *zsym = zbar_symbol_next(GET_PEER(Symbol, obj));
+    if(zsym) {
+        zbar_symbol_ref(zsym, 1);
+        stats.Symbol_create++;
+    }
+    return((intptr_t)zsym);
+}
+
+
+
+static void
+Image_cleanupByteArray (zbar_image_t *zimg)
+{
+    jobject data = zbar_image_get_userdata(zimg);
+    assert(data);
+
+    JNIEnv *env = NULL;
+    if((*jvm)->AttachCurrentThread(jvm, (void*)&env, NULL))
+        return;
+    assert(env);
+    if(env && data) {
+        void *raw = (void*)zbar_image_get_data(zimg);
+        assert(raw);
+        /* const image data is unchanged - abort copy back */
+        (*env)->ReleaseByteArrayElements(env, data, raw, JNI_ABORT);
+        (*env)->DeleteGlobalRef(env, data);
+        zbar_image_set_userdata(zimg, NULL);
+    }
+}
+
+static void
+Image_cleanupIntArray (zbar_image_t *zimg)
+{
+    jobject data = zbar_image_get_userdata(zimg);
+    assert(data);
+
+    JNIEnv *env = NULL;
+    if((*jvm)->AttachCurrentThread(jvm, (void*)&env, NULL))
+        return;
+    assert(env);
+    if(env && data) {
+        void *raw = (void*)zbar_image_get_data(zimg);
+        assert(raw);
+        /* const image data is unchanged - abort copy back */
+        (*env)->ReleaseIntArrayElements(env, data, raw, JNI_ABORT);
+        (*env)->DeleteGlobalRef(env, data);
+        zbar_image_set_userdata(zimg, NULL);
+    }
+}
+
+
+JNIEXPORT void JNICALL
+Java_net_sourceforge_zbar_Image_init (JNIEnv *env,
+                                      jclass cls)
+{
+    Image_peer = (*env)->GetFieldID(env, cls, "peer", "J");
+    Image_data = (*env)->GetFieldID(env, cls, "data", "Ljava/lang/Object;");
+}
+
+JNIEXPORT jlong JNICALL
+Java_net_sourceforge_zbar_Image_create (JNIEnv *env,
+                                        jobject obj)
+{
+    zbar_image_t *zimg = zbar_image_create();
+    if(!zimg) {
+        throw_exc(env, "java/lang/OutOfMemoryError", NULL);
+        return(0);
+    }
+    stats.Image_create++;
+    return((intptr_t)zimg);
+}
+
+JNIEXPORT void JNICALL
+Java_net_sourceforge_zbar_Image_destroy (JNIEnv *env,
+                                         jobject obj,
+                                         jlong peer)
+{
+    zbar_image_ref(PEER_CAST(peer), -1);
+    stats.Image_destroy++;
+}
+
+JNIEXPORT jlong JNICALL
+Java_net_sourceforge_zbar_Image_convert (JNIEnv *env,
+                                         jobject obj,
+                                         jlong peer,
+                                         jstring format)
+{
+    uint32_t fourcc = format_to_fourcc(env, format);
+    if(!fourcc)
+        return(0);
+    zbar_image_t *zimg = zbar_image_convert(PEER_CAST(peer), fourcc);
+    if(!zimg)
+        throw_exc(env, "java/lang/UnsupportedOperationException",
+                  "unsupported image format");
+    else
+        stats.Image_create++;
+    return((intptr_t)zimg);
+}
+
+JNIEXPORT jstring JNICALL
+Java_net_sourceforge_zbar_Image_getFormat (JNIEnv *env,
+                                           jobject obj)
+{
+    uint32_t fourcc = zbar_image_get_format(GET_PEER(Image, obj));
+    if(!fourcc)
+        return(NULL);
+    char fmtstr[5] = { fourcc, fourcc >> 8, fourcc >> 16, fourcc >> 24, 0 };
+    return((*env)->NewStringUTF(env, fmtstr));
+}
+
+JNIEXPORT void JNICALL
+Java_net_sourceforge_zbar_Image_setFormat (JNIEnv *env,
+                                           jobject obj,
+                                           jstring format)
+{
+    uint32_t fourcc = format_to_fourcc(env, format);
+    if(!fourcc)
+        return;
+    zbar_image_set_format(GET_PEER(Image, obj), fourcc);
+}
+
+JNIEXPORT jint JNICALL
+Java_net_sourceforge_zbar_Image_getSequence (JNIEnv *env,
+                                             jobject obj)
+{
+    return(zbar_image_get_sequence(GET_PEER(Image, obj)));
+}
+
+JNIEXPORT void JNICALL
+Java_net_sourceforge_zbar_Image_setSequence (JNIEnv *env,
+                                             jobject obj,
+                                             jint seq)
+{
+    zbar_image_set_sequence(GET_PEER(Image, obj), seq);
+}
+
+JNIEXPORT jint JNICALL
+Java_net_sourceforge_zbar_Image_getWidth (JNIEnv *env,
+                                          jobject obj)
+{
+    return(zbar_image_get_width(GET_PEER(Image, obj)));
+}
+
+JNIEXPORT jint JNICALL
+Java_net_sourceforge_zbar_Image_getHeight (JNIEnv *env,
+                                           jobject obj)
+{
+    return(zbar_image_get_height(GET_PEER(Image, obj)));
+}
+
+JNIEXPORT jobject JNICALL
+Java_net_sourceforge_zbar_Image_getSize (JNIEnv *env,
+                                         jobject obj)
+{
+    jintArray size = (*env)->NewIntArray(env, 2);
+    if(!size)
+        return(NULL);
+
+    unsigned dims[2];
+    zbar_image_get_size(GET_PEER(Image, obj), dims, dims + 1);
+    jint jdims[2] = { dims[0], dims[1] };
+    (*env)->SetIntArrayRegion(env, size, 0, 2, jdims);
+    return(size);
+}
+
+JNIEXPORT void JNICALL
+Java_net_sourceforge_zbar_Image_setSize__II (JNIEnv *env,
+                                             jobject obj,
+                                             jint width,
+                                             jint height)
+{
+    if(width < 0) width = 0;
+    if(height < 0) height = 0;
+    zbar_image_set_size(GET_PEER(Image, obj), width, height);
+}
+
+JNIEXPORT void JNICALL
+Java_net_sourceforge_zbar_Image_setSize___3I (JNIEnv *env,
+                                              jobject obj,
+                                              jintArray size)
+{
+    if((*env)->GetArrayLength(env, size) != 2)
+        throw_exc(env, "java/lang/IllegalArgumentException",
+                  "size must be an array of two ints");
+    jint dims[2];
+    (*env)->GetIntArrayRegion(env, size, 0, 2, dims);
+    if(dims[0] < 0) dims[0] = 0;
+    if(dims[1] < 0) dims[1] = 0;
+    zbar_image_set_size(GET_PEER(Image, obj), dims[0], dims[1]);
+}
+
+JNIEXPORT jobject JNICALL
+Java_net_sourceforge_zbar_Image_getCrop (JNIEnv *env,
+                                         jobject obj)
+{
+    jintArray crop = (*env)->NewIntArray(env, 4);
+    if(!crop)
+        return(NULL);
+
+    unsigned dims[4];
+    zbar_image_get_crop(GET_PEER(Image, obj), dims, dims + 1,
+                        dims + 2, dims + 3);
+    jint jdims[4] = { dims[0], dims[1], dims[2], dims[3] };
+    (*env)->SetIntArrayRegion(env, crop, 0, 4, jdims);
+    return(crop);
+}
+
+#define VALIDATE_CROP(u, m) \
+    if((u) < 0) {           \
+        (m) += (u);         \
+        (u) = 0;            \
+    }
+
+JNIEXPORT void JNICALL
+Java_net_sourceforge_zbar_Image_setCrop__IIII (JNIEnv *env,
+                                               jobject obj,
+                                               jint x, jint y,
+                                               jint w, jint h)
+{
+    VALIDATE_CROP(x, w);
+    VALIDATE_CROP(y, h);
+    zbar_image_set_crop(GET_PEER(Image, obj), x, y, w, h);
+}
+
+JNIEXPORT void JNICALL
+Java_net_sourceforge_zbar_Image_setCrop___3I (JNIEnv *env,
+                                              jobject obj,
+                                              jintArray crop)
+{
+    if((*env)->GetArrayLength(env, crop) != 4)
+        throw_exc(env, "java/lang/IllegalArgumentException",
+                  "crop must be an array of four ints");
+    jint dims[4];
+    (*env)->GetIntArrayRegion(env, crop, 0, 4, dims);
+    VALIDATE_CROP(dims[0], dims[2]);
+    VALIDATE_CROP(dims[1], dims[3]);
+    zbar_image_set_crop(GET_PEER(Image, obj),
+                        dims[0], dims[1], dims[2], dims[3]);
+}
+#undef VALIDATE_CROP
+
+JNIEXPORT jobject JNICALL
+Java_net_sourceforge_zbar_Image_getData (JNIEnv *env,
+                                         jobject obj)
+{
+    jobject data = (*env)->GetObjectField(env, obj, Image_data);
+    if(data)
+        return(data);
+
+    zbar_image_t *zimg = GET_PEER(Image, obj);
+    data = zbar_image_get_userdata(zimg);
+    if(data)
+        return(data);
+
+    unsigned long rawlen = zbar_image_get_data_length(zimg);
+    const void *raw = zbar_image_get_data(zimg);
+    if(!rawlen || !raw)
+        return(NULL);
+
+    data = (*env)->NewByteArray(env, rawlen);
+    if(!data)
+        return(NULL);
+
+    (*env)->SetByteArrayRegion(env, data, 0, rawlen, raw);
+    (*env)->SetObjectField(env, obj, Image_data, data);
+    return(data);
+}
+
+static inline void
+Image_setData (JNIEnv *env,
+               jobject obj,
+               jbyteArray data,
+               void *raw,
+               unsigned long rawlen,
+               zbar_image_cleanup_handler_t *cleanup)
+{
+    if(!data)
+        cleanup = NULL;
+    (*env)->SetObjectField(env, obj, Image_data, data);
+    zbar_image_t *zimg = GET_PEER(Image, obj);
+    zbar_image_set_data(zimg, raw, rawlen, cleanup);
+    zbar_image_set_userdata(zimg, (*env)->NewGlobalRef(env, data));
+}
+
+JNIEXPORT void JNICALL
+Java_net_sourceforge_zbar_Image_setData___3B (JNIEnv *env,
+                                              jobject obj,
+                                              jbyteArray data)
+{
+    jbyte *raw = NULL;
+    unsigned long rawlen = 0;
+    if(data) {
+        raw = (*env)->GetByteArrayElements(env, data, NULL);
+        if(!raw)
+            return;
+        rawlen = (*env)->GetArrayLength(env, data);
+    }
+    Image_setData(env, obj, data, raw, rawlen, Image_cleanupByteArray);
+}
+
+JNIEXPORT void JNICALL
+Java_net_sourceforge_zbar_Image_setData___3I (JNIEnv *env,
+                                              jobject obj,
+                                              jintArray data)
+{
+    jint *raw = NULL;
+    unsigned long rawlen = 0;
+    if(data) {
+        raw = (*env)->GetIntArrayElements(env, data, NULL);
+        if(!raw)
+            return;
+        rawlen = (*env)->GetArrayLength(env, data) * sizeof(*raw);
+    }
+    Image_setData(env, obj, data, raw, rawlen, Image_cleanupIntArray);
+}
+
+JNIEXPORT jlong JNICALL
+Java_net_sourceforge_zbar_Image_getSymbols (JNIEnv *env,
+                                            jobject obj,
+                                            jlong peer)
+{
+    const zbar_symbol_set_t *zsyms = zbar_image_get_symbols(PEER_CAST(peer));
+    if(zsyms) {
+        zbar_symbol_set_ref(zsyms, 1);
+        stats.SymbolSet_create++;
+    }
+    return((intptr_t)zsyms);
+}
+
+
+JNIEXPORT void JNICALL
+Java_net_sourceforge_zbar_ImageScanner_init (JNIEnv *env,
+                                             jclass cls)
+{
+    ImageScanner_peer = (*env)->GetFieldID(env, cls, "peer", "J");
+}
+
+JNIEXPORT jlong JNICALL
+Java_net_sourceforge_zbar_ImageScanner_create (JNIEnv *env,
+                                               jobject obj)
+{
+    zbar_image_scanner_t *zscn = zbar_image_scanner_create();
+    if(!zscn) {
+        throw_exc(env, "java/lang/OutOfMemoryError", NULL);
+        return(0);
+    }
+    stats.ImageScanner_create++;
+    return((intptr_t)zscn);
+}
+
+JNIEXPORT void JNICALL
+Java_net_sourceforge_zbar_ImageScanner_destroy (JNIEnv *env,
+                                                jobject obj,
+                                                jlong peer)
+{
+    zbar_image_scanner_destroy(PEER_CAST(peer));
+    stats.ImageScanner_destroy++;
+}
+
+JNIEXPORT void JNICALL
+Java_net_sourceforge_zbar_ImageScanner_setConfig (JNIEnv *env,
+                                                  jobject obj,
+                                                  jint symbology,
+                                                  jint config,
+                                                  jint value)
+{
+    zbar_image_scanner_set_config(GET_PEER(ImageScanner, obj),
+                                  symbology, config, value);
+}
+
+JNIEXPORT void JNICALL
+Java_net_sourceforge_zbar_ImageScanner_parseConfig (JNIEnv *env,
+                                                    jobject obj,
+                                                    jstring cfg)
+{
+    const char *cfgstr = (*env)->GetStringUTFChars(env, cfg, NULL);
+    if(!cfgstr)
+        return;
+    if(zbar_image_scanner_parse_config(GET_PEER(ImageScanner, obj), cfgstr))
+        throw_exc(env, "java/lang/IllegalArgumentException",
+                  "unknown configuration");
+}
+
+JNIEXPORT void JNICALL
+Java_net_sourceforge_zbar_ImageScanner_enableCache (JNIEnv *env,
+                                                    jobject obj,
+                                                    jboolean enable)
+{
+    zbar_image_scanner_enable_cache(GET_PEER(ImageScanner, obj), enable);
+}
+
+JNIEXPORT jlong JNICALL
+Java_net_sourceforge_zbar_ImageScanner_getResults (JNIEnv *env,
+                                                   jobject obj,
+                                                   jlong peer)
+{
+    const zbar_symbol_set_t *zsyms =
+        zbar_image_scanner_get_results(PEER_CAST(peer));
+    if(zsyms) {
+        zbar_symbol_set_ref(zsyms, 1);
+        stats.SymbolSet_create++;
+    }
+    return((intptr_t)zsyms);
+}
+
+JNIEXPORT jint JNICALL
+Java_net_sourceforge_zbar_ImageScanner_scanImage (JNIEnv *env,
+                                                  jobject obj,
+                                                  jobject image)
+{
+    zbar_image_scanner_t *zscn = GET_PEER(ImageScanner, obj);
+    zbar_image_t *zimg = GET_PEER(Image, image);
+
+    int n = zbar_scan_image(zscn, zimg);
+    if(n < 0)
+        throw_exc(env, "java/lang/UnsupportedOperationException",
+                  "unsupported image format");
+    return(n);
+}
diff -r 563557a923d0 perl/Changes
--- a/perl/Changes	Tue Oct 27 11:25:59 2009 -0400
+++ b/perl/Changes	Fri Feb 22 08:54:29 2013 -0300
@@ -1,5 +1,17 @@
 Revision history for Perl extension Barcode::ZBar.
 
+current spadix
+	* add Symbol orientation and Decoder direction interfaces
+
+0.04  2009-10-23 spadix
+	* add result query interfaces to ImageScanner and Processor
+
+0.03  2009-09-24 spadix
+	* add support for binary symbol data
+	* fix symbol leaks
+	* add symbol quality metric
+	* add support for QR Code
+
 0.02  2009-04-16 spadix
 	* project name change: package becomes Barcode::ZBar
 
diff -r 563557a923d0 perl/README
--- a/perl/README	Tue Oct 27 11:25:59 2009 -0400
+++ b/perl/README	Fri Feb 22 08:54:29 2013 -0300
@@ -1,10 +1,11 @@
 Barcode::ZBar Perl module
 =========================
 
-The ZBar Bar Code Reader is a library for scanning and decoding bar
-codes from various sources such as video streams, image files or raw
-intensity sensors.  It supports EAN, UPC, Code 128, Code 39 and
-Interleaved 2 of 5.  These are the Perl bindings for the library.
+ZBar Bar Code Reader is an open source software suite for reading bar
+codes from various sources, such as video streams, image files and raw
+intensity sensors. It supports EAN-13/UPC-A, UPC-E, EAN-8, Code 128,
+Code 93, Code 39, Codabar, Interleaved 2 of 5 and QR Code.  These are
+the Perl bindings for the library.
 
 Check the ZBar project home page for the latest release, mailing
 lists, etc.
@@ -34,4 +35,4 @@
 Licensed under the GNU Lesser General Public License, version 2.1.
 http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt
 
-Copyright 2008-2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+Copyright 2008-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
diff -r 563557a923d0 perl/ZBar.pm
--- a/perl/ZBar.pm	Tue Oct 27 11:25:59 2009 -0400
+++ b/perl/ZBar.pm	Fri Feb 22 08:54:29 2013 -0300
@@ -1,5 +1,5 @@
 #------------------------------------------------------------------------
-#  Copyright 2008-2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+#  Copyright 2008-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
 #
 #  This file is part of the ZBar Bar Code Reader.
 #
@@ -86,8 +86,8 @@
 
 The ZBar Bar Code Reader is a library for scanning and decoding bar
 codes from various sources such as video streams, image files or raw
-intensity sensors.  It supports EAN, UPC, Code 128, Code 39 and
-Interleaved 2 of 5.
+intensity sensors.  It supports EAN-13/UPC-A, UPC-E, EAN-8, Code 128,
+Code 93, Code 39, Codabar, Interleaved 2 of 5 and QR Code.
 
 These are the bindings for interacting directly with the library from
 Perl.
@@ -137,6 +137,56 @@
 
 =back
 
+Decoder configuration constants:
+
+=over 4
+
+=item Config::ENABLE
+
+=item Config::ADD_CHECK
+
+=item Config::EMIT_CHECK
+
+=item Config::ASCII
+
+=item Config::MIN_LEN
+
+=item Config::MAX_LEN
+
+=item Config::POSITION
+
+=item Config::X_DENSITY
+
+=item Config::Y_DENSITY
+
+=back
+
+Symbology modifier constants:
+
+=over 4
+
+=item Modifier::GS1
+
+=item Modifier::AIM
+
+=back
+
+Symbol orientation constants:
+
+=over 4
+
+=item Orient::UNKNOWN
+
+=item Orient::UP
+
+=item Orient::RIGHT
+
+=item Orient::DOWN
+
+=item Orient::LEFT
+
+=back
+
 
 =head1 SEE ALSO
 
@@ -156,7 +206,7 @@
 
 =head1 COPYRIGHT AND LICENSE
 
-Copyright 2008-2009 (c) Jeff Brown E<lt>spadix@users.sourceforge.netE<gt>
+Copyright 2008-2010 (c) Jeff Brown E<lt>spadix@users.sourceforge.netE<gt>
 
 The ZBar Bar Code Reader is free software; you can redistribute it
 and/or modify it under the terms of the GNU Lesser Public License as
diff -r 563557a923d0 perl/ZBar.xs
--- a/perl/ZBar.xs	Tue Oct 27 11:25:59 2009 -0400
+++ b/perl/ZBar.xs	Fri Feb 22 08:54:29 2013 -0300
@@ -1,5 +1,5 @@
 //------------------------------------------------------------------------
-//  Copyright 2008-2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+//  Copyright 2008-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
 //
 //  This file is part of the ZBar Bar Code Reader.
 //
@@ -53,6 +53,8 @@
 static AV *LOOKUP_zbar_symbol_type_t = NULL;
 static AV *LOOKUP_zbar_error_t = NULL;
 static AV *LOOKUP_zbar_config_t = NULL;
+static AV *LOOKUP_zbar_modifier_t = NULL;
+static AV *LOOKUP_zbar_orientation_t = NULL;
 
 #define CONSTANT(typ, prefix, sym, name)                \
     do {                                                \
@@ -93,6 +95,15 @@
         }                                                               \
     } while(0);
 
+#define PUSH_ENUM_MASK(typ, TYP, val)                         \
+    do {                                                      \
+        unsigned mask = (val);                                \
+        int i;                                                \
+        for(i = 0; i < ZBAR_ ## TYP ## _NUM; i++, mask >>= 1) \
+            if(mask & 1)                                      \
+                XPUSHs(LOOKUP_ENUM(typ, i));                  \
+    } while(0);
+
 static void image_cleanup_handler (zbar_image_t *image)
 {
     SV *data = zbar_image_get_userdata(image);
@@ -151,7 +162,7 @@
     SAVETMPS;
 
     PUSHMARK(SP);
-    EXTEND(SP, 2);
+    EXTEND(SP, 3);
     PUSHs(sv_mortalcopy(wrap->instance));
     if(param)
         PUSHs(param);
@@ -277,11 +288,37 @@
         CONSTANT(config, CFG_, ASCII, "ascii");
         CONSTANT(config, CFG_, MIN_LEN, "min-length");
         CONSTANT(config, CFG_, MAX_LEN, "max-length");
+        CONSTANT(config, CFG_, UNCERTAINTY, "uncertainty");
         CONSTANT(config, CFG_, POSITION, "position");
         CONSTANT(config, CFG_, X_DENSITY, "x-density");
         CONSTANT(config, CFG_, Y_DENSITY, "y-density");
     }
 
+MODULE = Barcode::ZBar  PACKAGE = Barcode::ZBar::Modifier  PREFIX = zbar_mod_
+
+BOOT:
+    {
+        HV *stash = gv_stashpv("Barcode::ZBar::Modifier", TRUE);
+
+        LOOKUP_zbar_modifier_t = newAV();
+        CONSTANT(modifier, MOD_, GS1, "GS1");
+        CONSTANT(modifier, MOD_, AIM, "AIM");
+    }
+
+MODULE = Barcode::ZBar	PACKAGE = Barcode::ZBar::Orient	PREFIX = zbar_orientation_
+
+BOOT:
+    {
+        HV *stash = gv_stashpv("Barcode::ZBar::Orient", TRUE);
+
+        LOOKUP_zbar_orientation_t = newAV();
+        CONSTANT(orientation, ORIENT_, UNKNOWN, "UNKNOWN");
+        CONSTANT(orientation, ORIENT_, UP, "UP");
+        CONSTANT(orientation, ORIENT_, RIGHT, "RIGHT");
+        CONSTANT(orientation, ORIENT_, DOWN, "DOWN");
+        CONSTANT(orientation, ORIENT_, LEFT, "LEFT");
+    }
+
 
 MODULE = Barcode::ZBar	PACKAGE = Barcode::ZBar::Symbol	PREFIX = zbar_symbol_
 
@@ -298,10 +335,15 @@
         CONSTANT(symbol_type, , UPCA, zbar_get_symbol_name(ZBAR_UPCA));
         CONSTANT(symbol_type, , EAN13, zbar_get_symbol_name(ZBAR_EAN13));
         CONSTANT(symbol_type, , ISBN13, zbar_get_symbol_name(ZBAR_ISBN13));
+        CONSTANT(symbol_type, , DATABAR, zbar_get_symbol_name(ZBAR_DATABAR));
+        CONSTANT(symbol_type, , DATABAR_EXP,
+                 zbar_get_symbol_name(ZBAR_DATABAR_EXP));
         CONSTANT(symbol_type, , I25, zbar_get_symbol_name(ZBAR_I25));
+        CONSTANT(symbol_type, , CODABAR, zbar_get_symbol_name(ZBAR_CODABAR));
         CONSTANT(symbol_type, , CODE39, zbar_get_symbol_name(ZBAR_CODE39));
         CONSTANT(symbol_type, , PDF417, zbar_get_symbol_name(ZBAR_PDF417));
         CONSTANT(symbol_type, , QRCODE, zbar_get_symbol_name(ZBAR_QRCODE));
+        CONSTANT(symbol_type, , CODE93, zbar_get_symbol_name(ZBAR_CODE93));
         CONSTANT(symbol_type, , CODE128, zbar_get_symbol_name(ZBAR_CODE128));
     }
 
@@ -316,6 +358,18 @@
 	Barcode::ZBar::Symbol symbol
 
 SV *
+zbar_symbol_get_configs(symbol)
+	Barcode::ZBar::Symbol	symbol
+    PPCODE:
+        PUSH_ENUM_MASK(config, CFG, zbar_symbol_get_configs(symbol));
+
+SV *
+zbar_symbol_get_modifiers(symbol)
+	Barcode::ZBar::Symbol	symbol
+    PPCODE:
+        PUSH_ENUM_MASK(modifier, MOD, zbar_symbol_get_modifiers(symbol));
+
+SV *
 zbar_symbol_get_data(symbol)
 	Barcode::ZBar::Symbol symbol
     CODE:
@@ -347,6 +401,10 @@
             av_push(pt, newSVuv(zbar_symbol_get_loc_y(symbol, i)));
         }
 
+zbar_orientation_t
+zbar_symbol_get_orientation(symbol)
+	Barcode::ZBar::Symbol symbol
+
 SV *
 get_components(symbol)
         Barcode::ZBar::Symbol	symbol
@@ -398,6 +456,19 @@
         mPUSHu(zbar_image_get_width(image));
         mPUSHu(zbar_image_get_height(image));
 
+void
+get_crop(image)
+        Barcode::ZBar::Image	image
+    PREINIT:
+        unsigned x, y, w, h;
+    PPCODE:
+        zbar_image_get_crop(image, &x, &y, &w, &h);
+        EXTEND(SP, 4);
+        mPUSHu(x);
+        mPUSHu(y);
+        mPUSHu(w);
+        mPUSHu(h);
+
 SV *
 zbar_image_get_data(image)
         Barcode::ZBar::Image	image
@@ -426,8 +497,16 @@
 void
 zbar_image_set_size(image, width, height)
         Barcode::ZBar::Image	image
-	unsigned	width
-	unsigned	height
+        int	width + if(width < 0) width = 0;
+        int	height + if(height < 0) height = 0;
+
+void
+zbar_image_set_crop(image, x, y, width, height)
+        Barcode::ZBar::Image	image
+        int	x + if(x < 0) { width += x; x = 0; }
+        int	y + if(y < 0) { height += y; y = 0; }
+        int	width
+        int	height
 
 void
 zbar_image_set_data(image, data)
@@ -712,6 +791,25 @@
 zbar_decoder_get_type(decoder)
 	Barcode::ZBar::Decoder	decoder
 
+SV *
+zbar_decoder_get_configs(decoder, symbology)
+	Barcode::ZBar::Decoder	decoder
+        zbar_symbol_type_t	symbology
+    PPCODE:
+        if(symbology == ZBAR_NONE)
+            symbology = zbar_decoder_get_type(decoder);
+        PUSH_ENUM_MASK(config, CFG, zbar_decoder_get_configs(decoder, symbology));
+
+SV *
+zbar_decoder_get_modifiers(decoder)
+	Barcode::ZBar::Decoder	decoder
+    PPCODE:
+        PUSH_ENUM_MASK(modifier, MOD, zbar_decoder_get_modifiers(decoder));
+
+int
+zbar_decoder_get_direction(decoder)
+	Barcode::ZBar::Decoder	decoder
+
 void
 zbar_decoder_set_handler(decoder, handler = 0, closure = 0)
 	Barcode::ZBar::Decoder	decoder
diff -r 563557a923d0 perl/ZBar/Image.pod
--- a/perl/ZBar/Image.pod	Tue Oct 27 11:25:59 2009 -0400
+++ b/perl/ZBar/Image.pod	Fri Feb 22 08:54:29 2013 -0300
@@ -132,7 +132,7 @@
 
 =head1 COPYRIGHT AND LICENSE
 
-Copyright 2008-2009 (c) Jeff Brown E<lt>spadix@users.sourceforge.netE<gt>
+Copyright 2008-2010 (c) Jeff Brown E<lt>spadix@users.sourceforge.netE<gt>
 
 The ZBar Bar Code Reader is free software; you can redistribute it
 and/or modify it under the terms of the GNU Lesser Public License as
diff -r 563557a923d0 perl/ZBar/ImageScanner.pod
--- a/perl/ZBar/ImageScanner.pod	Tue Oct 27 11:25:59 2009 -0400
+++ b/perl/ZBar/ImageScanner.pod	Fri Feb 22 08:54:29 2013 -0300
@@ -89,7 +89,7 @@
 
 =head1 COPYRIGHT AND LICENSE
 
-Copyright 2008-2009 (c) Jeff Brown E<lt>spadix@users.sourceforge.netE<gt>
+Copyright 2008-2010 (c) Jeff Brown E<lt>spadix@users.sourceforge.netE<gt>
 
 The ZBar Bar Code Reader is free software; you can redistribute it
 and/or modify it under the terms of the GNU Lesser Public License as
diff -r 563557a923d0 perl/ZBar/Processor.pod
--- a/perl/ZBar/Processor.pod	Tue Oct 27 11:25:59 2009 -0400
+++ b/perl/ZBar/Processor.pod	Fri Feb 22 08:54:29 2013 -0300
@@ -137,7 +137,7 @@
 
 =head1 COPYRIGHT AND LICENSE
 
-Copyright 2008-2009 (c) Jeff Brown E<lt>spadix@users.sourceforge.netE<gt>
+Copyright 2008-2010 (c) Jeff Brown E<lt>spadix@users.sourceforge.netE<gt>
 
 The ZBar Bar Code Reader is free software; you can redistribute it
 and/or modify it under the terms of the GNU Lesser Public License as
diff -r 563557a923d0 perl/ZBar/Symbol.pod
--- a/perl/ZBar/Symbol.pod	Tue Oct 27 11:25:59 2009 -0400
+++ b/perl/ZBar/Symbol.pod	Fri Feb 22 08:54:29 2013 -0300
@@ -1,5 +1,5 @@
 #------------------------------------------------------------------------
-#  Copyright 2008-2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+#  Copyright 2008-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
 #
 #  This file is part of the ZBar Bar Code Reader.
 #
@@ -72,6 +72,12 @@
 inter-scan reliability and redundancy information if enabled at the
 Barcode::ZBar::ImageScanner.
 
+=item get_orientation()
+
+General orientation of decoded symbol.  This returns one of the
+Barcode::ZBar::Orient constants, which provide a coarse, axis-aligned
+indication of symbol orientation.
+
 =item get_components()
 
 Components of a composite result.  This yields an array of physical
@@ -120,8 +126,12 @@
 
 =item I25
 
+=item CODABAR
+
 =item CODE39
 
+=item CODE93
+
 =item CODE128
 
 =item QRCODE
@@ -144,7 +154,7 @@
 
 =head1 COPYRIGHT AND LICENSE
 
-Copyright 2008-2009 (c) Jeff Brown E<lt>spadix@users.sourceforge.netE<gt>
+Copyright 2008-2010 (c) Jeff Brown E<lt>spadix@users.sourceforge.netE<gt>
 
 The ZBar Bar Code Reader is free software; you can redistribute it
 and/or modify it under the terms of the GNU Lesser Public License as
diff -r 563557a923d0 perl/t/Decoder.t
--- a/perl/t/Decoder.t	Tue Oct 27 11:25:59 2009 -0400
+++ b/perl/t/Decoder.t	Fri Feb 22 08:54:29 2013 -0300
@@ -3,7 +3,7 @@
 
 use warnings;
 use strict;
-use Test::More tests => 13;
+use Test::More tests => 17;
 
 #########################
 
@@ -19,7 +19,8 @@
 #########################
 
 can_ok($decoder, qw(set_config parse_config reset new_scan decode_width
-                    get_color get_data get_type set_handler));
+                    get_color get_configs get_direction get_data get_modifiers
+                    get_type set_handler));
 
 #########################
 
@@ -58,6 +59,10 @@
 
 #########################
 
+is($decoder->get_direction(), 0, 'reset direction');
+
+#########################
+
 $decoder->set_config(Barcode::ZBar::Symbol::QRCODE,
                      Barcode::ZBar::Config::ENABLE, 0);
 
@@ -74,6 +79,17 @@
 
 #########################
 
+is_deeply([$decoder->get_configs($sym)],
+          [Barcode::ZBar::Config::ENABLE,
+           Barcode::ZBar::Config::EMIT_CHECK],
+          'read configs');
+
+#########################
+
+is_deeply([$decoder->get_modifiers()], [], 'read modifiers');
+
+#########################
+
 is($decoder->get_data(), '6268964977804', 'EAN-13 data');
 
 #########################
@@ -82,6 +98,10 @@
 
 #########################
 
+is($decoder->get_direction(), 1, 'decode direction');
+
+#########################
+
 is($handler_type, Barcode::ZBar::Symbol::EAN13, 'handler type');
 
 #########################
diff -r 563557a923d0 perl/t/Image.t
--- a/perl/t/Image.t	Tue Oct 27 11:25:59 2009 -0400
+++ b/perl/t/Image.t	Fri Feb 22 08:54:29 2013 -0300
@@ -3,7 +3,7 @@
 
 use warnings;
 use strict;
-use Test::More tests => 22;
+use Test::More tests => 29;
 
 #########################
 
@@ -48,6 +48,26 @@
 
 #########################
 
+$image->set_crop(20, 20, 74, 40);
+is_deeply([$image->get_crop()], [20, 20, 74, 40], 'crop accessors');
+
+#########################
+
+$image->set_crop(-57, -40, 228, 160);
+is_deeply([$image->get_crop()], [0, 0, 114, 80], 'crop clipping');
+
+#########################
+
+$image->set_crop(10, 10, 94, 60);
+is_deeply([$image->get_crop()], [10, 10, 94, 60], 'crop accessors');
+
+#########################
+
+$image->set_size(114, 80);
+is_deeply([$image->get_crop()], [0, 0, 114, 80], 'crop reset');
+
+#########################
+
 # FIXME avoid skipping these (eg embed image vs ImageMagick)
 SKIP: {
     eval { require Image::Magick };
@@ -94,7 +114,8 @@
 
     #########################
 
-    can_ok($sym, qw(get_type get_data get_quality get_count get_loc));
+    can_ok($sym, qw(get_type get_configs get_modifiers get_data get_quality
+                    get_count get_loc get_orientation));
 
     #########################
 
@@ -102,6 +123,17 @@
 
     #########################
 
+    is_deeply([$sym->get_configs()],
+              [Barcode::ZBar::Config::ENABLE,
+               Barcode::ZBar::Config::EMIT_CHECK],
+              'result configs');
+
+    #########################
+
+    is_deeply([$sym->get_modifiers()], [], 'result modifiers');
+
+    #########################
+
     is($sym->get_data(), '9876543210128', 'result data');
 
     #########################
@@ -133,6 +165,10 @@
 
     #########################
 
+    is($sym->get_orientation(), Barcode::ZBar::Orient::UP, 'orientation');
+
+    #########################
+
     my @comps = $sym->get_components();
     is(scalar(@comps), 0, 'components size');
 
diff -r 563557a923d0 perl/t/ZBar.t
--- a/perl/t/ZBar.t	Tue Oct 27 11:25:59 2009 -0400
+++ b/perl/t/ZBar.t	Fri Feb 22 08:54:29 2013 -0300
@@ -3,7 +3,7 @@
 
 use warnings;
 use strict;
-use Test::More tests => 3;
+use Test::More tests => 37;
 
 #########################
 
@@ -20,3 +20,49 @@
 pass('verbosity');
 
 #########################
+
+# performs (2 * n) tests
+sub test_enum {
+    my $name = shift;
+    foreach my $test (@_) {
+        my $enum = $test->[0];
+
+        is($enum, $test->[1], "$name enum/string compare");
+
+        #########################
+
+        ok($enum == $test->[2], "$name enum/numeric compare");
+    }
+}
+
+test_enum('config',
+    [Barcode::ZBar::Config::ENABLE,      'enable',        0],
+    [Barcode::ZBar::Config::ADD_CHECK,   'add-check',     1],
+    [Barcode::ZBar::Config::EMIT_CHECK,  'emit-check',    2],
+    [Barcode::ZBar::Config::ASCII,       'ascii',         3],
+    [Barcode::ZBar::Config::MIN_LEN,     'min-length',   32],
+    [Barcode::ZBar::Config::MAX_LEN,     'max-length',   33],
+    [Barcode::ZBar::Config::UNCERTAINTY, 'uncertainty',  64],
+    [Barcode::ZBar::Config::POSITION,    'position',    128],
+    [Barcode::ZBar::Config::X_DENSITY,   'x-density',   256],
+    [Barcode::ZBar::Config::Y_DENSITY,   'y-density',   257],
+);
+
+#########################
+
+test_enum('modifier',
+    [Barcode::ZBar::Modifier::GS1, 'GS1', 0],
+    [Barcode::ZBar::Modifier::AIM, 'AIM', 1],
+);
+
+#########################
+
+test_enum('orientation',
+    [Barcode::ZBar::Orient::UNKNOWN, 'UNKNOWN', -1],
+    [Barcode::ZBar::Orient::UP,      'UP',       0],
+    [Barcode::ZBar::Orient::RIGHT,   'RIGHT',    1],
+    [Barcode::ZBar::Orient::DOWN,    'DOWN',     2],
+    [Barcode::ZBar::Orient::LEFT,    'LEFT',     3],
+);
+
+#########################
diff -r 563557a923d0 perl/typemap
--- a/perl/typemap	Tue Oct 27 11:25:59 2009 -0400
+++ b/perl/typemap	Fri Feb 22 08:54:29 2013 -0300
@@ -14,6 +14,8 @@
 zbar_error_t					T_ENUM
 zbar_symbol_type_t				T_ENUM
 zbar_config_t					T_ENUM
+zbar_modifier_t                                 T_ENUM
+zbar_orientation_t				T_ENUM
 
 # special scalars
 fourcc_t					T_FOURCC
@@ -30,14 +32,8 @@
 T_FOURCC
 	{
             if(SvPOK($arg)) {
-                STRLEN len;
-                char *str = SvPV($arg, len);
-                if(len != 4)
-                    croak(\"invalid fourcc: \%s\", str);
-                $var = ((unsigned long)str[0] |
-                        ((unsigned long)str[1] << 8) |
-                        ((unsigned long)str[2] << 16) |
-                        ((unsigned long)str[3] << 24));
+                char *str = SvPV_nolen($arg);
+                $var = zbar_fourcc_parse(str);
             }
             else
                 $var = SvUV($arg);
diff -r 563557a923d0 python/MANIFEST.in
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/python/MANIFEST.in	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,2 @@
+include MANIFEST MANIFEST.in zbarmodule.h test/barcode.png
+recursive-include examples *.py
diff -r 563557a923d0 python/Makefile.am.inc
--- a/python/Makefile.am.inc	Tue Oct 27 11:25:59 2009 -0400
+++ b/python/Makefile.am.inc	Fri Feb 22 08:54:29 2013 -0300
@@ -9,4 +9,5 @@
     python/symboliter.c python/image.c \
     python/processor.c python/imagescanner.c python/decoder.c python/scanner.c
 
-EXTRA_DIST += python/test/barcode.png python/test/test_zbar.py
+EXTRA_DIST += python/test/barcode.png python/test/test_zbar.py \
+    python/examples/processor.py python/examples/read_one.py
diff -r 563557a923d0 python/README
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/python/README	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,60 @@
+==========================================
+zbar -- read barcodes from images or video
+==========================================
+
+ZBar Bar Code Reader is an open source software suite for reading bar
+codes from various sources, such as video streams, image files and raw
+intensity sensors. It supports EAN-13/UPC-A, UPC-E, EAN-8, Code 128,
+Code 93, Code 39, Codabar, Interleaved 2 of 5 and QR Code.  These are
+the Python bindings for the library.
+
+Check the ZBar project home page for the latest release, mailing
+lists, etc.
+
+* http://zbar.sourceforge.net/
+
+Installation
+------------
+
+To install this module type the following::
+
+   python setup.py install
+
+Dependencies
+------------
+
+This module requires the ZBar Bar Code Reader, which may be obtained
+from:
+
+* http://zbar.sourceforge.net/
+
+Windows users please note: the module *will NOT load* unless the ZBar
+library DLL (currently libzbar-0.dll) is available in your Windows system
+PATH!
+
+Examples
+--------
+
+To scan an image, wrap the raw image data in a ``zbar.Image`` and feed
+it to a ``zbar.ImageScanner``::
+
+    import zbar
+    scanner = zbar.ImageScanner()
+    image = zbar.Image(width, height, 'Y800', raw_data)
+    scanner.scan(image)
+    for symbol in image:
+        print 'decoded', symbol.type, 'symbol', '"%s"' % symbol.data
+
+Complete, runnable examples may be found in the source distribution,
+under the ``examples/`` directory.  A couple of HOWTOs_ that cover
+programming with the library may be found on the project wiki.
+
+.. _HOWTOs: http://sourceforge.net/apps/mediawiki/zbar/index.php?title=Category:HOWTOs
+
+Copyright and License
+---------------------
+
+Licensed under the GNU Lesser General Public License, version 2.1.
+http://www.gnu.org/licenses/old-licenses/lgpl-2.1.txt
+
+Copyright 2008-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
diff -r 563557a923d0 python/decoder.c
--- a/python/decoder.c	Tue Oct 27 11:25:59 2009 -0400
+++ b/python/decoder.c	Fri Feb 22 08:54:29 2013 -0300
@@ -1,5 +1,5 @@
 /*------------------------------------------------------------------------
- *  Copyright 2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *  Copyright 2009-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
  *
  *  This file is part of the ZBar Bar Code Reader.
  *
@@ -104,6 +104,23 @@
 }
 
 static PyObject*
+decoder_get_configs (zbarDecoder *self,
+                     void *closure)
+{
+    unsigned int sym = zbar_decoder_get_type(self->zdcode);
+    unsigned int mask = zbar_decoder_get_configs(self->zdcode, sym);
+    return(zbarEnum_SetFromMask(config_enum, mask));
+}
+
+static PyObject*
+decoder_get_modifiers (zbarDecoder *self,
+                       void *closure)
+{
+    unsigned int mask = zbar_decoder_get_modifiers(self->zdcode);
+    return(zbarEnum_SetFromMask(modifier_enum, mask));
+}
+
+static PyObject*
 decoder_get_data (zbarDecoder *self,
                   void *closure)
 {
@@ -111,10 +128,20 @@
                                       zbar_decoder_get_data_length(self->zdcode)));
 }
 
+static PyObject*
+decoder_get_direction (zbarDecoder *self,
+                       void *closure)
+{
+    return(PyInt_FromLong(zbar_decoder_get_direction(self->zdcode)));
+}
+
 static PyGetSetDef decoder_getset[] = {
-    { "color",    (getter)decoder_get_color, },
-    { "type",     (getter)decoder_get_type, },
-    { "data",     (getter)decoder_get_data, },
+    { "color",     (getter)decoder_get_color, },
+    { "type",      (getter)decoder_get_type, },
+    { "configs",   (getter)decoder_get_configs, },
+    { "modifiers", (getter)decoder_get_modifiers, },
+    { "data",      (getter)decoder_get_data, },
+    { "direction", (getter)decoder_get_direction },
     { NULL, },
 };
 
@@ -139,6 +166,23 @@
 }
 
 static PyObject*
+decoder_get_configs_meth (zbarDecoder *self,
+                          PyObject *args,
+                          PyObject *kwds)
+{
+    zbar_symbol_type_t sym = ZBAR_NONE;
+    static char *kwlist[] = { "symbology", NULL };
+    if(!PyArg_ParseTupleAndKeywords(args, kwds, "|i", kwlist, &sym))
+        return(NULL);
+
+    if(sym == ZBAR_NONE)
+        sym = zbar_decoder_get_type(self->zdcode);
+
+    unsigned int mask = zbar_decoder_get_configs(self->zdcode, sym);
+    return(zbarEnum_SetFromMask(config_enum, mask));
+}
+
+static PyObject*
 decoder_parse_config (zbarDecoder *self,
                       PyObject *args,
                       PyObject *kwds)
@@ -262,6 +306,8 @@
 static PyMethodDef decoder_methods[] = {
     { "set_config",   (PyCFunction)decoder_set_config,
       METH_VARARGS | METH_KEYWORDS, },
+    { "get_configs",  (PyCFunction)decoder_get_configs_meth,
+      METH_VARARGS | METH_KEYWORDS, },
     { "parse_config", (PyCFunction)decoder_parse_config,
       METH_VARARGS | METH_KEYWORDS, },
     { "reset",        (PyCFunction)decoder_reset,
diff -r 563557a923d0 python/enum.c
--- a/python/enum.c	Tue Oct 27 11:25:59 2009 -0400
+++ b/python/enum.c	Fri Feb 22 08:54:29 2013 -0300
@@ -1,5 +1,5 @@
 /*------------------------------------------------------------------------
- *  Copyright 2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *  Copyright 2009-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
  *
  *  This file is part of the ZBar Bar Code Reader.
  *
@@ -192,3 +192,31 @@
         return(-1);
     return(0);
 }
+
+zbarEnumItem*
+zbarEnum_LookupValue (zbarEnum *self,
+                      int val)
+{
+    PyObject *key = PyInt_FromLong(val);
+    zbarEnumItem *e = (zbarEnumItem*)PyDict_GetItem(self->byvalue, key);
+    if(!e)
+        return((zbarEnumItem*)key);
+    Py_INCREF((PyObject*)e);
+    Py_DECREF(key);
+    return(e);
+}
+
+PyObject*
+zbarEnum_SetFromMask (zbarEnum *self,
+                      unsigned int mask)
+{
+    PyObject *result = PySet_New(NULL);
+    PyObject *key, *item;
+    Py_ssize_t i = 0;
+    while(PyDict_Next(self->byvalue, &i, &key, &item)) {
+        int val = PyInt_AsLong(item);
+        if(val < sizeof(mask) * 8 && ((mask >> val) & 1))
+            PySet_Add(result, item);
+    }
+    return(result);
+}
diff -r 563557a923d0 python/examples/processor.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/python/examples/processor.py	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,35 @@
+#!/usr/bin/python
+from sys import argv
+import zbar
+
+# create a Processor
+proc = zbar.Processor()
+
+# configure the Processor
+proc.parse_config('enable')
+
+# initialize the Processor
+device = '/dev/video0'
+if len(argv) > 1:
+    device = argv[1]
+proc.init(device)
+
+# setup a callback
+def my_handler(proc, image, closure):
+    # extract results
+    for symbol in image.symbols:
+        # do something useful with results
+        print 'decoded', symbol.type, 'symbol', '"%s"' % symbol.data
+
+proc.set_data_handler(my_handler)
+
+# enable the preview window
+proc.visible = True
+
+# initiate scanning
+proc.active = True
+try:
+    # keep scanning until user provides key/mouse input
+    proc.user_wait()
+except zbar.WindowClosed, e:
+    pass
diff -r 563557a923d0 python/examples/read_one.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/python/examples/read_one.py	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,29 @@
+#!/usr/bin/python
+from sys import argv
+import zbar
+
+# create a Processor
+proc = zbar.Processor()
+
+# configure the Processor
+proc.parse_config('enable')
+
+# initialize the Processor
+device = '/dev/video0'
+if len(argv) > 1:
+    device = argv[1]
+proc.init(device)
+
+# enable the preview window
+proc.visible = True
+
+# read at least one barcode (or until window closed)
+proc.process_one()
+
+# hide the preview window
+proc.visible = False
+
+# extract results
+for symbol in proc.results:
+    # do something useful with results
+    print 'decoded', symbol.type, 'symbol', '"%s"' % symbol.data
diff -r 563557a923d0 python/examples/scan_image.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/python/examples/scan_image.py	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,31 @@
+#!/usr/bin/python
+from sys import argv
+import zbar
+import Image
+
+if len(argv) < 2: exit(1)
+
+# create a reader
+scanner = zbar.ImageScanner()
+
+# configure the reader
+scanner.parse_config('enable')
+
+# obtain image data
+pil = Image.open(argv[1]).convert('L')
+width, height = pil.size
+raw = pil.tostring()
+
+# wrap image data
+image = zbar.Image(width, height, 'Y800', raw)
+
+# scan the image for barcodes
+scanner.scan(image)
+
+# extract results
+for symbol in image:
+    # do something useful with results
+    print 'decoded', symbol.type, 'symbol', '"%s"' % symbol.data
+
+# clean up
+del(image)
diff -r 563557a923d0 python/image.c
--- a/python/image.c	Tue Oct 27 11:25:59 2009 -0400
+++ b/python/image.c	Fri Feb 22 08:54:29 2013 -0300
@@ -1,5 +1,5 @@
 /*------------------------------------------------------------------------
- *  Copyright 2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *  Copyright 2009-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
  *
  *  This file is part of the ZBar Bar Code Reader.
  *
@@ -139,16 +139,18 @@
         PyErr_SetString(PyExc_TypeError, "cannot delete format attribute");
         return(-1);
     }
-    char *format;
+    char *format = NULL;
     Py_ssize_t len;
     if(PyString_AsStringAndSize(value, &format, &len) ||
        !format || len != 4) {
+        if(!format)
+            format = "(nil)";
         PyErr_Format(PyExc_ValueError,
                      "format '%.50s' is not a valid four character code",
                      format);
         return(-1);
     }
-    zbar_image_set_format(self->zimg,*((unsigned long*)format));
+    zbar_image_set_format(self->zimg, zbar_fourcc_parse(format));
     return(0);
 }
 
@@ -156,9 +158,9 @@
 image_get_size (zbarImage *self,
                 void *closure)
 {
-    unsigned int width = zbar_image_get_width(self->zimg);
-    unsigned int height = zbar_image_get_height(self->zimg);
-    return(PyTuple_Pack(2, PyInt_FromLong(width), PyInt_FromLong(height)));
+    unsigned int w, h;
+    zbar_image_get_size(self->zimg, &w, &h);
+    return(PyTuple_Pack(2, PyInt_FromLong(w), PyInt_FromLong(h)));
 }
 
 static int
@@ -170,34 +172,60 @@
         PyErr_SetString(PyExc_TypeError, "cannot delete size attribute");
         return(-1);
     }
-    int rc = -1;
-    PyObject *wobj = NULL, *hobj = NULL;
-    if(!PySequence_Check(value) ||
-       PySequence_Size(value) != 2)
-        goto error;
-    wobj = PySequence_GetItem(value, 0);
-    hobj = PySequence_GetItem(value, 1);
-    if(!wobj || !hobj)
-        goto error;
 
-    int width = PyInt_AsSsize_t(wobj);
-    if(width == -1 && PyErr_Occurred())
-        goto error;
+    int dims[2];
+    if(parse_dimensions(value, dims, 2) ||
+       dims[0] < 0 || dims[1] < 0) {
+        PyErr_SetString(PyExc_ValueError,
+                        "size must be a sequence of two positive ints");
+        return(-1);
+    }
 
-    int height = PyInt_AsSsize_t(hobj);
-    if(height == -1 && PyErr_Occurred())
-        goto error;
+    zbar_image_set_size(self->zimg, dims[0], dims[1]);
+    return(0);
+}
 
-    zbar_image_set_size(self->zimg, width, height);
-    rc = 0;
+static PyObject*
+image_get_crop (zbarImage *self,
+                void *closure)
+{
+    unsigned int x, y, w, h;
+    zbar_image_get_crop(self->zimg, &x, &y, &w, &h);
+    return(PyTuple_Pack(4, PyInt_FromLong(x), PyInt_FromLong(y),
+                        PyInt_FromLong(w), PyInt_FromLong(h)));
+}
 
-error:
-    Py_XDECREF(wobj);
-    Py_XDECREF(hobj);
-    if(rc)
+static int
+image_set_crop (zbarImage *self,
+                PyObject *value,
+                void *closure)
+{
+    unsigned w, h;
+    zbar_image_get_size(self->zimg, &w, &h);
+    if(!value) {
+        zbar_image_set_crop(self->zimg, 0, 0, w, h);
+        return(0);
+    }
+
+    int dims[4];
+    if(parse_dimensions(value, dims, 4) ||
+       dims[2] < 0 || dims[3] < 0) {
         PyErr_SetString(PyExc_ValueError,
-                        "size must be a sequence of two ints");
-    return(rc);
+                        "crop must be a sequence of four positive ints");
+        return(-1);
+    }
+
+    if(dims[0] < 0) {
+        dims[2] += dims[0];
+        dims[0] = 0;
+    }
+    if(dims[1] < 0) {
+        dims[3] += dims[1];
+        dims[1] = 0;
+    }
+
+    zbar_image_set_crop(self->zimg, dims[0], dims[1], dims[2], dims[3]);
+    return(0);
 }
 
 static PyObject*
@@ -308,6 +336,7 @@
 static PyGetSetDef image_getset[] = {
     { "format",   (getter)image_get_format, (setter)image_set_format, },
     { "size",     (getter)image_get_size,   (setter)image_set_size, },
+    { "crop",     (getter)image_get_crop,   (setter)image_set_crop, },
     { "width",    (getter)image_get_int,    (setter)image_set_int,
       NULL, (void*)0 },
     { "height",   (getter)image_get_int,    (setter)image_set_int,
@@ -359,6 +388,7 @@
                      format);
         return(NULL);
     }
+    unsigned long fourcc = zbar_fourcc_parse(format);
 
     zbarImage *img = PyObject_GC_New(zbarImage, &zbarImage_Type);
     if(!img)
@@ -366,11 +396,9 @@
     img->data = NULL;
     if(width > 0 && height > 0)
         img->zimg =
-            zbar_image_convert_resize(self->zimg,
-                                       *((unsigned long*)format),
-                                       width, height);
+            zbar_image_convert_resize(self->zimg, fourcc, width, height);
     else
-        img->zimg = zbar_image_convert(self->zimg, *((unsigned long*)format));
+        img->zimg = zbar_image_convert(self->zimg, fourcc);
 
     if(!img->zimg) {
         /* FIXME propagate exception */
diff -r 563557a923d0 python/processor.c
--- a/python/processor.c	Tue Oct 27 11:25:59 2009 -0400
+++ b/python/processor.c	Fri Feb 22 08:54:29 2013 -0300
@@ -36,15 +36,30 @@
                PyObject *args,
                PyObject *kwds)
 {
-    static char *kwlist[] = { NULL };
-    if(!PyArg_ParseTupleAndKeywords(args, kwds, "", kwlist))
+    static char *kwlist[] = { "enable_threads", NULL };
+    int threaded = -1;
+    if(!PyArg_ParseTupleAndKeywords(args, kwds, "|O&", kwlist,
+                                    object_to_bool, &threaded))
         return(NULL);
 
+#ifdef WITH_THREAD
+    /* the processor creates a thread that calls back into python,
+     * so we must ensure that threads are initialized before attempting
+     * to manipulate the GIL (bug #3349199)
+     */
+    PyEval_InitThreads();
+#else
+    if(threaded > 0 &&
+       PyErr_WarnEx(NULL, "threading requested but not available", 1))
+        return(NULL);
+    threaded = 0;
+#endif
+
     zbarProcessor *self = (zbarProcessor*)type->tp_alloc(type, 0);
     if(!self)
         return(NULL);
 
-    self->zproc = zbar_processor_create(0/*FIXME*/);
+    self->zproc = zbar_processor_create(threaded);
     zbar_processor_set_userdata(self->zproc, self);
     if(!self->zproc) {
         Py_DECREF(self);
@@ -138,12 +153,35 @@
     return(zbarSymbolSet_FromSymbolSet(zsyms));
 }
 
+static int
+processor_set_request_size (zbarProcessor *self,
+                            PyObject *value,
+                            void *closure)
+{
+    if(!value) {
+        zbar_processor_request_size(self->zproc, 0, 0);
+        return(0);
+    }
+
+    int dims[2];
+    if(parse_dimensions(value, dims, 2) ||
+       dims[0] < 0 || dims[1] < 0) {
+        PyErr_SetString(PyExc_ValueError,
+                        "request_size must be a sequence of two positive ints");
+        return(-1);
+    }
+
+    zbar_processor_request_size(self->zproc, dims[0], dims[1]);
+    return(0);
+}
+
 static PyGetSetDef processor_getset[] = {
     { "visible",  (getter)processor_get_bool, (setter)processor_set_bool,
       NULL, (void*)0 },
     { "active",   NULL,                       (setter)processor_set_bool,
       NULL, (void*)1 },
     { "results",  (getter)processor_get_results, },
+    { "request_size", NULL, (setter)processor_set_request_size, },
     { NULL, },
 };
 
@@ -228,7 +266,11 @@
                                     object_to_timeout, &timeout))
         return(NULL);
 
-    int rc = zbar_processor_user_wait(self->zproc, timeout);
+    int rc = -1;
+    Py_BEGIN_ALLOW_THREADS
+    rc = zbar_processor_user_wait(self->zproc, timeout);
+    Py_END_ALLOW_THREADS
+
     if(rc < 0)
         return(zbarErr_Set((PyObject*)self));
     return(PyInt_FromLong(rc));
@@ -245,7 +287,11 @@
                                     object_to_timeout, &timeout))
         return(NULL);
 
-    int rc = zbar_process_one(self->zproc, timeout);
+    int rc = -1;
+    Py_BEGIN_ALLOW_THREADS
+    rc = zbar_process_one(self->zproc, timeout);
+    Py_END_ALLOW_THREADS
+
     if(rc < 0)
         return(zbarErr_Set((PyObject*)self));
     return(PyInt_FromLong(rc));
@@ -265,7 +311,11 @@
     if(zbarImage_validate(img))
         return(NULL);
 
-    int n = zbar_process_image(self->zproc, img->zimg);
+    int n = -1;
+    Py_BEGIN_ALLOW_THREADS
+    n = zbar_process_image(self->zproc, img->zimg);
+    Py_END_ALLOW_THREADS
+
     if(n < 0)
         return(zbarErr_Set((PyObject*)self));
     return(PyInt_FromLong(n));
@@ -275,6 +325,9 @@
 process_handler (zbar_image_t *zimg,
                  const void *userdata)
 {
+    PyGILState_STATE gstate;
+    gstate = PyGILState_Ensure();
+
     zbarProcessor *self = (zbarProcessor*)userdata;
     assert(self);
     assert(self->handler);
@@ -285,7 +338,7 @@
         img = zbarImage_FromImage(zimg);
         if(!img) {
             PyErr_NoMemory();
-            return;
+            goto done;
         }
     }
     else
@@ -299,8 +352,17 @@
     PyTuple_SET_ITEM(args, 2, self->closure);
 
     PyObject *junk = PyObject_Call(self->handler, args, NULL);
-    Py_XDECREF(junk);
+    if(junk)
+        Py_DECREF(junk);
+    else {
+        PySys_WriteStderr("in ZBar Processor data_handler:\n");
+        assert(PyErr_Occurred());
+        PyErr_Print();
+    }
     Py_DECREF(args);
+
+done:
+    PyGILState_Release(gstate);
 }
 
 static PyObject*
diff -r 563557a923d0 python/setup.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/python/setup.py	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,44 @@
+#!/usr/bin/env python
+from distutils.core import setup, Extension
+
+setup(
+    name = 'zbar',
+    version = '0.10',
+    author = 'Jeff Brown',
+    author_email = 'spadix@users.sourceforge.net',
+    url = 'http://zbar.sourceforge.net',
+    description = 'read barcodes from images or video',
+    license = 'LGPL',
+    long_description = open('README').read(),
+    classifiers = [
+        'License :: OSI Approved :: GNU Library or Lesser General Public License (LGPL)',
+        'Development Status :: 4 - Beta',
+        'Intended Audience :: Developers',
+        'Environment :: Console',
+        'Environment :: X11 Applications',
+        'Environment :: Win32 (MS Windows)',
+        'Operating System :: POSIX',
+        'Operating System :: Unix',
+        'Operating System :: Microsoft :: Windows',
+        'Topic :: Communications',
+        'Topic :: Multimedia :: Graphics',
+        'Topic :: Software Development :: Libraries',
+    ],
+    ext_modules = [
+        Extension('zbar', [
+                'zbarmodule.c',
+                'enum.c',
+                'exception.c',
+                'symbol.c',
+                'symbolset.c',
+                'symboliter.c',
+                'image.c',
+                'processor.c',
+                'imagescanner.c',
+                'decoder.c',
+                'scanner.c',
+                ],
+            libraries = [ 'zbar' ],
+        ),
+    ],
+)
diff -r 563557a923d0 python/symbol.c
--- a/python/symbol.c	Tue Oct 27 11:25:59 2009 -0400
+++ b/python/symbol.c	Fri Feb 22 08:54:29 2013 -0300
@@ -1,5 +1,5 @@
 /*------------------------------------------------------------------------
- *  Copyright 2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *  Copyright 2009-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
  *
  *  This file is part of the ZBar Bar Code Reader.
  *
@@ -81,6 +81,22 @@
 }
 
 static PyObject*
+symbol_get_configs (zbarSymbol *self,
+                    void *closure)
+{
+    unsigned int mask = zbar_symbol_get_configs(self->zsym);
+    return(zbarEnum_SetFromMask(config_enum, mask));
+}
+
+static PyObject*
+symbol_get_modifiers (zbarSymbol *self,
+                      void *closure)
+{
+    unsigned int mask = zbar_symbol_get_modifiers(self->zsym);
+    return(zbarEnum_SetFromMask(modifier_enum, mask));
+}
+
+static PyObject*
 symbol_get_long (zbarSymbol *self,
                  void *closure)
 {
@@ -128,12 +144,23 @@
     return(self->loc);
 }
 
+static zbarEnumItem*
+symbol_get_orientation (zbarSymbol *self,
+                        void *closure)
+{
+    return(zbarEnum_LookupValue(orient_enum,
+                                zbar_symbol_get_orientation(self->zsym)));
+}
+
 static PyGetSetDef symbol_getset[] = {
     { "type",       (getter)symbol_get_type, },
+    { "configs",    (getter)symbol_get_configs, },
+    { "modifiers",  (getter)symbol_get_modifiers, },
     { "quality",    (getter)symbol_get_long, NULL, NULL, (void*)0 },
     { "count",      (getter)symbol_get_long, NULL, NULL, (void*)1 },
     { "data",       (getter)symbol_get_data, },
     { "location",   (getter)symbol_get_location, },
+    { "orientation",(getter)symbol_get_orientation, },
     { "components", (getter)symbol_get_components,  },
     { NULL, },
 };
diff -r 563557a923d0 python/test/test_zbar.py
--- a/python/test/test_zbar.py	Tue Oct 27 11:25:59 2009 -0400
+++ b/python/test/test_zbar.py	Fri Feb 22 08:54:29 2013 -0300
@@ -20,6 +20,9 @@
 encoded_widths = \
     '9 111 212241113121211311141132 11111 311213121312121332111132 111 9'
 
+databar_widths = \
+    '11 31111333 13911 31131231 11214222 11553 21231313 1'
+
 VIDEO_DEVICE = None
 if 'VIDEO_DEVICE' in os.environ:
     VIDEO_DEVICE = os.environ['VIDEO_DEVICE']
@@ -59,6 +62,7 @@
                     zbar.Config.ASCII,
                     zbar.Config.MIN_LEN,
                     zbar.Config.MAX_LEN,
+                    zbar.Config.UNCERTAINTY,
                     zbar.Config.POSITION,
                     zbar.Config.X_DENSITY,
                     zbar.Config.Y_DENSITY):
@@ -66,6 +70,13 @@
             self.assert_(int(cfg) >= 0)
             self.assert_(is_identifier.match(str(cfg)))
 
+    def test_modifiers(self):
+        for mod in (zbar.Modifier.GS1,
+                    zbar.Modifier.AIM):
+            self.assert_(isinstance(mod, zbar.EnumItem))
+            self.assert_(int(mod) >= 0)
+            self.assert_(is_identifier.match(str(mod)))
+
     def test_symbologies(self):
         for sym in (zbar.Symbol.NONE,
                     zbar.Symbol.PARTIAL,
@@ -75,15 +86,29 @@
                     zbar.Symbol.UPCA,
                     zbar.Symbol.EAN13,
                     zbar.Symbol.ISBN13,
+                    zbar.Symbol.DATABAR,
+                    zbar.Symbol.DATABAR_EXP,
                     zbar.Symbol.I25,
+                    zbar.Symbol.CODABAR,
                     zbar.Symbol.CODE39,
                     zbar.Symbol.PDF417,
                     zbar.Symbol.QRCODE,
+                    zbar.Symbol.CODE93,
                     zbar.Symbol.CODE128):
             self.assert_(isinstance(sym, zbar.EnumItem))
             self.assert_(int(sym) >= 0)
             self.assert_(is_identifier.match(str(sym)))
 
+    def test_orientations(self):
+        for orient in (zbar.Orient.UNKNOWN,
+                       zbar.Orient.UP,
+                       zbar.Orient.RIGHT,
+                       zbar.Orient.DOWN,
+                       zbar.Orient.LEFT):
+            self.assert_(isinstance(orient, zbar.EnumItem))
+            self.assert_(-1 <= int(orient) <= 3)
+            self.assert_(is_identifier.match(str(orient)))
+
 class TestScanner(ut.TestCase):
     def setUp(self):
         self.scn = zbar.Scanner()
@@ -135,6 +160,9 @@
             self.dcode.data = data
         self.assertRaises(AttributeError, set_data, 'yomama')
 
+        self.assertRaises(AttributeError,
+                          self.dcode.__setattr__, 'direction', -1)
+
     def test_width(self):
         sym = self.dcode.decode_width(5)
         self.assert_(sym is zbar.Symbol.NONE)
@@ -150,6 +178,7 @@
         self.assert_(self.dcode.color is zbar.BAR)
         self.dcode.reset()
         self.assert_(self.dcode.color is zbar.SPACE)
+        self.assertEqual(self.dcode.direction, 0)
 
     def test_decode(self):
         inline_sym = [ -1 ]
@@ -172,12 +201,33 @@
             else:
                 self.assert_(sym is zbar.Symbol.EAN13)
 
+        self.assertEqual(self.dcode.configs,
+                         set((zbar.Config.ENABLE, zbar.Config.EMIT_CHECK)))
+        self.assertEqual(self.dcode.modifiers, set())
         self.assertEqual(self.dcode.data, '6268964977804')
         self.assert_(self.dcode.color is zbar.BAR)
+        self.assertEqual(self.dcode.direction, 1)
         self.assert_(sym is zbar.Symbol.EAN13)
         self.assert_(inline_sym[0] is zbar.Symbol.EAN13)
         self.assertEqual(explicit_closure, [ 2 ])
 
+    def test_databar(self):
+        self.dcode.set_config(zbar.Symbol.QRCODE, zbar.Config.ENABLE, 0)
+        for (i, width) in enumerate(databar_widths):
+            if width == ' ': continue
+            sym = self.dcode.decode_width(int(width))
+            if i < len(databar_widths) - 1:
+                self.assert_(sym is zbar.Symbol.NONE or
+                             sym is zbar.Symbol.PARTIAL)
+
+        self.assert_(sym is zbar.Symbol.DATABAR)
+        self.assertEqual(self.dcode.get_configs(zbar.Symbol.EAN13),
+                         set((zbar.Config.ENABLE, zbar.Config.EMIT_CHECK)))
+        self.assertEqual(self.dcode.modifiers, set((zbar.Modifier.GS1,)))
+        self.assertEqual(self.dcode.data, '0124012345678905')
+        self.assert_(self.dcode.color is zbar.BAR)
+        self.assertEqual(self.dcode.direction, 1)
+
     # FIXME test exception during callback
 
 class TestImage(ut.TestCase):
@@ -194,11 +244,13 @@
     def test_new(self):
         self.assertEqual(self.image.format, 'Y800')
         self.assertEqual(self.image.size, (123, 456))
+        self.assertEqual(self.image.crop, (0, 0, 123, 456))
 
         image = zbar.Image()
         self.assert_(isinstance(image, zbar.Image))
         self.assertEqual(image.format, '\0\0\0\0')
         self.assertEqual(image.size, (0, 0))
+        self.assertEqual(image.crop, (0, 0, 0, 0))
 
     def test_format(self):
         def set_format(fmt):
@@ -231,6 +283,23 @@
         self.assertEqual(self.image.width, 81)
         self.assertEqual(self.image.height, 64)
 
+    def test_crop(self):
+        def set_crop(crp):
+            self.image.crop = crp
+        self.assertRaises(ValueError, set_crop, (1,))
+        self.assertRaises(ValueError, set_crop, 1)
+        self.image.crop = (1, 2, 100, 200)
+        self.assertRaises(ValueError, set_crop, (1, 2, 3, 4, 5))
+        self.assertEqual(self.image.crop, (1, 2, 100, 200))
+        self.assertRaises(ValueError, set_crop, "foo")
+        self.assertEqual(self.image.crop, (1, 2, 100, 200))
+        self.image.crop = (-100, -100, 400, 700)
+        self.assertEqual(self.image.crop, (0, 0, 123, 456))
+        self.image.crop = (40, 50, 60, 70)
+        self.assertEqual(self.image.crop, (40, 50, 60, 70))
+        self.image.size = (82, 65)
+        self.assertEqual(self.image.crop, (0, 0, 82, 65))
+
 class TestImageScanner(ut.TestCase):
     def setUp(self):
         self.scn = zbar.ImageScanner()
@@ -289,6 +358,20 @@
             self.assert_(sym.type is zbar.Symbol.EAN13)
             self.assert_(sym.type is sym.EAN13)
             self.assertEqual(str(sym.type), 'EAN13')
+
+            cfgs = sym.configs
+            self.assert_(isinstance(cfgs, set))
+            for cfg in cfgs:
+                self.assert_(isinstance(cfg, zbar.EnumItem))
+            self.assertEqual(cfgs,
+                             set((zbar.Config.ENABLE, zbar.Config.EMIT_CHECK)))
+
+            mods = sym.modifiers
+            self.assert_(isinstance(mods, set))
+            for mod in mods:
+                self.assert_(isinstance(mod, zbar.EnumItem))
+            self.assertEqual(mods, set())
+
             self.assert_(sym.quality > 0)
             self.assertEqual(sym.count, 0)
 
@@ -310,6 +393,7 @@
                 self.assertEqual(len(pt), 2)
                 # FIXME test values (API currently in flux)
 
+            self.assert_(sym.orientation is zbar.Orient.UP)
             self.assert_(data is sym.data)
             self.assert_(loc is sym.location)
 
@@ -320,6 +404,21 @@
         self.scn.recycle(self.image)
         self.assertEqual(len(self.image.symbols), 0)
 
+    def test_scan_crop(self):
+        self.image.crop = (0, 71, 114, 9)
+        self.assertEqual(self.image.crop, (0, 71, 114, 9))
+        n = self.scn.scan(self.image)
+        self.assertEqual(n, 0)
+
+        self.image.crop = (12, 24, 90, 12)
+        self.assertEqual(self.image.crop, (12, 24, 90, 12))
+        n = self.scn.scan(self.image)
+        self.assertEqual(n, 0)
+
+        self.image.crop = (9, 24, 96, 12)
+        self.assertEqual(self.image.crop, (9, 24, 96, 12))
+        self.test_scan()
+
     def test_scan_again(self):
         self.test_scan()
 
@@ -351,6 +450,15 @@
         self.assertRaises(ValueError, self.proc.set_config, -1)
         self.proc.set_config()
 
+    def test_request_size(self):
+        def set_size(sz):
+            self.proc.request_size = sz
+        self.assertRaises(ValueError, set_size, (1,))
+        self.assertRaises(ValueError, set_size, 1)
+        self.proc.request_size = (12, 6)
+        self.assertRaises(ValueError, set_size, (1, 2, 3))
+        self.assertRaises(ValueError, set_size, "foo")
+
     def test_processing(self):
         self.proc.init(VIDEO_DEVICE)
         self.assert_(self.proc.visible is False)
@@ -370,13 +478,14 @@
             symiter = iter(image)
             self.assert_(isinstance(symiter, zbar.SymbolIter))
 
-            symbols = tuple(image)
-            self.assertEqual(len(symbols), 1)
-            for symbol in symbols:
-                self.assert_(isinstance(symbol, zbar.Symbol))
-                self.assert_(symbol.type is zbar.Symbol.EAN13)
-                self.assertEqual(symbol.data, '9876543210128')
-                self.assert_(symbol.quality > 0)
+            syms = tuple(image)
+            self.assertEqual(len(syms), 1)
+            for sym in syms:
+                self.assert_(isinstance(sym, zbar.Symbol))
+                self.assert_(sym.type is zbar.Symbol.EAN13)
+                self.assertEqual(sym.data, '9876543210128')
+                self.assert_(sym.quality > 0)
+                self.assert_(sym.orientation is zbar.Orient.UP)
             closure[0] += 1
 
         explicit_closure = [ 0 ]
diff -r 563557a923d0 python/zbarmodule.c
--- a/python/zbarmodule.c	Tue Oct 27 11:25:59 2009 -0400
+++ b/python/zbarmodule.c	Fri Feb 22 08:54:29 2013 -0300
@@ -1,5 +1,5 @@
 /*------------------------------------------------------------------------
- *  Copyright 2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *  Copyright 2009-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
  *
  *  This file is part of the ZBar Bar Code Reader.
  *
@@ -23,6 +23,11 @@
 
 #include "zbarmodule.h"
 
+typedef struct enumdef {
+    const char *strval;
+    int intval;
+} enumdef;
+
 static char *exc_names[] = {
     "zbar.Exception",
     NULL,
@@ -38,6 +43,56 @@
     "zbar.WinAPIError",
 };
 
+static const enumdef symbol_defs[] = {
+    { "NONE",           ZBAR_NONE },
+    { "PARTIAL",        ZBAR_PARTIAL },
+    { "EAN8",           ZBAR_EAN8 },
+    { "UPCE",           ZBAR_UPCE },
+    { "ISBN10",         ZBAR_ISBN10 },
+    { "UPCA",           ZBAR_UPCA },
+    { "EAN13",          ZBAR_EAN13 },
+    { "ISBN13",         ZBAR_ISBN13 },
+    { "DATABAR",        ZBAR_DATABAR },
+    { "DATABAR_EXP",    ZBAR_DATABAR_EXP },
+    { "I25",            ZBAR_I25 },
+    { "CODABAR",        ZBAR_CODABAR },
+    { "CODE39",         ZBAR_CODE39 },
+    { "PDF417",         ZBAR_PDF417 },
+    { "QRCODE",         ZBAR_QRCODE },
+    { "CODE93",         ZBAR_CODE93 },
+    { "CODE128",        ZBAR_CODE128 },
+    { NULL, }
+};
+
+static const enumdef config_defs[] = {
+    { "ENABLE",         ZBAR_CFG_ENABLE },
+    { "ADD_CHECK",      ZBAR_CFG_ADD_CHECK },
+    { "EMIT_CHECK",     ZBAR_CFG_EMIT_CHECK },
+    { "ASCII",          ZBAR_CFG_ASCII },
+    { "MIN_LEN",        ZBAR_CFG_MIN_LEN },
+    { "MAX_LEN",        ZBAR_CFG_MAX_LEN },
+    { "UNCERTAINTY",    ZBAR_CFG_UNCERTAINTY },
+    { "POSITION",       ZBAR_CFG_POSITION },
+    { "X_DENSITY",      ZBAR_CFG_X_DENSITY },
+    { "Y_DENSITY",      ZBAR_CFG_Y_DENSITY },
+    { NULL, }
+};
+
+static const enumdef modifier_defs[] = {
+    { "GS1",            ZBAR_MOD_GS1 },
+    { "AIM",            ZBAR_MOD_AIM },
+    { NULL, }
+};
+
+static const enumdef orient_defs[] = {
+    { "UNKNOWN",        ZBAR_ORIENT_UNKNOWN },
+    { "UP",             ZBAR_ORIENT_UP },
+    { "RIGHT",          ZBAR_ORIENT_RIGHT },
+    { "DOWN",           ZBAR_ORIENT_DOWN },
+    { "LEFT",           ZBAR_ORIENT_LEFT },
+    { NULL, }
+};
+
 int
 object_to_bool (PyObject *obj,
                 int *val)
@@ -49,11 +104,35 @@
     return(1);
 }
 
+int
+parse_dimensions (PyObject *seq,
+                  int *dims,
+                  int n)
+{
+    if(!PySequence_Check(seq) ||
+       PySequence_Size(seq) != n)
+        return(-1);
+
+    int i;
+    for(i = 0; i < n; i++, dims++) {
+        PyObject *dim = PySequence_GetItem(seq, i);
+        if(!dim)
+            return(-1);
+        *dims = PyInt_AsSsize_t(dim);
+        Py_DECREF(dim);
+        if(*dims == -1 && PyErr_Occurred())
+            return(-1);
+    }
+    return(0);
+}
+
 PyObject *zbar_exc[ZBAR_ERR_NUM];
 zbarEnumItem *color_enum[2];
 zbarEnum *config_enum;
+zbarEnum *modifier_enum;
 PyObject *symbol_enum;
 zbarEnumItem *symbol_NONE;
+zbarEnum *orient_enum;
 
 static PyObject*
 version (PyObject *self,
@@ -105,12 +184,6 @@
 PyMODINIT_FUNC
 initzbar (void)
 {
-    /* initialize constant containers */
-    config_enum = zbarEnum_New();
-    symbol_enum = PyDict_New();
-    if(!config_enum || !symbol_enum)
-        return;
-
     /* initialize types */
     zbarEnumItem_Type.tp_base = &PyInt_Type;
     zbarException_Type.tp_base = (PyTypeObject*)PyExc_Exception;
@@ -128,6 +201,14 @@
        PyType_Ready(&zbarScanner_Type) < 0)
         return;
 
+    /* initialize constant containers */
+    config_enum = zbarEnum_New();
+    modifier_enum = zbarEnum_New();
+    symbol_enum = PyDict_New();
+    orient_enum = zbarEnum_New();
+    if(!config_enum || !modifier_enum || !symbol_enum || !orient_enum)
+        return;
+
     zbar_exc[0] = (PyObject*)&zbarException_Type;
     zbar_exc[ZBAR_ERR_NOMEM] = NULL;
     zbar_error_t ei;
@@ -151,6 +232,8 @@
     PyModule_AddObject(mod, "EnumItem", (PyObject*)&zbarEnumItem_Type);
     PyModule_AddObject(mod, "Image", (PyObject*)&zbarImage_Type);
     PyModule_AddObject(mod, "Config", (PyObject*)config_enum);
+    PyModule_AddObject(mod, "Modifier", (PyObject*)modifier_enum);
+    PyModule_AddObject(mod, "Orient", (PyObject*)orient_enum);
     PyModule_AddObject(mod, "Symbol", (PyObject*)&zbarSymbol_Type);
     PyModule_AddObject(mod, "SymbolSet", (PyObject*)&zbarSymbolSet_Type);
     PyModule_AddObject(mod, "SymbolIter", (PyObject*)&zbarSymbolIter_Type);
@@ -170,29 +253,16 @@
     color_enum[ZBAR_BAR] =
         zbarEnumItem_New(dict, NULL, ZBAR_BAR, "BAR");
 
-    zbarEnum_Add(config_enum, ZBAR_CFG_ENABLE,     "ENABLE");
-    zbarEnum_Add(config_enum, ZBAR_CFG_ADD_CHECK,  "ADD_CHECK");
-    zbarEnum_Add(config_enum, ZBAR_CFG_EMIT_CHECK, "EMIT_CHECK");
-    zbarEnum_Add(config_enum, ZBAR_CFG_ASCII,      "ASCII");
-    zbarEnum_Add(config_enum, ZBAR_CFG_MIN_LEN,    "MIN_LEN");
-    zbarEnum_Add(config_enum, ZBAR_CFG_MAX_LEN,    "MAX_LEN");
-    zbarEnum_Add(config_enum, ZBAR_CFG_X_DENSITY,  "POSITION");
-    zbarEnum_Add(config_enum, ZBAR_CFG_X_DENSITY,  "X_DENSITY");
-    zbarEnum_Add(config_enum, ZBAR_CFG_Y_DENSITY,  "Y_DENSITY");
+    const enumdef *item;
+    for(item = config_defs; item->strval; item++)
+        zbarEnum_Add(config_enum, item->intval, item->strval);
+    for(item = modifier_defs; item->strval; item++)
+        zbarEnum_Add(modifier_enum, item->intval, item->strval);
+    for(item = orient_defs; item->strval; item++)
+        zbarEnum_Add(orient_enum, item->intval, item->strval);
 
     PyObject *tp_dict = zbarSymbol_Type.tp_dict;
-    symbol_NONE =
-        zbarEnumItem_New(tp_dict, symbol_enum, ZBAR_NONE, "NONE");
-    zbarEnumItem_New(tp_dict, symbol_enum, ZBAR_PARTIAL, "PARTIAL");
-    zbarEnumItem_New(tp_dict, symbol_enum, ZBAR_EAN8,    "EAN8");
-    zbarEnumItem_New(tp_dict, symbol_enum, ZBAR_UPCE,    "UPCE");
-    zbarEnumItem_New(tp_dict, symbol_enum, ZBAR_ISBN10,  "ISBN10");
-    zbarEnumItem_New(tp_dict, symbol_enum, ZBAR_UPCA,    "UPCA");
-    zbarEnumItem_New(tp_dict, symbol_enum, ZBAR_EAN13,   "EAN13");
-    zbarEnumItem_New(tp_dict, symbol_enum, ZBAR_ISBN13,  "ISBN13");
-    zbarEnumItem_New(tp_dict, symbol_enum, ZBAR_I25,     "I25");
-    zbarEnumItem_New(tp_dict, symbol_enum, ZBAR_CODE39,  "CODE39");
-    zbarEnumItem_New(tp_dict, symbol_enum, ZBAR_PDF417,  "PDF417");
-    zbarEnumItem_New(tp_dict, symbol_enum, ZBAR_QRCODE,  "QRCODE");
-    zbarEnumItem_New(tp_dict, symbol_enum, ZBAR_CODE128, "CODE128");
+    for(item = symbol_defs; item->strval; item++)
+        zbarEnumItem_New(tp_dict, symbol_enum, item->intval, item->strval);
+    symbol_NONE = zbarSymbol_LookupEnum(ZBAR_NONE);
 }
diff -r 563557a923d0 python/zbarmodule.h
--- a/python/zbarmodule.h	Tue Oct 27 11:25:59 2009 -0400
+++ b/python/zbarmodule.h	Fri Feb 22 08:54:29 2013 -0300
@@ -1,5 +1,5 @@
 /*------------------------------------------------------------------------
- *  Copyright 2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *  Copyright 2009-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
  *
  *  This file is part of the ZBar Bar Code Reader.
  *
@@ -61,6 +61,10 @@
 extern int zbarEnum_Add(zbarEnum *self,
                          int val,
                          const char *name);
+extern zbarEnumItem *zbarEnum_LookupValue(zbarEnum *self,
+                                          int val);
+extern PyObject *zbarEnum_SetFromMask(zbarEnum *self,
+                                      unsigned int mask);
 
 typedef struct {
     PyObject_HEAD
@@ -144,10 +148,15 @@
 
 extern zbarEnumItem *color_enum[2];
 extern zbarEnum *config_enum;
+extern zbarEnum *modifier_enum;
 extern PyObject *symbol_enum;
 extern zbarEnumItem *symbol_NONE;
+extern zbarEnum *orient_enum;
 
-int object_to_bool(PyObject *obj,
-                   int *val);
+extern int object_to_bool(PyObject *obj,
+                          int *val);
+extern int parse_dimensions(PyObject *seq,
+                            int *dims,
+                            int n);
 
 #endif
diff -r 563557a923d0 qt/QZBarThread.cpp
--- a/qt/QZBarThread.cpp	Tue Oct 27 11:25:59 2009 -0400
+++ b/qt/QZBarThread.cpp	Fri Feb 22 08:54:29 2013 -0300
@@ -26,7 +26,7 @@
 
 using namespace zbar;
 
-static const QString textFormat("%1%2:%3");
+static const QString textFormat("%1:%2");
 
 QZBarThread::QZBarThread ()
     : _videoOpened(false),
@@ -52,7 +52,6 @@
 
             emit decodedText(textFormat.arg(
                 QString::fromStdString(sym->get_type_name()),
-                QString::fromStdString(sym->get_addon_name()),
                 data));
         }
 }
@@ -168,7 +167,7 @@
 
 bool QZBarThread::event (QEvent *e)
 {
-    switch(e->type()) {
+    switch((EventType)e->type()) {
     case VideoDevice:
         videoDeviceEvent((VideoDeviceEvent*)e);
         break;
diff -r 563557a923d0 test/Makefile.am.inc
--- a/test/Makefile.am.inc	Tue Oct 27 11:25:59 2009 -0400
+++ b/test/Makefile.am.inc	Fri Feb 22 08:54:29 2013 -0300
@@ -28,6 +28,10 @@
 test_test_cpp_SOURCES = test/test_cpp.cpp
 test_test_cpp_LDADD = zbar/libzbar.la $(AM_LDADD)
 
+check_PROGRAMS += test/test_cpp_img
+test_test_cpp_img_SOURCES = test/test_cpp_img.cpp $(TEST_IMAGE_SOURCES)
+test_test_cpp_img_LDADD = zbar/libzbar.la $(AM_LDADD)
+
 if HAVE_JPEG
 check_PROGRAMS += test/test_jpeg
 test_test_jpeg_SOURCES = test/test_jpeg.c
@@ -67,3 +71,17 @@
 CLEANFILES += test/.libs/test_decode test/.libs/test_proc \
     test/.libs/test_convert test/.libs/test_window \
     test/.libs/test_video test/.libs/dbg_scan test/.libs/test_gtk
+
+check-cpp: test/test_cpp_img
+	test/test_cpp_img
+
+check-decoder: test/test_decode
+	test/test_decode -q
+
+regress-decoder: test/test_decode
+	test/test_decode -n 100000
+
+check-local: check-cpp check-decoder check-images
+regress: regress-decoder regress-images
+
+.PHONY: check-cpp check-decoder check-images regress-decoder regress-images regress
diff -r 563557a923d0 test/barcodetest.py
--- a/test/barcodetest.py	Tue Oct 27 11:25:59 2009 -0400
+++ b/test/barcodetest.py	Fri Feb 22 08:54:29 2013 -0300
@@ -66,7 +66,7 @@
         import re
         makefile = open('Makefile')
         for line in makefile:
-            if re.match('^VPATH\s*=', line):
+            if re.match(r'^VPATH\s*=', line):
                 vpath = line.split('=', 1)[1].strip()
                 if vpath and vpath != rundir:
                     search.append(vpath)
@@ -124,6 +124,8 @@
     assert rc in (0, 4), \
            'zbarimg returned error status (%d)\n' % rc + err
 
+    assert not err, err
+
     result = ET.XML(xml)
     assert result.tag == ET.QName(BC, 'barcodes')
     return result
@@ -167,7 +169,8 @@
             href = 'http://zbar.sf.net/test/barcode.png'
 
         self.source = src = ET.Element(ET.QName(BC, 'source'), href=href)
-        sym = ET.SubElement(src, ET.QName(BC, 'symbol'), type='EAN-13')
+        sym = ET.SubElement(src, ET.QName(BC, 'symbol'), type='EAN-13',
+                            orientation='UP')
         data = ET.SubElement(sym, ET.QName(BC, 'data'))
         data.text = '9876543210128'
 
@@ -258,8 +261,9 @@
 
 
 def compare_symbols(expect, actual):
-    pass
-
+    orient = expect.get('orientation')
+    if orient:
+        assert actual.get('orientation') == orient
 
 # override unittest.TestLoader to populate tests from xml description
 class TestLoader:
@@ -348,7 +352,10 @@
                 continue
             if src.tag == ET.QName(BC, 'source'):
                 test = TestCase()
-                src.set('href', urljoin(url, href))
+                # convert file URLs to filesystem paths
+                href = urljoin(url, href)
+                href = re.sub(r'^file://', '', href)
+                src.set('href', href)
                 test.source = src
                 suite.addTest(test)
             elif src.tag == ET.QName(TS, 'index'):
diff -r 563557a923d0 test/test_cpp_img.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/test/test_cpp_img.cpp	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,235 @@
+//------------------------------------------------------------------------
+//  Copyright 2007-2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+//
+//  This file is part of the ZBar Bar Code Reader.
+//
+//  The ZBar Bar Code Reader is free software; you can redistribute it
+//  and/or modify it under the terms of the GNU Lesser Public License as
+//  published by the Free Software Foundation; either version 2.1 of
+//  the License, or (at your option) any later version.
+//
+//  The ZBar Bar Code Reader is distributed in the hope that it will be
+//  useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+//  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//  GNU Lesser Public License for more details.
+//
+//  You should have received a copy of the GNU Lesser Public License
+//  along with the ZBar Bar Code Reader; if not, write to the Free
+//  Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+//  Boston, MA  02110-1301  USA
+//
+//  http://sourceforge.net/projects/zbar
+//------------------------------------------------------------------------
+
+// NB do not put anything before this header
+// it's here to check that we didn't omit any dependencies
+#include <zbar.h>
+
+#include <iostream>
+#include <sstream>
+#include <iomanip>
+#include "test_images.h"
+
+bool debug = false;
+bool verbose = false;
+int errors = 0;
+zbar::zbar_symbol_type_t expect_type = zbar::ZBAR_NONE;
+std::string expect_data;
+
+template <class T>
+inline std::string to_string (const T& t)
+{
+    std::stringstream ss;
+    ss << t;
+    return ss.str();
+}
+
+static inline int
+error (const std::string &msg)
+{
+    errors++;
+    std::cerr << "ERROR: " << msg << std::endl;
+    if(debug)
+        abort();
+    return(-1);
+}
+
+static inline int
+check_loc (const zbar::Image &img,
+           const zbar::Symbol &sym)
+{
+    int n = 0;
+    int w = img.get_width();
+    int h = img.get_height();
+    for(zbar::Symbol::PointIterator p(sym.point_begin());
+        p != sym.point_end();
+        ++p, n++)
+    {
+        zbar::Symbol::Point q(*p);
+        if(q.x < 0 || q.x >= w ||
+           q.y < 0 || q.y >= h)
+            error("location point out of range");
+    }
+    return(!n);
+}
+
+static inline int
+check_symbol (const zbar::Image &img,
+              const zbar::Symbol &sym)
+{
+    zbar::zbar_symbol_type_t type(sym.get_type());
+    std::string data(sym.get_data());
+
+    bool pass =
+        expect_type &&
+        type == expect_type &&
+        data == expect_data &&
+        sym.get_data_length() == expect_data.length() &&
+        sym.get_quality() > 4;
+    if(pass)
+        pass = !check_loc(img, sym);
+
+    if(verbose || !pass)
+        std::cerr << "decode Symbol: " << sym << std::endl;
+
+    if(!expect_type)
+        error("unexpected");
+    else if(!pass)
+        error(std::string("expected: ") +
+              zbar::zbar_get_symbol_name(expect_type) +
+              " " + expect_data);
+
+    expect_type = zbar::ZBAR_NONE;
+    expect_data = "";
+    return(!pass);
+}
+
+static inline int
+check_image (const zbar::Image &img)
+{
+    zbar::SymbolSet syms(img.get_symbols());
+    int setn = syms.get_size(), countn = 0;
+
+    int rc = 0;
+    for(zbar::SymbolIterator sym(syms.symbol_begin());
+        sym != syms.symbol_end();
+        ++sym, ++countn)
+        rc |= check_symbol(img, *sym);
+
+    if(countn != setn)
+        rc |= error("SymbolSet size mismatch: exp=" + to_string(setn) +
+                    " act=" + to_string(countn));
+    return(rc);
+}
+
+static inline void
+expect (zbar::zbar_symbol_type_t type,
+        std::string data)
+{
+    if(expect_type)
+        error(std::string("missing: ") + zbar_get_symbol_name(expect_type) +
+              " " + expect_data);
+    expect_type = type;
+    expect_data = data;
+}
+
+class Handler : public zbar::Image::Handler {
+    void image_callback(zbar::Image &img);
+};
+
+void
+Handler::image_callback (zbar::Image &img)
+{
+    bool unexpected = !expect_type;
+    if(unexpected)
+        error("unexpected image callback");
+    check_image(img);
+}
+
+static inline int
+test_processor ()
+{
+    // create processor w/no video and no window
+    zbar::Processor proc(debug, NULL);
+    Handler handler;
+    proc.set_handler(handler);
+    if(debug) {
+        proc.set_visible();
+        proc.user_wait();
+    }
+
+    // generate barcode test image
+    zbar::Image rgb3(0, 0, "RGB3");
+
+    // test cast to C image
+    if(test_image_ean13(rgb3))
+        error("failed to generate image");
+
+    // test decode
+    expect(zbar::ZBAR_EAN13, test_image_ean13_data);
+    proc.process_image(rgb3);
+    if(debug)
+        proc.user_wait();
+
+    expect(zbar::ZBAR_EAN13, test_image_ean13_data);
+    check_image(rgb3);
+
+    if(rgb3.get_format() != zbar_fourcc('R','G','B','3'))
+        error("image format mismatch");
+
+    expect(zbar::ZBAR_NONE, "");
+    proc.set_config(zbar::ZBAR_EAN13,
+                    zbar::ZBAR_CFG_ENABLE,
+                    false);
+    proc.process_image(rgb3);
+    check_image(rgb3);
+    if(debug)
+        proc.user_wait();
+
+    proc.set_config("ean13.en");
+    expect(zbar::ZBAR_EAN13, test_image_ean13_data);
+    proc << rgb3;
+    expect(zbar::ZBAR_EAN13, test_image_ean13_data);
+    check_image(rgb3);
+    if(debug)
+        proc.user_wait();
+
+    {
+        zbar::Image grey(rgb3.convert(zbar_fourcc('G','R','E','Y')));
+        expect(zbar::ZBAR_EAN13, test_image_ean13_data);
+        proc << grey;
+
+        zbar::Image y800 = grey.convert("Y800");
+        expect(zbar::ZBAR_EAN13, test_image_ean13_data);
+        proc << y800;
+    }
+    if(debug)
+        // check image data retention
+        proc.user_wait();
+
+    expect(zbar::ZBAR_NONE, "");
+    return(0);
+}
+
+int main (int argc, char **argv)
+{
+    debug = (argc > 1 && std::string(argv[1]) == "-d");
+    verbose = (debug || (argc > 1 && std::string(argv[1]) == "-v"));
+
+    if(test_processor()) {
+        error("ERROR: Processor test FAILED");
+        return(2);
+    }
+
+    if(test_image_check_cleanup())
+        error("cleanup failed");
+
+    if(errors) {
+        std::cout << "FAIL" << std::endl;
+        return(2);
+    }
+    else {
+        std::cout << "OK" << std::endl;
+        return(0);
+    }
+}
diff -r 563557a923d0 test/test_decode.c
--- a/test/test_decode.c	Tue Oct 27 11:25:59 2009 -0400
+++ b/test/test_decode.c	Fri Feb 22 08:54:29 2013 -0300
@@ -22,33 +22,86 @@
  *------------------------------------------------------------------------*/
 
 #include <inttypes.h>
+#include <limits.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <string.h>
+#include <ctype.h>
+#include <time.h>
 #include <assert.h>
 
 #include <zbar.h>
 
 zbar_decoder_t *decoder;
 
+zbar_symbol_type_t expect_sym;
+char *expect_data = NULL;
+
+unsigned seed = 0;
+int verbosity = 1;
+int rnd_size = 9;  /* NB should be odd */
+int iter = 0;      /* test iteration */
+
+#define zprintf(level, format, ...) do {                                \
+        if(verbosity >= (level)) {                                      \
+            fprintf(stderr, format , ##__VA_ARGS__); \
+        }                                                               \
+    } while(0)
+
+static inline void print_sep (int level)
+{
+    zprintf(level,
+            "----------------------------------------------------------\n");
+}
+
 static void symbol_handler (zbar_decoder_t *decoder)
 {
     zbar_symbol_type_t sym = zbar_decoder_get_type(decoder);
-    if(sym <= ZBAR_PARTIAL)
+    if(sym <= ZBAR_PARTIAL || sym == ZBAR_QRCODE)
         return;
-    printf("%s%s:%s\n",
-           zbar_get_symbol_name(sym),
-           zbar_get_addon_name(sym),
-           zbar_decoder_get_data(decoder));
-    /* FIXME add check! */
+    const char *data = zbar_decoder_get_data(decoder);
+
+    int pass = (sym == expect_sym) && !strcmp(data, expect_data) &&
+        zbar_decoder_get_data_length(decoder) == strlen(data);
+    pass *= 3;
+
+    zprintf(pass, "decode %s:%s\n", zbar_get_symbol_name(sym), data);
+
+    if(!expect_sym)
+        zprintf(0, "UNEXPECTED!\n");
+    else
+        zprintf(pass, "expect %s:%s\n", zbar_get_symbol_name(expect_sym),
+                expect_data);
+    if(!pass) {
+        zprintf(0, "SEED=%d\n", seed);
+        abort();
+    }
+
+    expect_sym = ZBAR_NONE;
+    free(expect_data);
+    expect_data = NULL;
+}
+
+static void expect (zbar_symbol_type_t sym,
+                    const char *data)
+{
+    if(expect_sym) {
+        zprintf(0, "MISSING %s:%s\n"
+                "SEED=%d\n",
+                zbar_get_symbol_name(expect_sym), expect_data, seed);
+        abort();
+    }
+    expect_sym = sym;
+    expect_data = (data) ? strdup(data) : NULL;
 }
 
 static void encode_junk (int n)
 {
-    printf("encode random junk...\n");
+    if(n > 1)
+        zprintf(3, "encode random junk...\n");
     int i;
     for(i = 0; i < n; i++)
-        zbar_decode_width(decoder, 10. * (rand() / (RAND_MAX + 1.)));
+        zbar_decode_width(decoder, 20. * (rand() / (RAND_MAX + 1.)) + 1);
 }
 
 #define FWD 1
@@ -57,8 +110,8 @@
 static void encode (uint64_t units,
                     int fwd)
 {
-    printf(" raw=%x%x%c\n", (unsigned)(units >> 32),
-           (unsigned)(units & 0xffffffff), (fwd) ? '<' : '>');
+    zprintf(3, " raw=%x%x%c\n", (unsigned)(units >> 32),
+            (unsigned)(units & 0xffffffff), (fwd) ? '<' : '>');
     if(!fwd)
         while(units && !(units >> 0x3c))
             units <<= 4;
@@ -122,47 +175,188 @@
     0x2331112a,                             /* STOP (6a) */
 };
 
-static void encode_code128b (unsigned char *data)
+static void encode_code128b (char *data)
 {
-    printf("------------------------------------------------------------\n"
-           "encode CODE-128(B): %s\n"
-           "    encode START_B: %02x", data, START_B);
+    assert(zbar_decoder_get_color(decoder) == ZBAR_SPACE);
+    print_sep(3);
+    zprintf(2, "CODE-128(B): %s\n", data);
+    zprintf(3, "    encode START_B: %02x", START_B);
     encode(code128[START_B], 0);
     int i, chk = START_B;
     for(i = 0; data[i]; i++) {
-        printf("    encode '%c': %02x", data[i], data[i] - 0x20);
+        zprintf(3, "    encode '%c': %02x", data[i], data[i] - 0x20);
         encode(code128[data[i] - 0x20], 0);
         chk += (i + 1) * (data[i] - 0x20);
     }
     chk %= 103;
-    printf("    encode checksum: %02x", chk);
+    zprintf(3, "    encode checksum: %02x", chk);
     encode(code128[chk], 0);
-    printf("    encode STOP: %02x", STOP);
+    zprintf(3, "    encode STOP: %02x", STOP);
     encode(code128[STOP], 0);
-    printf("------------------------------------------------------------\n");
+    print_sep(3);
 }
 
-static void encode_code128c (unsigned char *data)
+static void encode_code128c (char *data)
 {
-    printf("------------------------------------------------------------\n"
-           "encode CODE-128(C): %s\n"
-           "    encode START_C: %02x", data, START_C);
+    assert(zbar_decoder_get_color(decoder) == ZBAR_SPACE);
+    print_sep(3);
+    zprintf(2, "CODE-128(C): %s\n", data);
+    zprintf(3, "    encode START_C: %02x", START_C);
     encode(code128[START_C], 0);
     int i, chk = START_C;
     for(i = 0; data[i]; i += 2) {
         assert(data[i] >= '0');
         assert(data[i + 1] >= '0');
         unsigned char c = (data[i] - '0') * 10 + (data[i + 1] - '0');
-        printf("    encode '%c%c': %02d", data[i], data[i + 1], c);
+        zprintf(3, "    encode '%c%c': %02d", data[i], data[i + 1], c);
         encode(code128[c], 0);
         chk += (i / 2 + 1) * c;
     }
     chk %= 103;
-    printf("    encode checksum: %02x", chk);
+    zprintf(3, "    encode checksum: %02x", chk);
     encode(code128[chk], 0);
-    printf("    encode STOP: %02x", STOP);
+    zprintf(3, "    encode STOP: %02x", STOP);
     encode(code128[STOP], 0);
-    printf("------------------------------------------------------------\n");
+    print_sep(3);
+}
+
+/*------------------------------------------------------------*/
+/* Code 93 encoding */
+
+#define CODE93_START_STOP 0x2f
+
+static const unsigned int code93[47 + 1] = {
+    0x131112, 0x111213, 0x111312, 0x111411, /* 00 */
+    0x121113, 0x121212, 0x121311, 0x111114,
+    0x131211, 0x141111, 0x211113, 0x211212, /* 08 */
+    0x211311, 0x221112, 0x221211, 0x231111,
+    0x112113, 0x112212, 0x112311, 0x122112, /* 10 */
+    0x132111, 0x111123, 0x111222, 0x111321,
+    0x121122, 0x131121, 0x212112, 0x212211, /* 18 */
+    0x211122, 0x211221, 0x221121, 0x222111,
+    0x112122, 0x112221, 0x122121, 0x123111, /* 20 */
+    0x121131, 0x311112, 0x311211, 0x321111,
+    0x112131, 0x113121, 0x211131, 0x121221, /* 28 */
+    0x312111, 0x311121, 0x122211,
+    0x111141,                               /* START/STOP (2f) */
+};
+
+#define S1 0x2b00|
+#define S2 0x2c00|
+#define S3 0x2d00|
+#define S4 0x2e00|
+
+static const unsigned short code93_ext[0x80] = {
+    S2'U', S1'A', S1'B', S1'C', S1'D', S1'E', S1'F', S1'G',
+    S1'H', S1'I', S1'J', S1'K', S1'L', S1'M', S1'N', S1'O',
+    S1'P', S1'Q', S1'R', S1'S', S1'T', S1'U', S1'V', S1'W',
+    S1'X', S1'Y', S1'Z', S2'A', S2'B', S2'C', S2'D', S2'E',
+    0x26,  S3'A', S3'B', S3'C', 0x27,  0x2a,  S3'F', S3'G',
+    S3'H', S3'I', S3'J', 0x29,  S3'L', 0x24,  0x25,  0x28,
+    0x00,  0x01,  0x02,  0x03,  0x04,  0x05,  0x06,  0x07,
+    0x08,  0x09,  S3'Z', S2'F', S2'G', S2'H', S2'I', S2'J',
+    S2'V', 0x0a,  0x0b,  0x0c,  0x0d,  0x0e,  0x0f,  0x10,
+    0x11,  0x12,  0x13,  0x14,  0x15,  0x16,  0x17,  0x18,
+    0x19,  0x1a,  0x1b,  0x1c,  0x1d,  0x1e,  0x1f,  0x20,
+    0x21,  0x22,  0x23,  S2'K', S2'L', S2'M', S2'N', S2'O',
+    S2'W', S4'A', S4'B', S4'C', S4'D', S4'E', S4'F', S4'G',
+    S4'H', S4'I', S4'J', S4'K', S4'L', S4'M', S4'N', S4'O',
+    S4'P', S4'Q', S4'R', S4'S', S4'T', S4'U', S4'V', S4'W',
+    S4'X', S4'Y', S4'Z', S2'P', S2'Q', S2'R', S2'S', S2'T',
+};
+
+#undef S1
+#undef S2
+#undef S3
+#undef S4
+
+static void encode_char93 (unsigned char c,
+                           int dir)
+{
+    unsigned ext = code93_ext[c];
+    unsigned shift = ext >> 8;
+    assert(shift < 0x30);
+    c = ext & 0xff;
+    if(shift) {
+        assert(c < 0x80);
+        c = code93_ext[c];
+    }
+    assert(c < 0x30);
+
+    if(shift) {
+        encode(code93[(dir) ? shift : c], dir ^ 1);
+        encode(code93[(dir) ? c : shift], dir ^ 1);
+    }
+    else
+        encode(code93[c], dir ^ 1);
+}
+
+static void encode_code93 (char *data,
+                           int dir)
+{
+    assert(zbar_decoder_get_color(decoder) == ZBAR_SPACE);
+    print_sep(3);
+
+    /* calculate checksums */
+    int i, j, chk_c = 0, chk_k = 0, n = 0;
+    for(i = 0; data[i]; i++, n++) {
+        unsigned c = data[i], ext;
+        assert(c < 0x80);
+        ext = code93_ext[c];
+        n += ext >> 13;
+    }
+
+    for(i = 0, j = 0; data[i]; i++, j++) {
+        unsigned ext = code93_ext[(unsigned)data[i]];
+        unsigned shift = ext >> 8;
+        unsigned c = ext & 0xff;
+        if(shift) {
+            chk_c += shift * (((n - 1 - j) % 20) + 1);
+            chk_k += shift * (((n - j) % 15) + 1);
+            j++;
+            c = code93_ext[c];
+        }
+        chk_c += c * (((n - 1 - j) % 20) + 1);
+        chk_k += c * (((n - j) % 15) + 1);
+    }
+    chk_c %= 47;
+    chk_k += chk_c;
+    chk_k %= 47;
+
+    zprintf(2, "CODE-93: %s (n=%x C=%02x K=%02x)\n", data, n, chk_c, chk_k);
+    encode(0xa, 0);  /* leading quiet */
+
+    zprintf(3, "    encode %s:", (dir) ? "START" : "STOP");
+    if(!dir)
+        encode(0x1, REV);
+    encode(code93[CODE93_START_STOP], dir ^ 1);
+    if(!dir) {
+        zprintf(3, "    encode checksum (K): %02x", chk_k);
+        encode(code93[chk_k], REV ^ 1);
+        zprintf(3, "    encode checksum (C): %02x", chk_c);
+        encode(code93[chk_c], REV ^ 1);
+    }
+
+    n = strlen(data);
+    for(i = 0; i < n; i++) {
+        unsigned char c = data[(dir) ? i : (n - i - 1)];
+        zprintf(3, "    encode '%c':", c);
+        encode_char93(c, dir);
+    }
+
+    if(dir) {
+        zprintf(3, "    encode checksum (C): %02x", chk_c);
+        encode(code93[chk_c], FWD ^ 1);
+        zprintf(3, "    encode checksum (K): %02x", chk_k);
+        encode(code93[chk_k], FWD ^ 1);
+    }
+    zprintf(3, "    encode %s:", (dir) ? "STOP" : "START");
+    encode(code93[CODE93_START_STOP], dir ^ 1);
+    if(dir)
+        encode(0x1, FWD);
+
+    encode(0xa, 0);  /* trailing quiet */
+    print_sep(3);
 }
 
 /*------------------------------------------------------------*/
@@ -182,14 +376,29 @@
 /* FIXME configurable/randomized ratio, ics */
 /* FIXME check digit option, ASCII escapes */
 
+static void convert_code39 (char *data)
+{
+    char *src, *dst;
+    for(src = data, dst = data; *src; src++) {
+        char c = *src;
+        if(c >= 'a' && c <= 'z')
+            *(dst++) = c - ('a' - 'A');
+        else if(c == ' ' ||
+                c == '$' || c == '%' ||
+                c == '+' || c == '-' ||
+                (c >= '.' && c <= '9') ||
+                (c >= 'A' && c <= 'Z'))
+            *(dst++) = c;
+        else
+            /* skip (FIXME) */;
+    }
+    *dst = 0;
+}
+
 static void encode_char39 (unsigned char c,
                            unsigned ics)
 {
-    if(c >= 'a' && c <= 'z')
-        c -= 'a' - 'A';
-    else if(c < 0x20 || c > 0x5a)
-        return; /* skip (FIXME) */
-
+    assert(0x20 <= c && c <= 0x5a);
     unsigned int raw = code39[c - 0x20];
     if(!raw)
         return; /* skip (FIXME) */
@@ -201,15 +410,16 @@
         raw <<= 1;
     }
     enc = (enc << 4) | ics;
-    printf("    encode '%c': %02x%08x: ", c,
-           (unsigned)(enc >> 32), (unsigned)(enc & 0xffffffff));
+    zprintf(3, "    encode '%c': %02x%08x: ", c,
+            (unsigned)(enc >> 32), (unsigned)(enc & 0xffffffff));
     encode(enc, REV);
 }
 
-static void encode_code39 (unsigned char *data)
+static void encode_code39 (char *data)
 {
-    printf("------------------------------------------------------------\n"
-           "encode CODE-39: %s\n", data);
+    assert(zbar_decoder_get_color(decoder) == ZBAR_SPACE);
+    print_sep(3);
+    zprintf(2, "CODE-39: %s\n", data);
     encode(0xa, 0);  /* leading quiet */
     encode_char39('*', 1);
     int i;
@@ -217,10 +427,10 @@
         if(data[i] != '*') /* skip (FIXME) */
             encode_char39(data[i], 1);
     encode_char39('*', 0xa);  /* w/trailing quiet */
-    printf("------------------------------------------------------------\n");
+    print_sep(3);
 }
 
-
+#if 0
 /*------------------------------------------------------------*/
 /* PDF417 encoding */
 
@@ -258,32 +468,33 @@
 {
     int k = r % 3;
 
-    printf("    [%d] encode %s:", r, (dir) ? "stop" : "start");
+    zprintf(3, "    [%d] encode %s:", r, (dir) ? "stop" : "start");
     encode((dir) ? PDF417_STOP : PDF417_START, dir);
 
     int cw = calc_ind417(k + !dir, r, cols);
-    printf("    [%d,%c] encode %03d(%d): ", r, (dir) ? 'R' : 'L', cw, k);
+    zprintf(3, "    [%d,%c] encode %03d(%d): ", r, (dir) ? 'R' : 'L', cw, k);
     encode(pdf417_encode[cw][k], dir);
 
     int c;
     for(c = 0; c < cols; c++) {
         cw = cws[c];
-        printf("    [%d,%d] encode %03d(%d): ", r, c, cw, k);
+        zprintf(3, "    [%d,%d] encode %03d(%d): ", r, c, cw, k);
         encode(pdf417_encode[cw][k], dir);
     }
 
     cw = calc_ind417(k + dir, r, cols);
-    printf("    [%d,%c] encode %03d(%d): ", r, (dir) ? 'L' : 'R', cw, k);
+    zprintf(3, "    [%d,%c] encode %03d(%d): ", r, (dir) ? 'L' : 'R', cw, k);
     encode(pdf417_encode[cw][k], dir);
 
-    printf("    [%d] encode %s:", r, (dir) ? "start" : "stop");
+    zprintf(3, "    [%d] encode %s:", r, (dir) ? "start" : "stop");
     encode((dir) ? PDF417_START : PDF417_STOP, dir);
 }
 
-static void encode_pdf417 (unsigned char *data)
+static void encode_pdf417 (char *data)
 {
-    printf("------------------------------------------------------------\n"
-           "encode PDF417: hello world\n");
+    assert(zbar_decoder_get_color(decoder) == ZBAR_SPACE);
+    print_sep(3);
+    zprintf(2, "PDF417: hello world\n");
     encode(0xa, 0);
 
     int r;
@@ -292,9 +503,108 @@
         encode(0xa, 0);
     }
 
-    printf("------------------------------------------------------------\n");
+    print_sep(3);
+}
+#endif
+
+/*------------------------------------------------------------*/
+/* Codabar encoding */
+
+static const unsigned int codabar[20] = {
+    0x03, 0x06, 0x09, 0x60, 0x12, 0x42, 0x21, 0x24,
+    0x30, 0x48, 0x0c, 0x18, 0x45, 0x51, 0x54, 0x15,
+    0x1a, 0x29, 0x0b, 0x0e,
+};
+
+static const char codabar_char[0x14] =
+    "0123456789-$:/.+ABCD";
+
+/* FIXME configurable/randomized ratio, ics */
+/* FIXME check digit option */
+
+static char *convert_codabar (char *src)
+{
+    unsigned len = strlen(src);
+    char tmp[4] = { 0, };
+    if(len < 2) {
+        unsigned delim = rand() >> 8;
+        tmp[0] = delim & 3;
+        if(len)
+            tmp[1] = src[0];
+        tmp[len + 1] = (delim >> 2) & 3;
+        len += 2;
+        src = tmp;
+    }
+
+    char *result = malloc(len + 1);
+    char *dst = result;
+    *(dst++) = ((*(src++) - 1) & 0x3) + 'A';
+    for(len--; len > 1; len--) {
+        char c = *(src++);
+        if(c >= '0' && c <= '9')
+            *(dst++) = c;
+        else if(c == '-' || c == '$' || c == ':' || c == '/' ||
+                c == '.' || c == '+')
+            *(dst++) = c;
+        else
+            *(dst++) = codabar_char[c % 0x10];
+    }
+    *(dst++) = ((*(src++) - 1) & 0x3) + 'A';
+    *dst = 0;
+    return(result);
 }
 
+static void encode_codachar (unsigned char c,
+                             unsigned ics,
+                             int dir)
+{
+    unsigned int idx;
+    if(c >= '0' && c <= '9')
+        idx = c - '0';
+    else if(c >= 'A' && c <= 'D')
+        idx = c - 'A' + 0x10;
+    else
+        switch(c)
+        {
+        case '-': idx = 0xa; break;
+        case '$': idx = 0xb; break;
+        case ':': idx = 0xc; break;
+        case '/': idx = 0xd; break;
+        case '.': idx = 0xe; break;
+        case '+': idx = 0xf; break;
+        default:
+            assert(0);
+        }
+
+    assert(idx < 0x14);
+    unsigned int raw = codabar[idx];
+
+    uint32_t enc = 0;
+    int j;
+    for(j = 0; j < 7; j++, raw <<= 1)
+        enc = (enc << 4) | ((raw & 0x40) ? 3 : 1);
+    zprintf(3, "    encode '%c': %07x: ", c, enc);
+    if(dir)
+        enc = (enc << 4) | ics;
+    else
+        enc |= ics << 28;
+    encode(enc, 1 - dir);
+}
+
+static void encode_codabar (char *data,
+                            int dir)
+{
+    assert(zbar_decoder_get_color(decoder) == ZBAR_SPACE);
+    print_sep(3);
+    zprintf(2, "CODABAR: %s\n", data);
+    encode(0xa, 0);  /* leading quiet */
+    int i, n = strlen(data);
+    for(i = 0; i < n; i++) {
+        int j = (dir) ? i : n - i - 1;
+        encode_codachar(data[j], (i < n - 1) ? 1 : 0xa, dir);
+    }
+    print_sep(3);
+}
 
 /*------------------------------------------------------------*/
 /* Interleaved 2 of 5 encoding */
@@ -303,21 +613,22 @@
     0x06, 0x11, 0x09, 0x18, 0x05, 0x14, 0x0c, 0x03, 0x12, 0x0a,
 };
 
-static void encode_i25 (unsigned char *data,
+static void encode_i25 (char *data,
                         int dir)
 {
-    printf("------------------------------------------------------------\n"
-           "encode Interleaved 2 of 5: %s\n"
-           "    encode start:", data);
+    assert(zbar_decoder_get_color(decoder) == ZBAR_SPACE);
+    print_sep(3);
+    zprintf(2, "Interleaved 2 of 5: %s\n", data);
+    zprintf(3, "    encode start:");
     encode((dir) ? 0xa1111 : 0xa112, 0);
 
     /* FIXME rev case data reversal */
     int i;
-    for(i = (strlen((char*)data) & 1) ? -1 : 0; i < 0 || data[i]; i += 2) {
+    for(i = (strlen(data) & 1) ? -1 : 0; i < 0 || data[i]; i += 2) {
         /* encode 2 digits */
         unsigned char c0 = (i < 0) ? 0 : data[i] - '0';
         unsigned char c1 = data[i + 1] - '0';
-        printf("    encode '%d%d':", c0, c1);
+        zprintf(3, "    encode '%d%d':", c0, c1);
         assert(c0 < 10);
         assert(c1 < 10);
 
@@ -337,12 +648,252 @@
         encode(enc, dir);
     }
 
-    printf("    encode end:");
+    zprintf(3, "    encode end:");
     encode((dir) ? 0x211a : 0x1111a, 0);
-    printf("------------------------------------------------------------\n");
+    print_sep(3);
 }
 
 /*------------------------------------------------------------*/
+/* DataBar encoding */
+
+
+/* character encoder reference algorithm from ISO/IEC 24724:2009 */
+
+struct rss_group {
+    int T_odd, T_even, n_odd, w_max;
+};
+
+static const struct rss_group databar_groups_outside[] = {
+    { 161,   1, 12, 8 },
+    {  80,  10, 10, 6 },
+    {  31,  34,  8, 4 },
+    {  10,  70,  6, 3 },
+    {   1, 126,  4, 1 },
+    {   0, }
+};
+
+static const struct rss_group databar_groups_inside[] = {
+    {  4, 84,  5, 2 },
+    { 20, 35,  7, 4 },
+    { 48, 10,  9, 6 },
+    { 81,  1, 11, 8 },
+    {  0, }
+};
+
+static const uint32_t databar_finders[9] = {
+    0x38211, 0x35511, 0x33711, 0x31911, 0x27411,
+    0x25611, 0x23811, 0x15711, 0x13911,
+};
+
+int combins (int n,
+             int r)
+{
+    int i, j;
+    int maxDenom, minDenom;
+    int val;
+    if(n-r > r) {
+        minDenom = r;
+        maxDenom = n-r;
+    }
+    else {
+        minDenom = n-r;
+        maxDenom = r;
+    }
+    val = 1;
+    j = 1;
+    for(i = n; i > maxDenom; i--) {
+        val *= i;
+        if(j <= minDenom) {
+            val /= j;
+            j++;
+        }
+    }
+    for(; j <= minDenom; j++)
+        val /= j;
+    return(val);
+}
+
+void getRSSWidths (int val,
+                   int n,
+                   int elements,
+                   int maxWidth,
+                   int noNarrow,
+                   int *widths)
+{
+    int narrowMask = 0;
+    int bar;
+    for(bar = 0; bar < elements - 1; bar++) {
+        int elmWidth, subVal;
+        for(elmWidth = 1, narrowMask |= (1<<bar);
+            ;
+            elmWidth++, narrowMask &= ~(1<<bar))
+        {
+            subVal = combins(n-elmWidth-1, elements-bar-2);
+            if((!noNarrow) && !narrowMask &&
+                (n-elmWidth-(elements-bar-1) >= elements-bar-1))
+                subVal -= combins(n-elmWidth-(elements-bar), elements-bar-2);
+            if(elements-bar-1 > 1) {
+                int mxwElement, lessVal = 0;
+                for (mxwElement = n-elmWidth-(elements-bar-2);
+                     mxwElement > maxWidth;
+                     mxwElement--)
+                    lessVal += combins(n-elmWidth-mxwElement-1, elements-bar-3);
+                subVal -= lessVal * (elements-1-bar);
+            }
+            else if (n-elmWidth > maxWidth)
+                subVal--;
+            val -= subVal;
+            if(val < 0)
+                break;
+        }
+        val += subVal;
+        n -= elmWidth;
+        widths[bar] = elmWidth;
+    }
+    widths[bar] = n;
+}
+
+static uint64_t encode_databar_char (unsigned val,
+                                     const struct rss_group *grp,
+                                     int nmodules,
+                                     int nelems,
+                                     int dir)
+{
+    int G_sum = 0;
+    while(1) {
+        assert(grp->T_odd);
+        int sum = G_sum + grp->T_odd * grp->T_even;
+        if(val >= sum)
+            G_sum = sum;
+        else
+            break;
+        grp++;
+    }
+
+    zprintf(3, "char=%d", val);
+
+    int V_grp = val - G_sum;
+    int V_odd, V_even;
+    if(!dir) {
+        V_odd = V_grp / grp->T_even;
+        V_even = V_grp % grp->T_even;
+    }
+    else {
+        V_even = V_grp / grp->T_odd;
+        V_odd = V_grp % grp->T_odd;
+    }
+
+    zprintf(3, " G_sum=%d T_odd=%d T_even=%d n_odd=%d w_max=%d V_grp=%d\n",
+            G_sum, grp->T_odd, grp->T_even, grp->n_odd, grp->w_max, V_grp);
+
+    int odd[16];
+    getRSSWidths(V_odd, grp->n_odd, nelems, grp->w_max, !dir, odd);
+    zprintf(3, "    V_odd=%d odd=%d%d%d%d",
+            V_odd, odd[0], odd[1], odd[2], odd[3]);
+
+    int even[16];
+    getRSSWidths(V_even, nmodules - grp->n_odd, nelems, 9 - grp->w_max,
+                 dir, even);
+    zprintf(3, " V_even=%d even=%d%d%d%d",
+            V_even, even[0], even[1], even[2], even[3]);
+
+    uint64_t units = 0;
+    int i;
+    for(i = 0; i < nelems; i++)
+        units = (units << 8) | (odd[i] << 4) | even[i];
+
+    zprintf(3, " raw=%"PRIx64"\n", units);
+    return(units);
+}
+
+#define SWAP(a, b) do { \
+        uint32_t tmp = (a); \
+        (a) = (b); \
+        (b) = tmp; \
+    } while(0);
+
+static void encode_databar (char *data,
+                            int dir)
+{
+    assert(zbar_decoder_get_color(decoder) == ZBAR_SPACE);
+
+    print_sep(3);
+    zprintf(2, "DataBar: %s\n", data);
+
+    uint32_t v[4] = { 0, };
+    int i, j;
+    for(i = 0; i < 14; i++) {
+        for(j = 0; j < 4; j++)
+            v[j] *= 10;
+        assert(data[i]);
+        v[0] += data[i] - '0';
+        v[1] += v[0] / 1597;
+        v[0] %= 1597;
+        v[2] += v[1] / 2841;
+        v[1] %= 2841;
+        v[3] += v[2] / 1597;
+        v[2] %= 1597;
+        /*printf("    [%d] %c (%d,%d,%d,%d)\n",
+               i, data[i], v[0], v[1], v[2], v[3]);*/
+    }
+    zprintf(3, "chars=(%d,%d,%d,%d)\n", v[3], v[2], v[1], v[0]);
+
+    uint32_t c[4] = {
+        encode_databar_char(v[3], databar_groups_outside, 16, 4, 0),
+        encode_databar_char(v[2], databar_groups_inside, 15, 4, 1),
+        encode_databar_char(v[1], databar_groups_outside, 16, 4, 0),
+        encode_databar_char(v[0], databar_groups_inside, 15, 4, 1),
+    };
+
+    int chk = 0, w = 1;
+    for(i = 0; i < 4; i++, chk %= 79, w %= 79)
+        for(j = 0; j < 8; j++, w *= 3)
+            chk += ((c[i] >> (28 - j * 4)) & 0xf) * w;
+    zprintf(3, "chk=%d\n", chk);
+
+    if(chk >= 8) chk++;
+    if(chk >= 72) chk++;
+    int C_left = chk / 9;
+    int C_right = chk % 9;
+
+    if(dir == REV) {
+        SWAP(C_left, C_right);
+        SWAP(c[0], c[2]);
+        SWAP(c[1], c[3]);
+        SWAP(v[0], v[2]);
+        SWAP(v[1], v[3]);
+    }
+
+    zprintf(3, "    encode start guard:");
+    encode_junk(dir);
+    encode(0x1, FWD);
+
+    zprintf(3, "encode char[0]=%d", v[3]);
+    encode(c[0], REV);
+
+    zprintf(3, "encode left finder=%d", C_left);
+    encode(databar_finders[C_left], REV);
+
+    zprintf(3, "encode char[1]=%d", v[2]);
+    encode(c[1], FWD);
+
+    zprintf(3, "encode char[3]=%d", v[0]);
+    encode(c[3], REV);
+
+    zprintf(3, "encode right finder=%d", C_right);
+    encode(databar_finders[C_right], FWD);
+
+    zprintf(3, "encode char[2]=%d", v[1]);
+    encode(c[2], FWD);
+
+    zprintf(3, "    encode end guard:");
+    encode(0x1, FWD);
+    encode_junk(!dir);
+    print_sep(3);
+}
+
+
+/*------------------------------------------------------------*/
 /* EAN/UPC encoding */
 
 static const unsigned int ean_digits[10] = {
@@ -372,7 +923,20 @@
     0x25,       /* ABBABA = 9 */
 };
 
-static void calc_ean_parity (unsigned char *data,
+static const unsigned char addon_parity_encode[] = {
+    0x07,       /* BBAAA = 0 */
+    0x0b,       /* BABAA = 1 */
+    0x0d,       /* BAABA = 2 */
+    0x0e,       /* BAAAB = 3 */
+    0x13,       /* ABBAA = 4 */
+    0x19,       /* AABBA = 5 */
+    0x1c,       /* AAABB = 6 */
+    0x15,       /* ABABA = 7 */
+    0x16,       /* ABAAB = 8 */
+    0x1a,       /* AABAB = 9 */
+};
+
+static void calc_ean_parity (char *data,
                              int n)
 {
     int i, chk = 0;
@@ -387,119 +951,372 @@
     data[i] = 0;
 }
 
-static void encode_ean13 (unsigned char *data)
+static void encode_ean13 (char *data)
 {
     int i;
     unsigned char par = ean_parity_encode[data[0] - '0'];
+    assert(zbar_decoder_get_color(decoder) == ZBAR_SPACE);
 
-    printf("------------------------------------------------------------\n"
-           "encode EAN-13: %s (%02x)\n"
-           "    encode start guard:",
-           data, par);
+    print_sep(3);
+    zprintf(2, "EAN-13: %s (%02x)\n", data, par);
+    zprintf(3, "    encode start guard:");
     encode(ean_guard[3], FWD);
     for(i = 1; i < 7; i++, par <<= 1) {
-        printf("    encode %x%c:", (par >> 5) & 1, data[i]);
-        encode(ean_digits[data[i] - '0'], REV ^ ((par >> 5) & 1));
+        zprintf(3, "    encode %x%c:", (par >> 5) & 1, data[i]);
+        encode(ean_digits[data[i] - '0'], (par >> 5) & 1);
     }
-    printf("    encode center guard:");
+    zprintf(3, "    encode center guard:");
     encode(ean_guard[5], FWD);
     for(; i < 13; i++) {
-        printf("    encode %x%c:", 0, data[i]);
+        zprintf(3, "    encode %x%c:", 0, data[i]);
         encode(ean_digits[data[i] - '0'], FWD);
     }
-    printf("    encode end guard:");
+    zprintf(3, "    encode end guard:");
     encode(ean_guard[3], REV);
-    printf("------------------------------------------------------------\n");
+    print_sep(3);
 }
 
-static void encode_ean8 (unsigned char *data)
+static void encode_ean8 (char *data)
 {
     int i;
-    printf("------------------------------------------------------------\n"
-           "encode EAN-8: %s\n"
-           "    encode start guard:",
-           data);
+    assert(zbar_decoder_get_color(decoder) == ZBAR_SPACE);
+    print_sep(3);
+    zprintf(2, "EAN-8: %s\n", data);
+    zprintf(3, "    encode start guard:");
     encode(ean_guard[3], FWD);
     for(i = 0; i < 4; i++) {
-        printf("    encode %c:", data[i]);
+        zprintf(3, "    encode %c:", data[i]);
         encode(ean_digits[data[i] - '0'], FWD);
     }
-    printf("    encode center guard:");
+    zprintf(3, "    encode center guard:");
     encode(ean_guard[5], FWD);
     for(; i < 8; i++) {
-        printf("    encode %c:", data[i]);
+        zprintf(3, "    encode %c:", data[i]);
         encode(ean_digits[data[i] - '0'], FWD);
     }
-    printf("    encode end guard:");
+    zprintf(3, "    encode end guard:");
     encode(ean_guard[3], REV);
-    printf("------------------------------------------------------------\n");
+    print_sep(3);
+}
+
+static void encode_addon (char *data,
+                          unsigned par,
+                          int n)
+{
+    int i;
+    assert(zbar_decoder_get_color(decoder) == ZBAR_SPACE);
+
+    print_sep(3);
+    zprintf(2, "EAN-%d: %s (par=%02x)\n", n, data, par);
+    zprintf(3, "    encode start guard:");
+    encode(ean_guard[4], FWD);
+    for(i = 0; i < n; i++, par <<= 1) {
+        zprintf(3, "    encode %x%c:", (par >> (n - 1)) & 1, data[i]);
+        encode(ean_digits[data[i] - '0'], (par >> (n - 1)) & 1);
+        if(i < n - 1) {
+	    zprintf(3, "    encode delineator:");
+            encode(ean_guard[2], FWD);
+        }
+    }
+    zprintf(3, "    encode trailing qz:");
+    encode(0x7, FWD);
+    print_sep(3);
+}
+
+static void encode_ean5 (char *data)
+{
+    unsigned chk = ((data[0] - '0' + data[2] - '0' + data[4] - '0') * 3 +
+                    (data[1] - '0' + data[3] - '0') * 9) % 10;
+    encode_addon(data, addon_parity_encode[chk], 5);
+}
+
+static void encode_ean2 (char *data)
+{
+    unsigned par = (~(10 * (data[0] - '0') + data[1] - '0')) & 3;
+    encode_addon(data, par, 2);
 }
 
 
 /*------------------------------------------------------------*/
 /* main test flow */
 
-int main (int argc, char **argv)
+int test_databar_F_1 ()
 {
-    int i;
-    int rnd_size = 9;           /* should be odd */
-    srand(0xbabeface);
+    expect(ZBAR_DATABAR, "0124012345678905");
+    assert(zbar_decoder_get_color(decoder) == ZBAR_SPACE);
+    encode(0x11, 0);
+    encode(0x31111333, 0);
+    encode(0x13911, 0);
+    encode(0x31131231, 0);
+    encode(0x11214222, 0);
+    encode(0x11553, 0);
+    encode(0x21231313, 0);
+    encode(0x1, 0);
+    encode_junk(rnd_size);
+    return(0);
+}
 
-    /* FIXME TBD:
-     *   - random module width (!= 1.0)
-     *   - simulate scan speed variance
-     *   - simulate dark "swelling" and light "blooming"
-     *   - inject parity errors
-     */
-    decoder = zbar_decoder_create();
-    zbar_decoder_set_handler(decoder, symbol_handler);
-    zbar_decoder_set_config(decoder, 0, ZBAR_CFG_MIN_LEN, 0);
+int test_databar_F_3 ()
+{
+    expect(ZBAR_DATABAR_EXP, "1012A");
+    assert(zbar_decoder_get_color(decoder) == ZBAR_SPACE);
+    encode(0x11, 0);
+    encode(0x11521151, 0);
+    encode(0x18411, 0);
+    encode(0x13171121, 0);
+    encode(0x11521232, 0);
+    encode(0x11481, 0);
+    encode(0x23171111, 0);
+    encode(0x1, 0);
+    encode_junk(rnd_size);
+    return(0);
+}
 
-    encode_junk(rnd_size + 1);
+int test_orange ()
+{
+    char data[32] = "0100845963000052";
+    expect(ZBAR_DATABAR, data);
+    assert(zbar_decoder_get_color(decoder) == ZBAR_SPACE);
+    encode(0x1, 0);
+    encode(0x23212321, 0);   // data[0]
+    encode(0x31911, 0);      // finder[?] = 3
+    encode(0x21121215, 1);   // data[1]
+    encode(0x41111133, 0);   // data[3]
+    encode(0x23811, 1);      // finder[?] = 6
+    encode(0x11215141, 1);   // data[2]
+    encode(0x11, 0);
+    encode_junk(rnd_size);
 
-    unsigned char data[32] = { 0 };
-    for(i = 0; i < 12; i++)
-        data[i] = (rand() % 10) + '0';
+    expect(ZBAR_DATABAR, data);
+    data[1] = '0';
+    encode_databar(data + 1, FWD);
+    encode_junk(rnd_size);
+    return(0);
+}
 
-    calc_ean_parity(data, 12);
-    encode_ean13(data);
+int test_numeric (char *data)
+{
+    char tmp[32] = "01";
+    strncpy(tmp + 2, data + 1, 13);
+    calc_ean_parity(tmp + 2, 13);
+    expect(ZBAR_DATABAR, tmp);
+
+    tmp[1] = data[0] & '1';
+    encode_databar(tmp + 1, (rand() >> 8) & 1);
 
     encode_junk(rnd_size);
 
-    data[i] = 0;
+    data[strlen(data) & ~1] = 0;
+    expect(ZBAR_CODE128, data);
     encode_code128c(data);
 
     encode_junk(rnd_size);
 
+    expect(ZBAR_I25, data);
     encode_i25(data, FWD);
 
     encode_junk(rnd_size);
-
+#if 0 /* FIXME encoding broken */
     encode_i25(data, REV);
 
     encode_junk(rnd_size);
+#endif
 
-    calc_ean_parity(data, 7);
-    encode_ean8(data);
+    char *cdb = convert_codabar(data);
+    expect(ZBAR_CODABAR, cdb);
+    encode_codabar(cdb, FWD);
+    encode_junk(rnd_size);
+
+    expect(ZBAR_CODABAR, cdb);
+    encode_codabar(cdb, REV);
+    encode_junk(rnd_size);
+    free(cdb);
+
+    calc_ean_parity(data + 2, 12);
+    expect(ZBAR_EAN13, data + 2);
+    encode_ean13(data + 2);
+    encode_junk(rnd_size);
+
+    calc_ean_parity(data + 7, 7);
+    expect(ZBAR_EAN8, data + 7);
+    encode_ean8(data + 7);
 
     encode_junk(rnd_size);
 
+    data[5] = 0;
+    expect(ZBAR_EAN5, data);
+    encode_ean5(data);
+
+    encode_junk(rnd_size);
+
+    data[2] = 0;
+    expect(ZBAR_EAN2, data);
+    encode_ean2(data);
+    encode_junk(rnd_size);
+
+    expect(ZBAR_NONE, NULL);
+    return(0);
+}
+
+int test_alpha (char *data)
+{
+    expect(ZBAR_CODE128, data);
+    encode_code128b(data);
+
+    encode_junk(rnd_size);
+
+    expect(ZBAR_CODE93, data);
+    encode_code93(data, FWD);
+
+    encode_junk(rnd_size);
+
+    expect(ZBAR_CODE93, data);
+    encode_code93(data, REV);
+
+    encode_junk(rnd_size);
+
+    char *cdb = convert_codabar(data);
+    expect(ZBAR_CODABAR, cdb);
+    encode_codabar(cdb, FWD);
+    encode_junk(rnd_size);
+
+    expect(ZBAR_CODABAR, cdb);
+    encode_codabar(cdb, REV);
+    encode_junk(rnd_size);
+    free(cdb);
+
+    convert_code39(data);
+    expect(ZBAR_CODE39, data);
+    encode_code39(data);
+
+    encode_junk(rnd_size);
+
+#if 0 /* FIXME decoder unfinished */
+    encode_pdf417(data);
+
+    encode_junk(rnd_size);
+#endif
+
+    expect(ZBAR_NONE, NULL);
+    return(0);
+}
+
+int test1 ()
+{
+    print_sep(2);
+    if(!seed)
+        seed = 0xbabeface;
+    zprintf(1, "[%d] SEED=%d\n", iter++, seed);
+    srand(seed);
+    if(/* EAN-2 within DataBar (020596539169270)
+        * (FIXME require COMPOSITE for addons)
+        */
+       seed == -862734747)
+    {
+        zprintf(2, "    FIXME known failure\n");
+        return(2);
+    }
+
+    int i;
+    char data[32] = { 0, };
+    for(i = 0; i < 14; i++)
+        data[i] = (rand() % 10) + '0';
+
+    test_numeric(data);
+
     for(i = 0; i < 10; i++)
         data[i] = (rand() % 0x5f) + 0x20;
     data[i] = 0;
 
-    encode_code128b(data);
+    test_alpha(data);
+    return(0);
+}
 
-    encode_junk(rnd_size);
+/* FIXME TBD:
+ *   - random module width (!= 1.0)
+ *   - simulate scan speed variance
+ *   - simulate dark "swelling" and light "blooming"
+ *   - inject parity errors
+ */
 
-    /*encode_code39("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%");*/
-    encode_code39(data);
+int main (int argc, char **argv)
+{
+    int n, i, j;
+    char *end;
 
-    encode_junk(rnd_size);
+    decoder = zbar_decoder_create();
+    /* allow empty CODE39 symbologies */
+    zbar_decoder_set_config(decoder, ZBAR_CODE39, ZBAR_CFG_MIN_LEN, 0);
+    /* enable addons */
+    zbar_decoder_set_config(decoder, ZBAR_EAN2, ZBAR_CFG_ENABLE, 1);
+    zbar_decoder_set_config(decoder, ZBAR_EAN5, ZBAR_CFG_ENABLE, 1);
+    zbar_decoder_set_handler(decoder, symbol_handler);
 
-    encode_pdf417(data);
+    encode_junk(rnd_size + 1);
 
-    encode_junk(rnd_size);
+    for(i = 1; i < argc; i++) {
+        if(argv[i][0] != '-') {
+            fprintf(stderr, "ERROR: unknown argument: %s\n", argv[i]);
+            return(2);
+        }
+        for(j = 1; argv[i][j]; j++) {
+            switch(argv[i][j])
+            {
+            case 'q': verbosity = 0; break;
+            case 'v': verbosity++; break;
+            case 'r':
+                seed = time(NULL);
+                srand(seed);
+                seed = (rand() << 8) ^ rand();
+                zprintf(0, "-r SEED=%d\n", seed);
+                break;
+
+            case 's':
+                if(!argv[i][++j] && !(j = 0) && ++i >= argc) {
+                    fprintf(stderr, "ERROR: -s needs <seed> argument\n");
+                    return(2);
+                }
+                long s = strtol(argv[i] + j, &end, 0);
+                seed = s;
+                if((!isdigit(argv[i][j]) && argv[i][j] != '-') ||
+                   !s || s == LONG_MAX || s == LONG_MIN) {
+                    fprintf(stderr, "ERROR: invalid <seed>: \"%s\"\n",
+                            argv[i] + j);
+                    return(2);
+                }
+                j = end - argv[i] - 1;
+                break;
+
+            case 'n':
+                if(!argv[i][++j] && !(j = 0) && ++i >= argc) {
+                    fprintf(stderr, "ERROR: -n needs <num> argument\n");
+                    return(2);
+                }
+                n = strtol(argv[i] + j, &end, 0);
+                if(!isdigit(argv[i][j]) || !n) {
+                    fprintf(stderr, "ERROR: invalid <num>: \"%s\"\n",
+                            argv[i] + j);
+                    return(2);
+                }
+                j = end - argv[i] - 1;
+
+                while(n--) {
+                    test1();
+                    seed = (rand() << 8) ^ rand();
+                }
+                break;
+            }
+        }
+    }
+
+    if(!iter) {
+        test_databar_F_1();
+        test_databar_F_3();
+        test_orange();
+        test1();
+    }
+
+    /* FIXME "Ran %d iterations in %gs\n\nOK\n" */
 
     zbar_decoder_destroy(decoder);
     return(0);
diff -r 563557a923d0 test/test_gtk.c
--- a/test/test_gtk.c	Tue Oct 27 11:25:59 2009 -0400
+++ b/test/test_gtk.c	Fri Feb 22 08:54:29 2013 -0300
@@ -45,7 +45,6 @@
     GtkTextIter end;
     gtk_text_buffer_get_end_iter(resultbuf, &end);
     gtk_text_buffer_insert(resultbuf, &end, zbar_get_symbol_name(symbol), -1);
-    gtk_text_buffer_insert(resultbuf, &end, zbar_get_addon_name(symbol), -1);
     gtk_text_buffer_insert(resultbuf, &end, ":", -1);
     gtk_text_buffer_insert(resultbuf, &end, result, -1);
     gtk_text_buffer_insert(resultbuf, &end, "\n", -1);
diff -r 563557a923d0 test/test_images.c
--- a/test/test_images.c	Tue Oct 27 11:25:59 2009 -0400
+++ b/test/test_images.c	Fri Feb 22 08:54:29 2013 -0300
@@ -96,30 +96,74 @@
     { 0 }
 };
 
+static const char *encoded_widths =
+    "9 111 212241113121211311141132 11111 311213121312121332111132 111 9";
+const char *test_image_ean13_data = "6268964977804";
+
 static int allocated_images = 0;
 
-int test_image_check_cleanup ()
+int
+test_image_check_cleanup ()
 {
     if(allocated_images)
         fprintf(stderr, "ERROR: %d image data buffers still allocated\n",
                 allocated_images);
-    else
-        fprintf(stderr, "all image data buffers freed\n");
+    /*else
+        fprintf(stderr, "all image data buffers freed\n");*/
     return(allocated_images);
 }
 
-static void test_cleanup_handler (zbar_image_t *img)
+static void
+test_cleanup_handler (zbar_image_t *img)
 {
     void *data = (void*)zbar_image_get_data(img);
-    fprintf(stderr, "cleanup image data @%p\n", data);
+    /*fprintf(stderr, "cleanup image data @%p\n", data);*/
     free(data);
     allocated_images--;
 }
 
+static inline const format_def_t*
+lookup_format (zbar_image_t *img)
+{
+    uint32_t ifmt = zbar_image_get_format(img);
+    const format_def_t *fmt;
+    for(fmt = formats; fmt->format; fmt++)
+        if(fmt->format == ifmt)
+            break;
+    if(!fmt->format) {
+        fprintf(stderr, "ERROR: no %.4s (%08"PRIx32") format\n",
+                (char*)&ifmt, ifmt);
+        return(NULL);
+    }
+    return(fmt);
+}
+
+static inline const format_def_t*
+alloc_data (zbar_image_t *img)
+{
+    allocated_images++;
+    const format_def_t *fmt = lookup_format(img);
+    if(!fmt)
+        return(NULL);
+
+    unsigned w = zbar_image_get_width(img);
+    unsigned h = zbar_image_get_height(img);
+    unsigned long planelen = w * h;
+    unsigned long datalen = planelen * fmt->bpp / 8;
+    uint8_t *data = malloc(datalen);
+
+    zbar_image_set_data(img, data, datalen, test_cleanup_handler);
+
+    /*fprintf(stderr, "create %.4s(%08"PRIx32") image data %lx bytes @%p\n",
+      (char*)&fmt->format, fmt->format, datalen, data);*/
+    return(fmt);
+}
+
 /* write intensity plane */
-static inline uint8_t *fill_bars_y (uint8_t *p,
-                                    unsigned w,
-                                    unsigned h)
+static inline uint8_t*
+fill_bars_y (uint8_t *p,
+             unsigned w,
+             unsigned h)
 {
     unsigned x, y, i;
     unsigned y0 = (h + 31) / 30;
@@ -145,10 +189,11 @@
 }
 
 /* write Cb (U) or Cr (V) plane */
-static inline uint8_t *fill_bars_uv (uint8_t *p,
-                                     unsigned w,
-                                     unsigned h,
-                                     const uint8_t *C)
+static inline uint8_t*
+fill_bars_uv (uint8_t *p,
+              unsigned w,
+              unsigned h,
+              const uint8_t *C)
 {
     unsigned x, y, i;
     unsigned y0 = (h + 31) / 30;
@@ -174,10 +219,11 @@
 }
 
 /* write packed CbCr plane */
-static inline uint8_t *fill_bars_nv (uint8_t *p,
-                                     unsigned w,
-                                     unsigned h,
-                                     format_type_t order)
+static inline uint8_t*
+fill_bars_nv (uint8_t *p,
+              unsigned w,
+              unsigned h,
+              format_type_t order)
 {
     unsigned x, y, i;
     unsigned y0 = (h + 31) / 30;
@@ -208,10 +254,11 @@
 }
 
 /* write packed YCbCr plane */
-static inline uint8_t *fill_bars_yuv (uint8_t *p,
-                                      unsigned w,
-                                      unsigned h,
-                                      format_type_t order)
+static inline uint8_t*
+fill_bars_yuv (uint8_t *p,
+               unsigned w,
+               unsigned h,
+               format_type_t order)
 {
     unsigned x, y, i;
     unsigned y0 = (h + 31) / 30;
@@ -253,11 +300,12 @@
     return((uint8_t*)q);
 }
 
-static inline uint8_t *fill_bars_rgb (uint8_t *p,
-                                      unsigned w,
-                                      unsigned h,
-                                      format_type_t order,
-                                      int bpp)
+static inline uint8_t*
+fill_bars_rgb (uint8_t *p,
+               unsigned w,
+               unsigned h,
+               format_type_t order,
+               int bpp)
 {
     unsigned x, y, i;
     unsigned y0 = (h + 31) / 30;
@@ -336,26 +384,17 @@
     return(((uint8_t*)q) + headlen);
 }
 
-int test_image_bars (zbar_image_t *img)
+int
+test_image_bars (zbar_image_t *img)
 {
-    allocated_images++;
+    const format_def_t *fmt = alloc_data(img);
+    if(!fmt)
+        return(-1);
+
     unsigned w = zbar_image_get_width(img);
     unsigned h = zbar_image_get_height(img);
-
-    const format_def_t *fmt;
-    for(fmt = formats; fmt->format; fmt++)
-        if(fmt->format == zbar_image_get_format(img))
-            break;
-    if(!fmt->format)
-        return(-1);
-
-    unsigned long planelen = w * h;
-    unsigned long datalen = planelen * fmt->bpp / 8;
-    uint8_t *data = malloc(datalen);
-    zbar_image_set_data(img, data, datalen, test_cleanup_handler);
-    fprintf(stderr, "create %.4s(%08" PRIx32 ") image data %lx bytes @%p\n",
-            (char*)&fmt->format, fmt->format, datalen, data);
-
+    uint8_t *data = (void*)zbar_image_get_data(img);
+    assert(data);
     uint8_t *p = data;
     switch(fmt->type) {
     case GRAY:
@@ -390,6 +429,88 @@
         break;
     }
 
+    assert(p == data + zbar_image_get_data_length(img));
+    return(0);
+}
+
+int
+test_image_ean13 (zbar_image_t *img)
+{
+    unsigned w = 114, h = 85;
+    zbar_image_set_size(img, w, h);
+
+    const format_def_t *fmt = alloc_data(img);
+    if(!fmt)
+        return(-1);
+
+    uint8_t *data = (void*)zbar_image_get_data(img);
+    unsigned int datalen = zbar_image_get_data_length(img);
+    assert(data && datalen);
+
+    uint8_t *p = data;
+    /* FIXME randomize? */
+    memset(data, 0x80, datalen);
+
+    int nrep = 1, nskip = 0;
+    switch(fmt->type)
+    {
+    case YUVP: /* planar YUV */
+    case YVUP:
+    case GRAY:
+        break;
+
+    case UYVY: /* packed YUV */
+        p++;
+    case YUYV:
+    case YVYU:
+        nskip = 1;
+        break;
+
+    default: /* RGB */
+        nrep = fmt->bpp / 8;
+    }
+
+    int y = 0, x, i;
+    for(; y < 10 && y < h; y++)
+        for(x = 0; x < w; x++) {
+            for(i = 0; i < nrep; i++)
+                *p++ = 0xff;
+            p += nskip;
+        }
+
+    for(; y < h - 10; y++) {
+        uint8_t color = 0xff;
+        const char *c;
+        for(x = 0, c = encoded_widths; *c; c++) {
+            int dx;
+            if(*c == ' ')
+                continue;
+            for(dx = *c - '0'; dx > 0; dx--) {
+                for(i = 0; i < nrep; i++)
+                    *p++ = color;
+                p += nskip;
+                x++;
+            }
+            color = ~color;
+        }
+        assert(!color);
+        for(; x < w; x++) {
+            for(i = 0; i < nrep; i++)
+                *p++ = 0xff;
+            p += nskip;
+        }
+        assert(x == w);
+    }
+
+    for(; y < h; y++)
+        for(x = 0; x < w; x++) {
+            for(i = 0; i < nrep; i++)
+                *p++ = 0xff;
+            p += nskip;
+        }
+
+    if(fmt->type == UYVY)
+        p--;
     assert(p == data + datalen);
     return(0);
 }
diff -r 563557a923d0 test/test_images.h
--- a/test/test_images.h	Tue Oct 27 11:25:59 2009 -0400
+++ b/test/test_images.h	Fri Feb 22 08:54:29 2013 -0300
@@ -1,5 +1,5 @@
 /*------------------------------------------------------------------------
- *  Copyright 2007-2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *  Copyright 2007-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
  *
  *  This file is part of the ZBar Bar Code Reader.
  *
@@ -23,12 +23,24 @@
 #ifndef _TEST_IMAGES_H_
 #define _TEST_IMAGES_H_
 
-/* adapted from v4l2 spec */
-#define fourcc(a, b, c, d)                      \
-    ((uint32_t)(a) | ((uint32_t)(b) << 8) |     \
-     ((uint32_t)(c) << 16) | ((uint32_t)(d) << 24))
+#define fourcc zbar_fourcc
+
+#ifdef __cplusplus
+
+extern "C" {
+    int test_image_check_cleanup(void);
+    int test_image_bars(zbar::zbar_image_t*);
+    int test_image_ean13(zbar::zbar_image_t*);
+}
+
+#else
 
 int test_image_check_cleanup(void);
 int test_image_bars(zbar_image_t*);
+int test_image_ean13(zbar_image_t*);
 
 #endif
+
+extern const char *test_image_ean13_data;
+
+#endif
diff -r 563557a923d0 zbar/Makefile.am.inc
--- a/zbar/Makefile.am.inc	Tue Oct 27 11:25:59 2009 -0400
+++ b/zbar/Makefile.am.inc	Fri Feb 22 08:54:29 2013 -0300
@@ -19,12 +19,21 @@
 if ENABLE_EAN
 zbar_libzbar_la_SOURCES += zbar/decoder/ean.h zbar/decoder/ean.c
 endif
+if ENABLE_DATABAR
+zbar_libzbar_la_SOURCES += zbar/decoder/databar.h zbar/decoder/databar.c
+endif
 if ENABLE_CODE128
 zbar_libzbar_la_SOURCES += zbar/decoder/code128.h zbar/decoder/code128.c
 endif
+if ENABLE_CODE93
+zbar_libzbar_la_SOURCES += zbar/decoder/code93.h zbar/decoder/code93.c
+endif
 if ENABLE_CODE39
 zbar_libzbar_la_SOURCES += zbar/decoder/code39.h zbar/decoder/code39.c
 endif
+if ENABLE_CODABAR
+zbar_libzbar_la_SOURCES += zbar/decoder/codabar.h zbar/decoder/codabar.c
+endif
 if ENABLE_I25
 zbar_libzbar_la_SOURCES += zbar/decoder/i25.h zbar/decoder/i25.c
 endif
@@ -53,11 +62,14 @@
 zbar_libzbar_la_SOURCES += zbar/processor/posix.h zbar/processor/posix.c
 endif
 
+if HAVE_V4L2
+zbar_libzbar_la_SOURCES += zbar/video/v4l.c zbar/video/v4l2.c
+endif
 if HAVE_V4L1
+if !HAVE_V4L2
+zbar_libzbar_la_SOURCES += zbar/video/v4l.c
+endif
 zbar_libzbar_la_SOURCES += zbar/video/v4l1.c
-if HAVE_V4L2
-zbar_libzbar_la_SOURCES += zbar/video/v4l2.c
-endif
 endif
 if WIN32
 if HAVE_VIDEO
diff -r 563557a923d0 zbar/config.c
--- a/zbar/config.c	Tue Oct 27 11:25:59 2009 -0400
+++ b/zbar/config.c	Fri Feb 22 08:54:29 2013 -0300
@@ -1,5 +1,5 @@
 /*------------------------------------------------------------------------
- *  Copyright 2008-2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *  Copyright 2008-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
  *
  *  This file is part of the ZBar Bar Code Reader.
  *
@@ -24,20 +24,24 @@
 #include <config.h>
 #include <stdlib.h>     /* strtol */
 #include <string.h>     /* strchr, strncmp, strlen */
-#include <errno.h>
-#include <assert.h>
+#ifdef HAVE_ERRNO_H
+# include <errno.h>
+#endif
 
 #include <zbar.h>
 
 int zbar_parse_config (const char *cfgstr,
-                        zbar_symbol_type_t *sym,
-                        zbar_config_t *cfg,
-                        int *val)
+                       zbar_symbol_type_t *sym,
+                       zbar_config_t *cfg,
+                       int *val)
 {
+    const char *dot, *eq;
+    int len;
+    char negate;
     if(!cfgstr)
         return(1);
 
-    const char *dot = strchr(cfgstr, '.');
+    dot = strchr(cfgstr, '.');
     if(dot) {
         int len = dot - cfgstr;
         if(!len || (len == 1 && !strncmp(cfgstr, "*", len)))
@@ -46,6 +50,8 @@
             return(1);
         else if(!strncmp(cfgstr, "qrcode", len))
             *sym = ZBAR_QRCODE;
+        else if(!strncmp(cfgstr, "db", len))
+            *sym = ZBAR_DATABAR;
         else if(len < 3)
             return(1);
         else if(!strncmp(cfgstr, "upca", len))
@@ -56,6 +62,12 @@
             *sym = ZBAR_EAN13;
         else if(!strncmp(cfgstr, "ean8", len))
             *sym = ZBAR_EAN8;
+        else if(!strncmp(cfgstr, "ean5", len))
+            *sym = ZBAR_EAN5;
+        else if(!strncmp(cfgstr, "ean2", len))
+            *sym = ZBAR_EAN2;
+        else if(!strncmp(cfgstr, "composite", len))
+            *sym = ZBAR_COMPOSITE;
         else if(!strncmp(cfgstr, "i25", len))
             *sym = ZBAR_I25;
         else if(len < 4)
@@ -66,15 +78,14 @@
             *sym = ZBAR_ISBN13;
         else if(!strncmp(cfgstr, "isbn10", len))
             *sym = ZBAR_ISBN10;
-#if 0
-        /* FIXME addons are configured per-main symbol type */
-        else if(!strncmp(cfgstr, "addon2", len))
-            *sym = ZBAR_ADDON2;
-        else if(!strncmp(cfgstr, "addon5", len))
-            *sym = ZBAR_ADDON5;
-#endif
+        else if(!strncmp(cfgstr, "db-exp", len))
+            *sym = ZBAR_DATABAR_EXP;
+        else if(!strncmp(cfgstr, "codabar", len))
+            *sym = ZBAR_CODABAR;
         else if(len < 6)
             return(1);
+        else if(!strncmp(cfgstr, "code93", len))
+            *sym = ZBAR_CODE93;
         else if(!strncmp(cfgstr, "code39", len))
             *sym = ZBAR_CODE39;
         else if(!strncmp(cfgstr, "pdf417", len))
@@ -83,6 +94,10 @@
             return(1);
         else if(!strncmp(cfgstr, "code128", len))
             *sym = ZBAR_CODE128;
+        else if(!strncmp(cfgstr, "databar", len))
+            *sym = ZBAR_DATABAR;
+        else if(!strncmp(cfgstr, "databar-exp", len))
+            *sym = ZBAR_DATABAR_EXP;
         else
             return(1);
         cfgstr = dot + 1;
@@ -90,13 +105,13 @@
     else
         *sym = 0;
 
-    int len = strlen(cfgstr);
-    const char *eq = strchr(cfgstr, '=');
+    len = strlen(cfgstr);
+    eq = strchr(cfgstr, '=');
     if(eq)
         len = eq - cfgstr;
     else
         *val = 1;  /* handle this here so we can override later */
-    char negate = 0;
+    negate = 0;
 
     if(len > 3 && !strncmp(cfgstr, "no-", 3)) {
         negate = 1;
@@ -130,16 +145,22 @@
         *cfg = ZBAR_CFG_ADD_CHECK;
     else if(!strncmp(cfgstr, "emit-check", len))
         *cfg = ZBAR_CFG_EMIT_CHECK;
+    else if(!strncmp(cfgstr, "uncertainty", len))
+        *cfg = ZBAR_CFG_UNCERTAINTY;
     else if(!strncmp(cfgstr, "position", len))
         *cfg = ZBAR_CFG_POSITION;
     else 
         return(1);
 
     if(eq) {
+#ifdef HAVE_ERRNO_H
         errno = 0;
+#endif
         *val = strtol(eq + 1, NULL, 0);
+#ifdef HAVE_ERRNO_H
         if(errno)
             return(1);
+#endif
     }
     if(negate)
         *val = !*val;
diff -r 563557a923d0 zbar/convert.c
--- a/zbar/convert.c	Tue Oct 27 11:25:59 2009 -0400
+++ b/zbar/convert.c	Fri Feb 22 08:54:29 2013 -0300
@@ -1,5 +1,5 @@
 /*------------------------------------------------------------------------
- *  Copyright 2007-2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *  Copyright 2007-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
  *
  *  This file is part of the ZBar Bar Code Reader.
  *
@@ -236,12 +236,13 @@
 static inline void uv_roundup (zbar_image_t *img,
                                const zbar_format_def_t *fmt)
 {
+    unsigned xmask, ymask;
     if(fmt->group == ZBAR_FMT_GRAY)
         return;
-    unsigned xmask = (1 << fmt->p.yuv.xsub2) - 1;
+    xmask = (1 << fmt->p.yuv.xsub2) - 1;
     if(img->width & xmask)
         img->width = (img->width + xmask) & ~xmask;
-    unsigned ymask = (1 << fmt->p.yuv.ysub2) - 1;
+    ymask = (1 << fmt->p.yuv.ysub2) - 1;
     if(img->height & ymask)
         img->height = (img->height + ymask) & ~ymask;
 }
@@ -306,16 +307,18 @@
                                      const zbar_format_def_t *srcfmt,
                                      size_t n)
 {
+    uint8_t *psrc, *pdst;
+    unsigned width, height, xpad, y;
+
     if(dst->width == src->width && dst->height == src->height) {
         memcpy((void*)dst->data, src->data, n);
         return;
     }
-    uint8_t *psrc = (void*)src->data;
-    uint8_t *pdst = (void*)dst->data;
-    unsigned width = (dst->width > src->width) ? src->width : dst->width;
-    unsigned xpad = (dst->width > src->width) ? dst->width - src->width : 0;
-    unsigned height = (dst->height > src->height) ? src->height : dst->height;
-    unsigned y;
+    psrc = (void*)src->data;
+    pdst = (void*)dst->data;
+    width = (dst->width > src->width) ? src->width : dst->width;
+    xpad = (dst->width > src->width) ? dst->width - src->width : 0;
+    height = (dst->height > src->height) ? src->height : dst->height;
     for(y = 0; y < height; y++) {
         memcpy(pdst, psrc, width);
         pdst += width;
@@ -344,10 +347,10 @@
 {
     if(src->width == dst->width &&
        src->height == dst->height) {
+        zbar_image_t *s = (zbar_image_t*)src;
         dst->data = src->data;
         dst->datalen = src->datalen;
         dst->cleanup = cleanup_ref;
-        zbar_image_t *s = (zbar_image_t*)src;
         dst->next = s;
         _zbar_image_refcnt(s, 1);
     }
@@ -362,9 +365,10 @@
                                 const zbar_image_t *src,
                                 const zbar_format_def_t *srcfmt)
 {
+    unsigned long n;
     uv_roundup(dst, dstfmt);
     dst->datalen = uvp_size(dst, dstfmt) * 2;
-    unsigned long n = dst->width * dst->height;
+    n = dst->width * dst->height;
     dst->datalen += n;
     assert(src->datalen >= src->width * src->height);
     zprintf(24, "dst=%dx%d (%lx) %lx src=%dx%d %lx\n",
@@ -373,7 +377,7 @@
     dst->data = malloc(dst->datalen);
     if(!dst->data) return;
     convert_y_resize(dst, dstfmt, src, srcfmt, n);
-    memset((void*)dst->data + n, 0x80, dst->datalen - n);
+    memset((uint8_t*)dst->data + n, 0x80, dst->datalen - n);
 }
 
 /* interleave YUV planes into packed YUV */
@@ -382,32 +386,35 @@
                               const zbar_image_t *src,
                               const zbar_format_def_t *srcfmt)
 {
+    unsigned long srcm, srcn;
+    uint8_t flags, *srcy, *dstp;
+    const uint8_t *srcu, *srcv;
+    unsigned srcl, xmask, ymask, x, y;
+    uint8_t y0 = 0, y1 = 0, u = 0x80, v = 0x80;
+
     uv_roundup(dst, dstfmt);
     dst->datalen = dst->width * dst->height + uvp_size(dst, dstfmt) * 2;
     dst->data = malloc(dst->datalen);
     if(!dst->data) return;
-    uint8_t *dstp = (void*)dst->data;
+    dstp = (void*)dst->data;
 
-    unsigned long srcm = uvp_size(src, srcfmt);
-    unsigned long srcn = src->width * src->height;
+    srcm = uvp_size(src, srcfmt);
+    srcn = src->width * src->height;
     assert(src->datalen >= srcn + 2 * srcn);
-    uint8_t flags = dstfmt->p.yuv.packorder ^ srcfmt->p.yuv.packorder;
-    uint8_t *srcy = (void*)src->data;
-    const uint8_t *srcu, *srcv;
+    flags = dstfmt->p.yuv.packorder ^ srcfmt->p.yuv.packorder;
+    srcy = (void*)src->data;
     if(flags & 1) {
-        srcv = src->data + srcn;
+        srcv = (uint8_t*)src->data + srcn;
         srcu = srcv + srcm;
     } else {
-        srcu = src->data + srcn;
+        srcu = (uint8_t*)src->data + srcn;
         srcv = srcu + srcm;
     }
     flags = dstfmt->p.yuv.packorder & 2;
 
-    unsigned srcl = src->width >> srcfmt->p.yuv.xsub2;
-    unsigned xmask = (1 << srcfmt->p.yuv.xsub2) - 1;
-    unsigned ymask = (1 << srcfmt->p.yuv.ysub2) - 1;
-    unsigned x, y;
-    uint8_t y0 = 0, y1 = 0, u = 0x80, v = 0x80;
+    srcl = src->width >> srcfmt->p.yuv.xsub2;
+    xmask = (1 << srcfmt->p.yuv.xsub2) - 1;
+    ymask = (1 << srcfmt->p.yuv.ysub2) - 1;
     for(y = 0; y < dst->height; y++) {
         if(y >= src->height) {
             srcy -= src->width;
@@ -448,25 +455,29 @@
                                 const zbar_image_t *src,
                                 const zbar_format_def_t *srcfmt)
 {
+    unsigned long dstn, dstm2;
+    uint8_t *dsty, flags;
+    const uint8_t *srcp;
+    unsigned srcl, x, y;
+    uint8_t y0 = 0, y1 = 0;
+
     uv_roundup(dst, dstfmt);
-    unsigned long dstn = dst->width * dst->height;
-    unsigned long dstm2 = uvp_size(dst, dstfmt) * 2;
+    dstn = dst->width * dst->height;
+    dstm2 = uvp_size(dst, dstfmt) * 2;
     dst->datalen = dstn + dstm2;
     dst->data = malloc(dst->datalen);
     if(!dst->data) return;
     if(dstm2)
-        memset((void*)dst->data + dstn, 0x80, dstm2);
-    uint8_t *dsty = (void*)dst->data;
+        memset((uint8_t*)dst->data + dstn, 0x80, dstm2);
+    dsty = (uint8_t*)dst->data;
 
-    uint8_t flags = srcfmt->p.yuv.packorder ^ dstfmt->p.yuv.packorder;
+    flags = srcfmt->p.yuv.packorder ^ dstfmt->p.yuv.packorder;
     flags &= 2;
-    const uint8_t *srcp = src->data;
+    srcp = src->data;
     if(flags)
         srcp++;
 
-    unsigned srcl = src->width + (src->width >> srcfmt->p.yuv.xsub2);
-    unsigned x, y;
-    uint8_t y0 = 0, y1 = 0;
+    srcl = src->width + (src->width >> srcfmt->p.yuv.xsub2);
     for(y = 0; y < dst->height; y++) {
         if(y >= src->height)
             srcp -= srcl;
@@ -491,15 +502,16 @@
                                   const zbar_image_t *src,
                                   const zbar_format_def_t *srcfmt)
 {
+    unsigned long dstn, dstm2;
     uv_roundup(dst, dstfmt);
-    unsigned long dstn = dst->width * dst->height;
-    unsigned long dstm2 = uvp_size(dst, dstfmt) * 2;
+    dstn = dst->width * dst->height;
+    dstm2 = uvp_size(dst, dstfmt) * 2;
     dst->datalen = dstn + dstm2;
     dst->data = malloc(dst->datalen);
     if(!dst->data) return;
     convert_y_resize(dst, dstfmt, src, srcfmt, dstn);
     if(dstm2)
-        memset((void*)dst->data + dstn, 0x80, dstm2);
+        memset((uint8_t*)dst->data + dstn, 0x80, dstm2);
 }
 
 /* rearrange interleaved UV componets */
@@ -508,19 +520,23 @@
                                  const zbar_image_t *src,
                                  const zbar_format_def_t *srcfmt)
 {
+    unsigned long dstn;
+    uint8_t *dstp, flags;
+    const uint8_t *srcp;
+    unsigned srcl, x, y;
+    uint8_t y0 = 0, y1 = 0, u = 0x80, v = 0x80;
+
     uv_roundup(dst, dstfmt);
-    unsigned long dstn = dst->width * dst->height;
+    dstn = dst->width * dst->height;
     dst->datalen = dstn + uvp_size(dst, dstfmt) * 2;
     dst->data = malloc(dst->datalen);
     if(!dst->data) return;
-    uint8_t *dstp = (void*)dst->data;
+    dstp = (void*)dst->data;
 
-    uint8_t flags = (srcfmt->p.yuv.packorder ^ dstfmt->p.yuv.packorder) & 1;
-    const uint8_t *srcp = src->data;
+    flags = (srcfmt->p.yuv.packorder ^ dstfmt->p.yuv.packorder) & 1;
+    srcp = src->data;
 
-    unsigned srcl = src->width + (src->width >> srcfmt->p.yuv.xsub2);
-    unsigned x, y;
-    uint8_t y0 = 0, y1 = 0, u = 0x80, v = 0x80;
+    srcl = src->width + (src->width >> srcfmt->p.yuv.xsub2);
     for(y = 0; y < dst->height; y++) {
         if(y >= src->height)
             srcp -= srcl;
@@ -560,25 +576,29 @@
                                  const zbar_image_t *src,
                                  const zbar_format_def_t *srcfmt)
 {
+    uint8_t *dstp, *srcy;
+    int drbits, drbit0, dgbits, dgbit0, dbbits, dbbit0;
+    unsigned long srcm, srcn;
+    unsigned x, y;
+    uint32_t p = 0;
+
     dst->datalen = dst->width * dst->height * dstfmt->p.rgb.bpp;
     dst->data = malloc(dst->datalen);
     if(!dst->data) return;
-    uint8_t *dstp = (void*)dst->data;
+    dstp = (void*)dst->data;
 
-    int drbits = RGB_SIZE(dstfmt->p.rgb.red);
-    int drbit0 = RGB_OFFSET(dstfmt->p.rgb.red);
-    int dgbits = RGB_SIZE(dstfmt->p.rgb.green);
-    int dgbit0 = RGB_OFFSET(dstfmt->p.rgb.green);
-    int dbbits = RGB_SIZE(dstfmt->p.rgb.blue);
-    int dbbit0 = RGB_OFFSET(dstfmt->p.rgb.blue);
+    drbits = RGB_SIZE(dstfmt->p.rgb.red);
+    drbit0 = RGB_OFFSET(dstfmt->p.rgb.red);
+    dgbits = RGB_SIZE(dstfmt->p.rgb.green);
+    dgbit0 = RGB_OFFSET(dstfmt->p.rgb.green);
+    dbbits = RGB_SIZE(dstfmt->p.rgb.blue);
+    dbbit0 = RGB_OFFSET(dstfmt->p.rgb.blue);
 
-    unsigned long srcm = uvp_size(src, srcfmt);
-    unsigned long srcn = src->width * src->height;
+    srcm = uvp_size(src, srcfmt);
+    srcn = src->width * src->height;
     assert(src->datalen >= srcn + 2 * srcm);
-    uint8_t *srcy = (void*)src->data;
+    srcy = (void*)src->data;
 
-    unsigned x, y;
-    uint32_t p = 0;
     for(y = 0; y < dst->height; y++) {
         if(y >= src->height)
             srcy -= src->width;
@@ -606,29 +626,34 @@
                                  const zbar_image_t *src,
                                  const zbar_format_def_t *srcfmt)
 {
+    unsigned long dstn, dstm2;
+    uint8_t *dsty;
+    const uint8_t *srcp;
+    int rbits, rbit0, gbits, gbit0, bbits, bbit0;
+    unsigned srcl, x, y;
+    uint16_t y0 = 0;
+
     uv_roundup(dst, dstfmt);
-    unsigned long dstn = dst->width * dst->height;
-    unsigned long dstm2 = uvp_size(dst, dstfmt) * 2;
+    dstn = dst->width * dst->height;
+    dstm2 = uvp_size(dst, dstfmt) * 2;
     dst->datalen = dstn + dstm2;
     dst->data = malloc(dst->datalen);
     if(!dst->data) return;
     if(dstm2)
-        memset((void*)dst->data + dstn, 0x80, dstm2);
-    uint8_t *dsty = (void*)dst->data;
+        memset((uint8_t*)dst->data + dstn, 0x80, dstm2);
+    dsty = (void*)dst->data;
 
     assert(src->datalen >= (src->width * src->height * srcfmt->p.rgb.bpp));
-    const uint8_t *srcp = src->data;
+    srcp = src->data;
 
-    int rbits = RGB_SIZE(srcfmt->p.rgb.red);
-    int rbit0 = RGB_OFFSET(srcfmt->p.rgb.red);
-    int gbits = RGB_SIZE(srcfmt->p.rgb.green);
-    int gbit0 = RGB_OFFSET(srcfmt->p.rgb.green);
-    int bbits = RGB_SIZE(srcfmt->p.rgb.blue);
-    int bbit0 = RGB_OFFSET(srcfmt->p.rgb.blue);
+    rbits = RGB_SIZE(srcfmt->p.rgb.red);
+    rbit0 = RGB_OFFSET(srcfmt->p.rgb.red);
+    gbits = RGB_SIZE(srcfmt->p.rgb.green);
+    gbit0 = RGB_OFFSET(srcfmt->p.rgb.green);
+    bbits = RGB_SIZE(srcfmt->p.rgb.blue);
+    bbit0 = RGB_OFFSET(srcfmt->p.rgb.blue);
 
-    unsigned srcl = src->width * srcfmt->p.rgb.bpp;
-    unsigned x, y;
-    uint16_t y0 = 0;
+    srcl = src->width * srcfmt->p.rgb.bpp;
     for(y = 0; y < dst->height; y++) {
         if(y >= src->height)
             srcp -= srcl;
@@ -659,29 +684,33 @@
                                 const zbar_image_t *src,
                                 const zbar_format_def_t *srcfmt)
 {
+    uint8_t *dstp;
     unsigned long dstn = dst->width * dst->height;
+    int drbits, drbit0, dgbits, dgbit0, dbbits, dbbit0;
+    const uint8_t *srcp;
+    unsigned srcl, x, y;
+    uint32_t p = 0;
+
     dst->datalen = dstn * dstfmt->p.rgb.bpp;
     dst->data = malloc(dst->datalen);
     if(!dst->data) return;
-    uint8_t *dstp = (void*)dst->data;
+    dstp = (void*)dst->data;
 
-    int drbits = RGB_SIZE(dstfmt->p.rgb.red);
-    int drbit0 = RGB_OFFSET(dstfmt->p.rgb.red);
-    int dgbits = RGB_SIZE(dstfmt->p.rgb.green);
-    int dgbit0 = RGB_OFFSET(dstfmt->p.rgb.green);
-    int dbbits = RGB_SIZE(dstfmt->p.rgb.blue);
-    int dbbit0 = RGB_OFFSET(dstfmt->p.rgb.blue);
+    drbits = RGB_SIZE(dstfmt->p.rgb.red);
+    drbit0 = RGB_OFFSET(dstfmt->p.rgb.red);
+    dgbits = RGB_SIZE(dstfmt->p.rgb.green);
+    dgbit0 = RGB_OFFSET(dstfmt->p.rgb.green);
+    dbbits = RGB_SIZE(dstfmt->p.rgb.blue);
+    dbbit0 = RGB_OFFSET(dstfmt->p.rgb.blue);
 
     assert(src->datalen >= (src->width * src->height +
                             uvp_size(src, srcfmt) * 2));
-    const uint8_t *srcp = src->data;
+    srcp = src->data;
     if(srcfmt->p.yuv.packorder & 2)
         srcp++;
 
     assert(srcfmt->p.yuv.xsub2 == 1);
-    unsigned srcl = src->width + (src->width >> 1);
-    unsigned x, y;
-    uint32_t p = 0;
+    srcl = src->width + (src->width >> 1);
     for(y = 0; y < dst->height; y++) {
         if(y >= src->height)
             srcp -= srcl;
@@ -717,26 +746,30 @@
                                 const zbar_image_t *src,
                                 const zbar_format_def_t *srcfmt)
 {
+    uint8_t *dstp, flags;
+    const uint8_t *srcp;
+    int rbits, rbit0, gbits, gbit0, bbits, bbit0;
+    unsigned srcl, x, y;
+    uint16_t y0 = 0;
+
     uv_roundup(dst, dstfmt);
     dst->datalen = dst->width * dst->height + uvp_size(dst, dstfmt) * 2;
     dst->data = malloc(dst->datalen);
     if(!dst->data) return;
-    uint8_t *dstp = (void*)dst->data;
-    uint8_t flags = dstfmt->p.yuv.packorder & 2;
+    dstp = (void*)dst->data;
+    flags = dstfmt->p.yuv.packorder & 2;
 
     assert(src->datalen >= (src->width * src->height * srcfmt->p.rgb.bpp));
-    const uint8_t *srcp = src->data;
+    srcp = src->data;
 
-    int rbits = RGB_SIZE(srcfmt->p.rgb.red);
-    int rbit0 = RGB_OFFSET(srcfmt->p.rgb.red);
-    int gbits = RGB_SIZE(srcfmt->p.rgb.green);
-    int gbit0 = RGB_OFFSET(srcfmt->p.rgb.green);
-    int bbits = RGB_SIZE(srcfmt->p.rgb.blue);
-    int bbit0 = RGB_OFFSET(srcfmt->p.rgb.blue);
+    rbits = RGB_SIZE(srcfmt->p.rgb.red);
+    rbit0 = RGB_OFFSET(srcfmt->p.rgb.red);
+    gbits = RGB_SIZE(srcfmt->p.rgb.green);
+    gbit0 = RGB_OFFSET(srcfmt->p.rgb.green);
+    bbits = RGB_SIZE(srcfmt->p.rgb.blue);
+    bbit0 = RGB_OFFSET(srcfmt->p.rgb.blue);
 
-    unsigned srcl = src->width * srcfmt->p.rgb.bpp;
-    unsigned x, y;
-    uint16_t y0 = 0;
+    srcl = src->width * srcfmt->p.rgb.bpp;
     for(y = 0; y < dst->height; y++) {
         if(y >= src->height)
             srcp -= srcl;
@@ -773,31 +806,36 @@
                                   const zbar_format_def_t *srcfmt)
 {
     unsigned long dstn = dst->width * dst->height;
+    uint8_t *dstp;
+    int drbits, drbit0, dgbits, dgbit0, dbbits, dbbit0;
+    int srbits, srbit0, sgbits, sgbit0, sbbits, sbbit0;
+    const uint8_t *srcp;
+    unsigned srcl, x, y;
+    uint32_t p = 0;
+
     dst->datalen = dstn * dstfmt->p.rgb.bpp;
     dst->data = malloc(dst->datalen);
     if(!dst->data) return;
-    uint8_t *dstp = (void*)dst->data;
+    dstp = (void*)dst->data;
 
-    int drbits = RGB_SIZE(dstfmt->p.rgb.red);
-    int drbit0 = RGB_OFFSET(dstfmt->p.rgb.red);
-    int dgbits = RGB_SIZE(dstfmt->p.rgb.green);
-    int dgbit0 = RGB_OFFSET(dstfmt->p.rgb.green);
-    int dbbits = RGB_SIZE(dstfmt->p.rgb.blue);
-    int dbbit0 = RGB_OFFSET(dstfmt->p.rgb.blue);
+    drbits = RGB_SIZE(dstfmt->p.rgb.red);
+    drbit0 = RGB_OFFSET(dstfmt->p.rgb.red);
+    dgbits = RGB_SIZE(dstfmt->p.rgb.green);
+    dgbit0 = RGB_OFFSET(dstfmt->p.rgb.green);
+    dbbits = RGB_SIZE(dstfmt->p.rgb.blue);
+    dbbit0 = RGB_OFFSET(dstfmt->p.rgb.blue);
 
     assert(src->datalen >= (src->width * src->height * srcfmt->p.rgb.bpp));
-    const uint8_t *srcp = src->data;
+    srcp = src->data;
 
-    int srbits = RGB_SIZE(srcfmt->p.rgb.red);
-    int srbit0 = RGB_OFFSET(srcfmt->p.rgb.red);
-    int sgbits = RGB_SIZE(srcfmt->p.rgb.green);
-    int sgbit0 = RGB_OFFSET(srcfmt->p.rgb.green);
-    int sbbits = RGB_SIZE(srcfmt->p.rgb.blue);
-    int sbbit0 = RGB_OFFSET(srcfmt->p.rgb.blue);
+    srbits = RGB_SIZE(srcfmt->p.rgb.red);
+    srbit0 = RGB_OFFSET(srcfmt->p.rgb.red);
+    sgbits = RGB_SIZE(srcfmt->p.rgb.green);
+    sgbit0 = RGB_OFFSET(srcfmt->p.rgb.green);
+    sbbits = RGB_SIZE(srcfmt->p.rgb.blue);
+    sbbit0 = RGB_OFFSET(srcfmt->p.rgb.blue);
 
-    unsigned srcl = src->width * srcfmt->p.rgb.bpp;
-    unsigned x, y;
-    uint32_t p = 0;
+    srcl = src->width * srcfmt->p.rgb.bpp;
     for(y = 0; y < dst->height; y++) {
         if(y >= src->height)
             y -= srcl;
@@ -928,14 +966,12 @@
     if(!src->src) {
         tmp = zbar_image_create();
         tmp->format = fourcc('Y','8','0','0');
-        tmp->width = dst->width;
-        tmp->height = dst->height;
+        _zbar_image_copy_size(tmp, dst);
     }
     else {
         tmp = src->src->jpeg_img;
         assert(tmp);
-        dst->width = tmp->width;
-        dst->height = tmp->height;
+        _zbar_image_copy_size(dst, tmp);
     }
 
     const zbar_format_def_t *tmpfmt = _zbar_format_lookup(tmp->format);
@@ -945,8 +981,7 @@
     _zbar_convert_jpeg_to_y(tmp, tmpfmt, src, srcfmt);
 
     /* now convert to dst */
-    dst->width = tmp->width;
-    dst->height = tmp->height;
+    _zbar_image_copy_size(dst, tmp);
 
     conversion_handler_t *func =
         conversions[tmpfmt->group][dstfmt->group].func;
@@ -963,10 +998,14 @@
                                          unsigned width,
                                          unsigned height)
 {
+    const zbar_format_def_t *srcfmt, *dstfmt;
+    conversion_handler_t *func;
     zbar_image_t *dst = zbar_image_create();
     dst->format = fmt;
     dst->width = width;
     dst->height = height;
+    zbar_image_set_crop(dst, src->crop_x, src->crop_y,
+                        src->crop_w, src->crop_h);
     if(src->format == fmt &&
        src->width == width &&
        src->height == height) {
@@ -974,8 +1013,8 @@
         return(dst);
     }
 
-    const zbar_format_def_t *srcfmt = _zbar_format_lookup(src->format);
-    const zbar_format_def_t *dstfmt = _zbar_format_lookup(dst->format);
+    srcfmt = _zbar_format_lookup(src->format);
+    dstfmt = _zbar_format_lookup(dst->format);
     if(!srcfmt || !dstfmt)
         /* FIXME free dst */
         return(NULL);
@@ -988,8 +1027,7 @@
         return(dst);
     }
 
-    conversion_handler_t *func =
-        conversions[srcfmt->group][dstfmt->group].func;
+    func = conversions[srcfmt->group][dstfmt->group].func;
 
     dst->cleanup = zbar_image_free_data;
     func(dst, dstfmt, src, srcfmt);
@@ -1021,6 +1059,9 @@
                        uint32_t *dst,
                        const uint32_t *dsts)
 {
+    const zbar_format_def_t *srcfmt;
+    unsigned min_cost = -1;
+
     if(dst)
         *dst = 0;
     if(!dsts)
@@ -1031,17 +1072,16 @@
             *dst = src;
         return(0);
     }
-    const zbar_format_def_t *srcfmt = _zbar_format_lookup(src);
+    srcfmt = _zbar_format_lookup(src);
     if(!srcfmt)
         return(-1);
 
     zprintf(8, "from %.4s(%08" PRIx32 ") to", (char*)&src, src);
-    unsigned min_cost = -1;
     for(; *dsts; dsts++) {
         const zbar_format_def_t *dstfmt = _zbar_format_lookup(*dsts);
+        int cost;
         if(!dstfmt)
             continue;
-        int cost;
         if(srcfmt->group == dstfmt->group &&
            srcfmt->p.cmp == dstfmt->p.cmp)
             cost = 0;
@@ -1065,13 +1105,20 @@
 int zbar_negotiate_format (zbar_video_t *vdo,
                            zbar_window_t *win)
 {
+    static const uint32_t y800[2] = { fourcc('Y','8','0','0'), 0 };
+    errinfo_t *errdst;
+    const uint32_t *srcs, *dsts;
+    unsigned min_cost = -1;
+    uint32_t min_fmt = 0;
+    const uint32_t *fmt;
+
     if(!vdo && !win)
         return(0);
 
     if(win)
         (void)window_lock(win);
 
-    errinfo_t *errdst = (vdo) ? &vdo->err : &win->err;
+    errdst = (vdo) ? &vdo->err : &win->err;
     if(verify_format_sort()) {
         if(win)
             (void)window_unlock(win);
@@ -1086,19 +1133,16 @@
                            "no input or output formats available"));
     }
 
-    static const uint32_t y800[2] = { fourcc('Y','8','0','0'), 0 };
-    const uint32_t *srcs = (vdo) ? vdo->formats : y800;
-    const uint32_t *dsts = (win) ? win->formats : y800;
+    srcs = (vdo) ? vdo->formats : y800;
+    dsts = (win) ? win->formats : y800;
 
-    unsigned min_cost = -1;
-    uint32_t min_fmt = 0;
-    const uint32_t *fmt;
     for(fmt = _zbar_formats; *fmt; fmt++) {
         /* only consider formats supported by video device */
+        uint32_t win_fmt = 0;
+        int cost;
         if(!has_format(*fmt, srcs))
             continue;
-        uint32_t win_fmt = 0;
-        int cost = _zbar_best_format(*fmt, &win_fmt, dsts);
+        cost = _zbar_best_format(*fmt, &win_fmt, dsts);
         if(cost < 0) {
             zprintf(4, "%.4s(%08" PRIx32 ") -> ? (unsupported)\n",
                     (char*)fmt, *fmt);
diff -r 563557a923d0 zbar/debug.h
--- a/zbar/debug.h	Tue Oct 27 11:25:59 2009 -0400
+++ b/zbar/debug.h	Fri Feb 22 08:54:29 2013 -0300
@@ -23,28 +23,30 @@
 
 /* varargs variations on compile time debug spew */
 
+# include <stdio.h>
+
 #ifndef DEBUG_LEVEL
 
 # ifdef __GNUC__
     /* older versions of gcc (< 2.95) require a named varargs parameter */
-#  define dprintf(args...)
+#  define dbprintf(args...) while(0)
 # else
     /* unfortunately named vararg parameter is a gcc-specific extension */
-#  define dprintf(...)
+#  define dbprintf(...) while(0)
 # endif
 
 #else
 
-# include <stdio.h>
-
 # ifdef __GNUC__
-#  define dprintf(level, args...) \
-    if((level) <= DEBUG_LEVEL)    \
-        fprintf(stderr, args)
+#  define dbprintf(level, args...) do { \
+        if((level) <= DEBUG_LEVEL)      \
+            fprintf(stderr, args);      \
+    } while(0)
 # else
-#  define dprintf(level, ...)     \
-    if((level) <= DEBUG_LEVEL)    \
-        fprintf(stderr, __VA_ARGS__)
+#  define dbprintf(level, ...) do {         \
+        if((level) <= DEBUG_LEVEL)          \
+            fprintf(stderr, __VA_ARGS__);   \
+    } while(0)
 # endif
 
 #endif /* DEBUG_LEVEL */
diff -r 563557a923d0 zbar/decoder.c
--- a/zbar/decoder.c	Tue Oct 27 11:25:59 2009 -0400
+++ b/zbar/decoder.c	Fri Feb 22 08:54:29 2013 -0300
@@ -1,5 +1,5 @@
 /*------------------------------------------------------------------------
- *  Copyright 2007-2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *  Copyright 2007-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
  *
  *  This file is part of the ZBar Bar Code Reader.
  *
@@ -27,15 +27,15 @@
 #include <string.h>     /* memset, strlen */
 
 #include <zbar.h>
-#include "decoder.h"
 
-#if defined(DEBUG_DECODER) || defined(DEBUG_EAN) ||             \
-    defined(DEBUG_CODE39) || defined(DEBUG_I25) ||              \
-    defined(DEBUG_CODE128) || defined(DEBUG_QR_FINDER) ||       \
-    (defined(DEBUG_PDF417) && (DEBUG_PDF417 >= 4))
+#if defined(DEBUG_DECODER) || defined(DEBUG_EAN) || defined(DEBUG_CODE93) || \
+    defined(DEBUG_CODE39) || defined(DEBUG_CODABAR) || defined(DEBUG_I25) || \
+    defined(DEBUG_DATABAR) || defined(DEBUG_CODE128) || \
+    defined(DEBUG_QR_FINDER) || (defined(DEBUG_PDF417) && (DEBUG_PDF417 >= 4))
 # define DEBUG_LEVEL 1
 #endif
 #include "debug.h"
+#include "decoder.h"
 
 zbar_decoder_t *zbar_decoder_create ()
 {
@@ -54,15 +54,34 @@
     dcode->ean.upce_config = 1 << ZBAR_CFG_EMIT_CHECK;
     dcode->ean.isbn10_config = 1 << ZBAR_CFG_EMIT_CHECK;
     dcode->ean.isbn13_config = 1 << ZBAR_CFG_EMIT_CHECK;
+# ifdef FIXME_ADDON_SYNC
+    dcode->ean.ean2_config = 1 << ZBAR_CFG_ENABLE;
+    dcode->ean.ean5_config = 1 << ZBAR_CFG_ENABLE;
+# endif
 #endif
 #ifdef ENABLE_I25
     dcode->i25.config = 1 << ZBAR_CFG_ENABLE;
     CFG(dcode->i25, ZBAR_CFG_MIN_LEN) = 6;
 #endif
+#ifdef ENABLE_DATABAR
+    dcode->databar.config = ((1 << ZBAR_CFG_ENABLE) |
+                             (1 << ZBAR_CFG_EMIT_CHECK));
+    dcode->databar.config_exp = ((1 << ZBAR_CFG_ENABLE) |
+                                 (1 << ZBAR_CFG_EMIT_CHECK));
+    dcode->databar.csegs = 4;
+    dcode->databar.segs = calloc(4, sizeof(*dcode->databar.segs));
+#endif
+#ifdef ENABLE_CODABAR
+    dcode->codabar.config = 1 << ZBAR_CFG_ENABLE;
+    CFG(dcode->codabar, ZBAR_CFG_MIN_LEN) = 4;
+#endif
 #ifdef ENABLE_CODE39
     dcode->code39.config = 1 << ZBAR_CFG_ENABLE;
     CFG(dcode->code39, ZBAR_CFG_MIN_LEN) = 1;
 #endif
+#ifdef ENABLE_CODE93
+    dcode->code93.config = 1 << ZBAR_CFG_ENABLE;
+#endif
 #ifdef ENABLE_CODE128
     dcode->code128.config = 1 << ZBAR_CFG_ENABLE;
 #endif
@@ -79,6 +98,10 @@
 
 void zbar_decoder_destroy (zbar_decoder_t *dcode)
 {
+#ifdef ENABLE_DATABAR
+    if(dcode->databar.segs)
+        free(dcode->databar.segs);
+#endif
     if(dcode->buf)
         free(dcode->buf);
     free(dcode);
@@ -93,9 +116,18 @@
 #ifdef ENABLE_I25
     i25_reset(&dcode->i25);
 #endif
+#ifdef ENABLE_DATABAR
+    databar_reset(&dcode->databar);
+#endif
+#ifdef ENABLE_CODABAR
+    codabar_reset(&dcode->codabar);
+#endif
 #ifdef ENABLE_CODE39
     code39_reset(&dcode->code39);
 #endif
+#ifdef ENABLE_CODE93
+    code93_reset(&dcode->code93);
+#endif
 #ifdef ENABLE_CODE128
     code128_reset(&dcode->code128);
 #endif
@@ -113,15 +145,25 @@
     memset(dcode->w, 0, sizeof(dcode->w));
     dcode->lock = 0;
     dcode->idx = 0;
+    dcode->s6 = 0;
 #ifdef ENABLE_EAN
     ean_new_scan(&dcode->ean);
 #endif
 #ifdef ENABLE_I25
     i25_reset(&dcode->i25);
 #endif
+#ifdef ENABLE_DATABAR
+    databar_new_scan(&dcode->databar);
+#endif
+#ifdef ENABLE_CODABAR
+    codabar_reset(&dcode->codabar);
+#endif
 #ifdef ENABLE_CODE39
     code39_reset(&dcode->code39);
 #endif
+#ifdef ENABLE_CODE93
+    code93_reset(&dcode->code93);
+#endif
 #ifdef ENABLE_CODE128
     code128_reset(&dcode->code128);
 #endif
@@ -149,9 +191,14 @@
     return(dcode->buflen);
 }
 
+int zbar_decoder_get_direction (const zbar_decoder_t *dcode)
+{
+    return(dcode->direction);
+}
+
 zbar_decoder_handler_t *
 zbar_decoder_set_handler (zbar_decoder_t *dcode,
-                          zbar_decoder_handler_t handler)
+                          zbar_decoder_handler_t *handler)
 {
     zbar_decoder_handler_t *result = dcode->handler;
     dcode->handler = handler;
@@ -174,68 +221,101 @@
     return(dcode->type);
 }
 
+unsigned int zbar_decoder_get_modifiers (const zbar_decoder_t *dcode)
+{
+    return(dcode->modifiers);
+}
+
 zbar_symbol_type_t zbar_decode_width (zbar_decoder_t *dcode,
                                       unsigned w)
 {
+    zbar_symbol_type_t tmp, sym = ZBAR_NONE;
+
     dcode->w[dcode->idx & (DECODE_WINDOW - 1)] = w;
-    dprintf(1, "    decode[%x]: w=%d (%g)\n", dcode->idx, w, (w / 32.));
+    dbprintf(1, "    decode[%x]: w=%d (%g)\n", dcode->idx, w, (w / 32.));
+
+    /* update shared character width */
+    dcode->s6 -= get_width(dcode, 7);
+    dcode->s6 += get_width(dcode, 1);
 
     /* each decoder processes width stream in parallel */
-    zbar_symbol_type_t sym = dcode->type = ZBAR_NONE;
-
+#ifdef ENABLE_QRCODE
+    if(TEST_CFG(dcode->qrf.config, ZBAR_CFG_ENABLE) &&
+       (tmp = _zbar_find_qr(dcode)) > ZBAR_PARTIAL)
+        sym = tmp;
+#endif
 #ifdef ENABLE_EAN
     if((dcode->ean.enable) &&
-       (sym = _zbar_decode_ean(dcode)))
-        dcode->type = sym;
+       (tmp = _zbar_decode_ean(dcode)))
+        sym = tmp;
 #endif
 #ifdef ENABLE_CODE39
     if(TEST_CFG(dcode->code39.config, ZBAR_CFG_ENABLE) &&
-       (sym = _zbar_decode_code39(dcode)) > ZBAR_PARTIAL)
-        dcode->type = sym;
+       (tmp = _zbar_decode_code39(dcode)) > ZBAR_PARTIAL)
+        sym = tmp;
+#endif
+#ifdef ENABLE_CODE93
+    if(TEST_CFG(dcode->code93.config, ZBAR_CFG_ENABLE) &&
+       (tmp = _zbar_decode_code93(dcode)) > ZBAR_PARTIAL)
+        sym = tmp;
 #endif
 #ifdef ENABLE_CODE128
     if(TEST_CFG(dcode->code128.config, ZBAR_CFG_ENABLE) &&
-       (sym = _zbar_decode_code128(dcode)) > ZBAR_PARTIAL)
-        dcode->type = sym;
+       (tmp = _zbar_decode_code128(dcode)) > ZBAR_PARTIAL)
+        sym = tmp;
+#endif
+#ifdef ENABLE_DATABAR
+    if(TEST_CFG(dcode->databar.config | dcode->databar.config_exp,
+                ZBAR_CFG_ENABLE) &&
+       (tmp = _zbar_decode_databar(dcode)) > ZBAR_PARTIAL)
+        sym = tmp;
+#endif
+#ifdef ENABLE_CODABAR
+    if(TEST_CFG(dcode->codabar.config, ZBAR_CFG_ENABLE) &&
+       (tmp = _zbar_decode_codabar(dcode)) > ZBAR_PARTIAL)
+        sym = tmp;
 #endif
 #ifdef ENABLE_I25
     if(TEST_CFG(dcode->i25.config, ZBAR_CFG_ENABLE) &&
-       (sym = _zbar_decode_i25(dcode)) > ZBAR_PARTIAL)
-        dcode->type = sym;
+       (tmp = _zbar_decode_i25(dcode)) > ZBAR_PARTIAL)
+        sym = tmp;
 #endif
 #ifdef ENABLE_PDF417
     if(TEST_CFG(dcode->pdf417.config, ZBAR_CFG_ENABLE) &&
-       (sym = _zbar_decode_pdf417(dcode)) > ZBAR_PARTIAL)
-        dcode->type = sym;
-#endif
-#ifdef ENABLE_QRCODE
-    if(TEST_CFG(dcode->qrf.config, ZBAR_CFG_ENABLE) &&
-       (sym = _zbar_find_qr(dcode)) > ZBAR_PARTIAL)
-        dcode->type = sym;
+       (tmp = _zbar_decode_pdf417(dcode)) > ZBAR_PARTIAL)
+        sym = tmp;
 #endif
 
     dcode->idx++;
-    if(dcode->type) {
+    dcode->type = sym;
+    if(sym) {
+        if(dcode->lock && sym > ZBAR_PARTIAL && sym != ZBAR_QRCODE)
+            release_lock(dcode, sym);
         if(dcode->handler)
             dcode->handler(dcode);
-        if(dcode->lock && dcode->type > ZBAR_PARTIAL)
-            dcode->lock = 0;
     }
-    return(dcode->type);
+    return(sym);
 }
 
-static inline int decoder_set_config_bool (zbar_decoder_t *dcode,
-                                           zbar_symbol_type_t sym,
-                                           zbar_config_t cfg,
-                                           int val)
+static inline const unsigned int*
+decoder_get_configp (const zbar_decoder_t *dcode,
+                     zbar_symbol_type_t sym)
 {
-    unsigned *config = NULL;
+    const unsigned int *config;
     switch(sym) {
 #ifdef ENABLE_EAN
     case ZBAR_EAN13:
         config = &dcode->ean.ean13_config;
         break;
 
+    case ZBAR_EAN2:
+        config = &dcode->ean.ean2_config;
+        break;
+
+    case ZBAR_EAN5:
+        config = &dcode->ean.ean5_config;
+        break;
+
     case ZBAR_EAN8:
         config = &dcode->ean.ean8_config;
         break;
@@ -263,12 +343,33 @@
         break;
 #endif
 
+#ifdef ENABLE_DATABAR
+    case ZBAR_DATABAR:
+        config = &dcode->databar.config;
+        break;
+    case ZBAR_DATABAR_EXP:
+        config = &dcode->databar.config_exp;
+        break;
+#endif
+
+#ifdef ENABLE_CODABAR
+    case ZBAR_CODABAR:
+        config = &dcode->codabar.config;
+        break;
+#endif
+
 #ifdef ENABLE_CODE39
     case ZBAR_CODE39:
         config = &dcode->code39.config;
         break;
 #endif
 
+#ifdef ENABLE_CODE93
+    case ZBAR_CODE93:
+        config = &dcode->code93.config;
+        break;
+#endif
+
 #ifdef ENABLE_CODE128
     case ZBAR_CODE128:
         config = &dcode->code128.config;
@@ -287,11 +388,27 @@
         break;
 #endif
 
-    /* FIXME handle addons */
+    default:
+        config = NULL;
+    }
+    return(config);
+}
 
-    default:
-        return(1);
-    }
+unsigned int zbar_decoder_get_configs (const zbar_decoder_t *dcode,
+                                       zbar_symbol_type_t sym)
+{
+    const unsigned *config = decoder_get_configp(dcode, sym);
+    if(!config)
+        return(0);
+    return(*config);
+}
+
+static inline int decoder_set_config_bool (zbar_decoder_t *dcode,
+                                           zbar_symbol_type_t sym,
+                                           zbar_config_t cfg,
+                                           int val)
+{
+    unsigned *config = (void*)decoder_get_configp(dcode, sym);
     if(!config || cfg >= ZBAR_CFG_NUM)
         return(1);
 
@@ -304,6 +421,8 @@
 
 #ifdef ENABLE_EAN
     dcode->ean.enable = TEST_CFG(dcode->ean.ean13_config |
+                                 dcode->ean.ean2_config |
+                                 dcode->ean.ean5_config |
                                  dcode->ean.ean8_config |
                                  dcode->ean.upca_config |
                                  dcode->ean.upce_config |
@@ -327,11 +446,21 @@
         CFG(dcode->i25, cfg) = val;
         break;
 #endif
+#ifdef ENABLE_CODABAR
+    case ZBAR_CODABAR:
+        CFG(dcode->codabar, cfg) = val;
+        break;
+#endif
 #ifdef ENABLE_CODE39
     case ZBAR_CODE39:
         CFG(dcode->code39, cfg) = val;
         break;
 #endif
+#ifdef ENABLE_CODE93
+    case ZBAR_CODE93:
+        CFG(dcode->code93, cfg) = val;
+        break;
+#endif
 #ifdef ENABLE_CODE128
     case ZBAR_CODE128:
         CFG(dcode->code128, cfg) = val;
@@ -355,17 +484,16 @@
                              int val)
 {
     if(sym == ZBAR_NONE) {
-        zbar_decoder_set_config(dcode, ZBAR_EAN13, cfg, val);
-        zbar_decoder_set_config(dcode, ZBAR_EAN8, cfg, val);
-        zbar_decoder_set_config(dcode, ZBAR_UPCA, cfg, val);
-        zbar_decoder_set_config(dcode, ZBAR_UPCE, cfg, val);
-        zbar_decoder_set_config(dcode, ZBAR_ISBN10, cfg, val);
-        zbar_decoder_set_config(dcode, ZBAR_ISBN13, cfg, val);
-        zbar_decoder_set_config(dcode, ZBAR_I25, cfg, val);
-        zbar_decoder_set_config(dcode, ZBAR_CODE39, cfg, val);
-        zbar_decoder_set_config(dcode, ZBAR_CODE128, cfg, val);
-        zbar_decoder_set_config(dcode, ZBAR_PDF417, cfg, val);
-        zbar_decoder_set_config(dcode, ZBAR_QRCODE, cfg, val);
+        static const zbar_symbol_type_t all[] = {
+	    ZBAR_EAN13, ZBAR_EAN2, ZBAR_EAN5, ZBAR_EAN8,
+            ZBAR_UPCA, ZBAR_UPCE, ZBAR_ISBN10, ZBAR_ISBN13,
+            ZBAR_I25, ZBAR_DATABAR, ZBAR_DATABAR_EXP, ZBAR_CODABAR,
+	    ZBAR_CODE39, ZBAR_CODE93, ZBAR_CODE128, ZBAR_QRCODE, 
+	    ZBAR_PDF417, 0
+        };
+        const zbar_symbol_type_t *symp;
+        for(symp = all; *symp; symp++)
+            zbar_decoder_set_config(dcode, *symp, cfg, val);
         return(0);
     }
 
@@ -385,16 +513,18 @@
                                     unsigned int buflen)
 {
     int dumplen = (buflen * 3) + 12;
+    char *p;
+    int i;
+
     if(!decoder_dump || dumplen > decoder_dumplen) {
         if(decoder_dump)
             free(decoder_dump);
         decoder_dump = malloc(dumplen);
         decoder_dumplen = dumplen;
     }
-    char *p = decoder_dump +
+    p = decoder_dump +
         snprintf(decoder_dump, 12, "buf[%04x]=",
                  (buflen > 0xffff) ? 0xffff : buflen);
-    int i;
     for(i = 0; i < buflen; i++)
         p += snprintf(p, 4, "%s%02x", (i) ? " " : "",  buf[i]);
     return(decoder_dump);
diff -r 563557a923d0 zbar/decoder.h
--- a/zbar/decoder.h	Tue Oct 27 11:25:59 2009 -0400
+++ b/zbar/decoder.h	Fri Feb 22 08:54:29 2013 -0300
@@ -1,5 +1,5 @@
 /*------------------------------------------------------------------------
- *  Copyright 2007-2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *  Copyright 2007-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
  *
  *  This file is part of the ZBar Bar Code Reader.
  *
@@ -25,9 +25,12 @@
 
 #include <config.h>
 #include <stdlib.h>     /* realloc */
+#include <limits.h>
 
 #include <zbar.h>
 
+#include "debug.h"
+
 #define NUM_CFGS (ZBAR_CFG_MAX_LEN - ZBAR_CFG_MIN_LEN + 1)
 
 #ifdef ENABLE_EAN
@@ -36,9 +39,18 @@
 #ifdef ENABLE_I25
 # include "decoder/i25.h"
 #endif
+#ifdef ENABLE_DATABAR
+# include "decoder/databar.h"
+#endif
+#ifdef ENABLE_CODABAR
+# include "decoder/codabar.h"
+#endif
 #ifdef ENABLE_CODE39
 # include "decoder/code39.h"
 #endif
+#ifdef ENABLE_CODE93
+# include "decoder/code93.h"
+#endif
 #ifdef ENABLE_CODE128
 # include "decoder/code128.h"
 #endif
@@ -73,6 +85,7 @@
 
 #define CFG(dcode, cfg) ((dcode).configs[(cfg) - ZBAR_CFG_MIN_LEN])
 #define TEST_CFG(config, cfg) (((config) >> (cfg)) & 1)
+#define MOD(mod) (1 << (mod))
 
 /* symbology independent decoder state */
 struct zbar_decoder_s {
@@ -80,6 +93,9 @@
     unsigned w[DECODE_WINDOW];          /* window of last N bar widths */
     zbar_symbol_type_t type;            /* type of last decoded data */
     zbar_symbol_type_t lock;            /* buffer lock */
+    unsigned modifiers;                 /* symbology modifier */
+    int direction;                      /* direction of last decoded data */
+    unsigned s6;                        /* 6-element character width */
 
     /* everything above here is automatically reset */
     unsigned buf_alloc;                 /* dynamic buffer allocation */
@@ -95,9 +111,18 @@
 #ifdef ENABLE_I25
     i25_decoder_t i25;                  /* Interleaved 2 of 5 decode state */
 #endif
+#ifdef ENABLE_DATABAR
+    databar_decoder_t databar;          /* DataBar decode state */
+#endif
+#ifdef ENABLE_CODABAR
+    codabar_decoder_t codabar;          /* Codabar decode state */
+#endif
 #ifdef ENABLE_CODE39
     code39_decoder_t code39;            /* Code 39 decode state */
 #endif
+#ifdef ENABLE_CODE93
+    code93_decoder_t code93;            /* Code 93 decode state */
+#endif
 #ifdef ENABLE_CODE128
     code128_decoder_t code128;          /* Code 128 decode state */
 #endif
@@ -167,20 +192,86 @@
     return((E >= n - 3) ? -1 : E);
 }
 
+/* sort three like-colored elements and return ordering
+ */
+static inline unsigned decode_sort3 (zbar_decoder_t *dcode,
+                                     int i0)
+{
+    unsigned w0 = get_width(dcode, i0);
+    unsigned w2 = get_width(dcode, i0 + 2);
+    unsigned w4 = get_width(dcode, i0 + 4);
+    if(w0 < w2) {
+        if(w2 < w4)
+            return((i0 << 8) | ((i0 + 2) << 4) | (i0 + 4));
+        if(w0 < w4)
+            return((i0 << 8) | ((i0 + 4) << 4) | (i0 + 2));
+        return(((i0 + 4) << 8) | (i0 << 4) | (i0 + 2));
+    }
+    if(w4 < w2)
+        return(((i0 + 4) << 8) | ((i0 + 2) << 4) | i0);
+    if(w0 < w4)
+        return(((i0 + 2) << 8) | (i0 << 4) | (i0 + 4));
+    return(((i0 + 2) << 8) | ((i0 + 4) << 4) | i0);
+}
+
+/* sort N like-colored elements and return ordering
+ */
+static inline unsigned decode_sortn (zbar_decoder_t *dcode,
+                                     int n,
+                                     int i0)
+{
+    unsigned mask = 0, sort = 0;
+    int i;
+    for(i = n - 1; i >= 0; i--) {
+        unsigned wmin = UINT_MAX;
+        int jmin = -1, j;
+        for(j = n - 1; j >= 0; j--) {
+            if((mask >> j) & 1)
+                continue;
+            unsigned w = get_width(dcode, i0 + j * 2);
+            if(wmin >= w) {
+                wmin = w;
+                jmin = j;
+            }
+        }
+        zassert(jmin >= 0, 0, "sortn(%d,%d) jmin=%d",
+                n, i0, jmin);
+        sort <<= 4;
+        mask |= 1 << jmin;
+        sort |= i0 + jmin * 2;
+    }
+    return(sort);
+}
+
 /* acquire shared state lock */
-static inline char get_lock (zbar_decoder_t *dcode,
-                             zbar_symbol_type_t req)
+static inline char acquire_lock (zbar_decoder_t *dcode,
+                                 zbar_symbol_type_t req)
 {
-    if(dcode->lock)
+    if(dcode->lock) {
+        dbprintf(2, " [locked %d]\n", dcode->lock);
         return(1);
+    }
     dcode->lock = req;
     return(0);
 }
 
+/* check and release shared state lock */
+static inline char release_lock (zbar_decoder_t *dcode,
+                                 zbar_symbol_type_t req)
+{
+    zassert(dcode->lock == req, 1, "lock=%d req=%d\n",
+            dcode->lock, req);
+    dcode->lock = 0;
+    return(0);
+}
+
 /* ensure output buffer has sufficient allocation for request */
 static inline char size_buf (zbar_decoder_t *dcode,
                              unsigned len)
 {
+    unsigned char *buf;
+    if(len <= BUFFER_MIN)
+        return(0);
     if(len < dcode->buf_alloc)
         /* FIXME size reduction heuristic? */
         return(0);
@@ -191,7 +282,7 @@
         if(len > BUFFER_MAX)
             len = BUFFER_MAX;
     }
-    unsigned char *buf = realloc(dcode->buf, len);
+    buf = realloc(dcode->buf, len);
     if(!buf)
         return(1);
     dcode->buf = buf;
@@ -200,6 +291,6 @@
 }
 
 extern const char *_zbar_decoder_buf_dump (unsigned char *buf,
-                                            unsigned int buflen);
+                                           unsigned int buflen);
 
 #endif
diff -r 563557a923d0 zbar/decoder/codabar.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/zbar/decoder/codabar.c	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,437 @@
+/*------------------------------------------------------------------------
+ *  Copyright 2011 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *
+ *  This file is part of the ZBar Bar Code Reader.
+ *
+ *  The ZBar Bar Code Reader is free software; you can redistribute it
+ *  and/or modify it under the terms of the GNU Lesser Public License as
+ *  published by the Free Software Foundation; either version 2.1 of
+ *  the License, or (at your option) any later version.
+ *
+ *  The ZBar Bar Code Reader is distributed in the hope that it will be
+ *  useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+ *  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser Public License
+ *  along with the ZBar Bar Code Reader; if not, write to the Free
+ *  Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ *  Boston, MA  02110-1301  USA
+ *
+ *  http://sourceforge.net/projects/zbar
+ *------------------------------------------------------------------------*/
+
+#include <config.h>
+#include <string.h>     /* memmove */
+
+#include <zbar.h>
+
+#ifdef DEBUG_CODABAR
+# define DEBUG_LEVEL (DEBUG_CODABAR)
+#endif
+#include "debug.h"
+#include "decoder.h"
+
+#define NIBUF 6 /* initial scan buffer size */
+
+static const signed char codabar_lo[12] = {
+    0x0, 0x1, 0x4, 0x5, 0x2, 0xa, 0xb, 0x9,
+    0x6, 0x7, 0x8, 0x3
+};
+
+static const unsigned char codabar_hi[8] = {
+    0x1, 0x4, 0x7, 0x6, 0x2, 0x3, 0x0, 0x5
+};
+
+static const unsigned char codabar_characters[20] =
+    "0123456789-$:/.+ABCD";
+
+static inline int
+check_width (unsigned ref,
+             unsigned w)
+{
+    unsigned dref = ref;
+    ref *= 4;
+    w *= 4;
+    return(ref - dref <= w && w <= ref + dref);
+}
+
+static inline signed char
+codabar_decode7 (zbar_decoder_t *dcode)
+{
+    codabar_decoder_t *codabar = &dcode->codabar;
+    unsigned s = codabar->s7;
+    dbprintf(2, " s=%d", s);
+    if(s < 7)
+        return(-1);
+
+    /* check width */
+    if(!check_width(codabar->width, s)) {
+        dbprintf(2, " [width]");
+        return(-1);
+    }
+
+    /* extract min/max bar */
+    unsigned ibar = decode_sortn(dcode, 4, 1);
+    dbprintf(2, " bar=%04x", ibar);
+
+    unsigned wbmax = get_width(dcode, ibar & 0xf);
+    unsigned wbmin = get_width(dcode, ibar >> 12);
+    if(8 * wbmin < wbmax ||
+       3 * wbmin > 2 * wbmax)
+    {
+        dbprintf(2, " [bar outer ratio]");
+        return(-1);
+    }
+
+    unsigned wb1 = get_width(dcode, (ibar >> 8) & 0xf);
+    unsigned wb2 = get_width(dcode, (ibar >> 4) & 0xf);
+    unsigned long b0b3 = wbmin * wbmax;
+    unsigned long b1b2 = wb1 * wb2;
+    if(b1b2 + b1b2 / 8 < b0b3) {
+        /* single wide bar combinations */
+        if(8 * wbmin < 5 * wb1 ||
+           8 * wb1 < 5 * wb2 ||
+           4 * wb2 > 3 * wbmax ||
+           wb2 * wb2 >= wb1 * wbmax)
+        {
+            dbprintf(2, " [1bar inner ratios]");
+            return(-1);
+        }
+        ibar = (ibar >> 1) & 0x3;
+    }
+    else if(b1b2 > b0b3 + b0b3 / 8) {
+        /* three wide bars, no wide spaces */
+        if(4 * wbmin > 3 * wb1 ||
+           8 * wb1 < 5 * wb2 ||
+           8 * wb2 < 5 * wbmax ||
+           wbmin * wb2 >= wb1 * wb1)
+        {
+            dbprintf(2, " [3bar inner ratios]");
+            return(-1);
+        }
+        ibar = (ibar >> 13) + 4;
+    }
+    else {
+        dbprintf(2, " [bar inner ratios]");
+        return(-1);
+    }
+
+    unsigned ispc = decode_sort3(dcode, 2);
+    dbprintf(2, "(%x) spc=%03x", ibar, ispc);
+
+    unsigned wsmax = get_width(dcode, ispc & 0xf);
+    unsigned wsmid = get_width(dcode, (ispc >> 4) & 0xf);
+    unsigned wsmin = get_width(dcode, (ispc >> 8) & 0xf);
+    if(ibar >> 2) {
+        /* verify no wide spaces */
+        if(8 * wsmin < wsmax ||
+           8 * wsmin < 5 * wsmid ||
+           8 * wsmid < 5 * wsmax)
+        {
+            dbprintf(2, " [0space inner ratios]");
+            return(-1);
+        }
+        ibar &= 0x3;
+        if(codabar->direction)
+            ibar = 3 - ibar;
+        int c = (0xfcde >> (ibar << 2)) & 0xf;
+        dbprintf(2, " ex[%d]=%x", ibar, c);
+        return(c);
+    }
+    else if(8 * wsmin < wsmax ||
+            3 * wsmin > 2 * wsmax)
+    {
+        dbprintf(2, " [space outer ratio]");
+        return(-1);
+    }
+
+    unsigned long s0s2 = wsmin * wsmax;
+    unsigned long s1s1 = wsmid * wsmid;
+    if(s1s1 + s1s1 / 8 < s0s2) {
+        /* single wide space */
+        if(8 * wsmin < 5 * wsmid ||
+           4 * wsmid > 3 * wsmax)
+        {
+            dbprintf(2, " [1space inner ratios]");
+            return(-1);
+        }
+        ispc = ((ispc & 0xf) >> 1) - 1;
+        unsigned ic = (ispc << 2) | ibar;
+        if(codabar->direction)
+            ic = 11 - ic;
+        int c = codabar_lo[ic];
+        dbprintf(2, "(%d) lo[%d]=%x", ispc, ic, c);
+        return(c);
+    }
+    else if(s1s1 > s0s2 + s0s2 / 8) {
+        /* two wide spaces, check start/stop */
+        if(4 * wsmin > 3 * wsmid ||
+           8 * wsmid < 5 * wsmax)
+        {
+            dbprintf(2, " [2space inner ratios]");
+            return(-1);
+        }
+        if((ispc >> 8) == 4) {
+            dbprintf(2, " [space comb]");
+            return(-1);
+        }
+        ispc >>= 10;
+        dbprintf(2, "(%d)", ispc);
+        unsigned ic = ispc * 4 + ibar;
+        zassert(ic < 8, -1, "ic=%d ispc=%d ibar=%d", ic, ispc, ibar);
+        unsigned char c = codabar_hi[ic];
+        if(c >> 2 != codabar->direction) {
+            dbprintf(2, " [invalid stop]");
+            return(-1);
+        }
+        c = (c & 0x3) | 0x10;
+        dbprintf(2, " hi[%d]=%x", ic, c);
+        return(c);
+    }
+    else {
+        dbprintf(2, " [space inner ratios]");
+        return(-1);
+    }
+}
+
+static inline signed char
+codabar_decode_start (zbar_decoder_t *dcode)
+{
+    codabar_decoder_t *codabar = &dcode->codabar;
+    unsigned s = codabar->s7;
+    if(s < 8)
+        return(ZBAR_NONE);
+    dbprintf(2, "      codabar: s=%d", s);
+
+    /* check leading quiet zone - spec is 10x */
+    unsigned qz = get_width(dcode, 8);
+    if((qz && qz * 2 < s) ||
+       4 * get_width(dcode, 0) > 3 * s)
+    {
+        dbprintf(2, " [invalid qz/ics]\n");
+        return(ZBAR_NONE);
+    }
+
+    /* check space ratios first */
+    unsigned ispc = decode_sort3(dcode, 2);
+    dbprintf(2, " spc=%03x", ispc);
+    if((ispc >> 8) == 4) {
+        dbprintf(2, " [space comb]\n");
+        return(ZBAR_NONE);
+    }
+
+    /* require 2 wide and 1 narrow spaces */
+    unsigned wsmax = get_width(dcode, ispc & 0xf);
+    unsigned wsmin = get_width(dcode, ispc >> 8);
+    unsigned wsmid = get_width(dcode, (ispc >> 4) & 0xf);
+    if(8 * wsmin < wsmax ||
+       3 * wsmin > 2 * wsmax ||
+       4 * wsmin > 3 * wsmid ||
+       8 * wsmid < 5 * wsmax ||
+       wsmid * wsmid <= wsmax * wsmin)
+    {
+        dbprintf(2, " [space ratio]\n");
+        return(ZBAR_NONE);
+    }
+    ispc >>= 10;
+    dbprintf(2, "(%d)", ispc);
+
+    /* check bar ratios */
+    unsigned ibar = decode_sortn(dcode, 4, 1);
+    dbprintf(2, " bar=%04x", ibar);
+
+    unsigned wbmax = get_width(dcode, ibar & 0xf);
+    unsigned wbmin = get_width(dcode, ibar >> 12);
+    if(8 * wbmin < wbmax ||
+       3 * wbmin > 2 * wbmax)
+    {
+        dbprintf(2, " [bar outer ratio]\n");
+        return(ZBAR_NONE);
+    }
+
+    /* require 1 wide & 3 narrow bars */
+    unsigned wb1 = get_width(dcode, (ibar >> 8) & 0xf);
+    unsigned wb2 = get_width(dcode, (ibar >> 4) & 0xf);
+    if(8 * wbmin < 5 * wb1 ||
+       8 * wb1 < 5 * wb2 ||
+       4 * wb2 > 3 * wbmax ||
+       wb1 * wb2 >= wbmin * wbmax ||
+       wb2 * wb2 >= wb1 * wbmax)
+    {
+        dbprintf(2, " [bar inner ratios]\n");
+        return(ZBAR_NONE);
+    }
+    ibar = ((ibar & 0xf) - 1) >> 1;
+    dbprintf(2, "(%d)", ibar);
+
+    /* decode combination */
+    int ic = ispc * 4 + ibar;
+    zassert(ic < 8, ZBAR_NONE, "ic=%d ispc=%d ibar=%d", ic, ispc, ibar);
+    int c = codabar_hi[ic];
+    codabar->buf[0] = (c & 0x3) | 0x10;
+
+    /* set character direction */
+    codabar->direction = c >> 2;
+
+    codabar->element = 4;
+    codabar->character = 1;
+    codabar->width = codabar->s7;
+    dbprintf(1, " start=%c dir=%x [valid start]\n",
+             codabar->buf[0] + 0x31, codabar->direction);
+    return(ZBAR_PARTIAL);
+}
+
+static inline int
+codabar_checksum (zbar_decoder_t *dcode,
+                  unsigned n)
+{
+    unsigned chk = 0;
+    unsigned char *buf = dcode->buf;
+    while(n--)
+        chk += *(buf++);
+    return(!!(chk & 0xf));
+}
+
+static inline zbar_symbol_type_t
+codabar_postprocess (zbar_decoder_t *dcode)
+{
+    codabar_decoder_t *codabar = &dcode->codabar;
+    int dir = codabar->direction;
+    dcode->direction = 1 - 2 * dir;
+    int i, n = codabar->character;
+    for(i = 0; i < NIBUF; i++)
+        dcode->buf[i] = codabar->buf[i];
+    if(dir)
+        /* reverse buffer */
+        for(i = 0; i < n / 2; i++) {
+            unsigned j = n - 1 - i;
+            char code = dcode->buf[i];
+            dcode->buf[i] = dcode->buf[j];
+            dcode->buf[j] = code;
+        }
+
+    if(TEST_CFG(codabar->config, ZBAR_CFG_ADD_CHECK)) {
+        /* validate checksum */
+        if(codabar_checksum(dcode, n))
+            return(ZBAR_NONE);
+        if(!TEST_CFG(codabar->config, ZBAR_CFG_EMIT_CHECK)) {
+            dcode->buf[n - 2] = dcode->buf[n - 1];
+            n--;
+        }
+    }
+
+    for(i = 0; i < n; i++) {
+        unsigned c = dcode->buf[i];
+        dcode->buf[i] = ((c < 0x14)
+                         ? codabar_characters[c]
+                         : '?');
+    }
+    dcode->buflen = i;
+    dcode->buf[i] = '\0';
+    dcode->modifiers = 0;
+
+    codabar->character = -1;
+    return(ZBAR_CODABAR);
+}
+
+zbar_symbol_type_t
+_zbar_decode_codabar (zbar_decoder_t *dcode)
+{
+    codabar_decoder_t *codabar = &dcode->codabar;
+
+    /* update latest character width */
+    codabar->s7 -= get_width(dcode, 8);
+    codabar->s7 += get_width(dcode, 1);
+
+    if(get_color(dcode) != ZBAR_SPACE)
+        return(ZBAR_NONE);
+    if(codabar->character < 0)
+        return(codabar_decode_start(dcode));
+    if(codabar->character < 2 &&
+       codabar_decode_start(dcode))
+        return(ZBAR_PARTIAL);
+    if(--codabar->element)
+        return(ZBAR_NONE);
+    codabar->element = 4;
+
+    dbprintf(1, "      codabar[%c%02d+%x]",
+             (codabar->direction) ? '<' : '>',
+             codabar->character, codabar->element);
+
+    signed char c = codabar_decode7(dcode);
+    dbprintf(1, " %d", c);
+    if(c < 0) {
+        dbprintf(1, " [aborted]\n");
+        goto reset;
+    }
+
+    unsigned char *buf;
+    if(codabar->character < NIBUF)
+        buf = codabar->buf;
+    else {
+        if(codabar->character >= BUFFER_MIN &&
+           size_buf(dcode, codabar->character + 1))
+        {
+            dbprintf(1, " [overflow]\n");
+            goto reset;
+        }
+        buf = dcode->buf;
+    }
+    buf[codabar->character++] = c;
+
+    /* lock shared resources */
+    if(codabar->character == NIBUF &&
+       acquire_lock(dcode, ZBAR_CODABAR))
+    {
+        codabar->character = -1;
+        return(ZBAR_PARTIAL);
+    }
+
+    unsigned s = codabar->s7;
+    if(c & 0x10) {
+        unsigned qz = get_width(dcode, 0);
+        if(qz && qz * 2 < s) {
+            dbprintf(2, " [invalid qz]\n");
+            goto reset;
+        }
+        unsigned n = codabar->character;
+        if(n < CFG(*codabar, ZBAR_CFG_MIN_LEN) ||
+           (CFG(*codabar, ZBAR_CFG_MAX_LEN) > 0 &&
+            n > CFG(*codabar, ZBAR_CFG_MAX_LEN)))
+        {
+            dbprintf(2, " [invalid len]\n");
+            goto reset;
+        }
+        if(codabar->character < NIBUF &&
+           acquire_lock(dcode, ZBAR_CODABAR))
+        {
+            codabar->character = -1;
+            return(ZBAR_PARTIAL);
+        }
+        dbprintf(2, " stop=%c", c + 0x31);
+
+        zbar_symbol_type_t sym = codabar_postprocess(dcode);
+        if(sym > ZBAR_PARTIAL)
+            dbprintf(2, " [valid stop]");
+        else {
+            release_lock(dcode, ZBAR_CODABAR);
+            codabar->character = -1;
+        }
+        dbprintf(2, "\n");
+        return(sym);
+    }
+    else if(4 * get_width(dcode, 0) > 3 * s) {
+        dbprintf(2, " [ics]\n");
+        goto reset;
+    }
+
+    dbprintf(2, "\n");
+    return(ZBAR_NONE);
+
+reset:
+    if(codabar->character >= NIBUF)
+        release_lock(dcode, ZBAR_CODABAR);
+    codabar->character = -1;
+    return(ZBAR_NONE);
+}
diff -r 563557a923d0 zbar/decoder/codabar.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/zbar/decoder/codabar.h	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,51 @@
+/*------------------------------------------------------------------------
+ *  Copyright 2011 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *
+ *  This file is part of the ZBar Bar Code Reader.
+ *
+ *  The ZBar Bar Code Reader is free software; you can redistribute it
+ *  and/or modify it under the terms of the GNU Lesser Public License as
+ *  published by the Free Software Foundation; either version 2.1 of
+ *  the License, or (at your option) any later version.
+ *
+ *  The ZBar Bar Code Reader is distributed in the hope that it will be
+ *  useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+ *  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser Public License
+ *  along with the ZBar Bar Code Reader; if not, write to the Free
+ *  Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ *  Boston, MA  02110-1301  USA
+ *
+ *  http://sourceforge.net/projects/zbar
+ *------------------------------------------------------------------------*/
+#ifndef _CODABAR_H_
+#define _CODABAR_H_
+
+/* Codabar specific decode state */
+typedef struct codabar_decoder_s {
+    unsigned direction : 1;     /* scan direction: 0=fwd, 1=rev */
+    unsigned element : 4;       /* element offset 0-7 */
+    int character : 12;         /* character position in symbol */
+    unsigned s7;                /* current character width */
+    unsigned width;             /* last character width */
+    unsigned char buf[6];       /* initial scan buffer */
+
+    unsigned config;
+    int configs[NUM_CFGS];      /* int valued configurations */
+} codabar_decoder_t;
+
+/* reset Codabar specific state */
+static inline void codabar_reset (codabar_decoder_t *codabar)
+{
+    codabar->direction = 0;
+    codabar->element = 0;
+    codabar->character = -1;
+    codabar->s7 = 0;
+}
+
+/* decode Codabar symbols */
+zbar_symbol_type_t _zbar_decode_codabar(zbar_decoder_t *dcode);
+
+#endif
diff -r 563557a923d0 zbar/decoder/code128.c
--- a/zbar/decoder/code128.c	Tue Oct 27 11:25:59 2009 -0400
+++ b/zbar/decoder/code128.c	Fri Feb 22 08:54:29 2013 -0300
@@ -1,5 +1,5 @@
 /*------------------------------------------------------------------------
- *  Copyright 2007-2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *  Copyright 2007-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
  *
  *  This file is part of the ZBar Bar Code Reader.
  *
@@ -25,12 +25,12 @@
 #include <string.h>     /* memmove */
 
 #include <zbar.h>
-#include "decoder.h"
 
 #ifdef DEBUG_CODE128
 # define DEBUG_LEVEL (DEBUG_CODE128)
 #endif
 #include "debug.h"
+#include "decoder.h"
 
 #define NUM_CHARS 108           /* total number of character codes */
 
@@ -120,6 +120,8 @@
                             ((sig >> 5) & 0x18) |
                             ((sig >> 7) & 0x60));
     unsigned char idx = lo_offset[offset];
+    unsigned char base, c;
+
     if(sig & 1)
         idx &= 0xf;
     else
@@ -127,31 +129,31 @@
     if(idx == 0xf)
         return(-1);
 
-    unsigned char base = (sig >> 11) | ((sig >> 9) & 1);
+    base = (sig >> 11) | ((sig >> 9) & 1);
     zassert(base < 8, -1, "sig=%x offset=%x idx=%x base=%x\n",
             sig, offset, idx, base);
     idx += lo_base[base];
 
     zassert(idx <= 0x50, -1, "sig=%x offset=%x base=%x idx=%x\n",
             sig, offset, base, idx);
-    unsigned char c = characters[idx];
-    dprintf(2, " %02x(%x(%02x)/%x(%02x)) => %02x",
-            idx, base, lo_base[base], offset, lo_offset[offset],
-            (unsigned char)c);
+    c = characters[idx];
+    dbprintf(2, " %02x(%x(%02x)/%x(%02x)) => %02x",
+             idx, base, lo_base[base], offset, lo_offset[offset],
+             (unsigned char)c);
     return(c);
 }
 
 static inline signed char decode_hi (int sig)
 {
     unsigned char rev = (sig & 0x4400) != 0;
+    unsigned char idx, c;
     if(rev)
         sig = (((sig >> 12) & 0x000f) |
                ((sig >>  4) & 0x00f0) |
                ((sig <<  4) & 0x0f00) |
                ((sig << 12) & 0xf000));
-    dprintf(2, " rev=%x", rev != 0);
+    dbprintf(2, " rev=%x", rev != 0);
 
-    unsigned char idx;
     switch(sig) {
     case 0x0014: idx = 0x0; break;
     case 0x0025: idx = 0x1; break;
@@ -171,8 +173,8 @@
     }
     if(rev)
         idx += 0xe;
-    unsigned char c = characters[0x51 + idx];
-    dprintf(2, " %02x => %02x", idx, c);
+    c = characters[0x51 + idx];
+    dbprintf(2, " %02x => %02x", idx, c);
     return(c);
 }
 
@@ -190,13 +192,18 @@
 
 static inline signed char decode6 (zbar_decoder_t *dcode)
 {
+    int sig;
+    signed char c, chk;
+    unsigned bars;
+
     /* build edge signature of character */
     unsigned s = dcode->code128.s6;
-    dprintf(2, " s=%d", s);
+
+    dbprintf(2, " s=%d", s);
     if(s < 5)
         return(-1);
     /* calculate similar edge measurements */
-    int sig = (get_color(dcode) == ZBAR_BAR)
+    sig = (get_color(dcode) == ZBAR_BAR)
         ? ((decode_e(get_width(dcode, 0) + get_width(dcode, 1), s, 11) << 12) |
            (decode_e(get_width(dcode, 1) + get_width(dcode, 2), s, 11) << 8) |
            (decode_e(get_width(dcode, 2) + get_width(dcode, 3), s, 11) << 4) |
@@ -207,19 +214,19 @@
            (decode_e(get_width(dcode, 2) + get_width(dcode, 1), s, 11)));
     if(sig < 0)
         return(-1);
-    dprintf(2, " sig=%04x", sig);
+    dbprintf(2, " sig=%04x", sig);
     /* lookup edge signature */
-    signed char c = (sig & 0x4444) ? decode_hi(sig) : decode_lo(sig);
+    c = (sig & 0x4444) ? decode_hi(sig) : decode_lo(sig);
     if(c == -1)
         return(-1);
 
     /* character validation */
-    unsigned bars = (get_color(dcode) == ZBAR_BAR)
+    bars = (get_color(dcode) == ZBAR_BAR)
         ? (get_width(dcode, 0) + get_width(dcode, 2) + get_width(dcode, 4))
         : (get_width(dcode, 1) + get_width(dcode, 3) + get_width(dcode, 5));
     bars = bars * 11 * 4 / s;
-    unsigned char chk = calc_check(c);
-    dprintf(2, " bars=%d chk=%d", bars, chk);
+    chk = calc_check(c);
+    dbprintf(2, " bars=%d chk=%d", bars, chk);
     if(chk - 7 > bars || bars > chk + 7)
         return(-1);
 
@@ -228,18 +235,20 @@
 
 static inline unsigned char validate_checksum (zbar_decoder_t *dcode)
 {
+    unsigned idx, sum, i, acc = 0;
+    unsigned char check, err;
+
     code128_decoder_t *dcode128 = &dcode->code128;
     if(dcode128->character < 3)
         return(1);
 
     /* add in irregularly weighted start character */
-    unsigned idx = (dcode128->direction) ? dcode128->character - 1 : 0;
-    unsigned sum = dcode->buf[idx];
+    idx = (dcode128->direction) ? dcode128->character - 1 : 0;
+    sum = dcode->buf[idx];
     if(sum >= 103)
         sum -= 103;
 
     /* calculate sum in reverse to avoid multiply operations */
-    unsigned i, acc = 0;
     for(i = dcode128->character - 3; i; i--) {
         zassert(sum < 103, -1, "dir=%x i=%x sum=%x acc=%x %s\n",
                 dcode128->direction, i, sum, acc,
@@ -258,11 +267,11 @@
 
     /* and compare to check character */
     idx = (dcode128->direction) ? 1 : dcode128->character - 2;
-    unsigned char check = dcode->buf[idx];
-    dprintf(2, " chk=%02x(%02x)", sum, check);
-    unsigned char err = (sum != check);
+    check = dcode->buf[idx];
+    dbprintf(2, " chk=%02x(%02x)", sum, check);
+    err = (sum != check);
     if(err)
-        dprintf(1, " [checksum error]\n");
+        dbprintf(1, " [checksum error]\n");
     return(err);
 }
 
@@ -272,6 +281,8 @@
                                       unsigned end,
                                       unsigned dst)
 {
+    unsigned i, j;
+
     /* expand buffer to accomodate 2x set C characters (2 digits per-char) */
     unsigned delta = end - start;
     unsigned newlen = dcode->code128.character + delta;
@@ -282,7 +293,6 @@
             dcode->code128.character - start);
     dcode->code128.character = newlen;
 
-    unsigned i, j;
     for(i = 0, j = dst; i < delta; i++, j += 2) {
         /* convert each set C character into two ASCII digits */
         unsigned char code = dcode->buf[start + delta + i];
@@ -317,13 +327,15 @@
 /* resolve scan direction and convert to ASCII */
 static inline unsigned char postprocess (zbar_decoder_t *dcode)
 {
+    unsigned i, j, cexp;
+    unsigned char code = 0, charset;
     code128_decoder_t *dcode128 = &dcode->code128;
-    dprintf(2, "\n    postproc len=%d", dcode128->character);
-    unsigned i, j;
-    unsigned char code = 0;
+    dbprintf(2, "\n    postproc len=%d", dcode128->character);
+    dcode->modifiers = 0;
+    dcode->direction = 1 - 2 * dcode128->direction;
     if(dcode128->direction) {
         /* reverse buffer */
-        dprintf(2, " (rev)");
+        dbprintf(2, " (rev)");
         for(i = 0; i < dcode128->character / 2; i++) {
             unsigned j = dcode128->character - 1 - i;
             code = dcode->buf[i];
@@ -343,9 +355,9 @@
     zassert(code >= START_A && code <= START_C, 1, "%s\n",
             _zbar_decoder_buf_dump(dcode->buf, dcode->code128.character));
 
-    unsigned char charset = code - START_A;
-    unsigned cexp = (code == START_C) ? 1 : 0;
-    dprintf(2, " start=%c", 'A' + charset);
+    charset = code - START_A;
+    cexp = (code == START_C) ? 1 : 0;
+    dbprintf(2, " start=%c", 'A' + charset);
 
     for(i = 1, j = 0; i < dcode128->character - 2; i++) {
         unsigned char code = dcode->buf[i];
@@ -368,14 +380,15 @@
                 charset &= 0x7f;
         }
         else {
-            dprintf(2, " %02x", code);
+            dbprintf(2, " %02x", code);
             if(charset & 0x2) {
+                unsigned delta;
                 /* expand character set C to ASCII */
                 zassert(cexp, 1, "i=%x j=%x code=%02x charset=%x cexp=%x %s\n",
                         i, j, code, charset, cexp,
                         _zbar_decoder_buf_dump(dcode->buf,
                                                 dcode->code128.character));
-                unsigned delta = postprocess_c(dcode, cexp, i, j);
+                delta = postprocess_c(dcode, cexp, i, j);
                 i += delta;
                 j += delta * 2;
                 cexp = 0;
@@ -383,28 +396,39 @@
             if(code < CODE_C) {
                 if(code == SHIFT)
                     charset |= 0x80;
-                else if(code == FNC2)
-                    /* FIXME FNC2 - message append */;
-                else if(code == FNC3)
-                    /* FIXME FNC3 - initialize */;
+                else if(code == FNC2) {
+                    /* FIXME FNC2 - message append */
+                }
+                else if(code == FNC3) {
+                    /* FIXME FNC3 - initialize */
+                }
             }
-            else if(code == FNC1)
-                /* FIXME FNC1 - Code 128 subsets or ASCII 0x1d */;
+            else if(code == FNC1) {
+                /* FNC1 - Code 128 subsets or ASCII 0x1d */
+                if(i == 1)
+                    dcode->modifiers |= MOD(ZBAR_MOD_GS1);
+                else if(i == 2)
+                    dcode->modifiers |= MOD(ZBAR_MOD_AIM);
+                else if(i < dcode->code128.character - 3)
+                    dcode->buf[j++] = 0x1d;
+                /*else drop trailing FNC1 */
+            }
             else if(code >= START_A) {
-                dprintf(1, " [truncated]\n");
+                dbprintf(1, " [truncated]\n");
                 return(1);
             }
             else {
+                unsigned char newset = CODE_A - code;
                 zassert(code >= CODE_C && code <= CODE_A, 1,
                         "i=%x j=%x code=%02x charset=%x cexp=%x %s\n",
                         i, j, code, charset, cexp,
                         _zbar_decoder_buf_dump(dcode->buf,
                                                 dcode->code128.character));
-                unsigned char newset = CODE_A - code;
                 if(newset != charset)
                     charset = newset;
-                else
-                    /* FIXME FNC4 - extended ASCII */;
+                else {
+                    /* FIXME FNC4 - extended ASCII */
+                }
             }
             if(charset & 0x2)
                 cexp = i + 1;
@@ -417,6 +441,8 @@
                                         dcode->code128.character));
         j += postprocess_c(dcode, cexp, i, j) * 2;
     }
+    zassert(j < dcode->buf_alloc, 1, "j=%02x %s\n", j,
+            _zbar_decoder_buf_dump(dcode->buf, dcode->code128.character));
     dcode->buflen = j;
     dcode->buf[j] = '\0';
     dcode->code128.character = j;
@@ -426,66 +452,90 @@
 zbar_symbol_type_t _zbar_decode_code128 (zbar_decoder_t *dcode)
 {
     code128_decoder_t *dcode128 = &dcode->code128;
+    signed char c;
 
     /* update latest character width */
     dcode128->s6 -= get_width(dcode, 6);
     dcode128->s6 += get_width(dcode, 0);
 
-    if(/* process every 6th element of active symbol */
-       (dcode128->character >= 0 &&
-        (++dcode128->element) != 6) ||
-       /* decode color based on direction */
-       (get_color(dcode) != dcode128->direction))
+    if((dcode128->character < 0)
+       ? get_color(dcode) != ZBAR_SPACE
+       : (/* process every 6th element of active symbol */
+          ++dcode128->element != 6 ||
+          /* decode color based on direction */
+          get_color(dcode) != dcode128->direction))
         return(0);
     dcode128->element = 0;
 
-    dprintf(2, "      code128[%c%02d+%x]:",
-            (dcode128->direction) ? '<' : '>',
-            dcode128->character, dcode128->element);
+    dbprintf(2, "      code128[%c%02d+%x]:",
+             (dcode128->direction) ? '<' : '>',
+             dcode128->character, dcode128->element);
 
-    signed char c = decode6(dcode);
+    c = decode6(dcode);
     if(dcode128->character < 0) {
-        dprintf(2, " c=%02x", c);
+        unsigned qz;
+        dbprintf(2, " c=%02x", c);
         if(c < START_A || c > STOP_REV || c == STOP_FWD) {
-            dprintf(2, " [invalid]\n");
+            dbprintf(2, " [invalid]\n");
             return(0);
         }
-        unsigned qz = get_width(dcode, 6);
-        if(qz && qz < (dcode->code128.s6 * 3) / 4) {
-            dprintf(2, " [invalid qz %d]\n", qz);
-            return(0);
-        }
-        /* lock shared resources */
-        if(get_lock(dcode, ZBAR_CODE128)) {
-            dprintf(2, " [locked %d]\n", dcode->lock);
-            dcode128->character = -1;
+        qz = get_width(dcode, 6);
+        if(qz && qz < (dcode128->s6 * 3) / 4) {
+            dbprintf(2, " [invalid qz %d]\n", qz);
             return(0);
         }
         /* decoded valid start/stop */
         /* initialize state */
-        dcode128->character = 0;
+        dcode128->character = 1;
         if(c == STOP_REV) {
             dcode128->direction = ZBAR_BAR;
             dcode128->element = 7;
         }
         else
             dcode128->direction = ZBAR_SPACE;
-        dprintf(2, " dir=%x [valid start]", dcode128->direction);
+        dcode128->start = c;
+        dcode128->width = dcode128->s6;
+        dbprintf(2, " dir=%x [valid start]\n", dcode128->direction);
+        return(0);
     }
-    else if((c < 0) ||
-            ((dcode128->character >= BUFFER_MIN) &&
-             size_buf(dcode, dcode128->character + 1))) {
-        dprintf(1, (c < 0) ? " [aborted]\n" : " [overflow]\n");
-        dcode->lock = 0;
+    else if(c < 0 || size_buf(dcode, dcode128->character + 1)) {
+        dbprintf(1, (c < 0) ? " [aborted]\n" : " [overflow]\n");
+        if(dcode128->character > 1)
+            release_lock(dcode, ZBAR_CODE128);
         dcode128->character = -1;
         return(0);
     }
+    else {
+        unsigned dw;
+        if(dcode128->width > dcode128->s6)
+            dw = dcode128->width - dcode128->s6;
+        else
+            dw = dcode128->s6 - dcode128->width;
+        dw *= 4;
+        if(dw > dcode128->width) {
+            dbprintf(1, " [width var]\n");
+            if(dcode128->character > 1)
+                release_lock(dcode, ZBAR_CODE128);
+            dcode128->character = -1;
+            return(0);
+        }
+    }
+    dcode128->width = dcode128->s6;
 
     zassert(dcode->buf_alloc > dcode128->character, 0,
             "alloc=%x idx=%x c=%02x %s\n",
             dcode->buf_alloc, dcode128->character, c,
             _zbar_decoder_buf_dump(dcode->buf, dcode->buf_alloc));
 
+    if(dcode128->character == 1) {
+        /* lock shared resources */
+        if(acquire_lock(dcode, ZBAR_CODE128)) {
+            dcode128->character = -1;
+            return(0);
+        }
+        dcode->buf[0] = dcode128->start;
+    }
+
     dcode->buf[dcode128->character++] = c;
 
     if(dcode128->character > 2 &&
@@ -499,17 +549,17 @@
         else if(dcode128->character < CFG(*dcode128, ZBAR_CFG_MIN_LEN) ||
                 (CFG(*dcode128, ZBAR_CFG_MAX_LEN) > 0 &&
                  dcode128->character > CFG(*dcode128, ZBAR_CFG_MAX_LEN))) {
-            dprintf(2, " [invalid len]\n");
+            dbprintf(2, " [invalid len]\n");
             sym = ZBAR_NONE;
         }
         else
-            dprintf(2, " [valid end]\n");
+            dbprintf(2, " [valid end]\n");
         dcode128->character = -1;
         if(!sym)
-            dcode->lock = 0;
+            release_lock(dcode, ZBAR_CODE128);
         return(sym);
     }
 
-    dprintf(2, "\n");
+    dbprintf(2, "\n");
     return(0);
 }
diff -r 563557a923d0 zbar/decoder/code128.h
--- a/zbar/decoder/code128.h	Tue Oct 27 11:25:59 2009 -0400
+++ b/zbar/decoder/code128.h	Fri Feb 22 08:54:29 2013 -0300
@@ -28,7 +28,9 @@
     unsigned direction : 1;     /* scan direction: 0=fwd/space, 1=rev/bar */
     unsigned element : 3;       /* element offset 0-5 */
     int character : 12;         /* character position in symbol */
+    unsigned char start;        /* start character */
     unsigned s6;                /* character width */
+    unsigned width;             /* last character width */
 
     unsigned config;
     int configs[NUM_CFGS];      /* int valued configurations */
diff -r 563557a923d0 zbar/decoder/code39.c
--- a/zbar/decoder/code39.c	Tue Oct 27 11:25:59 2009 -0400
+++ b/zbar/decoder/code39.c	Fri Feb 22 08:54:29 2013 -0300
@@ -1,5 +1,5 @@
 /*------------------------------------------------------------------------
- *  Copyright 2008-2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *  Copyright 2008-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
  *
  *  This file is part of the ZBar Bar Code Reader.
  *
@@ -25,12 +25,12 @@
 #include <string.h>     /* memmove */
 
 #include <zbar.h>
-#include "decoder.h"
 
 #ifdef DEBUG_CODE39
 # define DEBUG_LEVEL (DEBUG_CODE39)
 #endif
 #include "debug.h"
+#include "decoder.h"
 
 #define NUM_CHARS (0x2c)
 
@@ -130,16 +130,16 @@
                                             unsigned e,
                                             unsigned s)
 {
-    unsigned char E = decode_e(e, s, 36);
-    if(E > 7)
+    unsigned char E = decode_e(e, s, 72);
+    if(E > 18)
         return(0xff);
     enc <<= 1;
-    if(E > 2) {
+    if(E > 6) {
         enc |= 1;
-        dprintf(2, "1");
+        dbprintf(2, "1");
     }
     else
-        dprintf(2, "0");
+        dbprintf(2, "0");
     return(enc);
 }
 
@@ -147,7 +147,6 @@
 {
     code39_decoder_t *dcode39 = &dcode->code39;
 
-    dprintf(2, " s=%d ", dcode39->s9);
     if(dcode39->s9 < 9)
         return(-1);
 
@@ -181,7 +180,7 @@
     zassert(idx < 0x2c, -1, " idx=%x enc=%x s9=%x\n", idx, enc, dcode39->s9);
 
     const char39_t *c = &code39_encodings[idx];
-    dprintf(2, " i=%02x chk=%02x c=%02x/%02x", idx, c->chk, c->fwd, c->rev);
+    dbprintf(2, " i=%02x chk=%02x c=%02x/%02x", idx, c->chk, c->fwd, c->rev);
     if(enc != c->chk)
         return(-1);
 
@@ -192,35 +191,36 @@
 static inline signed char code39_decode_start (zbar_decoder_t *dcode)
 {
     code39_decoder_t *dcode39 = &dcode->code39;
+    dbprintf(2, " s=%d ", dcode39->s9);
 
     signed char c = code39_decode9(dcode);
-    if(c == 0x19)
-        dcode39->direction ^= 1;
-    else if(c != 0x2b) {
-        dprintf(2, "\n");
+    if(c != 0x19 && c != 0x2b) {
+        dbprintf(2, "\n");
         return(ZBAR_NONE);
     }
+    dcode39->direction ^= (c == 0x19);
 
     /* check leading quiet zone - spec is 10x */
     unsigned quiet = get_width(dcode, 9);
     if(quiet && quiet < dcode39->s9 / 2) {
-        dprintf(2, " [invalid quiet]\n");
+        dbprintf(2, " [invalid quiet]\n");
         return(ZBAR_NONE);
     }
 
     dcode39->element = 9;
     dcode39->character = 0;
-    dprintf(1, " dir=%x [valid start]\n", dcode39->direction);
+    dbprintf(1, " dir=%x [valid start]\n", dcode39->direction);
     return(ZBAR_PARTIAL);
 }
 
-static inline void code39_postprocess (zbar_decoder_t *dcode)
+static inline int code39_postprocess (zbar_decoder_t *dcode)
 {
     code39_decoder_t *dcode39 = &dcode->code39;
+    dcode->direction = 1 - 2 * dcode39->direction;
     int i;
     if(dcode39->direction) {
         /* reverse buffer */
-        dprintf(2, " (rev)");
+        dbprintf(2, " (rev)");
         for(i = 0; i < dcode39->character / 2; i++) {
             unsigned j = dcode39->character - 1 - i;
             char code = dcode->buf[i];
@@ -232,8 +232,22 @@
         dcode->buf[i] = ((dcode->buf[i] < 0x2b)
                          ? code39_characters[(unsigned)dcode->buf[i]]
                          : '?');
+    zassert(i < dcode->buf_alloc, -1, "i=%02x %s\n", i,
+            _zbar_decoder_buf_dump(dcode->buf, dcode39->character));
     dcode->buflen = i;
     dcode->buf[i] = '\0';
+    dcode->modifiers = 0;
+    return(0);
+}
+
+static inline int
+check_width (unsigned ref,
+             unsigned w)
+{
+    unsigned dref = ref;
+    ref *= 4;
+    w *= 4;
+    return(ref - dref <= w && w <= ref + dref);
 }
 
 zbar_symbol_type_t _zbar_decode_code39 (zbar_decoder_t *dcode)
@@ -247,16 +261,16 @@
     if(dcode39->character < 0) {
         if(get_color(dcode) != ZBAR_BAR)
             return(ZBAR_NONE);
-        dprintf(2, "      code39:");
+        dbprintf(2, "      code39:");
         return(code39_decode_start(dcode));
     }
 
     if(++dcode39->element < 9)
         return(ZBAR_NONE);
 
-    dprintf(2, "      code39[%c%02d+%x]",
-            (dcode39->direction) ? '<' : '>',
-            dcode39->character, dcode39->element);
+    dbprintf(2, "      code39[%c%02d+%x]",
+             (dcode39->direction) ? '<' : '>',
+             dcode39->character, dcode39->element);
 
     if(dcode39->element == 10) {
         unsigned space = get_width(dcode, 0);
@@ -264,61 +278,64 @@
            dcode->buf[dcode39->character - 1] == 0x2b) {  /* STOP */
             /* trim STOP character */
             dcode39->character--;
-            zbar_symbol_type_t sym = ZBAR_CODE39;
+            zbar_symbol_type_t sym = ZBAR_NONE;
 
             /* trailing quiet zone check */
-            if(space && space < dcode39->width / 2) {
-                dprintf(2, " [invalid qz]\n");
-                sym = ZBAR_NONE;
-            }
+            if(space && space < dcode39->width / 2)
+                dbprintf(2, " [invalid qz]\n");
             else if(dcode39->character < CFG(*dcode39, ZBAR_CFG_MIN_LEN) ||
                     (CFG(*dcode39, ZBAR_CFG_MAX_LEN) > 0 &&
-                     dcode39->character > CFG(*dcode39, ZBAR_CFG_MAX_LEN))) {
-                dprintf(2, " [invalid len]\n");
-                sym = ZBAR_NONE;
-            }
-            else {
-                /* FIXME checksum (needs config enable) */
-                code39_postprocess(dcode);
-                dprintf(2, " [valid end]\n");
+                     dcode39->character > CFG(*dcode39, ZBAR_CFG_MAX_LEN)))
+                dbprintf(2, " [invalid len]\n");
+            else if(!code39_postprocess(dcode)) {
+                /* FIXME checksum */
+                dbprintf(2, " [valid end]\n");
+                sym = ZBAR_CODE39;
             }
             dcode39->character = -1;
             if(!sym)
-                dcode->lock = 0;
+                release_lock(dcode, ZBAR_CODE39);
             return(sym);
         }
         if(space > dcode39->width / 2) {
             /* inter-character space check failure */
-            dcode->lock = 0;
+            dbprintf(2, " ics>%d [invalid ics]", dcode39->width);
+            if(dcode39->character)
+                release_lock(dcode, ZBAR_CODE39);
             dcode39->character = -1;
-            dprintf(2, " ics>%d [invalid ics]", dcode39->width);
         }
         dcode39->element = 0;
-        dprintf(2, "\n");
+        dbprintf(2, "\n");
+        return(ZBAR_NONE);
+    }
+
+    dbprintf(2, " s=%d ", dcode39->s9);
+    if(!check_width(dcode39->width, dcode39->s9)) {
+        dbprintf(2, " [width]\n");
+        if(dcode39->character)
+            release_lock(dcode, ZBAR_CODE39);
+        dcode39->character = -1;
         return(ZBAR_NONE);
     }
 
     signed char c = code39_decode9(dcode);
-    dprintf(2, " c=%d", c);
+    dbprintf(2, " c=%d", c);
 
     /* lock shared resources */
-    if(!dcode39->character && get_lock(dcode, ZBAR_CODE39)) {
+    if(!dcode39->character && acquire_lock(dcode, ZBAR_CODE39)) {
         dcode39->character = -1;
-        dprintf(1, " [locked %d]\n", dcode->lock);
         return(ZBAR_PARTIAL);
     }
 
-    if(c < 0 ||
-       ((dcode39->character >= BUFFER_MIN) &&
-        size_buf(dcode, dcode39->character + 1))) {
-        dprintf(1, (c < 0) ? " [aborted]\n" : " [overflow]\n");
-        dcode->lock = 0;
+    if(c < 0 || size_buf(dcode, dcode39->character + 1)) {
+        dbprintf(1, (c < 0) ? " [aborted]\n" : " [overflow]\n");
+        release_lock(dcode, ZBAR_CODE39);
         dcode39->character = -1;
         return(ZBAR_NONE);
     }
     else {
         zassert(c < 0x2c, ZBAR_NONE, "c=%02x s9=%x\n", c, dcode39->s9);
-        dprintf(2, "\n");
+        dbprintf(2, "\n");
     }
 
     dcode->buf[dcode39->character++] = c;
diff -r 563557a923d0 zbar/decoder/code93.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/zbar/decoder/code93.c	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,400 @@
+/*------------------------------------------------------------------------
+ *  Copyright 2010 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *
+ *  This file is part of the ZBar Bar Code Reader.
+ *
+ *  The ZBar Bar Code Reader is free software; you can redistribute it
+ *  and/or modify it under the terms of the GNU Lesser Public License as
+ *  published by the Free Software Foundation; either version 2.1 of
+ *  the License, or (at your option) any later version.
+ *
+ *  The ZBar Bar Code Reader is distributed in the hope that it will be
+ *  useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+ *  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser Public License
+ *  along with the ZBar Bar Code Reader; if not, write to the Free
+ *  Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ *  Boston, MA  02110-1301  USA
+ *
+ *  http://sourceforge.net/projects/zbar
+ *------------------------------------------------------------------------*/
+
+#include <config.h>
+#include <zbar.h>
+
+#ifdef DEBUG_CODE93
+# define DEBUG_LEVEL (DEBUG_CODE93)
+#endif
+#include "debug.h"
+#include "decoder.h"
+
+static const signed char code93_hash[0x40] = {
+    0x0f, 0x2b, 0x30, 0x38, 0x13, 0x1b, 0x11, 0x2a,
+    0x0a,   -1, 0x2f, 0x0f, 0x38, 0x38, 0x2f, 0x37,
+    0x24, 0x3a, 0x1b, 0x36, 0x18, 0x26, 0x02, 0x2c,
+    0x2b, 0x05, 0x21, 0x3b, 0x04, 0x15, 0x12, 0x0c,
+    0x00, 0x26, 0x23, 0x00,   -1, 0x2e, 0x3f, 0x13,
+    0x2e, 0x36,   -1, 0x08, 0x09,   -1, 0x15, 0x14,
+      -1, 0x00, 0x21, 0x3b,   -1, 0x33, 0x00,   -1,
+    0x2d, 0x0c, 0x1b, 0x0a, 0x3f, 0x3f, 0x29, 0x1c,
+};
+
+static inline int
+check_width (unsigned cur,
+             unsigned prev)
+{
+    unsigned dw;
+    if(prev > cur)
+        dw = prev - cur;
+    else
+        dw = cur - prev;
+    dw *= 4;
+    return(dw > prev);
+}
+
+static inline int
+encode6 (zbar_decoder_t *dcode)
+{
+    /* build edge signature of character */
+    unsigned s = dcode->s6;
+    int sig = 0, i;
+
+    dbprintf(2, " s=%d ", s);
+    if(s < 9)
+        return(-1);
+
+    for(i = 6; --i > 0; ) {
+        unsigned c = decode_e(pair_width(dcode, i), s, 9);
+        if(c > 3)
+            return(-1);
+        sig = (sig << 2) | c;
+        dbprintf(2, "%d", c);
+    }
+    dbprintf(2, " sig=%03x", sig);
+
+    return(sig);
+}
+
+static inline int
+validate_sig (int sig)
+{
+    int i, sum = 0, emin = 0, sig0 = 0, sig1 = 0;
+    dbprintf(3, " sum=0");
+    for(i = 3; --i >= 0; ) {
+        int e = sig & 3;
+        sig >>= 2;
+        sum = e - sum;
+        sig1 <<= 4;
+        sig1 += sum;
+        dbprintf(3, "%d", sum);
+        if(!i)
+            break;
+
+        e = sig & 3;
+        sig >>= 2;
+        sum = e - sum;
+        sig0 <<= 4;
+        if(emin > sum)
+            emin = sum;
+        sig0 += sum;
+        dbprintf(3, "%d", sum);
+    }
+
+    dbprintf(3, " emin=%d sig=%03x/%03x", emin, sig1 & 0xfff, sig0 & 0xfff);
+
+    emin = emin + (emin << 4) + (emin << 8);
+    sig0 -= emin;
+    sig1 += emin;
+
+    dbprintf(3, "=%03x/%03x", sig1 & 0xfff, sig0 & 0xfff);
+    return((sig0 | sig1) & 0x888);
+}
+
+static inline int
+decode6 (zbar_decoder_t *dcode)
+{
+    int sig = encode6(dcode);
+    int g0, g1, c;
+    if(sig < 0 ||
+       (sig & 0x3) + ((sig >> 4) & 0x3) + ((sig >> 8) & 0x3) != 3 ||
+       validate_sig(sig))
+        return(-1);
+
+    if(dcode->code93.direction) {
+        /* reverse signature */
+        unsigned tmp = sig & 0x030;
+        sig = ((sig & 0x3c0) >> 6) | ((sig & 0x00f) << 6);
+        sig = ((sig & 0x30c) >> 2) | ((sig & 0x0c3) << 2) | tmp;
+    }
+
+    g0 = code93_hash[(sig - (sig >> 4)) & 0x3f];
+    g1 = code93_hash[((sig >> 2) - (sig >> 7)) & 0x3f];
+    zassert(g0 >= 0 && g1 >= 0, -1,
+            "dir=%x sig=%03x g0=%03x g1=%03x %s\n",
+            dcode->code93.direction, sig, g0, g1,
+            _zbar_decoder_buf_dump(dcode->buf, dcode->code93.character));
+
+    c = (g0 + g1) & 0x3f;
+    dbprintf(2, " g0=%x g1=%x c=%02x", g0, g1, c);
+    return(c);
+}
+
+static inline zbar_symbol_type_t
+decode_start (zbar_decoder_t *dcode)
+{
+    code93_decoder_t *dcode93 = &dcode->code93;
+    unsigned dir, qz, s = dcode->s6;
+    int c;
+
+    dbprintf(2, "      code93:");
+    c = encode6(dcode);
+    if(c < 0 || (c != 0x00f && c != 0x0f0))
+        return(ZBAR_NONE);
+
+    dir = (c >> 7);
+
+    if(dir) {
+        if(decode_e(pair_width(dcode, 0), s, 9))
+            return(ZBAR_NONE);
+        qz = get_width(dcode, 8);
+    }
+
+    qz = get_width(dcode, 7);
+    if(qz && qz < (s * 3) / 4) {
+        dbprintf(2, " [invalid qz %d]", qz);
+        return(ZBAR_NONE);
+    }
+
+    /* decoded valid start/stop - initialize state */
+    dcode93->direction = dir;
+    dcode93->element = (!dir) ? 0 : 7;
+    dcode93->character = 0;
+    dcode93->width = s;
+
+    dbprintf(2, " dir=%x [valid start]", dir);
+    return(ZBAR_PARTIAL);
+}
+
+static inline zbar_symbol_type_t
+decode_abort (zbar_decoder_t *dcode,
+              const char *reason)
+{
+    code93_decoder_t *dcode93 = &dcode->code93;
+    if(dcode93->character > 1)
+        release_lock(dcode, ZBAR_CODE93);
+    dcode93->character = -1;
+    if(reason)
+        dbprintf(1, " [%s]\n", reason);
+    return(ZBAR_NONE);
+}
+
+static inline zbar_symbol_type_t
+check_stop (zbar_decoder_t *dcode)
+{
+    code93_decoder_t *dcode93 = &dcode->code93;
+    unsigned n = dcode93->character, s = dcode->s6;
+    int max_len = CFG(*dcode93, ZBAR_CFG_MAX_LEN);
+    if(n < 2 ||
+       n < CFG(*dcode93, ZBAR_CFG_MIN_LEN) ||
+       (max_len && n > max_len))
+        return(decode_abort(dcode, "invalid len"));
+
+    if(dcode93->direction) {
+        unsigned qz = get_width(dcode, 0);
+        if(qz && qz < (s * 3) / 4)
+            return(decode_abort(dcode, "invalid qz"));
+    }
+    else if(decode_e(pair_width(dcode, 0), s, 9))
+        /* FIXME forward-trailing QZ check */
+        return(decode_abort(dcode, "invalid stop"));
+
+    return(ZBAR_CODE93);
+}
+
+#define CHKMOD (47)
+
+static inline int
+plusmod47 (int acc,
+           int add)
+{
+    acc += add;
+    if(acc >= CHKMOD)
+        acc -= CHKMOD;
+    return(acc);
+}
+
+static inline int
+validate_checksums (zbar_decoder_t *dcode)
+{
+    code93_decoder_t *dcode93 = &dcode->code93;
+    unsigned d, i, n = dcode93->character;
+    unsigned sum_c = 0, acc_c = 0, i_c = (n - 2) % 20;
+    unsigned sum_k = 0, acc_k = 0, i_k = (n - 1) % 15;
+
+    for(i = 0; i < n - 2; i++) {
+        d = dcode->buf[(dcode93->direction) ? n - 1 - i : i];
+
+        if(!i_c--) {
+            acc_c = 0;
+            i_c = 19;
+        }
+        acc_c = plusmod47(acc_c, d);
+        sum_c = plusmod47(sum_c, acc_c);
+
+        if(!i_k--) {
+            acc_k = 0;
+            i_k = 14;
+        }
+        acc_k = plusmod47(acc_k, d);
+        sum_k = plusmod47(sum_k, acc_k);
+    }
+
+    d = dcode->buf[(dcode93->direction) ? 1 : n - 2];
+    dbprintf(2, " C=%02x?=%02x", d, sum_c);
+    if(d != sum_c)
+        return(1);
+
+    acc_k = plusmod47(acc_k, sum_c);
+    sum_k = plusmod47(sum_k, acc_k);
+    d = dcode->buf[(dcode93->direction) ? 0 : n - 1];
+    dbprintf(2, " K=%02x?=%02x", d, sum_k);
+    if(d != sum_k)
+        return(1);
+
+    return(0);
+}
+
+/* resolve scan direction and convert to ASCII */
+static inline int
+postprocess (zbar_decoder_t *dcode)
+{
+    code93_decoder_t *dcode93 = &dcode->code93;
+    unsigned i, j, n = dcode93->character;
+    static const unsigned char code93_graph[] = "-. $/+%";
+    static const unsigned char code93_s2[] =
+        "\x1b\x1c\x1d\x1e\x1f;<=>?[\\]^_{|}~\x7f\x00\x40`\x7f\x7f\x7f";
+
+    dbprintf(2, "\n    postproc len=%d", n);
+    dcode->direction = 1 - 2 * dcode93->direction;
+    if(dcode93->direction) {
+        /* reverse buffer */
+        dbprintf(2, " (rev)");
+        for(i = 0; i < n / 2; i++) {
+            unsigned j = n - 1 - i;
+            unsigned char d = dcode->buf[i];
+            dcode->buf[i] = dcode->buf[j];
+            dcode->buf[j] = d;
+        }
+    }
+
+    n -= 2;
+    for(i = 0, j = 0; i < n; ) {
+        unsigned char d = dcode->buf[i++];
+        if(d < 0xa)
+            d = '0' + d;
+        else if(d < 0x24)
+            d = 'A' + d - 0xa;
+        else if(d < 0x2b)
+            d = code93_graph[d - 0x24];
+        else {
+            unsigned shift = d;
+            zassert(shift < 0x2f, -1, "%s\n",
+                    _zbar_decoder_buf_dump(dcode->buf, dcode93->character));
+            d = dcode->buf[i++];
+            if(d < 0xa || d >= 0x24)
+                return(1);
+            d -= 0xa;
+            switch(shift)
+            {
+            case 0x2b: d++; break;
+            case 0x2c: d = code93_s2[d]; break;
+            case 0x2d: d += 0x21; break;
+            case 0x2e: d += 0x61; break;
+            default: return(1);
+            }
+        }
+        dcode->buf[j++] = d;
+    }
+
+    zassert(j < dcode->buf_alloc, 1,
+            "j=%02x %s\n", j,
+            _zbar_decoder_buf_dump(dcode->buf, dcode->code93.character));
+    dcode->buflen = j;
+    dcode->buf[j] = '\0';
+    dcode->modifiers = 0;
+    return(0);
+}
+
+zbar_symbol_type_t
+_zbar_decode_code93 (zbar_decoder_t *dcode)
+{
+    code93_decoder_t *dcode93 = &dcode->code93;
+    int c;
+
+    if(dcode93->character < 0) {
+        zbar_symbol_type_t sym;
+        if(get_color(dcode) != ZBAR_BAR)
+            return(ZBAR_NONE);
+        sym = decode_start(dcode);
+        dbprintf(2, "\n");
+        return(sym);
+    }
+
+    if(/* process every 6th element of active symbol */
+       ++dcode93->element != 6 ||
+       /* decode color based on direction */
+       get_color(dcode) == dcode93->direction)
+        return(ZBAR_NONE);
+
+    dcode93->element = 0;
+
+    dbprintf(2, "      code93[%c%02d+%x]:",
+             (dcode93->direction) ? '<' : '>',
+             dcode93->character, dcode93->element);
+
+    if(check_width(dcode->s6, dcode93->width))
+        return(decode_abort(dcode, "width var"));
+
+    c = decode6(dcode);
+    if(c < 0)
+        return(decode_abort(dcode, "aborted"));
+
+    if(c == 0x2f) {
+        if(!check_stop(dcode))
+            return(ZBAR_NONE);
+        if(validate_checksums(dcode))
+            return(decode_abort(dcode, "checksum error"));
+        if(postprocess(dcode))
+            return(decode_abort(dcode, "invalid encoding"));
+
+        dbprintf(2, " [valid end]\n");
+        dbprintf(3, "    %s\n",
+                 _zbar_decoder_buf_dump(dcode->buf, dcode93->character));
+
+        dcode93->character = -1;
+        return(ZBAR_CODE93);
+    }
+
+    if(size_buf(dcode, dcode93->character + 1))
+        return(decode_abort(dcode, "overflow"));
+
+    dcode93->width = dcode->s6;
+
+    if(dcode93->character == 1) {
+        /* lock shared resources */
+        if(acquire_lock(dcode, ZBAR_CODE93))
+            return(decode_abort(dcode, NULL));
+        dcode->buf[0] = dcode93->buf;
+    }
+
+    if(!dcode93->character)
+        dcode93->buf = c;
+    else 
+        dcode->buf[dcode93->character] = c;
+    dcode93->character++;
+
+    dbprintf(2, "\n");
+    return(ZBAR_NONE);
+}
diff -r 563557a923d0 zbar/decoder/code93.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/zbar/decoder/code93.h	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,49 @@
+/*------------------------------------------------------------------------
+ *  Copyright 2010 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *
+ *  This file is part of the ZBar Bar Code Reader.
+ *
+ *  The ZBar Bar Code Reader is free software; you can redistribute it
+ *  and/or modify it under the terms of the GNU Lesser Public License as
+ *  published by the Free Software Foundation; either version 2.1 of
+ *  the License, or (at your option) any later version.
+ *
+ *  The ZBar Bar Code Reader is distributed in the hope that it will be
+ *  useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+ *  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser Public License
+ *  along with the ZBar Bar Code Reader; if not, write to the Free
+ *  Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ *  Boston, MA  02110-1301  USA
+ *
+ *  http://sourceforge.net/projects/zbar
+ *------------------------------------------------------------------------*/
+#ifndef _CODE93_H_
+#define _CODE93_H_
+
+/* Code 93 specific decode state */
+typedef struct code93_decoder_s {
+    unsigned direction : 1;     /* scan direction: 0=fwd/space, 1=rev/bar */
+    unsigned element : 3;       /* element offset 0-5 */
+    int character : 12;         /* character position in symbol */
+    unsigned width;             /* last character width */
+    unsigned char buf;          /* first character */
+
+    unsigned config;
+    int configs[NUM_CFGS];      /* int valued configurations */
+} code93_decoder_t;
+
+/* reset Code 93 specific state */
+static inline void code93_reset (code93_decoder_t *dcode93)
+{
+    dcode93->direction = 0;
+    dcode93->element = 0;
+    dcode93->character = -1;
+}
+
+/* decode Code 93 symbols */
+zbar_symbol_type_t _zbar_decode_code93(zbar_decoder_t *dcode);
+
+#endif
diff -r 563557a923d0 zbar/decoder/databar.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/zbar/decoder/databar.c	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,1280 @@
+/*------------------------------------------------------------------------
+ *  Copyright 2010 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *
+ *  This file is part of the ZBar Bar Code Reader.
+ *
+ *  The ZBar Bar Code Reader is free software; you can redistribute it
+ *  and/or modify it under the terms of the GNU Lesser Public License as
+ *  published by the Free Software Foundation; either version 2.1 of
+ *  the License, or (at your option) any later version.
+ *
+ *  The ZBar Bar Code Reader is distributed in the hope that it will be
+ *  useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+ *  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser Public License
+ *  along with the ZBar Bar Code Reader; if not, write to the Free
+ *  Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ *  Boston, MA  02110-1301  USA
+ *
+ *  http://sourceforge.net/projects/zbar
+ *------------------------------------------------------------------------*/
+
+#include <config.h>
+#include <zbar.h>
+
+#ifdef DEBUG_DATABAR
+# define DEBUG_LEVEL (DEBUG_DATABAR)
+#endif
+#include "debug.h"
+#include "decoder.h"
+
+#define GS ('\035')
+
+enum { SCH_NUM, SCH_ALNUM, SCH_ISO646 };
+
+static const signed char finder_hash[0x20] = {
+    0x16, 0x1f, 0x02, 0x00, 0x03, 0x00, 0x06, 0x0b,
+    0x1f, 0x0e, 0x17, 0x0c, 0x0b, 0x14, 0x11, 0x0c,
+    0x1f, 0x03, 0x13, 0x08, 0x00, 0x0a,   -1, 0x16,
+    0x0c, 0x09,   -1, 0x1a, 0x1f, 0x1c, 0x00,   -1,
+};
+
+/* DataBar character encoding groups */
+struct group_s {
+    unsigned short sum;
+    unsigned char wmax;
+    unsigned char todd;
+    unsigned char teven;
+} groups[] = {
+    /* (17,4) DataBar Expanded character groups */
+    {    0, 7,  87,   4 },
+    {  348, 5,  52,  20 },
+    { 1388, 4,  30,  52 },
+    { 2948, 3,  10, 104 },
+    { 3988, 1,   1, 204 },
+
+    /* (16,4) DataBar outer character groups */
+    {    0, 8, 161,   1 },
+    {  161, 6,  80,  10 },
+    {  961, 4,  31,  34 },
+    { 2015, 3,  10,  70 },
+    { 2715, 1,   1, 126 },
+
+    /* (15,4) DataBar inner character groups */
+    { 1516, 8,  81,   1 },
+    { 1036, 6,  48,  10 },
+    {  336, 4,  20,  35 },
+    {    0, 2,   4,  84 },
+};
+
+static const unsigned char exp_sequences[] = {
+    /* sequence Group 1 */
+    0x01,
+    0x23,
+    0x25, 0x07,
+    0x29, 0x47,
+    0x29, 0x67, 0x0b,
+    0x29, 0x87, 0xab,
+    /* sequence Group 2 */
+    0x21, 0x43, 0x65, 0x07,
+    0x21, 0x43, 0x65, 0x89,
+    0x21, 0x43, 0x65, 0xa9, 0x0b,
+    0x21, 0x43, 0x67, 0x89, 0xab
+};
+
+/* DataBar expanded checksum multipliers */
+static const unsigned char exp_checksums[] = {
+    1, 189, 62, 113, 46, 43, 109, 134, 6, 79, 161, 45
+};
+
+static inline void
+append_check14 (unsigned char *buf)
+{
+    unsigned char chk = 0, d;
+    int i;
+    for(i = 13; --i >= 0; ) {
+        d = *(buf++) - '0';
+        chk += d;
+        if(!(i & 1))
+            chk += d << 1;
+    }
+    chk %= 10;
+    if(chk)
+        chk = 10 - chk;
+    *buf = chk + '0';
+}
+
+static inline void
+decode10 (unsigned char *buf,
+          unsigned long n,
+          int i)
+{
+    buf += i;
+    while(--i >= 0) {
+        unsigned char d = n % 10;
+        n /= 10;
+        *--buf = '0' + d;
+    }
+}
+
+#define VAR_MAX(l, i) ((((l) * 12 + (i)) * 2 + 6) / 7)
+
+#define FEED_BITS(b)                         \
+    while(i < (b) && len) {                  \
+        d = (d << 12) | (*(data++) & 0xfff); \
+        i += 12;                             \
+        len--;                               \
+        dbprintf(2, " %03lx", d & 0xfff);     \
+    }
+
+#define PUSH_CHAR(c) \
+    *(buf++) = (c)
+
+#define PUSH_CHAR4(c0, c1, c2, c3) do { \
+        PUSH_CHAR(c0);                  \
+        PUSH_CHAR(c1);                  \
+        PUSH_CHAR(c2);                  \
+        PUSH_CHAR(c3);                  \
+    } while(0);
+
+static inline int
+databar_postprocess_exp (zbar_decoder_t *dcode,
+                         int *data)
+{
+    int i = 0, enc;
+    unsigned n;
+    unsigned char *buf;
+    unsigned long d = *(data++);
+    int len = d / 211 + 4, buflen;
+
+    /* grok encodation method */
+    d = *(data++);
+    dbprintf(2, "\n    len=%d %03lx", len, d & 0xfff);
+    n = (d >> 4) & 0x7f;
+    if(n >= 0x40) {
+        i = 10;
+        enc = 1;
+        buflen = 2 + 14 + VAR_MAX(len, 10 - 2 - 44 + 6) + 2;
+    }
+    else if(n >= 0x38) {
+        i = 4;
+        enc = 6 + (n & 7);
+        buflen = 2 + 14 + 4 + 6 + 2 + 6 + 2;
+    }
+    else if(n >= 0x30) {
+        i = 6;
+        enc = 2 + ((n >> 2) & 1);
+        buflen = 2 + 14 + 4 + 3 + VAR_MAX(len, 6 - 2 - 44 - 2 - 10) + 2;
+    }
+    else if(n >= 0x20) {
+        i = 7;
+        enc = 4 + ((n >> 3) & 1);
+        buflen = 2 + 14 + 4 + 6;
+    }
+    else {
+        i = 9;
+        enc = 0;
+        buflen = VAR_MAX(len, 9 - 2) + 2;
+    }
+    dbprintf(2, " buflen=%d enc=%d", buflen, enc);
+    zassert(buflen > 2, -1, "buflen=%d\n", buflen);
+
+    if(enc < 4) {
+        /* grok variable length symbol bit field */
+        if((len ^ (d >> (--i))) & 1)
+            /* even/odd length mismatch */
+            return(-1);
+        if(((d >> (--i)) & 1) != (len > 14))
+            /* size group mismatch */
+            return(-1);
+    }
+    len -= 2;
+    dbprintf(2, " [%d+%d]", i, len);
+
+    if(size_buf(dcode, buflen))
+        return(-1);
+    buf = dcode->buf;
+
+    /* handle compressed fields */
+    if(enc) {
+        PUSH_CHAR('0');
+        PUSH_CHAR('1');
+    }
+
+    if(enc == 1) {
+        i -= 4;
+        n = (d >> i) & 0xf;
+        if(i >= 10)
+            return(-1);
+        PUSH_CHAR('0' + n);
+    }
+    else if(enc)
+        PUSH_CHAR('9');
+
+    if(enc) {
+        int j;
+        for(j = 0; j < 4; j++) {
+            FEED_BITS(10);
+            i -= 10;
+            n = (d >> i) & 0x3ff;
+            if(n >= 1000)
+                return(-1);
+            decode10(buf, n, 3);
+            buf += 3;
+        }
+        append_check14(buf - 13);
+        buf++;
+    }
+
+    switch(enc)
+    {
+    case 2: /* 01100: AI 392x */
+        FEED_BITS(2);
+        i -= 2;
+        n = (d >> i) & 0x3;
+        PUSH_CHAR4('3', '9', '2', '0' + n);
+        break;
+
+    case 3: /* 01101: AI 393x */
+        FEED_BITS(12);
+        i -= 2;
+        n = (d >> i) & 0x3;
+        PUSH_CHAR4('3', '9', '3', '0' + n);
+        i -= 10;
+        n = (d >> i) & 0x3ff;
+        if(n >= 1000)
+            return(-1);
+        decode10(buf, n, 3);
+        buf += 3;
+        break;
+
+    case 4: /* 0100: AI 3103 */
+        FEED_BITS(15);
+        i -= 15;
+        n = (d >> i) & 0x7fff;
+        PUSH_CHAR4('3', '1', '0', '3');
+        decode10(buf, n, 6);
+        buf += 6;
+        break;
+
+    case 5: /* 0101: AI 3202/3203 */
+        FEED_BITS(15);
+        i -= 15;
+        n = (d >> i) & 0x7fff;
+        dbprintf(2, " v=%d", n);
+        PUSH_CHAR4('3', '2', '0', (n >= 10000) ? '3' : '2' );
+        if(n >= 10000)
+            n -= 10000;
+        decode10(buf, n, 6);
+        buf += 6;
+        break;
+    }
+    if(enc >= 6) {
+        /* 0111000 - 0111111: AI 310x/320x + AI 11/13/15/17 */
+        PUSH_CHAR4('3', '1' + (enc & 1), '0', 'x');
+        FEED_BITS(20);
+        i -= 20;
+        n = (d >> i) & 0xfffff;
+        dbprintf(2, " [%d+%d] %d", i, len, n);
+        if(n >= 1000000)
+            return(-1);
+        decode10(buf, n, 6);
+        *(buf - 1) = *buf;
+        *buf = '0';
+        buf += 6;
+
+        FEED_BITS(16);
+        i -= 16;
+        n = (d >> i) & 0xffff;
+        if(n < 38400) {
+            int dd, mm, yy;
+            dd = n % 32;
+            n /= 32;
+            mm = n % 12 + 1;
+            n /= 12;
+            yy = n;
+            PUSH_CHAR('1');
+            PUSH_CHAR('0' + ((enc - 6) | 1));
+            decode10(buf, yy, 2);
+            buf += 2;
+            decode10(buf, mm, 2);
+            buf += 2;
+            decode10(buf, dd, 2);
+            buf += 2;
+        }
+        else if(n > 38400)
+            return(-1);
+    }
+
+    if(enc < 4) {
+        /* remainder is general-purpose data compaction */
+        int scheme = SCH_NUM;
+        while(i > 0 || len > 0) {
+            FEED_BITS(8);
+            dbprintf(2, " [%d+%d]", i, len);
+
+            if(scheme == SCH_NUM) {
+                int n1;
+                i -= 4;
+                if(i < 0)
+                    break;
+                if(!((d >> i) & 0xf)) {
+                    scheme = SCH_ALNUM;
+                    dbprintf(2, ">A");
+                    continue;
+                }
+                if(!len && i < 3) {
+                    /* special case last digit */
+                    n = ((d >> i) & 0xf) - 1;
+                    if(n > 9)
+                        return(-1);
+                    *(buf++) = '0' + n;
+                    break;
+                }
+                i -= 3;
+                zassert(i >= 0, -1, "\n");
+                n = ((d >> i) & 0x7f) - 8;
+                n1 = n % 11;
+                n = n / 11;
+                dbprintf(2, "N%d%d", n, n1);
+                *(buf++) = (n < 10) ? '0' + n : GS;
+                *(buf++) = (n1 < 10) ? '0' + n1 : GS;
+            }
+            else  {
+                unsigned c = 0;
+                i -= 3;
+                if(i < 0)
+                    break;
+                if(!((d >> i) & 0x7)) {
+                    scheme = SCH_NUM;
+                    continue;
+                }
+                i -= 2;
+                if(i < 0)
+                    break;
+                n = (d >> i) & 0x1f;
+                if(n == 0x04) {
+                    scheme ^= 0x3;
+                    dbprintf(2, ">%d", scheme);
+                }
+                else if(n == 0x0f)
+                    c = GS;
+                else if(n < 0x0f)
+                    c = 43 + n;
+                else if(scheme == SCH_ALNUM) {
+                    i--;
+                    if(i < 0)
+                        return(-1);
+                    n = (d >> i) & 0x1f;
+                    if(n < 0x1a)
+                        c = 'A' + n;
+                    else if(n == 0x1a)
+                        c = '*';
+                    else if(n < 0x1f)
+                        c = ',' + n - 0x1b;
+                    else
+                        return(-1);
+                }
+                else if(scheme == SCH_ISO646 && n < 0x1d) {
+                    i -= 2;
+                    if(i < 0)
+                        return(-1);
+                    n = (d >> i) & 0x3f;
+                    if(n < 0x1a)
+                        c = 'A' + n;
+                    else if(n < 0x34)
+                        c = 'a' + n - 0x1a;
+                    else
+                        return(-1);
+                }
+                else if(scheme == SCH_ISO646) {
+                    i -= 3;
+                    if(i < 0)
+                        return(-1);
+                    n = ((d >> i) & 0x1f);
+                    dbprintf(2, "(%02x)", n);
+                    if(n < 0xa)
+                        c = '!' + n - 8;
+                    else if(n < 0x15)
+                        c = '%' + n - 0xa;
+                    else if(n < 0x1b)
+                        c = ':' + n - 0x15;
+                    else if(n == 0x1b)
+                        c = '_';
+                    else if(n == 0x1c)
+                        c = ' ';
+                    else
+                        return(-1);
+                }
+                else
+                    return(-1);
+
+                if(c) {
+                    dbprintf(2, "%d%c", scheme, c);
+                    *(buf++) = c;
+                }
+            }
+        }
+        /* FIXME check pad? */
+    }
+
+    i = buf - dcode->buf;
+    zassert(i < dcode->buf_alloc, -1, "i=%02x %s\n", i,
+            _zbar_decoder_buf_dump(dcode->buf, i));
+
+    *buf = 0;
+    dcode->buflen = i;
+    if(i && *--buf == GS) {
+        *buf = 0;
+        dcode->buflen--;
+    }
+
+    dbprintf(2, "\n    %s", _zbar_decoder_buf_dump(dcode->buf, dcode->buflen));
+    return(0);
+}
+#undef FEED_BITS
+
+/* convert from heterogeneous base {1597,2841}
+ * to base 10 character representation
+ */
+static inline void
+databar_postprocess (zbar_decoder_t *dcode,
+                     unsigned d[4])
+{
+    databar_decoder_t *db = &dcode->databar;
+    int i;
+    unsigned c, chk = 0;
+    unsigned char *buf = dcode->buf;
+    *(buf++) = '0';
+    *(buf++) = '1';
+    buf += 15;
+    *--buf = '\0';
+    *--buf = '\0';
+
+    dbprintf(2, "\n    d={%d,%d,%d,%d}", d[0], d[1], d[2], d[3]);
+    unsigned long r = d[0] * 1597 + d[1];
+    d[1] = r / 10000;
+    r %= 10000;
+    r = r * 2841 + d[2];
+    d[2] = r / 10000;
+    r %= 10000;
+    r = r * 1597 + d[3];
+    d[3] = r / 10000;
+    dbprintf(2, " r=%ld", r);
+
+    for(i = 4; --i >= 0; ) {
+        c = r % 10;
+        chk += c;
+        if(i & 1)
+            chk += c << 1;
+        *--buf = c + '0';
+        if(i)
+            r /= 10;
+    }
+
+    dbprintf(2, " d={%d,%d,%d}", d[1], d[2], d[3]);
+    r = d[1] * 2841 + d[2];
+    d[2] = r / 10000;
+    r %= 10000;
+    r = r * 1597 + d[3];
+    d[3] = r / 10000;
+    dbprintf(2, " r=%ld", r);
+
+    for(i = 4; --i >= 0; ) {
+        c = r % 10;
+        chk += c;
+        if(i & 1)
+            chk += c << 1;
+        *--buf = c + '0';
+        if(i)
+            r /= 10;
+    }
+
+    r = d[2] * 1597 + d[3];
+    dbprintf(2, " d={%d,%d} r=%ld", d[2], d[3], r);
+
+    for(i = 5; --i >= 0; ) {
+        c = r % 10;
+        chk += c;
+        if(!(i & 1))
+            chk += c << 1;
+        *--buf = c + '0';
+        if(i)
+            r /= 10;
+    }
+
+    /* NB linkage flag not supported */
+    if(TEST_CFG(db->config, ZBAR_CFG_EMIT_CHECK)) {
+        chk %= 10;
+        if(chk)
+            chk = 10 - chk;
+        buf[13] = chk + '0';
+        dcode->buflen = buf - dcode->buf + 14;
+    }
+    else
+        dcode->buflen = buf - dcode->buf + 13;
+
+    dbprintf(2, "\n    %s", _zbar_decoder_buf_dump(dcode->buf, 16));
+}
+
+static inline int
+check_width (unsigned wf,
+             unsigned wd,
+             unsigned n)
+{
+    unsigned dwf = wf * 3;
+    wd *= 14;
+    wf *= n;
+    return(wf - dwf <= wd && wd <= wf + dwf);
+}
+
+static inline void
+merge_segment (databar_decoder_t *db,
+               databar_segment_t *seg)
+{
+    unsigned csegs = db->csegs;
+    int i;
+    for(i = 0; i < csegs; i++) {
+        databar_segment_t *s = db->segs + i;
+        if(s != seg && s->finder == seg->finder && s->exp == seg->exp &&
+           s->color == seg->color && s->side == seg->side &&
+           s->data == seg->data && s->check == seg->check &&
+           check_width(seg->width, s->width, 14)) {
+            /* merge with existing segment */
+            unsigned cnt = s->count;
+            if(cnt < 0x7f)
+                cnt++;
+            seg->count = cnt;
+            seg->partial &= s->partial;
+            seg->width = (3 * seg->width + s->width + 2) / 4;
+            s->finder = -1;
+            dbprintf(2, " dup@%d(%d,%d)",
+                     i, cnt, (db->epoch - seg->epoch) & 0xff);
+        }
+        else if(s->finder >= 0) {
+            unsigned age = (db->epoch - s->epoch) & 0xff;
+            if(age >= 248 || (age >= 128 && s->count < 2))
+                s->finder = -1;
+        }
+    }
+}
+
+static inline zbar_symbol_type_t
+match_segment (zbar_decoder_t *dcode,
+               databar_segment_t *seg)
+{
+    databar_decoder_t *db = &dcode->databar;
+    unsigned csegs = db->csegs, maxage = 0xfff;
+    int i0, i1, i2, maxcnt = 0;
+    databar_segment_t *smax[3] = { NULL, };
+
+    if(seg->partial && seg->count < 4)
+        return(ZBAR_PARTIAL);
+
+    for(i0 = 0; i0 < csegs; i0++) {
+        databar_segment_t *s0 = db->segs + i0;
+        if(s0 == seg || s0->finder != seg->finder || s0->exp ||
+           s0->color != seg->color || s0->side == seg->side ||
+           (s0->partial && s0->count < 4) ||
+           !check_width(seg->width, s0->width, 14))
+            continue;
+
+        for(i1 = 0; i1 < csegs; i1++) {
+            databar_segment_t *s1 = db->segs + i1;
+            int chkf, chks, chk;
+            unsigned age1;
+            if(i1 == i0 || s1->finder < 0 || s1->exp ||
+               s1->color == seg->color ||
+               (s1->partial && s1->count < 4) ||
+               !check_width(seg->width, s1->width, 14))
+                continue;
+            dbprintf(2, "\n\t[%d,%d] f=%d(0%xx)/%d(%x%x%x)",
+                     i0, i1, seg->finder, seg->color,
+                     s1->finder, s1->exp, s1->color, s1->side);
+
+            if(seg->color)
+                chkf = seg->finder + s1->finder * 9;
+            else
+                chkf = s1->finder + seg->finder * 9;
+            if(chkf > 72)
+                chkf--;
+            if(chkf > 8)
+                chkf--;
+
+            chks = (seg->check + s0->check + s1->check) % 79;
+
+            if(chkf >= chks)
+                chk = chkf - chks;
+            else
+                chk = 79 + chkf - chks;
+
+            dbprintf(2, " chk=(%d,%d) => %d", chkf, chks, chk);
+            age1 = (((db->epoch - s0->epoch) & 0xff) +
+                    ((db->epoch - s1->epoch) & 0xff));
+
+            for(i2 = i1 + 1; i2 < csegs; i2++) {
+                databar_segment_t *s2 = db->segs + i2;
+                unsigned cnt, age2, age;
+                if(i2 == i0 || s2->finder != s1->finder || s2->exp ||
+                   s2->color != s1->color || s2->side == s1->side ||
+                   s2->check != chk ||
+                   (s2->partial && s2->count < 4) ||
+                   !check_width(seg->width, s2->width, 14))
+                    continue;
+                age2 = (db->epoch - s2->epoch) & 0xff;
+                age = age1 + age2;
+                cnt = s0->count + s1->count + s2->count;
+                dbprintf(2, " [%d] MATCH cnt=%d age=%d", i2, cnt, age);
+                if(maxcnt < cnt ||
+                   (maxcnt == cnt && maxage > age)) {
+                    maxcnt = cnt;
+                    maxage = age;
+                    smax[0] = s0;
+                    smax[1] = s1;
+                    smax[2] = s2;
+                }
+            }
+        }
+    }
+
+    if(!smax[0])
+        return(ZBAR_PARTIAL);
+
+    unsigned d[4];
+    d[(seg->color << 1) | seg->side] = seg->data;
+    for(i0 = 0; i0 < 3; i0++) {
+        d[(smax[i0]->color << 1) | smax[i0]->side] = smax[i0]->data;
+        if(!--(smax[i0]->count))
+            smax[i0]->finder = -1;
+    }
+    seg->finder = -1;
+
+    if(size_buf(dcode, 18))
+        return(ZBAR_PARTIAL);
+
+    if(acquire_lock(dcode, ZBAR_DATABAR))
+        return(ZBAR_PARTIAL);
+
+    databar_postprocess(dcode, d);
+    dcode->modifiers = MOD(ZBAR_MOD_GS1);
+    dcode->direction = 1 - 2 * (seg->side ^ seg->color ^ 1);
+    return(ZBAR_DATABAR);
+}
+
+static inline unsigned
+lookup_sequence (databar_segment_t *seg,
+                 int fixed,
+                 int seq[22])
+{
+    unsigned n = seg->data / 211, i;
+    const unsigned char *p;
+    i = (n + 1) / 2 + 1;
+    n += 4;
+    i = (i * i) / 4;
+    dbprintf(2, " {%d,%d:", i, n);
+    p = exp_sequences + i;
+
+    fixed >>= 1;
+    seq[0] = 0;
+    seq[1] = 1;
+    for(i = 2; i < n; ) {
+        int s = *p;
+        if(!(i & 2)) {
+            p++;
+            s >>= 4;
+        }
+        else
+            s &= 0xf;
+        if(s == fixed)
+            fixed = -1;
+        s <<= 1;
+        dbprintf(2, "%x", s);
+        seq[i++] = s++;
+        seq[i++] = s;
+    }
+    dbprintf(2, "}");
+    seq[n] = -1;
+    return(fixed < 1);
+}
+
+#define IDX(s) \
+    (((s)->finder << 2) | ((s)->color << 1) | ((s)->color ^ (s)->side))
+
+static inline zbar_symbol_type_t
+match_segment_exp (zbar_decoder_t *dcode,
+                   databar_segment_t *seg,
+                   int dir)
+{
+    databar_decoder_t *db = &dcode->databar;
+    int bestsegs[22], i = 0, segs[22], seq[22];
+    int ifixed = seg - db->segs, fixed = IDX(seg), maxcnt = 0;
+    int iseg[DATABAR_MAX_SEGMENTS];
+    unsigned csegs = db->csegs, width = seg->width, maxage = 0x7fff;
+
+    bestsegs[0] = segs[0] = seq[1] = -1;
+    seq[0] = 0;
+
+    dbprintf(2, "\n    fixed=%d@%d: ", fixed, ifixed);
+    for(i = csegs, seg = db->segs + csegs - 1; --i >= 0; seg--) {
+        if(seg->exp && seg->finder >= 0 &&
+           (!seg->partial || seg->count >= 4))
+            iseg[i] = IDX(seg);
+        else
+            iseg[i] = -1;
+        dbprintf(2, " %d", iseg[i]);
+    }
+
+    for(i = 0; ; i--) {
+        if(!i)
+            dbprintf(2, "\n   ");
+        for(; i >= 0 && seq[i] >= 0; i--) {
+            int j;
+            dbprintf(2, " [%d]%d", i, seq[i]);
+
+            if(seq[i] == fixed) {
+                seg = db->segs + ifixed;
+                if(segs[i] < 0 && check_width(width, seg->width, 14)) {
+                    dbprintf(2, "*");
+                    j = ifixed;
+                }
+                else
+                    continue;
+            }
+            else {
+                for(j = segs[i] + 1; j < csegs; j++) {
+                    if(iseg[j] == seq[i] &&
+                       (!i || check_width(width, db->segs[j].width, 14))) {
+                        seg = db->segs + j;
+                        break;
+                    }
+                }
+                if(j == csegs)
+                    continue;
+            }
+
+            if(!i) {
+                if(!lookup_sequence(seg, fixed, seq)) {
+                    dbprintf(2, "[nf]");
+                    continue;
+                }
+                width = seg->width;
+                dbprintf(2, " A00@%d", j);
+            }
+            else {
+                width = (width + seg->width) / 2;
+                dbprintf(2, " %c%x%x@%d",
+                         'A' + seg->finder, seg->color, seg->side, j);
+            }
+            segs[i++] = j;
+            segs[i++] = -1;
+        }
+        if(i < 0)
+            break;
+
+        seg = db->segs + segs[0];
+        unsigned cnt = 0, chk = 0, age = (db->epoch - seg->epoch) & 0xff;
+        for(i = 1; segs[i] >= 0; i++) {
+            seg = db->segs + segs[i];
+            chk += seg->check;
+            cnt += seg->count;
+            age += (db->epoch - seg->epoch) & 0xff;
+        }
+
+        unsigned data0 = db->segs[segs[0]].data;
+        unsigned chk0 = data0 % 211;
+        chk %= 211;
+
+        dbprintf(2, " chk=%d ?= %d", chk, chk0);
+        if(chk != chk0)
+            continue;
+
+        dbprintf(2, " cnt=%d age=%d", cnt, age);
+        if(maxcnt > cnt || (maxcnt == cnt && maxage <= age))
+            continue;
+
+        dbprintf(2, " !");
+        maxcnt = cnt;
+        maxage = age;
+        for(i = 0; segs[i] >= 0; i++)
+            bestsegs[i] = segs[i];
+        bestsegs[i] = -1;
+    }
+
+    if(bestsegs[0] < 0)
+        return(ZBAR_PARTIAL);
+
+    if(acquire_lock(dcode, ZBAR_DATABAR_EXP))
+        return(ZBAR_PARTIAL);
+
+    for(i = 0; bestsegs[i] >= 0; i++)
+        segs[i] = db->segs[bestsegs[i]].data;
+
+    if(databar_postprocess_exp(dcode, segs)) {
+        release_lock(dcode, ZBAR_DATABAR_EXP);
+        return(ZBAR_PARTIAL);
+    }
+
+    for(i = 0; bestsegs[i] >= 0; i++)
+        if(bestsegs[i] != ifixed) {
+            seg = db->segs + bestsegs[i];
+            if(!--seg->count)
+                seg->finder = -1;
+        }
+
+    /* FIXME stacked rows are frequently reversed,
+     * so direction is impossible to determine at this level
+     */
+    dcode->direction = (1 - 2 * (seg->side ^ seg->color)) * dir;
+    dcode->modifiers = MOD(ZBAR_MOD_GS1);
+    return(ZBAR_DATABAR_EXP);
+}
+#undef IDX
+
+static inline unsigned
+calc_check (unsigned sig0,
+            unsigned sig1,
+            unsigned side,
+            unsigned mod)
+{
+    unsigned chk = 0;
+    int i;
+    for(i = 4; --i >= 0; ) {
+        chk = (chk * 3 + (sig1 & 0xf) + 1) * 3 + (sig0 & 0xf) + 1;
+        sig1 >>= 4;
+        sig0 >>= 4;
+        if(!(i & 1))
+            chk %= mod;
+    }
+    dbprintf(2, " chk=%d", chk);
+
+    if(side)
+        chk = (chk * (6561 % mod)) % mod;
+    return(chk);
+}
+
+static inline int
+calc_value4 (unsigned sig,
+             unsigned n,
+             unsigned wmax,
+             unsigned nonarrow)
+{
+    unsigned v = 0;
+    n--;
+
+    unsigned w0 = (sig >> 12) & 0xf;
+    if(w0 > 1) {
+        if(w0 > wmax)
+            return(-1);
+        unsigned n0 = n - w0;
+        unsigned sk20 = (n - 1) * n * (2 * n - 1);
+        unsigned sk21 = n0 * (n0 + 1) * (2 * n0 + 1);
+        v = sk20 - sk21 - 3 * (w0 - 1) * (2 * n - w0);
+
+        if(!nonarrow && w0 > 2 && n > 4) {
+            unsigned k = (n - 2) * (n - 1) * (2 * n - 3) - sk21;
+            k -= 3 * (w0 - 2) * (14 * n - 7 * w0 - 31);
+            v -= k;
+        }
+
+        if(n - 2 > wmax) {
+            unsigned wm20 = 2 * wmax * (wmax + 1);
+            unsigned wm21 = (2 * wmax + 1);
+            unsigned k = sk20;
+            if(n0 > wmax) {
+                k -= sk21;
+                k += 3 * (w0 - 1) * (wm20 - wm21 * (2 * n - w0));
+            }
+            else {
+                k -= (wmax + 1) * (wmax + 2) * (2 * wmax + 3);
+                k += 3 * (n - wmax - 2) * (wm20 - wm21 * (n + wmax + 1));
+            }
+            k *= 3;
+            v -= k;
+        }
+        v /= 12;
+    }
+    else
+        nonarrow = 1;
+    n -= w0;
+
+    unsigned w1 = (sig >> 8) & 0xf;
+    if(w1 > 1) {
+        if(w1 > wmax)
+            return(-1);
+        v += (2 * n - w1) * (w1 - 1) / 2;
+        if(!nonarrow && w1 > 2 && n > 3)
+            v -= (2 * n - w1 - 5) * (w1 - 2) / 2;
+        if(n - 1 > wmax) {
+            if(n - w1 > wmax)
+                v -= (w1 - 1) * (2 * n - w1 - 2 * wmax);
+            else
+                v -= (n - wmax) * (n - wmax - 1);
+        }
+    }
+    else
+        nonarrow = 1;
+    n -= w1;
+
+    unsigned w2 = (sig >> 4) & 0xf;
+    if(w2 > 1) {
+        if(w2 > wmax)
+            return(-1);
+        v += w2 - 1;
+        if(!nonarrow && w2 > 2 && n > 2)
+            v -= n - 2;
+        if(n > wmax)
+            v -= n - wmax;
+    }
+    else
+        nonarrow = 1;
+
+    unsigned w3 = sig & 0xf;
+    if(w3 == 1)
+        nonarrow = 1;
+    else if(w3 > wmax)
+        return(-1);
+
+    if(!nonarrow)
+        return(-1);
+
+    return(v);
+}
+
+static inline zbar_symbol_type_t
+decode_char (zbar_decoder_t *dcode,
+             databar_segment_t *seg,
+             int off,
+             int dir)
+{
+    databar_decoder_t *db = &dcode->databar;
+    unsigned s = calc_s(dcode, (dir > 0) ? off : off - 6, 8);
+    int n, i, emin[2] = { 0, }, sum = 0;
+    unsigned sig0 = 0, sig1 = 0;
+
+    if(seg->exp)
+        n = 17;
+    else if(seg->side)
+        n = 15;
+    else
+        n = 16;
+    emin[1] = -n;
+
+    dbprintf(2, "\n        char[%c%d]: n=%d s=%d w=%d sig=",
+             (dir < 0) ? '>' : '<', off, n, s, seg->width);
+    if(s < 13 || !check_width(seg->width, s, n))
+        return(ZBAR_NONE);
+
+    for(i = 4; --i >= 0; ) {
+        int e = decode_e(pair_width(dcode, off), s, n);
+        if(e < 0)
+            return(ZBAR_NONE);
+        dbprintf(2, "%d", e);
+        sum = e - sum;
+        off += dir;
+        sig1 <<= 4;
+        if(emin[1] < -sum)
+            emin[1] = -sum;
+        sig1 += sum;
+        if(!i)
+            break;
+
+        e = decode_e(pair_width(dcode, off), s, n);
+        if(e < 0)
+            return(ZBAR_NONE);
+        dbprintf(2, "%d", e);
+        sum = e - sum;
+        off += dir;
+        sig0 <<= 4;
+        if(emin[0] > sum)
+            emin[0] = sum;
+        sig0 += sum;
+    }
+
+    int diff = emin[~n & 1];
+    diff = diff + (diff << 4);
+    diff = diff + (diff << 8);
+
+    sig0 -= diff;
+    sig1 += diff;
+
+    dbprintf(2, " emin=%d,%d el=%04x/%04x", emin[0], emin[1], sig0, sig1);
+
+    unsigned sum0 = sig0 + (sig0 >> 8);
+    unsigned sum1 = sig1 + (sig1 >> 8);
+    sum0 += sum0 >> 4;
+    sum1 += sum1 >> 4;
+    sum0 &= 0xf;
+    sum1 &= 0xf;
+
+    dbprintf(2, " sum=%d/%d", sum0, sum1);
+
+    if(sum0 + sum1 + 8 != n) {
+        dbprintf(2, " [SUM]");
+        return(ZBAR_NONE);
+    }
+
+    if(((sum0 ^ (n >> 1)) | (sum1 ^ (n >> 1) ^ n)) & 1) {
+        dbprintf(2, " [ODD]");
+        return(ZBAR_NONE);
+    }
+
+    i = ((n & 0x3) ^ 1) * 5 + (sum1 >> 1);
+    zassert(i < sizeof(groups) / sizeof(*groups), -1,
+            "n=%d sum=%d/%d sig=%04x/%04x g=%d",
+            n, sum0, sum1, sig0, sig1, i);
+    struct group_s *g = groups + i;
+    dbprintf(2, "\n            g=%d(%d,%d,%d/%d)",
+             i, g->sum, g->wmax, g->todd, g->teven);
+
+    int vodd = calc_value4(sig0 + 0x1111, sum0 + 4, g->wmax, ~n & 1);
+    dbprintf(2, " v=%d", vodd);
+    if(vodd < 0 || vodd > g->todd)
+        return(ZBAR_NONE);
+
+    int veven = calc_value4(sig1 + 0x1111, sum1 + 4, 9 - g->wmax, n & 1);
+    dbprintf(2, "/%d", veven);
+    if(veven < 0 || veven > g->teven)
+        return(ZBAR_NONE);
+
+    int v = g->sum;
+    if(n & 2)
+        v += vodd + veven * g->todd;
+    else
+        v += veven + vodd * g->teven;
+
+    dbprintf(2, " f=%d(%x%x%x)", seg->finder, seg->exp, seg->color, seg->side);
+
+    unsigned chk = 0;
+    if(seg->exp) {
+        unsigned side = seg->color ^ seg->side ^ 1;
+        if(v >= 4096)
+            return(ZBAR_NONE);
+        /* skip A1 left */
+        chk = calc_check(sig0, sig1, side, 211);
+        if(seg->finder || seg->color || seg->side) {
+            i = (seg->finder << 1) - side + seg->color;
+            zassert(i >= 0 && i < 12, ZBAR_NONE,
+                    "f=%d(%x%x%x) side=%d i=%d\n",
+                    seg->finder, seg->exp, seg->color, seg->side, side, i);
+            chk = (chk * exp_checksums[i]) % 211;
+        }
+        else if(v >= 4009)
+            return(ZBAR_NONE);
+        else
+            chk = 0;
+    }
+    else {
+        chk = calc_check(sig0, sig1, seg->side, 79);
+        if(seg->color)
+            chk = (chk * 16) % 79;
+    }
+    dbprintf(2, " => %d val=%d", chk, v);
+
+    seg->check = chk;
+    seg->data = v;
+
+    merge_segment(db, seg);
+
+    if(seg->exp)
+        return(match_segment_exp(dcode, seg, dir));
+    else if(dir > 0)
+        return(match_segment(dcode, seg));
+    return(ZBAR_PARTIAL);
+}
+
+static inline int
+alloc_segment (databar_decoder_t *db)
+{
+    unsigned maxage = 0, csegs = db->csegs;
+    int i, old = -1;
+    for(i = 0; i < csegs; i++) {
+        databar_segment_t *seg = db->segs + i;
+        unsigned age;
+        if(seg->finder < 0) {
+            dbprintf(2, " free@%d", i);
+            return(i);
+        }
+        age = (db->epoch - seg->epoch) & 0xff;
+        if(age >= 128 && seg->count < 2) {
+            seg->finder = -1;
+            dbprintf(2, " stale@%d (%d - %d = %d)",
+                     i, db->epoch, seg->epoch, age);
+            return(i);
+        }
+
+        /* score based on both age and count */
+        if(age > seg->count)
+            age = age - seg->count + 1;
+        else
+            age = 1;
+
+        if(maxage < age) {
+            maxage = age;
+            old = i;
+            dbprintf(2, " old@%d(%u)", i, age);
+        }
+    }
+
+    if(csegs < DATABAR_MAX_SEGMENTS) {
+        dbprintf(2, " new@%d", i);
+        i = csegs;
+        csegs *= 2;
+        if(csegs > DATABAR_MAX_SEGMENTS)
+            csegs = DATABAR_MAX_SEGMENTS;
+        if(csegs != db->csegs) {
+            databar_segment_t *seg;
+            db->segs = realloc(db->segs, csegs * sizeof(*db->segs));
+            db->csegs = csegs;
+            seg = db->segs + csegs;
+            while(--seg, --csegs >= i) {
+                seg->finder = -1;
+                seg->exp = 0;
+                seg->color = 0;
+                seg->side = 0;
+                seg->partial = 0;
+                seg->count = 0;
+                seg->epoch = 0;
+                seg->check = 0;
+            }
+            return(i);
+        }
+    }
+    zassert(old >= 0, -1, "\n");
+
+    db->segs[old].finder = -1;
+    return(old);
+}
+
+static inline zbar_symbol_type_t
+decode_finder (zbar_decoder_t *dcode)
+{
+    databar_decoder_t *db = &dcode->databar;
+    databar_segment_t *seg;
+    unsigned e0 = pair_width(dcode, 1);
+    unsigned e2 = pair_width(dcode, 3);
+    unsigned e1, e3, s, finder, dir;
+    int sig, iseg;
+    dbprintf(2, "      databar: e0=%d e2=%d", e0, e2);
+    if(e0 < e2) {
+        unsigned e = e2 * 4;
+        if(e < 15 * e0 || e > 34 * e0)
+            return(ZBAR_NONE);
+        dir = 0;
+        e3 = pair_width(dcode, 4);
+    }
+    else {
+        unsigned e = e0 * 4;
+        if(e < 15 * e2 || e > 34 * e2)
+            return(ZBAR_NONE);
+        dir = 1;
+        e2 = e0;
+        e3 = pair_width(dcode, 0);
+    }
+    e1 = pair_width(dcode, 2);
+
+    s = e1 + e3;
+    dbprintf(2, " e1=%d e3=%d dir=%d s=%d", e1, e3, dir, s);
+    if(s < 12)
+        return(ZBAR_NONE);
+
+    sig = ((decode_e(e3, s, 14) << 8) | (decode_e(e2, s, 14) << 4) |
+           decode_e(e1, s, 14));
+    dbprintf(2, " sig=%04x", sig & 0xfff);
+    if(sig < 0 ||
+       ((sig >> 4) & 0xf) < 8 ||
+       ((sig >> 4) & 0xf) > 10 ||
+       (sig & 0xf) >= 10 ||
+       ((sig >> 8) & 0xf) >= 10 ||
+       (((sig >> 8) + sig) & 0xf) != 10)
+        return(ZBAR_NONE);
+
+    finder = (finder_hash[(sig - (sig >> 5)) & 0x1f] +
+              finder_hash[(sig >> 1) & 0x1f]) & 0x1f;
+    dbprintf(2, " finder=%d", finder);
+    if(finder == 0x1f ||
+       !TEST_CFG((finder < 9) ? db->config : db->config_exp, ZBAR_CFG_ENABLE))
+        return(ZBAR_NONE);
+
+    zassert(finder >= 0, ZBAR_NONE, "dir=%d sig=%04x f=%d\n",
+            dir, sig & 0xfff, finder);
+
+    iseg = alloc_segment(db);
+    if(iseg < 0)
+        return(ZBAR_NONE);
+
+    seg = db->segs + iseg;
+    seg->finder = (finder >= 9) ? finder - 9 : finder;
+    seg->exp = (finder >= 9);
+    seg->color = get_color(dcode) ^ dir ^ 1;
+    seg->side = dir;
+    seg->partial = 0;
+    seg->count = 1;
+    seg->width = s;
+    seg->epoch = db->epoch;
+
+    int rc = decode_char(dcode, seg, 12 - dir, -1);
+    if(!rc)
+        seg->partial = 1;
+    else
+        db->epoch++;
+
+    int i = (dcode->idx + 8 + dir) & 0xf;
+    zassert(db->chars[i] == -1, ZBAR_NONE, "\n");
+    db->chars[i] = iseg;
+    return(rc);
+}
+
+zbar_symbol_type_t
+_zbar_decode_databar (zbar_decoder_t *dcode)
+{
+    databar_decoder_t *db = &dcode->databar;
+    databar_segment_t *seg, *pair;
+    zbar_symbol_type_t sym;
+    int iseg, i = dcode->idx & 0xf;
+
+    sym = decode_finder(dcode);
+    dbprintf(2, "\n");
+
+    iseg = db->chars[i];
+    if(iseg < 0)
+        return(sym);
+
+    db->chars[i] = -1;
+    seg = db->segs + iseg;
+    dbprintf(2, "        databar: i=%d part=%d f=%d(%x%x%x)",
+             iseg, seg->partial, seg->finder, seg->exp, seg->color, seg->side);
+    zassert(seg->finder >= 0, ZBAR_NONE, "i=%d f=%d(%x%x%x) part=%x\n",
+            iseg, seg->finder, seg->exp, seg->color, seg->side, seg->partial);
+
+    if(seg->partial) {
+        pair = NULL;
+        seg->side = !seg->side;
+    }
+    else {
+        int jseg = alloc_segment(db);
+        pair = db->segs + iseg;
+        seg = db->segs + jseg;
+        seg->finder = pair->finder;
+        seg->exp = pair->exp;
+        seg->color = pair->color;
+        seg->side = !pair->side;
+        seg->partial = 0;
+        seg->count = 1;
+        seg->width = pair->width;
+        seg->epoch = db->epoch;
+    }
+
+    sym = decode_char(dcode, seg, 1, 1);
+    if(!sym) {
+        seg->finder = -1;
+        if(pair)
+            pair->partial = 1;
+    }
+    else
+        db->epoch++;
+    dbprintf(2, "\n");
+
+    return(sym);
+}
diff -r 563557a923d0 zbar/decoder/databar.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/zbar/decoder/databar.h	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,80 @@
+/*------------------------------------------------------------------------
+ *  Copyright 2010 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *
+ *  This file is part of the ZBar Bar Code Reader.
+ *
+ *  The ZBar Bar Code Reader is free software; you can redistribute it
+ *  and/or modify it under the terms of the GNU Lesser Public License as
+ *  published by the Free Software Foundation; either version 2.1 of
+ *  the License, or (at your option) any later version.
+ *
+ *  The ZBar Bar Code Reader is distributed in the hope that it will be
+ *  useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+ *  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser Public License
+ *  along with the ZBar Bar Code Reader; if not, write to the Free
+ *  Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ *  Boston, MA  02110-1301  USA
+ *
+ *  http://sourceforge.net/projects/zbar
+ *------------------------------------------------------------------------*/
+#ifndef _DATABAR_H_
+#define _DATABAR_H_
+
+#define DATABAR_MAX_SEGMENTS 32
+
+/* active DataBar (partial) segment entry */
+typedef struct databar_segment_s {
+    signed finder : 5;          /* finder pattern */
+    unsigned exp : 1;           /* DataBar expanded finder */
+    unsigned color : 1;         /* finder coloring */
+    unsigned side : 1;          /* data character side of finder */
+
+    unsigned partial : 1;       /* unpaired partial segment */
+    unsigned count : 7;         /* times encountered */
+    unsigned epoch : 8;         /* age, in characters scanned */
+    unsigned check : 8;         /* bar checksum */
+    signed short data;          /* decoded character data */
+    unsigned short width;       /* measured width of finder (14 modules) */
+} databar_segment_t;
+
+/* DataBar specific decode state */
+typedef struct databar_decoder_s {
+    unsigned config;            /* decoder configuration flags */
+    unsigned config_exp;
+
+    unsigned csegs : 8;         /* allocated segments */
+    unsigned epoch : 8;         /* current scan */
+
+    databar_segment_t *segs;    /* active segment list */
+    signed char chars[16];      /* outstanding character indices */
+} databar_decoder_t;
+
+/* reset DataBar segment decode state */
+static inline void databar_new_scan (databar_decoder_t *db)
+{
+    int i;
+    for(i = 0; i < 16; i++)
+        if(db->chars[i] >= 0) {
+            databar_segment_t *seg = db->segs + db->chars[i];
+            if(seg->partial)
+                seg->finder = -1;
+            db->chars[i] = -1;
+        }
+}
+
+/* reset DataBar accumulated segments */
+static inline void databar_reset (databar_decoder_t *db)
+{
+    int i, n = db->csegs;
+    databar_new_scan(db);
+    for(i = 0; i < n; i++)
+        db->segs[i].finder = -1;
+}
+
+/* decode DataBar symbols */
+zbar_symbol_type_t _zbar_decode_databar(zbar_decoder_t *dcode);
+
+#endif
diff -r 563557a923d0 zbar/decoder/ean.c
--- a/zbar/decoder/ean.c	Tue Oct 27 11:25:59 2009 -0400
+++ b/zbar/decoder/ean.c	Fri Feb 22 08:54:29 2013 -0300
@@ -1,5 +1,5 @@
 /*------------------------------------------------------------------------
- *  Copyright 2007-2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *  Copyright 2007-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
  *
  *  This file is part of the ZBar Bar Code Reader.
  *
@@ -23,12 +23,12 @@
 
 #include <config.h>
 #include <zbar.h>
-#include "decoder.h"
 
 #ifdef DEBUG_EAN
 # define DEBUG_LEVEL (DEBUG_EAN)
 #endif
 #include "debug.h"
+#include "decoder.h"
 
 /* partial decode symbol location */
 typedef enum symbol_partial_e {
@@ -109,35 +109,45 @@
 }
 #endif
 
+static inline int check_width (unsigned w0,
+                               unsigned w1)
+{
+    unsigned dw0 = w0;
+    w0 *= 8;
+    w1 *= 8;
+    return(w0 - dw0 <= w1 && w1 <= w0 + dw0);
+}
+
 /* evaluate previous N (>= 2) widths as auxiliary pattern,
  * using preceding 4 as character width
  */
 static inline signed char aux_end (zbar_decoder_t *dcode,
                                    unsigned char fwd)
 {
+    signed char code, i;
+
     /* reference width from previous character */
     unsigned s = calc_s(dcode, 4 + fwd, 4);
 
     /* check quiet zone */
     unsigned qz = get_width(dcode, 0);
-    if(!fwd && qz && qz < s * 3 / 4) {
-        dprintf(2, " [invalid quiet]");
+    if(!fwd && qz && qz <= s * 3 / 4) {
+        dbprintf(2, " [invalid quiet]");
         return(-1);
     }
 
-    dprintf(2, " (");
-    signed char code = 0;
-    unsigned char i;
+    dbprintf(2, " (");
+    code = 0;
     for(i = 1 - fwd; i < 3 + fwd; i++) {
         unsigned e = get_width(dcode, i) + get_width(dcode, i + 1);
-        dprintf(2, " %d", e);
+        dbprintf(2, " %d", e);
         code = (code << 2) | decode_e(e, s, 7);
         if(code < 0) {
-            dprintf(2, " [invalid end guard]");
+            dbprintf(2, " [invalid end guard]");
             return(-1);
         }
     }
-    dprintf(2, ") s=%d aux=%x", s, code);
+    dbprintf(2, ") s=%d aux=%x", s, code);
     return(code);
 }
 
@@ -147,60 +157,79 @@
 static inline signed char aux_start (zbar_decoder_t *dcode)
 {
     /* FIXME NB add-on has no guard in reverse */
-    unsigned e2 = get_width(dcode, 5) + get_width(dcode, 6);
+    unsigned e1, e2 = get_width(dcode, 5) + get_width(dcode, 6);
+    unsigned char E1;
+    if(dcode->ean.s4 < 6)
+        return(-1);
+
     if(decode_e(e2, dcode->ean.s4, 7)) {
-        dprintf(2, " [invalid any]");
-        return(/*FIXME (get_color(dcode) == ZBAR_SPACE) ? STATE_ADDON : */-1);
+        dbprintf(2, " [invalid any]");
+        return(-1);
     }
 
-    unsigned e1 = get_width(dcode, 4) + get_width(dcode, 5);
-    unsigned char E1 = decode_e(e1, dcode->ean.s4, 7);
+    e1 = get_width(dcode, 4) + get_width(dcode, 5);
+    E1 = decode_e(e1, dcode->ean.s4, 7);
 
     if(get_color(dcode) == ZBAR_BAR) {
         /* check for quiet-zone */
         unsigned qz = get_width(dcode, 7);
-        if(!qz || qz >= dcode->ean.s4 * 3 / 4) {
+        if(!qz || qz > dcode->ean.s4 * 3 / 4) {
             if(!E1) {
-                dprintf(2, " [valid normal]");
+                dbprintf(2, " [valid normal]");
                 return(0); /* normal symbol start */
             }
             else if(E1 == 1) {
-                dprintf(2, " [valid add-on]");
+                dbprintf(2, " [valid add-on]");
                 return(STATE_ADDON); /* add-on symbol start */
             }
         }
-        dprintf(2, " [invalid start]");
+        dbprintf(2, " [invalid start]");
         return(-1);
     }
 
     if(!E1) {
         /* attempting decode from SPACE => validate center guard */
         unsigned e3 = get_width(dcode, 6) + get_width(dcode, 7);
-        if(!decode_e(e3, dcode->ean.s4, 7)) {
-            dprintf(2, " [valid center]");
+        unsigned e4 = get_width(dcode, 7) + get_width(dcode, 8);
+        if(!decode_e(e3, dcode->ean.s4, 7) &&
+           !decode_e(e4, dcode->ean.s4, 7)) {
+            dbprintf(2, " [valid center]");
             return(0); /* start after center guard */
         }
     }
-    dprintf(2, " [invalid center]");
-    return(/*STATE_ADDON*/-1);
+    dbprintf(2, " [invalid center]");
+    return(-1);
+}
+
+/* check addon delimiter using current 4 as character
+ */
+static inline signed char aux_mid (zbar_decoder_t *dcode)
+{
+    unsigned e = get_width(dcode, 4) + get_width(dcode, 5);
+    return(decode_e(e, dcode->ean.s4, 7));
 }
 
 /* attempt to decode previous 4 widths (2 bars and 2 spaces) as a character */
 static inline signed char decode4 (zbar_decoder_t *dcode)
 {
+    signed char code;
+
     /* calculate similar edge measurements */
     unsigned e1 = ((get_color(dcode) == ZBAR_BAR)
                    ? get_width(dcode, 0) + get_width(dcode, 1)
                    : get_width(dcode, 2) + get_width(dcode, 3));
     unsigned e2 = get_width(dcode, 1) + get_width(dcode, 2);
-    dprintf(2, "\n        e1=%d e2=%d", e1, e2);
+    dbprintf(2, "\n        e1=%d e2=%d", e1, e2);
+
+    if(dcode->ean.s4 < 6)
+        return(-1);
 
     /* create compacted encoding for direct lookup */
-    signed char code = ((decode_e(e1, dcode->ean.s4, 7) << 2) |
-                        decode_e(e2, dcode->ean.s4, 7));
+    code = ((decode_e(e1, dcode->ean.s4, 7) << 2) |
+             decode_e(e2, dcode->ean.s4, 7));
     if(code < 0)
         return(-1);
-    dprintf(2, " code=%x", code);
+    dbprintf(2, " code=%x", code);
 
     /* 4 combinations require additional determinant (D2)
        E1E2 == 34 (0110)
@@ -209,25 +238,48 @@
        E1E2 == 44 (1010)
      */
     if((1 << code) & 0x0660) {
+        unsigned char mid, alt;
         /* use sum of bar widths */
         unsigned d2 = ((get_color(dcode) == ZBAR_BAR)
                        ? get_width(dcode, 0) + get_width(dcode, 2)
                        : get_width(dcode, 1) + get_width(dcode, 3));
         d2 *= 7;
-        unsigned char mid = (((1 << code) & 0x0420)
+        mid = (((1 << code) & 0x0420)
                              ? 3     /* E1E2 in 33,44 */
                              : 4);   /* E1E2 in 34,43 */
-        unsigned char alt = d2 > (mid * dcode->ean.s4);
+        alt = d2 > (mid * dcode->ean.s4);
         if(alt)
             code = ((code >> 1) & 3) | 0x10; /* compress code space */
-        dprintf(2, " (d2=%d(%d) alt=%d)", d2, mid * dcode->ean.s4, alt);
+        dbprintf(2, " (d2=%d(%d) alt=%d)", d2, mid * dcode->ean.s4, alt);
     }
-    dprintf(2, " char=%02x", digits[(unsigned char)code]);
+    dbprintf(2, " char=%02x", digits[(unsigned char)code]);
     zassert(code < 0x14, -1, "code=%02x e1=%x e2=%x s4=%x color=%x\n",
             code, e1, e2, dcode->ean.s4, get_color(dcode));
     return(code);
 }
 
+static inline char ean_part_end2 (ean_decoder_t *ean,
+                                  ean_pass_t *pass)
+{
+    if(!TEST_CFG(ean->ean2_config, ZBAR_CFG_ENABLE))
+        return(ZBAR_NONE);
+
+    /* extract parity bits */
+    unsigned char par = ((pass->raw[1] & 0x10) >> 3 |
+                         (pass->raw[2] & 0x10) >> 4);
+    /* calculate "checksum" */
+    unsigned char chk = ~((pass->raw[1] & 0xf) * 10 +
+                          (pass->raw[2] & 0xf)) & 0x3;
+    dbprintf(2, " par=%x chk=%x", par, chk);
+    if(par != chk)
+        return(ZBAR_NONE);
+
+    dbprintf(2, "\n");
+    dbprintf(1, "decode2=%x%x\n",
+             pass->raw[1] & 0xf, pass->raw[2] & 0xf);
+    return(ZBAR_EAN2);
+}
+
 static inline zbar_symbol_type_t ean_part_end4 (ean_pass_t *pass,
                                                 unsigned char fwd)
 {
@@ -237,7 +289,7 @@
                          (pass->raw[3] & 0x10) >> 3 |
                          (pass->raw[4] & 0x10) >> 4);
 
-    dprintf(2, " par=%x", par);
+    dbprintf(2, " par=%x", par);
     if(par && par != 0xf)
         /* invalid parity combination */
         return(ZBAR_NONE);
@@ -245,6 +297,7 @@
     if(!par == fwd) {
         /* reverse sampled digits */
         unsigned char tmp = pass->raw[1];
+        pass->state |= STATE_REV;
         pass->raw[1] = pass->raw[4];
         pass->raw[4] = tmp;
         tmp = pass->raw[2];
@@ -252,15 +305,51 @@
         pass->raw[3] = tmp;
     }
 
-    dprintf(2, "\n");
-    dprintf(1, "decode4=%x%x%x%x\n",
-            pass->raw[1] & 0xf, pass->raw[2] & 0xf,
-            pass->raw[3] & 0xf, pass->raw[4] & 0xf);
+    dbprintf(2, "\n");
+    dbprintf(1, "decode4=%x%x%x%x\n",
+             pass->raw[1] & 0xf, pass->raw[2] & 0xf,
+             pass->raw[3] & 0xf, pass->raw[4] & 0xf);
     if(!par)
         return(ZBAR_EAN8 | EAN_RIGHT);
     return(ZBAR_EAN8 | EAN_LEFT);
 }
 
+static inline char ean_part_end5 (ean_decoder_t *ean,
+                                  ean_pass_t *pass)
+{
+    if(!TEST_CFG(ean->ean5_config, ZBAR_CFG_ENABLE))
+        return(ZBAR_NONE);
+
+    /* extract parity bits */
+    unsigned char par = ((pass->raw[1] & 0x10) |
+                         (pass->raw[2] & 0x10) >> 1 |
+                         (pass->raw[3] & 0x10) >> 2 |
+                         (pass->raw[4] & 0x10) >> 3 |
+                         (pass->raw[5] & 0x10) >> 4);
+    /* calculate checksum */
+    unsigned char chk = (((pass->raw[1] & 0x0f) +
+                          (pass->raw[2] & 0x0f) * 3 +
+                          (pass->raw[3] & 0x0f) +
+                          (pass->raw[4] & 0x0f) * 3 +
+                          (pass->raw[5] & 0x0f)) * 3) % 10;
+
+    unsigned char parchk = parity_decode[par >> 1];
+    if(par & 1)
+        parchk >>= 4;
+    parchk &= 0xf;
+    dbprintf(2, " par=%x(%d) chk=%d", par, parchk, chk);
+    if(parchk != chk)
+        return(ZBAR_NONE);
+
+    dbprintf(2, "\n");
+    dbprintf(1, "decode5=%x%x%x%x%x\n",
+             pass->raw[1] & 0xf, pass->raw[2] & 0xf,
+             pass->raw[3] & 0xf, pass->raw[4] & 0xf,
+             pass->raw[5] & 0xf);
+
+    return(ZBAR_EAN5);
+}
+
 static inline zbar_symbol_type_t ean_part_end7 (ean_decoder_t *ean,
                                                 ean_pass_t *pass,
                                                 unsigned char fwd)
@@ -285,15 +374,16 @@
     if(par & 1)
         pass->raw[0] >>= 4;
     pass->raw[0] &= 0xf;
-    dprintf(2, " par=%02x(%x)", par, pass->raw[0]);
+    dbprintf(2, " par=%02x(%x)", par, pass->raw[0]);
 
     if(pass->raw[0] == 0xf)
         /* invalid parity combination */
         return(ZBAR_NONE);
 
     if(!par == fwd) {
+        unsigned char i;
+        pass->state |= STATE_REV;
         /* reverse sampled digits */
-        unsigned char i;
         for(i = 1; i < 4; i++) {
             unsigned char tmp = pass->raw[i];
             pass->raw[i] = pass->raw[7 - i];
@@ -301,12 +391,12 @@
         }
     }
 
-    dprintf(2, "\n");
-    dprintf(1, "decode=%x%x%x%x%x%x%x(%02x)\n",
-            pass->raw[0] & 0xf, pass->raw[1] & 0xf,
-            pass->raw[2] & 0xf, pass->raw[3] & 0xf,
-            pass->raw[4] & 0xf, pass->raw[5] & 0xf,
-            pass->raw[6] & 0xf, par);
+    dbprintf(2, "\n");
+    dbprintf(1, "decode=%x%x%x%x%x%x%x(%02x)\n",
+             pass->raw[0] & 0xf, pass->raw[1] & 0xf,
+             pass->raw[2] & 0xf, pass->raw[3] & 0xf,
+             pass->raw[4] & 0xf, pass->raw[5] & 0xf,
+             pass->raw[6] & 0xf, par);
 
     if(TEST_CFG(ean->ean13_config, ZBAR_CFG_ENABLE)) {
         if(!par)
@@ -324,54 +414,100 @@
 static inline zbar_symbol_type_t decode_pass (zbar_decoder_t *dcode,
                                               ean_pass_t *pass)
 {
+    unsigned char idx, fwd;
     pass->state++;
-    unsigned char idx = pass->state & STATE_IDX;
-    unsigned char fwd = pass->state & 1;
+    idx = pass->state & STATE_IDX;
+    fwd = pass->state & 1;
 
-    if(get_color(dcode) == ZBAR_SPACE &&
-       (idx == 0x10 || idx == 0x11) &&
-       TEST_CFG(dcode->ean.ean8_config, ZBAR_CFG_ENABLE) &&
-       !aux_end(dcode, fwd)) {
-        dprintf(2, " fwd=%x", fwd);
-        zbar_symbol_type_t part = ean_part_end4(pass, fwd);
-        pass->state = -1;
-        return(part);
+    if(get_color(dcode) == ZBAR_SPACE) {
+        if(pass->state & STATE_ADDON) {
+            dbprintf(2, " i=%d", idx);
+            if(idx == 0x09 || idx == 0x21) {
+                unsigned qz = get_width(dcode, 0);
+                unsigned s = calc_s(dcode, 1, 4);
+                zbar_symbol_type_t part = !qz || (qz >= s * 3 / 4);
+                if(part && idx == 0x09)
+                    part = ean_part_end2(&dcode->ean, pass);
+                else if(part)
+                    part = ean_part_end5(&dcode->ean, pass);
+
+                if(part || idx == 0x21) {
+                    dcode->ean.direction = 0;
+                    pass->state = -1;
+                    return(part);
+                }
+            }
+            if((idx & 7) == 1) {
+                dbprintf(2, " +");
+                pass->state += 2;
+                idx += 2;
+            }
+        }
+        else if((idx == 0x10 || idx == 0x11) &&
+                TEST_CFG(dcode->ean.ean8_config, ZBAR_CFG_ENABLE) &&
+                !aux_end(dcode, fwd)) {
+            dbprintf(2, " fwd=%x", fwd);
+            zbar_symbol_type_t part = ean_part_end4(pass, fwd);
+            if(part)
+                dcode->ean.direction = (pass->state & STATE_REV) != 0;
+            pass->state = -1;
+            return(part);
+        }
+	else if((idx == 0x18 || idx == 0x19)) {
+	  zbar_symbol_type_t part = ZBAR_NONE;
+	  dbprintf(2, " fwd=%x", fwd);
+	  if(!aux_end(dcode, fwd) && pass->raw[5] != 0xff)
+	    part = ean_part_end7(&dcode->ean, pass, fwd);
+	  if(part)
+	    dcode->ean.direction = (pass->state & STATE_REV) != 0;
+	  pass->state = -1;
+	  return(part);
+        }
     }
 
+    if(pass->state & STATE_ADDON)
+        idx >>= 1;
+
     if(!(idx & 0x03) && idx <= 0x14) {
+        signed char code = -1;
+        unsigned w = pass->width;
         if(!dcode->ean.s4)
             return(0);
         /* validate guard bars before decoding first char of symbol */
         if(!pass->state) {
             pass->state = aux_start(dcode);
+            pass->width = dcode->ean.s4;
             if(pass->state < 0)
                 return(0);
             idx = pass->state & STATE_IDX;
         }
-        signed char code = decode4(dcode);
-        if(code < 0)
+        else {
+            w = check_width(w, dcode->ean.s4);
+            if(w)
+                pass->width = (pass->width + dcode->ean.s4 * 3) / 4;
+        }
+
+        if(w)
+            code = decode4(dcode);
+        else
+            dbprintf(2, " [bad width]");
+
+        if((code < 0 && idx != 0x10) || 
+           (idx > 0 && (pass->state & STATE_ADDON) && aux_mid(dcode)))
             pass->state = -1;
+        else if(code < 0)
+            pass->raw[5] = 0xff;
         else {
-            dprintf(2, "\n        raw[%x]=%02x =>", idx >> 2,
-                    digits[(unsigned char)code]);
+            dbprintf(2, "\n        raw[%x]=%02x =>", idx >> 2,
+                     digits[(unsigned char)code]);
             pass->raw[(idx >> 2) + 1] = digits[(unsigned char)code];
-            dprintf(2, " raw=%d%d%d%d%d%d%d",
-                    pass->raw[0] & 0xf, pass->raw[1] & 0xf,
-                    pass->raw[2] & 0xf, pass->raw[3] & 0xf,
-                    pass->raw[4] & 0xf, pass->raw[5] & 0xf,
-                    pass->raw[6] & 0xf);
+            dbprintf(2, " raw=%d%d%d%d%d%d%d",
+                     pass->raw[0] & 0xf, pass->raw[1] & 0xf,
+                     pass->raw[2] & 0xf, pass->raw[3] & 0xf,
+                     pass->raw[4] & 0xf, pass->raw[5] & 0xf,
+                     pass->raw[6] & 0xf);
         }
     }
-
-    if(get_color(dcode) == ZBAR_SPACE &&
-       (idx == 0x18 || idx == 0x19)) {
-        zbar_symbol_type_t part = ZBAR_NONE;
-        dprintf(2, " fwd=%x", fwd);
-        if(!aux_end(dcode, fwd))
-            part = ean_part_end7(&dcode->ean, pass, fwd);
-        pass->state = -1;
-        return(part);
-    }
     return(0);
 }
 
@@ -379,7 +515,7 @@
                                                int n)
 {
     unsigned char chk = 0;
-    unsigned char i;
+    unsigned char i, d;
     for(i = 0; i < n; i++) {
         unsigned char d = ean->buf[i];
         zassert(d < 10, -1, "i=%x d=%x chk=%x %s\n", i, d, chk,
@@ -397,12 +533,12 @@
             _zbar_decoder_buf_dump((void*)ean->buf, 18));
     if(chk)
         chk = 10 - chk;
-    unsigned char d = ean->buf[n];
+    d = ean->buf[n];
     zassert(d < 10, -1, "n=%x d=%x chk=%x %s\n", n, d, chk,
             _zbar_decoder_buf_dump((void*)ean->buf, 18));
     if(chk != d) {
-        dprintf(1, "\nchecksum mismatch %d != %d (%s)\n",
-                chk, d, dsprintbuf(ean));
+        dbprintf(1, "\nchecksum mismatch %d != %d (%s)\n",
+                 chk, d, dsprintbuf(ean));
         return(-1);
     }
     return(0);
@@ -431,10 +567,11 @@
                                     ean_pass_t *pass)
 {
     int i = 0;
+    unsigned char decode;
     /* parity encoded digit is checksum */
     ean->buf[12] = pass->raw[i++];
 
-    unsigned char decode = pass->raw[6] & 0xf;
+    decode = pass->raw[6] & 0xf;
     ean->buf[0] = 0;
     ean->buf[1] = 0;
     ean->buf[2] = pass->raw[i++] & 0xf;
@@ -446,7 +583,7 @@
     ean->buf[8] = 0;
     ean->buf[9] = (decode < 3) ? pass->raw[i++] & 0xf : 0;
     ean->buf[10] = (decode < 4) ? pass->raw[i++] & 0xf : 0;
-    ean->buf[11] = (decode < 5) ? pass->raw[i++] & 0xf : decode;
+    ean->buf[11] = (decode < 5) ? pass->raw[i] & 0xf : decode;
 }
 
 static inline zbar_symbol_type_t integrate_partial (ean_decoder_t *ean,
@@ -455,70 +592,75 @@
 {
     /* copy raw data into holding buffer */
     /* if same partial is not consistent, reset others */
-    dprintf(2, " integrate part=%x (%s)", part, dsprintbuf(ean));
+    dbprintf(2, " integrate part=%x (%s)", part, dsprintbuf(ean));
     signed char i, j;
-    if(part & ZBAR_ADDON) {
-        /* FIXME TBD */
-        for(i = (part == ZBAR_ADDON5) ? 4 : 1; i >= 0; i--) {
-            unsigned char digit = pass->raw[i] & 0xf;
-            if(ean->addon && ean->buf[i + 13] != digit) {
-                /* partial mismatch - reset collected parts */
-                ean->left = ean->right = ean->addon = ZBAR_NONE;
-            }
-            ean->buf[i + 13] = digit;
-        }
-        ean->addon = part;
-    }
-    else {
-        if((ean->left && ((part & ZBAR_SYMBOL) != ean->left)) ||
-           (ean->right && ((part & ZBAR_SYMBOL) != ean->right))) {
-            /* partial mismatch - reset collected parts */
-            dprintf(2, " rst(type %x %x)", ean->left, ean->right);
-            ean->left = ean->right = ean->addon = ZBAR_NONE;
-        }
 
-        if(part & EAN_RIGHT) {
-            part &= ZBAR_SYMBOL;
-            j = (part == ZBAR_EAN13) ? 12 : 7;
-            for(i = (part == ZBAR_EAN13) ? 6 : 4; i; i--, j--) {
-                unsigned char digit = pass->raw[i] & 0xf;
-                if(ean->right && ean->buf[j] != digit) {
-                    /* partial mismatch - reset collected parts */
-                    dprintf(2, " rst(right)");
-                    ean->left = ean->right = ean->addon = ZBAR_NONE;
-                }
-                ean->buf[j] = digit;
-            }
-            ean->right = part;
-        }
-        else if(part != ZBAR_UPCE) /* EAN_LEFT */ {
-            j = (part == ZBAR_EAN13) ? 6 : 3;
-            for(i = (part == ZBAR_EAN13) ? 6 : 4; j >= 0; i--, j--) {
-                unsigned char digit = pass->raw[i] & 0xf;
-                if(ean->left && ean->buf[j] != digit) {
-                    /* partial mismatch - reset collected parts */
-                    dprintf(2, " rst(left)");
-                    ean->left = ean->right = ean->addon = ZBAR_NONE;
-                }
-                ean->buf[j] = digit;
-            }
-            ean->left = part;
-        }
-        else /* ZBAR_UPCE */
-            ean_expand_upce(ean, pass);
+    if((ean->left && ((part & ZBAR_SYMBOL) != ean->left)) ||
+       (ean->right && ((part & ZBAR_SYMBOL) != ean->right))) {
+        /* partial mismatch - reset collected parts */
+        dbprintf(2, " rst(type %x %x)", ean->left, ean->right);
+        ean->left = ean->right = ZBAR_NONE;
     }
 
-    if((part & ZBAR_SYMBOL) != ZBAR_UPCE) {
-        part = (ean->left & ean->right);
-        if(!part)
-            part = ZBAR_PARTIAL;
+    if((ean->left || ean->right) &&
+       !check_width(ean->width, pass->width)) {
+      dbprintf(2, " rst(width %d)", pass->width);
+      ean->left = ean->right = ZBAR_NONE;
     }
 
+
+    if(part & EAN_RIGHT) {
+        part &= ZBAR_SYMBOL;
+        j = part - 1;
+        for(i = part >> 1; i; i--, j--) {
+            unsigned char digit = pass->raw[i] & 0xf;
+            if(ean->right && ean->buf[j] != digit) {
+                /* partial mismatch - reset collected parts */
+                dbprintf(2, " rst(right)");
+                ean->left = ean->right = ZBAR_NONE;
+            }
+            ean->buf[j] = digit;
+        }
+        ean->right = part;
+        part &= ean->left;  /* FIXME!? */
+    }
+    else if(part == ZBAR_EAN13 || part == ZBAR_EAN8) /* EAN_LEFT */ {
+        j = (part - 1) >> 1;
+        for(i = part >> 1; j >= 0; i--, j--) {
+            unsigned char digit = pass->raw[i] & 0xf;
+            if(ean->left && ean->buf[j] != digit) {
+                /* partial mismatch - reset collected parts */
+                dbprintf(2, " rst(left)");
+                ean->left = ean->right = ZBAR_NONE;
+            }
+            ean->buf[j] = digit;
+        }
+        ean->left = part;
+        part &= ean->right;  /* FIXME!? */
+    }
+    else if(part != ZBAR_UPCE) /* add-ons */ {
+        for(i = part; i > 0; i--)
+            ean->buf[i - 1] = pass->raw[i] & 0xf;
+        ean->left = part;
+    }
+    else
+        ean_expand_upce(ean, pass);
+
+    ean->width = pass->width;
+
+    if(!part)
+        part = ZBAR_PARTIAL;
+
     if(((part == ZBAR_EAN13 ||
          part == ZBAR_UPCE) && ean_verify_checksum(ean, 12)) ||
-       (part == ZBAR_EAN8 && ean_verify_checksum(ean, 7)))
-        /* invalid parity */
+       (part == ZBAR_EAN8 && ean_verify_checksum(ean, 7))) {
+        /* invalid checksum */
+        if(ean->right)
+	  ean->left = ZBAR_NONE;
+        else
+	  ean->right = ZBAR_NONE;
         part = ZBAR_NONE;
+    }
 
     if(part == ZBAR_EAN13) {
         /* special case EAN-13 subsets */
@@ -553,10 +695,8 @@
             part = ZBAR_NONE;
     }
 
-    if(part > ZBAR_PARTIAL)
-        part |= ean->addon;
-
-    dprintf(2, " %x/%x=%x", ean->left, ean->right, part);
+    dbprintf(2, " dir=%d %x/%x=%x",
+             ean->direction, ean->left, ean->right, part);
     return(part);
 }
 
@@ -565,7 +705,7 @@
                                 zbar_symbol_type_t sym)
 {
     ean_decoder_t *ean = &dcode->ean;
-    zbar_symbol_type_t base = sym & ZBAR_SYMBOL;
+    zbar_symbol_type_t base = sym;
     int i = 0, j = 0;
     if(base > ZBAR_PARTIAL) {
         if(base == ZBAR_UPCA)
@@ -580,22 +720,23 @@
             i = 3;
 
         if(base == ZBAR_ISBN10 ||
-           !TEST_CFG(ean_get_config(ean, sym), ZBAR_CFG_EMIT_CHECK))
+           (base > ZBAR_EAN5 &&
+            !TEST_CFG(ean_get_config(ean, sym), ZBAR_CFG_EMIT_CHECK)))
             base--;
 
         for(; j < base && ean->buf[i] >= 0; i++, j++)
             dcode->buf[j] = ean->buf[i] + '0';
 
-        if((sym & ZBAR_SYMBOL) == ZBAR_ISBN10 && j == 9 &&
+        if(sym == ZBAR_ISBN10 && j == 9 &&
            TEST_CFG(ean->isbn10_config, ZBAR_CFG_EMIT_CHECK))
             /* recalculate ISBN-10 check digit */
             dcode->buf[j++] = isbn10_calc_checksum(ean);
     }
-    if(sym & ZBAR_ADDON)
-        for(i = 13; ean->buf[i] >= 0; i++, j++)
-            dcode->buf[j] = ean->buf[i] + '0';
     dcode->buflen = j;
     dcode->buf[j] = '\0';
+    dcode->direction = 1 - 2 * ean->direction;
+    dcode->modifiers = 0;
+    dbprintf(2, " base=%d j=%d (%s)", base, j, dcode->buf);
 }
 
 zbar_symbol_type_t _zbar_decode_ean (zbar_decoder_t *dcode)
@@ -603,39 +744,40 @@
     /* process upto 4 separate passes */
     zbar_symbol_type_t sym = ZBAR_NONE;
     unsigned char pass_idx = dcode->idx & 3;
+    unsigned char i;
 
     /* update latest character width */
     dcode->ean.s4 -= get_width(dcode, 4);
     dcode->ean.s4 += get_width(dcode, 0);
 
-    unsigned char i;
     for(i = 0; i < 4; i++) {
         ean_pass_t *pass = &dcode->ean.pass[i];
         if(pass->state >= 0 ||
            i == pass_idx)
         {
-            dprintf(2, "      ean[%x/%x]: idx=%x st=%d s=%d",
-                    pass_idx, i, dcode->idx, pass->state, dcode->ean.s4);
-            zbar_symbol_type_t part = decode_pass(dcode, pass);
+            zbar_symbol_type_t part;
+            dbprintf(2, "      ean[%x/%x]: idx=%x st=%d s=%d",
+                     i, pass_idx, dcode->idx, pass->state, dcode->ean.s4);
+            part = decode_pass(dcode, pass);
             if(part) {
                 /* update accumulated data from new partial decode */
                 sym = integrate_partial(&dcode->ean, pass, part);
                 if(sym) {
                     /* this pass valid => _reset_ all passes */
-                    dprintf(2, " sym=%x", sym);
+                    dbprintf(2, " sym=%x", sym);
                     dcode->ean.pass[0].state = dcode->ean.pass[1].state = -1;
                     dcode->ean.pass[2].state = dcode->ean.pass[3].state = -1;
                     if(sym > ZBAR_PARTIAL) {
-                        if(!get_lock(dcode, ZBAR_EAN13))
+                        if(!acquire_lock(dcode, sym))
                             postprocess(dcode, sym);
                         else {
-                            dprintf(1, " [locked %d]", dcode->lock);
+                            dbprintf(1, " [locked %d]", dcode->lock);
                             sym = ZBAR_PARTIAL;
                         }
                     }
                 }
             }
-            dprintf(2, "\n");
+            dbprintf(2, "\n");
         }
     }
     return(sym);
diff -r 563557a923d0 zbar/decoder/ean.h
--- a/zbar/decoder/ean.h	Tue Oct 27 11:25:59 2009 -0400
+++ b/zbar/decoder/ean.h	Fri Feb 22 08:54:29 2013 -0300
@@ -1,5 +1,5 @@
 /*------------------------------------------------------------------------
- *  Copyright 2007-2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *  Copyright 2007-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
  *
  *  This file is part of the ZBar Bar Code Reader.
  *
@@ -26,18 +26,20 @@
 /* state of each parallel decode attempt */
 typedef struct ean_pass_s {
     signed char state;          /* module position of w[idx] in symbol */
+#define STATE_REV   0x80        /*   scan direction reversed */
 #define STATE_ADDON 0x40        /*   scanning add-on */
-#define STATE_IDX   0x1f        /*   element offset into symbol */
+#define STATE_IDX   0x3f        /*   element offset into symbol */
+    unsigned width;             /* width of last character */
     unsigned char raw[7];       /* decode in process */
 } ean_pass_t;
 
 /* EAN/UPC specific decode state */
 typedef struct ean_decoder_s {
     ean_pass_t pass[4];         /* state of each parallel decode attempt */
-    zbar_symbol_type_t left;   /* current holding buffer contents */
+    zbar_symbol_type_t left;    /* current holding buffer contents */
     zbar_symbol_type_t right;
-    zbar_symbol_type_t addon;
-    unsigned s4;                /* character width */
+    int direction;              /* scan direction */
+    unsigned s4, width;         /* character width */
     signed char buf[18];        /* holding buffer */
 
     signed char enable;
@@ -47,6 +49,8 @@
     unsigned upce_config;
     unsigned isbn10_config;
     unsigned isbn13_config;
+    unsigned ean5_config;
+    unsigned ean2_config;
 } ean_decoder_t;
 
 /* reset EAN/UPC pass specific state */
@@ -61,20 +65,22 @@
 static inline void ean_reset (ean_decoder_t *ean)
 {
     ean_new_scan(ean);
-    ean->left = ean->right = ean->addon = ZBAR_NONE;
+    ean->left = ean->right = ZBAR_NONE;
 }
 
 static inline unsigned ean_get_config (ean_decoder_t *ean,
                                        zbar_symbol_type_t sym)
 {
-    switch(sym & ZBAR_SYMBOL) {
-    case ZBAR_EAN13:  return(ean->ean13_config);
+    switch(sym) {
+    case ZBAR_EAN2:   return(ean->ean2_config);
+    case ZBAR_EAN5:   return(ean->ean5_config);
     case ZBAR_EAN8:   return(ean->ean8_config);
-    case ZBAR_UPCA:   return(ean->upca_config);
     case ZBAR_UPCE:   return(ean->upce_config);
     case ZBAR_ISBN10: return(ean->isbn10_config);
+    case ZBAR_UPCA:   return(ean->upca_config);
+    case ZBAR_EAN13:  return(ean->ean13_config);
     case ZBAR_ISBN13: return(ean->isbn13_config);
-    default:           return(0);
+    default:          return(0);
     }
 }
 
diff -r 563557a923d0 zbar/decoder/i25.c
--- a/zbar/decoder/i25.c	Tue Oct 27 11:25:59 2009 -0400
+++ b/zbar/decoder/i25.c	Fri Feb 22 08:54:29 2013 -0300
@@ -1,5 +1,5 @@
 /*------------------------------------------------------------------------
- *  Copyright 2008-2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *  Copyright 2008-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
  *
  *  This file is part of the ZBar Bar Code Reader.
  *
@@ -25,12 +25,12 @@
 #include <string.h>     /* memmove */
 
 #include <zbar.h>
-#include "decoder.h"
 
 #ifdef DEBUG_I25
 # define DEBUG_LEVEL (DEBUG_I25)
 #endif
 #include "debug.h"
+#include "decoder.h"
 
 static inline unsigned char i25_decode1 (unsigned char enc,
                                          unsigned e,
@@ -49,7 +49,7 @@
                                           unsigned char offset)
 {
     i25_decoder_t *dcode25 = &dcode->i25;
-    dprintf(2, " s=%d", dcode25->s10);
+    dbprintf(2, " s=%d", dcode25->s10);
     if(dcode25->s10 < 10)
         return(0xff);
 
@@ -65,11 +65,11 @@
             par++;
     }
 
-    dprintf(2, " enc=%02x par=%x", enc, par);
+    dbprintf(2, " enc=%02x par=%x", enc, par);
 
     /* parity check */
     if(par != 2) {
-        dprintf(2, " [bad parity]");
+        dbprintf(2, " [bad parity]");
         return(0xff);
     }
 
@@ -79,12 +79,12 @@
         if(enc == 12)
             enc = 0;
         else if(--enc > 9) {
-            dprintf(2, " [invalid encoding]");
+            dbprintf(2, " [invalid encoding]");
             return(0xff);
         }
     }
 
-    dprintf(2, " => %x", enc);
+    dbprintf(2, " => %x", enc);
     return(enc);
 }
 
@@ -103,7 +103,7 @@
     if((get_color(dcode) == ZBAR_BAR)
        ? enc != 4
        : (enc = i25_decode1(enc, get_width(dcode, i++), dcode25->s10))) {
-        dprintf(4, "      i25: s=%d enc=%x [invalid]\n", dcode25->s10, enc);
+        dbprintf(4, "      i25: s=%d enc=%x [invalid]\n", dcode25->s10, enc);
         return(ZBAR_NONE);
     }
 
@@ -111,10 +111,10 @@
      * we require 5.25n for w=2n to 6.75n for w=3n
      * (FIXME should really factor in w:n ratio)
      */
-    unsigned quiet = get_width(dcode, i++);
+    unsigned quiet = get_width(dcode, i);
     if(quiet && quiet < dcode25->s10 * 3 / 8) {
-        dprintf(3, "      i25: s=%d enc=%x q=%d [invalid qz]\n",
-                dcode25->s10, enc, quiet);
+        dbprintf(3, "      i25: s=%d enc=%x q=%d [invalid qz]\n",
+                 dcode25->s10, enc, quiet);
         return(ZBAR_NONE);
     }
 
@@ -124,6 +124,21 @@
     return(ZBAR_PARTIAL);
 }
 
+static inline int i25_acquire_lock (zbar_decoder_t *dcode)
+{
+    int i;
+    /* lock shared resources */
+    if(acquire_lock(dcode, ZBAR_I25)) {
+        dcode->i25.character = -1;
+        return(1);
+    }
+
+    /* copy holding buffer */
+    for(i = 4; --i >= 0; )
+        dcode->buf[i] = dcode->i25.buf[i];
+    return(0);
+}
+
 static inline signed char i25_decode_end (zbar_decoder_t *dcode)
 {
     i25_decoder_t *dcode25 = &dcode->i25;
@@ -133,7 +148,8 @@
     if((quiet && quiet < dcode25->width * 3 / 8) ||
        decode_e(get_width(dcode, 1), dcode25->width, 45) > 2 ||
        decode_e(get_width(dcode, 2), dcode25->width, 45) > 2) {
-        dprintf(3, " s=%d q=%d [invalid qz]\n", dcode25->width, quiet);
+        dbprintf(3, "      i25: s=%d q=%d [invalid qz]\n",
+                 dcode25->width, quiet);
         return(ZBAR_NONE);
     }
 
@@ -145,9 +161,14 @@
           decode_e(get_width(dcode, 4), dcode25->width, 45) > 2))
         return(ZBAR_NONE);
 
+    if(dcode25->character <= 4 &&
+       i25_acquire_lock(dcode))
+        return(ZBAR_PARTIAL);
+
+    dcode->direction = 1 - 2 * dcode25->direction;
     if(dcode25->direction) {
         /* reverse buffer */
-        dprintf(2, " (rev)");
+        dbprintf(2, " (rev)");
         int i;
         for(i = 0; i < dcode25->character / 2; i++) {
             unsigned j = dcode25->character - 1 - i;
@@ -160,15 +181,19 @@
     if(dcode25->character < CFG(*dcode25, ZBAR_CFG_MIN_LEN) ||
        (CFG(*dcode25, ZBAR_CFG_MAX_LEN) > 0 &&
         dcode25->character > CFG(*dcode25, ZBAR_CFG_MAX_LEN))) {
-        dprintf(2, " [invalid len]\n");
-        dcode->lock = 0;
+        dbprintf(2, " [invalid len]\n");
+        release_lock(dcode, ZBAR_I25);
         dcode25->character = -1;
         return(ZBAR_NONE);
     }
 
+    zassert(dcode25->character < dcode->buf_alloc, ZBAR_NONE, "i=%02x %s\n",
+            dcode25->character,
+            _zbar_decoder_buf_dump(dcode->buf, dcode25->character));
     dcode->buflen = dcode25->character;
     dcode->buf[dcode25->character] = '\0';
-    dprintf(2, " [valid end]\n");
+    dcode->modifiers = 0;
+    dbprintf(2, " [valid end]\n");
     dcode25->character = -1;
     return(ZBAR_I25);
 }
@@ -193,42 +218,48 @@
     /* FIXME check current character width against previous */
     dcode25->width = dcode25->s10;
 
-    dprintf(2, "      i25[%c%02d+%x]",
-            (dcode25->direction) ? '<' : '>',
-            dcode25->character, dcode25->element);
+    dbprintf(2, "      i25[%c%02d+%x]",
+             (dcode25->direction) ? '<' : '>',
+             dcode25->character, dcode25->element);
 
-    /* lock shared resources */
-    if(!dcode25->character && get_lock(dcode, ZBAR_I25)) {
-        dcode25->character = -1;
-        dprintf(2, " [locked %d]\n", dcode->lock);
+    if(dcode25->character == 4 && i25_acquire_lock(dcode))
         return(ZBAR_PARTIAL);
+
+    unsigned char c = i25_decode10(dcode, 1);
+    dbprintf(2, " c=%x", c);
+    if(c > 9) {
+        dbprintf(2, " [aborted]\n");
+        goto reset;
     }
 
-    unsigned char c = i25_decode10(dcode, 1);
-    dprintf(2, " c=%x", c);
+    if(size_buf(dcode, dcode25->character + 3)) {
+        dbprintf(2, " [overflow]\n");
+        goto reset;
+    }
 
-    if(c > 9 ||
-       ((dcode25->character >= BUFFER_MIN) &&
-        size_buf(dcode, dcode25->character + 2))) {
-        dprintf(2, (c > 9) ? " [aborted]\n" : " [overflow]\n");
-        dcode->lock = 0;
-        dcode25->character = -1;
-        return(ZBAR_NONE);
-    }
-    dcode->buf[dcode25->character++] = c + '0';
+    unsigned char *buf;
+    if(dcode25->character >= 4)
+        buf = dcode->buf;
+    else
+        buf = dcode25->buf;
+    buf[dcode25->character++] = c + '0';
 
     c = i25_decode10(dcode, 0);
-    dprintf(2, " c=%x", c);
+    dbprintf(2, " c=%x", c);
     if(c > 9) {
-        dprintf(2, " [aborted]\n");
-        dcode->lock = 0;
-        dcode25->character = -1;
-        return(ZBAR_NONE);
+        dbprintf(2, " [aborted]\n");
+        goto reset;
     }
     else
-        dprintf(2, "\n");
+        dbprintf(2, "\n");
 
-    dcode->buf[dcode25->character++] = c + '0';
+    buf[dcode25->character++] = c + '0';
     dcode25->element = 10;
     return((dcode25->character == 2) ? ZBAR_PARTIAL : ZBAR_NONE);
+
+reset:
+    if(dcode25->character >= 4)
+        release_lock(dcode, ZBAR_I25);
+    dcode25->character = -1;
+    return(ZBAR_NONE);
 }
diff -r 563557a923d0 zbar/decoder/i25.h
--- a/zbar/decoder/i25.h	Tue Oct 27 11:25:59 2009 -0400
+++ b/zbar/decoder/i25.h	Fri Feb 22 08:54:29 2013 -0300
@@ -30,6 +30,7 @@
     int character : 12;         /* character position in symbol */
     unsigned s10;               /* current character width */
     unsigned width;             /* last character width */
+    unsigned char buf[4];       /* initial scan buffer */
 
     unsigned config;
     int configs[NUM_CFGS];      /* int valued configurations */
diff -r 563557a923d0 zbar/decoder/pdf417.c
--- a/zbar/decoder/pdf417.c	Tue Oct 27 11:25:59 2009 -0400
+++ b/zbar/decoder/pdf417.c	Fri Feb 22 08:54:29 2013 -0300
@@ -1,5 +1,5 @@
 /*------------------------------------------------------------------------
- *  Copyright 2008-2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *  Copyright 2008-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
  *
  *  This file is part of the ZBar Bar Code Reader.
  *
@@ -24,14 +24,14 @@
 #include <config.h>
 
 #include <zbar.h>
-#include "decoder.h"
-
-#include "pdf417_hash.h"
 
 #ifdef DEBUG_PDF417
 # define DEBUG_LEVEL (DEBUG_PDF417)
 #endif
 #include "debug.h"
+#include "decoder.h"
+
+#include "pdf417_hash.h"
 
 #define PDF417_STOP 0xbff
 
@@ -41,7 +41,7 @@
      * from similar edge measurements
      */
     unsigned s = dcode->pdf417.s8;
-    dprintf(2, " s=%d ", s);
+    dbprintf(2, " s=%d ", s);
     if(s < 8)
         return(-1);
 
@@ -55,19 +55,19 @@
         else
             e = decode_e(get_width(dcode, 7 - i) +
                          get_width(dcode, 6 - i), s, 17);
-        dprintf(4, "%x", e);
+        dbprintf(4, "%x", e);
         if(e < 0 || e > 8)
             return(-1);
         sig = (sig << 3) ^ e;
     }
-    dprintf(2, " sig=%06lx", sig);
+    dbprintf(2, " sig=%06lx", sig);
 
     /* determine cluster number */
     int clst = ((sig & 7) - ((sig >> 3) & 7) +
                 ((sig >> 12) & 7) - ((sig >> 15) & 7));
     if(clst < 0)
         clst += 9;
-    dprintf(2, " k=%d", clst);
+    dbprintf(2, " k=%d", clst);
     zassert(clst >= 0 && clst < 9, -1, "dir=%x sig=%lx k=%x %s\n",
             dcode->pdf417.direction, sig, clst,
             _zbar_decoder_buf_dump(dcode->buf, dcode->pdf417.character));
@@ -89,8 +89,8 @@
             _zbar_decoder_buf_dump(dcode->buf, dcode->pdf417.character));
 
     unsigned short c = (g[0] + g[1] + g[2]) & PDF417_HASH_MASK;
-    dprintf(2, " g0=%x g1=%x g2=%x c=%03d(%d)",
-            g[0], g[1], g[2], c & 0x3ff, c >> 10);
+    dbprintf(2, " g0=%x g1=%x g2=%x c=%03d(%d)",
+             g[0], g[1], g[2], c & 0x3ff, c >> 10);
     return(c);
 }
 
@@ -142,18 +142,18 @@
         ei = decode_e(get_width(dcode, 8) + get_width(dcode, 9), s, 17);
     }
 
-    dprintf(2, "      pdf417[%c]: s=%d",
-            (get_color(dcode)) ? '<' : '>', s);
+    dbprintf(2, "      pdf417[%c]: s=%d",
+             (get_color(dcode)) ? '<' : '>', s);
 
     /* check quiet zone */
     if(ei >= 0 && ei < ex) {
-        dprintf(2, " [invalid quiet]\n");
+        dbprintf(2, " [invalid quiet]\n");
         return(0);
     }
 
     /* lock shared resources */
-    if(get_lock(dcode, ZBAR_PDF417)) {
-        dprintf(2, " [locked %d]\n", dcode->lock);
+    if(acquire_lock(dcode, ZBAR_PDF417)) {
+        dbprintf(2, " [locked %d]\n", dcode->lock);
         return(0);
     }
 
@@ -162,7 +162,7 @@
     dcode417->element = 0;
     dcode417->character = 0;
 
-    dprintf(2, " [valid start]\n");
+    dbprintf(2, " [valid start]\n");
     return(ZBAR_PARTIAL);
 }
 
@@ -176,7 +176,7 @@
 
     if(dcode417->character < 0) {
         pdf417_decode_start(dcode);
-        dprintf(4, "\n");
+        dbprintf(4, "\n");
         return(0);
     }
 
@@ -185,12 +185,12 @@
         return(0);
     dcode417->element = 0;
 
-    dprintf(2, "      pdf417[%c%02d]:",
-            (dcode417->direction) ? '<' : '>', dcode417->character);
+    dbprintf(2, "      pdf417[%c%02d]:",
+             (dcode417->direction) ? '<' : '>', dcode417->character);
 
     if(get_color(dcode) != dcode417->direction) {
         int c = dcode417->character;
-        dcode->lock = 0;
+        release_lock(dcode, ZBAR_PDF417);
         dcode417->character = -1;
         zassert(get_color(dcode) == dcode417->direction, ZBAR_NONE,
                 "color=%x dir=%x char=%d elem=0 %s\n",
@@ -199,11 +199,9 @@
     }
 
     signed short c = pdf417_decode8(dcode);
-    if((c < 0) ||
-       ((dcode417->character >= BUFFER_MIN) &&
-        size_buf(dcode, dcode417->character + 1))) {
-        dprintf(1, (c < 0) ? " [aborted]\n" : " [overflow]\n");
-        dcode->lock = 0;
+    if(c < 0 || size_buf(dcode, dcode417->character + 1)) {
+        dbprintf(1, (c < 0) ? " [aborted]\n" : " [overflow]\n");
+        release_lock(dcode, ZBAR_PDF417);
         dcode417->character = -1;
         return(0);
     }
@@ -211,12 +209,14 @@
     /* FIXME TBD infer dimensions, save codewords */
 
     if(c == PDF417_STOP) {
-        dprintf(1, " [valid stop]");
+        dbprintf(1, " [valid stop]");
         /* FIXME check trailing bar and qz */
-        dcode->lock = 0;
+        dcode->direction = 1 - 2 * dcode417->direction;
+        dcode->modifiers = 0;
+        release_lock(dcode, ZBAR_PDF417);
         dcode417->character = -1;
     }
 
-    dprintf(2, "\n");
+    dbprintf(2, "\n");
     return(0);
 }
diff -r 563557a923d0 zbar/decoder/qr_finder.c
--- a/zbar/decoder/qr_finder.c	Tue Oct 27 11:25:59 2009 -0400
+++ b/zbar/decoder/qr_finder.c	Fri Feb 22 08:54:29 2013 -0300
@@ -1,13 +1,36 @@
+/*------------------------------------------------------------------------
+ *  Copyright 2009-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *
+ *  This file is part of the ZBar Bar Code Reader.
+ *
+ *  The ZBar Bar Code Reader is free software; you can redistribute it
+ *  and/or modify it under the terms of the GNU Lesser Public License as
+ *  published by the Free Software Foundation; either version 2.1 of
+ *  the License, or (at your option) any later version.
+ *
+ *  The ZBar Bar Code Reader is distributed in the hope that it will be
+ *  useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+ *  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser Public License
+ *  along with the ZBar Bar Code Reader; if not, write to the Free
+ *  Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ *  Boston, MA  02110-1301  USA
+ *
+ *  http://sourceforge.net/projects/zbar
+ *------------------------------------------------------------------------*/
+
 #include <config.h>
 #include <assert.h>
 
 #include <zbar.h>
-#include "decoder.h"
 
 #ifdef DEBUG_QR_FINDER
 # define DEBUG_LEVEL (DEBUG_QR_FINDER)
 #endif
 #include "debug.h"
+#include "decoder.h"
 
 /* at this point lengths are all decode unit offsets from the decode edge
  * NB owned by finder
@@ -20,42 +43,48 @@
 zbar_symbol_type_t _zbar_find_qr (zbar_decoder_t *dcode)
 {
     qr_finder_t *qrf = &dcode->qrf;
+    unsigned s, qz, w;
+    int ei;
 
     /* update latest finder pattern width */
     qrf->s5 -= get_width(dcode, 6);
     qrf->s5 += get_width(dcode, 1);
-    unsigned s = qrf->s5;
+    s = qrf->s5;
 
+    /*TODO: The 2005 standard allows reflectance-reversed codes (light on dark
+       instead of dark on light).
+      If we find finder patterns with the opposite polarity, we should invert
+       the final binarized image and use them to search for QR codes in that.*/
     if(get_color(dcode) != ZBAR_SPACE || s < 7)
         return(0);
 
-    dprintf(2, "    qrf: s=%d", s);
+    dbprintf(2, "    qrf: s=%d", s);
 
-    int ei = decode_e(pair_width(dcode, 1), s, 7);
-    dprintf(2, " %d", ei);
+    ei = decode_e(pair_width(dcode, 1), s, 7);
+    dbprintf(2, " %d", ei);
     if(ei)
         goto invalid;
 
     ei = decode_e(pair_width(dcode, 2), s, 7);
-    dprintf(2, "%d", ei);
+    dbprintf(2, "%d", ei);
     if(ei != 2)
         goto invalid;
 
     ei = decode_e(pair_width(dcode, 3), s, 7);
-    dprintf(2, "%d", ei);
+    dbprintf(2, "%d", ei);
     if(ei != 2)
         goto invalid;
 
     ei = decode_e(pair_width(dcode, 4), s, 7);
-    dprintf(2, "%d", ei);
+    dbprintf(2, "%d", ei);
     if(ei)
         goto invalid;
 
     /* valid QR finder symbol
      * mark positions needed by decoder
      */
-    unsigned qz = get_width(dcode, 0);
-    unsigned w = get_width(dcode, 1);
+    qz = get_width(dcode, 0);
+    w = get_width(dcode, 1);
     qrf->line.eoffs = qz + (w + 1) / 2;
     qrf->line.len = qz + w + get_width(dcode, 2);
     qrf->line.pos[0] = qrf->line.len + get_width(dcode, 3);
@@ -63,13 +92,15 @@
     w = get_width(dcode, 5);
     qrf->line.boffs = qrf->line.pos[0] + get_width(dcode, 4) + (w + 1) / 2;
 
-    dprintf(2, " boff=%d pos=%d len=%d eoff=%d [valid]\n",
-            qrf->line.boffs, qrf->line.pos[0], qrf->line.len,
-            qrf->line.eoffs);
+    dbprintf(2, " boff=%d pos=%d len=%d eoff=%d [valid]\n",
+             qrf->line.boffs, qrf->line.pos[0], qrf->line.len,
+             qrf->line.eoffs);
 
+    dcode->direction = 0;
+    dcode->buflen = 0;
     return(ZBAR_QRCODE);
 
 invalid:
-    dprintf(2, " [invalid]\n");
+    dbprintf(2, " [invalid]\n");
     return(0);
 }
diff -r 563557a923d0 zbar/error.c
--- a/zbar/error.c	Tue Oct 27 11:25:59 2009 -0400
+++ b/zbar/error.c	Fri Feb 22 08:54:29 2013 -0300
@@ -1,5 +1,5 @@
 /*------------------------------------------------------------------------
- *  Copyright 2007-2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *  Copyright 2007-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
  *
  *  This file is part of the ZBar Bar Code Reader.
  *
@@ -36,7 +36,7 @@
 };
 #define MOD_MAX (strlen(mod_str[ZBAR_MOD_IMAGE_SCANNER]))
 
-static const char const * err_str[] = {
+static const char * const err_str[] = {
     "no error",                 /* OK */
     "out of memory",            /* NOMEM */
     "internal library error",   /* INTERNAL */
@@ -99,32 +99,32 @@
 const char *_zbar_error_string (const void *container,
                                 int verbosity)
 {
+    static const char basefmt[] = "%s: zbar %s in %s():\n    %s: ";
     errinfo_t *err = (errinfo_t*)container;
+    const char *sev, *mod, *func, *type;
+    int len;
+
     assert(err->magic == ERRINFO_MAGIC);
 
-    const char *sev;
     if(err->sev >= SEV_FATAL && err->sev <= SEV_NOTE)
         sev = sev_str[err->sev + 2];
     else
         sev = sev_str[1];
 
-    const char *mod;
     if(err->module >= ZBAR_MOD_PROCESSOR &&
        err->module < ZBAR_MOD_UNKNOWN)
         mod = mod_str[err->module];
     else
         mod = mod_str[ZBAR_MOD_UNKNOWN];
 
-    const char *func = (err->func) ? err->func : "<unknown>";
+    func = (err->func) ? err->func : "<unknown>";
 
-    const char *type;
     if(err->type >= 0 && err->type < ZBAR_ERR_NUM)
         type = err_str[err->type];
     else
         type = err_str[ZBAR_ERR_NUM];
 
-    char basefmt[] = "%s: zbar %s in %s():\n    %s: ";
-    int len = SEV_MAX + MOD_MAX + ERR_MAX + strlen(func) + sizeof(basefmt);
+    len = SEV_MAX + MOD_MAX + ERR_MAX + strlen(func) + sizeof(basefmt);
     err->buf = realloc(err->buf, len);
     len = sprintf(err->buf, basefmt, sev, mod, func, type);
     if(len <= 0)
@@ -150,12 +150,14 @@
             return("<unknown>");
     }
 
+#ifdef HAVE_ERRNO_H
     if(err->type == ZBAR_ERR_SYSTEM) {
-        char sysfmt[] = ": %s (%d)\n";
+        static const char sysfmt[] = ": %s (%d)\n";
         const char *syserr = strerror(err->errnum);
         err->buf = realloc(err->buf, len + strlen(sysfmt) + strlen(syserr));
         len += sprintf(err->buf + len, sysfmt, syserr, err->errnum);
     }
+#endif
 #ifdef _WIN32
     else if(err->type == ZBAR_ERR_WINAPI) {
         char *syserr = NULL;
diff -r 563557a923d0 zbar/error.h
--- a/zbar/error.h	Tue Oct 27 11:25:59 2009 -0400
+++ b/zbar/error.h	Fri Feb 22 08:54:29 2013 -0300
@@ -1,5 +1,5 @@
 /*------------------------------------------------------------------------
- *  Copyright 2007-2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *  Copyright 2007-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
  *
  *  This file is part of the ZBar Bar Code Reader.
  *
@@ -30,7 +30,9 @@
 #include <stdlib.h>
 #include <stdio.h>
 #include <string.h>
-#include <errno.h>
+#ifdef HAVE_ERRNO_H
+# include <errno.h>
+#endif
 #include <assert.h>
 
 #include <zbar.h>
@@ -146,10 +148,12 @@
 {
     errinfo_t *err = (errinfo_t*)container;
     assert(err->magic == ERRINFO_MAGIC);
+#ifdef HAVE_ERRNO_H
     if(type == ZBAR_ERR_SYSTEM)
         err->errnum = errno;
+#endif
 #ifdef _WIN32
-    else if(type == ZBAR_ERR_WINAPI)
+    if(type == ZBAR_ERR_WINAPI)
         err->errnum = GetLastError();
 #endif
     err->sev = sev;
diff -r 563557a923d0 zbar/image.c
--- a/zbar/image.c	Tue Oct 27 11:25:59 2009 -0400
+++ b/zbar/image.c	Fri Feb 22 08:54:29 2013 -0300
@@ -1,5 +1,5 @@
 /*------------------------------------------------------------------------
- *  Copyright 2007-2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *  Copyright 2007-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
  *
  *  This file is part of the ZBar Bar Code Reader.
  *
@@ -74,6 +74,26 @@
     return(img->height);
 }
 
+void zbar_image_get_size (const zbar_image_t *img,
+                          unsigned *w,
+                          unsigned *h)
+{
+    if(w) *w = img->width;
+    if(h) *h = img->height;
+}
+
+void zbar_image_get_crop (const zbar_image_t *img,
+                          unsigned *x,
+                          unsigned *y,
+                          unsigned *w,
+                          unsigned *h)
+{
+    if(x) *x = img->crop_x;
+    if(y) *y = img->crop_y;
+    if(w) *w = img->crop_w;
+    if(h) *h = img->crop_h;
+}
+
 const void *zbar_image_get_data (const zbar_image_t *img)
 {
     return(img->data);
@@ -100,8 +120,28 @@
                           unsigned w,
                           unsigned h)
 {
-    img->width = w;
-    img->height = h;
+    img->crop_x = img->crop_y = 0;
+    img->width = img->crop_w = w;
+    img->height = img->crop_h = h;
+}
+
+void zbar_image_set_crop (zbar_image_t *img,
+                          unsigned x,
+                          unsigned y,
+                          unsigned w,
+                          unsigned h)
+{
+    unsigned img_w = img->width;
+    if(x > img_w) x = img_w;
+    if(x + w > img_w) w = img_w - x;
+    img->crop_x = x;
+    img->crop_w = w;
+
+    unsigned img_h = img->height;
+    if(y > img_h) y = img_h;
+    if(y + h > img_h) h = img_h - y;
+    img->crop_y = y;
+    img->crop_h = h;
 }
 
 inline void zbar_image_free_data (zbar_image_t *img)
@@ -109,9 +149,10 @@
     if(!img)
         return;
     if(img->src) {
+        zbar_image_t *newimg;
         /* replace video image w/new copy */
         assert(img->refcnt); /* FIXME needs lock */
-        zbar_image_t *newimg = zbar_image_create();
+        newimg = zbar_image_create();
         memcpy(newimg, img, sizeof(zbar_image_t));
         /* recycle video image */
         newimg->cleanup(newimg);
@@ -162,8 +203,7 @@
 {
     zbar_image_t *dst = zbar_image_create();
     dst->format = src->format;
-    dst->width = src->width;
-    dst->height = src->height;
+    _zbar_image_copy_size(dst, src);
     dst->datalen = src->datalen;
     dst->data = malloc(src->datalen);
     assert(dst->data);
@@ -180,11 +220,11 @@
 void zbar_image_set_symbols (zbar_image_t *img,
                              const zbar_symbol_set_t *syms)
 {
+    if(syms)
+        zbar_symbol_set_ref(syms, 1);
     if(img->syms)
         zbar_symbol_set_ref(img->syms, -1);
     img->syms = (zbar_symbol_set_t*)syms;
-    if(syms)
-        zbar_symbol_set_ref(img->syms, 1);
 }
 
 const zbar_symbol_t *zbar_image_first_symbol (const zbar_image_t *img)
@@ -202,29 +242,34 @@
                       const char *filebase)
 {
     int len = strlen(filebase) + 16;
-    char filename[len];
+    char *filename = malloc(len);
+    int n = 0, rc = 0;
+    FILE *f;
+    zimg_hdr_t hdr;
     strcpy(filename, filebase);
-    int n = 0;
-    if(*(char*)&img->format >= ' ')
+    if((img->format & 0xff) >= ' ')
         n = snprintf(filename, len, "%s.%.4s.zimg",
                      filebase, (char*)&img->format);
     else
         n = snprintf(filename, len, "%s.%08" PRIx32 ".zimg",
                      filebase, img->format);
-    assert(n < len);
-    filename[len] = '\0';
+    assert(n < len - 1);
+    filename[len - 1] = '\0';
 
     zprintf(1, "dumping %.4s(%08" PRIx32 ") image to %s\n",
             (char*)&img->format, img->format, filename);
 
-    FILE *f = fopen(filename, "w");
+    f = fopen(filename, "w");
     if(!f) {
-        int rc = errno;
+#ifdef HAVE_ERRNO_H
+        rc = errno;
         zprintf(1, "ERROR opening %s: %s\n", filename, strerror(rc));
-        return(rc);
+#else
+        rc = 1;
+#endif
+        goto error;
     }
 
-    zimg_hdr_t hdr;
     hdr.magic = 0x676d697a;
     hdr.format = img->format;
     hdr.width = img->width;
@@ -233,12 +278,21 @@
 
     if(fwrite(&hdr, sizeof(hdr), 1, f) != 1 ||
        fwrite(img->data, 1, img->datalen, f) != img->datalen) {
-        int rc = errno;
+#ifdef HAVE_ERRNO_H
+        rc = errno;
         zprintf(1, "ERROR writing %s: %s\n", filename, strerror(rc));
+#else
+        rc = 1;
+#endif
         fclose(f);
-        return(rc);
+        goto error;
     }
-    return(fclose(f));
+
+    rc = fclose(f);
+
+error:
+    free(filename);
+    return(rc);
 }
 
 #ifdef DEBUG_SVG
diff -r 563557a923d0 zbar/image.h
--- a/zbar/image.h	Tue Oct 27 11:25:59 2009 -0400
+++ b/zbar/image.h	Fri Feb 22 08:54:29 2013 -0300
@@ -1,5 +1,5 @@
 /*------------------------------------------------------------------------
- *  Copyright 2007-2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *  Copyright 2007-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
  *
  *  This file is part of the ZBar Bar Code Reader.
  *
@@ -35,10 +35,7 @@
 #include "symbol.h"
 #include "refcnt.h"
 
-/* adapted from v4l2 spec */
-#define fourcc(a, b, c, d)                      \
-    ((uint32_t)(a) | ((uint32_t)(b) << 8) |     \
-     ((uint32_t)(c) << 16) | ((uint32_t)(d) << 24))
+#define fourcc zbar_fourcc
 
 /* unpack size/location of component */
 #define RGB_SIZE(c)   ((c) >> 5)
@@ -65,6 +62,8 @@
     unsigned width, height;     /* image size */
     const void *data;           /* image sample data */
     unsigned long datalen;      /* allocated/mapped size of data */
+    unsigned crop_x, crop_y;    /* crop rectangle */
+    unsigned crop_w, crop_h;
     void *userdata;             /* user specified data associated w/image */
 
     /* cleanup handler */
@@ -129,4 +128,15 @@
     b->syms = tmp;
 }
 
+static inline void _zbar_image_copy_size (zbar_image_t *dst,
+                                          const zbar_image_t *src)
+{
+    dst->width = src->width;
+    dst->height = src->height;
+    dst->crop_x = src->crop_x;
+    dst->crop_y = src->crop_y;
+    dst->crop_w = src->crop_w;
+    dst->crop_h = src->crop_h;
+}
+
 #endif
diff -r 563557a923d0 zbar/img_scanner.c
--- a/zbar/img_scanner.c	Tue Oct 27 11:25:59 2009 -0400
+++ b/zbar/img_scanner.c	Fri Feb 22 08:54:29 2013 -0300
@@ -1,5 +1,5 @@
 /*------------------------------------------------------------------------
- *  Copyright 2007-2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *  Copyright 2007-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
  *
  *  This file is part of the ZBar Bar Code Reader.
  *
@@ -22,19 +22,20 @@
  *------------------------------------------------------------------------*/
 
 #include <config.h>
-#include <unistd.h>
+#ifdef HAVE_UNISTD_H
+# include <unistd.h>
+#endif
 #ifdef HAVE_INTTYPES_H
 # include <inttypes.h>
 #endif
 #include <stdlib.h>     /* malloc, free */
-#include <time.h>       /* clock_gettime */
-#include <sys/time.h>   /* gettimeofday */
 #include <string.h>     /* memcmp, memset, memcpy */
 #include <assert.h>
 
 #include <zbar.h>
 #include "error.h"
 #include "image.h"
+#include "timer.h"
 #ifdef ENABLE_QRCODE
 # include "qrcode.h"
 #endif
@@ -50,11 +51,6 @@
 
 /* FIXME cache setting configurability */
 
-/* number of times the same result must be detected
- * in "nearby" images before being reported
- */
-#define CACHE_CONSISTENCY    3 /* images */
-
 /* time interval for which two images are considered "nearby"
  */
 #define CACHE_PROXIMITY   1000 /* ms */
@@ -111,7 +107,9 @@
 
     /* configuration settings */
     unsigned config;            /* config flags */
+    unsigned ean_config;
     int configs[NUM_SCN_CFGS];  /* int valued configurations */
+    int sym_configs[1][NUM_SYMS]; /* per-symbology configurations */
 
 #ifndef NO_STATS
     int stat_syms_new;
@@ -136,6 +134,8 @@
             sym->next = NULL;
         }
         else {
+            int i;
+            recycle_bucket_t *bucket;
             /* recycle unreferenced symbol */
             if(!sym->data_alloc) {
                 sym->data = NULL;
@@ -149,7 +149,6 @@
                 _zbar_symbol_set_free(sym->syms);
                 sym->syms = NULL;
             }
-            int i;
             for(i = 0; i < RECYCLE_BUCKETS; i++)
                 if(sym->data_alloc < 1 << (i * 2))
                     break;
@@ -160,7 +159,7 @@
                 sym->data_alloc = 0;
                 i = 0;
             }
-            recycle_bucket_t *bucket = &iscn->recycle[i];
+            bucket = &iscn->recycle[i];
             /* FIXME cap bucket fill */
             bucket->nsyms++;
             sym->next = bucket->head;
@@ -196,18 +195,14 @@
 
     syms = img->syms;
     img->syms = NULL;
-    if(syms && recycle_syms(iscn, syms)) {
+    if(syms && recycle_syms(iscn, syms))
         STAT(img_syms_inuse);
-        syms = iscn->syms;
-    }
     else if(syms) {
         STAT(img_syms_recycle);
 
         /* select one set to resurrect, destroy the other */
-        if(iscn->syms) {
+        if(iscn->syms)
             _zbar_symbol_set_free(syms);
-            syms = iscn->syms;
-        }
         else
             iscn->syms = syms;
     }
@@ -219,12 +214,12 @@
                                int datalen)
 {
     /* recycle old or alloc new symbol */
+    zbar_symbol_t *sym = NULL;
     int i;
     for(i = 0; i < RECYCLE_BUCKETS - 1; i++)
         if(datalen <= 1 << (i * 2))
             break;
 
-    zbar_symbol_t *sym = NULL;
     for(; i > 0; i--)
         if((sym = iscn->recycle[i].head)) {
             STAT(sym_recycle[i]);
@@ -246,6 +241,7 @@
     sym->type = type;
     sym->quality = 1;
     sym->npts = 0;
+    sym->orient = ZBAR_ORIENT_UNKNOWN;
     sym->cache_count = 0;
     sym->time = iscn->time;
     assert(!sym->syms);
@@ -295,27 +291,33 @@
                               zbar_symbol_t *sym)
 {
     if(iscn->enable_cache) {
+        uint32_t age, near_thresh, far_thresh, dup;
         zbar_symbol_t *entry = cache_lookup(iscn, sym);
         if(!entry) {
             /* FIXME reuse sym */
             entry = _zbar_image_scanner_alloc_sym(iscn, sym->type,
                                                   sym->datalen + 1);
+            entry->configs = sym->configs;
+            entry->modifiers = sym->modifiers;
             memcpy(entry->data, sym->data, sym->datalen);
             entry->time = sym->time - CACHE_HYSTERESIS;
-            entry->cache_count = -CACHE_CONSISTENCY;
+            entry->cache_count = 0;
             /* add to cache */
             entry->next = iscn->cache;
             iscn->cache = entry;
         }
 
         /* consistency check and hysteresis */
-        uint32_t age = sym->time - entry->time;
+        age = sym->time - entry->time;
         entry->time = sym->time;
-        int near_thresh = (age < CACHE_PROXIMITY);
-        int far_thresh = (age >= CACHE_HYSTERESIS);
-        int dup = (entry->cache_count >= 0);
-        if((!dup && !near_thresh) || far_thresh)
-            entry->cache_count = -CACHE_CONSISTENCY;
+        near_thresh = (age < CACHE_PROXIMITY);
+        far_thresh = (age >= CACHE_HYSTERESIS);
+        dup = (entry->cache_count >= 0);
+        if((!dup && !near_thresh) || far_thresh) {
+            int type = sym->type;
+            int h = _zbar_get_symbol_hash(type);
+            entry->cache_count = -iscn->sym_configs[0][h];
+        }
         else if(dup || near_thresh)
             entry->cache_count++;
 
@@ -328,9 +330,10 @@
 void _zbar_image_scanner_add_sym(zbar_image_scanner_t *iscn,
                                  zbar_symbol_t *sym)
 {
+    zbar_symbol_set_t *syms;
     cache_sym(iscn, sym);
 
-    zbar_symbol_set_t *syms = iscn->syms;
+    syms = iscn->syms;
     if(sym->cache_count || !syms->tail) {
         sym->next = syms->head;
         syms->head = sym;
@@ -358,10 +361,12 @@
 
 static inline void qr_handler (zbar_image_scanner_t *iscn)
 {
+    unsigned u;
+    int vert;
     qr_finder_line *line = _zbar_decoder_get_qr_finder_line(iscn->dcode);
     assert(line);
-    unsigned u = zbar_scanner_get_edge(iscn->scn, line->pos[0],
-                                       QR_FINDER_SUBPREC);
+    u = zbar_scanner_get_edge(iscn->scn, line->pos[0],
+                              QR_FINDER_SUBPREC);
     line->boffs = u - zbar_scanner_get_edge(iscn->scn, line->boffs,
                                             QR_FINDER_SUBPREC);
     line->len = zbar_scanner_get_edge(iscn->scn, line->len,
@@ -372,12 +377,12 @@
 
     u = QR_FIXED(iscn->umin, 0) + iscn->du * u;
     if(iscn->du < 0) {
-        u -= line->len;
         int tmp = line->boffs;
         line->boffs = line->eoffs;
         line->eoffs = tmp;
+        u -= line->len;
     }
-    int vert = !iscn->dx;
+    vert = !iscn->dx;
     line->pos[vert] = u;
     line->pos[!vert] = QR_FIXED(iscn->v, 1);
 
@@ -389,10 +394,10 @@
 {
     zbar_image_scanner_t *iscn = zbar_decoder_get_userdata(dcode);
     zbar_symbol_type_t type = zbar_decoder_get_type(dcode);
-    /* FIXME assert(type == ZBAR_PARTIAL) */
-    /* FIXME debug flag to save/display all PARTIALs */
-    if(type <= ZBAR_PARTIAL)
-        return;
+    int x = 0, y = 0, dir;
+    const char *data;
+    unsigned datalen;
+    zbar_symbol_t *sym;
 
 #ifdef ENABLE_QRCODE
     if(type == ZBAR_QRCODE) {
@@ -403,10 +408,6 @@
     assert(type != ZBAR_QRCODE);
 #endif
 
-    const char *data = zbar_decoder_get_data(dcode);
-    unsigned datalen = zbar_decoder_get_data_length(dcode);
-
-    int x = 0, y = 0;
     if(TEST_CFG(iscn, ZBAR_CFG_POSITION)) {
         /* tmp position fixup */
         int w = zbar_scanner_get_width(iscn->scn);
@@ -421,13 +422,23 @@
         }
     }
 
+    /* FIXME debug flag to save/display all PARTIALs */
+    if(type <= ZBAR_PARTIAL) {
+        zprintf(256, "partial symbol @(%d,%d)\n", x, y);
+        return;
+    }
+
+    data = zbar_decoder_get_data(dcode);
+    datalen = zbar_decoder_get_data_length(dcode);
+
     /* FIXME need better symbol matching */
-    zbar_symbol_t *sym;
     for(sym = iscn->syms->head; sym; sym = sym->next)
         if(sym->type == type &&
            sym->datalen == datalen &&
            !memcmp(sym->data, data, datalen)) {
             sym->quality++;
+            zprintf(224, "dup symbol @(%d,%d): dup %s: %.20s\n",
+                    x, y, zbar_get_symbol_name(type), data);
             if(TEST_CFG(iscn, ZBAR_CFG_POSITION))
                 /* add new point to existing set */
                 /* FIXME should be polygon */
@@ -436,12 +447,21 @@
         }
 
     sym = _zbar_image_scanner_alloc_sym(iscn, type, datalen + 1);
+    sym->configs = zbar_decoder_get_configs(dcode, type);
+    sym->modifiers = zbar_decoder_get_modifiers(dcode);
     /* FIXME grab decoder buffer */
     memcpy(sym->data, data, datalen + 1);
 
     /* initialize first point */
-    if(TEST_CFG(iscn, ZBAR_CFG_POSITION))
+    if(TEST_CFG(iscn, ZBAR_CFG_POSITION)) {
+        zprintf(192, "new symbol @(%d,%d): %s: %.20s\n",
+                x, y, zbar_get_symbol_name(type), data);
         sym_add_point(sym, x, y);
+    }
+
+    dir = zbar_decoder_get_direction(dcode);
+    if(dir)
+        sym->orient = (iscn->dy != 0) + ((iscn->du ^ dir) & 2);
 
     _zbar_image_scanner_add_sym(iscn, sym);
 }
@@ -468,19 +488,26 @@
     CFG(iscn, ZBAR_CFG_X_DENSITY) = 1;
     CFG(iscn, ZBAR_CFG_Y_DENSITY) = 1;
     zbar_image_scanner_set_config(iscn, 0, ZBAR_CFG_POSITION, 1);
+    zbar_image_scanner_set_config(iscn, 0, ZBAR_CFG_UNCERTAINTY, 2);
+    zbar_image_scanner_set_config(iscn, ZBAR_QRCODE, ZBAR_CFG_UNCERTAINTY, 0);
+    zbar_image_scanner_set_config(iscn, ZBAR_CODE128, ZBAR_CFG_UNCERTAINTY, 0);
+    zbar_image_scanner_set_config(iscn, ZBAR_CODE93, ZBAR_CFG_UNCERTAINTY, 0);
+    zbar_image_scanner_set_config(iscn, ZBAR_CODE39, ZBAR_CFG_UNCERTAINTY, 0);
+    zbar_image_scanner_set_config(iscn, ZBAR_CODABAR, ZBAR_CFG_UNCERTAINTY, 1);
+    zbar_image_scanner_set_config(iscn, ZBAR_COMPOSITE, ZBAR_CFG_UNCERTAINTY, 0);
     return(iscn);
 }
 
 #ifndef NO_STATS
 static inline void dump_stats (const zbar_image_scanner_t *iscn)
 {
+    int i;
     zprintf(1, "symbol sets allocated   = %-4d\n", iscn->stat_syms_new);
     zprintf(1, "    scanner syms in use = %-4d\trecycled  = %-4d\n",
             iscn->stat_iscn_syms_inuse, iscn->stat_iscn_syms_recycle);
     zprintf(1, "    image syms in use   = %-4d\trecycled  = %-4d\n",
             iscn->stat_img_syms_inuse, iscn->stat_img_syms_recycle);
     zprintf(1, "symbols allocated       = %-4d\n", iscn->stat_sym_new);
-    int i;
     for(i = 0; i < RECYCLE_BUCKETS; i++)
         zprintf(1, "     recycled[%d]        = %-4d\n",
                 i, iscn->stat_sym_recycle[i]);
@@ -489,6 +516,7 @@
 
 void zbar_image_scanner_destroy (zbar_image_scanner_t *iscn)
 {
+    int i;
     dump_stats(iscn);
     if(iscn->syms) {
         if(iscn->syms->refcnt)
@@ -503,7 +531,6 @@
     if(iscn->dcode)
         zbar_decoder_destroy(iscn->dcode);
     iscn->dcode = NULL;
-    int i;
     for(i = 0; i < RECYCLE_BUCKETS; i++) {
         zbar_symbol_t *sym, *next;
         for(sym = iscn->recycle[i].head; sym; sym = next) {
@@ -536,14 +563,34 @@
                                    zbar_config_t cfg,
                                    int val)
 {
-    if(cfg < ZBAR_CFG_POSITION)
+    if((sym == 0 || sym == ZBAR_COMPOSITE) && cfg == ZBAR_CFG_ENABLE) {
+        iscn->ean_config = !!val;
+        if(sym)
+            return(0);
+    }
+
+    if(cfg < ZBAR_CFG_UNCERTAINTY)
         return(zbar_decoder_set_config(iscn->dcode, sym, cfg, val));
 
+    if(cfg < ZBAR_CFG_POSITION) {
+        int c, i;
+        if(cfg > ZBAR_CFG_UNCERTAINTY)
+            return(1);
+        c = cfg - ZBAR_CFG_UNCERTAINTY;
+        if(sym > ZBAR_PARTIAL) {
+            i = _zbar_get_symbol_hash(sym);
+            iscn->sym_configs[c][i] = val;
+        }
+        else
+            for(i = 0; i < NUM_SYMS; i++)
+                iscn->sym_configs[c][i] = val;
+        return(0);
+    }
+
     if(sym > ZBAR_PARTIAL)
         return(1);
 
     if(cfg >= ZBAR_CFG_X_DENSITY && cfg <= ZBAR_CFG_Y_DENSITY) {
-
         CFG(iscn, cfg) = val;
         return(0);
     }
@@ -591,30 +638,28 @@
 #define movedelta(dx, dy) do {                  \
         x += (dx);                              \
         y += (dy);                              \
-        p += (dx) + ((intptr_t)(dy) * w);       \
+        p += (dx) + ((uintptr_t)(dy) * w);       \
     } while(0);
 
 int zbar_scan_image (zbar_image_scanner_t *iscn,
                      zbar_image_t *img)
 {
+    zbar_symbol_set_t *syms;
+    const uint8_t *data;
+    zbar_scanner_t *scn = iscn->scn;
+    unsigned w, h, cx1, cy1;
+    int density;
+
     /* timestamp image
      * FIXME prefer video timestamp
      */
-#if _POSIX_TIMERS > 0
-    struct timespec abstime;
-    clock_gettime(CLOCK_REALTIME, &abstime);
-    iscn->time = (abstime.tv_sec * 1000) + ((abstime.tv_nsec / 500000) + 1) / 2;
-#else
-    struct timeval abstime;
-    gettimeofday(&abstime, NULL);
-    iscn->time = (abstime.tv_sec * 1000) + ((abstime.tv_usec / 500) + 1) / 2;
-#endif
+    iscn->time = _zbar_timer_now();
 
 #ifdef ENABLE_QRCODE
     _zbar_qr_reset(iscn->qr);
 #endif
 
-    /* get grayscale image, convert if necessary */
+    /* image must be in grayscale format */
     if(img->format != fourcc('Y','8','0','0') &&
        img->format != fourcc('G','R','E','Y'))
         return(-1);
@@ -622,7 +667,7 @@
 
     /* recycle previous scanner and image results */
     zbar_image_scanner_recycle_image(iscn, img);
-    zbar_symbol_set_t *syms = iscn->syms;
+    syms = iscn->syms;
     if(!syms) {
         syms = iscn->syms = _zbar_symbol_set_create();
         STAT(syms_new);
@@ -632,37 +677,43 @@
         zbar_symbol_set_ref(syms, 2);
     img->syms = syms;
 
-    unsigned w = img->width;
-    unsigned h = img->height;
-    const uint8_t *data = img->data;
+    w = img->width;
+    h = img->height;
+    cx1 = img->crop_x + img->crop_w;
+    assert(cx1 <= w);
+    cy1 = img->crop_y + img->crop_h;
+    assert(cy1 <= h);
+    data = img->data;
 
     zbar_image_write_png(img, "debug.png");
     svg_open("debug.svg", 0, 0, w, h);
     svg_image("debug.png", w, h);
 
-    zbar_scanner_t *scn = iscn->scn;
+    zbar_scanner_new_scan(scn);
 
-    int density = CFG(iscn, ZBAR_CFG_Y_DENSITY);
+    density = CFG(iscn, ZBAR_CFG_Y_DENSITY);
     if(density > 0) {
-        svg_group_start("scanner", 0, 1, 1, 0, 0);
         const uint8_t *p = data;
         int x = 0, y = 0;
+
+        int border = (((img->crop_h - 1) % density) + 1) / 2;
+        if(border > img->crop_h / 2)
+            border = img->crop_h / 2;
+        border += img->crop_y;
+        assert(border <= h);
+        svg_group_start("scanner", 0, 1, 1, 0, 0);
         iscn->dy = 0;
 
-        int border = (((h - 1) % density) + 1) / 2;
-        if(border > h / 2)
-            border = h / 2;
-        movedelta(0, border);
+        movedelta(img->crop_x, border);
         iscn->v = y;
 
-        zbar_scanner_new_scan(scn);
-
-        while(y < h) {
+        while(y < cy1) {
+            int cx0 = img->crop_x;;
             zprintf(128, "img_x+: %04d,%04d @%p\n", x, y, p);
             svg_path_start("vedge", 1. / 32, 0, y + 0.5);
             iscn->dx = iscn->du = 1;
-            iscn->umin = 0;
-            while(x < w) {
+            iscn->umin = cx0;
+            while(x < cx1) {
                 uint8_t d = *p;
                 movedelta(1, 0);
                 zbar_scan_y(scn, d);
@@ -673,14 +724,14 @@
 
             movedelta(-1, density);
             iscn->v = y;
-            if(y >= h)
+            if(y >= cy1)
                 break;
 
             zprintf(128, "img_x-: %04d,%04d @%p\n", x, y, p);
             svg_path_start("vedge", -1. / 32, w, y + 0.5);
             iscn->dx = iscn->du = -1;
-            iscn->umin = w;
-            while(x >= 0) {
+            iscn->umin = cx1;
+            while(x >= cx0) {
                 uint8_t d = *p;
                 movedelta(-1, 0);
                 zbar_scan_y(scn, d);
@@ -698,22 +749,25 @@
 
     density = CFG(iscn, ZBAR_CFG_X_DENSITY);
     if(density > 0) {
-        svg_group_start("scanner", 90, 1, -1, 0, 0);
         const uint8_t *p = data;
         int x = 0, y = 0;
 
-        int border = (((w - 1) % density) + 1) / 2;
-        if(border > w / 2)
-            border = w / 2;
-        movedelta(border, 0);
+        int border = (((img->crop_w - 1) % density) + 1) / 2;
+        if(border > img->crop_w / 2)
+            border = img->crop_w / 2;
+        border += img->crop_x;
+        assert(border <= w);
+        svg_group_start("scanner", 90, 1, -1, 0, 0);
+        movedelta(border, img->crop_y);
         iscn->v = x;
 
-        while(x < w) {
+        while(x < cx1) {
+            int cy0 = img->crop_y;
             zprintf(128, "img_y+: %04d,%04d @%p\n", x, y, p);
             svg_path_start("vedge", 1. / 32, 0, x + 0.5);
             iscn->dy = iscn->du = 1;
-            iscn->umin = 0;
-            while(y < h) {
+            iscn->umin = cy0;
+            while(y < cy1) {
                 uint8_t d = *p;
                 movedelta(0, 1);
                 zbar_scan_y(scn, d);
@@ -724,14 +778,14 @@
 
             movedelta(density, -1);
             iscn->v = x;
-            if(x >= w)
+            if(x >= cx1)
                 break;
 
             zprintf(128, "img_y-: %04d,%04d @%p\n", x, y, p);
             svg_path_start("vedge", -1. / 32, h, x + 0.5);
             iscn->dy = iscn->du = -1;
-            iscn->umin = h;
-            while(y >= 0) {
+            iscn->umin = cy1;
+            while(y >= cy0) {
                 uint8_t d = *p;
                 movedelta(0, -1);
                 zbar_scan_y(scn, d);
@@ -753,20 +807,82 @@
 #endif
 
     /* FIXME tmp hack to filter bad EAN results */
-    if(syms->nsyms && !iscn->enable_cache &&
-       (density == 1 || CFG(iscn, ZBAR_CFG_Y_DENSITY) == 1)) {
-        zbar_symbol_t **symp = &syms->head, *sym;
-        while((sym = *symp)) {
-            if(sym->type < ZBAR_I25 && sym->type > ZBAR_PARTIAL &&
-               sym->quality < 3) {
-                /* recycle */
-                *symp = sym->next;
-                syms->nsyms--;
-                sym->next = NULL;
-                _zbar_image_scanner_recycle_syms(iscn, sym);
+    /* FIXME tmp hack to merge simple case EAN add-ons */
+    char filter = (!iscn->enable_cache &&
+                   (density == 1 || CFG(iscn, ZBAR_CFG_Y_DENSITY) == 1));
+    int nean = 0, naddon = 0;
+    if(syms->nsyms) {
+        zbar_symbol_t **symp;
+        for(symp = &syms->head; *symp; ) {
+            zbar_symbol_t *sym = *symp;
+            if(sym->cache_count <= 0 &&
+               ((sym->type < ZBAR_COMPOSITE && sym->type > ZBAR_PARTIAL) ||
+                sym->type == ZBAR_DATABAR ||
+                sym->type == ZBAR_DATABAR_EXP ||
+                sym->type == ZBAR_CODABAR))
+            {
+	        if((sym->type == ZBAR_CODABAR || filter) && sym->quality < 4) {
+                    if(iscn->enable_cache) {
+                        /* revert cache update */
+                        zbar_symbol_t *entry = cache_lookup(iscn, sym);
+                        if(entry)
+                            entry->cache_count--;
+                        else
+                            assert(0);
+                    }
+
+                    /* recycle */
+                    *symp = sym->next;
+                    syms->nsyms--;
+                    sym->next = NULL;
+                    _zbar_image_scanner_recycle_syms(iscn, sym);
+                    continue;
+                }
+                else if(sym->type < ZBAR_COMPOSITE &&
+                        sym->type != ZBAR_ISBN10)
+                {
+                    if(sym->type > ZBAR_EAN5)
+                        nean++;
+                    else
+                        naddon++;
+                }
             }
-            else
-                symp = &sym->next;
+            symp = &sym->next;
+        }
+
+        if(nean == 1 && naddon == 1 && iscn->ean_config) {
+            /* create container symbol for composite result */
+            zbar_symbol_t *ean = NULL, *addon = NULL;
+            for(symp = &syms->head; *symp; ) {
+                zbar_symbol_t *sym = *symp;
+                if(sym->type < ZBAR_COMPOSITE && sym->type > ZBAR_PARTIAL) {
+                    /* move to composite */
+                    *symp = sym->next;
+                    syms->nsyms--;
+                    sym->next = NULL;
+                    if(sym->type <= ZBAR_EAN5)
+                        addon = sym;
+                    else
+                        ean = sym;
+                }
+                else
+                    symp = &sym->next;
+            }
+            assert(ean);
+            assert(addon);
+
+            int datalen = ean->datalen + addon->datalen + 1;
+            zbar_symbol_t *ean_sym =
+                _zbar_image_scanner_alloc_sym(iscn, ZBAR_COMPOSITE, datalen);
+            ean_sym->orient = ean->orient;
+            ean_sym->syms = _zbar_symbol_set_create();
+            memcpy(ean_sym->data, ean->data, ean->datalen);
+            memcpy(ean_sym->data + ean->datalen,
+                   addon->data, addon->datalen + 1);
+            ean_sym->syms->head = ean;
+            ean->next = addon;
+            ean_sym->syms->nsyms = 2;
+            _zbar_image_scanner_add_sym(iscn, ean_sym);
         }
     }
 
diff -r 563557a923d0 zbar/jpeg.c
--- a/zbar/jpeg.c	Tue Oct 27 11:25:59 2009 -0400
+++ b/zbar/jpeg.c	Fri Feb 22 08:54:29 2013 -0300
@@ -79,8 +79,15 @@
 void skip_input_data (j_decompress_ptr cinfo,
                       long num_bytes)
 {
-    cinfo->src->next_input_byte = NULL;
-    cinfo->src->bytes_in_buffer = 0;
+    if(num_bytes > 0) {
+        if (num_bytes < cinfo->src->bytes_in_buffer) {
+            cinfo->src->next_input_byte += num_bytes;
+            cinfo->src->bytes_in_buffer -= num_bytes;
+        }
+        else {
+            fill_input_buffer(cinfo);
+        }
+    }
 }
 
 void term_source (j_decompress_ptr cinfo)
@@ -195,10 +202,16 @@
     jpeg_start_decompress(cinfo);
 
     /* adjust dst image parameters to match(?) decompressor */
-    if(dst->width < cinfo->output_width)
+    if(dst->width < cinfo->output_width) {
         dst->width = cinfo->output_width;
-    if(dst->height < cinfo->output_height)
+        if(dst->crop_x + dst->crop_w > dst->width)
+            dst->crop_w = dst->width - dst->crop_x;
+    }
+    if(dst->height < cinfo->output_height) {
         dst->height = cinfo->output_height;
+        if(dst->crop_y + dst->crop_h > dst->height)
+            dst->crop_h = dst->height - dst->crop_y;
+    }
     unsigned long datalen = (cinfo->output_width *
                              cinfo->output_height *
                              cinfo->out_color_components);
diff -r 563557a923d0 zbar/processor.c
--- a/zbar/processor.c	Tue Oct 27 11:25:59 2009 -0400
+++ b/zbar/processor.c	Fri Feb 22 08:54:29 2013 -0300
@@ -1,5 +1,5 @@
 /*------------------------------------------------------------------------
- *  Copyright 2007-2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *  Copyright 2007-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
  *
  *  This file is part of the ZBar Bar Code Reader.
  *
@@ -95,11 +95,11 @@
             while(sym) {
                 zbar_symbol_type_t type = zbar_symbol_get_type(sym);
                 int count = zbar_symbol_get_count(sym);
-                zprintf(8, "%s%s: %s (%d pts) (q=%d) (%s)\n",
+                zprintf(8, "%s: %s (%d pts) (dir=%d) (q=%d) (%s)\n",
                         zbar_get_symbol_name(type),
-                        zbar_get_addon_name(type),
                         zbar_symbol_get_data(sym),
                         zbar_symbol_get_loc_size(sym),
+                        zbar_symbol_get_orientation(sym),
                         zbar_symbol_get_quality(sym),
                         (count < 0) ? "uncertain" :
                         (count > 0) ? "duplicate" : "new");
@@ -288,6 +288,10 @@
 {
     zbar_processor_init(proc, NULL, 0);
 
+    if(proc->syms) {
+        zbar_symbol_set_ref(proc->syms, -1);
+        proc->syms = NULL;
+    }
     if(proc->scanner) {
         zbar_image_scanner_destroy(proc->scanner);
         proc->scanner = NULL;
diff -r 563557a923d0 zbar/qrcode/qrdec.c
--- a/zbar/qrcode/qrdec.c	Tue Oct 27 11:25:59 2009 -0400
+++ b/zbar/qrcode/qrdec.c	Fri Feb 22 08:54:29 2013 -0300
@@ -3,6 +3,7 @@
    GNU Lesser General Public License as published by the Free Software
    Foundation; either version 2.1 of the License, or (at your option) any later
    version.*/
+#include <config.h>
 #include <stdlib.h>
 #include <limits.h>
 #include <string.h>
@@ -629,40 +630,46 @@
   int x0;
   int y0;
   int res;
+  int ires;
 };
 
 
 static void qr_aff_init(qr_aff *_aff,
  const qr_point _p0,const qr_point _p1,const qr_point _p2,int _res){
   int det;
+  int ires;
   int dx1;
   int dy1;
   int dx2;
   int dy2;
   /*det is ensured to be positive by our caller.*/
-  det=qr_point_ccw(_p0,_p1,_p2);
   dx1=_p1[0]-_p0[0];
   dx2=_p2[0]-_p0[0];
   dy1=_p1[1]-_p0[1];
   dy2=_p2[1]-_p0[1];
+  det=dx1*dy2-dy1*dx2;
+  ires=QR_MAXI((qr_ilog(abs(det))>>1)-2,0);
   _aff->fwd[0][0]=dx1;
   _aff->fwd[0][1]=dx2;
   _aff->fwd[1][0]=dy1;
   _aff->fwd[1][1]=dy2;
-  _aff->inv[0][0]=QR_DIVROUND(dy2<<_res,det);
-  _aff->inv[0][1]=QR_DIVROUND(-dx2<<_res,det);
-  _aff->inv[1][0]=QR_DIVROUND(-dy1<<_res,det);
-  _aff->inv[1][1]=QR_DIVROUND(dx1<<_res,det);
+  _aff->inv[0][0]=QR_DIVROUND(dy2<<_res,det>>ires);
+  _aff->inv[0][1]=QR_DIVROUND(-dx2<<_res,det>>ires);
+  _aff->inv[1][0]=QR_DIVROUND(-dy1<<_res,det>>ires);
+  _aff->inv[1][1]=QR_DIVROUND(dx1<<_res,det>>ires);
   _aff->x0=_p0[0];
   _aff->y0=_p0[1];
   _aff->res=_res;
+  _aff->ires=ires;
 }
 
 /*Map from the image (at subpel resolution) into the square domain.*/
 static void qr_aff_unproject(qr_point _q,const qr_aff *_aff,
  int _x,int _y){
-  _q[0]=_aff->inv[0][0]*(_x-_aff->x0)+_aff->inv[0][1]*(_y-_aff->y0);
-  _q[1]=_aff->inv[1][0]*(_x-_aff->x0)+_aff->inv[1][1]*(_y-_aff->y0);
+  _q[0]=_aff->inv[0][0]*(_x-_aff->x0)+_aff->inv[0][1]*(_y-_aff->y0)
+   +(1<<_aff->ires>>1)>>_aff->ires;
+  _q[1]=_aff->inv[1][0]*(_x-_aff->x0)+_aff->inv[1][1]*(_y-_aff->y0)
+   +(1<<_aff->ires>>1)>>_aff->ires;
 }
 
 /*Map from the square domain into the image (at subpel resolution).*/
@@ -1893,10 +1900,10 @@
   if(nc[0]){
     dx=QR_DIVROUND(c[0][0],nc[0]);
     dy=QR_DIVROUND(c[0][1],nc[0]);
-    /*But only if it doesn't make things worse.*/
+    /*But only if it doesn't make things too much worse.*/
     match=qr_alignment_pattern_fetch(p,bestx+dx,besty+dy,_img,_width,_height);
     dist=qr_hamming_dist(match,0x1F8D63F,best_dist+1);
-    if(dist<=best_dist){
+    if(dist<=best_dist+1){
       bestx+=dx;
       besty+=dy;
     }
@@ -2096,7 +2103,7 @@
             rlastfit=nr;
           }
         }
-        else nrempty=0;
+        nrempty=0;
       }
       else nrempty++;
       ru+=dru;
@@ -2217,11 +2224,11 @@
      _p[2][0],_p[2][1],_p[3][0],_p[3][1]);
     if(qr_alignment_pattern_search(p3,&cell,dim-7,dim-7,4,
      _img,_width,_height)>=0){
-      int c21;
-      int dx21;
-      int dy21;
-      int mask;
-      int w;
+      long long w;
+      long long mask;
+      int       c21;
+      int       dx21;
+      int       dy21;
       /*There's no real need to update the bounding box corner, and in fact we
          actively perform worse if we do.
         Clearly it was good enough for us to find this alignment pattern, so
@@ -2237,10 +2244,13 @@
       c21=_p[2][0]*_p[1][1]-_p[2][1]*_p[1][0];
       dx21=_p[2][0]-_p[1][0];
       dy21=_p[2][1]-_p[1][1];
-      w=(dim-7)*c21
-       +(dim-13)*(_p[0][0]*dy21-_p[0][1]*dx21)+6*(p3[0]*dy21-p3[1]*dx21);
+      w=QR_EXTMUL(dim-7,c21,
+       QR_EXTMUL(dim-13,_p[0][0]*dy21-_p[0][1]*dx21,
+       QR_EXTMUL(6,p3[0]*dy21-p3[1]*dx21,0)));
+      /*The projection failed: invalid geometry.*/
+      if(w==0)return -1;
       mask=QR_SIGNMASK(w);
-      w=abs(w);
+      w=w+mask^mask;
       brx=(int)QR_DIVROUND(QR_EXTMUL((dim-7)*_p[0][0],p3[0]*dy21,
        QR_EXTMUL((dim-13)*p3[0],c21-_p[0][1]*dx21,
        QR_EXTMUL(6*_p[0][0],c21-p3[1]*dx21,0)))+mask^mask,w);
@@ -2356,11 +2366,10 @@
     w0+=dwi;
   }
   ret=bch18_6_correct(&v);
-  /*TODO: I'd certainly hope the order the version bits is accessed in is
-     well-defined, but I seem to have images for two different codes with the
-     same version using two different orders?
-    Maybe the other one is a model 1 code?
-    Even if I parse the version here, I can't decode the rest of the code.
+  /*TODO: I seem to have an image with the version bits in a different order
+     (the transpose of the standard order).
+    Even if I change the order here so I can parse the version on this image,
+     I can't decode the rest of the code.
     If this is really needed, we should just re-order the bits.*/
 #if 0
   if(ret<0){
@@ -2478,16 +2487,9 @@
     y+=dy;
     w+=dw;
   }
-  /*For the 8th bit we have 3 samples... use the majority value.
-    TODO: The DL bit appears to be wrong as much as right? Guess it's not
-     really a third copy after all, but doesn't appear to be used for data.
-  i=((lo[0]>>7&1)+(lo[1]>>7&1)+(hi[1]>>7&1)>>1)<<7;
-  lo[0]=lo[0]&~0x80|i;
-  lo[1]=lo[1]&~0x80|i;
-  hi[1]&=~0x80;*/
-  /*For the remaining bits we have two samples... try them in all
-     combinations and pick the most popular valid code, breaking ties using
-     the number of bit errors.*/
+  /*For each group of bits we have two samples... try them in all combinations
+     and pick the most popular valid code, breaking ties using the number of
+     bit errors.*/
   imax=2<<(hi[0]!=hi[1]);
   di=1+(lo[0]==lo[1]);
   nfmt_info=0;
@@ -2577,8 +2579,8 @@
                                  qr_point *p,
                                  int n)
 {
+    int i;
     svg_path_start(cls, 1, 0, 0);
-    int i;
     for(i = 0; i < n; i++, p++)
         svg_path_moveto(SVG_ABS, p[0][0], p[0][1]);
     svg_path_end();
@@ -3184,6 +3186,7 @@
 static int qr_code_data_parse(qr_code_data *_qrdata,int _version,
  const unsigned char *_data,int _ndata){
   qr_pack_buf qpb;
+  unsigned    self_parity;
   int         centries;
   int         len_bits_idx;
   /*Entries are stored directly in the struct during parsing.
@@ -3191,6 +3194,7 @@
   _qrdata->entries=NULL;
   _qrdata->nentries=0;
   _qrdata->sa_size=0;
+  self_parity=0;
   centries=0;
   /*The versions are divided into 3 ranges that each use a different number of
      bits for length fields.*/
@@ -3209,9 +3213,10 @@
        centries*sizeof(*_qrdata->entries));
     }
     entry=_qrdata->entries+_qrdata->nentries++;
-    /*Set the mode to an invalid value until we allocate a buffer for it.
-      This ensures we don't try to free it on clean-up until then.*/
-    entry->mode=-1;
+    entry->mode=mode;
+    /*Set the buffer to NULL, because if parsing fails, we might try to free it
+       on clean-up.*/
+    entry->payload.data.buf=NULL;
     switch(mode){
       /*The number of bits used to encode the character count for each version
          range and each data mode.*/
@@ -3223,6 +3228,7 @@
       case QR_MODE_NUM:{
         unsigned char *buf;
         unsigned       bits;
+        unsigned       c;
         int            len;
         int            count;
         int            rem;
@@ -3233,35 +3239,47 @@
         count=len/3;
         rem=len%3;
         if(qr_pack_buf_avail(&qpb)<10*count+7*(rem>>1&1)+4*(rem&1))return -1;
-        entry->mode=mode;
         entry->payload.data.buf=buf=(unsigned char *)malloc(len*sizeof(*buf));
         entry->payload.data.len=len;
         /*Read groups of 3 digits encoded in 10 bits.*/
         while(count-->0){
           bits=qr_pack_buf_read(&qpb,10);
           if(bits>=1000)return -1;
-          *buf++=(unsigned char)('0'+bits/100);
+          c='0'+bits/100;
+          self_parity^=c;
+          *buf++=(unsigned char)c;
           bits%=100;
-          *buf++=(unsigned char)('0'+bits/10);
-          *buf++=(unsigned char)('0'+bits%10);
+          c='0'+bits/10;
+          self_parity^=c;
+          *buf++=(unsigned char)c;
+          c='0'+bits%10;
+          self_parity^=c;
+          *buf++=(unsigned char)c;
         }
         /*Read the last two digits encoded in 7 bits.*/
         if(rem>1){
           bits=qr_pack_buf_read(&qpb,7);
           if(bits>=100)return -1;
-          *buf++=(unsigned char)('0'+bits/10);
-          *buf++=(unsigned char)('0'+bits%10);
+          c='0'+bits/10;
+          self_parity^=c;
+          *buf++=(unsigned char)c;
+          c='0'+bits%10;
+          self_parity^=c;
+          *buf++=(unsigned char)c;
         }
         /*Or the last one digit encoded in 4 bits.*/
         else if(rem){
           bits=qr_pack_buf_read(&qpb,4);
           if(bits>=10)return -1;
-          *buf++=(unsigned char)('0'+bits);
+          c='0'+bits;
+          self_parity^=c;
+          *buf++=(unsigned char)c;
         }
       }break;
       case QR_MODE_ALNUM:{
         unsigned char *buf;
         unsigned       bits;
+        unsigned       c;
         int            len;
         int            count;
         int            rem;
@@ -3272,56 +3290,67 @@
         count=len>>1;
         rem=len&1;
         if(qr_pack_buf_avail(&qpb)<11*count+6*rem)return -1;
-        entry->mode=mode;
         entry->payload.data.buf=buf=(unsigned char *)malloc(len*sizeof(*buf));
         entry->payload.data.len=len;
         /*Read groups of two characters encoded in 11 bits.*/
         while(count-->0){
           bits=qr_pack_buf_read(&qpb,11);
           if(bits>=2025)return -1;
-          *buf++=QR_ALNUM_TABLE[bits/45];
-          *buf++=QR_ALNUM_TABLE[bits%45];
+          c=QR_ALNUM_TABLE[bits/45];
+          self_parity^=c;
+          *buf++=(unsigned char)c;
+          c=QR_ALNUM_TABLE[bits%45];
+          self_parity^=c;
+          *buf++=(unsigned char)c;
           len-=2;
         }
         /*Read the last character encoded in 6 bits.*/
         if(rem){
           bits=qr_pack_buf_read(&qpb,6);
           if(bits>=45)return -1;
-          *buf++=QR_ALNUM_TABLE[bits];
+          c=QR_ALNUM_TABLE[bits];
+          self_parity^=c;
+          *buf++=(unsigned char)c;
         }
       }break;
       /*Structured-append header.*/
       case QR_MODE_STRUCT:{
         int bits;
-        entry->mode=mode;
         bits=qr_pack_buf_read(&qpb,16);
         if(bits<0)return -1;
-        /*We also save a copy of the data in _qrdata for easy reference when
+        /*We save a copy of the data in _qrdata for easy reference when
            grouping structured-append codes.
-          If for some reason the code has multiple S-A headers, last one wins
-           (TODO: should we return an error instead?).*/
-        _qrdata->sa_index=entry->payload.sa.sa_index=
-         (unsigned char)(bits>>12&0xF);
-        _qrdata->sa_size=entry->payload.sa.sa_size=
-         (unsigned char)((bits>>8&0xF)+1);
-        _qrdata->sa_parity=entry->payload.sa.sa_parity=
-         (unsigned char)(bits&0xFF);
+          If for some reason the code has multiple S-A headers, first one wins,
+           since it is supposed to come before everything else (TODO: should we
+           return an error instead?).*/
+        if(_qrdata->sa_size==0){
+          _qrdata->sa_index=entry->payload.sa.sa_index=
+           (unsigned char)(bits>>12&0xF);
+          _qrdata->sa_size=entry->payload.sa.sa_size=
+           (unsigned char)((bits>>8&0xF)+1);
+          _qrdata->sa_parity=entry->payload.sa.sa_parity=
+           (unsigned char)(bits&0xFF);
+        }
       }break;
       case QR_MODE_BYTE:{
         unsigned char *buf;
+        unsigned       c;
         int            len;
         len=qr_pack_buf_read(&qpb,LEN_BITS[len_bits_idx][2]);
         if(len<0)return -1;
         /*Check to see if there are enough bits left now, so we don't have to
            in the decode loop.*/
         if(qr_pack_buf_avail(&qpb)<len<<3)return -1;
-        entry->mode=mode;
         entry->payload.data.buf=buf=(unsigned char *)malloc(len*sizeof(*buf));
         entry->payload.data.len=len;
-        while(len-->0)*buf++=(unsigned char)qr_pack_buf_read(&qpb,8);
+        while(len-->0){
+          c=qr_pack_buf_read(&qpb,8);
+          self_parity^=c;
+          *buf++=(unsigned char)c;
+        }
       }break;
       /*FNC1 first position marker.*/
-      case QR_MODE_FNC1_1ST:entry->mode=mode;break;
+      case QR_MODE_FNC1_1ST:break;
       /*Extended Channel Interpretation data.*/
       case QR_MODE_ECI:{
         unsigned val;
@@ -3349,7 +3378,6 @@
         }
         /*Invalid lead byte.*/
         else return -1;
-        entry->mode=mode;
         entry->payload.eci=val;
       }break;
       case QR_MODE_KANJI:{
@@ -3361,7 +3389,6 @@
         /*Check to see if there are enough bits left now, so we don't have to
            in the decode loop.*/
         if(qr_pack_buf_avail(&qpb)<13*len)return -1;
-        entry->mode=mode;
         entry->payload.data.buf=buf=(unsigned char *)malloc(2*len*sizeof(*buf));
         entry->payload.data.len=2*len;
         /*Decode 2-byte SJIS characters encoded in 13 bits.*/
@@ -3369,14 +3396,28 @@
           bits=qr_pack_buf_read(&qpb,13);
           bits=(bits/0xC0<<8|bits%0xC0)+0x8140;
           if(bits>=0xA000)bits+=0x4000;
-          /*Are values 0xXX7F, 0xXXFD...0xXXFF always invalid?
+          /*TODO: Are values 0xXX7F, 0xXXFD...0xXXFF always invalid?
             Should we reject them here?*/
+          self_parity^=bits;
           *buf++=(unsigned char)(bits>>8);
           *buf++=(unsigned char)(bits&0xFF);
         }
       }break;
       /*FNC1 second position marker.*/
-      case QR_MODE_FNC1_2ND:entry->mode=mode;break;
+      case QR_MODE_FNC1_2ND:{
+        int bits;
+        /*FNC1 in the 2nd position encodes an Application Indicator in one
+           byte, which is either a letter (A...Z or a...z) or a 2-digit number.
+          The letters are encoded with their ASCII value plus 100, the numbers
+           are encoded directly with their numeric value.
+          Values 100...164, 191...196, and 223...255 are invalid, so we reject
+           them here.*/
+        bits=qr_pack_buf_read(&qpb,8);
+        if(!(bits>=0&&bits<100||bits>=165&&bits<191||bits>=197&&bits<223)){
+          return -1;
+        }
+        entry->payload.ai=bits;
+      }break;
       /*Unknown mode number:*/
       default:{
         /*Unfortunately, because we have to understand the format of a mode to
@@ -3386,9 +3427,11 @@
       }break;
     }
   }
-  /*TODO: If there was a S-A header, we should compute the parity of this
-     code; how are non-data modes handled (ECI, FNC1)?*/
-  _qrdata->self_parity=0;
+  /*Store the parity of the data from this code, for S-A.
+    The final parity is the 8-bit XOR of all the decoded bytes of literal data.
+    We don't combine the 2-byte kanji codes into one byte in the loops above,
+     because we can just do it here instead.*/
+  _qrdata->self_parity=((self_parity>>8)^self_parity)&0xFF;
   /*Success.*/
   _qrdata->entries=(qr_code_data_entry *)realloc(_qrdata->entries,
    _qrdata->nentries*sizeof(*_qrdata->entries));
@@ -3565,7 +3608,17 @@
     int block_szi;
     int ndatai;
     block_szi=block_sz+(i>=nshort_blocks);
-    if(rs_correct(_gf,QR_M0,block_data+ncodewords,block_szi,npar,NULL,0)<0){
+    ret=rs_correct(_gf,QR_M0,block_data+ncodewords,block_szi,npar,NULL,0);
+    /*For version 1 symbols and version 2-L and 3-L symbols, we aren't allowed
+       to use all the parity bytes for correction.
+      They are instead used to improve detection.
+      Version 1-L reserves 3 parity bytes for detection.
+      Versions 1-M and 2-L reserve 2 parity bytes for detection.
+      Versions 1-Q, 1-H, and 3-L reserve 1 parity byte for detection.
+      We can ignore the version 3-L restriction because it has an odd number of
+       parity bytes, and we don't support erasure detection.*/
+    if(ret<0||_version==1&&ret>ecc_level+1<<1||
+     _version==2&&ecc_level==0&&ret>4){
       ret=-1;
       break;
     }
@@ -3627,6 +3680,7 @@
     qr_finder ul;
     qr_finder ur;
     qr_finder dl;
+    qr_point  bbox[4];
     int       res;
     int       ur_version;
     int       dl_version;
@@ -3663,10 +3717,11 @@
 #endif
     /*If we made it this far, upgrade the affine homography to a full
        homography.*/
-    if(qr_hom_fit(&hom,&ul,&ur,&dl,_qrdata->bbox,&aff,
+    if(qr_hom_fit(&hom,&ul,&ur,&dl,bbox,&aff,
      &_reader->isaac,_img,_width,_height)<0){
       continue;
     }
+    memcpy(_qrdata->bbox,bbox,sizeof(bbox));
     qr_hom_unproject(ul.o,&hom,ul.c->pos[0],ul.c->pos[1]);
     qr_hom_unproject(ur.o,&hom,ur.c->pos[0],ur.c->pos[1]);
     qr_hom_unproject(dl.o,&hom,dl.c->pos[0],dl.c->pos[1]);
@@ -3789,14 +3844,37 @@
       continue;
     }
     fmt_info=qr_finder_fmt_info_decode(&ul,&ur,&dl,&hom,_img,_width,_height);
-    if(fmt_info<0)continue;
-    if(qr_code_decode(_qrdata,&_reader->gf,ul.c->pos,ur.c->pos,dl.c->pos,
+    if(fmt_info<0||
+     qr_code_decode(_qrdata,&_reader->gf,ul.c->pos,ur.c->pos,dl.c->pos,
      ur_version,fmt_info,_img,_width,_height)<0){
-      /*TODO: Maybe somebody flipped the code?
-        We'd still get a valid version, and probably valid (but incorrect)
-         format info.
-        After we've come this far, it should be a simple matter to check.*/
-      continue;
+      /*The code may be flipped.
+        Try again, swapping the UR and DL centers.
+        We should get a valid version either way, so it's relatively cheap to
+         check this, as we've already filtered out a lot of invalid
+         configurations.*/
+      QR_SWAP2I(hom.inv[0][0],hom.inv[1][0]);
+      QR_SWAP2I(hom.inv[0][1],hom.inv[1][1]);
+      QR_SWAP2I(hom.fwd[0][0],hom.fwd[0][1]);
+      QR_SWAP2I(hom.fwd[1][0],hom.fwd[1][1]);
+      QR_SWAP2I(hom.fwd[2][0],hom.fwd[2][1]);
+      QR_SWAP2I(ul.o[0],ul.o[1]);
+      QR_SWAP2I(ul.size[0],ul.size[1]);
+      QR_SWAP2I(ur.o[0],ur.o[1]);
+      QR_SWAP2I(ur.size[0],ur.size[1]);
+      QR_SWAP2I(dl.o[0],dl.o[1]);
+      QR_SWAP2I(dl.size[0],dl.size[1]);
+#if defined(QR_DEBUG)
+      qr_finder_dump_hom_undistorted(&ul,&dl,&ur,&hom,_img,_width,_height);
+#endif
+      fmt_info=qr_finder_fmt_info_decode(&ul,&dl,&ur,&hom,_img,_width,_height);
+      if(fmt_info<0)continue;
+      QR_SWAP2I(bbox[1][0],bbox[2][0]);
+      QR_SWAP2I(bbox[1][1],bbox[2][1]);
+      memcpy(_qrdata->bbox,bbox,sizeof(bbox));
+      if(qr_code_decode(_qrdata,&_reader->gf,ul.c->pos,dl.c->pos,ur.c->pos,
+       ur_version,fmt_info,_img,_width,_height)<0){
+        continue;
+      }
     }
     return ur_version;
   }
@@ -3809,10 +3887,14 @@
   /*The number of centers should be small, so an O(n^3) exhaustive search of
      which ones go together should be reasonable.*/
   unsigned char *mark;
+  int            nfailures_max;
+  int            nfailures;
   int            i;
   int            j;
   int            k;
   mark=(unsigned char *)calloc(_ncenters,sizeof(*mark));
+  nfailures_max=QR_MAXI(8192,_width*_height>>9);
+  nfailures=0;
   for(i=0;i<_ncenters;i++){
     /*TODO: We might be able to accelerate this step significantly by
        considering the remaining finder centers in a more intelligent order,
@@ -3865,6 +3947,13 @@
           }
           /*Mark _all_ such centers used: codes cannot partially overlap.*/
           for(l=0;l<_ncenters;l++)if(mark[l]==2)mark[l]=1;
+          nfailures=0;
+        }
+        else if(++nfailures>nfailures_max){
+          /*Give up.
+            We're unlikely to find a valid code in all this clutter, and we
+             could spent quite a lot of time trying.*/
+          i=j=k=_ncenters;
         }
       }
     }
@@ -3913,7 +4002,7 @@
                      zbar_image_scanner_t *iscn,
                      zbar_image_t *img)
 {
-    int nqrdata = 0;
+    int nqrdata = 0, ncenters;
     qr_finder_edge_pt *edge_pts = NULL;
     qr_finder_center *centers = NULL;
 
@@ -3923,7 +4012,7 @@
 
     svg_group_start("finder", 0, 1. / (1 << QR_FINDER_SUBPREC), 0, 0, 0);
 
-    int ncenters = qr_finder_centers_locate(&centers, &edge_pts, reader, 0, 0);
+    ncenters = qr_finder_centers_locate(&centers, &edge_pts, reader, 0, 0);
 
     zprintf(14, "%dx%d finders, %d centers:\n",
             reader->finder_lines[0].nlines,
diff -r 563557a923d0 zbar/qrcode/qrdec.h
--- a/zbar/qrcode/qrdec.h	Tue Oct 27 11:25:59 2009 -0400
+++ b/zbar/qrcode/qrdec.h	Fri Feb 22 08:54:29 2013 -0300
@@ -85,7 +85,9 @@
   QR_ECI_ISO8859_16,
   /*ECI 000019 is reserved?*/
   /*Shift-JIS.*/
-  QR_ECI_SJIS=20
+  QR_ECI_SJIS=20,
+  /*UTF-8.*/
+  QR_ECI_UTF8=26
 }qr_eci_encoding;
 
 
@@ -101,6 +103,8 @@
     }data;
     /*Decoded "Extended Channel Interpretation" data.*/
     unsigned eci;
+    /*Decoded "Application Indicator" for FNC1 in 2nd position.*/
+    int      ai;
     /*Structured-append header data.*/
     struct{
       unsigned char sa_index;
diff -r 563557a923d0 zbar/qrcode/qrdectxt.c
--- a/zbar/qrcode/qrdectxt.c	Tue Oct 27 11:25:59 2009 -0400
+++ b/zbar/qrcode/qrdectxt.c	Fri Feb 22 08:54:29 2013 -0300
@@ -1,8 +1,9 @@
-/*Copyright (C) 2008-2009  Timothy B. Terriberry (tterribe@xiph.org)
+/*Copyright (C) 2008-2010  Timothy B. Terriberry (tterribe@xiph.org)
   You can redistribute this library and/or modify it under the terms of the
    GNU Lesser General Public License as published by the Free Software
    Foundation; either version 2.1 of the License, or (at your option) any later
    version.*/
+#include <config.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
@@ -11,6 +12,7 @@
 #include "qrdec.h"
 #include "util.h"
 #include "image.h"
+#include "decoder.h"
 #include "error.h"
 #include "img_scanner.h"
 
@@ -50,12 +52,10 @@
   const qr_code_data  *qrdata;
   int                  nqrdata;
   unsigned char       *mark;
-  char               **text;
   int                  ntext;
   int                  i;
   qrdata=_qrlist->qrdata;
   nqrdata=_qrlist->nqrdata;
-  text=(char **)malloc(nqrdata*sizeof(*text));
   mark=(unsigned char *)calloc(nqrdata,sizeof(*mark));
   ntext=0;
   /*This is the encoding the standard says is the default.*/
@@ -75,10 +75,16 @@
     size_t                    sa_ntext;
     size_t                    sa_ctext;
     int                       fnc1;
+    int                       fnc1_2ai;
+    int                       has_kanji;
     int                       eci;
     int                       err;
     int                       j;
     int                       k;
+    zbar_symbol_t *syms = NULL, **sym = &syms;
+    qr_point dir;
+    int horiz;
+
     /*Step 0: Collect the other QR codes belonging to this S-A group.*/
     if(qrdata[i].sa_size){
       unsigned sa_parity;
@@ -103,6 +109,8 @@
 
     sa_ctext=0;
     fnc1=0;
+    fnc1_2ai=0;
+    has_kanji=0;
     /*Step 1: Detect FNC1 markers and estimate the required buffer size.*/
     for(j=0;j<sa_size;j++)if(sa[j]>=0){
       qrdataj=qrdata+sa[j];
@@ -112,13 +120,20 @@
         shift=0;
         switch(entry->mode){
           /*FNC1 applies to the entire code and ignores subsequent markers.*/
-          case QR_MODE_FNC1_1ST:
-          case QR_MODE_FNC1_2ND:fnc1=1;break;
-          /*2 SJIS bytes will be at most 4 UTF-8 bytes.*/
-          case QR_MODE_KANJI:shift++;
+          case QR_MODE_FNC1_1ST:{
+            if(!fnc1)fnc1=MOD(ZBAR_MOD_GS1);
+          }break;
+          case QR_MODE_FNC1_2ND:{
+            if(!fnc1){
+              fnc1=MOD(ZBAR_MOD_AIM);
+              fnc1_2ai=entry->payload.ai;
+              sa_ctext+=2;
+            }
+          }break;
           /*We assume at most 4 UTF-8 bytes per input byte.
             I believe this is true for all the encodings we actually use.*/
-          case QR_MODE_BYTE:shift++;
+          case QR_MODE_KANJI:has_kanji=1;
+          case QR_MODE_BYTE:shift=2;
           default:{
             /*The remaining two modes are already valid UTF-8.*/
             if(QR_MODE_HAS_DATA(entry->mode)){
@@ -132,13 +147,24 @@
     /*Step 2: Convert the entries.*/
     sa_text=(char *)malloc((sa_ctext+1)*sizeof(*sa_text));
     sa_ntext=0;
+    /*Add the encoded Application Indicator for FNC1 in the second position.*/
+    if(fnc1==MOD(ZBAR_MOD_AIM)){
+      if(fnc1_2ai<100){
+        /*The Application Indicator is a 2-digit number.*/
+        sa_text[sa_ntext++]='0'+fnc1_2ai/10;
+        sa_text[sa_ntext++]='0'+fnc1_2ai%10;
+      }
+      /*The Application Indicator is a single letter.
+        We already checked that it lies in one of the ranges A...Z, a...z
+         when we decoded it.*/
+      else sa_text[sa_ntext++]=(char)(fnc1_2ai-100);
+    }
     eci=-1;
     enc_list[0]=sjis_cd;
     enc_list[1]=latin1_cd;
     enc_list[2]=utf8_cd;
     eci_cd=(iconv_t)-1;
     err=0;
-    zbar_symbol_t *syms = NULL, **sym = &syms;
     for(j = 0; j < sa_size && !err; j++, sym = &(*sym)->next) {
       *sym = _zbar_image_scanner_alloc_sym(iscn, ZBAR_QRCODE, 0);
       (*sym)->datalen = sa_ntext;
@@ -167,6 +193,14 @@
       sym_add_point(*sym, qrdataj->bbox[3][0], qrdataj->bbox[3][1]);
       sym_add_point(*sym, qrdataj->bbox[1][0], qrdataj->bbox[1][1]);
 
+      /* approx symbol "up" direction */
+      dir[0] = (qrdataj->bbox[0][0] - qrdataj->bbox[2][0] +
+                qrdataj->bbox[1][0] - qrdataj->bbox[3][0]);
+      dir[1] = (qrdataj->bbox[2][1] - qrdataj->bbox[0][1] +
+                qrdataj->bbox[3][1] - qrdataj->bbox[1][1]);
+      horiz = abs(dir[0]) > abs(dir[1]);
+      (*sym)->orient = horiz + 2 * (dir[1 - horiz] < 0);
+
       for(k=0;k<qrdataj->nentries&&!err;k++){
         size_t              inleft;
         size_t              outleft;
@@ -220,7 +254,8 @@
             Does such a thing occur?
             Is it allowed?
             It requires copying buffers around to handle correctly.*/
-          case QR_MODE_BYTE:{
+          case QR_MODE_BYTE:
+          case QR_MODE_KANJI:{
             in=(char *)entry->payload.data.buf;
             inleft=entry->payload.data.len;
             out=sa_text+sa_ntext;
@@ -228,8 +263,13 @@
             /*If we have no specified encoding, attempt to auto-detect it.*/
             if(eci<0){
               int ei;
-              /*First check for the UTF-8 BOM.*/
-              if(inleft>=3&&
+              /*If there was data encoded in kanji mode, assume it's SJIS.*/
+              if(has_kanji)enc_list_mtf(enc_list,sjis_cd);
+              /*Otherwise check for the UTF-8 BOM.
+                UTF-8 is rarely specified with ECI, and few decoders
+                 currently support doing so, so this is the best way for
+                 encoders to reliably indicate it.*/
+              else if(inleft>=3&&
                in[0]==(char)0xEF&&in[1]==(char)0xBB&&in[2]==(char)0xBF){
                 in+=3;
                 inleft-=3;
@@ -246,15 +286,17 @@
                 out=sa_text+sa_ntext;
                 outleft=sa_ctext-sa_ntext;
               }
-              /*If the text is 8-bit clean, prefer UTF-8 over SJIS, since SJIS
-                 will corrupt the backslashes used for DoCoMo formats.*/
+              /*If the text is 8-bit clean, prefer UTF-8 over SJIS, since
+                 SJIS will corrupt the backslashes used for DoCoMo formats.*/
               else if(text_is_ascii((unsigned char *)in,inleft)){
                 enc_list_mtf(enc_list,utf8_cd);
               }
               /*Try our list of encodings.*/
               for(ei=0;ei<3;ei++)if(enc_list[ei]!=(iconv_t)-1){
-                /*According to the standard, ISO/IEC 8859-1 (one hyphen) is
-                   supposed to be used, but reality is not always so.
+                /*According to the 2005 version of the standard,
+                   ISO/IEC 8859-1 (one hyphen) is supposed to be used, but
+                   reality is not always so (and in the 2000 version of the
+                   standard, it was JIS8/SJIS that was the default).
                   It's got an invalid range that is used often with SJIS
                    and UTF-8, though, which makes detection easier.
                   However, iconv() does not properly reject characters in
@@ -280,23 +322,16 @@
                 outleft=sa_ctext-sa_ntext;
               }
             }
-            /*We were actually given a character set; use it.*/
+            /*We were actually given a character set; use it.
+              The spec says that in this case, data should be treated as if it
+               came from the given character set even when encoded in kanji
+               mode.*/
             else{
               err=eci_cd==(iconv_t)-1||
                iconv(eci_cd,&in,&inleft,&out,&outleft)==(size_t)-1;
               if(!err)sa_ntext=out-sa_text;
             }
           }break;
-          /*Kanji mode always uses SJIS.*/
-          case QR_MODE_KANJI:{
-            in=(char *)entry->payload.data.buf;
-            inleft=entry->payload.data.len;
-            out=sa_text+sa_ntext;
-            outleft=sa_ctext-sa_ntext;
-            err=sjis_cd==(iconv_t)-1||
-             iconv(sjis_cd,&in,&inleft,&out,&outleft)==(size_t)-1;
-            if(!err)sa_ntext=out-sa_text;
-          }break;
           /*Check to see if a character set was specified.*/
           case QR_MODE_ECI:{
             const char *enc;
@@ -313,6 +348,7 @@
               else enc="CP437";
             }
             else if(cur_eci==QR_ECI_SJIS)enc="SJIS";
+            else if(cur_eci==QR_ECI_UTF8)enc="UTF-8";
             /*Don't know what this ECI code specifies, but not an encoding that
                we recognize.*/
             else continue;
@@ -331,26 +367,27 @@
     }
     if(eci_cd!=(iconv_t)-1)iconv_close(eci_cd);
     if(!err){
+      zbar_symbol_t *sa_sym;
       sa_text[sa_ntext++]='\0';
       if(sa_ctext+1>sa_ntext){
         sa_text=(char *)realloc(sa_text,sa_ntext*sizeof(*sa_text));
       }
 
-      zbar_symbol_t *sa_sym;
       if(sa_size == 1)
           sa_sym = syms;
       else {
+          /* cheap out w/axis aligned bbox for now */
+          int xmin = img->width, xmax = -2;
+          int ymin = img->height, ymax = -2;
+
           /* create "virtual" container symbol for composite result */
           sa_sym = _zbar_image_scanner_alloc_sym(iscn, ZBAR_QRCODE, 0);
           sa_sym->syms = _zbar_symbol_set_create();
           sa_sym->syms->head = syms;
 
-          /* cheap out w/axis aligned bbox for now */
-          int xmin = img->width, xmax = -2;
-          int ymin = img->height, ymax = -2;
-
           /* fixup data references */
           for(; syms; syms = syms->next) {
+              int next;
               _zbar_symbol_refcnt(syms, 1);
               if(syms->type == ZBAR_PARTIAL)
                   sa_sym->type = ZBAR_PARTIAL;
@@ -364,7 +401,7 @@
                       if(ymax <= u) ymax = u + 1;
                   }
               syms->data = sa_text + syms->datalen;
-              int next = (syms->next) ? syms->next->datalen : sa_ntext;
+              next = (syms->next) ? syms->next->datalen : sa_ntext;
               assert(next > syms->datalen);
               syms->datalen = next - syms->datalen - 1;
           }
@@ -378,6 +415,7 @@
       sa_sym->data = sa_text;
       sa_sym->data_alloc = sa_ntext;
       sa_sym->datalen = sa_ntext - 1;
+      sa_sym->modifiers = fnc1;
 
       _zbar_image_scanner_add_sym(iscn, sa_sym);
     }
diff -r 563557a923d0 zbar/qrcode/util.h
--- a/zbar/qrcode/util.h	Tue Oct 27 11:25:59 2009 -0400
+++ b/zbar/qrcode/util.h	Fri Feb 22 08:54:29 2013 -0300
@@ -17,6 +17,14 @@
 #define QR_DIVROUND(_x,_y)  (((_x)+QR_FLIPSIGNI(_y>>1,_x))/(_y))
 #define QR_CLAMPI(_a,_b,_c) (QR_MAXI(_a,QR_MINI(_b,_c)))
 #define QR_CLAMP255(_x)     ((unsigned char)((((_x)<0)-1)&((_x)|-((_x)>255))))
+#define QR_SWAP2I(_a,_b) \
+  do{ \
+    int t__; \
+    t__=(_a); \
+    (_a)=(_b); \
+    (_b)=t__; \
+  } \
+  while(0)
 /*Swaps two integers _a and _b if _a>_b.*/
 #define QR_SORT2I(_a,_b) \
   do{ \
diff -r 563557a923d0 zbar/refcnt.c
--- a/zbar/refcnt.c	Tue Oct 27 11:25:59 2009 -0400
+++ b/zbar/refcnt.c	Fri Feb 22 08:54:29 2013 -0300
@@ -23,7 +23,7 @@
 
 #include "refcnt.h"
 
-#ifdef HAVE_LIBPTHREAD
+#if !defined(_WIN32) && !defined(TARGET_OS_MAC) && defined(HAVE_LIBPTHREAD)
 
 pthread_once_t initialized = PTHREAD_ONCE_INIT;
 pthread_mutex_t _zbar_reflock;
diff -r 563557a923d0 zbar/refcnt.h
--- a/zbar/refcnt.h	Tue Oct 27 11:25:59 2009 -0400
+++ b/zbar/refcnt.h	Fri Feb 22 08:54:29 2013 -0300
@@ -1,5 +1,5 @@
 /*------------------------------------------------------------------------
- *  Copyright 2007-2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *  Copyright 2007-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
  *
  *  This file is part of the ZBar Bar Code Reader.
  *
@@ -29,7 +29,7 @@
 #if defined(_WIN32)
 # include <windows.h>
 
-typedef volatile LONG refcnt_t;  /* FIXME where did volatile come from? */
+typedef LONG refcnt_t;
 
 static inline int _zbar_refcnt (refcnt_t *cnt,
                                 int delta)
@@ -45,6 +45,18 @@
     return(rc);
 }
 
+#elif defined(TARGET_OS_MAC)
+# include <libkern/OSAtomic.h>
+
+typedef int32_t refcnt_t;
+
+static inline int _zbar_refcnt (refcnt_t *cnt,
+                                int delta)
+{
+    int rc = OSAtomicAdd32Barrier(delta, cnt);
+    assert(rc >= 0);
+    return(rc);
+}
 
 #elif defined(HAVE_LIBPTHREAD)
 # include <pthread.h>
diff -r 563557a923d0 zbar/scanner.c
--- a/zbar/scanner.c	Tue Oct 27 11:25:59 2009 -0400
+++ b/zbar/scanner.c	Fri Feb 22 08:54:29 2013 -0300
@@ -1,5 +1,5 @@
 /*------------------------------------------------------------------------
- *  Copyright 2007-2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *  Copyright 2007-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
  *
  *  This file is part of the ZBar Bar Code Reader.
  *
@@ -23,6 +23,7 @@
 
 #include <config.h>
 #include <stdlib.h>     /* malloc, free, abs */
+#include <stddef.h>
 #include <string.h>     /* memset */
 
 #include <zbar.h>
@@ -91,7 +92,7 @@
 
 zbar_symbol_type_t zbar_scanner_reset (zbar_scanner_t *scn)
 {
-    memset(&scn->x, 0, sizeof(zbar_scanner_t) + (void*)scn - (void*)&scn->x);
+    memset(&scn->x, 0, sizeof(zbar_scanner_t) - offsetof(zbar_scanner_t, x));
     scn->y1_thresh = scn->y1_min_thresh;
     if(scn->decoder)
         zbar_decoder_reset(scn->decoder);
@@ -125,19 +126,20 @@
 static inline unsigned calc_thresh (zbar_scanner_t *scn)
 {
     /* threshold 1st to improve noise rejection */
-    unsigned thresh = scn->y1_thresh;
+    unsigned dx, thresh = scn->y1_thresh;
+    unsigned long t;
     if((thresh <= scn->y1_min_thresh) || !scn->width) {
-        dprintf(1, " tmin=%d", scn->y1_min_thresh);
+        dbprintf(1, " tmin=%d", scn->y1_min_thresh);
         return(scn->y1_min_thresh);
     }
     /* slowly return threshold to min */
-    unsigned dx = (scn->x << ZBAR_FIXED) - scn->last_edge;
-    unsigned long t = thresh * dx;
+    dx = (scn->x << ZBAR_FIXED) - scn->last_edge;
+    t = thresh * dx;
     t /= scn->width;
     t /= ZBAR_SCANNER_THRESH_FADE;
-    dprintf(1, " thr=%d t=%ld x=%d last=%d.%d (%d)",
-            thresh, t, scn->x, scn->last_edge >> ZBAR_FIXED,
-            scn->last_edge & ((1 << ZBAR_FIXED) - 1), dx);
+    dbprintf(1, " thr=%d t=%ld x=%d last=%d.%d (%d)",
+             thresh, t, scn->x, scn->last_edge >> ZBAR_FIXED,
+             scn->last_edge & ((1 << ZBAR_FIXED) - 1), dx);
     if(thresh > t) {
         thresh -= t;
         if(thresh > scn->y1_min_thresh)
@@ -156,10 +158,10 @@
         scn->last_edge = scn->cur_edge;
 
     scn->width = scn->cur_edge - scn->last_edge;
-    dprintf(1, " sgn=%d cur=%d.%d w=%d (%s)\n",
-            scn->y1_sign, scn->cur_edge >> ZBAR_FIXED,
-            scn->cur_edge & ((1 << ZBAR_FIXED) - 1), scn->width,
-            ((y1 > 0) ? "SPACE" : "BAR"));
+    dbprintf(1, " sgn=%d cur=%d.%d w=%d (%s)\n",
+             scn->y1_sign, scn->cur_edge >> ZBAR_FIXED,
+             scn->cur_edge & ((1 << ZBAR_FIXED) - 1), scn->width,
+             ((y1 > 0) ? "SPACE" : "BAR"));
     scn->last_edge = scn->cur_edge;
 
 #if DEBUG_SVG > 1
@@ -174,14 +176,15 @@
 
 inline zbar_symbol_type_t zbar_scanner_flush (zbar_scanner_t *scn)
 {
+    unsigned x;
     if(!scn->y1_sign)
         return(ZBAR_NONE);
 
-    unsigned x = (scn->x << ZBAR_FIXED) + ROUND;
+    x = (scn->x << ZBAR_FIXED) + ROUND;
 
     if(scn->cur_edge != x || scn->y1_sign > 0) {
-        dprintf(1, "flush0:");
         zbar_symbol_type_t edge = process_edge(scn, -scn->y1_sign);
+        dbprintf(1, "flush0:");
         scn->cur_edge = x;
         scn->y1_sign = -scn->y1_sign;
         return(edge);
@@ -203,7 +206,7 @@
     }
 
     /* reset scanner and associated decoder */
-    memset(&scn->x, 0, sizeof(zbar_scanner_t) + (void*)scn - (void*)&scn->x);
+    memset(&scn->x, 0, sizeof(zbar_scanner_t) - offsetof(zbar_scanner_t, x));
     scn->y1_thresh = scn->y1_min_thresh;
     if(scn->decoder)
         zbar_decoder_new_scan(scn->decoder);
@@ -218,6 +221,8 @@
     register int x = scn->x;
     register int y0_1 = scn->y0[(x - 1) & 3];
     register int y0_0 = y0_1;
+    register int y0_2, y0_3, y1_1, y2_1, y2_2;
+    zbar_symbol_type_t edge;
     if(x) {
         /* update weighted moving average */
         y0_0 += ((int)((y - y0_1) * EWMA_WEIGHT)) >> ZBAR_FIXED;
@@ -225,10 +230,10 @@
     }
     else
         y0_0 = y0_1 = scn->y0[0] = scn->y0[1] = scn->y0[2] = scn->y0[3] = y;
-    register int y0_2 = scn->y0[(x - 2) & 3];
-    register int y0_3 = scn->y0[(x - 3) & 3];
+    y0_2 = scn->y0[(x - 2) & 3];
+    y0_3 = scn->y0[(x - 3) & 3];
     /* 1st differential @ x-1 */
-    register int y1_1 = y0_1 - y0_2;
+    y1_1 = y0_1 - y0_2;
     {
         register int y1_2 = y0_2 - y0_3;
         if((abs(y1_1) < abs(y1_2)) &&
@@ -237,13 +242,13 @@
     }
 
     /* 2nd differentials @ x-1 & x-2 */
-    register int y2_1 = y0_0 - (y0_1 * 2) + y0_2;
-    register int y2_2 = y0_1 - (y0_2 * 2) + y0_3;
+    y2_1 = y0_0 - (y0_1 * 2) + y0_2;
+    y2_2 = y0_1 - (y0_2 * 2) + y0_3;
 
-    dprintf(1, "scan: x=%d y=%d y0=%d y1=%d y2=%d",
-            x, y, y0_1, y1_1, y2_1);
+    dbprintf(1, "scan: x=%d y=%d y0=%d y1=%d y2=%d",
+             x, y, y0_1, y1_1, y2_1);
 
-    zbar_symbol_type_t edge = ZBAR_NONE;
+    edge = ZBAR_NONE;
     /* 2nd zero-crossing is 1st local min/max - could be edge */
     if((!y2_1 ||
         ((y2_1 > 0) ? y2_2 < 0 : y2_2 > 0)) &&
@@ -256,17 +261,18 @@
             edge = process_edge(scn, y1_1);
 
         if(y1_rev || (abs(scn->y1_sign) < abs(y1_1))) {
+            int d;
             scn->y1_sign = y1_1;
 
             /* adaptive thresholding */
             /* start at multiple of new min/max */
             scn->y1_thresh = (abs(y1_1) * THRESH_INIT + ROUND) >> ZBAR_FIXED;
-            dprintf(1, "\tthr=%d", scn->y1_thresh);
+            dbprintf(1, "\tthr=%d", scn->y1_thresh);
             if(scn->y1_thresh < scn->y1_min_thresh)
                 scn->y1_thresh = scn->y1_min_thresh;
 
             /* update current edge */
-            int d = y2_1 - y2_2;
+            d = y2_1 - y2_2;
             scn->cur_edge = 1 << ZBAR_FIXED;
             if(!d)
                 scn->cur_edge >>= 1;
@@ -274,11 +280,11 @@
                 /* interpolate zero crossing */
                 scn->cur_edge -= ((y2_1 << ZBAR_FIXED) + 1) / d;
             scn->cur_edge += x << ZBAR_FIXED;
-            dprintf(1, "\n");
+            dbprintf(1, "\n");
         }
     }
     else
-        dprintf(1, "\n");
+        dbprintf(1, "\n");
     /* FIXME add fall-thru pass to decoder after heuristic "idle" period
        (eg, 6-8 * last width) */
     scn->x = x + 1;
@@ -298,14 +304,14 @@
     register int y0_0 = scn->y0[(scn->x - 1) & 3];
     register int y0_1 = scn->y0[(scn->x - 2) & 3];
     register int y0_2 = scn->y0[(scn->x - 3) & 3];
+    zbar_scanner_t *mut_scn;
     if(x) *x = scn->x - 1;
-    if(cur_edge) *cur_edge = scn->cur_edge;
     if(last_edge) *last_edge = scn->last_edge;
     if(y0) *y0 = y0_1;
     if(y1) *y1 = y0_1 - y0_2;
     if(y2) *y2 = y0_0 - (y0_1 * 2) + y0_2;
     /* NB not quite accurate (uses updated x) */
-    zbar_scanner_t *mut_scn = (zbar_scanner_t*)scn;
+    mut_scn = (zbar_scanner_t*)scn;
     if(y1_thresh) *y1_thresh = calc_thresh(mut_scn);
-    dprintf(1, "\n");
+    dbprintf(1, "\n");
 }
diff -r 563557a923d0 zbar/symbol.c
--- a/zbar/symbol.c	Tue Oct 27 11:25:59 2009 -0400
+++ b/zbar/symbol.c	Fri Feb 22 08:54:29 2013 -0300
@@ -1,5 +1,5 @@
 /*------------------------------------------------------------------------
- *  Copyright 2007-2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *  Copyright 2007-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
  *
  *  This file is part of the ZBar Bar Code Reader.
  *
@@ -32,14 +32,21 @@
 const char *zbar_get_symbol_name (zbar_symbol_type_t sym)
 {
     switch(sym & ZBAR_SYMBOL) {
+    case ZBAR_EAN2: return("EAN-2");
+    case ZBAR_EAN5: return("EAN-5");
     case ZBAR_EAN8: return("EAN-8");
     case ZBAR_UPCE: return("UPC-E");
     case ZBAR_ISBN10: return("ISBN-10");
     case ZBAR_UPCA: return("UPC-A");
     case ZBAR_EAN13: return("EAN-13");
     case ZBAR_ISBN13: return("ISBN-13");
+    case ZBAR_COMPOSITE: return("COMPOSITE");
     case ZBAR_I25: return("I2/5");
+    case ZBAR_DATABAR: return("DataBar");
+    case ZBAR_DATABAR_EXP: return("DataBar-Exp");
+    case ZBAR_CODABAR: return("Codabar");
     case ZBAR_CODE39: return("CODE-39");
+    case ZBAR_CODE93: return("CODE-93");
     case ZBAR_CODE128: return("CODE-128");
     case ZBAR_PDF417: return("PDF417");
     case ZBAR_QRCODE: return("QR-Code");
@@ -49,13 +56,61 @@
 
 const char *zbar_get_addon_name (zbar_symbol_type_t sym)
 {
-    switch(sym & ZBAR_ADDON) {
-    case ZBAR_ADDON2: return("+2");
-    case ZBAR_ADDON5: return("+5");
+    return("");
+}
+
+const char *zbar_get_config_name (zbar_config_t cfg)
+{
+    switch(cfg) {
+    case ZBAR_CFG_ENABLE: return("ENABLE");
+    case ZBAR_CFG_ADD_CHECK: return("ADD_CHECK");
+    case ZBAR_CFG_EMIT_CHECK: return("EMIT_CHECK");
+    case ZBAR_CFG_ASCII: return("ASCII");
+    case ZBAR_CFG_MIN_LEN: return("MIN_LEN");
+    case ZBAR_CFG_MAX_LEN: return("MAX_LEN");
+    case ZBAR_CFG_UNCERTAINTY: return("UNCERTAINTY");
+    case ZBAR_CFG_POSITION: return("POSITION");
+    case ZBAR_CFG_X_DENSITY: return("X_DENSITY");
+    case ZBAR_CFG_Y_DENSITY: return("Y_DENSITY");
     default: return("");
     }
 }
 
+const char *zbar_get_modifier_name (zbar_modifier_t mod)
+{
+    switch(mod) {
+    case ZBAR_MOD_GS1: return("GS1");
+    case ZBAR_MOD_AIM: return("AIM");
+    default: return("");
+    }
+}
+
+const char *zbar_get_orientation_name (zbar_orientation_t orient)
+{
+    switch(orient) {
+    case ZBAR_ORIENT_UP: return("UP");
+    case ZBAR_ORIENT_RIGHT: return("RIGHT");
+    case ZBAR_ORIENT_DOWN: return("DOWN");
+    case ZBAR_ORIENT_LEFT: return("LEFT");
+    default: return("UNKNOWN");
+    }
+}
+
+int _zbar_get_symbol_hash (zbar_symbol_type_t sym)
+{
+    static const signed char hash[0x20] = {
+        0x00, 0x01, 0x10, 0x11,   -1, 0x11, 0x16, 0x0c,
+	0x05, 0x06, 0x08,   -1, 0x04, 0x03, 0x07, 0x12,
+	  -1,   -1,   -1,   -1,   -1,   -1,   -1, 0x02,
+	  -1, 0x00, 0x12, 0x0c, 0x0b, 0x1d, 0x0a, 0x00,
+     };
+    int g0 = hash[sym & 0x1f];
+    int g1 = hash[~(sym >> 4) & 0x1f];
+    assert(g0 >= 0 && g1 >= 0);
+    if(g0 < 0 || g1 < 0)
+        return(0);
+    return((g0 + g1) & 0x1f);
+}
 
 void _zbar_symbol_free (zbar_symbol_t *sym)
 {
@@ -82,6 +137,16 @@
     return(sym->type);
 }
 
+unsigned int zbar_symbol_get_configs (const zbar_symbol_t *sym)
+{
+    return(sym->configs);
+}
+
+unsigned int zbar_symbol_get_modifiers (const zbar_symbol_t *sym)
+{
+    return(sym->modifiers);
+}
+
 const char *zbar_symbol_get_data (const zbar_symbol_t *sym)
 {
     return(sym->data);
@@ -125,6 +190,11 @@
         return(-1);
 }
 
+zbar_orientation_t zbar_symbol_get_orientation (const zbar_symbol_t *sym)
+{
+    return(sym->orient);
+}
+
 const zbar_symbol_t *zbar_symbol_next (const zbar_symbol_t *sym)
 {
     return((sym) ? sym->next : NULL);
@@ -142,26 +212,100 @@
 }
 
 
-static const char *xmlfmt[] = {
-    "<symbol type='%s' quality='%d'",
-    " count='%d'",
-    "><data><![CDATA[",
-    "]]></data></symbol>",
+unsigned base64_encode (char *dst,
+                        const char *src,
+                        unsigned srclen)
+{
+    static const char alphabet[] =
+        "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
+    char *start = dst;
+    int nline = 19;
+    for(; srclen; srclen -= 3) {
+        unsigned int buf = *(src++) << 16;
+        if(srclen > 1) buf |= *(src++) << 8;
+        if(srclen > 2) buf |= *(src++);
+        *(dst++) = alphabet[(buf >> 18) & 0x3f];
+        *(dst++) = alphabet[(buf >> 12) & 0x3f];
+        *(dst++) = (srclen > 1) ? alphabet[(buf >> 6) & 0x3f] : '=';
+        *(dst++) = (srclen > 2) ? alphabet[buf & 0x3f] : '=';
+        if(srclen < 3) break;
+        if(!--nline) { *(dst++) = '\n'; nline = 19; }
+    }
+    *(dst++) = '\n';
+    *(dst++) = '\0';
+    return(dst - start - 1);
+}
+
+enum {
+    TMPL_START,
+    TMPL_MOD_START, TMPL_MOD_ITEM, TMPL_MOD_END,
+    TMPL_COUNT,
+    TMPL_DATA_START, TMPL_FORMAT, TMPL_CDATA,
+    TMPL_NL,
+    TMPL_END,
 };
 
 /* FIXME suspect... */
+#define MAX_STATIC 256
+#define MAX_MOD (5 * ZBAR_MOD_NUM)
+#define MAX_CFG (10 * ZBAR_CFG_NUM)
 #define MAX_INT_DIGITS 10
 
+#define TMPL_COPY(t) do {             \
+        static const char *_st = (t); \
+        i = strlen(_st);              \
+        memcpy(*buf + n, _st, i + 1); \
+        n += i;                       \
+        assert(n <= maxlen);          \
+    } while(0)
+
+#define TMPL_FMT(t, ...) do {                                 \
+        static const char *_st = (t);                         \
+        i = snprintf(*buf + n, maxlen - n, _st, __VA_ARGS__); \
+        assert(i > 0);                                        \
+        n += i;                                               \
+        assert(n <= maxlen);                                  \
+    } while(0)
+
 char *zbar_symbol_xml (const zbar_symbol_t *sym,
                        char **buf,
                        unsigned *len)
 {
+    unsigned int datalen, maxlen;
+    int i, n = 0;
+
     const char *type = zbar_get_symbol_name(sym->type);
-    /* FIXME binary data */
-    unsigned datalen = strlen(sym->data);
-    unsigned maxlen = (strlen(xmlfmt[0]) + strlen(xmlfmt[1]) +
-                       strlen(xmlfmt[2]) + strlen(xmlfmt[3]) +
-                       strlen(type) + datalen + MAX_INT_DIGITS + 1);
+    const char *orient = zbar_get_orientation_name(sym->orient);
+
+    /* check for binary data */
+    unsigned char *data = (unsigned char*)sym->data;
+    char binary = ((data[0] == 0xff && data[1] == 0xfe) ||
+                   (data[0] == 0xfe && data[1] == 0xff) ||
+                   !strncmp(sym->data, "<?xml", 5));
+    for(i = 0; !binary && i < sym->datalen; i++) {
+        unsigned char c = sym->data[i];
+        binary = ((c < 0x20 && ((~0x00002600 >> c) & 1)) ||
+                  (c >= 0x7f && c < 0xa0) ||
+                  (c == ']' && i + 2 < sym->datalen &&
+                   sym->data[i + 1] == ']' &&
+                   sym->data[i + 2] == '>'));
+    }
+
+    datalen = strlen(sym->data);
+    if(binary)
+        datalen = (sym->datalen + 2) / 3 * 4 + sym->datalen / 57 + 3;
+
+    maxlen = (MAX_STATIC + strlen(type) + strlen(orient) +
+              datalen + MAX_INT_DIGITS + 1);
+    unsigned int mods = sym->modifiers;
+    if(mods)
+        maxlen += MAX_MOD;
+    unsigned int cfgs = sym->configs & ~(1 << ZBAR_CFG_ENABLE);
+    if(cfgs)
+        maxlen += MAX_CFG;
+    if(binary)
+        maxlen += MAX_INT_DIGITS;
+
     if(!*buf || (*len < maxlen)) {
         if(*buf)
             free(*buf);
@@ -170,32 +314,50 @@
         *len = maxlen;
     }
 
-    int n = snprintf(*buf, maxlen, xmlfmt[0], type, sym->quality);
-    assert(n > 0);
+    TMPL_FMT("<symbol type='%s' quality='%d' orientation='%s'",
+             type, sym->quality, orient);
+
+    if(mods) {
+        int j;
+        TMPL_COPY(" modifiers='");
+        for(j = 0; mods && j < ZBAR_MOD_NUM; j++, mods >>= 1)
+            if(mods & 1)
+                TMPL_FMT("%s ", zbar_get_modifier_name(j));
+        /* cleanup trailing space */
+        n--;
+        TMPL_COPY("'");
+    }
+
+    if(cfgs) {
+        int j;
+        TMPL_COPY(" configs='");
+        for(j = 0; cfgs && j < ZBAR_CFG_NUM; j++, cfgs >>= 1)
+            if(cfgs & 1)
+                TMPL_FMT("%s ", zbar_get_config_name(j));
+        /* cleanup trailing space */
+        n--;
+        TMPL_COPY("'");
+    }
+
+    if(sym->cache_count)
+        TMPL_FMT(" count='%d'", sym->cache_count);
+
+    TMPL_COPY("><data");
+    if(binary)
+        TMPL_FMT(" format='base64' length='%d'", sym->datalen);
+    TMPL_COPY("><![CDATA[");
+
+    if(!binary) {
+        memcpy(*buf + n, sym->data, sym->datalen + 1);
+        n += sym->datalen;
+    }
+    else {
+        TMPL_COPY("\n");
+        n += base64_encode(*buf + n, sym->data, sym->datalen);
+    }
     assert(n <= maxlen);
 
-    if(sym->cache_count) {
-        int i = snprintf(*buf + n, maxlen - n, xmlfmt[1], sym->cache_count);
-        assert(i > 0);
-        n += i;
-        assert(n <= maxlen);
-    }
-
-    int i = strlen(xmlfmt[2]);
-    memcpy(*buf + n, xmlfmt[2], i + 1);
-    n += i;
-    assert(n <= maxlen);
-
-    /* FIXME binary data */
-    /* FIXME handle "]]>" */
-    strncpy(*buf + n, sym->data, datalen + 1);
-    n += datalen;
-    assert(n <= maxlen);
-
-    i = strlen(xmlfmt[3]);
-    memcpy(*buf + n, xmlfmt[3], i + 1);
-    n += i;
-    assert(n <= maxlen);
+    TMPL_COPY("]]></data></symbol>");
 
     *len = n;
     return(*buf);
@@ -242,3 +404,9 @@
         return(sym->next);
     return(syms->head);
 }
+
+const zbar_symbol_t*
+zbar_symbol_set_first_unfiltered (const zbar_symbol_set_t *syms)
+{
+    return(syms->head);
+}
diff -r 563557a923d0 zbar/symbol.h
--- a/zbar/symbol.h	Tue Oct 27 11:25:59 2009 -0400
+++ b/zbar/symbol.h	Fri Feb 22 08:54:29 2013 -0300
@@ -1,5 +1,5 @@
 /*------------------------------------------------------------------------
- *  Copyright 2007-2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *  Copyright 2007-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
  *
  *  This file is part of the ZBar Bar Code Reader.
  *
@@ -27,6 +27,8 @@
 #include <zbar.h>
 #include "refcnt.h"
 
+#define NUM_SYMS  20
+
 typedef struct point_s {
     int x, y;
 } point_t;
@@ -40,6 +42,8 @@
 
 struct zbar_symbol_s {
     zbar_symbol_type_t type;    /* symbol type */
+    unsigned int configs;       /* symbology boolean config bitmask */
+    unsigned int modifiers;     /* symbology modifier bitmask */
     unsigned int data_alloc;    /* allocation size of data */
     unsigned int datalen;       /* length of binary symbol data */
     char *data;                 /* symbol data */
@@ -47,6 +51,7 @@
     unsigned pts_alloc;         /* allocation size of pts */
     unsigned npts;              /* number of points in location polygon */
     point_t *pts;               /* list of points in location polygon */
+    zbar_orientation_t orient;  /* coarse orientation */
 
     refcnt_t refcnt;            /* reference count */
     zbar_symbol_t *next;        /* linked list of results (or siblings) */
@@ -56,6 +61,8 @@
     int quality;                /* relative symbol reliability metric */
 };
 
+extern int _zbar_get_symbol_hash(zbar_symbol_type_t);
+
 extern void _zbar_symbol_free(zbar_symbol_t*);
 
 extern zbar_symbol_set_t *_zbar_symbol_set_create(void);
diff -r 563557a923d0 zbar/timer.h
--- a/zbar/timer.h	Tue Oct 27 11:25:59 2009 -0400
+++ b/zbar/timer.h	Fri Feb 22 08:54:29 2013 -0300
@@ -1,5 +1,5 @@
 /*------------------------------------------------------------------------
- *  Copyright 2007-2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *  Copyright 2007-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
  *
  *  This file is part of the ZBar Bar Code Reader.
  *
@@ -24,7 +24,9 @@
 #define _ZBAR_TIMER_H_
 
 #include <time.h>
-#include <sys/time.h>   /* gettimeofday */
+#ifdef HAVE_SYS_TIME_H
+# include <sys/time.h>   /* gettimeofday */
+#endif
 
 /* platform timer abstraction
  *
@@ -41,6 +43,13 @@
 
 typedef struct timespec zbar_timer_t;
 
+static inline int _zbar_timer_now ()
+{
+    struct timespec now;
+    clock_gettime(CLOCK_REALTIME, &now);
+    return(now.tv_sec * 1000 + now.tv_nsec / 1000000);
+}
+
 static inline zbar_timer_t *_zbar_timer_init (zbar_timer_t *timer,
                                               int delay)
 {
@@ -56,13 +65,14 @@
 
 static inline int _zbar_timer_check (zbar_timer_t *timer)
 {
+    struct timespec now;
+    int delay;
     if(!timer)
         return(-1);
 
-    struct timespec now;
     clock_gettime(CLOCK_REALTIME, &now);
-    int delay = ((timer->tv_sec - now.tv_sec) * 1000 +
-                 (timer->tv_nsec - now.tv_nsec) / 1000000);
+    delay = ((timer->tv_sec - now.tv_sec) * 1000 +
+             (timer->tv_nsec - now.tv_nsec) / 1000000);
     return((delay >= 0) ? delay : 0);
 }
 
@@ -73,6 +83,11 @@
 
 typedef DWORD zbar_timer_t;
 
+static inline int _zbar_timer_now ()
+{
+    return(timeGetTime());
+}
+
 static inline zbar_timer_t *_zbar_timer_init (zbar_timer_t *timer,
                                               int delay)
 {
@@ -85,18 +100,26 @@
 
 static inline int _zbar_timer_check (zbar_timer_t *timer)
 {
+    int delay;
     if(!timer)
         return(INFINITE);
 
-    int delay = *timer - timeGetTime();
+    delay = *timer - timeGetTime();
     return((delay >= 0) ? delay : 0);
 }
 
 
-#else
+#elif defined(HAVE_SYS_TIME_H)
 
 typedef struct timeval zbar_timer_t;
 
+static inline int _zbar_timer_now ()
+{
+    struct timeval now;
+    gettimeofday(&now, NULL);
+    return(now.tv_sec * 1000 + now.tv_usec / 1000);
+}
+
 static inline zbar_timer_t *_zbar_timer_init (zbar_timer_t *timer,
                                               int delay)
 {
@@ -112,15 +135,17 @@
 
 static inline int _zbar_timer_check (zbar_timer_t *timer)
 {
+    struct timeval now;
     if(!timer)
         return(-1);
 
-    struct timeval now;
     gettimeofday(&now, NULL);
     return((timer->tv_sec - now.tv_sec) * 1000 +
            (timer->tv_usec - now.tv_usec) / 1000);
 }
 
+#else
+# error "unable to find a timer interface"
 #endif
 
 #endif
diff -r 563557a923d0 zbar/video.c
--- a/zbar/video.c	Tue Oct 27 11:25:59 2009 -0400
+++ b/zbar/video.c	Fri Feb 22 08:54:29 2013 -0300
@@ -1,5 +1,5 @@
 /*------------------------------------------------------------------------
- *  Copyright 2007-2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *  Copyright 2007-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
  *
  *  This file is part of the ZBar Bar Code Reader.
  *
@@ -58,6 +58,7 @@
 zbar_video_t *zbar_video_create ()
 {
     zbar_video_t *vdo = calloc(1, sizeof(zbar_video_t));
+    int i;
     if(!vdo)
         return(NULL);
     err_init(&vdo->err, ZBAR_MOD_VIDEO);
@@ -73,7 +74,6 @@
         return(NULL);
     }
 
-    int i;
     for(i = 0; i < ZBAR_VIDEO_IMAGES_MAX; i++) {
         zbar_image_t *img = vdo->images[i] = zbar_image_create();
         if(!img) {
@@ -97,7 +97,7 @@
         int i;
         for(i = 0; i < ZBAR_VIDEO_IMAGES_MAX; i++)
             if(vdo->images[i])
-                free(vdo->images[i]);
+                _zbar_image_free(vdo->images[i]);
         free(vdo->images);
     }
     while(vdo->shadow_image) {
@@ -130,6 +130,8 @@
 int zbar_video_open (zbar_video_t *vdo,
                      const char *dev)
 {
+    char *ldev = NULL;
+    int rc;
     zbar_video_enable(vdo, 0);
     video_lock(vdo);
     if(vdo->intf != VIDEO_INVALID) {
@@ -145,7 +147,6 @@
     if(!dev)
         return(0);
 
-    char *ldev = NULL;
     if((unsigned char)dev[0] < 0x10) {
         /* default linux device, overloaded for other platforms */
         int id = dev[0];
@@ -153,7 +154,7 @@
         ldev[10] = '0' + id;
     }
 
-    int rc = _zbar_video_open(vdo, dev);
+    rc = _zbar_video_open(vdo, dev);
 
     if(ldev)
         free(ldev);
@@ -227,12 +228,12 @@
 
 static inline int video_init_images (zbar_video_t *vdo)
 {
-    
+    int i;
     assert(vdo->datalen);
     if(vdo->iomode != VIDEO_MMAP) {
         assert(!vdo->buf);
         vdo->buflen = vdo->num_images * vdo->datalen;
-        vdo->buf = malloc(vdo->buflen);
+        vdo->buf = calloc(1, vdo->buflen);
         if(!vdo->buf)
             return(err_capture(vdo, SEV_FATAL, ZBAR_ERR_NOMEM, __func__,
                                "unable to allocate image buffers"));
@@ -240,16 +241,14 @@
                 (vdo->iomode == VIDEO_READWRITE) ? "READ" : "USERPTR",
                 vdo->buflen);
     }
-    int i;
     for(i = 0; i < vdo->num_images; i++) {
         zbar_image_t *img = vdo->images[i];
         img->format = vdo->format;
-        img->width = vdo->width;
-        img->height = vdo->height;
+        zbar_image_set_size(img, vdo->width, vdo->height);
         if(vdo->iomode != VIDEO_MMAP) {
+            unsigned long offset = i * vdo->datalen;
             img->datalen = vdo->datalen;
-            unsigned long offset = i * vdo->datalen;
-            img->data = vdo->buf + offset;
+            img->data = (uint8_t*)vdo->buf + offset;
             zprintf(2, "    [%02d] @%08lx\n", i, offset);
         }
     }
@@ -259,6 +258,9 @@
 int zbar_video_init (zbar_video_t *vdo,
                      unsigned long fmt)
 {
+#ifdef HAVE_LIBJPEG
+    const zbar_format_def_t *vidfmt;
+#endif
     if(vdo->initialized)
         /* FIXME re-init different format? */
         return(err_capture(vdo, SEV_ERROR, ZBAR_ERR_INVALID, __func__,
@@ -270,8 +272,9 @@
     if(video_init_images(vdo))
         return(-1);
 #ifdef HAVE_LIBJPEG
-    const zbar_format_def_t *vidfmt = _zbar_format_lookup(fmt);
+    vidfmt = _zbar_format_lookup(fmt);
     if(vidfmt && vidfmt->group == ZBAR_FMT_JPEG) {
+        zbar_image_t *img;
         /* prepare for decoding */
         if(!vdo->jpeg)
             vdo->jpeg = _zbar_jpeg_decomp_create();
@@ -279,10 +282,9 @@
             zbar_image_destroy(vdo->jpeg_img);
 
         /* create intermediate image for decoder to use*/
-        zbar_image_t *img = vdo->jpeg_img = zbar_image_create();
+        img = vdo->jpeg_img = zbar_image_create();
         img->format = fourcc('Y','8','0','0');
-        img->width = vdo->width;
-        img->height = vdo->height;
+        zbar_image_set_size(img, vdo->width, vdo->height);
         img->datalen = vdo->width * vdo->height;
     }
 #endif
@@ -333,6 +335,9 @@
 
 zbar_image_t *zbar_video_next_image (zbar_video_t *vdo)
 {
+    unsigned frame;
+    zbar_image_t *img;
+
     if(video_lock(vdo))
         return(NULL);
     if(!vdo->active) {
@@ -340,8 +345,8 @@
         return(NULL);
     }
 
-    unsigned frame = vdo->frame++;
-    zbar_image_t *img = vdo->dq(vdo);
+    frame = vdo->frame++;
+    img = vdo->dq(vdo);
     if(img) {
         img->seq = frame;
         if(vdo->num_images < 2) {
@@ -362,8 +367,7 @@
                 /* recycle the shadow images */
 
                 img->format = vdo->format;
-                img->width = vdo->width;
-                img->height = vdo->height;
+                zbar_image_set_size(img, vdo->width, vdo->height);
                 img->datalen = vdo->datalen;
                 img->data = malloc(vdo->datalen);
             }
diff -r 563557a923d0 zbar/video/v4l.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/zbar/video/v4l.c	Fri Feb 22 08:54:29 2013 -0300
@@ -0,0 +1,67 @@
+/*------------------------------------------------------------------------
+ *  Copyright 2007-2011 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *
+ *  This file is part of the ZBar Bar Code Reader.
+ *
+ *  The ZBar Bar Code Reader is free software; you can redistribute it
+ *  and/or modify it under the terms of the GNU Lesser Public License as
+ *  published by the Free Software Foundation; either version 2.1 of
+ *  the License, or (at your option) any later version.
+ *
+ *  The ZBar Bar Code Reader is distributed in the hope that it will be
+ *  useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+ *  of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser Public License
+ *  along with the ZBar Bar Code Reader; if not, write to the Free
+ *  Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ *  Boston, MA  02110-1301  USA
+ *
+ *  http://sourceforge.net/projects/zbar
+ *------------------------------------------------------------------------*/
+
+#include <config.h>
+#ifdef HAVE_SYS_TYPES_H
+# include <sys/types.h>
+#endif
+#ifdef HAVE_SYS_STAT_H
+# include <sys/stat.h>
+#endif
+#ifdef HAVE_FCNTL_H
+# include <fcntl.h>
+#endif
+#ifdef HAVE_UNISTD_H
+# include <unistd.h>
+#endif
+
+#include "video.h"
+
+extern int _zbar_v4l1_probe(zbar_video_t*);
+extern int _zbar_v4l2_probe(zbar_video_t*);
+
+int _zbar_video_open (zbar_video_t *vdo,
+                      const char *dev)
+{
+    vdo->fd = open(dev, O_RDWR);
+    if(vdo->fd < 0)
+        return(err_capture_str(vdo, SEV_ERROR, ZBAR_ERR_SYSTEM, __func__,
+                               "opening video device '%s'", dev));
+    zprintf(1, "opened camera device %s (fd=%d)\n", dev, vdo->fd);
+
+    int rc = -1;
+#ifdef HAVE_LINUX_VIDEODEV2_H
+    if(vdo->intf != VIDEO_V4L1)
+        rc = _zbar_v4l2_probe(vdo);
+#endif
+#ifdef HAVE_LINUX_VIDEODEV_H
+    if(rc && vdo->intf != VIDEO_V4L2)
+        rc = _zbar_v4l1_probe(vdo);
+#endif
+
+    if(rc && vdo->fd >= 0) {
+        close(vdo->fd);
+        vdo->fd = -1;
+    }
+    return(rc);
+}
diff -r 563557a923d0 zbar/video/v4l1.c
--- a/zbar/video/v4l1.c	Tue Oct 27 11:25:59 2009 -0400
+++ b/zbar/video/v4l1.c	Fri Feb 22 08:54:29 2013 -0300
@@ -1,5 +1,5 @@
 /*------------------------------------------------------------------------
- *  Copyright 2007-2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *  Copyright 2007-2011 (c) Jeff Brown <spadix@users.sourceforge.net>
  *
  *  This file is part of the ZBar Bar Code Reader.
  *
@@ -46,8 +46,6 @@
 #include "video.h"
 #include "image.h"
 
-extern int _zbar_v4l2_probe(zbar_video_t*);
-
 typedef struct v4l1_format_s {
     uint32_t format;
     uint8_t bpp;
@@ -371,7 +369,7 @@
     return(0);
 }
 
-static int _zbar_v4l1_probe (zbar_video_t *vdo)
+int _zbar_v4l1_probe (zbar_video_t *vdo)
 {
     /* check capabilities */
     struct video_capability vcap;
@@ -407,29 +405,3 @@
     vdo->dq = v4l1_dq;
     return(0);
 }
-
-int _zbar_video_open (zbar_video_t *vdo,
-                      const char *dev)
-{
-    vdo->fd = open(dev, O_RDWR);
-    if(vdo->fd < 0)
-        return(err_capture_str(vdo, SEV_ERROR, ZBAR_ERR_SYSTEM, __func__,
-                               "opening video device '%s'", dev));
-    zprintf(1, "opened camera device %s (fd=%d)\n", dev, vdo->fd);
-
-    int rc = -1;
-#ifdef HAVE_LINUX_VIDEODEV2_H
-    if(vdo->intf != VIDEO_V4L1)
-        rc = _zbar_v4l2_probe(vdo);
-    if(rc)
-#else
-    zprintf(1, "WARNING: not compiled with v4l2 support, trying v4l1\n");
-#endif
-        rc = _zbar_v4l1_probe(vdo);
-
-    if(rc && vdo->fd >= 0) {
-        close(vdo->fd);
-        vdo->fd = -1;
-    }
-    return(rc);
-}
diff -r 563557a923d0 zbar/window.c
--- a/zbar/window.c	Tue Oct 27 11:25:59 2009 -0400
+++ b/zbar/window.c	Fri Feb 22 08:54:29 2013 -0300
@@ -1,5 +1,5 @@
 /*------------------------------------------------------------------------
- *  Copyright 2007-2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *  Copyright 2007-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
  *
  *  This file is part of the ZBar Bar Code Reader.
  *
@@ -23,8 +23,11 @@
 
 #include "window.h"
 #include "image.h"
+#include "timer.h"
 #include <time.h>       /* clock_gettime */
-#include <sys/time.h>   /* gettimeofday */
+#ifdef HAVE_SYS_TIME_H
+# include <sys/time.h>   /* gettimeofday */
+#endif
 
 zbar_window_t *zbar_window_create ()
 {
@@ -117,20 +120,11 @@
 
     if(w->overlay >= 2) {
         /* calculate/display frame rate */
-        unsigned long time;
-#if _POSIX_TIMERS > 0
-        struct timespec abstime;
-        clock_gettime(CLOCK_REALTIME, &abstime);
-        time = (abstime.tv_sec * 1000) + ((abstime.tv_nsec / 500000) + 1) / 2;
-#else
-        struct timeval abstime;
-        gettimeofday(&abstime, NULL);
-        time = (abstime.tv_sec * 1000) + ((abstime.tv_usec / 500) + 1) / 2;
-#endif
-        point_t p = { -8, -1 };
-        char text[32];
+        unsigned long time = _zbar_timer_now();
         if(w->time) {
             int avg = w->time_avg = (w->time_avg + time - w->time) / 2;
+            point_t p = { -8, -1 };
+            char text[32];
             sprintf(text, "%d.%01d fps", 1000 / avg, (10000 / avg) % 10);
             _zbar_window_draw_text(w, 3, p, text);
         }
@@ -141,6 +135,8 @@
 
 inline int zbar_window_redraw (zbar_window_t *w)
 {
+    int rc = 0;
+    zbar_image_t *img;
     if(window_lock(w))
         return(-1);
     if(!w->display || _zbar_window_begin(w)) {
@@ -148,8 +144,7 @@
         return(-1);
     }
 
-    int rc = 0;
-    zbar_image_t *img = w->image;
+    img = w->image;
     if(w->init && w->draw_image && img) {
         int format_change = (w->src_format != img->format &&
                              w->format != img->format);
@@ -163,6 +158,7 @@
         }
 
         if(!rc && (format_change || !w->scaled_size.x || !w->dst_width)) {
+            point_t size = { w->width, w->height };
             zprintf(24, "init: src=%.4s(%08x) %dx%d dst=%.4s(%08x) %dx%d\n",
                     (char*)&w->src_format, w->src_format,
                     w->src_width, w->src_height,
@@ -173,7 +169,6 @@
                 w->src_height = img->height;
             }
 
-            point_t size = { w->width, w->height };
             if(size.x > w->max_width)
                 size.x = w->max_width;
             if(size.y > w->max_height)
@@ -226,9 +221,10 @@
         }
 
         if(!rc) {
+            point_t org;
             rc = w->draw_image(w, img);
 
-            point_t org = w->scaled_offset;
+            org = w->scaled_offset;
             if(org.x > 0) {
                 point_t p = { 0, org.y };
                 point_t s = { org.x, w->scaled_size.y };
@@ -300,9 +296,10 @@
 int zbar_window_get_overlay (const zbar_window_t *w)
 {
     zbar_window_t *ncw = (zbar_window_t*)w;
+    int lvl;
     if(window_lock(ncw))
         return(-1);
-    int lvl = w->overlay;
+    lvl = w->overlay;
     (void)window_unlock(ncw);
     return(lvl);
 }
diff -r 563557a923d0 zbarcam/zbarcam.c
--- a/zbarcam/zbarcam.c	Tue Oct 27 11:25:59 2009 -0400
+++ b/zbarcam/zbarcam.c	Fri Feb 22 08:54:29 2013 -0300
@@ -105,17 +105,27 @@
         if(type == ZBAR_PARTIAL)
             continue;
 
-        if(!format)
-            printf("%s%s:%s\n",
-                   zbar_get_symbol_name(type), zbar_get_addon_name(type),
-                   zbar_symbol_get_data(sym));
-        else if(format == RAW)
-            printf("%s\n", zbar_symbol_get_data(sym));
+        if(!format) {
+            printf("%s:", zbar_get_symbol_name(type));
+            if(fwrite(zbar_symbol_get_data(sym),
+                      zbar_symbol_get_data_length(sym),
+                      1, stdout) != 1)
+                continue;
+        }
+        else if(format == RAW) {
+            if(fwrite(zbar_symbol_get_data(sym),
+                      zbar_symbol_get_data_length(sym),
+                      1, stdout) != 1)
+                continue;
+        }
         else if(format == XML) {
             if(!n)
                 printf("<index num='%u'>\n", zbar_image_get_sequence(img));
-            printf("%s\n", zbar_symbol_xml(sym, &xml_buf, &xml_len));
+            zbar_symbol_xml(sym, &xml_buf, &xml_len);
+            if(fwrite(xml_buf, xml_len, 1, stdout) != 1)
+                continue;
         }
+        printf("\n");
         n++;
     }
 
diff -r 563557a923d0 zbarcam/zbarcam.rc
--- a/zbarcam/zbarcam.rc	Tue Oct 27 11:25:59 2009 -0400
+++ b/zbarcam/zbarcam.rc	Fri Feb 22 08:54:29 2013 -0300
@@ -19,7 +19,7 @@
 
             VALUE "FileDescription", "Scan bar codes from video devices"
 
-            VALUE "LegalCopyright", "Copyright 2007-2009 (c) Jeff Brown <spadix@users.sourceforge.net>"
+            VALUE "LegalCopyright", "Copyright 2007-2010 (c) Jeff Brown <spadix@users.sourceforge.net>"
         }
     }
     BLOCK "VarFileInfo" {
diff -r 563557a923d0 zbarimg/Makefile.am.inc
--- a/zbarimg/Makefile.am.inc	Tue Oct 27 11:25:59 2009 -0400
+++ b/zbarimg/Makefile.am.inc	Fri Feb 22 08:54:29 2013 -0300
@@ -12,10 +12,10 @@
 
 EXTRA_DIST += test/barcodetest.py
 
-check-local:
+check-images: zbarimg/zbarimg
 	$(PYTHON) $(srcdir)/test/barcodetest.py
 
-regress:
+regress-images: zbarimg/zbarimg
 	suite='$(ZBAR_TESTS)'; \
 	if test "x$$suite" = "x"; then suite='http://zbar.sf.net/test'; fi ; \
 	$(PYTHON) $(srcdir)/test/barcodetest.py $$suite
diff -r 563557a923d0 zbarimg/zbarimg.c
--- a/zbarimg/zbarimg.c	Tue Oct 27 11:25:59 2009 -0400
+++ b/zbarimg/zbarimg.c	Fri Feb 22 08:54:29 2013 -0300
@@ -1,5 +1,5 @@
 /*------------------------------------------------------------------------
- *  Copyright 2007-2009 (c) Jeff Brown <spadix@users.sourceforge.net>
+ *  Copyright 2007-2010 (c) Jeff Brown <spadix@users.sourceforge.net>
  *
  *  This file is part of the ZBar Bar Code Reader.
  *
@@ -38,15 +38,29 @@
 #include <assert.h>
 
 #include <zbar.h>
-#include <wand/MagickWand.h>
+
+#ifdef HAVE_GRAPHICSMAGICK
+# include <wand/wand_api.h>
+#endif
+
+#ifdef HAVE_IMAGEMAGICK
+# include <wand/MagickWand.h>
+
+/* ImageMagick frequently changes API names - just use the original
+ * (more stable?) names to match GraphicsMagick
+ */
+# define InitializeMagick(f) MagickWandGenesis()
+# define DestroyMagick MagickWandTerminus
+# define MagickSetImageIndex MagickSetIteratorIndex
 
 /* in 6.4.5.4 MagickGetImagePixels changed to MagickExportImagePixels.
  * (still not sure this check is quite right...
  *  how does MagickGetAuthenticImagePixels fit in?)
  * ref http://bugs.gentoo.org/247292
  */
-#if MagickLibVersion < 0x645
-# define MagickExportImagePixels MagickGetImagePixels
+# if MagickLibVersion > 0x645
+#  define MagickGetImagePixels MagickExportImagePixels
+# endif
 #endif
 
 static const char *note_usage =
@@ -76,8 +90,9 @@
     "  things to check:\n"
     "    - is the barcode type supported?"
     "  currently supported symbologies are:\n"
-    "      EAN/UPC (EAN-13, EAN-8, UPC-A, UPC-E, ISBN-10, ISBN-13),\n"
-    "      Code 128, Code 39 and Interleaved 2 of 5\n"
+    "      EAN/UPC (EAN-13, EAN-8, EAN-2, EAN-5, UPC-A, UPC-E,\n"
+    "      ISBN-10, ISBN-13), Code 128, Code 93, Code 39, Codabar,\n"
+    "      DataBar, DataBar Expanded, and Interleaved 2 of 5\n"
     "    - is the barcode large enough in the image?\n"
     "    - is the barcode mostly in focus?\n"
     "    - is there sufficient contrast/illumination?\n"
@@ -132,12 +147,12 @@
         if(exit_code == 3)
             return(-1);
 
-        if(!MagickSetIteratorIndex(images, seq) && dump_error(images))
+        if(!MagickSetImageIndex(images, seq) && dump_error(images))
             return(-1);
 
         zbar_image_t *zimage = zbar_image_create();
         assert(zimage);
-        zbar_image_set_format(zimage, *(unsigned long*)"Y800");
+        zbar_image_set_format(zimage, zbar_fourcc('Y','8','0','0'));
 
         int width = MagickGetImageWidth(images);
         int height = MagickGetImageHeight(images);
@@ -150,8 +165,8 @@
         unsigned char *blob = malloc(bloblen);
         zbar_image_set_data(zimage, blob, bloblen, zbar_image_free_data);
 
-        if(!MagickExportImagePixels(images, 0, 0, width, height,
-                                    "I", CharPixel, blob))
+        if(!MagickGetImagePixels(images, 0, 0, width, height,
+                                 "I", CharPixel, blob))
             return(-1);
 
         if(xmllvl == 1) {
@@ -165,23 +180,30 @@
         const zbar_symbol_t *sym = zbar_image_first_symbol(zimage);
         for(; sym; sym = zbar_symbol_next(sym)) {
             zbar_symbol_type_t typ = zbar_symbol_get_type(sym);
+            unsigned len = zbar_symbol_get_data_length(sym);
             if(typ == ZBAR_PARTIAL)
                 continue;
-            else if(!xmllvl)
-                printf("%s%s:%s\n",
-                       zbar_get_symbol_name(typ),
-                       zbar_get_addon_name(typ),
-                       zbar_symbol_get_data(sym));
-            else if(xmllvl < 0)
-                printf("%s\n", zbar_symbol_get_data(sym));
+            else if(xmllvl <= 0) {
+                if(!xmllvl)
+                    printf("%s:", zbar_get_symbol_name(typ));
+                if(len &&
+                   fwrite(zbar_symbol_get_data(sym), len, 1, stdout) != 1) {
+                    exit_code = 1;
+                    return(-1);
+                }
+            }
             else {
                 if(xmllvl < 3) {
                     xmllvl++;
                     printf("<index num='%u'>\n", seq);
                 }
                 zbar_symbol_xml(sym, &xmlbuf, &xmlbuflen);
-                printf("%s\n", xmlbuf);
+                if(fwrite(xmlbuf, xmlbuflen, 1, stdout) != 1) {
+                    exit_code = 1;
+                    return(-1);
+                }
             }
+            printf("\n");
             found++;
             num_symbols++;
         }
@@ -247,7 +269,7 @@
     int i, j;
     for(i = 1; i < argc; i++) {
         const char *arg = argv[i];
-        if(arg[0] != '-')
+        if(arg[0] != '-' || !arg[1])
             // first pass, skip images
             num_images++;
         else if(arg[1] != '-')
@@ -304,7 +326,7 @@
         return(usage(1, "ERROR: specify image file(s) to scan", NULL));
     num_images = 0;
 
-    MagickWandGenesis();
+    InitializeMagick("zbarimg");
 
     processor = zbar_processor_create(0);
     assert(processor);
@@ -318,7 +340,7 @@
         if(!arg)
             continue;
 
-        if(arg[0] != '-') {
+        if(arg[0] != '-' || !arg[1]) {
             if(scan_image(arg))
                 return(exit_code);
         }
@@ -417,6 +439,6 @@
         exit_code = 4;
 
     zbar_processor_destroy(processor);
-    MagickWandTerminus();
+    DestroyMagick();
     return(exit_code);
 }
diff -r 563557a923d0 zbarimg/zbarimg.rc
--- a/zbarimg/zbarimg.rc	Tue Oct 27 11:25:59 2009 -0400
+++ b/zbarimg/zbarimg.rc	Fri Feb 22 08:54:29 2013 -0300
@@ -19,7 +19,7 @@
 
             VALUE "FileDescription", "Scan bar codes from image files"
 
-            VALUE "LegalCopyright", "Copyright 2007-2009 (c) Jeff Brown <spadix@users.sourceforge.net>"
+            VALUE "LegalCopyright", "Copyright 2007-2010 (c) Jeff Brown <spadix@users.sourceforge.net>"
         }
     }
     BLOCK "VarFileInfo" {
