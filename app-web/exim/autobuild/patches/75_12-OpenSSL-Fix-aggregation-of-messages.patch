From 1bd4207a399775cf842607930e76c14ac54327df Mon Sep 17 00:00:00 2001
From: Jeremy Harris <jgh146exb@wizmail.org>
Date: Tue, 19 Mar 2019 15:33:31 +0000
Subject: [PATCH 12/29] OpenSSL: Fix aggregation of messages.

Broken-by: a5ffa9b475
(cherry picked from commit c09dbcfb71f4b9a42cbfd8a20e0be6bfa1b12488)
(cherry picked from commit 332ebeaf8139b2b75f475880fc14b63c7c45c706)
---
 doc/ChangeLog |  5 +++
 src/tls-openssl.c | 24 ++++++++++----
 test/confs/2152       | 76 +++++++++++++++++++++++++++++++++++++++++++
 test/log/2152         |  9 +++++
 4 files changed, 108 insertions(+), 6 deletions(-)
 create mode 100644 test/confs/2152
 create mode 100644 test/log/2152

--- a/doc/ChangeLog
+++ b/doc/ChangeLog
@@ -34,6 +34,11 @@ JH/08 Add hardening against SRV & TLSA l
 JH/09 Logging: Fix initial listening-on line for multiple ports for an IP when
       the OS reports them interleaved with other addresses.
 
+JH/10 OpenSSL: Fix aggregation of messages.  Previously, when PIPELINING was
+      used both for input and for a verify callout, both encrypted, SMTP
+      responses being sent by the server could be lost.  This resulted in
+      dropped connections and sometimes bounces generated by a peer sending
+      to this system.
 
 
 Exim version 4.92
--- a/src/tls-openssl.c
+++ b/src/tls-openssl.c
@@ -274,6 +274,7 @@ Server:
 typedef struct {
   SSL_CTX *	ctx;
   SSL *		ssl;
+  gstring *	corked;
 } exim_openssl_client_tls_ctx;
 
 static SSL_CTX *server_ctx = NULL;
@@ -2473,6 +2474,7 @@ BOOL require_ocsp = FALSE;
 rc = store_pool;
 store_pool = POOL_PERM;
 exim_client_ctx = store_get(sizeof(exim_openssl_client_tls_ctx));
+exim_client_ctx->corked = NULL;
 store_pool = rc;
 
 #ifdef SUPPORT_DANE
@@ -2908,8 +2910,12 @@ int
 tls_write(void * ct_ctx, const uschar *buff, size_t len, BOOL more)
 {
 int outbytes, error, left;
-SSL * ssl = ct_ctx ? ((exim_openssl_client_tls_ctx *)ct_ctx)->ssl : server_ssl;
-static gstring * corked = NULL;
+SSL * ssl = ct_ctx
+  ? ((exim_openssl_client_tls_ctx *)ct_ctx)->ssl : server_ssl;
+static gstring * server_corked = NULL;
+gstring ** corkedp = ct_ctx
+  ? &((exim_openssl_client_tls_ctx *)ct_ctx)->corked : &server_corked;
+gstring * corked = *corkedp;
 
 DEBUG(D_tls) debug_printf("%s(%p, %lu%s)\n", __FUNCTION__,
   buff, (unsigned long)len, more ? ", more" : "");
@@ -2917,9 +2923,12 @@ DEBUG(D_tls) debug_printf("%s(%p, %lu%s)
 /* Lacking a CORK or MSG_MORE facility (such as GnuTLS has) we copy data when
 "more" is notified.  This hack is only ok if small amounts are involved AND only
 one stream does it, in one context (i.e. no store reset).  Currently it is used
-for the responses to the received SMTP MAIL , RCPT, DATA sequence, only. */
-/*XXX + if PIPE_COMMAND, banner & ehlo-resp for smmtp-on-connect. Suspect there's
-a store reset there. */
+for the responses to the received SMTP MAIL , RCPT, DATA sequence, only.
+We support callouts done by the server process by using a separate client
+context for the stashed information. */
+/* + if PIPE_COMMAND, banner & ehlo-resp for smmtp-on-connect. Suspect there's
+a store reset there, so use POOL_PERM. */
+/* + if CHUNKING, cmds EHLO,MAIL,RCPT(s),BDAT */
 
 if (!ct_ctx && (more || corked))
   {
@@ -2935,10 +2944,13 @@ if (!ct_ctx && (more || corked))
 #endif
 
   if (more)
+    {
+    *corkedp = corked;
     return len;
+    }
   buff = CUS corked->s;
   len = corked->ptr;
-  corked = NULL;
+  *corkedp = NULL;
   }
 
 for (left = len; left > 0;)
