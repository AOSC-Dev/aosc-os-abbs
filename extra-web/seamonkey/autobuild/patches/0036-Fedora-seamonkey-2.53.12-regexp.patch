diff -Nrup mozilla/.clang-format-ignore mozilla-OK/.clang-format-ignore
--- mozilla/.clang-format-ignore	2022-04-13 21:14:20.000000000 +0300
+++ mozilla-OK/.clang-format-ignore	2022-04-22 05:08:04.448366199 +0300
@@ -134,3 +134,7 @@ toolkit/components/jsoncpp/.*
 toolkit/components/protobuf/.*
 toolkit/crashreporter/google-breakpad/.*
 tools/fuzzing/libfuzzer.*
+
+# Don't want to reformat irregexp (third-party code)
+js/src/irregexp/imported/.*
+
diff -Nrup mozilla/config/system-headers.mozbuild mozilla-OK/config/system-headers.mozbuild
--- mozilla/config/system-headers.mozbuild	2022-04-22 04:47:49.105904658 +0300
+++ mozilla-OK/config/system-headers.mozbuild	2022-04-22 05:08:52.055032516 +0300
@@ -1349,6 +1349,7 @@ if CONFIG['MOZ_SYSTEM_ICU']:
         'unicode/udatpg.h',
         'unicode/udisplaycontext.h',
         'unicode/uenum.h',
+        'unicode/uniset.h',
         'unicode/unistr.h',
         'unicode/unorm.h',
         'unicode/unum.h',
diff -Nrup mozilla/dom/base/nsContentUtils.cpp mozilla-OK/dom/base/nsContentUtils.cpp
--- mozilla/dom/base/nsContentUtils.cpp	2022-04-13 21:14:21.000000000 +0300
+++ mozilla-OK/dom/base/nsContentUtils.cpp	2022-04-22 05:04:28.935876755 +0300
@@ -20,6 +20,7 @@
 #include "imgRequestProxy.h"
 #include "jsapi.h"
 #include "jsfriendapi.h"
+#include "js/RegExp.h"
 #include "js/Value.h"
 #include "Layers.h"
 #include "nsAppRunner.h"
@@ -7159,28 +7160,17 @@ nsContentUtils::FindInternalContentViewe
 }
 
 static void
-ReportPatternCompileFailure(nsAString& aPattern, nsIDocument* aDocument,
+ReportPatternCompileFailure(nsAString& aPattern,
+                            nsIDocument* aDocument,
+                            JS::MutableHandle<JS::Value> error,
                             JSContext* cx)
 {
-    MOZ_ASSERT(JS_IsExceptionPending(cx));
-
-    JS::RootedValue exn(cx);
-    if (!JS_GetPendingException(cx, &exn)) {
-      return;
-    }
-    if (!exn.isObject()) {
-      // If pending exception is not an object, it should be OOM.
-      return;
-    }
-
     JS::AutoSaveExceptionState savedExc(cx);
-    JS::RootedObject exnObj(cx, &exn.toObject());
+    JS::RootedObject exnObj(cx, &error.toObject());
     JS::RootedValue messageVal(cx);
     if (!JS_GetProperty(cx, exnObj, "message", &messageVal)) {
       return;
     }
-    MOZ_ASSERT(messageVal.isString());
-
     JS::RootedString messageStr(cx, messageVal.toString());
     MOZ_ASSERT(messageStr);
 
@@ -7214,25 +7204,36 @@ nsContentUtils::IsPatternMatching(nsAStr
   // regexp evaluation, not actual script execution.
   JSAutoCompartment ac(cx, xpc::UnprivilegedJunkScope());
 
+  // Check if the pattern by itself is valid first, and not that it only becomes
+  // valid once we add ^(?: and )$.
+  JS::RootedValue error(cx);
+  if (!JS::CheckRegExpSyntax(
+          cx, static_cast<char16_t*>(aPattern.BeginWriting()),
+          aPattern.Length(), JS::RegExpFlag::Unicode, &error)) {
+    return true;
+  }
+
+  if (!error.isUndefined()) {
+    ReportPatternCompileFailure(aPattern, aDocument, &error, cx);
+    return true;
+  }
+
   // The pattern has to match the entire value.
   aPattern.InsertLiteral(u"^(?:", 0);
   aPattern.AppendLiteral(")$");
 
   JS::Rooted<JSObject*> re(cx,
-    JS_NewUCRegExpObject(cx,
+    JS::NewUCRegExpObject(cx,
                          static_cast<char16_t*>(aPattern.BeginWriting()),
-                         aPattern.Length(), JSREG_UNICODE));
+                         aPattern.Length(), JS::RegExpFlag::Unicode));
+
   if (!re) {
-    // Remove extra patterns added above to report with the original pattern.
-    aPattern.Cut(0, 4);
-    aPattern.Cut(aPattern.Length() - 2, 2);
-    ReportPatternCompileFailure(aPattern, aDocument, cx);
     return true;
   }
 
   JS::Rooted<JS::Value> rval(cx, JS::NullValue());
   size_t idx = 0;
-  if (!JS_ExecuteRegExpNoStatics(cx, re,
+  if (!JS::ExecuteRegExpNoStatics(cx, re,
                                  static_cast<char16_t*>(aValue.BeginWriting()),
                                  aValue.Length(), &idx, true, &rval)) {
     return true;
diff -Nrup mozilla/js/ipc/WrapperAnswer.cpp mozilla-OK/js/ipc/WrapperAnswer.cpp
--- mozilla/js/ipc/WrapperAnswer.cpp	2020-02-18 02:37:52.000000000 +0300
+++ mozilla-OK/js/ipc/WrapperAnswer.cpp	2022-04-22 05:03:52.023135483 +0300
@@ -12,6 +12,7 @@
 #include "mozilla/dom/ScriptSettings.h"
 #include "xpcprivate.h"
 #include "js/Class.h"
+#include "js/RegExp.h"
 #include "jsfriendapi.h"
 
 using namespace JS;
@@ -686,7 +687,7 @@ WrapperAnswer::RecvRegExpToShared(const
     if (!obj)
         return deadCPOW(jsapi, rs);
 
-    RootedString sourceJSStr(cx, JS_GetRegExpSource(cx, obj));
+    RootedString sourceJSStr(cx, JS::GetRegExpSource(cx, obj));
     if (!sourceJSStr)
         return fail(jsapi, rs);
     nsAutoJSString sourceStr;
@@ -694,7 +695,7 @@ WrapperAnswer::RecvRegExpToShared(const
         return fail(jsapi, rs);
     source->Assign(sourceStr);
 
-    *flags = JS_GetRegExpFlags(cx, obj);
+    *flags = JS::GetRegExpFlags(cx, obj).value();
 
     return ok(rs);
 }
diff -Nrup mozilla/js/ipc/WrapperOwner.cpp mozilla-OK/js/ipc/WrapperOwner.cpp
--- mozilla/js/ipc/WrapperOwner.cpp	2021-03-01 21:17:56.000000000 +0300
+++ mozilla-OK/js/ipc/WrapperOwner.cpp	2022-04-22 05:03:52.024135476 +0300
@@ -11,6 +11,8 @@
 #include "mozilla/dom/BindingUtils.h"
 #include "jsfriendapi.h"
 #include "js/CharacterEncoding.h"
+#include "js/RegExp.h"
+#include "js/RegExpFlags.h"
 #include "xpcprivate.h"
 #include "CPOWTimer.h"
 #include "WrapperFactory.h"
@@ -877,7 +879,8 @@ WrapperOwner::regexp_toShared(JSContext*
         return nullptr;
 
     RootedObject regexp(cx);
-    regexp = JS_NewUCRegExpObject(cx, source.get(), source.Length(), flags);
+    regexp = JS::NewUCRegExpObject(
+      cx, source.get(), source.Length(), RegExpFlags(flags));
     if (!regexp)
         return nullptr;
 
diff -Nrup mozilla/js/moz.configure mozilla-OK/js/moz.configure
--- mozilla/js/moz.configure	2021-10-26 19:49:54.000000000 +0300
+++ mozilla-OK/js/moz.configure	2022-04-22 05:05:37.995392727 +0300
@@ -427,16 +427,3 @@ def enable_pipeline_operator(value):
 
 set_config('ENABLE_PIPELINE_OPERATOR', enable_pipeline_operator)
 set_define('ENABLE_PIPELINE_OPERATOR', enable_pipeline_operator)
-
-# Initial support for new regexp engine
-# ==================================================
-
-js_option('--enable-new-regexp', default=False, help='Enable new regexp engine')
-
-@depends('--enable-new-regexp')
-def enable_new_regexp(value):
-    if value:
-        return True
-
-set_config('ENABLE_NEW_REGEXP', enable_new_regexp)
-set_define('ENABLE_NEW_REGEXP', enable_new_regexp)
diff -Nrup mozilla/js/public/Class.h mozilla-OK/js/public/Class.h
--- mozilla/js/public/Class.h	2022-01-25 01:04:25.000000000 +0300
+++ mozilla-OK/js/public/Class.h	2022-04-22 05:05:32.275432809 +0300
@@ -851,7 +851,7 @@ static const uint32_t JSCLASS_FOREGROUND
 // application.
 static const uint32_t JSCLASS_GLOBAL_APPLICATION_SLOTS = 5;
 static const uint32_t JSCLASS_GLOBAL_SLOT_COUNT =
-    JSCLASS_GLOBAL_APPLICATION_SLOTS + JSProto_LIMIT * 2 + 39;
+    JSCLASS_GLOBAL_APPLICATION_SLOTS + JSProto_LIMIT * 2 + 40;
 
 #define JSCLASS_GLOBAL_FLAGS_WITH_SLOTS(n)                              \
     (JSCLASS_IS_GLOBAL | JSCLASS_HAS_RESERVED_SLOTS(JSCLASS_GLOBAL_SLOT_COUNT + (n)))
diff -Nrup mozilla/js/public/RegExp.h mozilla-OK/js/public/RegExp.h
--- mozilla/js/public/RegExp.h	1970-01-01 03:00:00.000000000 +0300
+++ mozilla-OK/js/public/RegExp.h	2022-04-22 05:04:28.931876783 +0300
@@ -0,0 +1,107 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ *
+ * This Source Code Form is "Incompatible With Secondary Licenses", as
+ * defined by the Mozilla Public License, v. 2.0.
+ */
+
+/* Public JS API for Regular Expressions. */
+
+#ifndef js_RegExp_h
+#define js_RegExp_h
+
+#include <stddef.h> // size_t
+
+#include "jstypes.h" // JS_PUBLIC_API
+
+#include "js/RegExpFlags.h"  // JS::RegExpFlags
+#include "js/RootingAPI.h" // JS::{,Mutable}Handle
+#include "js/Value.h"      // JS::Value
+
+struct JSContext;
+class JSString;
+
+namespace JS {
+
+/*
+ * Create a new RegExp for the given Latin-1-encoded source and flags.
+ */
+extern JS_PUBLIC_API(JSObject*) NewRegExpObject(JSContext* cx,
+                                                const char* bytes,
+                                                size_t length,
+                                                RegExpFlags flags);
+
+/*
+ * Create a new RegExp for the given UC source and flags.
+ */
+extern JS_PUBLIC_API(JSObject*) NewUCRegExpObject(JSContext* cx,
+                                                  const char16_t* chars,
+                                                  size_t length,
+                                                  RegExpFlags flags);
+
+extern JS_PUBLIC_API(bool)
+  SetRegExpInput(JSContext* cx, Handle<JSObject*> obj, Handle<JSString*> input);
+
+extern JS_PUBLIC_API(bool)
+  ClearRegExpStatics(JSContext* cx, Handle<JSObject*> obj);
+
+/* RegExp interface for callers with a global object. */
+
+extern JS_PUBLIC_API(bool) ExecuteRegExp(JSContext* cx,
+                                         Handle<JSObject*> obj,
+                                         Handle<JSObject*> reobj,
+                                         char16_t* chars,
+                                         size_t length,
+                                         size_t* indexp,
+                                         bool test,
+                                         MutableHandle<Value> rval);
+
+/* RegExp interface for callers without a global object. */
+
+extern JS_PUBLIC_API(bool) ExecuteRegExpNoStatics(JSContext* cx,
+                                                  Handle<JSObject*> reobj,
+                                                  char16_t* chars,
+                                                  size_t length,
+                                                  size_t* indexp,
+                                                  bool test,
+                                                  MutableHandle<Value> rval);
+
+/*
+ * Returns true on success, setting |*isRegExp| to true if |obj| is a RegExp
+ * object or a wrapper around one, or to false if not. Returns false on failure.
+ *
+ * This method returns true with |*isRegExp == false| when passed an ES6 proxy
+ * whose target is a RegExp, or when passed a revoked proxy.
+ */
+extern JS_PUBLIC_API(bool)
+  ObjectIsRegExp(JSContext* cx, Handle<JSObject*> obj, bool* isRegExp);
+
+/*
+ * Given a RegExp object (or a wrapper around one), return all JS::RegExpFlag::* for it.
+ */
+extern JS_PUBLIC_API(RegExpFlags)
+  GetRegExpFlags(JSContext* cx, Handle<JSObject*> obj);
+
+/*
+ * Return the source text for a RegExp object (or a wrapper around one), or null on failure.
+ */
+extern JS_PUBLIC_API(JSString*)
+  GetRegExpSource(JSContext* cx, Handle<JSObject*> obj);
+
+/**
+ * Check whether the given source is a valid regexp. If the regexp parses
+ * successfully, returns true and sets |error| to undefined. If the regexp
+ * has a syntax error, returns true, sets |error| to that error object, and
+ * clears the exception. Returns false on OOM or over-recursion.
+ */
+extern JS_PUBLIC_API(bool) CheckRegExpSyntax(JSContext* cx,
+                                             const char16_t* chars,
+                                             size_t length,
+                                             RegExpFlags flags,
+                                             MutableHandle<Value> error);
+
+} // namespace JS
+
+#endif // js_RegExp_h
diff -Nrup mozilla/js/public/RegExpFlags.h mozilla-OK/js/public/RegExpFlags.h
--- mozilla/js/public/RegExpFlags.h	1970-01-01 03:00:00.000000000 +0300
+++ mozilla-OK/js/public/RegExpFlags.h	2022-04-22 05:04:15.963967677 +0300
@@ -0,0 +1,171 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ *
+ * This Source Code Form is "Incompatible With Secondary Licenses", as
+ * defined by the Mozilla Public License, v. 2.0.
+ */
+
+/* Regular Expression flags. */
+
+#ifndef js_RegExpFlags_h
+#define js_RegExpFlags_h
+
+#include "mozilla/Assertions.h" // for MOZ_ASSERT
+#include "mozilla/Attributes.h" // for MOZ_IMPLICIT
+#include <stdint.h>
+
+namespace JS {
+
+/*
+ * Regular Expression flag values, suitable for initializing a collection of
+ * regular expression flags as defined below in |RegExpFlags|.
+ * Flags are listed in alphabetical order by syntax: /g, /i, /m, /s, /u, /y.
+ */
+
+class RegExpFlag
+{
+  // WARNING TO SPIDERMONKEY HACKERS (embedders must assume these values can change):
+  //
+  // Flag-bit values appear in XDR and structured clone data formats, so none of
+  // these values can be changed (including to assign values in numerically
+  // ascending order) unless you also add a translation layer.
+public:
+  /**
+   * Act globally and find *all* matches (rather than stopping after just the
+   * first one), i.e. /g.
+   */
+  static uint8_t const Global = 0x02;
+
+  /**
+   * Interpret regular expression source text case-insensitively by folding
+   * uppercase letters to lowercase, i.e. /i.
+   */
+  static uint8_t const IgnoreCase = 0x01;
+
+  /** Treat ^ and $ as begin and end of line, i.e. /m. */
+  static uint8_t const Multiline = 0x04;
+
+  /** Match '.' to any character including newlines, i.e. /s. */
+  static uint8_t const DotAll = 0x20;
+
+  /** Use Unicode semantics, i.e. /u. */
+  static uint8_t const Unicode = 0x10;
+
+  /** Only match starting from <regular expression>.lastIndex, i.e. /y. */
+  static uint8_t const Sticky = 0x08;
+
+  /** No regular expression flags. */
+  static uint8_t const NoFlags = 0x00;
+
+  /** All regular expression flags. */
+  static uint8_t const AllFlags = 0x3F; //All supported bits set: 0b11'1111
+};
+
+/*
+ * A collection of regular expression flags.  Individual flag values may be
+ * combined into a collection using bitwise operators.
+ */
+class RegExpFlags
+{
+public:
+  using Flag = uint8_t;
+
+private:
+  Flag flags_;
+
+public:
+  RegExpFlags() = default;
+
+  MOZ_IMPLICIT RegExpFlags(Flag flags)
+    : flags_(flags)
+  {
+    MOZ_ASSERT((flags & RegExpFlag::AllFlags) == flags,
+               "flags must not contain unrecognized flags");
+  }
+
+  RegExpFlags(const RegExpFlags&) = default;
+
+  bool operator==(const RegExpFlags& other) const
+  {
+    return flags_ == other.flags_;
+  }
+
+  bool operator!=(const RegExpFlags& other) const { return !(*this == other); }
+
+  RegExpFlags& operator&=(const RegExpFlags& rhs)
+  {
+    flags_ &= rhs.flags_;
+    return *this;
+  }
+
+  RegExpFlags& operator|=(const RegExpFlags& rhs)
+  {
+    flags_ |= rhs.flags_;
+    return *this;
+  }
+
+  RegExpFlags operator&(Flag flag) const { return RegExpFlags(flags_ & flag); }
+
+  RegExpFlags operator|(Flag flag) const { return RegExpFlags(flags_ | flag); }
+
+  RegExpFlags operator^(Flag flag) const { return RegExpFlags(flags_ ^ flag); }
+
+  RegExpFlags operator~() const
+  {
+    return RegExpFlags(~flags_ & RegExpFlag::AllFlags);
+  }
+
+  bool global() const { return flags_ & RegExpFlag::Global; }
+  bool ignoreCase() const { return flags_ & RegExpFlag::IgnoreCase; }
+  bool multiline() const { return flags_ & RegExpFlag::Multiline; }
+  bool dotAll() const { return flags_ & RegExpFlag::DotAll; }
+  bool unicode() const { return flags_ & RegExpFlag::Unicode; }
+  bool sticky() const { return flags_ & RegExpFlag::Sticky; }
+
+  explicit operator bool() const { return flags_ != 0; }
+
+  Flag value() const { return flags_; }
+};
+
+inline RegExpFlags&
+operator&=(RegExpFlags& flags, RegExpFlags::Flag flag)
+{
+  flags = flags & flag;
+  return flags;
+}
+
+inline RegExpFlags&
+operator|=(RegExpFlags& flags, RegExpFlags::Flag flag)
+{
+  flags = flags | flag;
+  return flags;
+}
+
+inline RegExpFlags&
+operator^=(RegExpFlags& flags, RegExpFlags::Flag flag)
+{
+  flags = flags ^ flag;
+  return flags;
+}
+
+inline RegExpFlags
+operator&(const RegExpFlags& lhs, const RegExpFlags& rhs)
+{
+  RegExpFlags result = lhs;
+  result &= rhs;
+  return lhs;
+}
+
+inline RegExpFlags
+operator|(const RegExpFlags& lhs, const RegExpFlags& rhs)
+{
+  RegExpFlags result = lhs;
+  result |= rhs;
+  return result;
+}
+
+} // namespace JS
+
+#endif // js_RegExpFlags_h
diff -Nrup mozilla/js/public/Value.h mozilla-OK/js/public/Value.h
--- mozilla/js/public/Value.h	2021-10-26 19:49:54.000000000 +0300
+++ mozilla-OK/js/public/Value.h	2022-04-22 05:04:24.556907460 +0300
@@ -691,7 +691,7 @@ class MOZ_NON_PARAM alignas(8) Value
         return data.s.payload.u32;
     }
 
-    uint64_t asRawBits() const {
+    constexpr uint64_t asRawBits() const {
         return data.asBits;
     }
 
diff -Nrup mozilla/js/src/.clang-format mozilla-OK/js/src/.clang-format
--- mozilla/js/src/.clang-format	2020-02-18 02:37:52.000000000 +0300
+++ mozilla-OK/js/src/.clang-format	1970-01-01 03:00:00.000000000 +0300
@@ -1,10 +0,0 @@
-# Clang-format style for SpiderMonkey code which is different than the standard Mozilla style.
-BasedOnStyle: Mozilla
-ColumnLimit: 99
-IndentWidth: 4
-
-# Ignore all comments because they aren't reflowed properly.
-# We require 80-col comments and 99-col code.
-CommentPragmas: "^"
-
-SortIncludes: false
diff -Nrup mozilla/js/src/builtin/RegExp.cpp mozilla-OK/js/src/builtin/RegExp.cpp
--- mozilla/js/src/builtin/RegExp.cpp	2022-04-13 21:14:22.000000000 +0300
+++ mozilla-OK/js/src/builtin/RegExp.cpp	2022-04-22 05:08:24.530225405 +0300
@@ -6,14 +6,17 @@
 
 #include "builtin/RegExp.h"
 
+#include "mozilla/Casting.h"
 #include "mozilla/CheckedInt.h"
 #include "mozilla/TypeTraits.h"
 
 #include "jscntxt.h"
 
 #include "frontend/TokenStream.h"
-#include "irregexp/RegExpParser.h"
+#include "irregexp/RegExpAPI.h"
 #include "jit/InlinableNatives.h"
+#include "js/RegExpFlags.h"  // JS::RegExpFlag, JS::RegExpFlags
+#include "vm/NativeObject-inl.h"
 #include "vm/RegExpStatics.h"
 #include "vm/SelfHosting.h"
 #include "vm/StringBuffer.h"
@@ -28,17 +31,25 @@ using namespace js;
 using namespace js::unicode;
 
 using mozilla::ArrayLength;
+using mozilla::AssertedCast;
 using mozilla::CheckedInt;
 using mozilla::Maybe;
 
+using JS::RegExpFlag;
+using JS::RegExpFlags;
+
 /*
- * ES 2017 draft rev 6a13789aa9e7c6de4e96b7d3e24d9e6eba6584ad 21.2.5.2.2
- * steps 3, 16-25.
+ * ES 2021 draft 21.2.5.2.2: Steps 16-28
+ * https://tc39.es/ecma262/#sec-regexpbuiltinexec
  */
 bool
-js::CreateRegExpMatchResult(JSContext* cx, HandleString input, const MatchPairs& matches,
+js::CreateRegExpMatchResult(JSContext* cx,
+                            HandleRegExpShared re,
+                            HandleString input,
+                            const MatchPairs& matches,
                             MutableHandleValue rval)
 {
+    MOZ_ASSERT(re);
     MOZ_ASSERT(input);
 
     /*
@@ -49,23 +60,42 @@ js::CreateRegExpMatchResult(JSContext* c
      *  1..pairCount-1: paren matches
      *  input:          input string
      *  index:          start index for the match
+     *  groups:         named capture groups for the match
      */
 
     /* Get the templateObject that defines the shape and type of the output object */
     JSObject* templateObject = cx->compartment()->regExps.getOrCreateMatchResultTemplateObject(cx);
-    if (!templateObject)
+    if (!templateObject) {
         return false;
+    }
 
+    // Step 16
     size_t numPairs = matches.length();
     MOZ_ASSERT(numPairs > 0);
 
-    /* Step 17. */
+    // Steps 18-19
     RootedArrayObject arr(cx, NewDenseFullyAllocatedArrayWithTemplate(cx, numPairs, templateObject));
-    if (!arr)
+    if (!arr) {
         return false;
+    }
 
-    /* Steps 22-24.
-     * Store a Value for each pair. */
+    // Step 24 (reordered)
+    RootedNativeObject groups(cx);
+    bool groupsInDictionaryMode = false;
+    if (re->numNamedCaptures() > 0) {
+        RootedNativeObject groupsTemplate(cx, re->getGroupsTemplate());
+        if (groupsTemplate->inDictionaryMode()) {
+            groups = NewObjectWithGivenProto<PlainObject>(cx, nullptr);
+            groups->setGroup(groupsTemplate->group());
+            groupsInDictionaryMode = true;
+        } else {
+            JS_TRY_VAR_OR_RETURN_FALSE(
+              cx, groups, NativeObject::createWithTemplate(cx, gc::DefaultHeap, groupsTemplate));
+        }
+    }
+
+    // Steps 22-23 and 27 a-e.
+    // Store a Value for each pair.
     for (size_t i = 0; i < numPairs; i++) {
         const MatchPair& pair = matches[i];
 
@@ -82,6 +112,36 @@ js::CreateRegExpMatchResult(JSContext* c
         }
     }
 
+    // Step 27 f.
+    // The groups template object stores the names of the named captures in the
+    // the order in which they are defined. The named capture indices vector
+    // stores the corresponding capture indices. If we are not in dictionary mode,
+    // we simply fill in the slots with the correct values. In dictionary mode,
+    // we have to define the properties explicitly.
+    if (!groupsInDictionaryMode) {
+        for (uint32_t i = 0; i < re->numNamedCaptures(); i++) {
+            uint32_t idx = re->getNamedCaptureIndex(i);
+            groups->setSlot(i, arr->getDenseElement(idx));
+        }
+    } else {
+        AutoIdVector keys(cx);
+        RootedPlainObject groupsTemplate(cx, re->getGroupsTemplate());
+        if (!GetPropertyKeys(cx, groupsTemplate, 0, &keys)) {
+            return false;
+        }
+        MOZ_ASSERT(keys.length() == re->numNamedCaptures());
+        RootedId key(cx);
+        RootedValue val(cx);
+        for (uint32_t i = 0; i < keys.length(); i++) {
+            key = keys[i];
+            uint32_t idx = re->getNamedCaptureIndex(i);
+            val = arr->getDenseElement(idx);
+            if (!NativeDefineProperty(cx, groups, key, val, nullptr, nullptr, JSPROP_ENUMERATE)) {
+                return false;
+            }
+        }
+    }
+
     /* Step 20 (reordered).
      * Set the |index| property. (TemplateObject positions it in slot 0) */
     arr->setSlot(0, Int32Value(matches[0].start));
@@ -90,6 +150,10 @@ js::CreateRegExpMatchResult(JSContext* c
      * Set the |input| property. (TemplateObject positions it in slot 1) */
     arr->setSlot(1, StringValue(input));
 
+    // Steps 25-26 (reordered)
+    // Set the |groups| property.
+    arr->setSlot(2, groups ? ObjectValue(*groups) : UndefinedValue());
+
 #ifdef DEBUG
     RootedValue test(cx);
     RootedId id(cx, NameToId(cx->names().index));
@@ -102,7 +166,7 @@ js::CreateRegExpMatchResult(JSContext* c
     MOZ_ASSERT(test == arr->getSlot(1));
 #endif
 
-    /* Step 25. */
+    // Step 28.
     rval.setObject(*arr);
     return true;
 }
@@ -123,19 +187,19 @@ CreateRegExpSearchResult(const MatchPair
  * steps 3, 9-14, except 12.a.i, 12.c.i.1.
  */
 static RegExpRunStatus
-ExecuteRegExpImpl(JSContext* cx, RegExpStatics* res, MutableHandleRegExpShared re,
-                  HandleLinearString input, size_t searchIndex, MatchPairs* matches,
-                  size_t* endIndex)
+ExecuteRegExpImpl(JSContext* cx,
+                  RegExpStatics* res,
+                  MutableHandleRegExpShared re,
+                  HandleLinearString input,
+                  size_t searchIndex,
+                  MatchPairs* matches)
 {
-    RegExpRunStatus status = RegExpShared::execute(cx, re, input, searchIndex, matches, endIndex);
+    RegExpRunStatus status = RegExpShared::execute(cx, re, input, searchIndex, matches);
 
     /* Out of spec: Update RegExpStatics. */
     if (status == RegExpRunStatus_Success && res) {
-        if (matches) {
-            if (!res->updateFromMatchPairs(cx, input, *matches))
-                return RegExpRunStatus_Error;
-        } else {
-            res->updateLazily(cx, input, re, searchIndex);
+        if (!res->updateFromMatchPairs(cx, input, *matches)) {
+            return RegExpRunStatus_Error;
         }
     }
     return status;
@@ -154,7 +218,7 @@ js::ExecuteRegExpLegacy(JSContext* cx, R
     ScopedMatchPairs matches(&cx->tempLifoAlloc());
 
     RegExpRunStatus status = ExecuteRegExpImpl(cx, res, &shared, input, *lastIndex,
-                                               &matches, nullptr);
+                                               &matches);
     if (status == RegExpRunStatus_Error)
         return false;
 
@@ -172,22 +236,42 @@ js::ExecuteRegExpLegacy(JSContext* cx, R
         return true;
     }
 
-    return CreateRegExpMatchResult(cx, input, matches, rval);
+    return CreateRegExpMatchResult(cx, shared, input, matches, rval);
 }
 
 static bool
-CheckPatternSyntax(JSContext* cx, HandleAtom pattern, RegExpFlag flags)
+CheckPatternSyntaxSlow(JSContext* cx, HandleAtom pattern, RegExpFlags flags)
 {
     CompileOptions options(cx);
     frontend::TokenStream dummyTokenStream(cx, options, nullptr, 0, nullptr);
-    return irregexp::ParsePatternSyntax(dummyTokenStream, cx->tempLifoAlloc(), pattern,
-                                        flags & UnicodeFlag);
+    return irregexp::CheckPatternSyntax(cx, dummyTokenStream, pattern, flags);
 }
 
-enum RegExpSharedUse {
-    UseRegExpShared,
-    DontUseRegExpShared
-};
+static RegExpShared*
+CheckPatternSyntax(JSContext* cx, HandleAtom pattern, RegExpFlags flags)
+{
+    // If we already have a RegExpShared for this pattern/flags, we can
+    // avoid the much slower CheckPatternSyntaxSlow call.
+
+    RootedRegExpShared shared(cx, cx->zone()->regExps.maybeGet(pattern, flags));
+    if (shared) {
+#ifdef DEBUG
+        // Assert the pattern is valid.
+        if (!CheckPatternSyntaxSlow(cx, pattern, flags)) {
+            MOZ_ASSERT(cx->isThrowingOutOfMemory() || cx->isThrowingOverRecursed());
+            return nullptr;
+        }
+#endif
+        return shared;
+    }
+
+    if (!CheckPatternSyntaxSlow(cx, pattern, flags))
+        return nullptr;
+
+    // Allocate and return a new RegExpShared so we will hit the fast path
+    // next time.
+    return cx->zone()->regExps.get(cx, pattern, flags);
+}
 
 /*
  * ES 2016 draft Mar 25, 2016 21.2.3.2.2.
@@ -206,8 +290,7 @@ enum RegExpSharedUse {
  */
 static bool
 RegExpInitializeIgnoringLastIndex(JSContext* cx, Handle<RegExpObject*> obj,
-                                  HandleValue patternValue, HandleValue flagsValue,
-                                  RegExpSharedUse sharedUse = DontUseRegExpShared)
+                                  HandleValue patternValue, HandleValue flagsValue)
 {
     RootedAtom pattern(cx);
     if (patternValue.isUndefined()) {
@@ -221,7 +304,7 @@ RegExpInitializeIgnoringLastIndex(JSCont
     }
 
     /* Step 3. */
-    RegExpFlag flags = RegExpFlag(0);
+    RegExpFlags flags = RegExpFlag::NoFlags;
     if (!flagsValue.isUndefined()) {
         /* Step 4. */
         RootedString flagStr(cx, ToString<CanGC>(cx, flagsValue));
@@ -233,24 +316,15 @@ RegExpInitializeIgnoringLastIndex(JSCont
             return false;
     }
 
-    if (sharedUse == UseRegExpShared) {
-        /* Steps 7-8. */
-        RegExpShared* re = cx->zone()->regExps.get(cx, pattern, flags);
-        if (!re)
-            return false;
-
-        /* Steps 9-12. */
-        obj->initIgnoringLastIndex(pattern, flags);
+    /* Steps 7-8. */
+    RegExpShared* shared = CheckPatternSyntax(cx, pattern, flags);
+    if (!shared)
+        return false;
 
-        obj->setShared(*re);
-    } else {
-        /* Steps 7-8. */
-        if (!CheckPatternSyntax(cx, pattern, flags))
-            return false;
+    /* Steps 9-12. */
+    obj->initIgnoringLastIndex(pattern, flags);
 
-        /* Steps 9-12. */
-        obj->initIgnoringLastIndex(pattern, flags);
-    }
+    obj->setShared(*shared);
 
     return true;
 }
@@ -266,7 +340,7 @@ js::RegExpCreate(JSContext* cx, HandleVa
          return false;
 
     /* Step 2. */
-    if (!RegExpInitializeIgnoringLastIndex(cx, regexp, patternValue, flagsValue, UseRegExpShared))
+    if (!RegExpInitializeIgnoringLastIndex(cx, regexp, patternValue, flagsValue))
         return false;
     regexp->zeroLastIndex(cx);
 
@@ -333,12 +407,11 @@ regexp_compile_impl(JSContext* cx, const
         }
 
         // Beware!  |patternObj| might be a proxy into another compartment, so
-        // don't assume |patternObj.is<RegExpObject>()|.  For the same reason,
-        // don't reuse the RegExpShared below.
+        // don't assume |patternObj.is<RegExpObject>()|.
         RootedObject patternObj(cx, &patternValue.toObject());
 
         RootedAtom sourceAtom(cx);
-        RegExpFlag flags;
+        RegExpFlags flags = RegExpFlag::NoFlags;
         {
             // Step 3b.
             RegExpShared* shared = RegExpToShared(cx, patternObj);
@@ -428,15 +501,15 @@ js::regexp_construct(JSContext* cx, unsi
         return false;
     if (cls == ESClass::RegExp) {
         // Beware!  |patternObj| might be a proxy into another compartment, so
-        // don't assume |patternObj.is<RegExpObject>()|.  For the same reason,
-        // don't reuse the RegExpShared below.
+        // don't assume |patternObj.is<RegExpObject>()|.
         RootedObject patternObj(cx, &patternValue.toObject());
 
         RootedAtom sourceAtom(cx);
-        RegExpFlag flags;
+        RegExpFlags flags;
+        RootedRegExpShared shared(cx);
         {
             // Step 4.a.
-            RegExpShared* shared = RegExpToShared(cx, patternObj);
+            shared = RegExpToShared(cx, patternObj);
             if (!shared)
                 return false;
             sourceAtom = shared->getSource();
@@ -444,6 +517,10 @@ js::regexp_construct(JSContext* cx, unsi
             // Step 4.b.
             // Get original flags in all cases, to compare with passed flags.
             flags = shared->getFlags();
+
+            // If the RegExpShared is in another Zone, don't reuse it.
+            if (cx->zone() != shared->zone())
+                shared = nullptr;
         }
 
         // Step 7.
@@ -458,19 +535,24 @@ js::regexp_construct(JSContext* cx, unsi
         // Step 8.
         if (args.hasDefined(1)) {
             // Step 4.c / 21.2.3.2.2 RegExpInitialize step 4.
-            RegExpFlag flagsArg = RegExpFlag(0);
+            RegExpFlags flagsArg = RegExpFlag::NoFlags;
             RootedString flagStr(cx, ToString<CanGC>(cx, args[1]));
             if (!flagStr)
                 return false;
             if (!ParseRegExpFlags(cx, flagStr, &flagsArg))
                 return false;
 
-            if (!(flags & UnicodeFlag) && flagsArg & UnicodeFlag) {
+            // Don't reuse the RegExpShared if we have different flags.
+            if (flags != flagsArg)
+                shared = nullptr;
+
+            if (!flags.unicode() && flagsArg.unicode()) {
                 // Have to check syntax again when adding 'u' flag.
 
                 // ES 2017 draft rev 9b49a888e9dfe2667008a01b2754c3662059ae56
                 // 21.2.3.2.2 step 7.
-                if (!CheckPatternSyntax(cx, sourceAtom, flagsArg))
+                shared = CheckPatternSyntax(cx, sourceAtom, flagsArg);
+                if (!shared)
                     return false;
             }
             flags = flagsArg;
@@ -478,6 +560,9 @@ js::regexp_construct(JSContext* cx, unsi
 
         regexp->initAndZeroLastIndex(sourceAtom, flags, cx);
 
+        if (shared)
+            regexp->setShared(*shared);
+
         args.rval().setObject(*regexp);
         return true;
     }
@@ -540,7 +625,7 @@ js::regexp_construct_raw_flags(JSContext
         return false;
 
     // Step 4.c.
-    int32_t flags = int32_t(args[1].toNumber());
+    RegExpFlags flags = AssertedCast<uint8_t>(int32_t(args[1].toNumber()));
 
     // Step 7.
     RegExpObject* regexp = RegExpAlloc(cx, GenericObject);
@@ -548,7 +633,7 @@ js::regexp_construct_raw_flags(JSContext
         return false;
 
     // Step 8.
-    regexp->initAndZeroLastIndex(sourceAtom, RegExpFlag(flags), cx);
+    regexp->initAndZeroLastIndex(sourceAtom, flags, cx);
     args.rval().setObject(*regexp);
     return true;
 }
@@ -680,6 +765,33 @@ regexp_source(JSContext* cx, unsigned ar
     return CallNonGenericMethod<IsRegExpObject, regexp_source_impl>(cx, args);
 }
 
+// ES 2018 dotAll
+MOZ_ALWAYS_INLINE bool
+regexp_dotAll_impl(JSContext* cx, const CallArgs& args)
+{
+    MOZ_ASSERT(IsRegExpObject(args.thisv()));
+
+    // Steps 4-6.
+    RegExpObject* reObj = &args.thisv().toObject().as<RegExpObject>();
+    args.rval().setBoolean(reObj->dotAll());
+    return true;
+}
+
+bool
+js::regexp_dotAll(JSContext* cx, unsigned argc, JS::Value* vp)
+{
+    CallArgs args = CallArgsFromVp(argc, vp);
+
+    // Step 3.a.
+    if (IsRegExpPrototype(args.thisv())) {
+        args.rval().setUndefined();
+        return true;
+    }
+
+    // Steps 1-3.
+    return CallNonGenericMethod<IsRegExpObject, regexp_dotAll_impl>(cx, args);
+}
+
 // ES 2017 draft 21.2.5.12.
 MOZ_ALWAYS_INLINE bool
 regexp_sticky_impl(JSContext* cx, const CallArgs& args)
@@ -742,6 +854,7 @@ const JSPropertySpec js::regexp_properti
     JS_PSG("source", regexp_source, 0),
     JS_PSG("sticky", regexp_sticky, 0),
     JS_PSG("unicode", regexp_unicode, 0),
+    JS_PSG("dotAll", regexp_dotAll, 0),
     JS_PS_END
 };
 
@@ -754,6 +867,7 @@ const JSFunctionSpec js::regexp_methods[
     JS_SELF_HOSTED_FN("exec", "RegExp_prototype_Exec", 1,0),
     JS_SELF_HOSTED_FN("test", "RegExpTest" ,    1,0),
     JS_SELF_HOSTED_SYM_FN(match, "RegExpMatch", 1,0),
+    JS_SELF_HOSTED_SYM_FN(matchAll, "RegExpMatchAll", 1, 0),
     JS_SELF_HOSTED_SYM_FN(replace, "RegExpReplace", 2,0),
     JS_SELF_HOSTED_SYM_FN(search, "RegExpSearch", 1,0),
     JS_SELF_HOSTED_SYM_FN(split, "RegExpSplit", 2,0),
@@ -888,7 +1002,7 @@ IsTrailSurrogateWithLeadSurrogate(Handle
  */
 static RegExpRunStatus
 ExecuteRegExp(JSContext* cx, HandleObject regexp, HandleString string, int32_t lastIndex,
-              MatchPairs* matches, size_t* endIndex)
+              MatchPairs* matches)
 {
     /*
      * WARNING: Despite the presence of spec step comment numbers, this
@@ -945,7 +1059,7 @@ ExecuteRegExp(JSContext* cx, HandleObjec
     }
 
     /* Steps 3, 11-14, except 12.a.i, 12.c.i.1. */
-    RegExpRunStatus status = ExecuteRegExpImpl(cx, res, &re, input, lastIndex, matches, endIndex);
+    RegExpRunStatus status = ExecuteRegExpImpl(cx, res, &re, input, lastIndex, matches);
     if (status == RegExpRunStatus_Error)
         return RegExpRunStatus_Error;
 
@@ -966,7 +1080,7 @@ RegExpMatcherImpl(JSContext* cx, HandleO
     ScopedMatchPairs matches(&cx->tempLifoAlloc());
 
     /* Steps 3, 9-14, except 12.a.i, 12.c.i.1. */
-    RegExpRunStatus status = ExecuteRegExp(cx, regexp, string, lastIndex, &matches, nullptr);
+    RegExpRunStatus status = ExecuteRegExp(cx, regexp, string, lastIndex, &matches);
     if (status == RegExpRunStatus_Error)
         return false;
 
@@ -977,7 +1091,8 @@ RegExpMatcherImpl(JSContext* cx, HandleO
     }
 
     /* Steps 16-25 */
-    return CreateRegExpMatchResult(cx, string, matches, rval);
+    RootedRegExpShared shared(cx, regexp->as<RegExpObject>().getShared());
+    return CreateRegExpMatchResult(cx, shared, string, matches, rval);
 }
 
 /*
@@ -1016,8 +1131,11 @@ js::RegExpMatcherRaw(JSContext* cx, Hand
 
     // The MatchPairs will always be passed in, but RegExp execution was
     // successful only if the pairs have actually been filled in.
-    if (maybeMatches && maybeMatches->pairsRaw()[0] >= 0)
-        return CreateRegExpMatchResult(cx, input, *maybeMatches, output);
+    if (maybeMatches && maybeMatches->pairsRaw()[0] >= 0) {
+        RootedRegExpShared shared(cx, regexp->as<RegExpObject>().getShared());
+        return CreateRegExpMatchResult(cx, shared, input, *maybeMatches, output);
+    }
+
     return RegExpMatcherImpl(cx, regexp, input, lastIndex, output);
 }
 
@@ -1035,7 +1153,7 @@ RegExpSearcherImpl(JSContext* cx, Handle
     ScopedMatchPairs matches(&cx->tempLifoAlloc());
 
     /* Steps 3, 9-14, except 12.a.i, 12.c.i.1. */
-    RegExpRunStatus status = ExecuteRegExp(cx, regexp, string, lastIndex, &matches, nullptr);
+    RegExpRunStatus status = ExecuteRegExp(cx, regexp, string, lastIndex, &matches);
     if (status == RegExpRunStatus_Error)
         return false;
 
@@ -1117,15 +1235,15 @@ js::RegExpTester(JSContext* cx, unsigned
     MOZ_ALWAYS_TRUE(ToInt32(cx, args[2], &lastIndex));
 
     /* Steps 3, 9-14, except 12.a.i, 12.c.i.1. */
-    size_t endIndex = 0;
-    RegExpRunStatus status = ExecuteRegExp(cx, regexp, string, lastIndex, nullptr, &endIndex);
+    ScopedMatchPairs matches(&cx->tempLifoAlloc());
+    RegExpRunStatus status = ExecuteRegExp(cx, regexp, string, lastIndex, &matches);
 
     if (status == RegExpRunStatus_Error)
         return false;
 
     if (status == RegExpRunStatus_Success) {
-        MOZ_ASSERT(endIndex <= INT32_MAX);
-        args.rval().setInt32(int32_t(endIndex));
+        int32_t endIndex = matches[0].limit;
+        args.rval().setInt32(endIndex);
     } else {
         args.rval().setInt32(-1);
     }
@@ -1142,12 +1260,11 @@ js::RegExpTesterRaw(JSContext* cx, Handl
 {
     MOZ_ASSERT(lastIndex >= 0);
 
-    size_t endIndexTmp = 0;
-    RegExpRunStatus status = ExecuteRegExp(cx, regexp, input, lastIndex, nullptr, &endIndexTmp);
+    ScopedMatchPairs matches(&cx->tempLifoAlloc());
+    RegExpRunStatus status = ExecuteRegExp(cx, regexp, input, lastIndex, &matches);
 
     if (status == RegExpRunStatus_Success) {
-        MOZ_ASSERT(endIndexTmp <= INT32_MAX);
-        *endIndex = int32_t(endIndexTmp);
+        *endIndex = matches[0].limit;
         return true;
     }
     if (status == RegExpRunStatus_Success_NotFound) {
@@ -1190,13 +1307,21 @@ GetParen(JSLinearString* matched, const
     out->init(&captureLinear, 0, captureLinear.length());
 }
 
-template <typename CharT>
+template<typename CharT>
 static bool
-InterpretDollar(JSLinearString* matched, JSLinearString* string, size_t position, size_t tailPos,
-                Handle<CapturesVector> captures, JSLinearString* replacement,
-                const CharT* replacementBegin, const CharT* currentDollar,
+InterpretDollar(JSLinearString* matched,
+                JSLinearString* string,
+                size_t position,
+                size_t tailPos,
+                Handle<CapturesVector> captures,
+                Handle<CapturesVector> namedCaptures,
+                JSLinearString* replacement,
+                const CharT* replacementBegin,
+                const CharT* currentDollar,
                 const CharT* replacementEnd,
-                JSSubString* out, size_t* skip)
+                JSSubString* out,
+                size_t* skip,
+                uint32_t* currentNamedCapture)
 {
     MOZ_ASSERT(*currentDollar == '$');
 
@@ -1204,13 +1329,14 @@ InterpretDollar(JSLinearString* matched,
     if (currentDollar + 1 >= replacementEnd)
         return false;
 
-    /* ES 2016 draft Mar 25, 2016 Table 46. */
+  // ES 2021 Table 52
+  // https://tc39.es/ecma262/#table-45 (sic)
     char16_t c = currentDollar[1];
     if (JS7_ISDEC(c)) {
         /* $n, $nn */
         unsigned num = JS7_UNDEC(c);
         if (num > captures.length()) {
-            // The result is implementation-defined, do not substitute.
+            // The result is implementation-defined. Do not substitute.
             return false;
         }
 
@@ -1229,8 +1355,7 @@ InterpretDollar(JSLinearString* matched,
         }
 
         if (num == 0) {
-            // The result is implementation-defined.
-            // Do not substitute.
+            // The result is implementation-defined. Do not substitute.
             return false;
         }
 
@@ -1242,7 +1367,35 @@ InterpretDollar(JSLinearString* matched,
         return true;
     }
 
-    *skip = 2;
+  // '$<': Named Captures
+  if (c == '<') {
+    // Step 1.
+    if (namedCaptures.length() == 0) {
+      return false;
+    }
+
+    // Step 2.b
+    const CharT* nameStart = currentDollar + 2;
+    const CharT* nameEnd = js_strchr_limit(nameStart, '>', replacementEnd);
+
+    // Step 2.c
+    if (!nameEnd) {
+      return false;
+    }
+
+    // Step 2.d
+    // We precompute named capture replacements in InitNamedCaptures.
+    // They are stored in the order in which we will need them, so here
+    // we can just take the next one in the list.
+    size_t nameLength = nameEnd - nameStart;
+    *skip = nameLength + 3;  // $<...>
+
+    // Steps 2.d.iii-iv
+    GetParen(matched, namedCaptures[*currentNamedCapture], out);
+    *currentNamedCapture += 1;
+    return true;
+  }
+
     switch (c) {
       default:
         return false;
@@ -1266,14 +1419,23 @@ InterpretDollar(JSLinearString* matched,
         out->init(string, tailPos, string->length() - tailPos);
         break;
     }
+
+    *skip = 2;
     return true;
 }
 
-template <typename CharT>
+template<typename CharT>
 static bool
-FindReplaceLengthString(JSContext* cx, HandleLinearString matched, HandleLinearString string,
-                        size_t position, size_t tailPos, Handle<CapturesVector> captures,
-                        HandleLinearString replacement, size_t firstDollarIndex, size_t* sizep)
+FindReplaceLengthString(JSContext* cx,
+                        HandleLinearString matched,
+                        HandleLinearString string,
+                        size_t position,
+                        size_t tailPos,
+                        Handle<CapturesVector> captures,
+                        Handle<CapturesVector> namedCaptures,
+                        HandleLinearString replacement,
+                        size_t firstDollarIndex,
+                        size_t* sizep)
 {
     CheckedInt<uint32_t> replen = replacement->length();
 
@@ -1282,12 +1444,23 @@ FindReplaceLengthString(JSContext* cx, H
     const CharT* replacementBegin = replacement->chars<CharT>(nogc);
     const CharT* currentDollar = replacementBegin + firstDollarIndex;
     const CharT* replacementEnd = replacementBegin + replacement->length();
+    uint32_t currentNamedCapture = 0;
     do {
         JSSubString sub;
         size_t skip;
-        if (InterpretDollar(matched, string, position, tailPos, captures, replacement,
-                            replacementBegin, currentDollar, replacementEnd, &sub, &skip))
-        {
+        if (InterpretDollar(matched,
+                            string,
+                            position,
+                            tailPos,
+                            captures,
+                            namedCaptures,
+                            replacement,
+                            replacementBegin,
+                            currentDollar,
+                            replacementEnd,
+                            &sub,
+                            &skip,
+                            &currentNamedCapture)) {
             if (sub.length > skip)
                 replen += sub.length - skip;
             else
@@ -1310,15 +1483,37 @@ FindReplaceLengthString(JSContext* cx, H
 }
 
 static bool
-FindReplaceLength(JSContext* cx, HandleLinearString matched, HandleLinearString string,
-                  size_t position, size_t tailPos, Handle<CapturesVector> captures,
-                  HandleLinearString replacement, size_t firstDollarIndex, size_t* sizep)
-{
-    return replacement->hasLatin1Chars()
-           ? FindReplaceLengthString<Latin1Char>(cx, matched, string, position, tailPos, captures,
-                                                 replacement, firstDollarIndex, sizep)
-           : FindReplaceLengthString<char16_t>(cx, matched, string, position, tailPos, captures,
-                                               replacement, firstDollarIndex, sizep);
+FindReplaceLength(JSContext* cx,
+                  HandleLinearString matched,
+                  HandleLinearString string,
+                  size_t position,
+                  size_t tailPos,
+                  Handle<CapturesVector> captures,
+                  Handle<CapturesVector> namedCaptures,
+                  HandleLinearString replacement,
+                  size_t firstDollarIndex,
+                  size_t* sizep)
+{
+    return replacement->hasLatin1Chars() ? FindReplaceLengthString<Latin1Char>(cx,
+                                                                               matched,
+                                                                               string,
+                                                                               position,
+                                                                               tailPos,
+                                                                               captures,
+                                                                               namedCaptures,
+                                                                               replacement,
+                                                                               firstDollarIndex,
+                                                                               sizep)
+                                         : FindReplaceLengthString<char16_t>(cx,
+                                                                             matched,
+                                                                             string,
+                                                                             position,
+                                                                             tailPos,
+                                                                             captures,
+                                                                             namedCaptures,
+                                                                             replacement,
+                                                                             firstDollarIndex,
+                                                                             sizep);
 }
 
 /*
@@ -1326,11 +1521,17 @@ FindReplaceLength(JSContext* cx, HandleL
  * derived from FindReplaceLength), and has been inflated to TwoByte if
  * necessary.
  */
-template <typename CharT>
+template<typename CharT>
 static void
-DoReplace(HandleLinearString matched, HandleLinearString string,
-          size_t position, size_t tailPos, Handle<CapturesVector> captures,
-          HandleLinearString replacement, size_t firstDollarIndex, StringBuffer &sb)
+DoReplace(HandleLinearString matched,
+          HandleLinearString string,
+          size_t position,
+          size_t tailPos,
+          Handle<CapturesVector> captures,
+          Handle<CapturesVector> namedCaptures,
+          HandleLinearString replacement,
+          size_t firstDollarIndex,
+          StringBuffer& sb)
 {
     JS::AutoCheckCannotGC nogc;
     const CharT* replacementBegin = replacement->chars<CharT>(nogc);
@@ -1339,6 +1540,7 @@ DoReplace(HandleLinearString matched, Ha
     MOZ_ASSERT(firstDollarIndex < replacement->length());
     const CharT* currentDollar = replacementBegin + firstDollarIndex;
     const CharT* replacementEnd = replacementBegin + replacement->length();
+    uint32_t currentNamedCapture = 0;
     do {
         /* Move one of the constant portions of the replacement value. */
         size_t len = currentDollar - currentChar;
@@ -1347,9 +1549,19 @@ DoReplace(HandleLinearString matched, Ha
 
         JSSubString sub;
         size_t skip;
-        if (InterpretDollar(matched, string, position, tailPos, captures, replacement,
-                            replacementBegin, currentDollar, replacementEnd, &sub, &skip))
-        {
+        if (InterpretDollar(matched,
+                            string,
+                            position,
+                            tailPos,
+                            captures,
+                            namedCaptures,
+                            replacement,
+                            replacementBegin,
+                            currentDollar,
+                            replacementEnd,
+                            &sub,
+                            &skip,
+                            &currentNamedCapture)) {
             sb.infallibleAppendSubstring(sub.base, sub.offset, sub.length);
             currentChar += skip;
             currentDollar += skip;
@@ -1362,9 +1574,120 @@ DoReplace(HandleLinearString matched, Ha
     sb.infallibleAppend(currentChar, replacement->length() - (currentChar - replacementBegin));
 }
 
+/*
+ * This function finds the list of named captures of the form
+ * "$<name>" in a replacement string and converts them into jsids, for
+ * use in InitNamedReplacements.
+ */
+template <typename CharT>
+static bool CollectNames(JSContext* cx, HandleLinearString replacement,
+                         size_t firstDollarIndex,
+                         MutableHandle<GCVector<jsid>> names) {
+  JS::AutoCheckCannotGC nogc;
+  MOZ_ASSERT(firstDollarIndex < replacement->length());
+
+  const CharT* replacementBegin = replacement->chars<CharT>(nogc);
+  const CharT* currentDollar = replacementBegin + firstDollarIndex;
+  const CharT* replacementEnd = replacementBegin + replacement->length();
+
+  // https://tc39.es/ecma262/#table-45, "$<" section
+  while (currentDollar && currentDollar + 1 < replacementEnd) {
+    if (currentDollar[1] == '<') {
+      // Step 2.b
+      const CharT* nameStart = currentDollar + 2;
+      const CharT* nameEnd = js_strchr_limit(nameStart, '>', replacementEnd);
+
+      // Step 2.c
+      if (!nameEnd) {
+        return true;
+      }
+
+      // Step 2.d.i
+      size_t nameLength = nameEnd - nameStart;
+      JSAtom* atom = AtomizeChars(cx, nameStart, nameLength);
+      if (!atom || !names.append(AtomToId(atom))) {
+        return false;
+      }
+      currentDollar = nameEnd + 1;
+    } else {
+      currentDollar += 2;
+    }
+    currentDollar = js_strchr_limit(currentDollar, '$', replacementEnd);
+  }
+  return true;
+}
+
+/*
+ * When replacing named captures, the spec requires us to perform
+ * `Get(match.groups, name)` for each "$<name>". These `Get`s can be
+ * script-visible; for example, RegExp can be extended with an `exec`
+ * method that wraps `groups` in a proxy. To make sure that we do the
+ * right thing, if a regexp has named captures, we find the named
+ * capture replacements before beginning the actual replacement.
+ * This guarantees that we will call GetProperty once and only once for
+ * each "$<name>" in the replacement string, in the correct order.
+ *
+ * This function precomputes the results of step 2 of the '$<' case
+ * here: https://tc39.es/proposal-regexp-named-groups/#table-45, so
+ * that when we need to access the nth named capture in InterpretDollar,
+ * we can just use the nth value stored in namedCaptures.
+ */
+static bool InitNamedCaptures(JSContext* cx, HandleLinearString replacement,
+                              HandleObject groups, size_t firstDollarIndex,
+                              MutableHandle<CapturesVector> namedCaptures) {
+  Rooted<GCVector<jsid>> names(cx, GCVector<jsid>(cx));
+  if (replacement->hasLatin1Chars()) {
+    if (!CollectNames<Latin1Char>(cx, replacement, firstDollarIndex, &names)) {
+      return false;
+    }
+  } else {
+    if (!CollectNames<char16_t>(cx, replacement, firstDollarIndex, &names)) {
+      return false;
+    }
+  }
+
+  // https://tc39.es/ecma262/#table-45, "$<" section
+  RootedId id(cx);
+  RootedValue capture(cx);
+  for (uint32_t i = 0; i < names.length(); i++) {
+    // Step 2.d.i
+    id = names[i];
+
+    // Step 2.d.ii
+    if (!GetProperty(cx, groups, groups, id, &capture)) {
+      return false;
+    }
+
+    // Step 2.d.iii
+    if (capture.isUndefined()) {
+      if (!namedCaptures.append(capture)) {
+        return false;
+      }
+    } else {
+      // Step 2.d.iv
+      JSString* str = ToString<CanGC>(cx, capture);
+      if (!str) {
+        return false;
+      }
+      JSLinearString* linear = str->ensureLinear(cx);
+      if (!linear) {
+        return false;
+      }
+      if (!namedCaptures.append(StringValue(linear))) {
+        return false;
+      }
+    }
+  }
+
+  return true;
+}
+
 static bool
-NeedTwoBytes(HandleLinearString string, HandleLinearString replacement,
-             HandleLinearString matched, Handle<CapturesVector> captures)
+NeedTwoBytes(HandleLinearString string,
+             HandleLinearString replacement,
+             HandleLinearString matched,
+             Handle<CapturesVector> captures,
+             Handle<CapturesVector> namedCaptures)
 {
     if (string->hasTwoByteChars())
         return true;
@@ -1373,22 +1696,36 @@ NeedTwoBytes(HandleLinearString string,
     if (matched->hasTwoByteChars())
         return true;
 
-    for (size_t i = 0, len = captures.length(); i < len; i++) {
-        const Value& capture = captures[i];
+    for (const Value& capture : captures) {
         if (capture.isUndefined())
             continue;
         if (capture.toString()->hasTwoByteChars())
             return true;
     }
 
+    for (const Value& capture : namedCaptures) {
+        if (capture.isUndefined()) {
+            continue;
+        }
+        if (capture.toString()->hasTwoByteChars()) {
+            return true;
+        }
+    }
+
     return false;
 }
 
-/* ES 2016 draft Mar 25, 2016 21.1.3.14.1. */
+/* ES 2021 21.1.3.17.1 */
+// https://tc39.es/ecma262/#sec-getsubstitution
 bool
-js::RegExpGetSubstitution(JSContext* cx, HandleArrayObject matchResult, HandleLinearString string,
-                          size_t position, HandleLinearString replacement,
-                          size_t firstDollarIndex, MutableHandleValue rval)
+js::RegExpGetSubstitution(JSContext* cx,
+                          HandleArrayObject matchResult,
+                          HandleLinearString string,
+                          size_t position,
+                          HandleLinearString replacement,
+                          size_t firstDollarIndex,
+                          HandleValue groups,
+                          MutableHandleValue rval)
 {
     MOZ_ASSERT(firstDollarIndex < replacement->length());
 
@@ -1432,6 +1769,16 @@ js::RegExpGetSubstitution(JSContext* cx,
         captures.infallibleAppend(StringValue(captureLinear));
     }
 
+    Rooted<CapturesVector> namedCaptures(cx, CapturesVector(cx));
+    if (groups.isObject()) {
+        RootedObject groupsObj(cx, &groups.toObject());
+        if (!InitNamedCaptures(cx, replacement, groupsObj, firstDollarIndex, &namedCaptures)) {
+            return false;
+        }
+    } else {
+        MOZ_ASSERT(groups.isUndefined());
+    }
+
     // Step 8 (skipped).
 
     // Step 9.
@@ -1446,27 +1793,36 @@ js::RegExpGetSubstitution(JSContext* cx,
 
     // Step 11.
     size_t reserveLength;
-    if (!FindReplaceLength(cx, matched, string, position, tailPos, captures, replacement,
-                           firstDollarIndex, &reserveLength))
-    {
+    if (!FindReplaceLength(cx,
+                           matched,
+                           string,
+                           position,
+                           tailPos,
+                           captures,
+                           namedCaptures,
+                           replacement,
+                           firstDollarIndex,
+                           &reserveLength)) {
         return false;
     }
 
     StringBuffer result(cx);
-    if (NeedTwoBytes(string, replacement, matched, captures)) {
-        if (!result.ensureTwoByteChars())
+    if (NeedTwoBytes(string, replacement, matched, captures, namedCaptures)) {
+        if (!result.ensureTwoByteChars()) {
             return false;
+        }
     }
 
-    if (!result.reserve(reserveLength))
+    if (!result.reserve(reserveLength)) {
         return false;
+    }
 
     if (replacement->hasLatin1Chars()) {
         DoReplace<Latin1Char>(matched, string, position, tailPos, captures,
-                              replacement, firstDollarIndex, result);
+                              namedCaptures, replacement, firstDollarIndex, result);
     } else {
         DoReplace<char16_t>(matched, string, position, tailPos, captures,
-                            replacement, firstDollarIndex, result);
+                            namedCaptures, replacement, firstDollarIndex, result);
     }
 
     // Step 12.
@@ -1601,6 +1957,13 @@ js::RegExpPrototypeOptimizableRaw(JSCont
     if (unicodeGetter != regexp_unicode)
         return false;
 
+    JSNative dotAllGetter;
+    if (!GetOwnNativeGetterPure(cx, proto, NameToId(cx->names().dotAll), &dotAllGetter))
+        return false;
+
+    if (dotAllGetter != regexp_dotAll)
+        return false;
+
     // Check if @@match, @@search, and exec are own data properties,
     // those values should be tested in selfhosted JS.
     bool has = false;
diff -Nrup mozilla/js/src/builtin/RegExp.h mozilla-OK/js/src/builtin/RegExp.h
--- mozilla/js/src/builtin/RegExp.h	2021-10-26 19:49:54.000000000 +0300
+++ mozilla-OK/js/src/builtin/RegExp.h	2022-04-22 05:04:44.735766010 +0300
@@ -33,7 +33,10 @@ ExecuteRegExpLegacy(JSContext* cx, RegEx
 
 /* Translation from MatchPairs to a JS array in regexp_exec()'s output format. */
 MOZ_MUST_USE bool
-CreateRegExpMatchResult(JSContext* cx, HandleString input, const MatchPairs& matches,
+CreateRegExpMatchResult(JSContext* cx,
+                        HandleRegExpShared re,
+                        HandleString input,
+                        const MatchPairs& matches,
                         MutableHandleValue rval);
 
 extern MOZ_MUST_USE bool
@@ -100,7 +103,7 @@ RegExpInstanceOptimizableRaw(JSContext*
 extern MOZ_MUST_USE bool
 RegExpGetSubstitution(JSContext* cx, HandleArrayObject matchResult, HandleLinearString string,
                       size_t position, HandleLinearString replacement, size_t firstDollarIndex,
-                      MutableHandleValue rval);
+                      HandleValue namedCaptures, MutableHandleValue rval);
 
 extern MOZ_MUST_USE bool
 GetFirstDollarIndex(JSContext* cx, unsigned argc, Value* vp);
@@ -129,6 +132,8 @@ extern MOZ_MUST_USE bool
 regexp_sticky(JSContext* cx, unsigned argc, JS::Value* vp);
 extern MOZ_MUST_USE bool
 regexp_unicode(JSContext* cx, unsigned argc, JS::Value* vp);
+extern MOZ_MUST_USE bool
+regexp_dotAll(JSContext* cx, unsigned argc, JS::Value* vp);
 
 } /* namespace js */
 
diff -Nrup mozilla/js/src/builtin/RegExp.js mozilla-OK/js/src/builtin/RegExp.js
--- mozilla/js/src/builtin/RegExp.js	2021-05-25 21:33:37.000000000 +0300
+++ mozilla-OK/js/src/builtin/RegExp.js	2022-04-22 05:08:33.241164354 +0300
@@ -2,7 +2,8 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
-// ES6 draft rev34 (2015/02/20) 21.2.5.3 get RegExp.prototype.flags
+// ECMAScript 2020 draft (2020/03/12) 21.2.5.4 get RegExp.prototype.flags
+// https://tc39.es/ecma262/#sec-get-regexp.prototype.flags
 function RegExpFlagsGetter() {
     // Steps 1-2.
     var R = this;
@@ -12,27 +13,31 @@ function RegExpFlagsGetter() {
     // Step 3.
     var result = "";
 
-    // Steps 4-6.
+    // Steps 4-5.
     if (R.global)
         result += "g";
 
-    // Steps 7-9.
+    // Steps 6-7.
     if (R.ignoreCase)
         result += "i";
 
-    // Steps 10-12.
+    // Steps 8-9.
     if (R.multiline)
         result += "m";
 
-    // Steps 13-15.
+    // Steps 10-11.
+    if (R.dotAll)
+        result += "s";
+
+    // Steps 12-13.
     if (R.unicode)
          result += "u";
 
-    // Steps 16-18.
+    // Steps 14-15.
     if (R.sticky)
         result += "y";
 
-    // Step 19.
+    // Step 16.
     return result;
 }
 _SetCanonicalName(RegExpFlagsGetter, "get flags");
@@ -225,6 +230,7 @@ function RegExpGlobalMatchOpt(rx, S, ful
 //   * global
 //   * ignoreCase
 //   * multiline
+//   * dotAll
 //   * sticky
 //   * unicode
 //   * exec
@@ -389,7 +395,7 @@ function RegExpReplaceSlowPath(rx, S, le
 
         var n, capN, replacement;
         if (functionalReplace || firstDollarIndex !== -1) {
-            // Steps 14.g-j.
+            // Steps 14.g-k.
             replacement = RegExpGetComplexReplacement(result, matched, S, position,
                                                       nCaptures, replaceValue,
                                                       functionalReplace, firstDollarIndex);
@@ -404,16 +410,22 @@ function RegExpReplaceSlowPath(rx, S, le
                 if (capN !== undefined)
                     ToString(capN);
             }
+            // Step 14.j, 14.l., GetSubstitution Step 11.
+            // We don't need namedCaptures, but ToObject is visible to script.
+            var namedCaptures = result.groups;
+            if (namedCaptures !== undefined)
+                ToObject(namedCaptures);
+
             replacement = replaceValue;
         }
 
-        // Step 14.l.
+        // Step 14.m.
         if (position >= nextSourcePosition) {
-            // Step 14.l.ii.
+            // Step 14.m.ii.
             accumulatedResult += Substring(S, nextSourcePosition,
                                            position - nextSourcePosition) + replacement;
 
-            // Step 14.l.iii.
+            // Step 14.m.iii.
             nextSourcePosition = position + matchLength;
         }
     }
@@ -426,8 +438,9 @@ function RegExpReplaceSlowPath(rx, S, le
     return accumulatedResult + Substring(S, nextSourcePosition, lengthS - nextSourcePosition);
 }
 
-// ES 2017 draft rev 03bfda119d060aca4099d2b77cf43f6d4f11cfa2 21.2.5.8
-// steps 14.g-k.
+// ES 2021 draft 21.2.5.10
+// https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
+// steps 14.g-l.
 // Calculates functional/substitution replacement from match result.
 // Used in the following functions:
 //   * RegExpReplaceSlowPath
@@ -439,7 +452,7 @@ function RegExpGetComplexReplacement(res
     var captures = [];
     var capturesLength = 0;
 
-    // Step 14.j.i (reordered).
+    // Step 14.k.i (reordered).
     _DefineDataProperty(captures, capturesLength++, matched);
 
     // Step 14.g, 14.i, 14.i.iv.
@@ -456,34 +469,46 @@ function RegExpGetComplexReplacement(res
     }
 
     // Step 14.j.
+    var namedCaptures = result.groups;
+
+    // Step 14.k.
     if (functionalReplace) {
         // For `nCaptures` <= 4 case, call `replaceValue` directly, otherwise
         // use `std_Function_apply` with all arguments stored in `captures`.
-        switch (nCaptures) {
-          case 0:
-            return ToString(replaceValue(SPREAD(captures, 1), position, S));
-          case 1:
-            return ToString(replaceValue(SPREAD(captures, 2), position, S));
-          case 2:
-            return ToString(replaceValue(SPREAD(captures, 3), position, S));
-          case 3:
-            return ToString(replaceValue(SPREAD(captures, 4), position, S));
-          case 4:
-            return ToString(replaceValue(SPREAD(captures, 5), position, S));
-          default:
-            // Steps 14.j.ii-v.
-            _DefineDataProperty(captures, capturesLength++, position);
-            _DefineDataProperty(captures, capturesLength++, S);
-            return ToString(callFunction(std_Function_apply, replaceValue, undefined, captures));
+        if (namedCaptures === undefined) {
+            switch (nCaptures) {
+              case 0:
+                return ToString(replaceValue(SPREAD(captures, 1), position, S));
+              case 1:
+                return ToString(replaceValue(SPREAD(captures, 2), position, S));
+              case 2:
+                return ToString(replaceValue(SPREAD(captures, 3), position, S));
+              case 3:
+                return ToString(replaceValue(SPREAD(captures, 4), position, S));
+              case 4:
+                return ToString(replaceValue(SPREAD(captures, 5), position, S));
+            }
         }
+        // Steps 14.k.ii-v.
+        _DefineDataProperty(captures, capturesLength++, position);
+        _DefineDataProperty(captures, capturesLength++, S);
+        if (namedCaptures !== undefined) {
+            _DefineDataProperty(captures, capturesLength++, namedCaptures);
+        }
+        return ToString(callFunction(std_Function_apply, replaceValue, undefined, captures));
     }
 
-    // Steps 14.k.i.
-    return RegExpGetSubstitution(captures, S, position, replaceValue, firstDollarIndex);
+    // Step 14.l.
+    if (namedCaptures !== undefined) {
+        namedCaptures = ToObject(namedCaptures);
+    }
+    return RegExpGetSubstitution(captures, S, position, replaceValue, firstDollarIndex,
+                                 namedCaptures);
 }
 
-// ES 2017 draft rev 03bfda119d060aca4099d2b77cf43f6d4f11cfa2 21.2.5.8
-// steps 14.g-j.
+// ES 2021 draft 21.2.5.10
+// https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
+// steps 14.g-k.
 // Calculates functional replacement from match result.
 // Used in the following functions:
 //   * RegExpGlobalReplaceOptFunc
@@ -495,20 +520,25 @@ function RegExpGetFunctionalReplacement(
     assert(result.length >= 1, "RegExpMatcher doesn't return an empty array");
     var nCaptures = result.length - 1;
 
-    switch (nCaptures) {
-      case 0:
-        return ToString(replaceValue(SPREAD(result, 1), position, S));
-      case 1:
-        return ToString(replaceValue(SPREAD(result, 2), position, S));
-      case 2:
-        return ToString(replaceValue(SPREAD(result, 3), position, S));
-      case 3:
-        return ToString(replaceValue(SPREAD(result, 4), position, S));
-      case 4:
-        return ToString(replaceValue(SPREAD(result, 5), position, S));
+    // Step 14.j (reordered)
+    var namedCaptures = result.groups;
+
+    if (namedCaptures === undefined) {
+        switch (nCaptures) {
+          case 0:
+            return ToString(replaceValue(SPREAD(result, 1), position, S));
+          case 1:
+            return ToString(replaceValue(SPREAD(result, 2), position, S));
+          case 2:
+            return ToString(replaceValue(SPREAD(result, 3), position, S));
+          case 3:
+            return ToString(replaceValue(SPREAD(result, 4), position, S));
+          case 4:
+            return ToString(replaceValue(SPREAD(result, 5), position, S));
+        }
     }
 
-    // Steps 14.g-i, 14.j.i-ii.
+    // Steps 14.g-i, 14.k.i-ii.
     var captures = [];
     for (var n = 0; n <= nCaptures; n++) {
         assert(typeof result[n] === "string" || result[n] === undefined,
@@ -516,11 +546,16 @@ function RegExpGetFunctionalReplacement(
         _DefineDataProperty(captures, n, result[n]);
     }
 
-    // Step 14.j.iii.
+    // Step 14.k.iii.
     _DefineDataProperty(captures, nCaptures + 1, position);
     _DefineDataProperty(captures, nCaptures + 2, S);
 
-    // Steps 14.j.iv-v.
+    // Step 14.k.iv.
+    if (namedCaptures !== undefined) {
+        _DefineDataProperty(captures, nCaptures + 3, namedCaptures);
+    }
+
+    // Steps 14.k.v-vi.
     return ToString(callFunction(std_Function_apply, replaceValue, undefined, captures));
 }
 
@@ -975,7 +1010,7 @@ function RegExpExec(R, S, forTest) {
     var result = callContentFunction(exec, R, S);
 
     // Step 5.c.
-    if (typeof result !== "object")
+    if (result !== null && !IsObject(result))
         ThrowTypeError(JSMSG_EXEC_NOT_OBJORNULL);
 
     // Step 5.d.
@@ -1095,3 +1130,235 @@ function RegExpSpecies() {
     return this;
 }
 _SetCanonicalName(RegExpSpecies, "get [Symbol.species]");
+
+function IsRegExpMatchAllOptimizable(rx, C) {
+    if (!IsRegExpObject(rx))
+        return false;
+
+    var RegExpCtor = GetBuiltinConstructor("RegExp");
+    if (C !== RegExpCtor)
+        return false;
+
+    var RegExpProto = RegExpCtor.prototype;
+    return RegExpPrototypeOptimizable(RegExpProto) &&
+           RegExpInstanceOptimizable(rx, RegExpProto);
+}
+
+// String.prototype.matchAll proposal.
+//
+// RegExp.prototype [ @@matchAll ] ( string )
+function RegExpMatchAll(string) {
+    // Step 1.
+    var rx = this;
+
+    // Step 2.
+    if (!IsObject(rx))
+        ThrowTypeError(JSMSG_NOT_NONNULL_OBJECT, rx === null ? "null" : typeof rx);
+
+    // Step 3.
+    var str = ToString(string);
+
+    // Step 4.
+    var C = SpeciesConstructor(rx, GetBuiltinConstructor("RegExp"));
+
+    var source, flags, matcher, lastIndex;
+    if (IsRegExpMatchAllOptimizable(rx, C)) {
+        // Step 5, 9-12.
+        source = UnsafeGetStringFromReservedSlot(rx, REGEXP_SOURCE_SLOT);
+        flags = UnsafeGetInt32FromReservedSlot(rx, REGEXP_FLAGS_SLOT);
+
+        // Step 6.
+        matcher = rx;
+
+        // Step 7.
+        lastIndex = ToLength(rx.lastIndex);
+
+        // Step 8 (not applicable for the optimized path).
+    } else {
+        // Step 5.
+        source = "";
+        flags = ToString(rx.flags);
+
+        // Step 6.
+        matcher = new C(rx, flags);
+
+        // Steps 7-8.
+        matcher.lastIndex = ToLength(rx.lastIndex);
+
+        // Steps 9-12.
+        flags = (callFunction(std_String_includes, flags, "g") ? REGEXP_GLOBAL_FLAG : 0);
+// XXXX                (callFunction(std_String_includes, flags, "u") ? REGEXP_UNICODE_FLAG : 0);
+
+        // Take the non-optimized path.
+        lastIndex = REGEXP_STRING_ITERATOR_LASTINDEX_SLOW;
+    }
+
+    // Step 13.
+    return CreateRegExpStringIterator(matcher, str, source, flags, lastIndex);
+}
+
+// String.prototype.matchAll proposal.
+//
+// CreateRegExpStringIterator ( R, S, global, fullUnicode )
+function CreateRegExpStringIterator(regexp, string, source, flags, lastIndex) {
+    // Step 1.
+    assert(typeof string === "string", "|string| is a string value");
+
+    // Steps 2-3.
+    assert(typeof flags === "number", "|flags| is a number value");
+
+    assert(typeof source === "string", "|source| is a string value");
+    assert(typeof lastIndex === "number", "|lastIndex| is a number value");
+
+    // Steps 4-9.
+    var iterator = NewRegExpStringIterator();
+    UnsafeSetReservedSlot(iterator, REGEXP_STRING_ITERATOR_REGEXP_SLOT, regexp);
+    UnsafeSetReservedSlot(iterator, REGEXP_STRING_ITERATOR_STRING_SLOT, string);
+    UnsafeSetReservedSlot(iterator, REGEXP_STRING_ITERATOR_SOURCE_SLOT, source);
+    UnsafeSetReservedSlot(iterator, REGEXP_STRING_ITERATOR_FLAGS_SLOT, flags | 0);
+    UnsafeSetReservedSlot(iterator, REGEXP_STRING_ITERATOR_LASTINDEX_SLOT, lastIndex);
+
+    // Step 10.
+    return iterator;
+}
+
+function IsRegExpStringIteratorNextOptimizable() {
+    var RegExpProto = GetBuiltinPrototype("RegExp");
+    // If RegExpPrototypeOptimizable succeeds, `RegExpProto.exec` is
+    // guaranteed to be a data property.
+    return RegExpPrototypeOptimizable(RegExpProto) &&
+           RegExpProto.exec === RegExp_prototype_Exec;
+}
+
+// String.prototype.matchAll proposal.
+//
+// %RegExpStringIteratorPrototype%.next ( )
+function RegExpStringIteratorNext() {
+    // Steps 1-3.
+    if (!IsObject(this) || !GuardToRegExpStringIterator(this)) {
+        return callFunction(CallRegExpStringIteratorMethodIfWrapped, this,
+                            "RegExpStringIteratorNext");
+    }
+
+    var result = { value: undefined, done: false };
+
+    // Step 4.
+    var lastIndex = UnsafeGetReservedSlot(this, REGEXP_STRING_ITERATOR_LASTINDEX_SLOT);
+    if (lastIndex === REGEXP_STRING_ITERATOR_LASTINDEX_DONE) {
+        result.done = true;
+        return result;
+    }
+
+    // Step 5.
+    var regexp = UnsafeGetObjectFromReservedSlot(this, REGEXP_STRING_ITERATOR_REGEXP_SLOT);
+
+    // Step 6.
+    var string = UnsafeGetStringFromReservedSlot(this, REGEXP_STRING_ITERATOR_STRING_SLOT);
+
+    // Steps 7-8.
+    var flags = UnsafeGetInt32FromReservedSlot(this, REGEXP_STRING_ITERATOR_FLAGS_SLOT);
+    var global = !!(flags & REGEXP_GLOBAL_FLAG);
+    var fullUnicode = !!(flags & REGEXP_UNICODE_FLAG);
+
+    if (lastIndex >= 0) {
+        assert(IsRegExpObject(regexp), "|regexp| is a RegExp object");
+
+        var source = UnsafeGetStringFromReservedSlot(this, REGEXP_STRING_ITERATOR_SOURCE_SLOT);
+        if (IsRegExpStringIteratorNextOptimizable() &&
+            UnsafeGetStringFromReservedSlot(regexp, REGEXP_SOURCE_SLOT) === source &&
+            UnsafeGetInt32FromReservedSlot(regexp, REGEXP_FLAGS_SLOT) === flags)
+        {
+            // Step 9 (Inlined RegExpBuiltinExec).
+            var globalOrSticky = !!(flags & (REGEXP_GLOBAL_FLAG | REGEXP_STICKY_FLAG));
+            if (!globalOrSticky)
+                lastIndex = 0;
+
+            var match = (lastIndex <= string.length)
+                        ? RegExpMatcher(regexp, string, lastIndex)
+                        : null;
+
+            // Step 10.
+            if (match === null) {
+                // Step 10.a.
+                UnsafeSetReservedSlot(this, REGEXP_STRING_ITERATOR_LASTINDEX_SLOT,
+                                      REGEXP_STRING_ITERATOR_LASTINDEX_DONE);
+
+                // Step 10.b.
+                result.done = true;
+                return result;
+            }
+
+            // Step 11.a.
+            if (global) {
+                // Step 11.a.i.
+                var matchLength = match[0].length;
+                lastIndex = match.index + matchLength;
+
+                // Step 11.a.ii.
+                if (matchLength === 0) {
+                    // Steps 11.a.ii.1-3.
+                    lastIndex = fullUnicode ? AdvanceStringIndex(string, lastIndex) : lastIndex + 1;
+                }
+
+                UnsafeSetReservedSlot(this, REGEXP_STRING_ITERATOR_LASTINDEX_SLOT, lastIndex);
+            } else {
+                // Step 11.b.i.
+                UnsafeSetReservedSlot(this, REGEXP_STRING_ITERATOR_LASTINDEX_SLOT,
+                                      REGEXP_STRING_ITERATOR_LASTINDEX_DONE);
+            }
+
+            // Steps 11.a.iii and 11.b.ii.
+            result.value = match;
+            return result;
+        }
+
+        // Reify the RegExp object.
+        regexp = regexp_construct_raw_flags(source, flags);
+        regexp.lastIndex = lastIndex;
+        UnsafeSetReservedSlot(this, REGEXP_STRING_ITERATOR_REGEXP_SLOT, regexp);
+
+        // Mark the iterator as no longer optimizable.
+        UnsafeSetReservedSlot(this, REGEXP_STRING_ITERATOR_LASTINDEX_SLOT,
+                              REGEXP_STRING_ITERATOR_LASTINDEX_SLOW);
+    }
+
+    // Step 9.
+    var match = RegExpExec(regexp, string, false);
+
+    // Step 10.
+    if (match === null) {
+        // Step 10.a.
+        UnsafeSetReservedSlot(this, REGEXP_STRING_ITERATOR_LASTINDEX_SLOT,
+                              REGEXP_STRING_ITERATOR_LASTINDEX_DONE);
+
+        // Step 10.b.
+        result.done = true;
+        return result;
+    }
+
+    // Step 11.a.
+    if (global) {
+        // Step 11.a.i.
+        var matchStr = ToString(match[0]);
+
+        // Step 11.a.ii.
+        if (matchStr.length === 0) {
+            // Step 11.a.ii.1.
+            var thisIndex = ToLength(regexp.lastIndex);
+
+            // Step 11.a.ii.2.
+            var nextIndex = fullUnicode ? AdvanceStringIndex(string, thisIndex) : thisIndex + 1;
+
+            // Step 11.a.ii.3.
+            regexp.lastIndex = nextIndex;
+        }
+    } else {
+        // Step 11.b.i.
+        UnsafeSetReservedSlot(this, REGEXP_STRING_ITERATOR_LASTINDEX_SLOT,
+                              REGEXP_STRING_ITERATOR_LASTINDEX_DONE);
+    }
+
+    // Steps 11.a.iii and 11.b.ii.
+    result.value = match;
+    return result;
+}
diff -Nrup mozilla/js/src/builtin/RegExpGlobalReplaceOpt.h.js mozilla-OK/js/src/builtin/RegExpGlobalReplaceOpt.h.js
--- mozilla/js/src/builtin/RegExpGlobalReplaceOpt.h.js	2021-05-25 21:33:37.000000000 +0300
+++ mozilla-OK/js/src/builtin/RegExpGlobalReplaceOpt.h.js	2022-04-22 05:04:44.750765905 +0300
@@ -69,12 +69,19 @@ function FUNC_NAME(rx, S, lengthS, repla
         var position = result.index | 0;
         lastIndex = position + matchLength;
 
-        // Steps g-k.
+        // Steps g-l.
         var replacement;
 #if defined(FUNCTIONAL)
         replacement = RegExpGetFunctionalReplacement(result, S, position, replaceValue);
 #elif defined(SUBSTITUTION)
-        replacement = RegExpGetSubstitution(result, S, position, replaceValue, firstDollarIndex);
+        // Step l.i
+        var namedCaptures = result.groups;
+        if (namedCaptures !== undefined) {
+            namedCaptures = ToObject(namedCaptures);
+        }
+        // Step l.ii
+        replacement = RegExpGetSubstitution(result, S, position, replaceValue,
+                                            firstDollarIndex, namedCaptures);
 #elif defined(ELEMBASE)
         if (IsObject(elemBase)) {
             var prop = GetStringDataProperty(elemBase, matched);
@@ -93,11 +100,11 @@ function FUNC_NAME(rx, S, lengthS, repla
         replacement = replaceValue;
 #endif
 
-        // Step 14.l.ii.
+        // Step 14.m.ii.
         accumulatedResult += Substring(S, nextSourcePosition,
                                        position - nextSourcePosition) + replacement;
 
-        // Step 14.l.iii.
+        // Step 14.m.iii.
         nextSourcePosition = lastIndex;
 
         // Step 11.c.iii.2.
diff -Nrup mozilla/js/src/builtin/RegExpLocalReplaceOpt.h.js mozilla-OK/js/src/builtin/RegExpLocalReplaceOpt.h.js
--- mozilla/js/src/builtin/RegExpLocalReplaceOpt.h.js	2021-05-25 21:33:37.000000000 +0300
+++ mozilla-OK/js/src/builtin/RegExpLocalReplaceOpt.h.js	2022-04-22 05:04:44.753765883 +0300
@@ -91,7 +91,7 @@ function FUNC_NAME(rx, S, lengthS, repla
     // Step 14.e-f.
     var position = result.index;
 
-    // Step 14.l.iii (reordered)
+    // Step 14.m.iii (reordered)
     // To set rx.lastIndex before RegExpGetFunctionalReplacement.
     var nextSourcePosition = position + matchLength;
 #else
@@ -109,16 +109,23 @@ function FUNC_NAME(rx, S, lengthS, repla
        rx.lastIndex = nextSourcePosition;
 
     var replacement;
-    // Steps g-j.
+    // Steps g-l.
 #if defined(FUNCTIONAL)
     replacement = RegExpGetFunctionalReplacement(result, S, position, replaceValue);
 #elif defined(SUBSTITUTION)
-    replacement = RegExpGetSubstitution(result, S, position, replaceValue, firstDollarIndex);
+    // Step l.i
+    var namedCaptures = result.groups;
+    if (namedCaptures !== undefined) {
+        namedCaptures = ToObject(namedCaptures);
+    }
+    // Step l.ii
+    replacement = RegExpGetSubstitution(result, S, position, replaceValue, firstDollarIndex,
+                                        namedCaptures);
 #else
     replacement = replaceValue;
 #endif
 
-    // Step 14.l.ii.
+    // Step 14.m.ii.
     var accumulatedResult = Substring(S, 0, position) + replacement;
 
     // Step 15.
diff -Nrup mozilla/js/src/builtin/SelfHostingDefines.h mozilla-OK/js/src/builtin/SelfHostingDefines.h
--- mozilla/js/src/builtin/SelfHostingDefines.h	2021-10-26 19:49:54.000000000 +0300
+++ mozilla-OK/js/src/builtin/SelfHostingDefines.h	2022-04-22 05:05:32.277432795 +0300
@@ -99,6 +99,16 @@
 #define REGEXP_MULTILINE_FLAG   0x04
 #define REGEXP_STICKY_FLAG      0x08
 #define REGEXP_UNICODE_FLAG     0x10
+#define REGEXP_DOTALL_FLAG      0x20
+
+#define REGEXP_STRING_ITERATOR_REGEXP_SLOT 0
+#define REGEXP_STRING_ITERATOR_STRING_SLOT 1
+#define REGEXP_STRING_ITERATOR_SOURCE_SLOT 2
+#define REGEXP_STRING_ITERATOR_FLAGS_SLOT 3
+#define REGEXP_STRING_ITERATOR_LASTINDEX_SLOT 4
+
+#define REGEXP_STRING_ITERATOR_LASTINDEX_DONE -1
+#define REGEXP_STRING_ITERATOR_LASTINDEX_SLOW -2
 
 #define MODULE_OBJECT_ENVIRONMENT_SLOT        1
 #define MODULE_OBJECT_STATUS_SLOT             3
diff -Nrup mozilla/js/src/builtin/String.js mozilla-OK/js/src/builtin/String.js
--- mozilla/js/src/builtin/String.js	2022-02-20 18:39:44.000000000 +0300
+++ mozilla-OK/js/src/builtin/String.js	2022-04-22 05:05:35.300411588 +0300
@@ -62,6 +62,49 @@ function String_generic_match(thisValue,
     return callFunction(String_match, thisValue, regexp);
 }
 
+// String.prototype.matchAll proposal.
+//
+// String.prototype.matchAll ( regexp )
+function String_matchAll(regexp) {
+    // Step 1.
+    RequireObjectCoercible(this);
+
+    // Step 2.
+    if (regexp !== undefined && regexp !== null) {
+        // Steps 2.a-b.
+        if (IsRegExp(regexp)) {
+            // Step 2.b.i.
+            var flags = regexp.flags;
+
+            // Step 2.b.ii.
+            if (flags === undefined || flags === null) {
+                ThrowTypeError(JSMSG_FLAGS_UNDEFINED_OR_NULL);
+            }
+
+            // Step 2.b.iii.
+            if (!callFunction(std_String_includes, ToString(flags), "g")) {
+                ThrowTypeError(JSMSG_REQUIRES_GLOBAL_REGEXP, "matchAll");
+            }
+        }
+
+        // Step 2.c.
+        var matcher = GetMethod(regexp, std_matchAll);
+
+        // Step 2.d.
+        if (matcher !== undefined)
+            return callContentFunction(matcher, regexp, this);
+    }
+
+    // Step 3.
+    var string = ToString(this);
+
+    // Step 4.
+    var rx = RegExpCreate(regexp, "g");
+
+    // Step 5.
+    return callContentFunction(GetMethod(rx, std_matchAll), rx, string);
+}
+
 /**
  * A helper function implementing the logic for both String.prototype.padStart
  * and String.prototype.padEnd as described in ES7 Draft March 29, 2016
@@ -792,57 +835,53 @@ function String_toLocaleUpperCase() {
     return intl_toLocaleUpperCase(string, requestedLocale);
 }
 
-/* ES6 Draft May 22, 2014 21.1.2.4 */
-function String_static_raw(callSite, ...substitutions) {
-    // Step 1 (implicit).
-    // Step 2.
-    var numberOfSubstitutions = substitutions.length;
+// ES2018 draft rev 8fadde42cf6a9879b4ab0cb6142b31c4ee501667
+// 21.1.2.4 String.raw ( template, ...substitutions )
+function String_static_raw(callSite/*, ...substitutions*/) {
+    // Steps 1-2 (not applicable).
 
-    // Steps 3-4.
+    // Step 3.
     var cooked = ToObject(callSite);
 
-    // Steps 5-7.
+    // Step 4.
     var raw = ToObject(cooked.raw);
 
-    // Steps 8-10.
+    // Step 5.
     var literalSegments = ToLength(raw.length);
 
-    // Step 11.
-    if (literalSegments <= 0)
+    // Step 6.
+    if (literalSegments === 0)
         return "";
 
-    // Step 12.
-    var resultString = "";
-
-    // Step 13.
-    var nextIndex = 0;
-
-    // Step 14.
-    while (true) {
-        // Steps a-d.
-        var nextSeg = ToString(raw[nextIndex]);
-
-        // Step e.
-        resultString = resultString + nextSeg;
-
-        // Step f.
-        if (nextIndex + 1 === literalSegments)
-            // Step f.i.
-            return resultString;
-
-        // Steps g-j.
-        var nextSub;
-        if (nextIndex < numberOfSubstitutions)
-            nextSub = ToString(substitutions[nextIndex]);
-        else
-            nextSub = "";
-
-        // Step k.
-        resultString = resultString + nextSub;
+    // Special case for |String.raw `<literal>`| callers to avoid falling into
+    // the loop code below.
+    if (literalSegments === 1)
+        return ToString(raw[0]);
+
+    // Steps 7-9 were reordered to use the arguments object instead of a rest
+    // parameter, because the former is currently more optimized.
+    //
+    // String.raw intersperses the substitution elements between the literal
+    // segments, i.e. a substitution is added iff there are still pending
+    // literal segments. Furthermore by moving the access to |raw[0]| outside
+    // of the loop, we can use |nextIndex| to index into both, the |raw| array
+    // and the arguments object.
+
+    // Steps 7 (implicit) and 9.a-c.
+    var resultString = ToString(raw[0]);
+
+    // Steps 8-9, 9.d, and 9.i.
+    for (var nextIndex = 1; nextIndex < literalSegments; nextIndex++) {
+        // Steps 9.e-h.
+        if (nextIndex < arguments.length)
+            resultString += ToString(arguments[nextIndex]);
 
-        // Step l.
-        nextIndex++;
+        // Steps 9.a-c.
+        resultString += ToString(raw[nextIndex]);
     }
+
+    // Step 9.d.i.
+    return resultString;
 }
 
 /**
diff -Nrup mozilla/js/src/builtin/TestingFunctions.cpp mozilla-OK/js/src/builtin/TestingFunctions.cpp
--- mozilla/js/src/builtin/TestingFunctions.cpp	2022-04-13 21:14:22.000000000 +0300
+++ mozilla-OK/js/src/builtin/TestingFunctions.cpp	2022-04-22 05:05:38.012392608 +0300
@@ -29,13 +29,11 @@
 #include "builtin/SelfHostingDefines.h"
 #ifdef DEBUG
 #include "frontend/TokenStream.h"
-#include "irregexp/RegExpAST.h"
-#include "irregexp/RegExpEngine.h"
-#include "irregexp/RegExpParser.h"
 #endif
 #include "jit/InlinableNatives.h"
 #include "js/Debug.h"
 #include "js/HashTable.h"
+#include "js/RegExpFlags.h"
 #include "js/StructuredClone.h"
 #include "js/UbiNode.h"
 #include "js/UbiNodeBreadthFirst.h"
@@ -70,6 +68,9 @@ using namespace js;
 using mozilla::ArrayLength;
 using mozilla::Move;
 
+using JS::RegExpFlag;
+using JS::RegExpFlags;
+
 // If fuzzingSafe is set, remove functionality that could cause problems with
 // fuzzers. Set this via the environment variable MOZ_FUZZING_SAFE.
 static mozilla::Atomic<bool> fuzzingSafe(false);
@@ -4090,372 +4091,6 @@ GetModuleEnvironmentValue(JSContext* cx,
     return true;
 }
 
-#ifdef DEBUG
-static const char*
-AssertionTypeToString(irregexp::RegExpAssertion::AssertionType type)
-{
-    switch (type) {
-      case irregexp::RegExpAssertion::START_OF_LINE:
-        return "START_OF_LINE";
-      case irregexp::RegExpAssertion::START_OF_INPUT:
-        return "START_OF_INPUT";
-      case irregexp::RegExpAssertion::END_OF_LINE:
-        return "END_OF_LINE";
-      case irregexp::RegExpAssertion::END_OF_INPUT:
-        return "END_OF_INPUT";
-      case irregexp::RegExpAssertion::BOUNDARY:
-        return "BOUNDARY";
-      case irregexp::RegExpAssertion::NON_BOUNDARY:
-        return "NON_BOUNDARY";
-      case irregexp::RegExpAssertion::NOT_AFTER_LEAD_SURROGATE:
-        return "NOT_AFTER_LEAD_SURROGATE";
-      case irregexp::RegExpAssertion::NOT_IN_SURROGATE_PAIR:
-        return "NOT_IN_SURROGATE_PAIR";
-    }
-    MOZ_CRASH("unexpected AssertionType");
-}
-
-static JSObject*
-ConvertRegExpTreeToObject(JSContext* cx, irregexp::RegExpTree* tree)
-{
-    RootedObject obj(cx, JS_NewPlainObject(cx));
-    if (!obj)
-        return nullptr;
-
-    auto IntProp = [](JSContext* cx, HandleObject obj,
-                      const char* name, int32_t value) {
-        RootedValue val(cx, Int32Value(value));
-        return JS_SetProperty(cx, obj, name, val);
-    };
-
-    auto BooleanProp = [](JSContext* cx, HandleObject obj,
-                          const char* name, bool value) {
-        RootedValue val(cx, BooleanValue(value));
-        return JS_SetProperty(cx, obj, name, val);
-    };
-
-    auto StringProp = [](JSContext* cx, HandleObject obj,
-                         const char* name, const char* value) {
-        RootedString valueStr(cx, JS_NewStringCopyZ(cx, value));
-        if (!valueStr)
-            return false;
-
-        RootedValue val(cx, StringValue(valueStr));
-        return JS_SetProperty(cx, obj, name, val);
-    };
-
-    auto ObjectProp = [](JSContext* cx, HandleObject obj,
-                         const char* name, HandleObject value) {
-        RootedValue val(cx, ObjectValue(*value));
-        return JS_SetProperty(cx, obj, name, val);
-    };
-
-    auto CharVectorProp = [](JSContext* cx, HandleObject obj,
-                             const char* name, const irregexp::CharacterVector& data) {
-        RootedString valueStr(cx, JS_NewUCStringCopyN(cx, data.begin(), data.length()));
-        if (!valueStr)
-            return false;
-
-        RootedValue val(cx, StringValue(valueStr));
-        return JS_SetProperty(cx, obj, name, val);
-    };
-
-    auto TreeProp = [&ObjectProp](JSContext* cx, HandleObject obj,
-                                  const char* name, irregexp::RegExpTree* tree) {
-        RootedObject treeObj(cx, ConvertRegExpTreeToObject(cx, tree));
-        if (!treeObj)
-            return false;
-        return ObjectProp(cx, obj, name, treeObj);
-    };
-
-    auto TreeVectorProp = [&ObjectProp](JSContext* cx, HandleObject obj,
-                                        const char* name,
-                                        const irregexp::RegExpTreeVector& nodes) {
-        size_t len = nodes.length();
-        RootedObject array(cx, JS_NewArrayObject(cx, len));
-        if (!array)
-            return false;
-
-        for (size_t i = 0; i < len; i++) {
-            RootedObject child(cx, ConvertRegExpTreeToObject(cx, nodes[i]));
-            if (!child)
-                return false;
-
-            RootedValue childVal(cx, ObjectValue(*child));
-            if (!JS_SetElement(cx, array, i, childVal))
-                return false;
-        }
-        return ObjectProp(cx, obj, name, array);
-    };
-
-    auto CharRangesProp = [&ObjectProp](JSContext* cx, HandleObject obj,
-                                        const char* name,
-                                        const irregexp::CharacterRangeVector& ranges) {
-        size_t len = ranges.length();
-        RootedObject array(cx, JS_NewArrayObject(cx, len));
-        if (!array)
-            return false;
-
-        for (size_t i = 0; i < len; i++) {
-            const irregexp::CharacterRange& range = ranges[i];
-            RootedObject rangeObj(cx, JS_NewPlainObject(cx));
-            if (!rangeObj)
-                return false;
-
-            auto CharProp = [](JSContext* cx, HandleObject obj,
-                               const char* name, char16_t c) {
-                RootedString valueStr(cx, JS_NewUCStringCopyN(cx, &c, 1));
-                if (!valueStr)
-                    return false;
-                RootedValue val(cx, StringValue(valueStr));
-                return JS_SetProperty(cx, obj, name, val);
-            };
-
-            if (!CharProp(cx, rangeObj, "from", range.from()))
-                return false;
-            if (!CharProp(cx, rangeObj, "to", range.to()))
-                return false;
-
-            RootedValue rangeVal(cx, ObjectValue(*rangeObj));
-            if (!JS_SetElement(cx, array, i, rangeVal))
-                return false;
-        }
-        return ObjectProp(cx, obj, name, array);
-    };
-
-    auto ElemProp = [&ObjectProp](JSContext* cx, HandleObject obj,
-                                  const char* name, const irregexp::TextElementVector& elements) {
-        size_t len = elements.length();
-        RootedObject array(cx, JS_NewArrayObject(cx, len));
-        if (!array)
-            return false;
-
-        for (size_t i = 0; i < len; i++) {
-            const irregexp::TextElement& element = elements[i];
-            RootedObject elemTree(cx, ConvertRegExpTreeToObject(cx, element.tree()));
-            if (!elemTree)
-                return false;
-
-            RootedValue elemTreeVal(cx, ObjectValue(*elemTree));
-            if (!JS_SetElement(cx, array, i, elemTreeVal))
-                return false;
-        }
-        return ObjectProp(cx, obj, name, array);
-    };
-
-    if (tree->IsDisjunction()) {
-        if (!StringProp(cx, obj, "type", "Disjunction"))
-            return nullptr;
-        irregexp::RegExpDisjunction* t = tree->AsDisjunction();
-        if (!TreeVectorProp(cx, obj, "alternatives", t->alternatives()))
-            return nullptr;
-        return obj;
-    }
-    if (tree->IsAlternative()) {
-        if (!StringProp(cx, obj, "type", "Alternative"))
-            return nullptr;
-        irregexp::RegExpAlternative* t = tree->AsAlternative();
-        if (!TreeVectorProp(cx, obj, "nodes", t->nodes()))
-            return nullptr;
-        return obj;
-    }
-    if (tree->IsAssertion()) {
-        if (!StringProp(cx, obj, "type", "Assertion"))
-            return nullptr;
-        irregexp::RegExpAssertion* t = tree->AsAssertion();
-        if (!StringProp(cx, obj, "assertion_type", AssertionTypeToString(t->assertion_type())))
-            return nullptr;
-        return obj;
-    }
-    if (tree->IsCharacterClass()) {
-        if (!StringProp(cx, obj, "type", "CharacterClass"))
-            return nullptr;
-        irregexp::RegExpCharacterClass* t = tree->AsCharacterClass();
-        if (!BooleanProp(cx, obj, "is_negated", t->is_negated()))
-            return nullptr;
-        LifoAlloc* alloc = &cx->tempLifoAlloc();
-        if (!CharRangesProp(cx, obj, "ranges", t->ranges(alloc)))
-            return nullptr;
-        return obj;
-    }
-    if (tree->IsAtom()) {
-        if (!StringProp(cx, obj, "type", "Atom"))
-            return nullptr;
-        irregexp::RegExpAtom* t = tree->AsAtom();
-        if (!CharVectorProp(cx, obj, "data", t->data()))
-            return nullptr;
-        return obj;
-    }
-    if (tree->IsText()) {
-        if (!StringProp(cx, obj, "type", "Text"))
-            return nullptr;
-        irregexp::RegExpText* t = tree->AsText();
-        if (!ElemProp(cx, obj, "elements", t->elements()))
-            return nullptr;
-        return obj;
-    }
-    if (tree->IsQuantifier()) {
-        if (!StringProp(cx, obj, "type", "Quantifier"))
-            return nullptr;
-        irregexp::RegExpQuantifier* t = tree->AsQuantifier();
-        if (!IntProp(cx, obj, "min", t->min()))
-            return nullptr;
-        if (!IntProp(cx, obj, "max", t->max()))
-            return nullptr;
-        if (!StringProp(cx, obj, "quantifier_type",
-                        t->is_possessive() ? "POSSESSIVE"
-                        : t->is_non_greedy() ? "NON_GREEDY"
-                        : "GREEDY"))
-            return nullptr;
-        if (!TreeProp(cx, obj, "body", t->body()))
-            return nullptr;
-        return obj;
-    }
-    if (tree->IsCapture()) {
-        if (!StringProp(cx, obj, "type", "Capture"))
-            return nullptr;
-        irregexp::RegExpCapture* t = tree->AsCapture();
-        if (!IntProp(cx, obj, "index", t->index()))
-            return nullptr;
-        if (!TreeProp(cx, obj, "body", t->body()))
-            return nullptr;
-        return obj;
-    }
-    if (tree->IsLookahead()) {
-        if (!StringProp(cx, obj, "type", "Lookahead"))
-            return nullptr;
-        irregexp::RegExpLookahead* t = tree->AsLookahead();
-        if (!BooleanProp(cx, obj, "is_positive", t->is_positive()))
-            return nullptr;
-        if (!TreeProp(cx, obj, "body", t->body()))
-            return nullptr;
-        return obj;
-    }
-    if (tree->IsBackReference()) {
-        if (!StringProp(cx, obj, "type", "BackReference"))
-            return nullptr;
-        irregexp::RegExpBackReference* t = tree->AsBackReference();
-        if (!IntProp(cx, obj, "index", t->index()))
-            return nullptr;
-        return obj;
-    }
-    if (tree->IsEmpty()) {
-        if (!StringProp(cx, obj, "type", "Empty"))
-            return nullptr;
-        return obj;
-    }
-
-    MOZ_CRASH("unexpected RegExpTree type");
-}
-
-static bool
-ParseRegExp(JSContext* cx, unsigned argc, Value* vp)
-{
-    CallArgs args = CallArgsFromVp(argc, vp);
-    RootedObject callee(cx, &args.callee());
-
-    if (args.length() == 0) {
-        ReportUsageErrorASCII(cx, callee, "Wrong number of arguments");
-        return false;
-    }
-
-    if (!args[0].isString()) {
-        ReportUsageErrorASCII(cx, callee, "First argument must be a String");
-        return false;
-    }
-
-    RegExpFlag flags = RegExpFlag(0);
-    if (!args.get(1).isUndefined()) {
-        if (!args.get(1).isString()) {
-            ReportUsageErrorASCII(cx, callee, "Second argument, if present, must be a String");
-            return false;
-        }
-        RootedString flagStr(cx, args[1].toString());
-        if (!ParseRegExpFlags(cx, flagStr, &flags))
-            return false;
-    }
-
-    bool match_only = false;
-    if (!args.get(2).isUndefined()) {
-        if (!args.get(2).isBoolean()) {
-            ReportUsageErrorASCII(cx, callee, "Third argument, if present, must be a Boolean");
-            return false;
-        }
-        match_only = args[2].toBoolean();
-    }
-
-    RootedAtom pattern(cx, AtomizeString(cx, args[0].toString()));
-    if (!pattern)
-        return false;
-
-    CompileOptions options(cx);
-    frontend::TokenStream dummyTokenStream(cx, options, nullptr, 0, nullptr);
-
-    irregexp::RegExpCompileData data;
-    if (!irregexp::ParsePattern(dummyTokenStream, cx->tempLifoAlloc(), pattern,
-                                flags & MultilineFlag, match_only,
-                                flags & UnicodeFlag, flags & IgnoreCaseFlag,
-                                flags & GlobalFlag, flags & StickyFlag,
-                                &data))
-    {
-        return false;
-    }
-
-    RootedObject obj(cx, ConvertRegExpTreeToObject(cx, data.tree));
-    if (!obj)
-        return false;
-
-    args.rval().setObject(*obj);
-    return true;
-}
-
-static bool
-DisRegExp(JSContext* cx, unsigned argc, Value* vp)
-{
-    CallArgs args = CallArgsFromVp(argc, vp);
-    RootedObject callee(cx, &args.callee());
-
-    if (args.length() == 0) {
-        ReportUsageErrorASCII(cx, callee, "Wrong number of arguments");
-        return false;
-    }
-
-    if (!args[0].isObject() || !args[0].toObject().is<RegExpObject>()) {
-        ReportUsageErrorASCII(cx, callee, "First argument must be a RegExp");
-        return false;
-    }
-
-    Rooted<RegExpObject*> reobj(cx, &args[0].toObject().as<RegExpObject>());
-
-    bool match_only = false;
-    if (!args.get(1).isUndefined()) {
-        if (!args.get(1).isBoolean()) {
-            ReportUsageErrorASCII(cx, callee, "Second argument, if present, must be a Boolean");
-            return false;
-        }
-        match_only = args[1].toBoolean();
-    }
-
-    RootedLinearString input(cx, cx->runtime()->emptyString);
-    if (!args.get(2).isUndefined()) {
-        if (!args.get(2).isString()) {
-            ReportUsageErrorASCII(cx, callee, "Third argument, if present, must be a String");
-            return false;
-        }
-        RootedString inputStr(cx, args[2].toString());
-        input = inputStr->ensureLinear(cx);
-        if (!input)
-            return false;
-    }
-
-    if (!RegExpObject::dumpBytecode(cx, reobj, match_only, input))
-        return false;
-
-    args.rval().setUndefined();
-    return true;
-}
-#endif // DEBUG
-
 static bool
 EnableForEach(JSContext* cx, unsigned argc, Value* vp)
 {
@@ -5343,16 +4978,6 @@ gc::ZealModeHelpText),
 };
 
 static const JSFunctionSpecWithHelp FuzzingUnsafeTestingFunctions[] = {
-#ifdef DEBUG
-    JS_FN_HELP("parseRegExp", ParseRegExp, 3, 0,
-"parseRegExp(pattern[, flags[, match_only])",
-"  Parses a RegExp pattern and returns a tree, potentially throwing."),
-
-    JS_FN_HELP("disRegExp", DisRegExp, 3, 0,
-"disRegExp(regexp[, match_only[, input]])",
-"  Dumps RegExp bytecode."),
-#endif
-
     JS_FN_HELP("getErrorNotes", GetErrorNotes, 1, 0,
 "getErrorNotes(error)",
 "  Returns an array of error notes."),
diff -Nrup mozilla/js/src/builtin/intl/RelativeTimeFormat.cpp mozilla-OK/js/src/builtin/intl/RelativeTimeFormat.cpp
--- mozilla/js/src/builtin/intl/RelativeTimeFormat.cpp	2021-10-26 19:49:54.000000000 +0300
+++ mozilla-OK/js/src/builtin/intl/RelativeTimeFormat.cpp	2022-04-22 05:04:18.063952956 +0300
@@ -127,7 +127,7 @@ RelativeTimeFormat(JSContext* cx, unsign
 void
 js::RelativeTimeFormatObject::finalize(FreeOp* fop, JSObject* obj)
 {
-    MOZ_ASSERT(fop->onActiveCooperatingThread());
+    MOZ_ASSERT(fop->onMainThread());
 
     const Value& slot =
         obj->as<RelativeTimeFormatObject>().getReservedSlot(RelativeTimeFormatObject::URELATIVE_TIME_FORMAT_SLOT);
diff -Nrup mozilla/js/src/devtools/rootAnalysis/annotations.js mozilla-OK/js/src/devtools/rootAnalysis/annotations.js
--- mozilla/js/src/devtools/rootAnalysis/annotations.js	2022-04-13 21:14:22.000000000 +0300
+++ mozilla-OK/js/src/devtools/rootAnalysis/annotations.js	2022-04-22 05:04:24.567907383 +0300
@@ -241,6 +241,9 @@ var ignoreFunctions = {
     "uint8 nsContentUtils::IsExpandedPrincipal(nsIPrincipal*)" : true,
 
     "void mozilla::AutoProfilerLabel::~AutoProfilerLabel(int32)" : true,
+
+    // Calls MergeSort
+    "uint8 v8::internal::RegExpDisjunction::SortConsecutiveAtoms(v8::internal::RegExpCompiler*)": true,
 };
 
 function extraGCFunctions() {
@@ -267,6 +270,12 @@ function isGTest(name)
     return name.match(/\btesting::/);
 }
 
+function isICU(name)
+{
+    return name.match(/\bicu_\d+::/) ||
+           name.match(/u(prv_malloc|prv_realloc|prv_free|case_toFullLower)_\d+/)
+}
+
 function ignoreGCFunction(mangled)
 {
     assert(mangled in readableNames, mangled + " not in readableNames");
@@ -277,8 +286,9 @@ function ignoreGCFunction(mangled)
 
     // The protobuf library, and [de]serialization code generated by the
     // protobuf compiler, uses a _ton_ of function pointers but they are all
-    // internal. Easiest to just ignore that mess here.
-    if (isProtobuf(fun))
+    // internal. The same is true for ICU. Easiest to just ignore that mess
+    // here.
+    if (isProtobuf(fun) || isICU(fun))
         return true;
 
     // Ignore anything that goes through heap snapshot GTests or mocked classes
diff -Nrup mozilla/js/src/ds/LifoAlloc.h mozilla-OK/js/src/ds/LifoAlloc.h
--- mozilla/js/src/ds/LifoAlloc.h	2020-08-10 14:30:34.000000000 +0300
+++ mozilla-OK/js/src/ds/LifoAlloc.h	2022-04-22 05:08:49.733048817 +0300
@@ -717,21 +717,15 @@ class LifoAlloc
         return n;
     }
 
-    // Get the total size of the arena chunks (including unused space).
-    size_t computedSizeOfExcludingThis() const {
-        size_t n = 0;
-        for (const detail::BumpChunk& chunk : chunks_)
-            n += chunk.computedSizeOfIncludingThis();
-        for (const detail::BumpChunk& chunk : unused_)
-            n += chunk.computedSizeOfIncludingThis();
-        return n;
-    }
-
     // Like sizeOfExcludingThis(), but includes the size of the LifoAlloc itself.
     size_t sizeOfIncludingThis(mozilla::MallocSizeOf mallocSizeOf) const {
         return mallocSizeOf(this) + sizeOfExcludingThis(mallocSizeOf);
     }
 
+    // Get the current size of the arena chunks (including unused space and
+    // bookkeeping space).
+    size_t computedSizeOfExcludingThis() const { return curSize_; }
+
     // Get the peak size of the arena chunks (including unused space and
     // bookkeeping space).
     size_t peakSizeOfExcludingThis() const { return peakSize_; }
diff -Nrup mozilla/js/src/frontend/Parser.cpp mozilla-OK/js/src/frontend/Parser.cpp
--- mozilla/js/src/frontend/Parser.cpp	2022-04-13 21:14:22.000000000 +0300
+++ mozilla-OK/js/src/frontend/Parser.cpp	2022-04-22 05:05:38.015392587 +0300
@@ -34,7 +34,8 @@
 #include "frontend/BytecodeCompiler.h"
 #include "frontend/FoldConstants.h"
 #include "frontend/TokenStream.h"
-#include "irregexp/RegExpParser.h"
+#include "irregexp/RegExpAPI.h"
+#include "js/RegExpFlags.h"
 #include "vm/RegExpObject.h"
 #include "wasm/AsmJS.h"
 
@@ -54,6 +55,7 @@ using mozilla::PodZero;
 using mozilla::Some;
 
 using JS::AutoGCRooter;
+using JS::RegExpFlags;
 
 namespace js {
 namespace frontend {
@@ -9359,7 +9361,7 @@ Parser<FullParseHandler, char16_t>::newR
     // Create the regexp and check its syntax.
     const char16_t* chars = tokenStream.getTokenbuf().begin();
     size_t length = tokenStream.getTokenbuf().length();
-    RegExpFlag flags = anyChars.currentToken().regExpFlags();
+    RegExpFlags flags = anyChars.currentToken().regExpFlags();
 
     Rooted<RegExpObject*> reobj(context);
     reobj = RegExpObject::create(context, chars, length, flags, anyChars, alloc, TenuredObject);
@@ -9378,12 +9380,12 @@ Parser<SyntaxParseHandler, char16_t>::ne
     // Only check the regexp's syntax, but don't create a regexp object.
     const char16_t* chars = tokenStream.getTokenbuf().begin();
     size_t length = tokenStream.getTokenbuf().length();
-    RegExpFlag flags = anyChars.currentToken().regExpFlags();
+    RegExpFlags flags = anyChars.currentToken().regExpFlags();
 
     mozilla::Range<const char16_t> source(chars, length);
-    if (!js::irregexp::ParsePatternSyntax(anyChars, alloc, source, flags & UnicodeFlag))
-        return null();
-
+    if (!irregexp::CheckPatternSyntax(context, anyChars, source, flags)) {
+      return null();
+    }
     return handler.newRegExp(SyntaxParseHandler::NodeGeneric, pos(), *this);
 }
 
diff -Nrup mozilla/js/src/frontend/TokenStream.cpp mozilla-OK/js/src/frontend/TokenStream.cpp
--- mozilla/js/src/frontend/TokenStream.cpp	2022-04-13 21:14:22.000000000 +0300
+++ mozilla-OK/js/src/frontend/TokenStream.cpp	2022-04-22 05:03:52.030135434 +0300
@@ -26,6 +26,7 @@
 #include "frontend/Parser.h"
 #include "frontend/ReservedWords.h"
 #include "js/CharacterEncoding.h"
+#include "js/RegExpFlags.h"  // JS::RegExpFlags
 #include "js/UniquePtr.h"
 #include "vm/HelperThreads.h"
 #include "vm/StringBuffer.h"
@@ -38,6 +39,9 @@ using mozilla::PodAssign;
 using mozilla::PodCopy;
 using mozilla::PodZero;
 
+using JS::RegExpFlag;
+using JS::RegExpFlags;
+
 struct ReservedWordInfo
 {
     const char* chars;         // C string with reserved word text
@@ -1994,21 +1998,23 @@ TokenStreamSpecific<CharT, AnyCharsAcces
                     goto error;
             } while (true);
 
-            RegExpFlag reflags = NoFlags;
+            RegExpFlags reflags = RegExpFlag::NoFlags;
             unsigned length = tokenbuf.length() + 1;
             while (true) {
                 if (!peekChar(&c))
                     goto error;
-                if (c == 'g' && !(reflags & GlobalFlag))
-                    reflags = RegExpFlag(reflags | GlobalFlag);
-                else if (c == 'i' && !(reflags & IgnoreCaseFlag))
-                    reflags = RegExpFlag(reflags | IgnoreCaseFlag);
-                else if (c == 'm' && !(reflags & MultilineFlag))
-                    reflags = RegExpFlag(reflags | MultilineFlag);
-                else if (c == 'y' && !(reflags & StickyFlag))
-                    reflags = RegExpFlag(reflags | StickyFlag);
-                else if (c == 'u' && !(reflags & UnicodeFlag))
-                    reflags = RegExpFlag(reflags | UnicodeFlag);
+                if (c == 'g' && !(reflags & RegExpFlag::Global))
+                    reflags = RegExpFlags(reflags | RegExpFlag::Global);
+                else if (c == 'i' && !(reflags & RegExpFlag::IgnoreCase))
+                    reflags = RegExpFlags(reflags | RegExpFlag::IgnoreCase);
+                else if (c == 'm' && !(reflags & RegExpFlag::Multiline))
+                    reflags = RegExpFlags(reflags | RegExpFlag::Multiline);
+                else if (c == 's' && !(reflags & RegExpFlag::DotAll))
+                    reflags = RegExpFlags(reflags | RegExpFlag::DotAll);
+                else if (c == 'u' && !(reflags & RegExpFlag::Unicode))
+                    reflags = RegExpFlags(reflags | RegExpFlag::Unicode);
+                else if (c == 'y' && !(reflags & RegExpFlag::Sticky))
+                    reflags = RegExpFlags(reflags | RegExpFlag::Sticky);
                 else
                     break;
                 if (!getChar(&c))
diff -Nrup mozilla/js/src/frontend/TokenStream.h mozilla-OK/js/src/frontend/TokenStream.h
--- mozilla/js/src/frontend/TokenStream.h	2022-01-25 01:04:25.000000000 +0300
+++ mozilla-OK/js/src/frontend/TokenStream.h	2022-04-22 05:08:45.972075124 +0300
@@ -144,10 +144,10 @@
 
 #include "frontend/ErrorReporter.h"
 #include "frontend/TokenKind.h"
+#include "js/RegExpFlags.h"
 #include "js/UniquePtr.h"
 #include "js/Vector.h"
 #include "vm/ErrorReporting.h"
-#include "vm/RegExpShared.h"
 #include "vm/String.h"
 #include "vm/Unicode.h"
 
@@ -302,7 +302,7 @@ struct Token
             double      value;          // floating point number
             DecimalPoint decimalPoint;  // literal contains '.'
         } number;
-        RegExpFlag      reflags;        // regexp flags; use tokenbuf to access
+        JS::RegExpFlags  reflags;       // regexp flags; use tokenbuf to access
                                         //   regexp chars
     } u;
 #ifdef DEBUG
@@ -324,9 +324,8 @@ struct Token
         u.atom = atom;
     }
 
-    void setRegExpFlags(RegExpFlag flags) {
+    void setRegExpFlags(JS::RegExpFlags flags) {
         MOZ_ASSERT(type == TokenKind::RegExp);
-        MOZ_ASSERT((flags & AllFlags) == flags);
         u.reflags = flags;
     }
 
@@ -350,9 +349,8 @@ struct Token
         return u.atom;
     }
 
-    RegExpFlag regExpFlags() const {
+    JS::RegExpFlags regExpFlags() const {
         MOZ_ASSERT(type == TokenKind::RegExp);
-        MOZ_ASSERT((u.reflags & AllFlags) == u.reflags);
         return u.reflags;
     }
 
@@ -1405,7 +1403,7 @@ class TokenStreamAnyCharsAccess
     static inline const TokenStreamAnyChars& anyChars(const TokenStreamSpecific* tss);
 };
 
-class MOZ_STACK_CLASS TokenStream final
+class MOZ_STACK_CLASS TokenStream
   : public TokenStreamAnyChars,
     public TokenStreamSpecific<char16_t, TokenStreamAnyCharsAccess>
 {
@@ -1419,6 +1417,12 @@ class MOZ_STACK_CLASS TokenStream final
     {}
 };
 
+class MOZ_STACK_CLASS DummyTokenStream final : public TokenStream {
+  public:
+    DummyTokenStream(JSContext* cx, const JS::ReadOnlyCompileOptions& options)
+        : TokenStream(cx, options, nullptr, 0, nullptr) {}
+};
+
 template<class TokenStreamSpecific>
 /* static */ inline TokenStreamAnyChars&
 TokenStreamAnyCharsAccess::anyChars(TokenStreamSpecific* tss)
diff -Nrup mozilla/js/src/irregexp/IRREGEXP_VERSION mozilla-OK/js/src/irregexp/IRREGEXP_VERSION
--- mozilla/js/src/irregexp/IRREGEXP_VERSION	1970-01-01 03:00:00.000000000 +0300
+++ mozilla-OK/js/src/irregexp/IRREGEXP_VERSION	2022-04-22 05:08:42.153101910 +0300
@@ -0,0 +1,2 @@
+Imported using import-irregexp.py from:
+https://github.com/v8/v8/tree/8732b2ee52b567ad4e15ca91d141fd6e27499e99/src/regexp
diff -Nrup mozilla/js/src/irregexp/RegExpAPI.cpp mozilla-OK/js/src/irregexp/RegExpAPI.cpp
--- mozilla/js/src/irregexp/RegExpAPI.cpp	1970-01-01 03:00:00.000000000 +0300
+++ mozilla-OK/js/src/irregexp/RegExpAPI.cpp	2022-04-22 05:08:45.972075124 +0300
@@ -0,0 +1,703 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+// Copyright 2020 the V8 project authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "irregexp/RegExpAPI.h"
+
+#include "mozilla/ArrayUtils.h"
+#include "mozilla/Casting.h"
+
+#include "irregexp/imported/regexp-ast.h"
+#include "irregexp/imported/regexp-bytecode-generator.h"
+#include "irregexp/imported/regexp-compiler.h"
+#include "irregexp/imported/regexp-interpreter.h"
+#include "irregexp/imported/regexp-macro-assembler-arch.h"
+#include "irregexp/imported/regexp-parser.h"
+#include "irregexp/imported/regexp-stack.h"
+#include "irregexp/imported/regexp.h"
+#include "irregexp/RegExpShim.h"
+#include "jit/JitCommon.h"
+
+#include "util/Text.h"
+#include "vm/ErrorReporting.h"
+#include "vm/MatchPairs.h"
+#include "vm/RegExpShared.h"
+#include "vm/StringBuffer.h"
+
+namespace js {
+namespace irregexp {
+
+using namespace mozilla;
+
+using frontend::DummyTokenStream;
+using frontend::TokenStreamAnyChars;
+
+using v8::internal::DisallowGarbageCollection;
+using v8::internal::FlatStringReader;
+using v8::internal::HandleScope;
+using v8::internal::InputOutputData;
+using v8::internal::IrregexpInterpreter;
+using v8::internal::NativeRegExpMacroAssembler;
+using v8::internal::RegExpBytecodeGenerator;
+using v8::internal::RegExpCompileData;
+using v8::internal::RegExpCompiler;
+using v8::internal::RegExpError;
+using v8::internal::RegExpMacroAssembler;
+using v8::internal::RegExpNode;
+using v8::internal::RegExpParser;
+using v8::internal::SMRegExpMacroAssembler;
+using v8::internal::Zone;
+
+using V8HandleString = v8::internal::Handle<v8::internal::String>;
+using V8HandleRegExp = v8::internal::Handle<v8::internal::JSRegExp>;
+
+using namespace v8::internal::regexp_compiler_constants;
+
+static uint32_t ErrorNumber(RegExpError err) {
+  switch (err) {
+    case RegExpError::kNone:
+      return JSMSG_NOT_AN_ERROR;
+    case RegExpError::kStackOverflow:
+      return JSMSG_OVER_RECURSED;
+    case RegExpError::kAnalysisStackOverflow:
+      return JSMSG_OVER_RECURSED;
+    case RegExpError::kTooLarge:
+      return JSMSG_TOO_MANY_PARENS;
+    case RegExpError::kUnterminatedGroup:
+      return JSMSG_MISSING_PAREN;
+    case RegExpError::kUnmatchedParen:
+      return JSMSG_UNMATCHED_RIGHT_PAREN;
+    case RegExpError::kEscapeAtEndOfPattern:
+      return JSMSG_ESCAPE_AT_END_OF_REGEXP;
+    case RegExpError::kInvalidPropertyName:
+      return JSMSG_INVALID_PROPERTY_NAME;
+    case RegExpError::kInvalidEscape:
+      return JSMSG_INVALID_IDENTITY_ESCAPE;
+    case RegExpError::kInvalidDecimalEscape:
+      return JSMSG_INVALID_DECIMAL_ESCAPE;
+    case RegExpError::kInvalidUnicodeEscape:
+      return JSMSG_INVALID_UNICODE_ESCAPE;
+    case RegExpError::kNothingToRepeat:
+      return JSMSG_NOTHING_TO_REPEAT;
+    case RegExpError::kLoneQuantifierBrackets:
+      // Note: V8 reports the same error for both ']' and '}'.
+      return JSMSG_RAW_BRACKET_IN_REGEXP;
+    case RegExpError::kRangeOutOfOrder:
+      return JSMSG_NUMBERS_OUT_OF_ORDER;
+    case RegExpError::kIncompleteQuantifier:
+      return JSMSG_INCOMPLETE_QUANTIFIER;
+    case RegExpError::kInvalidQuantifier:
+      return JSMSG_INVALID_QUANTIFIER;
+    case RegExpError::kInvalidGroup:
+      return JSMSG_INVALID_GROUP;
+    case RegExpError::kMultipleFlagDashes:
+    case RegExpError::kRepeatedFlag:
+    case RegExpError::kInvalidFlagGroup:
+      // V8 contains experimental support for turning regexp flags on
+      // and off in the middle of a regular expression. Unless it
+      // becomes standardized, SM does not support this feature.
+      MOZ_CRASH("Mode modifiers not supported");
+    case RegExpError::kNotLinear:
+      // V8 has an experimental non-backtracking engine. We do not
+      // support it yet.
+      MOZ_CRASH("Non-backtracking execution not supported");
+    case RegExpError::kTooManyCaptures:
+      return JSMSG_TOO_MANY_PARENS;
+    case RegExpError::kInvalidCaptureGroupName:
+      return JSMSG_INVALID_CAPTURE_NAME;
+    case RegExpError::kDuplicateCaptureGroupName:
+      return JSMSG_DUPLICATE_CAPTURE_NAME;
+    case RegExpError::kInvalidNamedReference:
+      return JSMSG_INVALID_NAMED_REF;
+    case RegExpError::kInvalidNamedCaptureReference:
+      return JSMSG_INVALID_NAMED_CAPTURE_REF;
+    case RegExpError::kInvalidClassEscape:
+      return JSMSG_RANGE_WITH_CLASS_ESCAPE;
+    case RegExpError::kInvalidClassPropertyName:
+      return JSMSG_INVALID_CLASS_PROPERTY_NAME;
+    case RegExpError::kInvalidCharacterClass:
+      return JSMSG_RANGE_WITH_CLASS_ESCAPE;
+    case RegExpError::kUnterminatedCharacterClass:
+      return JSMSG_UNTERM_CLASS;
+    case RegExpError::kOutOfOrderCharacterClass:
+      return JSMSG_BAD_CLASS_RANGE;
+    case RegExpError::NumErrors:
+      MOZ_CRASH("Unreachable");
+  }
+  MOZ_CRASH("Unreachable");
+}
+
+Isolate* CreateIsolate(JSContext* cx) {
+  auto isolate = MakeUnique<Isolate>(cx);
+  if (!isolate || !isolate->init()) {
+    return nullptr;
+  }
+  return isolate.release();
+}
+
+void DestroyIsolate(Isolate* isolate) {
+  MOZ_ASSERT(isolate->liveHandles() == 0);
+  MOZ_ASSERT(isolate->livePseudoHandles() == 0);
+  js_delete(isolate);
+}
+
+size_t IsolateSizeOfIncludingThis(Isolate* isolate,
+                                  mozilla::MallocSizeOf mallocSizeOf) {
+  return isolate->sizeOfIncludingThis(mallocSizeOf);
+}
+
+static size_t ComputeColumn(const Latin1Char* begin, const Latin1Char* end) {
+  return mozilla::PointerRangeSize(begin, end);
+}
+
+static size_t ComputeColumn(const char16_t* begin, const char16_t* end) {
+  return unicode::CountCodePoints(begin, end);
+}
+
+// This function is varargs purely so it can call ReportCompileErrorLatin1.
+// We never call it with additional arguments.
+template <typename CharT>
+static void ReportSyntaxError(TokenStreamAnyChars& ts, RegExpCompileData& result,
+                              CharT* start, size_t length, ...) {
+  gc::AutoSuppressGC suppressGC(ts.context());
+  uint32_t errorNumber = ErrorNumber(result.error);
+
+  if (errorNumber == JSMSG_OVER_RECURSED) {
+    ReportOverRecursed(ts.context());
+    return;
+  }
+
+  uint32_t offset = std::max(result.error_pos, 0);
+  MOZ_ASSERT(offset <= length);
+
+  ErrorMetadata err;
+
+  // Ordinarily this indicates whether line-of-context information can be
+  // added, but we entirely ignore that here because we create a
+  // a line of context based on the expression source.
+  uint32_t location = ts.currentToken().pos.begin;
+  if (ts.fillExcludingContext(&err, location)) {
+    // Line breaks are not significant in pattern text in the same way as
+    // in source text, so act as though pattern text is a single line, then
+    // compute a column based on "code point" count (treating a lone
+    // surrogate as a "code point" in UTF-16).  Gak.
+    err.lineNumber = 1;
+    err.columnNumber =
+        AssertedCast<uint32_t>(ComputeColumn(start, start + offset));
+  }
+
+  // For most error reporting, the line of context derives from the token
+  // stream.  So when location information doesn't come from the token
+  // stream, we can't give a line of context.  But here the "line of context"
+  // can be (and is) derived from the pattern text, so we can provide it no
+  // matter if the location is derived from the caller.
+
+  const CharT* windowStart =
+      (offset > ErrorMetadata::lineOfContextRadius)
+          ? start + (offset - ErrorMetadata::lineOfContextRadius)
+          : start;
+
+  const CharT* windowEnd =
+      (length - offset > ErrorMetadata::lineOfContextRadius)
+          ? start + offset + ErrorMetadata::lineOfContextRadius
+          : start + length;
+
+  size_t windowLength = PointerRangeSize(windowStart, windowEnd);
+  MOZ_ASSERT(windowLength <= ErrorMetadata::lineOfContextRadius * 2);
+
+  // Create the windowed string, not including the potential line
+  // terminator.
+  StringBuffer windowBuf(ts.context());
+  if (!windowBuf.append(windowStart, windowEnd)) {
+    return;
+  }
+
+  // The line of context must be null-terminated, and StringBuffer doesn't
+  // make that happen unless we force it to.
+  if (!windowBuf.append('\0')) {
+    return;
+  }
+
+  err.lineOfContext.reset(windowBuf.stealChars());
+  if (!err.lineOfContext) {
+    return;
+  }
+
+  err.lineLength = windowLength;
+  err.tokenOffset = offset - (windowStart - start);
+
+  va_list args;
+  va_start(args, length);
+  ReportCompileError(ts.context(), std::move(err), nullptr, /* notes/report */
+                     JSREPORT_ERROR,                        /*flags*/
+                     errorNumber, args);
+  va_end(args);
+}
+
+static void ReportSyntaxError(TokenStreamAnyChars& ts, RegExpCompileData& result,
+                              HandleAtom pattern) {
+  JS::AutoCheckCannotGC nogc_;
+  if (pattern->hasLatin1Chars()) {
+    ReportSyntaxError(ts, result, pattern->latin1Chars(nogc_),
+                      pattern->length());
+  } else {
+    ReportSyntaxError(ts, result, pattern->twoByteChars(nogc_),
+                      pattern->length());
+  }
+}
+
+static bool CheckPatternSyntaxImpl(JSContext* cx, FlatStringReader* pattern,
+                                   JS::RegExpFlags flags,
+                                   RegExpCompileData* result) {
+  LifoAllocScope allocScope(&cx->tempLifoAlloc());
+  Zone zone(allocScope.alloc());
+
+  HandleScope handleScope(cx->isolate);
+  DisallowGarbageCollection no_gc;
+  return RegExpParser::VerifyRegExpSyntax(cx->isolate, &zone, pattern, flags,
+                                          result, no_gc);
+}
+
+bool CheckPatternSyntax(JSContext* cx, TokenStreamAnyChars& ts,
+                        const mozilla::Range<const char16_t> chars,
+                        JS::RegExpFlags flags) {
+  FlatStringReader reader(chars);
+  RegExpCompileData result;
+  if (!CheckPatternSyntaxImpl(cx, &reader, flags, &result)) {
+    ReportSyntaxError(ts, result, chars.begin().get(), chars.length());
+    return false;
+  }
+  return true;
+}
+
+bool CheckPatternSyntax(JSContext* cx, TokenStreamAnyChars& ts, HandleAtom pattern,
+                        JS::RegExpFlags flags) {
+  FlatStringReader reader(cx, pattern);
+  RegExpCompileData result;
+  if (!CheckPatternSyntaxImpl(cx, &reader, flags, &result)) {
+    ReportSyntaxError(ts, result, pattern);
+    return false;
+  }
+  return true;
+}
+
+// A regexp is a good candidate for Boyer-Moore if it has at least 3
+// times as many characters as it has unique characters. Note that
+// table lookups in irregexp are done modulo tableSize (128).
+template <typename CharT>
+static bool HasFewDifferentCharacters(const CharT* chars, size_t length) {
+  const uint32_t tableSize =
+      v8::internal::NativeRegExpMacroAssembler::kTableSize;
+  bool character_found[tableSize];
+  uint32_t different = 0;
+  memset(&character_found[0], 0, sizeof(character_found));
+  for (uint32_t i = 0; i < length; i++) {
+    uint32_t ch = chars[i] % tableSize;
+    if (!character_found[ch]) {
+      character_found[ch] = true;
+      different++;
+      // We declare a regexp low-alphabet if it has at least 3 times as many
+      // characters as it has different characters.
+      if (different * 3 > length) {
+        return false;
+      }
+    }
+  }
+  return true;
+}
+
+// Identifies the sort of pattern where Boyer-Moore is faster than string search
+static bool UseBoyerMoore(HandleAtom pattern, JS::AutoCheckCannotGC& nogc) {
+  size_t length =
+      std::min(size_t(kMaxLookaheadForBoyerMoore), pattern->length());
+  if (length <= kPatternTooShortForBoyerMoore) {
+    return false;
+  }
+
+  if (pattern->hasLatin1Chars()) {
+    return HasFewDifferentCharacters(pattern->latin1Chars(nogc), length);
+  }
+  MOZ_ASSERT(pattern->hasTwoByteChars());
+  return HasFewDifferentCharacters(pattern->twoByteChars(nogc), length);
+}
+
+// Sample character frequency information for use in Boyer-Moore.
+static void SampleCharacters(FlatStringReader* sample_subject,
+                             RegExpCompiler& compiler) {
+  static const int kSampleSize = 128;
+  int chars_sampled = 0;
+
+  int length = sample_subject->length();
+
+  int half_way = (length - kSampleSize) / 2;
+  for (int i = std::max(0, half_way); i < length && chars_sampled < kSampleSize;
+       i++, chars_sampled++) {
+    compiler.frequency_collator()->CountCharacter(sample_subject->Get(i));
+  }
+}
+
+// Recursively walking the AST for a deeply nested regexp (like
+// `/(a(a(a(a(a(a(a(...(a)...))))))))/`) may overflow the stack while
+// compiling. To avoid this, we use V8's implementation of the Visitor
+// pattern to walk the AST first with an overly large stack frame.
+class RegExpDepthCheck final : public v8::internal::RegExpVisitor {
+ public:
+  explicit RegExpDepthCheck(JSContext* cx) : cx_(cx) {}
+
+  bool check(v8::internal::RegExpTree* root) {
+    return !!root->Accept(this, nullptr);
+  }
+
+  // Leaf nodes with no children
+#define LEAF_DEPTH(Kind)                                                \
+  void* Visit##Kind(v8::internal::RegExp##Kind* node, void*) override { \
+    uint8_t padding[FRAME_PADDING];                                     \
+    dummy_ = padding; /* Prevent padding from being optimized away.*/   \
+    return (void*)CheckRecursionLimitDontReport(cx_);                   \
+  }
+
+  LEAF_DEPTH(Assertion)
+  LEAF_DEPTH(Atom)
+  LEAF_DEPTH(BackReference)
+  LEAF_DEPTH(CharacterClass)
+  LEAF_DEPTH(Empty)
+  LEAF_DEPTH(Text)
+#undef LEAF_DEPTH
+
+  // Wrapper nodes with one child
+#define WRAPPER_DEPTH(Kind)                                             \
+  void* Visit##Kind(v8::internal::RegExp##Kind* node, void*) override { \
+    uint8_t padding[FRAME_PADDING];                                     \
+    dummy_ = padding; /* Prevent padding from being optimized away.*/   \
+    if (!CheckRecursionLimitDontReport(cx_)) {                          \
+      return nullptr;                                                   \
+    }                                                                   \
+    return node->body()->Accept(this, nullptr);                         \
+  }
+
+  WRAPPER_DEPTH(Capture)
+  WRAPPER_DEPTH(Group)
+  WRAPPER_DEPTH(Lookaround)
+  WRAPPER_DEPTH(Quantifier)
+#undef WRAPPER_DEPTH
+
+  void* VisitAlternative(v8::internal::RegExpAlternative* node,
+                         void*) override {
+    uint8_t padding[FRAME_PADDING];
+    dummy_ = padding; /* Prevent padding from being optimized away.*/
+    if (!CheckRecursionLimitDontReport(cx_)) {
+      return nullptr;
+    }
+    for (auto* child : *node->nodes()) {
+      if (!child->Accept(this, nullptr)) {
+        return nullptr;
+      }
+    }
+    return (void*)true;
+  }
+  void* VisitDisjunction(v8::internal::RegExpDisjunction* node,
+                         void*) override {
+    uint8_t padding[FRAME_PADDING];
+    dummy_ = padding; /* Prevent padding from being optimized away.*/
+    if (!CheckRecursionLimitDontReport(cx_)) {
+      return nullptr;
+    }
+    for (auto* child : *node->alternatives()) {
+      if (!child->Accept(this, nullptr)) {
+        return nullptr;
+      }
+    }
+    return (void*)true;
+  }
+
+ private:
+  JSContext* cx_;
+  void* dummy_ = nullptr;
+
+  // This size is picked to be comfortably larger than any
+  // RegExp*::ToNode stack frame.
+  static const size_t FRAME_PADDING = 256;
+};
+
+enum class AssembleResult {
+  Success,
+  TooLarge,
+  OutOfMemory,
+};
+
+static MOZ_MUST_USE AssembleResult Assemble(JSContext* cx,
+                                            RegExpCompiler* compiler,
+                                            RegExpCompileData* data,
+                                            MutableHandleRegExpShared re,
+                                            HandleAtom pattern, Zone* zone,
+                                            bool useNativeCode, bool isLatin1) {
+  // Because we create a StackMacroAssembler, this function is not allowed
+  // to GC. If needed, we allocate and throw errors in the caller.
+  Maybe<jit::JitContext> jctx;
+  Maybe<js::jit::StackMacroAssembler> stack_masm;
+  UniquePtr<RegExpMacroAssembler> masm;
+  if (useNativeCode) {
+    NativeRegExpMacroAssembler::Mode mode =
+        isLatin1 ? NativeRegExpMacroAssembler::LATIN1
+                 : NativeRegExpMacroAssembler::UC16;
+    // If we are compiling native code, we need a macroassembler,
+    // which needs a jit context.
+    jctx.emplace(cx, nullptr);
+    stack_masm.emplace();
+    uint32_t num_capture_registers = re->pairCount() * 2;
+    masm = MakeUnique<SMRegExpMacroAssembler>(cx, stack_masm.ref(), zone, mode,
+                                              num_capture_registers);
+  } else {
+    masm = MakeUnique<RegExpBytecodeGenerator>(cx->isolate, zone);
+  }
+  if (!masm) {
+    return AssembleResult::OutOfMemory;
+  }
+
+  bool isLargePattern =
+      pattern->length() > v8::internal::RegExp::kRegExpTooLargeToOptimize;
+  masm->set_slow_safe(isLargePattern);
+  if (compiler->optimize()) {
+    compiler->set_optimize(!isLargePattern);
+  }
+
+  // When matching a regexp with known maximum length that is anchored
+  // at the end, we may be able to skip the beginning of long input
+  // strings. This decision is made here because it depends on
+  // information in the AST that isn't replicated in the Node
+  // structure used inside the compiler.
+  bool is_start_anchored = data->tree->IsAnchoredAtStart();
+  bool is_end_anchored = data->tree->IsAnchoredAtEnd();
+  int max_length = data->tree->max_match();
+  static const int kMaxBacksearchLimit = 1024;
+  if (is_end_anchored && !is_start_anchored && !re->sticky() &&
+      max_length < kMaxBacksearchLimit) {
+    masm->SetCurrentPositionFromEnd(max_length);
+  }
+
+  if (re->global()) {
+    RegExpMacroAssembler::GlobalMode mode = RegExpMacroAssembler::GLOBAL;
+    if (data->tree->min_match() > 0) {
+      mode = RegExpMacroAssembler::GLOBAL_NO_ZERO_LENGTH_CHECK;
+    } else if (re->unicode()) {
+      mode = RegExpMacroAssembler::GLOBAL_UNICODE;
+    }
+    masm->set_global_mode(mode);
+  }
+
+  // Compile the regexp.
+  V8HandleString wrappedPattern(v8::internal::String(pattern), cx->isolate);
+  RegExpCompiler::CompilationResult result = compiler->Assemble(
+      cx->isolate, masm.get(), data->node, data->capture_count, wrappedPattern);
+  if (!result.Succeeded()) {
+    MOZ_ASSERT(result.error == RegExpError::kTooLarge);
+    return AssembleResult::TooLarge;
+  }
+  if (result.code->value().isUndefined()) {
+    // SMRegExpMacroAssembler::GetCode returns undefined on OOM.
+    MOZ_ASSERT(useNativeCode);
+    return AssembleResult::OutOfMemory;
+  }
+
+  re->updateMaxRegisters(result.num_registers);
+  if (useNativeCode) {
+    // Transfer ownership of the tables from the macroassembler to the
+    // RegExpShared.
+    SMRegExpMacroAssembler::TableVector& tables =
+        static_cast<SMRegExpMacroAssembler*>(masm.get())->tables();
+    for (uint32_t i = 0; i < tables.length(); i++) {
+      if (!re->addTable(std::move(tables[i]))) {
+        return AssembleResult::OutOfMemory;
+      }
+    }
+    re->setJitCode(v8::internal::Code::cast(*result.code).inner(), isLatin1);
+  } else {
+    // Transfer ownership of the bytecode from the HandleScope to the
+    // RegExpShared.
+    ByteArray bytecode =
+        v8::internal::ByteArray::cast(*result.code).takeOwnership(cx->isolate);
+    uint32_t length = bytecode->length;
+    re->setByteCode(bytecode.release(), isLatin1);
+    // js::AddCellMemory(re, length, MemoryUse::RegExpSharedBytecode);
+  }
+
+  return AssembleResult::Success;
+}
+
+bool CompilePattern(JSContext* cx, MutableHandleRegExpShared re,
+                    HandleLinearString input, RegExpShared::CodeKind codeKind) {
+  RootedAtom pattern(cx, re->getSource());
+  JS::RegExpFlags flags = re->getFlags();
+  LifoAllocScope allocScope(&cx->tempLifoAlloc());
+  HandleScope handleScope(cx->isolate);
+  Zone zone(allocScope.alloc());
+
+  RegExpCompileData data;
+  {
+    FlatStringReader patternBytes(cx, pattern);
+    if (!RegExpParser::ParseRegExp(cx->isolate, &zone, &patternBytes, flags,
+                                   &data)) {
+      MOZ_ASSERT(data.error == RegExpError::kStackOverflow);
+      JS::CompileOptions options(cx);
+      DummyTokenStream dummyTokenStream(cx, options);
+      ReportSyntaxError(dummyTokenStream, data, pattern);
+      return false;
+    }
+  }
+
+  // Avoid stack overflow while recursively walking the AST.
+  RegExpDepthCheck depthCheck(cx);
+  if (!depthCheck.check(data.tree)) {
+    JS_ReportErrorASCII(cx, "regexp too big");
+    return false;
+  }
+
+  if (re->kind() == RegExpShared::Kind::Unparsed) {
+    // This is the first time we have compiled this regexp.
+    // First, check to see if we should use simple string search
+    // with an atom.
+    if (!flags.ignoreCase() && !flags.sticky()) {
+      RootedAtom searchAtom(cx);
+      if (data.simple) {
+        // The parse-tree is a single atom that is equal to the pattern.
+        searchAtom = re->getSource();
+      } else if (data.tree->IsAtom() && data.capture_count == 0) {
+        // The parse-tree is a single atom that is not equal to the pattern.
+        v8::internal::RegExpAtom* atom = data.tree->AsAtom();
+        const char16_t* twoByteChars = atom->data().begin();
+        searchAtom = AtomizeChars(cx, twoByteChars, atom->length());
+        if (!searchAtom) {
+          return false;
+        }
+      }
+      JS::AutoCheckCannotGC nogc(cx);
+      if (searchAtom && !UseBoyerMoore(searchAtom, nogc)) {
+        re->useAtomMatch(searchAtom);
+        return true;
+      }
+    }
+    if (!data.capture_name_map.is_null()) {
+      RootedNativeObject namedCaptures(cx, data.capture_name_map->inner());
+      if (!RegExpShared::initializeNamedCaptures(cx, re, namedCaptures)) {
+        return false;
+      }
+    }
+    // All fallible initialization has succeeded, so we can change state.
+    // Add one to capture_count to account for the whole-match capture.
+    uint32_t pairCount = data.capture_count + 1;
+    re->useRegExpMatch(pairCount);
+  }
+
+  MOZ_ASSERT(re->kind() == RegExpShared::Kind::RegExp);
+
+  RegExpCompiler compiler(cx->isolate, &zone, data.capture_count,
+                          input->hasLatin1Chars());
+
+  bool isLatin1 = input->hasLatin1Chars();
+
+  FlatStringReader sample_subject(cx, input);
+  SampleCharacters(&sample_subject, compiler);
+  data.node = compiler.PreprocessRegExp(&data, flags, isLatin1);
+  data.error = AnalyzeRegExp(cx->isolate, isLatin1, data.node);
+  if (data.error != RegExpError::kNone) {
+    MOZ_ASSERT(data.error == RegExpError::kAnalysisStackOverflow);
+    ReportOverRecursed(cx);
+    return false;
+  }
+
+  bool useNativeCode = codeKind == RegExpShared::CodeKind::Jitcode;
+  MOZ_ASSERT_IF(useNativeCode, IsNativeRegExpEnabled(cx));
+
+  switch (Assemble(cx, &compiler, &data, re, pattern, &zone, useNativeCode,
+                   isLatin1)) {
+    case AssembleResult::TooLarge:
+      JS_ReportErrorASCII(cx, "regexp too big");
+      return false;
+    case AssembleResult::OutOfMemory:
+      ReportOutOfMemory(cx);
+      return false;
+    case AssembleResult::Success:
+      break;
+  }
+  return true;
+}
+
+template <typename CharT>
+RegExpRunStatus ExecuteRaw(jit::JitCode* code, const CharT* chars,
+                           size_t length, size_t startIndex,
+                           MatchPairs* matches) {
+  InputOutputData data(chars, chars + length, startIndex, matches);
+
+  static_assert(RegExpRunStatus_Error ==
+                v8::internal::RegExp::kInternalRegExpException);
+  static_assert(RegExpRunStatus_Success ==
+                v8::internal::RegExp::kInternalRegExpSuccess);
+  static_assert(RegExpRunStatus_Success_NotFound ==
+                v8::internal::RegExp::kInternalRegExpFailure);
+
+  typedef int (*RegExpCodeSignature)(InputOutputData*);
+  auto function = reinterpret_cast<RegExpCodeSignature>(code->raw());
+  {
+    JS::AutoSuppressGCAnalysis nogc;
+    return (RegExpRunStatus)CALL_GENERATED_1(function, &data);
+  }
+}
+
+RegExpRunStatus Interpret(JSContext* cx, MutableHandleRegExpShared re,
+                          HandleLinearString input, size_t startIndex,
+                          MatchPairs* matches) {
+  MOZ_ASSERT(re->getByteCode(input->hasLatin1Chars()));
+
+  HandleScope handleScope(cx->isolate);
+  V8HandleRegExp wrappedRegExp(v8::internal::JSRegExp(re), cx->isolate);
+  V8HandleString wrappedInput(v8::internal::String(input), cx->isolate);
+
+  static_assert(RegExpRunStatus_Error ==
+                v8::internal::RegExp::kInternalRegExpException);
+  static_assert(RegExpRunStatus_Success ==
+                v8::internal::RegExp::kInternalRegExpSuccess);
+  static_assert(RegExpRunStatus_Success_NotFound ==
+                v8::internal::RegExp::kInternalRegExpFailure);
+
+  RegExpRunStatus status =
+      (RegExpRunStatus)IrregexpInterpreter::MatchForCallFromRuntime(
+          cx->isolate, wrappedRegExp, wrappedInput, matches->pairsRaw(),
+          matches->pairCount() * 2, startIndex);
+
+  MOZ_ASSERT(status == RegExpRunStatus_Error ||
+             status == RegExpRunStatus_Success ||
+             status == RegExpRunStatus_Success_NotFound);
+
+  return status;
+}
+
+RegExpRunStatus Execute(JSContext* cx, MutableHandleRegExpShared re,
+                        HandleLinearString input, size_t startIndex,
+                        MatchPairs* matches) {
+  bool latin1 = input->hasLatin1Chars();
+  jit::JitCode* jitCode = re->getJitCode(latin1);
+  bool isCompiled = !!jitCode;
+
+  // Reset the Irregexp backtrack stack if it grows during execution.
+  irregexp::RegExpStackScope stackScope(cx->isolate);
+
+  if (isCompiled) {
+    JS::AutoCheckCannotGC nogc;
+    if (latin1) {
+      return ExecuteRaw(jitCode, input->latin1Chars(nogc), input->length(),
+                        startIndex, matches);
+    }
+    return ExecuteRaw(jitCode, input->twoByteChars(nogc), input->length(),
+                      startIndex, matches);
+  }
+
+  return Interpret(cx, re, input, startIndex, matches);
+}
+
+}  // namespace irregexp
+}  // namespace js
diff -Nrup mozilla/js/src/irregexp/RegExpAPI.h mozilla-OK/js/src/irregexp/RegExpAPI.h
--- mozilla/js/src/irregexp/RegExpAPI.h	1970-01-01 03:00:00.000000000 +0300
+++ mozilla-OK/js/src/irregexp/RegExpAPI.h	2022-04-22 05:08:45.973075117 +0300
@@ -0,0 +1,46 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/.
+ *
+ * This Source Code Form is "Incompatible With Secondary Licenses", as
+ * defined by the Mozilla Public License, v. 2.0.
+ */
+
+/* This is the interface that the regexp engine exposes to SpiderMonkey. */
+
+#ifndef regexp_RegExpAPI_h
+#define regexp_RegExpAPI_h
+
+#include "mozilla/MemoryReporting.h"
+
+#include "frontend/TokenStream.h"
+#include "jscntxt.h"
+#include "jsgc.h"
+#include "vm/RegExpObject.h"
+
+namespace js {
+namespace irregexp {
+
+Isolate* CreateIsolate(JSContext* cx);
+void DestroyIsolate(Isolate* isolate);
+
+size_t IsolateSizeOfIncludingThis(Isolate* isolate,
+                                  mozilla::MallocSizeOf mallocSizeOf);
+
+bool CheckPatternSyntax(JSContext* cx, frontend::TokenStreamAnyChars& ts,
+                        const mozilla::Range<const char16_t> chars,
+                        JS::RegExpFlags flags);
+bool CheckPatternSyntax(JSContext* cx, frontend::TokenStreamAnyChars& ts,
+                        HandleAtom pattern, JS::RegExpFlags flags);
+bool CompilePattern(JSContext* cx, MutableHandleRegExpShared re,
+                    HandleLinearString input, RegExpShared::CodeKind codeKind);
+
+RegExpRunStatus Execute(JSContext* cx, MutableHandleRegExpShared re,
+                        HandleLinearString input, size_t start,
+                        MatchPairs* matches);
+
+}  // namespace irregexp
+}  // namespace js
+
+#endif /* regexp_RegExpAPI_h */
diff -Nrup mozilla/js/src/irregexp/RegExpNativeMacroAssembler.cpp mozilla-OK/js/src/irregexp/RegExpNativeMacroAssembler.cpp
--- mozilla/js/src/irregexp/RegExpNativeMacroAssembler.cpp	1970-01-01 03:00:00.000000000 +0300
+++ mozilla-OK/js/src/irregexp/RegExpNativeMacroAssembler.cpp	2022-04-22 05:08:42.155101896 +0300
@@ -0,0 +1,1250 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+// Copyright 2020 the V8 project authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "irregexp/imported/regexp-macro-assembler-arch.h"
+#include "irregexp/imported/regexp-stack.h"
+#include "irregexp/imported/special-case.h"
+#include "jit/Linker.h"
+#include "gc/Zone.h"
+#include "vm/MatchPairs.h"
+
+#include "jit/MacroAssembler-inl.h"
+
+using namespace js;
+using namespace js::irregexp;
+using namespace js::jit;
+
+namespace v8 {
+namespace internal {
+
+using js::MatchPairs;
+using js::jit::AbsoluteAddress;
+using js::jit::Address;
+using js::jit::AllocatableGeneralRegisterSet;
+using js::jit::Assembler;
+using js::jit::BaseIndex;
+using js::jit::CodeLocationLabel;
+using js::jit::GeneralRegisterBackwardIterator;
+using js::jit::GeneralRegisterForwardIterator;
+using js::jit::GeneralRegisterSet;
+using js::jit::Imm32;
+using js::jit::ImmPtr;
+using js::jit::ImmWord;
+using js::jit::JitCode;
+using js::jit::Linker;
+using js::jit::LiveGeneralRegisterSet;
+using js::jit::Register;
+using js::jit::Registers;
+using js::jit::StackMacroAssembler;
+
+SMRegExpMacroAssembler::SMRegExpMacroAssembler(JSContext* cx,
+                                               StackMacroAssembler& masm,
+                                               Zone* zone, Mode mode,
+                                               uint32_t num_capture_registers)
+    : NativeRegExpMacroAssembler(cx->isolate, zone),
+      cx_(cx),
+      masm_(masm),
+      mode_(mode),
+      num_registers_(num_capture_registers),
+      num_capture_registers_(num_capture_registers) {
+  // Each capture has a start and an end register
+  MOZ_ASSERT(num_capture_registers_ % 2 == 0);
+
+  AllocatableGeneralRegisterSet regs(GeneralRegisterSet::All());
+
+  temp0_ = regs.takeAny();
+  temp1_ = regs.takeAny();
+  temp2_ = regs.takeAny();
+  input_end_pointer_ = regs.takeAny();
+  current_character_ = regs.takeAny();
+  current_position_ = regs.takeAny();
+  backtrack_stack_pointer_ = regs.takeAny();
+  savedRegisters_ = js::jit::SavedNonVolatileRegisters(regs);
+
+  masm_.jump(&entry_label_);  // We'll generate the entry code later
+  masm_.bind(&start_label_);  // and continue from here.
+}
+
+int SMRegExpMacroAssembler::stack_limit_slack() {
+  return RegExpStack::kStackLimitSlack;
+}
+
+void SMRegExpMacroAssembler::AdvanceCurrentPosition(int by) {
+  if (by != 0) {
+    masm_.addPtr(Imm32(by * char_size()), current_position_);
+  }
+}
+
+void SMRegExpMacroAssembler::AdvanceRegister(int reg, int by) {
+  MOZ_ASSERT(reg >= 0 && reg < num_registers_);
+  if (by != 0) {
+    masm_.addPtr(Imm32(by), register_location(reg));
+  }
+}
+
+void SMRegExpMacroAssembler::Backtrack() {
+  // Check for an interrupt. We have to restart from the beginning if we
+  // are interrupted, so we only check for urgent interrupts.
+  js::jit::Label noInterrupt;
+  masm_.branch32(Assembler::Equal,
+                 AbsoluteAddress(cx_->addressOfInterruptRegExpJit()), Imm32(0),
+                 &noInterrupt);
+  masm_.movePtr(ImmWord(js::RegExpRunStatus_Error), temp0_);
+  masm_.jump(&exit_label_);
+  masm_.bind(&noInterrupt);
+
+  // Pop code location from backtrack stack and jump to location.
+  Pop(temp0_);
+  masm_.jump(temp0_);
+}
+
+void SMRegExpMacroAssembler::Bind(Label* label) {
+  masm_.bind(label->inner());
+  if (label->patchOffset_.bound()) {
+    AddLabelPatch(label->patchOffset_, label->pos());
+  }
+}
+
+// Check if current_position + cp_offset is the input start
+void SMRegExpMacroAssembler::CheckAtStartImpl(int cp_offset, Label* on_cond,
+                                              Assembler::Condition cond) {
+  Address addr(current_position_, cp_offset * char_size());
+  masm_.computeEffectiveAddress(addr, temp0_);
+
+  masm_.branchPtr(cond, inputStart(), temp0_, LabelOrBacktrack(on_cond));
+}
+
+void SMRegExpMacroAssembler::CheckAtStart(int cp_offset, Label* on_at_start) {
+  CheckAtStartImpl(cp_offset, on_at_start, Assembler::Equal);
+}
+
+void SMRegExpMacroAssembler::CheckNotAtStart(int cp_offset,
+                                             Label* on_not_at_start) {
+  CheckAtStartImpl(cp_offset, on_not_at_start, Assembler::NotEqual);
+}
+
+void SMRegExpMacroAssembler::CheckCharacterImpl(Imm32 c, Label* on_cond,
+                                                Assembler::Condition cond) {
+  masm_.branch32(cond, current_character_, c, LabelOrBacktrack(on_cond));
+}
+
+void SMRegExpMacroAssembler::CheckCharacter(uint32_t c, Label* on_equal) {
+  CheckCharacterImpl(Imm32(c), on_equal, Assembler::Equal);
+}
+
+void SMRegExpMacroAssembler::CheckNotCharacter(uint32_t c,
+                                               Label* on_not_equal) {
+  CheckCharacterImpl(Imm32(c), on_not_equal, Assembler::NotEqual);
+}
+
+void SMRegExpMacroAssembler::CheckCharacterGT(uc16 c, Label* on_greater) {
+  CheckCharacterImpl(Imm32(c), on_greater, Assembler::GreaterThan);
+}
+
+void SMRegExpMacroAssembler::CheckCharacterLT(uc16 c, Label* on_less) {
+  CheckCharacterImpl(Imm32(c), on_less, Assembler::LessThan);
+}
+
+// Bitwise-and the current character with mask and then check for a
+// match with c.
+void SMRegExpMacroAssembler::CheckCharacterAfterAndImpl(uint32_t c,
+                                                        uint32_t mask,
+                                                        Label* on_cond,
+                                                        bool is_not) {
+  if (c == 0) {
+    Assembler::Condition cond = is_not ? Assembler::NonZero : Assembler::Zero;
+    masm_.branchTest32(cond, current_character_, Imm32(mask),
+                       LabelOrBacktrack(on_cond));
+  } else {
+    Assembler::Condition cond = is_not ? Assembler::NotEqual : Assembler::Equal;
+    masm_.move32(Imm32(mask), temp0_);
+    masm_.and32(current_character_, temp0_);
+    masm_.branch32(cond, temp0_, Imm32(c), LabelOrBacktrack(on_cond));
+  }
+}
+
+void SMRegExpMacroAssembler::CheckCharacterAfterAnd(uint32_t c, uint32_t mask,
+                                                    Label* on_equal) {
+  CheckCharacterAfterAndImpl(c, mask, on_equal, /*is_not =*/false);
+}
+
+void SMRegExpMacroAssembler::CheckNotCharacterAfterAnd(uint32_t c,
+                                                       uint32_t mask,
+                                                       Label* on_not_equal) {
+  CheckCharacterAfterAndImpl(c, mask, on_not_equal, /*is_not =*/true);
+}
+
+// Subtract minus from the current character, then bitwise-and the
+// result with mask, then check for a match with c.
+void SMRegExpMacroAssembler::CheckNotCharacterAfterMinusAnd(
+    uc16 c, uc16 minus, uc16 mask, Label* on_not_equal) {
+  masm_.computeEffectiveAddress(Address(current_character_, -minus), temp0_);
+  if (c == 0) {
+    masm_.branchTest32(Assembler::NonZero, temp0_, Imm32(mask),
+                       LabelOrBacktrack(on_not_equal));
+  } else {
+    masm_.and32(Imm32(mask), temp0_);
+    masm_.branch32(Assembler::NotEqual, temp0_, Imm32(c),
+                   LabelOrBacktrack(on_not_equal));
+  }
+}
+
+// If the current position matches the position stored on top of the backtrack
+// stack, pops the backtrack stack and branches to the given label.
+void SMRegExpMacroAssembler::CheckGreedyLoop(Label* on_equal) {
+  js::jit::Label fallthrough;
+  masm_.branchPtr(Assembler::NotEqual, Address(backtrack_stack_pointer_, 0),
+                  current_position_, &fallthrough);
+  masm_.addPtr(Imm32(sizeof(void*)), backtrack_stack_pointer_);  // Pop.
+  JumpOrBacktrack(on_equal);
+  masm_.bind(&fallthrough);
+}
+
+void SMRegExpMacroAssembler::CheckCharacterInRangeImpl(
+    uc16 from, uc16 to, Label* on_cond, Assembler::Condition cond) {
+  // x is in [from,to] if unsigned(x - from) <= to - from
+  masm_.computeEffectiveAddress(Address(current_character_, -from), temp0_);
+  masm_.branch32(cond, temp0_, Imm32(to - from), LabelOrBacktrack(on_cond));
+}
+
+void SMRegExpMacroAssembler::CheckCharacterInRange(uc16 from, uc16 to,
+                                                   Label* on_in_range) {
+  CheckCharacterInRangeImpl(from, to, on_in_range, Assembler::BelowOrEqual);
+}
+
+void SMRegExpMacroAssembler::CheckCharacterNotInRange(uc16 from, uc16 to,
+                                                      Label* on_not_in_range) {
+  CheckCharacterInRangeImpl(from, to, on_not_in_range, Assembler::Above);
+}
+
+void SMRegExpMacroAssembler::CheckBitInTable(Handle<ByteArray> table,
+                                             Label* on_bit_set) {
+  // Claim ownership of the ByteArray from the current HandleScope.
+  // ByteArrays are allocated on the C++ heap and are (eventually)
+  // owned by the RegExpShared.
+  PseudoHandle<ByteArrayData> rawTable = table->takeOwnership(isolate());
+
+  masm_.movePtr(ImmPtr(rawTable->data()), temp0_);
+
+  masm_.move32(Imm32(kTableMask), temp1_);
+  masm_.and32(current_character_, temp1_);
+
+  masm_.load8ZeroExtend(BaseIndex(temp0_, temp1_, js::jit::TimesOne), temp0_);
+  masm_.branchTest32(Assembler::NonZero, temp0_, temp0_,
+                     LabelOrBacktrack(on_bit_set));
+
+  // Transfer ownership of |rawTable| to the |tables_| vector.
+  AddTable(std::move(rawTable));
+}
+
+void SMRegExpMacroAssembler::CheckNotBackReferenceImpl(int start_reg,
+                                                       bool read_backward,
+                                                       bool unicode,
+                                                       Label* on_no_match,
+                                                       bool ignore_case) {
+  js::jit::Label fallthrough;
+
+  // Captures are stored as a sequential pair of registers.
+  // Find the length of the back-referenced capture and load the
+  // capture's start index into current_character_.
+  masm_.loadPtr(register_location(start_reg),  // index of start
+                current_character_);
+  masm_.loadPtr(register_location(start_reg + 1), temp0_);  // index of end
+  masm_.subPtr(current_character_, temp0_);                 // length of capture
+
+  // Capture registers are either both set or both cleared.
+  // If the capture length is zero, then the capture is either empty or cleared.
+  // Fall through in both cases.
+  masm_.branchPtr(Assembler::Equal, temp0_, ImmWord(0), &fallthrough);
+
+  // Check that there are sufficient characters left in the input.
+  if (read_backward) {
+    // If start + len > current, there isn't enough room for a
+    // lookbehind backreference.
+    masm_.loadPtr(inputStart(), temp1_);
+    masm_.addPtr(temp0_, temp1_);
+    masm_.branchPtr(Assembler::GreaterThan, temp1_, current_position_,
+                    LabelOrBacktrack(on_no_match));
+  } else {
+    // current_position_ is the negative offset from the end.
+    // If current + len > 0, there isn't enough room for a backreference.
+    masm_.movePtr(current_position_, temp1_);
+    masm_.addPtr(temp0_, temp1_);
+    masm_.branchPtr(Assembler::GreaterThan, temp1_, ImmWord(0),
+                    LabelOrBacktrack(on_no_match));
+  }
+
+  if (mode_ == UC16 && ignore_case) {
+    // We call a helper function for case-insensitive non-latin1 strings.
+
+    // Save volatile regs. temp1_, temp2_, and current_character_
+    // don't need to be saved.  current_position_ needs to be saved
+    // even if it's non-volatile, because we modify it to use as an argument.
+    LiveGeneralRegisterSet volatileRegs(GeneralRegisterSet::Volatile());
+    volatileRegs.addUnchecked(current_position_);
+    volatileRegs.takeUnchecked(temp1_);
+    volatileRegs.takeUnchecked(temp2_);
+    volatileRegs.takeUnchecked(current_character_);
+    masm_.PushRegsInMask(volatileRegs);
+
+    // Parameters are
+    //   Address captured - Address of captured substring's start.
+    //   Address current - Address of current character position.
+    //   size_t byte_length - length of capture (in bytes)
+
+    // Compute |captured|
+    masm_.addPtr(input_end_pointer_, current_character_);
+
+    // Compute |current|
+    masm_.addPtr(input_end_pointer_, current_position_);
+    if (read_backward) {
+      // Offset by length when matching backwards.
+      masm_.subPtr(temp0_, current_position_);
+    }
+
+    masm_.setupUnalignedABICall(temp1_);
+    masm_.passABIArg(current_character_);
+    masm_.passABIArg(current_position_);
+    masm_.passABIArg(temp0_);
+
+    if (unicode) {
+      uint32_t (*fun)(const char16_t*, const char16_t*, size_t) =
+          CaseInsensitiveCompareUnicode;
+      masm_.callWithABI(JS_FUNC_TO_DATA_PTR(void*, fun));
+    } else {
+      uint32_t (*fun)(const char16_t*, const char16_t*, size_t) =
+          CaseInsensitiveCompareNonUnicode;
+      masm_.callWithABI(JS_FUNC_TO_DATA_PTR(void*, fun));
+    }
+    masm_.storeCallInt32Result(temp1_);
+    masm_.PopRegsInMask(volatileRegs);
+    masm_.branchTest32(Assembler::Zero, temp1_, temp1_,
+                       LabelOrBacktrack(on_no_match));
+
+    // On success, advance position by length of capture
+    if (read_backward) {
+      masm_.subPtr(temp0_, current_position_);
+    } else {
+      masm_.addPtr(temp0_, current_position_);
+    }
+
+    masm_.bind(&fallthrough);
+    return;
+  }
+
+  // We will be modifying current_position_. Save it in case the match fails.
+  masm_.push(current_position_);
+
+  // Compute start of capture string
+  masm_.addPtr(input_end_pointer_, current_character_);
+
+  // Compute start of match string
+  masm_.addPtr(input_end_pointer_, current_position_);
+  if (read_backward) {
+    // Offset by length when matching backwards.
+    masm_.subPtr(temp0_, current_position_);
+  }
+
+  // Compute end of match string
+  masm_.addPtr(current_position_, temp0_);
+
+  js::jit::Label success;
+  js::jit::Label fail;
+  js::jit::Label loop;
+  masm_.bind(&loop);
+
+  // Load next character from each string.
+  if (mode_ == LATIN1) {
+    masm_.load8ZeroExtend(Address(current_character_, 0), temp1_);
+    masm_.load8ZeroExtend(Address(current_position_, 0), temp2_);
+  } else {
+    masm_.load16ZeroExtend(Address(current_character_, 0), temp1_);
+    masm_.load16ZeroExtend(Address(current_position_, 0), temp2_);
+  }
+
+  if (ignore_case) {
+    MOZ_ASSERT(mode_ == LATIN1);
+    // Try exact match.
+    js::jit::Label loop_increment;
+    masm_.branch32(Assembler::Equal, temp1_, temp2_, &loop_increment);
+
+    // Mismatch. Try case-insensitive match.
+    // Force the capture character to lower case (by setting bit 0x20)
+    // then check to see if it is a letter.
+    js::jit::Label convert_match;
+    masm_.or32(Imm32(0x20), temp1_);
+
+    // Check if it is in [a,z].
+    masm_.computeEffectiveAddress(Address(temp1_, -'a'), temp2_);
+    masm_.branch32(Assembler::BelowOrEqual, temp2_, Imm32('z' - 'a'),
+                   &convert_match);
+    // Check for values in range [224,254].
+    // Exclude 247 (U+00F7 DIVISION SIGN).
+    masm_.sub32(Imm32(224 - 'a'), temp2_);
+    masm_.branch32(Assembler::Above, temp2_, Imm32(254 - 224), &fail);
+    masm_.branch32(Assembler::Equal, temp2_, Imm32(247 - 224), &fail);
+
+    // Capture character is lower case. Convert match character
+    // to lower case and compare.
+    masm_.bind(&convert_match);
+    masm_.load8ZeroExtend(Address(current_position_, 0), temp2_);
+    masm_.or32(Imm32(0x20), temp2_);
+    masm_.branch32(Assembler::NotEqual, temp1_, temp2_, &fail);
+
+    masm_.bind(&loop_increment);
+  } else {
+    // Fail if characters do not match.
+    masm_.branch32(Assembler::NotEqual, temp1_, temp2_, &fail);
+  }
+
+  // Increment pointers into match and capture strings.
+  masm_.addPtr(Imm32(char_size()), current_character_);
+  masm_.addPtr(Imm32(char_size()), current_position_);
+
+  // Loop if we have not reached the end of the match string.
+  masm_.branchPtr(Assembler::Below, current_position_, temp0_, &loop);
+  masm_.jump(&success);
+
+  // If we fail, restore current_position_ and branch.
+  masm_.bind(&fail);
+  masm_.pop(current_position_);
+  JumpOrBacktrack(on_no_match);
+
+  masm_.bind(&success);
+
+  // Drop saved value of current_position_
+  masm_.addToStackPtr(Imm32(sizeof(uintptr_t)));
+
+  // current_position_ is a pointer. Convert it back to an offset.
+  masm_.subPtr(input_end_pointer_, current_position_);
+  if (read_backward) {
+    // Subtract match length if we matched backward
+    masm_.addPtr(register_location(start_reg), current_position_);
+    masm_.subPtr(register_location(start_reg + 1), current_position_);
+  }
+
+  masm_.bind(&fallthrough);
+}
+
+// Branch if a back-reference does not match a previous capture.
+void SMRegExpMacroAssembler::CheckNotBackReference(int start_reg,
+                                                   bool read_backward,
+                                                   Label* on_no_match) {
+  CheckNotBackReferenceImpl(start_reg, read_backward, /*unicode = */ false,
+                            on_no_match, /*ignore_case = */ false);
+}
+
+void SMRegExpMacroAssembler::CheckNotBackReferenceIgnoreCase(
+    int start_reg, bool read_backward, bool unicode, Label* on_no_match) {
+  CheckNotBackReferenceImpl(start_reg, read_backward, unicode, on_no_match,
+                            /*ignore_case = */ true);
+}
+
+// Checks whether the given offset from the current position is
+// inside the input string.
+void SMRegExpMacroAssembler::CheckPosition(int cp_offset,
+                                           Label* on_outside_input) {
+  // Note: current_position_ is a (negative) byte offset relative to
+  // the end of the input string.
+  if (cp_offset >= 0) {
+    //      end + current + offset >= end
+    // <=>        current + offset >= 0
+    // <=>        current          >= -offset
+    masm_.branchPtr(Assembler::GreaterThanOrEqual, current_position_,
+                    ImmWord(-cp_offset * char_size()),
+                    LabelOrBacktrack(on_outside_input));
+  } else {
+    // Compute offset position
+    masm_.computeEffectiveAddress(
+        Address(current_position_, cp_offset * char_size()), temp0_);
+
+    // Compare to start of input.
+    masm_.branchPtr(Assembler::GreaterThan, inputStart(), temp0_,
+                    LabelOrBacktrack(on_outside_input));
+  }
+}
+
+// This function attempts to generate special case code for character classes.
+// Returns true if a special case is generated.
+// Otherwise returns false and generates no code.
+bool SMRegExpMacroAssembler::CheckSpecialCharacterClass(uc16 type,
+                                                        Label* on_no_match) {
+  js::jit::Label* no_match = LabelOrBacktrack(on_no_match);
+
+  // Note: throughout this function, range checks (c in [min, max])
+  // are implemented by an unsigned (c - min) <= (max - min) check.
+  switch (type) {
+    case 's': {
+      // Match space-characters
+      if (mode_ != LATIN1) {
+        return false;
+      }
+      js::jit::Label success;
+      // One byte space characters are ' ', '\t'..'\r', and '\u00a0' (NBSP).
+
+      // Check ' '
+      masm_.branch32(Assembler::Equal, current_character_, Imm32(' '),
+                     &success);
+
+      // Check '\t'..'\r'
+      masm_.computeEffectiveAddress(Address(current_character_, -'\t'), temp0_);
+      masm_.branch32(Assembler::BelowOrEqual, temp0_, Imm32('\r' - '\t'),
+                     &success);
+
+      // Check \u00a0.
+      masm_.branch32(Assembler::NotEqual, temp0_, Imm32(0x00a0 - '\t'),
+                     no_match);
+
+      masm_.bind(&success);
+      return true;
+    }
+    case 'S':
+      // The emitted code for generic character classes is good enough.
+      return false;
+    case 'd':
+      // Match latin1 digits ('0'-'9')
+      masm_.computeEffectiveAddress(Address(current_character_, -'0'), temp0_);
+      masm_.branch32(Assembler::Above, temp0_, Imm32('9' - '0'), no_match);
+      return true;
+    case 'D':
+      // Match anything except latin1 digits ('0'-'9')
+      masm_.computeEffectiveAddress(Address(current_character_, -'0'), temp0_);
+      masm_.branch32(Assembler::BelowOrEqual, temp0_, Imm32('9' - '0'),
+                     no_match);
+      return true;
+    case '.':
+      // Match non-newlines. This excludes '\n' (0x0a), '\r' (0x0d),
+      // U+2028 LINE SEPARATOR, and U+2029 PARAGRAPH SEPARATOR.
+      // See https://tc39.es/ecma262/#prod-LineTerminator
+
+      // To test for 0x0a and 0x0d efficiently, we XOR the input with 1.
+      // This converts 0x0a to 0x0b, and 0x0d to 0x0c, allowing us to
+      // test for the contiguous range 0x0b..0x0c.
+      masm_.move32(current_character_, temp0_);
+      masm_.xor32(Imm32(0x01), temp0_);
+      masm_.sub32(Imm32(0x0b), temp0_);
+      masm_.branch32(Assembler::BelowOrEqual, temp0_, Imm32(0x0c - 0x0b),
+                     no_match);
+
+      if (mode_ == UC16) {
+        // Compare original value to 0x2028 and 0x2029, using the already
+        // computed (current_char ^ 0x01 - 0x0b). I.e., check for
+        // 0x201d (0x2028 - 0x0b) or 0x201e.
+        masm_.sub32(Imm32(0x2028 - 0x0b), temp0_);
+        masm_.branch32(Assembler::BelowOrEqual, temp0_, Imm32(0x2029 - 0x2028),
+                       no_match);
+      }
+      return true;
+    case 'w':
+      // \w matches the set of 63 characters defined in Runtime Semantics:
+      // WordCharacters. We use a static lookup table, which is defined in
+      // regexp-macro-assembler.cc.
+      // Note: if both Unicode and IgnoreCase are true, \w matches a
+      // larger set of characters. That case is handled elsewhere.
+      if (mode_ != LATIN1) {
+        masm_.branch32(Assembler::Above, current_character_, Imm32('z'),
+                       no_match);
+      }
+      static_assert(
+          arraysize(word_character_map) > unibrow::Latin1::kMaxChar,
+          "regex: arraysize(word_character_map) > unibrow::Latin1::kMaxChar");
+      masm_.movePtr(ImmPtr(word_character_map), temp0_);
+      masm_.load8ZeroExtend(
+          BaseIndex(temp0_, current_character_, js::jit::TimesOne), temp0_);
+      masm_.branchTest32(Assembler::Zero, temp0_, temp0_, no_match);
+      return true;
+    case 'W': {
+      // See 'w' above.
+      js::jit::Label done;
+      if (mode_ != LATIN1) {
+        masm_.branch32(Assembler::Above, current_character_, Imm32('z'), &done);
+      }
+      static_assert(
+          arraysize(word_character_map) > unibrow::Latin1::kMaxChar,
+          "regex: arraysize(word_character_map) > unibrow::Latin1::kMaxChar");
+      masm_.movePtr(ImmPtr(word_character_map), temp0_);
+      masm_.load8ZeroExtend(
+          BaseIndex(temp0_, current_character_, js::jit::TimesOne), temp0_);
+      masm_.branchTest32(Assembler::NonZero, temp0_, temp0_, no_match);
+      if (mode_ != LATIN1) {
+        masm_.bind(&done);
+      }
+      return true;
+    }
+      ////////////////////////////////////////////////////////////////////////
+      // Non-standard classes (with no syntactic shorthand) used internally //
+      ////////////////////////////////////////////////////////////////////////
+    case '*':
+      // Match any character
+      return true;
+    case 'n':
+      // Match newlines. The opposite of '.'. See '.' above.
+      masm_.move32(current_character_, temp0_);
+      masm_.xor32(Imm32(0x01), temp0_);
+      masm_.sub32(Imm32(0x0b), temp0_);
+      if (mode_ == LATIN1) {
+        masm_.branch32(Assembler::Above, temp0_, Imm32(0x0c - 0x0b), no_match);
+      } else {
+        MOZ_ASSERT(mode_ == UC16);
+        js::jit::Label done;
+        masm_.branch32(Assembler::BelowOrEqual, temp0_, Imm32(0x0c - 0x0b),
+                       &done);
+
+        // Compare original value to 0x2028 and 0x2029, using the already
+        // computed (current_char ^ 0x01 - 0x0b). I.e., check for
+        // 0x201d (0x2028 - 0x0b) or 0x201e.
+        masm_.sub32(Imm32(0x2028 - 0x0b), temp0_);
+        masm_.branch32(Assembler::Above, temp0_, Imm32(0x2029 - 0x2028),
+                       no_match);
+        masm_.bind(&done);
+      }
+      return true;
+
+      // No custom implementation
+    default:
+      return false;
+  }
+}
+
+void SMRegExpMacroAssembler::Fail() {
+  masm_.movePtr(ImmWord(js::RegExpRunStatus_Success_NotFound), temp0_);
+  masm_.jump(&exit_label_);
+}
+
+void SMRegExpMacroAssembler::GoTo(Label* to) {
+  masm_.jump(LabelOrBacktrack(to));
+}
+
+void SMRegExpMacroAssembler::IfRegisterGE(int reg, int comparand,
+                                          Label* if_ge) {
+  masm_.branchPtr(Assembler::GreaterThanOrEqual, register_location(reg),
+                  ImmWord(comparand), LabelOrBacktrack(if_ge));
+}
+
+void SMRegExpMacroAssembler::IfRegisterLT(int reg, int comparand,
+                                          Label* if_lt) {
+  masm_.branchPtr(Assembler::LessThan, register_location(reg),
+                  ImmWord(comparand), LabelOrBacktrack(if_lt));
+}
+
+void SMRegExpMacroAssembler::IfRegisterEqPos(int reg, Label* if_eq) {
+  masm_.branchPtr(Assembler::Equal, register_location(reg), current_position_,
+                  LabelOrBacktrack(if_eq));
+}
+
+// This is a word-for-word identical copy of the V8 code, which is
+// duplicated in at least nine different places in V8 (one per
+// supported architecture) with no differences outside of comments and
+// formatting. It should be hoisted into the superclass. Once that is
+// done upstream, this version can be deleted.
+void SMRegExpMacroAssembler::LoadCurrentCharacterImpl(int cp_offset,
+                                                      Label* on_end_of_input,
+                                                      bool check_bounds,
+                                                      int characters,
+                                                      int eats_at_least) {
+  // It's possible to preload a small number of characters when each success
+  // path requires a large number of characters, but not the reverse.
+  MOZ_ASSERT(eats_at_least >= characters);
+  MOZ_ASSERT(cp_offset < (1 << 30));  // Be sane! (And ensure negation works)
+
+  if (check_bounds) {
+    if (cp_offset >= 0) {
+      CheckPosition(cp_offset + eats_at_least - 1, on_end_of_input);
+    } else {
+      CheckPosition(cp_offset, on_end_of_input);
+    }
+  }
+  LoadCurrentCharacterUnchecked(cp_offset, characters);
+}
+
+// Load the character (or characters) at the specified offset from the
+// current position. Zero-extend to 32 bits.
+void SMRegExpMacroAssembler::LoadCurrentCharacterUnchecked(int cp_offset,
+                                                           int characters) {
+  BaseIndex address(input_end_pointer_, current_position_, js::jit::TimesOne,
+                    cp_offset * char_size());
+  if (mode_ == LATIN1) {
+    if (characters == 4) {
+      masm_.load32(address, current_character_);
+    } else if (characters == 2) {
+      masm_.load16ZeroExtend(address, current_character_);
+    } else {
+      MOZ_ASSERT(characters == 1);
+      masm_.load8ZeroExtend(address, current_character_);
+    }
+  } else {
+    MOZ_ASSERT(mode_ == UC16);
+    if (characters == 2) {
+      masm_.load32(address, current_character_);
+    } else {
+      MOZ_ASSERT(characters == 1);
+      masm_.load16ZeroExtend(address, current_character_);
+    }
+  }
+}
+
+void SMRegExpMacroAssembler::PopCurrentPosition() { Pop(current_position_); }
+
+void SMRegExpMacroAssembler::PopRegister(int register_index) {
+  Pop(temp0_);
+  masm_.storePtr(temp0_, register_location(register_index));
+}
+
+void SMRegExpMacroAssembler::PushBacktrack(Label* label) {
+  MOZ_ASSERT(!label->is_bound());
+  MOZ_ASSERT(!label->patchOffset_.bound());
+  label->patchOffset_ = masm_.movWithPatch(ImmPtr(nullptr), temp0_);
+  MOZ_ASSERT(label->patchOffset_.bound());
+
+  Push(temp0_);
+
+  CheckBacktrackStackLimit();
+}
+
+void SMRegExpMacroAssembler::PushCurrentPosition() { Push(current_position_); }
+
+void SMRegExpMacroAssembler::PushRegister(int register_index,
+                                          StackCheckFlag check_stack_limit) {
+  masm_.loadPtr(register_location(register_index), temp0_);
+  Push(temp0_);
+  if (check_stack_limit) {
+    CheckBacktrackStackLimit();
+  }
+}
+
+void SMRegExpMacroAssembler::ReadCurrentPositionFromRegister(int reg) {
+  masm_.loadPtr(register_location(reg), current_position_);
+}
+
+void SMRegExpMacroAssembler::WriteCurrentPositionToRegister(int reg,
+                                                            int cp_offset) {
+  if (cp_offset == 0) {
+    masm_.storePtr(current_position_, register_location(reg));
+  } else {
+    Address addr(current_position_, cp_offset * char_size());
+    masm_.computeEffectiveAddress(addr, temp0_);
+    masm_.storePtr(temp0_, register_location(reg));
+  }
+}
+
+// Note: The backtrack stack pointer is stored in a register as an
+// offset from the stack top, not as a bare pointer, so that it is not
+// corrupted if the backtrack stack grows (and therefore moves).
+void SMRegExpMacroAssembler::ReadStackPointerFromRegister(int reg) {
+  masm_.loadPtr(register_location(reg), backtrack_stack_pointer_);
+  masm_.addPtr(backtrackStackBase(), backtrack_stack_pointer_);
+}
+void SMRegExpMacroAssembler::WriteStackPointerToRegister(int reg) {
+  masm_.movePtr(backtrack_stack_pointer_, temp0_);
+  masm_.subPtr(backtrackStackBase(), temp0_);
+  masm_.storePtr(temp0_, register_location(reg));
+}
+
+// When matching a regexp that is anchored at the end, this operation
+// is used to try skipping the beginning of long strings. If the
+// maximum length of a match is less than the length of the string, we
+// can skip the initial len - max_len bytes.
+void SMRegExpMacroAssembler::SetCurrentPositionFromEnd(int by) {
+  js::jit::Label after_position;
+  masm_.branchPtr(Assembler::GreaterThanOrEqual, current_position_,
+                  ImmWord(-by * char_size()), &after_position);
+  masm_.movePtr(ImmWord(-by * char_size()), current_position_);
+
+  // On RegExp code entry (where this operation is used), the character before
+  // the current position is expected to be already loaded.
+  // We have advanced the position, so it's safe to read backwards.
+  LoadCurrentCharacterUnchecked(-1, 1);
+  masm_.bind(&after_position);
+}
+
+void SMRegExpMacroAssembler::SetRegister(int register_index, int to) {
+  MOZ_ASSERT(register_index >= num_capture_registers_);
+  masm_.storePtr(ImmWord(to), register_location(register_index));
+}
+
+// Returns true if a regexp match can be restarted (aka the regexp is global).
+// The return value is not used anywhere, but we implement it to be safe.
+bool SMRegExpMacroAssembler::Succeed() {
+  masm_.jump(&success_label_);
+  return global();
+}
+
+// Capture registers are initialized to input[-1]
+void SMRegExpMacroAssembler::ClearRegisters(int reg_from, int reg_to) {
+  MOZ_ASSERT(reg_from <= reg_to);
+  masm_.loadPtr(inputStart(), temp0_);
+  masm_.subPtr(Imm32(char_size()), temp0_);
+  for (int reg = reg_from; reg <= reg_to; reg++) {
+    masm_.storePtr(temp0_, register_location(reg));
+  }
+}
+
+void SMRegExpMacroAssembler::Push(Register source) {
+  MOZ_ASSERT(source != backtrack_stack_pointer_);
+
+  masm_.subPtr(Imm32(sizeof(void*)), backtrack_stack_pointer_);
+  masm_.storePtr(source, Address(backtrack_stack_pointer_, 0));
+}
+
+void SMRegExpMacroAssembler::Pop(Register target) {
+  MOZ_ASSERT(target != backtrack_stack_pointer_);
+
+  masm_.loadPtr(Address(backtrack_stack_pointer_, 0), target);
+  masm_.addPtr(Imm32(sizeof(void*)), backtrack_stack_pointer_);
+}
+
+void SMRegExpMacroAssembler::JumpOrBacktrack(Label* to) {
+  if (to) {
+    masm_.jump(to->inner());
+  } else {
+    Backtrack();
+  }
+}
+
+// Generate a quick inline test for backtrack stack overflow.
+// If the test fails, call an OOL handler to try growing the stack.
+void SMRegExpMacroAssembler::CheckBacktrackStackLimit() {
+  js::jit::Label no_stack_overflow;
+  masm_.branchPtr(
+      Assembler::BelowOrEqual,
+      AbsoluteAddress(isolate()->regexp_stack()->limit_address_address()),
+      backtrack_stack_pointer_, &no_stack_overflow);
+
+  masm_.call(&stack_overflow_label_);
+
+  // Exit with an exception if the call failed
+  masm_.branchTest32(Assembler::Zero, temp0_, temp0_,
+                     &exit_with_exception_label_);
+
+  masm_.bind(&no_stack_overflow);
+}
+
+// This is used to sneak an OOM through the V8 layer.
+static Handle<HeapObject> DummyCode() {
+  return Handle<HeapObject>::fromHandleValue(JS::UndefinedHandleValue);
+}
+
+// Finalize code. This is called last, so that we know how many
+// registers we need.
+Handle<HeapObject> SMRegExpMacroAssembler::GetCode(Handle<String> source) {
+  if (!cx_->compartment()->ensureJitCompartmentExists(cx_)) {
+    return DummyCode();
+  }
+
+  masm_.bind(&entry_label_);
+
+  createStackFrame();
+  initFrameAndRegs();
+
+  masm_.jump(&start_label_);
+
+  successHandler();
+  exitHandler();
+  backtrackHandler();
+  stackOverflowHandler();
+
+  Linker linker(masm_);
+  JitCode* code = linker.newCode<NoGC>(cx_, REGEXP_CODE);
+  if (!code) {
+    ReportOutOfMemory(cx_);
+    return DummyCode();
+  }
+
+  for (LabelPatch& lp : labelPatches_) {
+    Assembler::PatchDataWithValueCheck(CodeLocationLabel(code, lp.patchOffset_),
+                                       ImmPtr(code->raw() + lp.labelOffset_),
+                                       ImmPtr(nullptr));
+  }
+
+  return Handle<HeapObject>(JS::PrivateGCThingValue(code), isolate());
+}
+
+/*
+ * The stack will have the following structure:
+ *  sp-> - FrameData
+ *         - inputStart
+ *         - backtrack stack base
+ *         - matches
+ *         - numMatches
+ *       - Registers
+ *         - Capture positions
+ *         - Scratch registers
+ *       --- frame alignment ---
+ *       - Saved register area
+ *       - Return address
+ */
+void SMRegExpMacroAssembler::createStackFrame() {
+#ifdef JS_CODEGEN_ARM64
+  // ARM64 communicates stack address via SP, but uses a pseudo-sp (PSP) for
+  // addressing.  The register we use for PSP may however also be used by
+  // calling code, and it is nonvolatile, so save it.  Do this as a special
+  // case first because the generic save/restore code needs the PSP to be
+  // initialized already.
+  MOZ_ASSERT(js::jit::PseudoStackPointer64.Is(masm_.GetStackPointer64()));
+  masm_.Str(js::jit::PseudoStackPointer64,
+            vixl::MemOperand(js::jit::sp, -16, vixl::PreIndex));
+
+  // Initialize the PSP from the SP.
+  masm_.initPseudoStackPtr();
+#endif
+
+  // Push non-volatile registers which might be modified by jitcode.
+  size_t pushedNonVolatileRegisters = 0;
+  for (GeneralRegisterForwardIterator iter(savedRegisters_); iter.more();
+       ++iter) {
+    masm_.Push(*iter);
+    pushedNonVolatileRegisters++;
+  }
+
+  // The pointer to InputOutputData is passed as the first argument.
+  // On x86 we have to load it off the stack into temp0_.
+  // On other platforms it is already in a register.
+#ifdef JS_CODEGEN_X86
+  Address ioDataAddr(masm_.getStackPointer(),
+                     (pushedNonVolatileRegisters + 1) * sizeof(void*));
+  masm_.loadPtr(ioDataAddr, temp0_);
+#else
+  if (js::jit::IntArgReg0 != temp0_) {
+    masm_.movePtr(js::jit::IntArgReg0, temp0_);
+  }
+#endif
+
+  // Start a new stack frame.
+  size_t frameBytes = sizeof(FrameData) + num_registers_ * sizeof(void*);
+  frameSize_ = js::jit::StackDecrementForCall(js::jit::ABIStackAlignment,
+                                              masm_.framePushed(), frameBytes);
+  masm_.reserveStack(frameSize_);
+  masm_.checkStackAlignment();
+
+  // Check if we have space on the stack. Use the *NoInterrupt stack limit to
+  // avoid failing repeatedly when the regex code is called from Ion JIT code.
+  // (See bug 1208819)
+  js::jit::Label stack_ok;
+  AbsoluteAddress limit_addr(cx_->addressOfJitStackLimitNoInterrupt());
+  masm_.branchStackPtrRhs(Assembler::Below, limit_addr, &stack_ok);
+
+  // There is not enough space on the stack. Exit with an exception.
+  masm_.movePtr(ImmWord(js::RegExpRunStatus_Error), temp0_);
+  masm_.jump(&exit_label_);
+
+  masm_.bind(&stack_ok);
+}
+
+void SMRegExpMacroAssembler::initFrameAndRegs() {
+  // At this point, an uninitialized stack frame has been created,
+  // and the address of the InputOutputData is in temp0_.
+  Register ioDataReg = temp0_;
+
+  Register matchesReg = temp1_;
+  masm_.loadPtr(Address(ioDataReg, offsetof(InputOutputData, matches)),
+                matchesReg);
+
+  // Initialize output registers
+  masm_.loadPtr(Address(matchesReg, MatchPairs::offsetOfPairs()), temp2_);
+  masm_.storePtr(temp2_, matches());
+  masm_.load32(Address(matchesReg, MatchPairs::offsetOfPairCount()), temp2_);
+  masm_.store32(temp2_, numMatches());
+
+#ifdef DEBUG
+  // Bounds-check numMatches.
+  js::jit::Label enoughRegisters;
+  masm_.branchPtr(Assembler::GreaterThanOrEqual, temp2_,
+                  ImmWord(num_capture_registers_ / 2), &enoughRegisters);
+  masm_.assumeUnreachable("Not enough output pairs for RegExp");
+  masm_.bind(&enoughRegisters);
+#endif
+
+  // Load input start pointer.
+  masm_.loadPtr(Address(ioDataReg, offsetof(InputOutputData, inputStart)),
+                current_position_);
+
+  // Load input end pointer
+  masm_.loadPtr(Address(ioDataReg, offsetof(InputOutputData, inputEnd)),
+                input_end_pointer_);
+
+  // Set up input position to be negative offset from string end.
+  masm_.subPtr(input_end_pointer_, current_position_);
+
+  // Store inputStart
+  masm_.storePtr(current_position_, inputStart());
+
+  // Load start index
+  Register startIndexReg = temp1_;
+  masm_.loadPtr(Address(ioDataReg, offsetof(InputOutputData, startIndex)),
+                startIndexReg);
+  masm_.computeEffectiveAddress(
+      BaseIndex(current_position_, startIndexReg, factor()), current_position_);
+
+  // Initialize current_character_.
+  // Load newline if index is at start, or previous character otherwise.
+  js::jit::Label start_regexp;
+  js::jit::Label load_previous_character;
+  masm_.branchPtr(Assembler::NotEqual, startIndexReg, ImmWord(0),
+                  &load_previous_character);
+  masm_.movePtr(ImmWord('\n'), current_character_);
+  masm_.jump(&start_regexp);
+
+  masm_.bind(&load_previous_character);
+  LoadCurrentCharacterUnchecked(-1, 1);
+  masm_.bind(&start_regexp);
+
+  // Initialize captured registers with inputStart - 1
+  MOZ_ASSERT(num_capture_registers_ > 0);
+  Register inputStartMinusOneReg = temp2_;
+  masm_.loadPtr(inputStart(), inputStartMinusOneReg);
+  masm_.subPtr(Imm32(char_size()), inputStartMinusOneReg);
+  if (num_capture_registers_ > 8) {
+    masm_.movePtr(ImmWord(register_offset(0)), temp1_);
+    js::jit::Label init_loop;
+    masm_.bind(&init_loop);
+    masm_.storePtr(inputStartMinusOneReg, BaseIndex(masm_.getStackPointer(),
+                                                    temp1_, js::jit::TimesOne));
+    masm_.addPtr(ImmWord(sizeof(void*)), temp1_);
+    masm_.branchPtr(Assembler::LessThan, temp1_,
+                    ImmWord(register_offset(num_capture_registers_)),
+                    &init_loop);
+  } else {
+    // Unroll the loop
+    for (int i = 0; i < num_capture_registers_; i++) {
+      masm_.storePtr(inputStartMinusOneReg, register_location(i));
+    }
+  }
+
+  // Initialize backtrack stack pointer
+  masm_.loadPtr(AbsoluteAddress(isolate()->top_of_regexp_stack()),
+                backtrack_stack_pointer_);
+  masm_.storePtr(backtrack_stack_pointer_, backtrackStackBase());
+}
+
+// Called when we find a match. May not be generated if we can
+// determine ahead of time that a regexp cannot match: for example,
+// when compiling /\u1e9e/ for latin-1 inputs.
+void SMRegExpMacroAssembler::successHandler() {
+  if (!success_label_.used()) {
+    return;
+  }
+  masm_.bind(&success_label_);
+
+  // Copy captures to the MatchPairs pointed to by the InputOutputData.
+  // Captures are stored as positions, which are negative byte offsets
+  // from the end of the string.  We must convert them to actual
+  // indices.
+  //
+  // Index:        [ 0 ][ 1 ][ 2 ][ 3 ][ 4 ][ 5 ][END]
+  // Pos (1-byte): [-6 ][-5 ][-4 ][-3 ][-2 ][-1 ][ 0 ] // IS = -6
+  // Pos (2-byte): [-12][-10][-8 ][-6 ][-4 ][-2 ][ 0 ] // IS = -12
+  //
+  // To convert a position to an index, we subtract InputStart, and
+  // divide the result by char_size.
+  Register matchesReg = temp1_;
+  masm_.loadPtr(matches(), matchesReg);
+
+  Register inputStartReg = temp2_;
+  masm_.loadPtr(inputStart(), inputStartReg);
+
+  for (int i = 0; i < num_capture_registers_; i++) {
+    masm_.loadPtr(register_location(i), temp0_);
+    masm_.subPtr(inputStartReg, temp0_);
+    if (mode_ == UC16) {
+      masm_.rshiftPtrArithmetic(Imm32(1), temp0_);
+    }
+    masm_.store32(temp0_, Address(matchesReg, i * sizeof(int32_t)));
+  }
+
+  masm_.movePtr(ImmWord(js::RegExpRunStatus_Success), temp0_);
+  // This falls through to the exit handler.
+}
+
+void SMRegExpMacroAssembler::exitHandler() {
+  masm_.bind(&exit_label_);
+
+  if (temp0_ != js::jit::ReturnReg) {
+    masm_.movePtr(temp0_, js::jit::ReturnReg);
+  }
+
+  masm_.freeStack(frameSize_);
+
+  // Restore registers which were saved on entry
+  for (GeneralRegisterBackwardIterator iter(savedRegisters_); iter.more();
+       ++iter) {
+    masm_.Pop(*iter);
+  }
+
+#ifdef JS_CODEGEN_ARM64
+  // Now restore the value that was in the PSP register on entry, and return.
+
+  // Obtain the correct SP from the PSP.
+  masm_.Mov(js::jit::sp, js::jit::PseudoStackPointer64);
+
+  // Restore the saved value of the PSP register, this value is whatever the
+  // caller had saved in it, not any actual SP value, and it must not be
+  // overwritten subsequently.
+  masm_.Ldr(js::jit::PseudoStackPointer64,
+            vixl::MemOperand(js::jit::sp, 16, vixl::PostIndex));
+
+  // Perform a plain Ret(), as abiret() will move SP <- PSP and that is wrong.
+  masm_.Ret(vixl::lr);
+#else
+  masm_.abiret();
+#endif
+
+  if (exit_with_exception_label_.used()) {
+    masm_.bind(&exit_with_exception_label_);
+
+    // Exit with an error result to signal thrown exception
+    masm_.movePtr(ImmWord(js::RegExpRunStatus_Error), temp0_);
+    masm_.jump(&exit_label_);
+  }
+}
+
+void SMRegExpMacroAssembler::backtrackHandler() {
+  if (!backtrack_label_.used()) {
+    return;
+  }
+  masm_.bind(&backtrack_label_);
+  Backtrack();
+}
+
+void SMRegExpMacroAssembler::stackOverflowHandler() {
+  if (!stack_overflow_label_.used()) {
+    return;
+  }
+
+  // Called if the backtrack-stack limit has been hit.
+  masm_.bind(&stack_overflow_label_);
+
+  // Load argument
+  masm_.movePtr(ImmPtr(isolate()->regexp_stack()), temp1_);
+
+  // Save registers before calling C function
+  LiveGeneralRegisterSet volatileRegs(GeneralRegisterSet::Volatile());
+
+#ifdef JS_USE_LINK_REGISTER
+  masm_.pushReturnAddress();
+#endif
+
+  // Adjust for the return address on the stack.
+  size_t frameOffset = sizeof(void*);
+
+  volatileRegs.takeUnchecked(temp0_);
+  volatileRegs.takeUnchecked(temp1_);
+  masm_.PushRegsInMask(volatileRegs);
+
+  masm_.setupUnalignedABICall(temp0_);
+  masm_.passABIArg(temp1_);
+  masm_.callWithABI(JS_FUNC_TO_DATA_PTR(void*, GrowBacktrackStack));
+  masm_.storeCallBoolResult(temp0_);
+
+  masm_.PopRegsInMask(volatileRegs);
+
+  // If GrowBacktrackStack returned false, we have failed to grow the
+  // stack, and must exit with a stack-overflow exception. Do this in
+  // the caller so that the stack is adjusted by our return instruction.
+  js::jit::Label overflow_return;
+  masm_.branchTest32(Assembler::Zero, temp0_, temp0_, &overflow_return);
+
+  // Otherwise, store the new backtrack stack base and recompute the new
+  // top of the stack.
+  Address bsbAddress(masm_.getStackPointer(),
+                     offsetof(FrameData, backtrackStackBase) + frameOffset);
+  masm_.subPtr(bsbAddress, backtrack_stack_pointer_);
+
+  masm_.loadPtr(AbsoluteAddress(isolate()->top_of_regexp_stack()), temp1_);
+  masm_.storePtr(temp1_, bsbAddress);
+  masm_.addPtr(temp1_, backtrack_stack_pointer_);
+
+  // Resume execution in calling code.
+  masm_.bind(&overflow_return);
+  masm_.ret();
+}
+
+// This is only used by tracing code.
+// The return value doesn't matter.
+RegExpMacroAssembler::IrregexpImplementation
+SMRegExpMacroAssembler::Implementation() {
+  return kBytecodeImplementation;
+}
+
+// Compare two strings in `/i` mode (ignoreCase, but not unicode).
+/*static */
+uint32_t SMRegExpMacroAssembler::CaseInsensitiveCompareNonUnicode(
+    const char16_t* substring1, const char16_t* substring2, size_t byteLength) {
+  JS::AutoCheckCannotGC nogc;
+
+  MOZ_ASSERT(byteLength % sizeof(char16_t) == 0);
+  size_t length = byteLength / sizeof(char16_t);
+
+  for (size_t i = 0; i < length; i++) {
+    char16_t c1 = substring1[i];
+    char16_t c2 = substring2[i];
+    if (c1 != c2) {
+#ifdef JS_HAS_INTL_API
+      // Non-unicode regexps have weird case-folding rules.
+      c1 = RegExpCaseFolding::Canonicalize(c1);
+      c2 = RegExpCaseFolding::Canonicalize(c2);
+#else
+      // If we aren't building with ICU, fall back to `/iu` mode. The only
+      // differences are in corner cases.
+      c1 = js::unicode::FoldCase(c1);
+      c2 = js::unicode::FoldCase(c2);
+#endif
+      if (c1 != c2) {
+        return 0;
+      }
+    }
+  }
+
+  return 1;
+}
+
+// Compare two strings in `/iu` mode (ignoreCase and unicode).
+/*static */
+uint32_t SMRegExpMacroAssembler::CaseInsensitiveCompareUnicode(
+    const char16_t* substring1, const char16_t* substring2, size_t byteLength) {
+  JS::AutoCheckCannotGC nogc;
+
+  MOZ_ASSERT(byteLength % sizeof(char16_t) == 0);
+  size_t length = byteLength / sizeof(char16_t);
+
+  for (size_t i = 0; i < length; i++) {
+    char16_t c1 = substring1[i];
+    char16_t c2 = substring2[i];
+    if (c1 != c2) {
+      // Unicode regexps use the common and simple case-folding
+      // mappings of the Unicode Character Database.
+      c1 = js::unicode::FoldCase(c1);
+      c2 = js::unicode::FoldCase(c2);
+      if (c1 != c2) {
+        return 0;
+      }
+    }
+  }
+
+  return 1;
+}
+
+/* static */
+bool SMRegExpMacroAssembler::GrowBacktrackStack(RegExpStack* regexp_stack) {
+  JS::AutoCheckCannotGC nogc;
+  size_t size = regexp_stack->stack_capacity();
+  return !!regexp_stack->EnsureCapacity(size * 2);
+}
+
+bool SMRegExpMacroAssembler::CanReadUnaligned() {
+#if defined(JS_CODEGEN_ARM)
+  return !js::jit::HasAlignmentFault();
+#elif defined(JS_CODEGEN_MIPS32) || defined(JS_CODEGEN_MIPS64)
+  return false;
+#else
+  return true;
+#endif
+}
+
+}  // namespace internal
+}  // namespace v8
diff -Nrup mozilla/js/src/irregexp/RegExpNativeMacroAssembler.h mozilla-OK/js/src/irregexp/RegExpNativeMacroAssembler.h
--- mozilla/js/src/irregexp/RegExpNativeMacroAssembler.h	1970-01-01 03:00:00.000000000 +0300
+++ mozilla-OK/js/src/irregexp/RegExpNativeMacroAssembler.h	2022-04-22 05:08:42.156101889 +0300
@@ -0,0 +1,297 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+// Copyright 2020 the V8 project authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+// This file implements the NativeRegExpMacroAssembler interface for
+// SpiderMonkey. It provides the same interface as each of V8's
+// architecture-specific implementations.
+
+#ifndef RegexpMacroAssemblerArch_h
+#define RegexpMacroAssemblerArch_h
+
+#include "irregexp/imported/regexp-macro-assembler.h"
+#include "jit/MacroAssembler.h"
+
+namespace v8 {
+namespace internal {
+
+struct FrameData {
+  // Character position at the start of the input, stored as a
+  // negative offset from the end of the string (input_end_pointer_).
+  size_t inputStart;
+
+  // The backtrack_stack_pointer_ register points to the top of the stack.
+  // This points to the bottom of the backtrack stack.
+  void* backtrackStackBase;
+
+  // Copy of the input MatchPairs.
+  int32_t* matches;    // pointer to capture array
+  int32_t numMatches;  // size of capture array
+};
+
+class SMRegExpMacroAssembler final : public NativeRegExpMacroAssembler {
+ public:
+  SMRegExpMacroAssembler(JSContext* cx, js::jit::StackMacroAssembler& masm,
+                         Zone* zone, Mode mode, uint32_t num_capture_registers);
+  virtual ~SMRegExpMacroAssembler() {}  // Nothing to do here
+
+  virtual int stack_limit_slack();
+  virtual IrregexpImplementation Implementation();
+
+  virtual bool Succeed();
+  virtual void Fail();
+
+  virtual void AdvanceCurrentPosition(int by);
+  virtual void PopCurrentPosition();
+  virtual void PushCurrentPosition();
+  virtual void SetCurrentPositionFromEnd(int by);
+
+  virtual void Backtrack();
+  virtual void Bind(Label* label);
+  virtual void GoTo(Label* label);
+  virtual void PushBacktrack(Label* label);
+
+  virtual void CheckCharacter(uint32_t c, Label* on_equal);
+  virtual void CheckNotCharacter(uint32_t c, Label* on_not_equal);
+  virtual void CheckCharacterGT(uc16 limit, Label* on_greater);
+  virtual void CheckCharacterLT(uc16 limit, Label* on_less);
+  virtual void CheckCharacterAfterAnd(uint32_t c, uint32_t mask,
+                                      Label* on_equal);
+  virtual void CheckNotCharacterAfterAnd(uint32_t c, uint32_t mask,
+                                         Label* on_not_equal);
+  virtual void CheckNotCharacterAfterMinusAnd(uc16 c, uc16 minus, uc16 mask,
+                                              Label* on_not_equal);
+  virtual void CheckGreedyLoop(Label* on_tos_equals_current_position);
+  virtual void CheckCharacterInRange(uc16 from, uc16 to, Label* on_in_range);
+  virtual void CheckCharacterNotInRange(uc16 from, uc16 to,
+                                        Label* on_not_in_range);
+  virtual void CheckAtStart(int cp_offset, Label* on_at_start);
+  virtual void CheckNotAtStart(int cp_offset, Label* on_not_at_start);
+  virtual void CheckPosition(int cp_offset, Label* on_outside_input);
+  virtual void CheckBitInTable(Handle<ByteArray> table, Label* on_bit_set);
+  virtual bool CheckSpecialCharacterClass(uc16 type, Label* on_no_match);
+  virtual void CheckNotBackReference(int start_reg, bool read_backward,
+                                     Label* on_no_match);
+  virtual void CheckNotBackReferenceIgnoreCase(int start_reg,
+                                               bool read_backward, bool unicode,
+                                               Label* on_no_match);
+
+  virtual void LoadCurrentCharacterImpl(int cp_offset, Label* on_end_of_input,
+                                        bool check_bounds, int characters,
+                                        int eats_at_least);
+
+  virtual void AdvanceRegister(int reg, int by);
+  virtual void IfRegisterGE(int reg, int comparand, Label* if_ge);
+  virtual void IfRegisterLT(int reg, int comparand, Label* if_lt);
+  virtual void IfRegisterEqPos(int reg, Label* if_eq);
+  virtual void PopRegister(int register_index);
+  virtual void PushRegister(int register_index,
+                            StackCheckFlag check_stack_limit);
+  virtual void ReadCurrentPositionFromRegister(int reg);
+  virtual void WriteCurrentPositionToRegister(int reg, int cp_offset);
+  virtual void ReadStackPointerFromRegister(int reg);
+  virtual void WriteStackPointerToRegister(int reg);
+  virtual void SetRegister(int register_index, int to);
+  virtual void ClearRegisters(int reg_from, int reg_to);
+
+  virtual Handle<HeapObject> GetCode(Handle<String> source);
+
+  virtual bool CanReadUnaligned();
+
+ private:
+  size_t frameSize_ = 0;
+
+  void createStackFrame();
+  void initFrameAndRegs();
+  void successHandler();
+  void exitHandler();
+  void backtrackHandler();
+  void stackOverflowHandler();
+
+  // Push a register on the backtrack stack.
+  void Push(js::jit::Register value);
+
+  // Pop a value from the backtrack stack.
+  void Pop(js::jit::Register target);
+
+  void CheckAtStartImpl(int cp_offset, Label* on_cond,
+                        js::jit::Assembler::Condition cond);
+  void CheckCharacterImpl(js::jit::Imm32 c, Label* on_cond,
+                          js::jit::Assembler::Condition cond);
+  void CheckCharacterAfterAndImpl(uint32_t c, uint32_t and_with, Label* on_cond,
+                                  bool negate);
+  void CheckCharacterInRangeImpl(uc16 from, uc16 to, Label* on_cond,
+                                 js::jit::Assembler::Condition cond);
+  void CheckNotBackReferenceImpl(int start_reg, bool read_backward,
+                                 bool unicode, Label* on_no_match,
+                                 bool ignore_case);
+
+  void LoadCurrentCharacterUnchecked(int cp_offset, int characters);
+
+  void JumpOrBacktrack(Label* to);
+
+  // MacroAssembler methods that take a Label can be called with a
+  // null label, which means that we should backtrack if we would jump
+  // to that label. This is a helper to avoid writing out the same
+  // logic a dozen times.
+  inline js::jit::Label* LabelOrBacktrack(Label* to) {
+    return to ? to->inner() : &backtrack_label_;
+  }
+
+  void CheckBacktrackStackLimit();
+
+  static bool GrowBacktrackStack(RegExpStack* regexp_stack);
+
+  static uint32_t CaseInsensitiveCompareNonUnicode(const char16_t* substring1,
+                                                   const char16_t* substring2,
+                                                   size_t byteLength);
+  static uint32_t CaseInsensitiveCompareUnicode(const char16_t* substring1,
+                                                const char16_t* substring2,
+                                                size_t byteLength);
+
+  inline int char_size() { return static_cast<int>(mode_); }
+  inline js::jit::Scale factor() {
+    return mode_ == UC16 ? js::jit::TimesTwo : js::jit::TimesOne;
+  }
+
+  js::jit::Address inputStart() {
+    return js::jit::Address(masm_.getStackPointer(),
+                            offsetof(FrameData, inputStart));
+  }
+  js::jit::Address backtrackStackBase() {
+    return js::jit::Address(masm_.getStackPointer(),
+                            offsetof(FrameData, backtrackStackBase));
+  }
+  js::jit::Address matches() {
+    return js::jit::Address(masm_.getStackPointer(),
+                            offsetof(FrameData, matches));
+  }
+  js::jit::Address numMatches() {
+    return js::jit::Address(masm_.getStackPointer(),
+                            offsetof(FrameData, numMatches));
+  }
+
+  // The stack-pointer-relative location of a regexp register.
+  js::jit::Address register_location(int register_index) {
+    return js::jit::Address(masm_.getStackPointer(),
+                            register_offset(register_index));
+  }
+
+  int32_t register_offset(int register_index) {
+    MOZ_ASSERT(register_index >= 0 && register_index <= kMaxRegister);
+    if (num_registers_ <= register_index) {
+      num_registers_ = register_index + 1;
+    }
+    static_assert(alignof(uintptr_t) <= alignof(FrameData),
+                  "Regexp: Alignment of uintptr_t and FrameData mismatch");
+    return sizeof(FrameData) + register_index * sizeof(uintptr_t*);
+  }
+
+  JSContext* cx_;
+  js::jit::StackMacroAssembler& masm_;
+
+  /*
+   * This assembler uses the following registers:
+   *
+   * - current_character_:
+   *     Contains the character (or characters) currently being examined.
+   *     Must be loaded using LoadCurrentCharacter before using any of the
+   *     dispatch methods. After a matching pass for a global regexp,
+   *     temporarily stores the index of capture start.
+   * - current_position_:
+   *     Current position in input *as negative byte offset from end of string*.
+   * - input_end_pointer_:
+   *     Points to byte after last character in the input. current_position_ is
+   *     relative to this.
+   * - backtrack_stack_pointer_:
+   *     Points to tip of the (heap-allocated) backtrack stack. The stack grows
+   *     downward (like the native stack).
+   * - temp0_, temp1_, temp2_:
+   *     Scratch registers.
+   *
+   * The native stack pointer is used to access arguments (InputOutputData),
+   * local variables (FrameData), and irregexp's internal virtual registers
+   * (see register_location).
+   */
+
+  js::jit::Register current_character_;
+  js::jit::Register current_position_;
+  js::jit::Register input_end_pointer_;
+  js::jit::Register backtrack_stack_pointer_;
+  js::jit::Register temp0_, temp1_, temp2_;
+
+  // These labels are used in various API calls and bound (if used) in
+  // GetCode. If we abort in the middle of a compilation, as may
+  // happen if a regexp is too big, they may be used but not
+  // bound.
+  js::jit::NonAssertingLabel entry_label_;
+  js::jit::NonAssertingLabel start_label_;
+  js::jit::NonAssertingLabel backtrack_label_;
+  js::jit::NonAssertingLabel success_label_;
+  js::jit::NonAssertingLabel exit_label_;
+  js::jit::NonAssertingLabel stack_overflow_label_;
+  js::jit::NonAssertingLabel exit_with_exception_label_;
+
+  // When we generate the code to push a backtrack label's address
+  // onto the backtrack stack, we don't know its final address. We
+  // have to patch it after linking. This is slightly delicate, as the
+  // Label itself (which is allocated on the stack) may not exist by
+  // the time we link. The approach is as follows:
+  //
+  // 1. When we push a label on the backtrack stack (PushBacktrack),
+  //    we bind the label's patchOffset_ field to the offset within
+  //    the code that should be overwritten. This works because each
+  //    label is only pushed by a single instruction.
+  //
+  // 2. When we bind a label (Bind), we check to see if it has a
+  //    bound patchOffset_. If it does, we create a LabelPatch mapping
+  //    its patch offset to the offset of the label itself.
+  //
+  // 3. While linking the code, we walk the list of label patches
+  //    and patch the code accordingly.
+  class LabelPatch {
+   public:
+    LabelPatch(js::jit::CodeOffset patchOffset, size_t labelOffset)
+        : patchOffset_(patchOffset), labelOffset_(labelOffset) {}
+
+    js::jit::CodeOffset patchOffset_;
+    size_t labelOffset_ = 0;
+  };
+
+  js::Vector<LabelPatch, 4, js::SystemAllocPolicy> labelPatches_;
+  void AddLabelPatch(js::jit::CodeOffset patchOffset, size_t labelOffset) {
+    js::AutoEnterOOMUnsafeRegion oomUnsafe;
+    if (!labelPatches_.emplaceBack(patchOffset, labelOffset)) {
+      oomUnsafe.crash("Irregexp label patch");
+    }
+  }
+
+  Mode mode_;
+  int num_registers_;
+  int num_capture_registers_;
+  js::jit::LiveGeneralRegisterSet savedRegisters_;
+
+ public:
+  using TableVector =
+      js::Vector<PseudoHandle<ByteArrayData>, 4, js::SystemAllocPolicy>;
+  TableVector& tables() { return tables_; }
+
+ private:
+  TableVector tables_;
+  void AddTable(PseudoHandle<ByteArrayData> table) {
+    js::AutoEnterOOMUnsafeRegion oomUnsafe;
+    if (!tables_.append(std::move(table))) {
+      oomUnsafe.crash("Irregexp table append");
+    }
+  }
+};
+
+}  // namespace internal
+}  // namespace v8
+
+#endif  // RegexpMacroAssemblerArch_h
diff -Nrup mozilla/js/src/irregexp/RegExpShim.cpp mozilla-OK/js/src/irregexp/RegExpShim.cpp
--- mozilla/js/src/irregexp/RegExpShim.cpp	1970-01-01 03:00:00.000000000 +0300
+++ mozilla-OK/js/src/irregexp/RegExpShim.cpp	2022-04-22 05:08:42.156101889 +0300
@@ -0,0 +1,255 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+// Copyright 2019 the V8 project authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "irregexp/RegExpShim.h"
+
+#include "mozilla/MemoryReporting.h"
+
+#include <iostream>
+
+#include "irregexp/imported/regexp-macro-assembler.h"
+#include "irregexp/imported/regexp-stack.h"
+
+#include "vm/NativeObject-inl.h"
+
+#include "mozilla/Sprintf.h"  // for SprintfLiteral
+
+namespace v8 {
+namespace internal {
+
+void PrintF(const char* format, ...) {
+  va_list arguments;
+  va_start(arguments, format);
+  vprintf(format, arguments);
+  va_end(arguments);
+}
+
+void PrintF(FILE* out, const char* format, ...) {
+  va_list arguments;
+  va_start(arguments, format);
+  vfprintf(out, format, arguments);
+  va_end(arguments);
+}
+
+StdoutStream::operator std::ostream&() const { return std::cerr; }
+
+template <typename T>
+std::ostream& StdoutStream::operator<<(T t) {
+  return std::cerr << t;
+}
+
+template std::ostream& StdoutStream::operator<<(char const* c);
+
+// Origin:
+// https://github.com/v8/v8/blob/855591a54d160303349a5f0a32fab15825c708d1/src/utils/ostreams.cc#L120-L169
+// (This is a hand-simplified version.)
+// Writes the given character to the output escaping everything outside
+// of printable ASCII range.
+std::ostream& operator<<(std::ostream& os, const AsUC16& c) {
+  uc16 v = c.value;
+  bool isPrint = 0x20 < v && v <= 0x7e;
+  char buf[10];
+  const char* format = isPrint ? "%c" : (v <= 0xFF) ? "\\x%02x" : "\\u%04x";
+  SprintfLiteral(buf, format, v);
+  return os << buf;
+}
+std::ostream& operator<<(std::ostream& os, const AsUC32& c) {
+  int32_t v = c.value;
+  if (v <= String::kMaxUtf16CodeUnit) {
+    return os << AsUC16(v);
+  }
+  char buf[13];
+  SprintfLiteral(buf, "\\u{%06x}", v);
+  return os << buf;
+}
+
+HandleScope::HandleScope(Isolate* isolate) : isolate_(isolate) {
+  isolate->openHandleScope(*this);
+}
+
+HandleScope::~HandleScope() {
+  isolate_->closeHandleScope(level_, non_gc_level_);
+}
+
+template <typename T>
+Handle<T>::Handle(T object, Isolate* isolate)
+    : location_(isolate->getHandleLocation(object.value())) {}
+
+template Handle<ByteArray>::Handle(ByteArray b, Isolate* isolate);
+template Handle<HeapObject>::Handle(const JS::Value& v, Isolate* isolate);
+template Handle<JSRegExp>::Handle(JSRegExp re, Isolate* isolate);
+template Handle<String>::Handle(String s, Isolate* isolate);
+
+template <typename T>
+Handle<T>::Handle(const JS::Value& value, Isolate* isolate)
+    : location_(isolate->getHandleLocation(value)) {
+  T::cast(Object(value));  // Assert that value has the correct type.
+}
+
+JS::Value* Isolate::getHandleLocation(const JS::Value& value) {
+  js::AutoEnterOOMUnsafeRegion oomUnsafe;
+  if (!handleArena_.Append(value)) {
+    oomUnsafe.crash("Irregexp handle allocation");
+  }
+  return &handleArena_.GetLast();
+}
+
+void* Isolate::allocatePseudoHandle(size_t bytes) {
+  PseudoHandle<void> ptr;
+  ptr.reset(js_malloc(bytes));
+  if (!ptr) {
+    return nullptr;
+  }
+  if (!uniquePtrArena_.Append(std::move(ptr))) {
+    return nullptr;
+  }
+  return uniquePtrArena_.GetLast().get();
+}
+
+template <typename T>
+PseudoHandle<T> Isolate::takeOwnership(void* ptr) {
+  for (auto iter = uniquePtrArena_.IterFromLast(); !iter.Done(); iter.Prev()) {
+    auto& entry = iter.Get();
+    if (entry.get() == ptr) {
+      PseudoHandle<T> result;
+      result.reset(static_cast<T*>(entry.release()));
+      return result;
+    }
+  }
+  MOZ_CRASH("Tried to take ownership of pseudohandle that is not in the arena");
+}
+
+PseudoHandle<ByteArrayData> ByteArray::takeOwnership(Isolate* isolate) {
+  PseudoHandle<ByteArrayData> result =
+      isolate->takeOwnership<ByteArrayData>(value().toPrivate());
+  setValue(JS::PrivateValue(nullptr));
+  return result;
+}
+
+void Isolate::trace(JSTracer* trc) {
+  for (auto iter = handleArena_.Iter(); !iter.Done(); iter.Next()) {
+    auto& elem = iter.Get();
+    JS::GCPolicy<JS::Value>::trace(trc, &elem, "Isolate handle arena");
+  }
+}
+
+size_t Isolate::sizeOfIncludingThis(mozilla::MallocSizeOf mallocSizeOf) const {
+  size_t size = mallocSizeOf(this);
+
+  // The RegExpStack code is imported from V8, so we peek inside it to
+  // measure its memory from here.
+  size += mallocSizeOf(regexpStack_);
+  if (regexpStack_->thread_local_.owns_memory_) {
+    size += mallocSizeOf(regexpStack_->thread_local_.memory_);
+  }
+
+  size += handleArena_.SizeOfExcludingThis(mallocSizeOf);
+  size += uniquePtrArena_.SizeOfExcludingThis(mallocSizeOf);
+  return size;
+}
+
+/*static*/ Handle<String> String::Flatten(Isolate* isolate,
+                                          Handle<String> string) {
+  if (string->IsFlat()) {
+    return string;
+  }
+  js::AutoEnterOOMUnsafeRegion oomUnsafe;
+  JSLinearString* linear = string->str()->ensureLinear(isolate->cx());
+  if (!linear) {
+    oomUnsafe.crash("Irregexp String::Flatten");
+  }
+  return Handle<String>(JS::StringValue(linear), isolate);
+}
+
+// This is only used for trace messages printing the source pattern of
+// a regular expression. We have to return a unique_ptr, but we don't
+// care about the contents, so we return an empty null-terminated string.
+std::unique_ptr<char[]> String::ToCString() {
+  js::AutoEnterOOMUnsafeRegion oomUnsafe;
+
+  std::unique_ptr<char[]> ptr;
+  ptr.reset(static_cast<char*>(js_malloc(1)));
+  if (!ptr) {
+    oomUnsafe.crash("Irregexp String::ToCString");
+  }
+  ptr[0] = '\0';
+
+  return ptr;
+}
+
+bool Isolate::init() {
+  regexpStack_ = js_new<RegExpStack>();
+  if (!regexpStack_) {
+    return false;
+  }
+  return true;
+}
+
+Isolate::~Isolate() {
+  if (regexpStack_) {
+    js_delete(regexpStack_);
+  }
+}
+
+byte* Isolate::top_of_regexp_stack() const {
+  return reinterpret_cast<byte*>(regexpStack_->memory_top_address_address());
+}
+
+Handle<ByteArray> Isolate::NewByteArray(int length, AllocationType alloc) {
+  MOZ_RELEASE_ASSERT(length >= 0);
+
+  js::AutoEnterOOMUnsafeRegion oomUnsafe;
+
+  size_t alloc_size = sizeof(uint32_t) + length;
+  ByteArrayData* data =
+      static_cast<ByteArrayData*>(allocatePseudoHandle(alloc_size));
+  if (!data) {
+    oomUnsafe.crash("Irregexp NewByteArray");
+  }
+  data->length = length;
+
+  return Handle<ByteArray>(JS::PrivateValue(data), this);
+}
+
+Handle<FixedArray> Isolate::NewFixedArray(int length) {
+  MOZ_RELEASE_ASSERT(length >= 0);
+  js::AutoEnterOOMUnsafeRegion oomUnsafe;
+  js::ArrayObject* array = js::NewDenseFullyAllocatedArray(cx(), length);
+  if (!array) {
+    oomUnsafe.crash("Irregexp NewFixedArray");
+  }
+  array->ensureDenseInitializedLength(cx(), 0, length);
+  return Handle<FixedArray>(JS::ObjectValue(*array), this);
+}
+
+template <typename CharT>
+Handle<String> Isolate::InternalizeString(const Vector<const CharT>& str) {
+  js::AutoEnterOOMUnsafeRegion oomUnsafe;
+  JSAtom* atom = js::AtomizeChars(cx(), str.begin(), str.length());
+  if (!atom) {
+    oomUnsafe.crash("Irregexp InternalizeString");
+  }
+  return Handle<String>(JS::StringValue(atom), this);
+}
+
+template Handle<String> Isolate::InternalizeString(
+    const Vector<const uint8_t>& str);
+template Handle<String> Isolate::InternalizeString(
+    const Vector<const char16_t>& str);
+
+static_assert(JSRegExp::RegistersForCaptureCount(JSRegExp::kMaxCaptures) <=
+              RegExpMacroAssembler::kMaxRegisterCount);
+
+bool FLAG_trace_regexp_assembler = false;
+bool FLAG_trace_regexp_bytecodes = false;
+bool FLAG_trace_regexp_parser = false;
+bool FLAG_trace_regexp_peephole_optimization = false;
+
+}  // namespace internal
+}  // namespace v8
diff -Nrup mozilla/js/src/irregexp/RegExpShim.h mozilla-OK/js/src/irregexp/RegExpShim.h
--- mozilla/js/src/irregexp/RegExpShim.h	1970-01-01 03:00:00.000000000 +0300
+++ mozilla-OK/js/src/irregexp/RegExpShim.h	2022-04-22 05:08:45.973075117 +0300
@@ -0,0 +1,1261 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+// Copyright 2019 the V8 project authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef RegexpShim_h
+#define RegexpShim_h
+
+#include "mozilla/Assertions.h"
+#include "mozilla/Attributes.h"
+#include "mozilla/MathAlgorithms.h"
+#include "mozilla/Maybe.h"
+#include "mozilla/SegmentedVector.h"
+#include "mozilla/Sprintf.h"
+#include "mozilla/Types.h"
+
+#include <algorithm>
+#include <cctype>
+#include <iostream>  // needed for gcc 10
+
+#include "irregexp/RegExpTypes.h"
+#include "irregexp/util/FlagsShim.h"
+#include "irregexp/util/VectorShim.h"
+#include "irregexp/util/ZoneShim.h"
+#include "jit/Label.h"
+#include "jit/shared/Assembler-shared.h"
+#include "js/Value.h"
+#include "threading/ExclusiveData.h"
+#include "vm/MutexIDs.h"
+#include "vm/NativeObject.h"
+
+// Forward declaration of classes
+namespace v8 {
+namespace internal {
+
+class Heap;
+class Isolate;
+class RegExpMatchInfo;
+class RegExpStack;
+
+}  // namespace internal
+}  // namespace v8
+
+#define V8_WARN_UNUSED_RESULT MOZ_MUST_USE
+#define V8_EXPORT_PRIVATE MOZ_EXPORT
+#define V8_FALLTHROUGH [[fallthrough]]
+#define V8_NODISCARD [[nodiscard]]
+
+#define FATAL(x) MOZ_CRASH(x)
+#define UNREACHABLE() MOZ_CRASH("unreachable code")
+#define UNIMPLEMENTED() MOZ_CRASH("unimplemented code")
+#define STATIC_ASSERT(exp) static_assert(exp, #exp)
+
+#define DCHECK MOZ_ASSERT
+#define DCHECK_EQ(lhs, rhs) MOZ_ASSERT((lhs) == (rhs))
+#define DCHECK_NE(lhs, rhs) MOZ_ASSERT((lhs) != (rhs))
+#define DCHECK_GT(lhs, rhs) MOZ_ASSERT((lhs) > (rhs))
+#define DCHECK_GE(lhs, rhs) MOZ_ASSERT((lhs) >= (rhs))
+#define DCHECK_LT(lhs, rhs) MOZ_ASSERT((lhs) < (rhs))
+#define DCHECK_LE(lhs, rhs) MOZ_ASSERT((lhs) <= (rhs))
+#define DCHECK_NULL(val) MOZ_ASSERT((val) == nullptr)
+#define DCHECK_NOT_NULL(val) MOZ_ASSERT((val) != nullptr)
+#define DCHECK_IMPLIES(lhs, rhs) MOZ_ASSERT_IF(lhs, rhs)
+#define CHECK MOZ_RELEASE_ASSERT
+#define CHECK_LE(lhs, rhs) MOZ_RELEASE_ASSERT((lhs) <= (rhs))
+#define CHECK_GE(lhs, rhs) MOZ_RELEASE_ASSERT((lhs) >= (rhs))
+#define CONSTEXPR_DCHECK MOZ_ASSERT
+
+template <class T>
+static constexpr inline T Min(T t1, T t2) {
+  return t1 < t2 ? t1 : t2;
+}
+
+template <class T>
+static constexpr inline T Max(T t1, T t2) {
+  return t1 > t2 ? t1 : t2;
+}
+#define MemCopy memcpy
+
+// Origin:
+// https://github.com/v8/v8/blob/855591a54d160303349a5f0a32fab15825c708d1/src/base/macros.h#L310-L319
+// ptrdiff_t is 't' according to the standard, but MSVC uses 'I'.
+#ifdef _MSC_VER
+#  define V8PRIxPTRDIFF "Ix"
+#  define V8PRIdPTRDIFF "Id"
+#  define V8PRIuPTRDIFF "Iu"
+#else
+#  define V8PRIxPTRDIFF "tx"
+#  define V8PRIdPTRDIFF "td"
+#  define V8PRIuPTRDIFF "tu"
+#endif
+
+#define arraysize mozilla::ArrayLength
+
+// Explicitly declare the assignment operator as deleted.
+#define DISALLOW_ASSIGN(TypeName) TypeName& operator=(const TypeName&) = delete
+
+// Explicitly declare the copy constructor and assignment operator as deleted.
+// This also deletes the implicit move constructor and implicit move assignment
+// operator, but still allows to manually define them.
+#define DISALLOW_COPY_AND_ASSIGN(TypeName) \
+  TypeName(const TypeName&) = delete;      \
+  DISALLOW_ASSIGN(TypeName)
+
+// Explicitly declare all implicit constructors as deleted, namely the
+// default constructor, copy constructor and operator= functions.
+// This is especially useful for classes containing only static methods.
+#define DISALLOW_IMPLICIT_CONSTRUCTORS(TypeName) \
+  TypeName() = delete;                           \
+  DISALLOW_COPY_AND_ASSIGN(TypeName)
+
+namespace v8 {
+
+// Origin:
+// https://github.com/v8/v8/blob/855591a54d160303349a5f0a32fab15825c708d1/src/base/macros.h#L364-L367
+template <typename T, typename U>
+constexpr inline bool IsAligned(T value, U alignment) {
+  return (value & (alignment - 1)) == 0;
+}
+
+using byte = uint8_t;
+using Address = uintptr_t;
+static const Address kNullAddress = 0;
+
+// Latin1/UTF-16 constants
+// Code-point values in Unicode 4.0 are 21 bits wide.
+// Code units in UTF-16 are 16 bits wide.
+using uc16 = char16_t;
+using uc32 = uint32_t;
+
+namespace base {
+
+// Origin:
+// https://github.com/v8/v8/blob/855591a54d160303349a5f0a32fab15825c708d1/src/base/macros.h#L247-L258
+// The USE(x, ...) template is used to silence C++ compiler warnings
+// issued for (yet) unused variables (typically parameters).
+// The arguments are guaranteed to be evaluated from left to right.
+struct Use {
+  template <typename T>
+  Use(T&&) {}  // NOLINT(runtime/explicit)
+};
+#define USE(...)                                                   \
+  do {                                                             \
+    ::v8::base::Use unused_tmp_array_for_use_macro[]{__VA_ARGS__}; \
+    (void)unused_tmp_array_for_use_macro;                          \
+  } while (false)
+
+// Origin:
+// https://github.com/v8/v8/blob/855591a54d160303349a5f0a32fab15825c708d1/src/base/safe_conversions.h#L35-L39
+// saturated_cast<> is analogous to static_cast<> for numeric types, except
+// that the specified numeric conversion will saturate rather than overflow or
+// underflow.
+template <typename Dst, typename Src>
+inline Dst saturated_cast(Src value);
+
+// This is the only specialization that is needed for regexp code.
+// Instead of pulling in dozens of lines of template goo
+// to derive it, I used the implementation from uint8_clamped in
+// ArrayBufferObject.h.
+template <>
+inline uint8_t saturated_cast<uint8_t, int>(int x) {
+  return (x >= 0) ? ((x < 255) ? uint8_t(x) : 255) : 0;
+}
+
+// Origin:
+// https://github.com/v8/v8/blob/fc088cdaccadede84886eee881e67af9db53669a/src/base/bounds.h#L14-L28
+// Checks if value is in range [lower_limit, higher_limit] using a single
+// branch.
+template <typename T, typename U>
+inline constexpr bool IsInRange(T value, U lower_limit, U higher_limit) {
+  using unsigned_T = typename std::make_unsigned<T>::type;
+  // Use static_cast to support enum classes.
+  return static_cast<unsigned_T>(static_cast<unsigned_T>(value) -
+                                 static_cast<unsigned_T>(lower_limit)) <=
+         static_cast<unsigned_T>(static_cast<unsigned_T>(higher_limit) -
+                                 static_cast<unsigned_T>(lower_limit));
+}
+
+#define LAZY_INSTANCE_INITIALIZER \
+  {}
+
+template <typename T>
+class LazyInstanceImpl {
+ public:
+  LazyInstanceImpl() : value_(js::mutexid::IrregexpLazyStatic) {}
+
+  const T* Pointer() {
+    auto val = value_.lock();
+    if (val->isNothing()) {
+      val->emplace();
+    }
+    return val->ptr();
+  }
+
+ private:
+  js::ExclusiveData<mozilla::Maybe<T>> value_;
+};
+
+template <typename T>
+class LazyInstance {
+ public:
+  using type = LazyInstanceImpl<T>;
+};
+
+namespace bits {
+
+inline uint64_t CountTrailingZeros(uint64_t value) {
+  return mozilla::CountTrailingZeroes64(value);
+}
+
+inline size_t RoundUpToPowerOfTwo32(size_t value) {
+  return mozilla::RoundUpPow2(value);
+}
+
+template <typename T>
+constexpr bool IsPowerOfTwo(T value) {
+  return value > 0 && (value & (value - 1)) == 0;
+}
+
+}  // namespace bits
+}  // namespace base
+
+namespace unibrow {
+
+using uchar = unsigned int;
+
+// Origin:
+// https://github.com/v8/v8/blob/1f1e4cdb04c75eab77adbecd5f5514ddc3eb56cf/src/strings/unicode.h#L133-L150
+class Latin1 {
+ public:
+  static const uc16 kMaxChar = 0xff;
+
+  // Convert the character to Latin-1 case equivalent if possible.
+  static inline uc16 TryConvertToLatin1(uc16 c) {
+    // "GREEK CAPITAL LETTER MU" case maps to "MICRO SIGN".
+    // "GREEK SMALL LETTER MU" case maps to "MICRO SIGN".
+    if (c == 0x039C || c == 0x03BC) {
+      return 0xB5;
+    }
+    // "LATIN CAPITAL LETTER Y WITH DIAERESIS" case maps to "LATIN SMALL LETTER
+    // Y WITH DIAERESIS".
+    if (c == 0x0178) {
+      return 0xFF;
+    }
+    return c;
+  }
+};
+
+// Origin:
+// https://github.com/v8/v8/blob/b4bfbce6f91fc2cc72178af42bb3172c5f5eaebb/src/strings/unicode.h#L99-L131
+class Utf16 {
+ public:
+  static inline bool IsLeadSurrogate(int code) {
+    return js::unicode::IsLeadSurrogate(code);
+  }
+  static inline bool IsTrailSurrogate(int code) {
+    return js::unicode::IsTrailSurrogate(code);
+  }
+  static inline uc16 LeadSurrogate(uint32_t char_code) {
+    return js::unicode::LeadSurrogate(char_code);
+  }
+  static inline uc16 TrailSurrogate(uint32_t char_code) {
+    return js::unicode::TrailSurrogate(char_code);
+  }
+  static inline uint32_t CombineSurrogatePair(char16_t lead, char16_t trail) {
+    return js::unicode::UTF16Decode(lead, trail);
+  }
+  static const uchar kMaxNonSurrogateCharCode = 0xffff;
+};
+
+#ifndef V8_INTL_SUPPORT
+
+// A cache used in case conversion.  It caches the value for characters
+// that either have no mapping or map to a single character independent
+// of context.  Characters that map to more than one character or that
+// map differently depending on context are always looked up.
+// Origin:
+// https://github.com/v8/v8/blob/b4bfbce6f91fc2cc72178af42bb3172c5f5eaebb/src/strings/unicode.h#L64-L88
+template <class T, int size = 256>
+class Mapping {
+ public:
+  inline Mapping() = default;
+  inline int get(uchar c, uchar n, uchar* result) {
+    CacheEntry entry = entries_[c & kMask];
+    if (entry.code_point_ == c) {
+      if (entry.offset_ == 0) {
+        return 0;
+      } else {
+        result[0] = c + entry.offset_;
+        return 1;
+      }
+    } else {
+      return CalculateValue(c, n, result);
+    }
+  }
+
+ private:
+  int CalculateValue(uchar c, uchar n, uchar* result) {
+    bool allow_caching = true;
+    int length = T::Convert(c, n, result, &allow_caching);
+    if (allow_caching) {
+      if (length == 1) {
+        entries_[c & kMask] = CacheEntry(c, result[0] - c);
+        return 1;
+      } else {
+        entries_[c & kMask] = CacheEntry(c, 0);
+        return 0;
+      }
+    } else {
+      return length;
+    }
+  }
+
+  struct CacheEntry {
+    inline CacheEntry() : code_point_(kNoChar), offset_(0) {}
+    inline CacheEntry(uchar code_point, signed offset)
+        : code_point_(code_point), offset_(offset) {}
+    uchar code_point_;
+    signed offset_;
+    static const int kNoChar = (1 << 21) - 1;
+  };
+  static const int kSize = size;
+  static const int kMask = kSize - 1;
+  CacheEntry entries_[kSize];
+};
+
+// Origin:
+// https://github.com/v8/v8/blob/b4bfbce6f91fc2cc72178af42bb3172c5f5eaebb/src/strings/unicode.h#L241-L252
+struct Ecma262Canonicalize {
+  static const int kMaxWidth = 1;
+  static int Convert(uchar c, uchar n, uchar* result, bool* allow_caching_ptr);
+};
+struct Ecma262UnCanonicalize {
+  static const int kMaxWidth = 4;
+  static int Convert(uchar c, uchar n, uchar* result, bool* allow_caching_ptr);
+};
+struct CanonicalizationRange {
+  static const int kMaxWidth = 1;
+  static int Convert(uchar c, uchar n, uchar* result, bool* allow_caching_ptr);
+};
+
+#endif  // !V8_INTL_SUPPORT
+
+struct Letter {
+  static bool Is(uchar c);
+};
+
+}  // namespace unibrow
+
+namespace internal {
+
+#define PRINTF_FORMAT(x, y) MOZ_FORMAT_PRINTF(x, y)
+void PRINTF_FORMAT(1, 2) PrintF(const char* format, ...);
+void PRINTF_FORMAT(2, 3) PrintF(FILE* out, const char* format, ...);
+
+// Superclass for classes only using static method functions.
+// The subclass of AllStatic cannot be instantiated at all.
+class AllStatic {
+#ifdef DEBUG
+ public:
+  AllStatic() = delete;
+#endif
+};
+
+// Superclass for classes managed with new and delete.
+// In irregexp, this is only AlternativeGeneration (in regexp-compiler.cc)
+// Compare:
+// https://github.com/v8/v8/blob/7b3332844212d78ee87a9426f3a6f7f781a8fbfa/src/utils/allocation.cc#L88-L96
+class Malloced {
+ public:
+  static void* operator new(size_t size) {
+    js::AutoEnterOOMUnsafeRegion oomUnsafe;
+    void* result = js_malloc(size);
+    if (!result) {
+      oomUnsafe.crash("Irregexp Malloced shim");
+    }
+    return result;
+  }
+  static void operator delete(void* p) { js_free(p); }
+};
+
+constexpr int32_t KB = 1024;
+constexpr int32_t MB = 1024 * 1024;
+
+#define kMaxInt JSVAL_INT_MAX
+#define kMinInt JSVAL_INT_MIN
+constexpr int kSystemPointerSize = sizeof(void*);
+
+// The largest integer n such that n and n + 1 are both exactly
+// representable as a Number value.  ES6 section 20.1.2.6
+constexpr double kMaxSafeInteger = 9007199254740991.0;  // 2^53-1
+
+constexpr int kBitsPerByte = 8;
+constexpr int kBitsPerByteLog2 = 3;
+constexpr int kUInt32Size = sizeof(uint32_t);
+constexpr int kInt64Size = sizeof(int64_t);
+constexpr int kUC16Size = sizeof(uc16);
+
+inline constexpr bool IsDecimalDigit(uc32 c) { return c >= '0' && c <= '9'; }
+
+inline bool is_uint24(int64_t val) { return (val >> 24) == 0; }
+inline bool is_int24(int64_t val) {
+  int64_t limit = int64_t(1) << 23;
+  return (-limit <= val) && (val < limit);
+}
+
+inline bool IsIdentifierStart(uc32 c) {
+  return js::unicode::IsIdentifierStart(uint32_t(c));
+}
+inline bool IsIdentifierPart(uc32 c) {
+  return js::unicode::IsIdentifierPart(uint32_t(c));
+}
+
+// Wrappers to disambiguate char16_t and uc16.
+struct AsUC16 {
+  explicit AsUC16(char16_t v) : value(v) {}
+  char16_t value;
+};
+
+struct AsUC32 {
+  explicit AsUC32(int32_t v) : value(v) {}
+  int32_t value;
+};
+
+std::ostream& operator<<(std::ostream& os, const AsUC16& c);
+std::ostream& operator<<(std::ostream& os, const AsUC32& c);
+
+// This class is used for the output of trace-regexp-parser.  V8 has
+// an elaborate implementation to ensure that the output gets to the
+// right place, even on Android. We just need something that will
+// print output (ideally to stderr, to match the rest of our tracing
+// code). This is an empty wrapper that will convert itself to
+// std::cerr when used.
+class StdoutStream {
+ public:
+  operator std::ostream&() const;
+  template <typename T>
+  std::ostream& operator<<(T t);
+};
+
+// Reuse existing Maybe implementation
+using mozilla::Maybe;
+
+template <typename T>
+Maybe<T> Just(const T& value) {
+  return mozilla::Some(value);
+}
+
+template <typename T>
+mozilla::Nothing Nothing() {
+  return mozilla::Nothing();
+}
+
+template <typename T>
+using PseudoHandle = mozilla::UniquePtr<T, JS::FreePolicy>;
+
+// Compare 8bit/16bit chars to 8bit/16bit chars.
+// Used indirectly by regexp-interpreter.cc
+// Taken from: https://github.com/v8/v8/blob/master/src/utils/utils.h
+template <typename lchar, typename rchar>
+inline int CompareCharsUnsigned(const lchar* lhs, const rchar* rhs,
+                                size_t chars) {
+  const lchar* limit = lhs + chars;
+  if (sizeof(*lhs) == sizeof(char) && sizeof(*rhs) == sizeof(char)) {
+    // memcmp compares byte-by-byte, yielding wrong results for two-byte
+    // strings on little-endian systems.
+    return memcmp(lhs, rhs, chars);
+  }
+  while (lhs < limit) {
+    int r = static_cast<int>(*lhs) - static_cast<int>(*rhs);
+    if (r != 0) return r;
+    ++lhs;
+    ++rhs;
+  }
+  return 0;
+}
+template <typename lchar, typename rchar>
+inline int CompareChars(const lchar* lhs, const rchar* rhs, size_t chars) {
+  DCHECK_LE(sizeof(lchar), 2);
+  DCHECK_LE(sizeof(rchar), 2);
+  if (sizeof(lchar) == 1) {
+    if (sizeof(rchar) == 1) {
+      return CompareCharsUnsigned(reinterpret_cast<const uint8_t*>(lhs),
+                                  reinterpret_cast<const uint8_t*>(rhs), chars);
+    } else {
+      return CompareCharsUnsigned(reinterpret_cast<const uint8_t*>(lhs),
+                                  reinterpret_cast<const char16_t*>(rhs),
+                                  chars);
+    }
+  } else {
+    if (sizeof(rchar) == 1) {
+      return CompareCharsUnsigned(reinterpret_cast<const char16_t*>(lhs),
+                                  reinterpret_cast<const uint8_t*>(rhs), chars);
+    } else {
+      return CompareCharsUnsigned(reinterpret_cast<const char16_t*>(lhs),
+                                  reinterpret_cast<const char16_t*>(rhs),
+                                  chars);
+    }
+  }
+}
+
+// Compare 8bit/16bit chars to 8bit/16bit chars.
+template <typename lchar, typename rchar>
+inline bool CompareCharsEqualUnsigned(const lchar* lhs, const rchar* rhs,
+                                      size_t chars) {
+  STATIC_ASSERT(std::is_unsigned<lchar>::value);
+  STATIC_ASSERT(std::is_unsigned<rchar>::value);
+  if (sizeof(*lhs) == sizeof(*rhs)) {
+    // memcmp compares byte-by-byte, but for equality it doesn't matter whether
+    // two-byte char comparison is little- or big-endian.
+    return memcmp(lhs, rhs, chars * sizeof(*lhs)) == 0;
+  }
+  for (const lchar* limit = lhs + chars; lhs < limit; ++lhs, ++rhs) {
+    if (*lhs != *rhs) return false;
+  }
+  return true;
+}
+
+template <typename lchar, typename rchar>
+inline bool CompareCharsEqual(const lchar* lhs, const rchar* rhs,
+                              size_t chars) {
+  using ulchar = typename std::make_unsigned<lchar>::type;
+  using urchar = typename std::make_unsigned<rchar>::type;
+  return CompareCharsEqualUnsigned(reinterpret_cast<const ulchar*>(lhs),
+                                   reinterpret_cast<const urchar*>(rhs), chars);
+}
+
+// Origin:
+// https://github.com/v8/v8/blob/855591a54d160303349a5f0a32fab15825c708d1/src/utils/utils.h#L40-L48
+// Returns the value (0 .. 15) of a hexadecimal character c.
+// If c is not a legal hexadecimal character, returns a value < 0.
+// Used in regexp-parser.cc
+inline int HexValue(uc32 c) {
+  c -= '0';
+  if (static_cast<unsigned>(c) <= 9) return c;
+  c = (c | 0x20) - ('a' - '0');  // detect 0x11..0x16 and 0x31..0x36.
+  if (static_cast<unsigned>(c) <= 5) return c + 10;
+  return -1;
+}
+
+// V8::Object ~= JS::Value
+class Object {
+ public:
+  // The default object constructor in V8 stores a nullptr,
+  // which has its low bit clear and is interpreted as Smi(0).
+  constexpr Object() : asBits_(JS::Int32Value(0).asRawBits()) {}
+
+  Object(const JS::Value& value) { setValue(value); }
+
+  // Used in regexp-interpreter.cc to check the return value of
+  // isolate->stack_guard()->HandleInterrupts(). We want to handle
+  // interrupts in the caller, so we always return false from
+  // HandleInterrupts and true here.
+  inline bool IsException(Isolate*) const {
+    MOZ_ASSERT(!value().toBoolean());
+    return true;
+  }
+
+  JS::Value value() const { return JS::Value::fromRawBits(asBits_); }
+
+  inline static Object cast(Object object) { return object; }
+
+ protected:
+  void setValue(const JS::Value& val) { asBits_ = val.asRawBits(); }
+  uint64_t asBits_;
+} JS_HAZ_GC_POINTER;
+
+class Smi : public Object {
+ public:
+  static Smi FromInt(int32_t value) {
+    Smi smi;
+    smi.setValue(JS::Int32Value(value));
+    return smi;
+  }
+  static inline int32_t ToInt(const Object object) {
+    return object.value().toInt32();
+  }
+};
+
+// V8::HeapObject ~= GC thing
+class HeapObject : public Object {
+ public:
+  inline static HeapObject cast(Object object) {
+    HeapObject h;
+    h.setValue(object.value());
+    return h;
+  }
+};
+
+// A fixed-size array with Objects (aka Values) as element types.
+// Implemented using the dense elements of an ArrayObject.
+// Used for named captures.
+class FixedArray : public HeapObject {
+ public:
+  inline void set(uint32_t index, Object value) {
+    inner()->setDenseElement(index, value.value());
+  }
+  inline static FixedArray cast(Object object) {
+    FixedArray f;
+    f.setValue(object.value());
+    return f;
+  }
+  js::NativeObject* inner() {
+    return &value().toObject().as<js::NativeObject>();
+  }
+};
+
+/*
+ * Conceptually, ByteArrayData is a variable-size structure. To
+ * implement this in a C++-approved way, we allocate a struct
+ * containing the 32-bit length field, followed by additional memory
+ * for the data. To access the data, we get a pointer to the next byte
+ * after the length field and cast it to the correct type.
+ */
+inline uint8_t* ByteArrayData::data() {
+  static_assert(alignof(uint8_t) <= alignof(ByteArrayData),
+                "The trailing data must be aligned to start immediately "
+                "after the header with no padding.");
+  ByteArrayData* immediatelyAfter = this + 1;
+  return reinterpret_cast<uint8_t*>(immediatelyAfter);
+}
+
+// A fixed-size array of bytes.
+class ByteArray : public HeapObject {
+  ByteArrayData* inner() const {
+    return static_cast<ByteArrayData*>(value().toPrivate());
+  }
+
+ public:
+  PseudoHandle<ByteArrayData> takeOwnership(Isolate* isolate);
+  byte get(uint32_t index) {
+    MOZ_ASSERT(index < length());
+    return inner()->data()[index];
+  }
+  void set(uint32_t index, byte val) {
+    MOZ_ASSERT(index < length());
+    inner()->data()[index] = val;
+  }
+  uint32_t length() const { return inner()->length; }
+  byte* GetDataStartAddress() { return inner()->data(); }
+
+  static ByteArray cast(Object object) {
+    ByteArray b;
+    b.setValue(object.value());
+    return b;
+  }
+};
+
+// Like Handles in SM, V8 handles are references to marked pointers.
+// Unlike SM, where Rooted pointers are created individually on the
+// stack, the target of a V8 handle lives in an arena on the isolate
+// (~= JSContext). Whenever a Handle is created, a new "root" is
+// created at the end of the arena.
+//
+// HandleScopes are used to manage the lifetimes of these handles.  A
+// HandleScope lives on the stack and stores the size of the arena at
+// the time of its creation. When the function returns and the
+// HandleScope is destroyed, the arena is truncated to its previous
+// size, clearing all roots that were created since the creation of
+// the HandleScope.
+//
+// In some cases, objects that are GC-allocated in V8 are not in SM.
+// In particular, irregexp allocates ByteArrays during code generation
+// to store lookup tables. This does not play nicely with the SM
+// macroassembler's requirement that no GC allocations take place
+// while it is on the stack. To work around this, this shim layer also
+// provides the ability to create pseudo-handles, which are not
+// managed by the GC but provide the same API to irregexp. The "root"
+// of a pseudohandle is a unique pointer living in a second arena. If
+// the allocated object should outlive the HandleScope, it must be
+// manually moved out of the arena using takeOwnership.
+
+class MOZ_STACK_CLASS HandleScope {
+ public:
+  HandleScope(Isolate* isolate);
+  ~HandleScope();
+
+ private:
+  size_t level_;
+  size_t non_gc_level_;
+  Isolate* isolate_;
+
+  friend class Isolate;
+};
+
+// Origin:
+// https://github.com/v8/v8/blob/5792f3587116503fc047d2f68c951c72dced08a5/src/handles/handles.h#L88-L171
+template <typename T>
+class MOZ_NONHEAP_CLASS Handle {
+ public:
+  Handle() : location_(nullptr) {}
+  Handle(T object, Isolate* isolate);
+  Handle(const JS::Value& value, Isolate* isolate);
+
+  // Constructor for handling automatic up casting.
+  template <typename S,
+            typename = typename std::enable_if<std::is_convertible<S*, T*>::value>::type>
+  inline Handle(Handle<S> handle) : location_(handle.location_) {}
+
+  inline bool is_null() const { return location_ == nullptr; }
+
+  inline T operator*() const { return T::cast(Object(*location_)); };
+
+  // {ObjectRef} is returned by {Handle::operator->}. It should never be stored
+  // anywhere or used in any other code; no one should ever have to spell out
+  // {ObjectRef} in code. Its only purpose is to be dereferenced immediately by
+  // "operator-> chaining". Returning the address of the field is valid because
+  // this object's lifetime only ends at the end of the full statement.
+  // Origin:
+  // https://github.com/v8/v8/blob/03aaa4b3bf4cb01eee1f223b252e6869b04ab08c/src/handles/handles.h#L91-L105
+  class ObjectRef {
+   public:
+    T* operator->() { return &object_; }
+
+   private:
+    friend class Handle;
+    explicit ObjectRef(T object) : object_(object) {}
+
+    T object_;
+  };
+  inline ObjectRef operator->() const { return ObjectRef{**this}; }
+
+  static Handle<T> fromHandleValue(JS::HandleValue handle) {
+    return Handle(handle.address());
+  }
+
+ private:
+  Handle(const JS::Value* location) : location_(location) {}
+
+  template <typename>
+  friend class Handle;
+  template <typename>
+  friend class MaybeHandle;
+
+  const JS::Value* location_;
+};
+
+// A Handle can be converted into a MaybeHandle. Converting a MaybeHandle
+// into a Handle requires checking that it does not point to nullptr.  This
+// ensures nullptr checks before use.
+//
+// Also note that Handles do not provide default equality comparison or hashing
+// operators on purpose. Such operators would be misleading, because intended
+// semantics is ambiguous between Handle location and object identity.
+// Origin:
+// https://github.com/v8/v8/blob/5792f3587116503fc047d2f68c951c72dced08a5/src/handles/maybe-handles.h#L15-L78
+template <typename T>
+class MOZ_NONHEAP_CLASS MaybeHandle final {
+ public:
+  MaybeHandle() : location_(nullptr) {}
+
+  // Constructor for handling automatic up casting from Handle.
+  // Ex. Handle<JSArray> can be passed when MaybeHandle<Object> is expected.
+  template <typename S,
+            typename = typename std::enable_if<std::is_convertible<S*, T*>::value>::type>
+  MaybeHandle(Handle<S> handle) : location_(handle.location_) {}
+
+  inline Handle<T> ToHandleChecked() const {
+    MOZ_RELEASE_ASSERT(location_);
+    return Handle<T>(location_);
+  }
+
+  // Convert to a Handle with a type that can be upcasted to.
+  template <typename S>
+  inline bool ToHandle(Handle<S>* out) const {
+    if (location_) {
+      *out = Handle<T>(location_);
+      return true;
+    } else {
+      *out = Handle<T>();
+      return false;
+    }
+  }
+
+ private:
+  JS::Value* location_;
+};
+
+// From v8/src/handles/handles-inl.h
+
+template <typename T>
+inline Handle<T> handle(T object, Isolate* isolate) {
+  return Handle<T>(object, isolate);
+}
+
+// RAII Guard classes
+
+using DisallowGarbageCollection = JS::AutoCheckCannotGC;
+
+// V8 uses this inside DisallowGarbageCollection regions to turn
+// allocation back on before throwing a stack overflow exception or
+// handling interrupts. AutoSuppressGC is sufficient for the former
+// case, but not for the latter: handling interrupts can execute
+// arbitrary script code, and V8 jumps through some scary hoops to
+// "manually relocate unhandlified references" afterwards. To keep
+// things sane, we don't try to handle interrupts while regex code is
+// still on the stack. Instead, we return EXCEPTION and handle
+// interrupts in the caller. (See RegExpShared::execute.)
+
+class AllowGarbageCollection {
+ public:
+  AllowGarbageCollection() {}
+};
+
+// Origin:
+// https://github.com/v8/v8/blob/84f3877c15bc7f8956d21614da4311337525a3c8/src/objects/string.h#L83-L474
+class String : public HeapObject {
+ private:
+  JSString* str() const { return value().toString(); }
+
+ public:
+  String() = default;
+  String(JSString* str) { setValue(JS::StringValue(str)); }
+
+  operator JSString*() const { return str(); }
+
+  // Max char codes.
+  static const int32_t kMaxOneByteCharCode = unibrow::Latin1::kMaxChar;
+  static const uint32_t kMaxOneByteCharCodeU = unibrow::Latin1::kMaxChar;
+  static const int kMaxUtf16CodeUnit = 0xffff;
+  static const uint32_t kMaxUtf16CodeUnitU = kMaxUtf16CodeUnit;
+  static const uc32 kMaxCodePoint = 0x10ffff;
+
+  MOZ_ALWAYS_INLINE int length() const { return str()->length(); }
+  bool IsFlat() { return str()->isLinear(); };
+
+  // Origin:
+  // https://github.com/v8/v8/blob/84f3877c15bc7f8956d21614da4311337525a3c8/src/objects/string.h#L95-L152
+  class FlatContent {
+   public:
+    FlatContent(JSLinearString* string, const DisallowGarbageCollection& no_gc)
+        : string_(string), no_gc_(no_gc) {}
+    inline bool IsOneByte() const { return string_->hasLatin1Chars(); }
+    inline bool IsTwoByte() const { return !string_->hasLatin1Chars(); }
+
+    Vector<const uint8_t> ToOneByteVector() const {
+      MOZ_ASSERT(IsOneByte());
+      return Vector<const uint8_t>(string_->latin1Chars(no_gc_),
+                                   string_->length());
+    }
+    Vector<const uc16> ToUC16Vector() const {
+      MOZ_ASSERT(IsTwoByte());
+      return Vector<const uc16>(string_->twoByteChars(no_gc_),
+                                string_->length());
+    }
+
+   private:
+    const JSLinearString* string_;
+    const JS::AutoCheckCannotGC& no_gc_;
+  };
+  FlatContent GetFlatContent(const DisallowGarbageCollection& no_gc) {
+    MOZ_ASSERT(IsFlat());
+    return FlatContent(&str()->asLinear(), no_gc);
+  }
+
+  static Handle<String> Flatten(Isolate* isolate, Handle<String> string);
+
+  inline static String cast(Object object) {
+    String s;
+    MOZ_ASSERT(object.value().isString());
+    s.setValue(object.value());
+    return s;
+  }
+
+  inline static bool IsOneByteRepresentationUnderneath(String string) {
+    return string.str()->hasLatin1Chars();
+  }
+  inline bool IsOneByteRepresentation() const {
+    return str()->hasLatin1Chars();
+  }
+
+  std::unique_ptr<char[]> ToCString();
+
+  template <typename Char>
+  Vector<const Char> GetCharVector(const DisallowGarbageCollection& no_gc);
+};
+
+template <>
+inline Vector<const uint8_t> String::GetCharVector(
+    const DisallowGarbageCollection& no_gc) {
+  String::FlatContent flat = GetFlatContent(no_gc);
+  MOZ_ASSERT(flat.IsOneByte());
+  return flat.ToOneByteVector();
+}
+
+template <>
+inline Vector<const uc16> String::GetCharVector(
+    const DisallowGarbageCollection& no_gc) {
+  String::FlatContent flat = GetFlatContent(no_gc);
+  MOZ_ASSERT(flat.IsTwoByte());
+  return flat.ToUC16Vector();
+}
+
+// A flat string reader provides random access to the contents of a
+// string independent of the character width of the string.
+class MOZ_STACK_CLASS FlatStringReader {
+ public:
+  FlatStringReader(JSContext* cx, js::HandleLinearString string)
+      : string_(string), length_(string->length()) {}
+
+  FlatStringReader(const mozilla::Range<const char16_t> range)
+      : string_(nullptr), range_(range), length_(range.length()) {}
+
+  int length() { return length_; }
+
+  inline char16_t Get(size_t index) {
+    MOZ_ASSERT(index < length_);
+    if (string_) {
+      return string_->latin1OrTwoByteChar(index);
+    }
+    return range_[index];
+  }
+
+ private:
+  js::HandleLinearString string_;
+  const mozilla::Range<const char16_t> range_;
+  size_t length_;
+};
+
+class JSRegExp : public HeapObject {
+ public:
+  JSRegExp() : HeapObject() {}
+  JSRegExp(js::RegExpShared* re) { setValue(JS::PrivateGCThingValue(re)); }
+
+  // ******************************************************
+  // Methods that are called from inside the implementation
+  // ******************************************************
+  void TierUpTick() { inner()->tierUpTick(); }
+
+  Object Code(bool is_latin1) const {
+    return Object(JS::PrivateGCThingValue(inner()->getJitCode(is_latin1)));
+  }
+  Object Bytecode(bool is_latin1) const {
+    return Object(JS::PrivateValue(inner()->getByteCode(is_latin1)));
+  }
+
+  // TODO: should we expose this?
+  uint32_t BacktrackLimit() const { return 0; }
+
+  static JSRegExp cast(Object object) {
+    JSRegExp regexp;
+    js::gc::Cell* regexpShared = object.value().toGCThing();
+    MOZ_ASSERT(regexpShared->is<js::RegExpShared>());
+    regexp.setValue(JS::PrivateGCThingValue(regexpShared));
+    return regexp;
+  }
+
+  // Each capture (including the match itself) needs two registers.
+  static constexpr int RegistersForCaptureCount(int count) {
+    return (count + 1) * 2;
+  }
+
+  inline int MaxRegisterCount() const { return inner()->getMaxRegisters(); }
+
+  // ******************************
+  // Static constants
+  // ******************************
+
+  // Maximum number of captures allowed.
+  static constexpr int kMaxCaptures = (1 << 15) - 1;
+
+  // **************************************************
+  // JSRegExp::Flags
+  // **************************************************
+
+  enum Flag : uint8_t {
+    kNone = JS::RegExpFlag::NoFlags,
+    kGlobal = JS::RegExpFlag::Global,
+    kIgnoreCase = JS::RegExpFlag::IgnoreCase,
+    kMultiline = JS::RegExpFlag::Multiline,
+    kSticky = JS::RegExpFlag::Sticky,
+    kUnicode = JS::RegExpFlag::Unicode,
+    kDotAll = JS::RegExpFlag::DotAll,
+  };
+  using Flags = JS::RegExpFlags;
+
+  static constexpr int kNoBacktrackLimit = 0;
+
+ private:
+  js::RegExpShared* inner() const {
+    return static_cast<js::RegExpShared*>(value().toGCThing());
+  }
+};
+
+class Histogram {
+ public:
+  inline void AddSample(int sample) {}
+};
+
+class Counters {
+ public:
+  Histogram* regexp_backtracks() { return &regexp_backtracks_; }
+
+ private:
+  Histogram regexp_backtracks_;
+};
+
+#define PROFILE(isolate, call) \
+  do {                         \
+  } while (false);
+
+enum class AllocationType : uint8_t {
+  kYoung,  // Allocate in the nursery
+  kOld,    // Allocate in the tenured heap
+};
+
+using StackGuard = Isolate;
+using Factory = Isolate;
+
+class Isolate {
+ public:
+  Isolate(JSContext* cx) : cx_(cx) {}
+  ~Isolate();
+  bool init();
+
+  size_t sizeOfIncludingThis(mozilla::MallocSizeOf mallocSizeOf) const;
+
+  //********** Isolate code **********//
+  RegExpStack* regexp_stack() const { return regexpStack_; }
+  byte* top_of_regexp_stack() const;
+
+  // This is called from inside no-GC code. Instead of suppressing GC
+  // to allocate the error, we return false from Execute and call
+  // ReportOverRecursed in the caller.
+  void StackOverflow() {}
+
+#ifndef V8_INTL_SUPPORT
+  unibrow::Mapping<unibrow::Ecma262UnCanonicalize>* jsregexp_uncanonicalize() {
+    return &jsregexp_uncanonicalize_;
+  }
+  unibrow::Mapping<unibrow::Ecma262Canonicalize>*
+  regexp_macro_assembler_canonicalize() {
+    return &regexp_macro_assembler_canonicalize_;
+  }
+  unibrow::Mapping<unibrow::CanonicalizationRange>* jsregexp_canonrange() {
+    return &jsregexp_canonrange_;
+  }
+
+ private:
+  unibrow::Mapping<unibrow::Ecma262UnCanonicalize> jsregexp_uncanonicalize_;
+  unibrow::Mapping<unibrow::Ecma262Canonicalize>
+      regexp_macro_assembler_canonicalize_;
+  unibrow::Mapping<unibrow::CanonicalizationRange> jsregexp_canonrange_;
+#endif  // !V8_INTL_SUPPORT
+
+ public:
+  // An empty stub for telemetry we don't support
+  void IncreaseTotalRegexpCodeGenerated(Handle<HeapObject> code) {}
+
+  Counters* counters() { return &counters_; }
+
+  //********** Factory code **********//
+  inline Factory* factory() { return this; }
+
+  Handle<ByteArray> NewByteArray(
+      int length, AllocationType allocation = AllocationType::kYoung);
+
+  // Allocates a fixed array initialized with undefined values.
+  Handle<FixedArray> NewFixedArray(int length);
+
+  template <typename Char>
+  Handle<String> InternalizeString(const Vector<const Char>& str);
+
+  //********** Stack guard code **********//
+  inline StackGuard* stack_guard() { return this; }
+
+  // This is called from inside no-GC code. V8 runs the interrupt
+  // inside the no-GC code and then "manually relocates unhandlified
+  // references" afterwards. We just return false and let the caller
+  // handle interrupts.
+  Object HandleInterrupts() { return Object(JS::BooleanValue(false)); }
+
+  JSContext* cx() const { return cx_; }
+
+  void trace(JSTracer* trc);
+
+  //********** Handle code **********//
+
+  JS::Value* getHandleLocation(const JS::Value& value);
+
+ private:
+  mozilla::SegmentedVector<JS::Value, 256> handleArena_;
+  mozilla::SegmentedVector<PseudoHandle<void>, 256> uniquePtrArena_;
+
+  void* allocatePseudoHandle(size_t bytes);
+
+ public:
+  template <typename T>
+  PseudoHandle<T> takeOwnership(void* ptr);
+
+  uint32_t liveHandles() const { return handleArena_.Length(); }
+  uint32_t livePseudoHandles() const { return uniquePtrArena_.Length(); }
+
+ private:
+  void openHandleScope(HandleScope& scope) {
+    scope.level_ = handleArena_.Length();
+    scope.non_gc_level_ = uniquePtrArena_.Length();
+  }
+  void closeHandleScope(size_t prevLevel, size_t prevUniqueLevel) {
+    size_t currLevel = handleArena_.Length();
+    handleArena_.PopLastN(currLevel - prevLevel);
+
+    size_t currUniqueLevel = uniquePtrArena_.Length();
+    uniquePtrArena_.PopLastN(currUniqueLevel - prevUniqueLevel);
+  }
+  friend class HandleScope;
+
+  JSContext* cx_;
+  RegExpStack* regexpStack_;
+  Counters counters_;
+};
+
+// Origin:
+// https://github.com/v8/v8/blob/50dcf2af54ce27801a71c47c1be1d2c5e36b0dd6/src/execution/isolate.h#L1909-L1931
+class StackLimitCheck {
+ public:
+  StackLimitCheck(Isolate* isolate) : cx_(isolate->cx()) {}
+
+  // Use this to check for stack-overflows in C++ code.
+  bool HasOverflowed() {
+    bool overflowed = !CheckRecursionLimitDontReport(cx_);
+#ifdef JS_MORE_DETERMINISTIC
+    if (overflowed) {
+      // We don't report overrecursion here, but we throw an exception later
+      // and this still affects differential testing. Mimic ReportOverRecursed
+      // (the fuzzers check for this particular string).
+      fprintf(stderr, "ReportOverRecursed called\n");
+    }
+#endif
+    return overflowed;
+  }
+
+  // Use this to check for interrupt request in C++ code.
+  bool InterruptRequested() { return cx_->hasPendingInterrupt(); }
+
+  // Use this to check for stack-overflow when entering runtime from JS code.
+  bool JsHasOverflowed() {
+    return !CheckRecursionLimitConservativeDontReport(cx_);
+  }
+
+ private:
+  JSContext* cx_;
+};
+
+class Code : public HeapObject {
+ public:
+  uint8_t* raw_instruction_start() { return inner()->raw(); }
+
+  static Code cast(Object object) {
+    Code c;
+    js::gc::Cell* jitCode = object.value().toGCThing();
+    MOZ_ASSERT(jitCode->is<js::jit::JitCode>());
+    c.setValue(JS::PrivateGCThingValue(jitCode));
+    return c;
+  }
+  js::jit::JitCode* inner() {
+    return static_cast<js::jit::JitCode*>(value().toGCThing());
+  }
+};
+
+enum class MessageTemplate { kStackOverflow };
+
+class MessageFormatter {
+ public:
+  static const char* TemplateString(MessageTemplate index) {
+    switch (index) {
+      case MessageTemplate::kStackOverflow:
+        return "too much recursion";
+    }
+  }
+};
+
+// Origin: https://github.com/v8/v8/blob/master/src/codegen/label.h
+class Label {
+ public:
+  Label() : inner_(js::jit::Label()) {}
+
+  js::jit::Label* inner() { return &inner_; }
+
+  void Unuse() { inner_.reset(); }
+
+  bool is_linked() { return inner_.used(); }
+  bool is_bound() { return inner_.bound(); }
+  bool is_unused() { return !inner_.used() && !inner_.bound(); }
+
+  int pos() { return inner_.offset(); }
+  void link_to(int pos) { inner_.use(pos); }
+  void bind_to(int pos) { inner_.bind(pos); }
+
+ private:
+  js::jit::Label inner_;
+  js::jit::CodeOffset patchOffset_;
+
+  friend class SMRegExpMacroAssembler;
+};
+
+//**************************************************
+// Constant Flags
+//**************************************************
+
+// V8 uses this for differential fuzzing to handle stack overflows.
+// We address the same problem in StackLimitCheck::HasOverflowed.
+const bool FLAG_correctness_fuzzer_suppressions = false;
+
+// Instead of using a flag for this, we provide an implementation of
+// CanReadUnaligned in SMRegExpMacroAssembler.
+const bool FLAG_enable_regexp_unaligned_accesses = false;
+
+// This is used to guard a prototype implementation of sequence properties.
+// See: https://github.com/tc39/proposal-regexp-unicode-sequence-properties
+// TODO: Expose this behind a pref once it is past stage 2?
+const bool FLAG_harmony_regexp_sequence = false;
+
+// This is only used in a helper function in regex.h that we never call.
+const bool FLAG_regexp_interpret_all = false;
+
+// This is used to guard a prototype implementation of mode modifiers,
+// which can modify the regexp flags on the fly inside the pattern.
+// As far as I can tell, there isn't even a TC39 proposal for this.
+const bool FLAG_regexp_mode_modifiers = false;
+
+// This is used to guard an old prototype implementation of possessive
+// quantifiers, which never got past the point of adding parser support.
+const bool FLAG_regexp_possessive_quantifier = false;
+
+// These affect the default level of optimization. We can still turn
+// optimization off on a case-by-case basis in CompilePattern - for
+// example, if a regexp is too long - so we might as well turn these
+// flags on unconditionally.
+const bool FLAG_regexp_optimization = true;
+#if MOZ_BIG_ENDIAN
+// peephole optimization not supported on big endian
+const bool FLAG_regexp_peephole_optimization = false;
+#else
+const bool FLAG_regexp_peephole_optimization = true;
+#endif
+
+// This is used to control whether regexps tier up from interpreted to
+// compiled. We control this with --no-native-regexp and
+// --regexp-warmup-threshold.
+const bool FLAG_regexp_tier_up = true;
+
+//**************************************************
+// Debugging Flags
+//**************************************************
+
+extern bool FLAG_trace_regexp_assembler;
+extern bool FLAG_trace_regexp_bytecodes;
+extern bool FLAG_trace_regexp_parser;
+extern bool FLAG_trace_regexp_peephole_optimization;
+
+#define COMPILING_IRREGEXP_FOR_EXTERNAL_EMBEDDER
+
+}  // namespace internal
+}  // namespace v8
+
+#endif  // RegexpShim_h
diff -Nrup mozilla/js/src/irregexp/RegExpTypes.h mozilla-OK/js/src/irregexp/RegExpTypes.h
--- mozilla/js/src/irregexp/RegExpTypes.h	1970-01-01 03:00:00.000000000 +0300
+++ mozilla-OK/js/src/irregexp/RegExpTypes.h	2022-04-22 05:08:42.157101882 +0300
@@ -0,0 +1,64 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+// This file forward-defines Irregexp classes that need to be visible
+// to the rest of Spidermonkey and re-exports them into js::irregexp.
+
+#ifndef regexp_RegExpTypes_h
+#define regexp_RegExpTypes_h
+
+#include "js/UniquePtr.h"
+
+namespace js {
+class MatchPairs;
+}
+
+namespace v8 {
+namespace internal {
+
+class ByteArrayData {
+ public:
+  uint32_t length;
+  uint8_t* data();
+};
+class Isolate;
+class RegExpStack;
+class RegExpStackScope;
+
+struct InputOutputData {
+  const void* inputStart;
+  const void* inputEnd;
+
+  // Index into inputStart (in chars) at which to begin matching.
+  size_t startIndex;
+
+  js::MatchPairs* matches;
+
+  template <typename CharT>
+  InputOutputData(const CharT* inputStart, const CharT* inputEnd,
+                  size_t startIndex, js::MatchPairs* matches)
+      : inputStart(inputStart),
+        inputEnd(inputEnd),
+        startIndex(startIndex),
+        matches(matches) {}
+};
+
+}  // namespace internal
+}  // namespace v8
+
+namespace js {
+namespace irregexp {
+
+using Isolate = v8::internal::Isolate;
+using RegExpStack = v8::internal::RegExpStack;
+using RegExpStackScope = v8::internal::RegExpStackScope;
+using ByteArrayData = v8::internal::ByteArrayData;
+using ByteArray = js::UniquePtr<v8::internal::ByteArrayData, JS::FreePolicy>;
+using InputOutputData = v8::internal::InputOutputData;
+
+}  // namespace irregexp
+}  // namespace js
+
+#endif  // regexp_RegExpTypes_h
diff -Nrup mozilla/js/src/irregexp/import-irregexp.py mozilla-OK/js/src/irregexp/import-irregexp.py
--- mozilla/js/src/irregexp/import-irregexp.py	1970-01-01 03:00:00.000000000 +0300
+++ mozilla-OK/js/src/irregexp/import-irregexp.py	2022-04-22 05:08:42.158101875 +0300
@@ -0,0 +1,148 @@
+#!/usr/bin/env python3
+
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this file,
+# You can obtain one at http://mozilla.org/MPL/2.0/.
+
+# This script handles all the mechanical steps of importing irregexp from v8:
+#
+# 1. Acquire the source: either from github, or optionally from a local copy of v8.
+# 2. Copy the contents of v8/src/regexp into js/src/irregexp/imported
+#    - Exclude files that we have chosen not to import.
+# 3. While doing so, update #includes:
+#    - Change "src/regexp/*" to "irregexp/imported/*".
+#    - Remove other v8-specific headers completely.
+# 4. Add '#include "irregexp/RegExpShim.h" in the necessary places.
+# 5. Update the IRREGEXP_VERSION file to include the correct git hash.
+#
+# Usage:
+#  cd path/to/js/src/irregexp
+#  ./import-irregexp.py --path path/to/v8/src/regexp
+#
+# Alternatively, without the --path argument, import-irregexp.py will
+# clone v8 from github into a temporary directory.
+#
+# After running this script, changes to the shim code may be necessary
+# to account for changes in upstream irregexp.
+
+import os
+import re
+import subprocess
+import sys
+from pathlib import Path
+
+
+def get_hash(path):
+    # Get the hash for the current git revision
+    cwd = os.getcwd()
+    os.chdir(path)
+    command = ["git", "rev-parse", "HEAD"]
+    result = subprocess.check_output(command, encoding="utf-8")
+    os.chdir(cwd)
+    return result.rstrip()
+
+
+def copy_and_update_includes(src_path, dst_path):
+    # List of header files that need to include the shim header
+    need_shim = [
+        "property-sequences.h",
+        "regexp-ast.h",
+        "regexp-bytecode-peephole.h",
+        "regexp-bytecodes.h",
+        "regexp-dotprinter.h",
+        "regexp-error.h",
+        "regexp.h",
+        "regexp-macro-assembler.h",
+        "regexp-stack.h",
+        "special-case.h",
+    ]
+
+    src = open(str(src_path), "r")
+    dst = open(str(dst_path), "w")
+
+    # 1. Rewrite includes of V8 regexp headers:
+    regexp_include = re.compile('#include "src/regexp')
+    regexp_include_new = '#include "irregexp/imported'
+
+    # 2. Remove includes of other V8 headers
+    other_include = re.compile('#include "src/')
+
+    # 3. If needed, add '#include "irregexp/RegExpShim.h"'.
+    #    Note: We get a little fancy to ensure that header files are
+    #    in alphabetic order. `need_to_add_shim` is true if we still
+    #    have to add the shim header in this file. `adding_shim_now`
+    #    is true if we have found a '#include "src/*' and we are just
+    #    waiting to find an empty line so that we can insert the shim
+    #    header in the right place.
+    need_to_add_shim = src_path.name in need_shim
+    adding_shim_now = False
+
+    for line in src:
+        if adding_shim_now:
+            if line == "\n":
+                dst.write('#include "irregexp/RegExpShim.h"\n')
+                need_to_add_shim = False
+                adding_shim_now = False
+
+        if regexp_include.search(line):
+            dst.write(re.sub(regexp_include, regexp_include_new, line))
+        elif other_include.search(line):
+            if need_to_add_shim:
+                adding_shim_now = True
+        else:
+            dst.write(line)
+
+
+def import_from(srcdir, dstdir):
+    excluded = [
+        "DIR_METADATA",
+        "OWNERS",
+        "regexp.cc",
+        "regexp-utils.cc",
+        "regexp-utils.h",
+        "regexp-macro-assembler-arch.h",
+    ]
+
+    for file in srcdir.iterdir():
+        if file.is_dir():
+            continue
+        if str(file.name) in excluded:
+            continue
+        copy_and_update_includes(file, dstdir / "imported" / file.name)
+
+    # Update IRREGEXP_VERSION file
+    hash = get_hash(srcdir)
+    version_file = open(str(dstdir / "IRREGEXP_VERSION"), "w")
+    version_file.write("Imported using import-irregexp.py from:\n")
+    version_file.write("https://github.com/v8/v8/tree/%s/src/regexp\n" % hash)
+
+
+if __name__ == "__main__":
+    import argparse
+    import tempfile
+
+    # This script should be run from js/src/irregexp to work correctly.
+    current_path = Path(os.getcwd())
+    expected_path = "js/src/irregexp"
+    if not current_path.match(expected_path):
+        raise RuntimeError("%s must be run from %s" % (sys.argv[0], expected_path))
+
+    parser = argparse.ArgumentParser(description="Import irregexp from v8")
+    parser.add_argument("-p", "--path", help="path to v8/src/regexp")
+    args = parser.parse_args()
+
+    if args.path:
+        src_path = Path(args.path)
+
+        if not (src_path / "regexp.h").exists():
+            print("Usage:\n  import-irregexp.py --path <path/to/v8/src/regexp>")
+            sys.exit(1)
+        import_from(src_path, current_path)
+        sys.exit(0)
+
+    with tempfile.TemporaryDirectory() as tempdir:
+        v8_git = "https://github.com/v8/v8.git"
+        clone = "git clone --depth 1 %s %s" % (v8_git, tempdir)
+        os.system(clone)
+        src_path = Path(tempdir) / "src/regexp"
+        import_from(src_path, current_path)
diff -Nrup mozilla/js/src/irregexp/moz.build mozilla-OK/js/src/irregexp/moz.build
--- mozilla/js/src/irregexp/moz.build	1970-01-01 03:00:00.000000000 +0300
+++ mozilla-OK/js/src/irregexp/moz.build	2022-04-22 05:08:42.175101756 +0300
@@ -0,0 +1,45 @@
+# -*- Mode: python; indent-tabs-mode: nil; tab-width: 40 -*-
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+include('../js-config.mozbuild')
+include('../js-cxxflags.mozbuild')
+
+FINAL_LIBRARY = "js"
+
+# Includes should be relative to parent path
+LOCAL_INCLUDES += ["!..", ".."]
+
+CXXFLAGS += ["-Wno-error=type-limits"]
+
+SOURCES += [
+    'imported/regexp-ast.cc',
+    'imported/regexp-bytecode-generator.cc',
+    'imported/regexp-bytecode-peephole.cc',
+    'imported/regexp-bytecodes.cc',
+    'imported/regexp-compiler-tonode.cc',
+    'imported/regexp-compiler.cc',
+    'imported/regexp-dotprinter.cc',
+    'imported/regexp-interpreter.cc',
+    'imported/regexp-macro-assembler-tracer.cc',
+    'imported/regexp-macro-assembler.cc',
+    'imported/regexp-parser.cc',
+    'imported/regexp-stack.cc',
+    'RegExpAPI.cpp',
+    'RegExpNativeMacroAssembler.cpp',
+    'RegExpShim.cpp',
+    'util/UnicodeShim.cpp'
+]
+
+if CONFIG['ENABLE_INTL_API']:
+    CXXFLAGS += ['-DV8_INTL_SUPPORT']
+    SOURCES += [
+        'imported/property-sequences.cc',
+        'imported/special-case.cc'
+    ]
+
+if CONFIG['_MSC_VER']:
+    # This is intended as a temporary workaround to unblock compilation
+    # on VS2015 in warnings as errors mode.
+    CXXFLAGS += ['-wd4275']
\ No newline at end of file
diff -Nrup mozilla/js/src/irregexp/util/FlagsShim.h mozilla-OK/js/src/irregexp/util/FlagsShim.h
--- mozilla/js/src/irregexp/util/FlagsShim.h	1970-01-01 03:00:00.000000000 +0300
+++ mozilla-OK/js/src/irregexp/util/FlagsShim.h	2022-04-22 05:08:42.175101756 +0300
@@ -0,0 +1,87 @@
+// Copyright 2014 the V8 project authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef V8_UTIL_FLAGS_H_
+#define V8_UTIL_FLAGS_H_
+
+// Origin:
+// https://github.com/v8/v8/blob/1bafcc6b999b23ea1d394f5d267a08183e3c4e19/src/base/flags.h#L15-L90
+
+namespace v8 {
+namespace base {
+
+// The Flags class provides a type-safe way of storing OR-combinations of enum
+// values. The Flags<T, S> class is a template class, where T is an enum type,
+// and S is the underlying storage type (usually int).
+//
+// The traditional C++ approach for storing OR-combinations of enum values is to
+// use an int or unsigned int variable. The inconvenience with this approach is
+// that there's no type checking at all; any enum value can be OR'd with any
+// other enum value and passed on to a function that takes an int or unsigned
+// int.
+template <typename T, typename S = int>
+class Flags final {
+ public:
+  using flag_type = T;
+  using mask_type = S;
+
+  Flags() : mask_(0) {}
+  Flags(flag_type flag) : mask_(static_cast<S>(flag)) {}
+  Flags(mask_type mask) : mask_(static_cast<S>(mask)) {}
+
+  bool operator==(flag_type flag) const {
+    return mask_ == static_cast<S>(flag);
+  }
+  bool operator!=(flag_type flag) const {
+    return mask_ != static_cast<S>(flag);
+  }
+
+  Flags& operator&=(const Flags& flags) {
+    mask_ &= flags.mask_;
+    return *this;
+  }
+  Flags& operator|=(const Flags& flags) {
+    mask_ |= flags.mask_;
+    return *this;
+  }
+  Flags& operator^=(const Flags& flags) {
+    mask_ ^= flags.mask_;
+    return *this;
+  }
+
+  Flags operator&(const Flags& flags) const {
+    return Flags(mask_ & flags.mask_);
+  }
+  Flags operator|(const Flags& flags) const {
+    return Flags(mask_ | flags.mask_);
+  }
+  Flags operator^(const Flags& flags) const {
+    return Flags(mask_ ^ flags.mask_);
+  }
+
+  Flags& operator&=(flag_type flag) { return operator&=(Flags(flag)); }
+  Flags& operator|=(flag_type flag) { return operator|=(Flags(flag)); }
+  Flags& operator^=(flag_type flag) { return operator^=(Flags(flag)); }
+
+  Flags operator&(flag_type flag) const { return operator&(Flags(flag)); }
+  Flags operator|(flag_type flag) const { return operator|(Flags(flag)); }
+  Flags operator^(flag_type flag) const { return operator^(Flags(flag)); }
+
+  Flags operator~() const { return Flags(~mask_); }
+
+  operator mask_type() const { return mask_; }
+  bool operator!() const { return !mask_; }
+
+  Flags without(flag_type flag) { return *this & (~Flags(flag)); }
+
+  friend size_t hash_value(const Flags& flags) { return flags.mask_; }
+
+ private:
+  mask_type mask_;
+};
+
+}  // namespace base
+}  // namespace v8
+
+#endif  // V8_UTIL_FLAG_H_
diff -Nrup mozilla/js/src/irregexp/util/UnicodeShim.cpp mozilla-OK/js/src/irregexp/util/UnicodeShim.cpp
--- mozilla/js/src/irregexp/util/UnicodeShim.cpp	1970-01-01 03:00:00.000000000 +0300
+++ mozilla-OK/js/src/irregexp/util/UnicodeShim.cpp	2022-04-22 05:08:42.177101742 +0300
@@ -0,0 +1,1866 @@
+// Copyright 2012 the V8 project authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+//
+// This file is a subset of:
+//  https://github.com/v8/v8/blob/master/src/strings/unicode.cc
+
+#include "irregexp/RegExpShim.h"
+
+#ifdef V8_INTL_SUPPORT
+#  include "unicode/uchar.h"
+#endif
+
+namespace v8 {
+namespace unibrow {
+
+#ifndef V8_INTL_SUPPORT
+static const int kStartBit = (1 << 30);
+static const int kChunkBits = (1 << 13);
+#endif  // !V8_INTL_SUPPORT
+
+static const uchar kSentinel = static_cast<uchar>(-1);
+
+/**
+ * \file
+ * Implementations of functions for working with Unicode.
+ */
+
+using int16_t = signed short;     // NOLINT
+using uint16_t = unsigned short;  // NOLINT
+using int32_t = int;              // NOLINT
+
+#ifndef V8_INTL_SUPPORT
+// All access to the character table should go through this function.
+template <int D>
+static inline uchar TableGet(const int32_t* table, int index) {
+  return table[D * index];
+}
+
+static inline uchar GetEntry(int32_t entry) { return entry & (kStartBit - 1); }
+
+static inline bool IsStart(int32_t entry) { return (entry & kStartBit) != 0; }
+
+/**
+ * Look up a character in the Unicode table using a mix of binary and
+ * interpolation search.  For a uniformly distributed array
+ * interpolation search beats binary search by a wide margin.  However,
+ * in this case interpolation search degenerates because of some very
+ * high values in the lower end of the table so this function uses a
+ * combination.  The average number of steps to look up the information
+ * about a character is around 10, slightly higher if there is no
+ * information available about the character.
+ */
+static bool LookupPredicate(const int32_t* table, uint16_t size, uchar chr) {
+  static const int kEntryDist = 1;
+  uint16_t value = chr & (kChunkBits - 1);
+  unsigned int low = 0;
+  unsigned int high = size - 1;
+  while (high != low) {
+    unsigned int mid = low + ((high - low) >> 1);
+    uchar current_value = GetEntry(TableGet<kEntryDist>(table, mid));
+    // If we've found an entry less than or equal to this one, and the
+    // next one is not also less than this one, we've arrived.
+    if ((current_value <= value) &&
+        (mid + 1 == size ||
+         GetEntry(TableGet<kEntryDist>(table, mid + 1)) > value)) {
+      low = mid;
+      break;
+    } else if (current_value < value) {
+      low = mid + 1;
+    } else if (current_value > value) {
+      // If we've just checked the bottom-most value and it's not
+      // the one we're looking for, we're done.
+      if (mid == 0) break;
+      high = mid - 1;
+    }
+  }
+  int32_t field = TableGet<kEntryDist>(table, low);
+  uchar entry = GetEntry(field);
+  bool is_start = IsStart(field);
+  return (entry == value) || (entry < value && is_start);
+}
+#endif  // !V8_INTL_SUPPORT
+
+template <int kW>
+struct MultiCharacterSpecialCase {
+  static const uchar kEndOfEncoding = kSentinel;
+  uchar chars[kW];
+};
+
+#ifndef V8_INTL_SUPPORT
+// Look up the mapping for the given character in the specified table,
+// which is of the specified length and uses the specified special case
+// mapping for multi-char mappings.  The next parameter is the character
+// following the one to map.  The result will be written in to the result
+// buffer and the number of characters written will be returned.  Finally,
+// if the allow_caching_ptr is non-null then false will be stored in
+// it if the result contains multiple characters or depends on the
+// context.
+// If ranges are linear, a match between a start and end point is
+// offset by the distance between the match and the start. Otherwise
+// the result is the same as for the start point on the entire range.
+template <bool ranges_are_linear, int kW>
+static int LookupMapping(const int32_t* table, uint16_t size,
+                         const MultiCharacterSpecialCase<kW>* multi_chars,
+                         uchar chr, uchar next, uchar* result,
+                         bool* allow_caching_ptr) {
+  static const int kEntryDist = 2;
+  uint16_t key = chr & (kChunkBits - 1);
+  uint16_t chunk_start = chr - key;
+  unsigned int low = 0;
+  unsigned int high = size - 1;
+  while (high != low) {
+    unsigned int mid = low + ((high - low) >> 1);
+    uchar current_value = GetEntry(TableGet<kEntryDist>(table, mid));
+    // If we've found an entry less than or equal to this one, and the next one
+    // is not also less than this one, we've arrived.
+    if ((current_value <= key) &&
+        (mid + 1 == size ||
+         GetEntry(TableGet<kEntryDist>(table, mid + 1)) > key)) {
+      low = mid;
+      break;
+    } else if (current_value < key) {
+      low = mid + 1;
+    } else if (current_value > key) {
+      // If we've just checked the bottom-most value and it's not
+      // the one we're looking for, we're done.
+      if (mid == 0) break;
+      high = mid - 1;
+    }
+  }
+  int32_t field = TableGet<kEntryDist>(table, low);
+  uchar entry = GetEntry(field);
+  bool is_start = IsStart(field);
+  bool found = (entry == key) || (entry < key && is_start);
+  if (found) {
+    int32_t value = table[2 * low + 1];
+    if (value == 0) {
+      // 0 means not present
+      return 0;
+    } else if ((value & 3) == 0) {
+      // Low bits 0 means a constant offset from the given character.
+      if (ranges_are_linear) {
+        result[0] = chr + (value >> 2);
+      } else {
+        result[0] = entry + chunk_start + (value >> 2);
+      }
+      return 1;
+    } else if ((value & 3) == 1) {
+      // Low bits 1 means a special case mapping
+      if (allow_caching_ptr) *allow_caching_ptr = false;
+      const MultiCharacterSpecialCase<kW>& mapping = multi_chars[value >> 2];
+      int length = 0;
+      for (length = 0; length < kW; length++) {
+        uchar mapped = mapping.chars[length];
+        if (mapped == MultiCharacterSpecialCase<kW>::kEndOfEncoding) break;
+        if (ranges_are_linear) {
+          result[length] = mapped + (key - entry);
+        } else {
+          result[length] = mapped;
+        }
+      }
+      return length;
+    } else {
+      // Low bits 2 means a really really special case
+      if (allow_caching_ptr) *allow_caching_ptr = false;
+      // The cases of this switch are defined in unicode.py in the
+      // really_special_cases mapping.
+      switch (value >> 2) {
+        case 1:
+          // Really special case 1: upper case sigma.  This letter
+          // converts to two different lower case sigmas depending on
+          // whether or not it occurs at the end of a word.
+          if (next != 0 && Letter::Is(next)) {
+            result[0] = 0x03C3;
+          } else {
+            result[0] = 0x03C2;
+          }
+          return 1;
+        default:
+          return 0;
+      }
+      return -1;
+    }
+  } else {
+    return 0;
+  }
+}
+#endif  // !V8_INTL_SUPPORT
+
+// Letter:               point.category in ['Lu', 'Ll', 'Lt', 'Lm', 'Lo', 'Nl']
+#ifdef V8_INTL_SUPPORT
+bool Letter::Is(uchar c) { return static_cast<bool>(u_isalpha(c)); }
+#else
+static const uint16_t kLetterTable0Size = 431;
+static const int32_t kLetterTable0[431] = {
+    1073741889, 90,         1073741921, 122,
+    170,        181,        186,        1073742016,  // NOLINT
+    214,        1073742040, 246,        1073742072,
+    705,        1073742534, 721,        1073742560,  // NOLINT
+    740,        748,        750,        1073742704,
+    884,        1073742710, 887,        1073742714,  // NOLINT
+    893,        895,        902,        1073742728,
+    906,        908,        1073742734, 929,  // NOLINT
+    1073742755, 1013,       1073742839, 1153,
+    1073742986, 1327,       1073743153, 1366,  // NOLINT
+    1369,       1073743201, 1415,       1073743312,
+    1514,       1073743344, 1522,       1073743392,  // NOLINT
+    1610,       1073743470, 1647,       1073743473,
+    1747,       1749,       1073743589, 1766,  // NOLINT
+    1073743598, 1775,       1073743610, 1788,
+    1791,       1808,       1073743634, 1839,  // NOLINT
+    1073743693, 1957,       1969,       1073743818,
+    2026,       1073743860, 2037,       2042,  // NOLINT
+    1073743872, 2069,       2074,       2084,
+    2088,       1073743936, 2136,       1073744032,  // NOLINT
+    2226,       1073744132, 2361,       2365,
+    2384,       1073744216, 2401,       1073744241,  // NOLINT
+    2432,       1073744261, 2444,       1073744271,
+    2448,       1073744275, 2472,       1073744298,  // NOLINT
+    2480,       2482,       1073744310, 2489,
+    2493,       2510,       1073744348, 2525,  // NOLINT
+    1073744351, 2529,       1073744368, 2545,
+    1073744389, 2570,       1073744399, 2576,  // NOLINT
+    1073744403, 2600,       1073744426, 2608,
+    1073744434, 2611,       1073744437, 2614,  // NOLINT
+    1073744440, 2617,       1073744473, 2652,
+    2654,       1073744498, 2676,       1073744517,  // NOLINT
+    2701,       1073744527, 2705,       1073744531,
+    2728,       1073744554, 2736,       1073744562,  // NOLINT
+    2739,       1073744565, 2745,       2749,
+    2768,       1073744608, 2785,       1073744645,  // NOLINT
+    2828,       1073744655, 2832,       1073744659,
+    2856,       1073744682, 2864,       1073744690,  // NOLINT
+    2867,       1073744693, 2873,       2877,
+    1073744732, 2909,       1073744735, 2913,  // NOLINT
+    2929,       2947,       1073744773, 2954,
+    1073744782, 2960,       1073744786, 2965,  // NOLINT
+    1073744793, 2970,       2972,       1073744798,
+    2975,       1073744803, 2980,       1073744808,  // NOLINT
+    2986,       1073744814, 3001,       3024,
+    1073744901, 3084,       1073744910, 3088,  // NOLINT
+    1073744914, 3112,       1073744938, 3129,
+    3133,       1073744984, 3161,       1073744992,  // NOLINT
+    3169,       1073745029, 3212,       1073745038,
+    3216,       1073745042, 3240,       1073745066,  // NOLINT
+    3251,       1073745077, 3257,       3261,
+    3294,       1073745120, 3297,       1073745137,  // NOLINT
+    3314,       1073745157, 3340,       1073745166,
+    3344,       1073745170, 3386,       3389,  // NOLINT
+    3406,       1073745248, 3425,       1073745274,
+    3455,       1073745285, 3478,       1073745306,  // NOLINT
+    3505,       1073745331, 3515,       3517,
+    1073745344, 3526,       1073745409, 3632,  // NOLINT
+    1073745458, 3635,       1073745472, 3654,
+    1073745537, 3714,       3716,       1073745543,  // NOLINT
+    3720,       3722,       3725,       1073745556,
+    3735,       1073745561, 3743,       1073745569,  // NOLINT
+    3747,       3749,       3751,       1073745578,
+    3755,       1073745581, 3760,       1073745586,  // NOLINT
+    3763,       3773,       1073745600, 3780,
+    3782,       1073745628, 3807,       3840,  // NOLINT
+    1073745728, 3911,       1073745737, 3948,
+    1073745800, 3980,       1073745920, 4138,  // NOLINT
+    4159,       1073746000, 4181,       1073746010,
+    4189,       4193,       1073746021, 4198,  // NOLINT
+    1073746030, 4208,       1073746037, 4225,
+    4238,       1073746080, 4293,       4295,  // NOLINT
+    4301,       1073746128, 4346,       1073746172,
+    4680,       1073746506, 4685,       1073746512,  // NOLINT
+    4694,       4696,       1073746522, 4701,
+    1073746528, 4744,       1073746570, 4749,  // NOLINT
+    1073746576, 4784,       1073746610, 4789,
+    1073746616, 4798,       4800,       1073746626,  // NOLINT
+    4805,       1073746632, 4822,       1073746648,
+    4880,       1073746706, 4885,       1073746712,  // NOLINT
+    4954,       1073746816, 5007,       1073746848,
+    5108,       1073746945, 5740,       1073747567,  // NOLINT
+    5759,       1073747585, 5786,       1073747616,
+    5866,       1073747694, 5880,       1073747712,  // NOLINT
+    5900,       1073747726, 5905,       1073747744,
+    5937,       1073747776, 5969,       1073747808,  // NOLINT
+    5996,       1073747822, 6000,       1073747840,
+    6067,       6103,       6108,       1073748000,  // NOLINT
+    6263,       1073748096, 6312,       6314,
+    1073748144, 6389,       1073748224, 6430,  // NOLINT
+    1073748304, 6509,       1073748336, 6516,
+    1073748352, 6571,       1073748417, 6599,  // NOLINT
+    1073748480, 6678,       1073748512, 6740,
+    6823,       1073748741, 6963,       1073748805,  // NOLINT
+    6987,       1073748867, 7072,       1073748910,
+    7087,       1073748922, 7141,       1073748992,  // NOLINT
+    7203,       1073749069, 7247,       1073749082,
+    7293,       1073749225, 7404,       1073749230,  // NOLINT
+    7409,       1073749237, 7414,       1073749248,
+    7615,       1073749504, 7957,       1073749784,  // NOLINT
+    7965,       1073749792, 8005,       1073749832,
+    8013,       1073749840, 8023,       8025,  // NOLINT
+    8027,       8029,       1073749855, 8061,
+    1073749888, 8116,       1073749942, 8124,  // NOLINT
+    8126,       1073749954, 8132,       1073749958,
+    8140,       1073749968, 8147,       1073749974,  // NOLINT
+    8155,       1073749984, 8172,       1073750002,
+    8180,       1073750006, 8188};  // NOLINT
+static const uint16_t kLetterTable1Size = 87;
+static const int32_t kLetterTable1[87] = {
+    113,        127,        1073741968, 156,
+    258,        263,        1073742090, 275,  // NOLINT
+    277,        1073742105, 285,        292,
+    294,        296,        1073742122, 301,  // NOLINT
+    1073742127, 313,        1073742140, 319,
+    1073742149, 329,        334,        1073742176,  // NOLINT
+    392,        1073744896, 3118,       1073744944,
+    3166,       1073744992, 3300,       1073745131,  // NOLINT
+    3310,       1073745138, 3315,       1073745152,
+    3365,       3367,       3373,       1073745200,  // NOLINT
+    3431,       3439,       1073745280, 3478,
+    1073745312, 3494,       1073745320, 3502,  // NOLINT
+    1073745328, 3510,       1073745336, 3518,
+    1073745344, 3526,       1073745352, 3534,  // NOLINT
+    1073745360, 3542,       1073745368, 3550,
+    3631,       1073745925, 4103,       1073745953,  // NOLINT
+    4137,       1073745969, 4149,       1073745976,
+    4156,       1073745985, 4246,       1073746077,  // NOLINT
+    4255,       1073746081, 4346,       1073746172,
+    4351,       1073746181, 4397,       1073746225,  // NOLINT
+    4494,       1073746336, 4538,       1073746416,
+    4607,       1073746944, 8191};  // NOLINT
+static const uint16_t kLetterTable2Size = 4;
+static const int32_t kLetterTable2[4] = {1073741824, 3509, 1073745408,
+                                         8191};  // NOLINT
+static const uint16_t kLetterTable3Size = 2;
+static const int32_t kLetterTable3[2] = {1073741824, 8191};  // NOLINT
+static const uint16_t kLetterTable4Size = 2;
+static const int32_t kLetterTable4[2] = {1073741824, 8140};  // NOLINT
+static const uint16_t kLetterTable5Size = 100;
+static const int32_t kLetterTable5[100] = {
+    1073741824, 1164,       1073743056, 1277,
+    1073743104, 1548,       1073743376, 1567,  // NOLINT
+    1073743402, 1579,       1073743424, 1646,
+    1073743487, 1693,       1073743520, 1775,  // NOLINT
+    1073743639, 1823,       1073743650, 1928,
+    1073743755, 1934,       1073743760, 1965,  // NOLINT
+    1073743792, 1969,       1073743863, 2049,
+    1073743875, 2053,       1073743879, 2058,  // NOLINT
+    1073743884, 2082,       1073743936, 2163,
+    1073744002, 2227,       1073744114, 2295,  // NOLINT
+    2299,       1073744138, 2341,       1073744176,
+    2374,       1073744224, 2428,       1073744260,  // NOLINT
+    2482,       2511,       1073744352, 2532,
+    1073744358, 2543,       1073744378, 2558,  // NOLINT
+    1073744384, 2600,       1073744448, 2626,
+    1073744452, 2635,       1073744480, 2678,  // NOLINT
+    2682,       1073744510, 2735,       2737,
+    1073744565, 2742,       1073744569, 2749,  // NOLINT
+    2752,       2754,       1073744603, 2781,
+    1073744608, 2794,       1073744626, 2804,  // NOLINT
+    1073744641, 2822,       1073744649, 2830,
+    1073744657, 2838,       1073744672, 2854,  // NOLINT
+    1073744680, 2862,       1073744688, 2906,
+    1073744732, 2911,       1073744740, 2917,   // NOLINT
+    1073744832, 3042,       1073744896, 8191};  // NOLINT
+static const uint16_t kLetterTable6Size = 6;
+static const int32_t kLetterTable6[6] = {1073741824, 6051, 1073747888, 6086,
+                                         1073747915, 6139};  // NOLINT
+static const uint16_t kLetterTable7Size = 48;
+static const int32_t kLetterTable7[48] = {
+    1073748224, 6765,       1073748592, 6873,
+    1073748736, 6918,       1073748755, 6935,  // NOLINT
+    6941,       1073748767, 6952,       1073748778,
+    6966,       1073748792, 6972,       6974,  // NOLINT
+    1073748800, 6977,       1073748803, 6980,
+    1073748806, 7089,       1073748947, 7485,  // NOLINT
+    1073749328, 7567,       1073749394, 7623,
+    1073749488, 7675,       1073749616, 7796,  // NOLINT
+    1073749622, 7932,       1073749793, 7994,
+    1073749825, 8026,       1073749862, 8126,  // NOLINT
+    1073749954, 8135,       1073749962, 8143,
+    1073749970, 8151,       1073749978, 8156};  // NOLINT
+bool Letter::Is(uchar c) {
+  int chunk_index = c >> 13;
+  switch (chunk_index) {
+    case 0:
+      return LookupPredicate(kLetterTable0, kLetterTable0Size, c);
+    case 1:
+      return LookupPredicate(kLetterTable1, kLetterTable1Size, c);
+    case 2:
+      return LookupPredicate(kLetterTable2, kLetterTable2Size, c);
+    case 3:
+      return LookupPredicate(kLetterTable3, kLetterTable3Size, c);
+    case 4:
+      return LookupPredicate(kLetterTable4, kLetterTable4Size, c);
+    case 5:
+      return LookupPredicate(kLetterTable5, kLetterTable5Size, c);
+    case 6:
+      return LookupPredicate(kLetterTable6, kLetterTable6Size, c);
+    case 7:
+      return LookupPredicate(kLetterTable7, kLetterTable7Size, c);
+    default:
+      return false;
+  }
+}
+#endif
+
+#ifndef V8_INTL_SUPPORT
+
+static const MultiCharacterSpecialCase<1> kEcma262CanonicalizeMultiStrings0[1] =
+    {                                                        // NOLINT
+        {{kSentinel}}};                                      // NOLINT
+static const uint16_t kEcma262CanonicalizeTable0Size = 498;  // NOLINT
+static const int32_t kEcma262CanonicalizeTable0[996] = {
+    1073741921, -128,   122,        -128,   181,        2972,
+    1073742048, -128,   246,        -128,   1073742072, -128,
+    254,        -128,   255,        484,  // NOLINT
+    257,        -4,     259,        -4,     261,        -4,
+    263,        -4,     265,        -4,     267,        -4,
+    269,        -4,     271,        -4,  // NOLINT
+    273,        -4,     275,        -4,     277,        -4,
+    279,        -4,     281,        -4,     283,        -4,
+    285,        -4,     287,        -4,  // NOLINT
+    289,        -4,     291,        -4,     293,        -4,
+    295,        -4,     297,        -4,     299,        -4,
+    301,        -4,     303,        -4,  // NOLINT
+    307,        -4,     309,        -4,     311,        -4,
+    314,        -4,     316,        -4,     318,        -4,
+    320,        -4,     322,        -4,  // NOLINT
+    324,        -4,     326,        -4,     328,        -4,
+    331,        -4,     333,        -4,     335,        -4,
+    337,        -4,     339,        -4,  // NOLINT
+    341,        -4,     343,        -4,     345,        -4,
+    347,        -4,     349,        -4,     351,        -4,
+    353,        -4,     355,        -4,  // NOLINT
+    357,        -4,     359,        -4,     361,        -4,
+    363,        -4,     365,        -4,     367,        -4,
+    369,        -4,     371,        -4,  // NOLINT
+    373,        -4,     375,        -4,     378,        -4,
+    380,        -4,     382,        -4,     384,        780,
+    387,        -4,     389,        -4,  // NOLINT
+    392,        -4,     396,        -4,     402,        -4,
+    405,        388,    409,        -4,     410,        652,
+    414,        520,    417,        -4,  // NOLINT
+    419,        -4,     421,        -4,     424,        -4,
+    429,        -4,     432,        -4,     436,        -4,
+    438,        -4,     441,        -4,  // NOLINT
+    445,        -4,     447,        224,    453,        -4,
+    454,        -8,     456,        -4,     457,        -8,
+    459,        -4,     460,        -8,  // NOLINT
+    462,        -4,     464,        -4,     466,        -4,
+    468,        -4,     470,        -4,     472,        -4,
+    474,        -4,     476,        -4,  // NOLINT
+    477,        -316,   479,        -4,     481,        -4,
+    483,        -4,     485,        -4,     487,        -4,
+    489,        -4,     491,        -4,  // NOLINT
+    493,        -4,     495,        -4,     498,        -4,
+    499,        -8,     501,        -4,     505,        -4,
+    507,        -4,     509,        -4,  // NOLINT
+    511,        -4,     513,        -4,     515,        -4,
+    517,        -4,     519,        -4,     521,        -4,
+    523,        -4,     525,        -4,  // NOLINT
+    527,        -4,     529,        -4,     531,        -4,
+    533,        -4,     535,        -4,     537,        -4,
+    539,        -4,     541,        -4,  // NOLINT
+    543,        -4,     547,        -4,     549,        -4,
+    551,        -4,     553,        -4,     555,        -4,
+    557,        -4,     559,        -4,  // NOLINT
+    561,        -4,     563,        -4,     572,        -4,
+    1073742399, 43260,  576,        43260,  578,        -4,
+    583,        -4,     585,        -4,  // NOLINT
+    587,        -4,     589,        -4,     591,        -4,
+    592,        43132,  593,        43120,  594,        43128,
+    595,        -840,   596,        -824,  // NOLINT
+    1073742422, -820,   599,        -820,   601,        -808,
+    603,        -812,   604,        169276, 608,        -820,
+    609,        169260, 611,        -828,  // NOLINT
+    613,        169120, 614,        169232, 616,        -836,
+    617,        -844,   619,        42972,  620,        169220,
+    623,        -844,   625,        42996,  // NOLINT
+    626,        -852,   629,        -856,   637,        42908,
+    640,        -872,   643,        -872,   647,        169128,
+    648,        -872,   649,        -276,  // NOLINT
+    1073742474, -868,   651,        -868,   652,        -284,
+    658,        -876,   670,        169032, 837,        336,
+    881,        -4,     883,        -4,  // NOLINT
+    887,        -4,     1073742715, 520,    893,        520,
+    940,        -152,   1073742765, -148,   943,        -148,
+    1073742769, -128,   961,        -128,  // NOLINT
+    962,        -124,   1073742787, -128,   971,        -128,
+    972,        -256,   1073742797, -252,   974,        -252,
+    976,        -248,   977,        -228,  // NOLINT
+    981,        -188,   982,        -216,   983,        -32,
+    985,        -4,     987,        -4,     989,        -4,
+    991,        -4,     993,        -4,  // NOLINT
+    995,        -4,     997,        -4,     999,        -4,
+    1001,       -4,     1003,       -4,     1005,       -4,
+    1007,       -4,     1008,       -344,  // NOLINT
+    1009,       -320,   1010,       28,     1011,       -464,
+    1013,       -384,   1016,       -4,     1019,       -4,
+    1073742896, -128,   1103,       -128,  // NOLINT
+    1073742928, -320,   1119,       -320,   1121,       -4,
+    1123,       -4,     1125,       -4,     1127,       -4,
+    1129,       -4,     1131,       -4,  // NOLINT
+    1133,       -4,     1135,       -4,     1137,       -4,
+    1139,       -4,     1141,       -4,     1143,       -4,
+    1145,       -4,     1147,       -4,  // NOLINT
+    1149,       -4,     1151,       -4,     1153,       -4,
+    1163,       -4,     1165,       -4,     1167,       -4,
+    1169,       -4,     1171,       -4,  // NOLINT
+    1173,       -4,     1175,       -4,     1177,       -4,
+    1179,       -4,     1181,       -4,     1183,       -4,
+    1185,       -4,     1187,       -4,  // NOLINT
+    1189,       -4,     1191,       -4,     1193,       -4,
+    1195,       -4,     1197,       -4,     1199,       -4,
+    1201,       -4,     1203,       -4,  // NOLINT
+    1205,       -4,     1207,       -4,     1209,       -4,
+    1211,       -4,     1213,       -4,     1215,       -4,
+    1218,       -4,     1220,       -4,  // NOLINT
+    1222,       -4,     1224,       -4,     1226,       -4,
+    1228,       -4,     1230,       -4,     1231,       -60,
+    1233,       -4,     1235,       -4,  // NOLINT
+    1237,       -4,     1239,       -4,     1241,       -4,
+    1243,       -4,     1245,       -4,     1247,       -4,
+    1249,       -4,     1251,       -4,  // NOLINT
+    1253,       -4,     1255,       -4,     1257,       -4,
+    1259,       -4,     1261,       -4,     1263,       -4,
+    1265,       -4,     1267,       -4,  // NOLINT
+    1269,       -4,     1271,       -4,     1273,       -4,
+    1275,       -4,     1277,       -4,     1279,       -4,
+    1281,       -4,     1283,       -4,  // NOLINT
+    1285,       -4,     1287,       -4,     1289,       -4,
+    1291,       -4,     1293,       -4,     1295,       -4,
+    1297,       -4,     1299,       -4,  // NOLINT
+    1301,       -4,     1303,       -4,     1305,       -4,
+    1307,       -4,     1309,       -4,     1311,       -4,
+    1313,       -4,     1315,       -4,  // NOLINT
+    1317,       -4,     1319,       -4,     1321,       -4,
+    1323,       -4,     1325,       -4,     1327,       -4,
+    1073743201, -192,   1414,       -192,  // NOLINT
+    7545,       141328, 7549,       15256,  7681,       -4,
+    7683,       -4,     7685,       -4,     7687,       -4,
+    7689,       -4,     7691,       -4,  // NOLINT
+    7693,       -4,     7695,       -4,     7697,       -4,
+    7699,       -4,     7701,       -4,     7703,       -4,
+    7705,       -4,     7707,       -4,  // NOLINT
+    7709,       -4,     7711,       -4,     7713,       -4,
+    7715,       -4,     7717,       -4,     7719,       -4,
+    7721,       -4,     7723,       -4,  // NOLINT
+    7725,       -4,     7727,       -4,     7729,       -4,
+    7731,       -4,     7733,       -4,     7735,       -4,
+    7737,       -4,     7739,       -4,  // NOLINT
+    7741,       -4,     7743,       -4,     7745,       -4,
+    7747,       -4,     7749,       -4,     7751,       -4,
+    7753,       -4,     7755,       -4,  // NOLINT
+    7757,       -4,     7759,       -4,     7761,       -4,
+    7763,       -4,     7765,       -4,     7767,       -4,
+    7769,       -4,     7771,       -4,  // NOLINT
+    7773,       -4,     7775,       -4,     7777,       -4,
+    7779,       -4,     7781,       -4,     7783,       -4,
+    7785,       -4,     7787,       -4,  // NOLINT
+    7789,       -4,     7791,       -4,     7793,       -4,
+    7795,       -4,     7797,       -4,     7799,       -4,
+    7801,       -4,     7803,       -4,  // NOLINT
+    7805,       -4,     7807,       -4,     7809,       -4,
+    7811,       -4,     7813,       -4,     7815,       -4,
+    7817,       -4,     7819,       -4,  // NOLINT
+    7821,       -4,     7823,       -4,     7825,       -4,
+    7827,       -4,     7829,       -4,     7835,       -236,
+    7841,       -4,     7843,       -4,  // NOLINT
+    7845,       -4,     7847,       -4,     7849,       -4,
+    7851,       -4,     7853,       -4,     7855,       -4,
+    7857,       -4,     7859,       -4,  // NOLINT
+    7861,       -4,     7863,       -4,     7865,       -4,
+    7867,       -4,     7869,       -4,     7871,       -4,
+    7873,       -4,     7875,       -4,  // NOLINT
+    7877,       -4,     7879,       -4,     7881,       -4,
+    7883,       -4,     7885,       -4,     7887,       -4,
+    7889,       -4,     7891,       -4,  // NOLINT
+    7893,       -4,     7895,       -4,     7897,       -4,
+    7899,       -4,     7901,       -4,     7903,       -4,
+    7905,       -4,     7907,       -4,  // NOLINT
+    7909,       -4,     7911,       -4,     7913,       -4,
+    7915,       -4,     7917,       -4,     7919,       -4,
+    7921,       -4,     7923,       -4,  // NOLINT
+    7925,       -4,     7927,       -4,     7929,       -4,
+    7931,       -4,     7933,       -4,     7935,       -4,
+    1073749760, 32,     7943,       32,  // NOLINT
+    1073749776, 32,     7957,       32,     1073749792, 32,
+    7975,       32,     1073749808, 32,     7991,       32,
+    1073749824, 32,     8005,       32,  // NOLINT
+    8017,       32,     8019,       32,     8021,       32,
+    8023,       32,     1073749856, 32,     8039,       32,
+    1073749872, 296,    8049,       296,  // NOLINT
+    1073749874, 344,    8053,       344,    1073749878, 400,
+    8055,       400,    1073749880, 512,    8057,       512,
+    1073749882, 448,    8059,       448,  // NOLINT
+    1073749884, 504,    8061,       504,    1073749936, 32,
+    8113,       32,     8126,       -28820, 1073749968, 32,
+    8145,       32,     1073749984, 32,   // NOLINT
+    8161,       32,     8165,       28};  // NOLINT
+static const MultiCharacterSpecialCase<1> kEcma262CanonicalizeMultiStrings1[1] =
+    {                                                       // NOLINT
+        {{kSentinel}}};                                     // NOLINT
+static const uint16_t kEcma262CanonicalizeTable1Size = 73;  // NOLINT
+static const int32_t kEcma262CanonicalizeTable1[146] = {
+    334,        -112,   1073742192, -64,    383,        -64,
+    388,        -4,     1073743056, -104,   1257,       -104,
+    1073744944, -192,   3166,       -192,  // NOLINT
+    3169,       -4,     3173,       -43180, 3174,       -43168,
+    3176,       -4,     3178,       -4,     3180,       -4,
+    3187,       -4,     3190,       -4,  // NOLINT
+    3201,       -4,     3203,       -4,     3205,       -4,
+    3207,       -4,     3209,       -4,     3211,       -4,
+    3213,       -4,     3215,       -4,  // NOLINT
+    3217,       -4,     3219,       -4,     3221,       -4,
+    3223,       -4,     3225,       -4,     3227,       -4,
+    3229,       -4,     3231,       -4,  // NOLINT
+    3233,       -4,     3235,       -4,     3237,       -4,
+    3239,       -4,     3241,       -4,     3243,       -4,
+    3245,       -4,     3247,       -4,  // NOLINT
+    3249,       -4,     3251,       -4,     3253,       -4,
+    3255,       -4,     3257,       -4,     3259,       -4,
+    3261,       -4,     3263,       -4,  // NOLINT
+    3265,       -4,     3267,       -4,     3269,       -4,
+    3271,       -4,     3273,       -4,     3275,       -4,
+    3277,       -4,     3279,       -4,  // NOLINT
+    3281,       -4,     3283,       -4,     3285,       -4,
+    3287,       -4,     3289,       -4,     3291,       -4,
+    3293,       -4,     3295,       -4,  // NOLINT
+    3297,       -4,     3299,       -4,     3308,       -4,
+    3310,       -4,     3315,       -4,     1073745152, -29056,
+    3365,       -29056, 3367,       -29056,  // NOLINT
+    3373,       -29056};                     // NOLINT
+static const MultiCharacterSpecialCase<1> kEcma262CanonicalizeMultiStrings5[1] =
+    {                                                       // NOLINT
+        {{kSentinel}}};                                     // NOLINT
+static const uint16_t kEcma262CanonicalizeTable5Size = 95;  // NOLINT
+static const int32_t kEcma262CanonicalizeTable5[190] =
+    {
+        1601, -4, 1603, -4, 1605, -4, 1607, -4,
+        1609, -4, 1611, -4, 1613, -4, 1615, -4,  // NOLINT
+        1617, -4, 1619, -4, 1621, -4, 1623, -4,
+        1625, -4, 1627, -4, 1629, -4, 1631, -4,  // NOLINT
+        1633, -4, 1635, -4, 1637, -4, 1639, -4,
+        1641, -4, 1643, -4, 1645, -4, 1665, -4,  // NOLINT
+        1667, -4, 1669, -4, 1671, -4, 1673, -4,
+        1675, -4, 1677, -4, 1679, -4, 1681, -4,  // NOLINT
+        1683, -4, 1685, -4, 1687, -4, 1689, -4,
+        1691, -4, 1827, -4, 1829, -4, 1831, -4,  // NOLINT
+        1833, -4, 1835, -4, 1837, -4, 1839, -4,
+        1843, -4, 1845, -4, 1847, -4, 1849, -4,  // NOLINT
+        1851, -4, 1853, -4, 1855, -4, 1857, -4,
+        1859, -4, 1861, -4, 1863, -4, 1865, -4,  // NOLINT
+        1867, -4, 1869, -4, 1871, -4, 1873, -4,
+        1875, -4, 1877, -4, 1879, -4, 1881, -4,  // NOLINT
+        1883, -4, 1885, -4, 1887, -4, 1889, -4,
+        1891, -4, 1893, -4, 1895, -4, 1897, -4,  // NOLINT
+        1899, -4, 1901, -4, 1903, -4, 1914, -4,
+        1916, -4, 1919, -4, 1921, -4, 1923, -4,  // NOLINT
+        1925, -4, 1927, -4, 1932, -4, 1937, -4,
+        1939, -4, 1943, -4, 1945, -4, 1947, -4,  // NOLINT
+        1949, -4, 1951, -4, 1953, -4, 1955, -4,
+        1957, -4, 1959, -4, 1961, -4};  // NOLINT
+static const MultiCharacterSpecialCase<1> kEcma262CanonicalizeMultiStrings7[1] =
+    {                                                      // NOLINT
+        {{kSentinel}}};                                    // NOLINT
+static const uint16_t kEcma262CanonicalizeTable7Size = 2;  // NOLINT
+static const int32_t kEcma262CanonicalizeTable7[4] = {1073749825, -128, 8026,
+                                                      -128};  // NOLINT
+int Ecma262Canonicalize::Convert(uchar c, uchar n, uchar* result,
+                                 bool* allow_caching_ptr) {
+  int chunk_index = c >> 13;
+  switch (chunk_index) {
+    case 0:
+      return LookupMapping<true>(
+          kEcma262CanonicalizeTable0, kEcma262CanonicalizeTable0Size,
+          kEcma262CanonicalizeMultiStrings0, c, n, result, allow_caching_ptr);
+    case 1:
+      return LookupMapping<true>(
+          kEcma262CanonicalizeTable1, kEcma262CanonicalizeTable1Size,
+          kEcma262CanonicalizeMultiStrings1, c, n, result, allow_caching_ptr);
+    case 5:
+      return LookupMapping<true>(
+          kEcma262CanonicalizeTable5, kEcma262CanonicalizeTable5Size,
+          kEcma262CanonicalizeMultiStrings5, c, n, result, allow_caching_ptr);
+    case 7:
+      return LookupMapping<true>(
+          kEcma262CanonicalizeTable7, kEcma262CanonicalizeTable7Size,
+          kEcma262CanonicalizeMultiStrings7, c, n, result, allow_caching_ptr);
+    default:
+      return 0;
+  }
+}
+
+static const MultiCharacterSpecialCase<4>
+    kEcma262UnCanonicalizeMultiStrings0[507] = {  // NOLINT
+        {{65, 97, kSentinel}},
+        {{90, 122, kSentinel}},
+        {{181, 924, 956, kSentinel}},
+        {{192, 224, kSentinel}},  // NOLINT
+        {{214, 246, kSentinel}},
+        {{216, 248, kSentinel}},
+        {{222, 254, kSentinel}},
+        {{255, 376, kSentinel}},  // NOLINT
+        {{256, 257, kSentinel}},
+        {{258, 259, kSentinel}},
+        {{260, 261, kSentinel}},
+        {{262, 263, kSentinel}},  // NOLINT
+        {{264, 265, kSentinel}},
+        {{266, 267, kSentinel}},
+        {{268, 269, kSentinel}},
+        {{270, 271, kSentinel}},  // NOLINT
+        {{272, 273, kSentinel}},
+        {{274, 275, kSentinel}},
+        {{276, 277, kSentinel}},
+        {{278, 279, kSentinel}},  // NOLINT
+        {{280, 281, kSentinel}},
+        {{282, 283, kSentinel}},
+        {{284, 285, kSentinel}},
+        {{286, 287, kSentinel}},  // NOLINT
+        {{288, 289, kSentinel}},
+        {{290, 291, kSentinel}},
+        {{292, 293, kSentinel}},
+        {{294, 295, kSentinel}},  // NOLINT
+        {{296, 297, kSentinel}},
+        {{298, 299, kSentinel}},
+        {{300, 301, kSentinel}},
+        {{302, 303, kSentinel}},  // NOLINT
+        {{306, 307, kSentinel}},
+        {{308, 309, kSentinel}},
+        {{310, 311, kSentinel}},
+        {{313, 314, kSentinel}},  // NOLINT
+        {{315, 316, kSentinel}},
+        {{317, 318, kSentinel}},
+        {{319, 320, kSentinel}},
+        {{321, 322, kSentinel}},  // NOLINT
+        {{323, 324, kSentinel}},
+        {{325, 326, kSentinel}},
+        {{327, 328, kSentinel}},
+        {{330, 331, kSentinel}},  // NOLINT
+        {{332, 333, kSentinel}},
+        {{334, 335, kSentinel}},
+        {{336, 337, kSentinel}},
+        {{338, 339, kSentinel}},  // NOLINT
+        {{340, 341, kSentinel}},
+        {{342, 343, kSentinel}},
+        {{344, 345, kSentinel}},
+        {{346, 347, kSentinel}},  // NOLINT
+        {{348, 349, kSentinel}},
+        {{350, 351, kSentinel}},
+        {{352, 353, kSentinel}},
+        {{354, 355, kSentinel}},  // NOLINT
+        {{356, 357, kSentinel}},
+        {{358, 359, kSentinel}},
+        {{360, 361, kSentinel}},
+        {{362, 363, kSentinel}},  // NOLINT
+        {{364, 365, kSentinel}},
+        {{366, 367, kSentinel}},
+        {{368, 369, kSentinel}},
+        {{370, 371, kSentinel}},  // NOLINT
+        {{372, 373, kSentinel}},
+        {{374, 375, kSentinel}},
+        {{377, 378, kSentinel}},
+        {{379, 380, kSentinel}},  // NOLINT
+        {{381, 382, kSentinel}},
+        {{384, 579, kSentinel}},
+        {{385, 595, kSentinel}},
+        {{386, 387, kSentinel}},  // NOLINT
+        {{388, 389, kSentinel}},
+        {{390, 596, kSentinel}},
+        {{391, 392, kSentinel}},
+        {{393, 598, kSentinel}},  // NOLINT
+        {{394, 599, kSentinel}},
+        {{395, 396, kSentinel}},
+        {{398, 477, kSentinel}},
+        {{399, 601, kSentinel}},  // NOLINT
+        {{400, 603, kSentinel}},
+        {{401, 402, kSentinel}},
+        {{403, 608, kSentinel}},
+        {{404, 611, kSentinel}},  // NOLINT
+        {{405, 502, kSentinel}},
+        {{406, 617, kSentinel}},
+        {{407, 616, kSentinel}},
+        {{408, 409, kSentinel}},  // NOLINT
+        {{410, 573, kSentinel}},
+        {{412, 623, kSentinel}},
+        {{413, 626, kSentinel}},
+        {{414, 544, kSentinel}},  // NOLINT
+        {{415, 629, kSentinel}},
+        {{416, 417, kSentinel}},
+        {{418, 419, kSentinel}},
+        {{420, 421, kSentinel}},  // NOLINT
+        {{422, 640, kSentinel}},
+        {{423, 424, kSentinel}},
+        {{425, 643, kSentinel}},
+        {{428, 429, kSentinel}},  // NOLINT
+        {{430, 648, kSentinel}},
+        {{431, 432, kSentinel}},
+        {{433, 650, kSentinel}},
+        {{434, 651, kSentinel}},  // NOLINT
+        {{435, 436, kSentinel}},
+        {{437, 438, kSentinel}},
+        {{439, 658, kSentinel}},
+        {{440, 441, kSentinel}},  // NOLINT
+        {{444, 445, kSentinel}},
+        {{447, 503, kSentinel}},
+        {{452, 453, 454, kSentinel}},
+        {{455, 456, 457, kSentinel}},  // NOLINT
+        {{458, 459, 460, kSentinel}},
+        {{461, 462, kSentinel}},
+        {{463, 464, kSentinel}},
+        {{465, 466, kSentinel}},  // NOLINT
+        {{467, 468, kSentinel}},
+        {{469, 470, kSentinel}},
+        {{471, 472, kSentinel}},
+        {{473, 474, kSentinel}},  // NOLINT
+        {{475, 476, kSentinel}},
+        {{478, 479, kSentinel}},
+        {{480, 481, kSentinel}},
+        {{482, 483, kSentinel}},  // NOLINT
+        {{484, 485, kSentinel}},
+        {{486, 487, kSentinel}},
+        {{488, 489, kSentinel}},
+        {{490, 491, kSentinel}},  // NOLINT
+        {{492, 493, kSentinel}},
+        {{494, 495, kSentinel}},
+        {{497, 498, 499, kSentinel}},
+        {{500, 501, kSentinel}},  // NOLINT
+        {{504, 505, kSentinel}},
+        {{506, 507, kSentinel}},
+        {{508, 509, kSentinel}},
+        {{510, 511, kSentinel}},  // NOLINT
+        {{512, 513, kSentinel}},
+        {{514, 515, kSentinel}},
+        {{516, 517, kSentinel}},
+        {{518, 519, kSentinel}},  // NOLINT
+        {{520, 521, kSentinel}},
+        {{522, 523, kSentinel}},
+        {{524, 525, kSentinel}},
+        {{526, 527, kSentinel}},  // NOLINT
+        {{528, 529, kSentinel}},
+        {{530, 531, kSentinel}},
+        {{532, 533, kSentinel}},
+        {{534, 535, kSentinel}},  // NOLINT
+        {{536, 537, kSentinel}},
+        {{538, 539, kSentinel}},
+        {{540, 541, kSentinel}},
+        {{542, 543, kSentinel}},  // NOLINT
+        {{546, 547, kSentinel}},
+        {{548, 549, kSentinel}},
+        {{550, 551, kSentinel}},
+        {{552, 553, kSentinel}},  // NOLINT
+        {{554, 555, kSentinel}},
+        {{556, 557, kSentinel}},
+        {{558, 559, kSentinel}},
+        {{560, 561, kSentinel}},  // NOLINT
+        {{562, 563, kSentinel}},
+        {{570, 11365, kSentinel}},
+        {{571, 572, kSentinel}},
+        {{574, 11366, kSentinel}},  // NOLINT
+        {{575, 11390, kSentinel}},
+        {{576, 11391, kSentinel}},
+        {{577, 578, kSentinel}},
+        {{580, 649, kSentinel}},  // NOLINT
+        {{581, 652, kSentinel}},
+        {{582, 583, kSentinel}},
+        {{584, 585, kSentinel}},
+        {{586, 587, kSentinel}},  // NOLINT
+        {{588, 589, kSentinel}},
+        {{590, 591, kSentinel}},
+        {{592, 11375, kSentinel}},
+        {{593, 11373, kSentinel}},  // NOLINT
+        {{594, 11376, kSentinel}},
+        {{604, 42923, kSentinel}},
+        {{609, 42924, kSentinel}},
+        {{613, 42893, kSentinel}},  // NOLINT
+        {{614, 42922, kSentinel}},
+        {{619, 11362, kSentinel}},
+        {{620, 42925, kSentinel}},
+        {{625, 11374, kSentinel}},  // NOLINT
+        {{637, 11364, kSentinel}},
+        {{647, 42929, kSentinel}},
+        {{670, 42928, kSentinel}},
+        {{837, 921, 953, 8126}},  // NOLINT
+        {{880, 881, kSentinel}},
+        {{882, 883, kSentinel}},
+        {{886, 887, kSentinel}},
+        {{891, 1021, kSentinel}},  // NOLINT
+        {{893, 1023, kSentinel}},
+        {{895, 1011, kSentinel}},
+        {{902, 940, kSentinel}},
+        {{904, 941, kSentinel}},  // NOLINT
+        {{906, 943, kSentinel}},
+        {{908, 972, kSentinel}},
+        {{910, 973, kSentinel}},
+        {{911, 974, kSentinel}},  // NOLINT
+        {{913, 945, kSentinel}},
+        {{914, 946, 976, kSentinel}},
+        {{915, 947, kSentinel}},
+        {{916, 948, kSentinel}},  // NOLINT
+        {{917, 949, 1013, kSentinel}},
+        {{918, 950, kSentinel}},
+        {{919, 951, kSentinel}},
+        {{920, 952, 977, kSentinel}},  // NOLINT
+        {{922, 954, 1008, kSentinel}},
+        {{923, 955, kSentinel}},
+        {{925, 957, kSentinel}},
+        {{927, 959, kSentinel}},  // NOLINT
+        {{928, 960, 982, kSentinel}},
+        {{929, 961, 1009, kSentinel}},
+        {{931, 962, 963, kSentinel}},
+        {{932, 964, kSentinel}},  // NOLINT
+        {{933, 965, kSentinel}},
+        {{934, 966, 981, kSentinel}},
+        {{935, 967, kSentinel}},
+        {{939, 971, kSentinel}},  // NOLINT
+        {{975, 983, kSentinel}},
+        {{984, 985, kSentinel}},
+        {{986, 987, kSentinel}},
+        {{988, 989, kSentinel}},  // NOLINT
+        {{990, 991, kSentinel}},
+        {{992, 993, kSentinel}},
+        {{994, 995, kSentinel}},
+        {{996, 997, kSentinel}},  // NOLINT
+        {{998, 999, kSentinel}},
+        {{1000, 1001, kSentinel}},
+        {{1002, 1003, kSentinel}},
+        {{1004, 1005, kSentinel}},  // NOLINT
+        {{1006, 1007, kSentinel}},
+        {{1010, 1017, kSentinel}},
+        {{1015, 1016, kSentinel}},
+        {{1018, 1019, kSentinel}},  // NOLINT
+        {{1024, 1104, kSentinel}},
+        {{1039, 1119, kSentinel}},
+        {{1040, 1072, kSentinel}},
+        {{1071, 1103, kSentinel}},  // NOLINT
+        {{1120, 1121, kSentinel}},
+        {{1122, 1123, kSentinel}},
+        {{1124, 1125, kSentinel}},
+        {{1126, 1127, kSentinel}},  // NOLINT
+        {{1128, 1129, kSentinel}},
+        {{1130, 1131, kSentinel}},
+        {{1132, 1133, kSentinel}},
+        {{1134, 1135, kSentinel}},  // NOLINT
+        {{1136, 1137, kSentinel}},
+        {{1138, 1139, kSentinel}},
+        {{1140, 1141, kSentinel}},
+        {{1142, 1143, kSentinel}},  // NOLINT
+        {{1144, 1145, kSentinel}},
+        {{1146, 1147, kSentinel}},
+        {{1148, 1149, kSentinel}},
+        {{1150, 1151, kSentinel}},  // NOLINT
+        {{1152, 1153, kSentinel}},
+        {{1162, 1163, kSentinel}},
+        {{1164, 1165, kSentinel}},
+        {{1166, 1167, kSentinel}},  // NOLINT
+        {{1168, 1169, kSentinel}},
+        {{1170, 1171, kSentinel}},
+        {{1172, 1173, kSentinel}},
+        {{1174, 1175, kSentinel}},  // NOLINT
+        {{1176, 1177, kSentinel}},
+        {{1178, 1179, kSentinel}},
+        {{1180, 1181, kSentinel}},
+        {{1182, 1183, kSentinel}},  // NOLINT
+        {{1184, 1185, kSentinel}},
+        {{1186, 1187, kSentinel}},
+        {{1188, 1189, kSentinel}},
+        {{1190, 1191, kSentinel}},  // NOLINT
+        {{1192, 1193, kSentinel}},
+        {{1194, 1195, kSentinel}},
+        {{1196, 1197, kSentinel}},
+        {{1198, 1199, kSentinel}},  // NOLINT
+        {{1200, 1201, kSentinel}},
+        {{1202, 1203, kSentinel}},
+        {{1204, 1205, kSentinel}},
+        {{1206, 1207, kSentinel}},  // NOLINT
+        {{1208, 1209, kSentinel}},
+        {{1210, 1211, kSentinel}},
+        {{1212, 1213, kSentinel}},
+        {{1214, 1215, kSentinel}},  // NOLINT
+        {{1216, 1231, kSentinel}},
+        {{1217, 1218, kSentinel}},
+        {{1219, 1220, kSentinel}},
+        {{1221, 1222, kSentinel}},  // NOLINT
+        {{1223, 1224, kSentinel}},
+        {{1225, 1226, kSentinel}},
+        {{1227, 1228, kSentinel}},
+        {{1229, 1230, kSentinel}},  // NOLINT
+        {{1232, 1233, kSentinel}},
+        {{1234, 1235, kSentinel}},
+        {{1236, 1237, kSentinel}},
+        {{1238, 1239, kSentinel}},  // NOLINT
+        {{1240, 1241, kSentinel}},
+        {{1242, 1243, kSentinel}},
+        {{1244, 1245, kSentinel}},
+        {{1246, 1247, kSentinel}},  // NOLINT
+        {{1248, 1249, kSentinel}},
+        {{1250, 1251, kSentinel}},
+        {{1252, 1253, kSentinel}},
+        {{1254, 1255, kSentinel}},  // NOLINT
+        {{1256, 1257, kSentinel}},
+        {{1258, 1259, kSentinel}},
+        {{1260, 1261, kSentinel}},
+        {{1262, 1263, kSentinel}},  // NOLINT
+        {{1264, 1265, kSentinel}},
+        {{1266, 1267, kSentinel}},
+        {{1268, 1269, kSentinel}},
+        {{1270, 1271, kSentinel}},  // NOLINT
+        {{1272, 1273, kSentinel}},
+        {{1274, 1275, kSentinel}},
+        {{1276, 1277, kSentinel}},
+        {{1278, 1279, kSentinel}},  // NOLINT
+        {{1280, 1281, kSentinel}},
+        {{1282, 1283, kSentinel}},
+        {{1284, 1285, kSentinel}},
+        {{1286, 1287, kSentinel}},  // NOLINT
+        {{1288, 1289, kSentinel}},
+        {{1290, 1291, kSentinel}},
+        {{1292, 1293, kSentinel}},
+        {{1294, 1295, kSentinel}},  // NOLINT
+        {{1296, 1297, kSentinel}},
+        {{1298, 1299, kSentinel}},
+        {{1300, 1301, kSentinel}},
+        {{1302, 1303, kSentinel}},  // NOLINT
+        {{1304, 1305, kSentinel}},
+        {{1306, 1307, kSentinel}},
+        {{1308, 1309, kSentinel}},
+        {{1310, 1311, kSentinel}},  // NOLINT
+        {{1312, 1313, kSentinel}},
+        {{1314, 1315, kSentinel}},
+        {{1316, 1317, kSentinel}},
+        {{1318, 1319, kSentinel}},  // NOLINT
+        {{1320, 1321, kSentinel}},
+        {{1322, 1323, kSentinel}},
+        {{1324, 1325, kSentinel}},
+        {{1326, 1327, kSentinel}},  // NOLINT
+        {{1329, 1377, kSentinel}},
+        {{1366, 1414, kSentinel}},
+        {{4256, 11520, kSentinel}},
+        {{4293, 11557, kSentinel}},  // NOLINT
+        {{4295, 11559, kSentinel}},
+        {{4301, 11565, kSentinel}},
+        {{7545, 42877, kSentinel}},
+        {{7549, 11363, kSentinel}},  // NOLINT
+        {{7680, 7681, kSentinel}},
+        {{7682, 7683, kSentinel}},
+        {{7684, 7685, kSentinel}},
+        {{7686, 7687, kSentinel}},  // NOLINT
+        {{7688, 7689, kSentinel}},
+        {{7690, 7691, kSentinel}},
+        {{7692, 7693, kSentinel}},
+        {{7694, 7695, kSentinel}},  // NOLINT
+        {{7696, 7697, kSentinel}},
+        {{7698, 7699, kSentinel}},
+        {{7700, 7701, kSentinel}},
+        {{7702, 7703, kSentinel}},  // NOLINT
+        {{7704, 7705, kSentinel}},
+        {{7706, 7707, kSentinel}},
+        {{7708, 7709, kSentinel}},
+        {{7710, 7711, kSentinel}},  // NOLINT
+        {{7712, 7713, kSentinel}},
+        {{7714, 7715, kSentinel}},
+        {{7716, 7717, kSentinel}},
+        {{7718, 7719, kSentinel}},  // NOLINT
+        {{7720, 7721, kSentinel}},
+        {{7722, 7723, kSentinel}},
+        {{7724, 7725, kSentinel}},
+        {{7726, 7727, kSentinel}},  // NOLINT
+        {{7728, 7729, kSentinel}},
+        {{7730, 7731, kSentinel}},
+        {{7732, 7733, kSentinel}},
+        {{7734, 7735, kSentinel}},  // NOLINT
+        {{7736, 7737, kSentinel}},
+        {{7738, 7739, kSentinel}},
+        {{7740, 7741, kSentinel}},
+        {{7742, 7743, kSentinel}},  // NOLINT
+        {{7744, 7745, kSentinel}},
+        {{7746, 7747, kSentinel}},
+        {{7748, 7749, kSentinel}},
+        {{7750, 7751, kSentinel}},  // NOLINT
+        {{7752, 7753, kSentinel}},
+        {{7754, 7755, kSentinel}},
+        {{7756, 7757, kSentinel}},
+        {{7758, 7759, kSentinel}},  // NOLINT
+        {{7760, 7761, kSentinel}},
+        {{7762, 7763, kSentinel}},
+        {{7764, 7765, kSentinel}},
+        {{7766, 7767, kSentinel}},  // NOLINT
+        {{7768, 7769, kSentinel}},
+        {{7770, 7771, kSentinel}},
+        {{7772, 7773, kSentinel}},
+        {{7774, 7775, kSentinel}},  // NOLINT
+        {{7776, 7777, 7835, kSentinel}},
+        {{7778, 7779, kSentinel}},
+        {{7780, 7781, kSentinel}},
+        {{7782, 7783, kSentinel}},  // NOLINT
+        {{7784, 7785, kSentinel}},
+        {{7786, 7787, kSentinel}},
+        {{7788, 7789, kSentinel}},
+        {{7790, 7791, kSentinel}},  // NOLINT
+        {{7792, 7793, kSentinel}},
+        {{7794, 7795, kSentinel}},
+        {{7796, 7797, kSentinel}},
+        {{7798, 7799, kSentinel}},  // NOLINT
+        {{7800, 7801, kSentinel}},
+        {{7802, 7803, kSentinel}},
+        {{7804, 7805, kSentinel}},
+        {{7806, 7807, kSentinel}},  // NOLINT
+        {{7808, 7809, kSentinel}},
+        {{7810, 7811, kSentinel}},
+        {{7812, 7813, kSentinel}},
+        {{7814, 7815, kSentinel}},  // NOLINT
+        {{7816, 7817, kSentinel}},
+        {{7818, 7819, kSentinel}},
+        {{7820, 7821, kSentinel}},
+        {{7822, 7823, kSentinel}},  // NOLINT
+        {{7824, 7825, kSentinel}},
+        {{7826, 7827, kSentinel}},
+        {{7828, 7829, kSentinel}},
+        {{7840, 7841, kSentinel}},  // NOLINT
+        {{7842, 7843, kSentinel}},
+        {{7844, 7845, kSentinel}},
+        {{7846, 7847, kSentinel}},
+        {{7848, 7849, kSentinel}},  // NOLINT
+        {{7850, 7851, kSentinel}},
+        {{7852, 7853, kSentinel}},
+        {{7854, 7855, kSentinel}},
+        {{7856, 7857, kSentinel}},  // NOLINT
+        {{7858, 7859, kSentinel}},
+        {{7860, 7861, kSentinel}},
+        {{7862, 7863, kSentinel}},
+        {{7864, 7865, kSentinel}},  // NOLINT
+        {{7866, 7867, kSentinel}},
+        {{7868, 7869, kSentinel}},
+        {{7870, 7871, kSentinel}},
+        {{7872, 7873, kSentinel}},  // NOLINT
+        {{7874, 7875, kSentinel}},
+        {{7876, 7877, kSentinel}},
+        {{7878, 7879, kSentinel}},
+        {{7880, 7881, kSentinel}},  // NOLINT
+        {{7882, 7883, kSentinel}},
+        {{7884, 7885, kSentinel}},
+        {{7886, 7887, kSentinel}},
+        {{7888, 7889, kSentinel}},  // NOLINT
+        {{7890, 7891, kSentinel}},
+        {{7892, 7893, kSentinel}},
+        {{7894, 7895, kSentinel}},
+        {{7896, 7897, kSentinel}},  // NOLINT
+        {{7898, 7899, kSentinel}},
+        {{7900, 7901, kSentinel}},
+        {{7902, 7903, kSentinel}},
+        {{7904, 7905, kSentinel}},  // NOLINT
+        {{7906, 7907, kSentinel}},
+        {{7908, 7909, kSentinel}},
+        {{7910, 7911, kSentinel}},
+        {{7912, 7913, kSentinel}},  // NOLINT
+        {{7914, 7915, kSentinel}},
+        {{7916, 7917, kSentinel}},
+        {{7918, 7919, kSentinel}},
+        {{7920, 7921, kSentinel}},  // NOLINT
+        {{7922, 7923, kSentinel}},
+        {{7924, 7925, kSentinel}},
+        {{7926, 7927, kSentinel}},
+        {{7928, 7929, kSentinel}},  // NOLINT
+        {{7930, 7931, kSentinel}},
+        {{7932, 7933, kSentinel}},
+        {{7934, 7935, kSentinel}},
+        {{7936, 7944, kSentinel}},  // NOLINT
+        {{7943, 7951, kSentinel}},
+        {{7952, 7960, kSentinel}},
+        {{7957, 7965, kSentinel}},
+        {{7968, 7976, kSentinel}},  // NOLINT
+        {{7975, 7983, kSentinel}},
+        {{7984, 7992, kSentinel}},
+        {{7991, 7999, kSentinel}},
+        {{8000, 8008, kSentinel}},  // NOLINT
+        {{8005, 8013, kSentinel}},
+        {{8017, 8025, kSentinel}},
+        {{8019, 8027, kSentinel}},
+        {{8021, 8029, kSentinel}},  // NOLINT
+        {{8023, 8031, kSentinel}},
+        {{8032, 8040, kSentinel}},
+        {{8039, 8047, kSentinel}},
+        {{8048, 8122, kSentinel}},  // NOLINT
+        {{8049, 8123, kSentinel}},
+        {{8050, 8136, kSentinel}},
+        {{8053, 8139, kSentinel}},
+        {{8054, 8154, kSentinel}},  // NOLINT
+        {{8055, 8155, kSentinel}},
+        {{8056, 8184, kSentinel}},
+        {{8057, 8185, kSentinel}},
+        {{8058, 8170, kSentinel}},  // NOLINT
+        {{8059, 8171, kSentinel}},
+        {{8060, 8186, kSentinel}},
+        {{8061, 8187, kSentinel}},
+        {{8112, 8120, kSentinel}},  // NOLINT
+        {{8113, 8121, kSentinel}},
+        {{8144, 8152, kSentinel}},
+        {{8145, 8153, kSentinel}},
+        {{8160, 8168, kSentinel}},  // NOLINT
+        {{8161, 8169, kSentinel}},
+        {{8165, 8172, kSentinel}},
+        {{kSentinel}}};                                         // NOLINT
+static const uint16_t kEcma262UnCanonicalizeTable0Size = 1005;  // NOLINT
+static const int32_t kEcma262UnCanonicalizeTable0[2010] = {
+    1073741889, 1,    90,         5,    1073741921, 1,
+    122,        5,    181,        9,    1073742016, 13,
+    214,        17,   1073742040, 21,  // NOLINT
+    222,        25,   1073742048, 13,   246,        17,
+    1073742072, 21,   254,        25,   255,        29,
+    256,        33,   257,        33,  // NOLINT
+    258,        37,   259,        37,   260,        41,
+    261,        41,   262,        45,   263,        45,
+    264,        49,   265,        49,  // NOLINT
+    266,        53,   267,        53,   268,        57,
+    269,        57,   270,        61,   271,        61,
+    272,        65,   273,        65,  // NOLINT
+    274,        69,   275,        69,   276,        73,
+    277,        73,   278,        77,   279,        77,
+    280,        81,   281,        81,  // NOLINT
+    282,        85,   283,        85,   284,        89,
+    285,        89,   286,        93,   287,        93,
+    288,        97,   289,        97,  // NOLINT
+    290,        101,  291,        101,  292,        105,
+    293,        105,  294,        109,  295,        109,
+    296,        113,  297,        113,  // NOLINT
+    298,        117,  299,        117,  300,        121,
+    301,        121,  302,        125,  303,        125,
+    306,        129,  307,        129,  // NOLINT
+    308,        133,  309,        133,  310,        137,
+    311,        137,  313,        141,  314,        141,
+    315,        145,  316,        145,  // NOLINT
+    317,        149,  318,        149,  319,        153,
+    320,        153,  321,        157,  322,        157,
+    323,        161,  324,        161,  // NOLINT
+    325,        165,  326,        165,  327,        169,
+    328,        169,  330,        173,  331,        173,
+    332,        177,  333,        177,  // NOLINT
+    334,        181,  335,        181,  336,        185,
+    337,        185,  338,        189,  339,        189,
+    340,        193,  341,        193,  // NOLINT
+    342,        197,  343,        197,  344,        201,
+    345,        201,  346,        205,  347,        205,
+    348,        209,  349,        209,  // NOLINT
+    350,        213,  351,        213,  352,        217,
+    353,        217,  354,        221,  355,        221,
+    356,        225,  357,        225,  // NOLINT
+    358,        229,  359,        229,  360,        233,
+    361,        233,  362,        237,  363,        237,
+    364,        241,  365,        241,  // NOLINT
+    366,        245,  367,        245,  368,        249,
+    369,        249,  370,        253,  371,        253,
+    372,        257,  373,        257,  // NOLINT
+    374,        261,  375,        261,  376,        29,
+    377,        265,  378,        265,  379,        269,
+    380,        269,  381,        273,  // NOLINT
+    382,        273,  384,        277,  385,        281,
+    386,        285,  387,        285,  388,        289,
+    389,        289,  390,        293,  // NOLINT
+    391,        297,  392,        297,  1073742217, 301,
+    394,        305,  395,        309,  396,        309,
+    398,        313,  399,        317,  // NOLINT
+    400,        321,  401,        325,  402,        325,
+    403,        329,  404,        333,  405,        337,
+    406,        341,  407,        345,  // NOLINT
+    408,        349,  409,        349,  410,        353,
+    412,        357,  413,        361,  414,        365,
+    415,        369,  416,        373,  // NOLINT
+    417,        373,  418,        377,  419,        377,
+    420,        381,  421,        381,  422,        385,
+    423,        389,  424,        389,  // NOLINT
+    425,        393,  428,        397,  429,        397,
+    430,        401,  431,        405,  432,        405,
+    1073742257, 409,  434,        413,  // NOLINT
+    435,        417,  436,        417,  437,        421,
+    438,        421,  439,        425,  440,        429,
+    441,        429,  444,        433,  // NOLINT
+    445,        433,  447,        437,  452,        441,
+    453,        441,  454,        441,  455,        445,
+    456,        445,  457,        445,  // NOLINT
+    458,        449,  459,        449,  460,        449,
+    461,        453,  462,        453,  463,        457,
+    464,        457,  465,        461,  // NOLINT
+    466,        461,  467,        465,  468,        465,
+    469,        469,  470,        469,  471,        473,
+    472,        473,  473,        477,  // NOLINT
+    474,        477,  475,        481,  476,        481,
+    477,        313,  478,        485,  479,        485,
+    480,        489,  481,        489,  // NOLINT
+    482,        493,  483,        493,  484,        497,
+    485,        497,  486,        501,  487,        501,
+    488,        505,  489,        505,  // NOLINT
+    490,        509,  491,        509,  492,        513,
+    493,        513,  494,        517,  495,        517,
+    497,        521,  498,        521,  // NOLINT
+    499,        521,  500,        525,  501,        525,
+    502,        337,  503,        437,  504,        529,
+    505,        529,  506,        533,  // NOLINT
+    507,        533,  508,        537,  509,        537,
+    510,        541,  511,        541,  512,        545,
+    513,        545,  514,        549,  // NOLINT
+    515,        549,  516,        553,  517,        553,
+    518,        557,  519,        557,  520,        561,
+    521,        561,  522,        565,  // NOLINT
+    523,        565,  524,        569,  525,        569,
+    526,        573,  527,        573,  528,        577,
+    529,        577,  530,        581,  // NOLINT
+    531,        581,  532,        585,  533,        585,
+    534,        589,  535,        589,  536,        593,
+    537,        593,  538,        597,  // NOLINT
+    539,        597,  540,        601,  541,        601,
+    542,        605,  543,        605,  544,        365,
+    546,        609,  547,        609,  // NOLINT
+    548,        613,  549,        613,  550,        617,
+    551,        617,  552,        621,  553,        621,
+    554,        625,  555,        625,  // NOLINT
+    556,        629,  557,        629,  558,        633,
+    559,        633,  560,        637,  561,        637,
+    562,        641,  563,        641,  // NOLINT
+    570,        645,  571,        649,  572,        649,
+    573,        353,  574,        653,  1073742399, 657,
+    576,        661,  577,        665,  // NOLINT
+    578,        665,  579,        277,  580,        669,
+    581,        673,  582,        677,  583,        677,
+    584,        681,  585,        681,  // NOLINT
+    586,        685,  587,        685,  588,        689,
+    589,        689,  590,        693,  591,        693,
+    592,        697,  593,        701,  // NOLINT
+    594,        705,  595,        281,  596,        293,
+    1073742422, 301,  599,        305,  601,        317,
+    603,        321,  604,        709,  // NOLINT
+    608,        329,  609,        713,  611,        333,
+    613,        717,  614,        721,  616,        345,
+    617,        341,  619,        725,  // NOLINT
+    620,        729,  623,        357,  625,        733,
+    626,        361,  629,        369,  637,        737,
+    640,        385,  643,        393,  // NOLINT
+    647,        741,  648,        401,  649,        669,
+    1073742474, 409,  651,        413,  652,        673,
+    658,        425,  670,        745,  // NOLINT
+    837,        749,  880,        753,  881,        753,
+    882,        757,  883,        757,  886,        761,
+    887,        761,  1073742715, 765,  // NOLINT
+    893,        769,  895,        773,  902,        777,
+    1073742728, 781,  906,        785,  908,        789,
+    1073742734, 793,  911,        797,  // NOLINT
+    913,        801,  914,        805,  1073742739, 809,
+    916,        813,  917,        817,  1073742742, 821,
+    919,        825,  920,        829,  // NOLINT
+    921,        749,  922,        833,  923,        837,
+    924,        9,    1073742749, 841,  927,        845,
+    928,        849,  929,        853,  // NOLINT
+    931,        857,  1073742756, 861,  933,        865,
+    934,        869,  1073742759, 873,  939,        877,
+    940,        777,  1073742765, 781,  // NOLINT
+    943,        785,  945,        801,  946,        805,
+    1073742771, 809,  948,        813,  949,        817,
+    1073742774, 821,  951,        825,  // NOLINT
+    952,        829,  953,        749,  954,        833,
+    955,        837,  956,        9,    1073742781, 841,
+    959,        845,  960,        849,  // NOLINT
+    961,        853,  962,        857,  963,        857,
+    1073742788, 861,  965,        865,  966,        869,
+    1073742791, 873,  971,        877,  // NOLINT
+    972,        789,  1073742797, 793,  974,        797,
+    975,        881,  976,        805,  977,        829,
+    981,        869,  982,        849,  // NOLINT
+    983,        881,  984,        885,  985,        885,
+    986,        889,  987,        889,  988,        893,
+    989,        893,  990,        897,  // NOLINT
+    991,        897,  992,        901,  993,        901,
+    994,        905,  995,        905,  996,        909,
+    997,        909,  998,        913,  // NOLINT
+    999,        913,  1000,       917,  1001,       917,
+    1002,       921,  1003,       921,  1004,       925,
+    1005,       925,  1006,       929,  // NOLINT
+    1007,       929,  1008,       833,  1009,       853,
+    1010,       933,  1011,       773,  1013,       817,
+    1015,       937,  1016,       937,  // NOLINT
+    1017,       933,  1018,       941,  1019,       941,
+    1073742845, 765,  1023,       769,  1073742848, 945,
+    1039,       949,  1073742864, 953,  // NOLINT
+    1071,       957,  1073742896, 953,  1103,       957,
+    1073742928, 945,  1119,       949,  1120,       961,
+    1121,       961,  1122,       965,  // NOLINT
+    1123,       965,  1124,       969,  1125,       969,
+    1126,       973,  1127,       973,  1128,       977,
+    1129,       977,  1130,       981,  // NOLINT
+    1131,       981,  1132,       985,  1133,       985,
+    1134,       989,  1135,       989,  1136,       993,
+    1137,       993,  1138,       997,  // NOLINT
+    1139,       997,  1140,       1001, 1141,       1001,
+    1142,       1005, 1143,       1005, 1144,       1009,
+    1145,       1009, 1146,       1013,  // NOLINT
+    1147,       1013, 1148,       1017, 1149,       1017,
+    1150,       1021, 1151,       1021, 1152,       1025,
+    1153,       1025, 1162,       1029,  // NOLINT
+    1163,       1029, 1164,       1033, 1165,       1033,
+    1166,       1037, 1167,       1037, 1168,       1041,
+    1169,       1041, 1170,       1045,  // NOLINT
+    1171,       1045, 1172,       1049, 1173,       1049,
+    1174,       1053, 1175,       1053, 1176,       1057,
+    1177,       1057, 1178,       1061,  // NOLINT
+    1179,       1061, 1180,       1065, 1181,       1065,
+    1182,       1069, 1183,       1069, 1184,       1073,
+    1185,       1073, 1186,       1077,  // NOLINT
+    1187,       1077, 1188,       1081, 1189,       1081,
+    1190,       1085, 1191,       1085, 1192,       1089,
+    1193,       1089, 1194,       1093,  // NOLINT
+    1195,       1093, 1196,       1097, 1197,       1097,
+    1198,       1101, 1199,       1101, 1200,       1105,
+    1201,       1105, 1202,       1109,  // NOLINT
+    1203,       1109, 1204,       1113, 1205,       1113,
+    1206,       1117, 1207,       1117, 1208,       1121,
+    1209,       1121, 1210,       1125,  // NOLINT
+    1211,       1125, 1212,       1129, 1213,       1129,
+    1214,       1133, 1215,       1133, 1216,       1137,
+    1217,       1141, 1218,       1141,  // NOLINT
+    1219,       1145, 1220,       1145, 1221,       1149,
+    1222,       1149, 1223,       1153, 1224,       1153,
+    1225,       1157, 1226,       1157,  // NOLINT
+    1227,       1161, 1228,       1161, 1229,       1165,
+    1230,       1165, 1231,       1137, 1232,       1169,
+    1233,       1169, 1234,       1173,  // NOLINT
+    1235,       1173, 1236,       1177, 1237,       1177,
+    1238,       1181, 1239,       1181, 1240,       1185,
+    1241,       1185, 1242,       1189,  // NOLINT
+    1243,       1189, 1244,       1193, 1245,       1193,
+    1246,       1197, 1247,       1197, 1248,       1201,
+    1249,       1201, 1250,       1205,  // NOLINT
+    1251,       1205, 1252,       1209, 1253,       1209,
+    1254,       1213, 1255,       1213, 1256,       1217,
+    1257,       1217, 1258,       1221,  // NOLINT
+    1259,       1221, 1260,       1225, 1261,       1225,
+    1262,       1229, 1263,       1229, 1264,       1233,
+    1265,       1233, 1266,       1237,  // NOLINT
+    1267,       1237, 1268,       1241, 1269,       1241,
+    1270,       1245, 1271,       1245, 1272,       1249,
+    1273,       1249, 1274,       1253,  // NOLINT
+    1275,       1253, 1276,       1257, 1277,       1257,
+    1278,       1261, 1279,       1261, 1280,       1265,
+    1281,       1265, 1282,       1269,  // NOLINT
+    1283,       1269, 1284,       1273, 1285,       1273,
+    1286,       1277, 1287,       1277, 1288,       1281,
+    1289,       1281, 1290,       1285,  // NOLINT
+    1291,       1285, 1292,       1289, 1293,       1289,
+    1294,       1293, 1295,       1293, 1296,       1297,
+    1297,       1297, 1298,       1301,  // NOLINT
+    1299,       1301, 1300,       1305, 1301,       1305,
+    1302,       1309, 1303,       1309, 1304,       1313,
+    1305,       1313, 1306,       1317,  // NOLINT
+    1307,       1317, 1308,       1321, 1309,       1321,
+    1310,       1325, 1311,       1325, 1312,       1329,
+    1313,       1329, 1314,       1333,  // NOLINT
+    1315,       1333, 1316,       1337, 1317,       1337,
+    1318,       1341, 1319,       1341, 1320,       1345,
+    1321,       1345, 1322,       1349,  // NOLINT
+    1323,       1349, 1324,       1353, 1325,       1353,
+    1326,       1357, 1327,       1357, 1073743153, 1361,
+    1366,       1365, 1073743201, 1361,  // NOLINT
+    1414,       1365, 1073746080, 1369, 4293,       1373,
+    4295,       1377, 4301,       1381, 7545,       1385,
+    7549,       1389, 7680,       1393,  // NOLINT
+    7681,       1393, 7682,       1397, 7683,       1397,
+    7684,       1401, 7685,       1401, 7686,       1405,
+    7687,       1405, 7688,       1409,  // NOLINT
+    7689,       1409, 7690,       1413, 7691,       1413,
+    7692,       1417, 7693,       1417, 7694,       1421,
+    7695,       1421, 7696,       1425,  // NOLINT
+    7697,       1425, 7698,       1429, 7699,       1429,
+    7700,       1433, 7701,       1433, 7702,       1437,
+    7703,       1437, 7704,       1441,  // NOLINT
+    7705,       1441, 7706,       1445, 7707,       1445,
+    7708,       1449, 7709,       1449, 7710,       1453,
+    7711,       1453, 7712,       1457,  // NOLINT
+    7713,       1457, 7714,       1461, 7715,       1461,
+    7716,       1465, 7717,       1465, 7718,       1469,
+    7719,       1469, 7720,       1473,  // NOLINT
+    7721,       1473, 7722,       1477, 7723,       1477,
+    7724,       1481, 7725,       1481, 7726,       1485,
+    7727,       1485, 7728,       1489,  // NOLINT
+    7729,       1489, 7730,       1493, 7731,       1493,
+    7732,       1497, 7733,       1497, 7734,       1501,
+    7735,       1501, 7736,       1505,  // NOLINT
+    7737,       1505, 7738,       1509, 7739,       1509,
+    7740,       1513, 7741,       1513, 7742,       1517,
+    7743,       1517, 7744,       1521,  // NOLINT
+    7745,       1521, 7746,       1525, 7747,       1525,
+    7748,       1529, 7749,       1529, 7750,       1533,
+    7751,       1533, 7752,       1537,  // NOLINT
+    7753,       1537, 7754,       1541, 7755,       1541,
+    7756,       1545, 7757,       1545, 7758,       1549,
+    7759,       1549, 7760,       1553,  // NOLINT
+    7761,       1553, 7762,       1557, 7763,       1557,
+    7764,       1561, 7765,       1561, 7766,       1565,
+    7767,       1565, 7768,       1569,  // NOLINT
+    7769,       1569, 7770,       1573, 7771,       1573,
+    7772,       1577, 7773,       1577, 7774,       1581,
+    7775,       1581, 7776,       1585,  // NOLINT
+    7777,       1585, 7778,       1589, 7779,       1589,
+    7780,       1593, 7781,       1593, 7782,       1597,
+    7783,       1597, 7784,       1601,  // NOLINT
+    7785,       1601, 7786,       1605, 7787,       1605,
+    7788,       1609, 7789,       1609, 7790,       1613,
+    7791,       1613, 7792,       1617,  // NOLINT
+    7793,       1617, 7794,       1621, 7795,       1621,
+    7796,       1625, 7797,       1625, 7798,       1629,
+    7799,       1629, 7800,       1633,  // NOLINT
+    7801,       1633, 7802,       1637, 7803,       1637,
+    7804,       1641, 7805,       1641, 7806,       1645,
+    7807,       1645, 7808,       1649,  // NOLINT
+    7809,       1649, 7810,       1653, 7811,       1653,
+    7812,       1657, 7813,       1657, 7814,       1661,
+    7815,       1661, 7816,       1665,  // NOLINT
+    7817,       1665, 7818,       1669, 7819,       1669,
+    7820,       1673, 7821,       1673, 7822,       1677,
+    7823,       1677, 7824,       1681,  // NOLINT
+    7825,       1681, 7826,       1685, 7827,       1685,
+    7828,       1689, 7829,       1689, 7835,       1585,
+    7840,       1693, 7841,       1693,  // NOLINT
+    7842,       1697, 7843,       1697, 7844,       1701,
+    7845,       1701, 7846,       1705, 7847,       1705,
+    7848,       1709, 7849,       1709,  // NOLINT
+    7850,       1713, 7851,       1713, 7852,       1717,
+    7853,       1717, 7854,       1721, 7855,       1721,
+    7856,       1725, 7857,       1725,  // NOLINT
+    7858,       1729, 7859,       1729, 7860,       1733,
+    7861,       1733, 7862,       1737, 7863,       1737,
+    7864,       1741, 7865,       1741,  // NOLINT
+    7866,       1745, 7867,       1745, 7868,       1749,
+    7869,       1749, 7870,       1753, 7871,       1753,
+    7872,       1757, 7873,       1757,  // NOLINT
+    7874,       1761, 7875,       1761, 7876,       1765,
+    7877,       1765, 7878,       1769, 7879,       1769,
+    7880,       1773, 7881,       1773,  // NOLINT
+    7882,       1777, 7883,       1777, 7884,       1781,
+    7885,       1781, 7886,       1785, 7887,       1785,
+    7888,       1789, 7889,       1789,  // NOLINT
+    7890,       1793, 7891,       1793, 7892,       1797,
+    7893,       1797, 7894,       1801, 7895,       1801,
+    7896,       1805, 7897,       1805,  // NOLINT
+    7898,       1809, 7899,       1809, 7900,       1813,
+    7901,       1813, 7902,       1817, 7903,       1817,
+    7904,       1821, 7905,       1821,  // NOLINT
+    7906,       1825, 7907,       1825, 7908,       1829,
+    7909,       1829, 7910,       1833, 7911,       1833,
+    7912,       1837, 7913,       1837,  // NOLINT
+    7914,       1841, 7915,       1841, 7916,       1845,
+    7917,       1845, 7918,       1849, 7919,       1849,
+    7920,       1853, 7921,       1853,  // NOLINT
+    7922,       1857, 7923,       1857, 7924,       1861,
+    7925,       1861, 7926,       1865, 7927,       1865,
+    7928,       1869, 7929,       1869,  // NOLINT
+    7930,       1873, 7931,       1873, 7932,       1877,
+    7933,       1877, 7934,       1881, 7935,       1881,
+    1073749760, 1885, 7943,       1889,  // NOLINT
+    1073749768, 1885, 7951,       1889, 1073749776, 1893,
+    7957,       1897, 1073749784, 1893, 7965,       1897,
+    1073749792, 1901, 7975,       1905,  // NOLINT
+    1073749800, 1901, 7983,       1905, 1073749808, 1909,
+    7991,       1913, 1073749816, 1909, 7999,       1913,
+    1073749824, 1917, 8005,       1921,  // NOLINT
+    1073749832, 1917, 8013,       1921, 8017,       1925,
+    8019,       1929, 8021,       1933, 8023,       1937,
+    8025,       1925, 8027,       1929,  // NOLINT
+    8029,       1933, 8031,       1937, 1073749856, 1941,
+    8039,       1945, 1073749864, 1941, 8047,       1945,
+    1073749872, 1949, 8049,       1953,  // NOLINT
+    1073749874, 1957, 8053,       1961, 1073749878, 1965,
+    8055,       1969, 1073749880, 1973, 8057,       1977,
+    1073749882, 1981, 8059,       1985,  // NOLINT
+    1073749884, 1989, 8061,       1993, 1073749936, 1997,
+    8113,       2001, 1073749944, 1997, 8121,       2001,
+    1073749946, 1949, 8123,       1953,  // NOLINT
+    8126,       749,  1073749960, 1957, 8139,       1961,
+    1073749968, 2005, 8145,       2009, 1073749976, 2005,
+    8153,       2009, 1073749978, 1965,  // NOLINT
+    8155,       1969, 1073749984, 2013, 8161,       2017,
+    8165,       2021, 1073749992, 2013, 8169,       2017,
+    1073749994, 1981, 8171,       1985,  // NOLINT
+    8172,       2021, 1073750008, 1973, 8185,       1977,
+    1073750010, 1989, 8187,       1993};  // NOLINT
+static const MultiCharacterSpecialCase<2>
+    kEcma262UnCanonicalizeMultiStrings1[83] = {  // NOLINT
+        {{8498, 8526}},   {{8544, 8560}},   {{8559, 8575}},
+        {{8579, 8580}},  // NOLINT
+        {{9398, 9424}},   {{9423, 9449}},   {{11264, 11312}},
+        {{11310, 11358}},  // NOLINT
+        {{11360, 11361}}, {{619, 11362}},   {{7549, 11363}},
+        {{637, 11364}},  // NOLINT
+        {{570, 11365}},   {{574, 11366}},   {{11367, 11368}},
+        {{11369, 11370}},  // NOLINT
+        {{11371, 11372}}, {{593, 11373}},   {{625, 11374}},
+        {{592, 11375}},  // NOLINT
+        {{594, 11376}},   {{11378, 11379}}, {{11381, 11382}},
+        {{575, 11390}},  // NOLINT
+        {{576, 11391}},   {{11392, 11393}}, {{11394, 11395}},
+        {{11396, 11397}},  // NOLINT
+        {{11398, 11399}}, {{11400, 11401}}, {{11402, 11403}},
+        {{11404, 11405}},  // NOLINT
+        {{11406, 11407}}, {{11408, 11409}}, {{11410, 11411}},
+        {{11412, 11413}},  // NOLINT
+        {{11414, 11415}}, {{11416, 11417}}, {{11418, 11419}},
+        {{11420, 11421}},  // NOLINT
+        {{11422, 11423}}, {{11424, 11425}}, {{11426, 11427}},
+        {{11428, 11429}},  // NOLINT
+        {{11430, 11431}}, {{11432, 11433}}, {{11434, 11435}},
+        {{11436, 11437}},  // NOLINT
+        {{11438, 11439}}, {{11440, 11441}}, {{11442, 11443}},
+        {{11444, 11445}},  // NOLINT
+        {{11446, 11447}}, {{11448, 11449}}, {{11450, 11451}},
+        {{11452, 11453}},  // NOLINT
+        {{11454, 11455}}, {{11456, 11457}}, {{11458, 11459}},
+        {{11460, 11461}},  // NOLINT
+        {{11462, 11463}}, {{11464, 11465}}, {{11466, 11467}},
+        {{11468, 11469}},  // NOLINT
+        {{11470, 11471}}, {{11472, 11473}}, {{11474, 11475}},
+        {{11476, 11477}},  // NOLINT
+        {{11478, 11479}}, {{11480, 11481}}, {{11482, 11483}},
+        {{11484, 11485}},  // NOLINT
+        {{11486, 11487}}, {{11488, 11489}}, {{11490, 11491}},
+        {{11499, 11500}},  // NOLINT
+        {{11501, 11502}}, {{11506, 11507}}, {{4256, 11520}},
+        {{4293, 11557}},                                       // NOLINT
+        {{4295, 11559}},  {{4301, 11565}},  {{kSentinel}}};    // NOLINT
+static const uint16_t kEcma262UnCanonicalizeTable1Size = 149;  // NOLINT
+static const int32_t kEcma262UnCanonicalizeTable1[298] = {
+    306,        1,   334,        1,   1073742176, 5,   367,  9,
+    1073742192, 5,   383,        9,   387,        13,  388,  13,  // NOLINT
+    1073743030, 17,  1231,       21,  1073743056, 17,  1257, 21,
+    1073744896, 25,  3118,       29,  1073744944, 25,  3166, 29,  // NOLINT
+    3168,       33,  3169,       33,  3170,       37,  3171, 41,
+    3172,       45,  3173,       49,  3174,       53,  3175, 57,  // NOLINT
+    3176,       57,  3177,       61,  3178,       61,  3179, 65,
+    3180,       65,  3181,       69,  3182,       73,  3183, 77,  // NOLINT
+    3184,       81,  3186,       85,  3187,       85,  3189, 89,
+    3190,       89,  1073745022, 93,  3199,       97,  3200, 101,  // NOLINT
+    3201,       101, 3202,       105, 3203,       105, 3204, 109,
+    3205,       109, 3206,       113, 3207,       113, 3208, 117,  // NOLINT
+    3209,       117, 3210,       121, 3211,       121, 3212, 125,
+    3213,       125, 3214,       129, 3215,       129, 3216, 133,  // NOLINT
+    3217,       133, 3218,       137, 3219,       137, 3220, 141,
+    3221,       141, 3222,       145, 3223,       145, 3224, 149,  // NOLINT
+    3225,       149, 3226,       153, 3227,       153, 3228, 157,
+    3229,       157, 3230,       161, 3231,       161, 3232, 165,  // NOLINT
+    3233,       165, 3234,       169, 3235,       169, 3236, 173,
+    3237,       173, 3238,       177, 3239,       177, 3240, 181,  // NOLINT
+    3241,       181, 3242,       185, 3243,       185, 3244, 189,
+    3245,       189, 3246,       193, 3247,       193, 3248, 197,  // NOLINT
+    3249,       197, 3250,       201, 3251,       201, 3252, 205,
+    3253,       205, 3254,       209, 3255,       209, 3256, 213,  // NOLINT
+    3257,       213, 3258,       217, 3259,       217, 3260, 221,
+    3261,       221, 3262,       225, 3263,       225, 3264, 229,  // NOLINT
+    3265,       229, 3266,       233, 3267,       233, 3268, 237,
+    3269,       237, 3270,       241, 3271,       241, 3272, 245,  // NOLINT
+    3273,       245, 3274,       249, 3275,       249, 3276, 253,
+    3277,       253, 3278,       257, 3279,       257, 3280, 261,  // NOLINT
+    3281,       261, 3282,       265, 3283,       265, 3284, 269,
+    3285,       269, 3286,       273, 3287,       273, 3288, 277,  // NOLINT
+    3289,       277, 3290,       281, 3291,       281, 3292, 285,
+    3293,       285, 3294,       289, 3295,       289, 3296, 293,  // NOLINT
+    3297,       293, 3298,       297, 3299,       297, 3307, 301,
+    3308,       301, 3309,       305, 3310,       305, 3314, 309,  // NOLINT
+    3315,       309, 1073745152, 313, 3365,       317, 3367, 321,
+    3373,       325};  // NOLINT
+static const MultiCharacterSpecialCase<2>
+    kEcma262UnCanonicalizeMultiStrings5[104] = {  // NOLINT
+        {{42560, 42561}}, {{42562, 42563}},
+        {{42564, 42565}}, {{42566, 42567}},  // NOLINT
+        {{42568, 42569}}, {{42570, 42571}},
+        {{42572, 42573}}, {{42574, 42575}},  // NOLINT
+        {{42576, 42577}}, {{42578, 42579}},
+        {{42580, 42581}}, {{42582, 42583}},  // NOLINT
+        {{42584, 42585}}, {{42586, 42587}},
+        {{42588, 42589}}, {{42590, 42591}},  // NOLINT
+        {{42592, 42593}}, {{42594, 42595}},
+        {{42596, 42597}}, {{42598, 42599}},  // NOLINT
+        {{42600, 42601}}, {{42602, 42603}},
+        {{42604, 42605}}, {{42624, 42625}},  // NOLINT
+        {{42626, 42627}}, {{42628, 42629}},
+        {{42630, 42631}}, {{42632, 42633}},  // NOLINT
+        {{42634, 42635}}, {{42636, 42637}},
+        {{42638, 42639}}, {{42640, 42641}},  // NOLINT
+        {{42642, 42643}}, {{42644, 42645}},
+        {{42646, 42647}}, {{42648, 42649}},  // NOLINT
+        {{42650, 42651}}, {{42786, 42787}},
+        {{42788, 42789}}, {{42790, 42791}},  // NOLINT
+        {{42792, 42793}}, {{42794, 42795}},
+        {{42796, 42797}}, {{42798, 42799}},  // NOLINT
+        {{42802, 42803}}, {{42804, 42805}},
+        {{42806, 42807}}, {{42808, 42809}},  // NOLINT
+        {{42810, 42811}}, {{42812, 42813}},
+        {{42814, 42815}}, {{42816, 42817}},  // NOLINT
+        {{42818, 42819}}, {{42820, 42821}},
+        {{42822, 42823}}, {{42824, 42825}},  // NOLINT
+        {{42826, 42827}}, {{42828, 42829}},
+        {{42830, 42831}}, {{42832, 42833}},  // NOLINT
+        {{42834, 42835}}, {{42836, 42837}},
+        {{42838, 42839}}, {{42840, 42841}},  // NOLINT
+        {{42842, 42843}}, {{42844, 42845}},
+        {{42846, 42847}}, {{42848, 42849}},  // NOLINT
+        {{42850, 42851}}, {{42852, 42853}},
+        {{42854, 42855}}, {{42856, 42857}},  // NOLINT
+        {{42858, 42859}}, {{42860, 42861}},
+        {{42862, 42863}}, {{42873, 42874}},  // NOLINT
+        {{42875, 42876}}, {{7545, 42877}},
+        {{42878, 42879}}, {{42880, 42881}},  // NOLINT
+        {{42882, 42883}}, {{42884, 42885}},
+        {{42886, 42887}}, {{42891, 42892}},  // NOLINT
+        {{613, 42893}},   {{42896, 42897}},
+        {{42898, 42899}}, {{42902, 42903}},  // NOLINT
+        {{42904, 42905}}, {{42906, 42907}},
+        {{42908, 42909}}, {{42910, 42911}},  // NOLINT
+        {{42912, 42913}}, {{42914, 42915}},
+        {{42916, 42917}}, {{42918, 42919}},  // NOLINT
+        {{42920, 42921}}, {{614, 42922}},
+        {{604, 42923}},   {{609, 42924}},  // NOLINT
+        {{620, 42925}},   {{670, 42928}},
+        {{647, 42929}},   {{kSentinel}}};                      // NOLINT
+static const uint16_t kEcma262UnCanonicalizeTable5Size = 198;  // NOLINT
+static const int32_t
+    kEcma262UnCanonicalizeTable5[396] =
+        {1600, 1,   1601, 1,   1602, 5,   1603, 5,
+         1604, 9,   1605, 9,   1606, 13,  1607, 13,  // NOLINT
+         1608, 17,  1609, 17,  1610, 21,  1611, 21,
+         1612, 25,  1613, 25,  1614, 29,  1615, 29,  // NOLINT
+         1616, 33,  1617, 33,  1618, 37,  1619, 37,
+         1620, 41,  1621, 41,  1622, 45,  1623, 45,  // NOLINT
+         1624, 49,  1625, 49,  1626, 53,  1627, 53,
+         1628, 57,  1629, 57,  1630, 61,  1631, 61,  // NOLINT
+         1632, 65,  1633, 65,  1634, 69,  1635, 69,
+         1636, 73,  1637, 73,  1638, 77,  1639, 77,  // NOLINT
+         1640, 81,  1641, 81,  1642, 85,  1643, 85,
+         1644, 89,  1645, 89,  1664, 93,  1665, 93,  // NOLINT
+         1666, 97,  1667, 97,  1668, 101, 1669, 101,
+         1670, 105, 1671, 105, 1672, 109, 1673, 109,  // NOLINT
+         1674, 113, 1675, 113, 1676, 117, 1677, 117,
+         1678, 121, 1679, 121, 1680, 125, 1681, 125,  // NOLINT
+         1682, 129, 1683, 129, 1684, 133, 1685, 133,
+         1686, 137, 1687, 137, 1688, 141, 1689, 141,  // NOLINT
+         1690, 145, 1691, 145, 1826, 149, 1827, 149,
+         1828, 153, 1829, 153, 1830, 157, 1831, 157,  // NOLINT
+         1832, 161, 1833, 161, 1834, 165, 1835, 165,
+         1836, 169, 1837, 169, 1838, 173, 1839, 173,  // NOLINT
+         1842, 177, 1843, 177, 1844, 181, 1845, 181,
+         1846, 185, 1847, 185, 1848, 189, 1849, 189,  // NOLINT
+         1850, 193, 1851, 193, 1852, 197, 1853, 197,
+         1854, 201, 1855, 201, 1856, 205, 1857, 205,  // NOLINT
+         1858, 209, 1859, 209, 1860, 213, 1861, 213,
+         1862, 217, 1863, 217, 1864, 221, 1865, 221,  // NOLINT
+         1866, 225, 1867, 225, 1868, 229, 1869, 229,
+         1870, 233, 1871, 233, 1872, 237, 1873, 237,  // NOLINT
+         1874, 241, 1875, 241, 1876, 245, 1877, 245,
+         1878, 249, 1879, 249, 1880, 253, 1881, 253,  // NOLINT
+         1882, 257, 1883, 257, 1884, 261, 1885, 261,
+         1886, 265, 1887, 265, 1888, 269, 1889, 269,  // NOLINT
+         1890, 273, 1891, 273, 1892, 277, 1893, 277,
+         1894, 281, 1895, 281, 1896, 285, 1897, 285,  // NOLINT
+         1898, 289, 1899, 289, 1900, 293, 1901, 293,
+         1902, 297, 1903, 297, 1913, 301, 1914, 301,  // NOLINT
+         1915, 305, 1916, 305, 1917, 309, 1918, 313,
+         1919, 313, 1920, 317, 1921, 317, 1922, 321,  // NOLINT
+         1923, 321, 1924, 325, 1925, 325, 1926, 329,
+         1927, 329, 1931, 333, 1932, 333, 1933, 337,  // NOLINT
+         1936, 341, 1937, 341, 1938, 345, 1939, 345,
+         1942, 349, 1943, 349, 1944, 353, 1945, 353,  // NOLINT
+         1946, 357, 1947, 357, 1948, 361, 1949, 361,
+         1950, 365, 1951, 365, 1952, 369, 1953, 369,  // NOLINT
+         1954, 373, 1955, 373, 1956, 377, 1957, 377,
+         1958, 381, 1959, 381, 1960, 385, 1961, 385,  // NOLINT
+         1962, 389, 1963, 393, 1964, 397, 1965, 401,
+         1968, 405, 1969, 409};  // NOLINT
+static const MultiCharacterSpecialCase<2>
+    kEcma262UnCanonicalizeMultiStrings7[3] = {  // NOLINT
+        {{65313, 65345}},
+        {{65338, 65370}},
+        {{kSentinel}}};                                      // NOLINT
+static const uint16_t kEcma262UnCanonicalizeTable7Size = 4;  // NOLINT
+static const int32_t kEcma262UnCanonicalizeTable7[8] = {
+    1073749793, 1, 7994, 5, 1073749825, 1, 8026, 5};  // NOLINT
+int Ecma262UnCanonicalize::Convert(uchar c, uchar n, uchar* result,
+                                   bool* allow_caching_ptr) {
+  int chunk_index = c >> 13;
+  switch (chunk_index) {
+    case 0:
+      return LookupMapping<true>(
+          kEcma262UnCanonicalizeTable0, kEcma262UnCanonicalizeTable0Size,
+          kEcma262UnCanonicalizeMultiStrings0, c, n, result, allow_caching_ptr);
+    case 1:
+      return LookupMapping<true>(
+          kEcma262UnCanonicalizeTable1, kEcma262UnCanonicalizeTable1Size,
+          kEcma262UnCanonicalizeMultiStrings1, c, n, result, allow_caching_ptr);
+    case 5:
+      return LookupMapping<true>(
+          kEcma262UnCanonicalizeTable5, kEcma262UnCanonicalizeTable5Size,
+          kEcma262UnCanonicalizeMultiStrings5, c, n, result, allow_caching_ptr);
+    case 7:
+      return LookupMapping<true>(
+          kEcma262UnCanonicalizeTable7, kEcma262UnCanonicalizeTable7Size,
+          kEcma262UnCanonicalizeMultiStrings7, c, n, result, allow_caching_ptr);
+    default:
+      return 0;
+  }
+}
+
+static const MultiCharacterSpecialCase<1>
+    kCanonicalizationRangeMultiStrings0[1] = {                // NOLINT
+        {{kSentinel}}};                                       // NOLINT
+static const uint16_t kCanonicalizationRangeTable0Size = 70;  // NOLINT
+static const int32_t kCanonicalizationRangeTable0[140] = {
+    1073741889, 100, 90,   0, 1073741921, 100, 122,  0,
+    1073742016, 88,  214,  0, 1073742040, 24,  222,  0,  // NOLINT
+    1073742048, 88,  246,  0, 1073742072, 24,  254,  0,
+    1073742715, 8,   893,  0, 1073742728, 8,   906,  0,  // NOLINT
+    1073742749, 8,   927,  0, 1073742759, 16,  939,  0,
+    1073742765, 8,   943,  0, 1073742781, 8,   959,  0,  // NOLINT
+    1073742791, 16,  971,  0, 1073742845, 8,   1023, 0,
+    1073742848, 60,  1039, 0, 1073742864, 124, 1071, 0,  // NOLINT
+    1073742896, 124, 1103, 0, 1073742928, 60,  1119, 0,
+    1073743153, 148, 1366, 0, 1073743201, 148, 1414, 0,  // NOLINT
+    1073746080, 148, 4293, 0, 1073749760, 28,  7943, 0,
+    1073749768, 28,  7951, 0, 1073749776, 20,  7957, 0,  // NOLINT
+    1073749784, 20,  7965, 0, 1073749792, 28,  7975, 0,
+    1073749800, 28,  7983, 0, 1073749808, 28,  7991, 0,  // NOLINT
+    1073749816, 28,  7999, 0, 1073749824, 20,  8005, 0,
+    1073749832, 20,  8013, 0, 1073749856, 28,  8039, 0,  // NOLINT
+    1073749864, 28,  8047, 0, 1073749874, 12,  8053, 0,
+    1073749960, 12,  8139, 0};  // NOLINT
+static const MultiCharacterSpecialCase<1>
+    kCanonicalizationRangeMultiStrings1[1] = {                // NOLINT
+        {{kSentinel}}};                                       // NOLINT
+static const uint16_t kCanonicalizationRangeTable1Size = 14;  // NOLINT
+static const int32_t kCanonicalizationRangeTable1[28] = {
+    1073742176, 60,  367,  0, 1073742192, 60,  383,  0,
+    1073743030, 100, 1231, 0, 1073743056, 100, 1257, 0,  // NOLINT
+    1073744896, 184, 3118, 0, 1073744944, 184, 3166, 0,
+    1073745152, 148, 3365, 0};  // NOLINT
+static const MultiCharacterSpecialCase<1>
+    kCanonicalizationRangeMultiStrings7[1] = {               // NOLINT
+        {{kSentinel}}};                                      // NOLINT
+static const uint16_t kCanonicalizationRangeTable7Size = 4;  // NOLINT
+static const int32_t kCanonicalizationRangeTable7[8] = {
+    1073749793, 100, 7994, 0, 1073749825, 100, 8026, 0};  // NOLINT
+int CanonicalizationRange::Convert(uchar c, uchar n, uchar* result,
+                                   bool* allow_caching_ptr) {
+  int chunk_index = c >> 13;
+  switch (chunk_index) {
+    case 0:
+      return LookupMapping<false>(
+          kCanonicalizationRangeTable0, kCanonicalizationRangeTable0Size,
+          kCanonicalizationRangeMultiStrings0, c, n, result, allow_caching_ptr);
+    case 1:
+      return LookupMapping<false>(
+          kCanonicalizationRangeTable1, kCanonicalizationRangeTable1Size,
+          kCanonicalizationRangeMultiStrings1, c, n, result, allow_caching_ptr);
+    case 7:
+      return LookupMapping<false>(
+          kCanonicalizationRangeTable7, kCanonicalizationRangeTable7Size,
+          kCanonicalizationRangeMultiStrings7, c, n, result, allow_caching_ptr);
+    default:
+      return 0;
+  }
+}
+
+#endif  // !V8_INTL_SUPPORT
+
+}  // namespace unibrow
+}  // namespace v8
diff -Nrup mozilla/js/src/irregexp/util/VectorShim.h mozilla-OK/js/src/irregexp/util/VectorShim.h
--- mozilla/js/src/irregexp/util/VectorShim.h	1970-01-01 03:00:00.000000000 +0300
+++ mozilla-OK/js/src/irregexp/util/VectorShim.h	2022-04-22 05:08:45.974075110 +0300
@@ -0,0 +1,215 @@
+// Copyright 2014 the V8 project authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef V8_UTIL_VECTOR_H_
+#define V8_UTIL_VECTOR_H_
+
+#include <algorithm>
+#include <cstring>
+#include <iterator>
+#include <memory>
+
+#include "jsalloc.h"
+#include "js/Utility.h"
+#include "js/Vector.h"
+
+namespace v8 {
+namespace internal {
+
+//////////////////////////////////////////////////
+
+// Adapted from:
+// https://github.com/v8/v8/blob/5f69bbc233c2d1baf149faf869a7901603929914/src/utils/allocation.h#L36-L58
+
+template <typename T>
+T* NewArray(size_t size) {
+  static_assert(std::is_pod<T>::value, "");
+  js::AutoEnterOOMUnsafeRegion oomUnsafe;
+  T* result = static_cast<T*>(js_malloc(size * sizeof(T)));
+  if (!result) {
+    oomUnsafe.crash("Irregexp NewArray");
+  }
+  return result;
+}
+
+template <typename T>
+void DeleteArray(T* array) {
+  js_free(array);
+}
+
+//////////////////////////////////////////////////
+
+// A non-resizable vector containing a pointer and a length.
+// The Vector may or may not own the pointer, depending on context.
+// Origin:
+// https://github.com/v8/v8/blob/5f69bbc233c2d1baf149faf869a7901603929914/src/utils/vector.h#L20-L134
+
+template <typename T>
+class Vector {
+ public:
+  Vector() : start_(nullptr), length_(0) {}
+
+  Vector(T* data, size_t length) : start_(data), length_(length) {
+    MOZ_ASSERT_IF(length != 0, data != nullptr);
+  }
+
+  static Vector<T> New(size_t length) {
+    return Vector<T>(NewArray<T>(length), length);
+  }
+
+  // Returns a vector using the same backing storage as this one,
+  // spanning from and including 'from', to but not including 'to'.
+  Vector<T> SubVector(size_t from, size_t to) const {
+    MOZ_ASSERT(from <= to);
+    MOZ_ASSERT(to <= length_);
+    return Vector<T>(begin() + from, to - from);
+  }
+
+  // Returns the length of the vector. Only use this if you really need an
+  // integer return value. Use {size()} otherwise.
+  int length() const {
+    MOZ_ASSERT(length_ <= static_cast<size_t>(std::numeric_limits<int>::max()));
+    return static_cast<int>(length_);
+  }
+
+  // Returns the length of the vector as a size_t.
+  constexpr size_t size() const { return length_; }
+
+  // Returns whether or not the vector is empty.
+  constexpr bool empty() const { return length_ == 0; }
+
+  // Access individual vector elements - checks bounds in debug mode.
+  T& operator[](size_t index) const {
+    MOZ_ASSERT(index < length_);
+    return start_[index];
+  }
+
+  const T& at(size_t index) const { return operator[](index); }
+
+  T& first() { return start_[0]; }
+
+  T& last() {
+    MOZ_ASSERT(length_ > 0);
+    return start_[length_ - 1];
+  }
+
+  // Returns a pointer to the start of the data in the vector.
+  constexpr T* begin() const { return start_; }
+
+  // Returns a pointer past the end of the data in the vector.
+  constexpr T* end() const { return start_ + length_; }
+
+  // Returns a clone of this vector with a new backing store.
+  Vector<T> Clone() const {
+    T* result = NewArray<T>(length_);
+    for (size_t i = 0; i < length_; i++) result[i] = start_[i];
+    return Vector<T>(result, length_);
+  }
+
+  void Truncate(size_t length) {
+    MOZ_ASSERT(length <= length_);
+    length_ = length;
+  }
+
+  // Releases the array underlying this vector. Once disposed the
+  // vector is empty.
+  void Dispose() {
+    DeleteArray(start_);
+    start_ = nullptr;
+    length_ = 0;
+  }
+
+  Vector<T> operator+(size_t offset) {
+    MOZ_ASSERT(offset <= length_);
+    return Vector<T>(start_ + offset, length_ - offset);
+  }
+
+  Vector<T> operator+=(size_t offset) {
+    MOZ_ASSERT(offset <= length_);
+    start_ += offset;
+    length_ -= offset;
+    return *this;
+  }
+
+  // Implicit conversion from Vector<T> to Vector<const T>.
+  inline operator Vector<const T>() const {
+    return Vector<const T>::cast(*this);
+  }
+
+  template <typename S>
+  static constexpr Vector<T> cast(Vector<S> input) {
+    return Vector<T>(reinterpret_cast<T*>(input.begin()),
+                     input.length() * sizeof(S) / sizeof(T));
+  }
+
+  bool operator==(const Vector<const T> other) const {
+    if (length_ != other.length_) return false;
+    if (start_ == other.start_) return true;
+    for (size_t i = 0; i < length_; ++i) {
+      if (start_[i] != other.start_[i]) {
+        return false;
+      }
+    }
+    return true;
+  }
+
+ private:
+  T* start_;
+  size_t length_;
+};
+
+// The resulting vector does not contain a null-termination byte. If you want
+// the null byte, use ArrayVector("foo").
+inline Vector<const char> CStrVector(const char* data) {
+  return Vector<const char>(data, strlen(data));
+}
+
+}  // namespace internal
+
+namespace base {
+
+// SmallVector uses inline storage first, and reallocates when full.
+// It is basically equivalent to js::Vector, and is implemented
+// as a thin wrapper.
+// V8's implementation:
+// https://github.com/v8/v8/blob/master/src/base/small-vector.h
+template <typename T, size_t kSize>
+class SmallVector {
+ public:
+  SmallVector() = default;
+  SmallVector(size_t size) { resize_no_init(size); }
+
+  inline bool empty() const { return inner_.empty(); }
+  inline const T& back() const { return inner_.back(); }
+  inline void pop_back() { inner_.popBack(); };
+  template <typename... Args>
+  inline void emplace_back(Args&&... args) {
+    js::AutoEnterOOMUnsafeRegion oomUnsafe;
+    if (!inner_.emplaceBack(args...)) {
+      oomUnsafe.crash("Irregexp SmallVector emplace_back");
+    }
+  };
+  inline size_t size() const { return inner_.length(); }
+  inline const T& at(size_t index) const { return inner_[index]; }
+  T* data() { return inner_.begin(); }
+
+  T& operator[](size_t index) { return inner_[index]; }
+  const T& operator[](size_t index) const { return inner_[index]; }
+
+  void resize_no_init(size_t new_size) {
+    js::AutoEnterOOMUnsafeRegion oomUnsafe;
+    if (!inner_.resizeUninitialized(new_size)) {
+      oomUnsafe.crash("Irregexp SmallVector resize");
+    }
+  }
+
+ private:
+  js::Vector<T, kSize, js::SystemAllocPolicy> inner_;
+};
+
+}  // namespace base
+
+}  // namespace v8
+
+#endif  // V8_UTIL_VECTOR_H_
diff -Nrup mozilla/js/src/irregexp/util/ZoneShim.h mozilla-OK/js/src/irregexp/util/ZoneShim.h
--- mozilla/js/src/irregexp/util/ZoneShim.h	1970-01-01 03:00:00.000000000 +0300
+++ mozilla-OK/js/src/irregexp/util/ZoneShim.h	2022-04-22 05:08:42.178101735 +0300
@@ -0,0 +1,376 @@
+// Copyright 2019 the V8 project authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef V8_UTIL_ZONE_H_
+#define V8_UTIL_ZONE_H_
+
+#include <list>
+#include <map>
+#include <set>
+#include <unordered_map>
+#include <vector>
+
+#include "ds/LifoAlloc.h"
+#include "ds/Sort.h"
+#include "irregexp/util/VectorShim.h"
+
+namespace v8 {
+namespace internal {
+
+// V8::Zone ~= LifoAlloc
+class Zone {
+ public:
+  Zone(js::LifoAlloc& alloc) : lifoAlloc_(alloc) {}
+
+  template <typename T, typename... Args>
+  T* New(Args&&... args) {
+    js::LifoAlloc::AutoFallibleScope fallible(&lifoAlloc_);
+    js::AutoEnterOOMUnsafeRegion oomUnsafe;
+    void* memory = lifoAlloc_.alloc(sizeof(T));
+    if (!memory) {
+      oomUnsafe.crash("Irregexp Zone::New");
+    }
+    return new (memory) T(std::forward<Args>(args)...);
+  }
+
+  // Allocates uninitialized memory for 'length' number of T instances.
+  template <typename T>
+  T* NewArray(size_t length) {
+    js::LifoAlloc::AutoFallibleScope fallible(&lifoAlloc_);
+    js::AutoEnterOOMUnsafeRegion oomUnsafe;
+    void* memory = lifoAlloc_.alloc(length * sizeof(T));
+    if (!memory) {
+      oomUnsafe.crash("Irregexp Zone::New");
+    }
+    return static_cast<T*>(memory);
+  }
+
+  void DeleteAll() { lifoAlloc_.freeAll(); }
+
+  // Returns true if the total memory allocated exceeds a threshold.
+  static const size_t kExcessLimit = 256 * 1024 * 1024;
+  bool excess_allocation() const {
+    return lifoAlloc_.computedSizeOfExcludingThis() > kExcessLimit;
+  }
+
+ private:
+  js::LifoAlloc& lifoAlloc_;
+};
+
+// Superclass for classes allocated in a Zone.
+// Based on: https://github.com/v8/v8/blob/master/src/zone/zone.h
+class ZoneObject {
+ public:
+  // new (zone) SomeObject(...) was the old pattern.
+  // Delete the constructor to avoid using it accidentally.
+  void* operator new(size_t size, Zone* zone) = delete;
+
+  // Allow non-allocating placement new
+  void* operator new(size_t size, void* ptr) { return ptr; }
+
+  // Ideally, the delete operator should be private instead of
+  // public, but unfortunately the compiler sometimes synthesizes
+  // (unused) destructors for classes derived from ZoneObject, which
+  // require the operator to be visible. MSVC requires the delete
+  // operator to be public.
+
+  // ZoneObjects should never be deleted individually; use
+  // Zone::DeleteAll() to delete all zone objects in one go.
+  void operator delete(void*, size_t) { MOZ_CRASH("unreachable"); }
+  void operator delete(void* pointer, Zone* zone) { MOZ_CRASH("unreachable"); }
+};
+
+// ZoneLists are growable lists with constant-time access to the
+// elements. The list itself and all its elements are allocated in the
+// Zone. ZoneLists cannot be deleted individually; you can delete all
+// objects in the Zone by calling Zone::DeleteAll().
+// Used throughout irregexp.
+// Based on: https://github.com/v8/v8/blob/master/src/zone/zone-list.h
+template <typename T>
+class ZoneList final : public ZoneObject {
+ public:
+  // Construct a new ZoneList with the given capacity; the length is
+  // always zero. The capacity must be non-negative.
+  ZoneList(int capacity, Zone* zone) : capacity_(capacity) {
+    data_ = (capacity_ > 0) ? zone->NewArray<T>(capacity_) : nullptr;
+  }
+  // Construct a new ZoneList by copying the elements of the given ZoneList.
+  ZoneList(const ZoneList<T>& other, Zone* zone)
+      : ZoneList(other.length(), zone) {
+    AddAll(other, zone);
+  }
+
+  // Returns a reference to the element at index i. This reference is not safe
+  // to use after operations that can change the list's backing store
+  // (e.g. Add).
+  inline T& operator[](int i) const {
+    MOZ_ASSERT(i >= 0);
+    MOZ_ASSERT(static_cast<unsigned>(i) < static_cast<unsigned>(length_));
+    return data_[i];
+  }
+  inline T& at(int i) const { return operator[](i); }
+  inline T& last() const { return at(length_ - 1); }
+  inline T& first() const { return at(0); }
+
+  using iterator = T*;
+  inline iterator begin() const { return &data_[0]; }
+  inline iterator end() const { return &data_[length_]; }
+
+  inline bool is_empty() const { return length_ == 0; }
+  inline int length() const { return length_; }
+  inline int capacity() const { return capacity_; }
+
+  Vector<T> ToVector() const { return Vector<T>(data_, length_); }
+  Vector<T> ToVector(int start, int length) const {
+    return Vector<T>(data_ + start, std::min(length_ - start, length));
+  }
+
+  Vector<const T> ToConstVector() const {
+    return Vector<const T>(data_, length_);
+  }
+
+  // Adds a copy of the given 'element' to the end of the list,
+  // expanding the list if necessary.
+  void Add(const T& element, Zone* zone) {
+    if (length_ < capacity_) {
+      data_[length_++] = element;
+    } else {
+      ZoneList<T>::ResizeAdd(element, zone);
+    }
+  }
+  // Add all the elements from the argument list to this list.
+  void AddAll(const ZoneList<T>& other, Zone* zone) {
+    AddAll(other.ToVector(), zone);
+  }
+  // Add all the elements from the vector to this list.
+  void AddAll(const Vector<T>& other, Zone* zone) {
+    int result_length = length_ + other.length();
+    if (capacity_ < result_length) {
+      Resize(result_length, zone);
+    }
+    if (std::is_fundamental<T>()) {
+      memcpy(data_ + length_, other.begin(), sizeof(*data_) * other.length());
+    } else {
+      for (int i = 0; i < other.length(); i++) {
+        data_[length_ + i] = other.at(i);
+      }
+    }
+    length_ = result_length;
+  }
+
+  // Overwrites the element at the specific index.
+  void Set(int index, const T& element) {
+    MOZ_ASSERT(index >= 0 && index <= length_);
+    data_[index] = element;
+  }
+
+  // Removes the i'th element without deleting it even if T is a
+  // pointer type; moves all elements above i "down". Returns the
+  // removed element.  This function's complexity is linear in the
+  // size of the list.
+  T Remove(int i) {
+    T element = at(i);
+    length_--;
+    while (i < length_) {
+      data_[i] = data_[i + 1];
+      i++;
+    }
+    return element;
+  }
+
+  // Removes the last element without deleting it even if T is a
+  // pointer type. Returns the removed element.
+  inline T RemoveLast() { return Remove(length_ - 1); }
+
+  // Clears the list by freeing the storage memory. If you want to keep the
+  // memory, use Rewind(0) instead. Be aware, that even if T is a
+  // pointer type, clearing the list doesn't delete the entries.
+  inline void Clear() {
+    data_ = nullptr;
+    capacity_ = 0;
+    length_ = 0;
+  }
+
+  // Drops all but the first 'pos' elements from the list.
+  inline void Rewind(int pos) {
+    MOZ_ASSERT(0 <= pos && pos <= length_);
+    length_ = pos;
+  }
+
+  inline bool Contains(const T& elm) const {
+    for (int i = 0; i < length_; i++) {
+      if (data_[i] == elm) return true;
+    }
+    return false;
+  }
+
+  template <typename CompareFunction>
+  void StableSort(CompareFunction cmp, size_t start, size_t length) {
+    js::AutoEnterOOMUnsafeRegion oomUnsafe;
+    T* scratch = static_cast<T*>(js_malloc(length * sizeof(T)));
+    if (!scratch) {
+      oomUnsafe.crash("Irregexp stable sort scratch space");
+    }
+    auto comparator = [cmp](const T& a, const T& b, bool* lessOrEqual) {
+      *lessOrEqual = cmp(&a, &b) <= 0;
+      return true;
+    };
+    MOZ_ALWAYS_TRUE(
+        js::MergeSort(begin() + start, length, scratch, comparator));
+    js_free(scratch);
+  }
+
+  void operator delete(void* pointer) { MOZ_CRASH("unreachable"); }
+  void operator delete(void* pointer, Zone* zone) { MOZ_CRASH("unreachable"); }
+
+ private:
+  T* data_ = nullptr;
+  int capacity_ = 0;
+  int length_ = 0;
+
+  // Increase the capacity of a full list, and add an element.
+  // List must be full already.
+  void ResizeAdd(const T& element, Zone* zone) {
+    MOZ_ASSERT(length_ >= capacity_);
+    // Grow the list capacity by 100%, but make sure to let it grow
+    // even when the capacity is zero (possible initial case).
+    int new_capacity = 1 + 2 * capacity_;
+    // Since the element reference could be an element of the list, copy
+    // it out of the old backing storage before resizing.
+    T temp = element;
+    Resize(new_capacity, zone);
+    data_[length_++] = temp;
+  }
+
+  // Resize the list.
+  void Resize(int new_capacity, Zone* zone) {
+    MOZ_ASSERT(length_ <= new_capacity);
+    static_assert(std::is_trivially_copyable<T>::value);
+    T* new_data = zone->NewArray<T>(new_capacity);
+    if (length_ > 0) {
+      memcpy(new_data, data_, length_ * sizeof(T));
+    }
+    data_ = new_data;
+    capacity_ = new_capacity;
+  }
+
+  ZoneList& operator=(const ZoneList&) = delete;
+  ZoneList() = delete;
+  ZoneList(const ZoneList&) = delete;
+};
+
+// Based on: https://github.com/v8/v8/blob/master/src/zone/zone-allocator.h
+template <typename T>
+class ZoneAllocator {
+ public:
+  using pointer = T*;
+  using const_pointer = const T*;
+  using reference = T&;
+  using const_reference = const T&;
+  using value_type = T;
+  using size_type = size_t;
+  using difference_type = ptrdiff_t;
+  template <class O>
+  struct rebind {
+    using other = ZoneAllocator<O>;
+  };
+
+  explicit ZoneAllocator(Zone* zone) : zone_(zone) {}
+  template <typename U>
+  ZoneAllocator(const ZoneAllocator<U>& other)
+      : ZoneAllocator<T>(other.zone_) {}
+  template <typename U>
+  friend class ZoneAllocator;
+
+  T* allocate(size_t n) { return zone_->NewArray<T>(n); }
+  void deallocate(T* p, size_t) {}  // noop for zones
+
+  bool operator==(ZoneAllocator const& other) const {
+    return zone_ == other.zone_;
+  }
+  bool operator!=(ZoneAllocator const& other) const {
+    return zone_ != other.zone_;
+  }
+
+ private:
+  Zone* zone_;
+};
+
+// Zone wrappers for std containers:
+// Origin:
+// https://github.com/v8/v8/blob/5e514a969376dc63517d575b062758efd36cd757/src/zone/zone-containers.h#L25-L169
+
+// A wrapper subclass for std::vector to make it easy to construct one
+// that uses a zone allocator.
+// Used throughout irregexp
+template <typename T>
+class ZoneVector : public std::vector<T, ZoneAllocator<T>> {
+ public:
+  ZoneVector(Zone* zone)
+      : std::vector<T, ZoneAllocator<T>>(ZoneAllocator<T>(zone)) {}
+
+  // Constructs a new vector and fills it with the contents of the range
+  // [first, last).
+  template <class Iter>
+  ZoneVector(Iter first, Iter last, Zone* zone)
+      : std::vector<T, ZoneAllocator<T>>(first, last, ZoneAllocator<T>(zone)) {}
+};
+
+// A wrapper subclass for std::list to make it easy to construct one
+// that uses a zone allocator.
+// Used in regexp-bytecode-peephole.cc
+template <typename T>
+class ZoneLinkedList : public std::list<T, ZoneAllocator<T>> {
+ public:
+  // Constructs an empty list.
+  explicit ZoneLinkedList(Zone* zone)
+      : std::list<T, ZoneAllocator<T>>(ZoneAllocator<T>(zone)) {}
+};
+
+// A wrapper subclass for std::set to make it easy to construct one that uses
+// a zone allocator.
+// Used in regexp-parser.cc
+template <typename K, typename Compare = std::less<K>>
+class ZoneSet : public std::set<K, Compare, ZoneAllocator<K>> {
+ public:
+  // Constructs an empty set.
+  explicit ZoneSet(Zone* zone)
+      : std::set<K, Compare, ZoneAllocator<K>>(Compare(),
+                                               ZoneAllocator<K>(zone)) {}
+};
+
+// A wrapper subclass for std::map to make it easy to construct one that uses
+// a zone allocator.
+// Used in regexp-bytecode-peephole.cc
+template <typename K, typename V, typename Compare = std::less<K>>
+class ZoneMap
+    : public std::map<K, V, Compare, ZoneAllocator<std::pair<const K, V>>> {
+ public:
+  // Constructs an empty map.
+  explicit ZoneMap(Zone* zone)
+      : std::map<K, V, Compare, ZoneAllocator<std::pair<const K, V>>>(
+            Compare(), ZoneAllocator<std::pair<const K, V>>(zone)) {}
+};
+
+// A wrapper subclass for std::unordered_map to make it easy to construct one
+// that uses a zone allocator.
+// Used in regexp-bytecode-peephole.cc
+template <typename K, typename V, typename Hash = std::hash<K>,
+          typename KeyEqual = std::equal_to<K>>
+class ZoneUnorderedMap
+    : public std::unordered_map<K, V, Hash, KeyEqual,
+                                ZoneAllocator<std::pair<const K, V>>> {
+ public:
+  // Constructs an empty map.
+  explicit ZoneUnorderedMap(Zone* zone, size_t bucket_count = 100)
+      : std::unordered_map<K, V, Hash, KeyEqual,
+                           ZoneAllocator<std::pair<const K, V>>>(
+            bucket_count, Hash(), KeyEqual(),
+            ZoneAllocator<std::pair<const K, V>>(zone)) {}
+};
+
+}  // namespace internal
+}  // namespace v8
+
+#endif  // V8_UTIL_FLAG_H_
diff -Nrup mozilla/js/src/jit/BaselineIC.cpp mozilla-OK/js/src/jit/BaselineIC.cpp
--- mozilla/js/src/jit/BaselineIC.cpp	2020-02-18 02:37:52.000000000 +0300
+++ mozilla-OK/js/src/jit/BaselineIC.cpp	2022-04-22 05:05:32.319432500 +0300
@@ -2112,6 +2112,11 @@ GetTemplateObjectForNative(JSContext* cx
         return !!res;
     }
 
+    if (native == js::intrinsic_NewRegExpStringIterator) {
+        res.set(NewRegExpStringIteratorObject(cx, TenuredObject));
+        return !!res;
+    }
+
     if (JitSupportsSimd() && GetTemplateObjectForSimd(cx, target, res))
        return !!res;
 
diff -Nrup mozilla/js/src/jit/CodeGenerator.cpp mozilla-OK/js/src/jit/CodeGenerator.cpp
--- mozilla/js/src/jit/CodeGenerator.cpp	2022-04-13 21:14:22.000000000 +0300
+++ mozilla-OK/js/src/jit/CodeGenerator.cpp	2022-04-22 05:08:30.459183847 +0300
@@ -26,7 +26,7 @@
 #include "builtin/SelfHostingDefines.h"
 #include "builtin/TypedObject.h"
 #include "gc/Nursery.h"
-#include "irregexp/NativeRegExpMacroAssembler.h"
+#include "irregexp/RegExpTypes.h"
 #include "jit/AtomicOperations.h"
 #include "jit/BaselineCompiler.h"
 #include "jit/IonBuilder.h"
@@ -41,6 +41,7 @@
 #include "jit/RangeAnalysis.h"
 #include "jit/SharedICHelpers.h"
 #include "jit/StackSlotAllocator.h"
+#include "js/RegExpFlags.h"
 #include "vm/AsyncFunction.h"
 #include "vm/AsyncIteration.h"
 #include "vm/MatchPairs.h"
@@ -1184,243 +1185,314 @@ CodeGenerator::visitRegExp(LRegExp* lir)
     masm.bind(ool->rejoin());
 }
 
+static const size_t InputOutputDataSize = sizeof(irregexp::InputOutputData);
+
 // Amount of space to reserve on the stack when executing RegExps inline.
-static const size_t RegExpReservedStack = sizeof(irregexp::InputOutputData)
+static const size_t RegExpReservedStack = InputOutputDataSize
                                         + sizeof(MatchPairs)
                                         + RegExpObject::MaxPairCount * sizeof(MatchPair);
 
 static size_t
 RegExpPairsVectorStartOffset(size_t inputOutputDataStartOffset)
 {
-    return inputOutputDataStartOffset + sizeof(irregexp::InputOutputData) + sizeof(MatchPairs);
+    return inputOutputDataStartOffset + InputOutputDataSize + sizeof(MatchPairs);
 }
 
 static Address
 RegExpPairCountAddress(MacroAssembler& masm, size_t inputOutputDataStartOffset)
 {
     return Address(masm.getStackPointer(), inputOutputDataStartOffset
-                                           + sizeof(irregexp::InputOutputData)
+                                           + InputOutputDataSize
                                            + MatchPairs::offsetOfPairCount());
 }
 
+// When the unicode flag is set, if lastIndex points to a trail
+// surrogate, we should step back to the corresponding lead surrogate.
+// See ExecuteRegExp in builtin/RegExp.cpp for more detail.
+static void
+StepBackToLeadSurrogate(MacroAssembler& masm,
+                        Register regexpShared,
+                        Register input,
+                        Register lastIndex,
+                        Register temp1,
+                        Register temp2)
+{
+    Label done;
+
+    // If the unicode flag is not set, there is nothing to do.
+    masm.branchTest32(Assembler::Zero,
+                      Address(regexpShared, RegExpShared::offsetOfFlags()),
+                      Imm32(int32_t(JS::RegExpFlag::Unicode)),
+                      &done);
+
+    // If the input is latin1, there can't be any surrogates.
+    masm.branchLatin1String(input, &done);
+
+    // Check if |lastIndex > 0 && lastIndex < input->length()|.
+    // lastIndex should already have no sign here.
+    masm.branchTest32(Assembler::Zero, lastIndex, lastIndex, &done);
+    masm.loadStringLength(input, temp1);
+    masm.branch32(Assembler::AboveOrEqual, lastIndex, temp1, &done);
+
+    Register charsReg = temp1;
+    masm.loadStringChars(input, charsReg);
+
+    // Check if input[lastIndex] is trail surrogate.
+    masm.computeEffectiveAddress(BaseIndex(charsReg, lastIndex, TimesTwo), temp2);
+    masm.load16ZeroExtend(Address(temp2, 0), temp2);
+
+    masm.branch32(Assembler::Below, temp2, Imm32(unicode::TrailSurrogateMin), &done);
+    masm.branch32(Assembler::Above, temp2, Imm32(unicode::TrailSurrogateMax), &done);
+
+    // Check if input[lastIndex-1] is lead surrogate.
+    masm.move32(lastIndex, temp2);
+    masm.sub32(Imm32(1), temp2);
+    masm.computeEffectiveAddress(BaseIndex(charsReg, temp2, TimesTwo), temp2);
+    masm.load16ZeroExtend(Address(temp2, 0), temp2);
+
+    masm.branch32(Assembler::Below, temp2, Imm32(unicode::LeadSurrogateMin), &done);
+    masm.branch32(Assembler::Above, temp2, Imm32(unicode::LeadSurrogateMax), &done);
+
+    // Move lastIndex back to lead surrogate.
+    masm.subPtr(Imm32(1), lastIndex);
+
+    masm.bind(&done);
+}
+
+static void
+UpdateRegExpStatics(MacroAssembler& masm,
+                    Register regexp,
+                    Register input,
+                    Register lastIndex,
+                    Register staticsReg,
+                    Register temp1,
+                    Register temp2,
+                    // bool stringsCanBeInNursery,
+                    LiveGeneralRegisterSet& volatileRegs)
+{
+    Address pendingInputAddress(staticsReg, RegExpStatics::offsetOfPendingInput());
+    Address matchesInputAddress(staticsReg, RegExpStatics::offsetOfMatchesInput());
+    Address lazySourceAddress(staticsReg, RegExpStatics::offsetOfLazySource());
+    Address lazyIndexAddress(staticsReg, RegExpStatics::offsetOfLazyIndex());
+
+    masm.guardedCallPreBarrier(pendingInputAddress, MIRType::String);
+    masm.guardedCallPreBarrier(matchesInputAddress, MIRType::String);
+    masm.guardedCallPreBarrier(lazySourceAddress, MIRType::String);
+
+    masm.storePtr(input, pendingInputAddress);
+    masm.storePtr(input, matchesInputAddress);
+    masm.storePtr(lastIndex, Address(staticsReg, RegExpStatics::offsetOfLazyIndex()));
+    masm.store32(Imm32(1), Address(staticsReg, RegExpStatics::offsetOfPendingLazyEvaluation()));
+
+    masm.loadPtr(Address(regexp, NativeObject::getFixedSlotOffset(RegExpObject::PRIVATE_SLOT)),
+                 temp1);
+    masm.loadPtr(Address(temp1, RegExpShared::offsetOfSource()), temp2);
+    masm.storePtr(temp2, lazySourceAddress);
+    masm.load32(Address(temp1, RegExpShared::offsetOfFlags()), temp2);
+    masm.store32(temp2, Address(staticsReg, RegExpStatics::offsetOfLazyFlags()));
+}
+
 // Prepare an InputOutputData and optional MatchPairs which space has been
 // allocated for on the stack, and try to execute a RegExp on a string input.
-// If the RegExp was successfully executed and matched the input, fallthrough,
-// otherwise jump to notFound or failure.
+// If the RegExp was successfully executed and matched the input, fallthrough.
+// Otherwise, jump to notFound or failure.
 static bool
-PrepareAndExecuteRegExp(JSContext* cx, MacroAssembler& masm, Register regexp, Register input,
+PrepareAndExecuteRegExp(JSContext* cx,
+                        MacroAssembler& masm,
+                        Register regexp,
+                        Register input,
                         Register lastIndex,
-                        Register temp1, Register temp2, Register temp3,
+                        Register temp1,
+                        Register temp2,
+                        Register temp3,
                         size_t inputOutputDataStartOffset,
-                        RegExpShared::CompilationMode mode,
-                        Label* notFound, Label* failure)
-{
-    size_t matchPairsStartOffset = inputOutputDataStartOffset + sizeof(irregexp::InputOutputData);
-    size_t pairsVectorStartOffset = RegExpPairsVectorStartOffset(inputOutputDataStartOffset);
+                        // bool stringsCanBeInNursery,
+                        Label* notFound,
+                        Label* failure)
+{
+    using irregexp::InputOutputData;
+
+    size_t ioOffset = inputOutputDataStartOffset;
+    size_t matchPairsOffset = ioOffset + sizeof(InputOutputData);
+    size_t pairsArrayOffset = matchPairsOffset + sizeof(MatchPairs);
 
     Address inputStartAddress(masm.getStackPointer(),
-        inputOutputDataStartOffset + offsetof(irregexp::InputOutputData, inputStart));
+                              ioOffset + offsetof(InputOutputData, inputStart));
     Address inputEndAddress(masm.getStackPointer(),
-        inputOutputDataStartOffset + offsetof(irregexp::InputOutputData, inputEnd));
-    Address matchesPointerAddress(masm.getStackPointer(),
-        inputOutputDataStartOffset + offsetof(irregexp::InputOutputData, matches));
+                            ioOffset + offsetof(InputOutputData, inputEnd));
     Address startIndexAddress(masm.getStackPointer(),
-        inputOutputDataStartOffset + offsetof(irregexp::InputOutputData, startIndex));
-    Address endIndexAddress(masm.getStackPointer(),
-        inputOutputDataStartOffset + offsetof(irregexp::InputOutputData, endIndex));
-    Address matchResultAddress(masm.getStackPointer(),
-        inputOutputDataStartOffset + offsetof(irregexp::InputOutputData, result));
+                              ioOffset + offsetof(InputOutputData, startIndex));
+    Address matchesAddress(masm.getStackPointer(), ioOffset + offsetof(InputOutputData, matches));
 
-    Address pairCountAddress = RegExpPairCountAddress(masm, inputOutputDataStartOffset);
+    Address matchPairsAddress(masm.getStackPointer(), matchPairsOffset);
+    Address pairCountAddress(masm.getStackPointer(),
+                             matchPairsOffset + MatchPairs::offsetOfPairCount());
     Address pairsPointerAddress(masm.getStackPointer(),
-        matchPairsStartOffset + MatchPairs::offsetOfPairs());
+                                matchPairsOffset + MatchPairs::offsetOfPairs());
 
-    Address pairsVectorAddress(masm.getStackPointer(), pairsVectorStartOffset);
+    Address pairsArrayAddress(masm.getStackPointer(), pairsArrayOffset);
 
-    RegExpStatics* res = GlobalObject::getRegExpStatics(cx, cx->global());
-    if (!res)
-        return false;
-#ifdef JS_USE_LINK_REGISTER
-    if (mode != RegExpShared::MatchOnly)
-        masm.pushReturnAddress();
-#endif
-    if (mode == RegExpShared::Normal) {
-        // First, fill in a skeletal MatchPairs instance on the stack. This will be
-        // passed to the OOL stub in the caller if we aren't able to execute the
-        // RegExp inline, and that stub needs to be able to determine whether the
-        // execution finished successfully.
-        masm.store32(Imm32(1), pairCountAddress);
-        masm.store32(Imm32(-1), pairsVectorAddress);
-        masm.computeEffectiveAddress(pairsVectorAddress, temp1);
-        masm.storePtr(temp1, pairsPointerAddress);
-    }
+    // First, fill in a skeletal MatchPairs instance on the stack. This will be
+    // passed to the OOL stub in the caller if we aren't able to execute the
+    // RegExp inline, and that stub needs to be able to determine whether the
+    // execution finished successfully.
+
+    // Initialize MatchPairs::pairCount to 1. The correct value can only
+    // be determined after loading the RegExpShared. If the RegExpShared
+    // has Kind::Atom, this is the correct pairCount.
+    masm.store32(Imm32(1), pairCountAddress);
+
+    // Initialize MatchPairs::pairs pointer
+    masm.store32(Imm32(-1), pairsArrayAddress);
+    masm.computeEffectiveAddress(pairsArrayAddress, temp1);
+    masm.storePtr(temp1, pairsPointerAddress);
 
     // Check for a linear input string.
     masm.branchIfRopeOrExternal(input, temp1, failure);
 
-    // Get the RegExpShared for the RegExp.
-    masm.loadPtr(Address(regexp, NativeObject::getFixedSlotOffset(RegExpObject::PRIVATE_SLOT)), temp1);
-    masm.branchPtr(Assembler::Equal, temp1, ImmWord(0), failure);
+    // Load the RegExpShared.
+    Register regexpReg = temp1;
 
-    // ES6 21.2.2.2 step 2.
-    // See RegExp.cpp ExecuteRegExp for more detail.
+    // Get the RegExpShared for the RegExp.
+    masm.loadPtr(Address(regexp, NativeObject::getFixedSlotOffset(RegExpObject::PRIVATE_SLOT)),
+                 regexpReg);
+    masm.branchPtr(Assembler::Equal, regexpReg, ImmWord(0), failure);
+
+    // Handle Atom matches
+    Label notAtom, checkSuccess;
+    masm.branchPtr(Assembler::Equal,
+                   Address(regexpReg, RegExpShared::offsetOfPatternAtom()),
+                   ImmWord(0), &notAtom);
     {
-        Label done;
-
-        masm.branchTest32(Assembler::Zero, Address(temp1, RegExpShared::offsetOfFlags()),
-                          Imm32(UnicodeFlag), &done);
-
-        // If input is latin1, there should not be surrogate pair.
-        masm.branchLatin1String(input, &done);
-
-        // Check if |lastIndex > 0 && lastIndex < input->length()|.
-        // lastIndex should already have no sign here.
-        masm.branchTest32(Assembler::Zero, lastIndex, lastIndex, &done);
-        masm.loadStringLength(input, temp2);
-        masm.branch32(Assembler::AboveOrEqual, lastIndex, temp2, &done);
-
-        // Check if input[lastIndex] is trail surrogate.
-        masm.loadStringChars(input, temp2);
-        masm.computeEffectiveAddress(BaseIndex(temp2, lastIndex, TimesTwo), temp3);
-        masm.load16ZeroExtend(Address(temp3, 0), temp3);
-
-        masm.branch32(Assembler::Below, temp3, Imm32(unicode::TrailSurrogateMin), &done);
-        masm.branch32(Assembler::Above, temp3, Imm32(unicode::TrailSurrogateMax), &done);
-
-        // Check if input[lastIndex-1] is lead surrogate.
-        masm.move32(lastIndex, temp3);
-        masm.sub32(Imm32(1), temp3);
-        masm.computeEffectiveAddress(BaseIndex(temp2, temp3, TimesTwo), temp3);
-        masm.load16ZeroExtend(Address(temp3, 0), temp3);
-
-        masm.branch32(Assembler::Below, temp3, Imm32(unicode::LeadSurrogateMin), &done);
-        masm.branch32(Assembler::Above, temp3, Imm32(unicode::LeadSurrogateMax), &done);
-
-        // Move lastIndex to lead surrogate.
-        masm.subPtr(Imm32(1), lastIndex);
-
-        masm.bind(&done);
-    }
-
-    if (mode == RegExpShared::Normal) {
-        // Don't handle RegExps with excessive parens.
-        masm.load32(Address(temp1, RegExpShared::offsetOfParenCount()), temp2);
-        masm.branch32(Assembler::AboveOrEqual, temp2, Imm32(RegExpObject::MaxPairCount), failure);
-
-        // Fill in the paren count in the MatchPairs on the stack.
-        masm.add32(Imm32(1), temp2);
-        masm.store32(temp2, pairCountAddress);
-    }
-
-    // Load the code pointer for the type of input string we have, and compute
-    // the input start/end pointers in the InputOutputData.
-    Register codePointer = temp1;
+      LiveGeneralRegisterSet regsToSave(GeneralRegisterSet::Volatile());
+      regsToSave.takeUnchecked(temp1);
+      regsToSave.takeUnchecked(temp2);
+      regsToSave.takeUnchecked(temp3);
+
+      masm.computeEffectiveAddress(matchPairsAddress, temp3);
+
+      masm.PushRegsInMask(regsToSave);
+      masm.setupUnalignedABICall(temp2);
+      masm.passABIArg(regexpReg);
+      masm.passABIArg(input);
+      masm.passABIArg(lastIndex);
+      masm.passABIArg(temp3);
+      masm.callWithABI(JS_FUNC_TO_DATA_PTR(void*, ExecuteRegExpAtomRaw));
+      masm.storeCallInt32Result(temp1);
+      masm.PopRegsInMask(regsToSave);
+
+      masm.jump(&checkSuccess);
+    }
+    masm.bind(&notAtom);
+
+    // Don't handle regexps with too many capture pairs.
+    masm.load32(Address(regexpReg, RegExpShared::offsetOfPairCount()), temp2);
+    masm.branch32(Assembler::Above, temp2, Imm32(RegExpObject::MaxPairCount), failure);
+
+    // Fill in the pair count in the MatchPairs on the stack.
+    masm.store32(temp2, pairCountAddress);
+
+    // Update lastIndex if necessary.
+    StepBackToLeadSurrogate(masm, regexpReg, input, lastIndex, temp2, temp3);
+
+    // Load code pointer and length of input (in bytes).
+    // Store the input start in the InputOutputData.
+    Register codePointer = temp1; // Note: temp1 was previously regexpReg.
+    Register byteLength = temp3;
     {
+        Label isLatin1, done;
         masm.loadStringChars(input, temp2);
         masm.storePtr(temp2, inputStartAddress);
-        masm.loadStringLength(input, temp3);
+        masm.loadStringLength(input, byteLength);
 
-        Label isLatin1, done;
         masm.branchLatin1String(input, &isLatin1);
-        {
-            masm.lshiftPtr(Imm32(1), temp3);
-            masm.loadPtr(Address(temp1, RegExpShared::offsetOfTwoByteJitCode(mode)),
-                         codePointer);
-        }
+
+        // Two-byte input
+        masm.loadPtr(Address(regexpReg, RegExpShared::offsetOfJitCode(/*latin1 =*/false)),
+                     codePointer);
+        masm.lshiftPtr(Imm32(1), byteLength);
         masm.jump(&done);
-        {
-            masm.bind(&isLatin1);
-            masm.loadPtr(Address(temp1, RegExpShared::offsetOfLatin1JitCode(mode)),
-                         codePointer);
-        }
+
+        // Latin1 input
+        masm.bind(&isLatin1);
+        masm.loadPtr(Address(regexpReg, RegExpShared::offsetOfJitCode(/*latin1 = */ true)),
+                     codePointer);
+
         masm.bind(&done);
 
-        masm.addPtr(temp3, temp2);
+        // Store end pointer
+        masm.addPtr(byteLength, temp2);
         masm.storePtr(temp2, inputEndAddress);
     }
 
-    // Check the RegExpShared has been compiled for this type of input.
+    // Guard that the RegExpShared has been compiled for this type of input.
+    // If it has not been compiled, we fall back to the OOL case, which will
+    // do a VM call into the interpreter.
+    // TODO: add an interpreter trampoline?
     masm.branchPtr(Assembler::Equal, codePointer, ImmWord(0), failure);
     masm.loadPtr(Address(codePointer, JitCode::offsetOfCode()), codePointer);
 
-    // Finish filling in the InputOutputData instance on the stack.
-    if (mode == RegExpShared::Normal) {
-        masm.computeEffectiveAddress(Address(masm.getStackPointer(), matchPairsStartOffset), temp2);
-        masm.storePtr(temp2, matchesPointerAddress);
-    } else {
-        // Use InputOutputData.endIndex itself for output.
-        masm.computeEffectiveAddress(endIndexAddress, temp2);
-        masm.storePtr(temp2, endIndexAddress);
-    }
+    // Finish filling in the InputOutputData instance on the stack
+    masm.computeEffectiveAddress(matchPairsAddress, temp2);
+    masm.storePtr(temp2, matchesAddress);
     masm.storePtr(lastIndex, startIndexAddress);
-    masm.store32(Imm32(0), matchResultAddress);
 
     // Save any volatile inputs.
     LiveGeneralRegisterSet volatileRegs;
-    if (lastIndex.volatile_())
+    if (lastIndex.volatile_()) {
         volatileRegs.add(lastIndex);
-    if (input.volatile_())
+    }
+    if (input.volatile_()) {
         volatileRegs.add(input);
-    if (regexp.volatile_())
+    }
+    if (regexp.volatile_()) {
         volatileRegs.add(regexp);
+    }
 
 #ifdef JS_TRACE_LOGGING
     if (TraceLogTextIdEnabled(TraceLogger_IrregexpExecute)) {
-        masm.push(temp1);
-        masm.loadTraceLogger(temp1);
-        masm.tracelogStartId(temp1, TraceLogger_IrregexpExecute);
-        masm.pop(temp1);
+        masm.loadTraceLogger(temp2);
+        masm.tracelogStartId(temp2, TraceLogger_IrregexpExecute);
     }
 #endif
 
     // Execute the RegExp.
-    masm.computeEffectiveAddress(Address(masm.getStackPointer(), inputOutputDataStartOffset), temp2);
+    masm.computeEffectiveAddress(Address(masm.getStackPointer(), inputOutputDataStartOffset),
+                                 temp2);
     masm.PushRegsInMask(volatileRegs);
     masm.setupUnalignedABICall(temp3);
     masm.passABIArg(temp2);
     masm.callWithABI(codePointer);
+    masm.storeCallInt32Result(temp1);
     masm.PopRegsInMask(volatileRegs);
 
 #ifdef JS_TRACE_LOGGING
     if (TraceLogTextIdEnabled(TraceLogger_IrregexpExecute)) {
-        masm.loadTraceLogger(temp1);
-        masm.tracelogStopId(temp1, TraceLogger_IrregexpExecute);
+        masm.loadTraceLogger(temp2);
+        masm.tracelogStopId(temp2, TraceLogger_IrregexpExecute);
     }
 #endif
 
     Label success;
-    masm.branch32(Assembler::Equal, matchResultAddress,
-                  Imm32(RegExpRunStatus_Success_NotFound), notFound);
-    masm.branch32(Assembler::Equal, matchResultAddress,
-                  Imm32(RegExpRunStatus_Error), failure);
+    masm.bind(&checkSuccess);
+    masm.branch32(Assembler::Equal, temp1, Imm32(RegExpRunStatus_Success_NotFound), notFound);
+    masm.branch32(Assembler::Equal, temp1, Imm32(RegExpRunStatus_Error), failure);
 
     // Lazily update the RegExpStatics.
-    masm.movePtr(ImmPtr(res), temp1);
-
-    Address pendingInputAddress(temp1, RegExpStatics::offsetOfPendingInput());
-    Address matchesInputAddress(temp1, RegExpStatics::offsetOfMatchesInput());
-    Address lazySourceAddress(temp1, RegExpStatics::offsetOfLazySource());
-    Address lazyIndexAddress(temp1, RegExpStatics::offsetOfLazyIndex());
-
-    masm.guardedCallPreBarrier(pendingInputAddress, MIRType::String);
-    masm.guardedCallPreBarrier(matchesInputAddress, MIRType::String);
-    masm.guardedCallPreBarrier(lazySourceAddress, MIRType::String);
-
-    masm.storePtr(input, pendingInputAddress);
-    masm.storePtr(input, matchesInputAddress);
-    masm.storePtr(lastIndex, Address(temp1, RegExpStatics::offsetOfLazyIndex()));
-    masm.store32(Imm32(1), Address(temp1, RegExpStatics::offsetOfPendingLazyEvaluation()));
-
-    masm.loadPtr(Address(regexp, NativeObject::getFixedSlotOffset(RegExpObject::PRIVATE_SLOT)), temp2);
-    masm.loadPtr(Address(temp2, RegExpShared::offsetOfSource()), temp3);
-    masm.storePtr(temp3, lazySourceAddress);
-    masm.load32(Address(temp2, RegExpShared::offsetOfFlags()), temp3);
-    masm.store32(temp3, Address(temp1, RegExpStatics::offsetOfLazyFlags()));
-
-    if (mode == RegExpShared::MatchOnly) {
-        // endIndex is passed via temp3.
-        masm.load32(endIndexAddress, temp3);
+    RegExpStatics* res = GlobalObject::getRegExpStatics(cx, cx->global());
+    if (!res) {
+        return false;
     }
+    masm.movePtr(ImmPtr(res), temp1);
+    UpdateRegExpStatics(masm,
+                        regexp,
+                        input,
+                        lastIndex,
+                        temp1,
+                        temp2,
+                        temp3,
+                        // stringsCanBeInNursery,
+                        volatileRegs);
 
     return true;
 }
@@ -1706,17 +1778,31 @@ JitCompartment::generateRegExpMatcherStu
 
     MacroAssembler masm(cx);
 
+#ifdef JS_USE_LINK_REGISTER
+    masm.pushReturnAddress();
+#endif
+
     // The InputOutputData is placed above the return address on the stack.
     size_t inputOutputDataStartOffset = sizeof(void*);
 
     Label notFound, oolEntry;
     if (!PrepareAndExecuteRegExp(cx, masm, regexp, input, lastIndex,
                                  temp1, temp2, temp5, inputOutputDataStartOffset,
-                                 RegExpShared::Normal, &notFound, &oolEntry))
+                                 &notFound, &oolEntry))
     {
         return nullptr;
     }
 
+    // If a regexp has named captures, fall back to the OOL stub, which
+    // will end up calling CreateRegExpMatchResults.
+    Register shared = temp2;
+    masm.loadPtr(Address(regexp, NativeObject::getFixedSlotOffset(RegExpObject::PRIVATE_SLOT)),
+                 shared);
+    masm.branchPtr(Assembler::NotEqual,
+                   Address(shared, RegExpShared::offsetOfGroupsTemplate()),
+                   ImmWord(0),
+                   &oolEntry);
+
     // Construct the result.
     Register object = temp1;
     Label matchResultFallback, matchResultJoin;
@@ -1727,6 +1813,7 @@ JitCompartment::generateRegExpMatcherStu
     masm.loadPtr(Address(object, NativeObject::offsetOfSlots()), temp2);
     masm.storeValue(templateObject->getSlot(0), Address(temp2, 0));
     masm.storeValue(templateObject->getSlot(1), Address(temp2, sizeof(Value)));
+    masm.storeValue(templateObject->getSlot(2), Address(temp2, 2 * sizeof(Value)));
 
     size_t elementsOffset = NativeObject::offsetOfFixedElements();
 
@@ -1936,7 +2023,7 @@ CodeGenerator::visitOutOfLineRegExpMatch
     Register temp = regs.takeAny();
 
     masm.computeEffectiveAddress(Address(masm.getStackPointer(),
-        sizeof(irregexp::InputOutputData)), temp);
+        InputOutputDataSize), temp);
 
     pushArg(temp);
     pushArg(lastIndex);
@@ -2007,13 +2094,17 @@ JitCompartment::generateRegExpSearcherSt
 
     MacroAssembler masm(cx);
 
+#ifdef JS_USE_LINK_REGISTER
+    masm.pushReturnAddress();
+#endif
+
     // The InputOutputData is placed above the return address on the stack.
     size_t inputOutputDataStartOffset = sizeof(void*);
 
     Label notFound, oolEntry;
     if (!PrepareAndExecuteRegExp(cx, masm, regexp, input, lastIndex,
                                  temp1, temp2, temp3, inputOutputDataStartOffset,
-                                 RegExpShared::Normal, &notFound, &oolEntry))
+                                 &notFound, &oolEntry))
     {
         return nullptr;
     }
@@ -2093,7 +2184,7 @@ CodeGenerator::visitOutOfLineRegExpSearc
     Register temp = regs.takeAny();
 
     masm.computeEffectiveAddress(Address(masm.getStackPointer(),
-        sizeof(irregexp::InputOutputData)), temp);
+        InputOutputDataSize), temp);
 
     pushArg(temp);
     pushArg(lastIndex);
@@ -2159,20 +2250,29 @@ JitCompartment::generateRegExpTesterStub
     Register temp2 = regs.takeAny();
     Register temp3 = regs.takeAny();
 
-    masm.reserveStack(sizeof(irregexp::InputOutputData));
+    masm.reserveStack(RegExpReservedStack);
 
     Label notFound, oolEntry;
     if (!PrepareAndExecuteRegExp(cx, masm, regexp, input, lastIndex,
                                  temp1, temp2, temp3, 0,
-                                 RegExpShared::MatchOnly, &notFound, &oolEntry))
+                                 &notFound, &oolEntry))
     {
         return nullptr;
     }
 
     Label done;
 
-    // temp3 contains endIndex.
-    masm.move32(temp3, result);
+    // In visitRegExpMatcher and visitRegExpSearcher, we reserve stack space
+    // before calling the stub. For RegExpTester we call the stub before reserving
+    // stack space, so the offset of the InputOutputData is 0.
+    size_t inputOutputDataStartOffset = 0;
+
+    size_t pairsVectorStartOffset = RegExpPairsVectorStartOffset(inputOutputDataStartOffset);
+    Address matchPairLimit(masm.getStackPointer(),
+                           pairsVectorStartOffset + offsetof(MatchPair, limit));
+
+    // RegExpTester returns the end index of the match to update lastIndex.
+    masm.load32(matchPairLimit, result);
     masm.jump(&done);
 
     masm.bind(&notFound);
@@ -2183,7 +2283,7 @@ JitCompartment::generateRegExpTesterStub
     masm.move32(Imm32(RegExpTesterResultFailed), result);
 
     masm.bind(&done);
-    masm.freeStack(sizeof(irregexp::InputOutputData));
+    masm.freeStack(RegExpReservedStack);
     masm.ret();
 
     Linker linker(masm);
@@ -5724,6 +5824,12 @@ typedef StringIteratorObject* (*NewStrin
 static const VMFunction NewStringIteratorObjectInfo =
     FunctionInfo<NewStringIteratorObjectFn>(NewStringIteratorObject, "NewStringIteratorObject");
 
+typedef RegExpStringIteratorObject* (*NewRegExpStringIteratorObjectFn)(JSContext*, NewObjectKind);
+
+static const VMFunction NewRegExpStringIteratorObjectInfo =
+  FunctionInfo<NewRegExpStringIteratorObjectFn>(NewRegExpStringIteratorObject,
+                                                "NewRegExpStringIteratorObject");
+
 void
 CodeGenerator::visitNewIterator(LNewIterator* lir)
 {
@@ -5743,6 +5849,12 @@ CodeGenerator::visitNewIterator(LNewIter
                         ArgList(Imm32(GenericObject)),
                         StoreRegisterTo(objReg));
         break;
+      case MNewIterator::RegExpStringIterator:
+          ool = oolCallVM(NewRegExpStringIteratorObjectInfo,
+                          lir,
+                          ArgList(Imm32(GenericObject)),
+                          StoreRegisterTo(objReg));
+          break;
       default:
           MOZ_CRASH("unexpected iterator type");
     }
diff -Nrup mozilla/js/src/jit/InlinableNatives.h mozilla-OK/js/src/jit/InlinableNatives.h
--- mozilla/js/src/jit/InlinableNatives.h	2021-08-08 16:01:59.000000000 +0300
+++ mozilla-OK/js/src/jit/InlinableNatives.h	2022-04-22 05:05:32.333432402 +0300
@@ -136,6 +136,7 @@
     _(IntrinsicIsMapIterator)       \
     _(IntrinsicIsSetIterator)       \
     _(IntrinsicIsStringIterator)    \
+    _(IntrinsicGuardToRegExpStringIterator)          \
                                     \
     _(IntrinsicIsMapObject)         \
     _(IntrinsicGetNextMapEntryForIterator) \
@@ -145,6 +146,7 @@
                                     \
     _(IntrinsicNewArrayIterator)    \
     _(IntrinsicNewStringIterator)   \
+    _(IntrinsicNewRegExpStringIterator)              \
                                     \
     _(IntrinsicArrayBufferByteLength) \
     _(IntrinsicPossiblyWrappedArrayBufferByteLength) \
diff -Nrup mozilla/js/src/jit/JitOptions.cpp mozilla-OK/js/src/jit/JitOptions.cpp
--- mozilla/js/src/jit/JitOptions.cpp	2020-02-18 02:37:52.000000000 +0300
+++ mozilla-OK/js/src/jit/JitOptions.cpp	2022-04-22 05:06:08.614178088 +0300
@@ -159,6 +159,10 @@ DefaultJitOptions::DefaultJitOptions()
     // are compiled with the baseline compiler.
     SET_DEFAULT(baselineWarmUpThreshold, 10);
 
+    // How many invocations are needed before regexps are compiled to
+    // native code.
+    SET_DEFAULT(regexpWarmUpThreshold, 10);
+
     // Number of exception bailouts (resuming into catch/finally block) before
     // we invalidate and forbid Ion compilation.
     SET_DEFAULT(exceptionBailoutThreshold, 10);
@@ -276,6 +280,7 @@ DefaultJitOptions::setEagerCompilation()
 {
     eagerCompilation = true;
     baselineWarmUpThreshold = 0;
+    regexpWarmUpThreshold = 0;
     forcedDefaultIonWarmUpThreshold.reset();
     forcedDefaultIonWarmUpThreshold.emplace(0);
     forcedDefaultIonSmallFunctionWarmUpThreshold.reset();
diff -Nrup mozilla/js/src/jit/JitOptions.h mozilla-OK/js/src/jit/JitOptions.h
--- mozilla/js/src/jit/JitOptions.h	2020-02-18 02:37:52.000000000 +0300
+++ mozilla-OK/js/src/jit/JitOptions.h	2022-04-22 05:06:08.614178088 +0300
@@ -79,6 +79,7 @@ struct DefaultJitOptions
     bool ionInterruptWithoutSignals;
     bool simulatorAlwaysInterrupt;
     uint32_t baselineWarmUpThreshold;
+    uint32_t regexpWarmUpThreshold;
     uint32_t exceptionBailoutThreshold;
     uint32_t frequentBailoutThreshold;
     uint32_t maxStackArgs;
diff -Nrup mozilla/js/src/jit/MCallOptimize.cpp mozilla-OK/js/src/jit/MCallOptimize.cpp
--- mozilla/js/src/jit/MCallOptimize.cpp	2022-01-25 01:04:29.000000000 +0300
+++ mozilla-OK/js/src/jit/MCallOptimize.cpp	2022-04-22 05:05:32.334432395 +0300
@@ -26,6 +26,7 @@
 #include "jit/Lowering.h"
 #include "jit/MIR.h"
 #include "jit/MIRGraph.h"
+#include "js/RegExpFlags.h"
 #include "vm/ArgumentsObject.h"
 #include "vm/ProxyObject.h"
 #include "vm/SelfHosting.h"
@@ -42,6 +43,8 @@ using mozilla::ArrayLength;
 using mozilla::AssertedCast;
 
 using JS::DoubleNaNValue;
+using JS::RegExpFlag;
+using JS::RegExpFlags;
 using JS::TrackedOutcome;
 using JS::TrackedStrategy;
 using JS::TrackedTypeSite;
@@ -224,6 +227,8 @@ IonBuilder::inlineNativeCall(CallInfo& c
         return inlineRegExpInstanceOptimizable(callInfo);
       case InlinableNative::GetFirstDollarIndex:
         return inlineGetFirstDollarIndex(callInfo);
+      case InlinableNative::IntrinsicNewRegExpStringIterator:
+        return inlineNewIterator(callInfo, MNewIterator::RegExpStringIterator);
 
       // String natives.
       case InlinableNative::String:
@@ -328,6 +333,8 @@ IonBuilder::inlineNativeCall(CallInfo& c
         return inlineHasClass(callInfo, &SetIteratorObject::class_);
       case InlinableNative::IntrinsicIsStringIterator:
         return inlineHasClass(callInfo, &StringIteratorObject::class_);
+      case InlinableNative::IntrinsicGuardToRegExpStringIterator:
+        return inlineHasClass(callInfo, &RegExpStringIteratorObject::class_);
       case InlinableNative::IntrinsicObjectHasPrototype:
         return inlineObjectHasPrototype(callInfo);
       case InlinableNative::IntrinsicFinishBoundFunctionInit:
@@ -426,7 +433,7 @@ IonBuilder::inlineNativeGetter(CallInfo&
     }
 
     // Try to optimize RegExp getters.
-    RegExpFlag mask = NoFlags;
+    RegExpFlags mask = RegExpFlag::NoFlags;
     if (RegExpObject::isOriginalFlagGetter(native, &mask)) {
         const Class* clasp = thisTypes->getKnownClass(constraints());
         if (clasp != &RegExpObject::class_)
@@ -435,7 +442,7 @@ IonBuilder::inlineNativeGetter(CallInfo&
         MLoadFixedSlot* flags = MLoadFixedSlot::New(alloc(), thisArg, RegExpObject::flagsSlot());
         current->add(flags);
         flags->setResultType(MIRType::Int32);
-        MConstant* maskConst = MConstant::New(alloc(), Int32Value(mask));
+        MConstant* maskConst = MConstant::New(alloc(), Int32Value(mask.value()));
         current->add(maskConst);
         MBitAnd* maskedFlag = MBitAnd::New(alloc(), flags, maskConst);
         maskedFlag->setInt32Specialization();
@@ -1026,6 +1033,10 @@ IonBuilder::inlineNewIterator(CallInfo&
         templateObject = inspector->getTemplateObjectForNative(pc, js::intrinsic_NewStringIterator);
         MOZ_ASSERT_IF(templateObject, templateObject->is<StringIteratorObject>());
         break;
+      case MNewIterator::RegExpStringIterator:
+        templateObject = inspector->getTemplateObjectForNative(pc, js::intrinsic_NewRegExpStringIterator);
+        MOZ_ASSERT_IF(templateObject, templateObject->is<RegExpStringIteratorObject>());
+        break;
     }
 
     if (!templateObject)
diff -Nrup mozilla/js/src/jit/MIR.h mozilla-OK/js/src/jit/MIR.h
--- mozilla/js/src/jit/MIR.h	2022-04-13 21:14:22.000000000 +0300
+++ mozilla-OK/js/src/jit/MIR.h	2022-04-22 05:05:32.350432283 +0300
@@ -3608,6 +3608,7 @@ class MNewIterator
     enum Type {
         ArrayIterator,
         StringIterator,
+        RegExpStringIterator,
     };
 
 private:
diff -Nrup mozilla/js/src/jit/MacroAssembler.h mozilla-OK/js/src/jit/MacroAssembler.h
--- mozilla/js/src/jit/MacroAssembler.h	2022-01-25 01:04:29.000000000 +0300
+++ mozilla-OK/js/src/jit/MacroAssembler.h	2022-04-22 05:08:45.994074970 +0300
@@ -2239,6 +2239,20 @@ class MacroAssembler : public MacroAssem
     inline void assertStackAlignment(uint32_t alignment, int32_t offset = 0);
 };
 
+// StackMacroAssembler checks no GC will happen while it's on the stack.
+class MOZ_RAII StackMacroAssembler : public MacroAssembler
+{
+    JS::AutoCheckCannotGC nogc;
+
+  public:
+    StackMacroAssembler()
+      : MacroAssembler()
+    {}
+    explicit StackMacroAssembler(JSContext* cx)
+      : MacroAssembler(cx)
+    {}
+};
+
 //{{{ check_macroassembler_style
 inline uint32_t
 MacroAssembler::framePushed() const
diff -Nrup mozilla/js/src/jit/Recover.cpp mozilla-OK/js/src/jit/Recover.cpp
--- mozilla/js/src/jit/Recover.cpp	2021-03-01 21:17:56.000000000 +0300
+++ mozilla-OK/js/src/jit/Recover.cpp	2022-04-22 05:05:32.360432212 +0300
@@ -1396,6 +1396,9 @@ RNewIterator::recover(JSContext* cx, Sna
       case MNewIterator::StringIterator:
         resultObject = NewStringIteratorObject(cx);
         break;
+      case MNewIterator::RegExpStringIterator:
+        resultObject = NewRegExpStringIteratorObject(cx);
+        break;
     }
 
     if (!resultObject)
diff -Nrup mozilla/js/src/jit/VMFunctions.h mozilla-OK/js/src/jit/VMFunctions.h
--- mozilla/js/src/jit/VMFunctions.h	2021-10-26 19:49:54.000000000 +0300
+++ mozilla-OK/js/src/jit/VMFunctions.h	2022-04-22 05:05:32.368432156 +0300
@@ -290,6 +290,7 @@ template <> struct TypeToDataType<ArrayO
 template <> struct TypeToDataType<TypedArrayObject*> { static const DataType result = Type_Object; };
 template <> struct TypeToDataType<ArrayIteratorObject*> { static const DataType result = Type_Object; };
 template <> struct TypeToDataType<StringIteratorObject*> { static const DataType result = Type_Object; };
+template <> struct TypeToDataType<RegExpStringIteratorObject*>{ static const DataType result = Type_Object; };
 template <> struct TypeToDataType<JSString*> { static const DataType result = Type_Object; };
 template <> struct TypeToDataType<JSFlatString*> { static const DataType result = Type_Object; };
 template <> struct TypeToDataType<HandleObject> { static const DataType result = Type_Handle; };
diff -Nrup mozilla/js/src/jit/arm64/Assembler-arm64.h mozilla-OK/js/src/jit/arm64/Assembler-arm64.h
--- mozilla/js/src/jit/arm64/Assembler-arm64.h	2021-03-01 21:17:56.000000000 +0300
+++ mozilla-OK/js/src/jit/arm64/Assembler-arm64.h	2022-04-22 05:06:08.627177997 +0300
@@ -72,9 +72,6 @@ static constexpr Register PseudoStackPoi
 static constexpr ARMRegister PseudoStackPointer64 = { Registers::x28, 64 };
 static constexpr ARMRegister PseudoStackPointer32 = { Registers::x28, 32 };
 
-// StackPointer for use by irregexp.
-static constexpr Register RegExpStackPointer = PseudoStackPointer;
-
 static constexpr Register IntArgReg0 { Registers::x0 };
 static constexpr Register IntArgReg1 { Registers::x1 };
 static constexpr Register IntArgReg2 { Registers::x2 };
diff -Nrup mozilla/js/src/jit-test/lib/regexp_parse.js mozilla-OK/js/src/jit-test/lib/regexp_parse.js
--- mozilla/js/src/jit-test/lib/regexp_parse.js	2020-02-18 02:37:52.000000000 +0300
+++ mozilla-OK/js/src/jit-test/lib/regexp_parse.js	1970-01-01 03:00:00.000000000 +0300
@@ -1,205 +0,0 @@
-load(libdir + "asserts.js");
-
-// helper functions
-
-function Disjunction(alternatives) {
-  return{
-    type: "Disjunction",
-    alternatives: alternatives
-  };
-}
-
-function Alternative(nodes) {
-  return {
-    type: "Alternative",
-    nodes: nodes
-  };
-}
-
-function Empty() {
-  return {
-    type: "Empty"
-  };
-}
-
-function Text(elements) {
-  return {
-    type: "Text",
-    elements: elements
-  };
-}
-
-function Assertion(type) {
-  return {
-    type: "Assertion",
-    assertion_type: type
-  };
-}
-
-function Atom(data) {
-  return {
-    type: "Atom",
-    data: data
-  };
-}
-
-const kInfinity = 0x7FFFFFFF;
-function Quantifier(min, max, type, body) {
-  return {
-    type: "Quantifier",
-    min: min,
-    max: max,
-    quantifier_type: type,
-    body: body
-  };
-}
-
-function Lookahead(body) {
-  return {
-    type: "Lookahead",
-    is_positive: true,
-    body: body
-  };
-}
-
-function NegativeLookahead(body) {
-  return {
-    type: "Lookahead",
-    is_positive: false,
-    body: body
-  };
-}
-
-function BackReference(index) {
-  return {
-    type: "BackReference",
-    index: index
-  };
-}
-
-function CharacterClass(ranges) {
-  return {
-    type: "CharacterClass",
-    is_negated: false,
-    ranges: ranges.map(([from, to]) => ({ from ,to }))
-  };
-}
-
-function NegativeCharacterClass(ranges) {
-  return {
-    type: "CharacterClass",
-    is_negated: true,
-    ranges: ranges.map(([from, to]) => ({ from ,to }))
-  };
-}
-
-function Capture(index, body) {
-  return {
-    type: "Capture",
-    index: index,
-    body: body
-  };
-}
-
-function AllSurrogateAndCharacterClass(ranges) {
-  return Disjunction([
-    CharacterClass(ranges),
-    Alternative([
-      CharacterClass([["\uD800", "\uDBFF"]]),
-      NegativeLookahead(CharacterClass([["\uDC00", "\uDFFF"]]))
-    ]),
-    Alternative([
-      Assertion("NOT_AFTER_LEAD_SURROGATE"),
-      CharacterClass([["\uDC00", "\uDFFF"]])
-    ]),
-    Text([
-      CharacterClass([["\uD800", "\uDBFF"]]),
-      CharacterClass([["\uDC00", "\uDFFF"]])
-    ])
-  ]);
-}
-
-// testing functions
-
-var all_flags = [
-  "",
-  "i",
-  "m",
-  "u",
-  "im",
-  "iu",
-  "mu",
-  "imu",
-];
-
-var no_unicode_flags = [
-  "",
-  "i",
-  "m",
-  "im",
-];
-
-var unicode_flags = [
-  "u",
-  "iu",
-  "mu",
-  "imu",
-];
-
-var no_multiline_flags = [
-  "",
-  "i",
-  "u",
-  "iu",
-];
-
-var multiline_flags = [
-  "m",
-  "im",
-  "mu",
-  "imu",
-];
-
-function test_flags(pattern, flags, match_only, expected) {
-  for (var flag of flags) {
-    assertDeepEq(parseRegExp(pattern, flag, match_only), expected);
-  }
-}
-
-function make_mix(tree) {
-  if (tree.type == "Atom") {
-    return Atom("X" + tree.data + "Y");
-  }
-  if (tree.type == "CharacterClass") {
-    return Text([
-      Atom("X"),
-      tree,
-      Atom("Y")
-    ]);
-  }
-  if (tree.type == "Alternative") {
-    return Alternative([
-      Atom("X"),
-      ...tree.nodes,
-      Atom("Y")
-    ]);
-  }
-  return Alternative([
-    Atom("X"),
-    tree,
-    Atom("Y")
-  ]);
-}
-
-function test_mix(pattern, flags, expected) {
-  test_flags(pattern, flags, false, expected);
-  test_flags("X" + pattern + "Y", flags, false, make_mix(expected));
-}
-
-function test(pattern, flags, expected) {
-  test_flags(pattern, flags, false, expected);
-}
-
-function test_match_only(pattern, flags, expected) {
-  test_flags(pattern, flags, true, expected);
-}
diff -Nrup mozilla/js/src/jit-test/tests/regexp/bug1419785.js mozilla-OK/js/src/jit-test/tests/regexp/bug1419785.js
--- mozilla/js/src/jit-test/tests/regexp/bug1419785.js	1970-01-01 03:00:00.000000000 +0300
+++ mozilla-OK/js/src/jit-test/tests/regexp/bug1419785.js	2022-04-22 05:04:03.735053394 +0300
@@ -0,0 +1,3 @@
+// |jit-test| error:character class
+Object.defineProperty(RegExp.prototype, Symbol.search, {get: () => { throw "wrong"; }});
+"abc".search("[[");
diff -Nrup mozilla/js/src/jit-test/tests/regexp/bug1640479.js mozilla-OK/js/src/jit-test/tests/regexp/bug1640479.js
--- mozilla/js/src/jit-test/tests/regexp/bug1640479.js	1970-01-01 03:00:00.000000000 +0300
+++ mozilla-OK/js/src/jit-test/tests/regexp/bug1640479.js	2022-04-22 05:05:07.715604938 +0300
@@ -0,0 +1,15 @@
+// |jit-test| skip-if: !('oomTest' in this)
+
+var failures = 0;
+var i = 0;
+
+function foo() {
+    var e;
+    var r = RegExp("(?<_" + (i++) + "a>)");
+    try { e = r.exec("a"); } catch {}
+    e = r.exec("a");
+    if (e.groups === undefined) failures++;
+}
+
+oomTest(foo);
+assertEq(failures, 0);
diff -Nrup mozilla/js/src/jit-test/tests/regexp/huge-02.js mozilla-OK/js/src/jit-test/tests/regexp/huge-02.js
--- mozilla/js/src/jit-test/tests/regexp/huge-02.js	1970-01-01 03:00:00.000000000 +0300
+++ mozilla-OK/js/src/jit-test/tests/regexp/huge-02.js	2022-04-22 05:04:37.923813770 +0300
@@ -0,0 +1,13 @@
+var interestingCaptureNums = [(1 << 14),
+                              (1 << 15) - 1,
+                              (1 << 15),
+                              (1 << 15) + 1,
+                              (1 << 16)]
+
+for (let i of interestingCaptureNums) {
+    print(i);
+    try {
+        var source = Array(i).join("(") + "a" + Array(i).join(")");
+        RegExp(source).exec("a");
+    } catch {}
+}
diff -Nrup mozilla/js/src/jit-test/tests/regexp_parse/Assertion.js mozilla-OK/js/src/jit-test/tests/regexp_parse/Assertion.js
--- mozilla/js/src/jit-test/tests/regexp_parse/Assertion.js	2020-02-18 02:37:52.000000000 +0300
+++ mozilla-OK/js/src/jit-test/tests/regexp_parse/Assertion.js	1970-01-01 03:00:00.000000000 +0300
@@ -1,20 +0,0 @@
-if (typeof parseRegExp === 'undefined')
-    quit();
-
-load(libdir + "regexp_parse.js");
-
-test_mix("^", no_multiline_flags,
-         Assertion("START_OF_INPUT"));
-test_mix("^", multiline_flags,
-         Assertion("START_OF_LINE"));
-
-test_mix("$", no_multiline_flags,
-         Assertion("END_OF_INPUT"));
-test_mix("$", multiline_flags,
-         Assertion("END_OF_LINE"));
-
-test_mix("\\b", all_flags,
-         Assertion("BOUNDARY"));
-
-test_mix("\\B", all_flags,
-         Assertion("NON_BOUNDARY"));
diff -Nrup mozilla/js/src/jit-test/tests/regexp_parse/Atom.js mozilla-OK/js/src/jit-test/tests/regexp_parse/Atom.js
--- mozilla/js/src/jit-test/tests/regexp_parse/Atom.js	2020-02-18 02:37:52.000000000 +0300
+++ mozilla-OK/js/src/jit-test/tests/regexp_parse/Atom.js	1970-01-01 03:00:00.000000000 +0300
@@ -1,54 +0,0 @@
-if (typeof parseRegExp === 'undefined')
-    quit();
-
-load(libdir + "regexp_parse.js");
-
-test_mix("a", all_flags,
-         Atom("a"));
-test_mix("abc\u3042\u3044\u3046", all_flags,
-         Atom("abc\u3042\u3044\u3046"));
-
-// raw brace
-
-test("{", no_unicode_flags,
-     Atom("{"));
-test("{a", no_unicode_flags,
-     Atom("{a"));
-test("a{b", no_unicode_flags,
-     Atom("a{b"));
-
-test("}", no_unicode_flags,
-     Atom("}"));
-test("}a", no_unicode_flags,
-     Atom("}a"));
-test("a}b", no_unicode_flags,
-     Atom("a}b"));
-
-// raw surrogate pair
-
-test("X\uD83D\uDC38Y", unicode_flags,
-     Text([
-         Atom("X"),
-         Atom("\uD83D\uDC38"),
-         Atom("Y")
-     ]));
-
-test("X\uD83DY", unicode_flags,
-     Alternative([
-         Atom("X"),
-         Alternative([
-             Atom("\uD83D"),
-             NegativeLookahead(CharacterClass([["\uDC00", "\uDFFF"]]))
-         ]),
-         Atom("Y")
-     ]));
-
-test("X\uDC38Y", unicode_flags,
-     Alternative([
-         Atom("X"),
-         Alternative([
-             Assertion("NOT_AFTER_LEAD_SURROGATE"),
-             Atom("\uDC38"),
-         ]),
-         Atom("Y")
-     ]));
diff -Nrup mozilla/js/src/jit-test/tests/regexp_parse/Atom_CharacterClassEscape.js mozilla-OK/js/src/jit-test/tests/regexp_parse/Atom_CharacterClassEscape.js
--- mozilla/js/src/jit-test/tests/regexp_parse/Atom_CharacterClassEscape.js	2020-02-18 02:37:52.000000000 +0300
+++ mozilla-OK/js/src/jit-test/tests/regexp_parse/Atom_CharacterClassEscape.js	1970-01-01 03:00:00.000000000 +0300
@@ -1,115 +0,0 @@
-if (typeof parseRegExp === 'undefined')
-    quit();
-
-load(libdir + "regexp_parse.js");
-
-test_mix("\\d", all_flags,
-         CharacterClass([["0", "9"]]));
-
-test_mix("\\D", no_unicode_flags,
-         CharacterClass([
-             ["\u0000", "/"],
-             [":", "\uFFFF"]
-         ]));
-test_mix("\\D", unicode_flags,
-         AllSurrogateAndCharacterClass([
-             ["\u0000", "/"],
-             [":", "\uD7FF"],
-             ["\uE000", "\uFFFF"]
-         ]));
-
-test_mix("\\s", all_flags,
-         CharacterClass([
-             ["\t", "\r"],
-             [" ", " "],
-             ["\u00A0", "\u00A0"],
-             ["\u1680", "\u1680"],
-             ["\u2000", "\u200A"],
-             ["\u2028", "\u2029"],
-             ["\u202F", "\u202F"],
-             ["\u205F", "\u205F"],
-             ["\u3000", "\u3000"],
-             ["\uFEFF", "\uFEFF"]
-         ]));
-test_mix("\\S", no_unicode_flags,
-         CharacterClass([
-             ["\u0000", "\u0008"],
-             ["\u000E", "\u001F"],
-             ["!", "\u009F"],
-             ["\u00A1", "\u167F"],
-             ["\u1681", "\u1FFF"],
-             ["\u200B", "\u2027"],
-             ["\u202A", "\u202E"],
-             ["\u2030", "\u205E"],
-             ["\u2060", "\u2FFF"],
-             ["\u3001", "\uFEFE"],
-             ["\uFF00", "\uFFFF"]
-         ]));
-test_mix("\\S", unicode_flags,
-         AllSurrogateAndCharacterClass([
-             ["\u0000", "\u0008"],
-             ["\u000E", "\u001F"],
-             ["!", "\u009F"],
-             ["\u00A1", "\u167F"],
-             ["\u1681", "\u1FFF"],
-             ["\u200B", "\u2027"],
-             ["\u202A", "\u202E"],
-             ["\u2030", "\u205E"],
-             ["\u2060", "\u2FFF"],
-             ["\u3001", "\uD7FF"],
-             ["\uE000", "\uFEFE"],
-             ["\uFF00", "\uFFFF"]
-         ]));
-
-test_mix("\\w", no_unicode_flags,
-         CharacterClass([
-             ["0", "9"],
-             ["A", "Z"],
-             ["_", "_"],
-             ["a", "z"]
-         ]));
-test_mix("\\w", ["u", "mu"],
-         CharacterClass([
-             ["0", "9"],
-             ["A", "Z"],
-             ["_", "_"],
-             ["a", "z"]
-         ]));
-test_mix("\\w", ["iu", "imu"],
-         CharacterClass([
-             ["0", "9"],
-             ["A", "Z"],
-             ["_", "_"],
-             ["a", "z"],
-             ["\u017F", "\u017F"],
-             ["\u212A", "\u212A"]
-         ]));
-
-test_mix("\\W", no_unicode_flags,
-         CharacterClass([
-             ["\u0000", "/"],
-             [":", "@"],
-             ["[", "^"],
-             ["`", "`"],
-             ["{", "\uFFFF"]
-         ]));
-test_mix("\\W", ["u", "mu"],
-         AllSurrogateAndCharacterClass([
-             ["\u0000", "/"],
-             [":", "@"],
-             ["[", "^"],
-             ["`", "`"],
-             ["{", "\uD7FF"],
-             ["\uE000", "\uFFFF"]
-         ]));
-test_mix("\\W", ["iu", "imu"],
-         AllSurrogateAndCharacterClass([
-             ["\u0000", "/"],
-             [":", "@"],
-             ["[", "^"],
-             ["`", "`"],
-             ["{", "\u017E"],
-             ["\u0180", "\u2129"],
-             ["\u212B", "\uD7FF"],
-             ["\uE000", "\uFFFF"]
-         ]));
diff -Nrup mozilla/js/src/jit-test/tests/regexp_parse/Atom_ControlEscape.js mozilla-OK/js/src/jit-test/tests/regexp_parse/Atom_ControlEscape.js
--- mozilla/js/src/jit-test/tests/regexp_parse/Atom_ControlEscape.js	2020-02-18 02:37:52.000000000 +0300
+++ mozilla-OK/js/src/jit-test/tests/regexp_parse/Atom_ControlEscape.js	1970-01-01 03:00:00.000000000 +0300
@@ -1,19 +0,0 @@
-if (typeof parseRegExp === 'undefined')
-    quit();
-
-load(libdir + "regexp_parse.js");
-
-test_mix("\\f", all_flags,
-         Atom("\u000c"));
-
-test_mix("\\n", all_flags,
-         Atom("\u000a"));
-
-test_mix("\\r", all_flags,
-         Atom("\u000d"));
-
-test_mix("\\t", all_flags,
-         Atom("\u0009"));
-
-test_mix("\\v", all_flags,
-         Atom("\u000b"));
diff -Nrup mozilla/js/src/jit-test/tests/regexp_parse/Atom_ControlLetter.js mozilla-OK/js/src/jit-test/tests/regexp_parse/Atom_ControlLetter.js
--- mozilla/js/src/jit-test/tests/regexp_parse/Atom_ControlLetter.js	2020-02-18 02:37:52.000000000 +0300
+++ mozilla-OK/js/src/jit-test/tests/regexp_parse/Atom_ControlLetter.js	1970-01-01 03:00:00.000000000 +0300
@@ -1,13 +0,0 @@
-if (typeof parseRegExp === 'undefined')
-    quit();
-
-load(libdir + "regexp_parse.js");
-
-test_mix("\\ca", all_flags,
-         Atom("\u0001"));
-test_mix("\\cz", all_flags,
-         Atom("\u001a"));
-test_mix("\\cA", all_flags,
-         Atom("\u0001"));
-test_mix("\\cZ", all_flags,
-         Atom("\u001a"));
diff -Nrup mozilla/js/src/jit-test/tests/regexp_parse/Atom_DecimalEscape.js mozilla-OK/js/src/jit-test/tests/regexp_parse/Atom_DecimalEscape.js
--- mozilla/js/src/jit-test/tests/regexp_parse/Atom_DecimalEscape.js	2020-02-18 02:37:52.000000000 +0300
+++ mozilla-OK/js/src/jit-test/tests/regexp_parse/Atom_DecimalEscape.js	1970-01-01 03:00:00.000000000 +0300
@@ -1,87 +0,0 @@
-if (typeof parseRegExp === 'undefined')
-    quit();
-
-load(libdir + "regexp_parse.js");
-
-// LegacyOctalEscapeSequence
-
-test_mix("\\1", no_unicode_flags,
-         Atom("\u0001"));
-test_mix("\\2", no_unicode_flags,
-         Atom("\u0002"));
-test_mix("\\3", no_unicode_flags,
-         Atom("\u0003"));
-test_mix("\\4", no_unicode_flags,
-         Atom("\u0004"));
-test_mix("\\5", no_unicode_flags,
-         Atom("\u0005"));
-test_mix("\\6", no_unicode_flags,
-         Atom("\u0006"));
-test_mix("\\7", no_unicode_flags,
-         Atom("\u0007"));
-test_mix("\\8", no_unicode_flags,
-         Atom("8"));
-test_mix("\\9", no_unicode_flags,
-         Atom("9"));
-
-test_mix("\\10", no_unicode_flags,
-         Atom("\u0008"));
-test_mix("\\11", no_unicode_flags,
-         Atom("\u0009"));
-
-test_mix("\\189", no_unicode_flags,
-         Atom("\u{0001}89"));
-test_mix("\\1089", no_unicode_flags,
-         Atom("\u{0008}89"));
-test_mix("\\10189", no_unicode_flags,
-         Atom("A89"));
-test_mix("\\101189", no_unicode_flags,
-         Atom("A189"));
-
-// BackReference
-
-test_mix("()\\1", no_unicode_flags,
-         Alternative([
-             Capture(1, Empty()),
-             BackReference(1)
-         ]));
-test_mix("()\\1", unicode_flags,
-         Alternative([
-             Capture(1, Empty()),
-             Alternative([
-                 BackReference(1),
-                 Assertion("NOT_IN_SURROGATE_PAIR")
-             ])
-         ]));
-
-test_mix("()()()()()()()()()()\\10", no_unicode_flags,
-         Alternative([
-             Capture(1, Empty()),
-             Capture(2, Empty()),
-             Capture(3, Empty()),
-             Capture(4, Empty()),
-             Capture(5, Empty()),
-             Capture(6, Empty()),
-             Capture(7, Empty()),
-             Capture(8, Empty()),
-             Capture(9, Empty()),
-             Capture(10, Empty()),
-             BackReference(10)
-         ]));
-test_mix("()()()()()()()()()()\\10", unicode_flags,
-         Alternative([
-             Capture(1, Empty()),
-             Capture(2, Empty()),
-             Capture(3, Empty()),
-             Capture(4, Empty()),
-             Capture(5, Empty()),
-             Capture(6, Empty()),
-             Capture(7, Empty()),
-             Capture(8, Empty()),
-             Capture(9, Empty()),
-             Capture(10, Empty()),
-             Alternative([
-                 BackReference(10),
-                 Assertion("NOT_IN_SURROGATE_PAIR")
-             ])
-         ]));
diff -Nrup mozilla/js/src/jit-test/tests/regexp_parse/Atom_HexEscapeSequence.js mozilla-OK/js/src/jit-test/tests/regexp_parse/Atom_HexEscapeSequence.js
--- mozilla/js/src/jit-test/tests/regexp_parse/Atom_HexEscapeSequence.js	2020-02-18 02:37:52.000000000 +0300
+++ mozilla-OK/js/src/jit-test/tests/regexp_parse/Atom_HexEscapeSequence.js	1970-01-01 03:00:00.000000000 +0300
@@ -1,19 +0,0 @@
-if (typeof parseRegExp === 'undefined')
-    quit();
-
-load(libdir + "regexp_parse.js");
-
-test_mix("\\x00", all_flags,
-         Atom("\u0000"));
-test_mix("\\xFF", all_flags,
-         Atom("\u00FF"));
-
-test_mix("\\x0", no_unicode_flags,
-         Atom("x0"));
-test_mix("\\x000", all_flags,
-         Atom("\u{0000}0"));
-
-test_mix("\\xG", no_unicode_flags,
-         Atom("xG"));
-test_mix("\\x0G", no_unicode_flags,
-         Atom("x0G"));
diff -Nrup mozilla/js/src/jit-test/tests/regexp_parse/Atom_IdentityEscape.js mozilla-OK/js/src/jit-test/tests/regexp_parse/Atom_IdentityEscape.js
--- mozilla/js/src/jit-test/tests/regexp_parse/Atom_IdentityEscape.js	2020-02-18 02:37:52.000000000 +0300
+++ mozilla-OK/js/src/jit-test/tests/regexp_parse/Atom_IdentityEscape.js	1970-01-01 03:00:00.000000000 +0300
@@ -1,55 +0,0 @@
-if (typeof parseRegExp === 'undefined')
-    quit();
-
-load(libdir + "regexp_parse.js");
-
-// SyntaxCharacter
-
-test("\\^", all_flags,
-     Atom("^"));
-test("\\$", all_flags,
-     Atom("$"));
-test("\\\\", all_flags,
-     Atom("\\"));
-test("\\.", all_flags,
-     Atom("."));
-test("\\*", all_flags,
-     Atom("*"));
-test("\\+", all_flags,
-     Atom("+"));
-test("\\?", all_flags,
-     Atom("?"));
-test("\\(", all_flags,
-     Atom("("));
-test("\\)", all_flags,
-     Atom(")"));
-test("\\[", all_flags,
-     Atom("["));
-test("\\]", all_flags,
-     Atom("]"));
-test("\\{", all_flags,
-     Atom("{"));
-test("\\}", all_flags,
-     Atom("}"));
-test("\\|", all_flags,
-     Atom("|"));
-
-// Slash
-
-test("\\/", all_flags,
-     Atom("/"));
-
-// SourceCharacter
-
-test("\\P", no_unicode_flags,
-     Atom("P"));
-
-test("\\uX", no_unicode_flags,
-     Atom("uX"));
-
-test("\\u{0000}", no_unicode_flags,
-     Quantifier(0, 0, "GREEDY", Atom("u")));
-
-test("\\c_", no_unicode_flags,
-     Atom("\\c_"));
-
diff -Nrup mozilla/js/src/jit-test/tests/regexp_parse/Atom_Null.js mozilla-OK/js/src/jit-test/tests/regexp_parse/Atom_Null.js
--- mozilla/js/src/jit-test/tests/regexp_parse/Atom_Null.js	2020-02-18 02:37:52.000000000 +0300
+++ mozilla-OK/js/src/jit-test/tests/regexp_parse/Atom_Null.js	1970-01-01 03:00:00.000000000 +0300
@@ -1,7 +0,0 @@
-if (typeof parseRegExp === 'undefined')
-    quit();
-
-load(libdir + "regexp_parse.js");
-
-test_mix("\\0", all_flags,
-         Atom("\u0000"));
diff -Nrup mozilla/js/src/jit-test/tests/regexp_parse/Atom_RegExpUnicodeEscapeSequence.js mozilla-OK/js/src/jit-test/tests/regexp_parse/Atom_RegExpUnicodeEscapeSequence.js
--- mozilla/js/src/jit-test/tests/regexp_parse/Atom_RegExpUnicodeEscapeSequence.js	2020-02-18 02:37:52.000000000 +0300
+++ mozilla-OK/js/src/jit-test/tests/regexp_parse/Atom_RegExpUnicodeEscapeSequence.js	1970-01-01 03:00:00.000000000 +0300
@@ -1,108 +0,0 @@
-if (typeof parseRegExp === 'undefined')
-    quit();
-
-load(libdir + "regexp_parse.js");
-
-// LeadSurrogate TrailSurrogate
-
-test("\\uD83D\\uDC38", all_flags,
-     Atom("\uD83D\uDC38"));
-test("X\\uD83D\\uDC38Y", no_unicode_flags,
-     Atom("X\uD83D\uDC38Y"));
-test("X\\uD83D\\uDC38Y", unicode_flags,
-     Text([
-         Atom("X"),
-         Atom("\uD83D\uDC38"),
-         Atom("Y")
-     ]));
-
-// LeadSurrogate
-
-test_mix("\\uD83D", no_unicode_flags,
-         Atom("\uD83D"));
-test("\\uD83D", unicode_flags,
-     Alternative([
-         Atom("\uD83D"),
-         NegativeLookahead(CharacterClass([["\uDC00", "\uDFFF"]]))
-     ]));
-test("X\\uD83DY", unicode_flags,
-     Alternative([
-         Atom("X"),
-         Alternative([
-             Atom("\uD83D"),
-             NegativeLookahead(CharacterClass([["\uDC00", "\uDFFF"]]))
-         ]),
-         Atom("Y")
-     ]));
-
-// TrailSurrogate
-
-test_mix("\\uDC38", no_unicode_flags,
-         Atom("\uDC38"));
-test("\\uDC38", unicode_flags,
-     Alternative([
-         Assertion("NOT_AFTER_LEAD_SURROGATE"),
-         Atom("\uDC38"),
-     ]));
-test("X\\uDC38Y", unicode_flags,
-     Alternative([
-         Atom("X"),
-         Alternative([
-             Assertion("NOT_AFTER_LEAD_SURROGATE"),
-             Atom("\uDC38"),
-         ]),
-         Atom("Y")
-     ]));
-
-// NonSurrogate / Hex4Digits
-
-test_mix("\\u0000", all_flags,
-         Atom("\u0000"));
-test_mix("\\uFFFF", all_flags,
-         Atom("\uFFFF"));
-
-// braced HexDigits
-
-test_mix("\\u{0000}", unicode_flags,
-         Atom("\u0000"));
-test_mix("\\u{FFFF}", unicode_flags,
-         Atom("\uFFFF"));
-
-test("\\u{1F438}", unicode_flags,
-     Atom("\uD83D\uDC38"));
-test("X\\u{1F438}Y", unicode_flags,
-     Text([
-         Atom("X"),
-         Atom("\uD83D\uDC38"),
-         Atom("Y")
-     ]));
-
-test("\\u{D83D}", unicode_flags,
-     Alternative([
-         Atom("\uD83D"),
-         NegativeLookahead(CharacterClass([["\uDC00", "\uDFFF"]]))
-     ]));
-test("X\\u{D83D}Y", unicode_flags,
-     Alternative([
-         Atom("X"),
-         Alternative([
-             Atom("\uD83D"),
-             NegativeLookahead(CharacterClass([["\uDC00", "\uDFFF"]]))
-         ]),
-         Atom("Y")
-     ]));
-
-test("\\u{DC38}", unicode_flags,
-     Alternative([
-         Assertion("NOT_AFTER_LEAD_SURROGATE"),
-         Atom("\uDC38"),
-     ]));
-test("X\\u{DC38}Y", unicode_flags,
-     Alternative([
-         Atom("X"),
-         Alternative([
-             Assertion("NOT_AFTER_LEAD_SURROGATE"),
-             Atom("\uDC38"),
-         ]),
-         Atom("Y")
-     ]));
diff -Nrup mozilla/js/src/jit-test/tests/regexp_parse/Capture.js mozilla-OK/js/src/jit-test/tests/regexp_parse/Capture.js
--- mozilla/js/src/jit-test/tests/regexp_parse/Capture.js	2020-02-18 02:37:52.000000000 +0300
+++ mozilla-OK/js/src/jit-test/tests/regexp_parse/Capture.js	1970-01-01 03:00:00.000000000 +0300
@@ -1,21 +0,0 @@
-if (typeof parseRegExp === 'undefined')
-    quit();
-
-load(libdir + "regexp_parse.js");
-
-test("()", all_flags,
-     Capture(1, Empty()));
-
-test("(a)", all_flags,
-     Capture(1, Atom("a")));
-
-test("((a()b))c(d)", all_flags,
-     Alternative([
-         Capture(1, Capture(2, Alternative([
-             Atom("a"),
-             Capture(3, Empty()),
-             Atom("b")
-         ]))),
-         Atom("c"),
-         Capture(4, Atom("d"))
-     ]));
diff -Nrup mozilla/js/src/jit-test/tests/regexp_parse/CharacterClass.js mozilla-OK/js/src/jit-test/tests/regexp_parse/CharacterClass.js
--- mozilla/js/src/jit-test/tests/regexp_parse/CharacterClass.js	2020-02-18 02:37:52.000000000 +0300
+++ mozilla-OK/js/src/jit-test/tests/regexp_parse/CharacterClass.js	1970-01-01 03:00:00.000000000 +0300
@@ -1,74 +0,0 @@
-if (typeof parseRegExp === 'undefined')
-    quit();
-
-load(libdir + "regexp_parse.js");
-
-test_mix("[]", all_flags,
-         NegativeCharacterClass([
-             ["\u0000", "\uFFFF"]
-         ]));
-
-test("[a]", all_flags,
-     CharacterClass([
-         ["a", "a"]
-     ]));
-
-test("[abc\u3042\u3044\u3046]", all_flags,
-     CharacterClass([
-         ["a", "a"],
-         ["b", "b"],
-         ["c", "c"],
-         ["\u3042", "\u3042"],
-         ["\u3044", "\u3044"],
-         ["\u3046", "\u3046"],
-     ]));
-
-test("[a-c\u3042-\u3046]", all_flags,
-     CharacterClass([
-         ["a", "c"],
-         ["\u3042", "\u3046"]
-     ]));
-
-test("[-]", all_flags,
-     CharacterClass([
-         ["-", "-"]
-     ]));
-
-// raw surrogate pair
-
-test("[X\uD83D\uDC38Y]", unicode_flags,
-     Disjunction([
-         CharacterClass([
-             ["X", "X"],
-             ["Y", "Y"],
-         ]),
-         Atom("\uD83D\uDC38")
-     ]));
-
-test("[X\uD83DY]", unicode_flags,
-     Disjunction([
-         CharacterClass([
-             ["X", "X"],
-             ["Y", "Y"]
-         ]),
-         Alternative([
-             CharacterClass([
-                 ["\uD83D", "\uD83D"]
-             ]),
-             NegativeLookahead(CharacterClass([["\uDC00", "\uDFFF"]]))
-         ])
-     ]));
-
-test("[X\uDC38Y]", unicode_flags,
-     Disjunction([
-         CharacterClass([
-             ["X", "X"],
-             ["Y", "Y"]
-         ]),
-         Alternative([
-             Assertion("NOT_AFTER_LEAD_SURROGATE"),
-             CharacterClass([
-                 ["\uDC38", "\uDC38"]
-             ])
-         ])
-     ]));
diff -Nrup mozilla/js/src/jit-test/tests/regexp_parse/CharacterClass_CharacterClassEscape.js mozilla-OK/js/src/jit-test/tests/regexp_parse/CharacterClass_CharacterClassEscape.js
--- mozilla/js/src/jit-test/tests/regexp_parse/CharacterClass_CharacterClassEscape.js	2020-02-18 02:37:52.000000000 +0300
+++ mozilla-OK/js/src/jit-test/tests/regexp_parse/CharacterClass_CharacterClassEscape.js	1970-01-01 03:00:00.000000000 +0300
@@ -1,115 +0,0 @@
-if (typeof parseRegExp === 'undefined')
-    quit();
-
-load(libdir + "regexp_parse.js");
-
-test("[\\d]", all_flags,
-     CharacterClass([["0", "9"]]));
-
-test("[\\D]", no_unicode_flags,
-     CharacterClass([
-         ["\u0000", "/"],
-         [":", "\uFFFF"]
-     ]));
-test("[\\D]", unicode_flags,
-     AllSurrogateAndCharacterClass([
-         ["\u0000", "/"],
-         [":", "\uD7FF"],
-         ["\uE000", "\uFFFF"]
-     ]));
-
-test("[\\s]", all_flags,
-     CharacterClass([
-         ["\t", "\r"],
-         [" ", " "],
-         ["\u00A0", "\u00A0"],
-         ["\u1680", "\u1680"],
-         ["\u2000", "\u200A"],
-         ["\u2028", "\u2029"],
-         ["\u202F", "\u202F"],
-         ["\u205F", "\u205F"],
-         ["\u3000", "\u3000"],
-         ["\uFEFF", "\uFEFF"]
-     ]));
-test("[\\S]", no_unicode_flags,
-     CharacterClass([
-         ["\u0000", "\u0008"],
-         ["\u000E", "\u001F"],
-         ["!", "\u009F"],
-         ["\u00A1", "\u167F"],
-         ["\u1681", "\u1FFF"],
-         ["\u200B", "\u2027"],
-         ["\u202A", "\u202E"],
-         ["\u2030", "\u205E"],
-         ["\u2060", "\u2FFF"],
-         ["\u3001", "\uFEFE"],
-         ["\uFF00", "\uFFFF"]
-     ]));
-test("[\\S]", unicode_flags,
-     AllSurrogateAndCharacterClass([
-         ["\u0000", "\u0008"],
-         ["\u000E", "\u001F"],
-         ["!", "\u009F"],
-         ["\u00A1", "\u167F"],
-         ["\u1681", "\u1FFF"],
-         ["\u200B", "\u2027"],
-         ["\u202A", "\u202E"],
-         ["\u2030", "\u205E"],
-         ["\u2060", "\u2FFF"],
-         ["\u3001", "\uD7FF"],
-         ["\uE000", "\uFEFE"],
-         ["\uFF00", "\uFFFF"]
-     ]));
-
-test("[\\w]", no_unicode_flags,
-     CharacterClass([
-         ["0", "9"],
-         ["A", "Z"],
-         ["_", "_"],
-         ["a", "z"]
-     ]));
-test("[\\w]", ["u", "mu"],
-     CharacterClass([
-         ["0", "9"],
-         ["A", "Z"],
-         ["_", "_"],
-         ["a", "z"]
-     ]));
-test("[\\w]", ["iu", "imu"],
-     CharacterClass([
-         ["0", "9"],
-         ["A", "Z"],
-         ["_", "_"],
-         ["a", "z"],
-         ["\u017F", "\u017F"],
-         ["\u212A", "\u212A"]
-     ]));
-
-test("[\\W]", no_unicode_flags,
-     CharacterClass([
-         ["\u0000", "/"],
-         [":", "@"],
-         ["[", "^"],
-         ["`", "`"],
-         ["{", "\uFFFF"]
-     ]));
-test("[\\W]", ["u", "mu"],
-     AllSurrogateAndCharacterClass([
-         ["\u0000", "/"],
-         [":", "@"],
-         ["[", "^"],
-         ["`", "`"],
-         ["{", "\uD7FF"],
-         ["\uE000", "\uFFFF"]
-     ]));
-test("[\\W]", ["iu", "imu"],
-     AllSurrogateAndCharacterClass([
-         ["\u0000", "/"],
-         [":", "@"],
-         ["[", "^"],
-         ["`", "`"],
-         ["{", "\u017E"],
-         ["\u0180", "\u2129"],
-         ["\u212B", "\uD7FF"],
-         ["\uE000", "\uFFFF"]
-     ]));
diff -Nrup mozilla/js/src/jit-test/tests/regexp_parse/CharacterClass_ClassEscape.js mozilla-OK/js/src/jit-test/tests/regexp_parse/CharacterClass_ClassEscape.js
--- mozilla/js/src/jit-test/tests/regexp_parse/CharacterClass_ClassEscape.js	2020-02-18 02:37:52.000000000 +0300
+++ mozilla-OK/js/src/jit-test/tests/regexp_parse/CharacterClass_ClassEscape.js	1970-01-01 03:00:00.000000000 +0300
@@ -1,13 +0,0 @@
-if (typeof parseRegExp === 'undefined')
-    quit();
-
-load(libdir + "regexp_parse.js");
-
-test("[\b]", all_flags,
-     CharacterClass([
-         ["\u0008", "\u0008"]
-     ]));
-test("[\-]", all_flags,
-     CharacterClass([
-         ["-", "-"]
-     ]));
diff -Nrup mozilla/js/src/jit-test/tests/regexp_parse/CharacterClass_ControlEscape.js mozilla-OK/js/src/jit-test/tests/regexp_parse/CharacterClass_ControlEscape.js
--- mozilla/js/src/jit-test/tests/regexp_parse/CharacterClass_ControlEscape.js	2020-02-18 02:37:52.000000000 +0300
+++ mozilla-OK/js/src/jit-test/tests/regexp_parse/CharacterClass_ControlEscape.js	1970-01-01 03:00:00.000000000 +0300
@@ -1,29 +0,0 @@
-if (typeof parseRegExp === 'undefined')
-    quit();
-
-load(libdir + "regexp_parse.js");
-
-test("[\\f]", all_flags,
-     CharacterClass([
-         ["\u000c", "\u000c"]
-     ]));
-
-test("[\\n]", all_flags,
-     CharacterClass([
-         ["\u000a", "\u000a"]
-     ]));
-
-test("[\\r]", all_flags,
-     CharacterClass([
-         ["\u000d", "\u000d"]
-     ]));
-
-test("[\\t]", all_flags,
-     CharacterClass([
-         ["\u0009", "\u0009"]
-     ]));
-
-test("[\\v]", all_flags,
-     CharacterClass([
-         ["\u000b", "\u000b"]
-     ]));
diff -Nrup mozilla/js/src/jit-test/tests/regexp_parse/CharacterClass_ControlLetter.js mozilla-OK/js/src/jit-test/tests/regexp_parse/CharacterClass_ControlLetter.js
--- mozilla/js/src/jit-test/tests/regexp_parse/CharacterClass_ControlLetter.js	2020-02-18 02:37:52.000000000 +0300
+++ mozilla-OK/js/src/jit-test/tests/regexp_parse/CharacterClass_ControlLetter.js	1970-01-01 03:00:00.000000000 +0300
@@ -1,35 +0,0 @@
-if (typeof parseRegExp === 'undefined')
-    quit();
-
-load(libdir + "regexp_parse.js");
-
-test("[\\ca]", all_flags,
-     CharacterClass([
-         ["\u0001", "\u0001"]
-     ]));
-test("[\\cz]", all_flags,
-     CharacterClass([
-         ["\u001a", "\u001a"]
-     ]));
-test("[\\cA]", all_flags,
-     CharacterClass([
-         ["\u0001", "\u0001"]
-     ]));
-test("[\\cZ]", all_flags,
-     CharacterClass([
-         ["\u001a", "\u001a"]
-     ]));
-
-// Invalid
-
-test("[\\c]", no_unicode_flags,
-     CharacterClass([
-         ["\\", "\\"],
-         ["c", "c"]
-     ]));
-test("[\\c=]", no_unicode_flags,
-     CharacterClass([
-         ["\\", "\\"],
-         ["c", "c"],
-         ["=", "="]
-     ]));
diff -Nrup mozilla/js/src/jit-test/tests/regexp_parse/CharacterClass_HexEscapeSequence.js mozilla-OK/js/src/jit-test/tests/regexp_parse/CharacterClass_HexEscapeSequence.js
--- mozilla/js/src/jit-test/tests/regexp_parse/CharacterClass_HexEscapeSequence.js	2020-02-18 02:37:52.000000000 +0300
+++ mozilla-OK/js/src/jit-test/tests/regexp_parse/CharacterClass_HexEscapeSequence.js	1970-01-01 03:00:00.000000000 +0300
@@ -1,39 +0,0 @@
-if (typeof parseRegExp === 'undefined')
-    quit();
-
-load(libdir + "regexp_parse.js");
-
-test("[\\x00]", all_flags,
-     CharacterClass([
-         ["\u0000", "\u0000"]
-     ]));
-test("[\\xff]", all_flags,
-     CharacterClass([
-         ["\u00FF", "\u00FF"]
-     ]));
-
-// Invalid
-
-test("[\\x]", no_unicode_flags,
-     CharacterClass([
-         ["x", "x"]
-     ]));
-
-test("[\\xG]", no_unicode_flags,
-     CharacterClass([
-         ["x", "x"],
-         ["G", "G"]
-     ]));
-
-test("[\\x0]", no_unicode_flags,
-     CharacterClass([
-         ["x", "x"],
-         ["0", "0"]
-     ]));
-
-test("[\\x0G]", no_unicode_flags,
-     CharacterClass([
-         ["x", "x"],
-         ["0", "0"],
-         ["G", "G"],
-     ]));
diff -Nrup mozilla/js/src/jit-test/tests/regexp_parse/CharacterClass_Null.js mozilla-OK/js/src/jit-test/tests/regexp_parse/CharacterClass_Null.js
--- mozilla/js/src/jit-test/tests/regexp_parse/CharacterClass_Null.js	2020-02-18 02:37:52.000000000 +0300
+++ mozilla-OK/js/src/jit-test/tests/regexp_parse/CharacterClass_Null.js	1970-01-01 03:00:00.000000000 +0300
@@ -1,9 +0,0 @@
-if (typeof parseRegExp === 'undefined')
-    quit();
-
-load(libdir + "regexp_parse.js");
-
-test("[\\0]", all_flags,
-     CharacterClass([
-         ["\u0000", "\u0000"]
-     ]));
diff -Nrup mozilla/js/src/jit-test/tests/regexp_parse/CharacterClass_RegExpUnicodeEscapeSequence.js mozilla-OK/js/src/jit-test/tests/regexp_parse/CharacterClass_RegExpUnicodeEscapeSequence.js
--- mozilla/js/src/jit-test/tests/regexp_parse/CharacterClass_RegExpUnicodeEscapeSequence.js	2020-02-18 02:37:52.000000000 +0300
+++ mozilla-OK/js/src/jit-test/tests/regexp_parse/CharacterClass_RegExpUnicodeEscapeSequence.js	1970-01-01 03:00:00.000000000 +0300
@@ -1,162 +0,0 @@
-if (typeof parseRegExp === 'undefined')
-    quit();
-
-load(libdir + "regexp_parse.js");
-
-// LeadSurrogate TrailSurrogate
-
-test("[X\\uD83D\\uDC38Y]", no_unicode_flags,
-     CharacterClass([
-         ["X", "X"],
-         ["\uD83D", "\uD83D"],
-         ["\uDC38", "\uDC38"],
-         ["Y", "Y"]
-     ]));
-test("[X\\uD83D\\uDC38Y]", unicode_flags,
-     Disjunction([
-         CharacterClass([
-             ["X", "X"],
-             ["Y", "Y"],
-         ]),
-         Atom("\uD83D\uDC38")
-     ]));
-
-// LeadSurrogate
-
-test("[X\\uD83DY]", no_unicode_flags,
-     CharacterClass([
-         ["X", "X"],
-         ["\uD83D", "\uD83D"],
-         ["Y", "Y"]
-     ]));
-test("[X\\uD83DY]", unicode_flags,
-     Disjunction([
-         CharacterClass([
-             ["X", "X"],
-             ["Y", "Y"]
-         ]),
-         Alternative([
-             CharacterClass([
-                 ["\uD83D", "\uD83D"]
-             ]),
-             NegativeLookahead(CharacterClass([["\uDC00", "\uDFFF"]]))
-         ])
-     ]));
-
-// TrailSurrogate
-
-test("[X\\uDC38Y]", no_unicode_flags,
-     CharacterClass([
-         ["X", "X"],
-         ["\uDC38", "\uDC38"],
-         ["Y", "Y"]
-     ]));
-test("[X\\uDC38Y]", unicode_flags,
-     Disjunction([
-         CharacterClass([
-             ["X", "X"],
-             ["Y", "Y"]
-         ]),
-         Alternative([
-             Assertion("NOT_AFTER_LEAD_SURROGATE"),
-             CharacterClass([
-                 ["\uDC38", "\uDC38"]
-             ])
-         ])
-     ]));
-
-// NonSurrogate / Hex4Digits
-
-test("[X\\u0000Y]", all_flags,
-     CharacterClass([
-         ["X", "X"],
-         ["\u0000", "\u0000"],
-         ["Y", "Y"]
-     ]));
-test("[X\\uFFFFY]", all_flags,
-     CharacterClass([
-         ["X", "X"],
-         ["\uFFFF", "\uFFFF"],
-         ["Y", "Y"]
-     ]));
-
-// braced HexDigits
-
-test("[X\\u{0000}Y]", unicode_flags,
-     CharacterClass([
-         ["X", "X"],
-         ["\u0000", "\u0000"],
-         ["Y", "Y"]
-     ]));
-test("[X\\uFFFFY]", unicode_flags,
-     CharacterClass([
-         ["X", "X"],
-         ["\uFFFF", "\uFFFF"],
-         ["Y", "Y"]
-     ]));
-
-test("[X\\u{1F438}Y]", unicode_flags,
-     Disjunction([
-         CharacterClass([
-             ["X", "X"],
-             ["Y", "Y"],
-         ]),
-         Atom("\uD83D\uDC38")
-     ]));
-
-test("[X\\u{D83D}Y]", unicode_flags,
-     Disjunction([
-         CharacterClass([
-             ["X", "X"],
-             ["Y", "Y"]
-         ]),
-         Alternative([
-             CharacterClass([
-                 ["\uD83D", "\uD83D"]
-             ]),
-             NegativeLookahead(CharacterClass([["\uDC00", "\uDFFF"]]))
-         ])
-     ]));
-test("[X\\u{DC38}Y]", unicode_flags,
-     Disjunction([
-         CharacterClass([
-             ["X", "X"],
-             ["Y", "Y"]
-         ]),
-         Alternative([
-             Assertion("NOT_AFTER_LEAD_SURROGATE"),
-             CharacterClass([
-                 ["\uDC38", "\uDC38"]
-             ])
-         ])
-     ]));
-
-// Invalid
-
-test("[\\u]", no_unicode_flags,
-     CharacterClass([
-         ["u", "u"]
-     ]));
-
-test("[\\uG]", no_unicode_flags,
-     CharacterClass([
-         ["u", "u"],
-         ["G", "G"]
-     ]));
-
-test("[\\uD83]", no_unicode_flags,
-     CharacterClass([
-         ["u", "u"],
-         ["D", "D"],
-         ["8", "8"],
-         ["3", "3"]
-     ]));
-
-test("[\\uD83G]", no_unicode_flags,
-     CharacterClass([
-         ["u", "u"],
-         ["D", "D"],
-         ["8", "8"],
-         ["3", "3"],
-         ["G", "G"]
-     ]));
diff -Nrup mozilla/js/src/jit-test/tests/regexp_parse/Disjunction.js mozilla-OK/js/src/jit-test/tests/regexp_parse/Disjunction.js
--- mozilla/js/src/jit-test/tests/regexp_parse/Disjunction.js	2020-02-18 02:37:52.000000000 +0300
+++ mozilla-OK/js/src/jit-test/tests/regexp_parse/Disjunction.js	1970-01-01 03:00:00.000000000 +0300
@@ -1,42 +0,0 @@
-if (typeof parseRegExp === 'undefined')
-    quit();
-
-load(libdir + "regexp_parse.js");
-
-test("a|\u3042", all_flags,
-     Disjunction([
-         Atom("a"),
-         Atom("\u3042")
-     ]));
-
-test("a|\u3042|abc", all_flags,
-     Disjunction([
-         Atom("a"),
-         Atom("\u3042"),
-         Atom("abc")
-     ]));
-
-test("|", all_flags,
-     Disjunction([
-         Empty(),
-         Empty()
-     ]));
-
-test("||", all_flags,
-     Disjunction([
-         Empty(),
-         Empty(),
-         Empty()
-     ]));
-
-test("abc|", all_flags,
-     Disjunction([
-         Atom("abc"),
-         Empty()
-     ]));
-
-test("|abc", all_flags,
-     Disjunction([
-         Empty(),
-         Atom("abc")
-     ]));
diff -Nrup mozilla/js/src/jit-test/tests/regexp_parse/Empty.js mozilla-OK/js/src/jit-test/tests/regexp_parse/Empty.js
--- mozilla/js/src/jit-test/tests/regexp_parse/Empty.js	2020-02-18 02:37:52.000000000 +0300
+++ mozilla-OK/js/src/jit-test/tests/regexp_parse/Empty.js	1970-01-01 03:00:00.000000000 +0300
@@ -1,7 +0,0 @@
-if (typeof parseRegExp === 'undefined')
-    quit();
-
-load(libdir + "regexp_parse.js");
-
-test("", all_flags,
-     Empty());
diff -Nrup mozilla/js/src/jit-test/tests/regexp_parse/Everything.js mozilla-OK/js/src/jit-test/tests/regexp_parse/Everything.js
--- mozilla/js/src/jit-test/tests/regexp_parse/Everything.js	2020-02-18 02:37:52.000000000 +0300
+++ mozilla-OK/js/src/jit-test/tests/regexp_parse/Everything.js	1970-01-01 03:00:00.000000000 +0300
@@ -1,21 +0,0 @@
-if (typeof parseRegExp === 'undefined')
-    quit();
-
-load(libdir + "regexp_parse.js");
-
-test_mix(".", no_unicode_flags,
-         CharacterClass([
-             ["\u0000", "\u0009"],
-             ["\u000b", "\u000c"],
-             ["\u000e", "\u2027"],
-             ["\u202A", "\uFFFF"]
-         ]));
-
-test_mix(".", unicode_flags,
-         AllSurrogateAndCharacterClass([
-             ["\u0000", "\u0009"],
-             ["\u000b", "\u000c"],
-             ["\u000e", "\u2027"],
-             ["\u202A", "\uD7FF"],
-             ["\uE000", "\uFFFF"]
-         ]));
diff -Nrup mozilla/js/src/jit-test/tests/regexp_parse/Group.js mozilla-OK/js/src/jit-test/tests/regexp_parse/Group.js
--- mozilla/js/src/jit-test/tests/regexp_parse/Group.js	2020-02-18 02:37:52.000000000 +0300
+++ mozilla-OK/js/src/jit-test/tests/regexp_parse/Group.js	1970-01-01 03:00:00.000000000 +0300
@@ -1,15 +0,0 @@
-if (typeof parseRegExp === 'undefined')
-    quit();
-
-load(libdir + "regexp_parse.js");
-
-test("(?:)", all_flags,
-     Empty());
-test("(?:a)", all_flags,
-     Atom("a"));
-test("X(?:a)Y", all_flags,
-     Text([
-         Atom("X"),
-         Atom("a"),
-         Atom("Y")
-     ]));
diff -Nrup mozilla/js/src/jit-test/tests/regexp_parse/Lookahead.js mozilla-OK/js/src/jit-test/tests/regexp_parse/Lookahead.js
--- mozilla/js/src/jit-test/tests/regexp_parse/Lookahead.js	2020-02-18 02:37:52.000000000 +0300
+++ mozilla-OK/js/src/jit-test/tests/regexp_parse/Lookahead.js	1970-01-01 03:00:00.000000000 +0300
@@ -1,31 +0,0 @@
-if (typeof parseRegExp === 'undefined')
-    quit();
-
-load(libdir + "regexp_parse.js");
-
-test_mix("(?=abc)", all_flags,
-         Lookahead(Atom("abc")));
-
-test_mix("(?!abc)", all_flags,
-         NegativeLookahead(Atom("abc")));
-
-test_mix("(?=abc)+", no_unicode_flags,
-         Lookahead(Atom("abc")));
-
-// Lookahead becomes Empty because max_match of Lookahead is 0 and the min vaue
-// of Quantifier is also 0.
-test("(?=abc)*", no_unicode_flags,
-     Empty());
-test("X(?=abc)*Y", no_unicode_flags,
-     Alternative([
-         Atom("X"),
-         Atom("Y"),
-     ]));
-
-test("(?=abc)?", no_unicode_flags,
-     Empty());
-test("X(?=abc)?Y", no_unicode_flags,
-     Alternative([
-         Atom("X"),
-         Atom("Y"),
-     ]));
diff -Nrup mozilla/js/src/jit-test/tests/regexp_parse/MatchOnly.js mozilla-OK/js/src/jit-test/tests/regexp_parse/MatchOnly.js
--- mozilla/js/src/jit-test/tests/regexp_parse/MatchOnly.js	2020-02-18 02:37:52.000000000 +0300
+++ mozilla-OK/js/src/jit-test/tests/regexp_parse/MatchOnly.js	1970-01-01 03:00:00.000000000 +0300
@@ -1,35 +0,0 @@
-if (typeof parseRegExp === 'undefined')
-    quit();
-
-load(libdir + "regexp_parse.js");
-
-// Leading and trailing .* are ignored if match_only==true.
-
-test_match_only(".*abc", all_flags,
-                Atom("abc"));
-test_match_only("abc.*", all_flags,
-                Atom("abc"));
-
-test_match_only(".*?abc", no_unicode_flags,
-                Alternative([
-                    Quantifier(0, kInfinity, "NON_GREEDY",
-                               CharacterClass([
-                                   ["\u0000", "\u0009"],
-                                   ["\u000b", "\u000c"],
-                                   ["\u000e", "\u2027"],
-                                   ["\u202A", "\uFFFF"]
-                               ])),
-                    Atom("abc")
-                ]));
-test_match_only(".*?abc", unicode_flags,
-                Alternative([
-                    Quantifier(0, kInfinity, "NON_GREEDY",
-                               AllSurrogateAndCharacterClass([
-                                   ["\u0000", "\u0009"],
-                                   ["\u000b", "\u000c"],
-                                   ["\u000e", "\u2027"],
-                                   ["\u202A", "\uD7FF"],
-                                   ["\uE000", "\uFFFF"]
-                               ])),
-                    Atom("abc")
-                ]));
diff -Nrup mozilla/js/src/jit-test/tests/regexp_parse/Quantifier.js mozilla-OK/js/src/jit-test/tests/regexp_parse/Quantifier.js
--- mozilla/js/src/jit-test/tests/regexp_parse/Quantifier.js	2020-02-18 02:37:52.000000000 +0300
+++ mozilla-OK/js/src/jit-test/tests/regexp_parse/Quantifier.js	1970-01-01 03:00:00.000000000 +0300
@@ -1,58 +0,0 @@
-if (typeof parseRegExp === 'undefined')
-    quit();
-
-load(libdir + "regexp_parse.js");
-
-test_mix("a*", all_flags,
-         Quantifier(0, kInfinity, "GREEDY", Atom("a")));
-test_mix("a*?", all_flags,
-         Quantifier(0, kInfinity, "NON_GREEDY", Atom("a")));
-
-test_mix("a+", all_flags,
-         Quantifier(1, kInfinity, "GREEDY", Atom("a")));
-test_mix("a+?", all_flags,
-         Quantifier(1, kInfinity, "NON_GREEDY", Atom("a")));
-
-test_mix("a?", all_flags,
-         Quantifier(0, 1, "GREEDY", Atom("a")));
-test_mix("a??", all_flags,
-         Quantifier(0, 1, "NON_GREEDY", Atom("a")));
-
-test_mix("a{3}", all_flags,
-         Quantifier(3, 3, "GREEDY", Atom("a")));
-test_mix("a{3}?", all_flags,
-         Quantifier(3, 3, "NON_GREEDY", Atom("a")));
-
-test_mix("a{3,}", all_flags,
-         Quantifier(3, kInfinity, "GREEDY", Atom("a")));
-test_mix("a{3,}?", all_flags,
-         Quantifier(3, kInfinity, "NON_GREEDY", Atom("a")));
-
-test_mix("a{3,5}", all_flags,
-         Quantifier(3, 5, "GREEDY", Atom("a")));
-test_mix("a{3,5}?", all_flags,
-         Quantifier(3, 5, "NON_GREEDY", Atom("a")));
-
-// Surrogate Pair and Quantifier
-
-test("\\uD83D\\uDC38+", no_unicode_flags,
-     Alternative([
-         Atom("\uD83D"),
-         Quantifier(1, kInfinity, "GREEDY", Atom("\uDC38"))
-     ]));
-test("\\uD83D\\uDC38+", unicode_flags,
-     Quantifier(1, kInfinity, "GREEDY", Atom("\uD83D\uDC38")));
-
-// Invalid
-
-test_mix("a{", no_unicode_flags,
-         Atom("a{"));
-test_mix("a{1", no_unicode_flags,
-         Atom("a{1"));
-test_mix("a{1,", no_unicode_flags,
-         Atom("a{1,"));
-test_mix("a{1,2", no_unicode_flags,
-         Atom("a{1,2"));
-
-test_mix("a{,", no_unicode_flags,
-         Atom("a{,"));
diff -Nrup mozilla/js/src/js.msg mozilla-OK/js/src/js.msg
--- mozilla/js/src/js.msg	2022-04-13 21:14:22.000000000 +0300
+++ mozilla-OK/js/src/js.msg	2022-04-22 05:06:08.650177835 +0300
@@ -497,7 +497,6 @@ MSG_DEF(JSMSG_INVALID_TIME_ZONE,       1
 MSG_DEF(JSMSG_UNDEFINED_CURRENCY,      0, JSEXN_TYPEERR, "undefined currency in NumberFormat() with currency style")
 
 // RegExp
-MSG_DEF(JSMSG_BACK_REF_OUT_OF_RANGE,   0, JSEXN_SYNTAXERR, "back reference out of range in regular expression")
 MSG_DEF(JSMSG_BAD_CLASS_RANGE,         0, JSEXN_SYNTAXERR, "invalid range in character class")
 MSG_DEF(JSMSG_ESCAPE_AT_END_OF_REGEXP, 0, JSEXN_SYNTAXERR, "\\ at end of pattern")
 MSG_DEF(JSMSG_EXEC_NOT_OBJORNULL,      0, JSEXN_TYPEERR, "RegExp exec method should return object or null")
@@ -510,12 +509,19 @@ MSG_DEF(JSMSG_NEWREGEXP_FLAGGED,       0
 MSG_DEF(JSMSG_NOTHING_TO_REPEAT,       0, JSEXN_SYNTAXERR, "nothing to repeat")
 MSG_DEF(JSMSG_NUMBERS_OUT_OF_ORDER,    0, JSEXN_SYNTAXERR, "numbers out of order in {} quantifier.")
 MSG_DEF(JSMSG_RANGE_WITH_CLASS_ESCAPE, 0, JSEXN_SYNTAXERR, "character class escape cannot be used in class range in regular expression")
-MSG_DEF(JSMSG_RAW_BRACE_IN_REGEP,      0, JSEXN_SYNTAXERR, "raw brace is not allowed in regular expression with unicode flag")
-MSG_DEF(JSMSG_RAW_BRACKET_IN_REGEP,    0, JSEXN_SYNTAXERR, "raw bracket is not allowed in regular expression with unicode flag")
+MSG_DEF(JSMSG_RAW_BRACKET_IN_REGEXP,   0, JSEXN_SYNTAXERR, "raw bracket is not allowed in regular expression with unicode flag")
 MSG_DEF(JSMSG_TOO_MANY_PARENS,         0, JSEXN_INTERNALERR, "too many parentheses in regular expression")
 MSG_DEF(JSMSG_UNICODE_OVERFLOW,        1, JSEXN_SYNTAXERR, "Unicode codepoint must not be greater than 0x10FFFF in {0}")
 MSG_DEF(JSMSG_UNMATCHED_RIGHT_PAREN,   0, JSEXN_SYNTAXERR, "unmatched ) in regular expression")
 MSG_DEF(JSMSG_UNTERM_CLASS,            0, JSEXN_SYNTAXERR, "unterminated character class")
+MSG_DEF(JSMSG_INVALID_PROPERTY_NAME,       0, JSEXN_SYNTAXERR, "invalid property name in regular expression")
+MSG_DEF(JSMSG_INVALID_CLASS_PROPERTY_NAME, 0, JSEXN_SYNTAXERR, "invalid class property name in regular expression")
+MSG_DEF(JSMSG_INCOMPLETE_QUANTIFIER,       0, JSEXN_SYNTAXERR, "incomplete quantifier in regular expression")
+MSG_DEF(JSMSG_INVALID_QUANTIFIER,          0, JSEXN_SYNTAXERR, "invalid quantifier in regular expression")
+MSG_DEF(JSMSG_INVALID_CAPTURE_NAME,        0, JSEXN_SYNTAXERR, "invalid capture group name in regular expression")
+MSG_DEF(JSMSG_DUPLICATE_CAPTURE_NAME,      0, JSEXN_SYNTAXERR, "duplicate capture group name in regular expression")
+MSG_DEF(JSMSG_INVALID_NAMED_REF,           0, JSEXN_SYNTAXERR, "invalid named reference in regular expression")
+MSG_DEF(JSMSG_INVALID_NAMED_CAPTURE_REF,   0, JSEXN_SYNTAXERR, "invalid named capture reference in regular expression")
 
 // Self-hosting
 MSG_DEF(JSMSG_DEFAULT_LOCALE_ERROR,    0, JSEXN_ERR, "internal error getting the default locale")
diff -Nrup mozilla/js/src/jsapi-tests/testRegExp.cpp mozilla-OK/js/src/jsapi-tests/testRegExp.cpp
--- mozilla/js/src/jsapi-tests/testRegExp.cpp	2020-02-18 02:37:53.000000000 +0300
+++ mozilla-OK/js/src/jsapi-tests/testRegExp.cpp	2022-04-22 05:03:52.098134957 +0300
@@ -2,6 +2,8 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
+#include "js/RegExp.h"
+#include "js/RegExpFlags.h"
 #include "jsapi-tests/tests.h"
 
 BEGIN_TEST(testObjectIsRegExp)
@@ -12,12 +14,12 @@ BEGIN_TEST(testObjectIsRegExp)
 
     EVAL("new Object", &val);
     JS::RootedObject obj(cx, val.toObjectOrNull());
-    CHECK(JS_ObjectIsRegExp(cx, obj, &isRegExp));
+    CHECK(JS::ObjectIsRegExp(cx, obj, &isRegExp));
     CHECK(!isRegExp);
 
     EVAL("/foopy/", &val);
     obj = val.toObjectOrNull();
-    CHECK(JS_ObjectIsRegExp(cx, obj, &isRegExp));
+    CHECK(JS::ObjectIsRegExp(cx, obj, &isRegExp));
     CHECK(isRegExp);
 
     return true;
@@ -31,15 +33,16 @@ BEGIN_TEST(testGetRegExpFlags)
 
     EVAL("/foopy/", &val);
     obj = val.toObjectOrNull();
-    CHECK_EQUAL(JS_GetRegExpFlags(cx, obj), 0u);
+    CHECK_EQUAL(JS::GetRegExpFlags(cx, obj), JS::RegExpFlags(JS::RegExpFlag::NoFlags));
 
     EVAL("/foopy/g", &val);
     obj = val.toObjectOrNull();
-    CHECK_EQUAL(JS_GetRegExpFlags(cx, obj), JSREG_GLOB);
+    CHECK_EQUAL(JS::GetRegExpFlags(cx, obj), JS::RegExpFlags(JS::RegExpFlag::Global));
 
     EVAL("/foopy/gi", &val);
     obj = val.toObjectOrNull();
-    CHECK_EQUAL(JS_GetRegExpFlags(cx, obj), (JSREG_FOLD | JSREG_GLOB));
+    CHECK_EQUAL(JS::GetRegExpFlags(cx, obj),
+                JS::RegExpFlags(JS::RegExpFlag::Global | JS::RegExpFlag::IgnoreCase));
 
     return true;
 }
@@ -52,7 +55,8 @@ BEGIN_TEST(testGetRegExpSource)
 
     EVAL("/foopy/", &val);
     obj = val.toObjectOrNull();
-    JSString* source = JS_GetRegExpSource(cx, obj);
+    JSString* source = JS::GetRegExpSource(cx, obj);
+    CHECK(source);
     CHECK(JS_FlatStringEqualsAscii(JS_ASSERT_STRING_IS_FLAT(source), "foopy"));
 
     return true;
diff -Nrup mozilla/js/src/jsapi-tests/tests.h mozilla-OK/js/src/jsapi-tests/tests.h
--- mozilla/js/src/jsapi-tests/tests.h	2021-10-26 19:49:54.000000000 +0300
+++ mozilla-OK/js/src/jsapi-tests/tests.h	2022-04-22 05:05:30.124447867 +0300
@@ -19,6 +19,7 @@
 #include "jscntxt.h"
 #include "jsgc.h"
 
+#include "js/RegExpFlags.h"
 #include "js/Vector.h"
 
 /* Note: Aborts on OOM. */
@@ -149,6 +150,30 @@ class JSAPITest
         return JSAPITestString(v ? "true" : "false");
     }
 
+    JSAPITestString toSource(JS::RegExpFlags flags)
+    {
+        JSAPITestString str;
+        if (flags.global()) {
+            str += "g";
+        }
+        if (flags.ignoreCase()) {
+            str += "i";
+        }
+        if (flags.multiline()) {
+            str += "m";
+        }
+        if (flags.dotAll()) {
+            str += "s";
+        }
+        if (flags.unicode()) {
+            str += "u";
+        }
+        if (flags.sticky()) {
+            str += "y";
+        }
+        return str;
+    }
+
     JSAPITestString toSource(JSAtom* v) {
         JS::RootedValue val(cx, JS::StringValue((JSString*)v));
         return jsvalToSource(val);
diff -Nrup mozilla/js/src/jsapi.cpp mozilla-OK/js/src/jsapi.cpp
--- mozilla/js/src/jsapi.cpp	2022-04-13 21:14:22.000000000 +0300
+++ mozilla-OK/js/src/jsapi.cpp	2022-04-22 05:03:49.708151735 +0300
@@ -44,7 +44,6 @@
 #include "builtin/Eval.h"
 #include "builtin/MapObject.h"
 #include "builtin/Promise.h"
-#include "builtin/RegExp.h"
 #include "builtin/Stream.h"
 #include "builtin/SymbolObject.h"
 #ifdef ENABLE_SIMD
@@ -76,7 +75,6 @@
 #include "vm/ErrorObject.h"
 #include "vm/HelperThreads.h"
 #include "vm/Interpreter.h"
-#include "vm/RegExpStatics.h"
 #include "vm/Runtime.h"
 #include "vm/SavedStacks.h"
 #include "vm/SelfHosting.h"
@@ -6547,138 +6545,6 @@ JS_ObjectIsDate(JSContext* cx, HandleObj
 }
 
 /************************************************************************/
-
-/*
- * Regular Expressions.
- */
-JS_PUBLIC_API(JSObject*)
-JS_NewRegExpObject(JSContext* cx, const char* bytes, size_t length, unsigned flags)
-{
-    AssertHeapIsIdle();
-    CHECK_REQUEST(cx);
-
-    ScopedJSFreePtr<char16_t> chars(InflateString(cx, bytes, length));
-    if (!chars)
-        return nullptr;
-
-    return RegExpObject::create(cx, chars.get(), length, RegExpFlag(flags), cx->tempLifoAlloc(),
-                                GenericObject);
-}
-
-JS_PUBLIC_API(JSObject*)
-JS_NewUCRegExpObject(JSContext* cx, const char16_t* chars, size_t length, unsigned flags)
-{
-    AssertHeapIsIdle();
-    CHECK_REQUEST(cx);
-
-    return RegExpObject::create(cx, chars, length, RegExpFlag(flags), cx->tempLifoAlloc(),
-                                GenericObject);
-}
-
-JS_PUBLIC_API(bool)
-JS_SetRegExpInput(JSContext* cx, HandleObject obj, HandleString input)
-{
-    AssertHeapIsIdle();
-    CHECK_REQUEST(cx);
-    assertSameCompartment(cx, input);
-
-    Handle<GlobalObject*> global = obj.as<GlobalObject>();
-    RegExpStatics* res = GlobalObject::getRegExpStatics(cx, global);
-    if (!res)
-        return false;
-
-    res->reset(input);
-    return true;
-}
-
-JS_PUBLIC_API(bool)
-JS_ClearRegExpStatics(JSContext* cx, HandleObject obj)
-{
-    AssertHeapIsIdle();
-    CHECK_REQUEST(cx);
-    MOZ_ASSERT(obj);
-
-    Handle<GlobalObject*> global = obj.as<GlobalObject>();
-    RegExpStatics* res = GlobalObject::getRegExpStatics(cx, global);
-    if (!res)
-        return false;
-
-    res->clear();
-    return true;
-}
-
-JS_PUBLIC_API(bool)
-JS_ExecuteRegExp(JSContext* cx, HandleObject obj, HandleObject reobj, char16_t* chars,
-                 size_t length, size_t* indexp, bool test, MutableHandleValue rval)
-{
-    AssertHeapIsIdle();
-    CHECK_REQUEST(cx);
-
-    Handle<GlobalObject*> global = obj.as<GlobalObject>();
-    RegExpStatics* res = GlobalObject::getRegExpStatics(cx, global);
-    if (!res)
-        return false;
-
-    RootedLinearString input(cx, NewStringCopyN<CanGC>(cx, chars, length));
-    if (!input)
-        return false;
-
-    return ExecuteRegExpLegacy(cx, res, reobj.as<RegExpObject>(), input, indexp, test, rval);
-}
-
-JS_PUBLIC_API(bool)
-JS_ExecuteRegExpNoStatics(JSContext* cx, HandleObject obj, char16_t* chars, size_t length,
-                          size_t* indexp, bool test, MutableHandleValue rval)
-{
-    AssertHeapIsIdle();
-    CHECK_REQUEST(cx);
-
-    RootedLinearString input(cx, NewStringCopyN<CanGC>(cx, chars, length));
-    if (!input)
-        return false;
-
-    return ExecuteRegExpLegacy(cx, nullptr, obj.as<RegExpObject>(), input, indexp, test,
-                               rval);
-}
-
-JS_PUBLIC_API(bool)
-JS_ObjectIsRegExp(JSContext* cx, HandleObject obj, bool* isRegExp)
-{
-    assertSameCompartment(cx, obj);
-
-    ESClass cls;
-    if (!GetBuiltinClass(cx, obj, &cls))
-        return false;
-
-    *isRegExp = cls == ESClass::RegExp;
-    return true;
-}
-
-JS_PUBLIC_API(unsigned)
-JS_GetRegExpFlags(JSContext* cx, HandleObject obj)
-{
-    AssertHeapIsIdle();
-    CHECK_REQUEST(cx);
-
-    RegExpShared* shared = RegExpToShared(cx, obj);
-    if (!shared)
-        return false;
-    return shared->getFlags();
-}
-
-JS_PUBLIC_API(JSString*)
-JS_GetRegExpSource(JSContext* cx, HandleObject obj)
-{
-    AssertHeapIsIdle();
-    CHECK_REQUEST(cx);
-
-    RegExpShared* shared = RegExpToShared(cx, obj);
-    if (!shared)
-        return nullptr;
-    return shared->getSource();
-}
-
-/************************************************************************/
 
 JS_PUBLIC_API(bool)
 JS_SetDefaultLocale(JSRuntime* rt, const char* locale)
diff -Nrup mozilla/js/src/jsapi.h mozilla-OK/js/src/jsapi.h
--- mozilla/js/src/jsapi.h	2022-01-25 01:04:29.000000000 +0300
+++ mozilla-OK/js/src/jsapi.h	2022-04-22 05:05:32.369432149 +0300
@@ -4986,7 +4986,8 @@ GetSymbolDescription(HandleSymbol symbol
     macro(toPrimitive) \
     macro(toStringTag) \
     macro(unscopables) \
-    macro(asyncIterator)
+    macro(asyncIterator) \
+    macro(matchAll)
 
 enum class SymbolCode : uint32_t {
     // There is one SymbolCode for each well-known symbol.
@@ -5596,56 +5597,6 @@ JS_ObjectIsDate(JSContext* cx, JS::Handl
 
 /************************************************************************/
 
-/*
- * Regular Expressions.
- */
-#define JSREG_FOLD      0x01u   /* fold uppercase to lowercase */
-#define JSREG_GLOB      0x02u   /* global exec, creates array of matches */
-#define JSREG_MULTILINE 0x04u   /* treat ^ and $ as begin and end of line */
-#define JSREG_STICKY    0x08u   /* only match starting at lastIndex */
-#define JSREG_UNICODE   0x10u   /* unicode */
-
-extern JS_PUBLIC_API(JSObject*)
-JS_NewRegExpObject(JSContext* cx, const char* bytes, size_t length, unsigned flags);
-
-extern JS_PUBLIC_API(JSObject*)
-JS_NewUCRegExpObject(JSContext* cx, const char16_t* chars, size_t length, unsigned flags);
-
-extern JS_PUBLIC_API(bool)
-JS_SetRegExpInput(JSContext* cx, JS::HandleObject obj, JS::HandleString input);
-
-extern JS_PUBLIC_API(bool)
-JS_ClearRegExpStatics(JSContext* cx, JS::HandleObject obj);
-
-extern JS_PUBLIC_API(bool)
-JS_ExecuteRegExp(JSContext* cx, JS::HandleObject obj, JS::HandleObject reobj,
-                 char16_t* chars, size_t length, size_t* indexp, bool test,
-                 JS::MutableHandleValue rval);
-
-/* RegExp interface for clients without a global object. */
-
-extern JS_PUBLIC_API(bool)
-JS_ExecuteRegExpNoStatics(JSContext* cx, JS::HandleObject reobj, char16_t* chars, size_t length,
-                          size_t* indexp, bool test, JS::MutableHandleValue rval);
-
-/**
- * Returns true and sets |*isRegExp| indicating whether |obj| is a RegExp
- * object or a wrapper around one, otherwise returns false on failure.
- *
- * This method returns true with |*isRegExp == false| when passed a proxy whose
- * target is a RegExp, or when passed a revoked proxy.
- */
-extern JS_PUBLIC_API(bool)
-JS_ObjectIsRegExp(JSContext* cx, JS::HandleObject obj, bool* isRegExp);
-
-extern JS_PUBLIC_API(unsigned)
-JS_GetRegExpFlags(JSContext* cx, JS::HandleObject obj);
-
-extern JS_PUBLIC_API(JSString*)
-JS_GetRegExpSource(JSContext* cx, JS::HandleObject obj);
-
-/************************************************************************/
-
 extern JS_PUBLIC_API(bool)
 JS_IsExceptionPending(JSContext* cx);
 
diff -Nrup mozilla/js/src/jscntxt.cpp mozilla-OK/js/src/jscntxt.cpp
--- mozilla/js/src/jscntxt.cpp	2022-01-25 01:04:29.000000000 +0300
+++ mozilla-OK/js/src/jscntxt.cpp	2022-04-22 05:08:35.259150204 +0300
@@ -44,6 +44,7 @@
 
 #include "gc/FreeOp.h"
 #include "gc/Marking.h"
+#include "irregexp/RegExpAPI.h"
 #include "jit/Ion.h"
 #include "jit/PcScriptCache.h"
 #include "js/CharacterEncoding.h"
@@ -116,9 +117,6 @@ JSContext::init(ContextKind kind)
         threadNative_ = (size_t)pthread_self();
 #endif
 
-        if (!regexpStack.ref().init())
-            return false;
-
         if (!fx.initInstance())
             return false;
 
@@ -132,6 +130,11 @@ JSContext::init(ContextKind kind)
             return false;
     }
 
+    isolate = irregexp::CreateIsolate(this);
+    if (!isolate) {
+        return false;
+    }
+
     // Set the ContextKind last, so that ProtectedData checks will allow us to
     // initialize this context before it becomes the runtime's active context.
     kind_ = kind;
@@ -1401,6 +1404,10 @@ JSContext::~JSContext()
         DestroyTraceLogger(traceLogger);
 #endif
 
+    if (isolate) {
+      irregexp::DestroyIsolate(isolate.ref());
+    }
+
     MOZ_ASSERT(TlsContext.get() == this);
     TlsContext.set(nullptr);
 }
@@ -1532,15 +1539,15 @@ JSContext::updateJITEnabled()
     jitIsBroken = IsJITBrokenHere();
 }
 
-size_t
-JSContext::sizeOfExcludingThis(mozilla::MallocSizeOf mallocSizeOf) const
-{
-    /*
-     * There are other JSContext members that could be measured; the following
-     * ones have been found by DMD to be worth measuring.  More stuff may be
-     * added later.
-     */
-    return cycleDetectorVector().sizeOfExcludingThis(mallocSizeOf);
+size_t JSContext::sizeOfExcludingThis(
+    mozilla::MallocSizeOf mallocSizeOf) const {
+  /*
+   * There are other JSContext members that could be measured; the following
+   * ones have been found by DMD to be worth measuring.  More stuff may be
+   * added later.
+   */
+  return cycleDetectorVector().sizeOfExcludingThis(mallocSizeOf) +
+         irregexp::IsolateSizeOfIncludingThis(isolate, mallocSizeOf);
 }
 
 void
diff -Nrup mozilla/js/src/jscntxt.h mozilla-OK/js/src/jscntxt.h
--- mozilla/js/src/jscntxt.h	2022-01-25 01:04:29.000000000 +0300
+++ mozilla-OK/js/src/jscntxt.h	2022-04-22 05:08:45.994074970 +0300
@@ -11,6 +11,7 @@
 
 #include "mozilla/MemoryReporting.h"
 
+#include "irregexp/RegExpTypes.h"
 #include "js/CharacterEncoding.h"
 #include "js/GCVector.h"
 #include "js/Result.h"
@@ -346,8 +347,8 @@ struct JSContext : public JS::RootingCon
      */
     js::ThreadLocalData<js::jit::JitActivation*> jitActivation;
 
-    // Information about the heap allocated backtrack stack used by RegExp JIT code.
-    js::ThreadLocalData<js::irregexp::RegExpStack> regexpStack;
+    // Shim for V8 interfaces used by irregexp code
+    js::ThreadLocalData<js::irregexp::Isolate*> isolate;
 
     /*
      * Points to the most recent activation running on the thread.
@@ -859,6 +860,19 @@ struct JSContext : public JS::RootingCon
         return handlingJitInterrupt_;
     }
 
+    void* addressOfInterrupt() {
+        return &interrupt_;
+    }
+    void* addressOfInterruptRegExpJit() {
+        return &interruptRegExpJit_;
+    }
+    void* addressOfJitStackLimit() {
+        return &jitStackLimit;
+    }
+    void* addressOfJitStackLimitNoInterrupt() {
+        return &jitStackLimitNoInterrupt;
+    }
+
     /* Futex state, used by Atomics.wait() and Atomics.wake() on the Atomics object */
     js::FutexThread fx;
 
diff -Nrup mozilla/js/src/jsgc.cpp mozilla-OK/js/src/jsgc.cpp
--- mozilla/js/src/jsgc.cpp	2022-04-13 21:14:22.000000000 +0300
+++ mozilla-OK/js/src/jsgc.cpp	2022-04-22 05:04:50.237727441 +0300
@@ -2768,7 +2768,8 @@ static const AllocKinds UpdatePhaseMisc
     AllocKind::OBJECT_GROUP,
     AllocKind::STRING,
     AllocKind::JITCODE,
-    AllocKind::SCOPE
+    AllocKind::SCOPE,
+    AllocKind::REGEXP_SHARED
 };
 
 static const AllocKinds UpdatePhaseObjects {
diff -Nrup mozilla/js/src/jsiter.cpp mozilla-OK/js/src/jsiter.cpp
--- mozilla/js/src/jsiter.cpp	2022-04-13 21:14:22.000000000 +0300
+++ mozilla-OK/js/src/jsiter.cpp	2022-04-22 05:05:32.382432058 +0300
@@ -23,6 +23,7 @@
 #include "jstypes.h"
 #include "jsutil.h"
 
+#include "builtin/SelfHostingDefines.h"
 #include "ds/Sort.h"
 #include "gc/FreeOp.h"
 #include "gc/Marking.h"
@@ -1337,6 +1338,78 @@ js::NewStringIteratorObject(JSContext* c
     return NewObjectWithGivenProto<StringIteratorObject>(cx, proto, newKind);
 }
 
+static const Class RegExpStringIteratorPrototypeClass = {
+    "RegExp String Iterator", 0
+};
+
+enum {
+  // The regular expression used for iteration. May hold the original RegExp
+  // object when it is reused instead of a new RegExp object.
+  RegExpStringIteratorSlotRegExp,
+
+  // The String value being iterated upon.
+  RegExpStringIteratorSlotString,
+
+  // The source string of the original RegExp object. Used to validate we can
+  // reuse the original RegExp object for matching.
+  RegExpStringIteratorSlotSource,
+
+  // The flags of the original RegExp object.
+  RegExpStringIteratorSlotFlags,
+
+  // When non-negative, this slot holds the current lastIndex position when
+  // reusing the original RegExp object for matching. When set to |-1|, the
+  // iterator has finished. When set to any other negative value, the
+  // iterator is not yet exhausted and we're not on the fast path and we're
+  // not reusing the input RegExp object.
+  RegExpStringIteratorSlotLastIndex,
+
+  RegExpStringIteratorSlotCount
+};
+
+static_assert(RegExpStringIteratorSlotRegExp ==
+                  REGEXP_STRING_ITERATOR_REGEXP_SLOT,
+              "RegExpStringIteratorSlotRegExp must match self-hosting define "
+              "for regexp slot.");
+static_assert(RegExpStringIteratorSlotString ==
+                  REGEXP_STRING_ITERATOR_STRING_SLOT,
+              "RegExpStringIteratorSlotString must match self-hosting define "
+              "for string slot.");
+static_assert(RegExpStringIteratorSlotSource ==
+                  REGEXP_STRING_ITERATOR_SOURCE_SLOT,
+              "RegExpStringIteratorSlotString must match self-hosting define "
+              "for source slot.");
+static_assert(RegExpStringIteratorSlotFlags ==
+                  REGEXP_STRING_ITERATOR_FLAGS_SLOT,
+              "RegExpStringIteratorSlotFlags must match self-hosting define "
+              "for flags slot.");
+static_assert(RegExpStringIteratorSlotLastIndex ==
+                  REGEXP_STRING_ITERATOR_LASTINDEX_SLOT,
+              "RegExpStringIteratorSlotLastIndex must match self-hosting "
+              "define for lastIndex slot.");
+
+const Class RegExpStringIteratorObject::class_ = {
+    "RegExp String Iterator",
+    JSCLASS_HAS_RESERVED_SLOTS(RegExpStringIteratorSlotCount)
+};
+
+static const JSFunctionSpec regexp_string_iterator_methods[] = {
+    JS_SELF_HOSTED_FN("next", "RegExpStringIteratorNext", 0, 0),
+    JS_FS_END
+};
+
+RegExpStringIteratorObject* js::NewRegExpStringIteratorObject(
+    JSContext* cx, NewObjectKind newKind) {
+  RootedObject proto(cx, GlobalObject::getOrCreateRegExpStringIteratorPrototype(
+                             cx, cx->global()));
+  if (!proto) {
+    return nullptr;
+  }
+
+  return NewObjectWithGivenProto<RegExpStringIteratorObject>(cx, proto,
+                                                             newKind);
+}
+
 JSObject*
 js::ValueToIterator(JSContext* cx, unsigned flags, HandleValue vp)
 {
@@ -1749,6 +1822,32 @@ GlobalObject::initStringIteratorProto(JS
     return true;
 }
 
+/* static */ bool
+GlobalObject::initRegExpStringIteratorProto(JSContext* cx, Handle<GlobalObject*> global)
+{
+  if (global->getReservedSlot(REGEXP_STRING_ITERATOR_PROTO).isObject()) {
+    return true;
+  }
+
+  RootedObject iteratorProto(cx, GlobalObject::getOrCreateIteratorPrototype(cx, global));
+  if (!iteratorProto) {
+    return false;
+  }
+
+  const Class* cls = &RegExpStringIteratorPrototypeClass;
+  RootedObject proto(cx, GlobalObject::createBlankPrototypeInheriting(cx, global, cls,
+                                                                      iteratorProto));
+  if (!proto ||
+      !DefinePropertiesAndFunctions(cx, proto, nullptr, regexp_string_iterator_methods) ||
+      !DefineToStringTag(cx, proto, cx->names().RegExpStringIterator))
+  {
+    return false;
+  }
+
+  global->setReservedSlot(REGEXP_STRING_ITERATOR_PROTO, ObjectValue(*proto));
+  return true;
+}
+
 JSObject*
 js::InitLegacyIteratorClass(JSContext* cx, HandleObject obj)
 {
diff -Nrup mozilla/js/src/jsiter.h mozilla-OK/js/src/jsiter.h
--- mozilla/js/src/jsiter.h	2020-02-18 02:37:53.000000000 +0300
+++ mozilla-OK/js/src/jsiter.h	2022-04-22 05:05:32.395431967 +0300
@@ -157,6 +157,15 @@ class StringIteratorObject : public JSOb
 StringIteratorObject*
 NewStringIteratorObject(JSContext* cx, NewObjectKind newKind = GenericObject);
 
+class RegExpStringIteratorObject : public NativeObject
+{
+ public:
+  static const Class class_;
+};
+
+RegExpStringIteratorObject*
+NewRegExpStringIteratorObject(JSContext* cx, NewObjectKind newKind = GenericObject);
+
 JSObject*
 GetIterator(JSContext* cx, HandleObject obj, unsigned flags);
 
diff -Nrup mozilla/js/src/jsstr.cpp mozilla-OK/js/src/jsstr.cpp
--- mozilla/js/src/jsstr.cpp	2022-04-13 21:14:22.000000000 +0300
+++ mozilla-OK/js/src/jsstr.cpp	2022-04-22 05:05:32.396431960 +0300
@@ -3281,6 +3281,36 @@ JSString* js::str_replaceAll_string_raw(
     return ReplaceAll<Latin1Char, Latin1Char>(cx, str, search, repl);
 }
 
+static ArrayObject*
+NewFullyAllocatedStringArray(JSContext* cx, HandleObjectGroup group, uint32_t length)
+{
+    ArrayObject* array = NewFullyAllocatedArrayTryUseGroup(cx, group, length);
+    if (!array)
+        return nullptr;
+
+    // Only string values will be added to this array. Inform TI early about
+    // the element type, so we can directly initialize all elements using
+    // NativeObject::initDenseElement() instead of the slightly more expensive
+    // NativeObject::initDenseElementWithType() method.
+    // Since this function is never called to create a zero-length array, it's
+    // always necessary and correct to call AddTypePropertyId here.
+    MOZ_ASSERT(length > 0);
+    AddTypePropertyId(cx, array, JSID_VOID, TypeSet::StringType());
+
+    return array;
+}
+
+static ArrayObject*
+SingleElementStringArray(JSContext* cx, HandleObjectGroup group, HandleLinearString str)
+{
+    ArrayObject* array = NewFullyAllocatedStringArray(cx, group, 1);
+    if (!array)
+        return nullptr;
+    array->setDenseInitializedLength(1);
+    array->initDenseElement(0, StringValue(str));
+    return array;
+}
+
 // ES 2016 draft Mar 25, 2016 21.1.3.17 steps 4, 8, 12-18.
 static ArrayObject*
 SplitHelper(JSContext* cx, HandleLinearString str, uint32_t limit, HandleLinearString sep,
@@ -3300,8 +3330,7 @@ SplitHelper(JSContext* cx, HandleLinearS
             return NewFullyAllocatedArrayTryUseGroup(cx, group, 0);
 
         // Steps 12.c-e.
-        RootedValue v(cx, StringValue(str));
-        return NewCopiedArrayTryUseGroup(cx, group, v.address(), 1);
+        return SingleElementStringArray(cx, group, str);
     }
 
     // Step 3 (reordered).
@@ -3388,19 +3417,22 @@ CharSplitHelper(JSContext* cx, HandleLin
 
     js::StaticStrings& staticStrings = cx->staticStrings();
     uint32_t resultlen = (limit < strLength ? limit : strLength);
+    MOZ_ASSERT(limit > 0 && resultlen > 0,
+               "Neither limit nor strLength is zero, so resultlen is greater than zero.");
 
-    AutoValueVector splits(cx);
-    if (!splits.reserve(resultlen))
+    RootedArrayObject splits(cx, NewFullyAllocatedStringArray(cx, group, resultlen));
+    if (!splits)
         return nullptr;
+    splits->ensureDenseInitializedLength(cx, 0, resultlen);
 
     for (size_t i = 0; i < resultlen; ++i) {
         JSString* sub = staticStrings.getUnitStringForElement(cx, str, i);
         if (!sub)
             return nullptr;
-        splits.infallibleAppend(StringValue(sub));
+        splits->initDenseElement(i, StringValue(sub));
     }
 
-    return NewCopiedArrayTryUseGroup(cx, group, splits.begin(), splits.length());
+    return splits;
 }
 
 template <typename TextChar>
@@ -3416,34 +3448,36 @@ SplitSingleCharHelper(JSContext* cx, Han
     }
 
     // Handle zero-occurrence case - return input string in an array.
-    if (count == 0) {
-        RootedValue strValue(cx, StringValue(str.get()));
-        return NewCopiedArrayTryUseGroup(cx, group, &strValue.get(), 1);
-    }
+    if (count == 0)
+        return SingleElementStringArray(cx, group, str);
 
-    // Reserve memory for substring values.
-    AutoValueVector splits(cx);
-    if (!splits.reserve(count + 1))
+    // Create the result array for the substring values.
+    RootedArrayObject splits(cx, NewFullyAllocatedStringArray(cx, group, count + 1));
+    if (!splits)
         return nullptr;
+    splits->ensureDenseInitializedLength(cx, 0, count + 1);
 
     // Add substrings.
+    uint32_t splitsIndex = 0;
     size_t lastEndIndex = 0;
     for (size_t index = 0; index < textLen; index++) {
         if (static_cast<char16_t>(text[index]) == patCh) {
             size_t subLength = size_t(index - lastEndIndex);
             JSString* sub = NewDependentString(cx, str, lastEndIndex, subLength);
-            if (!sub || !splits.append(StringValue(sub)))
+            if (!sub)
                 return nullptr;
+            splits->initDenseElement(splitsIndex++, StringValue(sub));
             lastEndIndex = index + 1;
         }
     }
 
     // Add substring for tail of string (after last match).
     JSString* sub = NewDependentString(cx, str, lastEndIndex, textLen - lastEndIndex);
-    if (!sub || !splits.append(StringValue(sub)))
+    if (!sub)
         return nullptr;
+    splits->initDenseElement(splitsIndex++, StringValue(sub));
 
-    return NewCopiedArrayTryUseGroup(cx, group, splits.begin(), splits.length());
+    return splits;
 }
 
 // ES 2016 draft Mar 25, 2016 21.1.3.17 steps 4, 8, 12-18.
@@ -3468,6 +3502,8 @@ ArrayObject*
 js::str_split_string(JSContext* cx, HandleObjectGroup group, HandleString str, HandleString sep,
                      uint32_t limit)
 {
+    MOZ_ASSERT(limit > 0, "Only called for strictly positive limit.");
+
     RootedLinearString linearStr(cx, str->ensureLinear(cx));
     if (!linearStr)
         return nullptr;
@@ -3563,6 +3599,7 @@ static const JSFunctionSpec string_metho
 
     /* Perl-ish methods (search is actually Python-esque). */
     JS_SELF_HOSTED_FN("match", "String_match",        1,0),
+    JS_SELF_HOSTED_FN("matchAll", "String_matchAll",  1,0),
     JS_SELF_HOSTED_FN("search", "String_search",      1,0),
     JS_SELF_HOSTED_FN("replace", "String_replace",    2,0),
     JS_SELF_HOSTED_FN("replaceAll", "String_replaceAll", 2, 0),
@@ -3833,7 +3870,7 @@ static const JSFunctionSpec string_stati
     JS_INLINABLE_FN("fromCharCode", js::str_fromCharCode, 1, 0, StringFromCharCode),
     JS_INLINABLE_FN("fromCodePoint", js::str_fromCodePoint, 1, 0, StringFromCodePoint),
 
-    JS_SELF_HOSTED_FN("raw",             "String_static_raw",           2,0),
+    JS_SELF_HOSTED_FN("raw",             "String_static_raw",           1,0),
     JS_SELF_HOSTED_FN("substring",       "String_static_substring",     3,0),
     JS_SELF_HOSTED_FN("substr",          "String_static_substr",        3,0),
     JS_SELF_HOSTED_FN("slice",           "String_static_slice",         3,0),
diff -Nrup mozilla/js/src/moz.build mozilla-OK/js/src/moz.build
--- mozilla/js/src/moz.build	2022-01-25 01:04:29.000000000 +0300
+++ mozilla-OK/js/src/moz.build	2022-04-22 05:08:45.995074963 +0300
@@ -143,6 +143,8 @@ EXPORTS.js += [
     '../public/Proxy.h',
     '../public/Realm.h',
     '../public/RefCounted.h',
+    '../public/RegExp.h',
+    '../public/RegExpFlags.h',
     '../public/RequiredDefines.h',
     '../public/Result.h',
     '../public/RootingAPI.h',
@@ -167,6 +169,10 @@ EXPORTS.js += [
     '../public/WeakMapPtr.h',
 ]
 
+SOURCES += [
+    'util/Text.cpp',
+]
+
 UNIFIED_SOURCES += [
     'builtin/AtomicsObject.cpp',
     'builtin/DataViewObject.cpp',
@@ -217,14 +223,6 @@ UNIFIED_SOURCES += [
     'gc/Verifier.cpp',
     'gc/Zone.cpp',
     'gc/ZoneGroup.cpp',
-    'irregexp/NativeRegExpMacroAssembler.cpp',
-    'irregexp/RegExpAST.cpp',
-    'irregexp/RegExpCharacters.cpp',
-    'irregexp/RegExpEngine.cpp',
-    'irregexp/RegExpInterpreter.cpp',
-    'irregexp/RegExpMacroAssembler.cpp',
-    'irregexp/RegExpParser.cpp',
-    'irregexp/RegExpStack.cpp',
     'jit/AliasAnalysis.cpp',
     'jit/AliasAnalysisShared.cpp',
     'jit/AlignmentMaskAnalysis.cpp',
@@ -659,9 +657,33 @@ ReservedWordsGenerated.inputs += [
     'frontend/ReservedWords.h'
 ]
 
-DIRS += [
-    'build',
-] + (['new-regexp'] if CONFIG['ENABLE_NEW_REGEXP'] else [])
+SOURCES += [
+    'irregexp/imported/regexp-ast.cc',
+    'irregexp/imported/regexp-bytecode-generator.cc',
+    'irregexp/imported/regexp-bytecode-peephole.cc',
+    'irregexp/imported/regexp-bytecodes.cc',
+    'irregexp/imported/regexp-compiler-tonode.cc',
+    'irregexp/imported/regexp-compiler.cc',
+    'irregexp/imported/regexp-dotprinter.cc',
+    'irregexp/imported/regexp-interpreter.cc',
+    'irregexp/imported/regexp-macro-assembler-tracer.cc',
+    'irregexp/imported/regexp-macro-assembler.cc',
+    'irregexp/imported/regexp-parser.cc',
+    'irregexp/imported/regexp-stack.cc',
+    'irregexp/RegExpAPI.cpp',
+    'irregexp/RegExpNativeMacroAssembler.cpp',
+    'irregexp/RegExpShim.cpp',
+    'irregexp/util/UnicodeShim.cpp'
+]
+
+if CONFIG['ENABLE_INTL_API']:
+    CXXFLAGS += ['-DV8_INTL_SUPPORT']
+    SOURCES += [
+        'irregexp/imported/property-sequences.cc',
+        'irregexp/imported/special-case.cc'
+    ]
+
+DIRS += ['build']
 
 
 FINAL_LIBRARY = 'js'
diff -Nrup mozilla/js/src/moz.build.later mozilla-OK/js/src/moz.build.later
--- mozilla/js/src/moz.build.later	1970-01-01 03:00:00.000000000 +0300
+++ mozilla-OK/js/src/moz.build.later	2022-04-22 05:06:08.652177821 +0300
@@ -0,0 +1,10 @@
+--- js/src/moz.build
++++ js/src/moz.build
+@@ -114,6 +114,7 @@
+     'frontend',
+     'gc',
+     'jit',
++    'irregexp',
+     'perf',
+     'proxy',
+     'threading',
diff -Nrup mozilla/js/src/shell/js.cpp mozilla-OK/js/src/shell/js.cpp
--- mozilla/js/src/shell/js.cpp	2022-04-13 21:14:22.000000000 +0300
+++ mozilla-OK/js/src/shell/js.cpp	2022-04-22 05:06:08.736177231 +0300
@@ -8101,6 +8101,11 @@ SetContextOptions(JSContext* cx, const O
     if (warmUpThreshold >= 0)
         jit::JitOptions.baselineWarmUpThreshold = warmUpThreshold;
 
+    warmUpThreshold = op.getIntOption("regexp-warmup-threshold");
+    if (warmUpThreshold >= 0) {
+        jit::JitOptions.regexpWarmUpThreshold = warmUpThreshold;
+    }
+
     if (op.getBoolOption("baseline-eager"))
         jit::JitOptions.baselineWarmUpThreshold = 0;
 
@@ -8415,6 +8420,11 @@ main(int argc, char** argv, char** envp)
         || !op.addBoolOption('\0', "no-wasm-baseline", "Disable wasm baseline compiler")
         || !op.addBoolOption('\0', "no-wasm-ion", "Disable wasm ion compiler")
         || !op.addBoolOption('\0', "no-native-regexp", "Disable native regexp compilation")
+        || !op.addIntOption(
+          '\0', "regexp-warmup-threshold", "COUNT",
+          "Wait for COUNT invocations before compiling regexps to native code "
+          "(default 10)",
+          -1)
         || !op.addBoolOption('\0', "no-unboxed-objects", "Disable creating unboxed plain objects")
         || !op.addBoolOption('\0', "wasm-check-bce", "Always generate wasm bounds check, even redundant ones.")
         || !op.addBoolOption('\0', "wasm-test-mode", "Enable wasm testing mode, creating synthetic "
diff -Nrup mozilla/js/src/tests/non262/RegExp/RegExpExec-exec-type-check.js mozilla-OK/js/src/tests/non262/RegExp/RegExpExec-exec-type-check.js
--- mozilla/js/src/tests/non262/RegExp/RegExpExec-exec-type-check.js	1970-01-01 03:00:00.000000000 +0300
+++ mozilla-OK/js/src/tests/non262/RegExp/RegExpExec-exec-type-check.js	2022-04-22 05:08:33.241164354 +0300
@@ -0,0 +1,12 @@
+// Bug 1667094.
+
+var obj = {
+  exec() {
+    return function(){};
+  }
+};
+
+assertEq(RegExp.prototype.test.call(obj, ""), true);
+
+if (typeof reportCompare === "function")
+    reportCompare(true, true);
diff -Nrup mozilla/js/src/tests/non262/extensions/bad-regexp-data-clone.js mozilla-OK/js/src/tests/non262/extensions/bad-regexp-data-clone.js
--- mozilla/js/src/tests/non262/extensions/bad-regexp-data-clone.js	1970-01-01 03:00:00.000000000 +0300
+++ mozilla-OK/js/src/tests/non262/extensions/bad-regexp-data-clone.js	2022-04-22 05:03:54.165120507 +0300
@@ -0,0 +1,20 @@
+// |reftest| skip-if(!xulRuntime.shell)
+// -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+// Any copyright is dedicated to the Public Domain.
+// http://creativecommons.org/licenses/publicdomain/
+
+let data = new Uint8Array([
+  104,97,108,101,6,0,255,255,95,98,
+  0,0,0,0,0,104,97,108,101,9,0,255,
+  255,95,98,115,0,0,0,0,0,0,65,0,0,
+  0,0,0,0,0,0,0,0,0,0,0,0,0
+]);
+let cloneBuffer = serialize(null);
+cloneBuffer.clonebuffer = data.buffer;
+
+// One of the bytes above encodes a JS::RegExpFlags, but that byte contains bits
+// outside of JS::RegExpFlag::AllFlags and so will trigger an error.
+assertThrowsInstanceOf(() => deserialize(cloneBuffer), InternalError);
+
+if (typeof reportCompare === "function")
+  reportCompare(0, 0, 'ok');
diff -Nrup mozilla/js/src/util/Text.cpp mozilla-OK/js/src/util/Text.cpp
--- mozilla/js/src/util/Text.cpp	1970-01-01 03:00:00.000000000 +0300
+++ mozilla-OK/js/src/util/Text.cpp	2022-04-22 05:03:56.435104571 +0300
@@ -0,0 +1,37 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
+ * vim: set ts=8 sts=2 et sw=2 tw=80:
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "util/Text.h"
+
+#include "mozilla/Assertions.h"
+#include "vm/Unicode.h"
+
+using namespace JS;
+using namespace js;
+
+size_t
+js::unicode::CountCodePoints(const char16_t* begin, const char16_t* end)
+{
+    MOZ_ASSERT(begin <= end);
+
+    size_t count = 0;
+
+    const char16_t* ptr = begin;
+    while (ptr < end) {
+        count++;
+
+        if (!IsLeadSurrogate(*ptr++)) {
+            continue;
+        }
+
+        if (ptr < end && IsTrailSurrogate(*ptr)) {
+            ptr++;
+        }
+    }
+    MOZ_ASSERT(ptr == end, "should have consumed the full range");
+
+    return count;
+}
diff -Nrup mozilla/js/src/util/Text.h mozilla-OK/js/src/util/Text.h
--- mozilla/js/src/util/Text.h	1970-01-01 03:00:00.000000000 +0300
+++ mozilla-OK/js/src/util/Text.h	2022-04-22 05:03:56.435104571 +0300
@@ -0,0 +1,27 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
+ * vim: set ts=8 sts=2 et sw=2 tw=80:
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef util_Text_h
+#define util_Text_h
+
+#include <stddef.h>
+
+namespace js {
+
+namespace unicode {
+/**
+ * Count the number of code points in [begin, end].
+ *
+ * Every sequence of 16-bit units is considered valid.  Lone surrogates are
+ * treated as if they represented a code point of the same value.
+ */
+extern size_t
+CountCodePoints(const char16_t* begin, const char16_t* end);
+} // namespace unicode
+
+} // namespace js
+
+#endif // util_Text_h
diff -Nrup mozilla/js/src/vm/CommonPropertyNames.h mozilla-OK/js/src/vm/CommonPropertyNames.h
--- mozilla/js/src/vm/CommonPropertyNames.h	2022-04-22 04:47:49.543901574 +0300
+++ mozilla-OK/js/src/vm/CommonPropertyNames.h	2022-04-22 05:05:32.396431960 +0300
@@ -105,6 +105,7 @@
     macro(displayURL, displayURL, "displayURL") \
     macro(do, do_, "do") \
     macro(done, done, "done") \
+    macro(dotAll, dotAll, "dotAll") \
     macro(dotGenerator, dotGenerator, ".generator") \
     macro(dotThis, dotThis, ".this") \
     macro(each, each, "each") \
@@ -167,6 +168,7 @@
     macro(global, global, "global") \
     macro(globalThis, globalThis, "globalThis") \
     macro(group, group, "group") \
+    macro(groups, groups, "groups") \
     macro(Handle, Handle, "Handle") \
     macro(has, has, "has") \
     macro(hasOwn, hasOwn, "hasOwn") \
@@ -347,6 +349,7 @@
     macro(ReadableStreamTee, ReadableStreamTee, "ReadableStreamTee") \
     macro(reason, reason, "reason") \
     macro(RegExpFlagsGetter, RegExpFlagsGetter, "RegExpFlagsGetter") \
+    macro(RegExpStringIterator, RegExpStringIterator, "RegExp String Iterator") \
     macro(Reify, Reify, "Reify") \
     macro(reject, reject, "reject") \
     macro(rejected, rejected, "rejected") \
diff -Nrup mozilla/js/src/vm/GlobalObject.cpp mozilla-OK/js/src/vm/GlobalObject.cpp
--- mozilla/js/src/vm/GlobalObject.cpp	2021-10-26 19:49:54.000000000 +0300
+++ mozilla-OK/js/src/vm/GlobalObject.cpp	2022-04-22 05:05:32.407431882 +0300
@@ -489,63 +489,30 @@ GlobalObject::initSelfHostingBuiltins(JS
         return false;
     }
 
-    RootedValue std_isConcatSpreadable(cx);
-    std_isConcatSpreadable.setSymbol(cx->wellKnownSymbols().get(JS::SymbolCode::isConcatSpreadable));
-    if (!JS_DefineProperty(cx, global, "std_isConcatSpreadable", std_isConcatSpreadable,
-                           JSPROP_PERMANENT | JSPROP_READONLY))
-    {
-        return false;
-    }
-
-    // Define a top-level property 'std_iterator' with the name of the method
-    // used by for-of loops to create an iterator.
-    RootedValue std_iterator(cx);
-    std_iterator.setSymbol(cx->wellKnownSymbols().get(JS::SymbolCode::iterator));
-    if (!JS_DefineProperty(cx, global, "std_iterator", std_iterator,
-                           JSPROP_PERMANENT | JSPROP_READONLY))
-    {
-        return false;
-    }
-
-    RootedValue std_match(cx);
-    std_match.setSymbol(cx->wellKnownSymbols().get(JS::SymbolCode::match));
-    if (!JS_DefineProperty(cx, global, "std_match", std_match,
-                           JSPROP_PERMANENT | JSPROP_READONLY))
-    {
-        return false;
-    }
-
-    RootedValue std_replace(cx);
-    std_replace.setSymbol(cx->wellKnownSymbols().get(JS::SymbolCode::replace));
-    if (!JS_DefineProperty(cx, global, "std_replace", std_replace,
-                           JSPROP_PERMANENT | JSPROP_READONLY))
-    {
-        return false;
-    }
-
-    RootedValue std_search(cx);
-    std_search.setSymbol(cx->wellKnownSymbols().get(JS::SymbolCode::search));
-    if (!JS_DefineProperty(cx, global, "std_search", std_search,
-                           JSPROP_PERMANENT | JSPROP_READONLY))
-    {
-        return false;
-    }
-
-    RootedValue std_species(cx);
-    std_species.setSymbol(cx->wellKnownSymbols().get(JS::SymbolCode::species));
-    if (!JS_DefineProperty(cx, global, "std_species", std_species,
-                           JSPROP_PERMANENT | JSPROP_READONLY))
-    {
-        return false;
-    }
-
-    RootedValue std_split(cx);
-    std_split.setSymbol(cx->wellKnownSymbols().get(JS::SymbolCode::split));
-    if (!JS_DefineProperty(cx, global, "std_split", std_split,
-                           JSPROP_PERMANENT | JSPROP_READONLY))
-    {
+    struct SymbolAndName {
+        JS::SymbolCode code;
+        const char* name;
+    };
+
+  SymbolAndName wellKnownSymbols[] = {
+      {JS::SymbolCode::isConcatSpreadable, "std_isConcatSpreadable"},
+      {JS::SymbolCode::iterator, "std_iterator"},
+      {JS::SymbolCode::match, "std_match"},
+      {JS::SymbolCode::matchAll, "std_matchAll"},
+      {JS::SymbolCode::replace, "std_replace"},
+      {JS::SymbolCode::search, "std_search"},
+      {JS::SymbolCode::species, "std_species"},
+      {JS::SymbolCode::split, "std_split"},
+  };
+
+  RootedValue symVal(cx);
+  for (const auto& sym : wellKnownSymbols) {
+    symVal.setSymbol(cx->wellKnownSymbols().get(sym.code));
+    if (!JS_DefineProperty(cx, global, sym.name, symVal,
+                           JSPROP_PERMANENT | JSPROP_READONLY)) {
         return false;
     }
+  }
 
     return InitBareBuiltinCtor(cx, global, JSProto_Array) &&
            InitBareBuiltinCtor(cx, global, JSProto_TypedArray) &&
diff -Nrup mozilla/js/src/vm/GlobalObject.h mozilla-OK/js/src/vm/GlobalObject.h
--- mozilla/js/src/vm/GlobalObject.h	2022-01-25 01:04:29.000000000 +0300
+++ mozilla-OK/js/src/vm/GlobalObject.h	2022-04-22 05:05:32.416431819 +0300
@@ -77,6 +77,7 @@ class GlobalObject : public NativeObject
         ITERATOR_PROTO,
         ARRAY_ITERATOR_PROTO,
         STRING_ITERATOR_PROTO,
+        REGEXP_STRING_ITERATOR_PROTO,
         LEGACY_GENERATOR_OBJECT_PROTO,
         STAR_GENERATOR_OBJECT_PROTO,
         STAR_GENERATOR_FUNCTION_PROTO,
@@ -585,6 +586,12 @@ class GlobalObject : public NativeObject
     }
 
     static NativeObject*
+    getOrCreateRegExpStringIteratorPrototype(JSContext* cx, Handle<GlobalObject*> global) {
+        return MaybeNativeObject(getOrCreateObject(cx, global, REGEXP_STRING_ITERATOR_PROTO,
+                                               initRegExpStringIteratorProto));
+    }
+
+    static NativeObject*
     getOrCreateLegacyGeneratorObjectPrototype(JSContext* cx, Handle<GlobalObject*> global) {
         return MaybeNativeObject(getOrCreateObject(cx, global, LEGACY_GENERATOR_OBJECT_PROTO,
                                                    initLegacyGeneratorProto));
@@ -776,6 +783,7 @@ class GlobalObject : public NativeObject
     static bool initIteratorProto(JSContext* cx, Handle<GlobalObject*> global);
     static bool initArrayIteratorProto(JSContext* cx, Handle<GlobalObject*> global);
     static bool initStringIteratorProto(JSContext* cx, Handle<GlobalObject*> global);
+    static bool initRegExpStringIteratorProto(JSContext* cx, Handle<GlobalObject*> global);
 
     // Implemented in vm/GeneratorObject.cpp.
     static bool initLegacyGeneratorProto(JSContext* cx, Handle<GlobalObject*> global);
diff -Nrup mozilla/js/src/vm/Interpreter.cpp mozilla-OK/js/src/vm/Interpreter.cpp
--- mozilla/js/src/vm/Interpreter.cpp	2022-04-13 21:14:22.000000000 +0300
+++ mozilla-OK/js/src/vm/Interpreter.cpp	2022-04-22 05:05:19.763520486 +0300
@@ -4485,8 +4485,7 @@ js::LambdaArrow(JSContext* cx, HandleFun
 {
     MOZ_ASSERT(fun->isArrow());
 
-    JSFunction* clone = CloneFunctionObjectIfNotSingleton(cx, fun, parent, nullptr,
-                                                          TenuredObject);
+    JSFunction* clone = CloneFunctionObjectIfNotSingleton(cx, fun, parent);
     if (!clone)
         return nullptr;
 
diff -Nrup mozilla/js/src/vm/MatchPairs.h mozilla-OK/js/src/vm/MatchPairs.h
--- mozilla/js/src/vm/MatchPairs.h	2022-01-25 01:04:29.000000000 +0300
+++ mozilla-OK/js/src/vm/MatchPairs.h	2022-04-22 05:08:30.727181975 +0300
@@ -79,6 +79,7 @@ class MatchPairs
     bool initArrayFrom(MatchPairs& copyFrom);
     void forgetArray() { pairs_ = nullptr; }
 
+  public:
     void checkAgainst(size_t inputLength) {
 #ifdef DEBUG
         for (size_t i = 0; i < pairCount_; i++) {
@@ -91,7 +92,6 @@ class MatchPairs
 #endif
     }
 
-  public:
     /* Querying functions in the style of RegExpStatics. */
     bool   empty() const           { return pairCount_ == 0; }
     size_t pairCount() const       { MOZ_ASSERT(pairCount_ > 0); return pairCount_; }
diff -Nrup mozilla/js/src/vm/MutexIDs.h mozilla-OK/js/src/vm/MutexIDs.h
--- mozilla/js/src/vm/MutexIDs.h	2021-10-26 19:49:54.000000000 +0300
+++ mozilla-OK/js/src/vm/MutexIDs.h	2022-04-22 05:04:35.650829686 +0300
@@ -46,6 +46,7 @@
   _(WasmCompileTaskState,        500) \
                                       \
   _(IcuTimeZoneStateMutex,       600) \
+  _(IrregexpLazyStatic,          600) \
   _(TraceLoggerGraphState,       600) \
   _(VTuneLock,                   600)
 
diff -Nrup mozilla/js/src/vm/RegExpObject.cpp mozilla-OK/js/src/vm/RegExpObject.cpp
--- mozilla/js/src/vm/RegExpObject.cpp	2022-04-13 21:14:22.000000000 +0300
+++ mozilla-OK/js/src/vm/RegExpObject.cpp	2022-04-22 05:08:38.691126158 +0300
@@ -16,11 +16,9 @@
 #endif
 
 #include "builtin/RegExp.h"
+#include "builtin/SelfHostingDefines.h"
 #include "frontend/TokenStream.h"
-#ifdef DEBUG
-#include "irregexp/RegExpBytecode.h"
-#endif
-#include "irregexp/RegExpParser.h"
+#include "irregexp/RegExpAPI.h"
 #include "vm/MatchPairs.h"
 #include "vm/RegExpStatics.h"
 #include "vm/StringBuffer.h"
@@ -35,21 +33,33 @@
 #include "vm/NativeObject-inl.h"
 #include "vm/Shape-inl.h"
 
+#include "js/RegExp.h"
+#include "js/RegExpFlags.h"
+
 using namespace js;
 
 using mozilla::ArrayLength;
 using mozilla::DebugOnly;
 using mozilla::Maybe;
 using mozilla::PodCopy;
+using JS::RegExpFlag;
+using JS::RegExpFlags;
 using js::frontend::TokenStream;
 
 using JS::AutoCheckCannotGC;
 
-JS_STATIC_ASSERT(IgnoreCaseFlag == JSREG_FOLD);
-JS_STATIC_ASSERT(GlobalFlag == JSREG_GLOB);
-JS_STATIC_ASSERT(MultilineFlag == JSREG_MULTILINE);
-JS_STATIC_ASSERT(StickyFlag == JSREG_STICKY);
-JS_STATIC_ASSERT(UnicodeFlag == JSREG_UNICODE);
+static_assert(RegExpFlag::Global == REGEXP_GLOBAL_FLAG,
+              "self-hosted JS and /g flag bits must agree");
+static_assert(RegExpFlag::IgnoreCase == REGEXP_IGNORECASE_FLAG,
+              "self-hosted JS and /i flag bits must agree");
+static_assert(RegExpFlag::Multiline == REGEXP_MULTILINE_FLAG,
+              "self-hosted JS and /m flag bits must agree");
+static_assert(RegExpFlag::DotAll == REGEXP_DOTALL_FLAG,
+              "self-hosted JS and /s flag bits must agree");
+static_assert(RegExpFlag::Unicode == REGEXP_UNICODE_FLAG,
+              "self-hosted JS and /u flag bits must agree");
+static_assert(RegExpFlag::Sticky == REGEXP_STICKY_FLAG,
+              "self-hosted JS and /y flag bits must agree");
 
 RegExpObject*
 js::RegExpAlloc(JSContext* cx, NewObjectKind newKind, HandleObject proto /* = nullptr */)
@@ -126,26 +136,30 @@ RegExpObject::getShared(JSContext* cx, H
 }
 
 /* static */ bool
-RegExpObject::isOriginalFlagGetter(JSNative native, RegExpFlag* mask)
+RegExpObject::isOriginalFlagGetter(JSNative native, RegExpFlags* mask)
 {
   if (native == regexp_global) {
-      *mask = GlobalFlag;
+      *mask = RegExpFlag::Global;
       return true;
   }
   if (native == regexp_ignoreCase) {
-      *mask = IgnoreCaseFlag;
+      *mask = RegExpFlag::IgnoreCase;
       return true;
   }
   if (native == regexp_multiline) {
-      *mask = MultilineFlag;
+      *mask = RegExpFlag::Multiline;
       return true;
   }
   if (native == regexp_sticky) {
-      *mask = StickyFlag;
+      *mask = RegExpFlag::Sticky;
       return true;
   }
   if (native == regexp_unicode) {
-      *mask = UnicodeFlag;
+      *mask = RegExpFlag::Unicode;
+      return true;
+  }
+  if (native == regexp_dotAll) {
+      *mask = RegExpFlag::DotAll;
       return true;
   }
 
@@ -227,7 +241,7 @@ const Class RegExpObject::protoClass_ =
 
 template<typename CharT>
 RegExpObject*
-RegExpObject::create(JSContext* cx, const CharT* chars, size_t length, RegExpFlag flags,
+RegExpObject::create(JSContext* cx, const CharT* chars, size_t length, RegExpFlags flags,
                      frontend::TokenStreamAnyChars& tokenStream, LifoAlloc& alloc,
                      NewObjectKind newKind)
 {
@@ -242,13 +256,13 @@ RegExpObject::create(JSContext* cx, cons
 }
 
 template RegExpObject*
-RegExpObject::create(JSContext* cx, const char16_t* chars, size_t length, RegExpFlag flags,
+RegExpObject::create(JSContext* cx, const char16_t* chars, size_t length, RegExpFlags flags,
                      frontend::TokenStreamAnyChars& tokenStream, LifoAlloc& alloc,
                      NewObjectKind newKind);
 
 template<typename CharT>
 RegExpObject*
-RegExpObject::create(JSContext* cx, const CharT* chars, size_t length, RegExpFlag flags,
+RegExpObject::create(JSContext* cx, const CharT* chars, size_t length, RegExpFlags flags,
                      LifoAlloc& alloc, NewObjectKind newKind)
 {
     static_assert(mozilla::IsSame<CharT, char16_t>::value,
@@ -262,17 +276,17 @@ RegExpObject::create(JSContext* cx, cons
 }
 
 template RegExpObject*
-RegExpObject::create(JSContext* cx, const char16_t* chars, size_t length, RegExpFlag flags,
+RegExpObject::create(JSContext* cx, const char16_t* chars, size_t length, RegExpFlags flags,
                      LifoAlloc& alloc, NewObjectKind newKind);
 
 RegExpObject*
-RegExpObject::create(JSContext* cx, HandleAtom source, RegExpFlag flags,
+RegExpObject::create(JSContext* cx, HandleAtom source, RegExpFlags flags,
                      frontend::TokenStreamAnyChars& tokenStream,
                      LifoAlloc& alloc, NewObjectKind newKind)
 {
-    if (!irregexp::ParsePatternSyntax(tokenStream, alloc, source, flags & UnicodeFlag))
+    if (!irregexp::CheckPatternSyntax(cx, tokenStream, source, flags)) {
         return nullptr;
-
+    }
     Rooted<RegExpObject*> regexp(cx, RegExpAlloc(cx, newKind));
     if (!regexp)
         return nullptr;
@@ -283,15 +297,15 @@ RegExpObject::create(JSContext* cx, Hand
 }
 
 RegExpObject*
-RegExpObject::create(JSContext* cx, HandleAtom source, RegExpFlag flags, LifoAlloc& alloc,
+RegExpObject::create(JSContext* cx, HandleAtom source, RegExpFlags flags, LifoAlloc& alloc,
                      NewObjectKind newKind)
 {
     CompileOptions dummyOptions(cx);
     TokenStream dummyTokenStream(cx, dummyOptions, (const char16_t*) nullptr, 0, nullptr);
 
-    if (!irregexp::ParsePatternSyntax(dummyTokenStream, alloc, source, flags & UnicodeFlag))
+    if (!irregexp::CheckPatternSyntax(cx, dummyTokenStream, source, flags)) {
         return nullptr;
-
+    }
     Rooted<RegExpObject*> regexp(cx, RegExpAlloc(cx, newKind));
     if (!regexp)
         return nullptr;
@@ -327,7 +341,7 @@ RegExpObject::assignInitialShape(JSConte
 }
 
 void
-RegExpObject::initIgnoringLastIndex(JSAtom* source, RegExpFlag flags)
+RegExpObject::initIgnoringLastIndex(JSAtom* source, RegExpFlags flags)
 {
     // If this is a re-initialization with an existing RegExpShared, 'flags'
     // may not match getShared()->flags, so forget the RegExpShared.
@@ -338,7 +352,7 @@ RegExpObject::initIgnoringLastIndex(JSAt
 }
 
 void
-RegExpObject::initAndZeroLastIndex(JSAtom* source, RegExpFlag flags, JSContext* cx)
+RegExpObject::initAndZeroLastIndex(JSAtom* source, RegExpFlags flags, JSContext* cx)
 {
     initIgnoringLastIndex(source, flags);
     zeroLastIndex(cx);
@@ -527,406 +541,12 @@ RegExpObject::toString(JSContext* cx) co
         return nullptr;
     if (sticky() && !sb.append('y'))
         return nullptr;
+    if (dotAll() && !sb.append('s'))
+        return nullptr;
 
     return sb.finishString();
 }
 
-#ifdef DEBUG
-/* static */ bool
-RegExpShared::dumpBytecode(JSContext* cx, MutableHandleRegExpShared re, bool match_only,
-                           HandleLinearString input)
-{
-    CompilationMode mode = match_only ? MatchOnly : Normal;
-    if (!RegExpShared::compileIfNecessary(cx, re, input, mode, ForceByteCode))
-        return false;
-
-    const uint8_t* byteCode = re->compilation(mode, input->hasLatin1Chars()).byteCode;
-    const uint8_t* pc = byteCode;
-
-    auto Load32Aligned = [](const uint8_t* pc) -> int32_t {
-        MOZ_ASSERT((reinterpret_cast<uintptr_t>(pc) & 3) == 0);
-        return *reinterpret_cast<const int32_t*>(pc);
-    };
-
-    auto Load16Aligned = [](const uint8_t* pc) -> int32_t {
-        MOZ_ASSERT((reinterpret_cast<uintptr_t>(pc) & 1) == 0);
-        return *reinterpret_cast<const uint16_t*>(pc);
-    };
-
-    int32_t numRegisters = Load32Aligned(pc);
-    fprintf(stderr, "numRegisters: %d\n", numRegisters);
-    pc += 4;
-
-    fprintf(stderr, "loc     op\n");
-    fprintf(stderr, "-----   --\n");
-
-    auto DumpLower = [](const char* text) {
-        while (*text) {
-            fprintf(stderr, "%c", unicode::ToLowerCase(*text));
-            text++;
-        }
-    };
-
-#define BYTECODE(NAME) \
-    case irregexp::BC_##NAME: \
-      DumpLower(#NAME);
-#define ADVANCE(NAME) \
-    fprintf(stderr, "\n"); \
-    pc += irregexp::BC_##NAME##_LENGTH; \
-    maxPc = js::Max(maxPc, pc); \
-    break;
-#define STOP(NAME) \
-    fprintf(stderr, "\n"); \
-    pc += irregexp::BC_##NAME##_LENGTH; \
-    break;
-#define JUMP(NAME, OFFSET) \
-    fprintf(stderr, "\n"); \
-    maxPc = js::Max(maxPc, byteCode + OFFSET); \
-    pc += irregexp::BC_##NAME##_LENGTH; \
-    break;
-#define BRANCH(NAME, OFFSET) \
-    fprintf(stderr, "\n"); \
-    pc += irregexp::BC_##NAME##_LENGTH; \
-    maxPc = js::Max(maxPc, js::Max(pc, byteCode + OFFSET)); \
-    break;
-
-    // Bytecode has no end marker, we need to calculate the bytecode length by
-    // tracing jumps and branches.
-    const uint8_t* maxPc = pc;
-    while (pc <= maxPc) {
-        fprintf(stderr, "%05d:  ", int32_t(pc - byteCode));
-        int32_t insn = Load32Aligned(pc);
-        switch (insn & irregexp::BYTECODE_MASK) {
-          BYTECODE(BREAK) {
-            STOP(BREAK);
-          }
-          BYTECODE(PUSH_CP) {
-            ADVANCE(PUSH_CP);
-          }
-          BYTECODE(PUSH_BT) {
-            int32_t offset = Load32Aligned(pc + 4);
-            fprintf(stderr, " %d",
-                    offset);
-            // Pushed value is used by POP_BT for jumping.
-            // Resolve maxPc here.
-            BRANCH(PUSH_BT, offset);
-          }
-          BYTECODE(PUSH_REGISTER) {
-            fprintf(stderr, " reg[%d]",
-                    insn >> irregexp::BYTECODE_SHIFT);
-            ADVANCE(PUSH_REGISTER);
-          }
-          BYTECODE(SET_REGISTER) {
-            fprintf(stderr, " reg[%d], %d",
-                    insn >> irregexp::BYTECODE_SHIFT,
-                    Load32Aligned(pc + 4));
-            ADVANCE(SET_REGISTER);
-          }
-          BYTECODE(ADVANCE_REGISTER) {
-            fprintf(stderr, " reg[%d], %d",
-                    insn >> irregexp::BYTECODE_SHIFT,
-                    Load32Aligned(pc + 4));
-            ADVANCE(ADVANCE_REGISTER);
-          }
-          BYTECODE(SET_REGISTER_TO_CP) {
-            fprintf(stderr, " reg[%d], %d",
-                    insn >> irregexp::BYTECODE_SHIFT,
-                    Load32Aligned(pc + 4));
-            ADVANCE(SET_REGISTER_TO_CP);
-          }
-          BYTECODE(SET_CP_TO_REGISTER) {
-            fprintf(stderr, " reg[%d]",
-                    insn >> irregexp::BYTECODE_SHIFT);
-            ADVANCE(SET_CP_TO_REGISTER);
-          }
-          BYTECODE(SET_REGISTER_TO_SP) {
-            fprintf(stderr, " reg[%d]",
-                    insn >> irregexp::BYTECODE_SHIFT);
-            ADVANCE(SET_REGISTER_TO_SP);
-          }
-          BYTECODE(SET_SP_TO_REGISTER) {
-            fprintf(stderr, " reg[%d]",
-                    insn >> irregexp::BYTECODE_SHIFT);
-            ADVANCE(SET_SP_TO_REGISTER);
-          }
-          BYTECODE(POP_CP) {
-            ADVANCE(POP_CP);
-          }
-          BYTECODE(POP_BT) {
-            // Jump is already resolved in PUSH_BT.
-            STOP(POP_BT);
-          }
-          BYTECODE(POP_REGISTER) {
-            fprintf(stderr, " reg[%d]",
-                    insn >> irregexp::BYTECODE_SHIFT);
-            ADVANCE(POP_REGISTER);
-          }
-          BYTECODE(FAIL) {
-            ADVANCE(FAIL);
-          }
-          BYTECODE(SUCCEED) {
-            ADVANCE(SUCCEED);
-          }
-          BYTECODE(ADVANCE_CP) {
-            fprintf(stderr, " %d",
-                    insn >> irregexp::BYTECODE_SHIFT);
-            ADVANCE(ADVANCE_CP);
-          }
-          BYTECODE(GOTO) {
-            int32_t offset = Load32Aligned(pc + 4);
-            fprintf(stderr, " %d",
-                    offset);
-            JUMP(GOTO, offset);
-          }
-          BYTECODE(ADVANCE_CP_AND_GOTO) {
-            int32_t offset = Load32Aligned(pc + 4);
-            fprintf(stderr, " %d, %d",
-                    insn >> irregexp::BYTECODE_SHIFT,
-                    offset);
-            JUMP(ADVANCE_CP_AND_GOTO, offset);
-          }
-          BYTECODE(CHECK_GREEDY) {
-            int32_t offset = Load32Aligned(pc + 4);
-            fprintf(stderr, " %d",
-                    offset);
-            BRANCH(CHECK_GREEDY, offset);
-          }
-          BYTECODE(LOAD_CURRENT_CHAR) {
-            int32_t offset = Load32Aligned(pc + 4);
-            fprintf(stderr, " %d, %d",
-                    insn >> irregexp::BYTECODE_SHIFT,
-                    offset);
-            BRANCH(LOAD_CURRENT_CHAR, offset);
-          }
-          BYTECODE(LOAD_CURRENT_CHAR_UNCHECKED) {
-            fprintf(stderr, " %d",
-                    insn >> irregexp::BYTECODE_SHIFT);
-            ADVANCE(LOAD_CURRENT_CHAR_UNCHECKED);
-          }
-          BYTECODE(LOAD_2_CURRENT_CHARS) {
-            int32_t offset = Load32Aligned(pc + 4);
-            fprintf(stderr, " %d, %d",
-                    insn >> irregexp::BYTECODE_SHIFT,
-                    offset);
-            BRANCH(LOAD_2_CURRENT_CHARS, offset);
-          }
-          BYTECODE(LOAD_2_CURRENT_CHARS_UNCHECKED) {
-            fprintf(stderr, " %d",
-                    insn >> irregexp::BYTECODE_SHIFT);
-            ADVANCE(LOAD_2_CURRENT_CHARS_UNCHECKED);
-          }
-          BYTECODE(LOAD_4_CURRENT_CHARS) {
-            ADVANCE(LOAD_4_CURRENT_CHARS);
-          }
-          BYTECODE(LOAD_4_CURRENT_CHARS_UNCHECKED) {
-            ADVANCE(LOAD_4_CURRENT_CHARS_UNCHECKED);
-          }
-          BYTECODE(CHECK_4_CHARS) {
-            int32_t offset = Load32Aligned(pc + 8);
-            fprintf(stderr, " %d, %d",
-                    Load32Aligned(pc + 4),
-                    offset);
-            BRANCH(CHECK_4_CHARS, offset);
-          }
-          BYTECODE(CHECK_CHAR) {
-            int32_t offset = Load32Aligned(pc + 4);
-            fprintf(stderr, " %d, %d",
-                    insn >> irregexp::BYTECODE_SHIFT,
-                    offset);
-            BRANCH(CHECK_CHAR, offset);
-          }
-          BYTECODE(CHECK_NOT_4_CHARS) {
-            int32_t offset = Load32Aligned(pc + 8);
-            fprintf(stderr, " %d, %d",
-                    Load32Aligned(pc + 4),
-                    offset);
-            BRANCH(CHECK_NOT_4_CHARS, offset);
-          }
-          BYTECODE(CHECK_NOT_CHAR) {
-            int32_t offset = Load32Aligned(pc + 4);
-            fprintf(stderr, " %d, %d",
-                    insn >> irregexp::BYTECODE_SHIFT,
-                    offset);
-            BRANCH(CHECK_NOT_CHAR, offset);
-          }
-          BYTECODE(AND_CHECK_4_CHARS) {
-            int32_t offset = Load32Aligned(pc + 12);
-            fprintf(stderr, " %d, %d, %d",
-                    Load32Aligned(pc + 4),
-                    Load32Aligned(pc + 8),
-                    offset);
-            BRANCH(AND_CHECK_4_CHARS, offset);
-          }
-          BYTECODE(AND_CHECK_CHAR) {
-            int32_t offset = Load32Aligned(pc + 8);
-            fprintf(stderr, " %d, %d, %d",
-                    insn >> irregexp::BYTECODE_SHIFT,
-                    Load32Aligned(pc + 4),
-                    offset);
-            BRANCH(AND_CHECK_CHAR, offset);
-          }
-          BYTECODE(AND_CHECK_NOT_4_CHARS) {
-            int32_t offset = Load32Aligned(pc + 12);
-            fprintf(stderr, " %d, %d, %d",
-                    Load32Aligned(pc + 4),
-                    Load32Aligned(pc + 8),
-                    offset);
-            BRANCH(AND_CHECK_NOT_4_CHARS, offset);
-          }
-          BYTECODE(AND_CHECK_NOT_CHAR) {
-            int32_t offset = Load32Aligned(pc + 8);
-            fprintf(stderr, " %d, %d, %d",
-                    insn >> irregexp::BYTECODE_SHIFT,
-                    Load32Aligned(pc + 4),
-                    offset);
-            BRANCH(AND_CHECK_NOT_CHAR, offset);
-          }
-          BYTECODE(MINUS_AND_CHECK_NOT_CHAR) {
-            int32_t offset = Load32Aligned(pc + 8);
-            fprintf(stderr, " %d, %d, %d, %d",
-                    insn >> irregexp::BYTECODE_SHIFT,
-                    Load16Aligned(pc + 4),
-                    Load16Aligned(pc + 6),
-                    offset);
-            BRANCH(MINUS_AND_CHECK_NOT_CHAR, offset);
-          }
-          BYTECODE(CHECK_CHAR_IN_RANGE) {
-            int32_t offset = Load32Aligned(pc + 8);
-            fprintf(stderr, " %d, %d, %d",
-                    Load16Aligned(pc + 4),
-                    Load16Aligned(pc + 6),
-                    offset);
-            BRANCH(CHECK_CHAR_IN_RANGE, offset);
-          }
-          BYTECODE(CHECK_CHAR_NOT_IN_RANGE) {
-            int32_t offset = Load32Aligned(pc + 8);
-            fprintf(stderr, " %d, %d, %d",
-                    Load16Aligned(pc + 4),
-                    Load16Aligned(pc + 6),
-                    offset);
-            BRANCH(CHECK_CHAR_NOT_IN_RANGE, offset);
-          }
-          BYTECODE(CHECK_BIT_IN_TABLE) {
-            int32_t offset = Load32Aligned(pc + 4);
-            fprintf(stderr, " %d, "
-                    "%02x %02x %02x %02x %02x %02x %02x %02x "
-                    "%02x %02x %02x %02x %02x %02x %02x %02x",
-                    offset,
-                    pc[8], pc[9], pc[10], pc[11],
-                    pc[12], pc[13], pc[14], pc[15],
-                    pc[16], pc[17], pc[18], pc[19],
-                    pc[20], pc[21], pc[22], pc[23]);
-            BRANCH(CHECK_BIT_IN_TABLE, offset);
-          }
-          BYTECODE(CHECK_LT) {
-            int32_t offset = Load32Aligned(pc + 4);
-            fprintf(stderr, " %d, %d",
-                    insn >> irregexp::BYTECODE_SHIFT,
-                    offset);
-            BRANCH(CHECK_LT, offset);
-          }
-          BYTECODE(CHECK_GT) {
-            int32_t offset = Load32Aligned(pc + 4);
-            fprintf(stderr, " %d, %d",
-                    insn >> irregexp::BYTECODE_SHIFT,
-                    offset);
-            BRANCH(CHECK_GT, offset);
-          }
-          BYTECODE(CHECK_REGISTER_LT) {
-            int32_t offset = Load32Aligned(pc + 8);
-            fprintf(stderr, " reg[%d], %d, %d",
-                    insn >> irregexp::BYTECODE_SHIFT,
-                    Load32Aligned(pc + 4),
-                    offset);
-            BRANCH(CHECK_REGISTER_LT, offset);
-          }
-          BYTECODE(CHECK_REGISTER_GE) {
-            int32_t offset = Load32Aligned(pc + 8);
-            fprintf(stderr, " reg[%d], %d, %d",
-                    insn >> irregexp::BYTECODE_SHIFT,
-                    Load32Aligned(pc + 4),
-                    offset);
-            BRANCH(CHECK_REGISTER_GE, offset);
-          }
-          BYTECODE(CHECK_REGISTER_EQ_POS) {
-            int32_t offset = Load32Aligned(pc + 4);
-            fprintf(stderr, " reg[%d], %d",
-                    insn >> irregexp::BYTECODE_SHIFT,
-                    offset);
-            BRANCH(CHECK_REGISTER_EQ_POS, offset);
-          }
-          BYTECODE(CHECK_NOT_REGS_EQUAL) {
-            int32_t offset = Load32Aligned(pc + 8);
-            fprintf(stderr, " reg[%d], %d, %d",
-                    insn >> irregexp::BYTECODE_SHIFT,
-                    Load32Aligned(pc + 4),
-                    offset);
-            BRANCH(CHECK_NOT_REGS_EQUAL, offset);
-          }
-          BYTECODE(CHECK_NOT_BACK_REF) {
-            int32_t offset = Load32Aligned(pc + 4);
-            fprintf(stderr, " reg[%d], %d",
-                    insn >> irregexp::BYTECODE_SHIFT,
-                    offset);
-            BRANCH(CHECK_NOT_BACK_REF, offset);
-          }
-          BYTECODE(CHECK_NOT_BACK_REF_NO_CASE) {
-            int32_t offset = Load32Aligned(pc + 4);
-            fprintf(stderr, " reg[%d], %d",
-                    insn >> irregexp::BYTECODE_SHIFT,
-                    offset);
-            BRANCH(CHECK_NOT_BACK_REF_NO_CASE, offset);
-          }
-          BYTECODE(CHECK_NOT_BACK_REF_NO_CASE_UNICODE) {
-            int32_t offset = Load32Aligned(pc + 4);
-            fprintf(stderr, " reg[%d], %d",
-                    insn >> irregexp::BYTECODE_SHIFT,
-                    offset);
-            BRANCH(CHECK_NOT_BACK_REF_NO_CASE_UNICODE, offset);
-          }
-          BYTECODE(CHECK_AT_START) {
-            int32_t offset = Load32Aligned(pc + 4);
-            fprintf(stderr, " %d",
-                    offset);
-            BRANCH(CHECK_AT_START, offset);
-          }
-          BYTECODE(CHECK_NOT_AT_START) {
-            int32_t offset = Load32Aligned(pc + 4);
-            fprintf(stderr, " %d",
-                    offset);
-            BRANCH(CHECK_NOT_AT_START, offset);
-          }
-          BYTECODE(SET_CURRENT_POSITION_FROM_END) {
-            fprintf(stderr, " %u",
-                    static_cast<uint32_t>(insn) >> irregexp::BYTECODE_SHIFT);
-            ADVANCE(SET_CURRENT_POSITION_FROM_END);
-          }
-          default:
-            MOZ_CRASH("Bad bytecode");
-        }
-    }
-
-#undef BYTECODE
-#undef ADVANCE
-#undef STOP
-#undef JUMP
-#undef BRANCH
-
-    return true;
-}
-
-/* static */ bool
-RegExpObject::dumpBytecode(JSContext* cx, Handle<RegExpObject*> regexp,
-                           bool match_only, HandleLinearString input)
-{
-    RootedRegExpShared shared(cx, getShared(cx, regexp));
-    if (!shared)
-        return false;
-
-    return RegExpShared::dumpBytecode(cx, &shared, match_only, input);
-}
-#endif
-
 template <typename CharT>
 static MOZ_ALWAYS_INLINE bool
 IsRegExpMetaChar(CharT ch)
@@ -971,8 +591,10 @@ js::StringHasRegExpMetaChars(JSLinearStr
 
 /* RegExpShared */
 
-RegExpShared::RegExpShared(JSAtom* source, RegExpFlag flags)
-  : source(source), flags(flags), canStringMatch(false), parenCount(0)
+RegExpShared::RegExpShared(JSAtom* source, RegExpFlags flags)
+  : source(source)
+  , flags(flags)
+  , pairCount_(0)
 {}
 
 void
@@ -983,8 +605,14 @@ RegExpShared::traceChildren(JSTracer* tr
         discardJitCode();
 
     TraceNullableEdge(trc, &source, "RegExpShared source");
-    for (auto& comp : compilationArray)
-        TraceNullableEdge(trc, &comp.jitCode, "RegExpShared code");
+    if (kind() == RegExpShared::Kind::Atom) {
+        TraceNullableEdge(trc, &patternAtom_, "RegExpShared pattern atom");
+    } else {
+        for (auto& comp : compilationArray) {
+            TraceNullableEdge(trc, &comp.jitCode, "RegExpShared code");
+        }
+        TraceNullableEdge(trc, &groupsTemplate_, "RegExpShared groups template");
+    }
 }
 
 void
@@ -997,219 +625,287 @@ RegExpShared::discardJitCode()
     tables.clearAndFree();
 }
 
+
 void
 RegExpShared::finalize(FreeOp* fop)
 {
-    for (auto& comp : compilationArray)
-        js_free(comp.byteCode);
+    for (auto& comp : compilationArray) {
+        if (comp.byteCode) {
+            js_free(comp.byteCode);
+        }
+    }
+    if (namedCaptureIndices_) {
+        js_free(namedCaptureIndices_);
+    }
     tables.~JitCodeTables();
 }
 
-/* static */ bool
-RegExpShared::compile(JSContext* cx, MutableHandleRegExpShared re, HandleLinearString input,
-                      CompilationMode mode, ForceByteCodeEnum force)
-{
-    TraceLoggerThread* logger = TraceLoggerForCurrentThread(cx);
-    AutoTraceLog logCompile(logger, TraceLogger_IrregexpCompile);
-
-    RootedAtom pattern(cx, re->source);
-    return compile(cx, re, pattern, input, mode, force);
-}
-
-/* static */ bool
-RegExpShared::compile(JSContext* cx, MutableHandleRegExpShared re, HandleAtom pattern,
-                      HandleLinearString input, CompilationMode mode, ForceByteCodeEnum force)
-{
-    if (!re->ignoreCase() && !StringHasRegExpMetaChars(pattern))
-        re->canStringMatch = true;
-
-    CompileOptions options(cx);
-    frontend::TokenStream dummyTokenStream(cx, options, nullptr, 0, nullptr);
-
-    LifoAllocScope scope(&cx->tempLifoAlloc());
-
-    /* Parse the pattern. */
-    irregexp::RegExpCompileData data;
-    if (!irregexp::ParsePattern(dummyTokenStream, cx->tempLifoAlloc(), pattern,
-                                re->multiline(), mode == MatchOnly, re->unicode(),
-                                re->ignoreCase(), re->global(), re->sticky(), &data))
-    {
-        return false;
+/* static */
+bool
+RegExpShared::compileIfNecessary(JSContext* cx,
+                                 MutableHandleRegExpShared re,
+                                 HandleLinearString input,
+                                 RegExpShared::CodeKind codeKind)
+{
+  if (codeKind == RegExpShared::CodeKind::Any) {
+    // We start by interpreting regexps, then compile them once they are
+    // sufficiently hot. For very long input strings, we tier up eagerly.
+    codeKind = RegExpShared::CodeKind::Bytecode;
+    if (re->markedForTierUp(cx) || input->length() > 1000) {
+      codeKind = RegExpShared::CodeKind::Jitcode;
     }
+  }
 
-    re->parenCount = data.capture_count;
-
-    JitCodeTables tables;
-    irregexp::RegExpCode code = irregexp::CompilePattern(cx, re, &data, input,
-                                                         false /* global() */,
-                                                         re->ignoreCase(),
-                                                         input->hasLatin1Chars(),
-                                                         mode == MatchOnly,
-                                                         force == ForceByteCode,
-                                                         re->sticky(),
-                                                         re->unicode(),
-                                                         tables);
-    if (code.empty())
-        return false;
+  // Fall back to bytecode if native codegen is not available.
+  if (!IsNativeRegExpEnabled(cx) && codeKind == RegExpShared::CodeKind::Jitcode) {
+    codeKind = RegExpShared::CodeKind::Bytecode;
+  }
 
-    MOZ_ASSERT(!code.jitCode || !code.byteCode);
-    MOZ_ASSERT_IF(force == ForceByteCode, code.byteCode);
+  bool needsCompile = false;
+  if (re->kind() == RegExpShared::Kind::Unparsed) {
+    needsCompile = true;
+  }
 
-    RegExpCompilation& compilation = re->compilation(mode, input->hasLatin1Chars());
-    if (code.jitCode) {
-        // First copy the tables. GC can purge the tables if the RegExpShared
-        // has no JIT code, so it's important to do this right before setting
-        // compilation.jitCode (to ensure no purging happens between adding the
-        // tables and setting the JIT code).
-        for (size_t i = 0; i < tables.length(); i++) {
-            if (!re->addTable(Move(tables[i])))
-                return false;
-        }
-        compilation.jitCode = code.jitCode;
-    } else if (code.byteCode) {
-        MOZ_ASSERT(tables.empty(), "RegExpInterpreter does not use data tables");
-        compilation.byteCode = code.byteCode;
+  if (re->kind() == RegExpShared::Kind::RegExp) {
+    if (!re->isCompiled(input->hasLatin1Chars(), codeKind)) {
+      needsCompile = true;
     }
+  }
 
-    return true;
-}
-
-/* static */ bool
-RegExpShared::compileIfNecessary(JSContext* cx, MutableHandleRegExpShared re,
-                                 HandleLinearString input, CompilationMode mode,
-                                 ForceByteCodeEnum force)
-{
-    if (re->isCompiled(mode, input->hasLatin1Chars(), force))
-        return true;
-    return compile(cx, re, input, mode, force);
+  if (needsCompile) {
+    return irregexp::CompilePattern(cx, re, input, codeKind);
+  }
+  return true;
 }
 
-/* static */ RegExpRunStatus
-RegExpShared::execute(JSContext* cx, MutableHandleRegExpShared re, HandleLinearString input,
-                      size_t start, MatchPairs* matches, size_t* endIndex)
+/* static */
+RegExpRunStatus
+RegExpShared::execute(JSContext* cx,
+                      MutableHandleRegExpShared re,
+                      HandleLinearString input,
+                      size_t start,
+                      MatchPairs* matches)
 {
-    MOZ_ASSERT_IF(matches, !endIndex);
-    MOZ_ASSERT_IF(!matches, endIndex);
-    TraceLoggerThread* logger = TraceLoggerForCurrentThread(cx);
+    MOZ_ASSERT(matches);
 
-    CompilationMode mode = matches ? Normal : MatchOnly;
+    // TODO: Add tracelogger support
 
     /* Compile the code at point-of-use. */
-    if (!compileIfNecessary(cx, re, input, mode, DontForceByteCode))
+    if (!compileIfNecessary(cx, re, input, RegExpShared::CodeKind::Any)) {
         return RegExpRunStatus_Error;
+    }
 
     /*
      * Ensure sufficient memory for output vector.
      * No need to initialize it. The RegExp engine fills them in on a match.
      */
-    if (matches && !matches->allocOrExpandArray(re->pairCount())) {
+    if (!matches->allocOrExpandArray(re->pairCount())) {
         ReportOutOfMemory(cx);
         return RegExpRunStatus_Error;
     }
 
-    size_t length = input->length();
+    if (re->kind() == RegExpShared::Kind::Atom) {
+        return RegExpShared::executeAtom(re, input, start, matches);
+    }
 
-    // Reset the Irregexp backtrack stack if it grows during execution.
-    irregexp::RegExpStackScope stackScope(cx);
+    /*
+     * Ensure sufficient memory for output vector.
+     * No need to initialize it. The RegExp engine fills them in on a match.
+     */
+    if (!matches->allocOrExpandArray(re->pairCount())) {
+        ReportOutOfMemory(cx);
+        return RegExpRunStatus_Error;
+    }
+
+    uint32_t interruptRetries = 0;
+    const uint32_t maxInterruptRetries = 4;
+    do {
+        RegExpRunStatus result = irregexp::Execute(cx, re, input, start, matches);
 
-    if (re->canStringMatch) {
-        MOZ_ASSERT(re->pairCount() == 1);
-        size_t sourceLength = re->source->length();
-        if (re->sticky()) {
-            // First part checks size_t overflow.
-            if (sourceLength + start < sourceLength || sourceLength + start > length)
-                return RegExpRunStatus_Success_NotFound;
-            if (!HasSubstringAt(input, re->source, start))
-                return RegExpRunStatus_Success_NotFound;
-
-            if (matches) {
-                (*matches)[0].start = start;
-                (*matches)[0].limit = start + sourceLength;
-
-                matches->checkAgainst(length);
-            } else if (endIndex) {
-                *endIndex = start + sourceLength;
+        if (result == RegExpRunStatus_Error) {
+          /* Execute can return RegExpRunStatus_Error:
+           *
+           *  1. If the native stack overflowed
+           *  2. If the backtrack stack overflowed
+           *  3. If an interrupt was requested during execution.
+           *
+           * In the first two cases, we want to throw an error. In the
+           * third case, we want to handle the interrupt and try again.
+           * We cap the number of times we will retry.
+           */
+          if (cx->hasPendingInterrupt()) {
+            if (!CheckForInterrupt(cx)) {
+              return RegExpRunStatus_Error;
+            }
+            if (interruptRetries++ < maxInterruptRetries) {
+              // The initial execution may have been interpreted, or the
+              // interrupt may have triggered a GC that discarded jitcode.
+              // To maximize the chance of succeeding before being
+              // interrupted again, we want to ensure we are compiled.
+              if (!compileIfNecessary(cx, re, input,
+                                      RegExpShared::CodeKind::Jitcode)) {
+                return RegExpRunStatus_Error;
+              }
+              continue;
             }
-            return RegExpRunStatus_Success;
+          }
+          // If we have run out of retries, this regexp takes too long to
+          // execute.
+          ReportOverRecursed(cx);
+          return RegExpRunStatus_Error;
         }
 
-        int res = StringFindPattern(input, re->source, start);
-        if (res == -1)
-            return RegExpRunStatus_Success_NotFound;
+        MOZ_ASSERT(result == RegExpRunStatus_Success ||
+                   result == RegExpRunStatus_Success_NotFound);
 
-        if (matches) {
-            (*matches)[0].start = res;
-            (*matches)[0].limit = res + sourceLength;
-
-            matches->checkAgainst(length);
-        } else if (endIndex) {
-            *endIndex = res + sourceLength;
-        }
-        return RegExpRunStatus_Success;
+        return result;
+    } while (true);
+
+    MOZ_CRASH("Unreachable");
+}
+
+void RegExpShared::useAtomMatch(HandleAtom pattern) {
+  MOZ_ASSERT(kind() == RegExpShared::Kind::Unparsed);
+  kind_ = RegExpShared::Kind::Atom;
+  patternAtom_ = pattern;
+  pairCount_ = 1;
+}
+
+void RegExpShared::useRegExpMatch(size_t pairCount) {
+  MOZ_ASSERT(kind() == RegExpShared::Kind::Unparsed);
+  kind_ = RegExpShared::Kind::RegExp;
+  pairCount_ = pairCount;
+  ticks_ = jit::JitOptions.regexpWarmUpThreshold;
+}
+
+/* static */
+bool
+RegExpShared::initializeNamedCaptures(JSContext* cx,
+                                      HandleRegExpShared re,
+                                      HandleNativeObject namedCaptures)
+{
+    MOZ_ASSERT(!re->groupsTemplate_);
+    MOZ_ASSERT(!re->namedCaptureIndices_);
+
+    // The irregexp parser returns named capture information in the form
+    // of an ArrayObject, where even elements store the capture name and
+    // odd elements store the corresponding capture index. We create a
+    // template object with a property for each capture name, and store
+    // the capture indices as a heap-allocated array.
+    MOZ_ASSERT(namedCaptures->getDenseInitializedLength() % 2 == 0);
+    uint32_t numNamedCaptures = namedCaptures->getDenseInitializedLength() / 2;
+
+    // Create a plain template object.
+    RootedPlainObject templateObject(cx, NewObjectWithGivenProto<PlainObject>(cx, nullptr, TenuredObject));
+    if (!templateObject) {
+        return false;
     }
 
-    do {
-        jit::JitCode* code = re->compilation(mode, input->hasLatin1Chars()).jitCode;
-        if (!code)
-            break;
+    // Create a new group for the template.
+    Rooted<TaggedProto> proto(cx, templateObject->taggedProto());
+    ObjectGroup* group =
+      ObjectGroupCompartment::makeGroup(cx, templateObject->getClass(), proto);
+    if (!group) {
+        return false;
+    }
+    templateObject->setGroup(group);
 
-        RegExpRunStatus result;
-        {
-            AutoTraceLog logJIT(logger, TraceLogger_IrregexpExecute);
-            AutoCheckCannotGC nogc;
-            if (input->hasLatin1Chars()) {
-                const Latin1Char* chars = input->latin1Chars(nogc);
-                result = irregexp::ExecuteCode(cx, code, chars, start, length, matches, endIndex);
-            } else {
-                const char16_t* chars = input->twoByteChars(nogc);
-                result = irregexp::ExecuteCode(cx, code, chars, start, length, matches, endIndex);
-            }
+    // Initialize the properties of the template.
+    RootedId id(cx);
+    RootedValue dummyString(cx, StringValue(cx->runtime()->emptyString));
+    for (uint32_t i = 0; i < numNamedCaptures; i++) {
+        JSString* name = namedCaptures->getDenseElement(i * 2).toString();
+        id = NameToId(name->asAtom().asPropertyName());
+        if (!NativeDefineProperty(
+              cx, templateObject, id, dummyString, nullptr, nullptr, JSPROP_ENUMERATE)) {
+            return false;
         }
+        AddTypePropertyId(cx, templateObject, id, UndefinedValue());
+    }
 
-        if (result == RegExpRunStatus_Error) {
-            // An 'Error' result is returned if a stack overflow guard or
-            // interrupt guard failed. If CheckOverRecursed doesn't throw, break
-            // out and retry the regexp in the bytecode interpreter, which can
-            // execute while tolerating future interrupts. Otherwise, if we keep
-            // getting interrupted we will never finish executing the regexp.
-            if (!jit::CheckOverRecursed(cx))
-                return RegExpRunStatus_Error;
-            break;
-        }
+    // Allocate the capture index array.
+    uint32_t arraySize = numNamedCaptures * sizeof(uint32_t);
+    uint32_t* captureIndices = static_cast<uint32_t*>(js_malloc(arraySize));
+    if (!captureIndices) {
+        ReportOutOfMemory(cx);
+        return false;
+    }
 
-        if (result == RegExpRunStatus_Success_NotFound)
-            return RegExpRunStatus_Success_NotFound;
+    // Populate the capture index array
+    for (uint32_t i = 0; i < numNamedCaptures; i++) {
+        captureIndices[i] = namedCaptures->getDenseElement(i * 2 + 1).toInt32();
+    }
 
-        MOZ_ASSERT(result == RegExpRunStatus_Success);
+    re->numNamedCaptures_ = numNamedCaptures;
+    re->groupsTemplate_ = templateObject;
+    re->namedCaptureIndices_ = captureIndices;
+    // js::AddCellMemory(re, arraySize, MemoryUse::RegExpSharedNamedCaptureData);
+    return true;
+}
 
-        if (matches)
-            matches->checkAgainst(length);
-        return RegExpRunStatus_Success;
-    } while (false);
+void RegExpShared::tierUpTick() {
+  MOZ_ASSERT(kind() == RegExpShared::Kind::RegExp);
+  if (ticks_ > 0) {
+    ticks_--;
+  }
+}
 
-    // Compile bytecode for the RegExp if necessary.
-    if (!compileIfNecessary(cx, re, input, mode, ForceByteCode))
-        return RegExpRunStatus_Error;
+bool RegExpShared::markedForTierUp(JSContext* cx) const {
+  if (!IsNativeRegExpEnabled(cx)) {
+    return false;
+  }
+  if (kind() != RegExpShared::Kind::RegExp) {
+    return false;
+  }
+  return ticks_ == 0;
+}
 
-    uint8_t* byteCode = re->compilation(mode, input->hasLatin1Chars()).byteCode;
-    AutoTraceLog logInterpreter(logger, TraceLogger_IrregexpExecute);
+/* static */
+RegExpRunStatus ExecuteAtomImpl(RegExpShared* re, JSLinearString* input,
+                                size_t start, MatchPairs* matches)
+{
+    MOZ_ASSERT(re->pairCount() == 1);
+    size_t length = input->length();
+    size_t searchLength = re->patternAtom()->length();
 
-    AutoStableStringChars inputChars(cx);
-    if (!inputChars.init(cx, input))
-        return RegExpRunStatus_Error;
+    if (re->sticky()) {
+        // First part checks size_t overflow.
+        if (searchLength + start < searchLength || searchLength + start > length) {
+            return RegExpRunStatus_Success_NotFound;
+        }
+        if (!HasSubstringAt(input, re->patternAtom(), start)) {
+            return RegExpRunStatus_Success_NotFound;
+        }
 
-    RegExpRunStatus result;
-    if (inputChars.isLatin1()) {
-        const Latin1Char* chars = inputChars.latin1Range().begin().get();
-        result = irregexp::InterpretCode(cx, byteCode, chars, start, length, matches, endIndex);
-    } else {
-        const char16_t* chars = inputChars.twoByteRange().begin().get();
-        result = irregexp::InterpretCode(cx, byteCode, chars, start, length, matches, endIndex);
+        (*matches)[0].start = start;
+        (*matches)[0].limit = start + searchLength;
+        matches->checkAgainst(input->length());
+        return RegExpRunStatus_Success;
+    }
+
+    int res = StringFindPattern(input, re->patternAtom(), start);
+    if (res == -1) {
+        return RegExpRunStatus_Success_NotFound;
     }
 
-    if (result == RegExpRunStatus_Success && matches)
-        matches->checkAgainst(length);
-    return result;
+    (*matches)[0].start = res;
+    (*matches)[0].limit = res + searchLength;
+    matches->checkAgainst(input->length());
+    return RegExpRunStatus_Success;
+}
+
+RegExpRunStatus js::ExecuteRegExpAtomRaw(RegExpShared* re,
+                                         JSLinearString* input, size_t start,
+                                         MatchPairs* matchPairs) {
+  JS::AutoCheckCannotGC nogc;
+  return ExecuteAtomImpl(re, input, start, matchPairs);
+}
+
+/* static */
+RegExpRunStatus RegExpShared::executeAtom(MutableHandleRegExpShared re,
+                                          HandleLinearString input,
+                                          size_t start, MatchPairs* matches) {
+  return ExecuteAtomImpl(re, input, start, matches);
 }
 
 size_t
@@ -1246,14 +942,16 @@ RegExpCompartment::createMatchResultTemp
     /* Create template array object */
     RootedArrayObject templateObject(cx, NewDenseUnallocatedArray(cx, RegExpObject::MaxPairCount,
                                                                   nullptr, TenuredObject));
-    if (!templateObject)
-        return matchResultTemplateObject_; // = nullptr
+    if (!templateObject) {
+        return nullptr;
+    }
 
     // Create a new group for the template.
     Rooted<TaggedProto> proto(cx, templateObject->taggedProto());
     ObjectGroup* group = ObjectGroupCompartment::makeGroup(cx, templateObject->getClass(), proto);
-    if (!group)
-        return matchResultTemplateObject_; // = nullptr
+    if (!group) {
+        return nullptr;
+    }
     templateObject->setGroup(group);
 
     /* Set dummy index property */
@@ -1261,23 +959,36 @@ RegExpCompartment::createMatchResultTemp
     if (!NativeDefineProperty(cx, templateObject, cx->names().index, index, nullptr, nullptr,
                               JSPROP_ENUMERATE))
     {
-        return matchResultTemplateObject_; // = nullptr
+        return nullptr;
     }
 
     /* Set dummy input property */
     RootedValue inputVal(cx, StringValue(cx->runtime()->emptyString));
-    if (!NativeDefineProperty(cx, templateObject, cx->names().input, inputVal, nullptr, nullptr,
-                              JSPROP_ENUMERATE))
-    {
-        return matchResultTemplateObject_; // = nullptr
+    if (!NativeDefineProperty(
+          cx, templateObject, cx->names().input, inputVal, nullptr, nullptr, JSPROP_ENUMERATE)) {
+        return nullptr;
     }
 
+    /* Set dummy groups property */
+    RootedValue groupsVal(cx, UndefinedValue());
+    if (!NativeDefineProperty(
+          cx, templateObject, cx->names().groups, groupsVal, nullptr, nullptr, JSPROP_ENUMERATE)) {
+        return nullptr;
+    }
+    AddTypePropertyId(cx, templateObject, NameToId(cx->names().groups), TypeSet::AnyObjectType());
+
     // Make sure that the properties are in the right slots.
-    DebugOnly<Shape*> shape = templateObject->lastProperty();
-    MOZ_ASSERT(shape->previous()->slot() == 0 &&
-               shape->previous()->propidRef() == NameToId(cx->names().index));
-    MOZ_ASSERT(shape->slot() == 1 &&
-               shape->propidRef() == NameToId(cx->names().input));
+#ifdef DEBUG
+  Shape* groupsShape = templateObject->lastProperty();
+  MOZ_ASSERT(groupsShape->slot() == 0 &&
+             groupsShape->propidRef() == NameToId(cx->names().groups));
+  Shape* inputShape = groupsShape->previous().get();
+  MOZ_ASSERT(inputShape->slot() == 1 &&
+             inputShape->propidRef() == NameToId(cx->names().input));
+  Shape* indexShape = inputShape->previous().get();
+  MOZ_ASSERT(indexShape->slot() == 2 &&
+             indexShape->propidRef() == NameToId(cx->names().index));
+#endif
 
     // Make sure type information reflects the indexed properties which might
     // be added.
@@ -1321,7 +1032,7 @@ RegExpCompartment::sweep()
 }
 
 RegExpShared*
-RegExpZone::get(JSContext* cx, HandleAtom source, RegExpFlag flags)
+RegExpZone::get(JSContext* cx, HandleAtom source, RegExpFlags flags)
 {
     DependentAddPtr<Set> p(cx, set_, Key(source, flags));
     if (p)
@@ -1344,7 +1055,7 @@ RegExpZone::get(JSContext* cx, HandleAto
 RegExpShared*
 RegExpZone::get(JSContext* cx, HandleAtom atom, JSString* opt)
 {
-    RegExpFlag flags = RegExpFlag(0);
+    RegExpFlags flags = RegExpFlag::NoFlags;
     if (opt && !ParseRegExpFlags(cx, opt, &flags))
         return nullptr;
 
@@ -1388,27 +1099,30 @@ js::CloneRegExpObject(JSContext* cx, Han
 
 template <typename CharT>
 static bool
-ParseRegExpFlags(const CharT* chars, size_t length, RegExpFlag* flagsOut, char16_t* invalidFlag)
+ParseRegExpFlags(const CharT* chars, size_t length, RegExpFlags* flagsOut, char16_t* invalidFlag)
 {
-    *flagsOut = RegExpFlag(0);
+    *flagsOut = RegExpFlag::NoFlags;
 
     for (size_t i = 0; i < length; i++) {
-        RegExpFlag flag;
+        uint8_t flag;
         switch (chars[i]) {
           case 'i':
-            flag = IgnoreCaseFlag;
+            flag = RegExpFlag::IgnoreCase;
             break;
           case 'g':
-            flag = GlobalFlag;
+            flag = RegExpFlag::Global;
             break;
           case 'm':
-            flag = MultilineFlag;
+            flag = RegExpFlag::Multiline;
             break;
           case 'y':
-            flag = StickyFlag;
+            flag = RegExpFlag::Sticky;
             break;
           case 'u':
-            flag = UnicodeFlag;
+            flag = RegExpFlag::Unicode;
+            break;
+          case 's':
+            flag = RegExpFlag::DotAll;
             break;
           default:
             *invalidFlag = chars[i];
@@ -1418,14 +1132,14 @@ ParseRegExpFlags(const CharT* chars, siz
             *invalidFlag = chars[i];
             return false;
         }
-        *flagsOut = RegExpFlag(*flagsOut | flag);
+        *flagsOut = RegExpFlags(*flagsOut | flag);
     }
 
     return true;
 }
 
 bool
-js::ParseRegExpFlags(JSContext* cx, JSString* flagStr, RegExpFlag* flagsOut)
+js::ParseRegExpFlags(JSContext* cx, JSString* flagStr, RegExpFlags* flagsOut)
 {
     JSLinearString* linear = flagStr->ensureLinear(cx);
     if (!linear)
@@ -1445,7 +1159,7 @@ js::ParseRegExpFlags(JSContext* cx, JSSt
 
     if (!ok) {
         TwoByteChars range(&invalidFlag, 1);
-        UniqueChars utf8(JS::CharsToNewUTF8CharsZ(nullptr, range).c_str());
+        UniqueChars utf8(JS::CharsToNewUTF8CharsZ(cx, range).c_str());
         if (!utf8)
             return false;
         JS_ReportErrorFlagsAndNumberUTF8(cx, JSREPORT_ERROR, GetErrorMessage, nullptr,
@@ -1463,18 +1177,18 @@ js::XDRScriptRegExpObject(XDRState<mode>
     /* NB: Keep this in sync with CloneScriptRegExpObject. */
 
     RootedAtom source(xdr->cx());
-    uint32_t flagsword = 0;
+    uint8_t flags = 0;
 
     if (mode == XDR_ENCODE) {
         MOZ_ASSERT(objp);
         RegExpObject& reobj = *objp;
         source = reobj.getSource();
-        flagsword = reobj.getFlags();
+        flags = reobj.getFlags().value();
     }
-    if (!XDRAtom(xdr, &source) || !xdr->codeUint32(&flagsword))
+    if (!XDRAtom(xdr, &source) || !xdr->codeUint8(&flags))
         return false;
     if (mode == XDR_DECODE) {
-        RegExpObject* reobj = RegExpObject::create(xdr->cx(), source, RegExpFlag(flagsword),
+        RegExpObject* reobj = RegExpObject::create(xdr->cx(), source, RegExpFlags(flags),
                                                    xdr->lifoAlloc(), TenuredObject);
         if (!reobj)
             return false;
@@ -1513,3 +1227,162 @@ JS::ubi::Concrete<RegExpShared>::size(mo
     return js::gc::Arena::thingSize(gc::AllocKind::REGEXP_SHARED) +
         get().sizeOfExcludingThis(mallocSizeOf);
 }
+
+/*
+ * Public API functions for Regular Expressions.
+ */
+JS_PUBLIC_API(JSObject*)
+JS::NewRegExpObject(JSContext* cx, const char* bytes, size_t length, RegExpFlags flags)
+{
+    AssertHeapIsIdle();
+    CHECK_REQUEST(cx);
+
+    ScopedJSFreePtr<char16_t> chars(InflateString(cx, bytes, length));
+    if (!chars)
+        return nullptr;
+
+    return RegExpObject::create(cx, chars.get(), length, flags, cx->tempLifoAlloc(),
+                                GenericObject);
+}
+
+JS_PUBLIC_API(JSObject*)
+JS::NewUCRegExpObject(JSContext* cx, const char16_t* chars, size_t length, RegExpFlags flags)
+{
+    AssertHeapIsIdle();
+    CHECK_REQUEST(cx);
+
+    return RegExpObject::create(cx, chars, length, flags, cx->tempLifoAlloc(),
+                                GenericObject);
+}
+
+JS_PUBLIC_API(bool)
+JS::SetRegExpInput(JSContext* cx, HandleObject obj, HandleString input)
+{
+    AssertHeapIsIdle();
+    CHECK_REQUEST(cx);
+    assertSameCompartment(cx, input);
+
+    Handle<GlobalObject*> global = obj.as<GlobalObject>();
+    RegExpStatics* res = GlobalObject::getRegExpStatics(cx, global);
+    if (!res)
+        return false;
+
+    res->reset(input);
+    return true;
+}
+
+JS_PUBLIC_API(bool)
+JS::ClearRegExpStatics(JSContext* cx, HandleObject obj)
+{
+    AssertHeapIsIdle();
+    CHECK_REQUEST(cx);
+    MOZ_ASSERT(obj);
+
+    Handle<GlobalObject*> global = obj.as<GlobalObject>();
+    RegExpStatics* res = GlobalObject::getRegExpStatics(cx, global);
+    if (!res)
+        return false;
+
+    res->clear();
+    return true;
+}
+
+JS_PUBLIC_API(bool)
+JS::ExecuteRegExp(JSContext* cx, HandleObject obj, HandleObject reobj, char16_t* chars,
+                 size_t length, size_t* indexp, bool test, MutableHandleValue rval)
+{
+    AssertHeapIsIdle();
+    CHECK_REQUEST(cx);
+
+    Handle<GlobalObject*> global = obj.as<GlobalObject>();
+    RegExpStatics* res = GlobalObject::getRegExpStatics(cx, global);
+    if (!res)
+        return false;
+
+    RootedLinearString input(cx, NewStringCopyN<CanGC>(cx, chars, length));
+    if (!input)
+        return false;
+
+    return ExecuteRegExpLegacy(cx, res, reobj.as<RegExpObject>(), input, indexp, test, rval);
+}
+
+JS_PUBLIC_API(bool)
+JS::ExecuteRegExpNoStatics(JSContext* cx, HandleObject obj, char16_t* chars, size_t length,
+                          size_t* indexp, bool test, MutableHandleValue rval)
+{
+    AssertHeapIsIdle();
+    CHECK_REQUEST(cx);
+
+    RootedLinearString input(cx, NewStringCopyN<CanGC>(cx, chars, length));
+    if (!input)
+        return false;
+
+    return ExecuteRegExpLegacy(cx, nullptr, obj.as<RegExpObject>(), input, indexp, test,
+                               rval);
+}
+
+JS_PUBLIC_API(bool)
+JS::ObjectIsRegExp(JSContext* cx, HandleObject obj, bool* isRegExp)
+{
+    assertSameCompartment(cx, obj);
+
+    ESClass cls;
+    if (!GetBuiltinClass(cx, obj, &cls))
+        return false;
+
+    *isRegExp = cls == ESClass::RegExp;
+    return true;
+}
+
+JS_PUBLIC_API(RegExpFlags)
+JS::GetRegExpFlags(JSContext* cx, HandleObject obj)
+{
+    AssertHeapIsIdle();
+    CHECK_REQUEST(cx);
+
+    RegExpShared* shared = RegExpToShared(cx, obj);
+    if (!shared)
+        return RegExpFlag::NoFlags;
+    return shared->getFlags();
+}
+
+JS_PUBLIC_API(JSString*)
+JS::GetRegExpSource(JSContext* cx, HandleObject obj)
+{
+    AssertHeapIsIdle();
+    CHECK_REQUEST(cx);
+
+    RegExpShared* shared = RegExpToShared(cx, obj);
+    if (!shared)
+        return nullptr;
+    return shared->getSource();
+}
+
+JS_PUBLIC_API(bool)
+JS::CheckRegExpSyntax(JSContext* cx,
+                      const char16_t* chars,
+                      size_t length,
+                      RegExpFlags flags,
+                      MutableHandleValue error)
+{
+    AssertHeapIsIdle();
+    CHECK_REQUEST(cx);
+
+    CompileOptions options(cx);
+    frontend::TokenStream dummyTokenStream(cx, options, nullptr, 0, nullptr);
+
+    mozilla::Range<const char16_t> source(chars, length);
+    bool success = irregexp::CheckPatternSyntax(cx, dummyTokenStream, source, flags);
+    error.set(UndefinedValue());
+    if (!success) {
+        // We can fail because of OOM or over-recursion even if the syntax is valid.
+        if (cx->isThrowingOutOfMemory() || cx->isThrowingOverRecursed()) {
+            return false;
+        }
+        if (!cx->getPendingException(error)) {
+            return false;
+        }
+        cx->clearPendingException();
+    }
+    return true;
+}
diff -Nrup mozilla/js/src/vm/RegExpObject.h mozilla-OK/js/src/vm/RegExpObject.h
--- mozilla/js/src/vm/RegExpObject.h	2021-10-26 19:49:54.000000000 +0300
+++ mozilla-OK/js/src/vm/RegExpObject.h	2022-04-22 05:08:24.531225398 +0300
@@ -17,6 +17,7 @@
 #include "builtin/SelfHostingDefines.h"
 #include "gc/Marking.h"
 #include "js/GCHashTable.h"
+#include "js/RegExpFlags.h"
 #include "proxy/Proxy.h"
 #include "vm/ArrayObject.h"
 #include "vm/RegExpShared.h"
@@ -73,20 +74,20 @@ class RegExpObject : public NativeObject
 
     template<typename CharT>
     static RegExpObject*
-    create(JSContext* cx, const CharT* chars, size_t length, RegExpFlag flags, LifoAlloc& alloc,
+    create(JSContext* cx, const CharT* chars, size_t length, JS::RegExpFlags flags, LifoAlloc& alloc,
            NewObjectKind newKind);
 
     template<typename CharT>
     static RegExpObject*
-    create(JSContext* cx, const CharT* chars, size_t length, RegExpFlag flags,
+    create(JSContext* cx, const CharT* chars, size_t length, JS::RegExpFlags flags,
            frontend::TokenStreamAnyChars& ts, LifoAlloc& alloc, NewObjectKind kind);
 
     static RegExpObject*
-    create(JSContext* cx, HandleAtom atom, RegExpFlag flags, LifoAlloc& alloc,
+    create(JSContext* cx, HandleAtom atom, JS::RegExpFlags flags, LifoAlloc& alloc,
            NewObjectKind newKind);
 
     static RegExpObject*
-    create(JSContext* cx, HandleAtom atom, RegExpFlag flags, frontend::TokenStreamAnyChars& ts,
+    create(JSContext* cx, HandleAtom atom, JS::RegExpFlags flags, frontend::TokenStreamAnyChars& ts,
            LifoAlloc& alloc, NewObjectKind newKind);
 
     /*
@@ -135,25 +136,28 @@ class RegExpObject : public NativeObject
 
     static unsigned flagsSlot() { return FLAGS_SLOT; }
 
-    RegExpFlag getFlags() const {
-        return RegExpFlag(getFixedSlot(FLAGS_SLOT).toInt32());
-    }
-    void setFlags(RegExpFlag flags) {
-        setSlot(FLAGS_SLOT, Int32Value(flags));
-    }
+    JS::RegExpFlags getFlags() const
+    {
+        return JS::RegExpFlags(getFixedSlot(FLAGS_SLOT).toInt32());
+    }
+    void setFlags(JS::RegExpFlags flags) { setFixedSlot(FLAGS_SLOT, Int32Value(flags.value())); };
+
+    bool global() const { return getFlags().global(); }
+    bool ignoreCase() const { return getFlags().ignoreCase(); }
+    bool multiline() const { return getFlags().multiline(); }
+    bool dotAll() const { return getFlags().dotAll(); }
+    bool unicode() const { return getFlags().unicode(); }
+    bool sticky() const { return getFlags().sticky(); }
 
-    bool ignoreCase() const { return getFlags() & IgnoreCaseFlag; }
-    bool global() const     { return getFlags() & GlobalFlag; }
-    bool multiline() const  { return getFlags() & MultilineFlag; }
-    bool sticky() const     { return getFlags() & StickyFlag; }
-    bool unicode() const    { return getFlags() & UnicodeFlag; }
-
-    static bool isOriginalFlagGetter(JSNative native, RegExpFlag* mask);
+    static bool isOriginalFlagGetter(JSNative native, JS::RegExpFlags* mask);
 
     static RegExpShared* getShared(JSContext* cx, Handle<RegExpObject*> regexp);
 
-    bool hasShared() {
-        return !!sharedRef();
+    bool hasShared() const { return !!sharedRef(); }
+
+    RegExpShared* getShared() const {
+      MOZ_ASSERT(hasShared());
+      return sharedRef();
     }
 
     void setShared(RegExpShared& shared) {
@@ -161,7 +165,7 @@ class RegExpObject : public NativeObject
         sharedRef().init(&shared);
     }
 
-    PreBarriered<RegExpShared*>& sharedRef() {
+    PreBarriered<RegExpShared*>& sharedRef() const {
         auto& ref = NativeObject::privateRef(PRIVATE_SLOT);
         return reinterpret_cast<PreBarriered<RegExpShared*>&>(ref);
     }
@@ -169,16 +173,17 @@ class RegExpObject : public NativeObject
     static void trace(JSTracer* trc, JSObject* obj);
     void trace(JSTracer* trc);
 
-    void initIgnoringLastIndex(JSAtom* source, RegExpFlag flags);
+    void initIgnoringLastIndex(JSAtom* source, JS::RegExpFlags flags);
 
     // NOTE: This method is *only* safe to call on RegExps that haven't been
     //       exposed to script, because it requires that the "lastIndex"
     //       property be writable.
-    void initAndZeroLastIndex(JSAtom* source, RegExpFlag flags, JSContext* cx);
+    void initAndZeroLastIndex(JSAtom* source, JS::RegExpFlags flags, JSContext* cx);
 
 #ifdef DEBUG
-    static MOZ_MUST_USE bool dumpBytecode(JSContext* cx, Handle<RegExpObject*> regexp,
-                                          bool match_only, HandleLinearString input);
+    static MOZ_MUST_USE bool dumpBytecode(JSContext* cx,
+                                          Handle<RegExpObject*> regexp,
+                                          HandleLinearString input);
 #endif
 
   private:
@@ -199,7 +204,7 @@ class RegExpObject : public NativeObject
  * N.B. flagStr must be rooted.
  */
 bool
-ParseRegExpFlags(JSContext* cx, JSString* flagStr, RegExpFlag* flagsOut);
+ParseRegExpFlags(JSContext* cx, JSString* flagStr, JS::RegExpFlags* flagsOut);
 
 /* Assuming GetBuiltinClass(obj) is ESClass::RegExp, return a RegExpShared for obj. */
 inline RegExpShared*
diff -Nrup mozilla/js/src/vm/RegExpShared.h mozilla-OK/js/src/vm/RegExpShared.h
--- mozilla/js/src/vm/RegExpShared.h	2022-01-25 01:04:29.000000000 +0300
+++ mozilla-OK/js/src/vm/RegExpShared.h	2022-04-22 05:08:30.728181968 +0300
@@ -21,8 +21,11 @@
 #include "gc/Barrier.h"
 #include "gc/Heap.h"
 #include "gc/Marking.h"
+#include "jit/JitOptions.h"
+#include "js/RegExpFlags.h"
 #include "js/UbiNode.h"
 #include "js/Vector.h"
+#include "irregexp/RegExpTypes.h"
 #include "vm/ArrayObject.h"
 
 struct JSContext;
@@ -39,31 +42,19 @@ using RootedRegExpShared = JS::Rooted<Re
 using HandleRegExpShared = JS::Handle<RegExpShared*>;
 using MutableHandleRegExpShared = JS::MutableHandle<RegExpShared*>;
 
-enum RegExpFlag : uint8_t
+enum RegExpRunStatus : int32_t
 {
-    IgnoreCaseFlag  = 0x01,
-    GlobalFlag      = 0x02,
-    MultilineFlag   = 0x04,
-    StickyFlag      = 0x08,
-    UnicodeFlag     = 0x10,
-
-    NoFlags         = 0x00,
-    AllFlags        = 0x1f
-};
-
-static_assert(IgnoreCaseFlag == REGEXP_IGNORECASE_FLAG &&
-              GlobalFlag == REGEXP_GLOBAL_FLAG &&
-              MultilineFlag == REGEXP_MULTILINE_FLAG &&
-              StickyFlag == REGEXP_STICKY_FLAG &&
-              UnicodeFlag == REGEXP_UNICODE_FLAG,
-              "Flag values should be in sync with self-hosted JS");
-
-enum RegExpRunStatus
-{
-    RegExpRunStatus_Error,
-    RegExpRunStatus_Success,
-    RegExpRunStatus_Success_NotFound
+    RegExpRunStatus_Error = -1,
+    RegExpRunStatus_Success = 1,
+    RegExpRunStatus_Success_NotFound = 0,
 };
+inline bool IsNativeRegExpEnabled(JSContext* cx) {
+#ifdef JS_CODEGEN_NONE
+  return false;
+#else
+  return cx->options().nativeRegExp();
+#endif
+}
 
 /*
  * A RegExpShared is the compiled representation of a regexp. A RegExpShared is
@@ -85,17 +76,22 @@ enum RegExpRunStatus
 class RegExpShared : public gc::TenuredCell
 {
   public:
-    enum CompilationMode {
-        Normal,
-        MatchOnly
+    enum class Kind
+    {
+        Unparsed,
+        Atom,
+        RegExp
     };
 
-    enum ForceByteCodeEnum {
-        DontForceByteCode,
-        ForceByteCode
+    enum class CodeKind
+    {
+        Bytecode,
+        Jitcode,
+        Any
     };
 
-    using JitCodeTable = UniquePtr<uint8_t[], JS::FreePolicy>;
+    using ByteCode = js::irregexp::ByteArrayData;
+    using JitCodeTable = js::irregexp::ByteArray;
     using JitCodeTables = Vector<JitCodeTable, 0, SystemAllocPolicy>;
 
   private:
@@ -105,63 +101,75 @@ class RegExpShared : public gc::TenuredC
     struct RegExpCompilation
     {
         ReadBarriered<jit::JitCode*> jitCode;
-        uint8_t* byteCode;
+        ByteCode* byteCode;
 
         RegExpCompilation() : byteCode(nullptr) {}
 
-        bool compiled(ForceByteCodeEnum force = DontForceByteCode) const {
-            return byteCode || (force == DontForceByteCode && jitCode);
+        bool compiled(CodeKind kind = CodeKind::Any) const
+        {
+            switch (kind) {
+                case CodeKind::Bytecode:
+                    return !!byteCode;
+                case CodeKind::Jitcode:
+                    return !!jitCode;
+                case CodeKind::Any:
+                    return !!byteCode || !!jitCode;
+            }
+            MOZ_CRASH("Unreachable");
         }
     };
 
     /* Source to the RegExp, for lazy compilation. */
     GCPtr<JSAtom*>     source;
 
-    RegExpFlag         flags;
-    bool               canStringMatch;
-    size_t             parenCount;
-
-    RegExpCompilation  compilationArray[4];
-
-    static int CompilationIndex(CompilationMode mode, bool latin1) {
-        switch (mode) {
-          case Normal:    return latin1 ? 0 : 1;
-          case MatchOnly: return latin1 ? 2 : 3;
-        }
-        MOZ_CRASH();
-    }
+    JS::RegExpFlags    flags;
+
+    RegExpShared::Kind kind_ = Kind::Unparsed;
+    GCPtrAtom patternAtom_;
+    uint32_t maxRegisters_ = 0;
+    uint32_t ticks_ = 0;
+
+    uint32_t numNamedCaptures_ = {};
+    uint32_t* namedCaptureIndices_ = {};
+    GCPtr<PlainObject*> groupsTemplate_ = {};
+
+    size_t             pairCount_;
+
+    RegExpCompilation  compilationArray[2];
+
+    static int CompilationIndex(bool latin1) { return latin1 ? 0 : 1; }
 
     // Tables referenced by JIT code.
     JitCodeTables tables;
 
     /* Internal functions. */
-    RegExpShared(JSAtom* source, RegExpFlag flags);
-
-    static bool compile(JSContext* cx, MutableHandleRegExpShared res, HandleLinearString input,
-                        CompilationMode mode, ForceByteCodeEnum force);
-    static bool compile(JSContext* cx, MutableHandleRegExpShared res, HandleAtom pattern,
-                        HandleLinearString input, CompilationMode mode, ForceByteCodeEnum force);
+    RegExpShared(JSAtom* source, JS::RegExpFlags flags);
 
-    static bool compileIfNecessary(JSContext* cx, MutableHandleRegExpShared res,
-                                   HandleLinearString input, CompilationMode mode,
-                                   ForceByteCodeEnum force);
+    static bool compileIfNecessary(JSContext* cx,
+                                   MutableHandleRegExpShared res,
+                                   HandleLinearString input,
+                                   CodeKind code);
 
-    const RegExpCompilation& compilation(CompilationMode mode, bool latin1) const {
-        return compilationArray[CompilationIndex(mode, latin1)];
+    const RegExpCompilation& compilation(bool latin1) const {
+        return compilationArray[CompilationIndex(latin1)];
     }
 
-    RegExpCompilation& compilation(CompilationMode mode, bool latin1) {
-        return compilationArray[CompilationIndex(mode, latin1)];
+    RegExpCompilation& compilation(bool latin1) {
+        return compilationArray[CompilationIndex(latin1)];
     }
 
   public:
     ~RegExpShared() = delete;
 
-    // Execute this RegExp on input starting from searchIndex, filling in
-    // matches if specified and otherwise only determining if there is a match.
+    static RegExpRunStatus executeAtom(MutableHandleRegExpShared re,
+                                       HandleLinearString input,
+                                       size_t start,
+                                       MatchPairs* matches);
+
+    // Execute this RegExp on input starting from searchIndex, filling in matches.
     static RegExpRunStatus execute(JSContext* cx, MutableHandleRegExpShared res,
                                    HandleLinearString input, size_t searchIndex,
-                                   MatchPairs* matches, size_t* endIndex);
+                                   MatchPairs* matches);
 
     // Register a table with this RegExpShared, and take ownership.
     bool addTable(JitCodeTable table) {
@@ -170,30 +178,63 @@ class RegExpShared : public gc::TenuredC
 
     /* Accessors */
 
-    size_t getParenCount() const {
-        MOZ_ASSERT(isCompiled());
-        return parenCount;
+    size_t pairCount() const {
+        MOZ_ASSERT(kind() != Kind::Unparsed);
+        return pairCount_;
     }
 
-    /* Accounts for the "0" (whole match) pair. */
-    size_t pairCount() const            { return getParenCount() + 1; }
+    RegExpShared::Kind kind() const { return kind_; }
+
+    // Use simple string matching for this regexp.
+    void useAtomMatch(HandleAtom pattern);
+
+    // Use the regular expression engine for this regexp.
+    void useRegExpMatch(size_t parenCount);
+
+    static bool initializeNamedCaptures(JSContext* cx,
+                                        HandleRegExpShared re,
+                                        HandleNativeObject namedCaptures);
+    PlainObject* getGroupsTemplate() { return groupsTemplate_; }
+
+    void tierUpTick();
+    bool markedForTierUp(JSContext* cx) const;
+
+    void setByteCode(ByteCode* code, bool latin1) { compilation(latin1).byteCode = code; }
+    ByteCode* getByteCode(bool latin1) const { return compilation(latin1).byteCode; }
+    void setJitCode(jit::JitCode* code, bool latin1) { compilation(latin1).jitCode = code; }
+    jit::JitCode* getJitCode(bool latin1) const { return compilation(latin1).jitCode; }
+    uint32_t getMaxRegisters() const { return maxRegisters_; }
+    void updateMaxRegisters(uint32_t numRegisters)
+    {
+        maxRegisters_ = std::max(maxRegisters_, numRegisters);
+    }
+
+    uint32_t numNamedCaptures() const { return numNamedCaptures_; }
+    int32_t getNamedCaptureIndex(uint32_t idx) const
+    {
+        MOZ_ASSERT(idx < numNamedCaptures());
+        MOZ_ASSERT(namedCaptureIndices_);
+        return namedCaptureIndices_[idx];
+    }
 
     JSAtom* getSource() const           { return source; }
-    RegExpFlag getFlags() const         { return flags; }
-    bool ignoreCase() const             { return flags & IgnoreCaseFlag; }
-    bool global() const                 { return flags & GlobalFlag; }
-    bool multiline() const              { return flags & MultilineFlag; }
-    bool sticky() const                 { return flags & StickyFlag; }
-    bool unicode() const                { return flags & UnicodeFlag; }
-
-    bool isCompiled(CompilationMode mode, bool latin1,
-                    ForceByteCodeEnum force = DontForceByteCode) const {
-        return compilation(mode, latin1).compiled(force);
-    }
-    bool isCompiled() const {
-        return isCompiled(Normal, true) || isCompiled(Normal, false)
-            || isCompiled(MatchOnly, true) || isCompiled(MatchOnly, false);
+
+    JSAtom* patternAtom() const         { return patternAtom_; }
+
+    JS::RegExpFlags getFlags() const    { return flags; }
+
+    bool global() const                 { return flags.global(); }
+    bool ignoreCase() const             { return flags.ignoreCase(); }
+    bool multiline() const              { return flags.multiline(); }
+    bool dotAll() const                 { return flags.dotAll(); }
+    bool unicode() const                { return flags.unicode(); }
+    bool sticky() const                 { return flags.sticky(); }
+
+    bool isCompiled(bool latin1, CodeKind codeKind = CodeKind::Any) const
+    {
+        return compilation(latin1).compiled(codeKind);
     }
+    bool isCompiled() const { return isCompiled(true) || isCompiled(false); }
 
     void traceChildren(JSTracer* trc);
     void discardJitCode();
@@ -203,55 +244,62 @@ class RegExpShared : public gc::TenuredC
         return offsetof(RegExpShared, source);
     }
 
+    static size_t offsetOfPatternAtom() {
+        return offsetof(RegExpShared, patternAtom_);
+    }
+
     static size_t offsetOfFlags() {
         return offsetof(RegExpShared, flags);
     }
 
-    static size_t offsetOfParenCount() {
-        return offsetof(RegExpShared, parenCount);
+    static size_t offsetOfPairCount() {
+        return offsetof(RegExpShared, pairCount_);
     }
 
-    static size_t offsetOfLatin1JitCode(CompilationMode mode) {
-        return offsetof(RegExpShared, compilationArray)
-             + (CompilationIndex(mode, true) * sizeof(RegExpCompilation))
-             + offsetof(RegExpCompilation, jitCode);
-    }
-    static size_t offsetOfTwoByteJitCode(CompilationMode mode) {
-        return offsetof(RegExpShared, compilationArray)
-             + (CompilationIndex(mode, false) * sizeof(RegExpCompilation))
-             + offsetof(RegExpCompilation, jitCode);
+    static size_t offsetOfJitCode(bool latin1)
+    {
+        return offsetof(RegExpShared, compilationArray) +
+               (CompilationIndex(latin1) * sizeof(RegExpCompilation)) +
+               offsetof(RegExpCompilation, jitCode);
+    }
+
+    static size_t offsetOfGroupsTemplate() {
+        return offsetof(RegExpShared, groupsTemplate_);
     }
 
     size_t sizeOfExcludingThis(mozilla::MallocSizeOf mallocSizeOf);
 
 #ifdef DEBUG
-    static bool dumpBytecode(JSContext* cx, MutableHandleRegExpShared res, bool match_only,
+    static bool dumpBytecode(JSContext* cx,
+                             MutableHandleRegExpShared res,
                              HandleLinearString input);
 #endif
 };
 
 class RegExpZone
 {
-    struct Key {
-        JSAtom* atom;
-        uint16_t flag;
-
-        Key() {}
-        Key(JSAtom* atom, RegExpFlag flag)
-          : atom(atom), flag(flag)
-        { }
+    struct Key
+    {
+        JSAtom* atom = nullptr;
+        JS::RegExpFlags flags = JS::RegExpFlag::NoFlags;
+
+        Key() = default;
+        Key(JSAtom* atom, JS::RegExpFlags flags)
+          : atom(atom)
+          , flags(flags)
+        {}
         MOZ_IMPLICIT Key(const ReadBarriered<RegExpShared*>& shared)
           : atom(shared.unbarrieredGet()->getSource()),
-            flag(shared.unbarrieredGet()->getFlags())
+            flags(shared.unbarrieredGet()->getFlags())
         { }
 
         typedef Key Lookup;
         static HashNumber hash(const Lookup& l) {
             HashNumber hash = DefaultHasher<JSAtom*>::hash(l.atom);
-            return mozilla::AddToHash(hash, l.flag);
+            return mozilla::AddToHash(hash, l.flags.value());
         }
         static bool match(Key l, Key r) {
-            return l.atom == r.atom && l.flag == r.flag;
+            return l.atom == r.atom && l.flags == r.flags;
         }
     };
 
@@ -273,7 +321,12 @@ class RegExpZone
 
     bool empty() const { return set_.empty(); }
 
-    RegExpShared* get(JSContext* cx, HandleAtom source, RegExpFlag flags);
+    RegExpShared* maybeGet(JSAtom* source, JS::RegExpFlags flags) const {
+        Set::Ptr p = set_.lookup(Key(source, flags));
+        return p ? *p : nullptr;
+    }
+
+    RegExpShared* get(JSContext* cx, HandleAtom source, JS::RegExpFlags flags);
 
     /* Like 'get', but compile 'maybeOpt' (if non-null). */
     RegExpShared* get(JSContext* cx, HandleAtom source, JSString* maybeOpt);
@@ -346,6 +399,9 @@ class RegExpCompartment
     }
 };
 
+RegExpRunStatus ExecuteRegExpAtomRaw(RegExpShared* re, JSLinearString* input,
+                                     size_t start, MatchPairs* matchPairs);
+
 } /* namespace js */
 
 namespace JS {
diff -Nrup mozilla/js/src/vm/RegExpStatics.cpp mozilla-OK/js/src/vm/RegExpStatics.cpp
--- mozilla/js/src/vm/RegExpStatics.cpp	2021-10-26 19:49:54.000000000 +0300
+++ mozilla-OK/js/src/vm/RegExpStatics.cpp	2022-04-22 05:04:05.970037726 +0300
@@ -95,8 +95,7 @@ RegExpStatics::executeLazy(JSContext* cx
 
     /* Execute the full regular expression. */
     RootedLinearString input(cx, matchesInput);
-    RegExpRunStatus status = RegExpShared::execute(cx, &shared, input, lazyIndex, &this->matches,
-                                                   nullptr);
+    RegExpRunStatus status = RegExpShared::execute(cx, &shared, input, lazyIndex, &this->matches);
     if (status == RegExpRunStatus_Error)
         return false;
 
diff -Nrup mozilla/js/src/vm/RegExpStatics.h mozilla-OK/js/src/vm/RegExpStatics.h
--- mozilla/js/src/vm/RegExpStatics.h	2022-04-13 21:14:22.000000000 +0300
+++ mozilla-OK/js/src/vm/RegExpStatics.h	2022-04-22 05:03:52.117134824 +0300
@@ -31,8 +31,8 @@ class RegExpStatics
      * a different compartment via evalcx().
      */
     HeapPtr<JSAtom*>          lazySource;
-    RegExpFlag              lazyFlags;
-    size_t                  lazyIndex;
+    JS::RegExpFlags            lazyFlags;
+    size_t                    lazyIndex;
 
     /* The latest RegExp input, set before execution. */
     HeapPtr<JSString*>        pendingInput;
@@ -279,7 +279,7 @@ RegExpStatics::clear()
     matches.forgetArray();
     matchesInput = nullptr;
     lazySource = nullptr;
-    lazyFlags = RegExpFlag(0);
+    lazyFlags = JS::RegExpFlag::NoFlags;
     lazyIndex = size_t(-1);
     pendingInput = nullptr;
     pendingLazyEvaluation = false;
diff -Nrup mozilla/js/src/vm/Runtime.h mozilla-OK/js/src/vm/Runtime.h
--- mozilla/js/src/vm/Runtime.h	2022-01-25 01:04:29.000000000 +0300
+++ mozilla-OK/js/src/vm/Runtime.h	2022-04-22 05:06:08.738177217 +0300
@@ -31,7 +31,6 @@
 #include "gc/GCRuntime.h"
 #include "gc/Tracer.h"
 #include "gc/ZoneGroup.h"
-#include "irregexp/RegExpStack.h"
 #include "js/Debug.h"
 #include "js/GCVector.h"
 #include "js/HashTable.h"
diff -Nrup mozilla/js/src/vm/SelfHosting.cpp mozilla-OK/js/src/vm/SelfHosting.cpp
--- mozilla/js/src/vm/SelfHosting.cpp	2022-02-20 18:39:44.000000000 +0300
+++ mozilla-OK/js/src/vm/SelfHosting.cpp	2022-04-22 05:05:32.417431812 +0300
@@ -890,6 +890,21 @@ js::intrinsic_NewStringIterator(JSContex
     return true;
 }
 
+bool
+js::intrinsic_NewRegExpStringIterator(JSContext* cx, unsigned argc, Value* vp) 
+{
+  CallArgs args = CallArgsFromVp(argc, vp);
+  MOZ_ASSERT(args.length() == 0);
+
+  JSObject* obj = NewRegExpStringIteratorObject(cx);
+  if (!obj) {
+    return false;
+  }
+
+  args.rval().setObject(*obj);
+  return true;
+}
+
 static bool
 intrinsic_SetCanonicalName(JSContext* cx, unsigned argc, Value* vp)
 {
@@ -1651,7 +1666,7 @@ static bool
 intrinsic_RegExpGetSubstitution(JSContext* cx, unsigned argc, Value* vp)
 {
     CallArgs args = CallArgsFromVp(argc, vp);
-    MOZ_ASSERT(args.length() == 5);
+    MOZ_ASSERT(args.length() == 6);
 
     RootedArrayObject matchResult(cx, &args[0].toObject().as<ArrayObject>());
 
@@ -1669,8 +1684,17 @@ intrinsic_RegExpGetSubstitution(JSContex
     int32_t firstDollarIndex = int32_t(args[4].toNumber());
     MOZ_ASSERT(firstDollarIndex >= 0);
 
-    return RegExpGetSubstitution(cx, matchResult, string, size_t(position), replacement,
-                                 size_t(firstDollarIndex), args.rval());
+    RootedValue namedCaptures(cx, args[5]);
+    MOZ_ASSERT(namedCaptures.isUndefined() || namedCaptures.isObject());
+
+    return RegExpGetSubstitution(cx,
+                                 matchResult,
+                                 string,
+                                 size_t(position),
+                                 replacement,
+                                 size_t(firstDollarIndex),
+                                 namedCaptures,
+                                 args.rval());
 }
 
 static bool
@@ -1741,6 +1765,7 @@ intrinsic_StringSplitStringLimit(JSConte
     // args[2] should be already in UInt32 range, but it could be double typed,
     // because of Ion optimization.
     uint32_t limit = uint32_t(args[2].toNumber());
+    MOZ_ASSERT(limit > 0, "Zero limit case is already handled in self-hosted code.");
 
     RootedObjectGroup group(cx, ObjectGroupCompartment::getStringSplitStringGroup(cx));
     if (!group)
@@ -2402,6 +2427,10 @@ static const JSFunctionSpec intrinsic_fu
                     intrinsic_IsInstanceOfBuiltin<StringIteratorObject>, 1,0,
                     IntrinsicIsStringIterator),
 
+    JS_INLINABLE_FN("GuardToRegExpStringIterator",
+                    intrinsic_IsInstanceOfBuiltin<RegExpStringIteratorObject>, 1,0,
+                    IntrinsicGuardToRegExpStringIterator),
+
     JS_FN("_CreateMapIterationResultPair", intrinsic_CreateMapIterationResultPair, 0, 0),
     JS_INLINABLE_FN("_GetNextMapEntryForIterator", intrinsic_GetNextMapEntryForIterator, 2,0,
                     IntrinsicGetNextMapEntryForIterator),
@@ -2420,6 +2449,12 @@ static const JSFunctionSpec intrinsic_fu
     JS_FN("CallStringIteratorMethodIfWrapped",
           CallNonGenericSelfhostedMethod<Is<StringIteratorObject>>,     2,0),
 
+    JS_INLINABLE_FN("NewRegExpStringIterator",
+                    intrinsic_NewRegExpStringIterator, 0, 0,
+                    IntrinsicNewRegExpStringIterator),
+    JS_FN("CallRegExpStringIteratorMethodIfWrapped",
+          CallNonGenericSelfhostedMethod<Is<RegExpStringIteratorObject>>, 2, 0),
+
     JS_FN("IsStarGeneratorObject",
           intrinsic_IsInstanceOfBuiltin<StarGeneratorObject>,           1,0),
     JS_FN("StarGeneratorObjectIsClosed", intrinsic_StarGeneratorObjectIsClosed, 1,0),
diff -Nrup mozilla/js/src/vm/SelfHosting.h mozilla-OK/js/src/vm/SelfHosting.h
--- mozilla/js/src/vm/SelfHosting.h	2020-02-18 02:37:55.000000000 +0300
+++ mozilla-OK/js/src/vm/SelfHosting.h	2022-04-22 05:05:32.419431798 +0300
@@ -53,6 +53,9 @@ intrinsic_NewArrayIterator(JSContext* cx
 bool
 intrinsic_NewStringIterator(JSContext* cx, unsigned argc, JS::Value* vp);
 
+bool
+intrinsic_NewRegExpStringIterator(JSContext* cx, unsigned argc, JS::Value* vp);
+
 } /* namespace js */
 
 #endif /* vm_SelfHosting_h_ */
diff -Nrup mozilla/js/src/vm/StructuredClone.cpp mozilla-OK/js/src/vm/StructuredClone.cpp
--- mozilla/js/src/vm/StructuredClone.cpp	2022-04-13 21:14:22.000000000 +0300
+++ mozilla-OK/js/src/vm/StructuredClone.cpp	2022-04-22 05:03:54.166120500 +0300
@@ -29,6 +29,7 @@
 
 #include "js/StructuredClone.h"
 
+#include "mozilla/Casting.h"
 #include "mozilla/CheckedInt.h"
 #include "mozilla/EndianUtils.h"
 #include "mozilla/FloatingPoint.h"
@@ -44,6 +45,7 @@
 #include "builtin/MapObject.h"
 #include "js/Date.h"
 #include "js/GCHashTable.h"
+#include "js/RegExpFlags.h"
 #include "vm/RegExpObject.h"
 #include "vm/SavedFrame.h"
 #include "vm/SharedArrayObject.h"
@@ -55,12 +57,15 @@
 
 using namespace js;
 
+using mozilla::AssertedCast;
 using mozilla::BitwiseCast;
 using mozilla::IsNaN;
 using mozilla::LittleEndian;
 using mozilla::NativeEndian;
 using mozilla::NumbersAreIdentical;
 using JS::CanonicalizeNaN;
+using JS::RegExpFlag;
+using JS::RegExpFlags;
 
 // When you make updates here, make sure you consider whether you need to bump the
 // value of JS_STRUCTURED_CLONE_VERSION in js/public/StructuredClone.h.  You will
@@ -1485,7 +1490,7 @@ JSStructuredCloneWriter::startWrite(Hand
             RegExpShared* re = RegExpToShared(context(), obj);
             if (!re)
                 return false;
-            return out.writePair(SCTAG_REGEXP_OBJECT, re->getFlags()) &&
+            return out.writePair(SCTAG_REGEXP_OBJECT, re->getFlags().value()) &&
                    writeString(SCTAG_STRING, re->getSource());
         } else if (cls == ESClass::Date) {
             RootedValue unboxed(context());
@@ -2126,7 +2131,14 @@ JSStructuredCloneReader::startRead(Mutab
       }
 
       case SCTAG_REGEXP_OBJECT: {
-        RegExpFlag flags = RegExpFlag(data);
+        if ((data & RegExpFlag::AllFlags) != data) {
+          JS_ReportErrorNumberASCII(context(), GetErrorMessage, nullptr,
+                                    JSMSG_SC_BAD_SERIALIZED_DATA, "regexp");
+          return false;
+        }
+
+        RegExpFlags flags(AssertedCast<uint8_t>(data));
+
         uint32_t tag2, stringData;
         if (!in.readPair(&tag2, &stringData))
             return false;
@@ -2136,6 +2148,7 @@ JSStructuredCloneReader::startRead(Mutab
                                       "regexp");
             return false;
         }
+
         JSString* str = readString(stringData);
         if (!str)
             return false;
diff -Nrup mozilla/js/src/vm/UnicodeNonBMP.h mozilla-OK/js/src/vm/UnicodeNonBMP.h
--- mozilla/js/src/vm/UnicodeNonBMP.h	2020-08-10 14:30:35.000000000 +0300
+++ mozilla-OK/js/src/vm/UnicodeNonBMP.h	2022-04-22 05:08:24.546225293 +0300
@@ -48,32 +48,4 @@
     macro(0x16e60, 0x16e7f, 0xd81b, 0xde60, 0xde7f, -32) \
     macro(0x1e922, 0x1e943, 0xd83a, 0xdd22, 0xdd43, -34)
 
-// U+10400 DESERET CAPITAL LETTER LONG I .. U+10427 DESERET CAPITAL LETTER EW
-// U+104B0 OSAGE CAPITAL LETTER A .. U+104D3 OSAGE CAPITAL LETTER ZHA
-// U+10C80 OLD HUNGARIAN CAPITAL LETTER A .. U+10CB2 OLD HUNGARIAN CAPITAL LETTER US
-// U+118A0 WARANG CITI CAPITAL LETTER NGAA .. U+118BF WARANG CITI CAPITAL LETTER VIYO
-// U+16E40 MEDEFAIDRIN CAPITAL LETTER M .. U+16E5F MEDEFAIDRIN CAPITAL LETTER Y
-// U+1E900 ADLAM CAPITAL LETTER ALIF .. U+1E921 ADLAM CAPITAL LETTER SHA
-#define FOR_EACH_NON_BMP_CASE_FOLDING(macro) \
-    macro(0x10400, 0x10427, 0xd801, 0xdc00, 0xdc27, 40) \
-    macro(0x104b0, 0x104d3, 0xd801, 0xdcb0, 0xdcd3, 40) \
-    macro(0x10c80, 0x10cb2, 0xd803, 0xdc80, 0xdcb2, 64) \
-    macro(0x118a0, 0x118bf, 0xd806, 0xdca0, 0xdcbf, 32) \
-    macro(0x16e40, 0x16e5f, 0xd81b, 0xde40, 0xde5f, 32) \
-    macro(0x1e900, 0x1e921, 0xd83a, 0xdd00, 0xdd21, 34)
-
-// U+10428 DESERET SMALL LETTER LONG I .. U+1044F DESERET SMALL LETTER EW
-// U+104D8 OSAGE SMALL LETTER A .. U+104FB OSAGE SMALL LETTER ZHA
-// U+10CC0 OLD HUNGARIAN SMALL LETTER A .. U+10CF2 OLD HUNGARIAN SMALL LETTER US
-// U+118C0 WARANG CITI SMALL LETTER NGAA .. U+118DF WARANG CITI SMALL LETTER VIYO
-// U+16E60 MEDEFAIDRIN SMALL LETTER M .. U+16E7F MEDEFAIDRIN SMALL LETTER Y
-// U+1E922 ADLAM SMALL LETTER ALIF .. U+1E943 ADLAM SMALL LETTER SHA
-#define FOR_EACH_NON_BMP_REV_CASE_FOLDING(macro) \
-    macro(0x10428, 0x1044f, 0xd801, 0xdc28, 0xdc4f, -40) \
-    macro(0x104d8, 0x104fb, 0xd801, 0xdcd8, 0xdcfb, -40) \
-    macro(0x10cc0, 0x10cf2, 0xd803, 0xdcc0, 0xdcf2, -64) \
-    macro(0x118c0, 0x118df, 0xd806, 0xdcc0, 0xdcdf, -32) \
-    macro(0x16e60, 0x16e7f, 0xd81b, 0xde60, 0xde7f, -32) \
-    macro(0x1e922, 0x1e943, 0xd83a, 0xdd22, 0xdd43, -34)
-
 #endif /* vm_UnicodeNonBMP_h */
diff -Nrup mozilla/js/src/vm/make_unicode.py mozilla-OK/js/src/vm/make_unicode.py
--- mozilla/js/src/vm/make_unicode.py	2020-08-10 14:30:35.000000000 +0300
+++ mozilla-OK/js/src/vm/make_unicode.py	2022-04-22 05:08:24.557225216 +0300
@@ -393,18 +393,11 @@ def process_case_folding(case_folding):
     folding_tests = []
     folding_codes = set()
 
-    non_bmp_folding_map = {}
-    non_bmp_rev_folding_map = {}
-
     for row in read_case_folding(case_folding):
         code = row[0]
         mapping = row[2]
         folding_map[code] = mapping
 
-        if code > MAX_BMP:
-            non_bmp_folding_map[code] = mapping
-            non_bmp_rev_folding_map[mapping] = code
-
         if mapping not in rev_folding_map:
             rev_folding_map[mapping] = [code]
         else:
@@ -459,7 +452,6 @@ def process_case_folding(case_folding):
         folding_index[code] = i
     return (
         folding_table, folding_index,
-        non_bmp_folding_map, non_bmp_rev_folding_map,
         folding_tests
     )
 
@@ -604,7 +596,6 @@ def process_special_casing(special_casin
 
 def make_non_bmp_file(version,
                       non_bmp_lower_map, non_bmp_upper_map,
-                      non_bmp_folding_map, non_bmp_rev_folding_map,
                       codepoint_table):
     file_name = 'UnicodeNonBMP.h';
     with io.open(file_name, mode='wb') as non_bmp_file:
@@ -631,10 +622,6 @@ def make_non_bmp_file(version,
         make_non_bmp_convert_macro(non_bmp_file, 'LOWERCASE', non_bmp_lower_map, codepoint_table)
         non_bmp_file.write('\n')
         make_non_bmp_convert_macro(non_bmp_file, 'UPPERCASE', non_bmp_upper_map, codepoint_table)
-        non_bmp_file.write('\n')
-        make_non_bmp_convert_macro(non_bmp_file, 'CASE_FOLDING', non_bmp_folding_map, codepoint_table)
-        non_bmp_file.write('\n')
-        make_non_bmp_convert_macro(non_bmp_file, 'REV_CASE_FOLDING', non_bmp_rev_folding_map, codepoint_table)
 
         non_bmp_file.write("""
 #endif /* util_UnicodeNonBMP_h */
@@ -1287,203 +1274,6 @@ def splitbins(t):
         assert t[i] == t2[(t1[i >> shift] << shift) + (i & mask)]
     return best
 
-def make_irregexp_tables(version,
-                         table, index,
-                         folding_table, folding_index,
-                         codepoint_table):
-    import string
-
-    MAX_ASCII = 0x7F
-    MAX_LATIN1 = 0xFF
-    LEAD_SURROGATE_MIN = 0xD800
-    TRAIL_SURROGATE_MAX = 0xDFFF
-
-    def hex2(n):
-        assert 0 <= n and n < 16**2
-        return '0x{:02X}'.format(n)
-
-    def hex4(n):
-        assert 0 <= n and n < 16**4
-        return '0x{:04X}'.format(n)
-
-    def uhex4(n):
-        assert 0 <= n and n < 16**4
-        return 'U+{:04X}'.format(n)
-
-    def case_info(code):
-        assert 0 <= code and code <= MAX_BMP
-        (upper, lower, flags) = table[index[code]]
-        return ((code + upper) & 0xffff, (code + lower) & 0xffff, flags)
-
-    def is_space(code):
-        (_, _, flags) = case_info(code)
-        return bool(flags & FLAG_SPACE)
-
-    def to_upper(code):
-        (upper, _, _) = case_info(code)
-        return upper
-
-    def casefold(code):
-        assert 0 <= code and code <= MAX_BMP
-        (folding, _, _, _) = folding_table[folding_index[code]]
-        return (code + folding) & 0xffff
-
-    def casefolds_to_ascii(code):
-        return casefold(code) <= MAX_ASCII
-
-    def casefolds_to_latin1(code):
-        return casefold(code) <= MAX_LATIN1
-
-    def casemaps_to_nonlatin1(code):
-        upper = to_upper(code)
-        return upper > MAX_LATIN1
-
-    def char_name(code):
-        assert 0 <= code and code <= MAX_BMP
-        if code not in codepoint_table:
-            return '<Unused>'
-        if code == LEAD_SURROGATE_MIN:
-            return '<Lead Surrogate Min>'
-        if code == TRAIL_SURROGATE_MAX:
-            return '<Trail Surrogate Max>'
-        (_, _, name, alias) = codepoint_table[code]
-        return name if not name.startswith('<') else alias
-
-    def write_character_range(println, name, characters):
-        char_ranges = list(int_ranges(characters))
-        println('')
-        println('const int js::irregexp::k{}Ranges[] = {{'.format(name))
-        for (start, end) in char_ranges:
-            s_name = char_name(start)
-            e_name = char_name(end)
-            println('    {}, {} + 1, // {}'.format(hex4(start), hex4(end),
-                                                               '{}..{}'.format(s_name, e_name)
-                                                               if start != end else s_name))
-        println('    {} + 1'.format(hex4(MAX_BMP)))
-        println('};')
-        println('const int js::irregexp::k{}RangeCount = {};'.format(name,
-                                                                     len(char_ranges) * 2 + 1))
-
-    def write_character_test(println, test, consequent, default):
-        # Latin1 characters which, when case-mapped through
-        # String.prototype.toUpperCase(), canonicalize to a non-Latin1 character.
-        # ES2017, 21.2.2.8.2 Runtime Semantics: Canonicalize
-        casemapped_to_nonlatin1 = ifilter(casemaps_to_nonlatin1, xrange(0, MAX_LATIN1 + 1))
-
-        def casemap_closure(ch):
-            upper = to_upper(ch)
-            return (ch, [c for c in xrange(MAX_LATIN1 + 1, MAX_BMP + 1) if upper == to_upper(c)])
-
-        # Mapping from Latin1 characters to the list of case map equivalent
-        # non-Latin1 characters.
-        casemap_for_latin1 = dict(chain(imap(casemap_closure, casemapped_to_nonlatin1)))
-
-        # Non-latin1 characters which, when Unicode case-folded, canonicalize to
-        # a Latin1 character.
-        # ES2017, 21.2.2.8.2 Runtime Semantics: Canonicalize
-        casefolded_to_latin1 = ifilter(casefolds_to_latin1, xrange(MAX_LATIN1 + 1, MAX_BMP + 1))
-
-        println('    if (unicode) {')
-        for ch in casefolded_to_latin1:
-            casefolded = casefold(ch)
-            # Skip if also handled below for case mapping.
-            if casefolded in casemap_for_latin1 and ch in casemap_for_latin1[casefolded]:
-                continue
-            println('        // "{}" case folds to "{}".'.format(char_name(ch),
-                                                                 char_name(casefolded)))
-            println('        if ({})'.format(test(ch)))
-            println('            return {};'.format(consequent(casefolded)))
-        println('    }')
-        println('')
-        for (ch, casemapped_chars) in casemap_for_latin1.iteritems():
-            for casemapped in casemapped_chars:
-                println('    // "{}" case maps to "{}".'.format(char_name(casemapped),
-                                                                char_name(ch)))
-            println('    if ({})'.format(' || '.join(imap(test, casemapped_chars))))
-            println('        return {};'.format(consequent(ch)))
-        println('    return {};'.format(default))
-
-    with io.open('../irregexp/RegExpCharacters-inl.h', 'wb') as chars_file:
-        write = partial(print, file=chars_file, sep='', end='')
-        println = partial(write, end='\n')
-
-        write(warning_message)
-        write(unicode_version_message.format(version))
-
-        println('#ifndef V8_JSREGEXPCHARACTERS_INL_H_')
-        println('#define V8_JSREGEXPCHARACTERS_INL_H_')
-        println('')
-        println('namespace js {')
-        println('')
-        println('namespace irregexp {')
-        println('')
-
-        println('static inline bool')
-        println('RangeContainsLatin1Equivalents(CharacterRange range, bool unicode)')
-        println('{')
-        write_character_test(println, lambda ch: 'range.Contains({})'.format(hex4(ch)),
-                             lambda _: 'true', 'false')
-        println('}')
-
-        println('')
-        println('} } // namespace js::irregexp')
-        println('')
-        println('#endif // V8_JSREGEXPCHARACTERS_INL_H_')
-
-    with io.open('../irregexp/RegExpCharacters.cpp', 'wb') as chars_file:
-        write = partial(print, file=chars_file, sep='', end='')
-        println = partial(write, end='\n')
-        character_range = partial(write_character_range, println)
-
-        # Characters in \s, 21.2.2.12 CharacterClassEscape.
-        space_chars = filter(is_space, xrange(0, MAX_BMP + 1))
-
-        # Characters in \d, 21.2.2.12 CharacterClassEscape.
-        digit_chars = map(ord, string.digits)
-        assert all(ch <= MAX_ASCII for ch in digit_chars)
-
-        # Characters in \w, 21.2.2.12 CharacterClassEscape.
-        word_chars = map(ord, string.digits + string.ascii_letters + '_')
-        assert all(ch <= MAX_ASCII for ch in word_chars)
-
-        # Characters which case-fold to characters in \w.
-        ignorecase_word_chars = (word_chars +
-                                filter(casefolds_to_ascii, xrange(MAX_ASCII + 1, MAX_BMP + 1)))
-
-        # Surrogate characters.
-        surrogate_chars = range(LEAD_SURROGATE_MIN, TRAIL_SURROGATE_MAX + 1)
-
-        write(warning_message)
-        write(unicode_version_message.format(version))
-        println('#include "irregexp/RegExpCharacters.h"')
-        println('')
-        println('#include "mozilla/Assertions.h"')
-        println('')
-
-        println('char16_t')
-        println('js::irregexp::ConvertNonLatin1ToLatin1(char16_t c, bool unicode)')
-        println('{')
-        println('    MOZ_ASSERT(c > {}, "Character mustn\'t be Latin1");'.format(hex2(MAX_LATIN1)))
-        write_character_test(println, lambda ch: 'c == {}'.format(hex4(ch)), hex2, '0')
-        println('}')
-
-        character_range('Space', space_chars)
-        character_range('SpaceAndSurrogate', space_chars + surrogate_chars)
-
-        character_range('Word', word_chars)
-        character_range('IgnoreCaseWord', ignorecase_word_chars)
-        character_range('WordAndSurrogate', word_chars + surrogate_chars)
-        character_range('NegatedIgnoreCaseWordAndSurrogate',
-                        set(xrange(0, MAX_BMP + 1)) - set(ignorecase_word_chars + surrogate_chars))
-
-        character_range('Digit', digit_chars)
-        character_range('DigitAndSurrogate', digit_chars + surrogate_chars)
-
-        character_range('Surrogate', surrogate_chars)
-
-        character_range('LineTerminator', line_terminator)
-        character_range('LineTerminatorAndSurrogate', line_terminator + surrogate_chars)
-
 def update_unicode(args):
     import urllib2
 
@@ -1542,7 +1332,6 @@ def update_unicode(args):
         ) = process_unicode_data(unicode_data, derived_core_properties)
         (
             folding_table, folding_index,
-            non_bmp_folding_map, non_bmp_rev_folding_map,
             folding_tests
         ) = process_case_folding(case_folding)
         (
@@ -1560,12 +1349,7 @@ def update_unicode(args):
                       codepoint_table)
     make_non_bmp_file(unicode_version,
                       non_bmp_lower_map, non_bmp_upper_map,
-                      non_bmp_folding_map, non_bmp_rev_folding_map,
                       codepoint_table)
-    make_irregexp_tables(unicode_version,
-                         table, index,
-                         folding_table, folding_index,
-                         codepoint_table)
 
     make_bmp_mapping_test(unicode_version,
                           codepoint_table, unconditional_tolower, unconditional_toupper)
diff -Nrup mozilla/toolkit/components/extensions/MatchPattern.cpp mozilla-OK/toolkit/components/extensions/MatchPattern.cpp
--- mozilla/toolkit/components/extensions/MatchPattern.cpp	2022-01-25 01:04:33.000000000 +0300
+++ mozilla-OK/toolkit/components/extensions/MatchPattern.cpp	2022-04-22 05:03:49.746151469 +0300
@@ -6,6 +6,7 @@
 #include "mozilla/extensions/MatchPattern.h"
 #include "mozilla/extensions/MatchGlob.h"
 
+#include "js/RegExp.h"  // JS::NewUCRegExpObject, JS::ExecuteRegExpNoStatics
 #include "mozilla/dom/ScriptSettings.h"
 #include "mozilla/HoldDropJSObjects.h"
 #include "mozilla/Unused.h"
@@ -697,7 +698,7 @@ MatchGlob::Init(JSContext* aCx, const ns
   // TODO: Switch to the Rust regexp crate, when Rust integration is easier.
   // It uses a much more efficient, linear time matching algorithm, and
   // doesn't require special casing for the literal and prefix cases.
-  mRegExp = JS_NewUCRegExpObject(aCx, escaped.get(), escaped.Length(), 0);
+  mRegExp = JS::NewUCRegExpObject(aCx, escaped.get(), escaped.Length(), 0);
   if (mRegExp) {
     mozilla::HoldJSObjects(this);
   } else {
@@ -721,7 +722,7 @@ MatchGlob::Matches(const nsAString& aStr
     nsString input(aString);
 
     size_t index = 0;
-    if (!JS_ExecuteRegExpNoStatics(cx, regexp, input.BeginWriting(), aString.Length(),
+    if (!JS::ExecuteRegExpNoStatics(cx, regexp, input.BeginWriting(), aString.Length(),
                                    &index, true, &result)) {
       return false;
     }
