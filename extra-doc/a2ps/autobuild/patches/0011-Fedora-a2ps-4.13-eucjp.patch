diff -up a2ps-4.14/config.h.in.euc a2ps-4.14/config.h.in
--- a2ps-4.14/config.h.in.euc	2007-12-29 04:28:05.000000000 +0100
+++ a2ps-4.14/config.h.in	2008-04-27 10:39:24.000000000 +0200
@@ -24,6 +24,9 @@
 /* Define if TIOCGWINSZ requires sys/ioctl.h */
 #undef GWINSZ_IN_SYS_IOCTL
 
+/* Define if you want to support japanese  */
+#undef ENABLE_KANJI
+ 
 /* Define to 1 if you have the `alarm' function. */
 #undef HAVE_ALARM
 
diff -up a2ps-4.14/configure.euc a2ps-4.14/configure
--- a2ps-4.14/configure.euc	2008-04-27 10:39:24.000000000 +0200
+++ a2ps-4.14/configure	2008-04-27 10:41:39.000000000 +0200
@@ -1587,7 +1587,8 @@ Optional Packages:
   --with-medium=medium    specify the default medium (A4, Letter, Legal, etc.)
                           default=A4
   --with-encoding=enc     specify the default encoding (ascii, latin1,
-                          latin2... latin6, hp etc.) default=latin1
+                          latin2... latin6, euc-jp, hp etc.) default=latin1
+  --enable-kanji 	  support Japanese (default=yes)
 
 Some influential environment variables:
   CC          C compiler command
@@ -22521,7 +22522,7 @@ fi
 
 for ac_header in sys/time.h sys/stat.h sys/types.h sys/ioctl.h  \
  math.h string.h strings.h stdlib.h unistd.h stdarg.h pwd.h malloc.h \
- memory.h errno.h fcntl.h stdbool.h fnmatch.h
+ memory.h errno.h fcntl.h stdbool.h fnmatch.h iconv.h
 do
 as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
 if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
@@ -30947,6 +30948,22 @@ fi
 
 
 
+# Check whether --enable-kanji or --disable-kanji was given.
+if test "${enable_kanji+set}" = set; then
+  enableval="$enable_kanji"
+  SUPPORT_KANJI=$enableval
+else
+  SUPPORT_KANJI=yes
+fi
+
+if test "$SUPPORT_KANJI" = "yes"; then
+	cat >> confdefs.h <<\EOF
+#define ENABLE_KANJI 1
+EOF
+#	ENCODING=euc-jp
+fi
+
+
 ########################
 # Nice special printers
 ########################
diff -up a2ps-4.14/configure.in.euc a2ps-4.14/configure.in
--- a2ps-4.14/configure.in.euc	2008-04-27 10:39:24.000000000 +0200
+++ a2ps-4.14/configure.in	2008-04-27 10:39:24.000000000 +0200
@@ -72,7 +72,7 @@ AC_HEADER_SYS_WAIT
 AC_HEADER_DIRENT
 AC_CHECK_HEADERS(sys/time.h sys/stat.h sys/types.h sys/ioctl.h  \
  math.h string.h strings.h stdlib.h unistd.h stdarg.h pwd.h malloc.h \
- memory.h errno.h fcntl.h stdbool.h fnmatch.h)
+ memory.h errno.h fcntl.h stdbool.h fnmatch.h iconv.h)
 
 ## --------------------- ##
 ## Checks for typedefs.  ##
@@ -276,11 +276,23 @@ AC_SUBST(MEDIUM)
 #
 AC_ARG_WITH(encoding,
 AC_HELP_STRING([--with-encoding=enc],
-               [specify the default encoding (ascii, latin1, latin2... latin6, hp etc.) [default=latin1]]),
+               [specify the default encoding (ascii, latin1, latin2... latin6, euc-jp, hp etc.) [default=latin1]]),
 ENCODING=$with_encoding,
 ENCODING=latin1)
 AC_SUBST(ENCODING)
 
+#
+# use libjcode
+#
+AC_ARG_ENABLE(kanji,
+	[  --enable-kanji	  support Japanese/kanji (default: yes)],
+			SUPPORT_KANJI=$enableval, SUPPORT_KANJI=yes)
+if test "$SUPPORT_KANJI" = "yes"; then
+	AC_DEFINE(ENABLE_KANJI)
+	dnl ENCODING=euc-jp
+fi
+
+
 ########################
 # Nice special printers
 ########################
diff -up a2ps-4.14/encoding/encoding.map.euc a2ps-4.14/encoding/encoding.map
--- a2ps-4.14/encoding/encoding.map.euc	2007-12-29 02:39:21.000000000 +0100
+++ a2ps-4.14/encoding/encoding.map	2008-04-27 10:39:24.000000000 +0200
@@ -93,6 +93,12 @@ koi8r			koi8
 koi8			koi8
 koi			koi8
 
+euc-jp			euc-jp
+eucjp			euc-jp
+japanese		euc-jp
+ja			euc-jp
+jp			euc-jp
+
 ########################################################################
 # Some architectures specific char sets
 ########################################################################
diff -up /dev/null a2ps-4.14/encoding/euc-jp.edf
--- /dev/null	2008-04-27 11:55:27.307012118 +0200
+++ a2ps-4.14/encoding/euc-jp.edf	2008-04-27 10:39:24.000000000 +0200
@@ -0,0 +1,109 @@
+# Description of the EUC-JP encoding
+# Copyright (c) 1988, 89, 90, 91, 92, 93 Miguel Santana
+# Copyright (c) 1995, 96, 97, 98 Akim Demaille, Miguel Santana
+#
+
+#
+# This file is part of a2ps.
+# 
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2, or (at your option)
+# any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; see the file COPYING.  If not, write to
+# the Free Software Foundation, 59 Temple Place - Suite 330,
+# Boston, MA 02111-1307, USA.
+#
+
+Name: EUC-JP
+
+# This text is reproduced by a courtesy of Roman Czyborra
+# http://czyborra.com/charsets/iso8859.html
+Documentation
+The EUC-JP character set, often simply referred to as Latin 1,
+covers most West European languages, such as French, Spanish, Catalan,
+Basque, Portuguese, Italian, Albanian, Rhaeto-Romanic, Dutch, German,
+Danish, Swedish, Norwegian, Finnish, Faroese, Icelandic, Irish,
+Scottish, and English, incidentally also Afrikaans and Swahili, thus
+in effect also the entire American continent, Australia and the
+southern two-thirds of Africa. The lack of the ligatures Dutch IJ,
+French OE and ,,German`` quotation marks is considered tolerable.
+
+The lack of the new C=-resembling Euro currency symbol U+20AC has
+opened the discussion of a new Latin0.
+EndDocumentation
+
+# If there is an unknown font requested, use Courier
+Default: Courier
+
+# Automatic spell checking :)
+Substitute: 	Times			Times-Roman
+Substitute: 	Helvetica-Italic	Helvetica-Oblique
+Substitute: 	Helvetica-BoldItalic	Helvetica-BoldOblique
+
+
+# SlantFont for Japanese Italic Kanji font
+#		new font			source font		value
+SlantFont:	Ryumin-Light-EUC-H-Italic	Ryumin-Light-EUC-H	0.2
+SlantFont:	GothicBBB-Medium-EUC-H-Italic	GothicBBB-Medium-EUC-H	0.2
+
+# Compose font for japanese EUC code
+#		target font		additional font			width	size rate
+DefaultComposite:			Ryumin-Light-EUC-H		1.0	1.1
+
+# 1:2 fixed
+#DefaultComposite:			Ryumin-Light-EUC-H		1.0	0.8333
+
+# 1:1 fixed
+#DefaultComposite:			Ryumin-Light-EUC-H		1.0	1.6666
+
+Composite:	Helvetica		GothicBBB-Medium-EUC-H		1.0	1.1
+Composite:	Helvetica-Oblique	GothicBBB-Medium-EUC-H-Italic	1.0 	1.1
+Composite:	Helvetica-Bold		GothicBBB-Medium-EUC-H  	1.0 	1.1
+Composite:	Helvetica-BoldOblique	GothicBBB-Medium-EUC-H-Italic	1.0	1.1
+
+Composite:	Courier-Oblique		Ryumin-Light-EUC-H-Italic	1.0	1.1
+Composite:	Courier-Bold		GothicBBB-Medium-EUC-H		1.0	1.1
+Composite:	Courier-BoldOblique	GothicBBB-Medium-EUC-H-Italic	1.0	1.1
+Composite:	Times-Bold		GothicBBB-Medium-EUC-H		1.0	1.1
+
+Vector:
+.notdef .notdef .notdef .notdef .notdef .notdef .notdef .notdef
+.notdef .notdef .notdef .notdef .notdef .notdef .notdef .notdef
+.notdef .notdef .notdef .notdef .notdef .notdef .notdef .notdef
+.notdef .notdef .notdef .notdef .notdef .notdef .notdef .notdef
+space exclam quotedbl numbersign dollar percent ampersand quoteright
+parenleft parenright asterisk plus comma minus period slash
+zero one two three four five six seven
+eight nine colon semicolon less equal greater question
+at A B C D E F G
+H I J K L M N O
+P Q R S T U V W
+X Y Z bracketleft backslash bracketright asciicircum underscore
+quoteleft a b c d e f g
+h i j k l m n o
+p q r s t u v w
+x y z braceleft bar braceright asciitilde .notdef
+.notdef .notdef .notdef .notdef .notdef .notdef .notdef .notdef
+.notdef .notdef .notdef .notdef .notdef .notdef .notdef .notdef
+.notdef .notdef .notdef .notdef .notdef .notdef .notdef .notdef
+.notdef .notdef .notdef .notdef .notdef .notdef .notdef .notdef
+space exclamdown cent sterling currency yen brokenbar section
+dieresis copyright ordfeminine guillemotleft logicalnot hyphen registered macron
+degree plusminus twosuperior threesuperior acute mu paragraph bullet
+cedilla onesuperior ordmasculine guillemotright onequarter onehalf threequarters questiondown
+Agrave Aacute Acircumflex Atilde Adieresis Aring AE Ccedilla
+Egrave Eacute Ecircumflex Edieresis Igrave Iacute Icircumflex Idieresis
+Eth Ntilde Ograve Oacute Ocircumflex Otilde Odieresis multiply
+Oslash Ugrave Uacute Ucircumflex Udieresis Yacute Thorn germandbls
+agrave aacute acircumflex atilde adieresis aring ae ccedilla
+egrave eacute ecircumflex edieresis igrave iacute icircumflex idieresis
+eth ntilde ograve oacute ocircumflex otilde odieresis divide
+oslash ugrave uacute ucircumflex udieresis yacute thorn ydieresis
diff -up a2ps-4.14/encoding/Makefile.am.euc a2ps-4.14/encoding/Makefile.am
--- a2ps-4.14/encoding/Makefile.am.euc	2007-12-29 02:39:27.000000000 +0100
+++ a2ps-4.14/encoding/Makefile.am	2008-04-27 10:39:24.000000000 +0200
@@ -16,7 +16,7 @@ major_encodings = ascii.edf iso1.edf
 minor_encodings = \
 ms-cp1250.edf hp.edf mac.edf ibm-cp437.edf ibm-cp850.edf iso2.edf	\
 iso3.edf iso4.edf iso5.edf iso7.edf iso9.edf iso10.edf iso13.edf	\
-iso15.edf koi8.edf ms-cp1251.edf
+iso15.edf koi8.edf ms-cp1251.edf euc-jp.edf
 
 if EXTENSIONS
 encodings_DATA = encoding.map $(major_encodings) $(minor_encodings)
diff -up a2ps-4.14/encoding/Makefile.in.euc a2ps-4.14/encoding/Makefile.in
--- a2ps-4.14/encoding/Makefile.in.euc	2007-12-29 04:28:07.000000000 +0100
+++ a2ps-4.14/encoding/Makefile.in	2008-04-27 10:39:24.000000000 +0200
@@ -270,7 +270,7 @@ major_encodings = ascii.edf iso1.edf
 minor_encodings = \
 ms-cp1250.edf hp.edf mac.edf ibm-cp437.edf ibm-cp850.edf iso2.edf	\
 iso3.edf iso4.edf iso5.edf iso7.edf iso9.edf iso10.edf iso13.edf	\
-iso15.edf koi8.edf ms-cp1251.edf
+iso15.edf koi8.edf ms-cp1251.edf euc-jp.edf
 
 @EXTENSIONS_FALSE@encodings_DATA = encoding.map $(major_encodings)
 @EXTENSIONS_TRUE@encodings_DATA = encoding.map $(major_encodings) $(minor_encodings)
diff -up a2ps-4.14/lib/encoding.c.euc a2ps-4.14/lib/encoding.c
--- a2ps-4.14/lib/encoding.c.euc	2007-12-29 02:37:54.000000000 +0100
+++ a2ps-4.14/lib/encoding.c	2008-04-27 10:39:24.000000000 +0200
@@ -37,6 +37,9 @@
 #include "document.h"
 #include "quotearg.h"
 #include "strverscmp.h"
+#ifdef ENABLE_KANJI
+int use_jcode = false;
+#endif
 
 /* Suffix of the Encoding Description Files */
 #define EDF_SUFFIX ".edf"
@@ -389,15 +392,25 @@ font_entry_set_used (struct hash_table_s
  * Association of suffixes rules, and corresponding style sheet
  * (The hashing is upon `alias')
  */
+struct slantfont_info {
+  char * name;
+  char * src;
+  float raito;
+};
+
 struct encoding {
   char * key;			/* e.g. latin1			*/
   char * name;			/* e.g. ISO Latin 1		*/
+  int    composite_flag;		/* flag for composite font	*/
   uchar * documentation;		/* Useful pieces of text	*/
 
   char * default_font;		/* When a font can't be used
 				   define the font to use	*/
   struct pair_htable * substitutes;	/* e.g. in latin2, don't use
 					 * Courier, but Courier-Ogonki	*/
+  struct pair_htable * composite;
+
+  struct slantfont_info     slantfont[NB_FACES];
 
   char * vector[256];	/* Define the char set			*/
   struct darray * font_names_used;
@@ -407,6 +420,9 @@ struct encoding {
   struct hash_table_s * fonts;	/* Contains cells that are
 				 * 1. name of font, 2. int wx[256] 	*/
   unsigned int * faces_wx[NB_FACES];
+
+  unsigned int   composite_wx[NB_FACES];     /* fixed length font width*/
+  float          composite_raito[NB_FACES];  /* size raito of additonal and orinal font */
 };
 
 /*
@@ -423,9 +439,12 @@ encoding_new (const char * key)
   res->name = NULL;
   res->default_font = NULL;
   res->documentation = NULL;
+  res->composite_flag = false;
 
   /* Vector will be set by setup */
   res->substitutes = pair_table_new ();
+  res->composite = pair_table_new ();
+  res->slantfont[0].name = NULL;
   res->font_names_used = da_new ("List of font names", 10,
 				 da_linear, 10,
 				 (da_print_func_t) da_str_print,
@@ -471,6 +490,34 @@ encoding_add_font_substitute (struct enc
 }
 
 /*
+ * Add a composite font in the current encoding
+ */
+static void
+encoding_add_composite_font (struct encoding * encoding,
+			      const char * orig, const char * subs,
+			      int wx, float raito)
+{
+  encoding->composite_flag = true;
+  pair_add2 (encoding->composite, orig, subs, wx, raito);
+}
+
+/*
+ * Add a composite font in the current encoding
+ */
+static void
+encoding_add_slant_font (struct encoding * encoding,
+			 const char * new, const char * src,
+			 float raito)
+{
+  static num =  0;
+  encoding->slantfont[num].name = strdup(new);
+  encoding->slantfont[num].src  = strdup(src);
+  encoding->slantfont[num].raito = raito;
+  encoding->slantfont[num+1].name = NULL;
+  num++;
+}
+
+/*
  * When FONT_NAME is used with ENCODING, return the
  * real font name to use (e.g., in latin2, Courier-Ogonki
  * should be returned when asked for Courier).
@@ -514,6 +561,77 @@ encoding_resolve_font_substitute (struct
     }
 
   message (msg_enc,
+	   (stderr, "In encoding %s, composite font for %s is resolved as %s\n",
+	    encoding->key, font_name, res));
+  return res;
+}
+
+/*
+ * Get composite font size and raito
+ */
+static int
+composite_font_info_get_wx(struct a2ps_job * job,
+			   struct encoding * encoding,
+			   const char * font_list)
+{
+  int wx= -1;
+  char * font_list_copy;
+  char * font_name;
+  astrcpy (font_list_copy, font_list);
+  font_name = strtok (font_list_copy, ",<>;");
+
+  wx = pair_get_wx (encoding->composite, font_name);
+  if (wx<0)
+      wx = pair_get_wx (encoding->composite, "default_composite__");
+
+  return wx;
+}
+
+static float
+composite_font_info_get_raito(struct a2ps_job * job,
+			      struct encoding * encoding,
+			      const char * font_list)
+{
+  float raito= -1;
+  char * font_list_copy;
+  char * font_name;
+
+  astrcpy (font_list_copy, font_list);
+  font_name = strtok (font_list_copy, ",<>;");
+
+  raito = pair_get_raito (encoding->composite, font_name);
+  if (raito<0)
+      raito = pair_get_raito (encoding->composite, "default_composite__");
+  return raito;
+}
+
+const char *
+encoding_resolve_composite_font (struct a2ps_job * job,
+				  struct encoding * encoding,
+				  const char * font_list)
+{
+  const char * res = NULL;
+  char * font_list_copy;
+  char * font_name;
+
+  astrcpy (font_list_copy, font_list);
+  font_name = strtok (font_list_copy, ",<>;");
+
+  /* Find if there is a substitute for that font */
+  res = pair_get (encoding->composite, font_name);
+
+  /* We've found nothing interesting.  Last chance is the default
+   * font */
+  if (!res)
+    {
+      res = pair_get (encoding->composite, "default_composite__");
+
+      if (!res)
+	error (1, 0, "Cannot find font %s, nor any composite font",
+	       font_name);
+    }
+  
+  message (msg_enc,
 	   (stderr, "In encoding %s, font %s is resolved as %s\n",
 	    encoding->key, font_name, res));
   return res;
@@ -585,6 +703,12 @@ load_encoding_description_file (a2ps_job
 	{
 	  token2 = GET_TOKEN (NULL);
 	  CHECK_TOKEN ();
+#ifdef ENABLE_KANJI
+	  if( strcmp(token2, "EUC-JP")== 0)
+	    use_jcode = true;
+	  else 
+	    use_jcode = false;
+#endif
 	  encoding->name = xstrdup (token2);
 	}
       else if (strequ (token, "Default:"))
@@ -633,6 +757,66 @@ load_encoding_description_file (a2ps_job
 	  subs = token2;
 	  encoding_add_font_substitute (encoding, orig, subs);
 	}
+      else if (strequ (token, "DefaultComposite:"))
+	{
+	  char * orig, * subs;
+	  int wx;
+	  float raito;
+
+	  token2 = GET_TOKEN (NULL);
+	  CHECK_TOKEN ();
+	  subs = token2;
+	  token2 = GET_TOKEN (NULL);
+	  CHECK_TOKEN ();
+	  wx = (int)atof(token2)*1000;
+	  token2 = GET_TOKEN (NULL);
+	  CHECK_TOKEN ();
+	  raito = atof(token2);
+	  encoding_add_composite_font(encoding, "default_composite__",
+				      subs, wx, raito);
+	}
+      else if (strequ (token, "Composite:"))
+	{
+	  char * orig, * subs;
+	  int wx;
+	  float raito;
+
+	  token2 = GET_TOKEN (NULL);
+	  CHECK_TOKEN ();
+	  orig = token2;
+	  token2 = GET_TOKEN (NULL);
+	  CHECK_TOKEN ();
+	  subs = token2;
+	  token2 = GET_TOKEN (NULL);
+	  CHECK_TOKEN ();
+	  wx = (int)atof(token2)*1000;
+	  token2 = GET_TOKEN (NULL);
+	  CHECK_TOKEN ();
+	  raito = atof(token2);
+	  encoding_add_composite_font(encoding, orig, subs, wx, raito);
+	}
+      else if (strequ (token, "SlantFont:"))
+	{
+	  char * new, * src;
+	  float raito;
+	  unsigned int num;
+
+	  token2 = GET_TOKEN (NULL);
+	  CHECK_TOKEN ();
+	  new = token2;
+	  token2 = GET_TOKEN (NULL);
+	  CHECK_TOKEN ();
+	  src = token2;
+	  token2 = GET_TOKEN (NULL);
+	  CHECK_TOKEN ();
+	  raito = atof(token2);
+	  for (num = 0 ; encoding->slantfont[num].name ; num ++ );
+	  if (num > sizeof encoding->slantfont - 1){
+	      error_at_line (1, 0, fname, firstline,
+			   _("too many slant font: `%s'"), new);
+	  }
+	  encoding_add_slant_font(encoding, new, src, raito);
+	}
       else
         error_at_line (1, 0, fname, firstline,
                        _("invalid option `%s'"), quotearg (token));
@@ -754,6 +938,15 @@ encoding_char_exists (struct encoding * 
 }
 
 /*
+ * Return the flag of composite flag
+ */
+int
+encoding_get_composite_flag (struct encoding * enc)
+{
+  return enc->composite_flag;
+}
+
+/*
  * Prepare the environment (a dictionary) for the support
  * of ENCODING, dump it into STREAM.
  *
@@ -766,9 +959,11 @@ dump_encoding_setup (FILE * stream,
 		     struct encoding * encoding)
 {
   size_t i, nb;
+  size_t ns;
   const char * real_font_name;		/* After subsitution	*/
   char ** font_names = (char **) encoding->font_names_used->content;
 
+
   /* How many fonts are there? */
   da_qsort (encoding->font_names_used);
   da_unique (encoding->font_names_used, (da_map_func_t) free);
@@ -787,15 +982,46 @@ dump_encoding_setup (FILE * stream,
    * in the current ENCODING	*/
   nb = encoding->font_names_used->len;
 
+  /* The number of slant fonts */
+  for (i= 0, ns=0 ; encoding->slantfont[i].name ; i++ )
+      ns++;
+
   /* Create the dictionary and fill it */
   fprintf (stream, "%% Dictionary for %s support\n",
 	  encoding->name);
-  fprintf (stream, "/%sdict %d dict begin\n", encoding->key, nb);
+  fprintf (stream, "/%sdict %d dict begin\n", encoding->key,
+	   (encoding->composite_flag == true)? nb+nb+ns:nb+ns);
   for (i = 0 ; i < nb ; i++)
     fprintf (stream, "  /f%s %sEncoding /%s reencode_font\n",
 	     font_names [i],
 	     encoding->name,
 	     encoding_resolve_font_substitute (job, encoding, font_names [i]));
+
+  /* Slant font setting */
+  for (i = 0 ; encoding->slantfont[i].name ; i++ )
+    fprintf (stream, "  /%s /%s %f slantfont  definefont pop\n",
+	     encoding->slantfont[i].name,
+	     encoding->slantfont[i].src,
+	     encoding->slantfont[i].raito);
+
+  /*
+   * Composite font setting.
+   * If kanji font size is larger than alphabet character, 
+   * set base font size to kanji charactor size.
+   */
+  if (encoding->composite_flag == true) {
+    for (i = 0 ; i < nb ; i++)
+      fprintf (stream, "  /f%s /f%s /%s %f %f false  compositefont "
+	               "%f scalefont def\n",
+	       font_names [i],
+	       font_names [i],
+	       encoding_resolve_composite_font (job, encoding, font_names [i]),
+	       encoding->composite_raito[i],
+	       (encoding->composite_raito[i] > 1.0)?
+	       0: (1-encoding->composite_raito[i])/2.0,
+	       (encoding->composite_raito[i] > 1.0)?
+	       1.0/encoding->composite_raito[i]: 1.0 );
+  }
   fputs ("currentdict end def\n", stream);
 }
 
@@ -939,6 +1165,22 @@ encoding_build_faces_wx (a2ps_job * job,
 				   true_font_name,
 				   encoding->vector,
 				   encoding->faces_wx [face]);
+
+      if (encoding->composite_flag)
+	{
+	  encoding->composite_raito[i] =
+	    composite_font_info_get_raito(job, encoding, 
+					  job->face_eo_font [face]);
+
+	  encoding->composite_wx[i] =
+	    composite_font_info_get_wx(job, encoding, 
+				       job->face_eo_font [face]);
+
+	  /* If kanji font size is larger than alphabet character, 
+	     fit kanji charactor size to base font size */
+	  if (encoding->composite_raito[i] < 1.0)
+	      encoding->composite_wx[i] *= encoding->composite_raito[i]; 
+	}
     }
 }
 
@@ -1073,6 +1315,13 @@ char_WX (a2ps_job * job, uchar c)
   return 0;	/* For -Wall */
 }
 
+unsigned int
+char_composite_WX (a2ps_job * job, uchar c)
+{
+  return (job->encoding->composite_wx[job->status->face]/
+	  job->encoding->composite_raito[job->status->face]);
+}
+
 /*
  *	Returns the WX of a string (including M- and ^)
  */
diff -up a2ps-4.14/lib/encoding.h.euc a2ps-4.14/lib/encoding.h
--- a2ps-4.14/lib/encoding.h.euc	2007-12-29 02:58:17.000000000 +0100
+++ a2ps-4.14/lib/encoding.h	2008-04-27 10:39:24.000000000 +0200
@@ -43,6 +43,7 @@ struct a2ps_job;	/* Declared in jobs.h w
  */
 unsigned int char_WX PARAMS ((struct a2ps_job * job, uchar c));
 unsigned int string_WX PARAMS ((struct a2ps_job * job, uchar * string));
+unsigned int char_composite_WX PARAMS ((struct a2ps_job * job, uchar c));
 
 
 /************************************************************************/
@@ -56,6 +57,7 @@ void encoding_self_print PARAMS ((struct
 					FILE * stream));
 int encoding_char_exists PARAMS ((struct encoding * enc,
 					enum face_e face, uchar c));
+int encoding_get_composite_flag (struct encoding * enc);
 struct encoding *
 get_encoding_by_alias PARAMS ((struct a2ps_job * job, 
 			       char *string));
@@ -71,6 +73,12 @@ const char * encoding_resolve_font_subst
 		 struct encoding * encoding,
 		 const char * font_name));
 
+
+const char * encoding_resolve_composite_font
+	PARAMS ((struct a2ps_job * job,
+		 struct encoding * encoding,
+		 const char * font_name));
+
 /*
  * Have a struct encoding determine the faces_wx
  */
diff -up a2ps-4.14/lib/pair_ht.c.euc a2ps-4.14/lib/pair_ht.c
--- a2ps-4.14/lib/pair_ht.c.euc	2007-12-29 02:58:21.000000000 +0100
+++ a2ps-4.14/lib/pair_ht.c	2008-04-27 10:39:24.000000000 +0200
@@ -49,6 +49,8 @@ struct pair
 {
   char * key;
   char * value;
+  float  raito;
+  int    wx;
 };
 
 /*
@@ -165,6 +167,37 @@ pair_add (struct hash_table_s * table,
 }
 
 /*
+ *  Add a pair, with your own allocation for them.
+ * It KEY is yet used, override its value with VALUE
+ */
+void
+pair_add2 (struct hash_table_s * table,
+	  const char * key, const char * value, int wx, float raito)
+{
+  struct pair * item, token;
+  
+  token.key = (char *) key;
+  item = (struct pair *) hash_find_item (table, &token);
+
+  if (item) {
+    if (item->value)
+      free (item->value);
+  } else {
+    item = XMALLOC (struct pair, 1);
+    item->key = xstrdup(key);
+    item->wx    = wx;
+    item->raito = raito;
+  }
+  
+  if (value)
+    item->value = xstrdup (value);
+  else
+    item->value = NULL;
+
+  hash_insert (table, item);
+}
+
+/*
  * Remove a pair and free it.
  * It KEY is yet used, override its value with VALUE
  */
@@ -201,6 +234,34 @@ pair_get (struct hash_table_s * table, c
     return NULL;
 }
 
+int
+pair_get_wx (struct hash_table_s * table, const char * key)
+{
+  struct pair * item, token;
+  
+  token.key = (char *) key;
+  item = (struct pair *) hash_find_item (table, &token);
+
+  if (item)
+    return item->wx;
+  else
+    return -1;
+}
+
+float
+pair_get_raito (struct hash_table_s * table, const char * key)
+{
+  struct pair * item, token;
+  
+  token.key = (char *) key;
+  item = (struct pair *) hash_find_item (table, &token);
+
+  if (item)
+    return item->raito;
+  else
+    return -1;
+}
+
 /*
  * Return the content of the hash table, ordered
  */
diff -up a2ps-4.14/lib/pair_ht.h.euc a2ps-4.14/lib/pair_ht.h
--- a2ps-4.14/lib/pair_ht.h.euc	2007-12-29 02:58:21.000000000 +0100
+++ a2ps-4.14/lib/pair_ht.h	2008-04-27 10:39:24.000000000 +0200
@@ -56,6 +56,10 @@ void pair_table_free PARAMS ((struct pai
 void pair_add PARAMS ((struct pair_htable * table, 
 		       const char * key, const char * value));
 
+void pair_add2 PARAMS ((struct pair_htable * table, 
+		       const char * key, const char * value,
+			int wx, float raito));
+
 /*
  * The key and value of the matching item  will be free'd
  * (No problem if KEY matches nothing)
@@ -68,6 +72,10 @@ void pair_delete PARAMS ((struct pair_ht
  */
 char * pair_get PARAMS ((struct pair_htable * table,
 			 const char * key));
+int    pair_get_wx PARAMS ((struct pair_htable * table,
+			    const char * key));
+float  pair_get_raito PARAMS ((struct pair_htable * table,
+			       const char * key));
 
 void pair_table_list_short PARAMS ((struct pair_htable * table,
 				    FILE * stream));
diff -up a2ps-4.14/lib/psgen.c.euc a2ps-4.14/lib/psgen.c
--- a2ps-4.14/lib/psgen.c.euc	2007-12-29 02:58:22.000000000 +0100
+++ a2ps-4.14/lib/psgen.c	2008-04-27 10:39:24.000000000 +0200
@@ -875,6 +875,7 @@ ps_print_char (a2ps_job * job, int c, en
   print:
   default:
     {
+      static mb_flag= 0;
       uchar buf[256];
       int nchars;
       *buf = '\0';
@@ -889,6 +890,29 @@ ps_print_char (a2ps_job * job, int c, en
     job->status->face_declared = false;
   }
 
+  if (c > 127 && encoding_get_composite_flag (job->encoding) &&
+      job->status->face != Symbol) {
+    if (mb_flag) {
+        nchars = ps_escape_char (job, mb_flag, buf) + 
+	         ps_escape_char (job, c, buf);
+	job->status->wx += char_composite_WX(job, c);
+	job->status->column += nchars;
+	if (line_full) {
+	    if (job->folding) {
+	        fold_line (job, new_face);
+		job->status->column = nchars*2;
+		job->status->wx = char_composite_WX(job, c);
+	    } else {
+	      job->status->is_in_cut = true;
+	      return;
+	    }
+	}
+	mb_flag = 0;
+    } else {
+        mb_flag = c;
+	return;
+    }
+  } else {
       nchars = ps_escape_char (job, c, buf);
       job->status->wx += char_WX (job, c);
       job->status->column += nchars;
@@ -902,8 +926,9 @@ ps_print_char (a2ps_job * job, int c, en
 	  return;
 	}
       }
+  }
       output (jdiv, "%s", buf);
-      job->status->chars++;
+      job->status->chars+=nchars;
     }
     break;
   }
diff -up a2ps-4.14/ps/base.ps.euc a2ps-4.14/ps/base.ps
--- a2ps-4.14/ps/base.ps.euc	2007-12-29 02:58:26.000000000 +0100
+++ a2ps-4.14/ps/base.ps	2008-04-27 10:39:24.000000000 +0200
@@ -153,7 +153,11 @@
 % Return the y size of the current font
 % - => fontsize
 /currentfontsize {
-  currentfont /FontMatrix get 3 get 1000 mul
+  currentfont /FontType get 0 eq {
+    currentfont /FontMatrix get 3 get
+  }{
+    currentfont /FontMatrix get 3 get 1000 mul
+  } ifelse
 } bind def
 
 % reencode the font
@@ -200,6 +204,144 @@
   end 
 } bind def
 
+% composite fonts for ASCII-EUC mixed string
+% Version 1.2 1/31/1990
+% Orignal Ken'ichi HANDA (handa@etl.go.jp)
+% Modified Norio Katayama (katayama@rd.nacsis.ac.jp),1998
+% Extend & Fix Koji Nakamaru (maru@on.cs.keio.ac.jp), 1999
+% Anyone can freely copy, modify, distribute this program.
+
+/copyfont {	% font-dic extra-entry-count  copyfont  font-dic
+	1 index maxlength add dict begin
+	{	1 index /FID ne 2 index /UniqueID ne and
+		{def} {pop pop} ifelse
+	} forall
+	currentdict
+	end
+} bind def
+
+/compositefont { % ASCIIFontName EUCFontName RomanScale RomanOffset Rot(T/F) compositefont font
+    /RomanRotation exch def
+    /RomanOffset exch def
+    /RomanScale exch def
+    userdict /fixeucfont_dict known not {
+	userdict begin
+	    /fixeucfont_dict 2 dict begin
+		/UpperByteEncoding [
+		    16#00 1 16#20 { pop 0 } for
+		    16#21 1 16#28 { 16#20 sub } for
+		    16#29 1 16#2F { pop 0 } for
+		    16#30 1 16#74 { 16#27 sub } for
+		    16#75 1 16#FF { pop 0 } for
+		] def
+	        /LowerByteEncoding [
+		    16#00 1 16#A0 { pop /.notdef } for
+		    16#A1 1 16#FE { 16#80 sub 16 2 string cvrs
+				    (cXX) dup 1 4 -1 roll
+				    putinterval cvn } for
+		    /.notdef
+		] def
+		currentdict
+	    end def
+	end
+    } if
+    findfont dup /FontType get 0 eq {
+	14 dict begin
+	    %
+	    % 7+8 bit EUC font
+	    %
+	    12 dict begin
+		/EUCFont exch def
+		/FontInfo (7+8 bit EUC font) readonly def
+		/PaintType 0 def
+		/FontType 0 def
+		/FontMatrix matrix def
+		% /FontName
+		/Encoding fixeucfont_dict /UpperByteEncoding get def
+		/FMapType 2 def
+		EUCFont /WMode known
+		{ EUCFont /WMode get /WMode exch def }
+		{ /WMode 0 def } ifelse
+		/FDepVector [
+		    EUCFont /FDepVector get 0 get
+		    [ 16#21 1 16#28 {} for 16#30 1 16#74 {} for ]
+		    {
+			13 dict begin
+			    /EUCFont EUCFont def
+			    /UpperByte exch 16#80 add def	
+			    % /FontName
+			    /FontInfo (EUC lower byte font) readonly def
+			    /PaintType 0 def
+			    /FontType 3 def
+			    /FontMatrix matrix def
+			    /FontBBox {0 0 0 0} def
+			    /Encoding
+				fixeucfont_dict /LowerByteEncoding get def
+			    % /UniqueID
+			    % /WMode
+			    /BuildChar {
+				gsave
+				exch dup /EUCFont get setfont
+				/UpperByte get
+				2 string
+				dup 0 4 -1 roll put
+				dup 1 4 -1 roll put
+				dup stringwidth setcharwidth
+				0 0 moveto show
+				grestore
+			    } bind def
+			    currentdict
+			end
+			/lowerbytefont exch definefont
+		    } forall
+		] def
+		currentdict
+	    end
+	    /eucfont exch definefont
+	    exch
+	    findfont 1 copyfont dup begin
+		RomanRotation {
+			/FontMatrix FontMatrix
+			[ 0 RomanScale neg RomanScale 0 RomanOffset neg 0 ]
+			matrix concatmatrix def
+		}{
+			/FontMatrix FontMatrix
+			[ RomanScale 0 0 RomanScale 0 RomanOffset ] matrix concatmatrix
+			def
+			/CDevProc
+			    {pop pop pop pop 0 exch -1000 exch 2 div 880} def
+		} ifelse
+	    end
+	    /asciifont exch definefont
+	    exch
+	    /FDepVector [ 4 2 roll ] def
+	    /FontType 0 def
+	    /WMode 0 def
+	    /FMapType 4 def
+	    /FontMatrix matrix def
+	    /Encoding [0 1] def
+	    /FontBBox {0 0 0 0} def
+%	    /FontHeight 1.0 def % XXXX
+	    /FontHeight RomanScale 1.0 ge { RomanScale }{ 1.0 } ifelse def
+	    /Descent -0.3 def   % XXXX
+	    currentdict
+	end
+	/tmpfont exch definefont
+	pop
+	/tmpfont findfont
+    }{
+	pop findfont 0 copyfont
+    } ifelse
+} def	
+
+/slantfont {	% FontName slant-degree  slantfont  font'
+    exch findfont 1 copyfont begin
+    [ 1 0 4 -1 roll 1 0 0 ] FontMatrix exch matrix concatmatrix
+    /FontMatrix exch def
+    currentdict
+    end
+} def
+
 % Function print line number (<string> # -)
 /# {
   gsave
diff -up /dev/null a2ps-4.14/README.eucJP
--- /dev/null	2008-04-27 11:55:27.307012118 +0200
+++ a2ps-4.14/README.eucJP	2008-04-27 10:39:24.000000000 +0200
@@ -0,0 +1,100 @@
+a2ps euc-jp kanji supported patch:
+by SATO Satoru <ss@gnome.gr.jp>
+
+These patches enables a2ps to support the files written in EUC-JP (and other
+Japanese encodings). I only arranged patches created by FURUKAWA Yasuyuki,
+KATAYAMA Yukio, and replaced libjcode by customized jcode.[ch] (by KITAME
+Takuo).
+
+Notes from the orginal patch by FURUKAWA Yukihiro is follows.
+(sorry, it is written in japanese only):
+
+a2ps 4.12で漢字を印刷するためのパッチ
+				慶應大学大学院
+				古川 泰之 <yasu@on.cs.keio.ac.jp>
+
+composite font を使って漢字を表示するためのパッチです。
+composite fontには、片山 紀夫さん(はじめて日本語ghostscriptを作成した
+人)のfixeucfont をベースにa2ps用に多少手をいれております。これを利用す
+ることで、2バイトEUC＋ASCIIの文字列のPostscriptの扱いがぐっと簡単にな
+ります。
+
+●Compositeフォントの設定方法について
+最低限の設定はパッチに含まれていますので、とりあえず大丈夫だとは思いま
+す。一応メモしておきます。
+
+encodingファイル($prefix/share/a2ps/encoding/の下のファイル)には
+『Composite:』および、『DefaultComposite:』が新たに指定できます。たと
+えば、英語フォントに対応するEUCエンコーディングの日本語フォントを書い
+て行きます。また、この際、フォント幅と半角と漢字の比も指定しなくてはな
+りません。手抜きによって、漢字は固定幅フォントしか指定してはいけません。
+
+--------------------------------------------------
+#	                  日本語フォント          フォン横幅	半角と漢字の比
+DefaultComposite:         Ryumin-Light-EUC-H      1             1.1	
+#	    英語フォント  日本語フォント	  フォン横幅	半角と漢字の比
+Composite:  Helvetica     GothicBBB-Medium-EUC-H  1		1.1
+--------------------------------------------------
+
+また、これだと斜体漢字がなく、さみしいので、SlantFontを使い、斜体の漢
+字フォントも作成できます。
+
+--------------------------------------------------
+#               新規斜体日本語フォント名	ソース日本語フォント	傾き度
+SlantFont:	Ryumin-Light-EUC-H-Italic	Ryumin-Light-EUC-H	0.2
+--------------------------------------------------
+
+SlantFontで生成した斜体フォントはCompositeフォント(第2引数)で利用でき
+ます。
+
+●このパッチの詳細データ
+  ・残念ながら2バイトEUCコードを前提としたコーディングをしています。
+    そのため、あまり漢字以外の言語を考えておりません…。
+  ・倉光 君郎氏のlibjcodeを使って内部で入力ファイルの漢字エンコーディ
+    ングをすべてEUCに変換して処理するようにしています。ただし、オリジ
+    ナルのlibjcodeは、SJISおよびEUCの判定が甘かったので多少カスタムし
+    ております。
+  ・また、texのdelegate(contrib/texi2dvi4a2ps)中、TeXドライバにはpTeX
+    と決めうちしています。これがいやなら、例えばNTT-jTeXを使用したい場
+    合、環境変数TEXに『jtex』を、LATEXには『jlatex』を指定してください。
+  ・compositefontをa2ps用に多少カスタマイズしていますが、フォントの高
+    さなどの情報を完全に固定で決め打ちしている箇所があります(XXXでメモ
+    しています)。そのためあまり応用性が低いと思います。
+
+●半角を全角の1/2の大きさにしたい
+パッチデフォルトでは全角文字と半角文字の大きさのバランスは、見た感じが
+(個人的なセンスで)安定するようにチューニングしています。もし、テキスト
+で表を作成していて、そのため、半角文字を全角のちょうど半分にそろえたい
+という場合の対処方法を書いておきます。
+
+インストール後、$prefix/share/a2ps/encoding/euc-jp中に、
+
+--------------------------------------------------
+DefaultComposite:         Ryumin-Light-EUC-H      1.0  1.1
+--------------------------------------------------
+
+というのがあると思います。最後の『1.1』を『0.8342』あたりに変更して下
+さい。ノーマル固定文字に関してはこれで望みの結果が得られると思います。
+
+他の太字フォントなども、例えば
+
+--------------------------------------------------
+Composite: Courier-Bold   GothicBBB-Medium-EUC-H  1.0  0.8342
+--------------------------------------------------
+
+のように変更すればいいと思います。なお、Courierがつかないフォント
+(Helvetica等)はもともとプロポーショナルフォントなので、固定幅にはでき
+ません。
+
+
+
+●再配布について
+なんだかんだいって、このパッチは、
+
+倉光 君郎さんのlibjcode  ＋  片山 紀夫さんのfixeucfont 
+
+を組み合わてできたもので私自身のコードは実はほとんどありません…。
+
+私自身のコードは再配付／改造に関してなんら制限を設けるつもりはありませ
+ん。ただし、私以外のコードの方が多いため、一応それだけは御了承お願い致
+します。
diff -up a2ps-4.14/src/buffer.c.euc a2ps-4.14/src/buffer.c
--- a2ps-4.14/src/buffer.c.euc	2007-12-29 02:58:34.000000000 +0100
+++ a2ps-4.14/src/buffer.c	2008-04-27 10:39:24.000000000 +0200
@@ -41,6 +41,21 @@
 #include "argmatch.h"
 #include "buffer.h"
 #include <assert.h>
+
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+
+#ifdef ENABLE_KANJI
+#  include <stdio.h>
+#  include <stdlib.h>
+#  include <string.h>
+#  include <locale.h>
+#  include <errno.h>
+#  include <iconv.h>
+extern use_jcode;
+#endif
+
 
 /****************************************************************/
 /*		 	Handling of the various eol styles	*/
@@ -526,3 +541,278 @@ buffer_test (const char *filename)
   buffer_release (&buffer);
 }
 #endif
+
+/**
+ * from jcode.c by Takuo KITAME <kitame@northeye.org>
+ */
+#ifdef ENABLE_KANJI
+
+enum {
+    JCODE_ASCII,
+    JCODE_EUC,
+    JCODE_JIS,
+    JCODE_SJIS,
+    EUCORSJIS };
+
+#define ESC          0x1b
+#define SS2          0x8e
+
+#define JCODE_LOCALE_EUC   "ja", "ja_JP", "ja_JP.ujis", "ja_JP.EUC", "ja_JP.eucJP"
+#define JCODE_LOCALE_JIS   "ja_JP.JIS", "ja_JP.jis", "ja_JP.iso-2022-jp"
+#define JCODE_LOCALE_SJIS  "ja_JP.SJIS", "ja_JP.sjis"
+
+/****************************************************************************/
+/* Japanese string code detector */
+/****************************************************************************/
+int 
+detect_kanji(unsigned char *str)
+{
+    int expected = JCODE_ASCII;
+    register int c;
+    int c1, c2;
+    int euc_c = 0, sjis_c = 0;
+    unsigned char *ptr = str;
+    
+    while((c = (int)*ptr)!= '\0') {
+        if(c == ESC) {
+            if((c = (int)*(++ptr)) == '\0')
+                break;
+            if(c == '$') {
+                if((c = (int)*(++ptr)) == '\0')
+                    break;
+                if(c == 'B' || c == '@')
+                    return JCODE_JIS;
+            }
+            ptr++;
+            continue;
+        }
+        if((c >= 0x81 && c <= 0x8d) || (c >= 0x8f && c <= 0x9f))
+            return JCODE_SJIS;
+        
+        if(c == SS2) {
+            if((c = (int)*(++ptr)) == '\0')
+                break;
+            if((c >= 0x40 && c <= 0x7e) ||
+               (c >= 0x80 && c <= 0xa0) || 
+               (c >= 0xe0 && c <= 0xfc))
+                return JCODE_SJIS;
+            if(c >= 0xa1 && c <= 0xdf)
+                break;
+            
+            ptr++;
+            continue;
+        }        
+        if(c >= 0xa1 && c <= 0xdf) {
+            if((c = (int)*(++ptr)) == '\0')
+                break;
+            
+            if (c >= 0xe0 && c <= 0xfe)
+                return JCODE_EUC;
+            if (c >= 0xa1 && c <= 0xdf) {
+                expected = EUCORSJIS;
+                ptr++;
+                continue;
+            }
+#if 1
+            if(c == 0xa0 || (0xe0 <= c && c <= 0xfe))
+                return JCODE_EUC;
+            else {
+                expected = EUCORSJIS;
+                ptr++;
+                continue;
+            }
+#else
+            if(c <= 0x9f)
+                return JCODE_SJIS;
+            if(c >= 0xf0 && c <= 0xfe)
+                return JCODE_EUC;
+#endif
+            
+            if(c >= 0xe0 && c <= 0xef) {
+                expected = EUCORSJIS;
+                while(c >= 0x40) {
+                    if(c >= 0x81) {
+                        if(c <= 0x8d || (c >= 0x8f && c <= 0x9f))
+                            return JCODE_SJIS;
+                        else if(c >= 0xfd && c <= 0xfe) {
+                            return JCODE_EUC;
+                        }
+                    }
+                    if((c = (int)*(++ptr)) == '\0')
+                        break;
+                }
+                ptr++;
+                continue;
+            }
+            
+            if(c >= 0xe0 && c <= 0xef) {
+                if((c = (int)*(++ptr)) == '\0')
+                    break;
+                if((c >= 0x40 && c <= 0x7e) || (c >= 0x80 && c <= 0xa0))
+                    return JCODE_SJIS;
+                if(c >= 0xfd && c <= 0xfe)
+                    return JCODE_EUC;
+                if(c >= 0xa1 && c <= 0xfc)
+                    expected = EUCORSJIS;
+            }
+        }
+#if 1
+        if (0xf0 <= c && c <= 0xfe)
+            return JCODE_EUC;
+#endif
+        ptr++;
+    }
+
+   ptr = str;
+   c2 = 0;
+   while((c1 = (int)*ptr++) != '\0') {
+       if(((c2 >  0x80 && c2 < 0xa0) || (c2 >= 0xe0 && c2 < 0xfd)) &&
+          ((c1 >= 0x40 && c1 < 0x7f) || (c1 >= 0x80 && c1 < 0xfd)))
+           sjis_c++, c1 = *ptr++;
+       c2 = c1;
+   }
+   if(sjis_c == 0)
+       expected = JCODE_EUC;
+   else {
+       ptr = str, c2 = 0;
+       while((c1 = (int)*ptr++) != '\0') {
+	     if((c2 > 0xa0  && c2 < 0xff) &&
+            (c1 > 0xa0  && c1 < 0xff))
+             euc_c++, c1 = *ptr++;
+	     c2 = c1;
+       }
+       if(sjis_c > euc_c)
+           expected = JCODE_SJIS;
+       else
+           expected = JCODE_EUC;
+   }
+   return expected;
+}
+
+int
+int_detect_JCode(char *str)
+{
+    int detected;
+
+    if(!str)
+        return 0;
+
+    detected = detect_kanji((unsigned char *)str);
+    
+    if(detected == JCODE_ASCII)
+        return JCODE_ASCII;
+    
+    switch(detected) {
+    case JCODE_EUC:
+        return JCODE_EUC;
+        break;
+    case JCODE_JIS:
+        return JCODE_JIS;
+        break;
+    case JCODE_SJIS:  
+        return JCODE_SJIS;
+        break;
+    default:
+        return JCODE_ASCII;
+        break;
+    }
+    
+    /* not reached */
+    return 0;
+}
+
+const char *
+detect_JCode(char *str)
+{
+    int detected;
+
+    if(!str)
+        return NULL;
+
+    detected = detect_kanji((unsigned char *)str);
+    
+    if(detected == JCODE_ASCII)
+        return "ASCII";
+
+    switch(detected) {
+    case JCODE_EUC:
+        return "EUC-JP";
+        break;
+    case JCODE_JIS:
+        return "ISO-2022-JP";
+        break;
+    case JCODE_SJIS:  
+        return "SJIS";
+        break;
+    default:
+        return "ASCII";
+        break;
+    }
+    
+    /* not reached */
+    return 0;
+}
+
+char *
+kanji_conv_auto(char *str, const char *dstset)
+{
+    unsigned char *buf, *ret;
+    iconv_t cd;
+    size_t insize = 0;
+    size_t outsize = 0;
+    size_t nconv = 0;
+    char *inptr;
+    char *outptr;
+    char srcset[16];
+    
+    if(!str)
+        return NULL;
+    
+    switch (int_detect_JCode(str)) {
+    case JCODE_EUC:
+        strcpy(srcset, "EUC-JP");
+        break;
+    case JCODE_JIS:
+        strcpy(srcset, "ISO-2022-JP");
+        break;
+    case JCODE_SJIS:
+        strcpy(srcset, "SJIS");
+        break;
+    default:
+        return strdup(str);
+        break;
+    }
+    
+    buf = (unsigned char *)malloc(strlen(str)* 4 + 1);
+    if(!buf)
+        return NULL;
+    
+    insize = strlen(str);
+    inptr = str;
+    outsize = strlen(str) * 4 ;
+    outptr = buf;
+    
+    cd = iconv_open(dstset, srcset);
+    if(cd == (iconv_t) -1) {
+        if(errno == EINVAL)
+            return strdup(str);
+    }
+    
+    nconv = iconv(cd, (const char **)&inptr, &insize, &outptr, &outsize);
+    if(nconv == (size_t) -1) {
+        if (errno == EINVAL)
+            memmove (buf, inptr, insize);
+    } else
+        iconv(cd, NULL, NULL, &outptr, &outsize);
+    
+    *outptr = '\0';
+    iconv_close(cd);
+    
+    ret = strdup(buf);
+    free(buf);
+    
+    return ret;
+}
+
+#endif
+
diff -up a2ps-4.14/src/buffer.h.euc a2ps-4.14/src/buffer.h
--- a2ps-4.14/src/buffer.h.euc	2007-12-29 02:58:35.000000000 +0100
+++ a2ps-4.14/src/buffer.h	2008-04-27 10:39:24.000000000 +0200
@@ -104,4 +104,15 @@ void buffer_sample_get PARAMS ((buffer_t
 void buffer_save PARAMS ((buffer_t * buffer, const char * filename));
 
 #define buffer_is_empty(Buf) (Buf->curr >= Buf->len)
+
+
+/**
+ * from jcode.h by Takuo KITAME
+ */
+
+char *kanji_conv_auto(char *str, const char *dstset);
+
+const char *detect_JCode(char *str);
+int int_detect_JCode(char *str);
+
 #endif
diff -up a2ps-4.14/src/Makefile.am.euc a2ps-4.14/src/Makefile.am
--- a2ps-4.14/src/Makefile.am.euc	2007-12-29 02:36:09.000000000 +0100
+++ a2ps-4.14/src/Makefile.am	2008-04-27 10:39:24.000000000 +0200
@@ -33,13 +33,13 @@ DEFS = @DEFS@ -DLOCALEDIR=\"$(datadir)/l
 a2ps_SOURCES = main.c \
 read.c sshread.c ssheet.c select.c generate.c 			\
 delegate.c regex.c buffer.c versions.c ffaces.c			\
-version-etc.c long-options.c					\
+version-etc.c long-options.c jcode.c				\
 parsessh.y lexssh.l lexps.l sheets-map.l
 
 noinst_HEADERS = main.h \
 read.h sshread.h ssheet.h select.h generate.h			\
 delegate.h regex.h buffer.h versions.h ffaces.h			\
-version-etc.h long-options.h					\
+version-etc.h long-options.h jcode.h				\
 yy2ssh.h lexps.h
 
 BUILT_SOURCES = parsessh.c parsessh.h
