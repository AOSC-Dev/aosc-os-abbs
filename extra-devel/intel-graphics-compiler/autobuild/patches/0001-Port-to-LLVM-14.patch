From e5bb1bedf0e3199b5a72bb69b35df1803562402e Mon Sep 17 00:00:00 2001
From: liushuyu <liushuyu011@gmail.com>
Date: Wed, 27 Apr 2022 17:59:09 -0600
Subject: [PATCH 1/2] Port to LLVM 14

---
 .gitignore                                    |  3 +++
 IGC/AdaptorCommon/AddImplicitArgs.cpp         |  2 +-
 .../LegalizeFunctionSignatures.cpp            |  4 ++--
 IGC/Compiler/CISACodeGen/CheckInstrTypes.cpp  |  2 +-
 IGC/Compiler/CISACodeGen/DebugInfo.cpp        |  2 +-
 IGC/Compiler/CISACodeGen/EmitVISAPass.cpp     | 24 +++++++++----------
 IGC/Compiler/CISACodeGen/EmitVISAPass.hpp     |  2 +-
 IGC/Compiler/CISACodeGen/Emu64OpsPass.cpp     |  4 ++--
 IGC/Compiler/CISACodeGen/HalfPromotion.cpp    |  4 ++--
 .../CISACodeGen/OpenCLKernelCodeGen.cpp       |  2 +-
 IGC/Compiler/CISACodeGen/PatternMatchPass.hpp |  3 ++-
 .../CISACodeGen/PixelShaderLowering.cpp       |  2 +-
 IGC/Compiler/CISACodeGen/ResolveGAS.cpp       |  4 ++--
 IGC/Compiler/CISACodeGen/SLMConstProp.cpp     |  2 +-
 IGC/Compiler/CISACodeGen/VectorProcess.cpp    |  2 +-
 IGC/Compiler/CISACodeGen/WIAnalysis.cpp       |  2 +-
 IGC/Compiler/CISACodeGen/helper.cpp           |  2 +-
 IGC/Compiler/CustomSafeOptPass.cpp            |  2 +-
 IGC/Compiler/LowPrecisionOptPass.cpp          |  4 +++-
 IGC/Compiler/Optimizer/BuiltInFuncImport.cpp  |  6 ++---
 .../IGCInstCombiner/4.0/InstCombineCalls.cpp  | 10 ++++----
 .../IGCInstCombiner/7.0/InstCombineCalls.cpp  | 10 ++++----
 .../7.0/InstCombineSimplifyDemanded.cpp       |  2 +-
 .../IGCInstructionCombining.hpp               |  5 ++++
 .../Optimizer/IndirectCallOptimization.cpp    |  2 +-
 IGC/Compiler/Optimizer/OCLBIUtils.cpp         | 14 +++++------
 .../Atomics/ResolveOCLAtomics.cpp             |  2 +-
 .../DeviceEnqueueFuncs/DeviceEnqueue.cpp      |  4 ++--
 .../DeviceEnqueueFuncs/TransformBlocks.cpp    |  6 ++---
 .../ExtensionFuncResolution.cpp               |  4 ++--
 .../GenericAddressDynamicResolution.cpp       |  2 +-
 .../ImageFuncs/ImageFuncsAnalysis.cpp         |  2 +-
 .../ResolveSampledImageBuiltins.cpp           |  4 ++--
 .../OpenCLPrintf/OpenCLPrintfResolution.cpp   |  2 +-
 .../ResolveOCLRaytracingBuiltins.cpp          |  4 ++--
 .../ReplaceUnsupportedIntrinsics.cpp          |  2 +-
 .../TransformUnmaskedFunctionsPass.cpp        |  2 +-
 .../Optimizer/PreCompiledFuncImport.cpp       |  4 ++--
 IGC/Compiler/Optimizer/Scalarizer.cpp         |  4 ++--
 IGC/Compiler/PromoteResourceToDirectAS.cpp    |  2 +-
 IGC/GenISAIntrinsics/GenIntrinsicInst.h       | 11 +++++----
 .../include/vc/GenXCodeGen/TargetMachine.h    |  2 +-
 IGC/VectorCompiler/lib/Driver/Driver.cpp      |  2 +-
 .../lib/GenXCodeGen/GenXArgIndirection.cpp    | 12 +++++-----
 .../lib/GenXCodeGen/GenXBaling.cpp            |  6 ++---
 .../lib/GenXCodeGen/GenXCisaBuilder.cpp       |  6 ++---
 .../lib/GenXCodeGen/GenXConstants.cpp         |  6 ++---
 .../lib/GenXCodeGen/GenXIntrinsics.cpp        |  4 ++--
 .../lib/GenXCodeGen/GenXLegalization.cpp      |  6 ++---
 .../lib/GenXCodeGen/GenXLowering.cpp          | 10 ++++----
 .../lib/GenXCodeGen/GenXNumbering.cpp         |  4 ++--
 .../lib/GenXCodeGen/GenXPatternMatch.cpp      |  4 ++--
 .../lib/GenXCodeGen/GenXSimdCFConformance.cpp | 20 ++++++++--------
 .../lib/GenXCodeGen/GenXTargetMachine.cpp     |  2 +-
 .../GenXCodeGen/GenXThreadPrivateMemory.cpp   |  2 +-
 .../lib/GenXCodeGen/GenXUtil.cpp              |  4 ++--
 .../GenXCodeGen/TargetInfo/GenXTargetInfo.cpp |  2 +-
 .../CMAnalysis/ConstantFoldingGenX.cpp        |  3 ++-
 .../CMAnalysis/InstructionSimplifyGenX.cpp    |  4 ++--
 .../lib/GenXOpts/CMTrans/CMABI.cpp            |  4 ++--
 .../lib/GenXOpts/CMTrans/GenXImportOCLBiF.cpp |  4 ++--
 .../GenXOpts/CMTrans/GenXPrintfResolution.cpp |  4 ++--
 IGC/VectorCompiler/lib/Utils/GenX/Region.cpp  |  6 ++---
 .../lib/Utils/GenX/TransformArgCopy.cpp       |  2 +-
 .../include/llvmWrapper/IR/Instructions.h     |  9 +++++++
 .../include/llvmWrapper/MC/MCContext.h        |  2 +-
 .../llvmWrapper/Support/TargetRegistry.h      | 20 ++++++++++++++++
 .../include/llvmWrapper/Transforms/Scalar.h   |  2 +-
 IGC/common/IGCIRBuilder.h                     |  3 ++-
 69 files changed, 187 insertions(+), 144 deletions(-)
 create mode 100644 .gitignore
 create mode 100644 IGC/WrapperLLVM/include/llvmWrapper/Support/TargetRegistry.h

diff --git a/.gitignore b/.gitignore
new file mode 100644
index 000000000..9479979c5
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,3 @@
+/build
+compile_commands.json
+/.cache
\ No newline at end of file
diff --git a/IGC/AdaptorCommon/AddImplicitArgs.cpp b/IGC/AdaptorCommon/AddImplicitArgs.cpp
index 3c4668a74..3e4959ae4 100644
--- a/IGC/AdaptorCommon/AddImplicitArgs.cpp
+++ b/IGC/AdaptorCommon/AddImplicitArgs.cpp
@@ -374,7 +374,7 @@ void AddImplicitArgs::replaceAllUsesWithNewOCLBuiltinFunction(llvm::Function* ol
 
         std::vector<Value*> new_args;
         Function *parent_func = cInst->getParent()->getParent();
-        size_t numArgOperands = cInst->getNumArgOperands();
+        size_t numArgOperands = IGCLLVM::getNumArgOperands(cInst);
 
         // let's prepare argument list on new call function
         llvm::Function::arg_iterator new_arg_iter = new_func->arg_begin();
diff --git a/IGC/AdaptorCommon/LegalizeFunctionSignatures.cpp b/IGC/AdaptorCommon/LegalizeFunctionSignatures.cpp
index a48eee3de..dd36da462 100644
--- a/IGC/AdaptorCommon/LegalizeFunctionSignatures.cpp
+++ b/IGC/AdaptorCommon/LegalizeFunctionSignatures.cpp
@@ -513,7 +513,7 @@ void LegalizeFunctionSignatures::FixCallInstruction(Module& M, CallInst* callIns
         legalizeReturnType = true;
     }
     else if (callInst->getType()->isVoidTy() &&
-        callInst->getNumArgOperands() > 0 &&
+        IGCLLVM::getNumArgOperands(callInst) > 0 &&
         callInst->paramHasAttr(0, llvm::Attribute::StructRet) &&
         isPromotableStructType(M, callInst->getArgOperand(0)->getType(), isStackCall, true /* retval */))
     {
@@ -522,7 +522,7 @@ void LegalizeFunctionSignatures::FixCallInstruction(Module& M, CallInst* callIns
     }
 
     // Check call operands if it needs to be replaced
-    for (; opNum < callInst->getNumArgOperands(); opNum++)
+    for (; opNum < IGCLLVM::getNumArgOperands(callInst); opNum++)
     {
         Value* arg = callInst->getArgOperand(opNum);
         if (!isLegalIntVectorType(M, arg->getType()))
diff --git a/IGC/Compiler/CISACodeGen/CheckInstrTypes.cpp b/IGC/Compiler/CISACodeGen/CheckInstrTypes.cpp
index 3c3d1d87a..cef8a64cc 100644
--- a/IGC/Compiler/CISACodeGen/CheckInstrTypes.cpp
+++ b/IGC/Compiler/CISACodeGen/CheckInstrTypes.cpp
@@ -186,7 +186,7 @@ void CheckInstrTypes::visitCallInst(CallInst& C)
         if (C.isInlineAsm())
         {
             g_InstrTypes->hasInlineAsm = true;
-            for (unsigned i = 0; i < C.getNumArgOperands(); i++)
+            for (unsigned i = 0; i < IGCLLVM::getNumArgOperands(&C); i++)
             {
                 Type* opndTy = C.getArgOperand(i)->getType();
                 if (opndTy->isPointerTy() &&
diff --git a/IGC/Compiler/CISACodeGen/DebugInfo.cpp b/IGC/Compiler/CISACodeGen/DebugInfo.cpp
index de75a3e5c..457b21cb9 100644
--- a/IGC/Compiler/CISACodeGen/DebugInfo.cpp
+++ b/IGC/Compiler/CISACodeGen/DebugInfo.cpp
@@ -346,7 +346,7 @@ void DebugInfoData::extractAddressClass(llvm::Function& F, CShader* pShader, IDe
                             DIExpression* newDIExpr = di.createExpression(Exprs);
                             Value* newMD = MetadataAsValue::get(F.getContext(), newDIExpr);
 
-                            CI->setArgOperand(CI->getNumArgOperands() - 1, newMD);
+                            CI->setArgOperand(IGCLLVM::getNumArgOperands(CI) - 1, newMD);
                         }
                     }
                 }
diff --git a/IGC/Compiler/CISACodeGen/EmitVISAPass.cpp b/IGC/Compiler/CISACodeGen/EmitVISAPass.cpp
index d32819c42..205fa9e01 100644
--- a/IGC/Compiler/CISACodeGen/EmitVISAPass.cpp
+++ b/IGC/Compiler/CISACodeGen/EmitVISAPass.cpp
@@ -3457,13 +3457,13 @@ void EmitPass::emitSetMessagePhaseType(GenIntrinsicInst* inst, VISA_Type type) {
 
 void EmitPass::emitSetMessagePhaseX_legacy(GenIntrinsicInst* inst)
 {
-    Type* pTy = inst->getArgOperand(inst->getNumArgOperands() - 1)->getType();
+    Type* pTy = inst->getArgOperand(IGCLLVM::getNumArgOperands(inst) - 1)->getType();
     unsigned size = pTy->getScalarSizeInBits() / 8;
     emitSetMessagePhaseType_legacy(inst, GetTypeFromSize(size));
 }
 
 void EmitPass::emitSetMessagePhaseX(GenIntrinsicInst* inst) {
-    Type* pTy = inst->getArgOperand(inst->getNumArgOperands() - 1)->getType();
+    Type* pTy = inst->getArgOperand(IGCLLVM::getNumArgOperands(inst) - 1)->getType();
     unsigned size = pTy->getScalarSizeInBits() / 8;
     emitSetMessagePhaseType(inst, GetTypeFromSize(size));
 }
@@ -4293,7 +4293,7 @@ void EmitPass::emitEvalAttribute(llvm::GenIntrinsicInst* inst)
 {
     CPixelShader* psProgram = static_cast<CPixelShader*>(m_currShader);
     // temp variable should be the same type as the destination
-    bool perspective = cast<ConstantInt>(inst->getOperand(inst->getNumArgOperands() - 1))->getZExtValue() != 0;
+    bool perspective = cast<ConstantInt>(inst->getOperand(IGCLLVM::getNumArgOperands(inst) - 1))->getZExtValue() != 0;
     EU_PIXEL_INTERPOLATOR_INTERPOLATION_MODE interpolationMode =
         perspective ? EU_PI_MESSAGE_PERSPECTIVE_INTERPOLATION : EU_PI_MESSAGE_LINEAR_INTERPOLATION;
     if (interpolationMode == EU_PI_MESSAGE_LINEAR_INTERPOLATION)
@@ -10134,7 +10134,7 @@ bool EmitPass::validateInlineAsmConstraints(llvm::CallInst* inst, SmallVector<St
     if (success)
     {
         // Check the input constraint tokens
-        for (unsigned i = 0; i < inst->getNumArgOperands(); i++, index++)
+        for (unsigned i = 0; i < IGCLLVM::getNumArgOperands(inst); i++, index++)
         {
             CVariable* cv = GetSymbol(inst->getArgOperand(i));
             success &= CheckConstraintTypes(constraints[index], cv);
@@ -10184,7 +10184,7 @@ void EmitPass::EmitInlineAsm(llvm::CallInst* inst)
     {
         opnds.push_back(m_destination);
     }
-    for (unsigned i = 0; i < inst->getNumArgOperands(); i++)
+    for (unsigned i = 0; i < IGCLLVM::getNumArgOperands(inst); i++)
     {
         CVariable* cv = GetSymbol(inst->getArgOperand(i));
         opnds.push_back(cv);
@@ -11904,7 +11904,7 @@ void EmitPass::emitStackCall(llvm::CallInst* inst)
     std::vector<CVariable*> argsOnStack;
     SmallVector<std::tuple<CVariable*, Type*, uint32_t>, 8> argsOnRegister;
 
-    for (uint32_t i = 0; i < inst->getNumArgOperands(); i++)
+    for (uint32_t i = 0; i < IGCLLVM::getNumArgOperands(inst); i++)
     {
         Value* operand = inst->getArgOperand(i);
         CVariable* Src = GetSymbol(operand);
@@ -14991,7 +14991,7 @@ void EmitPass::emitAtomicRaw(llvm::GenIntrinsicInst* pInsn)
     ForceDMask();
     // Currently, Dword Atomics can be called by matching 2 intrinsics. One is the DwordAtomicRaw
     // and AtomicCmpXchg (which has 2 srcs unlike the other atomics).
-    IGC_ASSERT(pInsn->getNumArgOperands() == 4);
+    IGC_ASSERT(IGCLLVM::getNumArgOperands(pInsn) == 4);
 
     /// Immediate Atomics return the value before the atomic operation is performed. So that flag
     /// needs to be set for this.
@@ -15236,7 +15236,7 @@ void EmitPass::emitAtomicTyped(GenIntrinsicInst* pInsn)
     ForceDMask();
     // Currently, Dword Atomics can be called by matching 2 intrinsics. One is the DwordAtomicRaw
     // and AtomicCmpXchg (which has 2 srcs unlike the other atomics).
-    IGC_ASSERT(pInsn->getNumArgOperands() == 6);
+    IGC_ASSERT(IGCLLVM::getNumArgOperands(pInsn) == 6);
 
     /// Immediate Atomics return the value before the atomic operation is performed. So that flag
     /// needs to be set for this.
@@ -15887,7 +15887,7 @@ LSC_FENCE_OP EmitPass::getLSCMemoryFenceOp(bool IsGlobalMemFence, bool Invalidat
 void EmitPass::emitMemoryFence(llvm::Instruction* inst)
 {
     static constexpr int ExpectedNumberOfArguments = 7;
-    IGC_ASSERT(cast<CallInst>(inst)->getNumArgOperands() == ExpectedNumberOfArguments);
+    IGC_ASSERT(IGCLLVM::getNumArgOperands(cast<CallInst>(inst)) == ExpectedNumberOfArguments);
     CodeGenContext* ctx = getAnalysis<CodeGenContextWrapper>().getCodeGenContext();
 
     // If passed a non-constant value for any of the parameters,
@@ -16929,7 +16929,7 @@ void EmitPass::emitfitof(llvm::GenIntrinsicInst* inst)
 // Emit FP Operations (FPO) using round-to-zero (rtz)
 void EmitPass::emitFPOrtz(llvm::GenIntrinsicInst* inst)
 {
-    IGC_ASSERT_MESSAGE(inst->getNumArgOperands() >= 2, "ICE: incorrect gen intrinsic");
+    IGC_ASSERT_MESSAGE(IGCLLVM::getNumArgOperands(inst) >= 2, "ICE: incorrect gen intrinsic");
 
     GenISAIntrinsic::ID GID = inst->getIntrinsicID();
     CVariable* src0 = GetSymbol(inst->getOperand(0));
@@ -16965,7 +16965,7 @@ void EmitPass::emitFPOrtz(llvm::GenIntrinsicInst* inst)
 
 // Emit FP mad (FMA) using round-to-positive-infinity (rtp)
 void EmitPass::emitFMArtp(llvm::GenIntrinsicInst *inst) {
-  IGC_ASSERT_MESSAGE(inst->getNumArgOperands() == 3, "ICE: incorrect gen intrinsic");
+  IGC_ASSERT_MESSAGE(IGCLLVM::getNumArgOperands(inst) == 3, "ICE: incorrect gen intrinsic");
 
   CVariable *src0 = GetSymbol(inst->getOperand(0));
   CVariable *src1 = GetSymbol(inst->getOperand(1));
@@ -16982,7 +16982,7 @@ void EmitPass::emitFMArtp(llvm::GenIntrinsicInst *inst) {
 
 // Emit FP mad (FMA) using round-to-negative-infinity (rtn)
 void EmitPass::emitFMArtn(llvm::GenIntrinsicInst *inst) {
-  IGC_ASSERT_MESSAGE(inst->getNumArgOperands() == 3, "ICE: incorrect gen intrinsic");
+  IGC_ASSERT_MESSAGE(IGCLLVM::getNumArgOperands(inst) == 3, "ICE: incorrect gen intrinsic");
 
   CVariable *src0 = GetSymbol(inst->getOperand(0));
   CVariable *src1 = GetSymbol(inst->getOperand(1));
diff --git a/IGC/Compiler/CISACodeGen/EmitVISAPass.hpp b/IGC/Compiler/CISACodeGen/EmitVISAPass.hpp
index a4d16fd30..9e2eb9e90 100644
--- a/IGC/Compiler/CISACodeGen/EmitVISAPass.hpp
+++ b/IGC/Compiler/CISACodeGen/EmitVISAPass.hpp
@@ -630,7 +630,7 @@ public:
     {
         if (llvm::CallInst * pCall = llvm::dyn_cast<llvm::CallInst>(pInst))
         {
-            if (op < pCall->getNumArgOperands())
+            if (op < IGCLLVM::getNumArgOperands(pCall))
             {
                 return pInst->getOperand(op);
             }
diff --git a/IGC/Compiler/CISACodeGen/Emu64OpsPass.cpp b/IGC/Compiler/CISACodeGen/Emu64OpsPass.cpp
index 86c658f25..c41a4420c 100644
--- a/IGC/Compiler/CISACodeGen/Emu64OpsPass.cpp
+++ b/IGC/Compiler/CISACodeGen/Emu64OpsPass.cpp
@@ -18,7 +18,7 @@ SPDX-License-Identifier: MIT
 #include "llvm/IR/Function.h"
 #include "llvm/IR/IRBuilder.h"
 #include "llvm/IR/Instruction.h"
-#include "llvm/IR/Instructions.h"
+#include "llvmWrapper/IR/Instructions.h"
 #include "llvm/IR/IntrinsicInst.h"
 #include "llvm/IR/Module.h"
 #include "llvm/IR/Type.h"
@@ -1942,7 +1942,7 @@ bool InstExpander::visitCall(CallInst& Call) {
     IGC_ASSERT(nullptr != CallCopy);
     CallCopy->insertBefore(&Call);
     IRB->SetInsertPoint(CallCopy);
-    for (int argNo=0, sz = (int)Call.getNumArgOperands(); argNo < sz; ++argNo)
+    for (int argNo=0, sz = (int)IGCLLVM::getNumArgOperands(&Call); argNo < sz; ++argNo)
     {
         Value* OldVal = Call.getArgOperand(argNo);
         if (Emu->isInt64(OldVal))
diff --git a/IGC/Compiler/CISACodeGen/HalfPromotion.cpp b/IGC/Compiler/CISACodeGen/HalfPromotion.cpp
index 1ea2338b5..2dd10938c 100644
--- a/IGC/Compiler/CISACodeGen/HalfPromotion.cpp
+++ b/IGC/Compiler/CISACodeGen/HalfPromotion.cpp
@@ -86,7 +86,7 @@ void IGC::HalfPromotion::handleLLVMIntrinsic(llvm::IntrinsicInst& I)
             I.getIntrinsicID(),
             builder.getFloatTy());
 
-        for (unsigned i = 0; i < I.getNumArgOperands(); ++i)
+        for (unsigned i = 0; i < IGCLLVM::getNumArgOperands(&I); ++i)
         {
             if (I.getOperand(i)->getType()->isHalfTy())
             {
@@ -124,7 +124,7 @@ void IGC::HalfPromotion::handleGenIntrinsic(llvm::GenIntrinsicInst& I)
             I.getIntrinsicID(),
             builder.getFloatTy());
 
-        for (unsigned i = 0; i < I.getNumArgOperands(); ++i)
+        for (unsigned i = 0; i < IGCLLVM::getNumArgOperands(&I); ++i)
         {
             if (I.getOperand(i)->getType()->isHalfTy())
             {
diff --git a/IGC/Compiler/CISACodeGen/OpenCLKernelCodeGen.cpp b/IGC/Compiler/CISACodeGen/OpenCLKernelCodeGen.cpp
index 57020a7dc..3dfb2e3ef 100644
--- a/IGC/Compiler/CISACodeGen/OpenCLKernelCodeGen.cpp
+++ b/IGC/Compiler/CISACodeGen/OpenCLKernelCodeGen.cpp
@@ -1685,7 +1685,7 @@ namespace IGC
                 }
                 else
                 {
-                    for (int i = 0, e = (int)CallI->getNumArgOperands(); i < e; ++i)
+                    for (int i = 0, e = (int)IGCLLVM::getNumArgOperands(CallI); i < e; ++i)
                     {
                         Value* arg = CallI->getArgOperand(i);
                         PointerType* PTy = dyn_cast<PointerType>(arg->getType());
diff --git a/IGC/Compiler/CISACodeGen/PatternMatchPass.hpp b/IGC/Compiler/CISACodeGen/PatternMatchPass.hpp
index 276e0eba4..364aafbcf 100644
--- a/IGC/Compiler/CISACodeGen/PatternMatchPass.hpp
+++ b/IGC/Compiler/CISACodeGen/PatternMatchPass.hpp
@@ -21,6 +21,7 @@ SPDX-License-Identifier: MIT
 #include <llvm/Analysis/LoopInfo.h>
 #include <llvm/IR/DataLayout.h>
 #include "common/LLVMWarningsPop.hpp"
+#include "llvmWrapper/IR/Instructions.h"
 
 namespace llvm
 {
@@ -337,7 +338,7 @@ namespace IGC
     {
         if (llvm::CallInst * intrin = llvm::dyn_cast<llvm::CallInst>(&v))
         {
-            return intrin->getNumArgOperands();
+            return IGCLLVM::getNumArgOperands(intrin);
         }
         return v.getNumOperands();
     }
diff --git a/IGC/Compiler/CISACodeGen/PixelShaderLowering.cpp b/IGC/Compiler/CISACodeGen/PixelShaderLowering.cpp
index a25cac2f7..4dab24aa3 100644
--- a/IGC/Compiler/CISACodeGen/PixelShaderLowering.cpp
+++ b/IGC/Compiler/CISACodeGen/PixelShaderLowering.cpp
@@ -1299,7 +1299,7 @@ void PixelShaderLowering::moveRTWriteToBlock(
     unsigned numPredBB = predBB.size();
     if (numPredBB > 1)
     {
-        for (unsigned i = 0; i < call->getNumArgOperands(); i++)
+        for (unsigned i = 0; i < IGCLLVM::getNumArgOperands(call); i++)
         {
             if (Instruction * inst = dyn_cast<Instruction>(call->getArgOperand(i)))
             {
diff --git a/IGC/Compiler/CISACodeGen/ResolveGAS.cpp b/IGC/Compiler/CISACodeGen/ResolveGAS.cpp
index 6bedd7789..f01dc96b0 100644
--- a/IGC/Compiler/CISACodeGen/ResolveGAS.cpp
+++ b/IGC/Compiler/CISACodeGen/ResolveGAS.cpp
@@ -1125,7 +1125,7 @@ void GASRetValuePropagator::updateAllUsesWithNewFunction(Function* oldFunc, Func
 
         // Prepare args for new call
         std::vector<Value*> callArgs;
-        for (unsigned I = 0, E = cInst->getNumArgOperands(); I != E; ++I) {
+        for (unsigned I = 0, E = IGCLLVM::getNumArgOperands(cInst); I != E; ++I) {
             callArgs.push_back(cInst->getArgOperand(I));
         }
 
@@ -1939,7 +1939,7 @@ void LowerGPCallArg::updateAllUsesWithNewFunction(FuncToUpdate& f)
         std::vector<Value*> newCallArgs;
 
         auto AI = f.newFunc->arg_begin();
-        for (unsigned int i = 0; i < cInst->getNumArgOperands(); ++i, ++AI)
+        for (unsigned int i = 0; i < IGCLLVM::getNumArgOperands(cInst); ++i, ++AI)
         {
             Value* callArg = cInst->getOperand(i);
             Value* funcArg = AI;
diff --git a/IGC/Compiler/CISACodeGen/SLMConstProp.cpp b/IGC/Compiler/CISACodeGen/SLMConstProp.cpp
index d6a1c05f3..7c1ed8d89 100644
--- a/IGC/Compiler/CISACodeGen/SLMConstProp.cpp
+++ b/IGC/Compiler/CISACodeGen/SLMConstProp.cpp
@@ -1075,7 +1075,7 @@ bool SLMConstProp::runOnFunction(Function& F)
                 if (checkSLMArg) {
                     // Make sure those intrinsic does not use ptr to SLM
                     // (for example, SLM atomic, etc.
-                    for (int i = 0, e = (int)CallI->getNumArgOperands();
+                    for (int i = 0, e = (int)IGCLLVM::getNumArgOperands(CallI);
                         i < e; ++i) {
                         Type* Ty = CallI->getArgOperand(i)->getType();
                         if (PointerType * PTy = dyn_cast<PointerType>(Ty)) {
diff --git a/IGC/Compiler/CISACodeGen/VectorProcess.cpp b/IGC/Compiler/CISACodeGen/VectorProcess.cpp
index 3d2713be4..87adba4e1 100644
--- a/IGC/Compiler/CISACodeGen/VectorProcess.cpp
+++ b/IGC/Compiler/CISACodeGen/VectorProcess.cpp
@@ -214,7 +214,7 @@ bool VectorProcess::reLayoutLoadStore(Instruction* Inst)
         else
         {
             IGC_ASSERT(II->getIntrinsicID() == GenISAIntrinsic::GenISA_storerawvector_indexed);
-            IGC_ASSERT(2 < II->getNumArgOperands());
+            IGC_ASSERT(2 < IGCLLVM::getNumArgOperands(II));
             IGC_ASSERT(nullptr != II->getArgOperand(2));
 
             Ty = II->getArgOperand(2)->getType();
diff --git a/IGC/Compiler/CISACodeGen/WIAnalysis.cpp b/IGC/Compiler/CISACodeGen/WIAnalysis.cpp
index 3cdf48bad..a9bebef2a 100644
--- a/IGC/Compiler/CISACodeGen/WIAnalysis.cpp
+++ b/IGC/Compiler/CISACodeGen/WIAnalysis.cpp
@@ -1605,7 +1605,7 @@ WIAnalysis::WIDependancy WIAnalysisRunner::calculate_dep(const CallInst* inst)
 
         // Iterate over all input dependencies. If all are uniform - propagate it.
         // otherwise - return RANDOM
-        unsigned numParams = inst->getNumArgOperands();
+        unsigned numParams = IGCLLVM::getNumArgOperands(inst);
         WIAnalysis::WIDependancy dep = WIAnalysis::UNIFORM_GLOBAL;
         for (unsigned i = 0; i < numParams; ++i)
         {
diff --git a/IGC/Compiler/CISACodeGen/helper.cpp b/IGC/Compiler/CISACodeGen/helper.cpp
index ad1283dc7..21f78efc6 100644
--- a/IGC/Compiler/CISACodeGen/helper.cpp
+++ b/IGC/Compiler/CISACodeGen/helper.cpp
@@ -955,7 +955,7 @@ namespace IGC
         llvm::Function* pCalledFunc = pIntr->getCalledFunction();
 
         // Look at the intrinsic and figure out which pointer to change
-        int num_ops = pIntr->getNumArgOperands();
+        int num_ops = IGCLLVM::getNumArgOperands(pIntr);
         llvm::SmallVector<llvm::Value*, 5> args;
 
         for (int i = 0; i < num_ops; ++i)
diff --git a/IGC/Compiler/CustomSafeOptPass.cpp b/IGC/Compiler/CustomSafeOptPass.cpp
index 775250954..b06e0193f 100644
--- a/IGC/Compiler/CustomSafeOptPass.cpp
+++ b/IGC/Compiler/CustomSafeOptPass.cpp
@@ -1783,7 +1783,7 @@ void IGC::CustomSafeOptPass::visitSampleBptr(llvm::SampleIntrinsic* sampleInst)
     {
         // Copy args skipping bias operand:
         llvm::SmallVector<llvm::Value*, 10> args;
-        for (unsigned int i = 1; i < sampleInst->getNumArgOperands(); i++)
+        for (unsigned int i = 1; i < IGCLLVM::getNumArgOperands(sampleInst); i++)
         {
             args.push_back(sampleInst->getArgOperand(i));
         }
diff --git a/IGC/Compiler/LowPrecisionOptPass.cpp b/IGC/Compiler/LowPrecisionOptPass.cpp
index e3d65bc18..7cf09cf7a 100644
--- a/IGC/Compiler/LowPrecisionOptPass.cpp
+++ b/IGC/Compiler/LowPrecisionOptPass.cpp
@@ -21,6 +21,8 @@ SPDX-License-Identifier: MIT
 
 #include "GenISAIntrinsics/GenIntrinsicInst.h"
 #include "common/IGCIRBuilder.h"
+#include "llvmWrapper/IR/Instructions.h"
+
 using namespace llvm;
 using namespace IGC;
 using namespace IGC::IGCMD;
@@ -297,7 +299,7 @@ bool LowPrecisionOpt::propagateSamplerType(llvm::GenIntrinsicInst& I)
     Function* newSample = GenISAIntrinsic::getDeclaration(
         m_currFunction->getParent(), I.getIntrinsicID(), overloadTys);
     llvm::SmallVector<llvm::Value*, 8> newArgs;
-    for (unsigned int i = 0, argSize = I.getNumArgOperands(); i < argSize; i++)
+    for (unsigned int i = 0, argSize = IGCLLVM::getNumArgOperands(&I); i < argSize; i++)
     {
         newArgs.push_back(I.getArgOperand(i));
     }
diff --git a/IGC/Compiler/Optimizer/BuiltInFuncImport.cpp b/IGC/Compiler/Optimizer/BuiltInFuncImport.cpp
index 8cbb7b953..ddbbaf959 100644
--- a/IGC/Compiler/Optimizer/BuiltInFuncImport.cpp
+++ b/IGC/Compiler/Optimizer/BuiltInFuncImport.cpp
@@ -775,7 +775,7 @@ bool BIImport::runOnModule(Module& M)
                     IGC_ASSERT(FP->getType()->isPointerTy() && cast<PointerType>(FP->getType())->getElementType()->isFunctionTy());
                     // Call the loaded function address
                     SmallVector<Value*, 8> Args;
-                    for (unsigned i = 1; i < CI->getNumArgOperands(); i++)
+                    for (unsigned i = 1; i < IGCLLVM::getNumArgOperands(CI); i++)
                         Args.push_back(CI->getArgOperand(i));
                     CallInst* CallFP = builder.CreateCall(FP, Args);
                     CallFP->setCallingConv(llvm::CallingConv::SPIR_FUNC);
@@ -889,7 +889,7 @@ void BIImport::removeFunctionBitcasts(Module& M)
                         }
 
                         std::vector<Value*> Args;
-                        for (unsigned I = 0, E = pInstCall->getNumArgOperands(); I != E; ++I) {
+                        for (unsigned I = 0, E = IGCLLVM::getNumArgOperands(pInstCall); I != E; ++I) {
                             Args.push_back(pInstCall->getArgOperand(I));
                         }
                         auto newCI = CallInst::Create(pDstFunc, Args, "", pInstCall);
@@ -1228,7 +1228,7 @@ bool PreBIImportAnalysis::runOnModule(Module& M)
 
                   if (Function *newFunc = M.getFunction(newName)) {
                     SmallVector<Value *, 8> Args;
-                    for (unsigned I = 0, E = CI->getNumArgOperands(); I != E;
+                    for (unsigned I = 0, E = IGCLLVM::getNumArgOperands(CI); I != E;
                          ++I) {
                       Args.push_back(CI->getArgOperand(I));
                     }
diff --git a/IGC/Compiler/Optimizer/IGCInstCombiner/4.0/InstCombineCalls.cpp b/IGC/Compiler/Optimizer/IGCInstCombiner/4.0/InstCombineCalls.cpp
index af9628871..6baca12ea 100644
--- a/IGC/Compiler/Optimizer/IGCInstCombiner/4.0/InstCombineCalls.cpp
+++ b/IGC/Compiler/Optimizer/IGCInstCombiner/4.0/InstCombineCalls.cpp
@@ -37,7 +37,7 @@ See LICENSE.TXT for details.
 #include "llvm/IR/GlobalVariable.h"
 #include "llvm/IR/InstrTypes.h"
 #include "llvm/IR/Instruction.h"
-#include "llvm/IR/Instructions.h"
+#include "llvmWrapper/IR/Instructions.h"
 #include "llvm/IR/IntrinsicInst.h"
 #include "llvm/IR/Intrinsics.h"
 #include "llvm/IR/LLVMContext.h"
@@ -1336,8 +1336,8 @@ static bool simplifyX86MaskedStore(IntrinsicInst &II, InstCombiner &IC) {
 // comparison to the first NumOperands.
 static bool haveSameOperands(const IntrinsicInst &I, const IntrinsicInst &E,
                              unsigned NumOperands) {
-  IGC_ASSERT_MESSAGE(I.getNumArgOperands() >= NumOperands, "Not enough operands");
-  IGC_ASSERT_MESSAGE(E.getNumArgOperands() >= NumOperands, "Not enough operands");
+  IGC_ASSERT_MESSAGE(IGCLLVM::getNumArgOperands(&I) >= NumOperands, "Not enough operands");
+  IGC_ASSERT_MESSAGE(IGCLLVM::getNumArgOperands(&E) >= NumOperands, "Not enough operands");
   for (unsigned i = 0; i < NumOperands; i++)
     if (I.getArgOperand(i) != E.getArgOperand(i))
       return false;
@@ -1362,7 +1362,7 @@ static bool removeTriviallyEmptyRange(IntrinsicInst &I, unsigned StartID,
       if (isa<DbgInfoIntrinsic>(E) || E->getIntrinsicID() == StartID)
         continue;
       if (E->getIntrinsicID() == EndID &&
-          haveSameOperands(I, *E, E->getNumArgOperands())) {
+          haveSameOperands(I, *E, IGCLLVM::getNumArgOperands(E))) {
         IC.eraseInstFromFunction(*E);
         IC.eraseInstFromFunction(I);
         return true;
@@ -2481,7 +2481,7 @@ Instruction *InstCombiner::visitCallInst(CallInst &CI) {
   case Intrinsic::arm_neon_vst4lane: {
     unsigned MemAlign =
         getKnownAlignment(II->getArgOperand(0), DL, II, &AC, &DT);
-    unsigned AlignArg = II->getNumArgOperands() - 1;
+    unsigned AlignArg = IGCLLVM::getNumArgOperands(II) - 1;
     ConstantInt *IntrAlign = dyn_cast<ConstantInt>(II->getArgOperand(AlignArg));
     if (IntrAlign && IntrAlign->getZExtValue() < MemAlign) {
       II->setArgOperand(AlignArg,
diff --git a/IGC/Compiler/Optimizer/IGCInstCombiner/7.0/InstCombineCalls.cpp b/IGC/Compiler/Optimizer/IGCInstCombiner/7.0/InstCombineCalls.cpp
index 6d57a2210..d82284c1a 100644
--- a/IGC/Compiler/Optimizer/IGCInstCombiner/7.0/InstCombineCalls.cpp
+++ b/IGC/Compiler/Optimizer/IGCInstCombiner/7.0/InstCombineCalls.cpp
@@ -42,7 +42,7 @@ See LICENSE.TXT for details.
 #include "llvm/IR/GlobalVariable.h"
 #include "llvm/IR/InstrTypes.h"
 #include "llvm/IR/Instruction.h"
-#include "llvm/IR/Instructions.h"
+#include "llvmWrapper/IR/Instructions.h"
 #include "llvm/IR/IntrinsicInst.h"
 #include "llvm/IR/Intrinsics.h"
 #include "llvm/IR/LLVMContext.h"
@@ -1563,8 +1563,8 @@ static Value* simplifyNeonVld1(const IntrinsicInst& II,
 // comparison to the first NumOperands.
 static bool haveSameOperands(const IntrinsicInst& I, const IntrinsicInst& E,
     unsigned NumOperands) {
-    IGC_ASSERT_MESSAGE(I.getNumArgOperands() >= NumOperands, "Not enough operands");
-    IGC_ASSERT_MESSAGE(E.getNumArgOperands() >= NumOperands, "Not enough operands");
+    IGC_ASSERT_MESSAGE(IGCLLVM::getNumArgOperands(&I) >= NumOperands, "Not enough operands");
+    IGC_ASSERT_MESSAGE(IGCLLVM::getNumArgOperands(&E) >= NumOperands, "Not enough operands");
     for (unsigned i = 0; i < NumOperands; i++)
         if (I.getArgOperand(i) != E.getArgOperand(i))
             return false;
@@ -1589,7 +1589,7 @@ static bool removeTriviallyEmptyRange(IntrinsicInst& I, unsigned StartID,
             if (isa<DbgInfoIntrinsic>(E) || E->getIntrinsicID() == StartID)
                 continue;
             if (E->getIntrinsicID() == EndID &&
-                haveSameOperands(I, *E, E->getNumArgOperands())) {
+                haveSameOperands(I, *E, IGCLLVM::getNumArgOperands(E))) {
                 IC.eraseInstFromFunction(*E);
                 IC.eraseInstFromFunction(I);
                 return true;
@@ -3111,7 +3111,7 @@ Instruction* InstCombiner::visitCallInst(CallInst& CI) {
     case Intrinsic::arm_neon_vst4lane: {
         unsigned MemAlign =
             getKnownAlignment(II->getArgOperand(0), DL, II, &AC, &DT);
-        unsigned AlignArg = II->getNumArgOperands() - 1;
+        unsigned AlignArg = IGCLLVM::getNumArgOperands(II) - 1;
         ConstantInt* IntrAlign = dyn_cast<ConstantInt>(II->getArgOperand(AlignArg));
         if (IntrAlign && IntrAlign->getZExtValue() < MemAlign) {
             II->setArgOperand(AlignArg,
diff --git a/IGC/Compiler/Optimizer/IGCInstCombiner/7.0/InstCombineSimplifyDemanded.cpp b/IGC/Compiler/Optimizer/IGCInstCombiner/7.0/InstCombineSimplifyDemanded.cpp
index a5c8dd42f..0a7d6b002 100644
--- a/IGC/Compiler/Optimizer/IGCInstCombiner/7.0/InstCombineSimplifyDemanded.cpp
+++ b/IGC/Compiler/Optimizer/IGCInstCombiner/7.0/InstCombineSimplifyDemanded.cpp
@@ -1009,7 +1009,7 @@ Value* InstCombiner::simplifyAMDGCNMemoryIntrinsicDemanded(IntrinsicInst* II,
     Function* NewIntrin = Intrinsic::getDeclaration(M, IID, OverloadTys);
 
     SmallVector<Value*, 16> Args;
-    for (unsigned I = 0, E = II->getNumArgOperands(); I != E; ++I)
+    for (unsigned I = 0, E = IGCLLVM::getNumArgOperands(II); I != E; ++I)
         Args.push_back(II->getArgOperand(I));
 
     if (NewDMask)
diff --git a/IGC/Compiler/Optimizer/IGCInstCombiner/IGCInstructionCombining.hpp b/IGC/Compiler/Optimizer/IGCInstCombiner/IGCInstructionCombining.hpp
index fc849c3ca..46fe0e23c 100644
--- a/IGC/Compiler/Optimizer/IGCInstCombiner/IGCInstructionCombining.hpp
+++ b/IGC/Compiler/Optimizer/IGCInstCombiner/IGCInstructionCombining.hpp
@@ -11,7 +11,12 @@ SPDX-License-Identifier: MIT
 
 #include "llvm/Config/llvm-config.h"
 #include "llvm/PassRegistry.h"
+#if LLVM_VERSION_MAJOR <= 13
 #include "llvm/Transforms/InstCombine/InstCombineWorklist.h"
+#else
+#include "llvm/Transforms/Utils/InstructionWorklist.h"
+using llvm::InstCombineWorklist = llvm::InstructionWorklist;
+#endif
 #include "llvm/IR/PassManager.h"
 #include "Compiler/InitializePasses.h"
 
diff --git a/IGC/Compiler/Optimizer/IndirectCallOptimization.cpp b/IGC/Compiler/Optimizer/IndirectCallOptimization.cpp
index 6e1a9592b..d763c147b 100644
--- a/IGC/Compiler/Optimizer/IndirectCallOptimization.cpp
+++ b/IGC/Compiler/Optimizer/IndirectCallOptimization.cpp
@@ -74,7 +74,7 @@ namespace IGC
         if (func->getReturnType() != call->getType())
             return false;
 
-        if (func->arg_size() != call->getNumArgOperands())
+        if (func->arg_size() != IGCLLVM::getNumArgOperands(call))
             return false;
 
         unsigned index = 0;
diff --git a/IGC/Compiler/Optimizer/OCLBIUtils.cpp b/IGC/Compiler/Optimizer/OCLBIUtils.cpp
index a8c61b28d..3bf5cab11 100644
--- a/IGC/Compiler/Optimizer/OCLBIUtils.cpp
+++ b/IGC/Compiler/Optimizer/OCLBIUtils.cpp
@@ -867,7 +867,7 @@ class CSimpleIntrinMapping : public CCommand
 protected:
     void createIntrinsicType(const CallInst* pCI, ArrayRef<Type*> overloadTypes)
     {
-        m_args.append(pCI->op_begin(), pCI->op_begin() + pCI->getNumArgOperands());
+        m_args.append(pCI->op_begin(), pCI->op_begin() + IGCLLVM::getNumArgOperands(pCI));
         IGC_ASSERT_MESSAGE(!(id != Intrinsic::num_intrinsics && isaId != GenISAIntrinsic::ID::num_genisa_intrinsics), "Both intrinsic id's cannot be valid at the same time");
 
         // GenISA intrinsics ID start after llvm intrinsics
@@ -900,7 +900,7 @@ public:
 
     void createIntrinsic()
     {
-        IGC_ASSERT_MESSAGE(!(this->isOverloadable && m_pCallInst->getNumArgOperands() == 0), "Cannot create an overloadable with no args");
+        IGC_ASSERT_MESSAGE(!(this->isOverloadable && IGCLLVM::getNumArgOperands(m_pCallInst) == 0), "Cannot create an overloadable with no args");
         llvm::Type* tys[2];
         switch (isaId)
         {
@@ -921,7 +921,7 @@ public:
         case GenISAIntrinsic::GenISA_itof_rtz:
             tys[0] = m_pCallInst->getCalledFunction()->getReturnType();
             tys[1] = m_pCallInst->getArgOperand(0)->getType();
-            m_args.append(m_pCallInst->op_begin(), m_pCallInst->op_begin() + m_pCallInst->getNumArgOperands());
+            m_args.append(m_pCallInst->op_begin(), m_pCallInst->op_begin() + IGCLLVM::getNumArgOperands(m_pCallInst));
             IGC_ASSERT_MESSAGE(!(id != Intrinsic::num_intrinsics && isaId != GenISAIntrinsic::ID::num_genisa_intrinsics), "Both intrinsic id's cannot be valid at the same time");
             replaceGenISACallInst(isaId, llvm::ArrayRef<llvm::Type*>(tys));
             break;
@@ -936,7 +936,7 @@ public:
         case GenISAIntrinsic::GenISA_simdSetMessagePhase:
         case GenISAIntrinsic::GenISA_setMessagePhaseX:
         case GenISAIntrinsic::GenISA_setMessagePhaseX_legacy:
-            createIntrinsicType(m_pCallInst, m_pCallInst->getArgOperand(m_pCallInst->getNumArgOperands() - 1)->getType());
+            createIntrinsicType(m_pCallInst, m_pCallInst->getArgOperand(IGCLLVM::getNumArgOperands(m_pCallInst) - 1)->getType());
             break;
         case GenISAIntrinsic::GenISA_broadcastMessagePhaseV:
         case GenISAIntrinsic::GenISA_simdGetMessagePhaseV:
@@ -956,7 +956,7 @@ public:
             Type* overloadTypes[] =
             {
                 m_pCallInst->getCalledFunction()->getReturnType(),
-                m_pCallInst->getArgOperand(m_pCallInst->getNumArgOperands() - 1)->getType()
+                m_pCallInst->getArgOperand(IGCLLVM::getNumArgOperands(m_pCallInst) - 1)->getType()
             };
             createIntrinsicType(m_pCallInst, overloadTypes);
             break;
@@ -1043,7 +1043,7 @@ public:
         }
 
         // Rest of the params
-        m_args.append(m_pCallInst->op_begin() + 3 + num_images, m_pCallInst->op_begin() + m_pCallInst->getNumArgOperands());
+        m_args.append(m_pCallInst->op_begin() + 3 + num_images, m_pCallInst->op_begin() + IGCLLVM::getNumArgOperands(m_pCallInst));
 
         replaceGenISACallInst(id);
     }
@@ -1085,7 +1085,7 @@ public:
         }
 
         // Rest of the params except for the accelerator sampler.
-        m_args.append(m_pCallInst->op_begin() + 1 + m_numImgArgs + 1, m_pCallInst->op_begin() + m_pCallInst->getNumArgOperands());
+        m_args.append(m_pCallInst->op_begin() + 1 + m_numImgArgs + 1, m_pCallInst->op_begin() + IGCLLVM::getNumArgOperands(m_pCallInst));
 
         // Device-side VME using the CNewVMESend always use inline samplers.
         IGC::ModuleMetaData* MD = m_Ctx->getModuleMetaData();
diff --git a/IGC/Compiler/Optimizer/OpenCLPasses/Atomics/ResolveOCLAtomics.cpp b/IGC/Compiler/Optimizer/OpenCLPasses/Atomics/ResolveOCLAtomics.cpp
index 2f6d8da50..fca2938da 100644
--- a/IGC/Compiler/Optimizer/OpenCLPasses/Atomics/ResolveOCLAtomics.cpp
+++ b/IGC/Compiler/Optimizer/OpenCLPasses/Atomics/ResolveOCLAtomics.cpp
@@ -106,7 +106,7 @@ void ResolveOCLAtomics::processOCLAtomic(CallInst& callInst, AtomicOp op, Buffer
     // Generate a call to GenISA_dwordatomic intrinsic.
     GenISAIntrinsic::ID genIsaIntrinID;
 
-    const bool noSources = (callInst.getNumArgOperands() == 1);
+    const bool noSources = (IGCLLVM::getNumArgOperands(&callInst) == 1);
     // For atomics w/o sources (atomic_inc and atomic_dec), src0 should be absent.
     // However, we cannot pass nullptr as argument, so we set src0 = "0" and it
     // will be ignored in EmitPass::emitAtomicRaw.
diff --git a/IGC/Compiler/Optimizer/OpenCLPasses/DeviceEnqueueFuncs/DeviceEnqueue.cpp b/IGC/Compiler/Optimizer/OpenCLPasses/DeviceEnqueueFuncs/DeviceEnqueue.cpp
index e9146057d..6f3d226ab 100644
--- a/IGC/Compiler/Optimizer/OpenCLPasses/DeviceEnqueueFuncs/DeviceEnqueue.cpp
+++ b/IGC/Compiler/Optimizer/OpenCLPasses/DeviceEnqueueFuncs/DeviceEnqueue.cpp
@@ -126,7 +126,7 @@ void DeviceEnqueueFuncsAnalysis::visitCallInst(CallInst& CI)
     else if (funcName == GET_OBJECT_ID)
     {
         // Extract the arg num and add it to the appropriate data structure
-        IGC_ASSERT_MESSAGE(CI.getNumArgOperands() == 1, "get_object_id function is expected to have only one argument");
+        IGC_ASSERT_MESSAGE(IGCLLVM::getNumArgOperands(&CI) == 1, "get_object_id function is expected to have only one argument");
 
         // We support only compile-time constants as arguments of get_object_id()
         ConstantInt* callArg = dyn_cast<ConstantInt>(CI.getArgOperand(0));
@@ -138,7 +138,7 @@ void DeviceEnqueueFuncsAnalysis::visitCallInst(CallInst& CI)
     else if (funcName == GET_BLOCK_SIMD_SIZE)
     {
         // Extract the arg num and add it to the appropriate data structure
-        IGC_ASSERT_MESSAGE(CI.getNumArgOperands() == 1, "get_block_simd_size function is expected to have only one argument");
+        IGC_ASSERT_MESSAGE(IGCLLVM::getNumArgOperands(&CI) == 1, "get_block_simd_size function is expected to have only one argument");
 
         // We support only compile-time constants as arguments of get_object_id()
         ConstantInt* callArg = dyn_cast<ConstantInt>(CI.getArgOperand(0));
diff --git a/IGC/Compiler/Optimizer/OpenCLPasses/DeviceEnqueueFuncs/TransformBlocks.cpp b/IGC/Compiler/Optimizer/OpenCLPasses/DeviceEnqueueFuncs/TransformBlocks.cpp
index 9d192a512..3485bb50a 100644
--- a/IGC/Compiler/Optimizer/OpenCLPasses/DeviceEnqueueFuncs/TransformBlocks.cpp
+++ b/IGC/Compiler/Optimizer/OpenCLPasses/DeviceEnqueueFuncs/TransformBlocks.cpp
@@ -928,7 +928,7 @@ namespace //Anonymous
         SPIRVOpEnqueueKernelCallArgs(llvm::CallInst& call, DataContext& dataContext)
             : DeviceExecCallArgs(call, dataContext)
         {
-            IGC_ASSERT_EXIT_MESSAGE(8 <= _call.getNumArgOperands(), "OpEnqueueKernel signature does not match");
+            IGC_ASSERT_EXIT_MESSAGE(8 <= IGCLLVM::getNumArgOperands(&_call), "OpEnqueueKernel signature does not match");
 
             _queue = _call.getArgOperand(0);
             _flags = _call.getArgOperand(1);
@@ -948,7 +948,7 @@ namespace //Anonymous
             }
 
             const unsigned localSizesStartArgNum = 10;
-            const unsigned argsNum = _call.getNumArgOperands();
+            const unsigned argsNum = IGCLLVM::getNumArgOperands(&_call);
             for (unsigned i = localSizesStartArgNum; i < argsNum; i++)
             {
                 auto arg = _call.getArgOperand(i);
@@ -1609,7 +1609,7 @@ namespace //Anonymous
                             {
                                 // assuming indirect call is the block call
                                 unsigned blockArgIdx = callInst->hasStructRetAttr() ? 1 : 0;
-                                if (callInst->getNumArgOperands() > blockArgIdx)
+                                if (IGCLLVM::getNumArgOperands(callInst) > blockArgIdx)
                                 {
                                     Value* spc = callInst->getArgOperand(blockArgIdx)->stripPointerCasts();
                                     if (KindQuery::isBlockStructType(spc->getType()))
diff --git a/IGC/Compiler/Optimizer/OpenCLPasses/ExtenstionFuncs/ExtensionFuncResolution.cpp b/IGC/Compiler/Optimizer/OpenCLPasses/ExtenstionFuncs/ExtensionFuncResolution.cpp
index 3c498033b..1778a4cbb 100644
--- a/IGC/Compiler/Optimizer/OpenCLPasses/ExtenstionFuncs/ExtensionFuncResolution.cpp
+++ b/IGC/Compiler/Optimizer/OpenCLPasses/ExtenstionFuncs/ExtensionFuncResolution.cpp
@@ -73,7 +73,7 @@ void ExtensionFuncsResolution::visitCallInst(CallInst& CI)
     }
     else if (funcName.startswith(ExtensionFuncsAnalysis::VME_HELPER_GET_HANDLE)) {
         // Load from the opaque vme pointer and return the a vector with values.
-        IGC_ASSERT(CI.getNumArgOperands() == 1);
+        IGC_ASSERT(IGCLLVM::getNumArgOperands(&CI) == 1);
         IGCLLVM::IRBuilder<> builder(&CI);
         Type* retType = CI.getType();
         IGC_ASSERT(retType->isVectorTy() || retType->isIntegerTy());
@@ -86,7 +86,7 @@ void ExtensionFuncsResolution::visitCallInst(CallInst& CI)
     }
     else if (funcName.startswith(ExtensionFuncsAnalysis::VME_HELPER_GET_AS)) {
         // Store the VME values and return an opaque vme pointer.
-        IGC_ASSERT(CI.getNumArgOperands() == 1);
+        IGC_ASSERT(IGCLLVM::getNumArgOperands(&CI) == 1);
         IGCLLVM::IRBuilder<> builder(&*CI.getParent()->getParent()->begin()->getFirstInsertionPt());
         Type* retType = CI.getType();
         Value* arg = CI.getArgOperand(0);
diff --git a/IGC/Compiler/Optimizer/OpenCLPasses/GenericAddressResolution/GenericAddressDynamicResolution.cpp b/IGC/Compiler/Optimizer/OpenCLPasses/GenericAddressResolution/GenericAddressDynamicResolution.cpp
index 2f9f1054b..b22dd7b82 100644
--- a/IGC/Compiler/Optimizer/OpenCLPasses/GenericAddressResolution/GenericAddressDynamicResolution.cpp
+++ b/IGC/Compiler/Optimizer/OpenCLPasses/GenericAddressResolution/GenericAddressDynamicResolution.cpp
@@ -400,7 +400,7 @@ bool GenericAddressDynamicResolution::visitIntrinsicCall(CallInst& I)
     if ((funcName == "__builtin_IB_to_private") || (funcName == "__builtin_IB_to_local")
         || (funcName == "__builtin_IB_to_global"))
     {
-        IGC_ASSERT(I.getNumArgOperands() == 1);
+        IGC_ASSERT(IGCLLVM::getNumArgOperands(&I) == 1);
         Value* arg = I.getArgOperand(0);
         PointerType* dstType = dyn_cast<PointerType>(I.getType());
         IGC_ASSERT( dstType != nullptr );
diff --git a/IGC/Compiler/Optimizer/OpenCLPasses/ImageFuncs/ImageFuncsAnalysis.cpp b/IGC/Compiler/Optimizer/OpenCLPasses/ImageFuncs/ImageFuncsAnalysis.cpp
index c07937626..54c59cff6 100644
--- a/IGC/Compiler/Optimizer/OpenCLPasses/ImageFuncs/ImageFuncsAnalysis.cpp
+++ b/IGC/Compiler/Optimizer/OpenCLPasses/ImageFuncs/ImageFuncsAnalysis.cpp
@@ -164,7 +164,7 @@ void ImageFuncsAnalysis::visitCallInst(CallInst& CI)
     }
 
     // Extract the arg num and add it to the appropriate data structure
-    IGC_ASSERT_MESSAGE(CI.getNumArgOperands() == 1, "Supported image/sampler functions are expected to have only one argument");
+    IGC_ASSERT_MESSAGE(IGCLLVM::getNumArgOperands(&CI) == 1, "Supported image/sampler functions are expected to have only one argument");
 
     // We only care about image and sampler arguments here, inline samplers
     // don't require extra kernel parameters.
diff --git a/IGC/Compiler/Optimizer/OpenCLPasses/ImageFuncs/ResolveSampledImageBuiltins.cpp b/IGC/Compiler/Optimizer/OpenCLPasses/ImageFuncs/ResolveSampledImageBuiltins.cpp
index df3169d8d..674fb6016 100644
--- a/IGC/Compiler/Optimizer/OpenCLPasses/ImageFuncs/ResolveSampledImageBuiltins.cpp
+++ b/IGC/Compiler/Optimizer/OpenCLPasses/ImageFuncs/ResolveSampledImageBuiltins.cpp
@@ -96,7 +96,7 @@ void ResolveSampledImageBuiltins::visitCallInst(CallInst& CI)
 
 Value* ResolveSampledImageBuiltins::lowerGetImage(CallInst& CI)
 {
-    IGC_ASSERT(CI.getNumArgOperands() == 1);
+    IGC_ASSERT(IGCLLVM::getNumArgOperands(&CI) == 1);
 
     CallInst* callReturningOpaque = dyn_cast<CallInst>(CI.getArgOperand(0)->stripPointerCasts());
     IGC_ASSERT(callReturningOpaque);
@@ -127,7 +127,7 @@ Value* ResolveSampledImageBuiltins::lowerGetImage(CallInst& CI)
 
 Value* ResolveSampledImageBuiltins::lowerGetSampler(CallInst& CI)
 {
-    IGC_ASSERT(CI.getNumArgOperands() == 1);
+    IGC_ASSERT(IGCLLVM::getNumArgOperands(&CI) == 1);
     CallInst* callReturningOpaque = dyn_cast<CallInst>(CI.getArgOperand(0)->stripPointerCasts());
     IGC_ASSERT(callReturningOpaque);
 
diff --git a/IGC/Compiler/Optimizer/OpenCLPasses/OpenCLPrintf/OpenCLPrintfResolution.cpp b/IGC/Compiler/Optimizer/OpenCLPasses/OpenCLPrintf/OpenCLPrintfResolution.cpp
index beeefdf9e..f4c99306b 100644
--- a/IGC/Compiler/Optimizer/OpenCLPasses/OpenCLPrintf/OpenCLPrintfResolution.cpp
+++ b/IGC/Compiler/Optimizer/OpenCLPasses/OpenCLPrintf/OpenCLPrintfResolution.cpp
@@ -746,7 +746,7 @@ Value* OpenCLPrintfResolution::fixupPrintfArg(CallInst& printfCall, Value* arg,
 
 void OpenCLPrintfResolution::preprocessPrintfArgs(CallInst& printfCall)
 {
-    for (int i = 0, numArgs = printfCall.getNumArgOperands(); i < numArgs; ++i)
+    for (int i = 0, numArgs = IGCLLVM::getNumArgOperands(&printfCall); i < numArgs; ++i)
     {
         Value* arg = printfCall.getOperand(i);
         Type* argType = arg->getType();
diff --git a/IGC/Compiler/Optimizer/OpenCLPasses/RayTracing/ResolveOCLRaytracingBuiltins.cpp b/IGC/Compiler/Optimizer/OpenCLPasses/RayTracing/ResolveOCLRaytracingBuiltins.cpp
index f97b474f7..b9adbeed3 100644
--- a/IGC/Compiler/Optimizer/OpenCLPasses/RayTracing/ResolveOCLRaytracingBuiltins.cpp
+++ b/IGC/Compiler/Optimizer/OpenCLPasses/RayTracing/ResolveOCLRaytracingBuiltins.cpp
@@ -134,7 +134,7 @@ Description:
 Returns a pointer to the data structure which the RT hardware operates on.
 The RT Stack address is computed as:
     syncStackSize = sizeof(HitInfo)*2 + (sizeof(Ray) + sizeof(TravStack))*RTDispatchGlobals.maxBVHLevels;
-    syncBase = RTDispatchGlobals.rtMemBasePtr – (DSSID * NUM_SIMD_LANES_PER_DSS + StackID + 1)*syncStackSize;
+    syncBase = RTDispatchGlobals.rtMemBasePtr ï¿½ (DSSID * NUM_SIMD_LANES_PER_DSS + StackID + 1)*syncStackSize;
 Where DSSID is an index which uniquely identifies the DSS in the machine (across tiles), and StackID is compute as below:
     With fused EUs (e.g. in DG2) :
       StackID[10:0] (msb to lsb) = (EUID[3:0]<<7) | (THREAD_ID[2:0]<<4) | SIMD_LANE_ID[3:0]
@@ -277,7 +277,7 @@ The return value of this function is a sync object which will be used by the ker
 */
 void ResolveOCLRaytracingBuiltins::handleDispatchTraceRayQuery(CallInst& callInst) {
   IGC_ASSERT(callInst.getType()->isPointerTy());
-  IGC_ASSERT(callInst.getNumArgOperands() == 3);
+  IGC_ASSERT(IGCLLVM::getNumArgOperands(&callInst) == 3);
 
   // Insert a ugm fence prior to send.rta to ensure RTUnit has accesss to
   // current data.
diff --git a/IGC/Compiler/Optimizer/OpenCLPasses/ReplaceUnsupportedIntrinsics/ReplaceUnsupportedIntrinsics.cpp b/IGC/Compiler/Optimizer/OpenCLPasses/ReplaceUnsupportedIntrinsics/ReplaceUnsupportedIntrinsics.cpp
index 68ee39a22..d1623a01b 100644
--- a/IGC/Compiler/Optimizer/OpenCLPasses/ReplaceUnsupportedIntrinsics/ReplaceUnsupportedIntrinsics.cpp
+++ b/IGC/Compiler/Optimizer/OpenCLPasses/ReplaceUnsupportedIntrinsics/ReplaceUnsupportedIntrinsics.cpp
@@ -137,7 +137,7 @@ ReplaceUnsupportedIntrinsics::ReplaceUnsupportedIntrinsics() : FunctionPass(ID)
 MemCpyInst* ReplaceUnsupportedIntrinsics::MemMoveToMemCpy(MemMoveInst* MM)
 {
     SmallVector<Value*, 5> args;
-    for (unsigned i = 0; i < MM->getNumArgOperands(); i++)
+    for (unsigned i = 0; i < IGCLLVM::getNumArgOperands(MM); i++)
         args.push_back(MM->getArgOperand(i));
 
     auto* Dst = MM->getRawDest();
diff --git a/IGC/Compiler/Optimizer/OpenCLPasses/TransformUnmaskedFunctionsPass.cpp b/IGC/Compiler/Optimizer/OpenCLPasses/TransformUnmaskedFunctionsPass.cpp
index ef34ab64d..9355af9e9 100644
--- a/IGC/Compiler/Optimizer/OpenCLPasses/TransformUnmaskedFunctionsPass.cpp
+++ b/IGC/Compiler/Optimizer/OpenCLPasses/TransformUnmaskedFunctionsPass.cpp
@@ -159,7 +159,7 @@ static TrivialUniformity checkCallInst(const CallInst* CI, UniformityCache *Cach
     if (result.kind == TrivialUniformity::FORMAL_ARG) {
         /* If uniformity of the function depends on a formal argument, check if all actual arguments are uniform: */
         result = TrivialUniformity::Unifrom();
-        const size_t count = CI->getNumArgOperands();
+        const size_t count = IGCLLVM::getNumArgOperands(CI);
         for (size_t i = 0; i < count; ++i) {
             result = mergeUnifromity(result, checkValue(CI->getArgOperand(i), Cache));
             if (result.kind == TrivialUniformity::NONUNIFORM) {
diff --git a/IGC/Compiler/Optimizer/PreCompiledFuncImport.cpp b/IGC/Compiler/Optimizer/PreCompiledFuncImport.cpp
index 3c1c3eae4..e07c6ff64 100644
--- a/IGC/Compiler/Optimizer/PreCompiledFuncImport.cpp
+++ b/IGC/Compiler/Optimizer/PreCompiledFuncImport.cpp
@@ -514,7 +514,7 @@ bool PreCompiledFuncImport::runOnModule(Module& M)
 
         types.push_back(CI->getType());
 
-        for (unsigned i = 0; i < CI->getNumArgOperands(); i++)
+        for (unsigned i = 0; i < IGCLLVM::getNumArgOperands(CI); i++)
         {
             types.push_back(CI->getArgOperand(i)->getType());
             args.push_back(CI->getArgOperand(i));
@@ -2082,7 +2082,7 @@ void PreCompiledFuncImport::replaceFunc(Function* old_func, Function* new_func)
             return;
         }
         Function* parent_func = cInst->getParent()->getParent();
-        size_t numArgOperands = cInst->getNumArgOperands();
+        size_t numArgOperands = IGCLLVM::getNumArgOperands(cInst);
 
         // let's prepare argument list on new call function
         llvm::Function::arg_iterator new_arg_iter = new_func->arg_begin();
diff --git a/IGC/Compiler/Optimizer/Scalarizer.cpp b/IGC/Compiler/Optimizer/Scalarizer.cpp
index c3b6cfcd1..67c33fac5 100644
--- a/IGC/Compiler/Optimizer/Scalarizer.cpp
+++ b/IGC/Compiler/Optimizer/Scalarizer.cpp
@@ -196,7 +196,7 @@ void ScalarizeFunction::buildExclusiveSet()
         std::vector<llvm::Value*> workset;
         if (GenIntrinsicInst * GII = dyn_cast<GenIntrinsicInst>(currInst))
         {
-            unsigned numOperands = GII->getNumArgOperands();
+            unsigned numOperands = IGCLLVM::getNumArgOperands(GII);
             for (unsigned i = 0; i < numOperands; i++)
             {
                 Value* operand = GII->getArgOperand(i);
@@ -391,7 +391,7 @@ void ScalarizeFunction::recoverNonScalarizableInst(Instruction* Inst)
     // Iterate over all arguments. Check that they all exist (or rebuilt)
     if (CallInst * CI = dyn_cast<CallInst>(Inst))
     {
-        unsigned numOperands = CI->getNumArgOperands();
+        unsigned numOperands = IGCLLVM::getNumArgOperands(CI);
         for (unsigned i = 0; i < numOperands; i++)
         {
             Value* operand = CI->getArgOperand(i);
diff --git a/IGC/Compiler/PromoteResourceToDirectAS.cpp b/IGC/Compiler/PromoteResourceToDirectAS.cpp
index 4d9ccf20c..b6f6fc3ac 100644
--- a/IGC/Compiler/PromoteResourceToDirectAS.cpp
+++ b/IGC/Compiler/PromoteResourceToDirectAS.cpp
@@ -700,7 +700,7 @@ void PromoteResourceToDirectAS::PromoteBufferToDirectAS(Instruction* inst, Value
 
             args.push_back(sourcePointer);
             args.push_back(bufferAddress);
-            for (unsigned i = 2; i < pIntr->getNumArgOperands(); i++)
+            for (unsigned i = 2; i < IGCLLVM::getNumArgOperands(pIntr); i++)
             {
                 args.push_back(pIntr->getArgOperand(i));
             }
diff --git a/IGC/GenISAIntrinsics/GenIntrinsicInst.h b/IGC/GenISAIntrinsics/GenIntrinsicInst.h
index 50217d0bc..4b4df813f 100644
--- a/IGC/GenISAIntrinsics/GenIntrinsicInst.h
+++ b/IGC/GenISAIntrinsics/GenIntrinsicInst.h
@@ -34,7 +34,6 @@ See LICENSE.TXT for details.
 #include "common/LLVMWarningsPush.hpp"
 #include "llvm/IR/Constants.h"
 #include "llvm/IR/Function.h"
-#include "llvm/IR/Instructions.h"
 #include "llvm/IR/IRBuilder.h"
 #include "llvm/IR/Module.h"
 #include "common/LLVMWarningsPop.hpp"
@@ -44,6 +43,8 @@ See LICENSE.TXT for details.
 #include "GenIntrinsics.h"
 #include "Probe/Assertion.h"
 
+#include "llvmWrapper/IR/Instructions.h"
+
 namespace llvm {
 /// IntrinsicInst - A useful wrapper class for inspecting calls to intrinsic
 /// functions.  This allows the standard isa/dyncast/cast functionality to
@@ -322,19 +323,19 @@ class LdMSIntrinsic : public SamplerLoadIntrinsic {
 public:
     inline Value* getImmOffset(unsigned int i)
     {
-        return getOperand(getNumArgOperands() - 3 + i);
+        return getOperand(arg_size() - 3 + i);
     }
     inline void setImmOffset(unsigned int i, Value* val)
     {
-        return setOperand(getNumArgOperands() - 3 + i, val);
+        return setOperand(arg_size() - 3 + i, val);
     }
     inline Value* getCoordinate(unsigned int i)
     {
-        return getOperand(getNumArgOperands() - 8 + i);
+        return getOperand(arg_size() - 8 + i);
     }
     inline void setCoordinate(unsigned int i, Value* val)
     {
-        return setOperand(getNumArgOperands() - 8 + i, val);
+        return setOperand(arg_size() - 8 + i, val);
     }
     static inline bool classof(const GenIntrinsicInst *I) {
         switch(I->getIntrinsicID()) {
diff --git a/IGC/VectorCompiler/include/vc/GenXCodeGen/TargetMachine.h b/IGC/VectorCompiler/include/vc/GenXCodeGen/TargetMachine.h
index d0ce2942a..9e396ddd2 100644
--- a/IGC/VectorCompiler/include/vc/GenXCodeGen/TargetMachine.h
+++ b/IGC/VectorCompiler/include/vc/GenXCodeGen/TargetMachine.h
@@ -9,7 +9,7 @@ SPDX-License-Identifier: MIT
 #ifndef VC_LIB_GENXCODEGEN_TARGETMACHINE_H
 #define VC_LIB_GENXCODEGEN_TARGETMACHINE_H
 
-#include "llvm/Support/TargetRegistry.h"
+#include "llvmWrapper/Support/TargetRegistry.h"
 
 #include "vc/Support/BackendConfig.h"
 
diff --git a/IGC/VectorCompiler/lib/Driver/Driver.cpp b/IGC/VectorCompiler/lib/Driver/Driver.cpp
index 4294ca813..e355876da 100644
--- a/IGC/VectorCompiler/lib/Driver/Driver.cpp
+++ b/IGC/VectorCompiler/lib/Driver/Driver.cpp
@@ -42,7 +42,6 @@ SPDX-License-Identifier: MIT
 #include "llvm/Support/MemoryBuffer.h"
 #include "llvm/Support/SourceMgr.h"
 #include "llvm/Support/StringSaver.h"
-#include "llvm/Support/TargetRegistry.h"
 #include "llvm/Support/Timer.h"
 #include "llvm/Support/raw_ostream.h"
 #include "llvm/Target/TargetOptions.h"
@@ -51,6 +50,7 @@ SPDX-License-Identifier: MIT
 #include "llvm/Transforms/Scalar.h"
 
 #include "llvmWrapper/Option/OptTable.h"
+#include "llvmWrapper/Support/TargetRegistry.h"
 #include "llvmWrapper/Target/TargetMachine.h"
 
 #include "Probe/Assertion.h"
diff --git a/IGC/VectorCompiler/lib/GenXCodeGen/GenXArgIndirection.cpp b/IGC/VectorCompiler/lib/GenXCodeGen/GenXArgIndirection.cpp
index d56672f6e..92802531b 100644
--- a/IGC/VectorCompiler/lib/GenXCodeGen/GenXArgIndirection.cpp
+++ b/IGC/VectorCompiler/lib/GenXCodeGen/GenXArgIndirection.cpp
@@ -155,13 +155,13 @@ SPDX-License-Identifier: MIT
 #include "llvm/IR/DebugInfo.h"
 #include "llvm/IR/DiagnosticInfo.h"
 #include "llvm/IR/DiagnosticPrinter.h"
-#include "llvm/IR/Instructions.h"
 #include "llvm/IR/LLVMContext.h"
 #include "llvm/IR/ValueHandle.h"
 #include "llvm/Support/CommandLine.h"
 #include "llvm/Support/Debug.h"
 #include "Probe/Assertion.h"
 
+#include "llvmWrapper/IR/Instructions.h"
 #include "llvmWrapper/IR/DerivedTypes.h"
 
 using namespace llvm;
@@ -755,7 +755,7 @@ Indirectability SubroutineArg::checkIndirectability()
   // Create an object of some subclass of ArgIndCallSite for each call site.
   for (auto &U: F->uses()) {
     if (auto *CI = checkFunctionCall(U.getUser(), F)) {
-      IGC_ASSERT(U.getOperandNo() == CI->getNumArgOperands());
+      IGC_ASSERT(U.getOperandNo() == IGCLLVM::getNumArgOperands(CI));
       auto CS = createCallSite(CI);
       if (!CS)
         return Indirectability::CANNOT_INDIRECT;
@@ -1285,7 +1285,7 @@ void SubroutineArg::fixCallSites()
     // can modify the arg being indirected such that the eraseUnusedTree erases
     // the rd-wr sequence that sets up the arg in the old call.
     SmallVector<Value *, 4> Args;
-    for (unsigned oi = 0, oe = CS->CI->getNumArgOperands(); oi != oe; ++oi)
+    for (unsigned oi = 0, oe = IGCLLVM::getNumArgOperands(CS->CI); oi != oe; ++oi)
       Args.push_back(CS->CI->getArgOperand(oi));
     Args.push_back(UndefValue::get(Type::getInt16Ty(CS->CI->getContext())));
     CallInst *OldCI = CS->CI;
@@ -1337,7 +1337,7 @@ Value *CallerIndirectingCallSite::process(GenXArgIndirection *Pass,
 Value *NoOptCallSite::process(GenXArgIndirection *Pass, SubroutineArg *SubrArg)
 {
   unsigned InsertNumber = Pass->Numbering->getArgIndirectionNumber(
-      CI, CI->getNumArgOperands() - 1, 0);
+      CI, IGCLLVM::getNumArgOperands(CI) - 1, 0);
   Instruction *InsertBefore = CI;
   Type *I16Ty = Type::getInt16Ty(CI->getContext());
   // If the arg is undef, we can just use an undef address.
@@ -1400,7 +1400,7 @@ Value *ConstArgRetCallSite::process(GenXArgIndirection *Pass,
   // instruction number of the address arg's pre-copy slot.
   Instruction *InsertBefore = CI;
   unsigned InsertNumber = Pass->Numbering->getArgIndirectionNumber(
-        CI, CI->getNumArgOperands() - 1, 0);
+        CI, IGCLLVM::getNumArgOperands(CI) - 1, 0);
   // Insert a load the constant. Bitcast it to the right type to replace
   // RetEndWr.
   SmallVector<Instruction *, 4> AddedInsts;
@@ -1485,7 +1485,7 @@ Value *IndirectArgCallSite::process(GenXArgIndirection *Pass,
   // instruction number of the address arg's pre-copy slot.
   Instruction *InsertBefore = CI;
   unsigned InsertNumber = Pass->Numbering->getArgIndirectionNumber(CI,
-      CI->getNumArgOperands() - 1, 0);
+      IGCLLVM::getNumArgOperands(CI) - 1, 0);
   Value *AddressArg = nullptr;
   if (isa<Constant>(Index)) {
     // Constant index for the region. Add a convert.addr to load it into an
diff --git a/IGC/VectorCompiler/lib/GenXCodeGen/GenXBaling.cpp b/IGC/VectorCompiler/lib/GenXCodeGen/GenXBaling.cpp
index 0b2d1d482..007929cdd 100644
--- a/IGC/VectorCompiler/lib/GenXCodeGen/GenXBaling.cpp
+++ b/IGC/VectorCompiler/lib/GenXCodeGen/GenXBaling.cpp
@@ -32,7 +32,6 @@ SPDX-License-Identifier: MIT
 #include "llvm/IR/Function.h"
 #include "llvm/IR/IRBuilder.h"
 #include "llvm/IR/InstIterator.h"
-#include "llvm/IR/Instructions.h"
 #include "llvm/IR/Intrinsics.h"
 #include "llvm/IR/Module.h"
 #include "llvm/IR/PatternMatch.h"
@@ -41,6 +40,7 @@ SPDX-License-Identifier: MIT
 #include "llvm/Support/Debug.h"
 #include "llvm/Transforms/Utils/Local.h"
 
+#include "llvmWrapper/IR/Instructions.h"
 #include "llvmWrapper/IR/DerivedTypes.h"
 
 #include "Probe/Assertion.h"
@@ -973,7 +973,7 @@ void GenXBaling::processInlineAsm(Instruction *Inst) {
   IGC_ASSERT_MESSAGE(CI->isInlineAsm(), "Inline Asm expected");
 
   BaleInfo BI(BaleInfo::MAININST);
-  for (unsigned I = 0; I < CI->getNumArgOperands(); I++)
+  for (unsigned I = 0; I < IGCLLVM::getNumArgOperands(CI); I++)
     if (auto RdR = dyn_cast<Instruction>(CI->getArgOperand(I)))
       if (GenXIntrinsic::isRdRegion(RdR)) {
         switch (GenXIntrinsic::getGenXIntrinsicID(RdR->getOperand(0))) {
@@ -1626,7 +1626,7 @@ void GenXBaling::processBranch(BranchInst *Branch)
  */
 void GenXBaling::processTwoAddrSend(CallInst *CI)
 {
-  unsigned TwoAddrOperandNum = CI->getNumArgOperands() - 1;
+  unsigned TwoAddrOperandNum = IGCLLVM::getNumArgOperands(CI) - 1;
   IGC_ASSERT(GenXIntrinsicInfo(vc::getAnyIntrinsicID(CI))
       .getArgInfo(TwoAddrOperandNum)
       .getCategory() == GenXIntrinsicInfo::TWOADDR);
diff --git a/IGC/VectorCompiler/lib/GenXCodeGen/GenXCisaBuilder.cpp b/IGC/VectorCompiler/lib/GenXCodeGen/GenXCisaBuilder.cpp
index 01116c9bf..b4d616a3c 100644
--- a/IGC/VectorCompiler/lib/GenXCodeGen/GenXCisaBuilder.cpp
+++ b/IGC/VectorCompiler/lib/GenXCodeGen/GenXCisaBuilder.cpp
@@ -3424,7 +3424,7 @@ void GenXKernelBuilder::buildIntrinsic(CallInst *CI, unsigned IntrinID,
     unsigned RoundedWidth = roundedVal(Width, 4u);
     Type *DataType = CI->getType();
     if (DataType->isVoidTy())
-      DataType = CI->getOperand(CI->getNumArgOperands() - 1)->getType();
+      DataType = CI->getOperand(IGCLLVM::getNumArgOperands(CI) - 1)->getType();
     unsigned DataSize;
     if (VectorType *VT = dyn_cast<VectorType>(DataType))
       DataSize = DL.getTypeSizeInBits(VT) / genx::ByteBits;
@@ -3691,7 +3691,7 @@ void GenXKernelBuilder::buildIntrinsic(CallInst *CI, unsigned IntrinID,
     auto BaseArg = AI.getArgIdx();
     MaxRawOperands = BaseArg;
 
-    for (unsigned Idx = BaseArg; Idx < CI->getNumArgOperands(); ++Idx) {
+    for (unsigned Idx = BaseArg; Idx < IGCLLVM::getNumArgOperands(CI); ++Idx) {
       if (auto CA = dyn_cast<Constant>(CI->getArgOperand(Idx))) {
         if (CA->isNullValue())
           continue;
@@ -5077,7 +5077,7 @@ bool GenXKernelBuilder::isInLoop(BasicBlock *BB) {
     auto CI = dyn_cast<CallInst>(ui->getUser());
     if (!checkFunctionCall(CI, BBFunc))
       continue;
-    IGC_ASSERT(ui->getOperandNo() == CI->getNumArgOperands());
+    IGC_ASSERT(ui->getOperandNo() == IGCLLVM::getNumArgOperands(CI));
     if (CI->getFunction() == BBFunc)
       continue;
     if (isInLoop(CI->getParent())) {
diff --git a/IGC/VectorCompiler/lib/GenXCodeGen/GenXConstants.cpp b/IGC/VectorCompiler/lib/GenXCodeGen/GenXConstants.cpp
index 14eb2a7fc..a9c895623 100644
--- a/IGC/VectorCompiler/lib/GenXCodeGen/GenXConstants.cpp
+++ b/IGC/VectorCompiler/lib/GenXCodeGen/GenXConstants.cpp
@@ -95,7 +95,7 @@ SPDX-License-Identifier: MIT
 #include "llvm/IR/Dominators.h"
 #include "llvm/IR/Function.h"
 #include "llvm/IR/InstIterator.h"
-#include "llvm/IR/Instructions.h"
+#include "llvmWrapper/IR/Instructions.h"
 #include "llvm/IR/Intrinsics.h"
 #include "llvm/IR/ValueMap.h"
 #include "llvm/Support/Casting.h"
@@ -163,7 +163,7 @@ bool genx::loadNonSimpleConstants(
   unsigned NumArgs = Inst->getNumOperands();
   auto CI = dyn_cast<CallInst>(Inst);
   if (CI)
-    NumArgs = CI->getNumArgOperands();
+    NumArgs = IGCLLVM::getNumArgOperands(CI);
   unsigned IID = vc::getAnyIntrinsicID(Inst);
   // Do not proceed loading of genx.alloca argument since its value doesn't
   // needed (only type matters) and always null.
@@ -346,7 +346,7 @@ bool genx::loadConstants(Instruction *Inst, const GenXSubtarget &Subtarget,
     case GenXIntrinsic::genx_output:
     case GenXIntrinsic::genx_output_1:
       // load all args for subroutine and some intrinsic calls.
-      for (unsigned i = 0, e = CI->getNumArgOperands(); i != e; ++i) {
+      for (unsigned i = 0, e = IGCLLVM::getNumArgOperands(CI); i != e; ++i) {
         U = &CI->getOperandUse(i);
         if (auto C = dyn_cast<Constant>(*U)) {
           if (!isa<UndefValue>(C)) {
diff --git a/IGC/VectorCompiler/lib/GenXCodeGen/GenXIntrinsics.cpp b/IGC/VectorCompiler/lib/GenXCodeGen/GenXIntrinsics.cpp
index 214178f9b..6fc704852 100644
--- a/IGC/VectorCompiler/lib/GenXCodeGen/GenXIntrinsics.cpp
+++ b/IGC/VectorCompiler/lib/GenXCodeGen/GenXIntrinsics.cpp
@@ -22,7 +22,7 @@ SPDX-License-Identifier: MIT
 #include "visa_igc_common_header.h"
 #include "llvm/GenXIntrinsics/GenXIntrinsics.h"
 #include "llvm/IR/Constants.h"
-#include "llvm/IR/Instructions.h"
+#include "llvmWrapper/IR/Instructions.h"
 #include "llvm/IR/Intrinsics.h"
 
 #include "llvmWrapper/IR/DerivedTypes.h"
@@ -82,7 +82,7 @@ unsigned GenXIntrinsicInfo::getTrailingNullZoneStart(CallInst *CI) const {
     return CI->getNumOperands();
   unsigned BaseArg = AI->getArgIdx();
   unsigned TrailingNullStart = BaseArg;
-  for (unsigned Idx = BaseArg; Idx < CI->getNumArgOperands(); ++Idx) {
+  for (unsigned Idx = BaseArg; Idx < IGCLLVM::getNumArgOperands(CI); ++Idx) {
     if (auto CA = dyn_cast<Constant>(CI->getArgOperand(Idx)))
       if (CA->isNullValue())
         continue;
diff --git a/IGC/VectorCompiler/lib/GenXCodeGen/GenXLegalization.cpp b/IGC/VectorCompiler/lib/GenXCodeGen/GenXLegalization.cpp
index 722e97d13..391329e04 100644
--- a/IGC/VectorCompiler/lib/GenXCodeGen/GenXLegalization.cpp
+++ b/IGC/VectorCompiler/lib/GenXCodeGen/GenXLegalization.cpp
@@ -220,7 +220,7 @@ SPDX-License-Identifier: MIT
 #include "llvm/IR/DiagnosticInfo.h"
 #include "llvm/IR/DiagnosticPrinter.h"
 #include "llvm/IR/Function.h"
-#include "llvm/IR/Instructions.h"
+#include "llvmWrapper/IR/Instructions.h"
 #include "llvm/IR/IntrinsicInst.h"
 #include "llvm/IR/Intrinsics.h"
 #include "llvm/IR/Module.h"
@@ -1740,7 +1740,7 @@ unsigned GenXLegalization::determineNonRegionWidth(Instruction *Inst,
   if (!isa<SelectInst>(Inst)) {
     unsigned NumOperands = Inst->getNumOperands();
     if (CallInst *CI = dyn_cast<CallInst>(Inst))
-      NumOperands = CI->getNumArgOperands();
+      NumOperands = IGCLLVM::getNumArgOperands(CI);
     if (NumOperands) {
       IGC_ASSERT_MESSAGE(isa<VectorType>(Inst->getOperand(0)->getType()),
         "instruction not supported");
@@ -2322,7 +2322,7 @@ Value *GenXLegalization::splitInst(Value *PrevSliceRes, BaleInst BInst,
         cast<VectorType>(BInst.Inst->getType())->getElementType(),
         Width * WidthAdjust)); // RetTy
   }
-  for (unsigned i = 0, e = CI->getNumArgOperands(); i != e; ++i) {
+  for (unsigned i = 0, e = IGCLLVM::getNumArgOperands(CI); i != e; ++i) {
     Use *U = &CI->getOperandUse(i);
     if (U == Fixed4) {
       Args.push_back(CI->getArgOperand(i));
diff --git a/IGC/VectorCompiler/lib/GenXCodeGen/GenXLowering.cpp b/IGC/VectorCompiler/lib/GenXCodeGen/GenXLowering.cpp
index 226ae66db..f3bcc780c 100644
--- a/IGC/VectorCompiler/lib/GenXCodeGen/GenXLowering.cpp
+++ b/IGC/VectorCompiler/lib/GenXCodeGen/GenXLowering.cpp
@@ -361,7 +361,7 @@ bool GenXLowering::processTwoAddressOpnd(CallInst *CI) {
     Type *Ty = CI->getArgOperand(*OpNum)->getType();
     IGC_ASSERT_MESSAGE(Ty == CI->getType(), "two address op type out of sync");
 
-    for (unsigned i = 0; i < CI->getNumArgOperands(); ++i) {
+    for (unsigned i = 0; i < IGCLLVM::getNumArgOperands(CI); ++i) {
       auto Op = dyn_cast<Constant>(CI->getArgOperand(i));
       // Check if the predicate operand is all true.
       if (Op && Op->getType()->getScalarSizeInBits() == 1) {
@@ -991,7 +991,7 @@ bool GenXLowering::splitGatherScatter(CallInst *CI, unsigned IID) {
   for (auto CurWidth : Widths) {
     SmallVector<Value *, 8> Args;
     // initialize the args with the old values
-    for (unsigned ArgI = 0; ArgI < CI->getNumArgOperands(); ++ArgI)
+    for (unsigned ArgI = 0; ArgI < IGCLLVM::getNumArgOperands(CI); ++ArgI)
       Args.push_back(CI->getArgOperand(ArgI));
     // Predicate
     if (PredIdx != NONEED) {
@@ -1707,7 +1707,7 @@ bool GenXLowering::widenSIMD8GatherScatter(CallInst *CI, unsigned IID) {
   }
 
   SmallVector<Value *, 8> Args;
-  for (unsigned i = 0; i < CI->getNumArgOperands(); ++i) {
+  for (unsigned i = 0; i < IGCLLVM::getNumArgOperands(CI); ++i) {
     Args.push_back(CI->getArgOperand(i));
   }
   Args[PredIdx] = ExpandPredicate(CI, PredIdx, WidenSIMD);
@@ -3234,7 +3234,7 @@ bool GenXLowering::processInst(Instruction *Inst) {
     unsigned IntrinsicID = GenXIntrinsic::not_any_intrinsic;
     if (Function *Callee = CI->getCalledFunction()) {
       IntrinsicID = vc::getAnyIntrinsicID(Callee);
-      IGC_ASSERT(CI->getNumArgOperands() < GenXIntrinsicInfo::OPNDMASK);
+      IGC_ASSERT(IGCLLVM::getNumArgOperands(CI) < GenXIntrinsicInfo::OPNDMASK);
     }
     if (ST) {
       // use gather/scatter to implement SLM oword load/store on
@@ -5676,7 +5676,7 @@ bool GenXLowering::widenByteOp(Instruction *Inst) {
   // Get the range of operands to process.
   unsigned StartIdx = 0, EndIdx = Inst->getNumOperands();
   if (auto CI = dyn_cast<CallInst>(Inst))
-    EndIdx = CI->getNumArgOperands();
+    EndIdx = IGCLLVM::getNumArgOperands(CI);
   else if (isa<SelectInst>(Inst))
     StartIdx = 1;
   // Extend the operands.
diff --git a/IGC/VectorCompiler/lib/GenXCodeGen/GenXNumbering.cpp b/IGC/VectorCompiler/lib/GenXCodeGen/GenXNumbering.cpp
index 3d36e2905..b5ca3f602 100644
--- a/IGC/VectorCompiler/lib/GenXCodeGen/GenXNumbering.cpp
+++ b/IGC/VectorCompiler/lib/GenXCodeGen/GenXNumbering.cpp
@@ -20,7 +20,7 @@ SPDX-License-Identifier: MIT
 #include "vc/Utils/GenX/KernelInfo.h"
 #include "llvm/IR/BasicBlock.h"
 #include "llvm/IR/Function.h"
-#include "llvm/IR/Instructions.h"
+#include "llvmWrapper/IR/Instructions.h"
 #include "llvm/IR/Intrinsics.h"
 #include "llvm/Support/Debug.h"
 
@@ -120,7 +120,7 @@ unsigned GenXNumbering::numberInstructionsInFunc(Function *Func, unsigned Num)
           // wasting numbers does not really matter.
           PreReserve = 2 * IndexFlattener::getNumArgElements(
                 CI->getFunctionType());
-          PreReserve += 2 * CI->getNumArgOperands(); // extra for pre-copy addresses of args
+          PreReserve += 2 * IGCLLVM::getNumArgOperands(CI); // extra for pre-copy addresses of args
           unsigned NumRetVals = IndexFlattener::getNumElements(CI->getType());
           PreReserve += NumRetVals; // extra for pre-copy addresses of retvals
           PostReserve = NumRetVals;
diff --git a/IGC/VectorCompiler/lib/GenXCodeGen/GenXPatternMatch.cpp b/IGC/VectorCompiler/lib/GenXCodeGen/GenXPatternMatch.cpp
index 66d6fe4ec..29969cc97 100644
--- a/IGC/VectorCompiler/lib/GenXCodeGen/GenXPatternMatch.cpp
+++ b/IGC/VectorCompiler/lib/GenXCodeGen/GenXPatternMatch.cpp
@@ -63,7 +63,7 @@ SPDX-License-Identifier: MIT
 #include "llvm/IR/IRBuilder.h"
 #include "llvm/IR/InstIterator.h"
 #include "llvm/IR/InstVisitor.h"
-#include "llvm/IR/Instructions.h"
+#include "llvmWrapper/IR/Instructions.h"
 #include "llvm/IR/Intrinsics.h"
 #include "llvm/IR/Module.h"
 #include "llvm/IR/PatternMatch.h"
@@ -3279,7 +3279,7 @@ bool GenXPatternMatch::vectorizeConstants(Function *F) {
       unsigned NumOpnds = Inst->getNumOperands();
       auto CI = dyn_cast<CallInst>(Inst);
       if (CI)
-        NumOpnds = CI->getNumArgOperands();
+        NumOpnds = IGCLLVM::getNumArgOperands(CI);
       for (unsigned i = 0, e = NumOpnds; i != e; ++i) {
         auto C = dyn_cast<Constant>(Inst->getOperand(i));
         if (!C || isa<UndefValue>(C))
diff --git a/IGC/VectorCompiler/lib/GenXCodeGen/GenXSimdCFConformance.cpp b/IGC/VectorCompiler/lib/GenXCodeGen/GenXSimdCFConformance.cpp
index 93bb42151..0bccb2753 100644
--- a/IGC/VectorCompiler/lib/GenXCodeGen/GenXSimdCFConformance.cpp
+++ b/IGC/VectorCompiler/lib/GenXCodeGen/GenXSimdCFConformance.cpp
@@ -210,7 +210,7 @@ SPDX-License-Identifier: MIT
 #include "llvm/IR/DiagnosticPrinter.h"
 #include "llvm/IR/Dominators.h"
 #include "llvm/IR/IRBuilder.h"
-#include "llvm/IR/Instructions.h"
+#include "llvmWrapper/IR/Instructions.h"
 #include "llvm/IR/LLVMContext.h"
 #include "llvm/IR/PatternMatch.h"
 #include "llvm/Support/CommandLine.h"
@@ -715,7 +715,7 @@ void GenXSimdCFConformance::gatherGotoJoinEMVals(bool IncludeIncoming)
         if (!GotoJoin)
           continue;
         if (FG && (FGA->getGroup(GotoJoin->getParent()->getParent()) != FG
-            || ui->getOperandNo() != GotoJoin->getNumArgOperands()))
+            || ui->getOperandNo() != IGCLLVM::getNumArgOperands(GotoJoin)))
           continue;
         // We have a goto/join (in our function group in the case of the late
         // pass).  Add the EM value (struct index 0) to EMVals.
@@ -747,7 +747,7 @@ void GenXSimdCFConformance::gatherEMVals()
     if (!Savemask)
       continue;
     if (FG && (FGA->getGroup(Savemask->getParent()->getParent()) != FG ||
-               ui->getOperandNo() != Savemask->getNumArgOperands()))
+               ui->getOperandNo() != IGCLLVM::getNumArgOperands(Savemask)))
       continue;
       lowerSimdCF = true;
     // Add its EM input to EMVals, if not a constant.
@@ -763,7 +763,7 @@ void GenXSimdCFConformance::gatherEMVals()
     if (!Unmask)
       continue;
     if (FG && (FGA->getGroup(Unmask->getParent()->getParent()) != FG ||
-               ui->getOperandNo() != Unmask->getNumArgOperands()))
+               ui->getOperandNo() != IGCLLVM::getNumArgOperands(Unmask)))
       continue;
       lowerSimdCF = true;
     // We have a unmask (in our function group in the case of the late
@@ -777,7 +777,7 @@ void GenXSimdCFConformance::gatherEMVals()
     if (!Remask)
       continue;
     if (FG && (FGA->getGroup(Remask->getParent()->getParent()) != FG ||
-               ui->getOperandNo() != Remask->getNumArgOperands()))
+               ui->getOperandNo() != IGCLLVM::getNumArgOperands(Remask)))
       continue;
       lowerSimdCF = true;
     // We have a remask (in our function group in the case of the late
@@ -1747,7 +1747,7 @@ bool GenXSimdCFConformance::hoistJoin(CallInst *Join)
   // However, if we find such an instruction and it is an extractvalue from the
   // result of an earlier goto/join in a different block, we can just move it
   // to after that goto/join.
-  for (unsigned oi = 0, oe = Join->getNumArgOperands(); oi != oe; ++oi) {
+  for (unsigned oi = 0, oe = IGCLLVM::getNumArgOperands(Join); oi != oe; ++oi) {
     auto Opnd = dyn_cast<Instruction>(Join->getOperand(oi));
     if (!Opnd || isa<PHINode>(Opnd))
       continue;
@@ -2437,7 +2437,7 @@ static bool checkAllUsesAreSelectOrWrRegion(Value *V)
     if (GenXIntrinsic::isWrRegion(IID))
       continue;
     if (IID == GenXIntrinsic::genx_wrpredpredregion
-        && OpNum == cast<CallInst>(User2)->getNumArgOperands() - 1)
+        && OpNum == IGCLLVM::getNumArgOperands(cast<CallInst>(User2)) - 1)
       continue;
     if (GenXIntrinsic::isAnyNonTrivialIntrinsic(IID)
         && !cast<CallInst>(User2)->doesNotAccessMemory())
@@ -2617,7 +2617,7 @@ bool GenXSimdCFConformance::getConnectedVals(
         // about that.
         auto ValTy = IndexFlattener::getElementType(
             Val.getType(), Val.getIndex());
-        for (unsigned Idx = 0, End = CI->getNumArgOperands(); ; ++Idx) {
+        for (unsigned Idx = 0, End = IGCLLVM::getNumArgOperands(CI); ; ++Idx) {
           if (Idx == End)
             return false; // no corresponding call arg found
           if (CI->getArgOperand(Idx)->getType() == ValTy) {
@@ -2778,7 +2778,7 @@ bool GenXSimdCFConformance::getConnectedVals(
           break;
         case GenXIntrinsic::genx_wrpredpredregion:
           // Use in wrpredpredregion allowed as the last arg.
-          if (ui->getOperandNo() + 1 != CI->getNumArgOperands())
+          if (ui->getOperandNo() + 1 != IGCLLVM::getNumArgOperands(CI))
             UsersToLower.push_back(SimpleValue(User, ui->getOperandNo()));
           break;
         default:
@@ -3697,7 +3697,7 @@ void GenXSimdCFConformance::replaceGotoJoinUses(CallInst *GotoJoin,
           continue;
         unsigned NumOperands = I->getNumOperands();
         if (auto CI = dyn_cast<CallInst>(I))
-          NumOperands = CI->getNumArgOperands();
+          NumOperands = IGCLLVM::getNumArgOperands(CI);
         V = nullptr;
         if (NumOperands == 1)
           V = I->getOperand(0);
diff --git a/IGC/VectorCompiler/lib/GenXCodeGen/GenXTargetMachine.cpp b/IGC/VectorCompiler/lib/GenXCodeGen/GenXTargetMachine.cpp
index 786d81032..b4ac569fb 100644
--- a/IGC/VectorCompiler/lib/GenXCodeGen/GenXTargetMachine.cpp
+++ b/IGC/VectorCompiler/lib/GenXCodeGen/GenXTargetMachine.cpp
@@ -55,7 +55,7 @@ SPDX-License-Identifier: MIT
 #include "llvm/Pass.h"
 #include "llvm/PassRegistry.h"
 #include "llvm/Support/CommandLine.h"
-#include "llvm/Support/TargetRegistry.h"
+#include "llvmWrapper/Support/TargetRegistry.h"
 #include "llvm/Transforms/IPO.h"
 #include "llvm/Transforms/IPO/AlwaysInliner.h"
 #include "llvm/Transforms/IPO/PassManagerBuilder.h"
diff --git a/IGC/VectorCompiler/lib/GenXCodeGen/GenXThreadPrivateMemory.cpp b/IGC/VectorCompiler/lib/GenXCodeGen/GenXThreadPrivateMemory.cpp
index ac2b68376..27e4630c6 100644
--- a/IGC/VectorCompiler/lib/GenXCodeGen/GenXThreadPrivateMemory.cpp
+++ b/IGC/VectorCompiler/lib/GenXCodeGen/GenXThreadPrivateMemory.cpp
@@ -1402,7 +1402,7 @@ bool GenXThreadPrivateMemory::processUsers() {
         Changed = true;
       } else if (ID == GenXIntrinsic::not_any_intrinsic) {
         if (m_Calls[CI->getCalledFunction()].Calls.count(CI) > 0) {
-          for (unsigned i = 0; i < CI->getNumArgOperands(); i++) {
+          for (unsigned i = 0; i < IGCLLVM::getNumArgOperands(CI); i++) {
             if (m_Calls[CI->getCalledFunction()].Args.count(
                     IGCLLVM::getArg(*CI->getCalledFunction(), i)) > 0)
               CI->replaceUsesOfWith(
diff --git a/IGC/VectorCompiler/lib/GenXCodeGen/GenXUtil.cpp b/IGC/VectorCompiler/lib/GenXCodeGen/GenXUtil.cpp
index 9e705bc8c..bcc79f037 100644
--- a/IGC/VectorCompiler/lib/GenXCodeGen/GenXUtil.cpp
+++ b/IGC/VectorCompiler/lib/GenXCodeGen/GenXUtil.cpp
@@ -30,7 +30,7 @@ SPDX-License-Identifier: MIT
 #include "llvm/IR/Dominators.h"
 #include "llvm/IR/Function.h"
 #include "llvm/IR/IRBuilder.h"
-#include "llvm/IR/Instructions.h"
+#include "llvmWrapper/IR/Instructions.h"
 #include "llvm/IR/IntrinsicInst.h"
 #include "llvm/IR/Intrinsics.h"
 #include "llvm/IR/Metadata.h"
@@ -292,7 +292,7 @@ llvm::Optional<unsigned> genx::getTwoAddressOperandNum(CallInst *CI)
   if (CI->getType()->isVoidTy())
     return None; // no return value
   GenXIntrinsicInfo II(IntrinsicID);
-  unsigned Num = CI->getNumArgOperands();
+  unsigned Num = IGCLLVM::getNumArgOperands(CI);
   if (!Num)
     return None; // no args
   --Num; // Num = last arg number, could be two address operand
diff --git a/IGC/VectorCompiler/lib/GenXCodeGen/TargetInfo/GenXTargetInfo.cpp b/IGC/VectorCompiler/lib/GenXCodeGen/TargetInfo/GenXTargetInfo.cpp
index f069d22e8..6ec992891 100644
--- a/IGC/VectorCompiler/lib/GenXCodeGen/TargetInfo/GenXTargetInfo.cpp
+++ b/IGC/VectorCompiler/lib/GenXCodeGen/TargetInfo/GenXTargetInfo.cpp
@@ -8,7 +8,7 @@ SPDX-License-Identifier: MIT
 
 #include "GenXTargetInfo.h"
 
-#include "llvm/Support/TargetRegistry.h"
+#include "llvmWrapper/Support/TargetRegistry.h"
 
 using namespace llvm;
 
diff --git a/IGC/VectorCompiler/lib/GenXOpts/CMAnalysis/ConstantFoldingGenX.cpp b/IGC/VectorCompiler/lib/GenXOpts/CMAnalysis/ConstantFoldingGenX.cpp
index 7088b4653..f1aa93171 100644
--- a/IGC/VectorCompiler/lib/GenXOpts/CMAnalysis/ConstantFoldingGenX.cpp
+++ b/IGC/VectorCompiler/lib/GenXOpts/CMAnalysis/ConstantFoldingGenX.cpp
@@ -26,6 +26,7 @@ SPDX-License-Identifier: MIT
 #include "llvmWrapper/Analysis/CallGraph.h"
 #include "llvmWrapper/IR/DerivedTypes.h"
 #include "llvmWrapper/IR/CallSite.h"
+#include "llvmWrapper/IR/Instructions.h"
 
 #define DEBUG_TYPE "genx-constantfolding"
 
@@ -255,7 +256,7 @@ Constant *llvm::ConstantFoldGenX(Instruction *I, const DataLayout &DL) {
     return nullptr;
 
   SmallVector<Constant *, 4> ConstantArgs;
-  ConstantArgs.reserve(CS.getNumArgOperands());
+  ConstantArgs.reserve(IGCLLVM::getNumArgOperands(&CS));
   auto FoldOperand = [&DL](const Use &A) {
     auto *C = cast<Constant>(A.get());
     Constant *Folded = ConstantFoldConstant(C, DL);
diff --git a/IGC/VectorCompiler/lib/GenXOpts/CMAnalysis/InstructionSimplifyGenX.cpp b/IGC/VectorCompiler/lib/GenXOpts/CMAnalysis/InstructionSimplifyGenX.cpp
index 1ba4b8d21..bf5c30ab8 100644
--- a/IGC/VectorCompiler/lib/GenXOpts/CMAnalysis/InstructionSimplifyGenX.cpp
+++ b/IGC/VectorCompiler/lib/GenXOpts/CMAnalysis/InstructionSimplifyGenX.cpp
@@ -537,7 +537,7 @@ bool GenXSimplify::simplifyGenXLscAtomic(CallInst &CI,
 
   LLVM_DEBUG(dbgs() << "processing <lsc atomic>: " << CI << "\n");
 
-  if (!isa<UndefValue>(CI.getArgOperand(CI.getNumArgOperands() - 1))) {
+  if (!isa<UndefValue>(CI.getArgOperand(IGCLLVM::getNumArgOperands(&CI) - 1))) {
     LLVM_DEBUG(dbgs() << "  skipping as instruction already has some " <<
                "\"previous value\" set\n");
     return false;
@@ -597,7 +597,7 @@ bool GenXSimplify::simplifyGenXLscAtomic(CallInst &CI,
     LLVM_DEBUG(dbgs() << "previous value does not dominate candidate!\n");
     return false;
   }
-  CI.setArgOperand(CI.getNumArgOperands() - 1, PrevValue);
+  CI.setArgOperand(IGCLLVM::getNumArgOperands(&CI) - 1, PrevValue);
 
   Select->replaceAllUsesWith(&CI);
   Select->eraseFromParent();
diff --git a/IGC/VectorCompiler/lib/GenXOpts/CMTrans/CMABI.cpp b/IGC/VectorCompiler/lib/GenXOpts/CMTrans/CMABI.cpp
index b4336aea5..7650aa460 100644
--- a/IGC/VectorCompiler/lib/GenXOpts/CMTrans/CMABI.cpp
+++ b/IGC/VectorCompiler/lib/GenXOpts/CMTrans/CMABI.cpp
@@ -365,7 +365,7 @@ bool CMABI::runOnSCC(CallGraphSCC &SCC) {
       continue;
     for (auto ui = F->use_begin(), ue = F->use_end(); ui != ue; ++ui) {
       auto CI = dyn_cast<CallInst>(ui->getUser());
-      if (CI && CI->getNumArgOperands() == ui->getOperandNo())
+      if (CI && IGCLLVM::getNumArgOperands(CI) == ui->getOperandNo())
         diagnoseOverlappingArgs(CI);
     }
   }
@@ -712,7 +712,7 @@ void CMABI::diagnoseOverlappingArgs(CallInst *CI)
   std::set<std::pair<unsigned, unsigned>> Reported;
   // Using ArgIndex starting at 1 so we can reserve 0 to mean "element does not
   // come from any by-ref arg".
-  for (unsigned ArgIndex = 1, NumArgs = CI->getNumArgOperands();
+  for (unsigned ArgIndex = 1, NumArgs = IGCLLVM::getNumArgOperands(CI);
       ArgIndex <= NumArgs; ++ArgIndex) {
     Value *Arg = CI->getOperand(ArgIndex - 1);
     if (!Arg->getType()->isPointerTy())
diff --git a/IGC/VectorCompiler/lib/GenXOpts/CMTrans/GenXImportOCLBiF.cpp b/IGC/VectorCompiler/lib/GenXOpts/CMTrans/GenXImportOCLBiF.cpp
index f91e419d0..f669e3157 100644
--- a/IGC/VectorCompiler/lib/GenXOpts/CMTrans/GenXImportOCLBiF.cpp
+++ b/IGC/VectorCompiler/lib/GenXOpts/CMTrans/GenXImportOCLBiF.cpp
@@ -248,7 +248,7 @@ void BIConvert::runOnModule(Module &M) {
           tys0[0] = InstCall->getArgOperand(0)->getType();
           // build argument list for the 1st intrinsic
           args0.append(InstCall->op_begin(),
-                       InstCall->op_begin() + InstCall->getNumArgOperands());
+                       InstCall->op_begin() + IGCLLVM::getNumArgOperands(InstCall));
           Function *IntrinFunc0 =
               GenXIntrinsic::getAnyDeclaration(&M, pair.first, tys0);
           Instruction *IntrinCall0 = CallInst::Create(
@@ -396,7 +396,7 @@ static void removeFunctionBitcasts(Module &M) {
             }
 
             std::vector<Value *> Args;
-            for (unsigned I = 0, E = pInstCall->getNumArgOperands(); I != E;
+            for (unsigned I = 0, E = IGCLLVM::getNumArgOperands(pInstCall); I != E;
                  ++I) {
               Args.push_back(pInstCall->getArgOperand(I));
             }
diff --git a/IGC/VectorCompiler/lib/GenXOpts/CMTrans/GenXPrintfResolution.cpp b/IGC/VectorCompiler/lib/GenXOpts/CMTrans/GenXPrintfResolution.cpp
index 3e637bcd8..dde297742 100644
--- a/IGC/VectorCompiler/lib/GenXOpts/CMTrans/GenXPrintfResolution.cpp
+++ b/IGC/VectorCompiler/lib/GenXOpts/CMTrans/GenXPrintfResolution.cpp
@@ -39,7 +39,6 @@ SPDX-License-Identifier: MIT
 #include <llvm/IR/DataLayout.h>
 #include <llvm/IR/IRBuilder.h>
 #include <llvm/IR/InstIterator.h>
-#include <llvm/IR/Instructions.h>
 #include <llvm/IR/Module.h>
 #include <llvm/Linker/Linker.h>
 #include <llvm/Pass.h>
@@ -47,6 +46,7 @@ SPDX-License-Identifier: MIT
 
 #include "llvmWrapper/IR/DerivedTypes.h"
 #include "llvmWrapper/IR/Operator.h"
+#include "llvmWrapper/IR/Instructions.h"
 
 #include <algorithm>
 #include <functional>
@@ -292,7 +292,7 @@ void GenXPrintfResolution::handlePrintfCall(CallInst &OrigPrintf) {
   assertPrintfCall(OrigPrintf);
   auto [FmtStrSize, ArgsInfo] =
       analyzeFormatString(*OrigPrintf.getArgOperand(0));
-  if (ArgsInfo.size() != OrigPrintf.getNumArgOperands() - 1)
+  if (ArgsInfo.size() != IGCLLVM::getNumArgOperands(&OrigPrintf) - 1)
     vc::fatal(OrigPrintf.getContext(), "GenXPrintfResolution",
               "printf format string and arguments don't correspond");
 
diff --git a/IGC/VectorCompiler/lib/Utils/GenX/Region.cpp b/IGC/VectorCompiler/lib/Utils/GenX/Region.cpp
index 1d825ea8c..f06f74ec3 100644
--- a/IGC/VectorCompiler/lib/Utils/GenX/Region.cpp
+++ b/IGC/VectorCompiler/lib/Utils/GenX/Region.cpp
@@ -25,7 +25,7 @@ SPDX-License-Identifier: MIT
 #include "llvm/IR/Constants.h"
 #include "llvm/IR/DerivedTypes.h"
 #include "llvm/IR/Function.h"
-#include "llvm/IR/Instructions.h"
+#include "llvmWrapper/IR/Instructions.h"
 #include "llvm/IR/IntrinsicInst.h"
 #include "llvm/IR/Intrinsics.h"
 #include "llvm/Support/Debug.h"
@@ -556,13 +556,13 @@ void CMRegion::setRegionCalledFunc(Instruction *Inst)
 {
   auto CI = cast<CallInst>(Inst);
   SmallVector<Value *, 8> Opnds;
-  for (unsigned i = 0, e = CI->getNumArgOperands(); i != e; ++i)
+  for (unsigned i = 0, e = IGCLLVM::getNumArgOperands(CI); i != e; ++i)
     Opnds.push_back(CI->getOperand(i));
   Function *Decl = getGenXRegionDeclaration(
       Inst->getParent()->getParent()->getParent(),
       GenXIntrinsic::getGenXIntrinsicID(Inst),
       Inst->getType(), Opnds);
-  CI->setOperand(CI->getNumArgOperands(), Decl);
+  CI->setOperand(IGCLLVM::getNumArgOperands(CI), Decl);
 }
 
 /***********************************************************************
diff --git a/IGC/VectorCompiler/lib/Utils/GenX/TransformArgCopy.cpp b/IGC/VectorCompiler/lib/Utils/GenX/TransformArgCopy.cpp
index b94632206..b74416508 100644
--- a/IGC/VectorCompiler/lib/Utils/GenX/TransformArgCopy.cpp
+++ b/IGC/VectorCompiler/lib/Utils/GenX/TransformArgCopy.cpp
@@ -499,7 +499,7 @@ getTransformedFuncCallArgs(CallInst &OrigCall,
 static AttributeList
 inheritCallAttributes(CallInst &OrigCall, int NumOrigFuncArgs,
                       const TransformedFuncInfo &NewFuncInfo) {
-  IGC_ASSERT_MESSAGE(OrigCall.getNumArgOperands() == NumOrigFuncArgs,
+  IGC_ASSERT_MESSAGE(IGCLLVM::getNumArgOperands(&OrigCall) == NumOrigFuncArgs,
                      "varargs aren't supported");
 
   const AttributeList &CallPAL = OrigCall.getAttributes();
diff --git a/IGC/WrapperLLVM/include/llvmWrapper/IR/Instructions.h b/IGC/WrapperLLVM/include/llvmWrapper/IR/Instructions.h
index 1e6db9344..a0dda4a30 100644
--- a/IGC/WrapperLLVM/include/llvmWrapper/IR/Instructions.h
+++ b/IGC/WrapperLLVM/include/llvmWrapper/IR/Instructions.h
@@ -80,6 +80,15 @@ namespace IGCLLVM
 #endif
     }
 
+    inline unsigned getNumArgOperands(const llvm::CallInst* CI)
+    {
+#if LLVM_VERSION_MAJOR < 14
+       return CI->getNumArgOperands();
+#else
+       return CI->arg_size();
+#endif
+    }
+
     inline unsigned getArgOperandNo(llvm::CallInst &CI, const llvm::Use *U) {
 #if LLVM_VERSION_MAJOR < 10
       IGC_ASSERT_MESSAGE(CI.isArgOperand(U), "Arg operand # out of range!");
diff --git a/IGC/WrapperLLVM/include/llvmWrapper/MC/MCContext.h b/IGC/WrapperLLVM/include/llvmWrapper/MC/MCContext.h
index 3725864ef..3b4abc1cf 100644
--- a/IGC/WrapperLLVM/include/llvmWrapper/MC/MCContext.h
+++ b/IGC/WrapperLLVM/include/llvmWrapper/MC/MCContext.h
@@ -11,7 +11,7 @@ SPDX-License-Identifier: MIT
 
 #include "llvm/Config/llvm-config.h"
 #include "llvm/MC/MCContext.h"
-#include "llvm/Support/TargetRegistry.h"
+#include "llvmWrapper/Support/TargetRegistry.h"
 
 namespace IGCLLVM
 {
diff --git a/IGC/WrapperLLVM/include/llvmWrapper/Support/TargetRegistry.h b/IGC/WrapperLLVM/include/llvmWrapper/Support/TargetRegistry.h
new file mode 100644
index 000000000..f506655b0
--- /dev/null
+++ b/IGC/WrapperLLVM/include/llvmWrapper/Support/TargetRegistry.h
@@ -0,0 +1,20 @@
+/*========================== begin_copyright_notice ============================
+
+Copyright (C) 2018-2022 Intel Corporation
+
+SPDX-License-Identifier: MIT
+
+============================= end_copyright_notice ===========================*/
+
+#ifndef IGCLLVM_SUPPORT_TARGETREGISTRY_H
+#define IGCLLVM_SUPPORT_TARGETREGISTRY_H
+
+#include "llvm/Config/llvm-config.h"
+
+#if LLVM_VERSION_MAJOR < 14
+#include "llvm/Support/TargetRegistry.h"
+#else
+#include "llvm/MC/TargetRegistry.h"
+#endif
+
+#endif
diff --git a/IGC/WrapperLLVM/include/llvmWrapper/Transforms/Scalar.h b/IGC/WrapperLLVM/include/llvmWrapper/Transforms/Scalar.h
index 022141d15..35faa703d 100644
--- a/IGC/WrapperLLVM/include/llvmWrapper/Transforms/Scalar.h
+++ b/IGC/WrapperLLVM/include/llvmWrapper/Transforms/Scalar.h
@@ -26,7 +26,7 @@ namespace IGCLLVM
     {
         return llvm::createLoopUnrollPass(OptLevel, false, Threshold, Count, AllowPartial, Runtime, UpperBound, AllowPeeling);
     }
-#elif LLVM_VERSION_MAJOR >= 9 && LLVM_VERSION_MAJOR <= 13
+#elif LLVM_VERSION_MAJOR >= 9 && LLVM_VERSION_MAJOR <= 14
     inline static llvm::Pass * createLoopUnrollPass(
         int OptLevel = 2, int Threshold = -1, int Count = -1,
         int AllowPartial = -1, int Runtime = -1,
diff --git a/IGC/common/IGCIRBuilder.h b/IGC/common/IGCIRBuilder.h
index 6e319308d..d1d5f4ceb 100644
--- a/IGC/common/IGCIRBuilder.h
+++ b/IGC/common/IGCIRBuilder.h
@@ -11,7 +11,6 @@ SPDX-License-Identifier: MIT
 #include "common/LLVMWarningsPush.hpp"
 #include "llvmWrapper/IR/IRBuilder.h"
 #include "llvm/ADT/ArrayRef.h"
-#include "llvm/IR/Instructions.h"
 #include "llvm/IR/Intrinsics.h"
 #include "llvm/IR/LLVMContext.h"
 #include "llvm/ADT/Twine.h"
@@ -23,6 +22,8 @@ SPDX-License-Identifier: MIT
 #include "common/LLVMWarningsPop.hpp"
 #include "GenISAIntrinsics/GenIntrinsics.h"
 
+#include "llvmWrapper/IR/Instructions.h"
+
 //This Builder class provides definitions for functions calls that were once available till LLVM version 3.6.0
 //===--------------------------------------------------------------------===
 // CreateCall Variations which are removed in 3.8 for API Simplification, which IGC still finds convenient to use
-- 
2.36.0

