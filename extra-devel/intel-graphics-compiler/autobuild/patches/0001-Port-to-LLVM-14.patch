From 419ad88730b9b40ebff30fa273a7dcdb2158e39b Mon Sep 17 00:00:00 2001
From: liushuyu <liushuyu011@gmail.com>
Date: Wed, 27 Apr 2022 17:59:09 -0600
Subject: [PATCH] Port to LLVM 14

Signed-off-by: Zixing Liu <liushuyu011@gmail.com>
---
 IGC/AdaptorCommon/AddImplicitArgs.cpp         |   2 +-
 .../LegalizeFunctionSignatures.cpp            |   9 +-
 IGC/AdaptorCommon/ProcessFuncAttributes.cpp   |   7 +-
 IGC/AdaptorCommon/RayTracing/RTBuilder.cpp    |  13 +-
 IGC/AdaptorOCL/SPIRV/SPIRVReader.cpp          |   7 +-
 IGC/AdaptorOCL/SPIRV/SPIRVUtil.cpp            |   4 +-
 IGC/AdaptorOCL/UnifyIROCL.cpp                 |   3 +-
 IGC/Compiler/CISACodeGen/CheckInstrTypes.cpp  |   2 +-
 IGC/Compiler/CISACodeGen/CodeSinking.cpp      |   3 +-
 IGC/Compiler/CISACodeGen/DebugInfo.cpp        |   3 +-
 IGC/Compiler/CISACodeGen/EmitVISAPass.cpp     |  24 +--
 IGC/Compiler/CISACodeGen/EmitVISAPass.hpp     |   2 +-
 IGC/Compiler/CISACodeGen/Emu64OpsPass.cpp     |   4 +-
 IGC/Compiler/CISACodeGen/GenCodeGenModule.cpp |   4 +-
 IGC/Compiler/CISACodeGen/HFfoldingOpt.cpp     |   3 +-
 IGC/Compiler/CISACodeGen/HalfPromotion.cpp    |   4 +-
 .../CISACodeGen/OpenCLKernelCodeGen.cpp       |   2 +-
 IGC/Compiler/CISACodeGen/PatternMatchPass.hpp |   3 +-
 .../CISACodeGen/PixelShaderLowering.cpp       |   2 +-
 IGC/Compiler/CISACodeGen/ResolveGAS.cpp       |   4 +-
 IGC/Compiler/CISACodeGen/SLMConstProp.cpp     |   2 +-
 IGC/Compiler/CISACodeGen/VectorProcess.cpp    |   2 +-
 IGC/Compiler/CISACodeGen/WIAnalysis.cpp       |   2 +-
 IGC/Compiler/CISACodeGen/helper.cpp           |   2 +-
 IGC/Compiler/CustomSafeOptPass.cpp            |   3 +-
 IGC/Compiler/GenTTI.cpp                       |   6 +-
 IGC/Compiler/GenTTI.h                         |   6 +-
 IGC/Compiler/LowPrecisionOptPass.cpp          |   4 +-
 IGC/Compiler/Optimizer/BuiltInFuncImport.cpp  |  18 +-
 .../IGCInstCombiner/4.0/InstCombineCalls.cpp  |  12 +-
 .../IGCInstCombiner/7.0/InstCombineCalls.cpp  |  12 +-
 .../7.0/InstCombineSimplifyDemanded.cpp       |   2 +-
 .../IGCInstructionCombining.hpp               |   2 +-
 .../Optimizer/IndirectCallOptimization.cpp    |   2 +-
 .../Optimizer/IntDivConstantReduction.cpp     |  32 +--
 IGC/Compiler/Optimizer/OCLBIUtils.cpp         |  14 +-
 .../AlignmentAnalysis/AlignmentAnalysis.cpp   | 192 +++++++++---------
 .../AlignmentAnalysis/AlignmentAnalysis.hpp   |   4 +-
 .../Atomics/ResolveOCLAtomics.cpp             |   2 +-
 .../DebuggerSupport/ImplicitGIDPass.cpp       |   4 +-
 .../DeviceEnqueueFuncs/DeviceEnqueue.cpp      |   4 +-
 .../DeviceEnqueueFuncs/TransformBlocks.cpp    |  19 +-
 .../ExtensionFuncResolution.cpp               |   4 +-
 .../GenericAddressDynamicResolution.cpp       |   2 +-
 .../ImageFuncs/ImageFuncsAnalysis.cpp         |   2 +-
 .../ResolveSampledImageBuiltins.cpp           |   5 +-
 .../OpenCLPrintf/OpenCLPrintfResolution.cpp   |   2 +-
 .../ResolveOCLRaytracingBuiltins.cpp          |   2 +-
 .../ReplaceUnsupportedIntrinsics.cpp          |   2 +-
 .../TransformUnmaskedFunctionsPass.cpp        |   7 +-
 .../Optimizer/PreCompiledFuncImport.cpp       |   8 +-
 IGC/Compiler/Optimizer/Scalarizer.cpp         |   4 +-
 IGC/Compiler/PromoteResourceToDirectAS.cpp    |   2 +-
 IGC/DebugInfo/StreamEmitter.cpp               |  16 +-
 IGC/GenISAIntrinsics/GenIntrinsicInst.h       |  11 +-
 .../BuiltinsFrontendDefinitions.hpp           |   9 +-
 .../CMCL/tools/Translator/Main.cpp            |   1 +
 .../include/vc/GenXCodeGen/TargetMachine.h    |   2 +-
 .../include/vc/Support/GenXDiagnostic.h       |   2 +-
 IGC/VectorCompiler/lib/Driver/Driver.cpp      |   2 +-
 .../lib/GenXCodeGen/GenXArgIndirection.cpp    |  12 +-
 .../lib/GenXCodeGen/GenXBaling.cpp            |   6 +-
 .../lib/GenXCodeGen/GenXCisaBuilder.cpp       |  12 +-
 .../lib/GenXCodeGen/GenXCoalescing.cpp        |   3 +-
 .../lib/GenXCodeGen/GenXConstants.cpp         |   6 +-
 .../lib/GenXCodeGen/GenXDepressurizer.cpp     |   3 +-
 .../lib/GenXCodeGen/GenXEmulate.cpp           |   3 +-
 .../lib/GenXCodeGen/GenXIntrinsics.cpp        |   4 +-
 .../lib/GenXCodeGen/GenXLegalization.cpp      |   6 +-
 .../lib/GenXCodeGen/GenXLowering.cpp          |  13 +-
 .../lib/GenXCodeGen/GenXNumbering.cpp         |   4 +-
 .../lib/GenXCodeGen/GenXPatternMatch.cpp      |  26 +--
 .../GenXCodeGen/GenXPrologEpilogInsertion.cpp |   6 +-
 .../lib/GenXCodeGen/GenXPromotePredicate.cpp  |   3 +-
 .../GenXPromoteStatefulToBindless.cpp         |   2 +-
 .../lib/GenXCodeGen/GenXSimdCFConformance.cpp |  20 +-
 .../lib/GenXCodeGen/GenXStackUsage.cpp        |   7 +-
 .../lib/GenXCodeGen/GenXTargetMachine.cpp     |   2 +-
 .../lib/GenXCodeGen/GenXTargetMachine.h       |   6 +-
 .../GenXCodeGen/GenXThreadPrivateMemory.cpp   |   2 +-
 .../lib/GenXCodeGen/GenXUtil.cpp              |   4 +-
 .../lib/GenXCodeGen/GenXVectorCombiner.cpp    |   3 +-
 IGC/VectorCompiler/lib/GenXCodeGen/GenXVisa.h |   3 +-
 .../GenXCodeGen/TargetInfo/GenXTargetInfo.cpp |   2 +-
 .../CMAnalysis/ConstantFoldingGenX.cpp        |   3 +-
 .../CMAnalysis/InstructionSimplifyGenX.cpp    |   4 +-
 .../GenXOpts/CMPacketize/GenXPacketize.cpp    |   2 +-
 .../lib/GenXOpts/CMTrans/CMABI.cpp            |  20 +-
 .../lib/GenXOpts/CMTrans/CMImpParam.cpp       |  11 +-
 .../lib/GenXOpts/CMTrans/GenXImportOCLBiF.cpp |   4 +-
 .../GenXOpts/CMTrans/GenXPrintfResolution.cpp |   4 +-
 .../lib/Support/BackendConfig.cpp             |   4 +-
 IGC/VectorCompiler/lib/Utils/GenX/Region.cpp  |   6 +-
 .../lib/Utils/GenX/TransformArgCopy.cpp       |  15 +-
 IGC/VectorCompiler/lib/Utils/General/BiF.cpp  |   2 +-
 .../lib/Utils/General/DebugInfo.cpp           |  12 +-
 .../utils/vcb/UniqueCompilation.cpp           |   4 +-
 IGC/VectorCompiler/utils/vcb/vcb.cpp          |   4 +-
 IGC/WrapperLLVM/CMakeLists.txt                |   8 +
 .../include/lldWrapper/Common/Driver.h        |   4 +-
 .../include/llvmWrapper/ADT/APInt.h           |  84 ++++++++
 .../include/llvmWrapper/IR/Attributes.h       |  86 ++++++++
 .../include/llvmWrapper/IR/ConstantFolder.h   | 180 +++++++++++-----
 .../include/llvmWrapper/IR/Function.h         |  16 ++
 .../include/llvmWrapper/IR/IRBuilder.h        |   8 +
 .../include/llvmWrapper/IR/InstrTypes.h       |  18 ++
 .../include/llvmWrapper/IR/Instructions.h     |  18 ++
 .../include/llvmWrapper/MC/MCContext.h        |   2 +-
 .../include/llvmWrapper/MC/MCStreamer.h       |  25 +++
 .../include/llvmWrapper/Support/Alignment.h   |   6 +
 .../llvmWrapper/Support/TargetRegistry.h      |  20 ++
 .../InstCombine/InstCombineWorklist.h         |  19 ++
 .../include/llvmWrapper/Transforms/Scalar.h   |   2 +-
 IGC/common/IGCIRBuilder.h                     |   2 +-
 IGC/common/debug/Debug.cpp                    |  12 ++
 115 files changed, 882 insertions(+), 415 deletions(-)
 create mode 100644 IGC/WrapperLLVM/include/llvmWrapper/ADT/APInt.h
 create mode 100644 IGC/WrapperLLVM/include/llvmWrapper/IR/Attributes.h
 create mode 100644 IGC/WrapperLLVM/include/llvmWrapper/MC/MCStreamer.h
 create mode 100644 IGC/WrapperLLVM/include/llvmWrapper/Support/TargetRegistry.h
 create mode 100644 IGC/WrapperLLVM/include/llvmWrapper/Transforms/InstCombine/InstCombineWorklist.h

diff --git a/IGC/AdaptorCommon/AddImplicitArgs.cpp b/IGC/AdaptorCommon/AddImplicitArgs.cpp
index 3c4668a74..3e4959ae4 100644
--- a/IGC/AdaptorCommon/AddImplicitArgs.cpp
+++ b/IGC/AdaptorCommon/AddImplicitArgs.cpp
@@ -374,7 +374,7 @@ void AddImplicitArgs::replaceAllUsesWithNewOCLBuiltinFunction(llvm::Function* ol
 
         std::vector<Value*> new_args;
         Function *parent_func = cInst->getParent()->getParent();
-        size_t numArgOperands = cInst->getNumArgOperands();
+        size_t numArgOperands = IGCLLVM::getNumArgOperands(cInst);
 
         // let's prepare argument list on new call function
         llvm::Function::arg_iterator new_arg_iter = new_func->arg_begin();
diff --git a/IGC/AdaptorCommon/LegalizeFunctionSignatures.cpp b/IGC/AdaptorCommon/LegalizeFunctionSignatures.cpp
index fc83d8005..9554b4522 100644
--- a/IGC/AdaptorCommon/LegalizeFunctionSignatures.cpp
+++ b/IGC/AdaptorCommon/LegalizeFunctionSignatures.cpp
@@ -12,6 +12,7 @@ SPDX-License-Identifier: MIT
 #include "Compiler/CISACodeGen/helper.h"
 #include "Compiler/CodeGenPublic.h"
 #include "common/LLVMWarningsPush.hpp"
+#include "llvmWrapper/IR/Attributes.h"
 #include "llvmWrapper/IR/DerivedTypes.h"
 #include <llvmWrapper/IR/Instructions.h>
 #include <llvm/IR/Module.h>
@@ -541,7 +542,7 @@ void LegalizeFunctionSignatures::FixCallInstruction(Module& M, CallInst* callIns
     // Check return type
     Value* returnPtr = nullptr;
     if (callInst->getType()->isVoidTy() &&
-        callInst->getNumArgOperands() > 0 &&
+        IGCLLVM::getNumArgOperands(callInst) > 0 &&
         callInst->paramHasAttr(0, llvm::Attribute::StructRet) &&
         isPromotableStructType(M, callInst->getArgOperand(0)->getType(), isStackCall, true /* retval */))
     {
@@ -563,7 +564,7 @@ void LegalizeFunctionSignatures::FixCallInstruction(Module& M, CallInst* callIns
     }
 
     // Check call operands if it needs to be replaced
-    for (; opNum < callInst->getNumArgOperands(); opNum++)
+    for (; opNum < IGCLLVM::getNumArgOperands(callInst); opNum++)
     {
         Value* arg = callInst->getArgOperand(opNum);
         if (!isLegalIntVectorType(M, arg->getType()))
@@ -601,7 +602,7 @@ void LegalizeFunctionSignatures::FixCallInstruction(Module& M, CallInst* callIns
         {
             // legal argument
             callArgs.push_back(arg);
-            ArgAttrVec.push_back(PAL.getParamAttributes(opNum));
+            ArgAttrVec.push_back(IGCLLVM::getParamAttrs(PAL, opNum));
         }
     }
 
@@ -634,7 +635,7 @@ void LegalizeFunctionSignatures::FixCallInstruction(Module& M, CallInst* callIns
         // Create the new call instruction
         CallInst* newCallInst = builder.CreateCall(newCalledValue, callArgs);
         newCallInst->setCallingConv(callInst->getCallingConv());
-        newCallInst->setAttributes(AttributeList::get(M.getContext(), PAL.getFnAttributes(), PAL.getRetAttributes(), ArgAttrVec));
+        newCallInst->setAttributes(AttributeList::get(M.getContext(), IGCLLVM::getFnAttrs(PAL), IGCLLVM::getRetAttrs(PAL), ArgAttrVec));
         newCallInst->setDebugLoc(callInst->getDebugLoc());
 
         if (legalizeReturnType)
diff --git a/IGC/AdaptorCommon/ProcessFuncAttributes.cpp b/IGC/AdaptorCommon/ProcessFuncAttributes.cpp
index a6d22e613..5bedb00b1 100644
--- a/IGC/AdaptorCommon/ProcessFuncAttributes.cpp
+++ b/IGC/AdaptorCommon/ProcessFuncAttributes.cpp
@@ -18,6 +18,7 @@ SPDX-License-Identifier: MIT
 #include "common/LLVMWarningsPush.hpp"
 
 #include "llvm/IR/Attributes.h"
+#include "llvmWrapper/IR/InstrTypes.h"
 #include "llvmWrapper/IR/Instructions.h"
 
 #include <llvm/Pass.h>
@@ -379,12 +380,12 @@ bool ProcessFuncAttributes::runOnModule(Module& M)
                 // Go through call sites and remove NoInline atrributes.
                 // Verifier fails if a call has optnone but not noinline, so if we remove noinline, we must also remove optnone
                 if (callInst->hasFnAttr(llvm::Attribute::NoInline)) {
-                    callInst->removeAttribute(AttributeList::FunctionIndex, llvm::Attribute::NoInline);
-                    callInst->removeAttribute(AttributeList::FunctionIndex, llvm::Attribute::OptimizeNone);
+                    IGCLLVM::removeFnAttr(callInst, llvm::Attribute::NoInline);
+                    IGCLLVM::removeFnAttr(callInst, llvm::Attribute::OptimizeNone);
                 }
                 // Remove AlwaysInline at callsites
                 if (isOptDisable && callInst->hasFnAttr(llvm::Attribute::AlwaysInline)) {
-                    callInst->removeAttribute(AttributeList::FunctionIndex, llvm::Attribute::AlwaysInline);
+                    IGCLLVM::removeFnAttr(callInst, llvm::Attribute::AlwaysInline);
                 }
             }
         }
diff --git a/IGC/AdaptorCommon/RayTracing/RTBuilder.cpp b/IGC/AdaptorCommon/RayTracing/RTBuilder.cpp
index ab7977bea..59e8507b9 100644
--- a/IGC/AdaptorCommon/RayTracing/RTBuilder.cpp
+++ b/IGC/AdaptorCommon/RayTracing/RTBuilder.cpp
@@ -23,6 +23,7 @@ SPDX-License-Identifier: MIT
 #include "RTStackFormat.h"
 #include "Probe/Assertion.h"
 
+#include "llvmWrapper/IR/Attributes.h"
 #include "llvmWrapper/IR/DerivedTypes.h"
 #include "llvmWrapper/Support/Alignment.h"
 #include "common/LLVMWarningsPush.hpp"
@@ -3251,30 +3252,30 @@ Value* RTBuilder::createAllocaNumber(const AllocaInst* AI, uint32_t Number)
 void RTBuilder::setReturnAlignment(CallInst* CI, uint32_t AlignVal)
 {
     auto Attrs = CI->getAttributes();
-    AttrBuilder AB{ Attrs, AttributeList::ReturnIndex };
+    IGCLLVM::AttrBuilder AB { CI->getContext(), Attrs.getAttributes(AttributeList::ReturnIndex)};
     AB.addAlignmentAttr(AlignVal);
     auto AL =
-        Attrs.addAttributes(CI->getContext(), AttributeList::ReturnIndex, AB);
+        IGCLLVM::addAttributesAtIndex(Attrs, CI->getContext(), AttributeList::ReturnIndex, AB);
     CI->setAttributes(AL);
 }
 
 void RTBuilder::setNoAlias(CallInst* CI)
 {
     auto Attrs = CI->getAttributes();
-    AttrBuilder AB{ Attrs, AttributeList::ReturnIndex };
+    IGCLLVM::AttrBuilder AB{ CI->getContext(), Attrs.getAttributes(AttributeList::ReturnIndex) };
     AB.addAttribute(Attribute::AttrKind::NoAlias);
     auto AL =
-        Attrs.addAttributes(CI->getContext(), AttributeList::ReturnIndex, AB);
+        IGCLLVM::addAttributesAtIndex(Attrs, CI->getContext(), AttributeList::ReturnIndex, AB);
     CI->setAttributes(AL);
 }
 
 void RTBuilder::setDereferenceable(CallInst* CI, uint32_t Size)
 {
     auto Attrs = CI->getAttributes();
-    AttrBuilder AB{ Attrs, AttributeList::ReturnIndex };
+    IGCLLVM::AttrBuilder AB{ CI->getContext(), Attrs.getAttributes(AttributeList::ReturnIndex) };
     AB.addDereferenceableAttr(Size);
     auto AL =
-        Attrs.addAttributes(CI->getContext(), AttributeList::ReturnIndex, AB);
+        IGCLLVM::addAttributesAtIndex(Attrs, CI->getContext(), AttributeList::ReturnIndex, AB);
     CI->setAttributes(AL);
 }
 
diff --git a/IGC/AdaptorOCL/SPIRV/SPIRVReader.cpp b/IGC/AdaptorOCL/SPIRV/SPIRVReader.cpp
index ad6c62888..20e2e7baf 100644
--- a/IGC/AdaptorOCL/SPIRV/SPIRVReader.cpp
+++ b/IGC/AdaptorOCL/SPIRV/SPIRVReader.cpp
@@ -47,8 +47,10 @@ THE SOFTWARE.
 #include "common/LLVMWarningsPush.hpp"
 #include "llvm/Config/llvm-config.h"
 #include "llvmWrapper/IR/DerivedTypes.h"
+#include "llvmWrapper/IR/Function.h"
 #include "llvmWrapper/IR/IRBuilder.h"
 #include "llvmWrapper/IR/DIBuilder.h"
+#include "llvmWrapper/IR/InstrTypes.h"
 #include "llvmWrapper/IR/Module.h"
 #include "llvmWrapper/Support/Alignment.h"
 #include "llvmWrapper/Support/TypeSize.h"
@@ -4211,8 +4213,7 @@ SPIRVToLLVM::transFunction(SPIRVFunction *BF) {
   BF->foreachReturnValueAttr([&](SPIRVFuncParamAttrKind Kind){
     if (Kind == FunctionParameterAttributeCount)
       return;
-    F->addAttribute(AttributeList::ReturnIndex,
-        SPIRSPIRVFuncParamAttrMap::rmap(Kind));
+    IGCLLVM::addRetAttr(F, SPIRSPIRVFuncParamAttrMap::rmap(Kind));
   });
 
   // Creating all basic blocks before creating instructions.
@@ -5052,7 +5053,7 @@ SPIRVToLLVM::transOCLBuiltinFromExtInst(SPIRVExtInst *BC, BasicBlock *BB) {
       BC->getName(),
       BB);
   setCallingConv(Call);
-  Call->addAttribute(AttributeList::FunctionIndex, Attribute::NoUnwind);
+  IGCLLVM::addFnAttr(Call, Attribute::NoUnwind);
   return Call;
 }
 
diff --git a/IGC/AdaptorOCL/SPIRV/SPIRVUtil.cpp b/IGC/AdaptorOCL/SPIRV/SPIRVUtil.cpp
index d6e68bb8b..a598b134b 100644
--- a/IGC/AdaptorOCL/SPIRV/SPIRVUtil.cpp
+++ b/IGC/AdaptorOCL/SPIRV/SPIRVUtil.cpp
@@ -54,7 +54,9 @@ THE SOFTWARE.
 
 #include <llvm/Support/ScaledNumber.h>
 #include "llvm/ADT/StringExtras.h"
+#include "llvm/Support/Regex.h"
 #include "llvmWrapper/IR/IRBuilder.h"
+#include "llvmWrapper/IR/Instructions.h"
 #include "llvmWrapper/Transforms/Utils/Cloning.h"
 #include "common/LLVMWarningsPop.hpp"
 
@@ -121,7 +123,7 @@ getOrCreateFunction(Module *M, Type *RetTy, ArrayRef<Type *> ArgTypes,
 std::vector<Value *>
 getArguments(CallInst* CI) {
   std::vector<Value*> Args;
-  for (unsigned I = 0, E = CI->getNumArgOperands(); I != E; ++I) {
+  for (unsigned I = 0, E = IGCLLVM::getNumArgOperands(CI); I != E; ++I) {
     Args.push_back(CI->getArgOperand(I));
   }
   return Args;
diff --git a/IGC/AdaptorOCL/UnifyIROCL.cpp b/IGC/AdaptorOCL/UnifyIROCL.cpp
index 805886412..acb4f746d 100644
--- a/IGC/AdaptorOCL/UnifyIROCL.cpp
+++ b/IGC/AdaptorOCL/UnifyIROCL.cpp
@@ -21,9 +21,8 @@ SPDX-License-Identifier: MIT
 #include <llvm/IR/Module.h>
 #include <llvm/IR/Function.h>
 #include <llvm/Analysis/TargetLibraryInfo.h>
-#include <llvm/Transforms/InstCombine/InstCombineWorklist.h>
-#include <llvm/Transforms/InstCombine/InstCombine.h>
 
+#include <llvmWrapper/Transforms/InstCombine/InstCombineWorklist.h>
 #include <llvmWrapper/Transforms/Utils.h>
 
 #include "common/LLVMWarningsPop.hpp"
diff --git a/IGC/Compiler/CISACodeGen/CheckInstrTypes.cpp b/IGC/Compiler/CISACodeGen/CheckInstrTypes.cpp
index 3c3d1d87a..cef8a64cc 100644
--- a/IGC/Compiler/CISACodeGen/CheckInstrTypes.cpp
+++ b/IGC/Compiler/CISACodeGen/CheckInstrTypes.cpp
@@ -186,7 +186,7 @@ void CheckInstrTypes::visitCallInst(CallInst& C)
         if (C.isInlineAsm())
         {
             g_InstrTypes->hasInlineAsm = true;
-            for (unsigned i = 0; i < C.getNumArgOperands(); i++)
+            for (unsigned i = 0; i < IGCLLVM::getNumArgOperands(&C); i++)
             {
                 Type* opndTy = C.getArgOperand(i)->getType();
                 if (opndTy->isPointerTy() &&
diff --git a/IGC/Compiler/CISACodeGen/CodeSinking.cpp b/IGC/Compiler/CISACodeGen/CodeSinking.cpp
index 9ce359b3a..0c0343e44 100644
--- a/IGC/Compiler/CISACodeGen/CodeSinking.cpp
+++ b/IGC/Compiler/CISACodeGen/CodeSinking.cpp
@@ -42,6 +42,7 @@ See LICENSE.TXT for details.
 #include "llvm/IR/IntrinsicInst.h"
 #include "llvm/IR/CFG.h"
 #include "llvm/ADT/PostOrderIterator.h"
+#include "llvmWrapper/IR/Function.h"
 #include "common/LLVMWarningsPop.hpp"
 #include "Compiler/CodeGenPublic.h"
 #include "Compiler/CISACodeGen/CodeSinking.hpp"
@@ -767,7 +768,7 @@ namespace IGC {
 
             if (!call0->getCalledFunction() ||
                 call0->getCalledFunction() != call1->getCalledFunction() ||
-                !call0->getCalledFunction()->doesNotReadMemory() ||
+                !IGCLLVM::onlyWritesMemory(call0->getCalledFunction()) ||
                 call0->isConvergent())
             {
                 return false;
diff --git a/IGC/Compiler/CISACodeGen/DebugInfo.cpp b/IGC/Compiler/CISACodeGen/DebugInfo.cpp
index 425d9dbdd..b5ba1d6a7 100644
--- a/IGC/Compiler/CISACodeGen/DebugInfo.cpp
+++ b/IGC/Compiler/CISACodeGen/DebugInfo.cpp
@@ -14,6 +14,7 @@ SPDX-License-Identifier: MIT
 #include "DebugInfo/DwarfDebug.hpp"
 #include "DebugInfo/VISADebugInfo.hpp"
 #include "Compiler/CISACodeGen/DebugInfo.hpp"
+#include "llvmWrapper/IR/Instructions.h"
 #include "llvm/IR/IntrinsicInst.h"
 
 using namespace llvm;
@@ -346,7 +347,7 @@ void DebugInfoData::extractAddressClass(llvm::Function& F, CShader* pShader, IDe
                             DIExpression* newDIExpr = di.createExpression(Exprs);
                             Value* newMD = MetadataAsValue::get(F.getContext(), newDIExpr);
 
-                            CI->setArgOperand(CI->getNumArgOperands() - 1, newMD);
+                            CI->setArgOperand(IGCLLVM::getNumArgOperands(CI) - 1, newMD);
                         }
                     }
                 }
diff --git a/IGC/Compiler/CISACodeGen/EmitVISAPass.cpp b/IGC/Compiler/CISACodeGen/EmitVISAPass.cpp
index 9d9d4a4a3..bbf432a83 100644
--- a/IGC/Compiler/CISACodeGen/EmitVISAPass.cpp
+++ b/IGC/Compiler/CISACodeGen/EmitVISAPass.cpp
@@ -3465,13 +3465,13 @@ void EmitPass::emitSetMessagePhaseType(GenIntrinsicInst* inst, VISA_Type type) {
 
 void EmitPass::emitSetMessagePhaseX_legacy(GenIntrinsicInst* inst)
 {
-    Type* pTy = inst->getArgOperand(inst->getNumArgOperands() - 1)->getType();
+    Type* pTy = inst->getArgOperand(IGCLLVM::getNumArgOperands(inst) - 1)->getType();
     unsigned size = pTy->getScalarSizeInBits() / 8;
     emitSetMessagePhaseType_legacy(inst, GetTypeFromSize(size));
 }
 
 void EmitPass::emitSetMessagePhaseX(GenIntrinsicInst* inst) {
-    Type* pTy = inst->getArgOperand(inst->getNumArgOperands() - 1)->getType();
+    Type* pTy = inst->getArgOperand(IGCLLVM::getNumArgOperands(inst) - 1)->getType();
     unsigned size = pTy->getScalarSizeInBits() / 8;
     emitSetMessagePhaseType(inst, GetTypeFromSize(size));
 }
@@ -4301,7 +4301,7 @@ void EmitPass::emitEvalAttribute(llvm::GenIntrinsicInst* inst)
 {
     CPixelShader* psProgram = static_cast<CPixelShader*>(m_currShader);
     // temp variable should be the same type as the destination
-    bool perspective = cast<ConstantInt>(inst->getOperand(inst->getNumArgOperands() - 1))->getZExtValue() != 0;
+    bool perspective = cast<ConstantInt>(inst->getOperand(IGCLLVM::getNumArgOperands(inst) - 1))->getZExtValue() != 0;
     EU_PIXEL_INTERPOLATOR_INTERPOLATION_MODE interpolationMode =
         perspective ? EU_PI_MESSAGE_PERSPECTIVE_INTERPOLATION : EU_PI_MESSAGE_LINEAR_INTERPOLATION;
     if (interpolationMode == EU_PI_MESSAGE_LINEAR_INTERPOLATION)
@@ -10158,7 +10158,7 @@ bool EmitPass::validateInlineAsmConstraints(llvm::CallInst* inst, SmallVector<St
     if (success)
     {
         // Check the input constraint tokens
-        for (unsigned i = 0; i < inst->getNumArgOperands(); i++, index++)
+        for (unsigned i = 0; i < IGCLLVM::getNumArgOperands(inst); i++, index++)
         {
             CVariable* cv = GetSymbol(inst->getArgOperand(i));
             success &= CheckConstraintTypes(constraints[index], cv);
@@ -10208,7 +10208,7 @@ void EmitPass::EmitInlineAsm(llvm::CallInst* inst)
     {
         opnds.push_back(m_destination);
     }
-    for (unsigned i = 0; i < inst->getNumArgOperands(); i++)
+    for (unsigned i = 0; i < IGCLLVM::getNumArgOperands(inst); i++)
     {
         CVariable* cv = GetSymbol(inst->getArgOperand(i));
         opnds.push_back(cv);
@@ -11928,7 +11928,7 @@ void EmitPass::emitStackCall(llvm::CallInst* inst)
     std::vector<CVariable*> argsOnStack;
     SmallVector<std::tuple<CVariable*, Type*, uint32_t>, 8> argsOnRegister;
 
-    for (uint32_t i = 0; i < inst->getNumArgOperands(); i++)
+    for (uint32_t i = 0; i < IGCLLVM::getNumArgOperands(inst); i++)
     {
         Value* operand = inst->getArgOperand(i);
         CVariable* Src = GetSymbol(operand);
@@ -15016,7 +15016,7 @@ void EmitPass::emitAtomicRaw(llvm::GenIntrinsicInst* pInsn)
     ForceDMask();
     // Currently, Dword Atomics can be called by matching 2 intrinsics. One is the DwordAtomicRaw
     // and AtomicCmpXchg (which has 2 srcs unlike the other atomics).
-    IGC_ASSERT(pInsn->getNumArgOperands() == 4);
+    IGC_ASSERT(IGCLLVM::getNumArgOperands(pInsn) == 4);
 
     /// Immediate Atomics return the value before the atomic operation is performed. So that flag
     /// needs to be set for this.
@@ -15261,7 +15261,7 @@ void EmitPass::emitAtomicTyped(GenIntrinsicInst* pInsn)
     ForceDMask();
     // Currently, Dword Atomics can be called by matching 2 intrinsics. One is the DwordAtomicRaw
     // and AtomicCmpXchg (which has 2 srcs unlike the other atomics).
-    IGC_ASSERT(pInsn->getNumArgOperands() == 6);
+    IGC_ASSERT(IGCLLVM::getNumArgOperands(pInsn) == 6);
 
     /// Immediate Atomics return the value before the atomic operation is performed. So that flag
     /// needs to be set for this.
@@ -15912,7 +15912,7 @@ LSC_FENCE_OP EmitPass::getLSCMemoryFenceOp(bool IsGlobalMemFence, bool Invalidat
 void EmitPass::emitMemoryFence(llvm::Instruction* inst)
 {
     static constexpr int ExpectedNumberOfArguments = 7;
-    IGC_ASSERT(cast<CallInst>(inst)->getNumArgOperands() == ExpectedNumberOfArguments);
+    IGC_ASSERT(IGCLLVM::getNumArgOperands(cast<CallInst>(inst)) == ExpectedNumberOfArguments);
     CodeGenContext* ctx = getAnalysis<CodeGenContextWrapper>().getCodeGenContext();
 
     // If passed a non-constant value for any of the parameters,
@@ -16954,7 +16954,7 @@ void EmitPass::emitfitof(llvm::GenIntrinsicInst* inst)
 // Emit FP Operations (FPO) using round-to-zero (rtz)
 void EmitPass::emitFPOrtz(llvm::GenIntrinsicInst* inst)
 {
-    IGC_ASSERT_MESSAGE(inst->getNumArgOperands() >= 2, "ICE: incorrect gen intrinsic");
+    IGC_ASSERT_MESSAGE(IGCLLVM::getNumArgOperands(inst) >= 2, "ICE: incorrect gen intrinsic");
 
     GenISAIntrinsic::ID GID = inst->getIntrinsicID();
     CVariable* src0 = GetSymbol(inst->getOperand(0));
@@ -16990,7 +16990,7 @@ void EmitPass::emitFPOrtz(llvm::GenIntrinsicInst* inst)
 
 // Emit FP mad (FMA) using round-to-positive-infinity (rtp)
 void EmitPass::emitFMArtp(llvm::GenIntrinsicInst *inst) {
-  IGC_ASSERT_MESSAGE(inst->getNumArgOperands() == 3, "ICE: incorrect gen intrinsic");
+  IGC_ASSERT_MESSAGE(IGCLLVM::getNumArgOperands(inst) == 3, "ICE: incorrect gen intrinsic");
 
   CVariable *src0 = GetSymbol(inst->getOperand(0));
   CVariable *src1 = GetSymbol(inst->getOperand(1));
@@ -17007,7 +17007,7 @@ void EmitPass::emitFMArtp(llvm::GenIntrinsicInst *inst) {
 
 // Emit FP mad (FMA) using round-to-negative-infinity (rtn)
 void EmitPass::emitFMArtn(llvm::GenIntrinsicInst *inst) {
-  IGC_ASSERT_MESSAGE(inst->getNumArgOperands() == 3, "ICE: incorrect gen intrinsic");
+  IGC_ASSERT_MESSAGE(IGCLLVM::getNumArgOperands(inst) == 3, "ICE: incorrect gen intrinsic");
 
   CVariable *src0 = GetSymbol(inst->getOperand(0));
   CVariable *src1 = GetSymbol(inst->getOperand(1));
diff --git a/IGC/Compiler/CISACodeGen/EmitVISAPass.hpp b/IGC/Compiler/CISACodeGen/EmitVISAPass.hpp
index 0ae743dfb..9a122d90b 100644
--- a/IGC/Compiler/CISACodeGen/EmitVISAPass.hpp
+++ b/IGC/Compiler/CISACodeGen/EmitVISAPass.hpp
@@ -631,7 +631,7 @@ public:
     {
         if (llvm::CallInst * pCall = llvm::dyn_cast<llvm::CallInst>(pInst))
         {
-            if (op < pCall->getNumArgOperands())
+            if (op < IGCLLVM::getNumArgOperands(pCall))
             {
                 return pInst->getOperand(op);
             }
diff --git a/IGC/Compiler/CISACodeGen/Emu64OpsPass.cpp b/IGC/Compiler/CISACodeGen/Emu64OpsPass.cpp
index 4402d0bae..a735fccd5 100644
--- a/IGC/Compiler/CISACodeGen/Emu64OpsPass.cpp
+++ b/IGC/Compiler/CISACodeGen/Emu64OpsPass.cpp
@@ -18,7 +18,7 @@ SPDX-License-Identifier: MIT
 #include "llvm/IR/Function.h"
 #include "llvm/IR/IRBuilder.h"
 #include "llvm/IR/Instruction.h"
-#include "llvm/IR/Instructions.h"
+#include "llvmWrapper/IR/Instructions.h"
 #include "llvm/IR/IntrinsicInst.h"
 #include "llvm/IR/Module.h"
 #include "llvm/IR/Type.h"
@@ -1950,7 +1950,7 @@ bool InstExpander::visitCall(CallInst& Call) {
     IGC_ASSERT(nullptr != CallCopy);
     CallCopy->insertBefore(&Call);
     IRB->SetInsertPoint(CallCopy);
-    for (int argNo=0, sz = (int)Call.getNumArgOperands(); argNo < sz; ++argNo)
+    for (int argNo=0, sz = (int)IGCLLVM::getNumArgOperands(&Call); argNo < sz; ++argNo)
     {
         Value* OldVal = Call.getArgOperand(argNo);
         if (Emu->isInt64(OldVal))
diff --git a/IGC/Compiler/CISACodeGen/GenCodeGenModule.cpp b/IGC/Compiler/CISACodeGen/GenCodeGenModule.cpp
index 6c6eadbf2..784874433 100644
--- a/IGC/Compiler/CISACodeGen/GenCodeGenModule.cpp
+++ b/IGC/Compiler/CISACodeGen/GenCodeGenModule.cpp
@@ -18,7 +18,7 @@ SPDX-License-Identifier: MIT
 #include "common/LLVMWarningsPush.hpp"
 #include "llvm/Config/llvm-config.h"
 #include "llvm/IR/Argument.h"
-#include "llvm/IR/Attributes.h"
+#include "llvmWrapper/IR/Attributes.h"
 #include "llvmWrapper/Analysis/InlineCost.h"
 #include "llvm/ADT/SetVector.h"
 #include "llvm/ADT/SCCIterator.h"
@@ -368,7 +368,7 @@ static bool DeduceNonNullAttribute(Module& M)
             if (NotNull) {
                 // FIXME: Below lines possibly can be refactored to be simpler.
                 AttributeList attrSet = AttributeList::get(Arg.getParent()->getContext(), Arg.getArgNo() + 1, llvm::Attribute::NonNull);
-                Arg.addAttr(attrSet.getAttribute(Arg.getArgNo() + 1, llvm::Attribute::NonNull));
+                Arg.addAttr(IGCLLVM::getAttribute(attrSet, Arg.getArgNo() + 1, llvm::Attribute::NonNull));
                 Modifided = true;
             }
         }
diff --git a/IGC/Compiler/CISACodeGen/HFfoldingOpt.cpp b/IGC/Compiler/CISACodeGen/HFfoldingOpt.cpp
index f2c1a95d3..fbfb0a3ac 100644
--- a/IGC/Compiler/CISACodeGen/HFfoldingOpt.cpp
+++ b/IGC/Compiler/CISACodeGen/HFfoldingOpt.cpp
@@ -17,6 +17,7 @@ SPDX-License-Identifier: MIT
 #include "Compiler/MetaDataUtilsWrapper.h"
 #include "Compiler/CISACodeGen/HFfoldingOpt.hpp"
 #include "Probe/Assertion.h"
+#include "llvmWrapper/IR/Instructions.h"
 
 using namespace llvm;
 using namespace IGC;
@@ -594,7 +595,7 @@ bool HFfoldingOpt::findStoreSequence(std::vector<Instruction*>& path, std::vecto
         uint srciCount = inst->getNumOperands();
         if (CallInst* cinst = dyn_cast<CallInst>(inst))
         {
-            srciCount = cinst->getNumArgOperands();
+            srciCount = IGCLLVM::getNumArgOperands(cinst);
         }
 
         for (uint srci = 0; srci < srciCount; srci++)
diff --git a/IGC/Compiler/CISACodeGen/HalfPromotion.cpp b/IGC/Compiler/CISACodeGen/HalfPromotion.cpp
index 1ea2338b5..2dd10938c 100644
--- a/IGC/Compiler/CISACodeGen/HalfPromotion.cpp
+++ b/IGC/Compiler/CISACodeGen/HalfPromotion.cpp
@@ -86,7 +86,7 @@ void IGC::HalfPromotion::handleLLVMIntrinsic(llvm::IntrinsicInst& I)
             I.getIntrinsicID(),
             builder.getFloatTy());
 
-        for (unsigned i = 0; i < I.getNumArgOperands(); ++i)
+        for (unsigned i = 0; i < IGCLLVM::getNumArgOperands(&I); ++i)
         {
             if (I.getOperand(i)->getType()->isHalfTy())
             {
@@ -124,7 +124,7 @@ void IGC::HalfPromotion::handleGenIntrinsic(llvm::GenIntrinsicInst& I)
             I.getIntrinsicID(),
             builder.getFloatTy());
 
-        for (unsigned i = 0; i < I.getNumArgOperands(); ++i)
+        for (unsigned i = 0; i < IGCLLVM::getNumArgOperands(&I); ++i)
         {
             if (I.getOperand(i)->getType()->isHalfTy())
             {
diff --git a/IGC/Compiler/CISACodeGen/OpenCLKernelCodeGen.cpp b/IGC/Compiler/CISACodeGen/OpenCLKernelCodeGen.cpp
index 362ee0e6b..c68b0d3bf 100644
--- a/IGC/Compiler/CISACodeGen/OpenCLKernelCodeGen.cpp
+++ b/IGC/Compiler/CISACodeGen/OpenCLKernelCodeGen.cpp
@@ -1685,7 +1685,7 @@ namespace IGC
                 }
                 else
                 {
-                    for (int i = 0, e = (int)CallI->getNumArgOperands(); i < e; ++i)
+                    for (int i = 0, e = (int)IGCLLVM::getNumArgOperands(CallI); i < e; ++i)
                     {
                         Value* arg = CallI->getArgOperand(i);
                         PointerType* PTy = dyn_cast<PointerType>(arg->getType());
diff --git a/IGC/Compiler/CISACodeGen/PatternMatchPass.hpp b/IGC/Compiler/CISACodeGen/PatternMatchPass.hpp
index e52a9e16f..e32a613aa 100644
--- a/IGC/Compiler/CISACodeGen/PatternMatchPass.hpp
+++ b/IGC/Compiler/CISACodeGen/PatternMatchPass.hpp
@@ -21,6 +21,7 @@ SPDX-License-Identifier: MIT
 #include <llvm/Analysis/LoopInfo.h>
 #include <llvm/IR/DataLayout.h>
 #include "common/LLVMWarningsPop.hpp"
+#include "llvmWrapper/IR/Instructions.h"
 
 namespace llvm
 {
@@ -339,7 +340,7 @@ namespace IGC
     {
         if (llvm::CallInst * intrin = llvm::dyn_cast<llvm::CallInst>(&v))
         {
-            return intrin->getNumArgOperands();
+            return IGCLLVM::getNumArgOperands(intrin);
         }
         return v.getNumOperands();
     }
diff --git a/IGC/Compiler/CISACodeGen/PixelShaderLowering.cpp b/IGC/Compiler/CISACodeGen/PixelShaderLowering.cpp
index a25cac2f7..4dab24aa3 100644
--- a/IGC/Compiler/CISACodeGen/PixelShaderLowering.cpp
+++ b/IGC/Compiler/CISACodeGen/PixelShaderLowering.cpp
@@ -1299,7 +1299,7 @@ void PixelShaderLowering::moveRTWriteToBlock(
     unsigned numPredBB = predBB.size();
     if (numPredBB > 1)
     {
-        for (unsigned i = 0; i < call->getNumArgOperands(); i++)
+        for (unsigned i = 0; i < IGCLLVM::getNumArgOperands(call); i++)
         {
             if (Instruction * inst = dyn_cast<Instruction>(call->getArgOperand(i)))
             {
diff --git a/IGC/Compiler/CISACodeGen/ResolveGAS.cpp b/IGC/Compiler/CISACodeGen/ResolveGAS.cpp
index 2574580c8..e54a14cf7 100644
--- a/IGC/Compiler/CISACodeGen/ResolveGAS.cpp
+++ b/IGC/Compiler/CISACodeGen/ResolveGAS.cpp
@@ -1255,7 +1255,7 @@ void GASRetValuePropagator::updateAllUsesWithNewFunction(Function* oldFunc, Func
 
         // Prepare args for new call
         std::vector<Value*> callArgs;
-        for (unsigned I = 0, E = cInst->getNumArgOperands(); I != E; ++I) {
+        for (unsigned I = 0, E = IGCLLVM::getNumArgOperands(cInst); I != E; ++I) {
             callArgs.push_back(cInst->getArgOperand(I));
         }
 
@@ -1813,7 +1813,7 @@ void LowerGPCallArg::updateAllUsesWithNewFunction(Function* oldFunc, Function* n
         std::vector<Value*> newCallArgs;
 
         auto AI = newFunc->arg_begin();
-        for (unsigned int i = 0; i < cInst->getNumArgOperands(); ++i, ++AI)
+        for (unsigned int i = 0; i < IGCLLVM::getNumArgOperands(cInst); ++i, ++AI)
         {
             Value* callArg = cInst->getOperand(i);
             Value* funcArg = AI;
diff --git a/IGC/Compiler/CISACodeGen/SLMConstProp.cpp b/IGC/Compiler/CISACodeGen/SLMConstProp.cpp
index d6a1c05f3..7c1ed8d89 100644
--- a/IGC/Compiler/CISACodeGen/SLMConstProp.cpp
+++ b/IGC/Compiler/CISACodeGen/SLMConstProp.cpp
@@ -1075,7 +1075,7 @@ bool SLMConstProp::runOnFunction(Function& F)
                 if (checkSLMArg) {
                     // Make sure those intrinsic does not use ptr to SLM
                     // (for example, SLM atomic, etc.
-                    for (int i = 0, e = (int)CallI->getNumArgOperands();
+                    for (int i = 0, e = (int)IGCLLVM::getNumArgOperands(CallI);
                         i < e; ++i) {
                         Type* Ty = CallI->getArgOperand(i)->getType();
                         if (PointerType * PTy = dyn_cast<PointerType>(Ty)) {
diff --git a/IGC/Compiler/CISACodeGen/VectorProcess.cpp b/IGC/Compiler/CISACodeGen/VectorProcess.cpp
index 3d2713be4..87adba4e1 100644
--- a/IGC/Compiler/CISACodeGen/VectorProcess.cpp
+++ b/IGC/Compiler/CISACodeGen/VectorProcess.cpp
@@ -214,7 +214,7 @@ bool VectorProcess::reLayoutLoadStore(Instruction* Inst)
         else
         {
             IGC_ASSERT(II->getIntrinsicID() == GenISAIntrinsic::GenISA_storerawvector_indexed);
-            IGC_ASSERT(2 < II->getNumArgOperands());
+            IGC_ASSERT(2 < IGCLLVM::getNumArgOperands(II));
             IGC_ASSERT(nullptr != II->getArgOperand(2));
 
             Ty = II->getArgOperand(2)->getType();
diff --git a/IGC/Compiler/CISACodeGen/WIAnalysis.cpp b/IGC/Compiler/CISACodeGen/WIAnalysis.cpp
index d07f6ff84..46bf802bc 100644
--- a/IGC/Compiler/CISACodeGen/WIAnalysis.cpp
+++ b/IGC/Compiler/CISACodeGen/WIAnalysis.cpp
@@ -1608,7 +1608,7 @@ WIAnalysis::WIDependancy WIAnalysisRunner::calculate_dep(const CallInst* inst)
 
         // Iterate over all input dependencies. If all are uniform - propagate it.
         // otherwise - return RANDOM
-        unsigned numParams = inst->getNumArgOperands();
+        unsigned numParams = IGCLLVM::getNumArgOperands(inst);
         WIAnalysis::WIDependancy dep = WIAnalysis::UNIFORM_GLOBAL;
         for (unsigned i = 0; i < numParams; ++i)
         {
diff --git a/IGC/Compiler/CISACodeGen/helper.cpp b/IGC/Compiler/CISACodeGen/helper.cpp
index 16f9a036c..8cd8b1d22 100644
--- a/IGC/Compiler/CISACodeGen/helper.cpp
+++ b/IGC/Compiler/CISACodeGen/helper.cpp
@@ -959,7 +959,7 @@ namespace IGC
         llvm::Function* pCalledFunc = pIntr->getCalledFunction();
 
         // Look at the intrinsic and figure out which pointer to change
-        int num_ops = pIntr->getNumArgOperands();
+        int num_ops = IGCLLVM::getNumArgOperands(pIntr);
         llvm::SmallVector<llvm::Value*, 5> args;
 
         for (int i = 0; i < num_ops; ++i)
diff --git a/IGC/Compiler/CustomSafeOptPass.cpp b/IGC/Compiler/CustomSafeOptPass.cpp
index d0ce99329..01c50be5c 100644
--- a/IGC/Compiler/CustomSafeOptPass.cpp
+++ b/IGC/Compiler/CustomSafeOptPass.cpp
@@ -1784,7 +1784,7 @@ void IGC::CustomSafeOptPass::visitSampleBptr(llvm::SampleIntrinsic* sampleInst)
     {
         // Copy args skipping bias operand:
         llvm::SmallVector<llvm::Value*, 10> args;
-        for (unsigned int i = 1; i < sampleInst->getNumArgOperands(); i++)
+        for (unsigned int i = 1; i < IGCLLVM::getNumArgOperands(sampleInst); i++)
         {
             args.push_back(sampleInst->getArgOperand(i));
         }
@@ -6624,4 +6624,3 @@ bool InsertBranchOpt::runOnFunction(Function& F)
 
     return false;
 }
-
diff --git a/IGC/Compiler/GenTTI.cpp b/IGC/Compiler/GenTTI.cpp
index 5c1248f01..09988f9e6 100644
--- a/IGC/Compiler/GenTTI.cpp
+++ b/IGC/Compiler/GenTTI.cpp
@@ -158,7 +158,11 @@ namespace llvm {
 #if LLVM_VERSION_MAJOR >= 7
         ScalarEvolution& SE,
 #endif
-        TTI::UnrollingPreferences& UP)
+        TTI::UnrollingPreferences& UP
+#if LLVM_VERSION_MAJOR >= 14
+        , OptimizationRemarkEmitter* ORE
+#endif
+        )
     {
         unsigned LoopUnrollThreshold = ctx->m_DriverInfo.GetLoopUnrollThreshold();
 
diff --git a/IGC/Compiler/GenTTI.h b/IGC/Compiler/GenTTI.h
index 57a9852ee..aec2ca414 100644
--- a/IGC/Compiler/GenTTI.h
+++ b/IGC/Compiler/GenTTI.h
@@ -55,7 +55,11 @@ namespace llvm
 #if LLVM_VERSION_MAJOR >= 7
             ScalarEvolution & SE,
 #endif
-            TTI::UnrollingPreferences & UP);
+            TTI::UnrollingPreferences & UP
+#if LLVM_VERSION_MAJOR >= 14
+        , OptimizationRemarkEmitter* ORE
+#endif
+        );
 
 #if LLVM_VERSION_MAJOR >= 11
         void getPeelingPreferences(Loop* L, ScalarEvolution& SE,
diff --git a/IGC/Compiler/LowPrecisionOptPass.cpp b/IGC/Compiler/LowPrecisionOptPass.cpp
index e3d65bc18..7cf09cf7a 100644
--- a/IGC/Compiler/LowPrecisionOptPass.cpp
+++ b/IGC/Compiler/LowPrecisionOptPass.cpp
@@ -21,6 +21,8 @@ SPDX-License-Identifier: MIT
 
 #include "GenISAIntrinsics/GenIntrinsicInst.h"
 #include "common/IGCIRBuilder.h"
+#include "llvmWrapper/IR/Instructions.h"
+
 using namespace llvm;
 using namespace IGC;
 using namespace IGC::IGCMD;
@@ -297,7 +299,7 @@ bool LowPrecisionOpt::propagateSamplerType(llvm::GenIntrinsicInst& I)
     Function* newSample = GenISAIntrinsic::getDeclaration(
         m_currFunction->getParent(), I.getIntrinsicID(), overloadTys);
     llvm::SmallVector<llvm::Value*, 8> newArgs;
-    for (unsigned int i = 0, argSize = I.getNumArgOperands(); i < argSize; i++)
+    for (unsigned int i = 0, argSize = IGCLLVM::getNumArgOperands(&I); i < argSize; i++)
     {
         newArgs.push_back(I.getArgOperand(i));
     }
diff --git a/IGC/Compiler/Optimizer/BuiltInFuncImport.cpp b/IGC/Compiler/Optimizer/BuiltInFuncImport.cpp
index 8cbb7b953..e608c028c 100644
--- a/IGC/Compiler/Optimizer/BuiltInFuncImport.cpp
+++ b/IGC/Compiler/Optimizer/BuiltInFuncImport.cpp
@@ -12,7 +12,7 @@ SPDX-License-Identifier: MIT
 #include "Compiler/CodeGenPublic.h"
 #include "common/LLVMWarningsPush.hpp"
 #include <llvmWrapper/IR/IRBuilder.h>
-#include "llvm/IR/Attributes.h"
+#include "llvmWrapper/IR/Attributes.h"
 #include <llvm/IR/Function.h>
 #include <llvmWrapper/IR/Instructions.h>
 #include <llvmWrapper/IR/CallSite.h>
@@ -385,7 +385,7 @@ std::unique_ptr<llvm::Module> BIImport::Construct(Module& M, CLElfLib::CElfReade
                     IGC_ASSERT_MESSAGE(0, "Failed to materialize Global Variables");
                 }
                 else {
-                    pFunc->addAttribute(AttributeList::FunctionIndex, llvm::Attribute::Builtin);
+                    pFunc->addFnAttr(llvm::Attribute::Builtin);
                     Explore(pFunc);
                 }
             }
@@ -542,7 +542,7 @@ bool BIImport::runOnModule(Module& M)
                     IGC_ASSERT_MESSAGE(0, "Failed to materialize Global Variables");
                 }
                 else {
-                    pFunc->addAttribute(AttributeList::FunctionIndex, llvm::Attribute::Builtin);
+                    pFunc->addFnAttr(llvm::Attribute::Builtin);
                     Explore(pFunc);
                 }
             }
@@ -698,8 +698,7 @@ bool BIImport::runOnModule(Module& M)
                 {
                     Function* calledF = dyn_cast<Function>(CI->getArgOperand(0));
                     IGC_ASSERT(calledF && CI->hasFnAttr("vector-variant"));
-                    StringRef VariantName = CI->getAttributes()
-                        .getAttribute(AttributeList::FunctionIndex, "vector-variant")
+                    StringRef VariantName = IGCLLVM::getAttribute(CI->getAttributes(), AttributeList::FunctionIndex, "vector-variant")
                         .getValueAsString();
 
                     // Parse the variant string, and create a function declaration that represents a variant of the called function.
@@ -743,8 +742,7 @@ bool BIImport::runOnModule(Module& M)
                     if (CI->hasFnAttr("vector-variants"))
                     {
                         // Get the list of metadata strings indicating the function variant per index
-                        StringRef VariantsStr = CI->getAttributes()
-                            .getAttribute(AttributeList::FunctionIndex, "vector-variants")
+                        StringRef VariantsStr = IGCLLVM::getAttribute(CI->getAttributes(), AttributeList::FunctionIndex, "vector-variants")
                             .getValueAsString();
                         SmallVector<StringRef, 8> VariantsTable;
                         VariantsStr.split(VariantsTable, ',');
@@ -775,7 +773,7 @@ bool BIImport::runOnModule(Module& M)
                     IGC_ASSERT(FP->getType()->isPointerTy() && cast<PointerType>(FP->getType())->getElementType()->isFunctionTy());
                     // Call the loaded function address
                     SmallVector<Value*, 8> Args;
-                    for (unsigned i = 1; i < CI->getNumArgOperands(); i++)
+                    for (unsigned i = 1; i < IGCLLVM::getNumArgOperands(CI); i++)
                         Args.push_back(CI->getArgOperand(i));
                     CallInst* CallFP = builder.CreateCall(FP, Args);
                     CallFP->setCallingConv(llvm::CallingConv::SPIR_FUNC);
@@ -889,7 +887,7 @@ void BIImport::removeFunctionBitcasts(Module& M)
                         }
 
                         std::vector<Value*> Args;
-                        for (unsigned I = 0, E = pInstCall->getNumArgOperands(); I != E; ++I) {
+                        for (unsigned I = 0, E = IGCLLVM::getNumArgOperands(pInstCall); I != E; ++I) {
                             Args.push_back(pInstCall->getArgOperand(I));
                         }
                         auto newCI = CallInst::Create(pDstFunc, Args, "", pInstCall);
@@ -1228,7 +1226,7 @@ bool PreBIImportAnalysis::runOnModule(Module& M)
 
                   if (Function *newFunc = M.getFunction(newName)) {
                     SmallVector<Value *, 8> Args;
-                    for (unsigned I = 0, E = CI->getNumArgOperands(); I != E;
+                    for (unsigned I = 0, E = IGCLLVM::getNumArgOperands(CI); I != E;
                          ++I) {
                       Args.push_back(CI->getArgOperand(I));
                     }
diff --git a/IGC/Compiler/Optimizer/IGCInstCombiner/4.0/InstCombineCalls.cpp b/IGC/Compiler/Optimizer/IGCInstCombiner/4.0/InstCombineCalls.cpp
index af9628871..9487a70f4 100644
--- a/IGC/Compiler/Optimizer/IGCInstCombiner/4.0/InstCombineCalls.cpp
+++ b/IGC/Compiler/Optimizer/IGCInstCombiner/4.0/InstCombineCalls.cpp
@@ -37,7 +37,7 @@ See LICENSE.TXT for details.
 #include "llvm/IR/GlobalVariable.h"
 #include "llvm/IR/InstrTypes.h"
 #include "llvm/IR/Instruction.h"
-#include "llvm/IR/Instructions.h"
+#include "llvmWrapper/IR/Instructions.h"
 #include "llvm/IR/IntrinsicInst.h"
 #include "llvm/IR/Intrinsics.h"
 #include "llvm/IR/LLVMContext.h"
@@ -1336,8 +1336,8 @@ static bool simplifyX86MaskedStore(IntrinsicInst &II, InstCombiner &IC) {
 // comparison to the first NumOperands.
 static bool haveSameOperands(const IntrinsicInst &I, const IntrinsicInst &E,
                              unsigned NumOperands) {
-  IGC_ASSERT_MESSAGE(I.getNumArgOperands() >= NumOperands, "Not enough operands");
-  IGC_ASSERT_MESSAGE(E.getNumArgOperands() >= NumOperands, "Not enough operands");
+  IGC_ASSERT_MESSAGE(IGCLLVM::getNumArgOperands(&I) >= NumOperands, "Not enough operands");
+  IGC_ASSERT_MESSAGE(IGCLLVM::getNumArgOperands(&E) >= NumOperands, "Not enough operands");
   for (unsigned i = 0; i < NumOperands; i++)
     if (I.getArgOperand(i) != E.getArgOperand(i))
       return false;
@@ -1362,7 +1362,7 @@ static bool removeTriviallyEmptyRange(IntrinsicInst &I, unsigned StartID,
       if (isa<DbgInfoIntrinsic>(E) || E->getIntrinsicID() == StartID)
         continue;
       if (E->getIntrinsicID() == EndID &&
-          haveSameOperands(I, *E, E->getNumArgOperands())) {
+          haveSameOperands(I, *E, IGCLLVM::getNumArgOperands(E))) {
         IC.eraseInstFromFunction(*E);
         IC.eraseInstFromFunction(I);
         return true;
@@ -1388,7 +1388,7 @@ Instruction *InstCombiner::visitVACopyInst(VACopyInst &I) {
 /// instructions. For normal calls, it allows visitCallSite to do the heavy
 /// lifting.
 Instruction *InstCombiner::visitCallInst(CallInst &CI) {
-  auto Args = CI.arg_operands();
+  auto Args = IGCLLVM::args(CI);
   if (Value *V = SimplifyCall(CI.getCalledValue(), Args.begin(), Args.end(), DL,
                               &TLI, &DT, &AC))
     return replaceInstUsesWith(CI, V);
@@ -2481,7 +2481,7 @@ Instruction *InstCombiner::visitCallInst(CallInst &CI) {
   case Intrinsic::arm_neon_vst4lane: {
     unsigned MemAlign =
         getKnownAlignment(II->getArgOperand(0), DL, II, &AC, &DT);
-    unsigned AlignArg = II->getNumArgOperands() - 1;
+    unsigned AlignArg = IGCLLVM::getNumArgOperands(II) - 1;
     ConstantInt *IntrAlign = dyn_cast<ConstantInt>(II->getArgOperand(AlignArg));
     if (IntrAlign && IntrAlign->getZExtValue() < MemAlign) {
       II->setArgOperand(AlignArg,
diff --git a/IGC/Compiler/Optimizer/IGCInstCombiner/7.0/InstCombineCalls.cpp b/IGC/Compiler/Optimizer/IGCInstCombiner/7.0/InstCombineCalls.cpp
index 6d57a2210..04a5155c4 100644
--- a/IGC/Compiler/Optimizer/IGCInstCombiner/7.0/InstCombineCalls.cpp
+++ b/IGC/Compiler/Optimizer/IGCInstCombiner/7.0/InstCombineCalls.cpp
@@ -42,7 +42,7 @@ See LICENSE.TXT for details.
 #include "llvm/IR/GlobalVariable.h"
 #include "llvm/IR/InstrTypes.h"
 #include "llvm/IR/Instruction.h"
-#include "llvm/IR/Instructions.h"
+#include "llvmWrapper/IR/Instructions.h"
 #include "llvm/IR/IntrinsicInst.h"
 #include "llvm/IR/Intrinsics.h"
 #include "llvm/IR/LLVMContext.h"
@@ -1563,8 +1563,8 @@ static Value* simplifyNeonVld1(const IntrinsicInst& II,
 // comparison to the first NumOperands.
 static bool haveSameOperands(const IntrinsicInst& I, const IntrinsicInst& E,
     unsigned NumOperands) {
-    IGC_ASSERT_MESSAGE(I.getNumArgOperands() >= NumOperands, "Not enough operands");
-    IGC_ASSERT_MESSAGE(E.getNumArgOperands() >= NumOperands, "Not enough operands");
+    IGC_ASSERT_MESSAGE(IGCLLVM::getNumArgOperands(&I) >= NumOperands, "Not enough operands");
+    IGC_ASSERT_MESSAGE(IGCLLVM::getNumArgOperands(&E) >= NumOperands, "Not enough operands");
     for (unsigned i = 0; i < NumOperands; i++)
         if (I.getArgOperand(i) != E.getArgOperand(i))
             return false;
@@ -1589,7 +1589,7 @@ static bool removeTriviallyEmptyRange(IntrinsicInst& I, unsigned StartID,
             if (isa<DbgInfoIntrinsic>(E) || E->getIntrinsicID() == StartID)
                 continue;
             if (E->getIntrinsicID() == EndID &&
-                haveSameOperands(I, *E, E->getNumArgOperands())) {
+                haveSameOperands(I, *E, IGCLLVM::getNumArgOperands(E))) {
                 IC.eraseInstFromFunction(*E);
                 IC.eraseInstFromFunction(I);
                 return true;
@@ -1816,7 +1816,7 @@ static Instruction* SimplifyNVVMIntrinsic(IntrinsicInst* II, InstCombiner& IC) {
 
     // Simplify to target-generic intrinsic.
     if (Action.IID) {
-        SmallVector<Value*, 4> Args(II->arg_operands());
+        SmallVector<Value*, 4> Args(IGCLLVM::args(II));
         // All the target-generic intrinsics currently of interest to us have one
         // type argument, equal to that of the nvvm intrinsic's argument.
         Type* Tys[] = { II->getArgOperand(0)->getType() };
@@ -3111,7 +3111,7 @@ Instruction* InstCombiner::visitCallInst(CallInst& CI) {
     case Intrinsic::arm_neon_vst4lane: {
         unsigned MemAlign =
             getKnownAlignment(II->getArgOperand(0), DL, II, &AC, &DT);
-        unsigned AlignArg = II->getNumArgOperands() - 1;
+        unsigned AlignArg = IGCLLVM::getNumArgOperands(II) - 1;
         ConstantInt* IntrAlign = dyn_cast<ConstantInt>(II->getArgOperand(AlignArg));
         if (IntrAlign && IntrAlign->getZExtValue() < MemAlign) {
             II->setArgOperand(AlignArg,
diff --git a/IGC/Compiler/Optimizer/IGCInstCombiner/7.0/InstCombineSimplifyDemanded.cpp b/IGC/Compiler/Optimizer/IGCInstCombiner/7.0/InstCombineSimplifyDemanded.cpp
index a5c8dd42f..0a7d6b002 100644
--- a/IGC/Compiler/Optimizer/IGCInstCombiner/7.0/InstCombineSimplifyDemanded.cpp
+++ b/IGC/Compiler/Optimizer/IGCInstCombiner/7.0/InstCombineSimplifyDemanded.cpp
@@ -1009,7 +1009,7 @@ Value* InstCombiner::simplifyAMDGCNMemoryIntrinsicDemanded(IntrinsicInst* II,
     Function* NewIntrin = Intrinsic::getDeclaration(M, IID, OverloadTys);
 
     SmallVector<Value*, 16> Args;
-    for (unsigned I = 0, E = II->getNumArgOperands(); I != E; ++I)
+    for (unsigned I = 0, E = IGCLLVM::getNumArgOperands(II); I != E; ++I)
         Args.push_back(II->getArgOperand(I));
 
     if (NewDMask)
diff --git a/IGC/Compiler/Optimizer/IGCInstCombiner/IGCInstructionCombining.hpp b/IGC/Compiler/Optimizer/IGCInstCombiner/IGCInstructionCombining.hpp
index fc849c3ca..b96999f15 100644
--- a/IGC/Compiler/Optimizer/IGCInstCombiner/IGCInstructionCombining.hpp
+++ b/IGC/Compiler/Optimizer/IGCInstCombiner/IGCInstructionCombining.hpp
@@ -11,7 +11,7 @@ SPDX-License-Identifier: MIT
 
 #include "llvm/Config/llvm-config.h"
 #include "llvm/PassRegistry.h"
-#include "llvm/Transforms/InstCombine/InstCombineWorklist.h"
+#include "llvmWrapper/Transforms/InstCombine/InstCombineWorklist.h"
 #include "llvm/IR/PassManager.h"
 #include "Compiler/InitializePasses.h"
 
diff --git a/IGC/Compiler/Optimizer/IndirectCallOptimization.cpp b/IGC/Compiler/Optimizer/IndirectCallOptimization.cpp
index 6e1a9592b..d763c147b 100644
--- a/IGC/Compiler/Optimizer/IndirectCallOptimization.cpp
+++ b/IGC/Compiler/Optimizer/IndirectCallOptimization.cpp
@@ -74,7 +74,7 @@ namespace IGC
         if (func->getReturnType() != call->getType())
             return false;
 
-        if (func->arg_size() != call->getNumArgOperands())
+        if (func->arg_size() != IGCLLVM::getNumArgOperands(call))
             return false;
 
         unsigned index = 0;
diff --git a/IGC/Compiler/Optimizer/IntDivConstantReduction.cpp b/IGC/Compiler/Optimizer/IntDivConstantReduction.cpp
index af5c4744c..b68af6ede 100644
--- a/IGC/Compiler/Optimizer/IntDivConstantReduction.cpp
+++ b/IGC/Compiler/Optimizer/IntDivConstantReduction.cpp
@@ -26,6 +26,7 @@ SPDX-License-Identifier: MIT
 #include <type_traits>
 #include "Probe/Assertion.h"
 #include "Compiler/CISACodeGen/helper.h"
+#include "llvmWrapper/ADT/APInt.h"
 
 using namespace llvm;
 
@@ -479,22 +480,23 @@ struct IntDivConstantReduction : public FunctionPass
         //
         const int bitSize = dividend->getType()->getIntegerBitWidth();
         //
-        APInt::ms appxRecip = divisor.magic();
+        IGCLLVM::SignedDivisionByConstantInfo appxRecip = IGCLLVM::getAPIntMagic(divisor);
         //
         ConstantInt *appxRcp = IGC::getConstantSInt(
-            B, bitSize, appxRecip.m.getSExtValue());
+            B, bitSize, IGCLLVM::MagicNumber(appxRecip).getSExtValue());
         Value *appxQ =
             IGC::CreateMulh(F, B, true, dividend, appxRcp);
-        if (divisor.isStrictlyPositive() && appxRecip.m.isNegative()) {
+        if (divisor.isStrictlyPositive() && IGCLLVM::MagicNumber(appxRecip).isNegative()) {
             appxQ = B.CreateAdd(appxQ, dividend, "q_appx");
         }
-        if (divisor.isNegative() && appxRecip.m.isStrictlyPositive()) {
+        if (divisor.isNegative() && IGCLLVM::MagicNumber(appxRecip).isStrictlyPositive()) {
             appxQ = B.CreateSub(appxQ, dividend, "q_appx");
         }
-        if (appxRecip.s > 0) {
-            ConstantInt *shift = IGC::getConstantSInt(B, bitSize, appxRecip.s);
+        if (IGCLLVM::ShiftAmount(appxRecip) > 0) {
+            ConstantInt *shift = IGC::getConstantSInt(B, bitSize, IGCLLVM::ShiftAmount(appxRecip));
             appxQ = B.CreateAShr(appxQ, shift, "q_appx");
         }
+
         //
         // Extract the sign bit and add it to the quotient
         if (IGC_GET_FLAG_VALUE(EnableConstIntDivReduction) == 3) {
@@ -520,33 +522,33 @@ struct IntDivConstantReduction : public FunctionPass
     {
         //////////////////////////////////////////////////
         // C.f. Hacker's Delight 10-8
-        APInt::mu appxRecip = divisor.magicu();
+        IGCLLVM::UnsignedDivisonByConstantInfo appxRecip = IGCLLVM::getAPIntMagicUnsigned(divisor);
         //
         const int bitSize = dividend->getType()->getIntegerBitWidth();
         //
         // even divisors can pre-shift the dividend to avoid
         // extra work at the end.
         Value *shiftedDividend = dividend;
-        if (appxRecip.a && !divisor[0]) {
+        if (IGCLLVM::IsAddition(appxRecip) && !divisor[0]) {
             unsigned s = divisor.countTrailingZeros();
             shiftedDividend = B.CreateLShr(shiftedDividend, s);
-            appxRecip = divisor.lshr(s).magicu(s);
-            IGC_ASSERT_MESSAGE(!appxRecip.a, "expected to subtract now");
-            IGC_ASSERT_MESSAGE(appxRecip.s < divisor.getBitWidth(), "undefined shift");
+            appxRecip = IGCLLVM::getAPIntMagicUnsigned(divisor.lshr(s), s);
+            IGC_ASSERT_MESSAGE(!IGCLLVM::IsAddition(appxRecip), "expected to subtract now");
+            IGC_ASSERT_MESSAGE(IGCLLVM::ShiftAmount(appxRecip) < divisor.getBitWidth(), "undefined shift");
         }
         //
         ConstantInt *appxRcp = IGC::getConstantUInt(
-            B, bitSize, appxRecip.m.getZExtValue());
+            B, bitSize, IGCLLVM::MagicNumber(appxRecip).getZExtValue());
         Value *appxQ =
             IGC::CreateMulh(F, B, false, shiftedDividend, appxRcp);
         //
-        if (!appxRecip.a) {
-            appxQ = B.CreateLShr(appxQ, appxRecip.s, "q_appx");
+        if (!IGCLLVM::IsAddition(appxRecip)) {
+            appxQ = B.CreateLShr(appxQ, IGCLLVM::ShiftAmount(appxRecip), "q_appx");
         } else {
             Value *fixup = B.CreateSub(dividend, appxQ, "q_appx");
             fixup = B.CreateLShr(fixup, 1);
             appxQ = B.CreateAdd(fixup, appxQ, "q_appx");
-            appxQ = B.CreateLShr(appxQ, appxRecip.s - 1, "q_appx");
+            appxQ = B.CreateLShr(appxQ, IGCLLVM::ShiftAmount(appxRecip) - 1, "q_appx");
         }
         return appxQ;
     }
diff --git a/IGC/Compiler/Optimizer/OCLBIUtils.cpp b/IGC/Compiler/Optimizer/OCLBIUtils.cpp
index a8c61b28d..3bf5cab11 100644
--- a/IGC/Compiler/Optimizer/OCLBIUtils.cpp
+++ b/IGC/Compiler/Optimizer/OCLBIUtils.cpp
@@ -867,7 +867,7 @@ class CSimpleIntrinMapping : public CCommand
 protected:
     void createIntrinsicType(const CallInst* pCI, ArrayRef<Type*> overloadTypes)
     {
-        m_args.append(pCI->op_begin(), pCI->op_begin() + pCI->getNumArgOperands());
+        m_args.append(pCI->op_begin(), pCI->op_begin() + IGCLLVM::getNumArgOperands(pCI));
         IGC_ASSERT_MESSAGE(!(id != Intrinsic::num_intrinsics && isaId != GenISAIntrinsic::ID::num_genisa_intrinsics), "Both intrinsic id's cannot be valid at the same time");
 
         // GenISA intrinsics ID start after llvm intrinsics
@@ -900,7 +900,7 @@ public:
 
     void createIntrinsic()
     {
-        IGC_ASSERT_MESSAGE(!(this->isOverloadable && m_pCallInst->getNumArgOperands() == 0), "Cannot create an overloadable with no args");
+        IGC_ASSERT_MESSAGE(!(this->isOverloadable && IGCLLVM::getNumArgOperands(m_pCallInst) == 0), "Cannot create an overloadable with no args");
         llvm::Type* tys[2];
         switch (isaId)
         {
@@ -921,7 +921,7 @@ public:
         case GenISAIntrinsic::GenISA_itof_rtz:
             tys[0] = m_pCallInst->getCalledFunction()->getReturnType();
             tys[1] = m_pCallInst->getArgOperand(0)->getType();
-            m_args.append(m_pCallInst->op_begin(), m_pCallInst->op_begin() + m_pCallInst->getNumArgOperands());
+            m_args.append(m_pCallInst->op_begin(), m_pCallInst->op_begin() + IGCLLVM::getNumArgOperands(m_pCallInst));
             IGC_ASSERT_MESSAGE(!(id != Intrinsic::num_intrinsics && isaId != GenISAIntrinsic::ID::num_genisa_intrinsics), "Both intrinsic id's cannot be valid at the same time");
             replaceGenISACallInst(isaId, llvm::ArrayRef<llvm::Type*>(tys));
             break;
@@ -936,7 +936,7 @@ public:
         case GenISAIntrinsic::GenISA_simdSetMessagePhase:
         case GenISAIntrinsic::GenISA_setMessagePhaseX:
         case GenISAIntrinsic::GenISA_setMessagePhaseX_legacy:
-            createIntrinsicType(m_pCallInst, m_pCallInst->getArgOperand(m_pCallInst->getNumArgOperands() - 1)->getType());
+            createIntrinsicType(m_pCallInst, m_pCallInst->getArgOperand(IGCLLVM::getNumArgOperands(m_pCallInst) - 1)->getType());
             break;
         case GenISAIntrinsic::GenISA_broadcastMessagePhaseV:
         case GenISAIntrinsic::GenISA_simdGetMessagePhaseV:
@@ -956,7 +956,7 @@ public:
             Type* overloadTypes[] =
             {
                 m_pCallInst->getCalledFunction()->getReturnType(),
-                m_pCallInst->getArgOperand(m_pCallInst->getNumArgOperands() - 1)->getType()
+                m_pCallInst->getArgOperand(IGCLLVM::getNumArgOperands(m_pCallInst) - 1)->getType()
             };
             createIntrinsicType(m_pCallInst, overloadTypes);
             break;
@@ -1043,7 +1043,7 @@ public:
         }
 
         // Rest of the params
-        m_args.append(m_pCallInst->op_begin() + 3 + num_images, m_pCallInst->op_begin() + m_pCallInst->getNumArgOperands());
+        m_args.append(m_pCallInst->op_begin() + 3 + num_images, m_pCallInst->op_begin() + IGCLLVM::getNumArgOperands(m_pCallInst));
 
         replaceGenISACallInst(id);
     }
@@ -1085,7 +1085,7 @@ public:
         }
 
         // Rest of the params except for the accelerator sampler.
-        m_args.append(m_pCallInst->op_begin() + 1 + m_numImgArgs + 1, m_pCallInst->op_begin() + m_pCallInst->getNumArgOperands());
+        m_args.append(m_pCallInst->op_begin() + 1 + m_numImgArgs + 1, m_pCallInst->op_begin() + IGCLLVM::getNumArgOperands(m_pCallInst));
 
         // Device-side VME using the CNewVMESend always use inline samplers.
         IGC::ModuleMetaData* MD = m_Ctx->getModuleMetaData();
diff --git a/IGC/Compiler/Optimizer/OpenCLPasses/AlignmentAnalysis/AlignmentAnalysis.cpp b/IGC/Compiler/Optimizer/OpenCLPasses/AlignmentAnalysis/AlignmentAnalysis.cpp
index d1f5d59c4..8516e69af 100644
--- a/IGC/Compiler/Optimizer/OpenCLPasses/AlignmentAnalysis/AlignmentAnalysis.cpp
+++ b/IGC/Compiler/Optimizer/OpenCLPasses/AlignmentAnalysis/AlignmentAnalysis.cpp
@@ -95,6 +95,89 @@ bool AlignmentAnalysis::runOnFunction(Function& F)
     return true;
 }
 
+auto AlignmentAnalysis::getConstantAlignment(uint64_t C) const
+{
+    if (!C)
+    {
+        return Value::MaximumAlignment;
+    }
+#if LLVM_VERSION_MAJOR >= 14
+    return iSTD::Min(Value::MaximumAlignment, 1UL << llvm::countTrailingZeros(C));
+#else
+    return iSTD::Min(Value::MaximumAlignment, 1U << llvm::countTrailingZeros(C));
+#endif
+}
+
+auto AlignmentAnalysis::getAlignValue(Value* V) const
+{
+    const alignment_t MinimumAlignmentValue = static_cast<alignment_t>(MinimumAlignment);
+    if (dyn_cast<Instruction>(V))
+    {
+        auto iter = m_alignmentMap.find(V);
+        if (iter == m_alignmentMap.end())
+        {
+            // Instructions are initialize to maximum alignment
+            // (this is the "top" value)
+            return Value::MaximumAlignment;
+        }
+
+        return static_cast<alignment_t>(iter->second);
+    }
+    else if (dyn_cast<Constant>(V))
+    {
+        if (ConstantInt * constInt = dyn_cast<ConstantInt>(V))
+        {
+            return getConstantAlignment(constInt->getZExtValue());
+        }
+        else if (GlobalVariable * GV = dyn_cast<GlobalVariable>(V))
+        {
+            auto align = GV->getAlignment();
+
+            // If the globalvariable uses the default alignment, pull it from the datalayout
+            if (!align)
+            {
+                Type* gvType = GV->getType();
+                return m_DL->getABITypeAlignment(gvType->getPointerElementType());
+            }
+            else
+            {
+                return align;
+            }
+        }
+
+        // Not an int or a globalvariable, be pessimistic.
+        return MinimumAlignmentValue;
+    }
+    else if (Argument * arg = dyn_cast<Argument>(V))
+    {
+        if (arg->getType()->isPointerTy())
+        {
+            // Pointer arguments are guaranteed to be aligned on the ABI alignment
+            Type* pointedTo = arg->getType()->getPointerElementType();
+            if (pointedTo->isSized())
+            {
+                return m_DL->getABITypeAlignment(pointedTo);
+            }
+            else
+            {
+                // We have some pointer-to-opaque-types which are not real pointers -
+                // this is used to pass things like images around.
+                // Apparently, DataLayout being asked about the ABI alignment of opaque types.
+                // So, we don't.
+                return MinimumAlignmentValue;
+            }
+        }
+        else
+        {
+            // We don't know anything about integer arguments.
+            return MinimumAlignmentValue;
+        }
+    }
+
+    // Be pessimistic
+    return MinimumAlignmentValue;
+}
+
 bool AlignmentAnalysis::processInstruction(llvm::Instruction* I)
 {
     // Get the currently known alignment of I.
@@ -165,7 +248,7 @@ unsigned int AlignmentAnalysis::visitSelectInst(SelectInst& I)
 
 unsigned int AlignmentAnalysis::visitPHINode(PHINode& I)
 {
-    unsigned int newAlign = Value::MaximumAlignment;
+    auto newAlign = Value::MaximumAlignment;
 
     // The alignment of a PHI is the minimal alignment of any of the
     // incoming values.
@@ -437,10 +520,11 @@ void AlignmentAnalysis::SetInstAlignment(MemSetInst& I)
 {
     // Set the align attribute of the memset according to the detected
     // alignment of its operand.
-#if LLVM_VERSION_MAJOR == 4
-    unsigned alignment = iSTD::Max(I.getAlignment(), getAlignValue(I.getRawDest()));
-    I.setAlignment(ConstantInt::get(Type::getInt32Ty(I.getContext()), alignment));
-#elif LLVM_VERSION_MAJOR >= 7
+#if LLVM_VERSION_MAJOR >= 14
+    uint64_t alignment_value = iSTD::Max(I.getDestAlign()->value(), getAlignValue(I.getRawDest()));
+    llvm::Align alignment = llvm::Align(alignment_value);
+    I.setDestAlignment(alignment);
+#else
     unsigned alignment = iSTD::Max(I.getDestAlignment(), getAlignValue(I.getRawDest()));
     I.setDestAlignment(alignment);
 #endif
@@ -449,12 +533,12 @@ void AlignmentAnalysis::SetInstAlignment(MemSetInst& I)
 void AlignmentAnalysis::SetInstAlignment(MemCpyInst& I)
 {
     // Set the align attribute of the memcpy based on the minimum alignment of its source and dest fields
+#if LLVM_VERSION_MAJOR >= 14
+    uint64_t alignment_value = iSTD::Min(getAlignValue(I.getRawDest()), getAlignValue(I.getRawSource()));
+    llvm::Align alignment = llvm::Align(alignment_value);
+    I.setDestAlignment(alignment);
+#else
     unsigned alignment = iSTD::Min(getAlignValue(I.getRawDest()), getAlignValue(I.getRawSource()));
-#if LLVM_VERSION_MAJOR == 4
-    alignment = iSTD::Max(I.getAlignment(), alignment);
-    I.setAlignment(ConstantInt::get(Type::getInt32Ty(I.getContext()), alignment));
-#elif LLVM_VERSION_MAJOR >= 7
-    alignment = iSTD::Max(I.getDestAlignment(), alignment);
     I.setDestAlignment(alignment);
 #endif
 }
@@ -462,91 +546,13 @@ void AlignmentAnalysis::SetInstAlignment(MemCpyInst& I)
 void AlignmentAnalysis::SetInstAlignment(MemMoveInst& I)
 {
     // Set the align attribute of the memmove based on the minimum alignment of its source and dest fields
+#if LLVM_VERSION_MAJOR >= 14
+    uint64_t alignment_value = iSTD::Min(getAlignValue(I.getRawDest()), getAlignValue(I.getRawSource()));
+    llvm::Align alignment = llvm::max(I.getDestAlign(), llvm::Align(alignment_value));
+    I.setDestAlignment(alignment);
+#else
     unsigned alignment = iSTD::Min(getAlignValue(I.getRawDest()), getAlignValue(I.getRawSource()));
-#if LLVM_VERSION_MAJOR == 4
-    alignment = iSTD::Max(I.getAlignment(), alignment);
-    I.setAlignment(ConstantInt::get(Type::getInt32Ty(I.getContext()), alignment));
-#elif LLVM_VERSION_MAJOR >= 7
     alignment = iSTD::Max(I.getDestAlignment(), alignment);
     I.setDestAlignment(alignment);
 #endif
 }
-
-unsigned int AlignmentAnalysis::getAlignValue(Value* V) const
-{
-    if (dyn_cast<Instruction>(V))
-    {
-        auto iter = m_alignmentMap.find(V);
-        if (iter == m_alignmentMap.end())
-        {
-            // Instructions are initialize to maximum alignment
-            // (this is the "top" value)
-            return Value::MaximumAlignment;
-        }
-
-        return iter->second;
-    }
-    else if (dyn_cast<Constant>(V))
-    {
-        if (ConstantInt * constInt = dyn_cast<ConstantInt>(V))
-        {
-            return getConstantAlignment(constInt->getZExtValue());
-        }
-        else if (GlobalVariable * GV = dyn_cast<GlobalVariable>(V))
-        {
-            unsigned int align = GV->getAlignment();
-
-            // If the globalvariable uses the default alignment, pull it from the datalayout
-            if (!align)
-            {
-                Type* gvType = GV->getType();
-                return m_DL->getABITypeAlignment(gvType->getPointerElementType());
-            }
-            else
-            {
-                return align;
-            }
-        }
-
-        // Not an int or a globalvariable, be pessimistic.
-        return MinimumAlignment;
-    }
-    else if (Argument * arg = dyn_cast<Argument>(V))
-    {
-        if (arg->getType()->isPointerTy())
-        {
-            // Pointer arguments are guaranteed to be aligned on the ABI alignment
-            Type* pointedTo = arg->getType()->getPointerElementType();
-            if (pointedTo->isSized())
-            {
-                return m_DL->getABITypeAlignment(pointedTo);
-            }
-            else
-            {
-                // We have some pointer-to-opaque-types which are not real pointers -
-                // this is used to pass things like images around.
-                // Apparently, DataLayout being asked about the ABI alignment of opaque types.
-                // So, we don't.
-                return MinimumAlignment;
-            }
-        }
-        else
-        {
-            // We don't know anything about integer arguments.
-            return MinimumAlignment;
-        }
-    }
-
-    // Be pessimistic
-    return MinimumAlignment;
-}
-
-unsigned int AlignmentAnalysis::getConstantAlignment(uint64_t C) const
-{
-    if (!C)
-    {
-        return Value::MaximumAlignment;
-    }
-
-    return iSTD::Min(Value::MaximumAlignment, 1U << llvm::countTrailingZeros(C));
-}
diff --git a/IGC/Compiler/Optimizer/OpenCLPasses/AlignmentAnalysis/AlignmentAnalysis.hpp b/IGC/Compiler/Optimizer/OpenCLPasses/AlignmentAnalysis/AlignmentAnalysis.hpp
index 8836958bb..79a2d5d29 100644
--- a/IGC/Compiler/Optimizer/OpenCLPasses/AlignmentAnalysis/AlignmentAnalysis.hpp
+++ b/IGC/Compiler/Optimizer/OpenCLPasses/AlignmentAnalysis/AlignmentAnalysis.hpp
@@ -88,12 +88,12 @@ namespace IGC
         /// @brief Returns the alignment for V, if it is known.
         ///        Otherwise, returns the maximum alignment.
         /// @param V the value the alignment of which we're interested in
-        unsigned int getAlignValue(llvm::Value* V) const;
+        auto getAlignValue(llvm::Value* V) const;
 
         /// @brief Returns the alignment of a constant integer.
         ///        This is normally 1 << ctz(C) (the highest power of 2 that divides C),
         ///        except when C is 0, when it is the max alignment
-        unsigned int getConstantAlignment(uint64_t C) const;
+        auto getConstantAlignment(uint64_t C) const;
 
         /// @brief This map stores the known alignment of every value.
         llvm::MapVector<llvm::Value*, unsigned int> m_alignmentMap;
diff --git a/IGC/Compiler/Optimizer/OpenCLPasses/Atomics/ResolveOCLAtomics.cpp b/IGC/Compiler/Optimizer/OpenCLPasses/Atomics/ResolveOCLAtomics.cpp
index 2f6d8da50..fca2938da 100644
--- a/IGC/Compiler/Optimizer/OpenCLPasses/Atomics/ResolveOCLAtomics.cpp
+++ b/IGC/Compiler/Optimizer/OpenCLPasses/Atomics/ResolveOCLAtomics.cpp
@@ -106,7 +106,7 @@ void ResolveOCLAtomics::processOCLAtomic(CallInst& callInst, AtomicOp op, Buffer
     // Generate a call to GenISA_dwordatomic intrinsic.
     GenISAIntrinsic::ID genIsaIntrinID;
 
-    const bool noSources = (callInst.getNumArgOperands() == 1);
+    const bool noSources = (IGCLLVM::getNumArgOperands(&callInst) == 1);
     // For atomics w/o sources (atomic_inc and atomic_dec), src0 should be absent.
     // However, we cannot pass nullptr as argument, so we set src0 = "0" and it
     // will be ignored in EmitPass::emitAtomicRaw.
diff --git a/IGC/Compiler/Optimizer/OpenCLPasses/DebuggerSupport/ImplicitGIDPass.cpp b/IGC/Compiler/Optimizer/OpenCLPasses/DebuggerSupport/ImplicitGIDPass.cpp
index be493117b..9f1fddc69 100644
--- a/IGC/Compiler/Optimizer/OpenCLPasses/DebuggerSupport/ImplicitGIDPass.cpp
+++ b/IGC/Compiler/Optimizer/OpenCLPasses/DebuggerSupport/ImplicitGIDPass.cpp
@@ -8,7 +8,7 @@ SPDX-License-Identifier: MIT
 
 #include "common/LLVMWarningsPush.hpp"
 #include "llvm/Config/llvm-config.h"
-#include "llvm/IR/Attributes.h"
+#include "llvmWrapper/IR/Attributes.h"
 #include "llvmWrapper/IR/DerivedTypes.h"
 #include "common/LLVMWarningsPop.hpp"
 #include "Compiler/Optimizer/OpenCLPasses/DebuggerSupport/ImplicitGIDPass.hpp"
@@ -305,7 +305,7 @@ Value* ImplicitGlobalId::CreateGetId(IRBuilder<>& B, GlobalOrLocal wi)
 
         // Set function attributes
         AttributeList funcAttrs;
-        AttrBuilder attBuilder;
+        IGCLLVM::AttrBuilder attBuilder{ pNewFunc->getContext() };
         attBuilder.addAttribute(Attribute::NoUnwind).addAttribute(Attribute::ReadNone);
         funcAttrs = AttributeList::get(pNewFunc->getContext(), AttributeList::FunctionIndex, attBuilder);
         pNewFunc->setAttributes(funcAttrs);
diff --git a/IGC/Compiler/Optimizer/OpenCLPasses/DeviceEnqueueFuncs/DeviceEnqueue.cpp b/IGC/Compiler/Optimizer/OpenCLPasses/DeviceEnqueueFuncs/DeviceEnqueue.cpp
index e9146057d..6f3d226ab 100644
--- a/IGC/Compiler/Optimizer/OpenCLPasses/DeviceEnqueueFuncs/DeviceEnqueue.cpp
+++ b/IGC/Compiler/Optimizer/OpenCLPasses/DeviceEnqueueFuncs/DeviceEnqueue.cpp
@@ -126,7 +126,7 @@ void DeviceEnqueueFuncsAnalysis::visitCallInst(CallInst& CI)
     else if (funcName == GET_OBJECT_ID)
     {
         // Extract the arg num and add it to the appropriate data structure
-        IGC_ASSERT_MESSAGE(CI.getNumArgOperands() == 1, "get_object_id function is expected to have only one argument");
+        IGC_ASSERT_MESSAGE(IGCLLVM::getNumArgOperands(&CI) == 1, "get_object_id function is expected to have only one argument");
 
         // We support only compile-time constants as arguments of get_object_id()
         ConstantInt* callArg = dyn_cast<ConstantInt>(CI.getArgOperand(0));
@@ -138,7 +138,7 @@ void DeviceEnqueueFuncsAnalysis::visitCallInst(CallInst& CI)
     else if (funcName == GET_BLOCK_SIMD_SIZE)
     {
         // Extract the arg num and add it to the appropriate data structure
-        IGC_ASSERT_MESSAGE(CI.getNumArgOperands() == 1, "get_block_simd_size function is expected to have only one argument");
+        IGC_ASSERT_MESSAGE(IGCLLVM::getNumArgOperands(&CI) == 1, "get_block_simd_size function is expected to have only one argument");
 
         // We support only compile-time constants as arguments of get_object_id()
         ConstantInt* callArg = dyn_cast<ConstantInt>(CI.getArgOperand(0));
diff --git a/IGC/Compiler/Optimizer/OpenCLPasses/DeviceEnqueueFuncs/TransformBlocks.cpp b/IGC/Compiler/Optimizer/OpenCLPasses/DeviceEnqueueFuncs/TransformBlocks.cpp
index 9d192a512..9e1021fbc 100644
--- a/IGC/Compiler/Optimizer/OpenCLPasses/DeviceEnqueueFuncs/TransformBlocks.cpp
+++ b/IGC/Compiler/Optimizer/OpenCLPasses/DeviceEnqueueFuncs/TransformBlocks.cpp
@@ -25,7 +25,7 @@ SPDX-License-Identifier: MIT
 #include "llvmWrapper/IR/Module.h"
 #include "llvm/IR/Argument.h"
 #include "llvmWrapper/IR/Instructions.h"
-#include "llvm/IR/Attributes.h"
+#include "llvmWrapper/IR/Attributes.h"
 #include "llvmWrapper/IR/IRBuilder.h"
 #include "llvm/IR/ValueHandle.h"
 #include "llvmWrapper/Transforms/Utils.h"
@@ -46,6 +46,7 @@ SPDX-License-Identifier: MIT
 #include "llvm/Support/CommandLine.h"
 #include "llvmWrapper/IR/DIBuilder.h"
 #include "common/LLVMWarningsPop.hpp"
+#include "llvm/Support/Regex.h"
 #include <algorithm>
 #include <map>
 #include <unordered_set>
@@ -838,7 +839,7 @@ namespace //Anonymous
             : ObjCBlockCallArgs(call, dataContext)
             , _block(nullptr)
         {
-            auto arg = call.arg_operands().begin();
+            auto arg = IGCLLVM::args(call).begin();
 
             _queue = *(arg++);
             _flags = *(arg++);
@@ -852,7 +853,7 @@ namespace //Anonymous
 
             _block = *(arg++);
 
-            while (arg != call.arg_operands().end())
+            while (arg != IGCLLVM::args(call).end())
             {
                 if ((*arg)->getType()->isIntegerTy(32))
                 {
@@ -928,7 +929,7 @@ namespace //Anonymous
         SPIRVOpEnqueueKernelCallArgs(llvm::CallInst& call, DataContext& dataContext)
             : DeviceExecCallArgs(call, dataContext)
         {
-            IGC_ASSERT_EXIT_MESSAGE(8 <= _call.getNumArgOperands(), "OpEnqueueKernel signature does not match");
+            IGC_ASSERT_EXIT_MESSAGE(8 <= IGCLLVM::getNumArgOperands(&_call), "OpEnqueueKernel signature does not match");
 
             _queue = _call.getArgOperand(0);
             _flags = _call.getArgOperand(1);
@@ -948,7 +949,7 @@ namespace //Anonymous
             }
 
             const unsigned localSizesStartArgNum = 10;
-            const unsigned argsNum = _call.getNumArgOperands();
+            const unsigned argsNum = IGCLLVM::getNumArgOperands(&_call);
             for (unsigned i = localSizesStartArgNum; i < argsNum; i++)
             {
                 auto arg = _call.getArgOperand(i);
@@ -1564,7 +1565,7 @@ namespace //Anonymous
                     auto callInst = dyn_cast<CallInst>(user);
                     if (!callInst) continue;
 
-                    for (auto& arg : callInst->arg_operands()) {
+                    for (auto& arg : IGCLLVM::args(callInst)) {
                         if (Function * invoke = dyn_cast<Function>(arg)) {
                             if (isInvokeFunctionKernelWrapper(invoke, dataContext)) {
                                 // Inline the wrapped invoke function.
@@ -1609,7 +1610,7 @@ namespace //Anonymous
                             {
                                 // assuming indirect call is the block call
                                 unsigned blockArgIdx = callInst->hasStructRetAttr() ? 1 : 0;
-                                if (callInst->getNumArgOperands() > blockArgIdx)
+                                if (IGCLLVM::getNumArgOperands(callInst) > blockArgIdx)
                                 {
                                     Value* spc = callInst->getArgOperand(blockArgIdx)->stripPointerCasts();
                                     if (KindQuery::isBlockStructType(spc->getType()))
@@ -2450,7 +2451,9 @@ namespace //Anonymous
                 {
                     // FIXME: This potentially can be rewritted to be simpler.
                     AttributeList attrSet = AttributeList::get(arg.getParent()->getContext(), AttributeList::FunctionIndex, llvm::Attribute::ByVal);
-                    arg.addAttr(attrSet.getAttribute(AttributeList::FunctionIndex, llvm::Attribute::ByVal));
+                    arg.addAttr(
+                        IGCLLVM::getAttribute(attrSet, AttributeList::FunctionIndex, llvm::Attribute::ByVal)
+                    );
                     ++byValI;
                 }
             }
diff --git a/IGC/Compiler/Optimizer/OpenCLPasses/ExtensionFuncs/ExtensionFuncResolution.cpp b/IGC/Compiler/Optimizer/OpenCLPasses/ExtensionFuncs/ExtensionFuncResolution.cpp
index 12ce92eb9..de1668c4c 100644
--- a/IGC/Compiler/Optimizer/OpenCLPasses/ExtensionFuncs/ExtensionFuncResolution.cpp
+++ b/IGC/Compiler/Optimizer/OpenCLPasses/ExtensionFuncs/ExtensionFuncResolution.cpp
@@ -73,7 +73,7 @@ void ExtensionFuncsResolution::visitCallInst(CallInst& CI)
     }
     else if (funcName.startswith(ExtensionFuncsAnalysis::VME_HELPER_GET_HANDLE)) {
         // Load from the opaque vme pointer and return the a vector with values.
-        IGC_ASSERT(CI.getNumArgOperands() == 1);
+        IGC_ASSERT(IGCLLVM::getNumArgOperands(&CI) == 1);
         IGCLLVM::IRBuilder<> builder(&CI);
         Type* retType = CI.getType();
         IGC_ASSERT(retType->isVectorTy() || retType->isIntegerTy());
@@ -86,7 +86,7 @@ void ExtensionFuncsResolution::visitCallInst(CallInst& CI)
     }
     else if (funcName.startswith(ExtensionFuncsAnalysis::VME_HELPER_GET_AS)) {
         // Store the VME values and return an opaque vme pointer.
-        IGC_ASSERT(CI.getNumArgOperands() == 1);
+        IGC_ASSERT(IGCLLVM::getNumArgOperands(&CI) == 1);
         IGCLLVM::IRBuilder<> builder(&*CI.getParent()->getParent()->begin()->getFirstInsertionPt());
         Type* retType = CI.getType();
         Value* arg = CI.getArgOperand(0);
diff --git a/IGC/Compiler/Optimizer/OpenCLPasses/GenericAddressResolution/GenericAddressDynamicResolution.cpp b/IGC/Compiler/Optimizer/OpenCLPasses/GenericAddressResolution/GenericAddressDynamicResolution.cpp
index 2f9f1054b..b22dd7b82 100644
--- a/IGC/Compiler/Optimizer/OpenCLPasses/GenericAddressResolution/GenericAddressDynamicResolution.cpp
+++ b/IGC/Compiler/Optimizer/OpenCLPasses/GenericAddressResolution/GenericAddressDynamicResolution.cpp
@@ -400,7 +400,7 @@ bool GenericAddressDynamicResolution::visitIntrinsicCall(CallInst& I)
     if ((funcName == "__builtin_IB_to_private") || (funcName == "__builtin_IB_to_local")
         || (funcName == "__builtin_IB_to_global"))
     {
-        IGC_ASSERT(I.getNumArgOperands() == 1);
+        IGC_ASSERT(IGCLLVM::getNumArgOperands(&I) == 1);
         Value* arg = I.getArgOperand(0);
         PointerType* dstType = dyn_cast<PointerType>(I.getType());
         IGC_ASSERT( dstType != nullptr );
diff --git a/IGC/Compiler/Optimizer/OpenCLPasses/ImageFuncs/ImageFuncsAnalysis.cpp b/IGC/Compiler/Optimizer/OpenCLPasses/ImageFuncs/ImageFuncsAnalysis.cpp
index c07937626..54c59cff6 100644
--- a/IGC/Compiler/Optimizer/OpenCLPasses/ImageFuncs/ImageFuncsAnalysis.cpp
+++ b/IGC/Compiler/Optimizer/OpenCLPasses/ImageFuncs/ImageFuncsAnalysis.cpp
@@ -164,7 +164,7 @@ void ImageFuncsAnalysis::visitCallInst(CallInst& CI)
     }
 
     // Extract the arg num and add it to the appropriate data structure
-    IGC_ASSERT_MESSAGE(CI.getNumArgOperands() == 1, "Supported image/sampler functions are expected to have only one argument");
+    IGC_ASSERT_MESSAGE(IGCLLVM::getNumArgOperands(&CI) == 1, "Supported image/sampler functions are expected to have only one argument");
 
     // We only care about image and sampler arguments here, inline samplers
     // don't require extra kernel parameters.
diff --git a/IGC/Compiler/Optimizer/OpenCLPasses/ImageFuncs/ResolveSampledImageBuiltins.cpp b/IGC/Compiler/Optimizer/OpenCLPasses/ImageFuncs/ResolveSampledImageBuiltins.cpp
index df3169d8d..d0c8bc079 100644
--- a/IGC/Compiler/Optimizer/OpenCLPasses/ImageFuncs/ResolveSampledImageBuiltins.cpp
+++ b/IGC/Compiler/Optimizer/OpenCLPasses/ImageFuncs/ResolveSampledImageBuiltins.cpp
@@ -11,6 +11,7 @@ SPDX-License-Identifier: MIT
 #include "common/LLVMWarningsPush.hpp"
 #include <llvm/IR/Function.h>
 #include <llvm/IR/Instructions.h>
+#include <llvmWrapper/IR/Instructions.h>
 #include "common/LLVMWarningsPop.hpp"
 #include "Probe/Assertion.h"
 
@@ -96,7 +97,7 @@ void ResolveSampledImageBuiltins::visitCallInst(CallInst& CI)
 
 Value* ResolveSampledImageBuiltins::lowerGetImage(CallInst& CI)
 {
-    IGC_ASSERT(CI.getNumArgOperands() == 1);
+    IGC_ASSERT(IGCLLVM::getNumArgOperands(&CI) == 1);
 
     CallInst* callReturningOpaque = dyn_cast<CallInst>(CI.getArgOperand(0)->stripPointerCasts());
     IGC_ASSERT(callReturningOpaque);
@@ -127,7 +128,7 @@ Value* ResolveSampledImageBuiltins::lowerGetImage(CallInst& CI)
 
 Value* ResolveSampledImageBuiltins::lowerGetSampler(CallInst& CI)
 {
-    IGC_ASSERT(CI.getNumArgOperands() == 1);
+    IGC_ASSERT(IGCLLVM::getNumArgOperands(&CI) == 1);
     CallInst* callReturningOpaque = dyn_cast<CallInst>(CI.getArgOperand(0)->stripPointerCasts());
     IGC_ASSERT(callReturningOpaque);
 
diff --git a/IGC/Compiler/Optimizer/OpenCLPasses/OpenCLPrintf/OpenCLPrintfResolution.cpp b/IGC/Compiler/Optimizer/OpenCLPasses/OpenCLPrintf/OpenCLPrintfResolution.cpp
index 6042096ba..795b20656 100644
--- a/IGC/Compiler/Optimizer/OpenCLPasses/OpenCLPrintf/OpenCLPrintfResolution.cpp
+++ b/IGC/Compiler/Optimizer/OpenCLPasses/OpenCLPrintf/OpenCLPrintfResolution.cpp
@@ -746,7 +746,7 @@ Value* OpenCLPrintfResolution::fixupPrintfArg(CallInst& printfCall, Value* arg,
 
 void OpenCLPrintfResolution::preprocessPrintfArgs(CallInst& printfCall)
 {
-    for (int i = 0, numArgs = printfCall.getNumArgOperands(); i < numArgs; ++i)
+    for (int i = 0, numArgs = IGCLLVM::getNumArgOperands(&printfCall); i < numArgs; ++i)
     {
         Value* arg = printfCall.getOperand(i);
         Type* argType = arg->getType();
diff --git a/IGC/Compiler/Optimizer/OpenCLPasses/RayTracing/ResolveOCLRaytracingBuiltins.cpp b/IGC/Compiler/Optimizer/OpenCLPasses/RayTracing/ResolveOCLRaytracingBuiltins.cpp
index f97b474f7..13bf3af7a 100644
--- a/IGC/Compiler/Optimizer/OpenCLPasses/RayTracing/ResolveOCLRaytracingBuiltins.cpp
+++ b/IGC/Compiler/Optimizer/OpenCLPasses/RayTracing/ResolveOCLRaytracingBuiltins.cpp
@@ -277,7 +277,7 @@ The return value of this function is a sync object which will be used by the ker
 */
 void ResolveOCLRaytracingBuiltins::handleDispatchTraceRayQuery(CallInst& callInst) {
   IGC_ASSERT(callInst.getType()->isPointerTy());
-  IGC_ASSERT(callInst.getNumArgOperands() == 3);
+  IGC_ASSERT(IGCLLVM::getNumArgOperands(&callInst) == 3);
 
   // Insert a ugm fence prior to send.rta to ensure RTUnit has accesss to
   // current data.
diff --git a/IGC/Compiler/Optimizer/OpenCLPasses/ReplaceUnsupportedIntrinsics/ReplaceUnsupportedIntrinsics.cpp b/IGC/Compiler/Optimizer/OpenCLPasses/ReplaceUnsupportedIntrinsics/ReplaceUnsupportedIntrinsics.cpp
index 68ee39a22..d1623a01b 100644
--- a/IGC/Compiler/Optimizer/OpenCLPasses/ReplaceUnsupportedIntrinsics/ReplaceUnsupportedIntrinsics.cpp
+++ b/IGC/Compiler/Optimizer/OpenCLPasses/ReplaceUnsupportedIntrinsics/ReplaceUnsupportedIntrinsics.cpp
@@ -137,7 +137,7 @@ ReplaceUnsupportedIntrinsics::ReplaceUnsupportedIntrinsics() : FunctionPass(ID)
 MemCpyInst* ReplaceUnsupportedIntrinsics::MemMoveToMemCpy(MemMoveInst* MM)
 {
     SmallVector<Value*, 5> args;
-    for (unsigned i = 0; i < MM->getNumArgOperands(); i++)
+    for (unsigned i = 0; i < IGCLLVM::getNumArgOperands(MM); i++)
         args.push_back(MM->getArgOperand(i));
 
     auto* Dst = MM->getRawDest();
diff --git a/IGC/Compiler/Optimizer/OpenCLPasses/TransformUnmaskedFunctionsPass.cpp b/IGC/Compiler/Optimizer/OpenCLPasses/TransformUnmaskedFunctionsPass.cpp
index ef34ab64d..40e4b1536 100644
--- a/IGC/Compiler/Optimizer/OpenCLPasses/TransformUnmaskedFunctionsPass.cpp
+++ b/IGC/Compiler/Optimizer/OpenCLPasses/TransformUnmaskedFunctionsPass.cpp
@@ -22,6 +22,7 @@ SPDX-License-Identifier: MIT
 #include "llvm/IR/Function.h"
 #include "llvm/ADT/SetVector.h"
 #include "llvmWrapper/IR/Constant.h"
+#include "llvmWrapper/IR/InstrTypes.h"
 #include "llvmWrapper/Transforms/Utils/Cloning.h"
 #include "common/LLVMWarningsPop.hpp"
 #include "Probe/Assertion.h"
@@ -159,7 +160,7 @@ static TrivialUniformity checkCallInst(const CallInst* CI, UniformityCache *Cach
     if (result.kind == TrivialUniformity::FORMAL_ARG) {
         /* If uniformity of the function depends on a formal argument, check if all actual arguments are uniform: */
         result = TrivialUniformity::Unifrom();
-        const size_t count = CI->getNumArgOperands();
+        const size_t count = IGCLLVM::getNumArgOperands(CI);
         for (size_t i = 0; i < count; ++i) {
             result = mergeUnifromity(result, checkValue(CI->getArgOperand(i), Cache));
             if (result.kind == TrivialUniformity::NONUNIFORM) {
@@ -254,9 +255,9 @@ bool TransformUnmaskedFunctionsPass::runOnFunction(llvm::Function& F)
     for (User *U : F.users()) {
         if (CallInst* CI = dyn_cast<CallInst>(U)) {
             if (CI->hasFnAttr(llvm::Attribute::AlwaysInline)) {
-                CI->removeAttribute(AttributeList::FunctionIndex, llvm::Attribute::AlwaysInline);
+                IGCLLVM::removeFnAttr(CI, llvm::Attribute::AlwaysInline);
             }
-            CI->addAttribute(AttributeList::FunctionIndex, llvm::Attribute::NoInline);
+            IGCLLVM::addFnAttr(CI, llvm::Attribute::NoInline);
         }
     }
     return true;
diff --git a/IGC/Compiler/Optimizer/PreCompiledFuncImport.cpp b/IGC/Compiler/Optimizer/PreCompiledFuncImport.cpp
index e07fa1231..785ff59c5 100644
--- a/IGC/Compiler/Optimizer/PreCompiledFuncImport.cpp
+++ b/IGC/Compiler/Optimizer/PreCompiledFuncImport.cpp
@@ -13,7 +13,7 @@ SPDX-License-Identifier: MIT
 #include "llvm/IR/Module.h"
 #include "llvmWrapper/IR/DerivedTypes.h"
 #include "llvmWrapper/IR/IRBuilder.h"
-#include "llvm/IR/Function.h"
+#include "llvmWrapper/IR/Function.h"
 #include "llvm/IR/InstIterator.h"
 #include "llvm/Support/MemoryBuffer.h"
 #include "llvm/Support/GenericDomTree.h"
@@ -514,7 +514,7 @@ bool PreCompiledFuncImport::runOnModule(Module& M)
 
         types.push_back(CI->getType());
 
-        for (unsigned i = 0; i < CI->getNumArgOperands(); i++)
+        for (unsigned i = 0; i < IGCLLVM::getNumArgOperands(CI); i++)
         {
             types.push_back(CI->getArgOperand(i)->getType());
             args.push_back(CI->getArgOperand(i));
@@ -950,7 +950,7 @@ void PreCompiledFuncImport::processInt32Divide(BinaryOperator& inst, Int32Emulat
             funcName,
             m_pModule);
     }
-    func->addAttribute(0, llvm::Attribute::AlwaysInline);
+    IGCLLVM::addRetAttr(func, llvm::Attribute::AlwaysInline);
 
 
 
@@ -2082,7 +2082,7 @@ void PreCompiledFuncImport::replaceFunc(Function* old_func, Function* new_func)
             return;
         }
         Function* parent_func = cInst->getParent()->getParent();
-        size_t numArgOperands = cInst->getNumArgOperands();
+        size_t numArgOperands = IGCLLVM::getNumArgOperands(cInst);
 
         // let's prepare argument list on new call function
         llvm::Function::arg_iterator new_arg_iter = new_func->arg_begin();
diff --git a/IGC/Compiler/Optimizer/Scalarizer.cpp b/IGC/Compiler/Optimizer/Scalarizer.cpp
index c3b6cfcd1..67c33fac5 100644
--- a/IGC/Compiler/Optimizer/Scalarizer.cpp
+++ b/IGC/Compiler/Optimizer/Scalarizer.cpp
@@ -196,7 +196,7 @@ void ScalarizeFunction::buildExclusiveSet()
         std::vector<llvm::Value*> workset;
         if (GenIntrinsicInst * GII = dyn_cast<GenIntrinsicInst>(currInst))
         {
-            unsigned numOperands = GII->getNumArgOperands();
+            unsigned numOperands = IGCLLVM::getNumArgOperands(GII);
             for (unsigned i = 0; i < numOperands; i++)
             {
                 Value* operand = GII->getArgOperand(i);
@@ -391,7 +391,7 @@ void ScalarizeFunction::recoverNonScalarizableInst(Instruction* Inst)
     // Iterate over all arguments. Check that they all exist (or rebuilt)
     if (CallInst * CI = dyn_cast<CallInst>(Inst))
     {
-        unsigned numOperands = CI->getNumArgOperands();
+        unsigned numOperands = IGCLLVM::getNumArgOperands(CI);
         for (unsigned i = 0; i < numOperands; i++)
         {
             Value* operand = CI->getArgOperand(i);
diff --git a/IGC/Compiler/PromoteResourceToDirectAS.cpp b/IGC/Compiler/PromoteResourceToDirectAS.cpp
index 4d9ccf20c..b6f6fc3ac 100644
--- a/IGC/Compiler/PromoteResourceToDirectAS.cpp
+++ b/IGC/Compiler/PromoteResourceToDirectAS.cpp
@@ -700,7 +700,7 @@ void PromoteResourceToDirectAS::PromoteBufferToDirectAS(Instruction* inst, Value
 
             args.push_back(sourcePointer);
             args.push_back(bufferAddress);
-            for (unsigned i = 2; i < pIntr->getNumArgOperands(); i++)
+            for (unsigned i = 2; i < IGCLLVM::getNumArgOperands(pIntr); i++)
             {
                 args.push_back(pIntr->getArgOperand(i));
             }
diff --git a/IGC/DebugInfo/StreamEmitter.cpp b/IGC/DebugInfo/StreamEmitter.cpp
index 00a210fea..60efdac2d 100644
--- a/IGC/DebugInfo/StreamEmitter.cpp
+++ b/IGC/DebugInfo/StreamEmitter.cpp
@@ -16,6 +16,7 @@ See LICENSE.TXT for details.
 // clang-format off
 #include "common/LLVMWarningsPush.hpp"
 #include "llvmWrapper/ADT/STLExtras.h"
+#include "llvmWrapper/MC/MCStreamer.h"
 #include "llvm/IR/DataLayout.h"
 #include "llvm/IR/GlobalValue.h"
 #include "llvm/MC/MCAsmBackend.h"
@@ -32,7 +33,7 @@ See LICENSE.TXT for details.
 #include "llvm/MC/MCSymbol.h"
 #include "llvm/MC/MCValue.h"
 #include "llvm/Support/SourceMgr.h"
-#include "llvm/Support/TargetRegistry.h"
+#include "llvmWrapper/Support/TargetRegistry.h"
 #include "common/LLVMWarningsPop.hpp"
 // clang-format on
 
@@ -322,7 +323,16 @@ public:
   }
 #endif
 
-  bool writeNopData(raw_ostream &OS, uint64_t Count) const override {
+#if LLVM_VERSION_MAJOR < 14
+  bool writeNopData(raw_ostream &OS, uint64_t Count) const override
+  {
+      return writeNopData(OS, Count, nullptr);
+  }
+
+  bool writeNopData(raw_ostream &OS, uint64_t Count, const MCSubtargetInfo *STI) const {
+#else
+  bool writeNopData(raw_ostream &OS, uint64_t Count, const MCSubtargetInfo *STI) const override {
+#endif
     const char nop = (char)0x90;
     for (uint64_t i = 0; i < Count; ++i) {
       OS.write(&nop, 1);
@@ -417,7 +427,7 @@ StreamEmitter::StreamEmitter(raw_pwrite_stream &outStream,
                                     std::move(pObjectWriter),
                                     std::move(pCodeEmitter), isRelaxAll);
 
-  m_pMCStreamer->InitSections(isNoExecStack);
+  IGCLLVM::initSections(m_pMCStreamer, isNoExecStack, m_pContext);
 }
 
 StreamEmitter::~StreamEmitter() {
diff --git a/IGC/GenISAIntrinsics/GenIntrinsicInst.h b/IGC/GenISAIntrinsics/GenIntrinsicInst.h
index 50217d0bc..4b4df813f 100644
--- a/IGC/GenISAIntrinsics/GenIntrinsicInst.h
+++ b/IGC/GenISAIntrinsics/GenIntrinsicInst.h
@@ -34,7 +34,6 @@ See LICENSE.TXT for details.
 #include "common/LLVMWarningsPush.hpp"
 #include "llvm/IR/Constants.h"
 #include "llvm/IR/Function.h"
-#include "llvm/IR/Instructions.h"
 #include "llvm/IR/IRBuilder.h"
 #include "llvm/IR/Module.h"
 #include "common/LLVMWarningsPop.hpp"
@@ -44,6 +43,8 @@ See LICENSE.TXT for details.
 #include "GenIntrinsics.h"
 #include "Probe/Assertion.h"
 
+#include "llvmWrapper/IR/Instructions.h"
+
 namespace llvm {
 /// IntrinsicInst - A useful wrapper class for inspecting calls to intrinsic
 /// functions.  This allows the standard isa/dyncast/cast functionality to
@@ -322,19 +323,19 @@ class LdMSIntrinsic : public SamplerLoadIntrinsic {
 public:
     inline Value* getImmOffset(unsigned int i)
     {
-        return getOperand(getNumArgOperands() - 3 + i);
+        return getOperand(arg_size() - 3 + i);
     }
     inline void setImmOffset(unsigned int i, Value* val)
     {
-        return setOperand(getNumArgOperands() - 3 + i, val);
+        return setOperand(arg_size() - 3 + i, val);
     }
     inline Value* getCoordinate(unsigned int i)
     {
-        return getOperand(getNumArgOperands() - 8 + i);
+        return getOperand(arg_size() - 8 + i);
     }
     inline void setCoordinate(unsigned int i, Value* val)
     {
-        return setOperand(getNumArgOperands() - 8 + i, val);
+        return setOperand(arg_size() - 8 + i, val);
     }
     static inline bool classof(const GenIntrinsicInst *I) {
         switch(I->getIntrinsicID()) {
diff --git a/IGC/LLVM3DBuilder/BuiltinsFrontendDefinitions.hpp b/IGC/LLVM3DBuilder/BuiltinsFrontendDefinitions.hpp
index 7e8074bde..c9f20115f 100644
--- a/IGC/LLVM3DBuilder/BuiltinsFrontendDefinitions.hpp
+++ b/IGC/LLVM3DBuilder/BuiltinsFrontendDefinitions.hpp
@@ -3736,13 +3736,12 @@ inline llvm::Value* LLVM3DBuilder<preserveNames, T, Inserter>::create_wavePrefix
 inline llvm::CallInst* setUnsafeToHoistAttr(llvm::CallInst *CI)
     {
         CI->setConvergent();
-#if LLVM_VERSION_MAJOR >= 7
+#if LLVM_VERSION_MAJOR >= 14
         CI->setOnlyAccessesInaccessibleMemory();
-        CI->removeAttribute(llvm::AttributeList::FunctionIndex, llvm::Attribute::ReadNone);
+        CI->removeAttributeAtIndex(llvm::AttributeList::FunctionIndex, llvm::Attribute::ReadNone);
 #else
-        CI->addAttribute(
-            llvm::AttributeSet::FunctionIndex, llvm::Attribute::InaccessibleMemOnly);
-        CI->removeAttribute(llvm::AttributeSet::FunctionIndex, llvm::Attribute::ReadNone);
+        CI->setOnlyAccessesInaccessibleMemory();
+        CI->removeAttribute(llvm::AttributeList::FunctionIndex, llvm::Attribute::ReadNone);
 #endif
         llvm::OperandBundleDef OpDef("nohoist", llvm::None);
 
diff --git a/IGC/VectorCompiler/CMCL/tools/Translator/Main.cpp b/IGC/VectorCompiler/CMCL/tools/Translator/Main.cpp
index f1b3214a0..c7e23271d 100644
--- a/IGC/VectorCompiler/CMCL/tools/Translator/Main.cpp
+++ b/IGC/VectorCompiler/CMCL/tools/Translator/Main.cpp
@@ -8,6 +8,7 @@ SPDX-License-Identifier: MIT
 
 #include "cmcl/Support/BuiltinTranslator.h"
 
+#include <llvm/Pass.h>
 #include <llvm/Bitcode/BitcodeWriterPass.h>
 #include <llvm/IR/IRPrintingPasses.h>
 #include <llvm/IR/LLVMContext.h>
diff --git a/IGC/VectorCompiler/include/vc/GenXCodeGen/TargetMachine.h b/IGC/VectorCompiler/include/vc/GenXCodeGen/TargetMachine.h
index d0ce2942a..9e396ddd2 100644
--- a/IGC/VectorCompiler/include/vc/GenXCodeGen/TargetMachine.h
+++ b/IGC/VectorCompiler/include/vc/GenXCodeGen/TargetMachine.h
@@ -9,7 +9,7 @@ SPDX-License-Identifier: MIT
 #ifndef VC_LIB_GENXCODEGEN_TARGETMACHINE_H
 #define VC_LIB_GENXCODEGEN_TARGETMACHINE_H
 
-#include "llvm/Support/TargetRegistry.h"
+#include "llvmWrapper/Support/TargetRegistry.h"
 
 #include "vc/Support/BackendConfig.h"
 
diff --git a/IGC/VectorCompiler/include/vc/Support/GenXDiagnostic.h b/IGC/VectorCompiler/include/vc/Support/GenXDiagnostic.h
index 67ba8a50d..acc94faa9 100644
--- a/IGC/VectorCompiler/include/vc/Support/GenXDiagnostic.h
+++ b/IGC/VectorCompiler/include/vc/Support/GenXDiagnostic.h
@@ -126,7 +126,7 @@ public:
 
   void print(llvm::DiagnosticPrinter &DP) const override {
     if (Severity == llvm::DS_Error)
-      llvm::report_fatal_error(Description);
+      llvm::report_fatal_error(llvm::StringRef(Description));
     DP << Description;
   }
 
diff --git a/IGC/VectorCompiler/lib/Driver/Driver.cpp b/IGC/VectorCompiler/lib/Driver/Driver.cpp
index cd63f4eac..7660ae438 100644
--- a/IGC/VectorCompiler/lib/Driver/Driver.cpp
+++ b/IGC/VectorCompiler/lib/Driver/Driver.cpp
@@ -42,7 +42,6 @@ SPDX-License-Identifier: MIT
 #include "llvm/Support/MemoryBuffer.h"
 #include "llvm/Support/SourceMgr.h"
 #include "llvm/Support/StringSaver.h"
-#include "llvm/Support/TargetRegistry.h"
 #include "llvm/Support/Timer.h"
 #include "llvm/Support/raw_ostream.h"
 #include "llvm/Target/TargetOptions.h"
@@ -51,6 +50,7 @@ SPDX-License-Identifier: MIT
 #include "llvm/Transforms/Scalar.h"
 
 #include "llvmWrapper/Option/OptTable.h"
+#include "llvmWrapper/Support/TargetRegistry.h"
 #include "llvmWrapper/Target/TargetMachine.h"
 
 #include "Probe/Assertion.h"
diff --git a/IGC/VectorCompiler/lib/GenXCodeGen/GenXArgIndirection.cpp b/IGC/VectorCompiler/lib/GenXCodeGen/GenXArgIndirection.cpp
index d56672f6e..92802531b 100644
--- a/IGC/VectorCompiler/lib/GenXCodeGen/GenXArgIndirection.cpp
+++ b/IGC/VectorCompiler/lib/GenXCodeGen/GenXArgIndirection.cpp
@@ -155,13 +155,13 @@ SPDX-License-Identifier: MIT
 #include "llvm/IR/DebugInfo.h"
 #include "llvm/IR/DiagnosticInfo.h"
 #include "llvm/IR/DiagnosticPrinter.h"
-#include "llvm/IR/Instructions.h"
 #include "llvm/IR/LLVMContext.h"
 #include "llvm/IR/ValueHandle.h"
 #include "llvm/Support/CommandLine.h"
 #include "llvm/Support/Debug.h"
 #include "Probe/Assertion.h"
 
+#include "llvmWrapper/IR/Instructions.h"
 #include "llvmWrapper/IR/DerivedTypes.h"
 
 using namespace llvm;
@@ -755,7 +755,7 @@ Indirectability SubroutineArg::checkIndirectability()
   // Create an object of some subclass of ArgIndCallSite for each call site.
   for (auto &U: F->uses()) {
     if (auto *CI = checkFunctionCall(U.getUser(), F)) {
-      IGC_ASSERT(U.getOperandNo() == CI->getNumArgOperands());
+      IGC_ASSERT(U.getOperandNo() == IGCLLVM::getNumArgOperands(CI));
       auto CS = createCallSite(CI);
       if (!CS)
         return Indirectability::CANNOT_INDIRECT;
@@ -1285,7 +1285,7 @@ void SubroutineArg::fixCallSites()
     // can modify the arg being indirected such that the eraseUnusedTree erases
     // the rd-wr sequence that sets up the arg in the old call.
     SmallVector<Value *, 4> Args;
-    for (unsigned oi = 0, oe = CS->CI->getNumArgOperands(); oi != oe; ++oi)
+    for (unsigned oi = 0, oe = IGCLLVM::getNumArgOperands(CS->CI); oi != oe; ++oi)
       Args.push_back(CS->CI->getArgOperand(oi));
     Args.push_back(UndefValue::get(Type::getInt16Ty(CS->CI->getContext())));
     CallInst *OldCI = CS->CI;
@@ -1337,7 +1337,7 @@ Value *CallerIndirectingCallSite::process(GenXArgIndirection *Pass,
 Value *NoOptCallSite::process(GenXArgIndirection *Pass, SubroutineArg *SubrArg)
 {
   unsigned InsertNumber = Pass->Numbering->getArgIndirectionNumber(
-      CI, CI->getNumArgOperands() - 1, 0);
+      CI, IGCLLVM::getNumArgOperands(CI) - 1, 0);
   Instruction *InsertBefore = CI;
   Type *I16Ty = Type::getInt16Ty(CI->getContext());
   // If the arg is undef, we can just use an undef address.
@@ -1400,7 +1400,7 @@ Value *ConstArgRetCallSite::process(GenXArgIndirection *Pass,
   // instruction number of the address arg's pre-copy slot.
   Instruction *InsertBefore = CI;
   unsigned InsertNumber = Pass->Numbering->getArgIndirectionNumber(
-        CI, CI->getNumArgOperands() - 1, 0);
+        CI, IGCLLVM::getNumArgOperands(CI) - 1, 0);
   // Insert a load the constant. Bitcast it to the right type to replace
   // RetEndWr.
   SmallVector<Instruction *, 4> AddedInsts;
@@ -1485,7 +1485,7 @@ Value *IndirectArgCallSite::process(GenXArgIndirection *Pass,
   // instruction number of the address arg's pre-copy slot.
   Instruction *InsertBefore = CI;
   unsigned InsertNumber = Pass->Numbering->getArgIndirectionNumber(CI,
-      CI->getNumArgOperands() - 1, 0);
+      IGCLLVM::getNumArgOperands(CI) - 1, 0);
   Value *AddressArg = nullptr;
   if (isa<Constant>(Index)) {
     // Constant index for the region. Add a convert.addr to load it into an
diff --git a/IGC/VectorCompiler/lib/GenXCodeGen/GenXBaling.cpp b/IGC/VectorCompiler/lib/GenXCodeGen/GenXBaling.cpp
index 0b2d1d482..007929cdd 100644
--- a/IGC/VectorCompiler/lib/GenXCodeGen/GenXBaling.cpp
+++ b/IGC/VectorCompiler/lib/GenXCodeGen/GenXBaling.cpp
@@ -32,7 +32,6 @@ SPDX-License-Identifier: MIT
 #include "llvm/IR/Function.h"
 #include "llvm/IR/IRBuilder.h"
 #include "llvm/IR/InstIterator.h"
-#include "llvm/IR/Instructions.h"
 #include "llvm/IR/Intrinsics.h"
 #include "llvm/IR/Module.h"
 #include "llvm/IR/PatternMatch.h"
@@ -41,6 +40,7 @@ SPDX-License-Identifier: MIT
 #include "llvm/Support/Debug.h"
 #include "llvm/Transforms/Utils/Local.h"
 
+#include "llvmWrapper/IR/Instructions.h"
 #include "llvmWrapper/IR/DerivedTypes.h"
 
 #include "Probe/Assertion.h"
@@ -973,7 +973,7 @@ void GenXBaling::processInlineAsm(Instruction *Inst) {
   IGC_ASSERT_MESSAGE(CI->isInlineAsm(), "Inline Asm expected");
 
   BaleInfo BI(BaleInfo::MAININST);
-  for (unsigned I = 0; I < CI->getNumArgOperands(); I++)
+  for (unsigned I = 0; I < IGCLLVM::getNumArgOperands(CI); I++)
     if (auto RdR = dyn_cast<Instruction>(CI->getArgOperand(I)))
       if (GenXIntrinsic::isRdRegion(RdR)) {
         switch (GenXIntrinsic::getGenXIntrinsicID(RdR->getOperand(0))) {
@@ -1626,7 +1626,7 @@ void GenXBaling::processBranch(BranchInst *Branch)
  */
 void GenXBaling::processTwoAddrSend(CallInst *CI)
 {
-  unsigned TwoAddrOperandNum = CI->getNumArgOperands() - 1;
+  unsigned TwoAddrOperandNum = IGCLLVM::getNumArgOperands(CI) - 1;
   IGC_ASSERT(GenXIntrinsicInfo(vc::getAnyIntrinsicID(CI))
       .getArgInfo(TwoAddrOperandNum)
       .getCategory() == GenXIntrinsicInfo::TWOADDR);
diff --git a/IGC/VectorCompiler/lib/GenXCodeGen/GenXCisaBuilder.cpp b/IGC/VectorCompiler/lib/GenXCodeGen/GenXCisaBuilder.cpp
index d52b35a18..4c73676a4 100644
--- a/IGC/VectorCompiler/lib/GenXCodeGen/GenXCisaBuilder.cpp
+++ b/IGC/VectorCompiler/lib/GenXCodeGen/GenXCisaBuilder.cpp
@@ -3424,7 +3424,7 @@ void GenXKernelBuilder::buildIntrinsic(CallInst *CI, unsigned IntrinID,
     unsigned RoundedWidth = roundedVal(Width, 4u);
     Type *DataType = CI->getType();
     if (DataType->isVoidTy())
-      DataType = CI->getOperand(CI->getNumArgOperands() - 1)->getType();
+      DataType = CI->getOperand(IGCLLVM::getNumArgOperands(CI) - 1)->getType();
     unsigned DataSize;
     if (VectorType *VT = dyn_cast<VectorType>(DataType))
       DataSize = DL.getTypeSizeInBits(VT) / genx::ByteBits;
@@ -3691,7 +3691,7 @@ void GenXKernelBuilder::buildIntrinsic(CallInst *CI, unsigned IntrinID,
     auto BaseArg = AI.getArgIdx();
     MaxRawOperands = BaseArg;
 
-    for (unsigned Idx = BaseArg; Idx < CI->getNumArgOperands(); ++Idx) {
+    for (unsigned Idx = BaseArg; Idx < IGCLLVM::getNumArgOperands(CI); ++Idx) {
       if (auto CA = dyn_cast<Constant>(CI->getArgOperand(Idx))) {
         if (CA->isNullValue())
           continue;
@@ -5077,7 +5077,7 @@ bool GenXKernelBuilder::isInLoop(BasicBlock *BB) {
     auto CI = dyn_cast<CallInst>(ui->getUser());
     if (!checkFunctionCall(CI, BBFunc))
       continue;
-    IGC_ASSERT(ui->getOperandNo() == CI->getNumArgOperands());
+    IGC_ASSERT(ui->getOperandNo() == IGCLLVM::getNumArgOperands(CI));
     if (CI->getFunction() == BBFunc)
       continue;
     if (isInLoop(CI->getParent())) {
@@ -6374,7 +6374,7 @@ void GenXKernelBuilder::buildStackCall(CallInst *CI,
 
   // Check whether the called function has a predicate arg that is EM.
   int EMOperandNum = -1, EMIdx = -1;
-  for (auto &Arg : CI->arg_operands()) {
+  for (auto &Arg : IGCLLVM::args(CI)) {
     ++EMIdx;
     if (!Arg->getType()->getScalarType()->isIntegerTy(1))
       continue;
@@ -6385,7 +6385,7 @@ void GenXKernelBuilder::buildStackCall(CallInst *CI,
   }
 
   int TotalArgSize = 0;
-  for (auto &CallArg : CI->arg_operands())
+  for (auto &CallArg : IGCLLVM::args(CI))
     TotalArgSize += getValueSize(CallArg->getType());
 
   VISA_GenVar *Sp = nullptr, *Arg = nullptr, *Ret = nullptr;
@@ -6399,7 +6399,7 @@ void GenXKernelBuilder::buildStackCall(CallInst *CI,
   uint64_t StackOff = 0;
   bool StackStarted = false;
   // pack arguments
-  for (auto &CallArg : CI->arg_operands()) {
+  for (auto &CallArg : IGCLLVM::args(CI)) {
     auto *CallArgLR = Liveness->getLiveRangeOrNull(CallArg.get());
     if (CallArgLR && CallArgLR->getCategory() == vc::RegCategory::EM)
       continue;
diff --git a/IGC/VectorCompiler/lib/GenXCodeGen/GenXCoalescing.cpp b/IGC/VectorCompiler/lib/GenXCodeGen/GenXCoalescing.cpp
index 6325fd01a..3a2ff7ac0 100644
--- a/IGC/VectorCompiler/lib/GenXCodeGen/GenXCoalescing.cpp
+++ b/IGC/VectorCompiler/lib/GenXCodeGen/GenXCoalescing.cpp
@@ -160,7 +160,6 @@ SPDX-License-Identifier: MIT
 /// and insert an extra copy at the start of the function.
 ///
 //===----------------------------------------------------------------------===//
-#define DEBUG_TYPE "GENX_COALESCING"
 
 #include "FunctionGroup.h"
 #include "GenX.h"
@@ -203,6 +202,8 @@ SPDX-License-Identifier: MIT
 #include <map>
 #include <vector>
 
+#define DEBUG_TYPE "GENX_COALESCING"
+
 using namespace llvm;
 using namespace genx;
 
diff --git a/IGC/VectorCompiler/lib/GenXCodeGen/GenXConstants.cpp b/IGC/VectorCompiler/lib/GenXCodeGen/GenXConstants.cpp
index 14eb2a7fc..a9c895623 100644
--- a/IGC/VectorCompiler/lib/GenXCodeGen/GenXConstants.cpp
+++ b/IGC/VectorCompiler/lib/GenXCodeGen/GenXConstants.cpp
@@ -95,7 +95,7 @@ SPDX-License-Identifier: MIT
 #include "llvm/IR/Dominators.h"
 #include "llvm/IR/Function.h"
 #include "llvm/IR/InstIterator.h"
-#include "llvm/IR/Instructions.h"
+#include "llvmWrapper/IR/Instructions.h"
 #include "llvm/IR/Intrinsics.h"
 #include "llvm/IR/ValueMap.h"
 #include "llvm/Support/Casting.h"
@@ -163,7 +163,7 @@ bool genx::loadNonSimpleConstants(
   unsigned NumArgs = Inst->getNumOperands();
   auto CI = dyn_cast<CallInst>(Inst);
   if (CI)
-    NumArgs = CI->getNumArgOperands();
+    NumArgs = IGCLLVM::getNumArgOperands(CI);
   unsigned IID = vc::getAnyIntrinsicID(Inst);
   // Do not proceed loading of genx.alloca argument since its value doesn't
   // needed (only type matters) and always null.
@@ -346,7 +346,7 @@ bool genx::loadConstants(Instruction *Inst, const GenXSubtarget &Subtarget,
     case GenXIntrinsic::genx_output:
     case GenXIntrinsic::genx_output_1:
       // load all args for subroutine and some intrinsic calls.
-      for (unsigned i = 0, e = CI->getNumArgOperands(); i != e; ++i) {
+      for (unsigned i = 0, e = IGCLLVM::getNumArgOperands(CI); i != e; ++i) {
         U = &CI->getOperandUse(i);
         if (auto C = dyn_cast<Constant>(*U)) {
           if (!isa<UndefValue>(C)) {
diff --git a/IGC/VectorCompiler/lib/GenXCodeGen/GenXDepressurizer.cpp b/IGC/VectorCompiler/lib/GenXCodeGen/GenXDepressurizer.cpp
index 8aa453e1b..6b56f9312 100644
--- a/IGC/VectorCompiler/lib/GenXCodeGen/GenXDepressurizer.cpp
+++ b/IGC/VectorCompiler/lib/GenXCodeGen/GenXDepressurizer.cpp
@@ -101,7 +101,6 @@ SPDX-License-Identifier: MIT
 /// flag pressure.
 ///
 //===----------------------------------------------------------------------===//
-#define DEBUG_TYPE "GENX_DEPRESSURIZER"
 
 #include "FunctionGroup.h"
 #include "GenX.h"
@@ -127,6 +126,8 @@ SPDX-License-Identifier: MIT
 using namespace llvm;
 using namespace genx;
 
+#define DEBUG_TYPE "GENX_DEPRESSURIZER"
+
 static cl::opt<unsigned>
     LimitGenXDepressurizer("limit-genx-depressurizer", cl::init(UINT_MAX),
                            cl::Hidden, cl::desc("Limit GenX depressurizer."));
diff --git a/IGC/VectorCompiler/lib/GenXCodeGen/GenXEmulate.cpp b/IGC/VectorCompiler/lib/GenXCodeGen/GenXEmulate.cpp
index 8a409a0f3..b6323095d 100644
--- a/IGC/VectorCompiler/lib/GenXCodeGen/GenXEmulate.cpp
+++ b/IGC/VectorCompiler/lib/GenXCodeGen/GenXEmulate.cpp
@@ -14,6 +14,7 @@ SPDX-License-Identifier: MIT
 ///
 //===----------------------------------------------------------------------===//
 
+#include "llvmWrapper/IR/Instructions.h"
 #define DEBUG_TYPE "GENX_EMULATION"
 
 #include "GenX.h"
@@ -1220,7 +1221,7 @@ Value *GenXEmulate::Emu64Expander::visitGenxFPToISat(CallInst &CI) {
     vc::diagnose(CI.getContext(), "GenXEmulate",
                  "Unsupported instruction for emulation", &CI);
 
-  SmallVector<Value *, 8> Args(CI.arg_operands());
+  SmallVector<Value *, 8> Args(IGCLLVM::args(CI));
 
   return Builder.CreateCall(Iter->second, Args);
 }
diff --git a/IGC/VectorCompiler/lib/GenXCodeGen/GenXIntrinsics.cpp b/IGC/VectorCompiler/lib/GenXCodeGen/GenXIntrinsics.cpp
index 214178f9b..6fc704852 100644
--- a/IGC/VectorCompiler/lib/GenXCodeGen/GenXIntrinsics.cpp
+++ b/IGC/VectorCompiler/lib/GenXCodeGen/GenXIntrinsics.cpp
@@ -22,7 +22,7 @@ SPDX-License-Identifier: MIT
 #include "visa_igc_common_header.h"
 #include "llvm/GenXIntrinsics/GenXIntrinsics.h"
 #include "llvm/IR/Constants.h"
-#include "llvm/IR/Instructions.h"
+#include "llvmWrapper/IR/Instructions.h"
 #include "llvm/IR/Intrinsics.h"
 
 #include "llvmWrapper/IR/DerivedTypes.h"
@@ -82,7 +82,7 @@ unsigned GenXIntrinsicInfo::getTrailingNullZoneStart(CallInst *CI) const {
     return CI->getNumOperands();
   unsigned BaseArg = AI->getArgIdx();
   unsigned TrailingNullStart = BaseArg;
-  for (unsigned Idx = BaseArg; Idx < CI->getNumArgOperands(); ++Idx) {
+  for (unsigned Idx = BaseArg; Idx < IGCLLVM::getNumArgOperands(CI); ++Idx) {
     if (auto CA = dyn_cast<Constant>(CI->getArgOperand(Idx)))
       if (CA->isNullValue())
         continue;
diff --git a/IGC/VectorCompiler/lib/GenXCodeGen/GenXLegalization.cpp b/IGC/VectorCompiler/lib/GenXCodeGen/GenXLegalization.cpp
index 722e97d13..391329e04 100644
--- a/IGC/VectorCompiler/lib/GenXCodeGen/GenXLegalization.cpp
+++ b/IGC/VectorCompiler/lib/GenXCodeGen/GenXLegalization.cpp
@@ -220,7 +220,7 @@ SPDX-License-Identifier: MIT
 #include "llvm/IR/DiagnosticInfo.h"
 #include "llvm/IR/DiagnosticPrinter.h"
 #include "llvm/IR/Function.h"
-#include "llvm/IR/Instructions.h"
+#include "llvmWrapper/IR/Instructions.h"
 #include "llvm/IR/IntrinsicInst.h"
 #include "llvm/IR/Intrinsics.h"
 #include "llvm/IR/Module.h"
@@ -1740,7 +1740,7 @@ unsigned GenXLegalization::determineNonRegionWidth(Instruction *Inst,
   if (!isa<SelectInst>(Inst)) {
     unsigned NumOperands = Inst->getNumOperands();
     if (CallInst *CI = dyn_cast<CallInst>(Inst))
-      NumOperands = CI->getNumArgOperands();
+      NumOperands = IGCLLVM::getNumArgOperands(CI);
     if (NumOperands) {
       IGC_ASSERT_MESSAGE(isa<VectorType>(Inst->getOperand(0)->getType()),
         "instruction not supported");
@@ -2322,7 +2322,7 @@ Value *GenXLegalization::splitInst(Value *PrevSliceRes, BaleInst BInst,
         cast<VectorType>(BInst.Inst->getType())->getElementType(),
         Width * WidthAdjust)); // RetTy
   }
-  for (unsigned i = 0, e = CI->getNumArgOperands(); i != e; ++i) {
+  for (unsigned i = 0, e = IGCLLVM::getNumArgOperands(CI); i != e; ++i) {
     Use *U = &CI->getOperandUse(i);
     if (U == Fixed4) {
       Args.push_back(CI->getArgOperand(i));
diff --git a/IGC/VectorCompiler/lib/GenXCodeGen/GenXLowering.cpp b/IGC/VectorCompiler/lib/GenXCodeGen/GenXLowering.cpp
index 435bfd090..dd351770d 100644
--- a/IGC/VectorCompiler/lib/GenXCodeGen/GenXLowering.cpp
+++ b/IGC/VectorCompiler/lib/GenXCodeGen/GenXLowering.cpp
@@ -85,7 +85,6 @@ SPDX-License-Identifier: MIT
 /// GenXLiveness has another go at splitting them up.
 ///
 //===----------------------------------------------------------------------===//
-#define DEBUG_TYPE "GENX_LOWERING"
 
 #include "GenX.h"
 #include "GenXGotoJoin.h"
@@ -132,6 +131,8 @@ SPDX-License-Identifier: MIT
 #include <numeric>
 #include "Probe/Assertion.h"
 
+#define DEBUG_TYPE "GENX_LOWERING"
+
 using namespace llvm;
 using namespace genx;
 
@@ -363,7 +364,7 @@ bool GenXLowering::processTwoAddressOpnd(CallInst *CI) {
     Type *Ty = CI->getArgOperand(*OpNum)->getType();
     IGC_ASSERT_MESSAGE(Ty == CI->getType(), "two address op type out of sync");
 
-    for (unsigned i = 0; i < CI->getNumArgOperands(); ++i) {
+    for (unsigned i = 0; i < IGCLLVM::getNumArgOperands(CI); ++i) {
       auto Op = dyn_cast<Constant>(CI->getArgOperand(i));
       // Check if the predicate operand is all true.
       if (Op && Op->getType()->getScalarSizeInBits() == 1) {
@@ -993,7 +994,7 @@ bool GenXLowering::splitGatherScatter(CallInst *CI, unsigned IID) {
   for (auto CurWidth : Widths) {
     SmallVector<Value *, 8> Args;
     // initialize the args with the old values
-    for (unsigned ArgI = 0; ArgI < CI->getNumArgOperands(); ++ArgI)
+    for (unsigned ArgI = 0; ArgI < IGCLLVM::getNumArgOperands(CI); ++ArgI)
       Args.push_back(CI->getArgOperand(ArgI));
     // Predicate
     if (PredIdx != NONEED) {
@@ -1709,7 +1710,7 @@ bool GenXLowering::widenSIMD8GatherScatter(CallInst *CI, unsigned IID) {
   }
 
   SmallVector<Value *, 8> Args;
-  for (unsigned i = 0; i < CI->getNumArgOperands(); ++i) {
+  for (unsigned i = 0; i < IGCLLVM::getNumArgOperands(CI); ++i) {
     Args.push_back(CI->getArgOperand(i));
   }
   Args[PredIdx] = ExpandPredicate(CI, PredIdx, WidenSIMD);
@@ -3236,7 +3237,7 @@ bool GenXLowering::processInst(Instruction *Inst) {
     unsigned IntrinsicID = GenXIntrinsic::not_any_intrinsic;
     if (Function *Callee = CI->getCalledFunction()) {
       IntrinsicID = vc::getAnyIntrinsicID(Callee);
-      IGC_ASSERT(CI->getNumArgOperands() < GenXIntrinsicInfo::OPNDMASK);
+      IGC_ASSERT(IGCLLVM::getNumArgOperands(CI) < GenXIntrinsicInfo::OPNDMASK);
     }
     if (ST) {
       // use gather/scatter to implement SLM oword load/store on
@@ -5727,7 +5728,7 @@ bool GenXLowering::widenByteOp(Instruction *Inst) {
   // Get the range of operands to process.
   unsigned StartIdx = 0, EndIdx = Inst->getNumOperands();
   if (auto CI = dyn_cast<CallInst>(Inst))
-    EndIdx = CI->getNumArgOperands();
+    EndIdx = IGCLLVM::getNumArgOperands(CI);
   else if (isa<SelectInst>(Inst))
     StartIdx = 1;
   // Extend the operands.
diff --git a/IGC/VectorCompiler/lib/GenXCodeGen/GenXNumbering.cpp b/IGC/VectorCompiler/lib/GenXCodeGen/GenXNumbering.cpp
index 3d36e2905..b5ca3f602 100644
--- a/IGC/VectorCompiler/lib/GenXCodeGen/GenXNumbering.cpp
+++ b/IGC/VectorCompiler/lib/GenXCodeGen/GenXNumbering.cpp
@@ -20,7 +20,7 @@ SPDX-License-Identifier: MIT
 #include "vc/Utils/GenX/KernelInfo.h"
 #include "llvm/IR/BasicBlock.h"
 #include "llvm/IR/Function.h"
-#include "llvm/IR/Instructions.h"
+#include "llvmWrapper/IR/Instructions.h"
 #include "llvm/IR/Intrinsics.h"
 #include "llvm/Support/Debug.h"
 
@@ -120,7 +120,7 @@ unsigned GenXNumbering::numberInstructionsInFunc(Function *Func, unsigned Num)
           // wasting numbers does not really matter.
           PreReserve = 2 * IndexFlattener::getNumArgElements(
                 CI->getFunctionType());
-          PreReserve += 2 * CI->getNumArgOperands(); // extra for pre-copy addresses of args
+          PreReserve += 2 * IGCLLVM::getNumArgOperands(CI); // extra for pre-copy addresses of args
           unsigned NumRetVals = IndexFlattener::getNumElements(CI->getType());
           PreReserve += NumRetVals; // extra for pre-copy addresses of retvals
           PostReserve = NumRetVals;
diff --git a/IGC/VectorCompiler/lib/GenXCodeGen/GenXPatternMatch.cpp b/IGC/VectorCompiler/lib/GenXCodeGen/GenXPatternMatch.cpp
index 4a98f1a9e..b64ae8734 100644
--- a/IGC/VectorCompiler/lib/GenXCodeGen/GenXPatternMatch.cpp
+++ b/IGC/VectorCompiler/lib/GenXCodeGen/GenXPatternMatch.cpp
@@ -42,7 +42,6 @@ SPDX-License-Identifier: MIT
 ///
 //===----------------------------------------------------------------------===//
 
-#define DEBUG_TYPE "GENX_PATTERN_MATCH"
 #include "GenX.h"
 #include "GenXConstants.h"
 #include "GenXModule.h"
@@ -63,7 +62,7 @@ SPDX-License-Identifier: MIT
 #include "llvm/IR/IRBuilder.h"
 #include "llvm/IR/InstIterator.h"
 #include "llvm/IR/InstVisitor.h"
-#include "llvm/IR/Instructions.h"
+#include "llvmWrapper/IR/Instructions.h"
 #include "llvm/IR/Intrinsics.h"
 #include "llvm/IR/Module.h"
 #include "llvm/IR/PatternMatch.h"
@@ -75,6 +74,7 @@ SPDX-License-Identifier: MIT
 #include "llvm/Transforms/Utils/BasicBlockUtils.h"
 #include "llvm/Transforms/Utils/Local.h"
 
+#include "llvmWrapper/ADT/APInt.h"
 #include "llvmWrapper/IR/Constants.h"
 #include "llvmWrapper/IR/DerivedTypes.h"
 #include "llvmWrapper/Support/TypeSize.h"
@@ -93,6 +93,8 @@ using namespace llvm;
 using namespace llvm::PatternMatch;
 using namespace genx;
 
+#define DEBUG_TYPE "GENX_PATTERN_MATCH"
+
 STATISTIC(NumOfMadMatched, "Number of mad instructions matched");
 STATISTIC(NumOfMinMaxMatched, "Number of min/max instructions matched");
 
@@ -2963,34 +2965,34 @@ static void decomposeUDivNotPow2(BinaryOperator &UDivOp) {
                 : cast<ConstantInt>(Divisor))
           ->getValue();
 
-  APInt::mu MagicStruct = DivisorVal.magicu();
+  IGCLLVM::UnsignedDivisonByConstantInfo MagicStruct = IGCLLVM::getAPIntMagicUnsigned(DivisorVal);
   const int ElementBitWidth =
       Divisor->getType()->getScalarType()->getIntegerBitWidth();
   // Even divisors, can pre-shift the dividend to avoid
   // extra work at the end.
   Value *ShiftedDividend = Dividend;
   // Need addition and y is 2 * y'.
-  if (MagicStruct.a && !DivisorVal[0]) {
+  if (IGCLLVM::IsAddition(MagicStruct) && !DivisorVal[0]) {
     unsigned ShiftSizeRaw = DivisorVal.countTrailingZeros();
     Constant *ShiftSize =
         Constant::getIntegerValue(OperationTy, APInt{32, ShiftSizeRaw});
     ShiftedDividend = Builder.CreateLShr(ShiftedDividend, ShiftSize);
-    MagicStruct = DivisorVal.lshr(ShiftSizeRaw).magicu(ShiftSizeRaw);
+    MagicStruct = IGCLLVM::getAPIntMagicUnsigned(DivisorVal.lshr(ShiftSizeRaw), ShiftSizeRaw);
 
     // Should not change addition quality.
-    IGC_ASSERT_MESSAGE(!MagicStruct.a, "expected to subtract now");
-    IGC_ASSERT_MESSAGE(MagicStruct.s < DivisorVal.getBitWidth(),
+    IGC_ASSERT_MESSAGE(!IGCLLVM::IsAddition(MagicStruct), "expected to subtract now");
+    IGC_ASSERT_MESSAGE(IGCLLVM::ShiftAmount(MagicStruct) < DivisorVal.getBitWidth(),
                        "undefined shift");
   }
-  Constant *MagicConst = Constant::getIntegerValue(OperationTy, MagicStruct.m);
+  Constant *MagicConst = Constant::getIntegerValue(OperationTy, IGCLLVM::MagicNumber(MagicStruct));
   Value *MulH = vc::createAnyIntrinsic(Builder, {ShiftedDividend, MagicConst},
                                         GenXIntrinsic::genx_umulh,
                                         {OperationTy, OperationTy}, "opt");
 
   Value *Res = nullptr;
-  if (!MagicStruct.a) {
+  if (!IGCLLVM::IsAddition(MagicStruct)) {
     Constant *Shift =
-        Constant::getIntegerValue(OperationTy, APInt{32, MagicStruct.s});
+        Constant::getIntegerValue(OperationTy, APInt{32, IGCLLVM::ShiftAmount(MagicStruct)});
     Res = Builder.CreateLShr(MulH, Shift);
   } else {
     Value *Fixup = Builder.CreateSub(Dividend, MulH, "q_appx");
@@ -2998,7 +3000,7 @@ static void decomposeUDivNotPow2(BinaryOperator &UDivOp) {
     Fixup = Builder.CreateLShr(Fixup, One);
     Value *Addition = Builder.CreateAdd(Fixup, MulH, "q_appx_add");
     Constant *Shift =
-        Constant::getIntegerValue(OperationTy, APInt{32, MagicStruct.s - 1});
+        Constant::getIntegerValue(OperationTy, APInt{32, IGCLLVM::ShiftAmount(MagicStruct) - 1});
     Res = Builder.CreateLShr(Addition, Shift);
   }
   IGC_ASSERT(Res);
@@ -3394,7 +3396,7 @@ bool GenXPatternMatch::vectorizeConstants(Function *F) {
       unsigned NumOpnds = Inst->getNumOperands();
       auto CI = dyn_cast<CallInst>(Inst);
       if (CI)
-        NumOpnds = CI->getNumArgOperands();
+        NumOpnds = IGCLLVM::getNumArgOperands(CI);
       for (unsigned i = 0, e = NumOpnds; i != e; ++i) {
         auto C = dyn_cast<Constant>(Inst->getOperand(i));
         if (!C || isa<UndefValue>(C))
diff --git a/IGC/VectorCompiler/lib/GenXCodeGen/GenXPrologEpilogInsertion.cpp b/IGC/VectorCompiler/lib/GenXCodeGen/GenXPrologEpilogInsertion.cpp
index 869c4881e..8456f6c07 100644
--- a/IGC/VectorCompiler/lib/GenXCodeGen/GenXPrologEpilogInsertion.cpp
+++ b/IGC/VectorCompiler/lib/GenXCodeGen/GenXPrologEpilogInsertion.cpp
@@ -401,9 +401,9 @@ void GenXPrologEpilogInsertion::removeAttrs(Function &F) const {
 }
 
 static void removeCallInstAttrs(CallInst &CI) {
-  CI.removeAttribute(AttributeList::FunctionIndex, Attribute::ReadNone);
-  CI.removeAttribute(AttributeList::FunctionIndex, Attribute::ReadOnly);
-  CI.removeAttribute(AttributeList::FunctionIndex, Attribute::WriteOnly);
+  IGCLLVM::removeFnAttr(&CI, Attribute::ReadNone);
+  IGCLLVM::removeFnAttr(&CI, Attribute::ReadOnly);
+  IGCLLVM::removeFnAttr(&CI, Attribute::WriteOnly);
 }
 
 bool GenXPrologEpilogInsertion::runOnFunction(Function &F) {
diff --git a/IGC/VectorCompiler/lib/GenXCodeGen/GenXPromotePredicate.cpp b/IGC/VectorCompiler/lib/GenXCodeGen/GenXPromotePredicate.cpp
index 240a7c3ba..1adf1282d 100644
--- a/IGC/VectorCompiler/lib/GenXCodeGen/GenXPromotePredicate.cpp
+++ b/IGC/VectorCompiler/lib/GenXCodeGen/GenXPromotePredicate.cpp
@@ -16,7 +16,6 @@ SPDX-License-Identifier: MIT
 ///
 //===----------------------------------------------------------------------===//
 
-#define DEBUG_TYPE "GENX_PROMOTE_PREDICATE"
 
 #include "GenX.h"
 #include "GenXUtil.h"
@@ -28,6 +27,8 @@ SPDX-License-Identifier: MIT
 
 #include "llvmWrapper/IR/DerivedTypes.h"
 
+#define DEBUG_TYPE "GENX_PROMOTE_PREDICATE"
+
 using namespace llvm;
 using namespace genx;
 
diff --git a/IGC/VectorCompiler/lib/GenXCodeGen/GenXPromoteStatefulToBindless.cpp b/IGC/VectorCompiler/lib/GenXCodeGen/GenXPromoteStatefulToBindless.cpp
index 6489e7d84..f234a7b07 100644
--- a/IGC/VectorCompiler/lib/GenXCodeGen/GenXPromoteStatefulToBindless.cpp
+++ b/IGC/VectorCompiler/lib/GenXCodeGen/GenXPromoteStatefulToBindless.cpp
@@ -140,7 +140,7 @@ static void reportUnhandledIntrinsic(const char *Func, GenXIntrinsic::ID Id) {
   std::ostringstream SS;
   SS << "In function '" << Func << "': Intrinsic '" << getGenXName(Id)
      << "' is not yet supported";
-  llvm::report_fatal_error(SS.str());
+  llvm::report_fatal_error(llvm::StringRef(SS.str()));
 }
 
 // Buffer argument kind is converted to GENERAL to denote that
diff --git a/IGC/VectorCompiler/lib/GenXCodeGen/GenXSimdCFConformance.cpp b/IGC/VectorCompiler/lib/GenXCodeGen/GenXSimdCFConformance.cpp
index 93bb42151..0bccb2753 100644
--- a/IGC/VectorCompiler/lib/GenXCodeGen/GenXSimdCFConformance.cpp
+++ b/IGC/VectorCompiler/lib/GenXCodeGen/GenXSimdCFConformance.cpp
@@ -210,7 +210,7 @@ SPDX-License-Identifier: MIT
 #include "llvm/IR/DiagnosticPrinter.h"
 #include "llvm/IR/Dominators.h"
 #include "llvm/IR/IRBuilder.h"
-#include "llvm/IR/Instructions.h"
+#include "llvmWrapper/IR/Instructions.h"
 #include "llvm/IR/LLVMContext.h"
 #include "llvm/IR/PatternMatch.h"
 #include "llvm/Support/CommandLine.h"
@@ -715,7 +715,7 @@ void GenXSimdCFConformance::gatherGotoJoinEMVals(bool IncludeIncoming)
         if (!GotoJoin)
           continue;
         if (FG && (FGA->getGroup(GotoJoin->getParent()->getParent()) != FG
-            || ui->getOperandNo() != GotoJoin->getNumArgOperands()))
+            || ui->getOperandNo() != IGCLLVM::getNumArgOperands(GotoJoin)))
           continue;
         // We have a goto/join (in our function group in the case of the late
         // pass).  Add the EM value (struct index 0) to EMVals.
@@ -747,7 +747,7 @@ void GenXSimdCFConformance::gatherEMVals()
     if (!Savemask)
       continue;
     if (FG && (FGA->getGroup(Savemask->getParent()->getParent()) != FG ||
-               ui->getOperandNo() != Savemask->getNumArgOperands()))
+               ui->getOperandNo() != IGCLLVM::getNumArgOperands(Savemask)))
       continue;
       lowerSimdCF = true;
     // Add its EM input to EMVals, if not a constant.
@@ -763,7 +763,7 @@ void GenXSimdCFConformance::gatherEMVals()
     if (!Unmask)
       continue;
     if (FG && (FGA->getGroup(Unmask->getParent()->getParent()) != FG ||
-               ui->getOperandNo() != Unmask->getNumArgOperands()))
+               ui->getOperandNo() != IGCLLVM::getNumArgOperands(Unmask)))
       continue;
       lowerSimdCF = true;
     // We have a unmask (in our function group in the case of the late
@@ -777,7 +777,7 @@ void GenXSimdCFConformance::gatherEMVals()
     if (!Remask)
       continue;
     if (FG && (FGA->getGroup(Remask->getParent()->getParent()) != FG ||
-               ui->getOperandNo() != Remask->getNumArgOperands()))
+               ui->getOperandNo() != IGCLLVM::getNumArgOperands(Remask)))
       continue;
       lowerSimdCF = true;
     // We have a remask (in our function group in the case of the late
@@ -1747,7 +1747,7 @@ bool GenXSimdCFConformance::hoistJoin(CallInst *Join)
   // However, if we find such an instruction and it is an extractvalue from the
   // result of an earlier goto/join in a different block, we can just move it
   // to after that goto/join.
-  for (unsigned oi = 0, oe = Join->getNumArgOperands(); oi != oe; ++oi) {
+  for (unsigned oi = 0, oe = IGCLLVM::getNumArgOperands(Join); oi != oe; ++oi) {
     auto Opnd = dyn_cast<Instruction>(Join->getOperand(oi));
     if (!Opnd || isa<PHINode>(Opnd))
       continue;
@@ -2437,7 +2437,7 @@ static bool checkAllUsesAreSelectOrWrRegion(Value *V)
     if (GenXIntrinsic::isWrRegion(IID))
       continue;
     if (IID == GenXIntrinsic::genx_wrpredpredregion
-        && OpNum == cast<CallInst>(User2)->getNumArgOperands() - 1)
+        && OpNum == IGCLLVM::getNumArgOperands(cast<CallInst>(User2)) - 1)
       continue;
     if (GenXIntrinsic::isAnyNonTrivialIntrinsic(IID)
         && !cast<CallInst>(User2)->doesNotAccessMemory())
@@ -2617,7 +2617,7 @@ bool GenXSimdCFConformance::getConnectedVals(
         // about that.
         auto ValTy = IndexFlattener::getElementType(
             Val.getType(), Val.getIndex());
-        for (unsigned Idx = 0, End = CI->getNumArgOperands(); ; ++Idx) {
+        for (unsigned Idx = 0, End = IGCLLVM::getNumArgOperands(CI); ; ++Idx) {
           if (Idx == End)
             return false; // no corresponding call arg found
           if (CI->getArgOperand(Idx)->getType() == ValTy) {
@@ -2778,7 +2778,7 @@ bool GenXSimdCFConformance::getConnectedVals(
           break;
         case GenXIntrinsic::genx_wrpredpredregion:
           // Use in wrpredpredregion allowed as the last arg.
-          if (ui->getOperandNo() + 1 != CI->getNumArgOperands())
+          if (ui->getOperandNo() + 1 != IGCLLVM::getNumArgOperands(CI))
             UsersToLower.push_back(SimpleValue(User, ui->getOperandNo()));
           break;
         default:
@@ -3697,7 +3697,7 @@ void GenXSimdCFConformance::replaceGotoJoinUses(CallInst *GotoJoin,
           continue;
         unsigned NumOperands = I->getNumOperands();
         if (auto CI = dyn_cast<CallInst>(I))
-          NumOperands = CI->getNumArgOperands();
+          NumOperands = IGCLLVM::getNumArgOperands(CI);
         V = nullptr;
         if (NumOperands == 1)
           V = I->getOperand(0);
diff --git a/IGC/VectorCompiler/lib/GenXCodeGen/GenXStackUsage.cpp b/IGC/VectorCompiler/lib/GenXCodeGen/GenXStackUsage.cpp
index bc99f8a67..263203f80 100644
--- a/IGC/VectorCompiler/lib/GenXCodeGen/GenXStackUsage.cpp
+++ b/IGC/VectorCompiler/lib/GenXCodeGen/GenXStackUsage.cpp
@@ -103,7 +103,7 @@ class StackAnalysis : public InstVisitor<StackAnalysis> {
       NotStarted // function has not started processing but will start
     };
     uint64_t m_UsedSz{0};
-    unsigned m_RequiredAlign{0};
+    alignment_t m_RequiredAlign{0};
     bool m_HasIndirect{false};
     Function *m_pHeavyFunction{nullptr};
     ProcessingState m_ProcessingFlag{ProcessingState::NotStarted};
@@ -112,7 +112,7 @@ class StackAnalysis : public InstVisitor<StackAnalysis> {
   // map between Function and its State
   std::unordered_map<Function *, FunctionState> m_ProcessedFs{};
 
-  llvm::Optional<std::pair<uint64_t, unsigned>> checkFunction(Function &F);
+  llvm::Optional<std::pair<uint64_t, alignment_t>> checkFunction(Function &F);
   std::string GenerateCallSequence(Function &F);
   void checkKernel(Function &Kernel);
 
@@ -156,7 +156,7 @@ void StackAnalysis::visitFunction(Function &F) {
 }
 
 // Check CallGraph and usage of allocas in function
-llvm::Optional<std::pair<uint64_t, unsigned>>
+llvm::Optional<std::pair<uint64_t, alignment_t>>
 StackAnalysis::checkFunction(Function &F) {
   auto pOnF = m_ProcessedFs.find(&F);
   IGC_ASSERT_MESSAGE(pOnF != m_ProcessedFs.end(),
@@ -248,6 +248,7 @@ void StackAnalysis::checkKernel(Function &Kernel) {
                << Kernel.getName() << ")\n");
     return;
   }
+
   auto [KernelUsedStack, KernelAlignment] = *Res;
 
   KernelAlignment = std::max(KernelAlignment, visa::BytesPerSVMPtr);
diff --git a/IGC/VectorCompiler/lib/GenXCodeGen/GenXTargetMachine.cpp b/IGC/VectorCompiler/lib/GenXCodeGen/GenXTargetMachine.cpp
index 6d9efd142..644364a08 100644
--- a/IGC/VectorCompiler/lib/GenXCodeGen/GenXTargetMachine.cpp
+++ b/IGC/VectorCompiler/lib/GenXCodeGen/GenXTargetMachine.cpp
@@ -56,7 +56,7 @@ SPDX-License-Identifier: MIT
 #include "llvm/Pass.h"
 #include "llvm/PassRegistry.h"
 #include "llvm/Support/CommandLine.h"
-#include "llvm/Support/TargetRegistry.h"
+#include "llvmWrapper/Support/TargetRegistry.h"
 #include "llvm/Transforms/IPO.h"
 #include "llvm/Transforms/IPO/AlwaysInliner.h"
 #include "llvm/Transforms/IPO/PassManagerBuilder.h"
diff --git a/IGC/VectorCompiler/lib/GenXCodeGen/GenXTargetMachine.h b/IGC/VectorCompiler/lib/GenXCodeGen/GenXTargetMachine.h
index bd7fcd866..36655b003 100644
--- a/IGC/VectorCompiler/lib/GenXCodeGen/GenXTargetMachine.h
+++ b/IGC/VectorCompiler/lib/GenXCodeGen/GenXTargetMachine.h
@@ -177,7 +177,11 @@ public:
   }
 
   void getUnrollingPreferences(Loop *L, ScalarEvolution &SE,
-                               TTI::UnrollingPreferences &UP) {
+                               TTI::UnrollingPreferences &UP
+#if LLVM_VERSION_MAJOR >= 14
+                             , OptimizationRemarkEmitter* ORE
+#endif
+                               ) {
     if (BC.ignoreLoopUnrollThresholdOnPragma()) {
       if (GetUnrollMetadataForLoop(L, "llvm.loop.unroll.full"))
         UP.Threshold = std::numeric_limits<unsigned>::max();
diff --git a/IGC/VectorCompiler/lib/GenXCodeGen/GenXThreadPrivateMemory.cpp b/IGC/VectorCompiler/lib/GenXCodeGen/GenXThreadPrivateMemory.cpp
index ac2b68376..27e4630c6 100644
--- a/IGC/VectorCompiler/lib/GenXCodeGen/GenXThreadPrivateMemory.cpp
+++ b/IGC/VectorCompiler/lib/GenXCodeGen/GenXThreadPrivateMemory.cpp
@@ -1402,7 +1402,7 @@ bool GenXThreadPrivateMemory::processUsers() {
         Changed = true;
       } else if (ID == GenXIntrinsic::not_any_intrinsic) {
         if (m_Calls[CI->getCalledFunction()].Calls.count(CI) > 0) {
-          for (unsigned i = 0; i < CI->getNumArgOperands(); i++) {
+          for (unsigned i = 0; i < IGCLLVM::getNumArgOperands(CI); i++) {
             if (m_Calls[CI->getCalledFunction()].Args.count(
                     IGCLLVM::getArg(*CI->getCalledFunction(), i)) > 0)
               CI->replaceUsesOfWith(
diff --git a/IGC/VectorCompiler/lib/GenXCodeGen/GenXUtil.cpp b/IGC/VectorCompiler/lib/GenXCodeGen/GenXUtil.cpp
index 9e705bc8c..bcc79f037 100644
--- a/IGC/VectorCompiler/lib/GenXCodeGen/GenXUtil.cpp
+++ b/IGC/VectorCompiler/lib/GenXCodeGen/GenXUtil.cpp
@@ -30,7 +30,7 @@ SPDX-License-Identifier: MIT
 #include "llvm/IR/Dominators.h"
 #include "llvm/IR/Function.h"
 #include "llvm/IR/IRBuilder.h"
-#include "llvm/IR/Instructions.h"
+#include "llvmWrapper/IR/Instructions.h"
 #include "llvm/IR/IntrinsicInst.h"
 #include "llvm/IR/Intrinsics.h"
 #include "llvm/IR/Metadata.h"
@@ -292,7 +292,7 @@ llvm::Optional<unsigned> genx::getTwoAddressOperandNum(CallInst *CI)
   if (CI->getType()->isVoidTy())
     return None; // no return value
   GenXIntrinsicInfo II(IntrinsicID);
-  unsigned Num = CI->getNumArgOperands();
+  unsigned Num = IGCLLVM::getNumArgOperands(CI);
   if (!Num)
     return None; // no args
   --Num; // Num = last arg number, could be two address operand
diff --git a/IGC/VectorCompiler/lib/GenXCodeGen/GenXVectorCombiner.cpp b/IGC/VectorCompiler/lib/GenXCodeGen/GenXVectorCombiner.cpp
index 8f5746de3..68b85c576 100644
--- a/IGC/VectorCompiler/lib/GenXCodeGen/GenXVectorCombiner.cpp
+++ b/IGC/VectorCompiler/lib/GenXCodeGen/GenXVectorCombiner.cpp
@@ -14,7 +14,6 @@ SPDX-License-Identifier: MIT
 // and if we can combine them together, we do this
 ///
 //===----------------------------------------------------------------------===//
-#define DEBUG_TYPE "GENX_VECTOR_COMBINER"
 
 #include <algorithm>
 
@@ -34,6 +33,8 @@ SPDX-License-Identifier: MIT
 using namespace llvm;
 using namespace genx;
 
+#define DEBUG_TYPE "GENX_VECTOR_COMBINER"
+
 STATISTIC(NumOfWidenInsructions,
           "Number of combined to wider variant instructions");
 
diff --git a/IGC/VectorCompiler/lib/GenXCodeGen/GenXVisa.h b/IGC/VectorCompiler/lib/GenXCodeGen/GenXVisa.h
index e23f472ec..97115a7d7 100644
--- a/IGC/VectorCompiler/lib/GenXCodeGen/GenXVisa.h
+++ b/IGC/VectorCompiler/lib/GenXCodeGen/GenXVisa.h
@@ -25,6 +25,7 @@ SPDX-License-Identifier: MIT
 
 #include "Probe/Assertion.h"
 #include "llvmWrapper/IR/DerivedTypes.h"
+#include "llvmWrapper/Support/Alignment.h"
 
 #include <map>
 #include <string>
@@ -63,7 +64,7 @@ namespace llvm {
     // convention limits them to 12 and 8.
     constexpr static unsigned ArgRegSizeInGRFs = 12;
     constexpr static unsigned RetRegSizeInGRFs = 8;
-    constexpr static unsigned BytesPerSVMPtr = 8;
+    constexpr static alignment_t BytesPerSVMPtr = 8;
     constexpr static unsigned BytesPerOword = 16;
     constexpr static unsigned StackPerThreadScratch = 256;
     constexpr static unsigned StackPerThreadSVM = 8192*2;
diff --git a/IGC/VectorCompiler/lib/GenXCodeGen/TargetInfo/GenXTargetInfo.cpp b/IGC/VectorCompiler/lib/GenXCodeGen/TargetInfo/GenXTargetInfo.cpp
index f069d22e8..6ec992891 100644
--- a/IGC/VectorCompiler/lib/GenXCodeGen/TargetInfo/GenXTargetInfo.cpp
+++ b/IGC/VectorCompiler/lib/GenXCodeGen/TargetInfo/GenXTargetInfo.cpp
@@ -8,7 +8,7 @@ SPDX-License-Identifier: MIT
 
 #include "GenXTargetInfo.h"
 
-#include "llvm/Support/TargetRegistry.h"
+#include "llvmWrapper/Support/TargetRegistry.h"
 
 using namespace llvm;
 
diff --git a/IGC/VectorCompiler/lib/GenXOpts/CMAnalysis/ConstantFoldingGenX.cpp b/IGC/VectorCompiler/lib/GenXOpts/CMAnalysis/ConstantFoldingGenX.cpp
index ea006db31..a855e6ea0 100644
--- a/IGC/VectorCompiler/lib/GenXOpts/CMAnalysis/ConstantFoldingGenX.cpp
+++ b/IGC/VectorCompiler/lib/GenXOpts/CMAnalysis/ConstantFoldingGenX.cpp
@@ -26,6 +26,7 @@ SPDX-License-Identifier: MIT
 #include "llvmWrapper/Analysis/CallGraph.h"
 #include "llvmWrapper/IR/DerivedTypes.h"
 #include "llvmWrapper/IR/CallSite.h"
+#include "llvmWrapper/IR/Instructions.h"
 
 #define DEBUG_TYPE "genx-constantfolding"
 
@@ -255,7 +256,7 @@ Constant *llvm::ConstantFoldGenX(Instruction *I, const DataLayout &DL) {
     return nullptr;
 
   SmallVector<Constant *, 4> ConstantArgs;
-  ConstantArgs.reserve(CS.getNumArgOperands());
+  ConstantArgs.reserve(IGCLLVM::getNumArgOperands(&CS));
   auto FoldOperand = [&DL](const Use &A) {
     auto *C = cast<Constant>(A.get());
     Constant *Folded = ConstantFoldConstant(C, DL);
diff --git a/IGC/VectorCompiler/lib/GenXOpts/CMAnalysis/InstructionSimplifyGenX.cpp b/IGC/VectorCompiler/lib/GenXOpts/CMAnalysis/InstructionSimplifyGenX.cpp
index 1ba4b8d21..bf5c30ab8 100644
--- a/IGC/VectorCompiler/lib/GenXOpts/CMAnalysis/InstructionSimplifyGenX.cpp
+++ b/IGC/VectorCompiler/lib/GenXOpts/CMAnalysis/InstructionSimplifyGenX.cpp
@@ -537,7 +537,7 @@ bool GenXSimplify::simplifyGenXLscAtomic(CallInst &CI,
 
   LLVM_DEBUG(dbgs() << "processing <lsc atomic>: " << CI << "\n");
 
-  if (!isa<UndefValue>(CI.getArgOperand(CI.getNumArgOperands() - 1))) {
+  if (!isa<UndefValue>(CI.getArgOperand(IGCLLVM::getNumArgOperands(&CI) - 1))) {
     LLVM_DEBUG(dbgs() << "  skipping as instruction already has some " <<
                "\"previous value\" set\n");
     return false;
@@ -597,7 +597,7 @@ bool GenXSimplify::simplifyGenXLscAtomic(CallInst &CI,
     LLVM_DEBUG(dbgs() << "previous value does not dominate candidate!\n");
     return false;
   }
-  CI.setArgOperand(CI.getNumArgOperands() - 1, PrevValue);
+  CI.setArgOperand(IGCLLVM::getNumArgOperands(&CI) - 1, PrevValue);
 
   Select->replaceAllUsesWith(&CI);
   Select->eraseFromParent();
diff --git a/IGC/VectorCompiler/lib/GenXOpts/CMPacketize/GenXPacketize.cpp b/IGC/VectorCompiler/lib/GenXOpts/CMPacketize/GenXPacketize.cpp
index ef7552797..97c26d19f 100644
--- a/IGC/VectorCompiler/lib/GenXOpts/CMPacketize/GenXPacketize.cpp
+++ b/IGC/VectorCompiler/lib/GenXOpts/CMPacketize/GenXPacketize.cpp
@@ -818,7 +818,7 @@ Value *GenXPacketize::packetizeLLVMIntrinsic(Instruction *pInst) {
   // packetize intrinsic operands
   std::vector<Type *> vectorArgTys;
   std::vector<Value *> packetizedArgs;
-  for (auto &operand : pCall->arg_operands()) {
+  for (auto &operand : IGCLLVM::args(pCall)) {
     auto VV = getPacketizeValue(operand.get());
     packetizedArgs.push_back(VV);
     vectorArgTys.push_back(VV->getType());
diff --git a/IGC/VectorCompiler/lib/GenXOpts/CMTrans/CMABI.cpp b/IGC/VectorCompiler/lib/GenXOpts/CMTrans/CMABI.cpp
index d84988ce3..e1dbbc4b9 100644
--- a/IGC/VectorCompiler/lib/GenXOpts/CMTrans/CMABI.cpp
+++ b/IGC/VectorCompiler/lib/GenXOpts/CMTrans/CMABI.cpp
@@ -21,9 +21,9 @@ SPDX-License-Identifier: MIT
 ///
 //===----------------------------------------------------------------------===//
 
-#define DEBUG_TYPE "cmabi"
 
 #include "llvmWrapper/Analysis/CallGraph.h"
+#include "llvmWrapper/IR/Attributes.h"
 #include "llvmWrapper/IR/DerivedTypes.h"
 #include "llvmWrapper/IR/Instructions.h"
 #include "llvmWrapper/Support/Alignment.h"
@@ -84,6 +84,8 @@ SPDX-License-Identifier: MIT
 #include <unordered_set>
 #include <vector>
 
+#define DEBUG_TYPE "cmabi"
+
 using namespace llvm;
 
 static cl::opt<unsigned>
@@ -365,7 +367,7 @@ bool CMABI::runOnSCC(CallGraphSCC &SCC) {
       continue;
     for (auto ui = F->use_begin(), ue = F->use_end(); ui != ue; ++ui) {
       auto CI = dyn_cast<CallInst>(ui->getUser());
-      if (CI && CI->getNumArgOperands() == ui->getOperandNo())
+      if (CI && IGCLLVM::getNumArgOperands(CI) == ui->getOperandNo())
         diagnoseOverlappingArgs(CI);
     }
   }
@@ -493,9 +495,9 @@ CallGraphNode *CMABI::TransformKernel(Function *F) {
         ArgTys.push_back(Ty);
     } else {
       // Unchanged argument
-      AttributeSet attrs = PAL.getParamAttributes(ArgIndex);
+      AttributeSet attrs = IGCLLVM::getParamAttrs(PAL, ArgIndex);
       if (attrs.hasAttributes()) {
-        AttrBuilder B(attrs);
+        IGCLLVM::AttrBuilder B{ Context, attrs };
         AttrVec = AttrVec.addParamAttributes(Context, ArgTys.size(), B);
       }
       ArgTys.push_back(I->getType());
@@ -507,10 +509,10 @@ CallGraphNode *CMABI::TransformKernel(Function *F) {
     "type out of sync, expect bool arguments");
 
   // Add any function attributes.
-  AttributeSet FnAttrs = PAL.getFnAttributes();
+  AttributeSet FnAttrs = IGCLLVM::getFnAttrs(PAL);
   if (FnAttrs.hasAttributes()) {
-    AttrBuilder B(FnAttrs);
-    AttrVec = AttrVec.addAttributes(Context, AttributeList::FunctionIndex, B);
+    IGCLLVM::AttrBuilder B(Context, FnAttrs);
+    AttrVec = IGCLLVM::addAttributesAtIndex(AttrVec, Context, AttributeList::FunctionIndex, B);
   }
 
   // Create the new function body and insert it into the module.
@@ -712,7 +714,7 @@ void CMABI::diagnoseOverlappingArgs(CallInst *CI)
   std::set<std::pair<unsigned, unsigned>> Reported;
   // Using ArgIndex starting at 1 so we can reserve 0 to mean "element does not
   // come from any by-ref arg".
-  for (unsigned ArgIndex = 1, NumArgs = CI->getNumArgOperands();
+  for (unsigned ArgIndex = 1, NumArgs = IGCLLVM::getNumArgOperands(CI);
       ArgIndex <= NumArgs; ++ArgIndex) {
     Value *Arg = CI->getOperand(ArgIndex - 1);
     if (!Arg->getType()->isPointerTy())
@@ -1308,7 +1310,7 @@ void ArgRefPattern::process(DominatorTree &DT) {
     Builder.SetInsertPoint(LI);
     Value *SrcVal = Builder.CreateLoad(
         BaseAlloca->getType()->getPointerElementType(), BaseAlloca);
-    SmallVector<Value *, 8> Args(CopyInRegion->arg_operands());
+    SmallVector<Value *, 8> Args(IGCLLVM::args(CopyInRegion));
     Args[0] = SrcVal;
     Value *Val = Builder.CreateCall(RdFn, Args);
     LI->replaceAllUsesWith(Val);
diff --git a/IGC/VectorCompiler/lib/GenXOpts/CMTrans/CMImpParam.cpp b/IGC/VectorCompiler/lib/GenXOpts/CMTrans/CMImpParam.cpp
index 63e4f14dc..6e79eb738 100644
--- a/IGC/VectorCompiler/lib/GenXOpts/CMTrans/CMImpParam.cpp
+++ b/IGC/VectorCompiler/lib/GenXOpts/CMTrans/CMImpParam.cpp
@@ -146,6 +146,7 @@ SPDX-License-Identifier: MIT
 
 #include "Probe/Assertion.h"
 #include "llvmWrapper/Analysis/CallGraph.h"
+#include "llvmWrapper/IR/Attributes.h"
 #include "llvmWrapper/IR/DerivedTypes.h"
 #include "llvmWrapper/IR/Function.h"
 #include "llvmWrapper/Support/Alignment.h"
@@ -1088,9 +1089,9 @@ CMImpParam::processKernelParameters(Function *F,
   for (Function::arg_iterator I = F->arg_begin(), E = F->arg_end(); I != E;
        ++I, ++ArgIndex) {
     ArgTys.push_back(I->getType());
-    AttributeSet attrs = PAL.getParamAttributes(ArgIndex);
+    AttributeSet attrs = IGCLLVM::getParamAttrs(PAL, ArgIndex);
     if (attrs.hasAttributes()) {
-      AttrBuilder B(attrs);
+      IGCLLVM::AttrBuilder B(Context, attrs);
       AttrVec = AttrVec.addParamAttributes(Context, ArgIndex, B);
     }
   }
@@ -1114,10 +1115,10 @@ CMImpParam::processKernelParameters(Function *F,
     "type out of sync, expect bool arguments)");
 
   // Add any function attributes
-  AttributeSet FnAttrs = PAL.getFnAttributes();
+  AttributeSet FnAttrs = IGCLLVM::getFnAttrs(PAL);
   if (FnAttrs.hasAttributes()) {
-    AttrBuilder B(FnAttrs);
-    AttrVec = AttrVec.addAttributes(Context, AttributeList::FunctionIndex, B);
+    IGCLLVM::AttrBuilder B(Context, FnAttrs);
+    AttrVec = IGCLLVM::addAttributesAtIndex(AttrVec, Context, AttributeList::FunctionIndex, B);
   }
 
   // Create new function body and insert into the module
diff --git a/IGC/VectorCompiler/lib/GenXOpts/CMTrans/GenXImportOCLBiF.cpp b/IGC/VectorCompiler/lib/GenXOpts/CMTrans/GenXImportOCLBiF.cpp
index f91e419d0..f669e3157 100644
--- a/IGC/VectorCompiler/lib/GenXOpts/CMTrans/GenXImportOCLBiF.cpp
+++ b/IGC/VectorCompiler/lib/GenXOpts/CMTrans/GenXImportOCLBiF.cpp
@@ -248,7 +248,7 @@ void BIConvert::runOnModule(Module &M) {
           tys0[0] = InstCall->getArgOperand(0)->getType();
           // build argument list for the 1st intrinsic
           args0.append(InstCall->op_begin(),
-                       InstCall->op_begin() + InstCall->getNumArgOperands());
+                       InstCall->op_begin() + IGCLLVM::getNumArgOperands(InstCall));
           Function *IntrinFunc0 =
               GenXIntrinsic::getAnyDeclaration(&M, pair.first, tys0);
           Instruction *IntrinCall0 = CallInst::Create(
@@ -396,7 +396,7 @@ static void removeFunctionBitcasts(Module &M) {
             }
 
             std::vector<Value *> Args;
-            for (unsigned I = 0, E = pInstCall->getNumArgOperands(); I != E;
+            for (unsigned I = 0, E = IGCLLVM::getNumArgOperands(pInstCall); I != E;
                  ++I) {
               Args.push_back(pInstCall->getArgOperand(I));
             }
diff --git a/IGC/VectorCompiler/lib/GenXOpts/CMTrans/GenXPrintfResolution.cpp b/IGC/VectorCompiler/lib/GenXOpts/CMTrans/GenXPrintfResolution.cpp
index 3e637bcd8..dde297742 100644
--- a/IGC/VectorCompiler/lib/GenXOpts/CMTrans/GenXPrintfResolution.cpp
+++ b/IGC/VectorCompiler/lib/GenXOpts/CMTrans/GenXPrintfResolution.cpp
@@ -39,7 +39,6 @@ SPDX-License-Identifier: MIT
 #include <llvm/IR/DataLayout.h>
 #include <llvm/IR/IRBuilder.h>
 #include <llvm/IR/InstIterator.h>
-#include <llvm/IR/Instructions.h>
 #include <llvm/IR/Module.h>
 #include <llvm/Linker/Linker.h>
 #include <llvm/Pass.h>
@@ -47,6 +46,7 @@ SPDX-License-Identifier: MIT
 
 #include "llvmWrapper/IR/DerivedTypes.h"
 #include "llvmWrapper/IR/Operator.h"
+#include "llvmWrapper/IR/Instructions.h"
 
 #include <algorithm>
 #include <functional>
@@ -292,7 +292,7 @@ void GenXPrintfResolution::handlePrintfCall(CallInst &OrigPrintf) {
   assertPrintfCall(OrigPrintf);
   auto [FmtStrSize, ArgsInfo] =
       analyzeFormatString(*OrigPrintf.getArgOperand(0));
-  if (ArgsInfo.size() != OrigPrintf.getNumArgOperands() - 1)
+  if (ArgsInfo.size() != IGCLLVM::getNumArgOperands(&OrigPrintf) - 1)
     vc::fatal(OrigPrintf.getContext(), "GenXPrintfResolution",
               "printf format string and arguments don't correspond");
 
diff --git a/IGC/VectorCompiler/lib/Support/BackendConfig.cpp b/IGC/VectorCompiler/lib/Support/BackendConfig.cpp
index 840e30d40..0784d6aba 100644
--- a/IGC/VectorCompiler/lib/Support/BackendConfig.cpp
+++ b/IGC/VectorCompiler/lib/Support/BackendConfig.cpp
@@ -193,8 +193,8 @@ readBiFModuleFromFile(const cl::opt<std::string> &File) {
   ErrorOr<std::unique_ptr<MemoryBuffer>> FileOrErr =
       MemoryBuffer::getFileOrSTDIN(File);
   if (!FileOrErr)
-    report_fatal_error("opening OpenCL BiF file failed: " +
-                       FileOrErr.getError().message());
+    report_fatal_error(llvm::StringRef("opening OpenCL BiF file failed: " +
+                       FileOrErr.getError().message()));
   return std::move(FileOrErr.get());
 }
 
diff --git a/IGC/VectorCompiler/lib/Utils/GenX/Region.cpp b/IGC/VectorCompiler/lib/Utils/GenX/Region.cpp
index 1d825ea8c..f06f74ec3 100644
--- a/IGC/VectorCompiler/lib/Utils/GenX/Region.cpp
+++ b/IGC/VectorCompiler/lib/Utils/GenX/Region.cpp
@@ -25,7 +25,7 @@ SPDX-License-Identifier: MIT
 #include "llvm/IR/Constants.h"
 #include "llvm/IR/DerivedTypes.h"
 #include "llvm/IR/Function.h"
-#include "llvm/IR/Instructions.h"
+#include "llvmWrapper/IR/Instructions.h"
 #include "llvm/IR/IntrinsicInst.h"
 #include "llvm/IR/Intrinsics.h"
 #include "llvm/Support/Debug.h"
@@ -556,13 +556,13 @@ void CMRegion::setRegionCalledFunc(Instruction *Inst)
 {
   auto CI = cast<CallInst>(Inst);
   SmallVector<Value *, 8> Opnds;
-  for (unsigned i = 0, e = CI->getNumArgOperands(); i != e; ++i)
+  for (unsigned i = 0, e = IGCLLVM::getNumArgOperands(CI); i != e; ++i)
     Opnds.push_back(CI->getOperand(i));
   Function *Decl = getGenXRegionDeclaration(
       Inst->getParent()->getParent()->getParent(),
       GenXIntrinsic::getGenXIntrinsicID(Inst),
       Inst->getType(), Opnds);
-  CI->setOperand(CI->getNumArgOperands(), Decl);
+  CI->setOperand(IGCLLVM::getNumArgOperands(CI), Decl);
 }
 
 /***********************************************************************
diff --git a/IGC/VectorCompiler/lib/Utils/GenX/TransformArgCopy.cpp b/IGC/VectorCompiler/lib/Utils/GenX/TransformArgCopy.cpp
index b94632206..8e895c1d4 100644
--- a/IGC/VectorCompiler/lib/Utils/GenX/TransformArgCopy.cpp
+++ b/IGC/VectorCompiler/lib/Utils/GenX/TransformArgCopy.cpp
@@ -9,6 +9,7 @@ SPDX-License-Identifier: MIT
 #define DEBUG_TYPE "vc-transform-arg-copy"
 
 #include "llvmWrapper/Analysis/CallGraph.h"
+#include "llvmWrapper/IR/Attributes.h"
 #include "llvmWrapper/IR/CallSite.h"
 #include "llvmWrapper/IR/Function.h"
 #include "llvmWrapper/IR/Instructions.h"
@@ -371,19 +372,19 @@ vc::TransformedFuncInfo::gatherAttributes(LLVMContext &Context,
     if (OrigArgInfoEntry.getKind() == ArgKind::General) {
       IGC_ASSERT_MESSAGE(!OrigArgInfoEntry.isOmittedArg(),
                          "unexpected omitted argument");
-      AttributeSet ArgAttrs = AL.getParamAttributes(OrigIdx);
+      AttributeSet ArgAttrs = IGCLLVM::getParamAttrs(AL, OrigIdx);
       if (ArgAttrs.hasAttributes())
         GatheredAttrs = GatheredAttrs.addParamAttributes(
-            Context, OrigArgInfoEntry.getNewIdx(), AttrBuilder{ArgAttrs});
+            Context, OrigArgInfoEntry.getNewIdx(),
+            IGCLLVM::AttrBuilder{Context, ArgAttrs});
     }
   }
 
   // Gather function attributes.
-  AttributeSet FnAttrs = AL.getFnAttributes();
+  AttributeSet FnAttrs = IGCLLVM::getFnAttrs(AL);
   if (FnAttrs.hasAttributes()) {
-    AttrBuilder B(FnAttrs);
-    GatheredAttrs =
-        GatheredAttrs.addAttributes(Context, AttributeList::FunctionIndex, B);
+    IGCLLVM::AttrBuilder B(Context, FnAttrs);
+    GatheredAttrs = IGCLLVM::addAttributesAtIndex(GatheredAttrs, Context, AttributeList::FunctionIndex, B);
   }
 
   return GatheredAttrs;
@@ -499,7 +500,7 @@ getTransformedFuncCallArgs(CallInst &OrigCall,
 static AttributeList
 inheritCallAttributes(CallInst &OrigCall, int NumOrigFuncArgs,
                       const TransformedFuncInfo &NewFuncInfo) {
-  IGC_ASSERT_MESSAGE(OrigCall.getNumArgOperands() == NumOrigFuncArgs,
+  IGC_ASSERT_MESSAGE(IGCLLVM::getNumArgOperands(&OrigCall) == NumOrigFuncArgs,
                      "varargs aren't supported");
 
   const AttributeList &CallPAL = OrigCall.getAttributes();
diff --git a/IGC/VectorCompiler/lib/Utils/General/BiF.cpp b/IGC/VectorCompiler/lib/Utils/General/BiF.cpp
index 4982e8369..67a79ff6d 100644
--- a/IGC/VectorCompiler/lib/Utils/General/BiF.cpp
+++ b/IGC/VectorCompiler/lib/Utils/General/BiF.cpp
@@ -32,7 +32,7 @@ getBiFModuleOrReportErrorImpl(MemoryBufferRef BiFModuleBuffer, LLVMContext &Ctx,
                     [&ErrStream](const llvm::ErrorInfoBase &EI) {
                       ErrStream << EI.message() << std::endl;
                     });
-    report_fatal_error(ErrStream.str());
+    report_fatal_error(llvm::StringRef(ErrStream.str()));
   }
   return std::move(BiFModule.get());
 }
diff --git a/IGC/VectorCompiler/lib/Utils/General/DebugInfo.cpp b/IGC/VectorCompiler/lib/Utils/General/DebugInfo.cpp
index 83a5c3dbb..30bf771c1 100644
--- a/IGC/VectorCompiler/lib/Utils/General/DebugInfo.cpp
+++ b/IGC/VectorCompiler/lib/Utils/General/DebugInfo.cpp
@@ -150,7 +150,11 @@ llvm::DIGlobalVariableExpression *vc::DIBuilder::createGlobalVariableExpression(
   auto *GV = DIGlobalVariable::getDistinct(
       Ctx, cast_or_null<DIScope>(CU), Name, LinkageName, CU->getFile(),
       0 /*Line No*/, Type, true /*IsLocalToUnit*/, true /*isDefined*/,
-      nullptr /*Decl*/, nullptr /*TemplateParams*/, 0 /*AlignInBits*/);
+      nullptr /*Decl*/, nullptr /*TemplateParams*/, 0 /*AlignInBits*/
+#if LLVM_VERSION_MAJOR >= 14
+      , nullptr /*Annotation*/
+#endif
+      );
   auto *EmptyExpr = DIExpression::get(Ctx, llvm::None);
   auto *GVE = DIGlobalVariableExpression::get(Ctx, GV, EmptyExpr);
 
@@ -182,5 +186,9 @@ llvm::DILocalVariable *vc::DIBuilder::createLocalVariable(
     unsigned LineNo, llvm::DIType *Type, unsigned ArgNo,
     llvm::DINode::DIFlags Flags, unsigned AlignInBits) const {
   return DILocalVariable::get(M.getContext(), Scope, Name, File, LineNo, Type,
-                              ArgNo, Flags, AlignInBits);
+                              ArgNo, Flags, AlignInBits
+#if LLVM_VERSION_MAJOR >= 14
+                            , nullptr
+#endif
+                            );
 }
diff --git a/IGC/VectorCompiler/utils/vcb/UniqueCompilation.cpp b/IGC/VectorCompiler/utils/vcb/UniqueCompilation.cpp
index 3f5599d17..66759a214 100644
--- a/IGC/VectorCompiler/utils/vcb/UniqueCompilation.cpp
+++ b/IGC/VectorCompiler/utils/vcb/UniqueCompilation.cpp
@@ -17,8 +17,8 @@ SPDX-License-Identifier: MIT
 #include <llvm/Support/FileSystem.h>
 #include <llvm/Support/MD5.h>
 #include <llvm/Support/MemoryBuffer.h>
-#include <llvm/Support/TargetRegistry.h>
 #include <llvm/Support/ToolOutputFile.h>
+#include <llvmWrapper/Support/TargetRegistry.h>
 #include <llvmWrapper/Target/TargetMachine.h>
 
 #include <llvm/Transforms/Utils/Cloning.h>
@@ -89,7 +89,7 @@ void generateBifSelectionProcedure(
   int FD;
   auto EC = llvm::sys::fs::openFileForWrite(Output, FD);
   if (EC)
-    report_fatal_error("vcb : can't open output file " + Output);
+    report_fatal_error(llvm::StringRef("vcb : can't open output file " + Output));
   raw_fd_ostream OS{FD, /*shouldClose=*/true};
 
   OS << "// This file is auto generated by vcb tool, DO NOT EDIT\n\n";
diff --git a/IGC/VectorCompiler/utils/vcb/vcb.cpp b/IGC/VectorCompiler/utils/vcb/vcb.cpp
index 617e56339..954aa15c7 100644
--- a/IGC/VectorCompiler/utils/vcb/vcb.cpp
+++ b/IGC/VectorCompiler/utils/vcb/vcb.cpp
@@ -24,11 +24,11 @@ SPDX-License-Identifier: MIT
 #include <llvm/Support/CommandLine.h>
 #include <llvm/Support/FileSystem.h>
 #include <llvm/Support/InitLLVM.h>
-#include <llvm/Support/TargetRegistry.h>
 #include <llvm/Support/ToolOutputFile.h>
 
 #include <llvm/Pass.h>
 #include <llvmWrapper/Target/TargetMachine.h>
+#include <llvmWrapper/Support/TargetRegistry.h>
 
 using namespace llvm;
 
@@ -121,7 +121,7 @@ void vcbCompileModule(std::unique_ptr<Module> &M, std::string Platform) {
   sys::fs::OpenFlags Flags = TextOutput ? sys::fs::OF_Text : sys::fs::OF_None;
   ToolOutputFile Output{OutputFilename, EC, Flags};
   if (EC)
-    report_fatal_error("Can't open file : " + OutputFilename);
+    report_fatal_error(llvm::StringRef("Can't open file : " + OutputFilename));
   if (TextOutput)
     PM.add(createPrintModulePass(Output.os()));
   else
diff --git a/IGC/WrapperLLVM/CMakeLists.txt b/IGC/WrapperLLVM/CMakeLists.txt
index a543e784e..3e495b453 100644
--- a/IGC/WrapperLLVM/CMakeLists.txt
+++ b/IGC/WrapperLLVM/CMakeLists.txt
@@ -12,6 +12,7 @@ set(IGC_BUILD__PROJ__WrapperLLVM       "${IGC_BUILD__PROJ__WrapperLLVM}" PARENT_
 set(IGC_WrapperLLVM_HDR
     "${CMAKE_CURRENT_SOURCE_DIR}/Utils.h"
 
+    "${CMAKE_CURRENT_SOURCE_DIR}/include/llvmWrapper/ADT/APInt.h"
     "${CMAKE_CURRENT_SOURCE_DIR}/include/llvmWrapper/ADT/STLExtras.h"
     "${CMAKE_CURRENT_SOURCE_DIR}/include/llvmWrapper/ADT/StringRef.h"
     "${CMAKE_CURRENT_SOURCE_DIR}/include/llvmWrapper/Analysis/AliasAnalysis.h"
@@ -21,7 +22,9 @@ set(IGC_WrapperLLVM_HDR
     "${CMAKE_CURRENT_SOURCE_DIR}/include/llvmWrapper/Analysis/TargetLibraryInfo.h"
     "${CMAKE_CURRENT_SOURCE_DIR}/include/llvmWrapper/Bitcode/BitcodeWriter.h"
     "${CMAKE_CURRENT_SOURCE_DIR}/include/llvmWrapper/MC/MCContext.h"
+    "${CMAKE_CURRENT_SOURCE_DIR}/include/llvmWrapper/MC/MCStreamer.h"
     "${CMAKE_CURRENT_SOURCE_DIR}/include/llvmWrapper/MC/MCObjectFileInfo.h"
+    "${CMAKE_CURRENT_SOURCE_DIR}/include/llvmWrapper/IR/Attributes.h"
     "${CMAKE_CURRENT_SOURCE_DIR}/include/llvmWrapper/IR/IRBuilder.h"
     "${CMAKE_CURRENT_SOURCE_DIR}/include/llvmWrapper/IR/CallSite.h"
     "${CMAKE_CURRENT_SOURCE_DIR}/include/llvmWrapper/IR/CFG.h"
@@ -41,8 +44,13 @@ set(IGC_WrapperLLVM_HDR
     "${CMAKE_CURRENT_SOURCE_DIR}/include/llvmWrapper/IR/PassTimingInfo.h"
     "${CMAKE_CURRENT_SOURCE_DIR}/include/llvmWrapper/Support/KnownBits.h"
     "${CMAKE_CURRENT_SOURCE_DIR}/include/llvmWrapper/Support/Alignment.h"
+    "${CMAKE_CURRENT_SOURCE_DIR}/include/llvmWrapper/Support/MathExtras.h"
+    "${CMAKE_CURRENT_SOURCE_DIR}/include/llvmWrapper/Support/MemoryBuffer.h"
+    "${CMAKE_CURRENT_SOURCE_DIR}/include/llvmWrapper/Support/Regex.h"
+    "${CMAKE_CURRENT_SOURCE_DIR}/include/llvmWrapper/Support/TargetRegistry.h"
     "${CMAKE_CURRENT_SOURCE_DIR}/include/llvmWrapper/Support/TypeSize.h"
     "${CMAKE_CURRENT_SOURCE_DIR}/include/llvmWrapper/Transforms/IPO.h"
+    "${CMAKE_CURRENT_SOURCE_DIR}/include/llvmWrapper/Transforms/InstCombine/InstCombineWorklist.h"
     "${CMAKE_CURRENT_SOURCE_DIR}/include/llvmWrapper/Transforms/Scalar.h"
     "${CMAKE_CURRENT_SOURCE_DIR}/include/llvmWrapper/Transforms/Utils/Cloning.h"
     "${CMAKE_CURRENT_SOURCE_DIR}/include/llvmWrapper/Transforms/Utils/LoopUtils.h"
diff --git a/IGC/WrapperLLVM/include/lldWrapper/Common/Driver.h b/IGC/WrapperLLVM/include/lldWrapper/Common/Driver.h
index 352a7ecd1..84340589a 100644
--- a/IGC/WrapperLLVM/include/lldWrapper/Common/Driver.h
+++ b/IGC/WrapperLLVM/include/lldWrapper/Common/Driver.h
@@ -19,7 +19,9 @@ namespace IGCLLD {
     namespace elf {
         inline bool link(llvm::ArrayRef<const char *> Args, bool CanExitEarly,
                          llvm::raw_ostream &stdoutOS, llvm::raw_ostream &stderrOS) {
-#if LLVM_VERSION_MAJOR >= 10
+#if LLVM_VERSION_MAJOR >= 14
+            return lld::elf::link(Args, stdoutOS, stderrOS, CanExitEarly, false);
+#elif LLVM_VERSION_MAJOR >= 10
             return lld::elf::link(Args, CanExitEarly, stdoutOS, stderrOS);
 #else
             (void)stdoutOS;
diff --git a/IGC/WrapperLLVM/include/llvmWrapper/ADT/APInt.h b/IGC/WrapperLLVM/include/llvmWrapper/ADT/APInt.h
new file mode 100644
index 000000000..96ca46dfe
--- /dev/null
+++ b/IGC/WrapperLLVM/include/llvmWrapper/ADT/APInt.h
@@ -0,0 +1,84 @@
+/*========================== begin_copyright_notice ============================
+
+Copyright (C) 2020-2021 Intel Corporation
+
+SPDX-License-Identifier: MIT
+
+============================= end_copyright_notice ===========================*/
+
+#ifndef IGCLLVM_ADT_APINT_H
+#define IGCLLVM_ADT_APINT_H
+
+#include <llvm/ADT/APInt.h>
+
+#if LLVM_VERSION_MAJOR >= 14
+#include "llvm/Support/DivisionByConstantInfo.h"
+#endif
+
+namespace IGCLLVM {
+#if LLVM_VERSION_MAJOR >= 14
+using SignedDivisionByConstantInfo = llvm::SignedDivisionByConstantInfo;
+using UnsignedDivisonByConstantInfo = llvm::UnsignedDivisonByConstantInfo;
+#else
+using SignedDivisionByConstantInfo = llvm::APInt::ms;
+using UnsignedDivisonByConstantInfo = llvm::APInt::mu;
+#endif
+
+inline SignedDivisionByConstantInfo getAPIntMagic(const llvm::APInt &value) {
+#if LLVM_VERSION_MAJOR >= 14
+    return llvm::SignedDivisionByConstantInfo::get(value);
+#else
+    return value.magic();
+#endif
+}
+
+inline UnsignedDivisonByConstantInfo getAPIntMagicUnsigned(const llvm::APInt &value, const unsigned LeadingZeros = 0) {
+#if LLVM_VERSION_MAJOR >= 14
+    return llvm::UnsignedDivisonByConstantInfo::get(value, LeadingZeros);
+#else
+    return value.magicu(LeadingZeros);
+#endif
+}
+
+inline bool IsAddition(const UnsignedDivisonByConstantInfo &mu) {
+#if LLVM_VERSION_MAJOR >= 14
+    return mu.IsAdd;
+#else
+    return mu.a;
+#endif
+}
+
+inline unsigned ShiftAmount(const UnsignedDivisonByConstantInfo &mu) {
+#if LLVM_VERSION_MAJOR >= 14
+    return mu.ShiftAmount;
+#else
+    return mu.s;
+#endif
+}
+
+inline unsigned ShiftAmount(const SignedDivisionByConstantInfo &ms) {
+#if LLVM_VERSION_MAJOR >= 14
+    return ms.ShiftAmount;
+#else
+    return ms.s;
+#endif
+}
+
+inline llvm::APInt MagicNumber(const UnsignedDivisonByConstantInfo &mu) {
+#if LLVM_VERSION_MAJOR >= 14
+    return mu.Magic;
+#else
+    return mu.m;
+#endif
+}
+
+inline llvm::APInt MagicNumber(const SignedDivisionByConstantInfo &ms) {
+#if LLVM_VERSION_MAJOR >= 14
+    return ms.Magic;
+#else
+    return ms.m;
+#endif
+}
+}
+
+#endif
\ No newline at end of file
diff --git a/IGC/WrapperLLVM/include/llvmWrapper/IR/Attributes.h b/IGC/WrapperLLVM/include/llvmWrapper/IR/Attributes.h
new file mode 100644
index 000000000..6278cfad7
--- /dev/null
+++ b/IGC/WrapperLLVM/include/llvmWrapper/IR/Attributes.h
@@ -0,0 +1,86 @@
+/*========================== begin_copyright_notice ============================
+
+Copyright (C) 2022 Intel Corporation
+
+SPDX-License-Identifier: MIT
+
+============================= end_copyright_notice ===========================*/
+
+#ifndef IGCLLVM_IR_ATTRIBUTES_H
+#define IGCLLVM_IR_ATTRIBUTES_H
+
+#include "llvm/Config/llvm-config.h"
+
+#include <llvm/IR/Attributes.h>
+
+namespace IGCLLVM {
+    /// Return the attribute object that exists at the given index.
+    inline llvm::Attribute getAttribute(llvm::AttributeList Attrs, unsigned Index, llvm::Attribute::AttrKind Kind) {
+#if LLVM_VERSION_MAJOR >= 14
+        return Attrs.getAttributeAtIndex(llvm::AttributeList::FunctionIndex, Kind);
+#else
+        return Attrs.getAttribute(Index, Kind);
+#endif
+    }
+
+    /// Return the attribute object that exists at the given index.
+    inline llvm::Attribute getAttribute(llvm::AttributeList Attrs, unsigned Index, llvm::StringRef Kind) {
+#if LLVM_VERSION_MAJOR >= 14
+        return Attrs.getAttributeAtIndex(llvm::AttributeList::FunctionIndex, Kind);
+#else
+        return Attrs.getAttribute(Index, Kind);
+#endif
+    }
+
+    inline llvm::AttributeSet getParamAttrs(const llvm::AttributeList &AL, unsigned opNum) {
+#if LLVM_VERSION_MAJOR >= 14
+        return AL.getParamAttrs(opNum);
+#else
+        return AL.getParamAttributes(opNum);
+#endif
+    }
+
+    inline llvm::AttributeList addAttributesAtIndex(llvm::AttributeList &Attrs, llvm::LLVMContext &C, unsigned Index, const llvm::AttrBuilder &B) {
+#if LLVM_VERSION_MAJOR >= 14
+        return Attrs.addAttributesAtIndex(C, Index, B);
+#else
+        return Attrs.addAttributes(C, Index, B);
+#endif
+    }
+
+    inline llvm::AttributeSet getFnAttrs(const llvm::AttributeList &AL) {
+#if LLVM_VERSION_MAJOR >= 14
+        return AL.getFnAttrs();
+#else
+        return AL.getFnAttributes();
+#endif
+    }
+
+    inline llvm::AttributeSet getRetAttrs(const llvm::AttributeList &AL) {
+#if LLVM_VERSION_MAJOR >= 14
+        return AL.getRetAttrs();
+#else
+        return AL.getRetAttributes();
+#endif
+    }
+
+    class AttrBuilder : public llvm::AttrBuilder {
+    public:
+        AttrBuilder() = delete;
+        AttrBuilder(llvm::LLVMContext &Ctx)
+        #if LLVM_VERSION_MAJOR >= 14
+        : llvm::AttrBuilder(Ctx) {}
+        #else
+        : llvm::AttrBuilder() {}
+        #endif
+
+        AttrBuilder(llvm::LLVMContext &Ctx, llvm::AttributeSet AS)
+        #if LLVM_VERSION_MAJOR >= 14
+        : llvm::AttrBuilder(Ctx, AS) {}
+        #else
+        : llvm::AttrBuilder(AS) {}
+        #endif
+    };
+}
+
+#endif
diff --git a/IGC/WrapperLLVM/include/llvmWrapper/IR/ConstantFolder.h b/IGC/WrapperLLVM/include/llvmWrapper/IR/ConstantFolder.h
index 41b1f81b4..1f9a8f0f1 100644
--- a/IGC/WrapperLLVM/include/llvmWrapper/IR/ConstantFolder.h
+++ b/IGC/WrapperLLVM/include/llvmWrapper/IR/ConstantFolder.h
@@ -11,6 +11,7 @@ SPDX-License-Identifier: MIT
 
 #include "llvm/Config/llvm-config.h"
 #include "llvm/IR/ConstantFolder.h"
+#include <llvm/Support/Casting.h>
 
 namespace IGCLLVM
 {
@@ -27,15 +28,140 @@ namespace IGCLLVM
     {
     private:
         llvm::ConstantFolder m_baseConstantFolder;
-    public:
-        ConstantFolderBase() :
-            m_baseConstantFolder(llvm::ConstantFolder()) {}
 
+        // these override functions are here to avoid letting `ConstantFolderBase` class
+        // becoming a pure-virtual class when LLVM_VERSION_MAJOR < 14
+#if LLVM_VERSION_MAJOR < 14
         inline llvm::Constant* CreateAdd(llvm::Constant* LHS, llvm::Constant* RHS,
             bool HasNUW = false, bool HasNSW = false) const override {
             return m_baseConstantFolder.CreateAdd(LHS, RHS, HasNUW, HasNSW);
         }
 
+        inline llvm::Constant* CreateAnd(llvm::Constant* LHS, llvm::Constant* RHS) const override {
+            return m_baseConstantFolder.CreateAnd(LHS, RHS);
+        }
+
+        inline llvm::Constant* CreateOr(llvm::Constant* LHS, llvm::Constant* RHS) const override {
+            return m_baseConstantFolder.CreateOr(LHS, RHS);
+        }
+
+        inline llvm::Constant* CreateICmp(llvm::CmpInst::Predicate P, llvm::Constant* LHS,
+            llvm::Constant* RHS) const override {
+            return m_baseConstantFolder.CreateICmp(P, LHS, RHS);
+        }
+
+        inline llvm::Constant* CreateSelect(llvm::Constant* C, llvm::Constant* True,
+            llvm::Constant* False) const override {
+            return m_baseConstantFolder.CreateSelect(C, True, False);
+        }
+
+        inline llvm::Constant* CreateGetElementPtr(llvm::Type* Ty, llvm::Constant* C,
+            llvm::ArrayRef<llvm::Constant*> IdxList) const override {
+            return m_baseConstantFolder.CreateGetElementPtr(Ty, C, IdxList);
+        }
+
+        inline llvm::Constant* CreateGetElementPtr(llvm::Type* Ty, llvm::Constant* C,
+            llvm::Constant* Idx) const override {
+            return m_baseConstantFolder.CreateGetElementPtr(Ty, C, Idx);
+        }
+
+        inline llvm::Constant* CreateGetElementPtr(llvm::Type* Ty, llvm::Constant* C,
+            llvm::ArrayRef<llvm::Value*> IdxList) const override {
+            return m_baseConstantFolder.CreateGetElementPtr(Ty, C, IdxList);
+        }
+
+        inline llvm::Constant* CreateInBoundsGetElementPtr(llvm::Type* Ty, llvm::Constant* C,
+            llvm::ArrayRef<llvm::Constant*> IdxList) const override {
+            return m_baseConstantFolder.CreateInBoundsGetElementPtr(Ty, C, IdxList);
+        }
+
+        inline llvm::Constant* CreateInBoundsGetElementPtr(llvm::Type* Ty, llvm::Constant* C,
+            llvm::Constant* Idx) const override {
+            return m_baseConstantFolder.CreateInBoundsGetElementPtr(Ty, C, Idx);
+        }
+
+        inline llvm::Constant* CreateInBoundsGetElementPtr(llvm::Type* Ty, llvm::Constant* C,
+            llvm::ArrayRef<llvm::Value*> IdxList) const override {
+            return m_baseConstantFolder.CreateInBoundsGetElementPtr(Ty, C, IdxList);
+        }
+#endif
+
+    public:
+        ConstantFolderBase() :
+            m_baseConstantFolder(llvm::ConstantFolder()) {}
+
+        inline llvm::Value* FoldAdd(llvm::Value* LHS, llvm::Value* RHS, bool HasNUW = false,
+            bool HasNSW = false) const
+#if LLVM_VERSION_MAJOR < 14
+        {
+            return CreateAdd(llvm::dyn_cast<llvm::Constant>(LHS), llvm::dyn_cast<llvm::Constant>(RHS), HasNUW, HasNSW);
+        }
+#else
+        override {
+            return m_baseConstantFolder.FoldAdd(LHS, RHS, HasNUW, HasNSW);
+        }
+#endif
+
+        inline llvm::Value* FoldAnd(llvm::Value* LHS, llvm::Value* RHS) const
+#if LLVM_VERSION_MAJOR < 14
+        {
+            return CreateAnd(llvm::dyn_cast<llvm::Constant>(LHS), llvm::dyn_cast<llvm::Constant>(RHS));
+        }
+#else
+        override {
+            return m_baseConstantFolder.FoldAnd(LHS, RHS);
+        }
+#endif
+
+        inline llvm::Value* FoldOr(llvm::Value* LHS, llvm::Value* RHS) const
+#if LLVM_VERSION_MAJOR < 14
+        {
+            return CreateOr(llvm::dyn_cast<llvm::Constant>(LHS), llvm::dyn_cast<llvm::Constant>(RHS));
+        }
+#else
+        override {
+            return m_baseConstantFolder.FoldOr(LHS, RHS);
+        }
+#endif
+
+        inline llvm::Value* FoldICmp(llvm::CmpInst::Predicate P, llvm::Value* LHS, llvm::Value* RHS) const
+#if LLVM_VERSION_MAJOR < 14
+        {
+            return CreateICmp(P, llvm::dyn_cast<llvm::Constant>(LHS), llvm::dyn_cast<llvm::Constant>(RHS));
+        }
+#else
+        override {
+            return m_baseConstantFolder.FoldICmp(P, LHS, RHS);
+        }
+#endif
+
+        inline llvm::Value* FoldSelect(llvm::Value* C, llvm::Value* True, llvm::Value* False) const
+#if LLVM_VERSION_MAJOR < 14
+        {
+            return CreateSelect(llvm::dyn_cast<llvm::Constant>(C), llvm::dyn_cast<llvm::Constant>(True), llvm::dyn_cast<llvm::Constant>(False));
+        }
+#else
+        override {
+            return m_baseConstantFolder.FoldSelect(C, True, False);
+        }
+#endif
+
+        inline llvm::Value* FoldGEP(llvm::Type* Ty, llvm::Value* Ptr, llvm::ArrayRef<llvm::Value*> IdxList,
+            bool IsInBounds = false) const
+#if LLVM_VERSION_MAJOR < 14
+        {
+            if (IsInBounds) {
+                return CreateInBoundsGetElementPtr(Ty, llvm::dyn_cast<llvm::Constant>(Ptr), IdxList);
+            } else {
+                return CreateGetElementPtr(Ty, llvm::dyn_cast<llvm::Constant>(Ptr), IdxList);
+            }
+        }
+#else
+        override {
+            return m_baseConstantFolder.FoldGEP(Ty, Ptr, IdxList, IsInBounds);
+        }
+#endif
+
         inline llvm::Constant* CreateFAdd(llvm::Constant* LHS, llvm::Constant* RHS) const override {
             return m_baseConstantFolder.CreateFAdd(LHS, RHS);
         }
@@ -99,14 +225,6 @@ namespace IGCLLVM
             return m_baseConstantFolder.CreateAShr(LHS, RHS, isExact);
         }
 
-        inline llvm::Constant* CreateAnd(llvm::Constant* LHS, llvm::Constant* RHS) const override {
-            return m_baseConstantFolder.CreateAnd(LHS, RHS);
-        }
-
-        inline llvm::Constant* CreateOr(llvm::Constant* LHS, llvm::Constant* RHS) const override {
-            return m_baseConstantFolder.CreateOr(LHS, RHS);
-        }
-
         inline llvm::Constant* CreateXor(llvm::Constant* LHS, llvm::Constant* RHS) const override {
             return m_baseConstantFolder.CreateXor(LHS, RHS);
         }
@@ -133,36 +251,6 @@ namespace IGCLLVM
             return m_baseConstantFolder.CreateUnOp(Opc, C);
         }
 
-        inline llvm::Constant* CreateGetElementPtr(llvm::Type* Ty, llvm::Constant* C,
-            llvm::ArrayRef<llvm::Constant*> IdxList) const override {
-            return m_baseConstantFolder.CreateGetElementPtr(Ty, C, IdxList);
-        }
-
-        inline llvm::Constant* CreateGetElementPtr(llvm::Type* Ty, llvm::Constant* C,
-            llvm::Constant* Idx) const override {
-            return m_baseConstantFolder.CreateGetElementPtr(Ty, C, Idx);
-        }
-
-        inline llvm::Constant* CreateGetElementPtr(llvm::Type* Ty, llvm::Constant* C,
-            llvm::ArrayRef<llvm::Value*> IdxList) const override {
-            return m_baseConstantFolder.CreateGetElementPtr(Ty, C, IdxList);
-        }
-
-        inline llvm::Constant* CreateInBoundsGetElementPtr(llvm::Type* Ty, llvm::Constant* C,
-            llvm::ArrayRef<llvm::Constant*> IdxList) const override {
-            return m_baseConstantFolder.CreateInBoundsGetElementPtr(Ty, C, IdxList);
-        }
-
-        inline llvm::Constant* CreateInBoundsGetElementPtr(llvm::Type* Ty, llvm::Constant* C,
-            llvm::Constant* Idx) const override {
-            return m_baseConstantFolder.CreateInBoundsGetElementPtr(Ty, C, Idx);
-        }
-
-        inline llvm::Constant* CreateInBoundsGetElementPtr(llvm::Type* Ty, llvm::Constant* C,
-            llvm::ArrayRef<llvm::Value*> IdxList) const override {
-            return m_baseConstantFolder.CreateInBoundsGetElementPtr(Ty, C, IdxList);
-        }
-
         inline llvm::Constant* CreateCast(llvm::Instruction::CastOps Op, llvm::Constant* C,
             llvm::Type* DestTy) const override {
             return m_baseConstantFolder.CreateCast(Op, C, DestTy);
@@ -210,21 +298,11 @@ namespace IGCLLVM
             return m_baseConstantFolder.CreateTruncOrBitCast(C, DestTy);
         }
 
-        inline llvm::Constant* CreateICmp(llvm::CmpInst::Predicate P, llvm::Constant* LHS,
-            llvm::Constant* RHS) const override {
-            return m_baseConstantFolder.CreateICmp(P, LHS, RHS);
-        }
-
         inline llvm::Constant* CreateFCmp(llvm::CmpInst::Predicate P, llvm::Constant* LHS,
             llvm::Constant* RHS) const override {
             return m_baseConstantFolder.CreateFCmp(P, LHS, RHS);
         }
 
-        inline llvm::Constant* CreateSelect(llvm::Constant* C, llvm::Constant* True,
-            llvm::Constant* False) const override {
-            return m_baseConstantFolder.CreateSelect(C, True, False);
-        }
-
         inline llvm::Constant* CreateExtractElement(llvm::Constant* Vec, llvm::Constant* Idx) const override {
             return m_baseConstantFolder.CreateExtractElement(Vec, Idx);
         }
diff --git a/IGC/WrapperLLVM/include/llvmWrapper/IR/Function.h b/IGC/WrapperLLVM/include/llvmWrapper/IR/Function.h
index 795509012..0e2ab4a15 100644
--- a/IGC/WrapperLLVM/include/llvmWrapper/IR/Function.h
+++ b/IGC/WrapperLLVM/include/llvmWrapper/IR/Function.h
@@ -31,6 +31,22 @@ inline llvm::Argument *getArg(const llvm::Function &F, unsigned ArgNo) {
   return Arg;
 }
 
+inline void addRetAttr(llvm::Function *F, llvm::Attribute::AttrKind Kind) {
+#if LLVM_VERSION_MAJOR < 14
+  F->addAttribute(llvm::AttributeList::ReturnIndex, Kind);
+#else
+  F->addRetAttr(Kind);
+#endif
+}
+
+inline bool onlyWritesMemory(llvm::Function *F) {
+#if LLVM_VERSION_MAJOR < 14
+  return F->doesNotReadMemory();
+#else
+  return F->onlyWritesMemory();
+#endif
+}
+
 } // namespace IGCLLVM
 
 #endif
diff --git a/IGC/WrapperLLVM/include/llvmWrapper/IR/IRBuilder.h b/IGC/WrapperLLVM/include/llvmWrapper/IR/IRBuilder.h
index c9347c191..54eae7648 100644
--- a/IGC/WrapperLLVM/include/llvmWrapper/IR/IRBuilder.h
+++ b/IGC/WrapperLLVM/include/llvmWrapper/IR/IRBuilder.h
@@ -301,6 +301,14 @@ namespace IGCLLVM
 
 #endif
 
+#if LLVM_VERSION_MAJOR >= 14
+        Value* CreatePtrDiff(Value *LHS, Value *RHS, const Twine &Name = "") {
+          auto *PtrTy = cast<PointerType>(LHS->getType());
+          Type *Ty = PtrTy->getElementType();
+          return llvm::IRBuilder<T, InserterTyDef()>::CreatePtrDiff(Ty, LHS, RHS, Name);
+        }
+#endif
+
         inline llvm::Value* CreateConstInBoundsGEP2_64(
             llvm::Value* Ptr,
             uint64_t Idx0,
diff --git a/IGC/WrapperLLVM/include/llvmWrapper/IR/InstrTypes.h b/IGC/WrapperLLVM/include/llvmWrapper/IR/InstrTypes.h
index 71a1aead0..569eece3f 100644
--- a/IGC/WrapperLLVM/include/llvmWrapper/IR/InstrTypes.h
+++ b/IGC/WrapperLLVM/include/llvmWrapper/IR/InstrTypes.h
@@ -34,6 +34,24 @@ namespace IGCLLVM
 #endif
         }
     }
+
+    inline void removeFnAttr(llvm::CallInst *CI, llvm::Attribute::AttrKind Kind)
+    {
+#if LLVM_VERSION_MAJOR >= 14
+        CI->removeFnAttr(Kind);
+#else
+        CI->removeAttribute(llvm::AttributeList::FunctionIndex, Kind);
+#endif
+    }
+
+    inline void addFnAttr(llvm::CallInst *CI, llvm::Attribute::AttrKind Kind)
+    {
+#if LLVM_VERSION_MAJOR >= 14
+        CI->addFnAttr(Kind);
+#else
+        CI->addAttribute(llvm::AttributeList::FunctionIndex, Kind);
+#endif
+    }
 }
 
 #endif
diff --git a/IGC/WrapperLLVM/include/llvmWrapper/IR/Instructions.h b/IGC/WrapperLLVM/include/llvmWrapper/IR/Instructions.h
index 1e6db9344..fa58622a3 100644
--- a/IGC/WrapperLLVM/include/llvmWrapper/IR/Instructions.h
+++ b/IGC/WrapperLLVM/include/llvmWrapper/IR/Instructions.h
@@ -80,6 +80,24 @@ namespace IGCLLVM
 #endif
     }
 
+    inline llvm::iterator_range<llvm::User::op_iterator> args(llvm::CallInst* CI)
+    {
+#if LLVM_VERSION_MAJOR < 8
+        return CI->arg_operands();
+#else
+        return CI->args();
+#endif
+    }
+
+    inline unsigned getNumArgOperands(const llvm::CallInst* CI)
+    {
+#if LLVM_VERSION_MAJOR < 14
+       return CI->getNumArgOperands();
+#else
+       return CI->arg_size();
+#endif
+    }
+
     inline unsigned getArgOperandNo(llvm::CallInst &CI, const llvm::Use *U) {
 #if LLVM_VERSION_MAJOR < 10
       IGC_ASSERT_MESSAGE(CI.isArgOperand(U), "Arg operand # out of range!");
diff --git a/IGC/WrapperLLVM/include/llvmWrapper/MC/MCContext.h b/IGC/WrapperLLVM/include/llvmWrapper/MC/MCContext.h
index 3725864ef..3b4abc1cf 100644
--- a/IGC/WrapperLLVM/include/llvmWrapper/MC/MCContext.h
+++ b/IGC/WrapperLLVM/include/llvmWrapper/MC/MCContext.h
@@ -11,7 +11,7 @@ SPDX-License-Identifier: MIT
 
 #include "llvm/Config/llvm-config.h"
 #include "llvm/MC/MCContext.h"
-#include "llvm/Support/TargetRegistry.h"
+#include "llvmWrapper/Support/TargetRegistry.h"
 
 namespace IGCLLVM
 {
diff --git a/IGC/WrapperLLVM/include/llvmWrapper/MC/MCStreamer.h b/IGC/WrapperLLVM/include/llvmWrapper/MC/MCStreamer.h
new file mode 100644
index 000000000..eff4861c7
--- /dev/null
+++ b/IGC/WrapperLLVM/include/llvmWrapper/MC/MCStreamer.h
@@ -0,0 +1,25 @@
+/*========================== begin_copyright_notice ============================
+
+Copyright (C) 2022 Intel Corporation
+
+SPDX-License-Identifier: MIT
+
+============================= end_copyright_notice ===========================*/
+
+#ifndef IGCLLVM_MC_MCSTREAMER_H
+#define IGCLLVM_MC_MCSTREAMER_H
+
+#include <llvm/MC/MCContext.h>
+#include <llvm/MC/MCStreamer.h>
+
+namespace IGCLLVM {
+inline void initSections(llvm::MCStreamer *streamer, bool NoExecStack, const llvm::MCContext *Context) {
+#if LLVM_VERSION_MAJOR >= 14
+    streamer->initSections(NoExecStack, *(Context->getSubtargetInfo()));
+#else
+    streamer->InitSections(NoExecStack);
+#endif
+}
+}
+
+#endif
diff --git a/IGC/WrapperLLVM/include/llvmWrapper/Support/Alignment.h b/IGC/WrapperLLVM/include/llvmWrapper/Support/Alignment.h
index 02d53af96..75e8cb533 100644
--- a/IGC/WrapperLLVM/include/llvmWrapper/Support/Alignment.h
+++ b/IGC/WrapperLLVM/include/llvmWrapper/Support/Alignment.h
@@ -18,6 +18,12 @@ SPDX-License-Identifier: MIT
 using namespace llvm;
 #endif
 
+#if LLVM_VERSION_MAJOR >= 14
+typedef uint64_t alignment_t;
+#else
+typedef unsigned alignment_t;
+#endif
+
 namespace IGCLLVM {
 #if LLVM_VERSION_MAJOR < 10
     inline uint64_t getAlignmentValue(uint64_t Val) { return Val; }
diff --git a/IGC/WrapperLLVM/include/llvmWrapper/Support/TargetRegistry.h b/IGC/WrapperLLVM/include/llvmWrapper/Support/TargetRegistry.h
new file mode 100644
index 000000000..f506655b0
--- /dev/null
+++ b/IGC/WrapperLLVM/include/llvmWrapper/Support/TargetRegistry.h
@@ -0,0 +1,20 @@
+/*========================== begin_copyright_notice ============================
+
+Copyright (C) 2018-2022 Intel Corporation
+
+SPDX-License-Identifier: MIT
+
+============================= end_copyright_notice ===========================*/
+
+#ifndef IGCLLVM_SUPPORT_TARGETREGISTRY_H
+#define IGCLLVM_SUPPORT_TARGETREGISTRY_H
+
+#include "llvm/Config/llvm-config.h"
+
+#if LLVM_VERSION_MAJOR < 14
+#include "llvm/Support/TargetRegistry.h"
+#else
+#include "llvm/MC/TargetRegistry.h"
+#endif
+
+#endif
diff --git a/IGC/WrapperLLVM/include/llvmWrapper/Transforms/InstCombine/InstCombineWorklist.h b/IGC/WrapperLLVM/include/llvmWrapper/Transforms/InstCombine/InstCombineWorklist.h
new file mode 100644
index 000000000..b54a23096
--- /dev/null
+++ b/IGC/WrapperLLVM/include/llvmWrapper/Transforms/InstCombine/InstCombineWorklist.h
@@ -0,0 +1,19 @@
+/*========================== begin_copyright_notice ============================
+
+Copyright (C) 2022 Intel Corporation
+
+SPDX-License-Identifier: MIT
+
+============================= end_copyright_notice ===========================*/
+#ifndef IGCLLVM_TRANSFORMS_UTILS_INSTCOMBINEWORKLIST_H
+#define IGCLLVM_TRANSFORMS_UTILS_INSTCOMBINEWORKLIST_H
+
+#include "llvm/Config/llvm-config.h"
+
+#if LLVM_VERSION_MAJOR <= 13
+#include "llvm/Transforms/InstCombine/InstCombineWorklist.h"
+#else
+#include "llvm/Transforms/Utils/InstructionWorklist.h"
+using InstCombineWorklist = llvm::InstructionWorklist;
+#endif
+#endif
diff --git a/IGC/WrapperLLVM/include/llvmWrapper/Transforms/Scalar.h b/IGC/WrapperLLVM/include/llvmWrapper/Transforms/Scalar.h
index 022141d15..35faa703d 100644
--- a/IGC/WrapperLLVM/include/llvmWrapper/Transforms/Scalar.h
+++ b/IGC/WrapperLLVM/include/llvmWrapper/Transforms/Scalar.h
@@ -26,7 +26,7 @@ namespace IGCLLVM
     {
         return llvm::createLoopUnrollPass(OptLevel, false, Threshold, Count, AllowPartial, Runtime, UpperBound, AllowPeeling);
     }
-#elif LLVM_VERSION_MAJOR >= 9 && LLVM_VERSION_MAJOR <= 13
+#elif LLVM_VERSION_MAJOR >= 9 && LLVM_VERSION_MAJOR <= 14
     inline static llvm::Pass * createLoopUnrollPass(
         int OptLevel = 2, int Threshold = -1, int Count = -1,
         int AllowPartial = -1, int Runtime = -1,
diff --git a/IGC/common/IGCIRBuilder.h b/IGC/common/IGCIRBuilder.h
index 6e319308d..4ceebaf96 100644
--- a/IGC/common/IGCIRBuilder.h
+++ b/IGC/common/IGCIRBuilder.h
@@ -11,7 +11,7 @@ SPDX-License-Identifier: MIT
 #include "common/LLVMWarningsPush.hpp"
 #include "llvmWrapper/IR/IRBuilder.h"
 #include "llvm/ADT/ArrayRef.h"
-#include "llvm/IR/Instructions.h"
+#include "llvmWrapper/IR/Instructions.h"
 #include "llvm/IR/Intrinsics.h"
 #include "llvm/IR/LLVMContext.h"
 #include "llvm/ADT/Twine.h"
diff --git a/IGC/common/debug/Debug.cpp b/IGC/common/debug/Debug.cpp
index 96804d32b..92551b95f 100644
--- a/IGC/common/debug/Debug.cpp
+++ b/IGC/common/debug/Debug.cpp
@@ -228,18 +228,30 @@ void Warning(
 }
 
 namespace {
+#if LLVM_VERSION_MAJOR >= 14
+    void FatalErrorHandler(void *user_data, const char* reason, bool gen_crash_diag)
+#else
     void FatalErrorHandler(void *user_data, const std::string& reason, bool gen_crash_diag)
+#endif
     {
         (void)user_data;
         (void)reason;
 #if defined( _DEBUG )
 #if defined( _WIN32 )
         OutputDebugStringA("LLVM Error: ");
+    #if LLVM_VERSION_MAJOR >= 14
+        OutputDebugStringA(reason);
+    #else
         OutputDebugStringA(reason.c_str());
+    #endif
         OutputDebugStringA("\n");
 #endif
         fprintf( stderr, "%s", "LLVM Error: " );
+    #if LLVM_VERSION_MAJOR >= 14
+        fprintf( stderr, "%s", reason);
+    #else
         fprintf( stderr, "%s", reason.c_str());
+    #endif
         fprintf( stderr, "%s", "\n");
         fflush( stderr );
 
-- 
2.36.1

