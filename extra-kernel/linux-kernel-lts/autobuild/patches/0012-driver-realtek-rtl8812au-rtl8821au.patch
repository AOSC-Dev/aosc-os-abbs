diff -Naur linux-4.9/drivers/staging/Kconfig linux-4.9.8821au/drivers/staging/Kconfig
--- linux-4.9/drivers/staging/Kconfig	2016-12-11 19:48:03.033737891 -0600
+++ linux-4.9.8821au/drivers/staging/Kconfig	2016-12-11 19:48:25.146978488 -0600
@@ -108,4 +108,6 @@
 
 source "drivers/staging/vc04_services/Kconfig"
 
+source "drivers/staging/rtl8821au/Kconfig"
+
 endif # STAGING
diff -Naur linux-4.9/drivers/staging/Kconfig.orig linux-4.9.8821au/drivers/staging/Kconfig.orig
--- linux-4.9/drivers/staging/Kconfig.orig	2016-12-11 19:48:03.037071210 -0600
+++ linux-4.9.8821au/drivers/staging/Kconfig.orig	2016-12-11 19:48:11.200369620 -0600
@@ -40,6 +40,8 @@
 
 source "drivers/staging/rtl8188eu/Kconfig"
 
+source "drivers/staging/rtl8723bs/Kconfig"
+
 source "drivers/staging/rts5208/Kconfig"
 
 source "drivers/staging/octeon/Kconfig"
diff -Naur linux-4.9/drivers/staging/Makefile linux-4.9.8821au/drivers/staging/Makefile
--- linux-4.9/drivers/staging/Makefile	2016-12-11 19:48:03.037071210 -0600
+++ linux-4.9.8821au/drivers/staging/Makefile	2016-12-11 19:48:50.043547661 -0600
@@ -43,3 +43,4 @@
 obj-$(CONFIG_GREYBUS)		+= greybus/
 obj-$(CONFIG_BCM2708_VCHIQ)	+= vc04_services/
 obj-$(CONFIG_RTL8723BS)		+= rtl8723bs/
+obj-$(CONFIG_RTL8821AU)		+= rtl8821au/
diff -Naur linux-4.9/drivers/staging/Makefile.orig linux-4.9.8821au/drivers/staging/Makefile.orig
--- linux-4.9/drivers/staging/Makefile.orig	2016-12-11 19:48:03.037071210 -0600
+++ linux-4.9.8821au/drivers/staging/Makefile.orig	2016-12-11 19:48:25.146978488 -0600
@@ -42,3 +42,4 @@
 obj-$(CONFIG_KS7010)		+= ks7010/
 obj-$(CONFIG_GREYBUS)		+= greybus/
 obj-$(CONFIG_BCM2708_VCHIQ)	+= vc04_services/
+obj-$(CONFIG_RTL8723BS)		+= rtl8723bs/
diff -Naur linux-4.9/drivers/staging/Makefile.rej linux-4.9.8821au/drivers/staging/Makefile.rej
--- linux-4.9/drivers/staging/Makefile.rej	2016-12-11 19:48:03.037071210 -0600
+++ linux-4.9.8821au/drivers/staging/Makefile.rej	2016-12-11 19:48:25.146978488 -0600
@@ -1,10 +1,7 @@
 --- drivers/staging/Makefile	2016-10-07 08:03:33.000000000 -0500
-+++ drivers/staging/Makefile	2016-10-13 14:20:55.744782469 -0500
-@@ -10,6 +10,7 @@
- obj-$(CONFIG_R8712U)		+= rtl8712/
- obj-$(CONFIG_R8188EU)		+= rtl8188eu/
- obj-$(CONFIG_R8723AU)		+= rtl8723au/
-+obj-$(CONFIG_RTL8723BS)		+= rtl8723bs/
- obj-$(CONFIG_RTS5208)		+= rts5208/
- obj-$(CONFIG_NETLOGIC_XLR_NET)	+= netlogic/
- obj-$(CONFIG_OCTEON_ETHERNET)	+= octeon/
++++ drivers/staging/Makefile	2016-10-13 07:28:59.790835486 -0500
+@@ -41,3 +41,4 @@
+ obj-$(CONFIG_MOST)		+= most/
+ obj-$(CONFIG_ISDN_I4L)		+= i4l/
+ obj-$(CONFIG_KS7010)		+= ks7010/
++obj-$(CONFIG_RTL8821AU)		+= rtl8821au/
diff -Naur linux-4.9/drivers/staging/rtl8821au/cam.c linux-4.9.8821au/drivers/staging/rtl8821au/cam.c
--- linux-4.9/drivers/staging/rtl8821au/cam.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/cam.c	2016-12-11 19:48:25.146978488 -0600
@@ -0,0 +1,209 @@
+#include <drv_types.h>
+#include <../usb.h>
+#include <../wifi.h>
+#include <../debug.h>
+#include <../cam.h>
+#include <../rtl8821au/reg.h>
+
+void rtw_cam_reset_sec_info(struct rtl_priv *rtlpriv)
+{
+	rtlpriv->sec.use_defaultkey = false;
+	rtlpriv->sec.pairwise_enc_algorithm = NO_ENCRYPTION;
+	rtlpriv->sec.group_enc_algorithm = NO_ENCRYPTION;
+	memset(rtlpriv->sec.key_buf, 0, KEY_BUF_SIZE * MAX_KEY_LEN);
+	memset(rtlpriv->sec.key_len, 0, KEY_BUF_SIZE);
+	rtlpriv->sec.pairwise_key = NULL;
+}
+
+
+void rtw_cam_reset_all_entry(struct rtl_priv *rtlpriv)
+{
+	u32 ul_command;
+
+	ul_command = BIT(31) | BIT(30);
+	rtl_write_dword(rtlpriv, rtlpriv->cfg->maps[RWCAM], ul_command);
+}
+
+void CAM_empty_entry(struct rtl_priv *rtlpriv, uint8_t ucIndex)
+{
+	uint8_t i;
+	uint32_t	ulCommand = 0;
+	uint32_t	ulContent = 0;
+	uint32_t	ulEncAlgo = CAM_AES;
+
+	for (i = 0; i < CAM_CONTENT_COUNT; i++) {
+		/* filled id in CAM config 2 byte */
+		if (i == 0) {
+			ulContent |= (ucIndex & 0x03) | ((u16)(ulEncAlgo)<<2);
+			/* ulContent |= CAM_VALID; */
+		} else 	{
+			ulContent = 0;
+		}
+		/*  polling bit, and No Write enable, and address */
+		ulCommand = CAM_CONTENT_COUNT*ucIndex+i;
+		ulCommand = ulCommand | CAM_POLLINIG | CAM_WRITE;
+		/* write content 0 is equall to mark invalid */
+		rtl_write_dword(rtlpriv, WCAMI, ulContent);  /* delay_ms(40); */
+		rtl_write_dword(rtlpriv, RWCAM, ulCommand);  /* delay_ms(40); */
+	}
+}
+
+static void write_cam(struct rtl_priv *rtlpriv, uint8_t entry, u16 ctrl, uint8_t *mac, uint8_t *key)
+{
+	unsigned int	i, val, addr;
+	//unsigned int    cmd;
+	int j;
+	uint32_t	cam_val[2];
+
+	addr = entry << 3;
+
+	for (j = 5; j >= 0; j--)
+	{
+		switch (j)
+		{
+			case 0:
+				val = (ctrl | (mac[0] << 16) | (mac[1] << 24) );
+				break;
+
+			case 1:
+				val = (mac[2] | ( mac[3] << 8) | (mac[4] << 16) | (mac[5] << 24));
+				break;
+
+			default:
+				i = (j - 2) << 2;
+				val = (key[i] | (key[i+1] << 8) | (key[i+2] << 16) | (key[i+3] << 24));
+				break;
+
+		}
+
+		cam_val[0] = val;
+		cam_val[1] = addr + (unsigned int)j;
+
+		rtlpriv->cfg->ops->set_hw_reg(rtlpriv, HW_VAR_CAM_WRITE, (uint8_t *)cam_val);
+
+		//rtw_write32(rtlpriv, WCAMI, val);
+
+		//cmd = CAM_POLLINIG | CAM_WRITE | (addr + j);
+		//rtw_write32(rtlpriv, RWCAM, cmd);
+
+		//DBG_871X("%s=> cam write: %x, %x\n",__FUNCTION__, cmd, val);
+
+	}
+
+}
+
+void clear_cam_entry(struct rtl_priv *rtlpriv, uint8_t entry)
+{
+
+	unsigned char null_sta[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
+
+	unsigned char null_key[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00};
+
+	write_cam(rtlpriv, entry, 0, null_sta, null_key);
+}
+
+static void rtl_cam_program_entry(struct rtl_priv *rtlpriv, u32 entry_no,
+			   u8 *mac_addr, u8 *key_cont_128, u16 us_config)
+{
+	u32 target_command;
+	u32 target_content = 0;
+	u8 entry_i;
+
+	RT_PRINT_DATA(rtlpriv, COMP_SEC, DBG_DMESG, "Key content :",
+		      key_cont_128, 16);
+
+	for (entry_i = 0; entry_i < CAM_CONTENT_COUNT; entry_i++) {
+		target_command = entry_i + CAM_CONTENT_COUNT * entry_no;
+		target_command = target_command | BIT(31) | BIT(16);
+
+		if (entry_i == 0) {
+			target_content = (u32) (*(mac_addr + 0)) << 16 |
+			    (u32) (*(mac_addr + 1)) << 24 | (u32) us_config;
+
+			rtl_write_dword(rtlpriv, rtlpriv->cfg->maps[WCAMI],
+					target_content);
+			rtl_write_dword(rtlpriv, rtlpriv->cfg->maps[RWCAM],
+					target_command);
+
+			RT_TRACE(rtlpriv, COMP_SEC, DBG_LOUD,
+				 "WRITE %x: %x\n",
+				 rtlpriv->cfg->maps[WCAMI], target_content);
+			RT_TRACE(rtlpriv, COMP_SEC, DBG_LOUD,
+				 "The Key ID is %d\n", entry_no);
+			RT_TRACE(rtlpriv, COMP_SEC, DBG_LOUD,
+				 "WRITE %x: %x\n",
+				 rtlpriv->cfg->maps[RWCAM], target_command);
+
+		} else if (entry_i == 1) {
+
+			target_content = (u32) (*(mac_addr + 5)) << 24 |
+			    (u32) (*(mac_addr + 4)) << 16 |
+			    (u32) (*(mac_addr + 3)) << 8 |
+			    (u32) (*(mac_addr + 2));
+
+			rtl_write_dword(rtlpriv, rtlpriv->cfg->maps[WCAMI],
+					target_content);
+			rtl_write_dword(rtlpriv, rtlpriv->cfg->maps[RWCAM],
+					target_command);
+
+			RT_TRACE(rtlpriv, COMP_SEC, DBG_LOUD,
+				 "WRITE A4: %x\n", target_content);
+			RT_TRACE(rtlpriv, COMP_SEC, DBG_LOUD,
+				 "WRITE A0: %x\n", target_command);
+
+		} else {
+
+			target_content =
+			    (u32) (*(key_cont_128 + (entry_i * 4 - 8) + 3)) <<
+			    24 | (u32) (*(key_cont_128 + (entry_i * 4 - 8) + 2))
+			    << 16 |
+			    (u32) (*(key_cont_128 + (entry_i * 4 - 8) + 1)) << 8
+			    | (u32) (*(key_cont_128 + (entry_i * 4 - 8) + 0));
+
+			rtl_write_dword(rtlpriv, rtlpriv->cfg->maps[WCAMI],
+					target_content);
+			rtl_write_dword(rtlpriv, rtlpriv->cfg->maps[RWCAM],
+					target_command);
+			udelay(100);
+
+			RT_TRACE(rtlpriv, COMP_SEC, DBG_LOUD,
+				 "WRITE A4: %x\n", target_content);
+			RT_TRACE(rtlpriv, COMP_SEC, DBG_LOUD,
+				 "WRITE A0: %x\n", target_command);
+		}
+	}
+
+	RT_TRACE(rtlpriv, COMP_SEC, DBG_LOUD,
+		 "after set key, usconfig:%x\n", us_config);
+}
+
+u8 rtw_cam_add_one_entry(struct rtl_priv *rtlpriv, u8 *mac_addr,
+			 u32 ul_key_id, u32 ul_entry_idx, u32 ul_enc_alg,
+			 u32 ul_default_key, u8 *key_content)
+{
+	u32 us_config;
+
+	RT_TRACE(rtlpriv, COMP_SEC, DBG_DMESG,
+		 "EntryNo:%x, ulKeyId=%x, ulEncAlg=%x, ulUseDK=%x MacAddr %pM\n",
+		 ul_entry_idx, ul_key_id, ul_enc_alg,
+		 ul_default_key, mac_addr);
+
+	if (ul_key_id == TOTAL_CAM_ENTRY) {
+		RT_TRACE(rtlpriv, COMP_ERR, DBG_WARNING,
+			 "ulKeyId exceed!\n");
+		return 0;
+	}
+
+	if (ul_default_key == 1)
+		us_config = CFG_VALID | ((u16) (ul_enc_alg) << 2);
+	else
+		us_config = CFG_VALID | ((ul_enc_alg) << 2) | ul_key_id;
+
+
+	rtl_cam_program_entry(rtlpriv, ul_entry_idx, mac_addr,
+			      (u8 *)key_content, us_config);
+
+	RT_TRACE(rtlpriv, COMP_SEC, DBG_DMESG, "end\n");
+	
+	return 1;
+}
diff -Naur linux-4.9/drivers/staging/rtl8821au/cam.h linux-4.9.8821au/drivers/staging/rtl8821au/cam.h
--- linux-4.9/drivers/staging/rtl8821au/cam.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/cam.h	2016-12-11 19:48:25.146978488 -0600
@@ -0,0 +1,19 @@
+#ifndef __RTW_CAM_H__
+#define __RTW_CAM_H__
+
+#define	CAM_CONTENT_COUNT		8
+#define	CFG_VALID			BIT(15)
+#define	CAM_WRITE			BIT(16)
+#define	CAM_POLLINIG			BIT(31)
+
+void rtw_cam_reset_all_entry(struct rtl_priv *rtlpriv);
+// void write_cam(struct rtl_priv *rtlpriv, uint8_t entry, u16 ctrl, uint8_t *mac, uint8_t *key);
+void clear_cam_entry(struct rtl_priv *rtlpriv, uint8_t entry);
+
+void CAM_empty_entry(struct rtl_priv *rtlpriv, uint8_t ucIndex);
+
+u8 rtw_cam_add_one_entry(struct rtl_priv *rtlpriv, u8 *mac_addr,
+			 u32 ul_key_id, u32 ul_entry_idx, u32 ul_enc_alg,
+			 u32 ul_default_key, u8 *key_content);
+
+#endif
diff -Naur linux-4.9/drivers/staging/rtl8821au/core/rtw_ap.c linux-4.9.8821au/drivers/staging/rtl8821au/core/rtw_ap.c
--- linux-4.9/drivers/staging/rtl8821au/core/rtw_ap.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/core/rtw_ap.c	2016-12-11 19:48:25.146978488 -0600
@@ -0,0 +1,2402 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#define _RTW_AP_C_
+
+#include <drv_types.h>
+#include <rtw_ap.h>
+#include <../rtl8821au/hw.h>
+
+#undef DBG_871X
+static inline void DBG_871X(const char *fmt, ...)
+{
+}
+
+#ifdef CONFIG_AP_MODE
+
+static struct list_head *get_next(struct list_head	*list)
+{
+	return list->next;
+}
+
+extern unsigned char	RTW_WPA_OUI[];
+extern unsigned char	WMM_OUI[];
+extern unsigned char	WPS_OUI[];
+extern unsigned char	P2P_OUI[];
+extern unsigned char	WFD_OUI[];
+
+void init_mlme_ap_info(struct rtl_priv *rtlpriv)
+{
+	struct mlme_ext_priv *pmlmeext = &rtlpriv->mlmeextpriv;
+	struct mlme_priv *pmlmepriv = &(rtlpriv->mlmepriv);
+	struct sta_priv *pstapriv = &rtlpriv->stapriv;
+	struct wlan_acl_pool *pacl_list = &pstapriv->acl_list;
+
+
+	spin_lock_init(&pmlmepriv->bcn_update_lock);
+
+	/*
+	 * for ACL
+	 */
+	_rtw_init_queue(&pacl_list->acl_node_q);
+
+	/*
+	 * pmlmeext->bstart_bss = false;
+	 */
+
+	start_ap_mode(rtlpriv);
+}
+
+void free_mlme_ap_info(struct rtl_priv *rtlpriv)
+{
+	struct sta_info *psta = NULL;
+	struct sta_priv *pstapriv = &rtlpriv->stapriv;
+	struct mlme_priv *pmlmepriv = &(rtlpriv->mlmepriv);
+	struct mlme_ext_priv *pmlmeext = &rtlpriv->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	/*
+	 * stop_ap_mode(rtlpriv);
+	 */
+
+	pmlmepriv->update_bcn = false;
+	pmlmeext->bstart_bss = false;
+
+	rtw_sta_flush(rtlpriv);
+
+	pmlmeinfo->state = _HW_STATE_NOLINK_;
+
+	/*
+	 * ree_assoc_sta_resources
+	 */
+	rtw_free_all_stainfo(rtlpriv);
+
+	/*
+	 * free bc/mc sta_info
+	 */
+
+	psta = rtw_get_bcmc_stainfo(rtlpriv);
+	spin_lock_bh(&(pstapriv->sta_hash_lock));
+	rtw_free_stainfo(rtlpriv, psta);
+	spin_unlock_bh(&(pstapriv->sta_hash_lock));
+}
+
+static void update_BCNTIM(struct rtl_priv *rtlpriv)
+{
+	struct sta_priv *pstapriv = &rtlpriv->stapriv;
+	struct mlme_ext_priv *pmlmeext = &(rtlpriv->mlmeextpriv);
+	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
+	WLAN_BSSID_EX *pnetwork_mlmeext = &(pmlmeinfo->network);
+	unsigned char *pie = pnetwork_mlmeext->IEs;
+
+	/*
+	 * DBG_871X("%s\n", __FUNCTION__);
+	 */
+
+	/*
+	 * pdate TIM IE
+	 */
+	/* if (pstapriv->tim_bitmap) */
+	if (true) {
+		uint8_t *p, *dst_ie, *premainder_ie = NULL, *pbackup_remainder_ie = NULL;
+		u16 tim_bitmap_le;
+		uint offset, tmp_len, tim_ielen, tim_ie_offset, remainder_ielen;
+
+		tim_bitmap_le = cpu_to_le16(pstapriv->tim_bitmap);
+
+		p = rtw_get_ie(pie + _FIXED_IE_LENGTH_, _TIM_IE_, &tim_ielen, pnetwork_mlmeext->IELength - _FIXED_IE_LENGTH_);
+		if (p != NULL && tim_ielen > 0) {
+			tim_ielen += 2;
+
+			premainder_ie = p+tim_ielen;
+
+			tim_ie_offset = (int)(p - pie);
+
+			remainder_ielen = pnetwork_mlmeext->IELength - tim_ie_offset - tim_ielen;
+
+			/*
+			 * append TIM IE from dst_ie offset
+			 */
+			dst_ie = p;
+		} else {
+			tim_ielen = 0;
+
+			/* calucate head_len */
+
+			offset = _FIXED_IE_LENGTH_;
+
+			/* get ssid_ie len */
+			p = rtw_get_ie(pie + _BEACON_IE_OFFSET_, _SSID_IE_, &tmp_len, (pnetwork_mlmeext->IELength - _BEACON_IE_OFFSET_));
+			if (p != NULL)
+				offset += tmp_len+2;
+
+			/* get supported rates len */
+			p = rtw_get_ie(pie + _BEACON_IE_OFFSET_, _SUPPORTEDRATES_IE_, &tmp_len, (pnetwork_mlmeext->IELength - _BEACON_IE_OFFSET_));
+			if (p !=  NULL) {
+				offset += tmp_len+2;
+			}
+
+			/* DS Parameter Set IE, len=3 */
+			offset += 3;
+
+			premainder_ie = pie + offset;
+
+			remainder_ielen = pnetwork_mlmeext->IELength - offset - tim_ielen;
+
+			/* append TIM IE from offset */
+			dst_ie = pie + offset;
+		}
+
+
+		if (remainder_ielen > 0) {
+			pbackup_remainder_ie = rtw_malloc(remainder_ielen);
+			if (pbackup_remainder_ie && premainder_ie)
+				memcpy(pbackup_remainder_ie, premainder_ie, remainder_ielen);
+		}
+
+		*dst_ie++ = _TIM_IE_;
+
+		if ((pstapriv->tim_bitmap&0xff00) && (pstapriv->tim_bitmap&0x00fe))
+			tim_ielen = 5;
+		else
+			tim_ielen = 4;
+
+		*dst_ie++ = tim_ielen;
+
+		*dst_ie++ = 0;	/*	DTIM count */
+		*dst_ie++ = 1;	/*	DTIM peroid */
+
+		if (pstapriv->tim_bitmap&BIT(0))	/* for bc/mc frames */
+			*dst_ie++ = BIT(0);	/*bitmap ctrl */
+		else
+			*dst_ie++ = 0;
+
+		if (tim_ielen == 4) {
+			uint8_t pvb = 0;
+
+			if (pstapriv->tim_bitmap&0x00fe)
+				pvb = (uint8_t)tim_bitmap_le;
+			else if (pstapriv->tim_bitmap&0xff00)
+				pvb = (uint8_t)(tim_bitmap_le>>8);
+			else
+				pvb = (uint8_t)tim_bitmap_le;
+
+			*dst_ie++ = pvb;
+
+		} else if (tim_ielen == 5) {
+			memcpy(dst_ie, &tim_bitmap_le, 2);
+			dst_ie += 2;
+		}
+
+		/* copy remainder IE */
+		if (pbackup_remainder_ie) {
+			memcpy(dst_ie, pbackup_remainder_ie, remainder_ielen);
+
+			/* ULLI check usage of remainder_ielen */
+			rtw_mfree(pbackup_remainder_ie);
+		}
+
+		offset =  (uint)(dst_ie - pie);
+		pnetwork_mlmeext->IELength = offset + remainder_ielen;
+
+	}
+
+	set_tx_beacon_cmd(rtlpriv);
+
+
+}
+
+void rtw_add_bcn_ie(struct rtl_priv *rtlpriv, WLAN_BSSID_EX *pnetwork, uint8_t index, uint8_t *data, uint8_t len)
+{
+	PNDIS_802_11_VARIABLE_IEs	pIE;
+	uint8_t	bmatch = false;
+	uint8_t	*pie = pnetwork->IEs;
+	uint8_t	*p, *dst_ie, *premainder_ie = NULL, *pbackup_remainder_ie = NULL;
+	uint32_t	i, offset, ielen, ie_offset, remainder_ielen = 0;
+
+	for (i = sizeof(NDIS_802_11_FIXED_IEs); i < pnetwork->IELength;) {
+		pIE = (PNDIS_802_11_VARIABLE_IEs)(pnetwork->IEs + i);
+
+		if (pIE->ElementID > index) {
+			break;
+		} else if (pIE->ElementID == index) {	/* already exist the same IE */
+			p = (uint8_t *)pIE;
+			ielen = pIE->Length;
+			bmatch = true;
+			break;
+		}
+
+		p = (uint8_t *)pIE;
+		ielen = pIE->Length;
+		i += (pIE->Length + 2);
+	}
+
+	if (p != NULL && ielen > 0) {
+		ielen += 2;
+
+		premainder_ie = p+ielen;
+
+		ie_offset = (int)(p -pie);
+
+		remainder_ielen = pnetwork->IELength - ie_offset - ielen;
+
+		if (bmatch)
+			dst_ie = p;
+		else
+			dst_ie = (p+ielen);
+	}
+
+	if (remainder_ielen > 0) {
+		pbackup_remainder_ie = rtw_malloc(remainder_ielen);
+		if (pbackup_remainder_ie && premainder_ie)
+			memcpy(pbackup_remainder_ie, premainder_ie, remainder_ielen);
+	}
+
+	*dst_ie++ = index;
+	*dst_ie++ = len;
+
+	memcpy(dst_ie, data, len);
+	dst_ie += len;
+
+	/* copy remainder IE */
+	if (pbackup_remainder_ie) {
+		memcpy(dst_ie, pbackup_remainder_ie, remainder_ielen);
+		/* ULLI check usage of remainder_ielen  */
+		rtw_mfree(pbackup_remainder_ie);
+	}
+
+	offset =  (uint)(dst_ie - pie);
+	pnetwork->IELength = offset + remainder_ielen;
+}
+
+void rtw_remove_bcn_ie(struct rtl_priv *rtlpriv, WLAN_BSSID_EX *pnetwork, uint8_t index)
+{
+	uint8_t *p, *dst_ie, *premainder_ie = NULL, *pbackup_remainder_ie = NULL;
+	uint offset, ielen, ie_offset, remainder_ielen = 0;
+	uint8_t	*pie = pnetwork->IEs;
+
+	p = rtw_get_ie(pie + _FIXED_IE_LENGTH_, index, &ielen, pnetwork->IELength - _FIXED_IE_LENGTH_);
+	if (p != NULL && ielen > 0) {
+		ielen += 2;
+
+		premainder_ie = p+ielen;
+
+		ie_offset = (int)(p -pie);
+
+		remainder_ielen = pnetwork->IELength - ie_offset - ielen;
+
+		dst_ie = p;
+	}
+
+	if (remainder_ielen > 0) {
+		pbackup_remainder_ie = rtw_malloc(remainder_ielen);
+		if (pbackup_remainder_ie && premainder_ie)
+			memcpy(pbackup_remainder_ie, premainder_ie, remainder_ielen);
+	}
+
+	/* copy remainder IE */
+	if (pbackup_remainder_ie) {
+		memcpy(dst_ie, pbackup_remainder_ie, remainder_ielen);
+		/* ULLI check usage of remainder_ielen */
+		rtw_mfree(pbackup_remainder_ie);
+	}
+
+	offset =  (uint)(dst_ie - pie);
+	pnetwork->IELength = offset + remainder_ielen;
+}
+
+
+uint8_t chk_sta_is_alive(struct sta_info *psta);
+uint8_t chk_sta_is_alive(struct sta_info *psta)
+{
+	uint8_t ret = false;
+	#ifdef DBG_EXPIRATION_CHK
+	DBG_871X("sta:"MAC_FMT", rssi:%d, rx:"STA_PKTS_FMT", expire_to:%u, %s%ssq_len:%u\n"
+		, MAC_ARG(psta->hwaddr)
+		, psta->rssi_stat.UndecoratedSmoothedPWDB
+		//, STA_RX_PKTS_ARG(psta)
+		, STA_RX_PKTS_DIFF_ARG(psta)
+		, psta->expire_to
+		, psta->state&WIFI_SLEEP_STATE?"PS, ":""
+		, psta->state&WIFI_STA_ALIVE_CHK_STATE?"SAC, ":""
+		, psta->sleepq_len
+	);
+	#endif
+
+	/* if (sta_last_rx_pkts(psta) == sta_rx_pkts(psta)) */
+	if ((psta->sta_stats.last_rx_data_pkts + psta->sta_stats.last_rx_ctrl_pkts) == (psta->sta_stats.rx_data_pkts + psta->sta_stats.rx_ctrl_pkts))
+	{
+		#if 0
+		if (psta->state&WIFI_SLEEP_STATE)
+			ret = true;
+		#endif
+	} else {
+		ret = true;
+	}
+
+	sta_update_last_rx_pkts(psta);
+
+	return ret;
+}
+
+void	expire_timeout_chk(struct rtl_priv *rtlpriv)
+{
+	struct list_head	*phead, *plist;
+	uint8_t updated;
+	struct sta_info *psta = NULL;
+	struct sta_priv *pstapriv = &rtlpriv->stapriv;
+	uint8_t chk_alive_num = 0;
+	char chk_alive_list[NUM_STA];
+	int i;
+
+	spin_lock_bh(&pstapriv->auth_list_lock);
+
+	phead = &pstapriv->auth_list;
+	plist = get_next(phead);
+
+	/* check auth_queue */
+#ifdef DBG_EXPIRATION_CHK
+	if (rtw_end_of_queue_search(phead, plist) == false) {
+		DBG_871X(FUNC_NDEV_FMT" auth_list, cnt:%u\n"
+			, FUNC_NDEV_ARG(rtlpriv->ndev), pstapriv->auth_list_cnt);
+	}
+#endif
+	while ((rtw_end_of_queue_search(phead, plist)) == false) {
+		psta = container_of(plist, struct sta_info, auth_list);
+		plist = get_next(plist);
+
+		if (psta->expire_to > 0) {
+			psta->expire_to--;
+			if (psta->expire_to == 0) {
+				list_del_init(&psta->auth_list);
+				pstapriv->auth_list_cnt--;
+
+				DBG_871X("auth expire %02X%02X%02X%02X%02X%02X\n",
+					psta->hwaddr[0], psta->hwaddr[1], psta->hwaddr[2],
+					psta->hwaddr[3], psta->hwaddr[4], psta->hwaddr[5]);
+
+				spin_unlock_bh(&pstapriv->auth_list_lock);
+
+				spin_lock_bh(&(pstapriv->sta_hash_lock));
+				rtw_free_stainfo(rtlpriv, psta);
+				spin_unlock_bh(&(pstapriv->sta_hash_lock));
+
+				spin_lock_bh(&pstapriv->auth_list_lock);
+			}
+		}
+
+	}
+
+	spin_unlock_bh(&pstapriv->auth_list_lock);
+
+	psta = NULL;
+
+	spin_lock_bh(&pstapriv->asoc_list_lock);
+
+	phead = &pstapriv->asoc_list;
+	plist = get_next(phead);
+
+	/* check asoc_queue */
+#ifdef DBG_EXPIRATION_CHK
+	if (rtw_end_of_queue_search(phead, plist) == false) {
+		DBG_871X(FUNC_NDEV_FMT" asoc_list, cnt:%u\n"
+			, FUNC_NDEV_ARG(rtlpriv->ndev), pstapriv->asoc_list_cnt);
+	}
+#endif
+	while ((rtw_end_of_queue_search(phead, plist)) == false) {
+		psta = container_of(plist, struct sta_info, asoc_list);
+		plist = get_next(plist);
+
+		if (chk_sta_is_alive(psta) || !psta->expire_to) {
+			psta->expire_to = pstapriv->expire_to;
+			psta->keep_alive_trycnt = 0;
+			#ifdef CONFIG_TX_MCAST2UNI
+			psta->under_exist_checking = 0;
+			#endif	/* CONFIG_TX_MCAST2UNI */
+		} else {
+			psta->expire_to--;
+		}
+
+#ifdef CONFIG_TX_MCAST2UNI
+		if ((psta->flags & WLAN_STA_HT) && (psta->htpriv.agg_enable_bitmap || psta->under_exist_checking)) {
+			/*
+			 * check sta by delba(addba) for 11n STA
+			 * ToDo: use CCX report to check for all STAs
+			 */
+
+			/*
+			 * DBG_871X("asoc check by DELBA/ADDBA! (pstapriv->expire_to=%d s)(psta->expire_to=%d s), [%02x, %d]\n", pstapriv->expire_to*2, psta->expire_to*2, psta->htpriv.agg_enable_bitmap, psta->under_exist_checking);
+			 */
+
+				if ( psta->expire_to <= (pstapriv->expire_to - 50 ) ) {
+				DBG_871X("asoc expire by DELBA/ADDBA! (%d s)\n", (pstapriv->expire_to-psta->expire_to)*2);
+				psta->under_exist_checking = 0;
+				psta->expire_to = 0;
+			} else if ( psta->expire_to <= (pstapriv->expire_to - 3) && (psta->under_exist_checking == 0)) {
+				DBG_871X("asoc check by DELBA/ADDBA! (%d s)\n", (pstapriv->expire_to-psta->expire_to)*2);
+				psta->under_exist_checking = 1;
+				/* tear down TX AMPDU */
+				send_delba(rtlpriv, 1, psta->hwaddr);// // originator
+				psta->htpriv.agg_enable_bitmap = 0x0;//reset
+				psta->htpriv.candidate_tid_bitmap = 0x0;//reset
+			}
+		}
+#endif // CONFIG_TX_MCAST2UNI
+
+		if (psta->expire_to <= 0) {
+			list_del_init(&psta->asoc_list);
+			pstapriv->asoc_list_cnt--;
+
+			DBG_871X("asoc expire "MAC_FMT", state=0x%x\n", MAC_ARG(psta->hwaddr), psta->state);
+			updated = ap_free_sta(rtlpriv, psta, false, WLAN_REASON_DEAUTH_LEAVING);
+		} else {
+			/* TODO: Aging mechanism to digest frames in sleep_q to avoid running out of xmitframe */
+			if (psta->sleepq_len > (NR_XMITFRAME/pstapriv->asoc_list_cnt)
+				&& rtlpriv->xmitpriv.free_xmitframe_cnt < ((NR_XMITFRAME/pstapriv->asoc_list_cnt)/2)
+			){
+				DBG_871X("%s sta:"MAC_FMT", sleepq_len:%u, free_xmitframe_cnt:%u, asoc_list_cnt:%u, clear sleep_q\n", __func__
+					, MAC_ARG(psta->hwaddr)
+					, psta->sleepq_len, rtlpriv->xmitpriv.free_xmitframe_cnt, pstapriv->asoc_list_cnt);
+				wakeup_sta_to_xmit(rtlpriv, psta);
+			}
+		}
+	}
+
+	spin_unlock_bh(&pstapriv->asoc_list_lock);
+
+	associated_clients_update(rtlpriv, updated);
+}
+
+void add_RATid(struct rtl_priv *rtlpriv, struct sta_info *psta, uint8_t rssi_level)
+{
+	int i;
+	uint8_t rf_type;
+	uint32_t	 init_rate = 0;
+	unsigned char sta_band = 0, raid, shortGIrate = false;
+	unsigned char limit;
+	unsigned int tx_ra_bitmap=0;
+	struct ht_priv	*psta_ht = NULL;
+	struct mlme_priv *pmlmepriv = &(rtlpriv->mlmepriv);
+	WLAN_BSSID_EX *pcur_network = (WLAN_BSSID_EX *)&pmlmepriv->cur_network.network;
+
+	if (psta)
+		psta_ht = &psta->htpriv;
+	else
+		return;
+
+	if (!(psta->state & _FW_LINKED))
+		return;
+
+	//b/g mode ra_bitmap
+	for (i = 0; i < sizeof(psta->bssrateset); i++) {
+		if (psta->bssrateset[i])
+			tx_ra_bitmap |= rtw_get_bit_value_from_ieee_value(psta->bssrateset[i]&0x7f);
+	}
+	//AC mode ra_bitmap
+	if (psta->vhtpriv.vht_option) {
+		uint32_t	vht_bitmap = 0;
+
+		vht_bitmap = rtw_vht_rate_to_bitmap(psta->vhtpriv.vht_mcs_map);
+		tx_ra_bitmap |= (vht_bitmap << 12);
+
+		//max short GI rate
+		shortGIrate = psta->vhtpriv.sgi;
+	} else
+		{
+		//n mode ra_bitmap
+		if (psta_ht->ht_option)	{
+			rf_type = rtlpriv->phy.rf_type;
+
+			if (rf_type == RF_2T2R)
+				limit = 16;	// 2R
+			else
+				limit = 8;	//  1R
+
+			for (i = 0; i < limit; i++) {
+				if (psta_ht->ht_cap.supp_mcs_set[i/8] & BIT(i%8))
+					tx_ra_bitmap |= BIT(i+12);
+			}
+
+			//max short GI rate
+			shortGIrate = psta_ht->sgi;
+		}
+	}
+
+	if ( pcur_network->Configuration.DSConfig > 14 ) {
+		// 5G band
+		if (psta->vhtpriv.vht_option)  {
+			sta_band = WIRELESS_11_5AC;
+		} else
+		{
+			if (tx_ra_bitmap & 0xffff000)
+				sta_band |= WIRELESS_11_5N | WIRELESS_11A;
+			else
+				sta_band |= WIRELESS_11A;
+		}
+	} else {
+		if (tx_ra_bitmap & 0xffff000)
+			sta_band |= WIRELESS_11_24N | WIRELESS_11G | WIRELESS_11B;
+		else if (tx_ra_bitmap & 0xff0)
+			sta_band |= WIRELESS_11G |WIRELESS_11B;
+		else
+			sta_band |= WIRELESS_11B;
+	}
+
+	psta->wireless_mode = sta_band;
+
+	//raid = networktype_to_raid(sta_band);
+	raid = rtw_hal_networktype_to_raid(rtlpriv,sta_band);
+
+	init_rate = get_highest_rate_idx(tx_ra_bitmap)&0x3f;
+
+	if (psta->aid < NUM_STA) {
+		uint8_t	arg[4] = {0};
+
+		//arg[0] = macid
+		//arg[1] = raid
+		//arg[2] = shortGIrate
+		//arg[3] = init_rate
+
+		arg[0] = psta->mac_id;
+		arg[1] = raid;
+		arg[2] = shortGIrate;
+		arg[3] = init_rate;
+
+		DBG_871X("%s=> mac_id:%d , raid:%d , shortGIrate=%d, bitmap=0x%x\n",
+			__FUNCTION__ , psta->mac_id, raid ,shortGIrate, tx_ra_bitmap);
+
+		rtlpriv->cfg->ops->Add_RateATid(rtlpriv, tx_ra_bitmap, arg, rssi_level);
+
+		if (shortGIrate == true)
+			init_rate |= BIT(6);
+
+		//set ra_id, init_rate
+		psta->raid = raid;
+		psta->init_rate = init_rate;
+	} else {
+		DBG_871X("station aid %d exceed the max number\n", psta->aid);
+	}
+
+}
+
+static void update_bmc_sta(struct rtl_priv *rtlpriv)
+{
+	uint32_t	 init_rate=0;
+	unsigned char	network_type, raid;
+	int i, supportRateNum = 0;
+	unsigned int tx_ra_bitmap = 0;
+	struct mlme_priv *pmlmepriv = &(rtlpriv->mlmepriv);
+	struct mlme_ext_priv	*pmlmeext = &(rtlpriv->mlmeextpriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	WLAN_BSSID_EX *pcur_network = (WLAN_BSSID_EX *)&pmlmepriv->cur_network.network;
+	struct sta_info *psta = rtw_get_bcmc_stainfo(rtlpriv);
+
+	if (psta) {
+		psta->aid = 0;//default set to 0
+		//psta->mac_id = psta->aid+4;
+		psta->mac_id = psta->aid + 1;//mac_id=1 for bc/mc stainfo
+
+		pmlmeinfo->FW_sta_info[psta->mac_id].psta = psta;
+
+		psta->qos_option = 0;
+		psta->htpriv.ht_option = false;
+
+		psta->ieee8021x_blocked = 0;
+
+		memset((void*)&psta->sta_stats, 0, sizeof(struct stainfo_stats));
+
+		//psta->dot118021XPrivacy = NO_ENCRYPTION;//!!! remove it, because it has been set before this.
+
+
+
+		//prepare for add_RATid
+		supportRateNum = rtw_get_rateset_len((uint8_t *)&pcur_network->SupportedRates);
+		network_type = rtw_check_network_type((uint8_t *)&pcur_network->SupportedRates, supportRateNum, 1);
+
+		memcpy(psta->bssrateset, &pcur_network->SupportedRates, supportRateNum);
+		psta->bssratelen = supportRateNum;
+
+		//b/g mode ra_bitmap
+		for (i=0; i<supportRateNum; i++) {
+			if (psta->bssrateset[i])
+				tx_ra_bitmap |= rtw_get_bit_value_from_ieee_value(psta->bssrateset[i]&0x7f);
+		}
+
+		if ( pcur_network->Configuration.DSConfig > 14 ) {
+			//force to A mode. 5G doesn't support CCK rates
+			network_type = WIRELESS_11A;
+			tx_ra_bitmap = 0x150; // 6, 12, 24 Mbps
+		} else {
+			//force to b mode
+			network_type = WIRELESS_11B;
+			tx_ra_bitmap = 0xf;
+		}
+
+		//tx_ra_bitmap = update_basic_rate(pcur_network->SupportedRates, supportRateNum);
+
+		//raid = networktype_to_raid(network_type);
+		raid = rtw_hal_networktype_to_raid(rtlpriv,network_type);
+
+		init_rate = get_highest_rate_idx(tx_ra_bitmap&0x0fffffff)&0x3f;
+
+		//DBG_871X("Add id %d val %08x to ratr for bmc sta\n", psta->aid, tx_ra_bitmap);
+		//ap mode
+		rtw_set_sta_info(rtlpriv, psta, true);
+
+		//if (pHalData->fw_ractrl == true)
+		{
+			uint8_t	arg[4] = {0};
+
+			//arg[0] = macid
+			//arg[1] = raid
+			//arg[2] = shortGIrate
+			//arg[3] = init_rate
+
+			arg[0] = psta->mac_id;
+			arg[1] = raid;
+			arg[2] = 0;
+			arg[3] = init_rate;
+
+			DBG_871X("%s=> mac_id:%d , raid:%d , bitmap=0x%x\n",
+				__FUNCTION__ , psta->mac_id, raid , tx_ra_bitmap);
+
+			rtlpriv->cfg->ops->Add_RateATid(rtlpriv, tx_ra_bitmap, arg, 0);
+		}
+
+		//set ra_id, init_rate
+		psta->raid = raid;
+		psta->init_rate = init_rate;
+
+		rtw_stassoc_hw_rpt(rtlpriv, psta);
+
+		spin_lock_bh(&psta->lock);
+		psta->state = _FW_LINKED;
+		spin_unlock_bh(&psta->lock);
+
+	} else {
+		DBG_871X("add_RATid_bmc_sta error!\n");
+	}
+
+}
+
+//notes:
+//AID: 1~MAX for sta and 0 for bc/mc in ap/adhoc mode
+//MAC_ID = AID+1 for sta in ap/adhoc mode
+//MAC_ID = 1 for bc/mc for sta/ap/adhoc
+//MAC_ID = 0 for bssid for sta/ap/adhoc
+//CAM_ID = //0~3 for default key, cmd_id=macid + 3, macid=aid+1;
+
+void update_sta_info_apmode(struct rtl_priv *rtlpriv, struct sta_info *psta)
+{
+	struct mlme_priv *pmlmepriv = &(rtlpriv->mlmepriv);
+	struct security_priv *psecuritypriv = &rtlpriv->securitypriv;
+	struct mlme_ext_priv	*pmlmeext = &(rtlpriv->mlmeextpriv);
+	struct ht_priv	*phtpriv_ap = &pmlmepriv->htpriv;
+	struct ht_priv	*phtpriv_sta = &psta->htpriv;
+	//set intf_tag to if1
+	//psta->intf_tag = 0;
+
+        DBG_871X("%s\n",__FUNCTION__);
+
+	//psta->mac_id = psta->aid+4;
+	//psta->mac_id = psta->aid+1;//alloc macid when call rtw_alloc_stainfo(),
+		                                       //release macid when call rtw_free_stainfo()
+
+	//ap mode
+	rtw_set_sta_info(rtlpriv, psta, true);
+
+	if (psecuritypriv->dot11AuthAlgrthm == dot11AuthAlgrthm_8021X)
+		psta->ieee8021x_blocked = true;
+	else
+		psta->ieee8021x_blocked = false;
+
+
+	//update sta's cap
+
+	//ERP
+	VCS_update(rtlpriv, psta);
+	//HT related cap
+	if (phtpriv_sta->ht_option) {
+		//check if sta supports rx ampdu
+		phtpriv_sta->ampdu_enable = phtpriv_ap->ampdu_enable;
+
+		//check if sta support s Short GI
+		if ((phtpriv_sta->ht_cap.cap_info & phtpriv_ap->ht_cap.cap_info) & cpu_to_le16(IEEE80211_HT_CAP_SGI_20|IEEE80211_HT_CAP_SGI_40)) {
+			phtpriv_sta->sgi = true;
+		}
+
+		// bwmode
+		if ((phtpriv_sta->ht_cap.cap_info & phtpriv_ap->ht_cap.cap_info) & cpu_to_le16(IEEE80211_HT_CAP_SUP_WIDTH)) {
+			//phtpriv_sta->bwmode = CHANNEL_WIDTH_40;
+			phtpriv_sta->bwmode = pmlmeext->cur_bwmode;
+			phtpriv_sta->ch_offset = pmlmeext->cur_ch_offset;
+		}
+
+		psta->qos_option = true;
+
+	} else {
+		phtpriv_sta->ampdu_enable = false;
+
+		phtpriv_sta->sgi = false;
+		phtpriv_sta->bwmode = CHANNEL_WIDTH_20;
+		phtpriv_sta->ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
+	}
+
+	//Rx AMPDU
+	send_delba(rtlpriv, 0, psta->hwaddr);// recipient
+
+	//TX AMPDU
+	send_delba(rtlpriv, 1, psta->hwaddr);// // originator
+	phtpriv_sta->agg_enable_bitmap = 0x0;//reset
+	phtpriv_sta->candidate_tid_bitmap = 0x0;//reset
+
+	update_sta_vht_info_apmode(rtlpriv, psta);
+
+	//todo: init other variables
+
+	memset((void*)&psta->sta_stats, 0, sizeof(struct stainfo_stats));
+
+
+	//add ratid
+	//add_RATid(rtlpriv, psta);//move to ap_sta_info_defer_update()
+
+
+	spin_lock_bh(&psta->lock);
+	psta->state |= _FW_LINKED;
+	spin_unlock_bh(&psta->lock);
+
+
+}
+
+static void update_hw_ht_param(struct rtl_priv *rtlpriv)
+{
+	unsigned char		max_AMPDU_len;
+	unsigned char		min_MPDU_spacing;
+	struct registry_priv	 *pregpriv = &rtlpriv->registrypriv;
+	struct mlme_ext_priv	*pmlmeext = &rtlpriv->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	DBG_871X("%s\n", __FUNCTION__);
+
+
+	//handle A-MPDU parameter field
+	/*
+		AMPDU_para [1:0]:Max AMPDU Len => 0:8k , 1:16k, 2:32k, 3:64k
+		AMPDU_para [4:2]:Min MPDU Start Spacing
+	*/
+	max_AMPDU_len = pmlmeinfo->HT_caps.u.HT_cap_element.AMPDU_para & 0x03;
+
+	min_MPDU_spacing = (pmlmeinfo->HT_caps.u.HT_cap_element.AMPDU_para & 0x1c) >> 2;
+
+	rtlpriv->cfg->ops->set_hw_reg(rtlpriv, HW_VAR_AMPDU_MIN_SPACE, (uint8_t *)(&min_MPDU_spacing));
+
+	rtlpriv->cfg->ops->set_hw_reg(rtlpriv, HW_VAR_AMPDU_FACTOR, (uint8_t *)(&max_AMPDU_len));
+
+	//
+	// Config SM Power Save setting
+	//
+	pmlmeinfo->SM_PS = (pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info & 0x0C) >> 2;
+	if (pmlmeinfo->SM_PS == WLAN_HT_CAP_SM_PS_STATIC) {
+		/*uint8_t i;
+		//update the MCS rates
+		for (i = 0; i < 16; i++)
+		{
+			pmlmeinfo->HT_caps.HT_cap_element.MCS_rate[i] &= MCS_rate_1R[i];
+		}*/
+		DBG_871X("%s(): WLAN_HT_CAP_SM_PS_STATIC\n",__FUNCTION__);
+	}
+
+	//
+	// Config current HT Protection mode.
+	//
+	//pmlmeinfo->HT_protection = pmlmeinfo->HT_info.infos[1] & 0x3;
+
+}
+
+static void start_bss_network(struct rtl_priv *rtlpriv, uint8_t *pbuf)
+{
+	uint8_t *p;
+	uint8_t val8, cur_channel, cur_bwmode, cur_ch_offset;
+	u16 bcn_interval;
+	uint32_t	acparm;
+	int	ie_len;
+	struct registry_priv	 *pregpriv = &rtlpriv->registrypriv;
+	struct mlme_priv *pmlmepriv = &(rtlpriv->mlmepriv);
+	struct security_priv* psecuritypriv= &(rtlpriv->securitypriv);
+	WLAN_BSSID_EX *pnetwork = (WLAN_BSSID_EX *)&pmlmepriv->cur_network.network;
+	struct mlme_ext_priv	*pmlmeext = &(rtlpriv->mlmeextpriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	WLAN_BSSID_EX *pnetwork_mlmeext = &(pmlmeinfo->network);
+	struct HT_info_element *pht_info=NULL;
+	uint8_t	cbw40_enable=0;
+	uint8_t	change_band = false;
+
+	//DBG_871X("%s\n", __FUNCTION__);
+
+	bcn_interval = (u16)pnetwork->Configuration.BeaconPeriod;
+	cur_channel = pnetwork->Configuration.DSConfig;
+	cur_bwmode = CHANNEL_WIDTH_20;
+	cur_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
+
+
+	//check if there is wps ie,
+	//if there is wpsie in beacon, the hostapd will update beacon twice when stating hostapd,
+	//and at first time the security ie ( RSN/WPA IE) will not include in beacon.
+	if (NULL == rtw_get_wps_ie(pnetwork->IEs+_FIXED_IE_LENGTH_, pnetwork->IELength-_FIXED_IE_LENGTH_, NULL, NULL))
+	{
+		pmlmeext->bstart_bss = true;
+	}
+
+	//todo: update wmm, ht cap
+	//pmlmeinfo->WMM_enable;
+	//pmlmeinfo->HT_enable;
+	if (pmlmepriv->qospriv.qos_option)
+		pmlmeinfo->WMM_enable = true;
+	if (pmlmepriv->htpriv.ht_option) {
+		pmlmeinfo->WMM_enable = true;
+		pmlmeinfo->HT_enable = true;
+		//pmlmeinfo->HT_info_enable = true;
+		//pmlmeinfo->HT_caps_enable = true;
+
+		update_hw_ht_param(rtlpriv);
+	}
+
+	if (pmlmepriv->vhtpriv.vht_option) {
+		pmlmeinfo->VHT_enable = true;
+		update_hw_vht_param(rtlpriv);
+	}
+
+	if (pmlmepriv->cur_network.join_res != true) { //setting only at  first time
+		//WEP Key will be set before this function, do not clear CAM.
+		if ((psecuritypriv->dot11PrivacyAlgrthm != WEP40_ENCRYPTION) && (psecuritypriv->dot11PrivacyAlgrthm != WEP104_ENCRYPTION))
+			flush_all_cam_entry(rtlpriv);	//clear CAM
+	}
+
+	//set MSR to AP_Mode
+	Set_MSR(rtlpriv, _HW_STATE_AP_);
+
+	//Set BSSID REG
+	rtlpriv->cfg->ops->set_hw_reg(rtlpriv, HW_VAR_BSSID, pnetwork->MacAddress);
+
+	//Set EDCA param reg
+	acparm = 0x002F3217; // VO
+	rtlpriv->cfg->ops->set_hw_reg(rtlpriv, HW_VAR_AC_PARAM_VO, (uint8_t *)(&acparm));
+	acparm = 0x005E4317; // VI
+	rtlpriv->cfg->ops->set_hw_reg(rtlpriv, HW_VAR_AC_PARAM_VI, (uint8_t *)(&acparm));
+	//acparm = 0x00105320; // BE
+	acparm = 0x005ea42b;
+	rtlpriv->cfg->ops->set_hw_reg(rtlpriv, HW_VAR_AC_PARAM_BE, (uint8_t *)(&acparm));
+	acparm = 0x0000A444; // BK
+	rtlpriv->cfg->ops->set_hw_reg(rtlpriv, HW_VAR_AC_PARAM_BK, (uint8_t *)(&acparm));
+
+	//Set Security
+	val8 = (psecuritypriv->dot11AuthAlgrthm == dot11AuthAlgrthm_8021X)? 0xcc: 0xcf;
+	rtlpriv->cfg->ops->set_hw_reg(rtlpriv, HW_VAR_SEC_CFG, (uint8_t *)(&val8));
+
+	//Beacon Control related register
+	rtlpriv->cfg->ops->set_hw_reg(rtlpriv, HW_VAR_BEACON_INTERVAL, (uint8_t *)(&bcn_interval));
+
+	if (pmlmepriv->cur_network.join_res != true) { //setting only at  first time
+		//uint32_t	 initialgain;
+
+		//initialgain = 0x1e;
+
+
+		//disable dynamic functions, such as high power, DIG
+		//Save_DM_Func_Flag(rtlpriv);
+		//Switch_DM_Func(rtlpriv, DYNAMIC_FUNC_DISABLE, false);
+
+			{
+
+			//rtlpriv->cfg->ops->set_hw_reg(rtlpriv, HW_VAR_INITIAL_GAIN, (uint8_t *)(&initialgain));
+		}
+
+	}
+	//set channel, bwmode
+	p = rtw_get_ie((pnetwork->IEs + sizeof(NDIS_802_11_FIXED_IEs)), _HT_ADD_INFO_IE_, &ie_len, (pnetwork->IELength - sizeof(NDIS_802_11_FIXED_IEs)));
+	if ( p && ie_len) {
+		pht_info = (struct HT_info_element *)(p+2);
+
+		if (cur_channel > 14) {
+			if ((0x21 & 0xf0) > 0)
+				cbw40_enable = 1;
+		} else {
+			if ((0x21 & 0x0f) > 0)
+				cbw40_enable = 1;
+		}
+
+		if ((cbw40_enable) && (pht_info->infos[0] & BIT(2))) {
+			//switch to the 40M Hz mode
+			//pmlmeext->cur_bwmode = CHANNEL_WIDTH_40;
+			cur_bwmode = CHANNEL_WIDTH_40;
+			switch (pht_info->infos[0] & 0x3) {
+			case 1:
+				//pmlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_LOWER;
+				cur_ch_offset = HAL_PRIME_CHNL_OFFSET_LOWER;
+				break;
+
+			case 3:
+				//pmlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_UPPER;
+				cur_ch_offset = HAL_PRIME_CHNL_OFFSET_UPPER;
+				break;
+
+			default:
+				//pmlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
+				cur_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
+				break;
+			}
+
+		}
+
+	}
+
+	p = rtw_get_ie((pnetwork->IEs + sizeof(NDIS_802_11_FIXED_IEs)), EID_VHTOperation, &ie_len, (pnetwork->IELength - sizeof(NDIS_802_11_FIXED_IEs)));
+	if ( p && ie_len) {
+		if (GET_VHT_OPERATION_ELE_CHL_WIDTH(p+2) >= 1) {
+			cur_bwmode = CHANNEL_WIDTH_80;
+		}
+	}
+
+	//TODO: need to judge the phy parameters on concurrent mode for single phy
+	//set_channel_bwmode(rtlpriv, pmlmeext->cur_channel, pmlmeext->cur_ch_offset, pmlmeext->cur_bwmode);
+	set_channel_bwmode(rtlpriv, cur_channel, cur_ch_offset, cur_bwmode);
+
+	DBG_871X("CH=%d, BW=%d, offset=%d\n", cur_channel, cur_bwmode, cur_ch_offset);
+
+	pmlmeext->cur_channel = cur_channel;
+	pmlmeext->cur_bwmode = cur_bwmode;
+	pmlmeext->cur_ch_offset = cur_ch_offset;
+
+	//buddy interface band is different from current interface, update ERP, support rate, ext support rate IE
+	if (change_band == true)
+		change_band_update_ie(rtlpriv, pnetwork);
+
+	pmlmeext->cur_wireless_mode = pmlmepriv->cur_network.network_type;
+
+	//update cur_wireless_mode
+	update_wireless_mode(rtlpriv);
+
+	//update RRSR after set channel and bandwidth
+	UpdateBrateTbl(rtlpriv, pnetwork->SupportedRates);
+	rtlpriv->cfg->ops->set_hw_reg(rtlpriv, HW_VAR_BASIC_RATE, pnetwork->SupportedRates);
+
+	//udpate capability after cur_wireless_mode updated
+	update_capinfo(rtlpriv, rtw_get_capability((WLAN_BSSID_EX *)pnetwork));
+
+	//let pnetwork_mlmeext == pnetwork_mlme.
+	memcpy(pnetwork_mlmeext, pnetwork, pnetwork->Length);
+
+	if (true == pmlmeext->bstart_bss) {
+		update_beacon(rtlpriv, _TIM_IE_, NULL, false);
+
+		//issue beacon frame
+		if (send_beacon(rtlpriv) == _FAIL)
+		{
+			DBG_871X("issue_beacon, fail!\n");
+		}
+
+	}
+
+
+	//update bc/mc sta_info
+	update_bmc_sta(rtlpriv);
+
+	//pmlmeext->bstart_bss = true;
+
+}
+
+int rtw_check_beacon_data(struct rtl_priv *rtlpriv, uint8_t *pbuf,  int len)
+{
+	int ret=_SUCCESS;
+	uint8_t *p;
+	uint8_t *pHT_caps_ie=NULL;
+	uint8_t *pHT_info_ie=NULL;
+	struct sta_info *psta = NULL;
+	u16 cap, ht_cap=false;
+	uint ie_len = 0;
+	int group_cipher, pairwise_cipher;
+	uint8_t	channel, network_type, supportRate[NDIS_802_11_LENGTH_RATES_EX];
+	int supportRateNum = 0;
+	uint8_t OUI1[] = {0x00, 0x50, 0xf2,0x01};
+	uint8_t wps_oui[4]={0x0,0x50,0xf2,0x04};
+	uint8_t WMM_PARA_IE[] = {0x00, 0x50, 0xf2, 0x02, 0x01, 0x01};
+	struct registry_priv *pregistrypriv = &rtlpriv->registrypriv;
+	struct security_priv *psecuritypriv = &rtlpriv->securitypriv;
+	struct mlme_priv *pmlmepriv = &(rtlpriv->mlmepriv);
+	WLAN_BSSID_EX *pbss_network = (WLAN_BSSID_EX *)&pmlmepriv->cur_network.network;
+	struct sta_priv *pstapriv = &rtlpriv->stapriv;
+	uint8_t *ie = pbss_network->IEs;
+
+
+	/* SSID */
+	/* Supported rates */
+	/* DS Params */
+	/* WLAN_EID_COUNTRY */
+	/* ERP Information element */
+	/* Extended supported rates */
+	/* WPA/WPA2 */
+	/* Wi-Fi Wireless Multimedia Extensions */
+	/* ht_capab, ht_oper */
+	/* WPS IE */
+
+	DBG_871X("%s, len=%d\n", __FUNCTION__, len);
+
+	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) != true)
+		return _FAIL;
+
+
+	if (len>MAX_IE_SZ)
+		return _FAIL;
+
+	pbss_network->IELength = len;
+
+	memset(ie, 0, MAX_IE_SZ);
+
+	memcpy(ie, pbuf, pbss_network->IELength);
+
+
+	if (pbss_network->InfrastructureMode!=Ndis802_11APMode)
+		return _FAIL;
+
+	pbss_network->Rssi = 0;
+
+	memcpy(pbss_network->MacAddress, rtlpriv->mac80211.mac_addr, ETH_ALEN);
+
+	//beacon interval
+	p = rtw_get_beacon_interval_from_ie(ie);//ie + 8;	// 8: TimeStamp, 2: Beacon Interval 2:Capability
+	//pbss_network->Configuration.BeaconPeriod = le16_to_cpu(*(unsigned short*)p);
+	pbss_network->Configuration.BeaconPeriod = RTW_GET_LE16(p);
+
+	//capability
+	//cap = *(unsigned short *)rtw_get_capability_from_ie(ie);
+	//cap = le16_to_cpu(cap);
+	cap = RTW_GET_LE16(ie);
+
+	//SSID
+	p = rtw_get_ie(ie + _BEACON_IE_OFFSET_, _SSID_IE_, &ie_len, (pbss_network->IELength -_BEACON_IE_OFFSET_));
+	if (p && ie_len>0) {
+		memset(&pbss_network->Ssid, 0, sizeof(NDIS_802_11_SSID));
+		memcpy(pbss_network->Ssid.Ssid, (p + 2), ie_len);
+		pbss_network->Ssid.SsidLength = ie_len;
+	}
+
+	//chnnel
+	channel = 0;
+	pbss_network->Configuration.Length = 0;
+	p = rtw_get_ie(ie + _BEACON_IE_OFFSET_, _DSSET_IE_, &ie_len, (pbss_network->IELength - _BEACON_IE_OFFSET_));
+	if (p && ie_len>0)
+		channel = *(p + 2);
+
+	pbss_network->Configuration.DSConfig = channel;
+
+
+	memset(supportRate, 0, NDIS_802_11_LENGTH_RATES_EX);
+	// get supported rates
+	p = rtw_get_ie(ie + _BEACON_IE_OFFSET_, _SUPPORTEDRATES_IE_, &ie_len, (pbss_network->IELength - _BEACON_IE_OFFSET_));
+	if (p !=  NULL) {
+		memcpy(supportRate, p+2, ie_len);
+		supportRateNum = ie_len;
+	}
+
+	//get ext_supported rates
+	p = rtw_get_ie(ie + _BEACON_IE_OFFSET_, _EXT_SUPPORTEDRATES_IE_, &ie_len, pbss_network->IELength - _BEACON_IE_OFFSET_);
+	if (p !=  NULL) {
+		memcpy(supportRate+supportRateNum, p+2, ie_len);
+		supportRateNum += ie_len;
+
+	}
+
+	network_type = rtw_check_network_type(supportRate, supportRateNum, channel);
+
+	rtw_set_supported_rate(pbss_network->SupportedRates, network_type);
+
+
+	//parsing ERP_IE
+	p = rtw_get_ie(ie + _BEACON_IE_OFFSET_, _ERPINFO_IE_, &ie_len, (pbss_network->IELength - _BEACON_IE_OFFSET_));
+	if (p && ie_len>0) {
+		ERP_IE_handler(rtlpriv, (PNDIS_802_11_VARIABLE_IEs)p);
+	}
+
+	//update privacy/security
+	if (cap & BIT(4))
+		pbss_network->Privacy = 1;
+	else
+		pbss_network->Privacy = 0;
+
+	psecuritypriv->wpa_psk = 0;
+
+	//wpa2
+	group_cipher = 0; pairwise_cipher = 0;
+	psecuritypriv->wpa2_group_cipher = NO_ENCRYPTION;
+	psecuritypriv->wpa2_pairwise_cipher = NO_ENCRYPTION;
+	p = rtw_get_ie(ie + _BEACON_IE_OFFSET_, _RSN_IE_2_, &ie_len, (pbss_network->IELength - _BEACON_IE_OFFSET_));
+	if (p && ie_len>0) {
+		if (rtw_parse_wpa2_ie(p, ie_len+2, &group_cipher, &pairwise_cipher, NULL) == _SUCCESS) {
+			psecuritypriv->dot11AuthAlgrthm= dot11AuthAlgrthm_8021X;
+
+			psecuritypriv->dot8021xalg = 1;//psk,  todo:802.1x
+			psecuritypriv->wpa_psk |= BIT(1);
+
+			psecuritypriv->wpa2_group_cipher = group_cipher;
+			psecuritypriv->wpa2_pairwise_cipher = pairwise_cipher;
+		}
+
+	}
+
+	//wpa
+	ie_len = 0;
+	group_cipher = 0; pairwise_cipher = 0;
+	psecuritypriv->wpa_group_cipher = NO_ENCRYPTION;
+	psecuritypriv->wpa_pairwise_cipher = NO_ENCRYPTION;
+	for (p = ie + _BEACON_IE_OFFSET_; ;p += (ie_len + 2)) {
+		p = rtw_get_ie(p, _SSN_IE_1_, &ie_len, (pbss_network->IELength - _BEACON_IE_OFFSET_ - (ie_len + 2)));
+		if ((p) && (_rtw_memcmp(p+2, OUI1, 4))) {
+			if (rtw_parse_wpa_ie(p, ie_len+2, &group_cipher, &pairwise_cipher, NULL) == _SUCCESS) {
+				psecuritypriv->dot11AuthAlgrthm= dot11AuthAlgrthm_8021X;
+
+				psecuritypriv->dot8021xalg = 1;//psk,  todo:802.1x
+
+				psecuritypriv->wpa_psk |= BIT(0);
+
+				psecuritypriv->wpa_group_cipher = group_cipher;
+				psecuritypriv->wpa_pairwise_cipher = pairwise_cipher;
+			}
+
+			break;
+
+		}
+
+		if ((p == NULL) || (ie_len == 0)) {
+				break;
+		}
+
+	}
+
+	//wmm
+	ie_len = 0;
+	pmlmepriv->qospriv.qos_option = 0;
+	if (pregistrypriv->wmm_enable) {
+		for (p = ie + _BEACON_IE_OFFSET_; ;p += (ie_len + 2)) {
+			p = rtw_get_ie(p, _VENDOR_SPECIFIC_IE_, &ie_len, (pbss_network->IELength - _BEACON_IE_OFFSET_ - (ie_len + 2)));
+			if ((p) && _rtw_memcmp(p+2, WMM_PARA_IE, 6)) {
+				pmlmepriv->qospriv.qos_option = 1;
+
+				*(p+8) |= BIT(7);//QoS Info, support U-APSD
+
+				/* disable all ACM bits since the WMM admission control is not supported */
+				*(p + 10) &= ~BIT(4); /* BE */
+				*(p + 14) &= ~BIT(4); /* BK */
+				*(p + 18) &= ~BIT(4); /* VI */
+				*(p + 22) &= ~BIT(4); /* VO */
+
+				break;
+			}
+
+			if ((p == NULL) || (ie_len == 0)) {
+				break;
+			}
+		}
+	}
+	//parsing HT_CAP_IE
+	p = rtw_get_ie(ie + _BEACON_IE_OFFSET_, _HT_CAPABILITY_IE_, &ie_len, (pbss_network->IELength - _BEACON_IE_OFFSET_));
+	if (p && ie_len>0) {
+		uint8_t rf_type;
+
+		struct rtw_ieee80211_ht_cap *pht_cap = (struct rtw_ieee80211_ht_cap *)(p+2);
+
+		pHT_caps_ie=p;
+
+
+		ht_cap = true;
+		network_type |= WIRELESS_11_24N;
+
+		rf_type = rtlpriv->phy.rf_type;
+
+		if ((psecuritypriv->wpa_pairwise_cipher & WPA_CIPHER_CCMP) ||
+			(psecuritypriv->wpa2_pairwise_cipher & WPA_CIPHER_CCMP)) {
+			pht_cap->ampdu_params_info |= (IEEE80211_HT_CAP_AMPDU_DENSITY&(0x07<<2));
+		} else 	{
+			pht_cap->ampdu_params_info |= (IEEE80211_HT_CAP_AMPDU_DENSITY&0x00);
+		}
+
+		pht_cap->ampdu_params_info |= (IEEE80211_HT_CAP_AMPDU_FACTOR & 0x03); //set  Max Rx AMPDU size  to 64K
+
+		if (rf_type == RF_1T1R) {
+			pht_cap->supp_mcs_set[0] = 0xff;
+			pht_cap->supp_mcs_set[1] = 0x0;
+		}
+
+		memcpy(&pmlmepriv->htpriv.ht_cap, p+2, ie_len);
+
+	}
+
+	//parsing HT_INFO_IE
+	p = rtw_get_ie(ie + _BEACON_IE_OFFSET_, _HT_ADD_INFO_IE_, &ie_len, (pbss_network->IELength - _BEACON_IE_OFFSET_));
+	if (p && ie_len>0) {
+		pHT_info_ie=p;
+	}
+	switch(network_type) {
+	case WIRELESS_11B:
+		pbss_network->NetworkTypeInUse = Ndis802_11DS;
+		break;
+	case WIRELESS_11G:
+	case WIRELESS_11BG:
+	case WIRELESS_11G_24N:
+	case WIRELESS_11BG_24N:
+		pbss_network->NetworkTypeInUse = Ndis802_11OFDM24;
+		break;
+	case WIRELESS_11A:
+		pbss_network->NetworkTypeInUse = Ndis802_11OFDM5;
+		break;
+	default :
+		pbss_network->NetworkTypeInUse = Ndis802_11OFDM24;
+	break;
+	}
+
+	pmlmepriv->cur_network.network_type = network_type;
+
+	pmlmepriv->htpriv.ht_option = false;
+
+	if ( (psecuritypriv->wpa2_pairwise_cipher&WPA_CIPHER_TKIP) ||
+		      (psecuritypriv->wpa_pairwise_cipher&WPA_CIPHER_TKIP)) {
+		//todo:
+		//ht_cap = false;
+	}
+
+	//ht_cap
+	if (ht_cap == true) {
+		pmlmepriv->htpriv.ht_option = true;
+		pmlmepriv->qospriv.qos_option = 1;
+
+		pmlmepriv->htpriv.ampdu_enable = true;
+
+		HT_caps_handler(rtlpriv, (PNDIS_802_11_VARIABLE_IEs)pHT_caps_ie);
+
+		HT_info_handler(rtlpriv, (PNDIS_802_11_VARIABLE_IEs)pHT_info_ie);
+	}
+	pbss_network->Length = get_WLAN_BSSID_EX_sz((WLAN_BSSID_EX  *)pbss_network);
+
+	//issue beacon to start bss network
+	start_bss_network(rtlpriv, (uint8_t *)pbss_network);
+
+
+	//alloc sta_info for ap itself
+	psta = rtw_get_stainfo(&rtlpriv->stapriv, pbss_network->MacAddress);
+	if (!psta) {
+		psta = rtw_alloc_stainfo(&rtlpriv->stapriv, pbss_network->MacAddress);
+		if (psta == NULL) {
+			return _FAIL;
+		}
+	}
+	psta->state |= WIFI_AP_STATE;		//Aries, add,fix bug of flush_cam_entry at STOP AP mode , 0724
+	rtw_indicate_connect( rtlpriv);
+
+	pmlmepriv->cur_network.join_res = true;//for check if already set beacon
+
+	//update bc/mc sta_info
+	//update_bmc_sta(rtlpriv);
+
+	return ret;
+
+}
+
+void rtw_set_macaddr_acl(struct rtl_priv *rtlpriv, int mode)
+{
+	struct sta_priv *pstapriv = &rtlpriv->stapriv;
+	struct wlan_acl_pool *pacl_list = &pstapriv->acl_list;
+
+	DBG_871X("%s, mode=%d\n", __func__, mode);
+
+	pacl_list->mode = mode;
+}
+
+int rtw_acl_add_sta(struct rtl_priv *rtlpriv, uint8_t *addr)
+{
+	struct list_head	*plist, *phead;
+	uint8_t added = false;
+	int i, ret=0;
+	struct rtw_wlan_acl_node *paclnode;
+	struct sta_priv *pstapriv = &rtlpriv->stapriv;
+	struct wlan_acl_pool *pacl_list = &pstapriv->acl_list;
+	struct __queue	*pacl_node_q = &pacl_list->acl_node_q;
+
+	DBG_871X("%s(acl_num=%d)=" MAC_FMT "\n", __func__, pacl_list->num, MAC_ARG(addr));
+
+	if ((NUM_ACL-1) < pacl_list->num)
+		return (-1);
+
+	spin_lock_bh(&(pacl_node_q->lock));
+
+	phead = get_list_head(pacl_node_q);
+	plist = get_next(phead);
+
+	while ((rtw_end_of_queue_search(phead, plist)) == false) {
+		paclnode = container_of(plist, struct rtw_wlan_acl_node, list);
+		plist = get_next(plist);
+
+		if (_rtw_memcmp(paclnode->addr, addr, ETH_ALEN)) {
+			if (paclnode->valid == true) {
+				added = true;
+				DBG_871X("%s, sta has been added\n", __func__);
+				break;
+			}
+		}
+	}
+
+	spin_unlock_bh(&(pacl_node_q->lock));
+
+
+	if (added == true)
+		return ret;
+
+
+	spin_lock_bh(&(pacl_node_q->lock));
+
+	for(i=0; i< NUM_ACL; i++) {
+		paclnode = &pacl_list->aclnode[i];
+
+		if (paclnode->valid == false) {
+			INIT_LIST_HEAD(&paclnode->list);
+
+			memcpy(paclnode->addr, addr, ETH_ALEN);
+
+			paclnode->valid = true;
+
+			list_add_tail(&paclnode->list, get_list_head(pacl_node_q));
+
+			pacl_list->num++;
+
+			break;
+		}
+	}
+
+	DBG_871X("%s, acl_num=%d\n", __func__, pacl_list->num);
+
+	spin_unlock_bh(&(pacl_node_q->lock));
+
+	return ret;
+}
+
+int rtw_acl_remove_sta(struct rtl_priv *rtlpriv, uint8_t *addr)
+{
+	struct list_head	*plist, *phead;
+	int i, ret=0;
+	struct rtw_wlan_acl_node *paclnode;
+	struct sta_priv *pstapriv = &rtlpriv->stapriv;
+	struct wlan_acl_pool *pacl_list = &pstapriv->acl_list;
+	struct __queue	*pacl_node_q = &pacl_list->acl_node_q;
+
+	DBG_871X("%s(acl_num=%d)=" MAC_FMT "\n", __func__, pacl_list->num, MAC_ARG(addr));
+
+	spin_lock_bh(&(pacl_node_q->lock));
+
+	phead = get_list_head(pacl_node_q);
+	plist = get_next(phead);
+
+	while ((rtw_end_of_queue_search(phead, plist)) == false) {
+		paclnode = container_of(plist, struct rtw_wlan_acl_node, list);
+		plist = get_next(plist);
+
+		if (_rtw_memcmp(paclnode->addr, addr, ETH_ALEN)) {
+			if (paclnode->valid == true) {
+				paclnode->valid = false;
+
+				list_del_init(&paclnode->list);
+
+				pacl_list->num--;
+			}
+		}
+	}
+
+	spin_unlock_bh(&(pacl_node_q->lock));
+
+	DBG_871X("%s, acl_num=%d\n", __func__, pacl_list->num);
+
+	return ret;
+
+}
+
+uint8_t rtw_ap_set_pairwise_key(struct rtl_priv *rtlpriv, struct sta_info *psta)
+{
+	struct cmd_obj*			ph2c;
+	struct set_stakey_parm	*psetstakey_para;
+	struct cmd_priv 			*pcmdpriv= &rtlpriv->cmdpriv;
+	uint8_t	res=_SUCCESS;
+
+	ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
+	if ( ph2c == NULL) {
+		res= _FAIL;
+		goto exit;
+	}
+
+	psetstakey_para = (struct set_stakey_parm*)rtw_zmalloc(sizeof(struct set_stakey_parm));
+	if (psetstakey_para == NULL) {
+		rtw_mfree(ph2c);
+		res=_FAIL;
+		goto exit;
+	}
+
+	init_h2fwcmd_w_parm_no_rsp(ph2c, psetstakey_para, _SetStaKey_CMD_);
+
+
+	psetstakey_para->algorithm = (uint8_t)psta->dot118021XPrivacy;
+
+	memcpy(psetstakey_para->addr, psta->hwaddr, ETH_ALEN);
+
+	memcpy(psetstakey_para->key, &psta->dot118021x_UncstKey, 16);
+
+
+	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
+
+exit:
+
+	return res;
+
+}
+
+static int rtw_ap_set_key(struct rtl_priv *rtlpriv, uint8_t *key, uint8_t alg, int keyid, uint8_t set_tx)
+{
+	uint8_t keylen;
+	struct cmd_obj* pcmd;
+	struct setkey_parm *psetkeyparm;
+	struct cmd_priv	*pcmdpriv= &(rtlpriv->cmdpriv);
+	int res=_SUCCESS;
+
+	//DBG_871X("%s\n", __FUNCTION__);
+
+	pcmd = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
+	if (pcmd == NULL) {
+		res= _FAIL;
+		goto exit;
+	}
+	psetkeyparm=(struct setkey_parm*)rtw_zmalloc(sizeof(struct setkey_parm));
+	if (psetkeyparm == NULL) {
+		rtw_mfree(pcmd);
+		res= _FAIL;
+		goto exit;
+	}
+
+	memset(psetkeyparm, 0, sizeof(struct setkey_parm));
+
+	psetkeyparm->keyid=(uint8_t)keyid;
+	if (is_wep_enc(alg))
+		rtlpriv->mlmepriv.key_mask |= BIT(psetkeyparm->keyid);
+
+	psetkeyparm->algorithm = alg;
+
+	psetkeyparm->set_tx = set_tx;
+
+	switch(alg) {
+	case WEP40_ENCRYPTION:
+		keylen = 5;
+		break;
+	case WEP104_ENCRYPTION:
+		keylen = 13;
+		break;
+	case TKIP_ENCRYPTION:
+	case RSERVED_ENCRYPTION:
+	case AESCCMP_ENCRYPTION:
+		keylen = 16;
+	default:
+		keylen = 16;
+	}
+
+	memcpy(&(psetkeyparm->key[0]), key, keylen);
+
+	pcmd->cmdcode = _SetKey_CMD_;
+	pcmd->parmbuf = (uint8_t *)psetkeyparm;
+	pcmd->cmdsz =  (sizeof(struct setkey_parm));
+	pcmd->rsp = NULL;
+	pcmd->rspsz = 0;
+
+
+	INIT_LIST_HEAD(&pcmd->list);
+
+	res = rtw_enqueue_cmd(pcmdpriv, pcmd);
+
+exit:
+
+	return res;
+}
+
+int rtw_ap_set_group_key(struct rtl_priv *rtlpriv, uint8_t *key, uint8_t alg, int keyid)
+{
+	DBG_871X("%s\n", __FUNCTION__);
+
+	return rtw_ap_set_key(rtlpriv, key, alg, keyid, 1);
+}
+
+int rtw_ap_set_wep_key(struct rtl_priv *rtlpriv, uint8_t *key, uint8_t keylen, int keyid, uint8_t set_tx)
+{
+	uint8_t alg;
+
+	switch(keylen) {
+	case 5:
+		alg =WEP40_ENCRYPTION;
+		break;
+	case 13:
+		alg =WEP104_ENCRYPTION;
+		break;
+	default:
+		alg =NO_ENCRYPTION;
+	}
+
+	DBG_871X("%s\n", __FUNCTION__);
+
+	return rtw_ap_set_key(rtlpriv, key, alg, keyid, set_tx);
+}
+
+static void update_bcn_erpinfo_ie(struct rtl_priv *rtlpriv)
+{
+	struct mlme_priv *pmlmepriv = &(rtlpriv->mlmepriv);
+	struct mlme_ext_priv	*pmlmeext = &(rtlpriv->mlmeextpriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	WLAN_BSSID_EX *pnetwork = &(pmlmeinfo->network);
+	unsigned char *p, *ie = pnetwork->IEs;
+	uint32_t	 len = 0;
+
+	DBG_871X("%s, ERP_enable=%d\n", __FUNCTION__, pmlmeinfo->ERP_enable);
+
+	if (!pmlmeinfo->ERP_enable)
+		return;
+
+	//parsing ERP_IE
+	p = rtw_get_ie(ie + _BEACON_IE_OFFSET_, _ERPINFO_IE_, &len, (pnetwork->IELength - _BEACON_IE_OFFSET_));
+	if (p && len>0) {
+		PNDIS_802_11_VARIABLE_IEs pIE = (PNDIS_802_11_VARIABLE_IEs)p;
+
+		if (pmlmepriv->num_sta_non_erp == 1)
+			pIE->data[0] |= RTW_ERP_INFO_NON_ERP_PRESENT|RTW_ERP_INFO_USE_PROTECTION;
+		else
+			pIE->data[0] &= ~(RTW_ERP_INFO_NON_ERP_PRESENT|RTW_ERP_INFO_USE_PROTECTION);
+
+		if (pmlmepriv->num_sta_no_short_preamble > 0)
+			pIE->data[0] |= RTW_ERP_INFO_BARKER_PREAMBLE_MODE;
+		else
+			pIE->data[0] &= ~(RTW_ERP_INFO_BARKER_PREAMBLE_MODE);
+
+		ERP_IE_handler(rtlpriv, pIE);
+	}
+
+}
+
+static void update_bcn_wps_ie(struct rtl_priv *rtlpriv)
+{
+	uint8_t *pwps_ie=NULL, *pwps_ie_src, *premainder_ie, *pbackup_remainder_ie=NULL;
+	uint wps_ielen=0, wps_offset, remainder_ielen;
+	struct mlme_priv *pmlmepriv = &(rtlpriv->mlmepriv);
+	struct mlme_ext_priv	*pmlmeext = &(rtlpriv->mlmeextpriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	WLAN_BSSID_EX *pnetwork = &(pmlmeinfo->network);
+	unsigned char *ie = pnetwork->IEs;
+	uint32_t	 ielen = pnetwork->IELength;
+
+
+	DBG_871X("%s\n", __FUNCTION__);
+
+	pwps_ie = rtw_get_wps_ie(ie+_FIXED_IE_LENGTH_, ielen-_FIXED_IE_LENGTH_, NULL, &wps_ielen);
+
+	if (pwps_ie == NULL || wps_ielen == 0)
+		return;
+
+	wps_offset = (uint)(pwps_ie-ie);
+
+	premainder_ie = pwps_ie + wps_ielen;
+
+	remainder_ielen = ielen - wps_offset - wps_ielen;
+
+	if (remainder_ielen>0) {
+		pbackup_remainder_ie = rtw_malloc(remainder_ielen);
+		if (pbackup_remainder_ie)
+			memcpy(pbackup_remainder_ie, premainder_ie, remainder_ielen);
+	}
+
+
+	pwps_ie_src = pmlmepriv->wps_beacon_ie;
+	if (pwps_ie_src == NULL)
+		return;
+
+
+	wps_ielen = (uint)pwps_ie_src[1];//to get ie data len
+	if ((wps_offset+wps_ielen+2+remainder_ielen)<=MAX_IE_SZ) {
+		memcpy(pwps_ie, pwps_ie_src, wps_ielen+2);
+		pwps_ie += (wps_ielen+2);
+
+		if (pbackup_remainder_ie)
+			memcpy(pwps_ie, pbackup_remainder_ie, remainder_ielen);
+
+		//update IELength
+		pnetwork->IELength = wps_offset + (wps_ielen+2) + remainder_ielen;
+	}
+
+	if (pbackup_remainder_ie) {
+		/* ULLI check usage of remainder_ielen */
+		rtw_mfree(pbackup_remainder_ie);
+	}
+
+}
+
+static void update_bcn_vendor_spec_ie(struct rtl_priv *rtlpriv, uint8_t *oui)
+{
+	DBG_871X("%s\n", __FUNCTION__);
+
+	if (_rtw_memcmp(WPS_OUI, oui, 4)) {
+		update_bcn_wps_ie(rtlpriv);
+	} else {
+		DBG_871X("unknown OUI type!\n");
+ 	}
+
+
+}
+
+void update_beacon(struct rtl_priv *rtlpriv, uint8_t ie_id, uint8_t *oui, uint8_t tx)
+{
+	struct mlme_priv *pmlmepriv;
+	struct mlme_ext_priv	*pmlmeext;
+	//struct mlme_ext_info	*pmlmeinfo;
+
+	//DBG_871X("%s\n", __FUNCTION__);
+
+	if (!rtlpriv)
+		return;
+
+	pmlmepriv = &(rtlpriv->mlmepriv);
+	pmlmeext = &(rtlpriv->mlmeextpriv);
+	//pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	if (false == pmlmeext->bstart_bss)
+		return;
+
+	spin_lock_bh(&pmlmepriv->bcn_update_lock);
+
+	switch(ie_id) {
+	case _TIM_IE_:
+		update_BCNTIM(rtlpriv);
+		break;
+
+	case _ERPINFO_IE_:
+		update_bcn_erpinfo_ie(rtlpriv);
+		break;
+
+	case _VENDOR_SPECIFIC_IE_:
+		update_bcn_vendor_spec_ie(rtlpriv, oui);
+		break;
+
+	default:
+		break;
+	}
+
+	pmlmepriv->update_bcn = true;
+
+	spin_unlock_bh(&pmlmepriv->bcn_update_lock);
+
+	if (tx) {
+		//send_beacon(rtlpriv);//send_beacon must execute on TSR level
+		set_tx_beacon_cmd(rtlpriv);
+	}
+
+}
+
+/*
+op_mode
+Set to 0 (HT pure) under the followign conditions
+	- all STAs in the BSS are 20/40 MHz HT in 20/40 MHz BSS or
+	- all STAs in the BSS are 20 MHz HT in 20 MHz BSS
+Set to 1 (HT non-member protection) if there may be non-HT STAs
+	in both the primary and the secondary channel
+Set to 2 if only HT STAs are associated in BSS,
+	however and at least one 20 MHz HT STA is associated
+Set to 3 (HT mixed mode) when one or more non-HT STAs are associated
+	(currently non-GF HT station is considered as non-HT STA also)
+*/
+static int rtw_ht_operation_update(struct rtl_priv *rtlpriv)
+{
+	u16 cur_op_mode, new_op_mode;
+	int op_mode_changes = 0;
+	struct mlme_priv *pmlmepriv = &(rtlpriv->mlmepriv);
+	struct ht_priv	*phtpriv_ap = &pmlmepriv->htpriv;
+
+	if (pmlmepriv->htpriv.ht_option == true)
+		return 0;
+
+	//if (!iface->conf->ieee80211n || iface->conf->ht_op_mode_fixed)
+	//	return 0;
+
+	DBG_871X("%s current operation mode=0x%X\n",
+		   __FUNCTION__, pmlmepriv->ht_op_mode);
+
+	if (!(pmlmepriv->ht_op_mode & HT_INFO_OPERATION_MODE_NON_GF_DEVS_PRESENT)
+	    && pmlmepriv->num_sta_ht_no_gf) {
+		pmlmepriv->ht_op_mode |=
+			HT_INFO_OPERATION_MODE_NON_GF_DEVS_PRESENT;
+		op_mode_changes++;
+	} else if ((pmlmepriv->ht_op_mode &
+		    HT_INFO_OPERATION_MODE_NON_GF_DEVS_PRESENT) &&
+		   pmlmepriv->num_sta_ht_no_gf == 0) {
+		pmlmepriv->ht_op_mode &=
+			~HT_INFO_OPERATION_MODE_NON_GF_DEVS_PRESENT;
+		op_mode_changes++;
+	}
+
+	if (!(pmlmepriv->ht_op_mode & HT_INFO_OPERATION_MODE_NON_HT_STA_PRESENT) &&
+	    (pmlmepriv->num_sta_no_ht || pmlmepriv->olbc_ht)) {
+		pmlmepriv->ht_op_mode |= HT_INFO_OPERATION_MODE_NON_HT_STA_PRESENT;
+		op_mode_changes++;
+	} else if ((pmlmepriv->ht_op_mode &
+		    HT_INFO_OPERATION_MODE_NON_HT_STA_PRESENT) &&
+		   (pmlmepriv->num_sta_no_ht == 0 && !pmlmepriv->olbc_ht)) {
+		pmlmepriv->ht_op_mode &=
+			~HT_INFO_OPERATION_MODE_NON_HT_STA_PRESENT;
+		op_mode_changes++;
+	}
+
+	/* Note: currently we switch to the MIXED op mode if HT non-greenfield
+	 * station is associated. Probably it's a theoretical case, since
+	 * it looks like all known HT STAs support greenfield.
+	 */
+	new_op_mode = 0;
+	if (pmlmepriv->num_sta_no_ht ||
+	    (pmlmepriv->ht_op_mode & HT_INFO_OPERATION_MODE_NON_GF_DEVS_PRESENT))
+		new_op_mode = OP_MODE_MIXED;
+	else if ((phtpriv_ap->ht_cap.cap_info & IEEE80211_HT_CAP_SUP_WIDTH)
+		 && pmlmepriv->num_sta_ht_20mhz)
+		new_op_mode = OP_MODE_20MHZ_HT_STA_ASSOCED;
+	else if (pmlmepriv->olbc_ht)
+		new_op_mode = OP_MODE_MAY_BE_LEGACY_STAS;
+	else
+		new_op_mode = OP_MODE_PURE;
+
+	cur_op_mode = pmlmepriv->ht_op_mode & HT_INFO_OPERATION_MODE_OP_MODE_MASK;
+	if (cur_op_mode != new_op_mode) {
+		pmlmepriv->ht_op_mode &= ~HT_INFO_OPERATION_MODE_OP_MODE_MASK;
+		pmlmepriv->ht_op_mode |= new_op_mode;
+		op_mode_changes++;
+	}
+
+	DBG_871X("%s new operation mode=0x%X changes=%d\n",
+		   __FUNCTION__, pmlmepriv->ht_op_mode, op_mode_changes);
+
+	return op_mode_changes;
+
+}
+
+void associated_clients_update(struct rtl_priv *rtlpriv, uint8_t updated)
+{
+	//update associcated stations cap.
+	if (updated == true) {
+		struct list_head	*phead, *plist;
+		struct sta_info *psta=NULL;
+		struct sta_priv *pstapriv = &rtlpriv->stapriv;
+
+		spin_lock_bh(&pstapriv->asoc_list_lock);
+
+		phead = &pstapriv->asoc_list;
+		plist = get_next(phead);
+
+		//check asoc_queue
+		while ((rtw_end_of_queue_search(phead, plist)) == false) {
+			psta = container_of(plist, struct sta_info, asoc_list);
+
+			plist = get_next(plist);
+
+			VCS_update(rtlpriv, psta);
+		}
+
+		spin_unlock_bh(&pstapriv->asoc_list_lock);
+
+	}
+
+}
+
+/* called > TSR LEVEL for USB or SDIO Interface*/
+void bss_cap_update_on_sta_join(struct rtl_priv *rtlpriv, struct sta_info *psta)
+{
+	uint8_t beacon_updated = false;
+	struct mlme_priv *pmlmepriv = &(rtlpriv->mlmepriv);
+	struct mlme_ext_priv *pmlmeext = &(rtlpriv->mlmeextpriv);
+
+	if (!(psta->flags & WLAN_STA_SHORT_PREAMBLE)) {
+		if (!psta->no_short_preamble_set) {
+			psta->no_short_preamble_set = 1;
+
+			pmlmepriv->num_sta_no_short_preamble++;
+
+			if ((pmlmeext->cur_wireless_mode > WIRELESS_11B) &&
+		     		(pmlmepriv->num_sta_no_short_preamble == 1)) {
+				beacon_updated = true;
+				update_beacon(rtlpriv, 0xFF, NULL, true);
+			}
+
+		}
+	} else {
+		if (psta->no_short_preamble_set) {
+			psta->no_short_preamble_set = 0;
+
+			pmlmepriv->num_sta_no_short_preamble--;
+
+			if ((pmlmeext->cur_wireless_mode > WIRELESS_11B) &&
+		     		(pmlmepriv->num_sta_no_short_preamble == 0)) {
+				beacon_updated = true;
+				update_beacon(rtlpriv, 0xFF, NULL, true);
+			}
+
+		}
+	}
+
+	if (psta->flags & WLAN_STA_NONERP) {
+		if (!psta->nonerp_set) {
+			psta->nonerp_set = 1;
+
+			pmlmepriv->num_sta_non_erp++;
+
+			if (pmlmepriv->num_sta_non_erp == 1) {
+				beacon_updated = true;
+				update_beacon(rtlpriv, _ERPINFO_IE_, NULL, true);
+			}
+		}
+
+	} else {
+		if (psta->nonerp_set) {
+			psta->nonerp_set = 0;
+
+			pmlmepriv->num_sta_non_erp--;
+
+			if (pmlmepriv->num_sta_non_erp == 0) {
+				beacon_updated = true;
+				update_beacon(rtlpriv, _ERPINFO_IE_, NULL, true);
+			}
+		}
+
+	}
+
+	if (!(psta->capability & WLAN_CAPABILITY_SHORT_SLOT)) {
+		if (!psta->no_short_slot_time_set) {
+			psta->no_short_slot_time_set = 1;
+
+			pmlmepriv->num_sta_no_short_slot_time++;
+
+			if ((pmlmeext->cur_wireless_mode > WIRELESS_11B) &&
+		   		 (pmlmepriv->num_sta_no_short_slot_time == 1)) {
+				beacon_updated = true;
+				update_beacon(rtlpriv, 0xFF, NULL, true);
+			}
+
+		}
+	} else {
+		if (psta->no_short_slot_time_set) {
+			psta->no_short_slot_time_set = 0;
+
+			pmlmepriv->num_sta_no_short_slot_time--;
+
+			if ((pmlmeext->cur_wireless_mode > WIRELESS_11B) &&
+		   		 (pmlmepriv->num_sta_no_short_slot_time == 0)) {
+				beacon_updated = true;
+				update_beacon(rtlpriv, 0xFF, NULL, true);
+			}
+		}
+	}
+
+	if (psta->flags & WLAN_STA_HT) {
+		u16 ht_capab = le16_to_cpu(psta->htpriv.ht_cap.cap_info);
+
+		DBG_871X("HT: STA " MAC_FMT " HT Capabilities "
+			   "Info: 0x%04x\n", MAC_ARG(psta->hwaddr), ht_capab);
+
+		if (psta->no_ht_set) {
+			psta->no_ht_set = 0;
+			pmlmepriv->num_sta_no_ht--;
+		}
+
+		if ((ht_capab & IEEE80211_HT_CAP_GRN_FLD) == 0) {
+			if (!psta->no_ht_gf_set) {
+				psta->no_ht_gf_set = 1;
+				pmlmepriv->num_sta_ht_no_gf++;
+			}
+			DBG_871X("%s STA " MAC_FMT " - no "
+				   "greenfield, num of non-gf stations %d\n",
+				   __FUNCTION__, MAC_ARG(psta->hwaddr),
+				   pmlmepriv->num_sta_ht_no_gf);
+		}
+
+		if ((ht_capab & IEEE80211_HT_CAP_SUP_WIDTH) == 0) {
+			if (!psta->ht_20mhz_set) {
+				psta->ht_20mhz_set = 1;
+				pmlmepriv->num_sta_ht_20mhz++;
+			}
+			DBG_871X("%s STA " MAC_FMT " - 20 MHz HT, "
+				   "num of 20MHz HT STAs %d\n",
+				   __FUNCTION__, MAC_ARG(psta->hwaddr),
+				   pmlmepriv->num_sta_ht_20mhz);
+		}
+
+	} else {
+		if (!psta->no_ht_set) {
+			psta->no_ht_set = 1;
+			pmlmepriv->num_sta_no_ht++;
+		}
+		if (pmlmepriv->htpriv.ht_option == true) {
+			DBG_871X("%s STA " MAC_FMT
+				   " - no HT, num of non-HT stations %d\n",
+				   __FUNCTION__, MAC_ARG(psta->hwaddr),
+				   pmlmepriv->num_sta_no_ht);
+		}
+	}
+
+	if (rtw_ht_operation_update(rtlpriv) > 0) {
+		update_beacon(rtlpriv, _HT_CAPABILITY_IE_, NULL, false);
+		update_beacon(rtlpriv, _HT_ADD_INFO_IE_, NULL, true);
+	}
+
+	//update associcated stations cap.
+	associated_clients_update(rtlpriv,  beacon_updated);
+
+	DBG_871X("%s, updated=%d\n", __func__, beacon_updated);
+
+}
+
+uint8_t bss_cap_update_on_sta_leave(struct rtl_priv *rtlpriv, struct sta_info *psta)
+{
+	uint8_t beacon_updated = false;
+	struct mlme_priv *pmlmepriv = &(rtlpriv->mlmepriv);
+	struct mlme_ext_priv *pmlmeext = &(rtlpriv->mlmeextpriv);
+
+	if (!psta)
+		return beacon_updated;
+
+	if (psta->no_short_preamble_set) {
+		psta->no_short_preamble_set = 0;
+		pmlmepriv->num_sta_no_short_preamble--;
+		if (pmlmeext->cur_wireless_mode > WIRELESS_11B
+		    && pmlmepriv->num_sta_no_short_preamble == 0) {
+			beacon_updated = true;
+			update_beacon(rtlpriv, 0xFF, NULL, true);
+		}
+	}
+
+	if (psta->nonerp_set) {
+		psta->nonerp_set = 0;
+		pmlmepriv->num_sta_non_erp--;
+		if (pmlmepriv->num_sta_non_erp == 0) {
+			beacon_updated = true;
+			update_beacon(rtlpriv, _ERPINFO_IE_, NULL, true);
+		}
+	}
+
+	if (psta->no_short_slot_time_set) {
+		psta->no_short_slot_time_set = 0;
+		pmlmepriv->num_sta_no_short_slot_time--;
+		if (pmlmeext->cur_wireless_mode > WIRELESS_11B
+		    && pmlmepriv->num_sta_no_short_slot_time == 0) {
+			beacon_updated = true;
+			update_beacon(rtlpriv, 0xFF, NULL, true);
+		}
+	}
+
+	if (psta->no_ht_gf_set) {
+		psta->no_ht_gf_set = 0;
+		pmlmepriv->num_sta_ht_no_gf--;
+	}
+
+	if (psta->no_ht_set) {
+		psta->no_ht_set = 0;
+		pmlmepriv->num_sta_no_ht--;
+	}
+
+	if (psta->ht_20mhz_set) {
+		psta->ht_20mhz_set = 0;
+		pmlmepriv->num_sta_ht_20mhz--;
+	}
+
+	if (rtw_ht_operation_update(rtlpriv) > 0)
+	{
+		update_beacon(rtlpriv, _HT_CAPABILITY_IE_, NULL, false);
+		update_beacon(rtlpriv, _HT_ADD_INFO_IE_, NULL, true);
+	}
+
+	//update associcated stations cap.
+	//associated_clients_update(rtlpriv,  beacon_updated); //move it to avoid deadlock
+
+	DBG_871X("%s, updated=%d\n", __func__, beacon_updated);
+
+	return beacon_updated;
+
+}
+
+uint8_t ap_free_sta(struct rtl_priv *rtlpriv, struct sta_info *psta, bool active, u16 reason)
+{
+	uint8_t beacon_updated = false;
+	struct mlme_priv *pmlmepriv = &(rtlpriv->mlmepriv);
+	struct mlme_ext_priv	*pmlmeext = &(rtlpriv->mlmeextpriv);
+	struct sta_priv *pstapriv = &rtlpriv->stapriv;
+
+	if (!psta)
+		return beacon_updated;
+
+	if (active == true) {
+		//tear down Rx AMPDU
+		send_delba(rtlpriv, 0, psta->hwaddr);// recipient
+
+		//tear down TX AMPDU
+		send_delba(rtlpriv, 1, psta->hwaddr);// // originator
+
+		issue_deauth(rtlpriv, psta->hwaddr, reason);
+	}
+
+	psta->htpriv.agg_enable_bitmap = 0x0;//reset
+	psta->htpriv.candidate_tid_bitmap = 0x0;//reset
+
+
+	//report_del_sta_event(rtlpriv, psta->hwaddr, reason);
+
+	//clear cam entry / key
+	//clear_cam_entry(rtlpriv, (psta->mac_id + 3));
+	rtw_clearstakey_cmd(rtlpriv, (uint8_t *)psta, (uint8_t)rtw_get_camid(psta->mac_id), true);
+
+
+	spin_lock_bh(&psta->lock);
+	psta->state &= ~_FW_LINKED;
+	spin_unlock_bh(&psta->lock);
+
+	{
+		rtw_indicate_sta_disassoc_event(rtlpriv, psta);
+	}
+
+	report_del_sta_event(rtlpriv, psta->hwaddr, reason);
+
+	beacon_updated = bss_cap_update_on_sta_leave(rtlpriv, psta);
+
+	spin_lock_bh(&(pstapriv->sta_hash_lock));
+	rtw_free_stainfo(rtlpriv, psta);
+	spin_unlock_bh(&(pstapriv->sta_hash_lock));
+
+
+	return beacon_updated;
+
+}
+
+int rtw_ap_inform_ch_switch(struct rtl_priv *rtlpriv, uint8_t new_ch, uint8_t ch_offset)
+{
+	struct list_head	*phead, *plist;
+	int ret=0;
+	struct sta_info *psta = NULL;
+	struct sta_priv *pstapriv = &rtlpriv->stapriv;
+	struct mlme_ext_priv *pmlmeext = &rtlpriv->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	uint8_t bc_addr[ETH_ALEN] = {0xff,0xff,0xff,0xff,0xff,0xff};
+
+	if ((pmlmeinfo->state&0x03) != WIFI_FW_AP_STATE)
+		return ret;
+
+	DBG_871X(FUNC_NDEV_FMT" with ch:%u, offset:%u\n",
+		FUNC_NDEV_ARG(rtlpriv->ndev), new_ch, ch_offset);
+
+	spin_lock_bh(&pstapriv->asoc_list_lock);
+	phead = &pstapriv->asoc_list;
+	plist = get_next(phead);
+
+	/* for each sta in asoc_queue */
+	while ((rtw_end_of_queue_search(phead, plist)) == false) {
+		psta = container_of(plist, struct sta_info, asoc_list);
+		plist = get_next(plist);
+
+		issue_action_spct_ch_switch(rtlpriv, psta->hwaddr, new_ch, ch_offset);
+		psta->expire_to = ((pstapriv->expire_to * 2) > 5) ? 5 : (pstapriv->expire_to * 2);
+	}
+	spin_unlock_bh(&pstapriv->asoc_list_lock);
+
+	issue_action_spct_ch_switch(rtlpriv, bc_addr, new_ch, ch_offset);
+
+	return ret;
+}
+
+int rtw_sta_flush(struct rtl_priv *rtlpriv)
+{
+	struct list_head	*phead, *plist;
+	int ret=0;
+	struct sta_info *psta = NULL;
+	struct sta_priv *pstapriv = &rtlpriv->stapriv;
+	struct mlme_ext_priv *pmlmeext = &rtlpriv->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	uint8_t bc_addr[ETH_ALEN] = {0xff,0xff,0xff,0xff,0xff,0xff};
+
+	DBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(rtlpriv->ndev));
+
+	if ((pmlmeinfo->state&0x03) != WIFI_FW_AP_STATE)
+		return ret;
+
+
+	spin_lock_bh(&pstapriv->asoc_list_lock);
+	phead = &pstapriv->asoc_list;
+	plist = get_next(phead);
+
+	//free sta asoc_queue
+	while ((rtw_end_of_queue_search(phead, plist)) == false) {
+		psta = container_of(plist, struct sta_info, asoc_list);
+
+		plist = get_next(plist);
+
+		list_del_init(&psta->asoc_list);
+		pstapriv->asoc_list_cnt--;
+
+		//spin_unlock_bh(&pstapriv->asoc_list_lock, &irqL);
+		ap_free_sta(rtlpriv, psta, true, WLAN_REASON_DEAUTH_LEAVING);
+		//spin_lock_bh(&pstapriv->asoc_list_lock, &irqL);
+	}
+	spin_unlock_bh(&pstapriv->asoc_list_lock);
+
+
+	issue_deauth(rtlpriv, bc_addr, WLAN_REASON_DEAUTH_LEAVING);
+
+	associated_clients_update(rtlpriv, true);
+
+	return ret;
+
+}
+
+/* called > TSR LEVEL for USB or SDIO Interface*/
+void sta_info_update(struct rtl_priv *rtlpriv, struct sta_info *psta)
+{
+	int flags = psta->flags;
+	struct mlme_priv *pmlmepriv = &(rtlpriv->mlmepriv);
+
+
+	//update wmm cap.
+	if (WLAN_STA_WME&flags)
+		psta->qos_option = 1;
+	else
+		psta->qos_option = 0;
+
+	if (pmlmepriv->qospriv.qos_option == 0)
+		psta->qos_option = 0;
+
+
+	//update 802.11n ht cap.
+	if (WLAN_STA_HT&flags) {
+		psta->htpriv.ht_option = true;
+		psta->qos_option = 1;
+	} else {
+		psta->htpriv.ht_option = false;
+	}
+
+	if (pmlmepriv->htpriv.ht_option == false)
+		psta->htpriv.ht_option = false;
+
+	//update 802.11AC vht cap.
+	if (WLAN_STA_VHT&flags) {
+		psta->vhtpriv.vht_option = true;
+	} else {
+		psta->vhtpriv.vht_option = false;
+	}
+
+	if (pmlmepriv->vhtpriv.vht_option == false)
+		psta->vhtpriv.vht_option = false;
+
+
+	update_sta_info_apmode(rtlpriv, psta);
+
+
+}
+
+/* called >= TSR LEVEL for USB or SDIO Interface*/
+void ap_sta_info_defer_update(struct rtl_priv *rtlpriv, struct sta_info *psta)
+{
+	struct mlme_ext_priv *pmlmeext = &rtlpriv->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	if (psta->state & _FW_LINKED) {
+		pmlmeinfo->FW_sta_info[psta->mac_id].psta = psta;
+
+		//add ratid
+		add_RATid(rtlpriv, psta, 0);//DM_RATR_STA_INIT
+	}
+}
+
+/* restore hw setting from sw data structures */
+void rtw_ap_restore_network(struct rtl_priv *rtlpriv)
+{
+	struct mlme_priv *mlmepriv = &rtlpriv->mlmepriv;
+	struct mlme_ext_priv	*pmlmeext = &rtlpriv->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct sta_priv * pstapriv = &rtlpriv->stapriv;
+	struct sta_info *psta;
+	struct security_priv* psecuritypriv= &(rtlpriv->securitypriv);
+	struct list_head	*phead, *plist;
+	uint8_t chk_alive_num = 0;
+	char chk_alive_list[NUM_STA];
+	int i;
+
+	rtw_setopmode_cmd(rtlpriv, Ndis802_11APMode);
+
+	set_channel_bwmode(rtlpriv, pmlmeext->cur_channel, pmlmeext->cur_ch_offset, pmlmeext->cur_bwmode);
+
+	start_bss_network(rtlpriv, (uint8_t *)&mlmepriv->cur_network.network);
+
+	if ((rtlpriv->securitypriv.dot11PrivacyAlgrthm == TKIP_ENCRYPTION) ||
+		(rtlpriv->securitypriv.dot11PrivacyAlgrthm == AESCCMP_ENCRYPTION)) {
+		/* restore group key, WEP keys is restored in ips_leave() */
+		rtw_set_key(rtlpriv, psecuritypriv, psecuritypriv->dot118021XGrpKeyid, 0);
+	}
+
+	/* per sta pairwise key and settings */
+	if ((rtlpriv->securitypriv.dot11PrivacyAlgrthm != TKIP_ENCRYPTION) &&
+		(rtlpriv->securitypriv.dot11PrivacyAlgrthm != AESCCMP_ENCRYPTION)) {
+		return;
+	}
+
+	spin_lock_bh(&pstapriv->asoc_list_lock);
+
+	phead = &pstapriv->asoc_list;
+	plist = get_next(phead);
+
+	while ((rtw_end_of_queue_search(phead, plist)) == false) {
+		int stainfo_offset;
+
+		psta = container_of(plist, struct sta_info, asoc_list);
+		plist = get_next(plist);
+
+		stainfo_offset = rtw_stainfo_offset(pstapriv, psta);
+		if (stainfo_offset_valid(stainfo_offset)) {
+			chk_alive_list[chk_alive_num++] = stainfo_offset;
+		}
+	}
+
+	spin_unlock_bh(&pstapriv->asoc_list_lock);
+
+	for (i = 0; i < chk_alive_num; i++) {
+		psta = rtw_get_stainfo_by_offset(pstapriv, chk_alive_list[i]);
+
+		if (psta == NULL) {
+			DBG_871X(FUNC_ADPT_FMT" sta_info is null\n", FUNC_ADPT_ARG(rtlpriv));
+		} else if (psta->state &_FW_LINKED) {
+			Update_RA_Entry(rtlpriv, psta);
+			//pairwise key
+			rtw_setstakey_cmd(rtlpriv, (unsigned char *)psta, true);
+		}
+	}
+
+}
+
+void start_ap_mode(struct rtl_priv *rtlpriv)
+{
+	int i;
+	struct mlme_priv *pmlmepriv = &(rtlpriv->mlmepriv);
+	struct sta_priv *pstapriv = &rtlpriv->stapriv;
+	struct mlme_ext_priv *pmlmeext = &rtlpriv->mlmeextpriv;
+	struct wlan_acl_pool *pacl_list = &pstapriv->acl_list;
+
+	pmlmepriv->update_bcn = false;
+
+	//init_mlme_ap_info(rtlpriv);
+	pmlmeext->bstart_bss = false;
+
+	pmlmepriv->num_sta_non_erp = 0;
+
+	pmlmepriv->num_sta_no_short_slot_time = 0;
+
+	pmlmepriv->num_sta_no_short_preamble = 0;
+
+	pmlmepriv->num_sta_ht_no_gf = 0;
+	pmlmepriv->num_sta_no_ht = 0;
+	pmlmepriv->num_sta_ht_20mhz = 0;
+
+	pmlmepriv->olbc = false;
+
+	pmlmepriv->olbc_ht = false;
+
+	pmlmepriv->ht_op_mode = 0;
+
+	for(i=0; i<NUM_STA; i++)
+		pstapriv->sta_aid[i] = NULL;
+
+	pmlmepriv->wps_beacon_ie = NULL;
+	pmlmepriv->wps_probe_resp_ie = NULL;
+	pmlmepriv->wps_assoc_resp_ie = NULL;
+
+	pmlmepriv->p2p_beacon_ie = NULL;
+	pmlmepriv->p2p_probe_resp_ie = NULL;
+
+
+	//for ACL
+	INIT_LIST_HEAD(&(pacl_list->acl_node_q.list));
+	pacl_list->num = 0;
+	pacl_list->mode = 0;
+	for(i = 0; i < NUM_ACL; i++) {
+		INIT_LIST_HEAD(&pacl_list->aclnode[i].list);
+		pacl_list->aclnode[i].valid = false;
+	}
+
+}
+
+void stop_ap_mode(struct rtl_priv *rtlpriv)
+{
+	struct list_head	*phead, *plist;
+	struct rtw_wlan_acl_node *paclnode;
+	struct sta_info *psta = NULL;
+	struct sta_priv *pstapriv = &rtlpriv->stapriv;
+	struct mlme_priv *pmlmepriv = &(rtlpriv->mlmepriv);
+	struct mlme_ext_priv *pmlmeext = &rtlpriv->mlmeextpriv;
+	struct wlan_acl_pool *pacl_list = &pstapriv->acl_list;
+	struct __queue	*pacl_node_q = &pacl_list->acl_node_q;
+
+	pmlmepriv->update_bcn = false;
+	pmlmeext->bstart_bss = false;
+
+	//reset and init security priv , this can refine with rtw_reset_securitypriv
+	memset((unsigned char *)&rtlpriv->securitypriv, 0, sizeof (struct security_priv));
+	rtlpriv->securitypriv.ndisauthtype = Ndis802_11AuthModeOpen;
+	rtlpriv->securitypriv.ndisencryptstatus = Ndis802_11WEPDisabled;
+
+	//for ACL
+	spin_lock_bh(&(pacl_node_q->lock));
+	phead = get_list_head(pacl_node_q);
+	plist = get_next(phead);
+	while ((rtw_end_of_queue_search(phead, plist)) == false) {
+		paclnode = container_of(plist, struct rtw_wlan_acl_node, list);
+		plist = get_next(plist);
+
+		if (paclnode->valid == true) {
+			paclnode->valid = false;
+
+			list_del_init(&paclnode->list);
+
+			pacl_list->num--;
+		}
+	}
+	spin_unlock_bh(&(pacl_node_q->lock));
+
+	DBG_871X("%s, free acl_node_queue, num=%d\n", __func__, pacl_list->num);
+
+	rtw_sta_flush(rtlpriv);
+
+	//free_assoc_sta_resources
+	rtw_free_all_stainfo(rtlpriv);
+
+	psta = rtw_get_bcmc_stainfo(rtlpriv);
+	spin_lock_bh(&(pstapriv->sta_hash_lock));
+	rtw_free_stainfo(rtlpriv, psta);
+	spin_unlock_bh(&(pstapriv->sta_hash_lock));
+
+	rtw_init_bcmc_stainfo(rtlpriv);
+
+	rtw_free_mlme_priv_ie_data(pmlmepriv);
+
+}
+
+#endif //CONFIG_AP_MODE
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/core/rtw_cmd.c linux-4.9.8821au/drivers/staging/rtl8821au/core/rtw_cmd.c
--- linux-4.9/drivers/staging/rtl8821au/core/rtw_cmd.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/core/rtw_cmd.c	2016-12-11 19:48:25.150311808 -0600
@@ -0,0 +1,1820 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#define _RTW_CMD_C_
+
+#include <../rtl8821au/def.h>
+#include <drv_types.h>
+
+#include <rtw_ap.h>
+
+#include <../usb.h>
+#include <../wifi.h>
+#include <../cam.h>
+
+#undef DBG_871X
+static inline void DBG_871X(const char *fmt, ...)
+{
+}
+
+/*
+Caller and the rtw_cmd_thread can protect cmd_q by spin_lock.
+No irqsave is necessary.
+*/
+
+static int _rtw_init_cmd_priv (struct	cmd_priv *pcmdpriv)
+{
+	int res=_SUCCESS;
+
+
+
+	sema_init(&(pcmdpriv->cmd_queue_sema), 0);
+	//sema_init(&(pcmdpriv->cmd_done_sema), 0);
+	sema_init(&(pcmdpriv->terminate_cmdthread_sema), 0);
+
+
+	_rtw_init_queue(&(pcmdpriv->cmd_queue));
+
+	//allocate DMA-able/Non-Page memory for cmd_buf and rsp_buf
+
+	pcmdpriv->cmd_seq = 1;
+
+	pcmdpriv->cmd_allocated_buf = rtw_zmalloc(MAX_CMDSZ + CMDBUFF_ALIGN_SZ);
+
+	if (pcmdpriv->cmd_allocated_buf == NULL){
+		res= _FAIL;
+		goto exit;
+	}
+
+	pcmdpriv->cmd_buf = pcmdpriv->cmd_allocated_buf  +  CMDBUFF_ALIGN_SZ - ( (SIZE_PTR)(pcmdpriv->cmd_allocated_buf) & (CMDBUFF_ALIGN_SZ-1));
+
+	pcmdpriv->rsp_allocated_buf = rtw_zmalloc(MAX_RSPSZ + 4);
+
+	if (pcmdpriv->rsp_allocated_buf == NULL){
+		res= _FAIL;
+		goto exit;
+	}
+
+	pcmdpriv->rsp_buf = pcmdpriv->rsp_allocated_buf  +  4 - ( (SIZE_PTR)(pcmdpriv->rsp_allocated_buf) & 3);
+
+	pcmdpriv->cmd_issued_cnt = pcmdpriv->cmd_done_cnt = pcmdpriv->rsp_cnt = 0;
+
+exit:
+
+
+
+	return res;
+
+}
+
+static int _rtw_init_evt_priv(struct evt_priv *pevtpriv)
+{
+	int res=_SUCCESS;
+
+
+	//allocate DMA-able/Non-Page memory for cmd_buf and rsp_buf
+	atomic_set(&pevtpriv->event_seq, 0);
+	pevtpriv->evt_done_cnt = 0;
+
+	return res;
+}
+
+static void _rtw_free_evt_priv (struct	evt_priv *pevtpriv)
+{
+}
+
+static void _rtw_free_cmd_priv (struct	cmd_priv *pcmdpriv)
+{
+
+
+	if(pcmdpriv){
+		if (pcmdpriv->cmd_allocated_buf)
+			rtw_mfree(pcmdpriv->cmd_allocated_buf);
+
+		if (pcmdpriv->rsp_allocated_buf)
+			rtw_mfree(pcmdpriv->rsp_allocated_buf);
+	}
+
+}
+
+/*
+Calling Context:
+
+rtw_enqueue_cmd can only be called between kernel thread,
+since only spin_lock is used.
+
+ISR/Call-Back functions can't call this sub-function.
+
+*/
+
+static int _rtw_enqueue_cmd(struct __queue *queue, struct cmd_obj *obj)
+{
+	unsigned long flags;
+
+
+
+	if (obj == NULL)
+		goto exit;
+
+	//spin_lock_bh(&queue->lock, &irqL);
+	spin_lock_irqsave(&queue->lock, flags);
+
+	list_add_tail(&obj->list, &queue->list);
+
+	//spin_unlock_bh(&queue->lock, &irqL);
+	spin_unlock_irqrestore(&queue->lock, flags);
+
+exit:
+
+
+
+	return _SUCCESS;
+}
+
+static inline struct list_head *get_next(struct list_head	*list)
+{
+	return list->next;
+}
+
+static struct	cmd_obj	*_rtw_dequeue_cmd(struct __queue *queue)
+{
+	unsigned long flags;
+	struct cmd_obj *obj;
+
+
+
+	//spin_lock_bh(&(queue->lock), &irqL);
+	spin_lock_irqsave(&queue->lock, flags);
+	if (list_empty(&(queue->list)))
+		obj = NULL;
+	else
+	{
+		obj = container_of(get_next(&(queue->list)), struct cmd_obj, list);
+		list_del_init(&obj->list);
+	}
+
+	//spin_unlock_bh(&(queue->lock), &irqL);
+	spin_unlock_irqrestore(&queue->lock, flags);
+
+
+
+	return obj;
+}
+
+uint32_t	rtw_init_cmd_priv(struct cmd_priv *pcmdpriv)
+{
+	uint32_t	res;
+
+	res = _rtw_init_cmd_priv (pcmdpriv);
+
+	return res;
+}
+
+uint32_t	rtw_init_evt_priv (struct	evt_priv *pevtpriv)
+{
+	int	res;
+
+	res = _rtw_init_evt_priv(pevtpriv);
+
+	return res;
+}
+
+void rtw_free_evt_priv (struct	evt_priv *pevtpriv)
+{
+
+	_rtw_free_evt_priv(pevtpriv);
+
+}
+
+void rtw_free_cmd_priv (struct	cmd_priv *pcmdpriv)
+{
+
+	_rtw_free_cmd_priv(pcmdpriv);
+
+}
+
+int rtw_cmd_filter(struct cmd_priv *pcmdpriv, struct cmd_obj *cmd_obj);
+int rtw_cmd_filter(struct cmd_priv *pcmdpriv, struct cmd_obj *cmd_obj)
+{
+	uint8_t bAllow = false; //set to true to allow enqueuing cmd when hw_init_completed is false
+
+	if( (pcmdpriv->rtlpriv->hw_init_completed ==false && bAllow == false)
+		|| pcmdpriv->cmdthd_running== false	//com_thread not running
+	)
+	{
+		//DBG_871X("%s:%s: drop cmdcode:%u, hw_init_completed:%u, cmdthd_running:%u\n", caller_func, __FUNCTION__,
+		//	cmd_obj->cmdcode,
+		//	pcmdpriv->rtlpriv->hw_init_completed,
+		//	pcmdpriv->cmdthd_running
+		//);
+
+		return _FAIL;
+	}
+	return _SUCCESS;
+}
+
+
+
+uint32_t	 rtw_enqueue_cmd(struct cmd_priv *pcmdpriv, struct cmd_obj *cmd_obj)
+{
+	int res = _FAIL;
+	struct rtl_priv *rtlpriv = pcmdpriv->rtlpriv;
+
+
+
+	if (cmd_obj == NULL) {
+		goto exit;
+	}
+
+	cmd_obj->rtlpriv = rtlpriv;
+
+	if( _FAIL == (res=rtw_cmd_filter(pcmdpriv, cmd_obj)) ) {
+		rtw_free_cmd_obj(cmd_obj);
+		goto exit;
+	}
+
+	res = _rtw_enqueue_cmd(&pcmdpriv->cmd_queue, cmd_obj);
+
+	if(res == _SUCCESS)
+		up(&pcmdpriv->cmd_queue_sema);
+
+exit:
+
+
+
+	return res;
+}
+
+struct	cmd_obj	*rtw_dequeue_cmd(struct cmd_priv *pcmdpriv)
+{
+	struct cmd_obj *cmd_obj;
+
+
+
+	cmd_obj = _rtw_dequeue_cmd(&pcmdpriv->cmd_queue);
+
+
+	return cmd_obj;
+}
+
+void rtw_cmd_clr_isr(struct	cmd_priv *pcmdpriv)
+{
+
+	pcmdpriv->cmd_done_cnt++;
+	//up(&(pcmdpriv->cmd_done_sema));
+
+}
+
+void rtw_free_cmd_obj(struct cmd_obj *pcmd)
+{
+
+
+	if((pcmd->cmdcode!=_JoinBss_CMD_) &&(pcmd->cmdcode!= _CreateBss_CMD_))
+	{
+		//free parmbuf in cmd_obj
+		/* ULLI check usage of pcmd->cmdsz */
+		rtw_mfree(pcmd->parmbuf);
+	}
+
+	if(pcmd->rsp!=NULL)
+	{
+		if(pcmd->rspsz!= 0)
+		{
+			//free rsp in cmd_obj
+			/* ULLI check usage of pcmd->rspsz */
+			rtw_mfree(pcmd->rsp);
+		}
+	}
+
+	//free cmd_obj
+	rtw_mfree(pcmd);
+
+
+}
+
+int rtw_cmd_thread(void *context)
+{
+	uint8_t ret;
+	struct cmd_obj *pcmd;
+	uint8_t *pcmdbuf, *prspbuf;
+	uint8_t (*cmd_hdl)(struct rtl_priv *rtlpriv, uint8_t * pbuf);
+	void (*pcmd_callback)(struct rtl_priv *dev, struct cmd_obj *pcmd);
+	struct rtl_priv *rtlpriv = (struct rtl_priv *) context;
+	struct cmd_priv *pcmdpriv = &(rtlpriv->cmdpriv);
+
+
+
+	thread_enter("RTW_CMD_THREAD");
+
+	pcmdbuf = pcmdpriv->cmd_buf;
+	prspbuf = pcmdpriv->rsp_buf;
+
+	pcmdpriv->cmdthd_running=true;
+	up(&pcmdpriv->terminate_cmdthread_sema);
+
+	while(1)
+	{
+		if (down_interruptible(&pcmdpriv->cmd_queue_sema))
+			break;
+
+		if ((rtlpriv->bDriverStopped == true)||(rtlpriv->bSurpriseRemoved == true))
+		{
+			DBG_871X("%s: DriverStopped(%d) SurpriseRemoved(%d) break at line %d\n",
+				__FUNCTION__, rtlpriv->bDriverStopped, rtlpriv->bSurpriseRemoved, __LINE__);
+			break;
+		}
+
+_next:
+		if ((rtlpriv->bDriverStopped == true)||(rtlpriv->bSurpriseRemoved== true))
+		{
+			DBG_871X("%s: DriverStopped(%d) SurpriseRemoved(%d) break at line %d\n",
+				__FUNCTION__, rtlpriv->bDriverStopped, rtlpriv->bSurpriseRemoved, __LINE__);
+			break;
+		}
+
+		if(!(pcmd = rtw_dequeue_cmd(pcmdpriv))) {
+			continue;
+		}
+
+		if( _FAIL == rtw_cmd_filter(pcmdpriv, pcmd) )
+		{
+			pcmd->res = H2C_DROPPED;
+			goto post_process;
+		}
+
+		pcmdpriv->cmd_issued_cnt++;
+
+		pcmd->cmdsz = _RND4((pcmd->cmdsz));//_RND4
+
+		memcpy(pcmdbuf, pcmd->parmbuf, pcmd->cmdsz);
+
+		if(pcmd->cmdcode <= (sizeof(wlancmds) /sizeof(struct cmd_hdl)))
+		{
+			cmd_hdl = wlancmds[pcmd->cmdcode].h2cfuns;
+
+			if (cmd_hdl)
+			{
+				ret = cmd_hdl(pcmd->rtlpriv, pcmdbuf);
+				pcmd->res = ret;
+			}
+
+			pcmdpriv->cmd_seq++;
+		}
+		else
+		{
+			pcmd->res = H2C_PARAMETERS_ERROR;
+		}
+
+		cmd_hdl = NULL;
+
+post_process:
+
+		//call callback function for post-processed
+		if(pcmd->cmdcode <= (sizeof(rtw_cmd_callback) /sizeof(struct _cmd_callback)))
+		{
+			pcmd_callback = rtw_cmd_callback[pcmd->cmdcode].callback;
+			if(pcmd_callback == NULL)
+			{
+				rtw_free_cmd_obj(pcmd);
+			}
+			else
+			{
+				//todo: !!! fill rsp_buf to pcmd->rsp if (pcmd->rsp!=NULL)
+				pcmd_callback(pcmd->rtlpriv, pcmd);//need conider that free cmd_obj in rtw_cmd_callback
+			}
+		}
+		else
+		{
+			rtw_free_cmd_obj(pcmd);
+		}
+
+		flush_signals_thread();
+
+		goto _next;
+
+	}
+	pcmdpriv->cmdthd_running=false;
+
+
+	// free all cmd_obj resources
+	do{
+		pcmd = rtw_dequeue_cmd(pcmdpriv);
+		if(pcmd==NULL){
+			break;
+		}
+
+		//DBG_871X("%s: leaving... drop cmdcode:%u\n", __FUNCTION__, pcmd->cmdcode);
+
+		rtw_free_cmd_obj(pcmd);
+	}while(1);
+
+	up(&pcmdpriv->terminate_cmdthread_sema);
+
+
+
+	 complete_and_exit(NULL, 0);
+
+}
+
+/*
+rtw_sitesurvey_cmd(~)
+	### NOTE:#### (!!!!)
+	MUST TAKE CARE THAT BEFORE CALLING THIS FUNC, YOU SHOULD HAVE LOCKED pmlmepriv->lock
+*/
+uint8_t rtw_sitesurvey_cmd(struct rtl_priv  *rtlpriv, NDIS_802_11_SSID *ssid, int ssid_num,
+	struct rtw_ieee80211_channel *ch, int ch_num)
+{
+	uint8_t res = _FAIL;
+	struct cmd_obj		*ph2c;
+	struct sitesurvey_parm	*psurveyPara;
+	struct cmd_priv 	*pcmdpriv = &rtlpriv->cmdpriv;
+	struct mlme_priv	*pmlmepriv = &rtlpriv->mlmepriv;
+
+
+
+	if(check_fwstate(pmlmepriv, _FW_LINKED) == true){
+		rtw_lps_ctrl_wk_cmd(rtlpriv, LPS_CTRL_SCAN, 1);
+	}
+
+	ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
+	if (ph2c == NULL)
+		return _FAIL;
+
+	psurveyPara = (struct sitesurvey_parm*)rtw_zmalloc(sizeof(struct sitesurvey_parm));
+	if (psurveyPara == NULL) {
+		rtw_mfree(ph2c);
+		return _FAIL;
+	}
+
+	rtw_free_network_queue(rtlpriv, false);
+
+	init_h2fwcmd_w_parm_no_rsp(ph2c, psurveyPara, GEN_CMD_CODE(_SiteSurvey));
+
+	/* psurveyPara->bsslimit = 48; */
+	psurveyPara->scan_mode = pmlmepriv->scan_mode;
+
+	/* prepare ssid list */
+	if (ssid) {
+		int i;
+		for (i=0; i<ssid_num && i< RTW_SSID_SCAN_AMOUNT; i++) {
+			if (ssid[i].SsidLength) {
+				memcpy(&psurveyPara->ssid[i], &ssid[i], sizeof(NDIS_802_11_SSID));
+				psurveyPara->ssid_num++;
+				if (0)
+				DBG_871X(FUNC_ADPT_FMT" ssid:(%s, %d)\n", FUNC_ADPT_ARG(rtlpriv),
+					psurveyPara->ssid[i].Ssid, psurveyPara->ssid[i].SsidLength);
+			}
+		}
+	}
+
+	/* prepare channel list */
+	if (ch) {
+		int i;
+		for (i=0; i<ch_num && i< RTW_CHANNEL_SCAN_AMOUNT; i++) {
+			if (ch[i].hw_value && !(ch[i].flags & RTW_IEEE80211_CHAN_DISABLED)) {
+				memcpy(&psurveyPara->ch[i], &ch[i], sizeof(struct rtw_ieee80211_channel));
+				psurveyPara->ch_num++;
+				if (0)
+				DBG_871X(FUNC_ADPT_FMT" ch:%u\n", FUNC_ADPT_ARG(rtlpriv),
+					psurveyPara->ch[i].hw_value);
+			}
+		}
+	}
+
+	set_fwstate(pmlmepriv, _FW_UNDER_SURVEY);
+
+	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
+
+	if(res == _SUCCESS) {
+
+		pmlmepriv->scan_start_time = jiffies;
+
+			_set_timer(&pmlmepriv->scan_to_timer, SCANNING_TIMEOUT);
+		pmlmepriv->scan_interval = SCAN_INTERVAL;// 30*2 sec = 60sec
+	} else {
+		_clr_fwstate_(pmlmepriv, _FW_UNDER_SURVEY);
+	}
+
+
+
+	return res;
+}
+
+void rtw_getbbrfreg_cmdrsp_callback(struct rtl_priv*	rtlpriv,  struct cmd_obj *pcmd)
+{
+
+
+	//rtw_free_cmd_obj(pcmd);
+	/* ULLI check usage of pcmd->cmdsz */
+	rtw_mfree(pcmd->parmbuf);
+	rtw_mfree(pcmd);
+
+
+}
+
+void rtw_readtssi_cmdrsp_callback(struct rtl_priv*	rtlpriv,  struct cmd_obj *pcmd)
+{
+
+	/* ULLI check usage of pcmd->cmdsz */
+	rtw_mfree(pcmd->parmbuf);
+	rtw_mfree(pcmd);
+
+
+
+}
+
+uint8_t rtw_createbss_cmd(struct rtl_priv  *rtlpriv)
+{
+	struct cmd_obj*			pcmd;
+	struct cmd_priv 			*pcmdpriv=&rtlpriv->cmdpriv;
+	struct mlme_priv			*pmlmepriv = &rtlpriv->mlmepriv;
+	WLAN_BSSID_EX		*pdev_network = &rtlpriv->registrypriv.dev_network;
+	uint8_t	res=_SUCCESS;
+
+	if (pmlmepriv->assoc_ssid.SsidLength == 0){
+		;
+	} else {
+		;
+	}
+
+	pcmd = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
+	if(pcmd==NULL){
+		res= _FAIL;
+		goto exit;
+	}
+
+	INIT_LIST_HEAD(&pcmd->list);
+	pcmd->cmdcode = _CreateBss_CMD_;
+	pcmd->parmbuf = (unsigned char *)pdev_network;
+	pcmd->cmdsz = get_WLAN_BSSID_EX_sz((WLAN_BSSID_EX*)pdev_network);
+	pcmd->rsp = NULL;
+	pcmd->rspsz = 0;
+
+	pdev_network->Length = pcmd->cmdsz;
+
+	res = rtw_enqueue_cmd(pcmdpriv, pcmd);
+
+exit:
+
+
+
+	return res;
+}
+
+uint8_t rtw_createbss_cmd_ex(struct rtl_priv  *rtlpriv, unsigned char *pbss, unsigned int sz)
+{
+	struct cmd_obj*	pcmd;
+	struct cmd_priv 	*pcmdpriv=&rtlpriv->cmdpriv;
+	uint8_t	res=_SUCCESS;
+
+
+
+	pcmd = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
+	if(pcmd==NULL){
+		res= _FAIL;
+		goto exit;
+	}
+
+	INIT_LIST_HEAD(&pcmd->list);
+	pcmd->cmdcode = GEN_CMD_CODE(_CreateBss);
+	pcmd->parmbuf = pbss;
+	pcmd->cmdsz =  sz;
+	pcmd->rsp = NULL;
+	pcmd->rspsz = 0;
+
+	res = rtw_enqueue_cmd(pcmdpriv, pcmd);
+
+exit:
+
+
+
+	return res;
+}
+
+uint8_t rtw_joinbss_cmd(struct rtl_priv  *rtlpriv, struct wlan_network* pnetwork)
+{
+	uint8_t	*auth, res = _SUCCESS;
+	uint	t_len = 0;
+	WLAN_BSSID_EX		*psecnetwork;
+	struct cmd_obj		*pcmd;
+	struct cmd_priv		*pcmdpriv=&rtlpriv->cmdpriv;
+	struct mlme_priv		*pmlmepriv = &rtlpriv->mlmepriv;
+	struct qos_priv		*pqospriv= &pmlmepriv->qospriv;
+	struct security_priv	*psecuritypriv=&rtlpriv->securitypriv;
+	struct registry_priv	*pregistrypriv = &rtlpriv->registrypriv;
+	struct ht_priv			*phtpriv = &pmlmepriv->htpriv;
+	struct vht_priv		*pvhtpriv = &pmlmepriv->vhtpriv;
+	NDIS_802_11_NETWORK_INFRASTRUCTURE ndis_network_mode = pnetwork->network.InfrastructureMode;
+	struct mlme_ext_priv	*pmlmeext = &rtlpriv->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	if (pmlmepriv->assoc_ssid.SsidLength == 0){
+		;
+	} else {
+		;
+	}
+
+	pcmd = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
+	if(pcmd==NULL){
+		res=_FAIL;
+		goto exit;
+	}
+	/* // for IEs is pointer
+	t_len = sizeof (u32) + sizeof (NDIS_802_11_MAC_ADDRESS) + 2 +
+			sizeof (NDIS_802_11_SSID) + sizeof (u32) +
+			sizeof (NDIS_802_11_RSSI) + sizeof (NDIS_802_11_NETWORK_TYPE) +
+			sizeof (NDIS_802_11_CONFIGURATION) +
+			sizeof (NDIS_802_11_NETWORK_INFRASTRUCTURE) +
+			sizeof (NDIS_802_11_RATES_EX)+ sizeof(WLAN_PHY_INFO)+ sizeof (u32) + MAX_IE_SZ;
+	*/
+	//for IEs is fix buf size
+	t_len = sizeof(WLAN_BSSID_EX);
+
+
+	//for hidden ap to set fw_state here
+	if (check_fwstate(pmlmepriv, WIFI_STATION_STATE|WIFI_ADHOC_STATE) != true)
+	{
+		switch(ndis_network_mode)
+		{
+			case Ndis802_11IBSS:
+				set_fwstate(pmlmepriv, WIFI_ADHOC_STATE);
+				break;
+
+			case Ndis802_11Infrastructure:
+				set_fwstate(pmlmepriv, WIFI_STATION_STATE);
+				break;
+
+			case Ndis802_11APMode:
+			case Ndis802_11AutoUnknown:
+			case Ndis802_11InfrastructureMax:
+				break;
+
+		}
+	}
+
+	psecnetwork=(WLAN_BSSID_EX *)&psecuritypriv->sec_bss;
+	if(psecnetwork==NULL)
+	{
+		if(pcmd !=NULL)
+			rtw_mfree(pcmd);
+
+		res=_FAIL;
+
+		goto exit;
+	}
+
+	memset(psecnetwork, 0, t_len);
+
+	memcpy(psecnetwork, &pnetwork->network, get_WLAN_BSSID_EX_sz(&pnetwork->network));
+
+	auth=&psecuritypriv->authenticator_ie[0];
+	psecuritypriv->authenticator_ie[0]=(unsigned char)psecnetwork->IELength;
+
+	if((psecnetwork->IELength-12) < (256-1)) {
+		memcpy(&psecuritypriv->authenticator_ie[1], &psecnetwork->IEs[12], psecnetwork->IELength-12);
+	} else {
+		memcpy(&psecuritypriv->authenticator_ie[1], &psecnetwork->IEs[12], (256-1));
+	}
+
+	psecnetwork->IELength = 0;
+	// Added by Albert 2009/02/18
+	// If the the driver wants to use the bssid to create the connection.
+	// If not,  we have to copy the connecting AP's MAC address to it so that
+	// the driver just has the bssid information for PMKIDList searching.
+
+	if ( pmlmepriv->assoc_by_bssid == false )
+	{
+		memcpy( &pmlmepriv->assoc_bssid[ 0 ], &pnetwork->network.MacAddress[ 0 ], ETH_ALEN );
+	}
+
+	psecnetwork->IELength = rtw_restruct_sec_ie(rtlpriv, &pnetwork->network.IEs[0], &psecnetwork->IEs[0], pnetwork->network.IELength);
+
+
+	pqospriv->qos_option = 0;
+
+	if(pregistrypriv->wmm_enable)
+	{
+		uint32_t	 tmp_len;
+
+		tmp_len = rtw_restruct_wmm_ie(rtlpriv, &pnetwork->network.IEs[0], &psecnetwork->IEs[0], pnetwork->network.IELength, psecnetwork->IELength);
+
+		if (psecnetwork->IELength != tmp_len)
+		{
+			psecnetwork->IELength = tmp_len;
+			pqospriv->qos_option = 1; //There is WMM IE in this corresp. beacon
+		}
+		else
+		{
+			pqospriv->qos_option = 0;//There is no WMM IE in this corresp. beacon
+		}
+	}
+
+	phtpriv->ht_option = false;
+	{
+		//	Added by Albert 2010/06/23
+		//	For the WEP mode, we will use the bg mode to do the connection to avoid some IOT issue.
+		//	Especially for Realtek 8192u SoftAP.
+		if (	( rtlpriv->securitypriv.dot11PrivacyAlgrthm != WEP40_ENCRYPTION ) &&
+			( rtlpriv->securitypriv.dot11PrivacyAlgrthm != WEP104_ENCRYPTION ) &&
+			( rtlpriv->securitypriv.dot11PrivacyAlgrthm != TKIP_ENCRYPTION ))
+		{
+			//rtw_restructure_ht_ie
+			rtw_restructure_ht_ie(rtlpriv, &pnetwork->network.IEs[0], &psecnetwork->IEs[0],
+									pnetwork->network.IELength, &psecnetwork->IELength);
+		}
+	}
+
+
+	pvhtpriv->vht_option = false;
+	if (phtpriv->ht_option) {
+		rtw_restructure_vht_ie(rtlpriv, &pnetwork->network.IEs[0], &psecnetwork->IEs[0],
+								pnetwork->network.IELength, &psecnetwork->IELength);
+	}
+
+	pmlmeinfo->assoc_AP_vendor = check_assoc_AP(pnetwork->network.IEs, pnetwork->network.IELength);
+
+	#if 0
+	psecuritypriv->supplicant_ie[0]=(uint8_t)psecnetwork->IELength;
+
+	if(psecnetwork->IELength < (256-1))
+	{
+		memcpy(&psecuritypriv->supplicant_ie[1], &psecnetwork->IEs[0], psecnetwork->IELength);
+	}
+	else
+	{
+		memcpy(&psecuritypriv->supplicant_ie[1], &psecnetwork->IEs[0], (256-1));
+	}
+	#endif
+
+	pcmd->cmdsz = get_WLAN_BSSID_EX_sz(psecnetwork);//get cmdsz before endian conversion
+
+	INIT_LIST_HEAD(&pcmd->list);
+	pcmd->cmdcode = _JoinBss_CMD_;//GEN_CMD_CODE(_JoinBss)
+	pcmd->parmbuf = (unsigned char *)psecnetwork;
+	pcmd->rsp = NULL;
+	pcmd->rspsz = 0;
+
+	res = rtw_enqueue_cmd(pcmdpriv, pcmd);
+
+exit:
+
+
+
+	return res;
+}
+
+uint8_t rtw_disassoc_cmd(struct rtl_priv*rtlpriv, uint32_t	 deauth_timeout_ms, bool enqueue) /* for sta_mode */
+{
+	struct cmd_obj *cmdobj = NULL;
+	struct disconnect_parm *param = NULL;
+	struct cmd_priv *cmdpriv = &rtlpriv->cmdpriv;
+	uint8_t res = _SUCCESS;
+
+
+
+	/* prepare cmd parameter */
+	param = (struct disconnect_parm *)rtw_zmalloc(sizeof(*param));
+	if (param == NULL) {
+		res = _FAIL;
+		goto exit;
+	}
+	param->deauth_timeout_ms = deauth_timeout_ms;
+
+	if (enqueue) {
+		/* need enqueue, prepare cmd_obj and enqueue */
+		cmdobj = (struct cmd_obj *)rtw_zmalloc(sizeof(*cmdobj));
+		if (cmdobj == NULL) {
+			res = _FAIL;
+			rtw_mfree(param);
+			goto exit;
+		}
+		init_h2fwcmd_w_parm_no_rsp(cmdobj, param, _DisConnect_CMD_);
+		res = rtw_enqueue_cmd(cmdpriv, cmdobj);
+	} else {
+		/* no need to enqueue, do the cmd hdl directly and free cmd parameter */
+		if (H2C_SUCCESS != disconnect_hdl(rtlpriv, (uint8_t *)param))
+			res = _FAIL;
+		rtw_mfree(param);
+	}
+
+exit:
+
+
+
+	return res;
+}
+
+uint8_t rtw_setopmode_cmd(struct rtl_priv  *rtlpriv, NDIS_802_11_NETWORK_INFRASTRUCTURE networktype)
+{
+	struct	cmd_obj*	ph2c;
+	struct	setopmode_parm* psetop;
+
+	struct	cmd_priv   *pcmdpriv= &rtlpriv->cmdpriv;
+	uint8_t	res=_SUCCESS;
+
+
+
+	ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
+	if(ph2c==NULL){
+		res= false;
+		goto exit;
+	}
+	psetop = (struct setopmode_parm*)rtw_zmalloc(sizeof(struct setopmode_parm));
+
+	if(psetop==NULL){
+		rtw_mfree(ph2c);
+		res=false;
+		goto exit;
+	}
+
+	init_h2fwcmd_w_parm_no_rsp(ph2c, psetop, _SetOpMode_CMD_);
+	psetop->mode = (uint8_t)networktype;
+
+	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
+
+exit:
+
+
+
+	return res;
+}
+
+uint8_t rtw_setstakey_cmd(struct rtl_priv *rtlpriv, uint8_t *psta, uint8_t unicast_key)
+{
+	struct cmd_obj*			ph2c;
+	struct set_stakey_parm	*psetstakey_para;
+	struct cmd_priv 			*pcmdpriv=&rtlpriv->cmdpriv;
+	struct set_stakey_rsp		*psetstakey_rsp = NULL;
+
+	struct mlme_priv			*pmlmepriv = &rtlpriv->mlmepriv;
+	struct security_priv 		*psecuritypriv = &rtlpriv->securitypriv;
+	struct sta_info* 			sta = (struct sta_info* )psta;
+	uint8_t	res=_SUCCESS;
+
+
+
+	ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
+	if ( ph2c == NULL){
+		res= _FAIL;
+		goto exit;
+	}
+
+	psetstakey_para = (struct set_stakey_parm*)rtw_zmalloc(sizeof(struct set_stakey_parm));
+	if(psetstakey_para==NULL){
+		rtw_mfree(ph2c);
+		res=_FAIL;
+		goto exit;
+	}
+
+	psetstakey_rsp = (struct set_stakey_rsp*)rtw_zmalloc(sizeof(struct set_stakey_rsp));
+	if(psetstakey_rsp == NULL){
+		rtw_mfree(ph2c);
+		rtw_mfree(psetstakey_para);
+		res=_FAIL;
+		goto exit;
+	}
+
+	init_h2fwcmd_w_parm_no_rsp(ph2c, psetstakey_para, _SetStaKey_CMD_);
+	ph2c->rsp = (uint8_t *) psetstakey_rsp;
+	ph2c->rspsz = sizeof(struct set_stakey_rsp);
+
+	memcpy(psetstakey_para->addr, sta->hwaddr,ETH_ALEN);
+
+	if(check_fwstate(pmlmepriv, WIFI_STATION_STATE)){
+		psetstakey_para->algorithm =(unsigned char) psecuritypriv->dot11PrivacyAlgrthm;
+	}else{
+		GET_ENCRY_ALGO(psecuritypriv, sta, psetstakey_para->algorithm, false);
+	}
+
+	if (unicast_key == true) {
+			memcpy(&psetstakey_para->key, &sta->dot118021x_UncstKey, 16);
+        } else {
+		memcpy(&psetstakey_para->key, &psecuritypriv->dot118021XGrpKey[psecuritypriv->dot118021XGrpKeyid].skey, 16);
+        }
+
+	//jeff: set this becasue at least sw key is ready
+	rtlpriv->securitypriv.busetkipkey=true;
+
+	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
+
+exit:
+
+
+
+	return res;
+}
+
+uint8_t rtw_clearstakey_cmd(struct rtl_priv *rtlpriv, uint8_t *psta, uint8_t entry, uint8_t enqueue)
+{
+	struct cmd_obj*			ph2c;
+	struct set_stakey_parm	*psetstakey_para;
+	struct cmd_priv 			*pcmdpriv=&rtlpriv->cmdpriv;
+	struct set_stakey_rsp		*psetstakey_rsp = NULL;
+	struct mlme_priv			*pmlmepriv = &rtlpriv->mlmepriv;
+	struct security_priv 		*psecuritypriv = &rtlpriv->securitypriv;
+	struct sta_info* 			sta = (struct sta_info* )psta;
+	uint8_t	res=_SUCCESS;
+
+
+
+	if(!enqueue)
+	{
+		clear_cam_entry(rtlpriv, entry);
+	}
+	else
+	{
+		ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
+		if ( ph2c == NULL){
+			res= _FAIL;
+			goto exit;
+		}
+
+		psetstakey_para = (struct set_stakey_parm*)rtw_zmalloc(sizeof(struct set_stakey_parm));
+		if(psetstakey_para==NULL){
+			rtw_mfree(ph2c);
+			res=_FAIL;
+			goto exit;
+		}
+
+		psetstakey_rsp = (struct set_stakey_rsp*)rtw_zmalloc(sizeof(struct set_stakey_rsp));
+		if(psetstakey_rsp == NULL){
+			rtw_mfree(ph2c);
+			rtw_mfree(psetstakey_para);
+			res=_FAIL;
+			goto exit;
+		}
+
+		init_h2fwcmd_w_parm_no_rsp(ph2c, psetstakey_para, _SetStaKey_CMD_);
+		ph2c->rsp = (uint8_t *) psetstakey_rsp;
+		ph2c->rspsz = sizeof(struct set_stakey_rsp);
+
+		memcpy(psetstakey_para->addr, sta->hwaddr, ETH_ALEN);
+
+		psetstakey_para->algorithm = NO_ENCRYPTION;
+
+		psetstakey_para->id = entry;
+
+		res = rtw_enqueue_cmd(pcmdpriv, ph2c);
+
+	}
+
+exit:
+
+
+
+	return res;
+}
+
+uint8_t rtw_addbareq_cmd(struct rtl_priv*rtlpriv, uint8_t tid, uint8_t *addr)
+{
+	struct cmd_priv		*pcmdpriv = &rtlpriv->cmdpriv;
+	struct cmd_obj*		ph2c;
+	struct addBaReq_parm	*paddbareq_parm;
+
+	uint8_t	res=_SUCCESS;
+
+
+
+	ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
+	if(ph2c==NULL){
+		res= _FAIL;
+		goto exit;
+	}
+
+	paddbareq_parm = (struct addBaReq_parm*)rtw_zmalloc(sizeof(struct addBaReq_parm));
+	if(paddbareq_parm==NULL){
+		rtw_mfree(ph2c);
+		res= _FAIL;
+		goto exit;
+	}
+
+	paddbareq_parm->tid = tid;
+	memcpy(paddbareq_parm->addr, addr, ETH_ALEN);
+
+	init_h2fwcmd_w_parm_no_rsp(ph2c, paddbareq_parm, GEN_CMD_CODE(_AddBAReq));
+
+	//DBG_871X("rtw_addbareq_cmd, tid=%d\n", tid);
+
+	//rtw_enqueue_cmd(pcmdpriv, ph2c);
+	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
+
+exit:
+
+
+
+	return res;
+}
+
+uint8_t rtw_dynamic_chk_wk_cmd(struct rtl_priv*rtlpriv)
+{
+	struct cmd_obj*		ph2c;
+	struct drvextra_cmd_parm  *pdrvextra_cmd_parm;
+	struct cmd_priv	*pcmdpriv=&rtlpriv->cmdpriv;
+	uint8_t	res=_SUCCESS;
+
+
+
+	ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
+	if(ph2c==NULL){
+		res= _FAIL;
+		goto exit;
+	}
+
+	pdrvextra_cmd_parm = (struct drvextra_cmd_parm*)rtw_zmalloc(sizeof(struct drvextra_cmd_parm));
+	if(pdrvextra_cmd_parm==NULL){
+		rtw_mfree(ph2c);
+		res= _FAIL;
+		goto exit;
+	}
+
+	pdrvextra_cmd_parm->ec_id = DYNAMIC_CHK_WK_CID;
+	pdrvextra_cmd_parm->type_size = 0;
+	pdrvextra_cmd_parm->pbuf = (uint8_t *)rtlpriv;
+
+	init_h2fwcmd_w_parm_no_rsp(ph2c, pdrvextra_cmd_parm, GEN_CMD_CODE(_Set_Drv_Extra));
+
+
+	//rtw_enqueue_cmd(pcmdpriv, ph2c);
+	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
+
+exit:
+
+
+
+	return res;
+
+}
+
+uint8_t rtw_set_ch_cmd(struct rtl_priv*rtlpriv, uint8_t ch, uint8_t bw, uint8_t ch_offset, uint8_t enqueue)
+{
+	struct cmd_obj *pcmdobj;
+	struct set_ch_parm *set_ch_parm;
+	struct cmd_priv *pcmdpriv = &rtlpriv->cmdpriv;
+
+	uint8_t res=_SUCCESS;
+
+
+
+	DBG_871X(FUNC_NDEV_FMT" ch:%u, bw:%u, ch_offset:%u\n",
+		FUNC_NDEV_ARG(rtlpriv->ndev), ch, bw, ch_offset);
+
+	/* check input parameter */
+
+	/* prepare cmd parameter */
+	set_ch_parm = (struct set_ch_parm *)rtw_zmalloc(sizeof(*set_ch_parm));
+	if (set_ch_parm == NULL) {
+		res= _FAIL;
+		goto exit;
+	}
+	set_ch_parm->ch = ch;
+	set_ch_parm->bw = bw;
+	set_ch_parm->ch_offset = ch_offset;
+
+	if (enqueue) {
+		/* need enqueue, prepare cmd_obj and enqueue */
+		pcmdobj = (struct cmd_obj*)rtw_zmalloc(sizeof(struct	cmd_obj));
+		if(pcmdobj == NULL){
+			rtw_mfree(set_ch_parm);
+			res=_FAIL;
+			goto exit;
+		}
+
+		init_h2fwcmd_w_parm_no_rsp(pcmdobj, set_ch_parm, GEN_CMD_CODE(_SetChannel));
+		res = rtw_enqueue_cmd(pcmdpriv, pcmdobj);
+	} else {
+		/* no need to enqueue, do the cmd hdl directly and free cmd parameter */
+		if( H2C_SUCCESS !=set_ch_hdl(rtlpriv, (uint8_t *)set_ch_parm) )
+			res = _FAIL;
+
+		rtw_mfree(set_ch_parm);
+	}
+
+	/* do something based on res... */
+
+exit:
+
+	DBG_871X(FUNC_NDEV_FMT" res:%u\n", FUNC_NDEV_ARG(rtlpriv->ndev), res);
+
+
+
+	return res;
+}
+
+uint8_t rtw_set_csa_cmd(struct rtl_priv*rtlpriv, uint8_t new_ch_no)
+{
+	struct	cmd_obj*	pcmdobj;
+	struct	SetChannelSwitch_param*setChannelSwitch_param;
+	struct 	mlme_priv *pmlmepriv = &rtlpriv->mlmepriv;
+	struct	cmd_priv   *pcmdpriv = &rtlpriv->cmdpriv;
+
+	uint8_t	res=_SUCCESS;
+
+
+
+	pcmdobj = (struct	cmd_obj*)rtw_zmalloc(sizeof(struct	cmd_obj));
+	if(pcmdobj == NULL){
+		res=_FAIL;
+		goto exit;
+	}
+
+	setChannelSwitch_param = (struct SetChannelSwitch_param *)rtw_zmalloc(sizeof(struct	SetChannelSwitch_param));
+	if(setChannelSwitch_param == NULL) {
+		rtw_mfree(pcmdobj);
+		res= _FAIL;
+		goto exit;
+	}
+
+	setChannelSwitch_param->new_ch_no=new_ch_no;
+
+	init_h2fwcmd_w_parm_no_rsp(pcmdobj, setChannelSwitch_param, GEN_CMD_CODE(_SetChannelSwitch));
+	res = rtw_enqueue_cmd(pcmdpriv, pcmdobj);
+
+exit:
+
+
+
+	return res;
+}
+
+static void traffic_status_watchdog(struct rtl_priv *rtlpriv)
+{
+	uint8_t	bEnterPS;
+	u16	BusyThreshold = 100;
+	uint8_t	bBusyTraffic = false, bTxBusyTraffic = false, bRxBusyTraffic = false;
+	uint8_t	bHigherBusyTraffic = false, bHigherBusyRxTraffic = false, bHigherBusyTxTraffic = false;
+	struct mlme_priv		*pmlmepriv = &(rtlpriv->mlmepriv);
+
+	//
+	// Determine if our traffic is busy now
+	//
+	if((check_fwstate(pmlmepriv, _FW_LINKED)== true)
+		/*&& !MgntInitAdapterInProgress(pMgntInfo)*/)
+	{
+
+		// if we raise bBusyTraffic in last watchdog, using lower threshold.
+		if (pmlmepriv->LinkDetectInfo.bBusyTraffic)
+			BusyThreshold = 75;
+		if( pmlmepriv->LinkDetectInfo.NumRxOkInPeriod > BusyThreshold ||
+			pmlmepriv->LinkDetectInfo.NumTxOkInPeriod > BusyThreshold )
+		{
+			bBusyTraffic = true;
+
+			if (pmlmepriv->LinkDetectInfo.NumRxOkInPeriod > pmlmepriv->LinkDetectInfo.NumTxOkInPeriod)
+				bRxBusyTraffic = true;
+			else
+				bTxBusyTraffic = true;
+		}
+
+		// Higher Tx/Rx data.
+		if( pmlmepriv->LinkDetectInfo.NumRxOkInPeriod > 4000 ||
+			pmlmepriv->LinkDetectInfo.NumTxOkInPeriod > 4000 )
+		{
+			bHigherBusyTraffic = true;
+
+			if (pmlmepriv->LinkDetectInfo.NumRxOkInPeriod > pmlmepriv->LinkDetectInfo.NumTxOkInPeriod)
+				bHigherBusyRxTraffic = true;
+			else
+				bHigherBusyTxTraffic = true;
+		}
+
+		{
+		// check traffic for  powersaving.
+		if( ((pmlmepriv->LinkDetectInfo.NumRxUnicastOkInPeriod + pmlmepriv->LinkDetectInfo.NumTxOkInPeriod) > 8 ) ||
+			(pmlmepriv->LinkDetectInfo.NumRxUnicastOkInPeriod > 2) )
+		{
+			//DBG_871X("Tx = %d, Rx = %d \n",pmlmepriv->LinkDetectInfo.NumTxOkInPeriod,pmlmepriv->LinkDetectInfo.NumRxUnicastOkInPeriod);
+			bEnterPS= false;
+		}
+		else
+		{
+			bEnterPS= true;
+		}
+
+		// LeisurePS only work in infra mode.
+		if(bEnterPS)
+		{
+			LPS_Enter(rtlpriv);
+		}
+		else
+		{
+			LPS_Leave(rtlpriv);
+		}
+		}
+	}
+	else
+	{
+		LPS_Leave(rtlpriv);
+	}
+
+	pmlmepriv->LinkDetectInfo.NumRxOkInPeriod = 0;
+	pmlmepriv->LinkDetectInfo.NumTxOkInPeriod = 0;
+	pmlmepriv->LinkDetectInfo.NumRxUnicastOkInPeriod = 0;
+	pmlmepriv->LinkDetectInfo.bBusyTraffic = bBusyTraffic;
+	pmlmepriv->LinkDetectInfo.bTxBusyTraffic = bTxBusyTraffic;
+	pmlmepriv->LinkDetectInfo.bRxBusyTraffic = bRxBusyTraffic;
+	pmlmepriv->LinkDetectInfo.bHigherBusyTraffic = bHigherBusyTraffic;
+	pmlmepriv->LinkDetectInfo.bHigherBusyRxTraffic = bHigherBusyRxTraffic;
+	pmlmepriv->LinkDetectInfo.bHigherBusyTxTraffic = bHigherBusyTxTraffic;
+}
+
+void dynamic_chk_wk_hdl(struct rtl_priv *rtlpriv, uint8_t *pbuf, int sz);
+void dynamic_chk_wk_hdl(struct rtl_priv *rtlpriv, uint8_t *pbuf, int sz)
+{
+	struct mlme_priv *pmlmepriv;
+
+	rtlpriv = (struct rtl_priv *)pbuf;
+	pmlmepriv = &(rtlpriv->mlmepriv);
+
+	//if(check_fwstate(pmlmepriv, _FW_UNDER_LINKING|_FW_UNDER_SURVEY)==false)
+	{
+		linked_status_chk(rtlpriv);
+		traffic_status_watchdog(rtlpriv);
+	}
+
+	rtlpriv->cfg->ops->dm_watchdog(rtlpriv);
+
+	//check_hw_pbc(rtlpriv, pdrvextra_cmd->pbuf, pdrvextra_cmd->type_size);
+
+}
+
+void lps_ctrl_wk_hdl(struct rtl_priv *rtlpriv, uint8_t lps_ctrl_type);
+void lps_ctrl_wk_hdl(struct rtl_priv *rtlpriv, uint8_t lps_ctrl_type)
+{
+	struct pwrctrl_priv *pwrpriv = &rtlpriv->pwrctrlpriv;
+	struct mlme_priv *pmlmepriv = &(rtlpriv->mlmepriv);
+	uint8_t	mstatus;
+
+
+
+	if((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true)
+		|| (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true))
+	{
+		return;
+	}
+
+	switch(lps_ctrl_type)
+	{
+		case LPS_CTRL_SCAN:
+			//DBG_871X("LPS_CTRL_SCAN \n");
+			{
+				if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
+				{ //connect
+					LPS_Leave(rtlpriv);
+				}
+			}
+			break;
+		case LPS_CTRL_JOINBSS:
+			//DBG_871X("LPS_CTRL_JOINBSS \n");
+			LPS_Leave(rtlpriv);
+			break;
+		case LPS_CTRL_CONNECT:
+			//DBG_871X("LPS_CTRL_CONNECT \n");
+			mstatus = 1;//connect
+			// Reset LPS Setting
+			rtlpriv->pwrctrlpriv.LpsIdleCount = 0;
+			rtlpriv->cfg->ops->set_hw_reg(rtlpriv, HW_VAR_H2C_FW_JOINBSSRPT, (uint8_t *)(&mstatus));
+			break;
+		case LPS_CTRL_DISCONNECT:
+			//DBG_871X("LPS_CTRL_DISCONNECT \n");
+			mstatus = 0;//disconnect
+			{
+				LPS_Leave(rtlpriv);
+			}
+			rtlpriv->cfg->ops->set_hw_reg(rtlpriv, HW_VAR_H2C_FW_JOINBSSRPT, (uint8_t *)(&mstatus));
+			break;
+		case LPS_CTRL_SPECIAL_PACKET:
+			//DBG_871X("LPS_CTRL_SPECIAL_PACKET \n");
+			pwrpriv->DelayLPSLastTimeStamp = jiffies;
+			{
+				LPS_Leave(rtlpriv);
+			}
+			break;
+		case LPS_CTRL_LEAVE:
+			//DBG_871X("LPS_CTRL_LEAVE \n");
+			{
+				LPS_Leave(rtlpriv);
+			}
+			break;
+
+		default:
+			break;
+	}
+
+
+}
+
+uint8_t rtw_lps_ctrl_wk_cmd(struct rtl_priv*rtlpriv, uint8_t lps_ctrl_type, uint8_t enqueue)
+{
+	struct cmd_obj	*ph2c;
+	struct drvextra_cmd_parm	*pdrvextra_cmd_parm;
+	struct cmd_priv	*pcmdpriv = &rtlpriv->cmdpriv;
+	//struct pwrctrl_priv *pwrctrlpriv = &rtlpriv->pwrctrlpriv;
+	uint8_t	res = _SUCCESS;
+
+
+
+	//if(!pwrctrlpriv->bLeisurePs)
+	//	return res;
+
+	if(enqueue)
+	{
+		ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
+		if(ph2c==NULL){
+			res= _FAIL;
+			goto exit;
+		}
+
+		pdrvextra_cmd_parm = (struct drvextra_cmd_parm*)rtw_zmalloc(sizeof(struct drvextra_cmd_parm));
+		if(pdrvextra_cmd_parm==NULL){
+			rtw_mfree(ph2c);
+			res= _FAIL;
+			goto exit;
+		}
+
+		pdrvextra_cmd_parm->ec_id = LPS_CTRL_WK_CID;
+		pdrvextra_cmd_parm->type_size = lps_ctrl_type;
+		pdrvextra_cmd_parm->pbuf = NULL;
+
+		init_h2fwcmd_w_parm_no_rsp(ph2c, pdrvextra_cmd_parm, GEN_CMD_CODE(_Set_Drv_Extra));
+
+		res = rtw_enqueue_cmd(pcmdpriv, ph2c);
+	}
+	else
+	{
+		lps_ctrl_wk_hdl(rtlpriv, lps_ctrl_type);
+	}
+
+exit:
+
+
+
+	return res;
+
+}
+
+
+#if (RATE_ADAPTIVE_SUPPORT==1)
+void rpt_timer_setting_wk_hdl(struct rtl_priv *rtlpriv, u16 minRptTime)
+{
+	rtlpriv->cfg->ops->set_hw_reg(rtlpriv, HW_VAR_RPT_TIMER_SETTING, (uint8_t *)(&minRptTime));
+}
+
+uint8_t rtw_rpt_timer_cfg_cmd(struct rtl_priv*rtlpriv, u16 minRptTime)
+{
+	struct cmd_obj		*ph2c;
+	struct drvextra_cmd_parm	*pdrvextra_cmd_parm;
+	struct cmd_priv	*pcmdpriv = &rtlpriv->cmdpriv;
+
+	uint8_t	res = _SUCCESS;
+
+
+	ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
+	if(ph2c==NULL){
+		res= _FAIL;
+		goto exit;
+	}
+
+	pdrvextra_cmd_parm = (struct drvextra_cmd_parm*)rtw_zmalloc(sizeof(struct drvextra_cmd_parm));
+	if(pdrvextra_cmd_parm==NULL){
+		rtw_mfree(ph2c);
+		res= _FAIL;
+		goto exit;
+	}
+
+	pdrvextra_cmd_parm->ec_id = RTP_TIMER_CFG_WK_CID;
+	pdrvextra_cmd_parm->type_size = minRptTime;
+	pdrvextra_cmd_parm->pbuf = NULL;
+	init_h2fwcmd_w_parm_no_rsp(ph2c, pdrvextra_cmd_parm, GEN_CMD_CODE(_Set_Drv_Extra));
+	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
+exit:
+
+
+
+	return res;
+
+}
+
+#endif
+
+
+void power_saving_wk_hdl(struct rtl_priv *rtlpriv, uint8_t *pbuf, int sz);
+void power_saving_wk_hdl(struct rtl_priv *rtlpriv, uint8_t *pbuf, int sz)
+{
+	 rtw_ps_processor(rtlpriv);
+}
+
+uint8_t rtw_ps_cmd(struct rtl_priv*rtlpriv)
+{
+	struct cmd_obj		*ppscmd;
+	struct drvextra_cmd_parm	*pdrvextra_cmd_parm;
+	struct cmd_priv	*pcmdpriv = &rtlpriv->cmdpriv;
+
+	uint8_t	res = _SUCCESS;
+
+
+
+	ppscmd = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
+	if(ppscmd==NULL){
+		res= _FAIL;
+		goto exit;
+	}
+
+	pdrvextra_cmd_parm = (struct drvextra_cmd_parm*)rtw_zmalloc(sizeof(struct drvextra_cmd_parm));
+	if(pdrvextra_cmd_parm==NULL){
+		rtw_mfree(ppscmd);
+		res= _FAIL;
+		goto exit;
+	}
+
+	pdrvextra_cmd_parm->ec_id = POWER_SAVING_CTRL_WK_CID;
+	pdrvextra_cmd_parm->pbuf = NULL;
+	init_h2fwcmd_w_parm_no_rsp(ppscmd, pdrvextra_cmd_parm, GEN_CMD_CODE(_Set_Drv_Extra));
+
+	res = rtw_enqueue_cmd(pcmdpriv, ppscmd);
+
+exit:
+
+
+
+	return res;
+
+}
+
+#ifdef CONFIG_AP_MODE
+
+static void rtw_chk_hi_queue_hdl(struct rtl_priv *rtlpriv)
+{
+	int cnt=0;
+	struct sta_info *psta_bmc;
+	struct sta_priv *pstapriv = &rtlpriv->stapriv;
+
+	psta_bmc = rtw_get_bcmc_stainfo(rtlpriv);
+	if(!psta_bmc)
+		return;
+
+	if(psta_bmc->sleepq_len==0)
+	{
+		uint8_t val = 0;
+
+		//while((rtw_read32(rtlpriv, 0x414)&0x00ffff00)!=0)
+		//while((rtw_read32(rtlpriv, 0x414)&0x0000ff00)!=0)
+
+		rtlpriv->cfg->ops->get_hw_reg(rtlpriv, HW_VAR_CHK_HI_QUEUE_EMPTY, &val);
+
+		while(false == val)
+		{
+			msleep(100);
+
+			cnt++;
+
+			if(cnt>10)
+				break;
+
+			rtlpriv->cfg->ops->get_hw_reg(rtlpriv, HW_VAR_CHK_HI_QUEUE_EMPTY, &val);
+		}
+
+		if(cnt<=10)
+		{
+			pstapriv->tim_bitmap &= ~BIT(0);
+			pstapriv->sta_dz_bitmap &= ~BIT(0);
+
+			update_beacon(rtlpriv, _TIM_IE_, NULL, false);
+		}
+		else //re check again
+		{
+			rtw_chk_hi_queue_cmd(rtlpriv);
+		}
+
+	}
+
+}
+
+uint8_t rtw_chk_hi_queue_cmd(struct rtl_priv*rtlpriv)
+{
+	struct cmd_obj	*ph2c;
+	struct drvextra_cmd_parm	*pdrvextra_cmd_parm;
+	struct cmd_priv	*pcmdpriv = &rtlpriv->cmdpriv;
+	uint8_t	res = _SUCCESS;
+
+	ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj));
+	if(ph2c==NULL){
+		res= _FAIL;
+		goto exit;
+	}
+
+	pdrvextra_cmd_parm = (struct drvextra_cmd_parm*)rtw_zmalloc(sizeof(struct drvextra_cmd_parm));
+	if(pdrvextra_cmd_parm==NULL){
+		rtw_mfree(ph2c);
+		res= _FAIL;
+		goto exit;
+	}
+
+	pdrvextra_cmd_parm->ec_id = CHECK_HIQ_WK_CID;
+	pdrvextra_cmd_parm->type_size = 0;
+	pdrvextra_cmd_parm->pbuf = NULL;
+
+	init_h2fwcmd_w_parm_no_rsp(ph2c, pdrvextra_cmd_parm, GEN_CMD_CODE(_Set_Drv_Extra));
+
+	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
+
+exit:
+
+	return res;
+
+}
+#endif
+
+uint8_t rtw_drvextra_cmd_hdl(struct rtl_priv *rtlpriv, unsigned char *pbuf)
+{
+	struct drvextra_cmd_parm *pdrvextra_cmd;
+
+	if(!pbuf)
+		return H2C_PARAMETERS_ERROR;
+
+	pdrvextra_cmd = (struct drvextra_cmd_parm*)pbuf;
+
+	switch(pdrvextra_cmd->ec_id)
+	{
+		case DYNAMIC_CHK_WK_CID:
+			dynamic_chk_wk_hdl(rtlpriv, pdrvextra_cmd->pbuf, pdrvextra_cmd->type_size);
+			break;
+		case POWER_SAVING_CTRL_WK_CID:
+			power_saving_wk_hdl(rtlpriv, pdrvextra_cmd->pbuf, pdrvextra_cmd->type_size);
+			break;
+		case LPS_CTRL_WK_CID:
+			lps_ctrl_wk_hdl(rtlpriv, (uint8_t)pdrvextra_cmd->type_size);
+			break;
+#if (RATE_ADAPTIVE_SUPPORT==1)
+		case RTP_TIMER_CFG_WK_CID:
+			rpt_timer_setting_wk_hdl(rtlpriv, pdrvextra_cmd->type_size);
+			break;
+#endif
+#ifdef CONFIG_AP_MODE
+		case CHECK_HIQ_WK_CID:
+			rtw_chk_hi_queue_hdl(rtlpriv);
+			break;
+#endif //CONFIG_AP_MODE
+		default:
+			break;
+	}
+
+	if (pdrvextra_cmd->pbuf && pdrvextra_cmd->type_size>0)
+	{
+		/* ULLI check usage of pdrvextra_cmd->type_size */
+		rtw_mfree(pdrvextra_cmd->pbuf);
+	}
+
+	return H2C_SUCCESS;
+}
+
+void rtw_survey_cmd_callback(struct rtl_priv*	rtlpriv ,  struct cmd_obj *pcmd)
+{
+	struct 	mlme_priv *pmlmepriv = &rtlpriv->mlmepriv;
+
+
+
+	if(pcmd->res == H2C_DROPPED)
+	{
+		//TODO: cancel timer and do timeout handler directly...
+		//need to make timeout handlerOS independent
+		_set_timer(&pmlmepriv->scan_to_timer, 1);
+	}
+	else if (pcmd->res != H2C_SUCCESS) {
+		_set_timer(&pmlmepriv->scan_to_timer, 1);
+	}
+
+	// free cmd
+	rtw_free_cmd_obj(pcmd);
+
+
+}
+void rtw_disassoc_cmd_callback(struct rtl_priv*	rtlpriv,  struct cmd_obj *pcmd)
+{
+	struct 	mlme_priv *pmlmepriv = &rtlpriv->mlmepriv;
+
+
+
+	if (pcmd->res != H2C_SUCCESS)
+	{
+		spin_lock_bh(&pmlmepriv->lock);
+		set_fwstate(pmlmepriv, _FW_LINKED);
+		spin_unlock_bh(&pmlmepriv->lock);
+
+		goto exit;
+	}
+
+	// free cmd
+	rtw_free_cmd_obj(pcmd);
+
+exit:
+	;
+
+}
+
+
+void rtw_joinbss_cmd_callback(struct rtl_priv*	rtlpriv,  struct cmd_obj *pcmd)
+{
+	struct 	mlme_priv *pmlmepriv = &rtlpriv->mlmepriv;
+
+
+
+	if(pcmd->res == H2C_DROPPED)
+	{
+		//TODO: cancel timer and do timeout handler directly...
+		//need to make timeout handlerOS independent
+		_set_timer(&pmlmepriv->assoc_timer, 1);
+	}
+	else if(pcmd->res != H2C_SUCCESS)
+	{
+		_set_timer(&pmlmepriv->assoc_timer, 1);
+	}
+
+	rtw_free_cmd_obj(pcmd);
+
+
+}
+
+void rtw_createbss_cmd_callback(struct rtl_priv *rtlpriv, struct cmd_obj *pcmd)
+{
+	struct sta_info *psta = NULL;
+	struct wlan_network *pwlan = NULL;
+	struct 	mlme_priv *pmlmepriv = &rtlpriv->mlmepriv;
+	WLAN_BSSID_EX *pnetwork = (WLAN_BSSID_EX *)pcmd->parmbuf;
+	struct wlan_network *tgt_network = &(pmlmepriv->cur_network);
+
+
+
+	if((pcmd->res != H2C_SUCCESS))
+	{
+		_set_timer(&pmlmepriv->assoc_timer, 1 );
+	}
+
+	del_timer_sync(&pmlmepriv->assoc_timer);
+
+#ifdef CONFIG_FW_MLMLE
+       //endian_convert
+	pnetwork->Length = le32_to_cpu(pnetwork->Length);
+  	pnetwork->Ssid.SsidLength = le32_to_cpu(pnetwork->Ssid.SsidLength);
+	pnetwork->Privacy =le32_to_cpu(pnetwork->Privacy);
+	pnetwork->Rssi = le32_to_cpu(pnetwork->Rssi);
+	pnetwork->NetworkTypeInUse =le32_to_cpu(pnetwork->NetworkTypeInUse);
+	pnetwork->Configuration.ATIMWindow = le32_to_cpu(pnetwork->Configuration.ATIMWindow);
+	//pnetwork->Configuration.BeaconPeriod = le32_to_cpu(pnetwork->Configuration.BeaconPeriod);
+	pnetwork->Configuration.DSConfig =le32_to_cpu(pnetwork->Configuration.DSConfig);
+	pnetwork->Configuration.FHConfig.DwellTime=le32_to_cpu(pnetwork->Configuration.FHConfig.DwellTime);
+	pnetwork->Configuration.FHConfig.HopPattern=le32_to_cpu(pnetwork->Configuration.FHConfig.HopPattern);
+	pnetwork->Configuration.FHConfig.HopSet=le32_to_cpu(pnetwork->Configuration.FHConfig.HopSet);
+	pnetwork->Configuration.FHConfig.Length=le32_to_cpu(pnetwork->Configuration.FHConfig.Length);
+	pnetwork->Configuration.Length = le32_to_cpu(pnetwork->Configuration.Length);
+	pnetwork->InfrastructureMode = le32_to_cpu(pnetwork->InfrastructureMode);
+	pnetwork->IELength = le32_to_cpu(pnetwork->IELength);
+#endif
+
+	spin_lock_bh(&pmlmepriv->lock);
+
+
+	if(check_fwstate(pmlmepriv, WIFI_AP_STATE) )
+	{
+		psta = rtw_get_stainfo(&rtlpriv->stapriv, pnetwork->MacAddress);
+		if(!psta)
+		{
+		psta = rtw_alloc_stainfo(&rtlpriv->stapriv, pnetwork->MacAddress);
+		if (psta == NULL)
+		{
+			goto createbss_cmd_fail ;
+		}
+		}
+
+		rtw_indicate_connect( rtlpriv);
+	}
+	else
+	{
+		pwlan = _rtw_alloc_network(pmlmepriv);
+		spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
+		if ( pwlan == NULL)
+		{
+			pwlan = rtw_get_oldest_wlan_network(&pmlmepriv->scanned_queue);
+			if( pwlan == NULL)
+			{
+				spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
+				goto createbss_cmd_fail;
+			}
+			pwlan->last_scanned = jiffies;
+		}
+		else
+		{
+			list_add_tail(&(pwlan->list), &pmlmepriv->scanned_queue.list);
+		}
+
+		pnetwork->Length = get_WLAN_BSSID_EX_sz(pnetwork);
+		memcpy(&(pwlan->network), pnetwork, pnetwork->Length);
+		//pwlan->fixed = true;
+
+		//list_add_tail(&(pwlan->list), &pmlmepriv->scanned_queue.queue);
+
+		// copy pdev_network information to 	pmlmepriv->cur_network
+		memcpy(&tgt_network->network, pnetwork, (get_WLAN_BSSID_EX_sz(pnetwork)));
+
+		// reset DSConfig
+		//tgt_network->network.Configuration.DSConfig = (uint32_t)rtw_ch2freq(pnetwork->Configuration.DSConfig);
+
+		_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);
+
+		spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
+		// we will set _FW_LINKED when there is one more sat to join us (rtw_stassoc_event_callback)
+
+	}
+
+createbss_cmd_fail:
+
+	spin_unlock_bh(&pmlmepriv->lock);
+
+	rtw_free_cmd_obj(pcmd);
+
+
+
+}
+
+
+
+void rtw_setstaKey_cmdrsp_callback(struct rtl_priv*	rtlpriv ,  struct cmd_obj *pcmd)
+{
+
+	struct sta_priv * pstapriv = &rtlpriv->stapriv;
+	struct set_stakey_rsp* psetstakey_rsp = (struct set_stakey_rsp*) (pcmd->rsp);
+	struct sta_info*	psta = rtw_get_stainfo(pstapriv, psetstakey_rsp->addr);
+
+
+
+	if(psta==NULL)
+	{
+		goto exit;
+	}
+
+	//psta->aid = psta->mac_id = psetstakey_rsp->keyid; //CAM_ID(CAM_ENTRY)
+
+exit:
+
+	rtw_free_cmd_obj(pcmd);
+
+
+
+}
+void rtw_setassocsta_cmdrsp_callback(struct rtl_priv*	rtlpriv,  struct cmd_obj *pcmd)
+{
+	struct sta_priv * pstapriv = &rtlpriv->stapriv;
+	struct mlme_priv	*pmlmepriv = &rtlpriv->mlmepriv;
+	struct set_assocsta_parm* passocsta_parm = (struct set_assocsta_parm*)(pcmd->parmbuf);
+	struct set_assocsta_rsp* passocsta_rsp = (struct set_assocsta_rsp*) (pcmd->rsp);
+	struct sta_info*	psta = rtw_get_stainfo(pstapriv, passocsta_parm->addr);
+
+
+
+	if(psta==NULL)
+	{
+		goto exit;
+	}
+
+	psta->aid = psta->mac_id = passocsta_rsp->cam_id;
+
+	spin_lock_bh(&pmlmepriv->lock);
+
+	if ((check_fwstate(pmlmepriv, WIFI_MP_STATE) == true) && (check_fwstate(pmlmepriv, _FW_UNDER_LINKING) == true))
+		_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);
+
+	set_fwstate(pmlmepriv, _FW_LINKED);
+	spin_unlock_bh(&pmlmepriv->lock);
+
+exit:
+	rtw_free_cmd_obj(pcmd);
+
+
+}
+
+void rtw_getrttbl_cmd_cmdrsp_callback(struct rtl_priv*	rtlpriv,  struct cmd_obj *pcmd);
+void rtw_getrttbl_cmd_cmdrsp_callback(struct rtl_priv*	rtlpriv,  struct cmd_obj *pcmd)
+{
+
+
+	rtw_free_cmd_obj(pcmd);
+
+
+
+}
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/core/rtw_eeprom.c linux-4.9.8821au/drivers/staging/rtl8821au/core/rtw_eeprom.c
--- linux-4.9/drivers/staging/rtl8821au/core/rtw_eeprom.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/core/rtw_eeprom.c	2016-12-11 19:48:25.150311808 -0600
@@ -0,0 +1,358 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#define _RTW_EEPROM_C_
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+
+void up_clk(struct rtl_priv *rtlpriv, u16 *x)
+{
+	*x = *x | _EESK;
+	usb_write8(rtlpriv, EE_9346CR, (uint8_t)*x);
+	rtw_udelay_os(CLOCK_RATE);
+}
+
+void down_clk(struct rtl_priv *rtlpriv, u16 *x	)
+{
+	*x = *x & ~_EESK;
+	usb_write8(rtlpriv, EE_9346CR, (uint8_t)*x);
+	rtw_udelay_os(CLOCK_RATE);
+}
+
+void shift_out_bits(struct rtl_priv *rtlpriv, u16 data, u16 count)
+{
+	u16 x,mask;
+
+	if(rtlpriv->bSurpriseRemoved==true){
+		RT_TRACE(_module_rtl871x_eeprom_c_,_drv_err_,("rtlpriv->bSurpriseRemoved==true"));
+		goto out;
+	}
+
+	mask = 0x01 << (count - 1);
+	x = usb_read8(rtlpriv, EE_9346CR);
+
+	x &= ~(_EEDO | _EEDI);
+
+	do {
+		x &= ~_EEDI;
+		if (data & mask)
+			x |= _EEDI;
+
+		if (rtlpriv->bSurpriseRemoved==true) {
+			RT_TRACE(_module_rtl871x_eeprom_c_,_drv_err_,("rtlpriv->bSurpriseRemoved==true"));
+			goto out;
+		}
+
+		usb_write8(rtlpriv, EE_9346CR, (uint8_t)x);
+		rtw_udelay_os(CLOCK_RATE);
+		up_clk(rtlpriv, &x);
+		down_clk(rtlpriv, &x);
+		mask = mask >> 1;
+	} while (mask);
+
+	if (rtlpriv->bSurpriseRemoved==true){
+		RT_TRACE(_module_rtl871x_eeprom_c_,_drv_err_,("rtlpriv->bSurpriseRemoved==true"));
+		goto out;
+	}
+
+	x &= ~_EEDI;
+	usb_write8(rtlpriv, EE_9346CR, (uint8_t)x);
+out:
+}
+
+u16 shift_in_bits (struct rtl_priv *rtlpriv)
+{
+	u16 x,d=0,i;
+
+	if (rtlpriv->bSurpriseRemoved == true) {
+		RT_TRACE(_module_rtl871x_eeprom_c_,_drv_err_,("rtlpriv->bSurpriseRemoved==true"));
+		goto out;
+	}
+	x = usb_read8(rtlpriv, EE_9346CR);
+
+	x &= ~( _EEDO | _EEDI);
+	d = 0;
+
+	for(i = 0; i < 16; i++) {
+		d = d << 1;
+		up_clk(rtlpriv, &x);
+		if(rtlpriv->bSurpriseRemoved == true) {
+			RT_TRACE(_module_rtl871x_eeprom_c_,_drv_err_,("rtlpriv->bSurpriseRemoved==true"));
+			goto out;
+		}
+
+		x = usb_read8(rtlpriv, EE_9346CR);
+
+		x &= ~(_EEDI);
+		if(x & _EEDO)
+		d |= 1;
+
+		down_clk(rtlpriv, &x);
+	}
+out:
+	return d;
+}
+
+void standby(struct rtl_priv *rtlpriv)
+{
+	uint8_t   x;
+
+	x = usb_read8(rtlpriv, EE_9346CR);
+
+	x &= ~(_EECS | _EESK);
+	usb_write8(rtlpriv, EE_9346CR,x);
+
+	rtw_udelay_os(CLOCK_RATE);
+	x |= _EECS;
+	usb_write8(rtlpriv, EE_9346CR, x);
+	rtw_udelay_os(CLOCK_RATE);
+}
+
+u16 wait_eeprom_cmd_done(struct rtl_priv* rtlpriv)
+{
+	uint8_t 	x;
+	u16	i,res=false;
+
+	standby(rtlpriv );
+
+	for (i = 0; i < 200; i++) {
+		x = usb_read8(rtlpriv, EE_9346CR);
+		if (x & _EEDO){
+			res=true;
+			goto exit;
+			}
+		rtw_udelay_os(CLOCK_RATE);
+	}
+exit:
+
+	return res;
+}
+
+void eeprom_clean(struct rtl_priv *rtlpriv)
+{
+	u16 x;
+
+	if (rtlpriv->bSurpriseRemoved == true) {
+		RT_TRACE(_module_rtl871x_eeprom_c_,_drv_err_,("rtlpriv->bSurpriseRemoved==true"));
+		goto out;
+	}
+	x = usb_read8(rtlpriv, EE_9346CR);
+	if (rtlpriv->bSurpriseRemoved == true) {
+		RT_TRACE(_module_rtl871x_eeprom_c_,_drv_err_,("rtlpriv->bSurpriseRemoved==true"));
+		goto out;
+	}
+	x &= ~(_EECS | _EEDI);
+	usb_write8(rtlpriv, EE_9346CR, (uint8_t)x);
+
+	if (rtlpriv->bSurpriseRemoved == true) {
+		RT_TRACE(_module_rtl871x_eeprom_c_,_drv_err_,("rtlpriv->bSurpriseRemoved==true"));
+		goto out;
+	}
+
+	up_clk(rtlpriv, &x);
+	if (rtlpriv->bSurpriseRemoved == true) {
+		RT_TRACE(_module_rtl871x_eeprom_c_,_drv_err_,("rtlpriv->bSurpriseRemoved==true"));
+		goto out;
+	}
+	down_clk(rtlpriv, &x);
+out:
+
+}
+
+void eeprom_write16(struct rtl_priv * rtlpriv, u16 reg, u16 data)
+{
+	uint8_t x;
+
+	x = usb_read8(rtlpriv, EE_9346CR);
+
+	x &= ~(_EEDI | _EEDO | _EESK | _EEM0);
+	x |= _EEM1 | _EECS;
+	usb_write8(rtlpriv, EE_9346CR, x);
+
+	shift_out_bits(rtlpriv, EEPROM_EWEN_OPCODE, 5);
+
+	if (rtlpriv->EepromAddressSize==8)	//CF+ and SDIO
+		shift_out_bits(rtlpriv, 0, 6);
+	else									//USB
+		shift_out_bits(rtlpriv, 0, 4);
+
+	standby( rtlpriv);
+
+// Commented out by rcnjko, 2004.0
+//	// Erase this particular word.  Write the erase opcode and register
+//	// number in that order. The opcode is 3bits in length; reg is 6 bits long.
+//	shift_out_bits(rtlpriv, EEPROM_ERASE_OPCODE, 3);
+//	shift_out_bits(rtlpriv, reg, rtlpriv->EepromAddressSize);
+//
+//	if (wait_eeprom_cmd_done(rtlpriv ) == false)
+//	{
+//		return;
+//	}
+
+
+	standby(rtlpriv );
+
+	// write the new word to the EEPROM
+
+	// send the write opcode the EEPORM
+	shift_out_bits(rtlpriv, EEPROM_WRITE_OPCODE, 3);
+
+	// select which word in the EEPROM that we are writing to.
+	shift_out_bits(rtlpriv, reg, rtlpriv->EepromAddressSize);
+
+	// write the data to the selected EEPROM word.
+	shift_out_bits(rtlpriv, data, 16);
+
+	if (wait_eeprom_cmd_done(rtlpriv ) == false) {
+		goto exit;
+	}
+
+	standby(rtlpriv );
+
+	shift_out_bits(rtlpriv, EEPROM_EWDS_OPCODE, 5);
+	shift_out_bits(rtlpriv, reg, 4);
+
+	eeprom_clean(rtlpriv );
+exit:
+
+	return;
+}
+
+u16 eeprom_read16(struct rtl_priv * rtlpriv, u16 reg) //ReadEEprom
+{
+
+	u16 x;
+	u16 data=0;
+
+	if (rtlpriv->bSurpriseRemoved == true) {
+		RT_TRACE(_module_rtl871x_eeprom_c_,_drv_err_,("rtlpriv->bSurpriseRemoved==true"));
+		goto out;
+	}
+	// select EEPROM, reset bits, set _EECS
+	x = usb_read8(rtlpriv, EE_9346CR);
+
+	if (rtlpriv->bSurpriseRemoved == true) {
+		RT_TRACE(_module_rtl871x_eeprom_c_,_drv_err_,("rtlpriv->bSurpriseRemoved==true"));
+		goto out;
+	}
+
+	x &= ~(_EEDI | _EEDO | _EESK | _EEM0);
+	x |= _EEM1 | _EECS;
+
+	usb_write8(rtlpriv, EE_9346CR, (unsigned char)x);
+
+	// write the read opcode and register number in that order
+	// The opcode is 3bits in length, reg is 6 bits long
+
+	shift_out_bits(rtlpriv, EEPROM_READ_OPCODE, 3);
+	shift_out_bits(rtlpriv, reg, rtlpriv->EepromAddressSize);
+
+	// Now read the data (16 bits) in from the selected EEPROM word
+	data = shift_in_bits(rtlpriv);
+
+	eeprom_clean(rtlpriv);
+out:
+
+	return data;
+}
+
+
+
+
+//From even offset
+void eeprom_read_sz(struct rtl_priv * rtlpriv, u16 reg, uint8_t * data, uint32_t	 sz)
+{
+
+	u16 x, data16;
+	uint32_t	 i;
+
+	if (rtlpriv->bSurpriseRemoved == true) {
+		RT_TRACE(_module_rtl871x_eeprom_c_,_drv_err_,("rtlpriv->bSurpriseRemoved==true"));
+		goto out;
+	}
+	// select EEPROM, reset bits, set _EECS
+	x = usb_read8(rtlpriv, EE_9346CR);
+
+	if (rtlpriv->bSurpriseRemoved == true) {
+		RT_TRACE(_module_rtl871x_eeprom_c_,_drv_err_,("rtlpriv->bSurpriseRemoved==true"));
+		goto out;
+	}
+
+	x &= ~(_EEDI | _EEDO | _EESK | _EEM0);
+	x |= _EEM1 | _EECS;
+	usb_write8(rtlpriv, EE_9346CR, (unsigned char)x);
+
+	// write the read opcode and register number in that order
+	// The opcode is 3bits in length, reg is 6 bits long
+	shift_out_bits(rtlpriv, EEPROM_READ_OPCODE, 3);
+	shift_out_bits(rtlpriv, reg, rtlpriv->EepromAddressSize);
+
+
+	for (i = 0; i < sz; i += 2) {
+		data16 = shift_in_bits(rtlpriv);
+		data[i] = data16 & 0xff;
+		data[i+1] = data16 >>8;
+	}
+
+	eeprom_clean(rtlpriv);
+out:
+}
+
+
+//addr_off : address offset of the entry in eeprom (not the tuple number of eeprom (reg); that is addr_off !=reg)
+uint8_t eeprom_read(struct rtl_priv *rtlpriv, uint32_t	addr_off, uint8_t sz, uint8_t * rbuf)
+{
+	uint8_t quotient, remainder, addr_2align_odd;
+	u16 reg, stmp , i=0, idx = 0;
+
+	reg = (u16)(addr_off >> 1);
+	addr_2align_odd = (uint8_t)(addr_off & 0x1);
+
+	if(addr_2align_odd) { /* read that start at high part: e.g  1,3,5,7,9,... */
+		stmp = eeprom_read16(rtlpriv, reg);
+		rbuf[idx++] = (uint8_t) ((stmp>>8)&0xff); //return hogh-part of the short
+		reg++; sz--;
+	}
+
+	quotient = sz >> 1;
+	remainder = sz & 0x1;
+
+	for (i = 0 ; i < quotient; i++) {
+		stmp = eeprom_read16(rtlpriv, reg+i);
+		rbuf[idx++] = (uint8_t) (stmp&0xff);
+		rbuf[idx++] = (uint8_t) ((stmp>>8)&0xff);
+	}
+
+	reg = reg+i;
+	if(remainder){ //end of read at lower part of short : 0,2,4,6,...
+		stmp = eeprom_read16(rtlpriv, reg);
+		rbuf[idx] = (uint8_t)(stmp & 0xff);
+	}
+
+	return true;
+}
+
+
+
+void read_eeprom_content(struct rtl_priv *rtlpriv)
+{
+}
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/core/rtw_ieee80211.c linux-4.9.8821au/drivers/staging/rtl8821au/core/rtw_ieee80211.c
--- linux-4.9/drivers/staging/rtl8821au/core/rtw_ieee80211.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/core/rtw_ieee80211.c	2016-12-11 19:48:25.150311808 -0600
@@ -0,0 +1,1565 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#define _IEEE80211_C
+
+#include <drv_types.h>
+
+#undef DBG_871X
+static inline void DBG_871X(const char *fmt, ...)
+{
+}
+
+
+uint8_t RTW_WPA_OUI_TYPE[] = { 0x00, 0x50, 0xf2, 1 };
+u16 RTW_WPA_VERSION = 1;
+uint8_t WPA_AUTH_KEY_MGMT_NONE[] = { 0x00, 0x50, 0xf2, 0 };
+uint8_t WPA_AUTH_KEY_MGMT_UNSPEC_802_1X[] = { 0x00, 0x50, 0xf2, 1 };
+uint8_t WPA_AUTH_KEY_MGMT_PSK_OVER_802_1X[] = { 0x00, 0x50, 0xf2, 2 };
+uint8_t WPA_CIPHER_SUITE_NONE[] = { 0x00, 0x50, 0xf2, 0 };
+uint8_t WPA_CIPHER_SUITE_WEP40[] = { 0x00, 0x50, 0xf2, 1 };
+uint8_t WPA_CIPHER_SUITE_TKIP[] = { 0x00, 0x50, 0xf2, 2 };
+uint8_t WPA_CIPHER_SUITE_WRAP[] = { 0x00, 0x50, 0xf2, 3 };
+uint8_t WPA_CIPHER_SUITE_CCMP[] = { 0x00, 0x50, 0xf2, 4 };
+uint8_t WPA_CIPHER_SUITE_WEP104[] = { 0x00, 0x50, 0xf2, 5 };
+
+uint8_t RSN_AUTH_KEY_MGMT_UNSPEC_802_1X[] = { 0x00, 0x0f, 0xac, 1 };
+uint8_t RSN_AUTH_KEY_MGMT_PSK_OVER_802_1X[] = { 0x00, 0x0f, 0xac, 2 };
+uint8_t RSN_CIPHER_SUITE_NONE[] = { 0x00, 0x0f, 0xac, 0 };
+uint8_t RSN_CIPHER_SUITE_WEP40[] = { 0x00, 0x0f, 0xac, 1 };
+uint8_t RSN_CIPHER_SUITE_TKIP[] = { 0x00, 0x0f, 0xac, 2 };
+uint8_t RSN_CIPHER_SUITE_WRAP[] = { 0x00, 0x0f, 0xac, 3 };
+uint8_t RSN_CIPHER_SUITE_CCMP[] = { 0x00, 0x0f, 0xac, 4 };
+uint8_t RSN_CIPHER_SUITE_WEP104[] = { 0x00, 0x0f, 0xac, 5 };
+//-----------------------------------------------------------
+// for adhoc-master to generate ie and provide supported-rate to fw
+//-----------------------------------------------------------
+
+static uint8_t 	WIFI_CCKRATES[] =
+{(IEEE80211_CCK_RATE_1MB | IEEE80211_BASIC_RATE_MASK),
+ (IEEE80211_CCK_RATE_2MB | IEEE80211_BASIC_RATE_MASK),
+ (IEEE80211_CCK_RATE_5MB | IEEE80211_BASIC_RATE_MASK),
+ (IEEE80211_CCK_RATE_11MB | IEEE80211_BASIC_RATE_MASK)};
+
+static uint8_t 	WIFI_OFDMRATES[] =
+{(IEEE80211_OFDM_RATE_6MB),
+ (IEEE80211_OFDM_RATE_9MB),
+ (IEEE80211_OFDM_RATE_12MB),
+ (IEEE80211_OFDM_RATE_18MB),
+ (IEEE80211_OFDM_RATE_24MB),
+ IEEE80211_OFDM_RATE_36MB,
+ IEEE80211_OFDM_RATE_48MB,
+ IEEE80211_OFDM_RATE_54MB};
+
+
+int rtw_get_bit_value_from_ieee_value(uint8_t val)
+{
+	unsigned char dot11_rate_table[]={2,4,11,22,12,18,24,36,48,72,96,108,0}; // last element must be zero!!
+
+	int i=0;
+	while(dot11_rate_table[i] != 0) {
+		if (dot11_rate_table[i] == val)
+			return BIT(i);
+		i++;
+	}
+	return 0;
+}
+
+uint	rtw_is_cckrates_included(uint8_t *rate)
+{
+		uint32_t	i = 0;
+
+		while(rate[i]!=0)
+		{
+			if  (  (((rate[i]) & 0x7f) == 2)	|| (((rate[i]) & 0x7f) == 4) ||
+			(((rate[i]) & 0x7f) == 11)  || (((rate[i]) & 0x7f) == 22) )
+			return true;
+			i++;
+		}
+
+		return false;
+}
+
+uint	rtw_is_cckratesonly_included(uint8_t *rate)
+{
+	uint32_t	 i = 0;
+
+
+	while(rate[i]!=0)
+	{
+			if  (  (((rate[i]) & 0x7f) != 2) && (((rate[i]) & 0x7f) != 4) &&
+				(((rate[i]) & 0x7f) != 11)  && (((rate[i]) & 0x7f) != 22) )
+
+			return false;
+
+			i++;
+	}
+
+	return true;
+
+}
+
+int rtw_check_network_type(unsigned char *rate, int ratelen, int channel)
+{
+	if (channel > 14)
+	{
+		if ((rtw_is_cckrates_included(rate)) == true)
+			return WIRELESS_INVALID;
+		else
+			return WIRELESS_11A;
+	}
+	else  // could be pure B, pure G, or B/G
+	{
+		if ((rtw_is_cckratesonly_included(rate)) == true)
+			return WIRELESS_11B;
+		else if((rtw_is_cckrates_included(rate)) == true)
+			return 	WIRELESS_11BG;
+		else
+			return WIRELESS_11G;
+	}
+
+}
+
+uint8_t *rtw_set_fixed_ie(unsigned char *pbuf, unsigned int len, unsigned char *source,
+				unsigned int *frlen)
+{
+	memcpy((void *)pbuf, (void *)source, len);
+	*frlen = *frlen + len;
+	return (pbuf + len);
+}
+
+// rtw_set_ie will update frame length
+uint8_t *rtw_set_ie
+(
+	uint8_t *pbuf,
+	int index,
+	uint len,
+	uint8_t *source,
+	uint *frlen //frame length
+)
+{
+
+	*pbuf = (uint8_t)index;
+
+	*(pbuf + 1) = (uint8_t)len;
+
+	if (len > 0)
+		memcpy((void *)(pbuf + 2), (void *)source, len);
+
+	*frlen = *frlen + (len + 2);
+
+	return (pbuf + len + 2);
+
+}
+
+inline uint8_t *rtw_set_ie_ch_switch(uint8_t *buf, uint32_t	 *buf_len, uint8_t ch_switch_mode,
+	uint8_t new_ch, uint8_t ch_switch_cnt)
+{
+	uint8_t ie_data[3];
+
+	ie_data[0] = ch_switch_mode;
+	ie_data[1] = new_ch;
+	ie_data[2] = ch_switch_cnt;
+	return rtw_set_ie(buf, WLAN_EID_CHANNEL_SWITCH,  3, ie_data, buf_len);
+}
+
+inline uint8_t secondary_ch_offset_to_hal_ch_offset(uint8_t ch_offset)
+{
+	if (ch_offset == SCN)
+		return HAL_PRIME_CHNL_OFFSET_DONT_CARE;
+	else if(ch_offset == SCA)
+		return HAL_PRIME_CHNL_OFFSET_UPPER;
+	else if(ch_offset == SCB)
+		return HAL_PRIME_CHNL_OFFSET_LOWER;
+
+	return HAL_PRIME_CHNL_OFFSET_DONT_CARE;
+}
+
+inline uint8_t hal_ch_offset_to_secondary_ch_offset(uint8_t ch_offset)
+{
+	if (ch_offset == HAL_PRIME_CHNL_OFFSET_DONT_CARE)
+		return SCN;
+	else if(ch_offset == HAL_PRIME_CHNL_OFFSET_LOWER)
+		return SCB;
+	else if(ch_offset == HAL_PRIME_CHNL_OFFSET_UPPER)
+		return SCA;
+
+	return SCN;
+}
+
+inline uint8_t *rtw_set_ie_secondary_ch_offset(uint8_t *buf, uint32_t	 *buf_len, uint8_t secondary_ch_offset)
+{
+	return rtw_set_ie(buf, WLAN_EID_SECONDARY_CHANNEL_OFFSET,  1, &secondary_ch_offset, buf_len);
+}
+
+inline uint8_t *rtw_set_ie_mesh_ch_switch_parm(uint8_t *buf, uint32_t	 *buf_len, uint8_t ttl,
+	uint8_t flags, u16 reason, u16 precedence)
+{
+	uint8_t ie_data[6];
+
+	ie_data[0] = ttl;
+	ie_data[1] = flags;
+	RTW_PUT_LE16((uint8_t *)&ie_data[2], reason);
+	RTW_PUT_LE16((uint8_t *)&ie_data[4], precedence);
+
+	return rtw_set_ie(buf, 0x118,  6, ie_data, buf_len);
+}
+
+/*----------------------------------------------------------------------------
+index: the information element id index, limit is the limit for search
+-----------------------------------------------------------------------------*/
+uint8_t *rtw_get_ie(uint8_t *pbuf, int index, int *len, int limit)
+{
+	int tmp,i;
+	uint8_t *p;
+
+	if (limit < 1){
+		
+		return NULL;
+	}
+
+	p = pbuf;
+	i = 0;
+	*len = 0;
+	while(1)
+	{
+		if (*p == index)
+		{
+			*len = *(p + 1);
+			return (p);
+		}
+		else
+		{
+			tmp = *(p + 1);
+			p += (tmp + 2);
+			i += (tmp + 2);
+		}
+		if (i >= limit)
+			break;
+	}
+
+	return NULL;
+}
+
+/**
+ * rtw_get_ie_ex - Search specific IE from a series of IEs
+ * @in_ie: Address of IEs to search
+ * @in_len: Length limit from in_ie
+ * @eid: Element ID to match
+ * @oui: OUI to match
+ * @oui_len: OUI length
+ * @ie: If not NULL and the specific IE is found, the IE will be copied to the buf starting from the specific IE
+ * @ielen: If not NULL and the specific IE is found, will set to the length of the entire IE
+ *
+ * Returns: The address of the specific IE found, or NULL
+ */
+uint8_t *rtw_get_ie_ex(uint8_t *in_ie, uint in_len, uint8_t eid, uint8_t *oui, uint8_t oui_len, uint8_t *ie, uint *ielen)
+{
+	uint cnt;
+	uint8_t *target_ie = NULL;
+
+
+	if(ielen)
+		*ielen = 0;
+
+	if(!in_ie || in_len<=0)
+		return target_ie;
+
+	cnt = 0;
+
+	while(cnt<in_len)
+	{
+		if(eid == in_ie[cnt]
+			&& ( !oui || _rtw_memcmp(&in_ie[cnt+2], oui, oui_len) == true))
+		{
+			target_ie = &in_ie[cnt];
+
+			if(ie)
+				memcpy(ie, &in_ie[cnt], in_ie[cnt+1]+2);
+
+			if(ielen)
+				*ielen = in_ie[cnt+1]+2;
+
+			break;
+		}
+		else
+		{
+			cnt+=in_ie[cnt+1]+2; //goto next
+		}
+
+	}
+
+	return target_ie;
+}
+
+/**
+ * rtw_ies_remove_ie - Find matching IEs and remove
+ * @ies: Address of IEs to search
+ * @ies_len: Pointer of length of ies, will update to new length
+ * @offset: The offset to start scarch
+ * @eid: Element ID to match
+ * @oui: OUI to match
+ * @oui_len: OUI length
+ *
+ * Returns: _SUCCESS: ies is updated, _FAIL: not updated
+ */
+int rtw_ies_remove_ie(uint8_t *ies, uint *ies_len, uint offset, uint8_t eid, uint8_t *oui, uint8_t oui_len)
+{
+	int ret = _FAIL;
+	uint8_t *target_ie;
+	uint32_t	 target_ielen;
+	uint8_t *start;
+	uint search_len;
+
+	if(!ies || !ies_len || *ies_len <= offset)
+		goto exit;
+
+	start = ies + offset;
+	search_len = *ies_len - offset;
+
+	while (1) {
+		target_ie = rtw_get_ie_ex(start, search_len, eid, oui, oui_len, NULL, &target_ielen);
+		if (target_ie && target_ielen) {
+			uint8_t buf[MAX_IE_SZ] = {0};
+			uint8_t *remain_ies = target_ie + target_ielen;
+			uint remain_len = search_len - (remain_ies - start);
+
+			memcpy(buf, remain_ies, remain_len);
+			memcpy(target_ie, buf, remain_len);
+			*ies_len = *ies_len - target_ielen;
+			ret = _SUCCESS;
+
+			start = target_ie;
+			search_len = remain_len;
+		} else {
+			break;
+		}
+	}
+exit:
+	return ret;
+}
+
+void rtw_set_supported_rate(uint8_t * SupportedRates, uint mode)
+{
+
+
+	memset(SupportedRates, 0, NDIS_802_11_LENGTH_RATES_EX);
+
+	switch (mode)
+	{
+		case WIRELESS_11B:
+			memcpy(SupportedRates, WIFI_CCKRATES, IEEE80211_CCK_RATE_LEN);
+			break;
+
+		case WIRELESS_11G:
+		case WIRELESS_11A:
+		case WIRELESS_11_5N:
+		case WIRELESS_11A_5N://Todo: no basic rate for ofdm ?
+		case WIRELESS_11_5AC:
+			memcpy(SupportedRates, WIFI_OFDMRATES, IEEE80211_NUM_OFDM_RATESLEN);
+			break;
+
+		case WIRELESS_11BG:
+		case WIRELESS_11G_24N:
+		case WIRELESS_11_24N:
+		case WIRELESS_11BG_24N:
+			memcpy(SupportedRates, WIFI_CCKRATES, IEEE80211_CCK_RATE_LEN);
+			memcpy(SupportedRates + IEEE80211_CCK_RATE_LEN, WIFI_OFDMRATES, IEEE80211_NUM_OFDM_RATESLEN);
+			break;
+
+	}
+
+}
+
+uint	rtw_get_rateset_len(uint8_t	*rateset)
+{
+	uint i = 0;
+
+	while(1)
+	{
+		if ((rateset[i]) == 0)
+			break;
+
+		if (i > 12)
+			break;
+
+		i++;
+	}
+
+	return i;
+}
+
+int rtw_generate_ie(struct registry_priv *pregistrypriv)
+{
+	uint8_t	wireless_mode;
+	int 	sz = 0, rateLen;
+	WLAN_BSSID_EX*	pdev_network = &pregistrypriv->dev_network;
+	uint8_t *	ie = pdev_network->IEs;
+
+
+
+	//timestamp will be inserted by hardware
+	sz += 8;
+	ie += sz;
+
+	//beacon interval : 2bytes
+	*(u16 *)ie = cpu_to_le16((u16)pdev_network->Configuration.BeaconPeriod);//BCN_INTERVAL;
+	sz += 2;
+	ie += 2;
+
+	//capability info
+	*(u16 *)ie = 0;
+
+	*(u16 *)ie |= cpu_to_le16(cap_IBSS);
+
+	if(pregistrypriv->preamble == PREAMBLE_SHORT)
+		*(u16 *)ie |= cpu_to_le16(cap_ShortPremble);
+
+	if (pdev_network->Privacy)
+		*(u16 *)ie |= cpu_to_le16(cap_Privacy);
+
+	sz += 2;
+	ie += 2;
+
+	//SSID
+	ie = rtw_set_ie(ie, _SSID_IE_, pdev_network->Ssid.SsidLength, pdev_network->Ssid.Ssid, &sz);
+
+	//supported rates
+	if(WIRELESS_MODE_MAX == WIRELESS_11ABGN) {
+		if(pdev_network->Configuration.DSConfig > 14)
+			wireless_mode = WIRELESS_11A_5N;
+		else
+			wireless_mode = WIRELESS_11BG_24N;
+	} else {
+		wireless_mode = WIRELESS_MODE_MAX;
+	}
+
+	rtw_set_supported_rate(pdev_network->SupportedRates, wireless_mode) ;
+
+	rateLen = rtw_get_rateset_len(pdev_network->SupportedRates);
+
+	if (rateLen > 8)
+	{
+		ie = rtw_set_ie(ie, _SUPPORTEDRATES_IE_, 8, pdev_network->SupportedRates, &sz);
+		//ie = rtw_set_ie(ie, _EXT_SUPPORTEDRATES_IE_, (rateLen - 8), (pdev_network->SupportedRates + 8), &sz);
+	}
+	else
+	{
+		ie = rtw_set_ie(ie, _SUPPORTEDRATES_IE_, rateLen, pdev_network->SupportedRates, &sz);
+	}
+
+	//DS parameter set
+	ie = rtw_set_ie(ie, _DSSET_IE_, 1, (uint8_t *)&(pdev_network->Configuration.DSConfig), &sz);
+
+
+	//IBSS Parameter Set
+
+	ie = rtw_set_ie(ie, _IBSS_PARA_IE_, 2, (uint8_t *)&(pdev_network->Configuration.ATIMWindow), &sz);
+
+	if (rateLen > 8)
+	{
+		ie = rtw_set_ie(ie, _EXT_SUPPORTEDRATES_IE_, (rateLen - 8), (pdev_network->SupportedRates + 8), &sz);
+	}
+
+	//HT Cap.
+	if(((WIRELESS_MODE_MAX & WIRELESS_11_5N) || (WIRELESS_MODE_MAX & WIRELESS_11_24N)))
+	{
+		//todo:
+	}
+
+	//pdev_network->IELength =  sz; //update IELength
+
+
+
+	//return _SUCCESS;
+
+	return sz;
+
+}
+
+unsigned char *rtw_get_wpa_ie(unsigned char *pie, int *wpa_ie_len, int limit)
+{
+	int len;
+	u16 val16;
+	unsigned char wpa_oui_type[] = {0x00, 0x50, 0xf2, 0x01};
+	uint8_t *pbuf = pie;
+	int limit_new = limit;
+
+	while(1)
+	{
+		pbuf = rtw_get_ie(pbuf, _WPA_IE_ID_, &len, limit_new);
+
+		if (pbuf) {
+
+			//check if oui matches...
+			if (_rtw_memcmp((pbuf + 2), wpa_oui_type, sizeof (wpa_oui_type)) == false) {
+
+				goto check_next_ie;
+			}
+
+			//check version...
+			memcpy((uint8_t *)&val16, (pbuf + 6), sizeof(val16));
+
+			val16 = le16_to_cpu(val16);
+			if (val16 != 0x0001)
+				goto check_next_ie;
+
+			*wpa_ie_len = *(pbuf + 1);
+
+			return pbuf;
+
+		}
+		else {
+
+			*wpa_ie_len = 0;
+			return NULL;
+		}
+
+check_next_ie:
+
+		limit_new = limit - (pbuf - pie) - 2 - len;
+
+		if (limit_new <= 0)
+			break;
+
+		pbuf += (2 + len);
+
+	}
+
+	*wpa_ie_len = 0;
+
+	return NULL;
+
+}
+
+unsigned char *rtw_get_wpa2_ie(unsigned char *pie, int *rsn_ie_len, int limit)
+{
+
+	return rtw_get_ie(pie, _WPA2_IE_ID_,rsn_ie_len, limit);
+
+}
+
+int rtw_get_wpa_cipher_suite(uint8_t *s)
+{
+	if (_rtw_memcmp(s, WPA_CIPHER_SUITE_NONE, WPA_SELECTOR_LEN) == true)
+		return WPA_CIPHER_NONE;
+	if (_rtw_memcmp(s, WPA_CIPHER_SUITE_WEP40, WPA_SELECTOR_LEN) == true)
+		return WPA_CIPHER_WEP40;
+	if (_rtw_memcmp(s, WPA_CIPHER_SUITE_TKIP, WPA_SELECTOR_LEN) == true)
+		return WPA_CIPHER_TKIP;
+	if (_rtw_memcmp(s, WPA_CIPHER_SUITE_CCMP, WPA_SELECTOR_LEN) == true)
+		return WPA_CIPHER_CCMP;
+	if (_rtw_memcmp(s, WPA_CIPHER_SUITE_WEP104, WPA_SELECTOR_LEN) == true)
+		return WPA_CIPHER_WEP104;
+
+	return 0;
+}
+
+int rtw_get_wpa2_cipher_suite(uint8_t *s)
+{
+	if (_rtw_memcmp(s, RSN_CIPHER_SUITE_NONE, RSN_SELECTOR_LEN) == true)
+		return WPA_CIPHER_NONE;
+	if (_rtw_memcmp(s, RSN_CIPHER_SUITE_WEP40, RSN_SELECTOR_LEN) == true)
+		return WPA_CIPHER_WEP40;
+	if (_rtw_memcmp(s, RSN_CIPHER_SUITE_TKIP, RSN_SELECTOR_LEN) == true)
+		return WPA_CIPHER_TKIP;
+	if (_rtw_memcmp(s, RSN_CIPHER_SUITE_CCMP, RSN_SELECTOR_LEN) == true)
+		return WPA_CIPHER_CCMP;
+	if (_rtw_memcmp(s, RSN_CIPHER_SUITE_WEP104, RSN_SELECTOR_LEN) == true)
+		return WPA_CIPHER_WEP104;
+
+	return 0;
+}
+
+
+int rtw_parse_wpa_ie(uint8_t * wpa_ie, int wpa_ie_len, int *group_cipher, int *pairwise_cipher, int *is_8021x)
+{
+	int i, ret=_SUCCESS;
+	int left, count;
+	uint8_t *pos;
+	uint8_t SUITE_1X[4] = {0x00, 0x50, 0xf2, 1};
+
+	if (wpa_ie_len <= 0) {
+		/* No WPA IE - fail silently */
+		return _FAIL;
+	}
+
+
+	if ((*wpa_ie != _WPA_IE_ID_) || (*(wpa_ie+1) != (uint8_t)(wpa_ie_len - 2)) ||
+	   (_rtw_memcmp(wpa_ie+2, RTW_WPA_OUI_TYPE, WPA_SELECTOR_LEN) != true) )
+	{
+		return _FAIL;
+	}
+
+	pos = wpa_ie;
+
+	pos += 8;
+	left = wpa_ie_len - 8;
+
+
+	//group_cipher
+	if (left >= WPA_SELECTOR_LEN) {
+
+		*group_cipher = rtw_get_wpa_cipher_suite(pos);
+
+		pos += WPA_SELECTOR_LEN;
+		left -= WPA_SELECTOR_LEN;
+
+	}
+	else if (left > 0)
+	{
+		return _FAIL;
+	}
+
+
+	//pairwise_cipher
+	if (left >= 2)
+	{
+                //count = le16_to_cpu(*(u16 *)pos);
+		count = RTW_GET_LE16(pos);
+		pos += 2;
+		left -= 2;
+
+		if (count == 0 || left < count * WPA_SELECTOR_LEN) {
+			return _FAIL;
+		}
+
+		for (i = 0; i < count; i++)
+		{
+			*pairwise_cipher |= rtw_get_wpa_cipher_suite(pos);
+
+			pos += WPA_SELECTOR_LEN;
+			left -= WPA_SELECTOR_LEN;
+		}
+
+	}
+	else if (left == 1)
+	{
+		return _FAIL;
+	}
+
+	if (is_8021x) {
+		if (left >= 6) {
+			pos += 2;
+			if (_rtw_memcmp(pos, SUITE_1X, 4) == 1) {
+				*is_8021x = 1;
+			}
+		}
+	}
+
+	return ret;
+
+}
+
+int rtw_parse_wpa2_ie(uint8_t * rsn_ie, int rsn_ie_len, int *group_cipher, int *pairwise_cipher, int *is_8021x)
+{
+	int i, ret=_SUCCESS;
+	int left, count;
+	uint8_t *pos;
+	uint8_t SUITE_1X[4] = {0x00,0x0f, 0xac, 0x01};
+
+	if (rsn_ie_len <= 0) {
+		/* No RSN IE - fail silently */
+		return _FAIL;
+	}
+
+
+	if ((*rsn_ie!= _WPA2_IE_ID_) || (*(rsn_ie+1) != (uint8_t)(rsn_ie_len - 2)))
+	{
+		return _FAIL;
+	}
+
+	pos = rsn_ie;
+	pos += 4;
+	left = rsn_ie_len - 4;
+
+	//group_cipher
+	if (left >= RSN_SELECTOR_LEN) {
+
+		*group_cipher = rtw_get_wpa2_cipher_suite(pos);
+
+		pos += RSN_SELECTOR_LEN;
+		left -= RSN_SELECTOR_LEN;
+
+	} else if (left > 0) {
+		return _FAIL;
+	}
+
+	//pairwise_cipher
+	if (left >= 2)
+	{
+	        //count = le16_to_cpu(*(u16 *)pos);
+		count = RTW_GET_LE16(pos);
+		pos += 2;
+		left -= 2;
+
+		if (count == 0 || left < count * RSN_SELECTOR_LEN) {
+			return _FAIL;
+		}
+
+		for (i = 0; i < count; i++)
+		{
+			*pairwise_cipher |= rtw_get_wpa2_cipher_suite(pos);
+
+			pos += RSN_SELECTOR_LEN;
+			left -= RSN_SELECTOR_LEN;
+		}
+
+	}
+	else if (left == 1)
+	{
+		return _FAIL;
+	}
+
+	if (is_8021x) {
+		if (left >= 6) {
+			pos += 2;
+			if (_rtw_memcmp(pos, SUITE_1X, 4) == 1) {
+				*is_8021x = 1;
+			}
+		}
+	}
+
+	return ret;
+
+}
+
+int rtw_get_sec_ie(uint8_t *in_ie,uint in_len,uint8_t *rsn_ie,u16 *rsn_len,uint8_t *wpa_ie,u16 *wpa_len)
+{
+	uint8_t authmode, sec_idx, i;
+	uint8_t wpa_oui[4]={0x0,0x50,0xf2,0x01};
+	uint 	cnt;
+
+
+
+	//Search required WPA or WPA2 IE and copy to sec_ie[ ]
+
+	cnt = (_TIMESTAMP_ + _BEACON_ITERVAL_ + _CAPABILITY_);
+
+	sec_idx=0;
+
+	while(cnt<in_len)
+	{
+		authmode=in_ie[cnt];
+
+		if((authmode==_WPA_IE_ID_)&&(_rtw_memcmp(&in_ie[cnt+2], &wpa_oui[0],4)==true))
+		{
+				if (wpa_ie) {
+				memcpy(wpa_ie, &in_ie[cnt],in_ie[cnt+1]+2);
+
+				for(i=0;i<(in_ie[cnt+1]+2);i=i+8){
+					}
+				}
+
+				*wpa_len=in_ie[cnt+1]+2;
+				cnt+=in_ie[cnt+1]+2;  //get next
+		}
+		else
+		{
+			if(authmode==_WPA2_IE_ID_)
+			{
+				if (rsn_ie) {
+				memcpy(rsn_ie, &in_ie[cnt],in_ie[cnt+1]+2);
+
+				for(i=0;i<(in_ie[cnt+1]+2);i=i+8){
+					}
+				}
+
+				*rsn_len=in_ie[cnt+1]+2;
+				cnt+=in_ie[cnt+1]+2;  //get next
+			}
+			else
+			{
+				cnt+=in_ie[cnt+1]+2;   //get next
+			}
+		}
+
+	}
+
+
+
+	return (*rsn_len+*wpa_len);
+
+}
+
+uint8_t rtw_is_wps_ie(uint8_t *ie_ptr, uint *wps_ielen)
+{
+	uint8_t match = false;
+	uint8_t eid, wps_oui[4]={0x0,0x50,0xf2,0x04};
+
+	if(ie_ptr == NULL) return match;
+
+	eid = ie_ptr[0];
+
+	if((eid==_WPA_IE_ID_)&&(_rtw_memcmp(&ie_ptr[2], wps_oui, 4)==true))
+	{
+		//DBG_8192C("==> found WPS_IE.....\n");
+		*wps_ielen = ie_ptr[1]+2;
+		match=true;
+	}
+	return match;
+}
+
+/**
+ * rtw_get_wps_ie - Search WPS IE from a series of IEs
+ * @in_ie: Address of IEs to search
+ * @in_len: Length limit from in_ie
+ * @wps_ie: If not NULL and WPS IE is found, WPS IE will be copied to the buf starting from wps_ie
+ * @wps_ielen: If not NULL and WPS IE is found, will set to the length of the entire WPS IE
+ *
+ * Returns: The address of the WPS IE found, or NULL
+ */
+uint8_t *rtw_get_wps_ie(uint8_t *in_ie, uint in_len, uint8_t *wps_ie, uint *wps_ielen)
+{
+	uint cnt;
+	uint8_t *wpsie_ptr=NULL;
+	uint8_t eid, wps_oui[4]={0x0,0x50,0xf2,0x04};
+
+	if(wps_ielen)
+		*wps_ielen = 0;
+
+	if(!in_ie || in_len<=0)
+		return wpsie_ptr;
+
+	cnt = 0;
+
+	while(cnt<in_len)
+	{
+		eid = in_ie[cnt];
+
+		if((eid==_WPA_IE_ID_)&&(_rtw_memcmp(&in_ie[cnt+2], wps_oui, 4)==true))
+		{
+			wpsie_ptr = &in_ie[cnt];
+
+			if(wps_ie)
+				memcpy(wps_ie, &in_ie[cnt], in_ie[cnt+1]+2);
+
+			if(wps_ielen)
+				*wps_ielen = in_ie[cnt+1]+2;
+
+			cnt+=in_ie[cnt+1]+2;
+
+			break;
+		}
+		else
+		{
+			cnt+=in_ie[cnt+1]+2; //goto next
+		}
+
+	}
+
+	return wpsie_ptr;
+}
+
+/**
+ * rtw_get_wps_attr - Search a specific WPS attribute from a given WPS IE
+ * @wps_ie: Address of WPS IE to search
+ * @wps_ielen: Length limit from wps_ie
+ * @target_attr_id: The attribute ID of WPS attribute to search
+ * @buf_attr: If not NULL and the WPS attribute is found, WPS attribute will be copied to the buf starting from buf_attr
+ * @len_attr: If not NULL and the WPS attribute is found, will set to the length of the entire WPS attribute
+ *
+ * Returns: the address of the specific WPS attribute found, or NULL
+ */
+uint8_t *rtw_get_wps_attr(uint8_t *wps_ie, uint wps_ielen, u16 target_attr_id ,uint8_t *buf_attr, uint32_t	 *len_attr)
+{
+	uint8_t *attr_ptr = NULL;
+	uint8_t * target_attr_ptr = NULL;
+	uint8_t wps_oui[4]={0x00,0x50,0xF2,0x04};
+
+	if(len_attr)
+		*len_attr = 0;
+
+	if ( ( wps_ie[0] != _VENDOR_SPECIFIC_IE_ ) ||
+		( _rtw_memcmp( wps_ie + 2, wps_oui , 4 ) != true ) )
+	{
+		return attr_ptr;
+	}
+
+	// 6 = 1(Element ID) + 1(Length) + 4(WPS OUI)
+	attr_ptr = wps_ie + 6; //goto first attr
+
+	while(attr_ptr - wps_ie < wps_ielen)
+	{
+		// 4 = 2(Attribute ID) + 2(Length)
+		u16 attr_id = RTW_GET_BE16(attr_ptr);
+		u16 attr_data_len = RTW_GET_BE16(attr_ptr + 2);
+		u16 attr_len = attr_data_len + 4;
+
+		//DBG_871X("%s attr_ptr:%p, id:%u, length:%u\n", __FUNCTION__, attr_ptr, attr_id, attr_data_len);
+		if( attr_id == target_attr_id )
+		{
+			target_attr_ptr = attr_ptr;
+
+			if(buf_attr)
+				memcpy(buf_attr, attr_ptr, attr_len);
+
+			if(len_attr)
+				*len_attr = attr_len;
+
+			break;
+		}
+		else
+		{
+			attr_ptr += attr_len; //goto next
+		}
+
+	}
+
+	return target_attr_ptr;
+}
+
+/**
+ * rtw_get_wps_attr_content - Search a specific WPS attribute content from a given WPS IE
+ * @wps_ie: Address of WPS IE to search
+ * @wps_ielen: Length limit from wps_ie
+ * @target_attr_id: The attribute ID of WPS attribute to search
+ * @buf_content: If not NULL and the WPS attribute is found, WPS attribute content will be copied to the buf starting from buf_content
+ * @len_content: If not NULL and the WPS attribute is found, will set to the length of the WPS attribute content
+ *
+ * Returns: the address of the specific WPS attribute content found, or NULL
+ */
+uint8_t *rtw_get_wps_attr_content(uint8_t *wps_ie, uint wps_ielen, u16 target_attr_id ,uint8_t *buf_content, uint *len_content)
+{
+	uint8_t *attr_ptr;
+	uint32_t	 attr_len;
+
+	if(len_content)
+		*len_content = 0;
+
+	attr_ptr = rtw_get_wps_attr(wps_ie, wps_ielen, target_attr_id, NULL, &attr_len);
+
+	if(attr_ptr && attr_len)
+	{
+		if(buf_content)
+			memcpy(buf_content, attr_ptr+4, attr_len-4);
+
+		if(len_content)
+			*len_content = attr_len-4;
+
+		return attr_ptr+4;
+	}
+
+	return NULL;
+}
+
+static int rtw_ieee802_11_parse_vendor_specific(uint8_t *pos, uint elen,
+					    struct rtw_ieee802_11_elems *elems,
+					    int show_errors)
+{
+	unsigned int oui;
+
+	/* first 3 bytes in vendor specific information element are the IEEE
+	 * OUI of the vendor. The following byte is used a vendor specific
+	 * sub-type. */
+	if (elen < 4) {
+		if (show_errors) {
+			DBG_871X("short vendor specific "
+				   "information element ignored (len=%lu)\n",
+				   (unsigned long) elen);
+		}
+		return -1;
+	}
+
+	oui = RTW_GET_BE24(pos);
+	switch (oui) {
+	case OUI_MICROSOFT:
+		/* Microsoft/Wi-Fi information elements are further typed and
+		 * subtyped */
+		switch (pos[3]) {
+		case 1:
+			/* Microsoft OUI (00:50:F2) with OUI Type 1:
+			 * real WPA information element */
+			elems->wpa_ie = pos;
+			elems->wpa_ie_len = elen;
+			break;
+		case WME_OUI_TYPE: /* this is a Wi-Fi WME info. element */
+			if (elen < 5) {
+				DBG_871X("short WME "
+					   "information element ignored "
+					   "(len=%lu)\n",
+					   (unsigned long) elen);
+				return -1;
+			}
+			switch (pos[4]) {
+			case WME_OUI_SUBTYPE_INFORMATION_ELEMENT:
+			case WME_OUI_SUBTYPE_PARAMETER_ELEMENT:
+				elems->wme = pos;
+				elems->wme_len = elen;
+				break;
+			case WME_OUI_SUBTYPE_TSPEC_ELEMENT:
+				elems->wme_tspec = pos;
+				elems->wme_tspec_len = elen;
+				break;
+			default:
+				DBG_871X("unknown WME "
+					   "information element ignored "
+					   "(subtype=%d len=%lu)\n",
+					   pos[4], (unsigned long) elen);
+				return -1;
+			}
+			break;
+		case 4:
+			/* Wi-Fi Protected Setup (WPS) IE */
+			elems->wps_ie = pos;
+			elems->wps_ie_len = elen;
+			break;
+		default:
+			DBG_871X("Unknown Microsoft "
+				   "information element ignored "
+				   "(type=%d len=%lu)\n",
+				   pos[3], (unsigned long) elen);
+			return -1;
+		}
+		break;
+
+	case OUI_BROADCOM:
+		switch (pos[3]) {
+		case VENDOR_HT_CAPAB_OUI_TYPE:
+			elems->vendor_ht_cap = pos;
+			elems->vendor_ht_cap_len = elen;
+			break;
+		default:
+			DBG_871X("Unknown Broadcom "
+				   "information element ignored "
+				   "(type=%d len=%lu)\n",
+				   pos[3], (unsigned long) elen);
+			return -1;
+		}
+		break;
+
+	default:
+		DBG_871X("unknown vendor specific information "
+			   "element ignored (vendor OUI %02x:%02x:%02x "
+			   "len=%lu)\n",
+			   pos[0], pos[1], pos[2], (unsigned long) elen);
+		return -1;
+	}
+
+	return 0;
+
+}
+
+/**
+ * ieee802_11_parse_elems - Parse information elements in management frames
+ * @start: Pointer to the start of IEs
+ * @len: Length of IE buffer in octets
+ * @elems: Data structure for parsed elements
+ * @show_errors: Whether to show parsing errors in debug log
+ * Returns: Parsing result
+ */
+ParseRes rtw_ieee802_11_parse_elems(uint8_t *start, uint len,
+				struct rtw_ieee802_11_elems *elems,
+				int show_errors)
+{
+	uint left = len;
+	uint8_t *pos = start;
+	int unknown = 0;
+
+	memset(elems, 0, sizeof(*elems));
+
+	while (left >= 2) {
+		uint8_t id, elen;
+
+		id = *pos++;
+		elen = *pos++;
+		left -= 2;
+
+		if (elen > left) {
+			if (show_errors) {
+				DBG_871X("IEEE 802.11 element "
+					   "parse failed (id=%d elen=%d "
+					   "left=%lu)\n",
+					   id, elen, (unsigned long) left);
+			}
+			return ParseFailed;
+		}
+
+		switch (id) {
+		case WLAN_EID_SSID:
+			elems->ssid = pos;
+			elems->ssid_len = elen;
+			break;
+		case WLAN_EID_SUPP_RATES:
+			elems->supp_rates = pos;
+			elems->supp_rates_len = elen;
+			break;
+		case WLAN_EID_FH_PARAMS:
+			elems->fh_params = pos;
+			elems->fh_params_len = elen;
+			break;
+		case WLAN_EID_DS_PARAMS:
+			elems->ds_params = pos;
+			elems->ds_params_len = elen;
+			break;
+		case WLAN_EID_CF_PARAMS:
+			elems->cf_params = pos;
+			elems->cf_params_len = elen;
+			break;
+		case WLAN_EID_TIM:
+			elems->tim = pos;
+			elems->tim_len = elen;
+			break;
+		case WLAN_EID_IBSS_PARAMS:
+			elems->ibss_params = pos;
+			elems->ibss_params_len = elen;
+			break;
+		case WLAN_EID_CHALLENGE:
+			elems->challenge = pos;
+			elems->challenge_len = elen;
+			break;
+		case WLAN_EID_ERP_INFO:
+			elems->erp_info = pos;
+			elems->erp_info_len = elen;
+			break;
+		case WLAN_EID_EXT_SUPP_RATES:
+			elems->ext_supp_rates = pos;
+			elems->ext_supp_rates_len = elen;
+			break;
+		case WLAN_EID_VENDOR_SPECIFIC:
+			if (rtw_ieee802_11_parse_vendor_specific(pos, elen,
+							     elems,
+							     show_errors))
+				unknown++;
+			break;
+		case WLAN_EID_RSN:
+			elems->rsn_ie = pos;
+			elems->rsn_ie_len = elen;
+			break;
+		case WLAN_EID_PWR_CAPABILITY:
+			elems->power_cap = pos;
+			elems->power_cap_len = elen;
+			break;
+		case WLAN_EID_SUPPORTED_CHANNELS:
+			elems->supp_channels = pos;
+			elems->supp_channels_len = elen;
+			break;
+		case WLAN_EID_MOBILITY_DOMAIN:
+			elems->mdie = pos;
+			elems->mdie_len = elen;
+			break;
+		case WLAN_EID_FAST_BSS_TRANSITION:
+			elems->ftie = pos;
+			elems->ftie_len = elen;
+			break;
+		case WLAN_EID_TIMEOUT_INTERVAL:
+			elems->timeout_int = pos;
+			elems->timeout_int_len = elen;
+			break;
+		case WLAN_EID_HT_CAP:
+			elems->ht_capabilities = pos;
+			elems->ht_capabilities_len = elen;
+			break;
+		case WLAN_EID_HT_OPERATION:
+			elems->ht_operation = pos;
+			elems->ht_operation_len = elen;
+			break;
+		case WLAN_EID_VHT_CAPABILITY:
+			elems->vht_capabilities = pos;
+			elems->vht_capabilities_len = elen;
+			break;
+		case WLAN_EID_VHT_OPERATION:
+			elems->vht_operation = pos;
+			elems->vht_operation_len = elen;
+			break;
+		case WLAN_EID_VHT_OP_MODE_NOTIFY:
+			elems->vht_op_mode_notify = pos;
+			elems->vht_op_mode_notify_len = elen;
+			break;
+		default:
+			unknown++;
+			if (!show_errors)
+				break;
+			DBG_871X("IEEE 802.11 element parse "
+				   "ignored unknown element (id=%d elen=%d)\n",
+				   id, elen);
+			break;
+		}
+
+		left -= elen;
+		pos += elen;
+	}
+
+	if (left)
+		return ParseFailed;
+
+	return unknown ? ParseUnknown : ParseOK;
+
+}
+
+static uint8_t key_char2num(uint8_t ch);
+static uint8_t key_char2num(uint8_t ch)
+{
+    if((ch>='0')&&(ch<='9'))
+        return ch - '0';
+    else if ((ch>='a')&&(ch<='f'))
+        return ch - 'a' + 10;
+    else if ((ch>='A')&&(ch<='F'))
+        return ch - 'A' + 10;
+    else
+	 return 0xff;
+}
+
+uint8_t str_2char2num(uint8_t hch, uint8_t lch);
+uint8_t str_2char2num(uint8_t hch, uint8_t lch)
+{
+    return ((key_char2num(hch) * 10 ) + key_char2num(lch));
+}
+
+uint8_t key_2char2num(uint8_t hch, uint8_t lch);
+uint8_t key_2char2num(uint8_t hch, uint8_t lch)
+{
+    return ((key_char2num(hch) << 4) | key_char2num(lch));
+}
+
+uint8_t convert_ip_addr(uint8_t hch, uint8_t mch, uint8_t lch)
+{
+    return ((key_char2num(hch) * 100) + (key_char2num(mch) * 10 ) + key_char2num(lch));
+}
+
+extern char* __rtw_initmac;
+void rtw_macaddr_cfg(uint8_t *mac_addr)
+{
+	uint8_t mac[ETH_ALEN];
+	if(mac_addr == NULL)	return;
+
+	if ( __rtw_initmac )
+	{	//	Users specify the mac address
+		int jj,kk;
+
+		for( jj = 0, kk = 0; jj < ETH_ALEN; jj++, kk += 3 )
+		{
+			mac[jj] = key_2char2num(__rtw_initmac[kk], __rtw_initmac[kk+ 1]);
+		}
+		memcpy(mac_addr, mac, ETH_ALEN);
+	}
+	else
+	{	//	Use the mac address stored in the Efuse
+		memcpy(mac, mac_addr, ETH_ALEN);
+	}
+
+	if (((mac[0]==0xff) &&(mac[1]==0xff) && (mac[2]==0xff) &&
+	     (mac[3]==0xff) && (mac[4]==0xff) &&(mac[5]==0xff)) ||
+	    ((mac[0]==0x0) && (mac[1]==0x0) && (mac[2]==0x0) &&
+	     (mac[3]==0x0) && (mac[4]==0x0) &&(mac[5]==0x0)))
+	{
+		mac[0] = 0x00;
+		mac[1] = 0xe0;
+		mac[2] = 0x4c;
+		mac[3] = 0x87;
+		mac[4] = 0x00;
+		mac[5] = 0x00;
+		// use default mac addresss
+		memcpy(mac_addr, mac, ETH_ALEN);
+		DBG_871X("MAC Address from efuse error, assign default one !!!\n");
+	}
+
+	DBG_871X("rtw_macaddr_cfg MAC Address  = "MAC_FMT"\n", MAC_ARG(mac_addr));
+}
+
+void dump_ies(uint8_t *buf, uint32_t	 buf_len) {
+	uint8_t * pos = (uint8_t *)buf;
+	uint8_t id, len;
+
+	while(pos-buf<=buf_len){
+		id = *pos;
+		len = *(pos+1);
+
+		DBG_871X("%s ID:%u, LEN:%u\n", __FUNCTION__, id, len);
+		dump_wps_ie(pos, len);
+
+		pos+=(2+len);
+	}
+}
+
+void dump_wps_ie(uint8_t *ie, uint32_t	 ie_len) {
+	uint8_t * pos = (uint8_t *)ie;
+	u16 id;
+	u16 len;
+
+	uint8_t *wps_ie;
+	uint wps_ielen;
+
+	wps_ie = rtw_get_wps_ie(ie, ie_len, NULL, &wps_ielen);
+	if(wps_ie != ie || wps_ielen == 0)
+		return;
+
+	pos+=6;
+	while(pos-ie < ie_len){
+		id = RTW_GET_BE16(pos);
+		len = RTW_GET_BE16(pos + 2);
+
+		DBG_871X("%s ID:0x%04x, LEN:%u\n", __FUNCTION__, id, len);
+
+		pos+=(4+len);
+	}
+}
+
+//Baron adds to avoid FreeBSD warning
+int ieee80211_is_empty_essid(const char *essid, int essid_len)
+{
+	/* Single white space is for Linksys APs */
+	if (essid_len == 1 && essid[0] == ' ')
+		return 1;
+
+	/* Otherwise, if the entire essid is 0, we assume it is hidden */
+	while (essid_len) {
+		essid_len--;
+		if (essid[essid_len] != '\0')
+			return 0;
+	}
+
+	return 1;
+}
+
+int ieee80211_get_hdrlen(u16 fc)
+{
+	int hdrlen = 24;
+
+	switch (WLAN_FC_GET_TYPE(fc)) {
+	case RTW_IEEE80211_FTYPE_DATA:
+		if (fc & RTW_IEEE80211_STYPE_QOS_DATA)
+			hdrlen += 2;
+		if ((fc & RTW_IEEE80211_FCTL_FROMDS) && (fc & RTW_IEEE80211_FCTL_TODS))
+			hdrlen += 6; /* Addr4 */
+		break;
+	case RTW_IEEE80211_FTYPE_CTL:
+		switch (WLAN_FC_GET_STYPE(fc)) {
+		case RTW_IEEE80211_STYPE_CTS:
+		case RTW_IEEE80211_STYPE_ACK:
+			hdrlen = 10;
+			break;
+		default:
+			hdrlen = 16;
+			break;
+		}
+		break;
+	}
+
+	return hdrlen;
+}
+
+int rtw_get_cipher_info(struct wlan_network *pnetwork)
+{
+	uint32_t	 wpa_ielen;
+	unsigned char *pbuf;
+	int group_cipher = 0, pairwise_cipher = 0, is8021x = 0;
+	int ret = _FAIL;
+	pbuf = rtw_get_wpa_ie(&pnetwork->network.IEs[12], &wpa_ielen, pnetwork->network.IELength-12);
+
+	if(pbuf && (wpa_ielen>0)) {
+		if (_SUCCESS == rtw_parse_wpa_ie(pbuf, wpa_ielen+2, &group_cipher, &pairwise_cipher, &is8021x)) {
+			pnetwork->BcnInfo.pairwise_cipher = pairwise_cipher;
+			pnetwork->BcnInfo.group_cipher = group_cipher;
+			pnetwork->BcnInfo.is_8021x = is8021x;
+			ret = _SUCCESS;
+		}
+	} else {
+
+		pbuf = rtw_get_wpa2_ie(&pnetwork->network.IEs[12], &wpa_ielen, pnetwork->network.IELength-12);
+
+		if(pbuf && (wpa_ielen>0)) {
+			if (_SUCCESS == rtw_parse_wpa2_ie(pbuf, wpa_ielen+2, &group_cipher, &pairwise_cipher, &is8021x)) {
+				pnetwork->BcnInfo.pairwise_cipher = pairwise_cipher;
+				pnetwork->BcnInfo.group_cipher = group_cipher;
+				pnetwork->BcnInfo.is_8021x = is8021x;
+				ret = _SUCCESS;
+			}
+		}
+	}
+
+	return ret;
+}
+
+void rtw_get_bcn_info(struct wlan_network *pnetwork)
+{
+	unsigned short cap = 0;
+	uint8_t bencrypt = 0;
+	//uint8_t wpa_ie[255],rsn_ie[255];
+	u16 wpa_len=0,rsn_len=0;
+	struct HT_info_element *pht_info = NULL;
+	struct rtw_ieee80211_ht_cap *pht_cap = NULL;
+	unsigned int		len;
+	unsigned char		*p;
+
+	memcpy((uint8_t *)&cap, rtw_get_capability_from_ie(pnetwork->network.IEs), 2);
+	cap = le16_to_cpu(cap);
+	if (cap & WLAN_CAPABILITY_PRIVACY) {
+		bencrypt = 1;
+		pnetwork->network.Privacy = 1;
+	} else {
+		pnetwork->BcnInfo.encryp_protocol = ENCRYP_PROTOCOL_OPENSYS;
+	}
+	rtw_get_sec_ie(pnetwork->network.IEs ,pnetwork->network.IELength,NULL,&rsn_len,NULL,&wpa_len);
+
+	if (rsn_len > 0) {
+		pnetwork->BcnInfo.encryp_protocol = ENCRYP_PROTOCOL_WPA2;
+	} else if (wpa_len > 0) {
+		pnetwork->BcnInfo.encryp_protocol = ENCRYP_PROTOCOL_WPA;
+	} else {
+		if (bencrypt)
+			pnetwork->BcnInfo.encryp_protocol = ENCRYP_PROTOCOL_WEP;
+	}
+	rtw_get_cipher_info(pnetwork);
+
+	/* get bwmode and ch_offset */
+	/* parsing HT_CAP_IE */
+	p = rtw_get_ie(pnetwork->network.IEs + _FIXED_IE_LENGTH_, _HT_CAPABILITY_IE_, &len, pnetwork->network.IELength - _FIXED_IE_LENGTH_);
+	if(p && len>0) {
+			pht_cap = (struct rtw_ieee80211_ht_cap *)(p + 2);
+			pnetwork->BcnInfo.ht_cap_info = pht_cap->cap_info;
+	} else {
+			pnetwork->BcnInfo.ht_cap_info = 0;
+	}
+	/* parsing HT_INFO_IE */
+	p = rtw_get_ie(pnetwork->network.IEs + _FIXED_IE_LENGTH_, _HT_ADD_INFO_IE_, &len, pnetwork->network.IELength - _FIXED_IE_LENGTH_);
+	if(p && len>0) {
+			pht_info = (struct HT_info_element *)(p + 2);
+			pnetwork->BcnInfo.ht_info_infos_0 = pht_info->infos[0];
+	} else {
+			pnetwork->BcnInfo.ht_info_infos_0 = 0;
+	}
+}
+
+//show MCS rate, unit: 100Kbps
+u16 rtw_mcs_rate(uint8_t rf_type, uint8_t bw_40MHz, uint8_t short_GI_20, uint8_t short_GI_40, unsigned char * MCS_rate)
+{
+	u16 max_rate = 0;
+
+	if(rf_type == RF_1T1R)
+	{
+		if(MCS_rate[0] & BIT(7))
+			max_rate = (bw_40MHz) ? ((short_GI_40)?1500:1350):((short_GI_20)?722:650);
+		else if(MCS_rate[0] & BIT(6))
+			max_rate = (bw_40MHz) ? ((short_GI_40)?1350:1215):((short_GI_20)?650:585);
+		else if(MCS_rate[0] & BIT(5))
+			max_rate = (bw_40MHz) ? ((short_GI_40)?1200:1080):((short_GI_20)?578:520);
+		else if(MCS_rate[0] & BIT(4))
+			max_rate = (bw_40MHz) ? ((short_GI_40)?900:810):((short_GI_20)?433:390);
+		else if(MCS_rate[0] & BIT(3))
+			max_rate = (bw_40MHz) ? ((short_GI_40)?600:540):((short_GI_20)?289:260);
+		else if(MCS_rate[0] & BIT(2))
+			max_rate = (bw_40MHz) ? ((short_GI_40)?450:405):((short_GI_20)?217:195);
+		else if(MCS_rate[0] & BIT(1))
+			max_rate = (bw_40MHz) ? ((short_GI_40)?300:270):((short_GI_20)?144:130);
+		else if(MCS_rate[0] & BIT(0))
+			max_rate = (bw_40MHz) ? ((short_GI_40)?150:135):((short_GI_20)?72:65);
+	}
+	else
+	{
+		if(MCS_rate[1])
+		{
+			if(MCS_rate[1] & BIT(7))
+				max_rate = (bw_40MHz) ? ((short_GI_40)?3000:2700):((short_GI_20)?1444:1300);
+			else if(MCS_rate[1] & BIT(6))
+				max_rate = (bw_40MHz) ? ((short_GI_40)?2700:2430):((short_GI_20)?1300:1170);
+			else if(MCS_rate[1] & BIT(5))
+				max_rate = (bw_40MHz) ? ((short_GI_40)?2400:2160):((short_GI_20)?1156:1040);
+			else if(MCS_rate[1] & BIT(4))
+				max_rate = (bw_40MHz) ? ((short_GI_40)?1800:1620):((short_GI_20)?867:780);
+			else if(MCS_rate[1] & BIT(3))
+				max_rate = (bw_40MHz) ? ((short_GI_40)?1200:1080):((short_GI_20)?578:520);
+			else if(MCS_rate[1] & BIT(2))
+				max_rate = (bw_40MHz) ? ((short_GI_40)?900:810):((short_GI_20)?433:390);
+			else if(MCS_rate[1] & BIT(1))
+				max_rate = (bw_40MHz) ? ((short_GI_40)?600:540):((short_GI_20)?289:260);
+			else if(MCS_rate[1] & BIT(0))
+				max_rate = (bw_40MHz) ? ((short_GI_40)?300:270):((short_GI_20)?144:130);
+		}
+		else
+		{
+			if(MCS_rate[0] & BIT(7))
+				max_rate = (bw_40MHz) ? ((short_GI_40)?1500:1350):((short_GI_20)?722:650);
+			else if(MCS_rate[0] & BIT(6))
+				max_rate = (bw_40MHz) ? ((short_GI_40)?1350:1215):((short_GI_20)?650:585);
+			else if(MCS_rate[0] & BIT(5))
+				max_rate = (bw_40MHz) ? ((short_GI_40)?1200:1080):((short_GI_20)?578:520);
+			else if(MCS_rate[0] & BIT(4))
+				max_rate = (bw_40MHz) ? ((short_GI_40)?900:810):((short_GI_20)?433:390);
+			else if(MCS_rate[0] & BIT(3))
+				max_rate = (bw_40MHz) ? ((short_GI_40)?600:540):((short_GI_20)?289:260);
+			else if(MCS_rate[0] & BIT(2))
+				max_rate = (bw_40MHz) ? ((short_GI_40)?450:405):((short_GI_20)?217:195);
+			else if(MCS_rate[0] & BIT(1))
+				max_rate = (bw_40MHz) ? ((short_GI_40)?300:270):((short_GI_20)?144:130);
+			else if(MCS_rate[0] & BIT(0))
+				max_rate = (bw_40MHz) ? ((short_GI_40)?150:135):((short_GI_20)?72:65);
+		}
+	}
+	return max_rate;
+}
+
+int rtw_action_frame_parse(const uint8_t *frame, uint32_t	 frame_len, uint8_t * category, uint8_t *action)
+{
+	const uint8_t *frame_body = frame + sizeof(struct rtw_ieee80211_hdr_3addr);
+	u16 fc;
+	uint8_t c, a;
+
+	fc = le16_to_cpu(((struct rtw_ieee80211_hdr_3addr *)frame)->frame_ctl);
+
+	if ((fc & (RTW_IEEE80211_FCTL_FTYPE|RTW_IEEE80211_FCTL_STYPE))
+		!= (RTW_IEEE80211_FTYPE_MGMT|RTW_IEEE80211_STYPE_ACTION)
+	)
+	{
+		return false;
+	}
+
+	c = frame_body[0];
+
+	switch(c) {
+	case RTW_WLAN_CATEGORY_P2P: /* vendor-specific */
+		break;
+	default:
+		a = frame_body[1];
+	}
+
+	if (category)
+		*category = c;
+	if (action)
+		*action = a;
+
+	return true;
+}
+
+static const char *_action_public_str[] = {
+	"ACT_PUB_BSSCOEXIST",
+	"ACT_PUB_DSE_ENABLE",
+	"ACT_PUB_DSE_DEENABLE",
+	"ACT_PUB_DSE_REG_LOCATION",
+	"ACT_PUB_EXT_CHL_SWITCH",
+	"ACT_PUB_DSE_MSR_REQ",
+	"ACT_PUB_DSE_MSR_RPRT",
+	"ACT_PUB_MP",
+	"ACT_PUB_DSE_PWR_CONSTRAINT",
+	"ACT_PUB_VENDOR",
+	"ACT_PUB_GAS_INITIAL_REQ",
+	"ACT_PUB_GAS_INITIAL_RSP",
+	"ACT_PUB_GAS_COMEBACK_REQ",
+	"ACT_PUB_GAS_COMEBACK_RSP",
+	"ACT_PUB_TDLS_DISCOVERY_RSP",
+	"ACT_PUB_LOCATION_TRACK",
+	"ACT_PUB_RSVD",
+};
+
+const char *action_public_str(uint8_t action)
+{
+	action = (action >= ACT_PUBLIC_MAX) ? ACT_PUBLIC_MAX : action;
+	return _action_public_str[action];
+}
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/core/rtw_ioctl_set.c linux-4.9.8821au/drivers/staging/rtl8821au/core/rtw_ioctl_set.c
--- linux-4.9/drivers/staging/rtl8821au/core/rtw_ioctl_set.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/core/rtw_ioctl_set.c	2016-12-11 19:48:25.150311808 -0600
@@ -0,0 +1,1089 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#define _RTW_IOCTL_SET_C_
+
+#include <drv_types.h>
+#include <rtw_ap.h>
+
+#undef DBG_871X
+static inline void DBG_871X(const char *fmt, ...)
+{
+}
+
+#define _drv_always_		1
+#undef DBG_871X_LEVEL
+static inline void DBG_871X_LEVEL(const int level, const char *fmt, ...)
+{
+}
+
+extern void indicate_wx_scan_complete_event(struct rtl_priv *rtlpriv);
+
+#define IS_MAC_ADDRESS_BROADCAST(addr) \
+( \
+	( (addr[0] == 0xff) && (addr[1] == 0xff) && \
+		(addr[2] == 0xff) && (addr[3] == 0xff) && \
+		(addr[4] == 0xff) && (addr[5] == 0xff) )  ? true : false \
+)
+
+uint8_t rtw_validate_ssid(NDIS_802_11_SSID *ssid)
+{
+	uint8_t	 i;
+	uint8_t	ret=true;
+
+
+
+	if (ssid->SsidLength > 32) {
+		ret= false;
+		goto exit;
+	}
+
+	for(i = 0; i < ssid->SsidLength; i++)
+	{
+		//wifi, printable ascii code must be supported
+		if(!( (ssid->Ssid[i] >= 0x20) && (ssid->Ssid[i] <= 0x7e) )){
+			ret= false;
+			break;
+		}
+	}
+
+exit:
+
+
+
+	return ret;
+}
+
+static inline struct list_head *get_next(struct list_head	*list)
+{
+	return list->next;
+}
+
+uint8_t rtw_do_join(struct rtl_priv * rtlpriv);
+uint8_t rtw_do_join(struct rtl_priv * rtlpriv)
+{
+	struct list_head	*plist, *phead;
+	uint8_t * pibss = NULL;
+	struct	mlme_priv	*pmlmepriv = &(rtlpriv->mlmepriv);
+	struct __queue	*queue	= &(pmlmepriv->scanned_queue);
+	uint8_t ret=_SUCCESS;
+
+
+
+	spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
+	phead = get_list_head(queue);
+	plist = get_next(phead);
+
+	pmlmepriv->cur_network.join_res = -2;
+
+	set_fwstate(pmlmepriv, _FW_UNDER_LINKING);
+
+	pmlmepriv->pscanned = plist;
+
+	pmlmepriv->to_join = true;
+
+	if(list_empty(&queue->list)) {
+		spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
+		_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);
+
+		//when set_ssid/set_bssid for rtw_do_join(), but scanning queue is empty
+		//we try to issue sitesurvey firstly
+
+		if (pmlmepriv->LinkDetectInfo.bBusyTraffic ==false)
+		{
+			// submit site_survey_cmd
+			if(_SUCCESS!=(ret=rtw_sitesurvey_cmd(rtlpriv, &pmlmepriv->assoc_ssid, 1, NULL, 0)) ) {
+				pmlmepriv->to_join = false;
+			}
+		}
+		else
+		{
+			pmlmepriv->to_join = false;
+			ret = _FAIL;
+		}
+
+		goto exit;
+	}
+	else
+	{
+		int select_ret;
+		spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
+		if((select_ret=rtw_select_and_join_from_scanned_queue(pmlmepriv))==_SUCCESS)
+		{
+			pmlmepriv->to_join = false;
+			_set_timer(&pmlmepriv->assoc_timer, MAX_JOIN_TIMEOUT);
+		}
+		else
+		{
+			if(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)==true)
+			{
+				// submit createbss_cmd to change to a ADHOC_MASTER
+
+ 				//pmlmepriv->lock has been acquired by caller...
+				WLAN_BSSID_EX    *pdev_network = &(rtlpriv->registrypriv.dev_network);
+
+				pmlmepriv->fw_state = WIFI_ADHOC_MASTER_STATE;
+
+				pibss = rtlpriv->registrypriv.dev_network.MacAddress;
+
+				memset(&pdev_network->Ssid, 0, sizeof(NDIS_802_11_SSID));
+				memcpy(&pdev_network->Ssid, &pmlmepriv->assoc_ssid, sizeof(NDIS_802_11_SSID));
+
+				rtw_update_registrypriv_dev_network(rtlpriv);
+
+				rtw_generate_random_ibss(pibss);
+
+				if(rtw_createbss_cmd(rtlpriv)!=_SUCCESS)
+				{
+					ret =  false;
+					goto exit;
+				}
+
+			     	pmlmepriv->to_join = false;
+
+			}
+			else
+			{
+				// can't associate ; reset under-linking
+				_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);
+
+#if 0
+				if((check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true))
+				{
+					if(_rtw_memcmp(pmlmepriv->cur_network.network.Ssid.Ssid, pmlmepriv->assoc_ssid.Ssid, pmlmepriv->assoc_ssid.SsidLength))
+					{
+						// for funk to do roaming
+						// funk will reconnect, but funk will not sitesurvey before reconnect
+						if(pmlmepriv->sitesurveyctrl.traffic_busy==false)
+							rtw_sitesurvey_cmd(rtlpriv, &pmlmepriv->assoc_ssid, 1, NULL, 0);
+					}
+
+				}
+#endif
+
+				//when set_ssid/set_bssid for rtw_do_join(), but there are no desired bss in scanning queue
+				//we try to issue sitesurvey firstly
+				if(pmlmepriv->LinkDetectInfo.bBusyTraffic==false)
+				{
+					//DBG_871X("rtw_do_join() when   no desired bss in scanning queue \n");
+					if( _SUCCESS!=(ret=rtw_sitesurvey_cmd(rtlpriv, &pmlmepriv->assoc_ssid, 1, NULL, 0)) ){
+						pmlmepriv->to_join = false;
+					}
+				}
+				else
+				{
+					ret = _FAIL;
+					pmlmepriv->to_join = false;
+				}
+			}
+
+		}
+
+	}
+
+exit:
+
+
+
+	return ret;
+}
+
+
+uint8_t rtw_set_802_11_bssid(struct rtl_priv* rtlpriv, uint8_t *bssid)
+{
+	uint8_t status=_SUCCESS;
+
+	struct mlme_priv *pmlmepriv = &rtlpriv->mlmepriv;
+
+
+
+	DBG_871X_LEVEL(_drv_always_, "set bssid:%pM\n", bssid);
+
+	if ((bssid[0]==0x00 && bssid[1]==0x00 && bssid[2]==0x00 && bssid[3]==0x00 && bssid[4]==0x00 &&bssid[5]==0x00) ||
+	    (bssid[0]==0xFF && bssid[1]==0xFF && bssid[2]==0xFF && bssid[3]==0xFF && bssid[4]==0xFF &&bssid[5]==0xFF))
+	{
+		status = _FAIL;
+		goto exit;
+	}
+
+	spin_lock_bh(&pmlmepriv->lock);
+
+
+	DBG_871X("Set BSSID under fw_state=0x%08x\n", get_fwstate(pmlmepriv));
+	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY) == true) {
+		goto handle_tkip_countermeasure;
+	} else if (check_fwstate(pmlmepriv, _FW_UNDER_LINKING) == true) {
+		goto release_mlme_lock;
+	}
+
+	if (check_fwstate(pmlmepriv, _FW_LINKED|WIFI_ADHOC_MASTER_STATE) == true)
+	{
+
+		if (_rtw_memcmp(&pmlmepriv->cur_network.network.MacAddress, bssid, ETH_ALEN) == true)
+		{
+			if (check_fwstate(pmlmepriv, WIFI_STATION_STATE) == false)
+				goto release_mlme_lock;//it means driver is in WIFI_ADHOC_MASTER_STATE, we needn't create bss again.
+		} else {
+			rtw_disassoc_cmd(rtlpriv, 0, true);
+
+			if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
+				rtw_indicate_disconnect(rtlpriv);
+
+			rtw_free_assoc_resources(rtlpriv, 1);
+
+			if ((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true)) {
+				_clr_fwstate_(pmlmepriv, WIFI_ADHOC_MASTER_STATE);
+				set_fwstate(pmlmepriv, WIFI_ADHOC_STATE);
+			}
+		}
+	}
+
+handle_tkip_countermeasure:
+	//should we add something here...?
+	if((status=rtw_handle_tkip_countermeasure(rtlpriv)) == _FAIL)
+		goto release_mlme_lock;
+
+	memcpy(&pmlmepriv->assoc_bssid, bssid, ETH_ALEN);
+	pmlmepriv->assoc_by_bssid=true;
+
+	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY) == true) {
+		pmlmepriv->to_join = true;
+	}
+	else {
+		status = rtw_do_join(rtlpriv);
+	}
+
+release_mlme_lock:
+	spin_unlock_bh(&pmlmepriv->lock);
+
+exit:
+
+
+
+	return status;
+}
+
+uint8_t rtw_set_802_11_ssid(struct rtl_priv* rtlpriv, NDIS_802_11_SSID *ssid)
+{
+	uint8_t status = _SUCCESS;
+	uint32_t	 cur_time = 0;
+
+	struct mlme_priv *pmlmepriv = &rtlpriv->mlmepriv;
+	struct wlan_network *pnetwork = &pmlmepriv->cur_network;
+
+
+
+	DBG_871X_LEVEL(_drv_always_, "set ssid [%s] fw_state=0x%08x\n",
+		       	ssid->Ssid, get_fwstate(pmlmepriv));
+
+	if(rtlpriv->hw_init_completed==false){
+		status = _FAIL;
+		goto exit;
+	}
+
+	spin_lock_bh(&pmlmepriv->lock);
+
+	DBG_871X("Set SSID under fw_state=0x%08x\n", get_fwstate(pmlmepriv));
+	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY) == true) {
+		goto handle_tkip_countermeasure;
+	} else if (check_fwstate(pmlmepriv, _FW_UNDER_LINKING) == true) {
+		goto release_mlme_lock;
+	}
+
+	if (check_fwstate(pmlmepriv, _FW_LINKED|WIFI_ADHOC_MASTER_STATE) == true)
+	{
+
+		if ((pmlmepriv->assoc_ssid.SsidLength == ssid->SsidLength) &&
+		    (_rtw_memcmp(&pmlmepriv->assoc_ssid.Ssid, ssid->Ssid, ssid->SsidLength) == true))
+		{
+			if((check_fwstate(pmlmepriv, WIFI_STATION_STATE) == false))
+			{
+				if(rtw_is_same_ibss(rtlpriv, pnetwork) == false)
+				{
+					//if in WIFI_ADHOC_MASTER_STATE | WIFI_ADHOC_STATE, create bss or rejoin again
+					rtw_disassoc_cmd(rtlpriv, 0, true);
+
+					if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
+						rtw_indicate_disconnect(rtlpriv);
+
+					rtw_free_assoc_resources(rtlpriv, 1);
+
+					if (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true) {
+						_clr_fwstate_(pmlmepriv, WIFI_ADHOC_MASTER_STATE);
+						set_fwstate(pmlmepriv, WIFI_ADHOC_STATE);
+					}
+				}
+				else
+				{
+					goto release_mlme_lock;//it means driver is in WIFI_ADHOC_MASTER_STATE, we needn't create bss again.
+				}
+			}
+			else {
+				rtw_lps_ctrl_wk_cmd(rtlpriv, LPS_CTRL_JOINBSS, 1);
+			}
+		}
+		else
+		{
+			rtw_disassoc_cmd(rtlpriv, 0, true);
+
+			if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
+				rtw_indicate_disconnect(rtlpriv);
+
+			rtw_free_assoc_resources(rtlpriv, 1);
+
+			if (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true) {
+				_clr_fwstate_(pmlmepriv, WIFI_ADHOC_MASTER_STATE);
+				set_fwstate(pmlmepriv, WIFI_ADHOC_STATE);
+			}
+		}
+	}
+
+handle_tkip_countermeasure:
+
+	if((status=rtw_handle_tkip_countermeasure(rtlpriv)) == _FAIL)
+		goto release_mlme_lock;
+
+	#ifdef CONFIG_VALIDATE_SSID
+	if (rtw_validate_ssid(ssid) == false) {
+		status = _FAIL;
+		goto release_mlme_lock;
+	}
+	#endif
+
+	memcpy(&pmlmepriv->assoc_ssid, ssid, sizeof(NDIS_802_11_SSID));
+	pmlmepriv->assoc_by_bssid=false;
+
+	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY) == true) {
+		pmlmepriv->to_join = true;
+	}
+	else {
+		status = rtw_do_join(rtlpriv);
+	}
+
+release_mlme_lock:
+	spin_unlock_bh(&pmlmepriv->lock);
+
+exit:
+
+
+
+	return status;
+
+}
+
+uint8_t rtw_set_802_11_infrastructure_mode(struct rtl_priv* rtlpriv,
+	NDIS_802_11_NETWORK_INFRASTRUCTURE networktype)
+{
+	struct	mlme_priv	*pmlmepriv = &rtlpriv->mlmepriv;
+	struct	wlan_network	*cur_network = &pmlmepriv->cur_network;
+	NDIS_802_11_NETWORK_INFRASTRUCTURE* pold_state = &(cur_network->network.InfrastructureMode);
+
+
+
+	if(*pold_state != networktype)
+	{
+		spin_lock_bh(&pmlmepriv->lock);
+
+		//DBG_871X("change mode, old_mode=%d, new_mode=%d, fw_state=0x%x\n", *pold_state, networktype, get_fwstate(pmlmepriv));
+
+		if(*pold_state==Ndis802_11APMode)
+		{
+			//change to other mode from Ndis802_11APMode
+			cur_network->join_res = -1;
+
+			stop_ap_mode(rtlpriv);
+		}
+
+		if((check_fwstate(pmlmepriv, _FW_LINKED)== true) ||(*pold_state==Ndis802_11IBSS))
+			rtw_disassoc_cmd(rtlpriv, 0, true);
+
+		if((check_fwstate(pmlmepriv, _FW_LINKED)== true) ||
+			(check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)== true) )
+			rtw_free_assoc_resources(rtlpriv, 1);
+
+		if((*pold_state == Ndis802_11Infrastructure) ||(*pold_state == Ndis802_11IBSS))
+	       {
+			if(check_fwstate(pmlmepriv, _FW_LINKED) == true)
+			{
+				rtw_indicate_disconnect(rtlpriv); //will clr Linked_state; before this function, we must have chked whether  issue dis-assoc_cmd or not
+			}
+	       }
+
+		*pold_state = networktype;
+
+		_clr_fwstate_(pmlmepriv, ~WIFI_NULL_STATE);
+
+		switch(networktype)
+		{
+			case Ndis802_11IBSS:
+				set_fwstate(pmlmepriv, WIFI_ADHOC_STATE);
+				break;
+
+			case Ndis802_11Infrastructure:
+				set_fwstate(pmlmepriv, WIFI_STATION_STATE);
+				break;
+
+			case Ndis802_11APMode:
+				set_fwstate(pmlmepriv, WIFI_AP_STATE);
+				start_ap_mode(rtlpriv);
+				//rtw_indicate_connect(rtlpriv);
+
+				break;
+
+			case Ndis802_11AutoUnknown:
+			case Ndis802_11InfrastructureMax:
+				break;
+		}
+
+		//SecClearAllKeys(rtlpriv);
+
+		//RT_TRACE(COMP_OID_SET, DBG_LOUD, ("set_infrastructure: fw_state:%x after changing mode\n",
+		//									get_fwstate(pmlmepriv) ));
+
+		spin_unlock_bh(&pmlmepriv->lock);
+	}
+
+
+
+	return true;
+}
+
+
+uint8_t rtw_set_802_11_disassociate(struct rtl_priv *rtlpriv)
+{
+	struct mlme_priv * pmlmepriv = &rtlpriv->mlmepriv;
+
+
+
+	spin_lock_bh(&pmlmepriv->lock);
+
+	if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
+	{
+		rtw_disassoc_cmd(rtlpriv, 0, true);
+		rtw_indicate_disconnect(rtlpriv);
+		rtw_free_assoc_resources(rtlpriv, 1);
+		rtw_pwr_wakeup(rtlpriv);
+	}
+
+	spin_unlock_bh(&pmlmepriv->lock);
+
+
+
+	return true;
+}
+
+uint8_t rtw_set_802_11_bssid_list_scan(struct rtl_priv* rtlpriv, NDIS_802_11_SSID *pssid, int ssid_max_num)
+{
+	struct	mlme_priv		*pmlmepriv= &rtlpriv->mlmepriv;
+	uint8_t	res=true;
+
+
+
+	if (rtlpriv == NULL) {
+		res=false;
+		goto exit;
+	}
+	if (rtlpriv->hw_init_completed==false){
+		res = false;
+		goto exit;
+	}
+
+	if ((check_fwstate(pmlmepriv, _FW_UNDER_SURVEY|_FW_UNDER_LINKING) == true) ||
+		(pmlmepriv->LinkDetectInfo.bBusyTraffic == true))
+	{
+		// Scan or linking is in progress, do nothing.
+		res = true;
+
+		if(check_fwstate(pmlmepriv, (_FW_UNDER_SURVEY|_FW_UNDER_LINKING))== true){
+			;
+		} else {
+			;
+		}
+	} else {
+		spin_lock_bh(&pmlmepriv->lock);
+
+		res = rtw_sitesurvey_cmd(rtlpriv, pssid, ssid_max_num, NULL, 0);
+
+		spin_unlock_bh(&pmlmepriv->lock);
+	}
+exit:
+
+
+
+	return res;
+}
+
+uint8_t rtw_set_802_11_authentication_mode(struct rtl_priv* rtlpriv, NDIS_802_11_AUTHENTICATION_MODE authmode)
+{
+	struct security_priv *psecuritypriv = &rtlpriv->securitypriv;
+	int res;
+	uint8_t ret;
+
+
+
+	psecuritypriv->ndisauthtype=authmode;
+
+	if(psecuritypriv->ndisauthtype>3)
+		psecuritypriv->dot11AuthAlgrthm=dot11AuthAlgrthm_8021X;
+
+	res=rtw_set_auth(rtlpriv,psecuritypriv);
+
+	if(res==_SUCCESS)
+		ret=true;
+	else
+		ret=false;
+
+
+
+	return ret;
+}
+
+uint8_t rtw_set_802_11_add_wep(struct rtl_priv* rtlpriv, NDIS_802_11_WEP *wep){
+
+	uint8_t		bdefaultkey;
+	uint8_t		btransmitkey;
+	int		keyid,res;
+	struct security_priv* psecuritypriv=&(rtlpriv->securitypriv);
+	uint8_t		ret=_SUCCESS;
+
+
+
+	bdefaultkey=(wep->KeyIndex & 0x40000000) > 0 ? false : true;   //for ???
+	btransmitkey= (wep->KeyIndex & 0x80000000) > 0 ? true  : false;	//for ???
+	keyid=wep->KeyIndex & 0x3fffffff;
+
+	if(keyid>4)
+	{
+		ret=false;
+		goto exit;
+	}
+
+	switch(wep->KeyLength)
+	{
+		case 5:
+			psecuritypriv->dot11PrivacyAlgrthm=WEP40_ENCRYPTION;
+			break;
+		case 13:
+			psecuritypriv->dot11PrivacyAlgrthm=WEP104_ENCRYPTION;
+			break;
+		default:
+			psecuritypriv->dot11PrivacyAlgrthm=NO_ENCRYPTION;
+			break;
+	}
+
+	memcpy(&(psecuritypriv->dot11DefKey[keyid].skey[0]),&(wep->KeyMaterial),wep->KeyLength);
+
+	psecuritypriv->dot11DefKeylen[keyid]=wep->KeyLength;
+
+	psecuritypriv->dot11PrivacyKeyIndex=keyid;
+
+	res=rtw_set_key(rtlpriv,psecuritypriv, keyid, 1);
+
+	if(res==_FAIL)
+		ret= false;
+exit:
+
+
+
+	return ret;
+
+}
+
+uint8_t rtw_set_802_11_remove_wep(struct rtl_priv* rtlpriv, uint32_t	 keyindex){
+
+	uint8_t ret=_SUCCESS;
+
+
+
+	if (keyindex >= 0x80000000 || rtlpriv == NULL){
+
+		ret=false;
+		goto exit;
+
+	}
+	else
+	{
+		int res;
+		struct security_priv* psecuritypriv=&(rtlpriv->securitypriv);
+		if( keyindex < 4 ){
+
+			memset(&psecuritypriv->dot11DefKey[keyindex], 0, 16);
+
+			res=rtw_set_key(rtlpriv,psecuritypriv,keyindex, 0);
+
+			psecuritypriv->dot11DefKeylen[keyindex]=0;
+
+			if(res==_FAIL)
+				ret=_FAIL;
+
+		}
+		else
+		{
+			ret=_FAIL;
+		}
+
+	}
+
+exit:
+
+
+
+	return ret;
+
+}
+
+uint8_t rtw_set_802_11_add_key(struct rtl_priv* rtlpriv, NDIS_802_11_KEY *key){
+
+	uint	encryptionalgo;
+	uint8_t * pbssid;
+	struct sta_info *stainfo;
+	uint8_t	bgroup = false;
+	uint8_t	bgrouptkey = false;//can be remove later
+	uint8_t	ret=_SUCCESS;
+
+
+
+	if (((key->KeyIndex & 0x80000000) == 0) && ((key->KeyIndex & 0x40000000) > 0)){
+
+		// It is invalid to clear bit 31 and set bit 30. If the miniport driver encounters this combination,
+		// it must fail the request and return NDIS_STATUS_INVALID_DATA.
+		ret= _FAIL;
+		goto exit;
+	}
+
+	if(key->KeyIndex & 0x40000000)
+	{
+		// Pairwise key
+
+		pbssid=get_bssid(&rtlpriv->mlmepriv);
+		stainfo=rtw_get_stainfo(&rtlpriv->stapriv, pbssid);
+
+		if((stainfo!=NULL)&&(rtlpriv->securitypriv.dot11AuthAlgrthm==dot11AuthAlgrthm_8021X)){
+			encryptionalgo=stainfo->dot118021XPrivacy;
+		}
+		else{
+			encryptionalgo=rtlpriv->securitypriv.dot11PrivacyAlgrthm;
+		}
+
+		if((stainfo!=NULL)){
+			;
+		}
+
+		if(key->KeyIndex & 0x000000FF){
+			// The key index is specified in the lower 8 bits by values of zero to 255.
+			// The key index should be set to zero for a Pairwise key, and the driver should fail with
+			// NDIS_STATUS_INVALID_DATA if the lower 8 bits is not zero
+			ret= _FAIL;
+			goto exit;
+		}
+
+		// check BSSID
+		if (IS_MAC_ADDRESS_BROADCAST(key->BSSID) == true){
+			ret= false;
+			goto exit;
+		}
+
+		// Check key length for TKIP.
+		//if(encryptionAlgorithm == RT_ENC_TKIP_ENCRYPTION && key->KeyLength != 32)
+		if((encryptionalgo== TKIP_ENCRYPTION)&& (key->KeyLength != 32)){
+			ret=_FAIL;
+			goto exit;
+
+		}
+
+		// Check key length for AES.
+		if((encryptionalgo== AESCCMP_ENCRYPTION)&& (key->KeyLength != 16)) {
+			// For our supplicant, EAPPkt9x.vxd, cannot differentiate TKIP and AES case.
+			if(key->KeyLength == 32) {
+				key->KeyLength = 16;
+			} else {
+				ret= _FAIL;
+				goto exit;
+			}
+		}
+
+		// Check key length for WEP. For NDTEST, 2005.01.27, by rcnjko.
+		if(	(encryptionalgo== WEP40_ENCRYPTION|| encryptionalgo== WEP104_ENCRYPTION) && (key->KeyLength != 5 || key->KeyLength != 13)) {
+			ret=_FAIL;
+			goto exit;
+		}
+
+		bgroup = false;
+
+	}
+	else
+	{
+
+		// when add wep key through add key and didn't assigned encryption type before
+		if((rtlpriv->securitypriv.ndisauthtype<=3)&&(rtlpriv->securitypriv.dot118021XGrpPrivacy==0))
+		{
+			switch(key->KeyLength)
+			{
+				case 5:
+					rtlpriv->securitypriv.dot11PrivacyAlgrthm=WEP40_ENCRYPTION;
+					break;
+				case 13:
+					rtlpriv->securitypriv.dot11PrivacyAlgrthm=WEP104_ENCRYPTION;
+					break;
+				default:
+					rtlpriv->securitypriv.dot11PrivacyAlgrthm=NO_ENCRYPTION;
+					break;
+			}
+
+			encryptionalgo=rtlpriv->securitypriv.dot11PrivacyAlgrthm;
+		}
+		else
+		{
+			encryptionalgo=rtlpriv->securitypriv.dot118021XGrpPrivacy;
+
+		}
+
+		if((check_fwstate(&rtlpriv->mlmepriv, WIFI_ADHOC_STATE)==true) && (IS_MAC_ADDRESS_BROADCAST(key->BSSID) == false)) {
+			ret= _FAIL;
+			goto exit;
+		}
+
+		// Check key length for TKIP
+		if((encryptionalgo== TKIP_ENCRYPTION) && (key->KeyLength != 32)) {
+			ret= _FAIL;
+			goto exit;
+
+		} else if(encryptionalgo== AESCCMP_ENCRYPTION && (key->KeyLength != 16 && key->KeyLength != 32) ) {
+
+			// Check key length for AES
+			// For NDTEST, we allow keylen=32 in this case. 2005.01.27, by rcnjko.
+			ret= _FAIL;
+			goto exit;
+		}
+
+		// Change the key length for EAPPkt9x.vxd. Added by Annie, 2005-11-03.
+		if((encryptionalgo==  AESCCMP_ENCRYPTION) && (key->KeyLength == 32) ) {
+			key->KeyLength = 16;
+		}
+
+		if(key->KeyIndex & 0x8000000) {//error ??? 0x8000_0000
+			bgrouptkey = true;
+		}
+
+		if((check_fwstate(&rtlpriv->mlmepriv, WIFI_ADHOC_STATE)==true)&&(check_fwstate(&rtlpriv->mlmepriv, _FW_LINKED)==true))
+		{
+			bgrouptkey = true;
+		}
+
+		bgroup = true;
+	}
+
+	// If WEP encryption algorithm, just call rtw_set_802_11_add_wep().
+	if((rtlpriv->securitypriv.dot11AuthAlgrthm !=dot11AuthAlgrthm_8021X)&&(encryptionalgo== WEP40_ENCRYPTION  || encryptionalgo== WEP104_ENCRYPTION))
+	{
+		uint8_t ret;
+		uint32_t	 keyindex;
+		uint32_t	 len = FIELD_OFFSET(NDIS_802_11_KEY, KeyMaterial) + key->KeyLength;
+		NDIS_802_11_WEP *wep = &rtlpriv->securitypriv.ndiswep;
+
+		wep->Length = len;
+		keyindex = key->KeyIndex&0x7fffffff;
+		wep->KeyIndex = keyindex ;
+		wep->KeyLength = key->KeyLength;
+
+		memcpy(wep->KeyMaterial, key->KeyMaterial, key->KeyLength);
+		memcpy(&(rtlpriv->securitypriv.dot11DefKey[keyindex].skey[0]), key->KeyMaterial, key->KeyLength);
+
+		rtlpriv->securitypriv.dot11DefKeylen[keyindex]=key->KeyLength;
+		rtlpriv->securitypriv.dot11PrivacyKeyIndex=keyindex;
+
+		ret = rtw_set_802_11_add_wep(rtlpriv, wep);
+
+		goto exit;
+
+	}
+
+	if(key->KeyIndex & 0x20000000){
+		// SetRSC
+		if(bgroup == true)
+		{
+			NDIS_802_11_KEY_RSC keysrc=key->KeyRSC & 0x00FFFFFFFFFFFFULL;
+			memcpy(&rtlpriv->securitypriv.dot11Grprxpn, &keysrc, 8);
+		}
+		else
+		{
+			NDIS_802_11_KEY_RSC keysrc=key->KeyRSC & 0x00FFFFFFFFFFFFULL;
+			memcpy(&rtlpriv->securitypriv.dot11Grptxpn, &keysrc, 8);
+		}
+
+	}
+
+	// Indicate this key idx is used for TX
+	// Save the key in KeyMaterial
+	if(bgroup == true) // Group transmit key
+	{
+		int res;
+
+		if(bgrouptkey == true)
+		{
+			rtlpriv->securitypriv.dot118021XGrpKeyid=(uint8_t)key->KeyIndex;
+		}
+
+		if((key->KeyIndex&0x3) == 0){
+			ret = _FAIL;
+			goto exit;
+		}
+
+		memset(&rtlpriv->securitypriv.dot118021XGrpKey[(uint8_t)((key->KeyIndex) & 0x03)], 0, 16);
+		memset(&rtlpriv->securitypriv.dot118021XGrptxmickey[(uint8_t)((key->KeyIndex) & 0x03)], 0, 16);
+		memset(&rtlpriv->securitypriv.dot118021XGrprxmickey[(uint8_t)((key->KeyIndex) & 0x03)], 0, 16);
+
+		if((key->KeyIndex & 0x10000000))
+		{
+			memcpy(&rtlpriv->securitypriv.dot118021XGrptxmickey[(uint8_t)((key->KeyIndex) & 0x03)], key->KeyMaterial + 16, 8);
+			memcpy(&rtlpriv->securitypriv.dot118021XGrprxmickey[(uint8_t)((key->KeyIndex) & 0x03)], key->KeyMaterial + 24, 8);
+		}
+		else
+		{
+			memcpy(&rtlpriv->securitypriv.dot118021XGrptxmickey[(uint8_t)((key->KeyIndex) & 0x03)], key->KeyMaterial + 24, 8);
+			memcpy(&rtlpriv->securitypriv.dot118021XGrprxmickey[(uint8_t)((key->KeyIndex) & 0x03)], key->KeyMaterial + 16, 8);
+		}
+
+		//set group key by index
+		memcpy(&rtlpriv->securitypriv.dot118021XGrpKey[(uint8_t)((key->KeyIndex) & 0x03)], key->KeyMaterial, key->KeyLength);
+
+		key->KeyIndex=key->KeyIndex & 0x03;
+
+		rtlpriv->securitypriv.binstallGrpkey=true;
+
+		rtlpriv->securitypriv.bcheck_grpkey=false;
+
+		res=rtw_set_key(rtlpriv,&rtlpriv->securitypriv, key->KeyIndex, 1);
+
+		if(res==_FAIL)
+			ret= _FAIL;
+
+		goto exit;
+
+	}
+	else // Pairwise Key
+	{
+		uint8_t res;
+
+		pbssid=get_bssid(&rtlpriv->mlmepriv);
+		stainfo=rtw_get_stainfo(&rtlpriv->stapriv , pbssid );
+
+		if(stainfo!=NULL)
+		{
+			memset( &stainfo->dot118021x_UncstKey, 0, 16);// clear keybuffer
+
+			memcpy(&stainfo->dot118021x_UncstKey, key->KeyMaterial, 16);
+
+			if(encryptionalgo== TKIP_ENCRYPTION)
+			{
+				rtlpriv->securitypriv.busetkipkey=false;
+
+				//_set_timer(&rtlpriv->securitypriv.tkip_timer, 50);
+
+				// if TKIP, save the Receive/Transmit MIC key in KeyMaterial[128-255]
+				if((key->KeyIndex & 0x10000000)){
+					memcpy(&stainfo->dot11tkiptxmickey, key->KeyMaterial + 16, 8);
+					memcpy(&stainfo->dot11tkiprxmickey, key->KeyMaterial + 24, 8);
+
+				} else {
+					memcpy(&stainfo->dot11tkiptxmickey, key->KeyMaterial + 24, 8);
+					memcpy(&stainfo->dot11tkiprxmickey, key->KeyMaterial + 16, 8);
+
+				}
+
+			}
+			else if(encryptionalgo == AESCCMP_ENCRYPTION)
+			{
+
+			}
+
+
+			//Set key to CAM through H2C command
+			if(bgrouptkey)//never go to here
+			{
+				res=rtw_setstakey_cmd(rtlpriv, (unsigned char *)stainfo, false);
+			}
+			else{
+				res=rtw_setstakey_cmd(rtlpriv, (unsigned char *)stainfo, true);
+			}
+
+			if(res ==false)
+				ret= _FAIL;
+
+		}
+
+	}
+
+exit:
+
+
+
+	return ret;
+}
+
+uint8_t rtw_set_802_11_remove_key(struct rtl_priv*	rtlpriv, NDIS_802_11_REMOVE_KEY *key){
+
+	uint				encryptionalgo;
+	uint8_t * pbssid;
+	struct sta_info *stainfo;
+	uint8_t	bgroup = (key->KeyIndex & 0x4000000) > 0 ? false: true;
+	uint8_t	keyIndex = (uint8_t)key->KeyIndex & 0x03;
+	uint8_t	ret=_SUCCESS;
+
+
+
+	if ((key->KeyIndex & 0xbffffffc) > 0) {
+		ret=_FAIL;
+		goto exit;
+	}
+
+	if (bgroup == true) {
+		encryptionalgo= rtlpriv->securitypriv.dot118021XGrpPrivacy;
+		// clear group key by index
+		//NdisZeroMemory(rtlpriv->MgntInfo.SecurityInfo.KeyBuf[keyIndex], MAX_WEP_KEY_LEN);
+		//rtlpriv->MgntInfo.SecurityInfo.KeyLen[keyIndex] = 0;
+
+		memset(&rtlpriv->securitypriv.dot118021XGrpKey[keyIndex], 0, 16);
+
+		//! \todo Send a H2C Command to Firmware for removing this Key in CAM Entry.
+
+	} else {
+
+		pbssid=get_bssid(&rtlpriv->mlmepriv);
+		stainfo=rtw_get_stainfo(&rtlpriv->stapriv , pbssid );
+		if(stainfo !=NULL){
+			encryptionalgo=stainfo->dot118021XPrivacy;
+
+		// clear key by BSSID
+		memset(&stainfo->dot118021x_UncstKey, 0, 16);
+
+		//! \todo Send a H2C Command to Firmware for disable this Key in CAM Entry.
+
+		}
+		else{
+			ret= _FAIL;
+			goto exit;
+		}
+	}
+
+exit:
+
+
+
+	return true;
+
+}
+
+/*
+* rtw_get_cur_max_rate -
+* @rtlpriv: pointer to struct rtl_priv structure
+*
+* Return 0 or 100Kbps
+*/
+u16 rtw_get_cur_max_rate(struct rtl_priv *rtlpriv)
+{
+	int	i = 0;
+	uint8_t	*p;
+	u16	rate = 0, max_rate = 0;
+	struct mlme_ext_priv	*pmlmeext = &rtlpriv->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct registry_priv *pregistrypriv = &rtlpriv->registrypriv;
+	struct mlme_priv	*pmlmepriv = &rtlpriv->mlmepriv;
+	WLAN_BSSID_EX  *pcur_bss = &pmlmepriv->cur_network.network;
+	struct rtw_ieee80211_ht_cap *pht_capie;
+	uint8_t	rf_type = 0;
+	uint8_t	bw_40MHz=0, short_GI_20=0, short_GI_40=0, cbw40_enable=0;
+	u16	mcs_rate=0;
+	uint32_t	ht_ielen = 0;
+	struct vht_priv	*pvhtpriv = &pmlmepriv->vhtpriv;
+
+	if((check_fwstate(pmlmepriv, _FW_LINKED) != true)
+		&& (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) != true))
+		return 0;
+
+	if (IsSupportedTxHT(pmlmeext->cur_wireless_mode)) {
+		p = rtw_get_ie(&pcur_bss->IEs[12], _HT_CAPABILITY_IE_, &ht_ielen, pcur_bss->IELength-12);
+		if(p && ht_ielen>0)
+		{
+			pht_capie = (struct rtw_ieee80211_ht_cap *)(p+2);
+
+			memcpy(&mcs_rate , pht_capie->supp_mcs_set, 2);
+
+			//bw_40MHz = (pht_capie->cap_info&IEEE80211_HT_CAP_SUP_WIDTH) ? 1:0;
+			//cur_bwmod is updated by beacon, pmlmeinfo is updated by association response
+			bw_40MHz = (pmlmeext->cur_bwmode && (HT_INFO_HT_PARAM_REC_TRANS_CHNL_WIDTH & pmlmeinfo->HT_info.infos[0])) ? 1:0;
+
+			//short_GI = (pht_capie->cap_info&(IEEE80211_HT_CAP_SGI_20|IEEE80211_HT_CAP_SGI_40)) ? 1:0;
+			short_GI_20 = (pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info&IEEE80211_HT_CAP_SGI_20) ? 1:0;
+			short_GI_40 = (pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info&IEEE80211_HT_CAP_SGI_40) ? 1:0;
+
+			rf_type = rtlpriv->phy.rf_type;
+
+			if (pmlmeext->cur_channel > 14) {
+				if ((0x21 & 0xf0) > 0)
+					cbw40_enable = 1;
+			} else {
+				if ((0x21 & 0x0f) > 0)
+					cbw40_enable = 1;
+			}
+
+			max_rate = rtw_mcs_rate(
+				rf_type,
+				bw_40MHz & cbw40_enable,
+				short_GI_20,
+				short_GI_40,
+				pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate
+			);
+		}
+	}
+	else if (IsSupportedVHT(pmlmeext->cur_wireless_mode)) {
+		max_rate = ((rtw_vht_data_rate(pvhtpriv->vht_bwmode, pvhtpriv->sgi, pvhtpriv->vht_highest_rate) + 1) >> 1) * 10;
+	}
+	else
+	{
+		while( (pcur_bss->SupportedRates[i]!=0) && (pcur_bss->SupportedRates[i]!=0xFF))
+		{
+			rate = pcur_bss->SupportedRates[i]&0x7F;
+			if(rate>max_rate)
+				max_rate = rate;
+			i++;
+		}
+
+		max_rate = max_rate*10/2;
+	}
+
+	return max_rate;
+}
+
+/*
+* rtw_set_scan_mode -
+* @rtlpriv: pointer to struct rtl_priv structure
+* @scan_mode:
+*
+* Return _SUCCESS or _FAIL
+*/
+int rtw_set_scan_mode(struct rtl_priv *rtlpriv, RT_SCAN_TYPE scan_mode)
+{
+	if(scan_mode != SCAN_ACTIVE && scan_mode != SCAN_PASSIVE)
+		return _FAIL;
+
+	rtlpriv->mlmepriv.scan_mode = scan_mode;
+
+	return _SUCCESS;
+}
diff -Naur linux-4.9/drivers/staging/rtl8821au/core/rtw_mlme.c linux-4.9.8821au/drivers/staging/rtl8821au/core/rtw_mlme.c
--- linux-4.9/drivers/staging/rtl8821au/core/rtw_mlme.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/core/rtw_mlme.c	2016-12-11 19:48:25.150311808 -0600
@@ -0,0 +1,2700 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#define _RTW_MLME_C_
+
+#include <linux/etherdevice.h>
+#include <drv_types.h>
+#include <rtw_ap.h>
+#include <rtl8812a_hal.h>
+
+#undef DBG_871X
+static inline void DBG_871X(const char *fmt, ...)
+{
+}
+
+static struct list_head *get_next(struct list_head	*list)
+{
+	return list->next;
+}
+
+extern void indicate_wx_scan_complete_event(struct rtl_priv *rtlpriv);
+extern uint8_t rtw_do_join(struct rtl_priv * rtlpriv);
+
+#ifdef CONFIG_DISABLE_MCS13TO15
+extern unsigned char	MCS_rate_2R_MCS13TO15_OFF[16];
+extern unsigned char	MCS_rate_2R[16];
+#else
+extern unsigned char	MCS_rate_2R[16];
+#endif
+extern unsigned char	MCS_rate_1R[16];
+
+int _rtw_init_mlme_priv (struct rtl_priv *rtlpriv)
+{
+	int	i;
+	uint8_t	*pbuf;
+	struct wlan_network *pnetwork;
+	struct mlme_priv *pmlmepriv = &rtlpriv->mlmepriv;
+	int	res = _SUCCESS;
+
+
+	/*
+	 *  We don't need to memset rtlpriv->XXX to zero, because rtlpriv is allocated by rtw_zvmalloc().
+	 * memset((uint8_t *)pmlmepriv, 0, sizeof(struct mlme_priv));
+	 */
+
+	pmlmepriv->nic_hdl = (uint8_t *)rtlpriv;
+
+	pmlmepriv->pscanned = NULL;
+	pmlmepriv->fw_state = 0;
+	pmlmepriv->cur_network.network.InfrastructureMode = Ndis802_11AutoUnknown;
+	pmlmepriv->scan_mode=SCAN_ACTIVE;// 1: active, 0: pasive. Maybe someday we should rename this varable to "active_mode" (Jeff)
+
+	spin_lock_init(&(pmlmepriv->lock));
+	_rtw_init_queue(&(pmlmepriv->free_bss_pool));
+	_rtw_init_queue(&(pmlmepriv->scanned_queue));
+
+	set_scanned_network_val(pmlmepriv, 0);
+
+	memset(&pmlmepriv->assoc_ssid,0,sizeof(NDIS_802_11_SSID));
+
+	pbuf = rtw_zvmalloc(MAX_BSS_CNT * (sizeof(struct wlan_network)));
+
+	if (pbuf == NULL) {
+		res=_FAIL;
+		goto exit;
+	}
+	pmlmepriv->free_bss_buf = pbuf;
+
+	pnetwork = (struct wlan_network *)pbuf;
+
+	for (i = 0; i < MAX_BSS_CNT; i++) {
+		INIT_LIST_HEAD(&(pnetwork->list));
+
+		list_add_tail(&(pnetwork->list), &(pmlmepriv->free_bss_pool.list));
+
+		pnetwork++;
+	}
+
+	/* allocate DMA-able/Non-Page memory for cmd_buf and rsp_buf */
+
+	rtw_init_mlme_timer(rtlpriv);
+
+exit:
+
+	return res;
+}
+
+/* ULLI check usage of param *plen */
+static void rtw_free_mlme_ie_data(uint8_t **ppie, uint32_t *plen)
+{
+	if (*ppie) {
+		_rtw_mfree(*ppie);
+		*plen = 0;
+		*ppie=NULL;
+	}
+}
+
+void rtw_free_mlme_priv_ie_data(struct mlme_priv *pmlmepriv)
+{
+#if defined (CONFIG_AP_MODE)
+	rtw_buf_free(&pmlmepriv->assoc_req, &pmlmepriv->assoc_req_len);
+	rtw_buf_free(&pmlmepriv->assoc_rsp, &pmlmepriv->assoc_rsp_len);
+	rtw_free_mlme_ie_data(&pmlmepriv->wps_beacon_ie, &pmlmepriv->wps_beacon_ie_len);
+	rtw_free_mlme_ie_data(&pmlmepriv->wps_probe_req_ie, &pmlmepriv->wps_probe_req_ie_len);
+	rtw_free_mlme_ie_data(&pmlmepriv->wps_probe_resp_ie, &pmlmepriv->wps_probe_resp_ie_len);
+	rtw_free_mlme_ie_data(&pmlmepriv->wps_assoc_resp_ie, &pmlmepriv->wps_assoc_resp_ie_len);
+
+	rtw_free_mlme_ie_data(&pmlmepriv->p2p_beacon_ie, &pmlmepriv->p2p_beacon_ie_len);
+	rtw_free_mlme_ie_data(&pmlmepriv->p2p_probe_req_ie, &pmlmepriv->p2p_probe_req_ie_len);
+	rtw_free_mlme_ie_data(&pmlmepriv->p2p_probe_resp_ie, &pmlmepriv->p2p_probe_resp_ie_len);
+	rtw_free_mlme_ie_data(&pmlmepriv->p2p_go_probe_resp_ie, &pmlmepriv->p2p_go_probe_resp_ie_len);
+	rtw_free_mlme_ie_data(&pmlmepriv->p2p_assoc_req_ie, &pmlmepriv->p2p_assoc_req_ie_len);
+#endif
+}
+
+void _rtw_free_mlme_priv (struct mlme_priv *pmlmepriv)
+{
+	rtw_free_mlme_priv_ie_data(pmlmepriv);
+
+	if (pmlmepriv){
+		if (pmlmepriv->free_bss_buf) {
+			rtw_vmfree(pmlmepriv->free_bss_buf);
+		}
+	}
+}
+
+int _rtw_enqueue_network(struct __queue *queue, struct wlan_network *pnetwork)
+{
+	if (pnetwork == NULL)
+		goto exit;
+
+	spin_lock_bh(&queue->lock);
+
+	list_add_tail(&pnetwork->list, &queue->list);
+
+	spin_unlock_bh(&queue->lock);
+
+exit:
+
+	return _SUCCESS;
+}
+
+/*
+struct	wlan_network *_rtw_dequeue_network(struct __queue *queue)
+{
+	_irqL irqL;
+
+	struct wlan_network *pnetwork;
+
+
+
+	spin_lock_bh(&queue->lock, &irqL);
+
+	if (_rtw_queue_empty(queue) == true)
+
+		pnetwork = NULL;
+
+	else
+	{
+		pnetwork = container_of(get_next(&queue->queue), struct wlan_network, list);
+
+		list_del_init(&(pnetwork->list));
+	}
+
+	spin_unlock_bh(&queue->lock, &irqL);
+
+
+
+	return pnetwork;
+}
+*/
+
+struct	wlan_network *_rtw_alloc_network(struct	mlme_priv *pmlmepriv )	/* (struct __queue *free_queue) */
+{
+	struct	wlan_network *pnetwork;
+	struct __queue *free_queue = &pmlmepriv->free_bss_pool;
+	struct list_head* plist = NULL;
+
+	spin_lock_bh(&free_queue->lock);
+
+	if (list_empty(&free_queue->list)) {
+		pnetwork=NULL;
+		goto exit;
+	}
+	plist = get_next(&(free_queue->list));
+
+	pnetwork = container_of(plist , struct wlan_network, list);
+
+	list_del_init(&pnetwork->list);
+
+	pnetwork->network_type = 0;
+	pnetwork->fixed = false;
+	pnetwork->last_scanned = jiffies;
+	pnetwork->aid=0;
+	pnetwork->join_res=0;
+
+	pmlmepriv->num_of_scanned ++;
+
+exit:
+	spin_unlock_bh(&free_queue->lock);
+
+	return pnetwork;
+}
+
+void _rtw_free_network(struct	mlme_priv *pmlmepriv ,struct wlan_network *pnetwork, uint8_t isfreeall)
+{
+	uint32_t delta_time;
+	uint32_t lifetime = SCANQUEUE_LIFETIME;
+	struct __queue *free_queue = &(pmlmepriv->free_bss_pool);
+
+	if (pnetwork == NULL)
+		goto exit;
+
+	if (pnetwork->fixed == true)
+		goto exit;
+
+	if ((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)==true ) ||
+		(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)==true ) )
+		lifetime = 1;
+
+	if (!isfreeall) {
+		delta_time = (uint32_t) rtw_get_passing_time_ms(pnetwork->last_scanned);
+		if (delta_time < lifetime) 	/* unit:msec */
+			goto exit;
+	}
+
+	spin_lock_bh(&free_queue->lock);
+
+	list_del_init(&(pnetwork->list));
+	list_add_tail(&(pnetwork->list),&(free_queue->list));
+
+	pmlmepriv->num_of_scanned --;
+
+
+	/*
+	 * DBG_871X("_rtw_free_network:SSID=%s\n", pnetwork->network.Ssid.Ssid);
+	 */
+
+	spin_unlock_bh(&free_queue->lock);
+exit:
+	;
+}
+
+void _rtw_free_network_nolock(struct	mlme_priv *pmlmepriv, struct wlan_network *pnetwork)
+{
+
+	struct __queue *free_queue = &(pmlmepriv->free_bss_pool);
+
+	if (pnetwork == NULL)
+		goto exit;
+
+	if (pnetwork->fixed == true)
+		goto exit;
+
+	/* spin_lock_irqsave(&free_queue->lock, &irqL); */
+
+	list_del_init(&(pnetwork->list));
+	list_add_tail(&(pnetwork->list), get_list_head(free_queue));
+
+	pmlmepriv->num_of_scanned --;
+
+	/*spin_unlock_irqrestore(&free_queue->lock, &irqL); */
+
+exit:
+	;
+}
+
+
+/*
+	return the wlan_network with the matching addr
+
+	Shall be calle under atomic context... to avoid possible racing condition...
+*/
+struct wlan_network *_rtw_find_network(struct __queue *scanned_queue, uint8_t *addr)
+{
+
+	/* _irqL irqL; */
+	struct list_head	*phead, *plist;
+	struct	wlan_network *pnetwork = NULL;
+	uint8_t zero_addr[ETH_ALEN] = {0,0,0,0,0,0};
+
+	if (_rtw_memcmp(zero_addr, addr, ETH_ALEN)){
+		pnetwork=NULL;
+		goto exit;
+	}
+
+	/* spin_lock_bh(&scanned_queue->lock, &irqL); */
+
+	phead = get_list_head(scanned_queue);
+	plist = get_next(phead);
+
+	while (plist != phead) {
+                pnetwork = container_of(plist, struct wlan_network ,list);
+
+		if (_rtw_memcmp(addr, pnetwork->network.MacAddress, ETH_ALEN) == true)
+                        break;
+
+		plist = get_next(plist);
+        }
+
+	if (plist == phead)
+		pnetwork = NULL;
+
+	/* spin_unlock_bh(&scanned_queue->lock, &irqL); */
+
+exit:
+
+	return pnetwork;
+}
+
+
+void _rtw_free_network_queue(struct rtl_priv *rtlpriv, uint8_t isfreeall)
+{
+	struct list_head *phead, *plist;
+	struct wlan_network *pnetwork;
+	struct mlme_priv* pmlmepriv = &rtlpriv->mlmepriv;
+	struct __queue *scanned_queue = &pmlmepriv->scanned_queue;
+
+	spin_lock_bh(&scanned_queue->lock);
+
+	phead = get_list_head(scanned_queue);
+	plist = get_next(phead);
+
+	while (rtw_end_of_queue_search(phead, plist) == false) {
+		pnetwork = container_of(plist, struct wlan_network, list);
+		plist = get_next(plist);
+		_rtw_free_network(pmlmepriv,pnetwork, isfreeall);
+	}
+
+	spin_unlock_bh(&scanned_queue->lock);
+}
+
+
+
+
+int rtw_if_up(struct rtl_priv *rtlpriv)
+{
+
+	int res;
+
+	if (rtlpriv->bDriverStopped || rtlpriv->bSurpriseRemoved
+	   || (check_fwstate(&rtlpriv->mlmepriv, _FW_LINKED)== false)){
+		res=false;
+	} else
+		res=  true;
+
+	return res;
+}
+
+
+void rtw_generate_random_ibss(uint8_t * pibss)
+{
+	uint32_t	curtime = jiffies;
+
+	pibss[0] = 0x02;  //in ad-hoc mode BIT(1) must set to 1
+	pibss[1] = 0x11;
+	pibss[2] = 0x87;
+	pibss[3] = (uint8_t)(curtime & 0xff) ;//p[0];
+	pibss[4] = (uint8_t)((curtime>>8) & 0xff) ;//p[1];
+	pibss[5] = (uint8_t)((curtime>>16) & 0xff) ;//p[2];
+
+	return;
+}
+
+uint8_t *rtw_get_capability_from_ie(uint8_t *ie)
+{
+	return (ie + 8 + 2);
+}
+
+
+u16 rtw_get_capability(WLAN_BSSID_EX *bss)
+{
+	u16	val;
+
+	memcpy((uint8_t *)&val, rtw_get_capability_from_ie(bss->IEs), 2);
+
+	return le16_to_cpu(val);
+}
+
+uint8_t *rtw_get_timestampe_from_ie(uint8_t *ie)
+{
+	return (ie + 0);
+}
+
+uint8_t *rtw_get_beacon_interval_from_ie(uint8_t *ie)
+{
+	return (ie + 8);
+}
+
+
+int	rtw_init_mlme_priv (struct rtl_priv *rtlpriv)//(struct	mlme_priv *pmlmepriv)
+{
+	int	res;
+
+	res = _rtw_init_mlme_priv(rtlpriv);// (pmlmepriv);
+
+	return res;
+}
+
+void rtw_free_mlme_priv (struct mlme_priv *pmlmepriv)
+{
+	_rtw_free_mlme_priv (pmlmepriv);
+}
+
+static int rtw_enqueue_network(struct __queue *queue, struct wlan_network *pnetwork)
+{
+	int	res;
+
+	res = _rtw_enqueue_network(queue, pnetwork);
+
+	return res;
+}
+
+/*
+static struct	wlan_network *rtw_dequeue_network(struct __queue *queue)
+{
+	struct wlan_network *pnetwork;
+
+	pnetwork = _rtw_dequeue_network(queue);
+
+	return pnetwork;
+}
+*/
+
+static struct wlan_network *rtw_alloc_network(struct mlme_priv *pmlmepriv )	/* (struct __queue	*free_queue) */
+{
+	struct	wlan_network	*pnetwork;
+
+	pnetwork = _rtw_alloc_network(pmlmepriv);
+
+	return pnetwork;
+}
+
+static void rtw_free_network(struct mlme_priv *pmlmepriv,
+	struct wlan_network *pnetwork, uint8_t is_freeall)/* (struct	wlan_network *pnetwork, struct __queue	*free_queue) */
+{
+	_rtw_free_network(pmlmepriv, pnetwork, is_freeall);
+}
+
+static void rtw_free_network_nolock(struct mlme_priv *pmlmepriv, struct wlan_network *pnetwork )
+{
+	/*
+	 * RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("rtw_free_network==> ssid = %s \n\n" , pnetwork->network.Ssid.Ssid));
+	 */
+	_rtw_free_network_nolock(pmlmepriv, pnetwork);
+}
+
+
+void rtw_free_network_queue(struct rtl_priv *dev, uint8_t isfreeall)
+{
+	_rtw_free_network_queue(dev, isfreeall);
+}
+
+/*
+	return the wlan_network with the matching addr
+
+	Shall be calle under atomic context... to avoid possible racing condition...
+*/
+struct	wlan_network *rtw_find_network(struct __queue *scanned_queue, uint8_t *addr)
+{
+	struct	wlan_network *pnetwork = _rtw_find_network(scanned_queue, addr);
+
+	return pnetwork;
+}
+
+int rtw_is_same_ibss(struct rtl_priv *rtlpriv, struct wlan_network *pnetwork)
+{
+	int ret=true;
+	struct security_priv *psecuritypriv = &rtlpriv->securitypriv;
+
+	if ((psecuritypriv->dot11PrivacyAlgrthm != NO_ENCRYPTION )
+	   && ( pnetwork->network.Privacy == 0 )) {
+		ret=false;
+	} else if ((psecuritypriv->dot11PrivacyAlgrthm == NO_ENCRYPTION )
+		  && ( pnetwork->network.Privacy == 1 ) ) {
+		ret=false;
+	} else {
+		ret=true;
+	}
+
+	return ret;
+
+}
+
+inline int is_same_ess(WLAN_BSSID_EX *a, WLAN_BSSID_EX *b);
+inline int is_same_ess(WLAN_BSSID_EX *a, WLAN_BSSID_EX *b)
+{
+	//RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("(%s,%d)(%s,%d)\n",
+	//		a->Ssid.Ssid,a->Ssid.SsidLength,b->Ssid.Ssid,b->Ssid.SsidLength));
+	return (a->Ssid.SsidLength == b->Ssid.SsidLength)
+		&&  _rtw_memcmp(a->Ssid.Ssid, b->Ssid.Ssid, a->Ssid.SsidLength)==true;
+}
+
+int is_same_network(WLAN_BSSID_EX *src, WLAN_BSSID_EX *dst)
+{
+	 u16 s_cap, d_cap;
+
+	if (rtw_bug_check(dst, src, &s_cap, &d_cap)==false)
+			return false;
+
+	memcpy((uint8_t *)&s_cap, rtw_get_capability_from_ie(src->IEs), 2);
+	memcpy((uint8_t *)&d_cap, rtw_get_capability_from_ie(dst->IEs), 2);
+
+
+	s_cap = le16_to_cpu(s_cap);
+	d_cap = le16_to_cpu(d_cap);
+
+	return ((src->Ssid.SsidLength == dst->Ssid.SsidLength) &&
+		//	(src->Configuration.DSConfig == dst->Configuration.DSConfig) &&
+			( (_rtw_memcmp(src->MacAddress, dst->MacAddress, ETH_ALEN)) == true) &&
+			( (_rtw_memcmp(src->Ssid.Ssid, dst->Ssid.Ssid, src->Ssid.SsidLength)) == true) &&
+			((s_cap & WLAN_CAPABILITY_IBSS) ==
+			(d_cap & WLAN_CAPABILITY_IBSS)) &&
+			((s_cap & WLAN_CAPABILITY_BSS) ==
+			(d_cap & WLAN_CAPABILITY_BSS)));
+
+}
+
+struct wlan_network *rtw_get_oldest_wlan_network(struct __queue *scanned_queue)
+{
+	struct list_head	*plist, *phead;
+
+	struct	wlan_network	*pwlan = NULL;
+	struct	wlan_network	*oldest = NULL;
+
+	phead = get_list_head(scanned_queue);
+	plist = get_next(phead);
+
+	while (1) {
+
+		if (rtw_end_of_queue_search(phead,plist)== true)
+			break;
+
+		pwlan= container_of(plist, struct wlan_network, list);
+
+		if (pwlan->fixed!=true) {
+			if (oldest == NULL ||time_after(oldest->last_scanned, pwlan->last_scanned))
+				oldest = pwlan;
+		}
+
+		plist = get_next(plist);
+	}
+
+	return oldest;
+
+}
+
+void update_network(WLAN_BSSID_EX *dst, WLAN_BSSID_EX *src,
+	struct rtl_priv * rtlpriv, bool update_ie)
+{
+	uint8_t ss_ori = dst->PhyInfo.SignalStrength;
+	uint8_t sq_ori = dst->PhyInfo.SignalQuality;
+	long rssi_ori = dst->Rssi;
+
+	uint8_t ss_smp = src->PhyInfo.SignalStrength;
+	uint8_t sq_smp = src->PhyInfo.SignalQuality;
+	long rssi_smp = src->Rssi;
+
+	uint8_t ss_final;
+	uint8_t sq_final;
+	long rssi_final;
+
+	/* The rule below is 1/5 for sample value, 4/5 for history value */
+	if (check_fwstate(&rtlpriv->mlmepriv, _FW_LINKED) && is_same_network(&(rtlpriv->mlmepriv.cur_network.network), src)) {
+		/* Take the recvpriv's value for the connected AP*/
+		ss_final = rtlpriv->recvpriv.signal_strength;
+		sq_final = rtlpriv->recvpriv.signal_qual;
+		/* the rssi value here is undecorated, and will be used for antenna diversity */
+		if (sq_smp != 101) /* from the right channel */
+			rssi_final = (src->Rssi+dst->Rssi*4)/5;
+		else
+			rssi_final = rssi_ori;
+	} else {
+		if (sq_smp != 101) { /* from the right channel */
+			ss_final = ((uint32_t)(src->PhyInfo.SignalStrength)+(uint32_t)(dst->PhyInfo.SignalStrength)*4)/5;
+			sq_final = ((uint32_t)(src->PhyInfo.SignalQuality)+(uint32_t)(dst->PhyInfo.SignalQuality)*4)/5;
+			rssi_final = (src->Rssi+dst->Rssi*4)/5;
+		} else {
+			/* bss info not receving from the right channel, use the original RX signal infos */
+			ss_final = dst->PhyInfo.SignalStrength;
+			sq_final = dst->PhyInfo.SignalQuality;
+			rssi_final = dst->Rssi;
+		}
+
+	}
+
+	if (update_ie)
+		memcpy((uint8_t *)dst, (uint8_t *)src, get_WLAN_BSSID_EX_sz(src));
+
+	dst->PhyInfo.SignalStrength = ss_final;
+	dst->PhyInfo.SignalQuality = sq_final;
+	dst->Rssi = rssi_final;
+}
+
+static void update_current_network(struct rtl_priv *rtlpriv, WLAN_BSSID_EX *pnetwork)
+{
+	struct	mlme_priv	*pmlmepriv = &(rtlpriv->mlmepriv);
+
+	rtw_bug_check(&(pmlmepriv->cur_network.network),
+		&(pmlmepriv->cur_network.network),
+		&(pmlmepriv->cur_network.network),
+		&(pmlmepriv->cur_network.network));
+
+	if ((check_fwstate(pmlmepriv, _FW_LINKED)== true)
+	   && (is_same_network(&(pmlmepriv->cur_network.network), pnetwork))) {
+		/*
+		 * RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,"Same Network\n");
+		 */
+
+		/* if (pmlmepriv->cur_network.network.IELength<= pnetwork->IELength) */
+		{
+			update_network(&(pmlmepriv->cur_network.network), pnetwork,rtlpriv, true);
+			rtw_update_protection(rtlpriv, (pmlmepriv->cur_network.network.IEs) + sizeof (NDIS_802_11_FIXED_IEs),
+									pmlmepriv->cur_network.network.IELength);
+		}
+	}
+
+
+
+}
+
+
+/*
+
+Caller must hold pmlmepriv->lock first.
+
+
+*/
+void rtw_update_scanned_network(struct rtl_priv *rtlpriv, WLAN_BSSID_EX *target)
+{
+	struct list_head	*plist, *phead;
+	u32	bssid_ex_sz;
+	struct mlme_priv	*pmlmepriv = &(rtlpriv->mlmepriv);
+	struct __queue	*queue	= &(pmlmepriv->scanned_queue);
+	struct wlan_network	*pnetwork = NULL;
+	struct wlan_network	*oldest = NULL;
+
+	spin_lock_bh(&queue->lock);
+	phead = get_list_head(queue);
+	plist = get_next(phead);
+
+	while (1) {
+		if (rtw_end_of_queue_search(phead,plist)== true)
+			break;
+
+		pnetwork = container_of(plist, struct wlan_network, list);
+
+		rtw_bug_check(pnetwork, pnetwork, pnetwork, pnetwork);
+
+		if (is_same_network(&(pnetwork->network), target))
+			break;
+
+		if ((oldest == ((struct wlan_network *)0)) ||
+		time_after(oldest->last_scanned, pnetwork->last_scanned))
+			oldest = pnetwork;
+
+		plist = get_next(plist);
+
+	}
+
+
+	/* If we didn't find a match, then get a new network slot to initialize
+	 * with this beacon's information */
+	if (rtw_end_of_queue_search(phead,plist)== true) {
+
+		if (list_empty(&(pmlmepriv->free_bss_pool.list)) == true) {
+			/* If there are no more slots, expire the oldest */
+			//list_del_init(&oldest->list);
+			pnetwork = oldest;
+
+			memcpy(&(pnetwork->network), target,  get_WLAN_BSSID_EX_sz(target));
+			/*
+			 * pnetwork->last_scanned = jiffies;
+			 * variable initialize
+			 */
+			pnetwork->fixed = false;
+			pnetwork->last_scanned = jiffies;
+
+			pnetwork->network_type = 0;
+			pnetwork->aid=0;
+			pnetwork->join_res=0;
+
+			/* bss info not receving from the right channel */
+			if (pnetwork->network.PhyInfo.SignalQuality == 101)
+				pnetwork->network.PhyInfo.SignalQuality = 0;
+		} else {
+			/* Otherwise just pull from the free list */
+
+			pnetwork = rtw_alloc_network(pmlmepriv); /* will update scan_time */
+
+			if (pnetwork==NULL){
+				goto exit;
+			}
+
+			bssid_ex_sz = get_WLAN_BSSID_EX_sz(target);
+			target->Length = bssid_ex_sz;
+			memcpy(&(pnetwork->network), target, bssid_ex_sz );
+
+			pnetwork->last_scanned = jiffies;
+
+			/* bss info not receving from the right channel */
+			if (pnetwork->network.PhyInfo.SignalQuality == 101)
+				pnetwork->network.PhyInfo.SignalQuality = 0;
+
+			list_add_tail(&(pnetwork->list),&(queue->list));
+
+		}
+	}
+	else {
+		/* we have an entry and we are going to update it. But this entry may
+		 * be already expired. In this case we do the same as we found a new
+		 * net and call the new_net handler
+		 */
+		bool update_ie = true;
+
+		pnetwork->last_scanned = jiffies;
+
+		//target.Reserved[0]==1, means that scaned network is a bcn frame.
+		if ((pnetwork->network.IELength>target->IELength) && (target->Reserved[0]==1))
+			update_ie = false;
+
+		update_network(&(pnetwork->network), target,rtlpriv, update_ie);
+	}
+
+exit:
+	spin_unlock_bh(&queue->lock);
+}
+
+static void rtw_add_network(struct rtl_priv *rtlpriv, WLAN_BSSID_EX *pnetwork)
+{
+	struct	mlme_priv	*pmlmepriv = &(((struct rtl_priv *)rtlpriv)->mlmepriv);
+	//struct __queue	*queue	= &(pmlmepriv->scanned_queue);
+
+
+
+	//spin_lock_bh(&queue->lock, &irqL);
+
+	update_current_network(rtlpriv, pnetwork);
+
+	rtw_update_scanned_network(rtlpriv, pnetwork);
+
+	//spin_unlock_bh(&queue->lock, &irqL);
+
+
+}
+
+//select the desired network based on the capability of the (i)bss.
+// check items: (1) security
+//			   (2) network_type
+//			   (3) WMM
+//			   (4) HT
+//                     (5) others
+static int rtw_is_desired_network(struct rtl_priv *rtlpriv, struct wlan_network *pnetwork)
+{
+	struct security_priv *psecuritypriv = &rtlpriv->securitypriv;
+	struct mlme_priv *pmlmepriv = &rtlpriv->mlmepriv;
+	uint32_t	 desired_encmode;
+	uint32_t	 privacy;
+
+	//uint8_t wps_ie[512];
+	uint wps_ielen;
+
+	int bselected = true;
+
+	desired_encmode = psecuritypriv->ndisencryptstatus;
+	privacy = pnetwork->network.Privacy;
+
+	if (check_fwstate(pmlmepriv, WIFI_UNDER_WPS)) {
+		if (rtw_get_wps_ie(pnetwork->network.IEs+_FIXED_IE_LENGTH_, pnetwork->network.IELength-_FIXED_IE_LENGTH_, NULL, &wps_ielen)!=NULL) {
+			return true;
+		} else {
+			return false;
+		}
+	}
+
+ 	if ((desired_encmode != Ndis802_11EncryptionDisabled) && (privacy == 0)) {
+		DBG_871X("desired_encmode: %d, privacy: %d\n", desired_encmode, privacy);
+		bselected = false;
+ 	}
+
+	if (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true) {
+		if (pnetwork->network.InfrastructureMode != pmlmepriv->cur_network.network.InfrastructureMode)
+			bselected = false;
+	}
+
+
+	return bselected;
+}
+
+/* TODO: Perry : For Power Management */
+void rtw_atimdone_event_callback(struct rtl_priv *rtlpriv , uint8_t *pbuf)
+{
+
+	return;
+}
+
+
+void rtw_survey_event_callback(struct rtl_priv *rtlpriv, uint8_t *pbuf)
+{
+	uint32_t	 len;
+	WLAN_BSSID_EX *pnetwork;
+	struct	mlme_priv	*pmlmepriv = &(rtlpriv->mlmepriv);
+
+
+	pnetwork = (WLAN_BSSID_EX *)pbuf;
+
+	len = get_WLAN_BSSID_EX_sz(pnetwork);
+	if (len > (sizeof(WLAN_BSSID_EX))) {
+		return;
+	}
+
+
+	spin_lock_bh(&pmlmepriv->lock);
+
+	// update IBSS_network 's timestamp
+	if ((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)) == true) {
+		//RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,"rtw_survey_event_callback : WIFI_ADHOC_MASTER_STATE \n\n");
+		if (_rtw_memcmp(&(pmlmepriv->cur_network.network.MacAddress), pnetwork->MacAddress, ETH_ALEN)) {
+			struct wlan_network* ibss_wlan = NULL;
+
+			memcpy(pmlmepriv->cur_network.network.IEs, pnetwork->IEs, 8);
+			spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
+			ibss_wlan = rtw_find_network(&pmlmepriv->scanned_queue,  pnetwork->MacAddress);
+			if (ibss_wlan) {
+				memcpy(ibss_wlan->network.IEs , pnetwork->IEs, 8);
+				spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
+				goto exit;
+			}
+			spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
+		}
+	}
+
+	// lock pmlmepriv->lock when you accessing network_q
+	if ((check_fwstate(pmlmepriv, _FW_UNDER_LINKING)) == false) {
+   	        if ( pnetwork->Ssid.Ssid[0] == 0 ) {
+			pnetwork->Ssid.SsidLength = 0;
+		}
+		rtw_add_network(rtlpriv, pnetwork);
+	}
+
+exit:
+
+	spin_unlock_bh(&pmlmepriv->lock);
+
+	return;
+}
+
+
+
+void rtw_surveydone_event_callback(struct rtl_priv	*rtlpriv, uint8_t *pbuf)
+{
+	struct	mlme_priv	*pmlmepriv = &(rtlpriv->mlmepriv);
+
+#ifdef CONFIG_MLME_EXT
+
+	mlmeext_surveydone_event_callback(rtlpriv);
+
+#endif
+
+
+
+	spin_lock_bh(&pmlmepriv->lock);
+
+	if (pmlmepriv->wps_probe_req_ie) {
+		/* ULLI check usage of free_len */
+		uint32_t	 free_len = pmlmepriv->wps_probe_req_ie_len;
+
+		pmlmepriv->wps_probe_req_ie_len = 0;
+		rtw_mfree(pmlmepriv->wps_probe_req_ie);
+		pmlmepriv->wps_probe_req_ie = NULL;
+	}
+
+	if (check_fwstate(pmlmepriv,_FW_UNDER_SURVEY)) {
+		del_timer_sync(&pmlmepriv->scan_to_timer);
+
+		_clr_fwstate_(pmlmepriv, _FW_UNDER_SURVEY);
+	} else {
+		;
+	}
+
+#ifdef CONFIG_NEW_SIGNAL_STAT_PROCESS
+	rtw_set_signal_stat_timer(&rtlpriv->recvpriv);
+#endif
+
+	if (pmlmepriv->to_join == true) {
+		if ((check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)==true) )
+		{
+			if (check_fwstate(pmlmepriv, _FW_LINKED)==false)
+			{
+				set_fwstate(pmlmepriv, _FW_UNDER_LINKING);
+
+		   		if (rtw_select_and_join_from_scanned_queue(pmlmepriv)==_SUCCESS)
+		   		{
+		       			_set_timer(&pmlmepriv->assoc_timer, MAX_JOIN_TIMEOUT );
+                  		}
+		   		else
+		  		{
+					WLAN_BSSID_EX    *pdev_network = &(rtlpriv->registrypriv.dev_network);
+					uint8_t *pibss = rtlpriv->registrypriv.dev_network.MacAddress;
+
+					//pmlmepriv->fw_state ^= _FW_UNDER_SURVEY;//because don't set assoc_timer
+					_clr_fwstate_(pmlmepriv, _FW_UNDER_SURVEY);
+
+					memset(&pdev_network->Ssid, 0, sizeof(NDIS_802_11_SSID));
+					memcpy(&pdev_network->Ssid, &pmlmepriv->assoc_ssid, sizeof(NDIS_802_11_SSID));
+
+					rtw_update_registrypriv_dev_network(rtlpriv);
+					rtw_generate_random_ibss(pibss);
+
+                       			pmlmepriv->fw_state = WIFI_ADHOC_MASTER_STATE;
+
+					if (rtw_createbss_cmd(rtlpriv)!=_SUCCESS)
+					{
+						;
+					}
+
+			     		pmlmepriv->to_join = false;
+		   		}
+		 	}
+		} else 	{
+			int s_ret;
+			set_fwstate(pmlmepriv, _FW_UNDER_LINKING);
+			pmlmepriv->to_join = false;
+			if (_SUCCESS == (s_ret=rtw_select_and_join_from_scanned_queue(pmlmepriv))) {
+	     		     _set_timer(&pmlmepriv->assoc_timer, MAX_JOIN_TIMEOUT);
+			} else if (s_ret == 2) {//there is no need to wait for join
+				_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);
+				rtw_indicate_connect(rtlpriv);
+			} else 	{
+				DBG_871X("try_to_join, but select scanning queue fail, to_roaming:%d\n", 0);
+				_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);
+			}
+		}
+	}
+
+	indicate_wx_scan_complete_event(rtlpriv);
+	//DBG_871X("scan complete in %dms\n",rtw_get_passing_time_ms(pmlmepriv->scan_start_time));
+
+	spin_unlock_bh(&pmlmepriv->lock);
+
+	rtw_os_xmit_schedule(rtlpriv);
+
+
+
+}
+
+void rtw_dummy_event_callback(struct rtl_priv *rtlpriv , uint8_t *pbuf)
+{
+
+}
+
+void rtw_fwdbg_event_callback(struct rtl_priv *rtlpriv , uint8_t *pbuf)
+{
+
+}
+
+static void free_scanqueue(struct	mlme_priv *pmlmepriv)
+{
+	struct __queue *free_queue = &pmlmepriv->free_bss_pool;
+	struct __queue *scan_queue = &pmlmepriv->scanned_queue;
+	struct list_head	*plist, *phead, *ptemp;
+
+	spin_lock_bh(&scan_queue->lock);
+	spin_lock_bh(&free_queue->lock);
+
+	phead = get_list_head(scan_queue);
+	plist = get_next(phead);
+
+	while (plist != phead) {
+		ptemp = get_next(plist);
+		list_del_init(plist);
+		list_add_tail(plist, &free_queue->list);
+		plist =ptemp;
+		pmlmepriv->num_of_scanned --;
+        }
+
+	spin_unlock_bh(&free_queue->lock);
+	spin_unlock_bh(&scan_queue->lock);
+
+}
+
+/*
+*rtw_free_assoc_resources: the caller has to lock pmlmepriv->lock
+*/
+void rtw_free_assoc_resources(struct rtl_priv *rtlpriv, int lock_scanned_queue)
+{
+	struct wlan_network* pwlan = NULL;
+     	struct	mlme_priv *pmlmepriv = &rtlpriv->mlmepriv;
+   	struct	sta_priv *pstapriv = &rtlpriv->stapriv;
+	struct wlan_network *tgt_network = &pmlmepriv->cur_network;
+
+
+
+	if (check_fwstate( pmlmepriv, WIFI_STATION_STATE|WIFI_AP_STATE)) {
+		struct sta_info* psta;
+
+		psta = rtw_get_stainfo(&rtlpriv->stapriv, tgt_network->network.MacAddress);
+		{
+			spin_lock_bh(&(pstapriv->sta_hash_lock));
+			rtw_free_stainfo(rtlpriv,  psta);
+		}
+
+		spin_unlock_bh(&(pstapriv->sta_hash_lock));
+
+	}
+
+	if (check_fwstate( pmlmepriv, WIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE|WIFI_AP_STATE)) {
+		struct sta_info* psta;
+
+		rtw_free_all_stainfo(rtlpriv);
+
+		psta = rtw_get_bcmc_stainfo(rtlpriv);
+		spin_lock_bh(&(pstapriv->sta_hash_lock));
+		rtw_free_stainfo(rtlpriv, psta);
+		spin_unlock_bh(&(pstapriv->sta_hash_lock));
+
+		rtw_init_bcmc_stainfo(rtlpriv);
+	}
+
+	if (lock_scanned_queue)
+		spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
+
+	pwlan = rtw_find_network(&pmlmepriv->scanned_queue, tgt_network->network.MacAddress);
+	if (pwlan) {
+		pwlan->fixed = false;
+	} else {
+		;
+	}
+
+
+	if ((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) && (rtlpriv->stapriv.asoc_sta_count== 1))
+		/*||check_fwstate(pmlmepriv, WIFI_STATION_STATE)*/)
+	{
+		rtw_free_network_nolock(pmlmepriv, pwlan);
+	}
+
+	if (lock_scanned_queue)
+		spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
+
+	pmlmepriv->key_mask = 0;
+
+}
+
+/*
+*rtw_indicate_connect: the caller has to lock pmlmepriv->lock
+*/
+void rtw_indicate_connect(struct rtl_priv *rtlpriv)
+{
+	struct mlme_priv	*pmlmepriv = &rtlpriv->mlmepriv;
+	struct xmit_priv	*pxmitpriv = &rtlpriv->xmitpriv;
+
+	pmlmepriv->to_join = false;
+
+	if (!check_fwstate(&rtlpriv->mlmepriv, _FW_LINKED)) {
+		set_fwstate(pmlmepriv, _FW_LINKED);
+		rtw_os_indicate_connect(rtlpriv);
+
+	}
+}
+
+
+/*
+*rtw_indicate_disconnect: the caller has to lock pmlmepriv->lock
+*/
+void rtw_indicate_disconnect( struct rtl_priv *rtlpriv )
+{
+	struct	mlme_priv *pmlmepriv = &rtlpriv->mlmepriv;
+	struct mlme_ext_priv *pmlmeext = &(rtlpriv->mlmeextpriv);
+	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
+	WLAN_BSSID_EX	*cur_network = &(pmlmeinfo->network);
+	struct sta_info *psta;
+	struct sta_priv *pstapriv = &rtlpriv->stapriv;
+
+	_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING|WIFI_UNDER_WPS);
+
+        //DBG_871X("clear wps when %s\n", __func__);
+
+	if (check_fwstate(&rtlpriv->mlmepriv, _FW_LINKED)
+	   || (0 <= 0)) {
+		rtw_os_indicate_disconnect(rtlpriv);
+
+		//set ips_deny_time to avoid enter IPS before LPS leave
+		rtlpriv->pwrctrlpriv.ips_deny_time = jiffies + rtw_ms_to_systime(3000);
+
+		_clr_fwstate_(pmlmepriv, _FW_LINKED);
+	}
+
+	rtw_lps_ctrl_wk_cmd(rtlpriv, LPS_CTRL_DISCONNECT, 1);
+}
+
+inline void rtw_indicate_scan_done( struct rtl_priv *rtlpriv, bool aborted)
+{
+	rtw_os_indicate_scan_done(rtlpriv, aborted);
+}
+
+void rtw_scan_abort(struct rtl_priv *rtlpriv)
+{
+	uint32_t	 cnt=0;
+	uint32_t	 start;
+	struct mlme_priv	*pmlmepriv = &(rtlpriv->mlmepriv);
+	struct mlme_ext_priv	*pmlmeext = &(rtlpriv->mlmeextpriv);
+
+	start = jiffies;
+	pmlmeext->scan_abort = true;
+	while (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY)
+		&& rtw_get_passing_time_ms(start) <= 200) {
+
+		if (rtlpriv->bDriverStopped || rtlpriv->bSurpriseRemoved)
+			break;
+
+		DBG_871X(FUNC_NDEV_FMT"fw_state=_FW_UNDER_SURVEY!\n", FUNC_NDEV_ARG(rtlpriv->ndev));
+		msleep(20);
+	}
+
+	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY)) {
+		if (!rtlpriv->bDriverStopped && !rtlpriv->bSurpriseRemoved)
+			DBG_871X(FUNC_NDEV_FMT"waiting for scan_abort time out!\n", FUNC_NDEV_ARG(rtlpriv->ndev));
+		rtw_indicate_scan_done(rtlpriv, true);
+	}
+	pmlmeext->scan_abort = false;
+}
+
+static struct sta_info *rtw_joinbss_update_stainfo(struct rtl_priv *rtlpriv, struct wlan_network *pnetwork)
+{
+	int i;
+	struct sta_info *bmc_sta, *psta=NULL;
+	struct recv_reorder_ctrl *preorder_ctrl;
+	struct sta_priv *pstapriv = &rtlpriv->stapriv;
+	struct mlme_ext_priv	*pmlmeext = &rtlpriv->mlmeextpriv;
+
+	psta = rtw_get_stainfo(pstapriv, pnetwork->network.MacAddress);
+	if (psta==NULL) {
+		psta = rtw_alloc_stainfo(pstapriv, pnetwork->network.MacAddress);
+	}
+
+	if (psta) //update ptarget_sta
+	{
+		DBG_871X("%s\n", __FUNCTION__);
+
+		psta->aid  = pnetwork->join_res;
+
+		//psta->raid = networktype_to_raid(pmlmeext->cur_wireless_mode);
+		psta->raid = rtw_hal_networktype_to_raid(rtlpriv,pmlmeext->cur_wireless_mode);
+
+
+		//sta mode
+		rtw_set_sta_info(rtlpriv, psta, true);
+
+		//security related
+		if (rtlpriv->securitypriv.dot11AuthAlgrthm== dot11AuthAlgrthm_8021X)
+		{
+			rtlpriv->securitypriv.binstallGrpkey=false;
+			rtlpriv->securitypriv.busetkipkey=false;
+			rtlpriv->securitypriv.bgrpkey_handshake=false;
+
+			psta->ieee8021x_blocked=true;
+			psta->dot118021XPrivacy=rtlpriv->securitypriv.dot11PrivacyAlgrthm;
+
+			memset((uint8_t *)&psta->dot118021x_UncstKey, 0, sizeof (union Keytype));
+
+			memset((uint8_t *)&psta->dot11tkiprxmickey, 0, sizeof (union Keytype));
+			memset((uint8_t *)&psta->dot11tkiptxmickey, 0, sizeof (union Keytype));
+
+			memset((uint8_t *)&psta->dot11txpn, 0, sizeof (union pn48));
+			memset((uint8_t *)&psta->dot11rxpn, 0, sizeof (union pn48));
+		}
+
+		//	Commented by Albert 2012/07/21
+		//	When doing the WPS, the wps_ie_len won't equal to 0
+		//	And the Wi-Fi driver shouldn't allow the data packet to be tramsmitted.
+		if ( rtlpriv->securitypriv.wps_ie_len != 0 )
+		{
+			psta->ieee8021x_blocked=true;
+			rtlpriv->securitypriv.wps_ie_len = 0;
+		}
+
+
+		//for A-MPDU Rx reordering buffer control for bmc_sta & sta_info
+		//if A-MPDU Rx is enabled, reseting  rx_ordering_ctrl wstart_b(indicate_seq) to default value=0xffff
+		//todo: check if AP can send A-MPDU packets
+		for(i=0; i < 16 ; i++)
+		{
+			//preorder_ctrl = &precvpriv->recvreorder_ctrl[i];
+			preorder_ctrl = &psta->recvreorder_ctrl[i];
+			preorder_ctrl->enable = false;
+			preorder_ctrl->indicate_seq = 0xffff;
+			preorder_ctrl->wend_b= 0xffff;
+			preorder_ctrl->wsize_b = 64;//max_ampdu_sz;//ex. 32(kbytes) -> wsize_b=32
+		}
+
+
+		bmc_sta = rtw_get_bcmc_stainfo(rtlpriv);
+		if (bmc_sta)
+		{
+			for(i=0; i < 16 ; i++)
+			{
+				//preorder_ctrl = &precvpriv->recvreorder_ctrl[i];
+				preorder_ctrl = &bmc_sta->recvreorder_ctrl[i];
+				preorder_ctrl->enable = false;
+				preorder_ctrl->indicate_seq = 0xffff;
+				preorder_ctrl->wend_b= 0xffff;
+				preorder_ctrl->wsize_b = 64;//max_ampdu_sz;//ex. 32(kbytes) -> wsize_b=32
+			}
+		}
+
+
+		//misc.
+		update_sta_info(rtlpriv, psta);
+
+	}
+
+	return psta;
+
+}
+
+//pnetwork : returns from rtw_joinbss_event_callback
+//ptarget_wlan: found from scanned_queue
+static void rtw_joinbss_update_network(struct rtl_priv *rtlpriv, struct wlan_network *ptarget_wlan, struct wlan_network  *pnetwork)
+{
+	struct mlme_priv	*pmlmepriv = &(rtlpriv->mlmepriv);
+	struct wlan_network  *cur_network = &(pmlmepriv->cur_network);
+
+	DBG_871X("%s\n", __FUNCTION__);
+
+	// why not use ptarget_wlan??
+	memcpy(&cur_network->network, &pnetwork->network, pnetwork->network.Length);
+	// some IEs in pnetwork is wrong, so we should use ptarget_wlan IEs
+	cur_network->network.IELength = ptarget_wlan->network.IELength;
+	memcpy(&cur_network->network.IEs[0], &ptarget_wlan->network.IEs[0], MAX_IE_SZ);
+
+	cur_network->aid = pnetwork->join_res;
+
+
+#ifdef CONFIG_NEW_SIGNAL_STAT_PROCESS
+	rtw_set_signal_stat_timer(&rtlpriv->recvpriv);
+#endif
+	rtlpriv->recvpriv.signal_strength = ptarget_wlan->network.PhyInfo.SignalStrength;
+	rtlpriv->recvpriv.signal_qual = ptarget_wlan->network.PhyInfo.SignalQuality;
+	//the ptarget_wlan->network.Rssi is raw data, we use ptarget_wlan->network.PhyInfo.SignalStrength instead (has scaled)
+	rtlpriv->recvpriv.rssi = translate_percentage_to_dbm(ptarget_wlan->network.PhyInfo.SignalStrength);
+#ifdef CONFIG_NEW_SIGNAL_STAT_PROCESS
+	rtw_set_signal_stat_timer(&rtlpriv->recvpriv);
+#endif
+
+	//update fw_state //will clr _FW_UNDER_LINKING here indirectly
+	switch(pnetwork->network.InfrastructureMode)
+	{
+		case Ndis802_11Infrastructure:
+
+				if (pmlmepriv->fw_state&WIFI_UNDER_WPS)
+					pmlmepriv->fw_state = WIFI_STATION_STATE|WIFI_UNDER_WPS;
+				else
+					pmlmepriv->fw_state = WIFI_STATION_STATE;
+
+				break;
+		case Ndis802_11IBSS:
+				pmlmepriv->fw_state = WIFI_ADHOC_STATE;
+				break;
+		default:
+				pmlmepriv->fw_state = WIFI_NULL_STATE;
+				break;
+	}
+
+	rtw_update_protection(rtlpriv, (cur_network->network.IEs) + sizeof (NDIS_802_11_FIXED_IEs),
+									(cur_network->network.IELength));
+
+	rtw_update_ht_cap(rtlpriv, cur_network->network.IEs, cur_network->network.IELength, (uint8_t) cur_network->network.Configuration.DSConfig);
+}
+
+//Notes: the fucntion could be > passive_level (the same context as Rx tasklet)
+//pnetwork : returns from rtw_joinbss_event_callback
+//ptarget_wlan: found from scanned_queue
+//if join_res > 0, for (fw_state==WIFI_STATION_STATE), we check if  "ptarget_sta" & "ptarget_wlan" exist.
+//if join_res > 0, for (fw_state==WIFI_ADHOC_STATE), we only check if "ptarget_wlan" exist.
+//if join_res > 0, update "cur_network->network" from "pnetwork->network" if (ptarget_wlan !=NULL).
+//
+//#define REJOIN
+void rtw_joinbss_event_prehandle(struct rtl_priv *rtlpriv, uint8_t *pbuf)
+{
+	static uint8_t retry=0;
+	struct sta_info *ptarget_sta= NULL, *pcur_sta = NULL;
+   	struct	sta_priv *pstapriv = &rtlpriv->stapriv;
+	struct	mlme_priv	*pmlmepriv = &(rtlpriv->mlmepriv);
+	struct wlan_network 	*pnetwork	= (struct wlan_network *)pbuf;
+	struct wlan_network 	*cur_network = &(pmlmepriv->cur_network);
+	struct wlan_network	*pcur_wlan = NULL, *ptarget_wlan = NULL;
+	unsigned int 		the_same_macaddr = false;
+
+	rtw_get_encrypt_decrypt_from_registrypriv(rtlpriv);
+
+	the_same_macaddr = _rtw_memcmp(pnetwork->network.MacAddress, cur_network->network.MacAddress, ETH_ALEN);
+
+	pnetwork->network.Length = get_WLAN_BSSID_EX_sz(&pnetwork->network);
+	if (pnetwork->network.Length > sizeof(WLAN_BSSID_EX))
+	{
+		goto ignore_joinbss_callback;
+	}
+
+	spin_lock_bh(&pmlmepriv->lock);
+
+	if (pnetwork->join_res > 0)
+	{
+		spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
+		retry = 0;
+		if (check_fwstate(pmlmepriv,_FW_UNDER_LINKING) )
+		{
+			//s1. find ptarget_wlan
+			if (check_fwstate(pmlmepriv, _FW_LINKED) )
+			{
+				if (the_same_macaddr == true)
+				{
+					ptarget_wlan = rtw_find_network(&pmlmepriv->scanned_queue, cur_network->network.MacAddress);
+				}
+				else
+				{
+					pcur_wlan = rtw_find_network(&pmlmepriv->scanned_queue, cur_network->network.MacAddress);
+					if (pcur_wlan)	pcur_wlan->fixed = false;
+
+					pcur_sta = rtw_get_stainfo(pstapriv, cur_network->network.MacAddress);
+					if (pcur_sta){
+						spin_lock_bh(&(pstapriv->sta_hash_lock));
+						rtw_free_stainfo(rtlpriv,  pcur_sta);
+						spin_unlock_bh(&(pstapriv->sta_hash_lock));
+					}
+
+					ptarget_wlan = rtw_find_network(&pmlmepriv->scanned_queue, pnetwork->network.MacAddress);
+					if (check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true){
+						if (ptarget_wlan)	ptarget_wlan->fixed = true;
+					}
+				}
+
+			}
+			else
+			{
+				ptarget_wlan = rtw_find_network(&pmlmepriv->scanned_queue, pnetwork->network.MacAddress);
+				if (check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true){
+					if (ptarget_wlan)	ptarget_wlan->fixed = true;
+				}
+			}
+
+			//s2. update cur_network
+			if (ptarget_wlan)
+			{
+				rtw_joinbss_update_network(rtlpriv, ptarget_wlan, pnetwork);
+			}
+			else
+			{
+				spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
+				goto ignore_joinbss_callback;
+			}
+
+
+			//s3. find ptarget_sta & update ptarget_sta after update cur_network only for station mode
+			if (check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true)
+			{
+				ptarget_sta = rtw_joinbss_update_stainfo(rtlpriv, pnetwork);
+				if (ptarget_sta==NULL)
+				{
+					spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
+					goto ignore_joinbss_callback;
+				}
+			}
+
+			//s4. indicate connect
+				if (check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true)
+				{
+					rtw_indicate_connect(rtlpriv);
+				}
+				else
+				{
+					;
+					//adhoc mode will rtw_indicate_connect when rtw_stassoc_event_callback
+				}
+
+
+			//s5. Cancle assoc_timer
+			del_timer_sync(&pmlmepriv->assoc_timer);
+
+
+		}
+		else
+		{
+			spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
+			goto ignore_joinbss_callback;
+		}
+
+		spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
+
+	}
+	else if (pnetwork->join_res == -4)
+	{
+		rtw_reset_securitypriv(rtlpriv);
+		_set_timer(&pmlmepriv->assoc_timer, 1);
+
+		//rtw_free_assoc_resources(rtlpriv, 1);
+
+		if ((check_fwstate(pmlmepriv, _FW_UNDER_LINKING)) == true)
+		{
+			_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);
+		}
+
+	}
+	else //if join_res < 0 (join fails), then try again
+	{
+
+		#ifdef REJOIN
+		res = _FAIL;
+		if (retry < 2) {
+			res = rtw_select_and_join_from_scanned_queue(pmlmepriv);
+		}
+
+		 if (res == _SUCCESS)
+		{
+			//extend time of assoc_timer
+			_set_timer(&pmlmepriv->assoc_timer, MAX_JOIN_TIMEOUT);
+			retry++;
+		}
+		else if (res == 2)//there is no need to wait for join
+		{
+			_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);
+			rtw_indicate_connect(rtlpriv);
+		}
+		else
+		{
+			RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("Set Assoc_Timer = 1; can't find match ssid in scanned_q \n"));
+		#endif
+
+			_set_timer(&pmlmepriv->assoc_timer, 1);
+			//rtw_free_assoc_resources(rtlpriv, 1);
+			_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);
+
+		#ifdef REJOIN
+			retry = 0;
+		}
+		#endif
+	}
+
+ignore_joinbss_callback:
+
+	spin_unlock_bh(&pmlmepriv->lock);
+
+}
+
+void rtw_joinbss_event_callback(struct rtl_priv *rtlpriv, uint8_t *pbuf)
+{
+	struct wlan_network 	*pnetwork	= (struct wlan_network *)pbuf;
+
+
+
+	mlmeext_joinbss_event_callback(rtlpriv, pnetwork->join_res);
+
+	rtw_os_xmit_schedule(rtlpriv);
+
+
+}
+
+uint8_t search_max_mac_id(struct rtl_priv *rtlpriv)
+{
+	uint8_t mac_id, aid;
+#if (RATE_ADAPTIVE_SUPPORT==1)	//for 88E RA
+	struct mlme_priv *pmlmepriv = &(rtlpriv->mlmepriv);
+	struct mlme_ext_priv *pmlmeext = &(rtlpriv->mlmeextpriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct sta_priv *pstapriv = &rtlpriv->stapriv;
+
+#if defined (CONFIG_AP_MODE)
+	if (check_fwstate(pmlmepriv, WIFI_AP_STATE)){
+
+#if 1
+		_irqL irqL;
+		struct rtl_usb *rtlusb = rtl_usbdev(rtlpriv);
+
+		spin_lock_bh(&rtlusb->lock, &irqL);
+		for(mac_id=(NUM_STA-1); mac_id>0; mac_id--)
+			if (pdvobj->macid[mac_id] == true)
+				break;
+		spin_unlock_bh(&rtlusb->lock, &irqL);
+
+#else
+		for (aid = (pstapriv->max_num_sta); aid > 0; aid--)
+		{
+			if (pstapriv->sta_aid[aid-1] != NULL)
+			{
+				psta = pstapriv->sta_aid[aid-1];
+				break;
+		}
+		}
+/*
+		for (mac_id = (pstapriv->max_num_sta-1); mac_id >= 0; mac_id--)
+		{
+			if (pstapriv->sta_aid[mac_id] != NULL)
+				break;
+		}
+*/
+		mac_id = aid + 1;
+#endif
+	}
+	else
+#endif
+	{//adhoc  id =  31~2
+		for (mac_id = (NUM_STA-1); mac_id >= IBSS_START_MAC_ID ; mac_id--)
+		{
+			if (pmlmeinfo->FW_sta_info[mac_id].status == 1)
+			{
+				break;
+			}
+		}
+	}
+#endif
+
+	DBG_871X("max mac_id=%d\n", mac_id);
+
+	return mac_id;
+
+}
+
+//FOR AP ,AD-HOC mode
+void rtw_stassoc_hw_rpt(struct rtl_priv *rtlpriv,struct sta_info *psta)
+{
+	u16 media_status;
+
+	if (psta==NULL)	return;
+
+	#if (RATE_ADAPTIVE_SUPPORT==1)	//for 88E RA
+	{
+		uint8_t macid = search_max_mac_id(rtlpriv);
+		rtlpriv->cfg->ops->set_hw_reg(rtlpriv,HW_VAR_TX_RPT_MAX_MACID, (uint8_t *)&macid);
+	}
+	#endif
+	media_status = (psta->mac_id<<8)|1; //  MACID|OPMODE:1 connect
+	rtlpriv->cfg->ops->set_hw_reg(rtlpriv,HW_VAR_H2C_MEDIA_STATUS_RPT,(uint8_t *)&media_status);
+}
+
+void rtw_stassoc_event_callback(struct rtl_priv *rtlpriv, uint8_t *pbuf)
+{
+	struct sta_info *psta;
+	struct mlme_priv *pmlmepriv = &(rtlpriv->mlmepriv);
+	struct stassoc_event	*pstassoc	= (struct stassoc_event*)pbuf;
+	struct wlan_network 	*cur_network = &(pmlmepriv->cur_network);
+	struct wlan_network	*ptarget_wlan = NULL;
+
+
+
+	if (rtw_access_ctrl(rtlpriv, pstassoc->macaddr) == false)
+		return;
+
+#if defined (CONFIG_AP_MODE)
+	if (check_fwstate(pmlmepriv, WIFI_AP_STATE))
+	{
+		psta = rtw_get_stainfo(&rtlpriv->stapriv, pstassoc->macaddr);
+		if (psta)
+		{
+			//bss_cap_update_on_sta_join(rtlpriv, psta);
+			//sta_info_update(rtlpriv, psta);
+			ap_sta_info_defer_update(rtlpriv, psta);
+
+			rtw_stassoc_hw_rpt(rtlpriv,psta);
+		}
+
+		goto exit;
+	}
+#endif
+	//for AD-HOC mode
+	psta = rtw_get_stainfo(&rtlpriv->stapriv, pstassoc->macaddr);
+	if ( psta != NULL)
+	{
+		//the sta have been in sta_info_queue => do nothing
+
+		goto exit; //(between drv has received this event before and  fw have not yet to set key to CAM_ENTRY)
+	}
+
+	psta = rtw_alloc_stainfo(&rtlpriv->stapriv, pstassoc->macaddr);
+	if (psta == NULL) {
+		goto exit;
+	}
+
+	//to do : init sta_info variable
+	psta->qos_option = 0;
+	psta->mac_id = (uint)pstassoc->cam_id;
+	//psta->aid = (uint)pstassoc->cam_id;
+	DBG_871X("%s\n",__FUNCTION__);
+	//for ad-hoc mode
+	rtw_set_sta_info(rtlpriv, psta, true);
+
+	rtw_stassoc_hw_rpt(rtlpriv,psta);
+
+	if (rtlpriv->securitypriv.dot11AuthAlgrthm==dot11AuthAlgrthm_8021X)
+		psta->dot118021XPrivacy = rtlpriv->securitypriv.dot11PrivacyAlgrthm;
+
+
+	psta->ieee8021x_blocked = false;
+
+	spin_lock_bh(&pmlmepriv->lock);
+
+	if ( (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)==true ) ||
+		(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)==true ) )
+	{
+		if (rtlpriv->stapriv.asoc_sta_count== 2)
+		{
+			spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
+			ptarget_wlan = rtw_find_network(&pmlmepriv->scanned_queue, cur_network->network.MacAddress);
+			if (ptarget_wlan)	ptarget_wlan->fixed = true;
+			spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
+			// a sta + bc/mc_stainfo (not Ibss_stainfo)
+			rtw_indicate_connect(rtlpriv);
+		}
+	}
+
+	spin_unlock_bh(&pmlmepriv->lock);
+
+
+	mlmeext_sta_add_event_callback(rtlpriv, psta);
+
+exit:
+
+	;
+
+}
+
+void rtw_stadel_event_callback(struct rtl_priv *rtlpriv, uint8_t *pbuf)
+{
+	int mac_id = (-1);
+	struct sta_info *psta;
+	struct wlan_network* pwlan = NULL;
+	WLAN_BSSID_EX    *pdev_network=NULL;
+	uint8_t * pibss = NULL;
+	struct	mlme_priv	*pmlmepriv = &(rtlpriv->mlmepriv);
+	struct 	stadel_event *pstadel	= (struct stadel_event*)pbuf;
+   	struct	sta_priv *pstapriv = &rtlpriv->stapriv;
+	struct wlan_network *tgt_network = &(pmlmepriv->cur_network);
+
+
+
+	psta = rtw_get_stainfo(&rtlpriv->stapriv, pstadel->macaddr);
+	if (psta)
+		mac_id = psta->mac_id;
+	else
+		mac_id = pstadel->mac_id;
+
+	DBG_871X("%s(mac_id=%d)=" MAC_FMT "\n", __func__, mac_id, MAC_ARG(pstadel->macaddr));
+
+	if (mac_id>=0){
+		u16 media_status;
+		media_status = (mac_id<<8)|0; //  MACID|OPMODE:0 means disconnect
+		//for STA,AP,ADHOC mode, report disconnect stauts to FW
+		rtlpriv->cfg->ops->set_hw_reg(rtlpriv, HW_VAR_H2C_MEDIA_STATUS_RPT, (uint8_t *)&media_status);
+	}
+
+        if (check_fwstate(pmlmepriv, WIFI_AP_STATE))
+        {
+		return;
+        }
+
+
+	mlmeext_sta_del_event_callback(rtlpriv);
+
+	spin_lock_bh(&pmlmepriv->lock);
+
+	if (check_fwstate(pmlmepriv, WIFI_STATION_STATE) )
+	{
+		rtw_free_uc_swdec_pending_queue(rtlpriv);
+
+		rtw_free_assoc_resources(rtlpriv, 1);
+		rtw_indicate_disconnect(rtlpriv);
+		spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
+		// remove the network entry in scanned_queue
+		pwlan = rtw_find_network(&pmlmepriv->scanned_queue, tgt_network->network.MacAddress);
+		if (pwlan) {
+			pwlan->fixed = false;
+			rtw_free_network_nolock(pmlmepriv, pwlan);
+		}
+		spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
+	}
+
+	if ( check_fwstate(pmlmepriv,WIFI_ADHOC_MASTER_STATE) ||
+	      check_fwstate(pmlmepriv,WIFI_ADHOC_STATE))
+	{
+
+		spin_lock_bh(&(pstapriv->sta_hash_lock));
+		rtw_free_stainfo(rtlpriv,  psta);
+		spin_unlock_bh(&(pstapriv->sta_hash_lock));
+
+		if (rtlpriv->stapriv.asoc_sta_count== 1) //a sta + bc/mc_stainfo (not Ibss_stainfo)
+		{
+			//rtw_indicate_disconnect(rtlpriv);//removed@20091105
+			spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
+			//free old ibss network
+			//pwlan = rtw_find_network(&pmlmepriv->scanned_queue, pstadel->macaddr);
+			pwlan = rtw_find_network(&pmlmepriv->scanned_queue, tgt_network->network.MacAddress);
+			if (pwlan)
+			{
+				pwlan->fixed = false;
+				rtw_free_network_nolock(pmlmepriv, pwlan);
+			}
+			spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
+			//re-create ibss
+			pdev_network = &(rtlpriv->registrypriv.dev_network);
+			pibss = rtlpriv->registrypriv.dev_network.MacAddress;
+
+			memcpy(pdev_network, &tgt_network->network, get_WLAN_BSSID_EX_sz(&tgt_network->network));
+
+			memset(&pdev_network->Ssid, 0, sizeof(NDIS_802_11_SSID));
+			memcpy(&pdev_network->Ssid, &pmlmepriv->assoc_ssid, sizeof(NDIS_802_11_SSID));
+
+			rtw_update_registrypriv_dev_network(rtlpriv);
+
+			rtw_generate_random_ibss(pibss);
+
+			if (check_fwstate(pmlmepriv,WIFI_ADHOC_STATE))
+			{
+				set_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE);
+				_clr_fwstate_(pmlmepriv, WIFI_ADHOC_STATE);
+			}
+
+			if (rtw_createbss_cmd(rtlpriv)!=_SUCCESS)
+			{
+				;
+
+			}
+
+
+		}
+
+	}
+
+	spin_unlock_bh(&pmlmepriv->lock);
+
+
+
+}
+
+
+void rtw_cpwm_event_callback(struct rtl_priv *rtlpriv, uint8_t *pbuf)
+{
+
+
+
+
+
+}
+
+/*
+* _rtw_join_timeout_handler - Timeout/faliure handler for CMD JoinBss
+* @rtlpriv: pointer to struct rtl_priv structure
+*/
+void _rtw_join_timeout_handler (struct rtl_priv *rtlpriv)
+{
+	struct	mlme_priv *pmlmepriv = &rtlpriv->mlmepriv;
+
+
+
+
+	DBG_871X("%s, fw_state=%x\n", __FUNCTION__, get_fwstate(pmlmepriv));
+
+	if (rtlpriv->bDriverStopped ||rtlpriv->bSurpriseRemoved)
+		return;
+
+
+	spin_lock_bh(&pmlmepriv->lock);
+
+	{
+		rtw_indicate_disconnect(rtlpriv);
+		free_scanqueue(pmlmepriv);//???
+
+ 	}
+
+	spin_unlock_bh(&pmlmepriv->lock);
+
+
+
+}
+
+/*
+* rtw_scan_timeout_handler - Timeout/Faliure handler for CMD SiteSurvey
+* @rtlpriv: pointer to struct rtl_priv structure
+*/
+void rtw_scan_timeout_handler (struct rtl_priv *rtlpriv)
+{
+	struct	mlme_priv *pmlmepriv = &rtlpriv->mlmepriv;
+
+	DBG_871X(FUNC_ADPT_FMT" fw_state=%x\n", FUNC_ADPT_ARG(rtlpriv), get_fwstate(pmlmepriv));
+
+	spin_lock_bh(&pmlmepriv->lock);
+
+	_clr_fwstate_(pmlmepriv, _FW_UNDER_SURVEY);
+
+	spin_unlock_bh(&pmlmepriv->lock);
+
+	rtw_indicate_scan_done(rtlpriv, true);
+
+}
+
+void rtw_dynamic_check_timer_handlder(struct rtl_priv *rtlpriv)
+{
+#ifdef CONFIG_AP_MODE
+	struct mlme_priv *pmlmepriv = &rtlpriv->mlmepriv;
+#endif //CONFIG_AP_MODE
+	struct registry_priv *pregistrypriv = &rtlpriv->registrypriv;
+
+	if (!rtlpriv)
+		return;
+
+	if (rtlpriv->hw_init_completed == false)
+		return;
+
+	if ((rtlpriv->bDriverStopped == true)||(rtlpriv->bSurpriseRemoved== true))
+		return;
+
+
+	if (rtlpriv->net_closed == true)
+	{
+		return;
+	}
+
+	rtw_dynamic_chk_wk_cmd(rtlpriv);
+
+#ifdef CONFIG_AP_MODE
+	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
+	{
+		expire_timeout_chk(rtlpriv);
+	}
+#endif
+}
+
+#if defined(IEEE80211_SCAN_RESULT_EXPIRE)
+#define RTW_SCAN_RESULT_EXPIRE IEEE80211_SCAN_RESULT_EXPIRE/HZ*1000 -1000 //3000 -1000
+#else
+#define RTW_SCAN_RESULT_EXPIRE 2000
+#endif
+
+/*
+* Select a new join candidate from the original @param candidate and @param competitor
+* @return true: candidate is updated
+* @return false: candidate is not updated
+*/
+static int rtw_check_join_candidate(struct mlme_priv *pmlmepriv
+	, struct wlan_network **candidate, struct wlan_network *competitor)
+{
+	int updated = false;
+	struct rtl_priv *rtlpriv = container_of(pmlmepriv, struct rtl_priv, mlmepriv);
+
+
+	//check bssid, if needed
+	if (pmlmepriv->assoc_by_bssid==true) {
+		if (_rtw_memcmp(competitor->network.MacAddress, pmlmepriv->assoc_bssid, ETH_ALEN) ==false)
+			goto exit;
+	}
+
+	//check ssid, if needed
+	if (pmlmepriv->assoc_ssid.Ssid && pmlmepriv->assoc_ssid.SsidLength) {
+		if (	competitor->network.Ssid.SsidLength != pmlmepriv->assoc_ssid.SsidLength
+			|| _rtw_memcmp(competitor->network.Ssid.Ssid, pmlmepriv->assoc_ssid.Ssid, pmlmepriv->assoc_ssid.SsidLength) == false
+		)
+			goto exit;
+	}
+
+	if (rtw_is_desired_network(rtlpriv, competitor)  == false)
+		goto exit;
+
+
+	if (*candidate == NULL ||(*candidate)->network.Rssi<competitor->network.Rssi )
+	{
+		*candidate = competitor;
+		updated = true;
+	}
+
+	if (updated){
+		DBG_871X("[by_bssid:%u][assoc_ssid:%s]"
+			"new candidate: %s("MAC_FMT") rssi:%d\n",
+			pmlmepriv->assoc_by_bssid,
+			pmlmepriv->assoc_ssid.Ssid,
+			(*candidate)->network.Ssid.Ssid,
+			MAC_ARG((*candidate)->network.MacAddress),
+			(int)(*candidate)->network.Rssi
+		);
+	}
+
+exit:
+	return updated;
+}
+
+/*
+Calling context:
+The caller of the sub-routine will be in critical section...
+
+The caller must hold the following spinlock
+
+pmlmepriv->lock
+
+
+*/
+
+int rtw_select_and_join_from_scanned_queue(struct mlme_priv *pmlmepriv )
+{
+	int ret;
+	struct list_head	*phead;
+	struct rtl_priv *rtlpriv;
+	struct __queue	*queue	= &(pmlmepriv->scanned_queue);
+	struct	wlan_network	*pnetwork = NULL;
+	struct	wlan_network	*candidate = NULL;
+	uint8_t 		bSupportAntDiv = false;
+
+
+
+	spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
+	phead = get_list_head(queue);
+	rtlpriv = (struct rtl_priv *)pmlmepriv->nic_hdl;
+
+	pmlmepriv->pscanned = get_next( phead );
+
+	while (!rtw_end_of_queue_search(phead, pmlmepriv->pscanned)) {
+
+		pnetwork = container_of(pmlmepriv->pscanned, struct wlan_network, list);
+		if (pnetwork==NULL){
+			ret = _FAIL;
+			goto exit;
+		}
+
+		pmlmepriv->pscanned = get_next(pmlmepriv->pscanned);
+
+		#if 0
+		DBG_871X("MacAddress:"MAC_FMT" ssid:%s\n", MAC_ARG(pnetwork->network.MacAddress), pnetwork->network.Ssid.Ssid);
+		#endif
+
+		rtw_check_join_candidate(pmlmepriv, &candidate, pnetwork);
+
+ 	}
+
+	if (candidate == NULL) {
+		DBG_871X("%s: return _FAIL(candidate == NULL)\n", __FUNCTION__);
+		ret = _FAIL;
+		goto exit;
+	} else {
+		DBG_871X("%s: candidate: %s("MAC_FMT", ch:%u)\n", __FUNCTION__,
+			candidate->network.Ssid.Ssid, MAC_ARG(candidate->network.MacAddress),
+			candidate->network.Configuration.DSConfig);
+	}
+
+
+	// check for situation of  _FW_LINKED
+	if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
+	{
+		DBG_871X("%s: _FW_LINKED while ask_for_joinbss!!!\n", __FUNCTION__);
+
+		#if 0 // for WPA/WPA2 authentication, wpa_supplicant will expect authentication from AP, it is needed to reconnect AP...
+		if (is_same_network(&pmlmepriv->cur_network.network, &candidate->network))
+		{
+			DBG_871X("%s: _FW_LINKED and is same network, it needn't join again\n", __FUNCTION__);
+
+			rtw_indicate_connect(rtlpriv);//rtw_indicate_connect again
+
+			ret = 2;
+			goto exit;
+		}
+		else
+		#endif
+		{
+			rtw_disassoc_cmd(rtlpriv, 0, true);
+			rtw_indicate_disconnect(rtlpriv);
+			rtw_free_assoc_resources(rtlpriv, 0);
+		}
+	}
+
+	set_fwstate(pmlmepriv, _FW_UNDER_LINKING);
+	ret = rtw_joinbss_cmd(rtlpriv, candidate);
+
+exit:
+	spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
+
+
+
+	return ret;
+}
+
+
+int rtw_set_auth(struct rtl_priv * rtlpriv,struct security_priv *psecuritypriv)
+{
+	struct	cmd_obj* pcmd;
+	struct 	setauth_parm *psetauthparm;
+	struct	cmd_priv	*pcmdpriv=&(rtlpriv->cmdpriv);
+	int		res=_SUCCESS;
+
+
+
+	pcmd = (struct	cmd_obj*)rtw_zmalloc(sizeof(struct	cmd_obj));
+	if (pcmd==NULL){
+		res= _FAIL;  //try again
+		goto exit;
+	}
+
+	psetauthparm=(struct setauth_parm*)rtw_zmalloc(sizeof(struct setauth_parm));
+	if (psetauthparm==NULL){
+		rtw_mfree(pcmd);
+		res= _FAIL;
+		goto exit;
+	}
+
+	memset(psetauthparm, 0, sizeof(struct setauth_parm));
+	psetauthparm->mode=(unsigned char)psecuritypriv->dot11AuthAlgrthm;
+
+	pcmd->cmdcode = _SetAuth_CMD_;
+	pcmd->parmbuf = (unsigned char *)psetauthparm;
+	pcmd->cmdsz =  (sizeof(struct setauth_parm));
+	pcmd->rsp = NULL;
+	pcmd->rspsz = 0;
+
+
+	INIT_LIST_HEAD(&pcmd->list);
+
+	res = rtw_enqueue_cmd(pcmdpriv, pcmd);
+
+exit:
+
+
+
+	return res;
+
+}
+
+
+int rtw_set_key(struct rtl_priv * rtlpriv,struct security_priv *psecuritypriv,int keyid, uint8_t set_tx)
+{
+	uint8_t	keylen;
+	struct cmd_obj		*pcmd;
+	struct setkey_parm	*psetkeyparm;
+	struct cmd_priv		*pcmdpriv = &(rtlpriv->cmdpriv);
+	struct mlme_priv		*pmlmepriv = &(rtlpriv->mlmepriv);
+	int	res=_SUCCESS;
+
+
+
+	pcmd = (struct	cmd_obj*)rtw_zmalloc(sizeof(struct	cmd_obj));
+	if (pcmd==NULL){
+		res= _FAIL;  //try again
+		goto exit;
+	}
+	psetkeyparm=(struct setkey_parm*)rtw_zmalloc(sizeof(struct setkey_parm));
+	if (psetkeyparm==NULL){
+		rtw_mfree(pcmd);
+		res= _FAIL;
+		goto exit;
+	}
+
+	memset(psetkeyparm, 0, sizeof(struct setkey_parm));
+
+	if (psecuritypriv->dot11AuthAlgrthm ==dot11AuthAlgrthm_8021X){
+		psetkeyparm->algorithm=(unsigned char)psecuritypriv->dot118021XGrpPrivacy;
+	}
+	else{
+		psetkeyparm->algorithm=(uint8_t)psecuritypriv->dot11PrivacyAlgrthm;
+
+	}
+	psetkeyparm->keyid = (uint8_t)keyid;//0~3
+	psetkeyparm->set_tx = set_tx;
+	if (is_wep_enc(psetkeyparm->algorithm))
+		pmlmepriv->key_mask |= BIT(psetkeyparm->keyid);
+
+#ifdef CONFIG_AUTOSUSPEND
+	if ( true  == rtlpriv->pwrctrlpriv.bInternalAutoSuspend)
+	{
+		rtlpriv->pwrctrlpriv.wepkeymask = pmlmepriv->key_mask;
+		DBG_871X("....AutoSuspend pwrctrlpriv.wepkeymask(%x)\n",rtlpriv->pwrctrlpriv.wepkeymask);
+	}
+#endif
+	DBG_871X("==> rtw_set_key algorithm(%x),keyid(%x),key_mask(%x)\n",psetkeyparm->algorithm,psetkeyparm->keyid,pmlmepriv->key_mask);
+
+	switch(psetkeyparm->algorithm){
+
+		case WEP40_ENCRYPTION:
+			keylen=5;
+			memcpy(&(psetkeyparm->key[0]), &(psecuritypriv->dot11DefKey[keyid].skey[0]), keylen);
+			break;
+		case WEP104_ENCRYPTION:
+			keylen=13;
+			memcpy(&(psetkeyparm->key[0]), &(psecuritypriv->dot11DefKey[keyid].skey[0]), keylen);
+			break;
+		case TKIP_ENCRYPTION:
+			keylen=16;
+			memcpy(&psetkeyparm->key, &psecuritypriv->dot118021XGrpKey[keyid], keylen);
+			psetkeyparm->grpkey=1;
+			break;
+		case AESCCMP_ENCRYPTION:
+			keylen=16;
+			memcpy(&psetkeyparm->key, &psecuritypriv->dot118021XGrpKey[keyid], keylen);
+			psetkeyparm->grpkey=1;
+			break;
+		default:
+			res= _FAIL;
+			goto exit;
+	}
+
+
+	pcmd->cmdcode = _SetKey_CMD_;
+	pcmd->parmbuf = (uint8_t *)psetkeyparm;
+	pcmd->cmdsz =  (sizeof(struct setkey_parm));
+	pcmd->rsp = NULL;
+	pcmd->rspsz = 0;
+
+
+	INIT_LIST_HEAD(&pcmd->list);
+
+	//sema_init(&(pcmd->cmd_sem), 0);
+
+	res = rtw_enqueue_cmd(pcmdpriv, pcmd);
+
+exit:
+
+	return res;
+
+}
+
+
+//adjust IEs for rtw_joinbss_cmd in WMM
+int rtw_restruct_wmm_ie(struct rtl_priv *rtlpriv, uint8_t *in_ie, uint8_t *out_ie, uint in_len, uint initial_out_len)
+{
+	unsigned	int ielength=0;
+	unsigned int i, j;
+
+	i = 12; //after the fixed IE
+	while(i<in_len)
+	{
+		ielength = initial_out_len;
+
+		if (in_ie[i] == 0xDD && in_ie[i+2] == 0x00 && in_ie[i+3] == 0x50  && in_ie[i+4] == 0xF2 && in_ie[i+5] == 0x02 && i+5 < in_len) //WMM element ID and OUI
+		{
+
+			//Append WMM IE to the last index of out_ie
+			/*
+			for(j=i; j< i+(in_ie[i+1]+2); j++)
+			{
+				out_ie[ielength] = in_ie[j];
+				ielength++;
+			}
+			out_ie[initial_out_len+8] = 0x00; //force the QoS Info Field to be zero
+	                */
+
+                        for ( j = i; j < i + 9; j++ )
+                        {
+                            out_ie[ ielength] = in_ie[ j ];
+                            ielength++;
+                        }
+                        out_ie[ initial_out_len + 1 ] = 0x07;
+                        out_ie[ initial_out_len + 6 ] = 0x00;
+                        out_ie[ initial_out_len + 8 ] = 0x00;
+
+			break;
+		}
+
+		i+=(in_ie[i+1]+2); // to the next IE element
+	}
+
+	return ielength;
+
+}
+
+
+//
+// Ported from 8185: IsInPreAuthKeyList(). (Renamed from SecIsInPreAuthKeyList(), 2006-10-13.)
+// Added by Annie, 2006-05-07.
+//
+// Search by BSSID,
+// Return Value:
+//		-1 		:if there is no pre-auth key in the  table
+//		>=0		:if there is pre-auth key, and   return the entry id
+//
+//
+
+static int SecIsInPMKIDList(struct rtl_priv *rtlpriv, uint8_t *bssid)
+{
+	struct security_priv *psecuritypriv=&rtlpriv->securitypriv;
+	int i=0;
+
+	do
+	{
+		if ( ( psecuritypriv->PMKIDList[i].bUsed ) &&
+                    (  _rtw_memcmp( psecuritypriv->PMKIDList[i].Bssid, bssid, ETH_ALEN ) == true ) )
+		{
+			break;
+		}
+		else
+		{
+			i++;
+			//continue;
+		}
+
+	}while(i<NUM_PMKID_CACHE);
+
+	if ( i == NUM_PMKID_CACHE )
+	{
+		i = -1;// Could not find.
+	}
+	else
+	{
+		// There is one Pre-Authentication Key for the specific BSSID.
+	}
+
+	return (i);
+
+}
+
+//
+// Check the RSN IE length
+// If the RSN IE length <= 20, the RSN IE didn't include the PMKID information
+// 0-11th element in the array are the fixed IE
+// 12th element in the array is the IE
+// 13th element in the array is the IE length
+//
+
+static int rtw_append_pmkid(struct rtl_priv *rtlpriv,int iEntry, uint8_t *ie, uint ie_len)
+{
+	struct security_priv *psecuritypriv=&rtlpriv->securitypriv;
+
+	if (ie[13]<=20){
+		// The RSN IE didn't include the PMK ID, append the PMK information
+			ie[ie_len]=1;
+			ie_len++;
+			ie[ie_len]=0;	//PMKID count = 0x0100
+			ie_len++;
+			memcpy(	&ie[ie_len], &psecuritypriv->PMKIDList[iEntry].PMKID, 16);
+
+			ie_len+=16;
+			ie[13]+=18;//PMKID length = 2+16
+
+	}
+	return (ie_len);
+
+}
+int rtw_restruct_sec_ie(struct rtl_priv *rtlpriv,uint8_t *in_ie, uint8_t *out_ie, uint in_len)
+{
+	uint8_t authmode, securitytype, match;
+	uint8_t sec_ie[255], uncst_oui[4], bkup_ie[255];
+	uint8_t wpa_oui[4]={0x0, 0x50, 0xf2, 0x01};
+	uint 	ielength, cnt, remove_cnt;
+	int iEntry;
+
+	struct mlme_priv *pmlmepriv = &rtlpriv->mlmepriv;
+	struct security_priv *psecuritypriv=&rtlpriv->securitypriv;
+	uint 	ndisauthmode=psecuritypriv->ndisauthtype;
+	uint ndissecuritytype = psecuritypriv->ndisencryptstatus;
+
+
+
+	//copy fixed ie only
+	memcpy(out_ie, in_ie,12);
+	ielength=12;
+	if ((ndisauthmode==Ndis802_11AuthModeWPA)||(ndisauthmode==Ndis802_11AuthModeWPAPSK))
+			authmode=_WPA_IE_ID_;
+	if ((ndisauthmode==Ndis802_11AuthModeWPA2)||(ndisauthmode==Ndis802_11AuthModeWPA2PSK))
+			authmode=_WPA2_IE_ID_;
+
+	if (check_fwstate(pmlmepriv, WIFI_UNDER_WPS))
+	{
+		memcpy(out_ie+ielength, psecuritypriv->wps_ie, psecuritypriv->wps_ie_len);
+
+		ielength += psecuritypriv->wps_ie_len;
+	}
+	else if ((authmode==_WPA_IE_ID_)||(authmode==_WPA2_IE_ID_))
+	{
+		//copy RSN or SSN
+		memcpy(&out_ie[ielength], &psecuritypriv->supplicant_ie[0], psecuritypriv->supplicant_ie[1]+2);
+		ielength+=psecuritypriv->supplicant_ie[1]+2;
+		rtw_report_sec_ie(rtlpriv, authmode, psecuritypriv->supplicant_ie);
+	}
+
+	iEntry = SecIsInPMKIDList(rtlpriv, pmlmepriv->assoc_bssid);
+	if (iEntry<0)
+	{
+		return ielength;
+	}
+	else
+	{
+		if (authmode == _WPA2_IE_ID_)
+		{
+			ielength=rtw_append_pmkid(rtlpriv, iEntry, out_ie, ielength);
+		}
+	}
+
+
+
+	return ielength;
+}
+
+void rtw_init_registrypriv_dev_network(	struct rtl_priv * rtlpriv)
+{
+	struct registry_priv* pregistrypriv = &rtlpriv->registrypriv;
+	WLAN_BSSID_EX    *pdev_network = &pregistrypriv->dev_network;
+
+
+
+	memcpy(pdev_network->MacAddress, rtlpriv->mac80211.mac_addr, ETH_ALEN);
+
+	memcpy(&pdev_network->Ssid, &pregistrypriv->ssid, sizeof(NDIS_802_11_SSID));
+
+	pdev_network->Configuration.Length=sizeof(NDIS_802_11_CONFIGURATION);
+	pdev_network->Configuration.BeaconPeriod = 100;
+	pdev_network->Configuration.FHConfig.Length = 0;
+	pdev_network->Configuration.FHConfig.HopPattern = 0;
+	pdev_network->Configuration.FHConfig.HopSet = 0;
+	pdev_network->Configuration.FHConfig.DwellTime = 0;
+
+
+
+
+}
+
+void rtw_update_registrypriv_dev_network(struct rtl_priv * rtlpriv)
+{
+	int sz=0;
+	struct registry_priv* pregistrypriv = &rtlpriv->registrypriv;
+	WLAN_BSSID_EX    *pdev_network = &pregistrypriv->dev_network;
+	struct	security_priv*	psecuritypriv = &rtlpriv->securitypriv;
+	struct	wlan_network	*cur_network = &rtlpriv->mlmepriv.cur_network;
+	//struct	xmit_priv	*pxmitpriv = &rtlpriv->xmitpriv;
+
+
+
+	pdev_network->Privacy = (psecuritypriv->dot11PrivacyAlgrthm > 0 ? 1 : 0) ; // adhoc no 802.1x
+
+	pdev_network->Rssi = 0;
+
+	switch(WIRELESS_MODE_MAX) {
+	case WIRELESS_11B:
+		pdev_network->NetworkTypeInUse = (Ndis802_11DS);
+		break;
+	case WIRELESS_11G:
+	case WIRELESS_11BG:
+	case WIRELESS_11_24N:
+	case WIRELESS_11G_24N:
+	case WIRELESS_11BG_24N:
+		pdev_network->NetworkTypeInUse = (Ndis802_11OFDM24);
+		break;
+	case WIRELESS_11A:
+	case WIRELESS_11A_5N:
+		pdev_network->NetworkTypeInUse = (Ndis802_11OFDM5);
+		break;
+	case WIRELESS_11ABGN:
+		if (pregistrypriv->channel > 14)
+			pdev_network->NetworkTypeInUse = (Ndis802_11OFDM5);
+		else
+			pdev_network->NetworkTypeInUse = (Ndis802_11OFDM24);
+		break;
+	default :
+		// TODO
+		break;
+	}
+
+	pdev_network->Configuration.DSConfig = (pregistrypriv->channel);
+
+	if (cur_network->network.InfrastructureMode == Ndis802_11IBSS)
+		pdev_network->Configuration.ATIMWindow = (0);
+
+	pdev_network->InfrastructureMode = (cur_network->network.InfrastructureMode);
+
+	// 1. Supported rates
+	// 2. IE
+
+	//rtw_set_supported_rate(pdev_network->SupportedRates, pregistrypriv->wireless_mode) ; // will be called in rtw_generate_ie
+	sz = rtw_generate_ie(pregistrypriv);
+
+	pdev_network->IELength = sz;
+
+	pdev_network->Length = get_WLAN_BSSID_EX_sz((WLAN_BSSID_EX  *)pdev_network);
+
+	//notes: translate IELength & Length after assign the Length to cmdsz in createbss_cmd();
+	//pdev_network->IELength = cpu_to_le32(sz);
+
+
+
+}
+
+void rtw_get_encrypt_decrypt_from_registrypriv(struct rtl_priv * rtlpriv)
+{
+
+
+
+
+
+}
+
+//the fucntion is at passive_level
+void rtw_joinbss_reset(struct rtl_priv *rtlpriv)
+{
+	uint8_t	threshold;
+	struct mlme_priv	*pmlmepriv = &rtlpriv->mlmepriv;
+
+	struct ht_priv		*phtpriv = &pmlmepriv->htpriv;
+
+	//todo: if you want to do something io/reg/hw setting before join_bss, please add code here
+
+	pmlmepriv->num_FortyMHzIntolerant = 0;
+
+	pmlmepriv->num_sta_no_ht = 0;
+
+	phtpriv->ampdu_enable = false;//reset to disabled
+
+	// TH=1 => means that invalidate usb rx aggregation
+	// TH=0 => means that validate usb rx aggregation, use init value.
+	if (phtpriv->ht_option)
+	{
+		threshold = 0;
+		rtlpriv->cfg->ops->set_hw_reg(rtlpriv, HW_VAR_RXDMA_AGG_PG_TH, (uint8_t *)(&threshold));
+	}
+	else
+	{
+		threshold = 1;
+		rtlpriv->cfg->ops->set_hw_reg(rtlpriv, HW_VAR_RXDMA_AGG_PG_TH, (uint8_t *)(&threshold));
+	}
+}
+
+
+//the fucntion is >= passive_level
+unsigned int rtw_restructure_ht_ie(struct rtl_priv *rtlpriv, uint8_t *in_ie, uint8_t *out_ie, uint in_len, uint *pout_len)
+{
+	uint32_t	 ielen, out_len;
+	HT_CAP_AMPDU_FACTOR max_rx_ampdu_factor;
+	unsigned char *p, *pframe;
+	struct rtw_ieee80211_ht_cap ht_capie;
+	unsigned char WMM_IE[] = {0x00, 0x50, 0xf2, 0x02, 0x00, 0x01, 0x00};
+	struct mlme_priv	*pmlmepriv = &rtlpriv->mlmepriv;
+	struct qos_priv   	*pqospriv= &pmlmepriv->qospriv;
+	struct ht_priv		*phtpriv = &pmlmepriv->htpriv;
+
+
+	phtpriv->ht_option = false;
+
+	p = rtw_get_ie(in_ie+12, _HT_CAPABILITY_IE_, &ielen, in_len-12);
+
+	if (p && ielen>0)
+	{
+		if (pqospriv->qos_option == 0)
+		{
+			out_len = *pout_len;
+			pframe = rtw_set_ie(out_ie+out_len, _VENDOR_SPECIFIC_IE_,
+								_WMM_IE_Length_, WMM_IE, pout_len);
+
+			pqospriv->qos_option = 1;
+		}
+
+		out_len = *pout_len;
+
+		memset(&ht_capie, 0, sizeof(struct rtw_ieee80211_ht_cap));
+
+		ht_capie.cap_info = IEEE80211_HT_CAP_SUP_WIDTH |IEEE80211_HT_CAP_SGI_20 |
+							IEEE80211_HT_CAP_SGI_40 | IEEE80211_HT_CAP_TX_STBC |
+							IEEE80211_HT_CAP_DSSSCCK40;
+
+
+		/*
+		AMPDU_para [1:0]:Max AMPDU Len => 0:8k , 1:16k, 2:32k, 3:64k
+		AMPDU_para [4:2]:Min MPDU Start Spacing
+		*/
+
+		max_rx_ampdu_factor = MAX_AMPDU_FACTOR_64K;
+		ht_capie.ampdu_params_info = (max_rx_ampdu_factor&0x03);
+
+		if (rtlpriv->securitypriv.dot11PrivacyAlgrthm == AESCCMP_ENCRYPTION )
+			ht_capie.ampdu_params_info |= (IEEE80211_HT_CAP_AMPDU_DENSITY&(0x07<<2));
+		else
+			ht_capie.ampdu_params_info |= (IEEE80211_HT_CAP_AMPDU_DENSITY&0x00);
+
+
+		pframe = rtw_set_ie(out_ie+out_len, _HT_CAPABILITY_IE_,
+							sizeof(struct rtw_ieee80211_ht_cap), (unsigned char*)&ht_capie, pout_len);
+
+
+		//memcpy(out_ie+out_len, p, ielen+2);//gtest
+		//*pout_len = *pout_len + (ielen+2);
+
+
+		phtpriv->ht_option = true;
+
+		p = rtw_get_ie(in_ie+12, _HT_ADD_INFO_IE_, &ielen, in_len-12);
+		if (p && (ielen==sizeof(struct ieee80211_ht_addt_info)))
+		{
+			out_len = *pout_len;
+			pframe = rtw_set_ie(out_ie+out_len, _HT_ADD_INFO_IE_, ielen, p+2 , pout_len);
+		}
+
+	}
+
+	return (phtpriv->ht_option);
+
+}
+
+//the fucntion is > passive_level (in critical_section)
+void rtw_update_ht_cap(struct rtl_priv *rtlpriv, uint8_t *pie, uint ie_len, uint8_t channel)
+{
+	uint8_t *p, max_ampdu_sz;
+	int len;
+	//struct sta_info *bmc_sta, *psta;
+	struct rtw_ieee80211_ht_cap *pht_capie;
+	struct ieee80211_ht_addt_info *pht_addtinfo;
+	//struct recv_reorder_ctrl *preorder_ctrl;
+	struct mlme_priv	*pmlmepriv = &rtlpriv->mlmepriv;
+	struct ht_priv		*phtpriv = &pmlmepriv->htpriv;
+	//struct recv_priv *precvpriv = &rtlpriv->recvpriv;
+	struct registry_priv *pregistrypriv = &rtlpriv->registrypriv;
+	//struct wlan_network *pcur_network = &(pmlmepriv->cur_network);;
+	struct mlme_ext_priv	*pmlmeext = &rtlpriv->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	uint8_t cbw40_enable=0;
+
+
+	if (!phtpriv->ht_option)
+		return;
+
+	if ((!pmlmeinfo->HT_info_enable) || (!pmlmeinfo->HT_caps_enable))
+		return;
+
+	DBG_871X("+rtw_update_ht_cap()\n");
+
+	//maybe needs check if ap supports rx ampdu.
+	if ((phtpriv->ampdu_enable==false))
+		phtpriv->ampdu_enable = true;
+
+	//check Max Rx A-MPDU Size
+	len = 0;
+	p = rtw_get_ie(pie+sizeof (NDIS_802_11_FIXED_IEs), _HT_CAPABILITY_IE_, &len, ie_len-sizeof (NDIS_802_11_FIXED_IEs));
+	if (p && len>0)
+	{
+		pht_capie = (struct rtw_ieee80211_ht_cap *)(p+2);
+		max_ampdu_sz = (pht_capie->ampdu_params_info & IEEE80211_HT_CAP_AMPDU_FACTOR);
+		max_ampdu_sz = 1 << (max_ampdu_sz+3); // max_ampdu_sz (kbytes);
+
+		//DBG_871X("rtw_update_ht_cap(): max_ampdu_sz=%d\n", max_ampdu_sz);
+		phtpriv->rx_ampdu_maxlen = max_ampdu_sz;
+
+	}
+
+
+	len=0;
+	p = rtw_get_ie(pie+sizeof (NDIS_802_11_FIXED_IEs), _HT_ADD_INFO_IE_, &len, ie_len-sizeof (NDIS_802_11_FIXED_IEs));
+	if (p && len>0)
+	{
+		pht_addtinfo = (struct ieee80211_ht_addt_info *)(p+2);
+		//todo:
+	}
+
+	if (channel > 14) {
+		if ((0x21 & 0xf0) > 0)
+			cbw40_enable = 1;
+	} else {
+		if ((0x21 & 0x0f) > 0)
+			cbw40_enable = 1;
+	}
+
+	//update cur_bwmode & cur_ch_offset
+	if ((cbw40_enable) &&
+		(pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info & BIT(1)) &&
+		(pmlmeinfo->HT_info.infos[0] & BIT(2)))
+	{
+		int i;
+		uint8_t	rf_type;
+
+		rf_type = rtlpriv->phy.rf_type;
+
+		//update the MCS rates
+		for (i = 0; i < 16; i++)
+		{
+			if ((rf_type == RF_1T1R) || (rf_type == RF_1T2R))
+			{
+				pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate[i] &= MCS_rate_1R[i];
+			}
+			else
+			{
+				#ifdef CONFIG_DISABLE_MCS13TO15
+				if (pmlmeext->cur_bwmode == CHANNEL_WIDTH_40 && pregistrypriv->wifi_spec != 1 )
+				{
+					pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate[i] &= MCS_rate_2R_MCS13TO15_OFF[i];
+				}
+				else
+					pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate[i] &= MCS_rate_2R[i];
+				#else
+				pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate[i] &= MCS_rate_2R[i];
+				#endif //CONFIG_DISABLE_MCS13TO15
+			}
+		}
+		//switch to the 40M Hz mode accoring to the AP
+		pmlmeext->cur_bwmode = CHANNEL_WIDTH_40;
+		switch ((pmlmeinfo->HT_info.infos[0] & 0x3))
+		{
+			case EXTCHNL_OFFSET_UPPER:
+				pmlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_LOWER;
+				break;
+
+			case EXTCHNL_OFFSET_LOWER:
+				pmlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_UPPER;
+				break;
+
+			default:
+				pmlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
+				break;
+		}
+	}
+
+	//
+	// Config SM Power Save setting
+	//
+	pmlmeinfo->SM_PS = (pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info & 0x0C) >> 2;
+	if (pmlmeinfo->SM_PS == WLAN_HT_CAP_SM_PS_STATIC)
+	{
+		/*uint8_t i;
+		//update the MCS rates
+		for (i = 0; i < 16; i++)
+		{
+			pmlmeinfo->HT_caps.HT_cap_element.MCS_rate[i] &= MCS_rate_1R[i];
+		}*/
+		DBG_871X("%s(): WLAN_HT_CAP_SM_PS_STATIC\n",__FUNCTION__);
+	}
+
+	//
+	// Config current HT Protection mode.
+	//
+	pmlmeinfo->HT_protection = pmlmeinfo->HT_info.infos[1] & 0x3;
+}
+
+void rtw_issue_addbareq_cmd(struct rtl_priv *rtlpriv, struct xmit_frame *pxmitframe)
+{
+	uint8_t issued;
+	int priority;
+	struct sta_info *psta=NULL;
+	struct ht_priv	*phtpriv;
+	struct tx_pkt_attrib *pattrib =&pxmitframe->tx_attrib;
+	int32_t bmcst = is_multicast_ether_addr(pattrib->ra);
+
+	//if (bmcst || (rtlpriv->mlmepriv.LinkDetectInfo.bTxBusyTraffic == false))
+	if (bmcst || (rtlpriv->mlmepriv.LinkDetectInfo.NumTxOkInPeriod<100))
+		return;
+
+	priority = pattrib->tx_priority;
+
+	psta = rtw_get_stainfo(&rtlpriv->stapriv, pattrib->ra);
+	if (pattrib->psta != psta)
+	{
+		DBG_871X("%s, pattrib->psta(%p) != psta(%p)\n", __func__, pattrib->psta, psta);
+		return;
+	}
+
+	if (psta==NULL)
+	{
+		DBG_871X("%s, psta==NUL\n", __func__);
+		return;
+	}
+
+	if (!(psta->state &_FW_LINKED))
+	{
+		DBG_871X("%s, psta->state(0x%x) != _FW_LINKED\n", __func__, psta->state);
+		return;
+	}
+
+
+	phtpriv = &psta->htpriv;
+
+	if ((phtpriv->ht_option==true) && (phtpriv->ampdu_enable==true))
+	{
+		issued = (phtpriv->agg_enable_bitmap>>priority)&0x1;
+		issued |= (phtpriv->candidate_tid_bitmap>>priority)&0x1;
+
+		if (0==issued)
+		{
+			DBG_871X("rtw_issue_addbareq_cmd, p=%d\n", priority);
+			psta->htpriv.candidate_tid_bitmap |= BIT((uint8_t)priority);
+			rtw_addbareq_cmd(rtlpriv,(uint8_t) priority, pattrib->ra);
+		}
+	}
+
+}
+
+int rtw_linked_check(struct rtl_priv *rtlpriv)
+{
+	if (	(check_fwstate(&rtlpriv->mlmepriv, WIFI_AP_STATE) == true) ||
+			(check_fwstate(&rtlpriv->mlmepriv, WIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE) == true))
+	{
+		if (rtlpriv->stapriv.asoc_sta_count > 2)
+			return true;
+	}
+	else
+	{	//Station mode
+		if (check_fwstate(&rtlpriv->mlmepriv, _FW_LINKED)== true)
+			return true;
+	}
+	return false;
+}
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/core/rtw_mlme_ext.c linux-4.9.8821au/drivers/staging/rtl8821au/core/rtw_mlme_ext.c
--- linux-4.9/drivers/staging/rtl8821au/core/rtw_mlme_ext.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/core/rtw_mlme_ext.c	2016-12-11 19:48:25.153645128 -0600
@@ -0,0 +1,6638 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#define _RTW_MLME_EXT_C_
+
+#include <drv_types.h>
+#include <rtw_ap.h>
+#include <../rtl8821au/hw.h>
+
+#include <../usb.h>
+#include <../wifi.h>
+#include <../cam.h>
+
+#undef DBG_871X
+static inline void DBG_871X(const char *fmt, ...)
+{
+}
+
+static struct list_head *get_next(struct list_head	*list)
+{
+	return list->next;
+}
+
+#define _drv_always_		1
+#define	_drv_warning_		6
+#undef DBG_871X_LEVEL
+static inline void DBG_871X_LEVEL(const int level, const char *fmt, ...)
+{
+}
+
+struct mlme_handler mlme_sta_tbl[]={
+	{WIFI_ASSOCREQ,		"OnAssocReq",	&OnAssocReq},
+	{WIFI_ASSOCRSP,		"OnAssocRsp",	&OnAssocRsp},
+	{WIFI_REASSOCREQ,	"OnReAssocReq",	&OnAssocReq},
+	{WIFI_REASSOCRSP,	"OnReAssocRsp",	&OnAssocRsp},
+	{WIFI_PROBEREQ,		"OnProbeReq",	&OnProbeReq},
+	{WIFI_PROBERSP,		"OnProbeRsp",		&OnProbeRsp},
+
+	/*----------------------------------------------------------
+					below 2 are reserved
+	-----------------------------------------------------------*/
+	{0,					"DoReserved",		&DoReserved},
+	{0,					"DoReserved",		&DoReserved},
+	{WIFI_BEACON,		"OnBeacon",		&OnBeacon},
+	{WIFI_ATIM,			"OnATIM",		&OnAtim},
+	{WIFI_DISASSOC,		"OnDisassoc",		&OnDisassoc},
+	{WIFI_AUTH,			"OnAuth",		&OnAuthClient},
+	{WIFI_DEAUTH,		"OnDeAuth",		&OnDeAuth},
+	{WIFI_ACTION,		"OnAction",		&OnAction},
+};
+
+#ifdef _CONFIG_NATIVEAP_MLME_
+struct mlme_handler mlme_ap_tbl[]={
+	{WIFI_ASSOCREQ,		"OnAssocReq",	&OnAssocReq},
+	{WIFI_ASSOCRSP,		"OnAssocRsp",	&OnAssocRsp},
+	{WIFI_REASSOCREQ,	"OnReAssocReq",	&OnAssocReq},
+	{WIFI_REASSOCRSP,	"OnReAssocRsp",	&OnAssocRsp},
+	{WIFI_PROBEREQ,		"OnProbeReq",	&OnProbeReq},
+	{WIFI_PROBERSP,		"OnProbeRsp",		&OnProbeRsp},
+
+	/*----------------------------------------------------------
+					below 2 are reserved
+	-----------------------------------------------------------*/
+	{0,					"DoReserved",		&DoReserved},
+	{0,					"DoReserved",		&DoReserved},
+	{WIFI_BEACON,		"OnBeacon",		&OnBeacon},
+	{WIFI_ATIM,			"OnATIM",		&OnAtim},
+	{WIFI_DISASSOC,		"OnDisassoc",		&OnDisassoc},
+	{WIFI_AUTH,			"OnAuth",		&OnAuth},
+	{WIFI_DEAUTH,		"OnDeAuth",		&OnDeAuth},
+	{WIFI_ACTION,		"OnAction",		&OnAction},
+};
+#endif
+
+struct action_handler OnAction_tbl[]={
+	{RTW_WLAN_CATEGORY_SPECTRUM_MGMT,	 "ACTION_SPECTRUM_MGMT", on_action_spct},
+	{RTW_WLAN_CATEGORY_QOS, "ACTION_QOS", &OnAction_qos},
+	{RTW_WLAN_CATEGORY_DLS, "ACTION_DLS", &OnAction_dls},
+	{RTW_WLAN_CATEGORY_BACK, "ACTION_BACK", &OnAction_back},
+	{RTW_WLAN_CATEGORY_PUBLIC, "ACTION_PUBLIC", on_action_public},
+	{RTW_WLAN_CATEGORY_RADIO_MEASUREMENT, "ACTION_RADIO_MEASUREMENT", &DoReserved},
+	{RTW_WLAN_CATEGORY_FT, "ACTION_FT",	&DoReserved},
+	{RTW_WLAN_CATEGORY_HT,	"ACTION_HT",	&OnAction_ht},
+	{RTW_WLAN_CATEGORY_SA_QUERY, "ACTION_SA_QUERY", &DoReserved},
+	{RTW_WLAN_CATEGORY_WMM, "ACTION_WMM", &OnAction_wmm},
+	{RTW_WLAN_CATEGORY_P2P, "ACTION_P2P", &OnAction_p2p},
+};
+
+
+uint8_t	null_addr[ETH_ALEN]= {0,0,0,0,0,0};
+
+/**************************************************
+OUI definitions for the vendor specific IE
+***************************************************/
+unsigned char	RTW_WPA_OUI[] = {0x00, 0x50, 0xf2, 0x01};
+unsigned char WMM_OUI[] = {0x00, 0x50, 0xf2, 0x02};
+unsigned char	WPS_OUI[] = {0x00, 0x50, 0xf2, 0x04};
+unsigned char	P2P_OUI[] = {0x50,0x6F,0x9A,0x09};
+unsigned char	WFD_OUI[] = {0x50,0x6F,0x9A,0x0A};
+
+unsigned char	WMM_INFO_OUI[] = {0x00, 0x50, 0xf2, 0x02, 0x00, 0x01};
+unsigned char	WMM_PARA_OUI[] = {0x00, 0x50, 0xf2, 0x02, 0x01, 0x01};
+
+unsigned char WPA_TKIP_CIPHER[4] = {0x00, 0x50, 0xf2, 0x02};
+unsigned char RSN_TKIP_CIPHER[4] = {0x00, 0x0f, 0xac, 0x02};
+
+extern unsigned char REALTEK_96B_IE[];
+
+/********************************************************
+MCS rate definitions
+*********************************************************/
+#ifdef CONFIG_DISABLE_MCS13TO15
+unsigned char	MCS_rate_2R_MCS13TO15_OFF[16] = {0xff, 0x1f, 0x0, 0x0, 0x01, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0};
+unsigned char	MCS_rate_2R[16] = {0xff, 0xff, 0x0, 0x0, 0x01, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0};
+#else //CONFIG_DISABLE_MCS13TO15
+unsigned char	MCS_rate_2R[16] = {0xff, 0xff, 0x0, 0x0, 0x01, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0};
+#endif //CONFIG_DISABLE_MCS13TO15
+unsigned char	MCS_rate_1R[16] = {0xff, 0x00, 0x0, 0x0, 0x01, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0};
+
+/********************************************************
+ChannelPlan definitions
+*********************************************************/
+
+static unsigned char RTW_ChannelPlan2G[MAX_CHANNEL_NUM_2G] = {
+	1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14		/* 0x03, RT_CHANNEL_DOMAIN_2G_MIKK1 */
+};
+
+static unsigned char RTW_ChannelPlan5G[MAX_CHANNEL_NUM_5G] = {
+	 36,  40,  44,  48,  52,  56,  60,  64, 100, 104,	/* 0x02, RT_CHANNEL_DOMAIN_5G_ETSI2 */
+	108, 112, 116, 120, 124, 128, 132, 136, 140, 149,
+	153, 157, 161, 165
+};
+
+/*
+ * Search the @param channel_num in given @param channel_set
+ * @ch_set: the given channel set
+ * @ch: the given channel number
+ *
+ * return the index of channel_num in channel_set, -1 if not found
+ */
+int rtw_ch_set_search_ch(RT_CHANNEL_INFO *ch_set, const uint32_t	 ch)
+{
+	int i;
+	for(i=0;ch_set[i].ChannelNum!=0;i++){
+		if(ch == ch_set[i].ChannelNum)
+			break;
+	}
+
+	if(i >= ch_set[i].ChannelNum)
+		return -1;
+	return i;
+}
+
+/****************************************************************************
+
+Following are the initialization functions for WiFi MLME
+
+*****************************************************************************/
+
+int init_hw_mlme_ext(struct rtl_priv *rtlpriv)
+{
+	struct	mlme_ext_priv *pmlmeext = &rtlpriv->mlmeextpriv;
+
+	//set_opmode_cmd(rtlpriv, infra_client_with_mlme);//removed
+
+	set_channel_bwmode(rtlpriv, pmlmeext->cur_channel, pmlmeext->cur_ch_offset, pmlmeext->cur_bwmode);
+
+	return _SUCCESS;
+}
+
+static void init_mlme_ext_priv_value(struct rtl_priv* rtlpriv)
+{
+	struct mlme_ext_priv	*pmlmeext = &rtlpriv->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+
+	//unsigned char default_channel_set[MAX_CHANNEL_NUM] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 0, 0};
+	unsigned char	mixed_datarate[NumRates] = {_1M_RATE_, _2M_RATE_, _5M_RATE_, _11M_RATE_, _6M_RATE_,_9M_RATE_, _12M_RATE_, _18M_RATE_, _24M_RATE_, _36M_RATE_, _48M_RATE_, _54M_RATE_, 0xff};
+	unsigned char	mixed_basicrate[NumRates] ={_1M_RATE_, _2M_RATE_, _5M_RATE_, _11M_RATE_, _6M_RATE_, _12M_RATE_, _24M_RATE_, 0xff,};
+
+	atomic_set(&pmlmeext->event_seq, 0);
+	pmlmeext->mgnt_seq = 0;//reset to zero when disconnect at client mode
+
+	pmlmeext->cur_channel = rtlpriv->registrypriv.channel;
+	pmlmeext->cur_bwmode = CHANNEL_WIDTH_20;
+	pmlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
+
+	pmlmeext->retry = 0;
+
+	pmlmeext->cur_wireless_mode = WIRELESS_MODE_MAX;
+
+	//memcpy(pmlmeext->channel_set, DefaultChannelPlan[rtlpriv->mlmepriv.ChannelPlan].Channel, DefaultChannelPlan[rtlpriv->mlmepriv.ChannelPlan].Len);
+	//memcpy(pmlmeext->channel_set, default_channel_set, MAX_CHANNEL_NUM);
+	memcpy(pmlmeext->datarate, mixed_datarate, NumRates);
+	memcpy(pmlmeext->basicrate, mixed_basicrate, NumRates);
+
+	if(pmlmeext->cur_channel > 14)
+		pmlmeext->tx_rate = IEEE80211_OFDM_RATE_6MB;
+	else
+		pmlmeext->tx_rate = IEEE80211_CCK_RATE_1MB;
+
+	pmlmeext->sitesurvey_res.state = SCAN_DISABLE;
+	pmlmeext->sitesurvey_res.channel_idx = 0;
+	pmlmeext->sitesurvey_res.bss_cnt = 0;
+	pmlmeext->scan_abort = false;
+
+	pmlmeinfo->state = WIFI_FW_NULL_STATE;
+	pmlmeinfo->reauth_count = 0;
+	pmlmeinfo->reassoc_count = 0;
+	pmlmeinfo->link_count = 0;
+	pmlmeinfo->auth_seq = 0;
+	pmlmeinfo->auth_algo = dot11AuthAlgrthm_Open;
+	pmlmeinfo->key_index = 0;
+	pmlmeinfo->iv = 0;
+
+	pmlmeinfo->enc_algo = NO_ENCRYPTION;
+	pmlmeinfo->authModeToggle = 0;
+
+	memset(pmlmeinfo->chg_txt, 0, 128);
+
+	pmlmeinfo->slotTime = SHORT_SLOT_TIME;
+	pmlmeinfo->preamble_mode = PREAMBLE_AUTO;
+
+	pmlmeinfo->dialogToken = 0;
+
+	pmlmeext->action_public_rxseq = 0xffff;
+	pmlmeext->action_public_dialog_token = 0xff;
+}
+
+static int has_channel(RT_CHANNEL_INFO *channel_set,
+					   uint8_t chanset_size,
+					   uint8_t chan) {
+	int i;
+
+	for (i = 0; i < chanset_size; i++) {
+		if (channel_set[i].ChannelNum == chan) {
+			return 1;
+		}
+	}
+
+	return 0;
+}
+
+static void init_channel_list(struct rtl_priv *rtlpriv, RT_CHANNEL_INFO *channel_set,
+							  uint8_t chanset_size,
+							  struct p2p_channels *channel_list) {
+
+	struct p2p_oper_class_map op_class[] = {
+		{ IEEE80211G,  81,   1,  13,  1, BW20 },
+		{ IEEE80211G,  82,  14,  14,  1, BW20 },
+		{ IEEE80211A, 115,  36,  48,  4, BW20 },
+		{ IEEE80211A, 116,  36,  44,  8, BW40PLUS },
+		{ IEEE80211A, 117,  40,  48,  8, BW40MINUS },
+		{ IEEE80211A, 124, 149, 161,  4, BW20 },
+		{ IEEE80211A, 125, 149, 169,  4, BW20 },
+		{ IEEE80211A, 126, 149, 157,  8, BW40PLUS },
+		{ IEEE80211A, 127, 153, 161,  8, BW40MINUS },
+		{ -1, 0, 0, 0, 0, BW20 }
+	};
+
+	int cla, op;
+
+	cla = 0;
+
+	for (op = 0; op_class[op].op_class; op++) {
+		uint8_t ch;
+		struct p2p_oper_class_map *o = &op_class[op];
+		struct p2p_reg_class *reg = NULL;
+
+		for (ch = o->min_chan; ch <= o->max_chan; ch += o->inc) {
+			if (!has_channel(channel_set, chanset_size, ch)) {
+				continue;
+			}
+
+			if ((0 < (0x21 & 0xf0)) &&
+				((BW40MINUS == o->bw) || (BW40PLUS == o->bw)))
+				continue;
+
+			if (reg == NULL) {
+				reg = &channel_list->reg_class[cla];
+				cla++;
+				reg->reg_class = o->op_class;
+				reg->channels = 0;
+			}
+			reg->channel[reg->channels] = ch;
+			reg->channels++;
+		}
+	}
+	channel_list->reg_classes = cla;
+
+}
+
+static uint8_t init_channel_set(struct rtl_priv* rtlpriv, uint8_t ChannelPlan, RT_CHANNEL_INFO *channel_set)
+{
+	uint8_t	index,chanset_size = 0;
+	uint8_t	b5GBand = false, b2_4GBand = false;
+	uint8_t	Index2G = 0, Index5G=0;
+
+	memset(channel_set, 0, sizeof(RT_CHANNEL_INFO)*MAX_CHANNEL_NUM);
+
+	if (ChannelPlan >= RT_CHANNEL_DOMAIN_MAX &&
+	    ChannelPlan != RT_CHANNEL_DOMAIN_REALTEK_DEFINE) {
+		DBG_871X("ChannelPlan ID %x error !!!!!\n",ChannelPlan);
+		return chanset_size;
+	}
+
+	if (IsSupported24G(WIRELESS_MODE_MAX)) {
+		b2_4GBand = true;
+		Index2G = 0x00;		/* ULLI now index */
+	}
+
+	if (IsSupported5G(WIRELESS_MODE_MAX)) {
+		b5GBand = true;
+		Index5G = 0x00;		/* ULLI now index */
+	}
+
+	if (b2_4GBand) {
+		for (index = 0; index < 14; index++) {
+			channel_set[chanset_size].ChannelNum = RTW_ChannelPlan2G[index];
+
+			if ((RT_CHANNEL_DOMAIN_GLOBAL_DOAMIN == ChannelPlan) ||//Channel 1~11 is active, and 12~14 is passive
+			    (RT_CHANNEL_DOMAIN_GLOBAL_DOAMIN_2G == ChannelPlan)) {
+				if(channel_set[chanset_size].ChannelNum >= 1 && channel_set[chanset_size].ChannelNum <= 11)
+					channel_set[chanset_size].ScanType = SCAN_ACTIVE;
+				else if((channel_set[chanset_size].ChannelNum  >= 12 && channel_set[chanset_size].ChannelNum  <= 14))
+					channel_set[chanset_size].ScanType  = SCAN_PASSIVE;
+			} else if(RT_CHANNEL_DOMAIN_WORLD_WIDE_13 == ChannelPlan ||
+				  RT_CHANNEL_DOMAIN_WORLD_WIDE_5G == ChannelPlan ||
+				  RT_CHANNEL_DOMAIN_2G_WORLD == Index2G) { // channel 12~13, passive scan
+					if (channel_set[chanset_size].ChannelNum <= 11)
+						channel_set[chanset_size].ScanType = SCAN_ACTIVE;
+					else
+						channel_set[chanset_size].ScanType = SCAN_PASSIVE;
+			} else {
+				channel_set[chanset_size].ScanType = SCAN_ACTIVE;
+			}
+
+			chanset_size++;
+		}
+	}
+
+	if (b5GBand) {
+		for (index = 0;index < 24; index++) {
+#ifdef CONFIG_DFS
+			channel_set[chanset_size].ChannelNum = RTW_ChannelPlan5G[index];
+			if (channel_set[chanset_size].ChannelNum <= 48 ||
+			    channel_set[chanset_size].ChannelNum >= 149) {
+				if(RT_CHANNEL_DOMAIN_WORLD_WIDE_5G == ChannelPlan)//passive scan for all 5G channels
+					channel_set[chanset_size].ScanType = SCAN_PASSIVE;
+				else
+					channel_set[chanset_size].ScanType = SCAN_ACTIVE;
+			} else {
+				channel_set[chanset_size].ScanType = SCAN_PASSIVE;
+			}
+			chanset_size++;
+#else /* CONFIG_DFS */
+			if (RTW_ChannelPlan5G[Index5G].Channel[index] <= 48 ||
+			    RTW_ChannelPlan5G[Index5G].Channel[index] >= 149 ) {
+				channel_set[chanset_size].ChannelNum = RTW_ChannelPlan5G[Index5G].Channel[index];
+				if(RT_CHANNEL_DOMAIN_WORLD_WIDE_5G == ChannelPlan)//passive scan for all 5G channels
+					channel_set[chanset_size].ScanType = SCAN_PASSIVE;
+				else
+					channel_set[chanset_size].ScanType = SCAN_ACTIVE;
+				DBG_871X("%s(): channel_set[%d].ChannelNum = %d\n", __FUNCTION__, chanset_size, channel_set[chanset_size].ChannelNum);
+				chanset_size++;
+			}
+#endif /* CONFIG_DFS */
+		}
+	}
+
+	DBG_871X("%s ChannelPlan ID %x Chan num:%d  \n",__FUNCTION__,ChannelPlan,chanset_size);
+	return chanset_size;
+}
+
+int	init_mlme_ext_priv(struct rtl_priv* rtlpriv)
+{
+	int	res = _SUCCESS;
+	struct registry_priv* pregistrypriv = &rtlpriv->registrypriv;
+	struct mlme_ext_priv *pmlmeext = &rtlpriv->mlmeextpriv;
+	struct mlme_priv *pmlmepriv = &(rtlpriv->mlmepriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	// We don't need to memset rtlpriv->XXX to zero, because rtlpriv is allocated by rtw_zvmalloc().
+	//memset((uint8_t *)pmlmeext, 0, sizeof(struct mlme_ext_priv));
+
+	pmlmeext->rtlpriv = rtlpriv;
+
+	//fill_fwpriv(rtlpriv, &(pmlmeext->fwpriv));
+
+	init_mlme_ext_priv_value(rtlpriv);
+	pmlmeinfo->bAcceptAddbaReq = pregistrypriv->bAcceptAddbaReq;
+
+	init_mlme_ext_timer(rtlpriv);
+
+#ifdef CONFIG_AP_MODE
+	init_mlme_ap_info(rtlpriv);
+#endif
+
+	pmlmeext->max_chan_nums = init_channel_set(rtlpriv, pmlmepriv->ChannelPlan,pmlmeext->channel_set);
+	init_channel_list(rtlpriv, pmlmeext->channel_set, pmlmeext->max_chan_nums, &pmlmeext->channel_list);
+
+	pmlmeext->chan_scan_time = SURVEY_TO;
+	pmlmeext->mlmeext_init = true;
+
+#ifdef DBG_FIXED_CHAN
+	pmlmeext->fixed_chan = 0xFF;
+#endif
+
+	return res;
+
+}
+
+void free_mlme_ext_priv (struct mlme_ext_priv *pmlmeext)
+{
+	struct rtl_priv *rtlpriv = pmlmeext->rtlpriv;
+
+	if (!rtlpriv)
+		return;
+
+	if (rtlpriv->bDriverStopped == true)
+	{
+		del_timer_sync_ex(&pmlmeext->survey_timer);
+		del_timer_sync_ex(&pmlmeext->link_timer);
+		//del_timer_sync_ex(&pmlmeext->ADDBA_timer);
+	}
+}
+
+static uint8_t cmp_pkt_chnl_diff(struct rtl_priv *rtlpriv,uint8_t * pframe,uint packet_len)
+{	// if the channel is same, return 0. else return channel differential
+	uint len;
+	uint8_t channel;
+	uint8_t *p;
+	p = rtw_get_ie(pframe + WLAN_HDR_A3_LEN + _BEACON_IE_OFFSET_, _DSSET_IE_, &len, packet_len - _BEACON_IE_OFFSET_);
+	if (p)
+	{
+		channel = *(p + 2);
+		if(rtlpriv->mlmeextpriv.cur_channel >= channel)
+		{
+			return (rtlpriv->mlmeextpriv.cur_channel - channel);
+		}
+		else
+		{
+			return (channel-rtlpriv->mlmeextpriv.cur_channel);
+		}
+	}
+	else
+	{
+		return 0;
+	}
+}
+
+static void _mgt_dispatcher(struct rtl_priv *rtlpriv, struct mlme_handler *ptable, struct recv_frame *precv_frame)
+{
+	uint8_t bc_addr[ETH_ALEN] = {0xff,0xff,0xff,0xff,0xff,0xff};
+	uint8_t *pframe = precv_frame->rx_data;
+
+	  if(ptable->func)
+        {
+       	 //receive the frames that ra(a1) is my address or ra(a1) is bc address.
+		if (!_rtw_memcmp(GetAddr1Ptr(pframe), rtlpriv->mac80211.mac_addr, ETH_ALEN) &&
+			!_rtw_memcmp(GetAddr1Ptr(pframe), bc_addr, ETH_ALEN))
+		{
+			return;
+		}
+
+		ptable->func(rtlpriv, precv_frame);
+        }
+
+}
+
+void mgt_dispatcher(struct rtl_priv *rtlpriv, struct recv_frame *precv_frame)
+{
+	int index;
+	struct mlme_handler *ptable;
+#ifdef CONFIG_AP_MODE
+	struct mlme_priv *pmlmepriv = &rtlpriv->mlmepriv;
+#endif //CONFIG_AP_MODE
+	uint8_t bc_addr[ETH_ALEN] = {0xff,0xff,0xff,0xff,0xff,0xff};
+	uint8_t *pframe = precv_frame->rx_data;
+	struct sta_info *psta = rtw_get_stainfo(&rtlpriv->stapriv, GetAddr2Ptr(pframe));
+
+
+	if (GetFrameType(pframe) != WIFI_MGT_TYPE)
+	{
+		return;
+	}
+
+	//receive the frames that ra(a1) is my address or ra(a1) is bc address.
+	if (!_rtw_memcmp(GetAddr1Ptr(pframe), rtlpriv->mac80211.mac_addr, ETH_ALEN) &&
+		!_rtw_memcmp(GetAddr1Ptr(pframe), bc_addr, ETH_ALEN))
+	{
+		return;
+	}
+
+	ptable = mlme_sta_tbl;
+
+	index = GetFrameSubType(pframe) >> 4;
+
+
+	if (index > 13)
+	{
+		return;
+	}
+	ptable += index;
+
+#if 1
+	if (psta != NULL)
+	{
+		if (GetRetry(pframe))
+		{
+			if (precv_frame->attrib.seq_num == psta->RxMgmtFrameSeqNum)
+			{
+				/* drop the duplicate management frame */
+				DBG_871X("Drop duplicate management frame with seq_num = %d.\n", precv_frame->attrib.seq_num);
+				return;
+			}
+		}
+		psta->RxMgmtFrameSeqNum = precv_frame->attrib.seq_num;
+	}
+#else
+
+	if(GetRetry(pframe))
+	{
+		//RT_TRACE(_module_rtl871x_mlme_c_,_drv_err_,("drop due to decache!\n"));
+		//return;
+	}
+#endif
+
+#ifdef CONFIG_AP_MODE
+	switch (GetFrameSubType(pframe))
+	{
+		case WIFI_AUTH:
+			if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
+				ptable->func = &OnAuth;
+			else
+				ptable->func = &OnAuthClient;
+			//pass through
+		case WIFI_ASSOCREQ:
+		case WIFI_REASSOCREQ:
+			_mgt_dispatcher(rtlpriv, ptable, precv_frame);
+			break;
+		case WIFI_PROBEREQ:
+			if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
+			{
+				_mgt_dispatcher(rtlpriv, ptable, precv_frame);
+			}
+			else
+				_mgt_dispatcher(rtlpriv, ptable, precv_frame);
+			break;
+		case WIFI_BEACON:
+			_mgt_dispatcher(rtlpriv, ptable, precv_frame);
+			break;
+		case WIFI_ACTION:
+			//if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
+			_mgt_dispatcher(rtlpriv, ptable, precv_frame);
+			break;
+		default:
+			_mgt_dispatcher(rtlpriv, ptable, precv_frame);
+			break;
+	}
+#else
+
+	_mgt_dispatcher(rtlpriv, ptable, precv_frame);
+
+#endif
+
+}
+
+/****************************************************************************
+
+Following are the callback functions for each subtype of the management frames
+
+*****************************************************************************/
+
+unsigned int OnProbeReq(struct rtl_priv *rtlpriv, struct recv_frame *precv_frame)
+{
+	unsigned int	ielen;
+	unsigned char	*p;
+	struct mlme_priv *pmlmepriv = &rtlpriv->mlmepriv;
+	struct mlme_ext_priv *pmlmeext = &rtlpriv->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	WLAN_BSSID_EX 	*cur = &(pmlmeinfo->network);
+	uint8_t *pframe = precv_frame->rx_data;
+	uint len = precv_frame->len;
+	uint8_t is_valid_p2p_probereq = false;
+
+
+	if(check_fwstate(pmlmepriv, WIFI_STATION_STATE))
+	{
+		return _SUCCESS;
+	}
+
+	if(check_fwstate(pmlmepriv, _FW_LINKED) == false &&
+		check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE|WIFI_AP_STATE)==false)
+	{
+		return _SUCCESS;
+	}
+
+
+	//DBG_871X("+OnProbeReq\n");
+
+
+	p = rtw_get_ie(pframe + WLAN_HDR_A3_LEN + _PROBEREQ_IE_OFFSET_, _SSID_IE_, (int *)&ielen,
+			len - WLAN_HDR_A3_LEN - _PROBEREQ_IE_OFFSET_);
+
+
+	//check (wildcard) SSID
+	if (p != NULL)
+	{
+		if(is_valid_p2p_probereq == true)
+		{
+			goto _issue_probersp;
+		}
+
+		if ( (ielen != 0 && false ==_rtw_memcmp((void *)(p+2), (void *)cur->Ssid.Ssid, cur->Ssid.SsidLength))
+			|| (ielen == 0 && pmlmeinfo->hidden_ssid_mode)
+		)
+		{
+			return _SUCCESS;
+		}
+
+_issue_probersp:
+
+		if(check_fwstate(pmlmepriv, _FW_LINKED) == true &&
+			pmlmepriv->cur_network.join_res == true)
+		{
+			//DBG_871X("+issue_probersp during ap mode\n");
+			issue_probersp(rtlpriv, get_sa(pframe), is_valid_p2p_probereq);
+		}
+
+	}
+
+	return _SUCCESS;
+
+}
+
+unsigned int OnProbeRsp(struct rtl_priv *rtlpriv, struct recv_frame *precv_frame)
+{
+	struct sta_info		*psta;
+	struct mlme_ext_priv	*pmlmeext = &rtlpriv->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct sta_priv		*pstapriv = &rtlpriv->stapriv;
+	uint8_t	*pframe = precv_frame->rx_data;
+
+
+
+
+	if (pmlmeext->sitesurvey_res.state == SCAN_PROCESS)
+	{
+		report_survey_event(rtlpriv, precv_frame);
+		return _SUCCESS;
+	}
+
+	#if 0 //move to validate_recv_mgnt_frame
+	if (_rtw_memcmp(GetAddr3Ptr(pframe), get_my_bssid(&pmlmeinfo->network), ETH_ALEN))
+	{
+		if (pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS)
+		{
+			if ((psta = rtw_get_stainfo(pstapriv, GetAddr2Ptr(pframe))) != NULL)
+			{
+				psta->sta_stats.rx_mgnt_pkts++;
+			}
+		}
+	}
+	#endif
+
+	return _SUCCESS;
+
+}
+
+unsigned int OnBeacon(struct rtl_priv *rtlpriv, struct recv_frame *precv_frame)
+{
+	int cam_idx;
+	struct sta_info	*psta;
+	struct mlme_ext_priv	*pmlmeext = &rtlpriv->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct mlme_priv *pmlmepriv = &rtlpriv->mlmepriv;
+	struct sta_priv	*pstapriv = &rtlpriv->stapriv;
+	uint8_t *pframe = precv_frame->rx_data;
+	uint len = precv_frame->len;
+	WLAN_BSSID_EX *pbss;
+	int ret = _SUCCESS;
+	uint8_t *p = NULL;
+	uint32_t	 ielen = 0;
+
+#ifdef CONFIG_ATTEMPT_TO_FIX_AP_BEACON_ERROR
+	p = rtw_get_ie(pframe + sizeof(struct rtw_ieee80211_hdr_3addr) + _BEACON_IE_OFFSET_, _EXT_SUPPORTEDRATES_IE_, &ielen, precv_frame->len -sizeof(struct rtw_ieee80211_hdr_3addr) - _BEACON_IE_OFFSET_);
+	if ((p != NULL) && (ielen > 0))
+	{
+		if ((*(p + 1 + ielen) == 0x2D) && (*(p + 2 + ielen) != 0x2D))
+		{
+			/* Invalid value 0x2D is detected in Extended Supported Rates (ESR) IE. Try to fix the IE length to avoid failed Beacon parsing. */
+		       	DBG_871X("[WIFIDBG] Error in ESR IE is detected in Beacon of BSSID:"MAC_FMT". Fix the length of ESR IE to avoid failed Beacon parsing.\n", MAC_ARG(GetAddr3Ptr(pframe)));
+		       	*(p + 1) = ielen - 1;
+		}
+	}
+#endif
+
+	if (pmlmeext->sitesurvey_res.state == SCAN_PROCESS)
+	{
+		report_survey_event(rtlpriv, precv_frame);
+		return _SUCCESS;
+	}
+
+	if (_rtw_memcmp(GetAddr3Ptr(pframe), get_my_bssid(&pmlmeinfo->network), ETH_ALEN))
+	{
+		if (pmlmeinfo->state & WIFI_FW_AUTH_NULL)
+		{
+			//we should update current network before auth, or some IE is wrong
+			pbss = (WLAN_BSSID_EX*)rtw_malloc(sizeof(WLAN_BSSID_EX));
+			if (pbss) {
+				if (collect_bss_info(rtlpriv, precv_frame, pbss) == _SUCCESS) {
+					update_network(&(pmlmepriv->cur_network.network), pbss, rtlpriv, true);
+					rtw_get_bcn_info(&(pmlmepriv->cur_network));
+				}
+				rtw_mfree(pbss);
+			}
+
+			//check the vendor of the assoc AP
+			pmlmeinfo->assoc_AP_vendor = check_assoc_AP(pframe+sizeof(struct rtw_ieee80211_hdr_3addr), len-sizeof(struct rtw_ieee80211_hdr_3addr));
+
+			//update TSF Value
+			update_TSF(pmlmeext, pframe, len);
+
+			//start auth
+			start_clnt_auth(rtlpriv);
+
+			return _SUCCESS;
+		}
+
+		if(((pmlmeinfo->state&0x03) == WIFI_FW_STATION_STATE) && (pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS))
+		{
+			if ((psta = rtw_get_stainfo(pstapriv, GetAddr2Ptr(pframe))) != NULL)
+			{
+				#ifdef CONFIG_PATCH_JOIN_WRONG_CHANNEL
+				//Merge from 8712 FW code
+				if (cmp_pkt_chnl_diff(rtlpriv,pframe,len) != 0)
+				{            // join wrong channel, deauth and reconnect
+					issue_deauth(rtlpriv, (&(pmlmeinfo->network))->MacAddress, WLAN_REASON_DEAUTH_LEAVING);
+
+					report_del_sta_event(rtlpriv,(&(pmlmeinfo->network))->MacAddress, WLAN_REASON_JOIN_WRONG_CHANNEL);
+					pmlmeinfo->state &= (~WIFI_FW_ASSOC_SUCCESS);
+					return _SUCCESS;
+				}
+				#endif //CONFIG_PATCH_JOIN_WRONG_CHANNEL
+
+				ret = rtw_check_bcn_info(rtlpriv, pframe, len);
+				if (!ret) {
+						DBG_871X_LEVEL(_drv_always_, "ap has changed, disconnect now\n ");
+						receive_disconnect(rtlpriv, pmlmeinfo->network.MacAddress , 65535);
+						return _SUCCESS;
+				}
+				//update WMM, ERP in the beacon
+				//todo: the timer is used instead of the number of the beacon received
+				if ((sta_rx_pkts(psta) & 0xf) == 0)
+				{
+					//DBG_871X("update_bcn_info\n");
+					update_beacon_info(rtlpriv, pframe, len, psta);
+				}
+
+#ifdef CONFIG_DFS
+				process_csa_ie(rtlpriv, pframe, len);	//channel switch announcement
+#endif //CONFIG_DFS
+				#if 0 //move to validate_recv_mgnt_frame
+				psta->sta_stats.rx_mgnt_pkts++;
+				#endif
+			}
+		}
+		else if((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE)
+		{
+			if ((psta = rtw_get_stainfo(pstapriv, GetAddr2Ptr(pframe))) != NULL)
+			{
+				//update WMM, ERP in the beacon
+				//todo: the timer is used instead of the number of the beacon received
+				if ((sta_rx_pkts(psta) & 0xf) == 0)
+				{
+					//DBG_871X("update_bcn_info\n");
+					update_beacon_info(rtlpriv, pframe, len, psta);
+				}
+
+				#if 0 //move to validate_recv_mgnt_frame
+				psta->sta_stats.rx_mgnt_pkts++;
+				#endif
+			}
+			else
+			{
+				//allocate a new CAM entry for IBSS station
+				if ((cam_idx = allocate_fw_sta_entry(rtlpriv)) == NUM_STA)
+				{
+					goto _END_ONBEACON_;
+				}
+
+				//get supported rate
+				if (update_sta_support_rate(rtlpriv, (pframe + WLAN_HDR_A3_LEN + _BEACON_IE_OFFSET_), (len - WLAN_HDR_A3_LEN - _BEACON_IE_OFFSET_), cam_idx) == _FAIL)
+				{
+					pmlmeinfo->FW_sta_info[cam_idx].status = 0;
+					goto _END_ONBEACON_;
+				}
+
+				//update TSF Value
+				update_TSF(pmlmeext, pframe, len);
+
+				//report sta add event
+				report_add_sta_event(rtlpriv, GetAddr2Ptr(pframe), cam_idx);
+			}
+		}
+	}
+
+_END_ONBEACON_:
+
+	return _SUCCESS;
+
+}
+
+unsigned int OnAuth(struct rtl_priv *rtlpriv, struct recv_frame *precv_frame)
+{
+#ifdef CONFIG_AP_MODE
+	unsigned int	auth_mode, seq, ie_len;
+	unsigned char	*sa, *p;
+	u16	algorithm;
+	int	status;
+	static struct sta_info stat;
+	struct	sta_info	*pstat=NULL;
+	struct	sta_priv *pstapriv = &rtlpriv->stapriv;
+	struct security_priv *psecuritypriv = &rtlpriv->securitypriv;
+	struct mlme_ext_priv	*pmlmeext = &rtlpriv->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	uint8_t *pframe = precv_frame->rx_data;
+	uint len = precv_frame->len;
+	uint8_t	offset = 0;
+
+	if((pmlmeinfo->state&0x03) != WIFI_FW_AP_STATE)
+		return _FAIL;
+
+	DBG_871X("+OnAuth\n");
+
+	sa = GetAddr2Ptr(pframe);
+
+	auth_mode = psecuritypriv->dot11AuthAlgrthm;
+
+	if (GetPrivacy(pframe))
+	{
+		uint8_t	*iv;
+		struct rx_pkt_attrib	 *prxattrib = &(precv_frame->attrib);
+
+		prxattrib->hdrlen = WLAN_HDR_A3_LEN;
+		prxattrib->encrypt = WEP40_ENCRYPTION;
+
+		iv = pframe+prxattrib->hdrlen;
+		prxattrib->key_index = ((iv[3]>>6)&0x3);
+
+		prxattrib->iv_len = 4;
+		prxattrib->icv_len = 4;
+
+		rtw_wep_decrypt(rtlpriv, precv_frame);
+
+		offset = 4;
+	}
+
+	algorithm = le16_to_cpu(*(u16 *)((u8 *)pframe + WLAN_HDR_A3_LEN + offset));
+	seq 	= le16_to_cpu(*(u16 *)((u8 *)pframe + WLAN_HDR_A3_LEN + offset + 2));
+
+	DBG_871X("auth alg=%x, seq=%X\n", algorithm, seq);
+
+	if (auth_mode == 2 &&
+			psecuritypriv->dot11PrivacyAlgrthm != WEP40_ENCRYPTION &&
+			psecuritypriv->dot11PrivacyAlgrthm != WEP104_ENCRYPTION)
+		auth_mode = 0;
+
+	if ((algorithm > 0 && auth_mode == 0) ||	// rx a shared-key auth but shared not enabled
+		(algorithm == 0 && auth_mode == 1) )	// rx a open-system auth but shared-key is enabled
+	{
+		DBG_871X("auth rejected due to bad alg [alg=%d, auth_mib=%d] %02X%02X%02X%02X%02X%02X\n",
+			algorithm, auth_mode, sa[0], sa[1], sa[2], sa[3], sa[4], sa[5]);
+
+		status = _STATS_NO_SUPP_ALG_;
+
+		goto auth_fail;
+	}
+
+	if(rtw_access_ctrl(rtlpriv, sa) == false)
+	{
+		status = _STATS_UNABLE_HANDLE_STA_;
+		goto auth_fail;
+	}
+
+	pstat = rtw_get_stainfo(pstapriv, sa);
+	if (pstat == NULL)
+	{
+		// allocate a new one
+		DBG_871X("going to alloc stainfo for sa="MAC_FMT"\n",  MAC_ARG(sa));
+		pstat = rtw_alloc_stainfo(pstapriv, sa);
+		if (pstat == NULL)
+		{
+			DBG_871X(" Exceed the upper limit of supported clients...\n");
+			status = _STATS_UNABLE_HANDLE_STA_;
+			goto auth_fail;
+		}
+
+		pstat->state = WIFI_FW_AUTH_NULL;
+		pstat->auth_seq = 0;
+
+		//pstat->flags = 0;
+		//pstat->capability = 0;
+	}
+	else
+	{
+		spin_lock_bh(&pstapriv->asoc_list_lock);
+		if(list_empty(&pstat->asoc_list)==false)
+		{
+			list_del_init(&pstat->asoc_list);
+			pstapriv->asoc_list_cnt--;
+			if (pstat->expire_to > 0)
+			{
+				//TODO: STA re_auth within expire_to
+			}
+		}
+		spin_unlock_bh(&pstapriv->asoc_list_lock);
+
+		if (seq==1) {
+			//TODO: STA re_auth and auth timeout
+		}
+	}
+
+	spin_lock_bh(&pstapriv->auth_list_lock);
+	if (list_empty(&pstat->auth_list))
+	{
+		list_add_tail(&pstat->auth_list, &pstapriv->auth_list);
+		pstapriv->auth_list_cnt++;
+	}
+	spin_unlock_bh(&pstapriv->auth_list_lock);
+
+	if (pstat->auth_seq == 0)
+		pstat->expire_to = pstapriv->auth_to;
+
+	if ((pstat->auth_seq + 1) != seq)
+	{
+		DBG_871X("(1)auth rejected because out of seq [rx_seq=%d, exp_seq=%d]!\n",
+			seq, pstat->auth_seq+1);
+		status = _STATS_OUT_OF_AUTH_SEQ_;
+		goto auth_fail;
+	}
+
+	if (algorithm==0 && (auth_mode == 0 || auth_mode == 2 || auth_mode == 3))
+	{
+		if (seq == 1)
+		{
+			pstat->state &= ~WIFI_FW_AUTH_NULL;
+			pstat->state |= WIFI_FW_AUTH_SUCCESS;
+			pstat->expire_to = pstapriv->assoc_to;
+			pstat->authalg = algorithm;
+		}
+		else
+		{
+			DBG_871X("(2)auth rejected because out of seq [rx_seq=%d, exp_seq=%d]!\n",
+				seq, pstat->auth_seq+1);
+			status = _STATS_OUT_OF_AUTH_SEQ_;
+			goto auth_fail;
+		}
+	}
+	else // shared system or auto authentication
+	{
+		if (seq == 1)
+		{
+			//prepare for the challenging txt...
+
+			//get_random_bytes((void *)pstat->chg_txt, 128);//TODO:
+			memset((void *)pstat->chg_txt, 78, 128);
+
+			pstat->state &= ~WIFI_FW_AUTH_NULL;
+			pstat->state |= WIFI_FW_AUTH_STATE;
+			pstat->authalg = algorithm;
+			pstat->auth_seq = 2;
+		}
+		else if (seq == 3)
+		{
+			//checking for challenging txt...
+			DBG_871X("checking for challenging txt...\n");
+
+			p = rtw_get_ie(pframe + WLAN_HDR_A3_LEN + 4 + _AUTH_IE_OFFSET_ , _CHLGETXT_IE_, (int *)&ie_len,
+					len - WLAN_HDR_A3_LEN - _AUTH_IE_OFFSET_ - 4);
+
+			if((p==NULL) || (ie_len<=0))
+			{
+				DBG_871X("auth rejected because challenge failure!(1)\n");
+				status = _STATS_CHALLENGE_FAIL_;
+				goto auth_fail;
+			}
+
+			if (_rtw_memcmp((void *)(p + 2), pstat->chg_txt, 128))
+			{
+				pstat->state &= (~WIFI_FW_AUTH_STATE);
+				pstat->state |= WIFI_FW_AUTH_SUCCESS;
+				// challenging txt is correct...
+				pstat->expire_to =  pstapriv->assoc_to;
+			}
+			else
+			{
+				DBG_871X("auth rejected because challenge failure!\n");
+				status = _STATS_CHALLENGE_FAIL_;
+				goto auth_fail;
+			}
+		}
+		else
+		{
+			DBG_871X("(3)auth rejected because out of seq [rx_seq=%d, exp_seq=%d]!\n",
+				seq, pstat->auth_seq+1);
+			status = _STATS_OUT_OF_AUTH_SEQ_;
+			goto auth_fail;
+		}
+	}
+
+
+	// Now, we are going to issue_auth...
+	pstat->auth_seq = seq + 1;
+
+	issue_auth(rtlpriv, pstat, (unsigned short)(_STATS_SUCCESSFUL_));
+
+	if (pstat->state & WIFI_FW_AUTH_SUCCESS)
+		pstat->auth_seq = 0;
+
+
+	return _SUCCESS;
+
+auth_fail:
+
+	if(pstat)
+		rtw_free_stainfo(rtlpriv , pstat);
+
+	pstat = &stat;
+	memset((char *)pstat, '\0', sizeof(stat));
+	pstat->auth_seq = 2;
+	memcpy(pstat->hwaddr, sa, 6);
+
+	issue_auth(rtlpriv, pstat, (unsigned short)status);
+
+#endif
+	return _FAIL;
+
+}
+
+unsigned int OnAuthClient(struct rtl_priv *rtlpriv, struct recv_frame *precv_frame)
+{
+	unsigned int	seq, len, status, algthm, offset;
+	unsigned char	*p;
+	unsigned int	go2asoc = 0;
+	struct mlme_ext_priv	*pmlmeext = &rtlpriv->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	uint8_t *pframe = precv_frame->rx_data;
+	uint pkt_len = precv_frame->len;
+
+	DBG_871X("%s\n", __FUNCTION__);
+
+	//check A1 matches or not
+	if (!_rtw_memcmp(rtlpriv->mac80211.mac_addr, get_da(pframe), ETH_ALEN))
+		return _SUCCESS;
+
+	if (!(pmlmeinfo->state & WIFI_FW_AUTH_STATE))
+		return _SUCCESS;
+
+	offset = (GetPrivacy(pframe))? 4: 0;
+
+	algthm 	= le16_to_cpu(*(unsigned short *)((u8 *)pframe + WLAN_HDR_A3_LEN + offset));
+	seq 	= le16_to_cpu(*(unsigned short *)((u8 *)pframe + WLAN_HDR_A3_LEN + offset + 2));
+	status 	= le16_to_cpu(*(unsigned short *)((u8 *)pframe + WLAN_HDR_A3_LEN + offset + 4));
+
+	if (status != 0)
+	{
+		DBG_871X("clnt auth fail, status: %d\n", status);
+		if(status == 13)//&& pmlmeinfo->auth_algo == dot11AuthAlgrthm_Auto)
+		{
+			if(pmlmeinfo->auth_algo == dot11AuthAlgrthm_Shared)
+				pmlmeinfo->auth_algo = dot11AuthAlgrthm_Open;
+			else
+				pmlmeinfo->auth_algo = dot11AuthAlgrthm_Shared;
+			//pmlmeinfo->reauth_count = 0;
+		}
+
+		set_link_timer(pmlmeext, 1);
+		goto authclnt_fail;
+	}
+
+	if (seq == 2)
+	{
+		if (pmlmeinfo->auth_algo == dot11AuthAlgrthm_Shared)
+		{
+			 // legendary shared system
+			p = rtw_get_ie(pframe + WLAN_HDR_A3_LEN + _AUTH_IE_OFFSET_, _CHLGETXT_IE_, (int *)&len,
+				pkt_len - WLAN_HDR_A3_LEN - _AUTH_IE_OFFSET_);
+
+			if (p == NULL)
+			{
+				//DBG_871X("marc: no challenge text?\n");
+				goto authclnt_fail;
+			}
+
+			memcpy((void *)(pmlmeinfo->chg_txt), (void *)(p + 2), len);
+			pmlmeinfo->auth_seq = 3;
+			issue_auth(rtlpriv, NULL, 0);
+			set_link_timer(pmlmeext, REAUTH_TO);
+
+			return _SUCCESS;
+		}
+		else
+		{
+			// open system
+			go2asoc = 1;
+		}
+	}
+	else if (seq == 4)
+	{
+		if (pmlmeinfo->auth_algo == dot11AuthAlgrthm_Shared)
+		{
+			go2asoc = 1;
+		}
+		else
+		{
+			goto authclnt_fail;
+		}
+	}
+	else
+	{
+		// this is also illegal
+		//DBG_871X("marc: clnt auth failed due to illegal seq=%x\n", seq);
+		goto authclnt_fail;
+	}
+
+	if (go2asoc)
+	{
+		DBG_871X_LEVEL(_drv_always_, "auth success, start assoc\n");
+		start_clnt_assoc(rtlpriv);
+		return _SUCCESS;
+	}
+
+authclnt_fail:
+
+	//pmlmeinfo->state &= ~(WIFI_FW_AUTH_STATE);
+
+	return _FAIL;
+
+}
+
+unsigned int OnAssocReq(struct rtl_priv *rtlpriv, struct recv_frame *precv_frame)
+{
+#ifdef CONFIG_AP_MODE
+	u16 capab_info, listen_interval;
+	struct rtw_ieee802_11_elems elems;
+	struct sta_info	*pstat;
+	unsigned char		reassoc, *p, *pos, *wpa_ie;
+	unsigned char WMM_IE[] = {0x00, 0x50, 0xf2, 0x02, 0x00, 0x01};
+	int		i, ie_len, wpa_ie_len, left;
+	unsigned char		supportRate[16];
+	int					supportRateNum;
+	unsigned short		status = _STATS_SUCCESSFUL_;
+	unsigned short		frame_type, ie_offset=0;
+	struct mlme_priv *pmlmepriv = &rtlpriv->mlmepriv;
+	struct security_priv *psecuritypriv = &rtlpriv->securitypriv;
+	struct mlme_ext_priv *pmlmeext = &rtlpriv->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	WLAN_BSSID_EX 	*cur = &(pmlmeinfo->network);
+	struct sta_priv *pstapriv = &rtlpriv->stapriv;
+	uint8_t *pframe = precv_frame->rx_data;
+	uint pkt_len = precv_frame->len;
+
+	if((pmlmeinfo->state&0x03) != WIFI_FW_AP_STATE)
+		return _FAIL;
+
+	frame_type = GetFrameSubType(pframe);
+	if (frame_type == WIFI_ASSOCREQ)
+	{
+		reassoc = 0;
+		ie_offset = _ASOCREQ_IE_OFFSET_;
+	}
+	else // WIFI_REASSOCREQ
+	{
+		reassoc = 1;
+		ie_offset = _REASOCREQ_IE_OFFSET_;
+	}
+
+
+	if (pkt_len < IEEE80211_3ADDR_LEN + ie_offset) {
+		DBG_871X("handle_assoc(reassoc=%d) - too short payload (len=%lu)"
+		       "\n", reassoc, (unsigned long)pkt_len);
+		return _FAIL;
+	}
+
+	pstat = rtw_get_stainfo(pstapriv, GetAddr2Ptr(pframe));
+	if (pstat == (struct sta_info *)NULL)
+	{
+		status = _RSON_CLS2_;
+		goto asoc_class2_error;
+	}
+
+	capab_info = RTW_GET_LE16(pframe + WLAN_HDR_A3_LEN);
+	//capab_info = le16_to_cpu(*(unsigned short *)(pframe + WLAN_HDR_A3_LEN));
+	//listen_interval = le16_to_cpu(*(unsigned short *)(pframe + WLAN_HDR_A3_LEN+2));
+	listen_interval = RTW_GET_LE16(pframe + WLAN_HDR_A3_LEN+2);
+
+	left = pkt_len - (IEEE80211_3ADDR_LEN + ie_offset);
+	pos = pframe + (IEEE80211_3ADDR_LEN + ie_offset);
+
+
+	DBG_871X("%s\n", __FUNCTION__);
+
+	// check if this stat has been successfully authenticated/assocated
+	if (!((pstat->state) & WIFI_FW_AUTH_SUCCESS))
+	{
+		if (!((pstat->state) & WIFI_FW_ASSOC_SUCCESS))
+		{
+			status = _RSON_CLS2_;
+			goto asoc_class2_error;
+		}
+		else
+		{
+			pstat->state &= (~WIFI_FW_ASSOC_SUCCESS);
+			pstat->state |= WIFI_FW_ASSOC_STATE;
+		}
+	}
+	else
+	{
+		pstat->state &= (~WIFI_FW_AUTH_SUCCESS);
+		pstat->state |= WIFI_FW_ASSOC_STATE;
+	}
+
+	pstat->capability = capab_info;
+
+	//now parse all ieee802_11 ie to point to elems
+	if (rtw_ieee802_11_parse_elems(pos, left, &elems, 1) == ParseFailed ||
+	    !elems.ssid) {
+		DBG_871X("STA " MAC_FMT " sent invalid association request\n",
+		       MAC_ARG(pstat->hwaddr));
+		status = _STATS_FAILURE_;
+		goto OnAssocReqFail;
+	}
+
+
+	// now we should check all the fields...
+	// checking SSID
+	p = rtw_get_ie(pframe + WLAN_HDR_A3_LEN + ie_offset, _SSID_IE_, &ie_len,
+		pkt_len - WLAN_HDR_A3_LEN - ie_offset);
+	if (p == NULL)
+	{
+		status = _STATS_FAILURE_;
+	}
+
+	if (ie_len == 0) // broadcast ssid, however it is not allowed in assocreq
+		status = _STATS_FAILURE_;
+	else
+	{
+		// check if ssid match
+		if (!_rtw_memcmp((void *)(p+2), cur->Ssid.Ssid, cur->Ssid.SsidLength))
+			status = _STATS_FAILURE_;
+
+		if (ie_len != cur->Ssid.SsidLength)
+			status = _STATS_FAILURE_;
+	}
+
+	if(_STATS_SUCCESSFUL_ != status)
+		goto OnAssocReqFail;
+
+	// check if the supported rate is ok
+	p = rtw_get_ie(pframe + WLAN_HDR_A3_LEN + ie_offset, _SUPPORTEDRATES_IE_, &ie_len, pkt_len - WLAN_HDR_A3_LEN - ie_offset);
+	if (p == NULL) {
+		DBG_871X("Rx a sta assoc-req which supported rate is empty!\n");
+		// use our own rate set as statoin used
+		//memcpy(supportRate, AP_BSSRATE, AP_BSSRATE_LEN);
+		//supportRateNum = AP_BSSRATE_LEN;
+
+		status = _STATS_FAILURE_;
+		goto OnAssocReqFail;
+	}
+	else {
+		memcpy(supportRate, p+2, ie_len);
+		supportRateNum = ie_len;
+
+		p = rtw_get_ie(pframe + WLAN_HDR_A3_LEN + ie_offset, _EXT_SUPPORTEDRATES_IE_ , &ie_len,
+				pkt_len - WLAN_HDR_A3_LEN - ie_offset);
+		if (p !=  NULL) {
+
+			if(supportRateNum<=sizeof(supportRate))
+			{
+				memcpy(supportRate+supportRateNum, p+2, ie_len);
+				supportRateNum += ie_len;
+			}
+		}
+	}
+
+	//todo: mask supportRate between AP & STA -> move to update raid
+	//get_matched_rate(pmlmeext, supportRate, &supportRateNum, 0);
+
+	//update station supportRate
+	pstat->bssratelen = supportRateNum;
+	memcpy(pstat->bssrateset, supportRate, supportRateNum);
+	UpdateBrateTblForSoftAP(pstat->bssrateset, pstat->bssratelen);
+
+	//check RSN/WPA/WPS
+	pstat->dot8021xalg = 0;
+      	pstat->wpa_psk = 0;
+	pstat->wpa_group_cipher = 0;
+	pstat->wpa2_group_cipher = 0;
+	pstat->wpa_pairwise_cipher = 0;
+	pstat->wpa2_pairwise_cipher = 0;
+	memset(pstat->wpa_ie, 0, sizeof(pstat->wpa_ie));
+	if((psecuritypriv->wpa_psk & BIT(1)) && elems.rsn_ie) {
+
+		int group_cipher=0, pairwise_cipher=0;
+
+		wpa_ie = elems.rsn_ie;
+		wpa_ie_len = elems.rsn_ie_len;
+
+		if(rtw_parse_wpa2_ie(wpa_ie-2, wpa_ie_len+2, &group_cipher, &pairwise_cipher, NULL) == _SUCCESS)
+		{
+			pstat->dot8021xalg = 1;//psk,  todo:802.1x
+			pstat->wpa_psk |= BIT(1);
+
+			pstat->wpa2_group_cipher = group_cipher&psecuritypriv->wpa2_group_cipher;
+			pstat->wpa2_pairwise_cipher = pairwise_cipher&psecuritypriv->wpa2_pairwise_cipher;
+
+			if(!pstat->wpa2_group_cipher)
+				status = WLAN_STATUS_GROUP_CIPHER_NOT_VALID;
+
+			if(!pstat->wpa2_pairwise_cipher)
+				status = WLAN_STATUS_PAIRWISE_CIPHER_NOT_VALID;
+		}
+		else
+		{
+			status = WLAN_STATUS_INVALID_IE;
+		}
+
+	} else if ((psecuritypriv->wpa_psk & BIT(0)) && elems.wpa_ie) {
+
+		int group_cipher=0, pairwise_cipher=0;
+
+		wpa_ie = elems.wpa_ie;
+		wpa_ie_len = elems.wpa_ie_len;
+
+		if(rtw_parse_wpa_ie(wpa_ie-2, wpa_ie_len+2, &group_cipher, &pairwise_cipher, NULL) == _SUCCESS)
+		{
+			pstat->dot8021xalg = 1;//psk,  todo:802.1x
+			pstat->wpa_psk |= BIT(0);
+
+			pstat->wpa_group_cipher = group_cipher&psecuritypriv->wpa_group_cipher;
+			pstat->wpa_pairwise_cipher = pairwise_cipher&psecuritypriv->wpa_pairwise_cipher;
+
+			if(!pstat->wpa_group_cipher)
+				status = WLAN_STATUS_GROUP_CIPHER_NOT_VALID;
+
+			if(!pstat->wpa_pairwise_cipher)
+				status = WLAN_STATUS_PAIRWISE_CIPHER_NOT_VALID;
+
+		}
+		else
+		{
+			status = WLAN_STATUS_INVALID_IE;
+		}
+
+	} else {
+		wpa_ie = NULL;
+		wpa_ie_len = 0;
+	}
+
+	if(_STATS_SUCCESSFUL_ != status)
+		goto OnAssocReqFail;
+
+	pstat->flags &= ~(WLAN_STA_WPS | WLAN_STA_MAYBE_WPS);
+	//if (hapd->conf->wps_state && wpa_ie == NULL) { //todo: to check ap if supporting WPS
+	if(wpa_ie == NULL) {
+		if (elems.wps_ie) {
+			DBG_871X("STA included WPS IE in "
+				   "(Re)Association Request - assume WPS is "
+				   "used\n");
+			pstat->flags |= WLAN_STA_WPS;
+			//wpabuf_free(sta->wps_ie);
+			//sta->wps_ie = wpabuf_alloc_copy(elems.wps_ie + 4,
+			//				elems.wps_ie_len - 4);
+		} else {
+			DBG_871X("STA did not include WPA/RSN IE "
+				   "in (Re)Association Request - possible WPS "
+				   "use\n");
+			pstat->flags |= WLAN_STA_MAYBE_WPS;
+		}
+
+
+		// AP support WPA/RSN, and sta is going to do WPS, but AP is not ready
+		// that the selected registrar of AP is _FLASE
+		if((psecuritypriv->wpa_psk >0)
+			&& (pstat->flags & (WLAN_STA_WPS|WLAN_STA_MAYBE_WPS)))
+		{
+			if(pmlmepriv->wps_beacon_ie)
+			{
+				uint8_t selected_registrar = 0;
+
+				rtw_get_wps_attr_content(pmlmepriv->wps_beacon_ie, pmlmepriv->wps_beacon_ie_len, WPS_ATTR_SELECTED_REGISTRAR , &selected_registrar, NULL);
+
+				if(!selected_registrar)
+				{
+					DBG_871X("selected_registrar is false , or AP is not ready to do WPS\n");
+
+					status = _STATS_UNABLE_HANDLE_STA_;
+
+					goto OnAssocReqFail;
+				}
+			}
+		}
+
+	}
+	else
+	{
+		int copy_len;
+
+		if(psecuritypriv->wpa_psk == 0)
+		{
+			DBG_871X("STA " MAC_FMT ": WPA/RSN IE in association "
+		       	"request, but AP don't support WPA/RSN\n", MAC_ARG(pstat->hwaddr));
+
+			status = WLAN_STATUS_INVALID_IE;
+
+			goto OnAssocReqFail;
+
+		}
+
+		if (elems.wps_ie) {
+			DBG_871X("STA included WPS IE in "
+				   "(Re)Association Request - WPS is "
+				   "used\n");
+			pstat->flags |= WLAN_STA_WPS;
+			copy_len=0;
+		}
+		else
+		{
+			copy_len = ((wpa_ie_len+2) > sizeof(pstat->wpa_ie)) ? (sizeof(pstat->wpa_ie)):(wpa_ie_len+2);
+		}
+
+
+		if(copy_len>0)
+			memcpy(pstat->wpa_ie, wpa_ie-2, copy_len);
+
+	}
+
+
+	// check if there is WMM IE & support WWM-PS
+	pstat->flags &= ~WLAN_STA_WME;
+	pstat->qos_option = 0;
+	pstat->qos_info = 0;
+	pstat->has_legacy_ac = true;
+	pstat->uapsd_vo = 0;
+	pstat->uapsd_vi = 0;
+	pstat->uapsd_be = 0;
+	pstat->uapsd_bk = 0;
+	if (pmlmepriv->qospriv.qos_option)
+	{
+		p = pframe + WLAN_HDR_A3_LEN + ie_offset; ie_len = 0;
+		for (;;)
+		{
+			p = rtw_get_ie(p, _VENDOR_SPECIFIC_IE_, &ie_len, pkt_len - WLAN_HDR_A3_LEN - ie_offset);
+			if (p != NULL) {
+				if (_rtw_memcmp(p+2, WMM_IE, 6)) {
+
+					pstat->flags |= WLAN_STA_WME;
+
+					pstat->qos_option = 1;
+					pstat->qos_info = *(p+8);
+
+					pstat->max_sp_len = (pstat->qos_info>>5)&0x3;
+
+					if((pstat->qos_info&0xf) !=0xf)
+						pstat->has_legacy_ac = true;
+					else
+						pstat->has_legacy_ac = false;
+
+					if(pstat->qos_info&0xf)
+					{
+						if(pstat->qos_info&BIT(0))
+							pstat->uapsd_vo = BIT(0)|BIT(1);
+						else
+							pstat->uapsd_vo = 0;
+
+						if(pstat->qos_info&BIT(1))
+							pstat->uapsd_vi = BIT(0)|BIT(1);
+						else
+							pstat->uapsd_vi = 0;
+
+						if(pstat->qos_info&BIT(2))
+							pstat->uapsd_bk = BIT(0)|BIT(1);
+						else
+							pstat->uapsd_bk = 0;
+
+						if(pstat->qos_info&BIT(3))
+							pstat->uapsd_be = BIT(0)|BIT(1);
+						else
+							pstat->uapsd_be = 0;
+
+					}
+
+					break;
+				}
+			}
+			else {
+				break;
+			}
+			p = p + ie_len + 2;
+		}
+	}
+
+
+	/* save HT capabilities in the sta object */
+	memset(&pstat->htpriv.ht_cap, 0, sizeof(struct rtw_ieee80211_ht_cap));
+	if (elems.ht_capabilities && elems.ht_capabilities_len >= sizeof(struct rtw_ieee80211_ht_cap))
+	{
+		pstat->flags |= WLAN_STA_HT;
+
+		pstat->flags |= WLAN_STA_WME;
+
+		memcpy(&pstat->htpriv.ht_cap, elems.ht_capabilities, sizeof(struct rtw_ieee80211_ht_cap));
+
+	} else
+		pstat->flags &= ~WLAN_STA_HT;
+
+
+	if((pmlmepriv->htpriv.ht_option == false) && (pstat->flags&WLAN_STA_HT))
+	{
+		status = _STATS_FAILURE_;
+		goto OnAssocReqFail;
+	}
+
+
+	if ((pstat->flags & WLAN_STA_HT) &&
+		    ((pstat->wpa2_pairwise_cipher&WPA_CIPHER_TKIP) ||
+		      (pstat->wpa_pairwise_cipher&WPA_CIPHER_TKIP)))
+	{
+		DBG_871X("HT: " MAC_FMT " tried to "
+				   "use TKIP with HT association\n", MAC_ARG(pstat->hwaddr));
+
+		//status = WLAN_STATUS_CIPHER_REJECTED_PER_POLICY;
+		//goto OnAssocReqFail;
+	}
+
+	memset(&pstat->vhtpriv, 0, sizeof(struct vht_priv));
+	if (elems.vht_capabilities && elems.vht_capabilities_len == 12) {
+		pstat->flags |= WLAN_STA_VHT;
+
+		memcpy(pstat->vhtpriv.vht_cap, elems.vht_capabilities, 12);
+
+		if (elems.vht_op_mode_notify && elems.vht_op_mode_notify_len == 1) {
+			pstat->vhtpriv.vht_bwmode = GET_VHT_OPERATING_MODE_FIELD_CHNL_WIDTH(elems.vht_op_mode_notify);
+		}
+	}
+	else {
+		pstat->flags &= ~WLAN_STA_HT;
+	}
+
+	if((pmlmepriv->vhtpriv.vht_option == false) && (pstat->flags&WLAN_STA_VHT))
+	{
+		status = _STATS_FAILURE_;
+		goto OnAssocReqFail;
+	}
+
+       //
+       //if (hapd->iface->current_mode->mode == HOSTAPD_MODE_IEEE80211G)//?
+	pstat->flags |= WLAN_STA_NONERP;
+	for (i = 0; i < pstat->bssratelen; i++) {
+		if ((pstat->bssrateset[i] & 0x7f) > 22) {
+			pstat->flags &= ~WLAN_STA_NONERP;
+			break;
+		}
+	}
+
+	if (pstat->capability & WLAN_CAPABILITY_SHORT_PREAMBLE)
+		pstat->flags |= WLAN_STA_SHORT_PREAMBLE;
+	else
+		pstat->flags &= ~WLAN_STA_SHORT_PREAMBLE;
+
+
+
+	if (status != _STATS_SUCCESSFUL_)
+		goto OnAssocReqFail;
+
+	//TODO: identify_proprietary_vendor_ie();
+	// Realtek proprietary IE
+	// identify if this is Broadcom sta
+	// identify if this is ralink sta
+	// Customer proprietary IE
+
+
+
+	/* get a unique AID */
+	if (pstat->aid > 0) {
+		DBG_871X("  old AID %d\n", pstat->aid);
+	} else {
+		for (pstat->aid = 1; pstat->aid <= NUM_STA; pstat->aid++)
+			if (pstapriv->sta_aid[pstat->aid - 1] == NULL)
+				break;
+
+		//if (pstat->aid > NUM_STA) {
+		if (pstat->aid > pstapriv->max_num_sta) {
+
+			pstat->aid = 0;
+
+			DBG_871X("  no room for more AIDs\n");
+
+			status = WLAN_STATUS_AP_UNABLE_TO_HANDLE_NEW_STA;
+
+			goto OnAssocReqFail;
+
+
+		} else {
+			pstapriv->sta_aid[pstat->aid - 1] = pstat;
+			DBG_871X("allocate new AID = (%d)\n", pstat->aid);
+		}
+	}
+
+
+	pstat->state &= (~WIFI_FW_ASSOC_STATE);
+	pstat->state |= WIFI_FW_ASSOC_SUCCESS;
+
+	spin_lock_bh(&pstapriv->auth_list_lock);
+	if (!list_empty(&pstat->auth_list))
+	{
+		list_del_init(&pstat->auth_list);
+		pstapriv->auth_list_cnt--;
+	}
+	spin_unlock_bh(&pstapriv->auth_list_lock);
+
+	spin_lock_bh(&pstapriv->asoc_list_lock);
+	if (list_empty(&pstat->asoc_list))
+	{
+		pstat->expire_to = pstapriv->expire_to;
+		list_add_tail(&pstat->asoc_list, &pstapriv->asoc_list);
+		pstapriv->asoc_list_cnt++;
+	}
+	spin_unlock_bh(&pstapriv->asoc_list_lock);
+
+	// now the station is qualified to join our BSS...
+	if(pstat && (pstat->state & WIFI_FW_ASSOC_SUCCESS) && (_STATS_SUCCESSFUL_==status))
+	{
+		//.1 bss_cap_update & sta_info_update
+		bss_cap_update_on_sta_join(rtlpriv, pstat);
+		sta_info_update(rtlpriv, pstat);
+
+		//issue assoc rsp before notify station join event.
+		if (frame_type == WIFI_ASSOCREQ)
+			issue_asocrsp(rtlpriv, status, pstat, WIFI_ASSOCRSP);
+		else
+			issue_asocrsp(rtlpriv, status, pstat, WIFI_REASSOCRSP);
+
+		//.2 - report to upper layer
+		DBG_871X("indicate_sta_join_event to upper layer - hostapd\n");
+		rtw_indicate_sta_assoc_event(rtlpriv, pstat);
+
+		//.3-(1) report sta add event
+		report_add_sta_event(rtlpriv, pstat->hwaddr, pstat->aid);
+
+/*
+		//issue assoc rsp before notify station join event.
+		if (frame_type == WIFI_ASSOCREQ)
+			issue_asocrsp(rtlpriv, status, pstat, WIFI_ASSOCRSP);
+		else
+			issue_asocrsp(rtlpriv, status, pstat, WIFI_REASSOCRSP);
+*/
+
+	}
+
+	return _SUCCESS;
+
+asoc_class2_error:
+
+	issue_deauth(rtlpriv, (void *)GetAddr2Ptr(pframe), status);
+
+	return _FAIL;
+
+OnAssocReqFail:
+
+
+	pstat->aid = 0;
+	if (frame_type == WIFI_ASSOCREQ)
+		issue_asocrsp(rtlpriv, status, pstat, WIFI_ASSOCRSP);
+	else
+		issue_asocrsp(rtlpriv, status, pstat, WIFI_REASSOCRSP);
+
+
+#endif /* CONFIG_AP_MODE */
+
+	return _FAIL;
+
+}
+
+unsigned int OnAssocRsp(struct rtl_priv *rtlpriv, struct recv_frame *precv_frame)
+{
+	uint i;
+	int res;
+	unsigned short	status;
+	PNDIS_802_11_VARIABLE_IEs	pIE;
+	struct mlme_priv *pmlmepriv = &rtlpriv->mlmepriv;
+	struct mlme_ext_priv	*pmlmeext = &rtlpriv->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	//WLAN_BSSID_EX 		*cur_network = &(pmlmeinfo->network);
+	uint8_t *pframe = precv_frame->rx_data;
+	uint pkt_len = precv_frame->len;
+	PNDIS_802_11_VARIABLE_IEs	pWapiIE = NULL;
+
+	DBG_871X("%s\n", __FUNCTION__);
+
+	//check A1 matches or not
+	if (!_rtw_memcmp(rtlpriv->mac80211.mac_addr, get_da(pframe), ETH_ALEN))
+		return _SUCCESS;
+
+	if (!(pmlmeinfo->state & (WIFI_FW_AUTH_SUCCESS | WIFI_FW_ASSOC_STATE)))
+		return _SUCCESS;
+
+	if (pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS)
+		return _SUCCESS;
+
+	del_timer_sync_ex(&pmlmeext->link_timer);
+
+	//status
+	if ((status = le16_to_cpu(*(unsigned short *)(pframe + WLAN_HDR_A3_LEN + 2))) > 0)
+	{
+		DBG_871X("assoc reject, status code: %d\n", status);
+		pmlmeinfo->state = WIFI_FW_NULL_STATE;
+		res = -4;
+		goto report_assoc_result;
+	}
+
+	//get capabilities
+	pmlmeinfo->capability = le16_to_cpu(*(unsigned short *)(pframe + WLAN_HDR_A3_LEN));
+
+	//set slot time
+	pmlmeinfo->slotTime = (pmlmeinfo->capability & BIT(10))? 9: 20;
+
+	//AID
+	res = pmlmeinfo->aid = (int)(le16_to_cpu(*(unsigned short *)(pframe + WLAN_HDR_A3_LEN + 4))&0x3fff);
+
+	//following are moved to join event callback function
+	//to handle HT, WMM, rate adaptive, update MAC reg
+	//for not to handle the synchronous IO in the tasklet
+	for (i = (6 + WLAN_HDR_A3_LEN); i < pkt_len;)
+	{
+		pIE = (PNDIS_802_11_VARIABLE_IEs)(pframe + i);
+
+		switch (pIE->ElementID)
+		{
+			case _VENDOR_SPECIFIC_IE_:
+				if (_rtw_memcmp(pIE->data, WMM_PARA_OUI, 6))	//WMM
+				{
+					WMM_param_handler(rtlpriv, pIE);
+				}
+				break;
+
+			case _HT_CAPABILITY_IE_:	//HT caps
+				HT_caps_handler(rtlpriv, pIE);
+				break;
+
+			case _HT_EXTRA_INFO_IE_:	//HT info
+				HT_info_handler(rtlpriv, pIE);
+				break;
+
+			case EID_VHTCapability:
+				VHT_caps_handler(rtlpriv, pIE);
+				break;
+
+			case EID_VHTOperation:
+				VHT_operation_handler(rtlpriv, pIE);
+				break;
+
+			case _ERPINFO_IE_:
+				ERP_IE_handler(rtlpriv, pIE);
+
+			default:
+				break;
+		}
+
+		i += (pIE->Length + 2);
+	}
+
+	pmlmeinfo->state &= (~WIFI_FW_ASSOC_STATE);
+	pmlmeinfo->state |= WIFI_FW_ASSOC_SUCCESS;
+
+	//Update Basic Rate Table for spec, 2010-12-28 , by thomas
+	UpdateBrateTbl(rtlpriv, pmlmeinfo->network.SupportedRates);
+
+report_assoc_result:
+	if (res > 0) {
+		rtw_buf_update(&pmlmepriv->assoc_rsp, &pmlmepriv->assoc_rsp_len, pframe, pkt_len);
+	} else {
+		rtw_buf_free(&pmlmepriv->assoc_rsp, &pmlmepriv->assoc_rsp_len);
+	}
+
+	report_join_res(rtlpriv, res);
+
+	return _SUCCESS;
+}
+
+unsigned int OnDeAuth(struct rtl_priv *rtlpriv, struct recv_frame *precv_frame)
+{
+	unsigned short	reason;
+	struct mlme_priv *pmlmepriv = &rtlpriv->mlmepriv;
+	struct mlme_ext_priv	*pmlmeext = &rtlpriv->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	uint8_t *pframe = precv_frame->rx_data;
+
+	//check A3
+	if (!(_rtw_memcmp(GetAddr3Ptr(pframe), get_my_bssid(&pmlmeinfo->network), ETH_ALEN)))
+		return _SUCCESS;
+
+
+	reason = le16_to_cpu(*(unsigned short *)(pframe + WLAN_HDR_A3_LEN));
+
+	DBG_871X("%s Reason code(%d)\n", __FUNCTION__,reason);
+
+#ifdef CONFIG_AP_MODE
+	if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
+	{
+		struct sta_info *psta;
+		struct sta_priv *pstapriv = &rtlpriv->stapriv;
+
+		//spin_lock_bh(&(pstapriv->sta_hash_lock), &irqL);
+		//rtw_free_stainfo(rtlpriv, psta);
+		//spin_unlock_bh(&(pstapriv->sta_hash_lock), &irqL);
+
+		DBG_871X_LEVEL(_drv_always_, "ap recv deauth reason code(%d) sta:%pM\n",
+			       	reason, GetAddr2Ptr(pframe));
+
+		psta = rtw_get_stainfo(pstapriv, GetAddr2Ptr(pframe));
+		if(psta)
+		{
+			uint8_t updated;
+
+			spin_lock_bh(&pstapriv->asoc_list_lock);
+			if(list_empty(&psta->asoc_list)==false)
+			{
+				list_del_init(&psta->asoc_list);
+				pstapriv->asoc_list_cnt--;
+				updated = ap_free_sta(rtlpriv, psta, false, reason);
+
+			}
+			spin_unlock_bh(&pstapriv->asoc_list_lock);
+
+			associated_clients_update(rtlpriv, updated);
+		}
+
+
+		return _SUCCESS;
+	}
+	else
+#endif
+	{
+		DBG_871X_LEVEL(_drv_always_, "sta recv deauth reason code(%d) sta:%pM\n",
+			       	reason, GetAddr3Ptr(pframe));
+
+		receive_disconnect(rtlpriv, GetAddr3Ptr(pframe) ,reason);
+	}
+	pmlmepriv->LinkDetectInfo.bBusyTraffic = false;
+	return _SUCCESS;
+
+}
+
+unsigned int OnDisassoc(struct rtl_priv *rtlpriv, struct recv_frame *precv_frame)
+{
+	unsigned short	reason;
+	struct mlme_priv *pmlmepriv = &rtlpriv->mlmepriv;
+	struct mlme_ext_priv	*pmlmeext = &rtlpriv->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	uint8_t *pframe = precv_frame->rx_data;
+
+	//check A3
+	if (!(_rtw_memcmp(GetAddr3Ptr(pframe), get_my_bssid(&pmlmeinfo->network), ETH_ALEN)))
+		return _SUCCESS;
+
+
+	reason = le16_to_cpu(*(unsigned short *)(pframe + WLAN_HDR_A3_LEN));
+
+        DBG_871X("%s Reason code(%d)\n", __FUNCTION__,reason);
+
+#ifdef CONFIG_AP_MODE
+	if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
+	{
+		struct sta_info *psta;
+		struct sta_priv *pstapriv = &rtlpriv->stapriv;
+
+		//spin_lock_bh(&(pstapriv->sta_hash_lock), &irqL);
+		//rtw_free_stainfo(rtlpriv, psta);
+		//spin_unlock_bh(&(pstapriv->sta_hash_lock), &irqL);
+
+		DBG_871X_LEVEL(_drv_always_, "ap recv disassoc reason code(%d) sta:%pM\n",
+				reason, GetAddr2Ptr(pframe));
+
+		psta = rtw_get_stainfo(pstapriv, GetAddr2Ptr(pframe));
+		if(psta)
+		{
+			uint8_t updated;
+
+			spin_lock_bh(&pstapriv->asoc_list_lock);
+			if(list_empty(&psta->asoc_list)==false)
+			{
+				list_del_init(&psta->asoc_list);
+				pstapriv->asoc_list_cnt--;
+				updated = ap_free_sta(rtlpriv, psta, false, reason);
+
+			}
+			spin_unlock_bh(&pstapriv->asoc_list_lock);
+
+			associated_clients_update(rtlpriv, updated);
+		}
+
+		return _SUCCESS;
+	}
+	else
+#endif
+	{
+		DBG_871X_LEVEL(_drv_always_, "ap recv disassoc reason code(%d) sta:%pM\n",
+				reason, GetAddr3Ptr(pframe));
+
+		receive_disconnect(rtlpriv, GetAddr3Ptr(pframe), reason);
+	}
+	pmlmepriv->LinkDetectInfo.bBusyTraffic = false;
+	return _SUCCESS;
+
+}
+
+unsigned int OnAtim(struct rtl_priv *rtlpriv, struct recv_frame *precv_frame)
+{
+	DBG_871X("%s\n", __FUNCTION__);
+	return _SUCCESS;
+}
+
+unsigned int on_action_spct_ch_switch(struct rtl_priv *rtlpriv, struct sta_info *psta, uint8_t *ies, uint ies_len)
+{
+	unsigned int ret = _FAIL;
+	struct mlme_ext_priv *mlmeext = &rtlpriv->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(mlmeext->mlmext_info);
+
+	if (!(pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS)) {
+		ret = _SUCCESS;
+		goto exit;
+	}
+
+	if ((pmlmeinfo->state & 0x03) == WIFI_FW_STATION_STATE) {
+
+		int ch_switch_mode = -1, ch = -1, ch_switch_cnt = -1;
+		int ch_offset = -1;
+		uint8_t bwmode;
+		struct ieee80211_info_element *ie;
+
+		DBG_871X(FUNC_NDEV_FMT" from "MAC_FMT"\n",
+			FUNC_NDEV_ARG(rtlpriv->ndev), MAC_ARG(psta->hwaddr));
+
+		for_each_ie(ie, ies, ies_len) {
+			if (ie->id == WLAN_EID_CHANNEL_SWITCH) {
+				ch_switch_mode = ie->data[0];
+				ch = ie->data[1];
+				ch_switch_cnt = ie->data[2];
+				DBG_871X("ch_switch_mode:%d, ch:%d, ch_switch_cnt:%d\n",
+					ch_switch_mode, ch, ch_switch_cnt);
+			}
+			else if (ie->id == WLAN_EID_SECONDARY_CHANNEL_OFFSET) {
+				ch_offset = secondary_ch_offset_to_hal_ch_offset(ie->data[0]);
+				DBG_871X("ch_offset:%d\n", ch_offset);
+			}
+		}
+
+		if (ch == -1)
+			return _SUCCESS;
+
+		if (ch_offset == -1)
+			bwmode = mlmeext->cur_bwmode;
+		else
+			bwmode = (ch_offset == HAL_PRIME_CHNL_OFFSET_DONT_CARE) ?
+				CHANNEL_WIDTH_20 : CHANNEL_WIDTH_40;
+
+		ch_offset = (ch_offset == -1) ? mlmeext->cur_ch_offset : ch_offset;
+
+		/* todo:
+		 * 1. the decision of channel switching
+		 * 2. things after channel switching
+		 */
+
+		ret = rtw_set_ch_cmd(rtlpriv, ch, bwmode, ch_offset, true);
+	}
+
+exit:
+	return ret;
+}
+
+unsigned int on_action_spct(struct rtl_priv *rtlpriv, struct recv_frame *precv_frame)
+{
+	unsigned int ret = _FAIL;
+	struct sta_info *psta = NULL;
+	struct sta_priv *pstapriv = &rtlpriv->stapriv;
+	uint8_t *pframe = precv_frame->rx_data;
+	uint frame_len = precv_frame->len;
+	uint8_t *frame_body = (uint8_t *)(pframe + sizeof(struct rtw_ieee80211_hdr_3addr));
+	uint8_t category;
+	uint8_t action;
+
+	DBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(rtlpriv->ndev));
+
+	psta = rtw_get_stainfo(pstapriv, GetAddr2Ptr(pframe));
+
+	if (!psta)
+		goto exit;
+
+	category = frame_body[0];
+	if(category != RTW_WLAN_CATEGORY_SPECTRUM_MGMT)
+		goto exit;
+
+	action = frame_body[1];
+	switch (action) {
+	case RTW_WLAN_ACTION_SPCT_MSR_REQ:
+	case RTW_WLAN_ACTION_SPCT_MSR_RPRT:
+	case RTW_WLAN_ACTION_SPCT_TPC_REQ:
+	case RTW_WLAN_ACTION_SPCT_TPC_RPRT:
+		break;
+	case RTW_WLAN_ACTION_SPCT_CHL_SWITCH:
+		#ifdef CONFIG_SPCT_CH_SWITCH
+		ret = on_action_spct_ch_switch(rtlpriv, psta, &frame_body[2],
+			frame_len-(frame_body-pframe)-2);
+		#endif
+		break;
+	default:
+		break;
+	}
+
+exit:
+	return ret;
+}
+
+unsigned int OnAction_qos(struct rtl_priv *rtlpriv, struct recv_frame *precv_frame)
+{
+	return _SUCCESS;
+}
+
+unsigned int OnAction_dls(struct rtl_priv *rtlpriv, struct recv_frame *precv_frame)
+{
+	return _SUCCESS;
+}
+
+unsigned int OnAction_back(struct rtl_priv *rtlpriv, struct recv_frame *precv_frame)
+{
+	uint8_t *addr;
+	struct sta_info *psta=NULL;
+	struct recv_reorder_ctrl *preorder_ctrl;
+	unsigned char		*frame_body;
+	unsigned char		category, action;
+	unsigned short	tid, status, reason_code = 0;
+	struct mlme_ext_priv	*pmlmeext = &rtlpriv->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	uint8_t *pframe = precv_frame->rx_data;
+	struct sta_priv *pstapriv = &rtlpriv->stapriv;
+	//check RA matches or not
+	if (!_rtw_memcmp(rtlpriv->mac80211.mac_addr, GetAddr1Ptr(pframe), ETH_ALEN))//for if1, sta/ap mode
+		return _SUCCESS;
+
+/*
+	//check A1 matches or not
+	if (!_rtw_memcmp(myid(&(rtlpriv->eeprompriv)), get_da(pframe), ETH_ALEN))
+		return _SUCCESS;
+*/
+	DBG_871X("%s\n", __FUNCTION__);
+
+	if((pmlmeinfo->state&0x03) != WIFI_FW_AP_STATE)
+		if (!(pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS))
+			return _SUCCESS;
+
+	addr = GetAddr2Ptr(pframe);
+	psta = rtw_get_stainfo(pstapriv, addr);
+
+	if(psta==NULL)
+		return _SUCCESS;
+
+	frame_body = (unsigned char *)(pframe + sizeof(struct rtw_ieee80211_hdr_3addr));
+
+	category = frame_body[0];
+	if (category == RTW_WLAN_CATEGORY_BACK)// representing Block Ack
+	{
+		if (!pmlmeinfo->HT_enable)
+		{
+			return _SUCCESS;
+		}
+
+		action = frame_body[1];
+		DBG_871X("%s, action=%d\n", __FUNCTION__, action);
+		switch (action)
+		{
+			case RTW_WLAN_ACTION_ADDBA_REQ: //ADDBA request
+
+				memcpy(&(pmlmeinfo->ADDBA_req), &(frame_body[2]), sizeof(struct ADDBA_request));
+				//process_addba_req(rtlpriv, (uint8_t *)&(pmlmeinfo->ADDBA_req), GetAddr3Ptr(pframe));
+				process_addba_req(rtlpriv, (uint8_t *)&(pmlmeinfo->ADDBA_req), addr);
+
+				if(pmlmeinfo->bAcceptAddbaReq == true)
+				{
+					issue_action_BA(rtlpriv, addr, RTW_WLAN_ACTION_ADDBA_RESP, 0);
+				}
+				else
+				{
+					issue_action_BA(rtlpriv, addr, RTW_WLAN_ACTION_ADDBA_RESP, 37);//reject ADDBA Req
+				}
+
+				break;
+
+			case RTW_WLAN_ACTION_ADDBA_RESP: //ADDBA response
+
+				//status = frame_body[3] | (frame_body[4] << 8); //endian issue
+				status = RTW_GET_LE16(&frame_body[3]);
+				tid = ((frame_body[5] >> 2) & 0x7);
+
+				if (status == 0)
+				{	//successful
+					DBG_871X("agg_enable for TID=%d\n", tid);
+					psta->htpriv.agg_enable_bitmap |= 1 << tid;
+					psta->htpriv.candidate_tid_bitmap &= ~BIT(tid);
+				}
+				else
+				{
+					psta->htpriv.agg_enable_bitmap &= ~BIT(tid);
+				}
+
+				//DBG_871X("marc: ADDBA RSP: %x\n", pmlmeinfo->agg_enable_bitmap);
+				break;
+
+			case RTW_WLAN_ACTION_DELBA: //DELBA
+				if ((frame_body[3] & BIT(3)) == 0)
+				{
+					psta->htpriv.agg_enable_bitmap &= ~(1 << ((frame_body[3] >> 4) & 0xf));
+					psta->htpriv.candidate_tid_bitmap &= ~(1 << ((frame_body[3] >> 4) & 0xf));
+
+					//reason_code = frame_body[4] | (frame_body[5] << 8);
+					reason_code = RTW_GET_LE16(&frame_body[4]);
+				}
+				else if((frame_body[3] & BIT(3)) == BIT(3))
+				{
+					tid = (frame_body[3] >> 4) & 0x0F;
+
+					preorder_ctrl =  &psta->recvreorder_ctrl[tid];
+					preorder_ctrl->enable = false;
+					preorder_ctrl->indicate_seq = 0xffff;
+				}
+
+				DBG_871X("%s(): DELBA: %x(%x)\n", __FUNCTION__,pmlmeinfo->agg_enable_bitmap, reason_code);
+				//todo: how to notify the host while receiving DELETE BA
+				break;
+
+			default:
+				break;
+		}
+	}
+	return _SUCCESS;
+}
+
+int32_t rtw_action_public_decache(struct recv_frame *recv_frame, int32_t token)
+{
+	struct rtl_priv *rtlpriv = recv_frame->rtlpriv;
+	struct mlme_ext_priv *mlmeext = &(rtlpriv->mlmeextpriv);
+	uint8_t *frame = recv_frame->rx_data;
+	u16 seq_ctrl = ( (recv_frame->attrib.seq_num&0xffff) << 4) |
+		(recv_frame->attrib.frag_num & 0xf);
+
+	if (GetRetry(frame)) {
+		if (token >= 0) {
+			if ((seq_ctrl == mlmeext->action_public_rxseq)
+				&& (token == mlmeext->action_public_dialog_token))
+			{
+				DBG_871X(FUNC_ADPT_FMT" seq_ctrl=0x%x, rxseq=0x%x, token:%d\n",
+					FUNC_ADPT_ARG(rtlpriv), seq_ctrl, mlmeext->action_public_rxseq, token);
+				return _FAIL;
+			}
+		} else {
+			if (seq_ctrl == mlmeext->action_public_rxseq) {
+				DBG_871X(FUNC_ADPT_FMT" seq_ctrl=0x%x, rxseq=0x%x\n",
+					FUNC_ADPT_ARG(rtlpriv), seq_ctrl, mlmeext->action_public_rxseq);
+				return _FAIL;
+			}
+		}
+	}
+
+	mlmeext->action_public_rxseq = seq_ctrl;
+
+	if (token >= 0)
+		mlmeext->action_public_dialog_token = token;
+
+	return _SUCCESS;
+}
+
+unsigned int on_action_public_p2p(struct recv_frame *precv_frame)
+{
+	struct rtl_priv *rtlpriv = precv_frame->rtlpriv;
+	uint8_t *pframe = precv_frame->rx_data;
+	uint len = precv_frame->len;
+	uint8_t *frame_body;
+	uint8_t dialogToken=0;
+
+	frame_body = (unsigned char *)(pframe + sizeof(struct rtw_ieee80211_hdr_3addr));
+
+	dialogToken = frame_body[7];
+
+	if (rtw_action_public_decache(precv_frame, dialogToken) == _FAIL)
+		return _FAIL;
+
+
+	return _SUCCESS;
+}
+
+unsigned int on_action_public_vendor(struct recv_frame *precv_frame)
+{
+	unsigned int ret = _FAIL;
+	uint8_t *pframe = precv_frame->rx_data;
+	uint frame_len = precv_frame->len;
+	uint8_t *frame_body = pframe + sizeof(struct rtw_ieee80211_hdr_3addr);
+
+	if (_rtw_memcmp(frame_body + 2, P2P_OUI, 4) == true) {
+		ret = on_action_public_p2p(precv_frame);
+	}
+
+	return ret;
+}
+
+unsigned int on_action_public_default(struct recv_frame *precv_frame, uint8_t action)
+{
+	unsigned int ret = _FAIL;
+	uint8_t *pframe = precv_frame->rx_data;
+	uint frame_len = precv_frame->len;
+	uint8_t *frame_body = pframe + sizeof(struct rtw_ieee80211_hdr_3addr);
+	uint8_t token;
+	struct rtl_priv *rtlpriv = precv_frame->rtlpriv;
+	int cnt = 0;
+	char msg[64];
+
+	token = frame_body[2];
+
+	if (rtw_action_public_decache(precv_frame, token) == _FAIL)
+		goto exit;
+
+	ret = _SUCCESS;
+
+exit:
+	return ret;
+}
+
+unsigned int on_action_public(struct rtl_priv *rtlpriv, struct recv_frame *precv_frame)
+{
+	unsigned int ret = _FAIL;
+	uint8_t *pframe = precv_frame->rx_data;
+	uint frame_len = precv_frame->len;
+	uint8_t *frame_body = pframe + sizeof(struct rtw_ieee80211_hdr_3addr);
+	uint8_t category, action;
+
+	/* check RA matches or not */
+	if (!_rtw_memcmp(rtlpriv->mac80211.mac_addr, GetAddr1Ptr(pframe), ETH_ALEN))
+		goto exit;
+
+	category = frame_body[0];
+	if(category != RTW_WLAN_CATEGORY_PUBLIC)
+		goto exit;
+
+	action = frame_body[1];
+	switch (action) {
+	case ACT_PUBLIC_VENDOR:
+		ret = on_action_public_vendor(precv_frame);
+		break;
+	default:
+		ret = on_action_public_default(precv_frame, action);
+		break;
+	}
+
+exit:
+	return ret;
+}
+
+unsigned int OnAction_ht(struct rtl_priv *rtlpriv, struct recv_frame *precv_frame)
+{
+	return _SUCCESS;
+}
+
+unsigned int OnAction_wmm(struct rtl_priv *rtlpriv, struct recv_frame *precv_frame)
+{
+	return _SUCCESS;
+}
+
+unsigned int OnAction_p2p(struct rtl_priv *rtlpriv, struct recv_frame *precv_frame)
+{
+
+	return _SUCCESS;
+
+}
+
+unsigned int OnAction(struct rtl_priv *rtlpriv, struct recv_frame *precv_frame)
+{
+	int i;
+	unsigned char	category;
+	struct action_handler *ptable;
+	unsigned char	*frame_body;
+	uint8_t *pframe = precv_frame->rx_data;
+
+	frame_body = (unsigned char *)(pframe + sizeof(struct rtw_ieee80211_hdr_3addr));
+
+	category = frame_body[0];
+
+	for(i = 0; i < sizeof(OnAction_tbl)/sizeof(struct action_handler); i++)
+	{
+		ptable = &OnAction_tbl[i];
+
+		if(category == ptable->num)
+			ptable->func(rtlpriv, precv_frame);
+
+	}
+
+	return _SUCCESS;
+
+}
+
+unsigned int DoReserved(struct rtl_priv *rtlpriv, struct recv_frame *precv_frame)
+{
+
+	//DBG_871X("rcvd mgt frame(%x, %x)\n", (GetFrameSubType(pframe) >> 4), *(unsigned int *)GetAddr1Ptr(pframe));
+	return _SUCCESS;
+}
+
+struct xmit_frame *_alloc_mgtxmitframe(struct xmit_priv *pxmitpriv, bool once)
+{
+	struct xmit_frame *pmgntframe;
+	struct xmit_buf *pxmitbuf;
+
+	if (once)
+		pmgntframe = rtw_alloc_xmitframe_once(pxmitpriv);
+	else
+		pmgntframe = rtw_alloc_xmitframe_ext(pxmitpriv);
+
+	if (pmgntframe == NULL) {
+		DBG_871X(FUNC_ADPT_FMT" alloc xmitframe fail, once:%d\n", FUNC_ADPT_ARG(pxmitpriv->rtlpriv), once);
+		goto exit;
+	}
+
+	if ((pxmitbuf = rtw_alloc_xmitbuf_ext(pxmitpriv)) == NULL) {
+		DBG_871X(FUNC_ADPT_FMT" alloc xmitbuf fail\n", FUNC_ADPT_ARG(pxmitpriv->rtlpriv));
+		rtw_free_xmitframe(pxmitpriv, pmgntframe);
+		pmgntframe = NULL;
+		goto exit;
+	}
+
+	pmgntframe->frame_tag = MGNT_FRAMETAG;
+	pmgntframe->pxmitbuf = pxmitbuf;
+	pmgntframe->buf_addr = pxmitbuf->pbuf;
+	pxmitbuf->priv_data = pmgntframe;
+
+exit:
+	return pmgntframe;
+
+}
+
+inline struct xmit_frame *alloc_mgtxmitframe(struct xmit_priv *pxmitpriv)
+{
+	return _alloc_mgtxmitframe(pxmitpriv, false);
+}
+
+inline struct xmit_frame *alloc_mgtxmitframe_once(struct xmit_priv *pxmitpriv)
+{
+	return _alloc_mgtxmitframe(pxmitpriv, true);
+}
+
+
+/****************************************************************************
+
+Following are some TX fuctions for WiFi MLME
+
+*****************************************************************************/
+
+void update_mgnt_tx_rate(struct rtl_priv *rtlpriv, uint8_t rate)
+{
+	struct mlme_ext_priv	*pmlmeext = &(rtlpriv->mlmeextpriv);
+
+	pmlmeext->tx_rate = rate;
+	//DBG_871X("%s(): rate = %x\n",__FUNCTION__, rate);
+}
+
+void update_mgntframe_attrib(struct rtl_priv *rtlpriv, struct tx_pkt_attrib *pattrib)
+{
+	uint8_t	wireless_mode;
+	struct mlme_ext_priv	*pmlmeext = &(rtlpriv->mlmeextpriv);
+
+	//memset((uint8_t *)(pattrib), 0, sizeof(struct pkt_attrib));
+
+	pattrib->hdrlen = 24;
+	pattrib->nr_frags = 1;
+	pattrib->tx_priority = 7;
+	pattrib->mac_id = 0;
+	pattrib->tx_qsel = 0x12;
+
+	pattrib->pktlen = 0;
+
+	if (pmlmeext->tx_rate == IEEE80211_CCK_RATE_1MB)
+		wireless_mode = WIRELESS_11B;
+	else
+		wireless_mode = WIRELESS_11G;
+	pattrib->raid =  rtw_get_mgntframe_raid(rtlpriv, wireless_mode);
+
+	pattrib->encrypt = NO_ENCRYPTION;
+	pattrib->bswenc = false;
+
+	pattrib->qos_en = false;
+	pattrib->ht_en = false;
+	pattrib->bwmode = CHANNEL_WIDTH_20;
+	pattrib->ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
+	pattrib->sgi = false;
+
+	pattrib->seqnum = pmlmeext->mgnt_seq;
+
+	pattrib->retry_ctrl = true;
+
+	pattrib->mbssid = 0;
+
+}
+
+void update_mgntframe_attrib_addr(struct rtl_priv *rtlpriv, struct xmit_frame *pmgntframe)
+{
+	uint8_t	*pframe;
+	struct tx_pkt_attrib	*pattrib = &pmgntframe->tx_attrib;
+
+	pframe = (uint8_t *)(pmgntframe->buf_addr) + TXDESC_OFFSET;
+
+	memcpy(pattrib->ra, GetAddr1Ptr(pframe), ETH_ALEN);
+	memcpy(pattrib->ta, GetAddr2Ptr(pframe), ETH_ALEN);
+}
+
+void dump_mgntframe(struct rtl_priv *rtlpriv, struct xmit_frame *pmgntframe)
+{
+	if(rtlpriv->bSurpriseRemoved == true ||
+		rtlpriv->bDriverStopped == true)
+		return;
+
+	rtw_hal_mgnt_xmit(rtlpriv, pmgntframe);
+}
+
+int32_t dump_mgntframe_and_wait(struct rtl_priv *rtlpriv, struct xmit_frame *pmgntframe, int timeout_ms)
+{
+	int32_t ret = _FAIL;
+	unsigned long flags;
+	struct xmit_priv *pxmitpriv = &rtlpriv->xmitpriv;
+	struct xmit_buf *pxmitbuf = pmgntframe->pxmitbuf;
+	struct submit_ctx sctx;
+
+	if(rtlpriv->bSurpriseRemoved == true ||
+		rtlpriv->bDriverStopped == true)
+		return ret;
+
+	rtw_sctx_init(&sctx, timeout_ms);
+	pxmitbuf->sctx = &sctx;
+
+	ret = rtw_hal_mgnt_xmit(rtlpriv, pmgntframe);
+
+	if (ret == _SUCCESS)
+		ret = rtw_sctx_wait(&sctx);
+
+	spin_lock_irqsave(&pxmitpriv->lock_sctx, flags);
+	pxmitbuf->sctx = NULL;
+	spin_unlock_irqrestore(&pxmitpriv->lock_sctx, flags);
+
+	 return ret;
+}
+
+int32_t dump_mgntframe_and_wait_ack(struct rtl_priv *rtlpriv, struct xmit_frame *pmgntframe)
+{
+	dump_mgntframe(rtlpriv, pmgntframe);
+	msleep(50);
+	return _SUCCESS;
+}
+
+int update_hidden_ssid(uint8_t *ies, uint32_t	 ies_len, uint8_t hidden_ssid_mode)
+{
+	uint8_t *ssid_ie;
+	int ssid_len_ori;
+	int len_diff = 0;
+
+	ssid_ie = rtw_get_ie(ies,  WLAN_EID_SSID, &ssid_len_ori, ies_len);
+
+	//DBG_871X("%s hidden_ssid_mode:%u, ssid_ie:%p, ssid_len_ori:%d\n", __FUNCTION__, hidden_ssid_mode, ssid_ie, ssid_len_ori);
+
+	if(ssid_ie && ssid_len_ori>0)
+	{
+		switch(hidden_ssid_mode)
+		{
+			case 1:
+			{
+				uint8_t *next_ie = ssid_ie + 2 + ssid_len_ori;
+				uint32_t	 remain_len = 0;
+
+				remain_len = ies_len -(next_ie-ies);
+
+				ssid_ie[1] = 0;
+				memcpy(ssid_ie+2, next_ie, remain_len);
+				len_diff -= ssid_len_ori;
+
+				break;
+			}
+			case 2:
+				memset(&ssid_ie[2], 0, ssid_len_ori);
+				break;
+			default:
+				break;
+		}
+	}
+
+	return len_diff;
+}
+
+void issue_beacon(struct rtl_priv *rtlpriv, int timeout_ms)
+{
+	struct xmit_frame	*pmgntframe;
+	struct tx_pkt_attrib	*pattrib;
+	unsigned char	*pframe;
+	struct rtw_ieee80211_hdr *pwlanhdr;
+	unsigned short *fctrl;
+	unsigned int	rate_len;
+	struct xmit_priv	*pxmitpriv = &(rtlpriv->xmitpriv);
+#if defined (CONFIG_AP_MODE)
+	struct mlme_priv *pmlmepriv = &(rtlpriv->mlmepriv);
+#endif //#if defined (CONFIG_AP_MODE)
+	struct mlme_ext_priv	*pmlmeext = &(rtlpriv->mlmeextpriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	WLAN_BSSID_EX 		*cur_network = &(pmlmeinfo->network);
+	uint8_t	bc_addr[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
+
+
+	//DBG_871X("%s\n", __FUNCTION__);
+
+	if ((pmgntframe = alloc_mgtxmitframe(pxmitpriv)) == NULL)
+	{
+		DBG_871X("%s, alloc mgnt frame fail\n", __FUNCTION__);
+		return;
+	}
+#if defined (CONFIG_AP_MODE)
+	spin_lock_bh(&pmlmepriv->bcn_update_lock);
+#endif //#if defined (CONFIG_AP_MODE)
+
+	//update attribute
+	pattrib = &pmgntframe->tx_attrib;
+	update_mgntframe_attrib(rtlpriv, pattrib);
+	pattrib->tx_qsel = 0x10;
+
+	memset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);
+
+	pframe = (uint8_t *)(pmgntframe->buf_addr) + TXDESC_OFFSET;
+	pwlanhdr = (struct rtw_ieee80211_hdr *)pframe;
+
+
+	fctrl = &(pwlanhdr->frame_ctl);
+	*(fctrl) = 0;
+
+	memcpy(pwlanhdr->addr1, bc_addr, ETH_ALEN);
+	memcpy(pwlanhdr->addr2, rtlpriv->mac80211.mac_addr, ETH_ALEN);
+	memcpy(pwlanhdr->addr3, get_my_bssid(cur_network), ETH_ALEN);
+
+	SetSeqNum(pwlanhdr, 0/*pmlmeext->mgnt_seq*/);
+	//pmlmeext->mgnt_seq++;
+	SetFrameSubType(pframe, WIFI_BEACON);
+
+	pframe += sizeof(struct rtw_ieee80211_hdr_3addr);
+	pattrib->pktlen = sizeof (struct rtw_ieee80211_hdr_3addr);
+
+	if( (pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE)
+	{
+		//DBG_871X("ie len=%d\n", cur_network->IELength);
+		{
+			int len_diff;
+			memcpy(pframe, cur_network->IEs, cur_network->IELength);
+			len_diff = update_hidden_ssid(
+				pframe+_BEACON_IE_OFFSET_
+				, cur_network->IELength-_BEACON_IE_OFFSET_
+				, pmlmeinfo->hidden_ssid_mode
+			);
+			pframe += (cur_network->IELength+len_diff);
+			pattrib->pktlen += (cur_network->IELength+len_diff);
+		}
+
+		{
+			uint8_t *wps_ie;
+			uint wps_ielen;
+			uint8_t sr = 0;
+			wps_ie = rtw_get_wps_ie(pmgntframe->buf_addr+TXDESC_OFFSET+sizeof (struct rtw_ieee80211_hdr_3addr)+_BEACON_IE_OFFSET_,
+				pattrib->pktlen-sizeof (struct rtw_ieee80211_hdr_3addr)-_BEACON_IE_OFFSET_, NULL, &wps_ielen);
+			if (wps_ie && wps_ielen>0) {
+				rtw_get_wps_attr_content(wps_ie,  wps_ielen, WPS_ATTR_SELECTED_REGISTRAR, (uint8_t *)(&sr), NULL);
+			}
+			if (sr != 0)
+				set_fwstate(pmlmepriv, WIFI_UNDER_WPS);
+			else
+				_clr_fwstate_(pmlmepriv, WIFI_UNDER_WPS);
+		}
+
+
+		goto _issue_bcn;
+
+	}
+
+	//below for ad-hoc mode
+
+	//timestamp will be inserted by hardware
+	pframe += 8;
+	pattrib->pktlen += 8;
+
+	// beacon interval: 2 bytes
+
+	memcpy(pframe, (unsigned char *)(rtw_get_beacon_interval_from_ie(cur_network->IEs)), 2);
+
+	pframe += 2;
+	pattrib->pktlen += 2;
+
+	// capability info: 2 bytes
+
+	memcpy(pframe, (unsigned char *)(rtw_get_capability_from_ie(cur_network->IEs)), 2);
+
+	pframe += 2;
+	pattrib->pktlen += 2;
+
+	// SSID
+	pframe = rtw_set_ie(pframe, _SSID_IE_, cur_network->Ssid.SsidLength, cur_network->Ssid.Ssid, &pattrib->pktlen);
+
+	// supported rates...
+	rate_len = rtw_get_rateset_len(cur_network->SupportedRates);
+	pframe = rtw_set_ie(pframe, _SUPPORTEDRATES_IE_, ((rate_len > 8)? 8: rate_len), cur_network->SupportedRates, &pattrib->pktlen);
+
+	// DS parameter set
+	pframe = rtw_set_ie(pframe, _DSSET_IE_, 1, (unsigned char *)&(cur_network->Configuration.DSConfig), &pattrib->pktlen);
+
+	//if( (pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE)
+	{
+		uint8_t erpinfo=0;
+		uint32_t	 ATIMWindow;
+		// IBSS Parameter Set...
+		//ATIMWindow = cur->Configuration.ATIMWindow;
+		ATIMWindow = 0;
+		pframe = rtw_set_ie(pframe, _IBSS_PARA_IE_, 2, (unsigned char *)(&ATIMWindow), &pattrib->pktlen);
+
+		//ERP IE
+		pframe = rtw_set_ie(pframe, _ERPINFO_IE_, 1, &erpinfo, &pattrib->pktlen);
+	}
+
+
+	// EXTERNDED SUPPORTED RATE
+	if (rate_len > 8)
+	{
+		pframe = rtw_set_ie(pframe, _EXT_SUPPORTEDRATES_IE_, (rate_len - 8), (cur_network->SupportedRates + 8), &pattrib->pktlen);
+	}
+
+
+	//todo:HT for adhoc
+
+_issue_bcn:
+
+#if defined (CONFIG_AP_MODE)
+	pmlmepriv->update_bcn = false;
+
+	spin_unlock_bh(&pmlmepriv->bcn_update_lock);
+#endif //#if defined (CONFIG_AP_MODE)
+
+	if ((pattrib->pktlen + TXDESC_SIZE) > 512)
+	{
+		DBG_871X("beacon frame too large\n");
+		return;
+	}
+
+	pattrib->last_txcmdsz = pattrib->pktlen;
+
+	//DBG_871X("issue bcn_sz=%d\n", pattrib->last_txcmdsz);
+	if(timeout_ms > 0)
+		dump_mgntframe_and_wait(rtlpriv, pmgntframe, timeout_ms);
+	else
+		dump_mgntframe(rtlpriv, pmgntframe);
+
+}
+
+void issue_probersp(struct rtl_priv *rtlpriv, unsigned char *da, uint8_t is_valid_p2p_probereq)
+{
+	struct xmit_frame			*pmgntframe;
+	struct tx_pkt_attrib			*pattrib;
+	unsigned char					*pframe;
+	struct rtw_ieee80211_hdr	*pwlanhdr;
+	unsigned short				*fctrl;
+	unsigned char					*mac, *bssid;
+	struct xmit_priv	*pxmitpriv = &(rtlpriv->xmitpriv);
+#if defined (CONFIG_AP_MODE)
+	uint8_t *pwps_ie;
+	uint wps_ielen;
+	struct mlme_priv *pmlmepriv = &rtlpriv->mlmepriv;
+#endif //#if defined (CONFIG_AP_MODE)
+	struct mlme_ext_priv	*pmlmeext = &(rtlpriv->mlmeextpriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	WLAN_BSSID_EX 		*cur_network = &(pmlmeinfo->network);
+	unsigned int	rate_len;
+
+	//DBG_871X("%s\n", __FUNCTION__);
+
+	if(da == NULL)
+		return;
+
+	if ((pmgntframe = alloc_mgtxmitframe(pxmitpriv)) == NULL)
+	{
+		DBG_871X("%s, alloc mgnt frame fail\n", __FUNCTION__);
+		return;
+	}
+
+
+	//update attribute
+	pattrib = &pmgntframe->tx_attrib;
+	update_mgntframe_attrib(rtlpriv, pattrib);
+
+	memset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);
+
+	pframe = (uint8_t *)(pmgntframe->buf_addr) + TXDESC_OFFSET;
+	pwlanhdr = (struct rtw_ieee80211_hdr *)pframe;
+
+	mac = rtlpriv->mac80211.mac_addr;
+	bssid = cur_network->MacAddress;
+
+	fctrl = &(pwlanhdr->frame_ctl);
+	*(fctrl) = 0;
+	memcpy(pwlanhdr->addr1, da, ETH_ALEN);
+	memcpy(pwlanhdr->addr2, mac, ETH_ALEN);
+	memcpy(pwlanhdr->addr3, bssid, ETH_ALEN);
+
+	SetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);
+	pmlmeext->mgnt_seq++;
+	SetFrameSubType(fctrl, WIFI_PROBERSP);
+
+	pattrib->hdrlen = sizeof(struct rtw_ieee80211_hdr_3addr);
+	pattrib->pktlen = pattrib->hdrlen;
+	pframe += pattrib->hdrlen;
+
+
+	if(cur_network->IELength>MAX_IE_SZ)
+		return;
+
+#if defined (CONFIG_AP_MODE)
+	if( (pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE)
+	{
+		pwps_ie = rtw_get_wps_ie(cur_network->IEs+_FIXED_IE_LENGTH_, cur_network->IELength-_FIXED_IE_LENGTH_, NULL, &wps_ielen);
+
+		//inerset & update wps_probe_resp_ie
+		if((pmlmepriv->wps_probe_resp_ie!=NULL) && pwps_ie && (wps_ielen>0))
+		{
+			uint wps_offset, remainder_ielen;
+			uint8_t *premainder_ie;
+
+			wps_offset = (uint)(pwps_ie - cur_network->IEs);
+
+			premainder_ie = pwps_ie + wps_ielen;
+
+			remainder_ielen = cur_network->IELength - wps_offset - wps_ielen;
+
+			memcpy(pframe, cur_network->IEs, wps_offset);
+			pframe += wps_offset;
+			pattrib->pktlen += wps_offset;
+
+			wps_ielen = (uint)pmlmepriv->wps_probe_resp_ie[1];//to get ie data len
+			if((wps_offset+wps_ielen+2)<=MAX_IE_SZ)
+			{
+				memcpy(pframe, pmlmepriv->wps_probe_resp_ie, wps_ielen+2);
+				pframe += wps_ielen+2;
+				pattrib->pktlen += wps_ielen+2;
+			}
+
+			if((wps_offset+wps_ielen+2+remainder_ielen)<=MAX_IE_SZ)
+			{
+				memcpy(pframe, premainder_ie, remainder_ielen);
+				pframe += remainder_ielen;
+				pattrib->pktlen += remainder_ielen;
+			}
+		}
+		else
+		{
+			memcpy(pframe, cur_network->IEs, cur_network->IELength);
+			pframe += cur_network->IELength;
+			pattrib->pktlen += cur_network->IELength;
+		}
+
+		/* retrieve SSID IE from cur_network->Ssid */
+		{
+			uint8_t *ssid_ie;
+			int ssid_ielen;
+			int ssid_ielen_diff;
+			uint8_t buf[MAX_IE_SZ];
+			uint8_t *ies = pmgntframe->buf_addr+TXDESC_OFFSET+sizeof(struct rtw_ieee80211_hdr_3addr);
+
+			ssid_ie = rtw_get_ie(ies+_FIXED_IE_LENGTH_, _SSID_IE_, &ssid_ielen,
+				(pframe-ies)-_FIXED_IE_LENGTH_);
+
+			ssid_ielen_diff = cur_network->Ssid.SsidLength - ssid_ielen;
+
+			if (ssid_ie &&  cur_network->Ssid.SsidLength) {
+				uint remainder_ielen;
+				uint8_t *remainder_ie;
+				remainder_ie = ssid_ie+2;
+				remainder_ielen = (pframe-remainder_ie);
+
+				DBG_871X_LEVEL(_drv_warning_, FUNC_ADPT_FMT" remainder_ielen > MAX_IE_SZ\n", FUNC_ADPT_ARG(rtlpriv));
+				if (remainder_ielen > MAX_IE_SZ) {
+					remainder_ielen = MAX_IE_SZ;
+				}
+
+				memcpy(buf, remainder_ie, remainder_ielen);
+				memcpy(remainder_ie+ssid_ielen_diff, buf, remainder_ielen);
+				*(ssid_ie+1) = cur_network->Ssid.SsidLength;
+				memcpy(ssid_ie+2, cur_network->Ssid.Ssid, cur_network->Ssid.SsidLength);
+
+				pframe += ssid_ielen_diff;
+				pattrib->pktlen += ssid_ielen_diff;
+			}
+		}
+	}
+	else
+#endif
+	{
+
+		//timestamp will be inserted by hardware
+		pframe += 8;
+		pattrib->pktlen += 8;
+
+		// beacon interval: 2 bytes
+
+		memcpy(pframe, (unsigned char *)(rtw_get_beacon_interval_from_ie(cur_network->IEs)), 2);
+
+		pframe += 2;
+		pattrib->pktlen += 2;
+
+		// capability info: 2 bytes
+
+		memcpy(pframe, (unsigned char *)(rtw_get_capability_from_ie(cur_network->IEs)), 2);
+
+		pframe += 2;
+		pattrib->pktlen += 2;
+
+		//below for ad-hoc mode
+
+		// SSID
+		pframe = rtw_set_ie(pframe, _SSID_IE_, cur_network->Ssid.SsidLength, cur_network->Ssid.Ssid, &pattrib->pktlen);
+
+		// supported rates...
+		rate_len = rtw_get_rateset_len(cur_network->SupportedRates);
+		pframe = rtw_set_ie(pframe, _SUPPORTEDRATES_IE_, ((rate_len > 8)? 8: rate_len), cur_network->SupportedRates, &pattrib->pktlen);
+
+		// DS parameter set
+		pframe =rtw_set_ie(pframe, _DSSET_IE_, 1, (unsigned char *)&(cur_network->Configuration.DSConfig), &pattrib->pktlen);
+
+		if( (pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE)
+		{
+			uint8_t erpinfo=0;
+			uint32_t	 ATIMWindow;
+			// IBSS Parameter Set...
+			//ATIMWindow = cur->Configuration.ATIMWindow;
+			ATIMWindow = 0;
+			pframe = rtw_set_ie(pframe, _IBSS_PARA_IE_, 2, (unsigned char *)(&ATIMWindow), &pattrib->pktlen);
+
+			//ERP IE
+			pframe = rtw_set_ie(pframe, _ERPINFO_IE_, 1, &erpinfo, &pattrib->pktlen);
+		}
+
+
+		// EXTERNDED SUPPORTED RATE
+		if (rate_len > 8)
+		{
+			pframe = rtw_set_ie(pframe, _EXT_SUPPORTEDRATES_IE_, (rate_len - 8), (cur_network->SupportedRates + 8), &pattrib->pktlen);
+		}
+
+
+		//todo:HT for adhoc
+
+	}
+
+	pattrib->last_txcmdsz = pattrib->pktlen;
+
+
+	dump_mgntframe(rtlpriv, pmgntframe);
+
+	return;
+
+}
+
+int _issue_probereq(struct rtl_priv *rtlpriv, NDIS_802_11_SSID *pssid, uint8_t *da, int wait_ack)
+{
+	int ret = _FAIL;
+	struct xmit_frame		*pmgntframe;
+	struct tx_pkt_attrib		*pattrib;
+	unsigned char			*pframe;
+	struct rtw_ieee80211_hdr	*pwlanhdr;
+	unsigned short		*fctrl;
+	unsigned char			*mac;
+	unsigned char			bssrate[NumRates];
+	struct xmit_priv		*pxmitpriv = &(rtlpriv->xmitpriv);
+	struct mlme_priv *pmlmepriv = &(rtlpriv->mlmepriv);
+	struct mlme_ext_priv	*pmlmeext = &(rtlpriv->mlmeextpriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	int	bssrate_len = 0;
+	uint8_t	bc_addr[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
+
+	if ((pmgntframe = alloc_mgtxmitframe(pxmitpriv)) == NULL)
+	{
+		goto exit;
+	}
+
+	//update attribute
+	pattrib = &pmgntframe->tx_attrib;
+	update_mgntframe_attrib(rtlpriv, pattrib);
+
+
+	memset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);
+
+	pframe = (uint8_t *)(pmgntframe->buf_addr) + TXDESC_OFFSET;
+	pwlanhdr = (struct rtw_ieee80211_hdr *)pframe;
+
+	mac = rtlpriv->mac80211.mac_addr;
+
+	fctrl = &(pwlanhdr->frame_ctl);
+	*(fctrl) = 0;
+
+	if (da)
+	{
+		//	unicast probe request frame
+		memcpy(pwlanhdr->addr1, da, ETH_ALEN);
+		memcpy(pwlanhdr->addr3, da, ETH_ALEN);
+	}
+	else
+	{
+		//	broadcast probe request frame
+		memcpy(pwlanhdr->addr1, bc_addr, ETH_ALEN);
+		memcpy(pwlanhdr->addr3, bc_addr, ETH_ALEN);
+	}
+
+	memcpy(pwlanhdr->addr2, mac, ETH_ALEN);
+
+	SetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);
+	pmlmeext->mgnt_seq++;
+	SetFrameSubType(pframe, WIFI_PROBEREQ);
+
+	pframe += sizeof (struct rtw_ieee80211_hdr_3addr);
+	pattrib->pktlen = sizeof (struct rtw_ieee80211_hdr_3addr);
+
+	if(pssid)
+		pframe = rtw_set_ie(pframe, _SSID_IE_, pssid->SsidLength, pssid->Ssid, &(pattrib->pktlen));
+	else
+		pframe = rtw_set_ie(pframe, _SSID_IE_, 0, NULL, &(pattrib->pktlen));
+
+	get_rate_set(rtlpriv, bssrate, &bssrate_len);
+
+	if (bssrate_len > 8)
+	{
+		pframe = rtw_set_ie(pframe, _SUPPORTEDRATES_IE_ , 8, bssrate, &(pattrib->pktlen));
+		pframe = rtw_set_ie(pframe, _EXT_SUPPORTEDRATES_IE_ , (bssrate_len - 8), (bssrate + 8), &(pattrib->pktlen));
+	}
+	else
+	{
+		pframe = rtw_set_ie(pframe, _SUPPORTEDRATES_IE_ , bssrate_len , bssrate, &(pattrib->pktlen));
+	}
+
+	//add wps_ie for wps2.0
+	if(pmlmepriv->wps_probe_req_ie_len>0 && pmlmepriv->wps_probe_req_ie)
+	{
+		memcpy(pframe, pmlmepriv->wps_probe_req_ie, pmlmepriv->wps_probe_req_ie_len);
+		pframe += pmlmepriv->wps_probe_req_ie_len;
+		pattrib->pktlen += pmlmepriv->wps_probe_req_ie_len;
+		//pmlmepriv->wps_probe_req_ie_len = 0 ;//reset to zero
+	}
+
+	pattrib->last_txcmdsz = pattrib->pktlen;
+
+	if (wait_ack) {
+		ret = dump_mgntframe_and_wait_ack(rtlpriv, pmgntframe);
+	} else {
+		dump_mgntframe(rtlpriv, pmgntframe);
+		ret = _SUCCESS;
+	}
+
+exit:
+	return ret;
+}
+
+inline void issue_probereq(struct rtl_priv *rtlpriv, NDIS_802_11_SSID *pssid, uint8_t *da)
+{
+	_issue_probereq(rtlpriv, pssid, da, false);
+}
+
+int issue_probereq_ex(struct rtl_priv *rtlpriv, NDIS_802_11_SSID *pssid, uint8_t *da,
+	int try_cnt, int wait_ms)
+{
+	int ret;
+	int i = 0;
+	uint32_t	 start = jiffies;
+
+	do
+	{
+		ret = _issue_probereq(rtlpriv, pssid, da, wait_ms>0?true:false);
+
+		i++;
+
+		if (rtlpriv->bDriverStopped || rtlpriv->bSurpriseRemoved)
+			break;
+
+		if(i < try_cnt && wait_ms > 0 && ret==_FAIL)
+			msleep(wait_ms);
+
+	}while((i<try_cnt) && ((ret==_FAIL)||(wait_ms==0)));
+
+	if (ret != _FAIL) {
+		ret = _SUCCESS;
+		#ifndef DBG_XMIT_ACK
+		goto exit;
+		#endif
+	}
+
+exit:
+	return ret;
+}
+
+// if psta == NULL, indiate we are station(client) now...
+void issue_auth(struct rtl_priv *rtlpriv, struct sta_info *psta, unsigned short status)
+{
+	struct xmit_frame			*pmgntframe;
+	struct tx_pkt_attrib			*pattrib;
+	unsigned char					*pframe;
+	struct rtw_ieee80211_hdr	*pwlanhdr;
+	unsigned short				*fctrl;
+	unsigned int					val32;
+	unsigned short				val16;
+	int use_shared_key = 0;
+	struct xmit_priv			*pxmitpriv = &(rtlpriv->xmitpriv);
+	struct mlme_ext_priv	*pmlmeext = &(rtlpriv->mlmeextpriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	if ((pmgntframe = alloc_mgtxmitframe(pxmitpriv)) == NULL)
+	{
+		return;
+	}
+
+	//update attribute
+	pattrib = &pmgntframe->tx_attrib;
+	update_mgntframe_attrib(rtlpriv, pattrib);
+
+	memset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);
+
+	pframe = (uint8_t *)(pmgntframe->buf_addr) + TXDESC_OFFSET;
+	pwlanhdr = (struct rtw_ieee80211_hdr *)pframe;
+
+	fctrl = &(pwlanhdr->frame_ctl);
+	*(fctrl) = 0;
+
+	SetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);
+	pmlmeext->mgnt_seq++;
+	SetFrameSubType(pframe, WIFI_AUTH);
+
+	pframe += sizeof(struct rtw_ieee80211_hdr_3addr);
+	pattrib->pktlen = sizeof(struct rtw_ieee80211_hdr_3addr);
+
+
+	if(psta)// for AP mode
+	{
+		memcpy(pwlanhdr->addr1, psta->hwaddr, ETH_ALEN);
+		memcpy(pwlanhdr->addr2, rtlpriv->mac80211.mac_addr, ETH_ALEN);
+		memcpy(pwlanhdr->addr3, rtlpriv->mac80211.mac_addr, ETH_ALEN);
+
+
+		// setting auth algo number
+		val16 = (u16)psta->authalg;
+
+		if(status != _STATS_SUCCESSFUL_)
+			val16 = 0;
+
+		if (val16)	{
+			val16 = cpu_to_le16(val16);
+			use_shared_key = 1;
+		}
+
+		pframe = rtw_set_fixed_ie(pframe, _AUTH_ALGM_NUM_, (unsigned char *)&val16, &(pattrib->pktlen));
+
+		// setting auth seq number
+		val16 =(u16)psta->auth_seq;
+		val16 = cpu_to_le16(val16);
+		pframe = rtw_set_fixed_ie(pframe, _AUTH_SEQ_NUM_, (unsigned char *)&val16, &(pattrib->pktlen));
+
+		// setting status code...
+		val16 = status;
+		val16 = cpu_to_le16(val16);
+		pframe = rtw_set_fixed_ie(pframe, _STATUS_CODE_, (unsigned char *)&val16, &(pattrib->pktlen));
+
+		// added challenging text...
+		if ((psta->auth_seq == 2) && (psta->state & WIFI_FW_AUTH_STATE) && (use_shared_key==1))
+		{
+			pframe = rtw_set_ie(pframe, _CHLGETXT_IE_, 128, psta->chg_txt, &(pattrib->pktlen));
+		}
+	}
+	else
+	{
+		memcpy(pwlanhdr->addr1, get_my_bssid(&pmlmeinfo->network), ETH_ALEN);
+		memcpy(pwlanhdr->addr2, rtlpriv->mac80211.mac_addr, ETH_ALEN);
+		memcpy(pwlanhdr->addr3, get_my_bssid(&pmlmeinfo->network), ETH_ALEN);
+
+		// setting auth algo number
+		val16 = (pmlmeinfo->auth_algo == dot11AuthAlgrthm_Shared)? 1: 0;// 0:OPEN System, 1:Shared key
+		if (val16)	{
+			val16 = cpu_to_le16(val16);
+			use_shared_key = 1;
+		}
+		//DBG_871X("%s auth_algo= %s auth_seq=%d\n",__FUNCTION__,(pmlmeinfo->auth_algo==0)?"OPEN":"SHARED",pmlmeinfo->auth_seq);
+
+		//setting IV for auth seq #3
+		if ((pmlmeinfo->auth_seq == 3) && (pmlmeinfo->state & WIFI_FW_AUTH_STATE) && (use_shared_key==1))
+		{
+			//DBG_871X("==> iv(%d),key_index(%d)\n",pmlmeinfo->iv,pmlmeinfo->key_index);
+			val32 = ((pmlmeinfo->iv++) | (pmlmeinfo->key_index << 30));
+			val32 = cpu_to_le32(val32);
+			pframe = rtw_set_fixed_ie(pframe, 4, (unsigned char *)&val32, &(pattrib->pktlen));
+
+			pattrib->iv_len = 4;
+		}
+
+		pframe = rtw_set_fixed_ie(pframe, _AUTH_ALGM_NUM_, (unsigned char *)&val16, &(pattrib->pktlen));
+
+		// setting auth seq number
+		val16 = pmlmeinfo->auth_seq;
+		val16 = cpu_to_le16(val16);
+		pframe = rtw_set_fixed_ie(pframe, _AUTH_SEQ_NUM_, (unsigned char *)&val16, &(pattrib->pktlen));
+
+
+		// setting status code...
+		val16 = status;
+		val16 = cpu_to_le16(val16);
+		pframe = rtw_set_fixed_ie(pframe, _STATUS_CODE_, (unsigned char *)&val16, &(pattrib->pktlen));
+
+		// then checking to see if sending challenging text...
+		if ((pmlmeinfo->auth_seq == 3) && (pmlmeinfo->state & WIFI_FW_AUTH_STATE) && (use_shared_key==1))
+		{
+			pframe = rtw_set_ie(pframe, _CHLGETXT_IE_, 128, pmlmeinfo->chg_txt, &(pattrib->pktlen));
+
+			SetPrivacy(fctrl);
+
+			pattrib->hdrlen = sizeof(struct rtw_ieee80211_hdr_3addr);
+
+			pattrib->encrypt = WEP40_ENCRYPTION;
+
+			pattrib->icv_len = 4;
+
+			pattrib->pktlen += pattrib->icv_len;
+
+		}
+
+	}
+
+	pattrib->last_txcmdsz = pattrib->pktlen;
+
+	rtw_wep_encrypt(rtlpriv, (uint8_t *)pmgntframe);
+	DBG_871X("%s\n", __FUNCTION__);
+	dump_mgntframe(rtlpriv, pmgntframe);
+
+	return;
+}
+
+
+void issue_asocrsp(struct rtl_priv *rtlpriv, unsigned short status, struct sta_info *pstat, int pkt_type)
+{
+#ifdef CONFIG_AP_MODE
+	struct xmit_frame	*pmgntframe;
+	struct rtw_ieee80211_hdr	*pwlanhdr;
+	struct tx_pkt_attrib *pattrib;
+	unsigned char	*pbuf, *pframe;
+	unsigned short val;
+	unsigned short *fctrl;
+	struct xmit_priv *pxmitpriv = &(rtlpriv->xmitpriv);
+	struct mlme_priv *pmlmepriv = &(rtlpriv->mlmepriv);
+	struct mlme_ext_priv *pmlmeext = &rtlpriv->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	WLAN_BSSID_EX *pnetwork = &(pmlmeinfo->network);
+	uint8_t *ie = pnetwork->IEs;
+
+	DBG_871X("%s\n", __FUNCTION__);
+
+	if ((pmgntframe = alloc_mgtxmitframe(pxmitpriv)) == NULL)
+	{
+		return;
+	}
+
+	//update attribute
+	pattrib = &pmgntframe->tx_attrib;
+	update_mgntframe_attrib(rtlpriv, pattrib);
+
+
+	memset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);
+
+	pframe = (uint8_t *)(pmgntframe->buf_addr) + TXDESC_OFFSET;
+	pwlanhdr = (struct rtw_ieee80211_hdr *)pframe;
+
+	fctrl = &(pwlanhdr->frame_ctl);
+	*(fctrl) = 0;
+
+	memcpy((void *)GetAddr1Ptr(pwlanhdr), pstat->hwaddr, ETH_ALEN);
+	memcpy((void *)GetAddr2Ptr(pwlanhdr), rtlpriv->mac80211.mac_addr, ETH_ALEN);
+	memcpy((void *)GetAddr3Ptr(pwlanhdr), get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);
+
+
+	SetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);
+	pmlmeext->mgnt_seq++;
+	if ((pkt_type == WIFI_ASSOCRSP) || (pkt_type == WIFI_REASSOCRSP))
+		SetFrameSubType(pwlanhdr, pkt_type);
+	else
+		return;
+
+	pattrib->hdrlen = sizeof(struct rtw_ieee80211_hdr_3addr);
+	pattrib->pktlen += pattrib->hdrlen;
+	pframe += pattrib->hdrlen;
+
+	//capability
+	val = *(unsigned short *)rtw_get_capability_from_ie(ie);
+
+	pframe = rtw_set_fixed_ie(pframe, _CAPABILITY_ , (unsigned char *)&val, &(pattrib->pktlen));
+
+	status = cpu_to_le16(status);
+	pframe = rtw_set_fixed_ie(pframe , _STATUS_CODE_ , (unsigned char *)&status, &(pattrib->pktlen));
+
+	val = cpu_to_le16(pstat->aid | BIT(14) | BIT(15));
+	pframe = rtw_set_fixed_ie(pframe, _ASOC_ID_ , (unsigned char *)&val, &(pattrib->pktlen));
+
+	if (pstat->bssratelen <= 8)
+	{
+		pframe = rtw_set_ie(pframe, _SUPPORTEDRATES_IE_, pstat->bssratelen, pstat->bssrateset, &(pattrib->pktlen));
+	}
+	else
+	{
+		pframe = rtw_set_ie(pframe, _SUPPORTEDRATES_IE_, 8, pstat->bssrateset, &(pattrib->pktlen));
+		pframe = rtw_set_ie(pframe, _EXT_SUPPORTEDRATES_IE_, (pstat->bssratelen-8), pstat->bssrateset+8, &(pattrib->pktlen));
+	}
+
+	if ((pstat->flags & WLAN_STA_HT) && (pmlmepriv->htpriv.ht_option))
+	{
+		uint ie_len=0;
+
+		//FILL HT CAP INFO IE
+		//p = hostapd_eid_ht_capabilities_info(hapd, p);
+		pbuf = rtw_get_ie(ie + _BEACON_IE_OFFSET_, _HT_CAPABILITY_IE_, &ie_len, (pnetwork->IELength - _BEACON_IE_OFFSET_));
+		if(pbuf && ie_len>0)
+		{
+			memcpy(pframe, pbuf, ie_len+2);
+			pframe += (ie_len+2);
+			pattrib->pktlen +=(ie_len+2);
+		}
+
+		//FILL HT ADD INFO IE
+		//p = hostapd_eid_ht_operation(hapd, p);
+		pbuf = rtw_get_ie(ie + _BEACON_IE_OFFSET_, _HT_ADD_INFO_IE_, &ie_len, (pnetwork->IELength - _BEACON_IE_OFFSET_));
+		if(pbuf && ie_len>0)
+		{
+			memcpy(pframe, pbuf, ie_len+2);
+			pframe += (ie_len+2);
+			pattrib->pktlen +=(ie_len+2);
+		}
+
+	}
+
+	if ((pstat->flags & WLAN_STA_VHT) && (pmlmepriv->vhtpriv.vht_option))
+	{
+		uint32_t	 ie_len=0;
+
+		//FILL VHT CAP IE
+		pbuf = rtw_get_ie(ie + _BEACON_IE_OFFSET_, EID_VHTCapability, &ie_len, (pnetwork->IELength - _BEACON_IE_OFFSET_));
+		if(pbuf && ie_len>0)
+		{
+			memcpy(pframe, pbuf, ie_len+2);
+			pframe += (ie_len+2);
+			pattrib->pktlen +=(ie_len+2);
+		}
+
+		//FILL VHT OPERATION IE
+		pbuf = rtw_get_ie(ie + _BEACON_IE_OFFSET_, EID_VHTOperation, &ie_len, (pnetwork->IELength - _BEACON_IE_OFFSET_));
+		if(pbuf && ie_len>0)
+		{
+			memcpy(pframe, pbuf, ie_len+2);
+			pframe += (ie_len+2);
+			pattrib->pktlen +=(ie_len+2);
+		}
+	}
+	//FILL WMM IE
+	if ((pstat->flags & WLAN_STA_WME) && (pmlmepriv->qospriv.qos_option))
+	{
+		uint ie_len=0;
+		unsigned char WMM_PARA_IE[] = {0x00, 0x50, 0xf2, 0x02, 0x01, 0x01};
+
+		for (pbuf = ie + _BEACON_IE_OFFSET_; ;pbuf+= (ie_len + 2))
+		{
+			pbuf = rtw_get_ie(pbuf, _VENDOR_SPECIFIC_IE_, &ie_len, (pnetwork->IELength - _BEACON_IE_OFFSET_ - (ie_len + 2)));
+			if(pbuf && _rtw_memcmp(pbuf+2, WMM_PARA_IE, 6))
+			{
+				memcpy(pframe, pbuf, ie_len+2);
+				pframe += (ie_len+2);
+				pattrib->pktlen +=(ie_len+2);
+
+				break;
+			}
+
+			if ((pbuf == NULL) || (ie_len == 0))
+			{
+				break;
+			}
+		}
+
+	}
+
+
+	if (pmlmeinfo->assoc_AP_vendor == HT_IOT_PEER_REALTEK)
+	{
+		pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, 6 , REALTEK_96B_IE, &(pattrib->pktlen));
+	}
+
+	//add WPS IE ie for wps 2.0
+	if(pmlmepriv->wps_assoc_resp_ie && pmlmepriv->wps_assoc_resp_ie_len>0)
+	{
+		memcpy(pframe, pmlmepriv->wps_assoc_resp_ie, pmlmepriv->wps_assoc_resp_ie_len);
+
+		pframe += pmlmepriv->wps_assoc_resp_ie_len;
+		pattrib->pktlen += pmlmepriv->wps_assoc_resp_ie_len;
+	}
+
+	pattrib->last_txcmdsz = pattrib->pktlen;
+
+	dump_mgntframe(rtlpriv, pmgntframe);
+
+#endif
+}
+
+void issue_assocreq(struct rtl_priv *rtlpriv)
+{
+	int ret = _FAIL;
+	struct xmit_frame				*pmgntframe;
+	struct tx_pkt_attrib				*pattrib;
+	unsigned char					*pframe, *p;
+	struct rtw_ieee80211_hdr			*pwlanhdr;
+	unsigned short				*fctrl;
+	unsigned short				val16;
+	unsigned int					i, j, ie_len, index=0;
+	unsigned char					rf_type, bssrate[NumRates], sta_bssrate[NumRates];
+	PNDIS_802_11_VARIABLE_IEs	pIE;
+	struct registry_priv	*pregpriv = &rtlpriv->registrypriv;
+	struct xmit_priv		*pxmitpriv = &(rtlpriv->xmitpriv);
+	struct mlme_priv *pmlmepriv = &(rtlpriv->mlmepriv);
+	struct mlme_ext_priv	*pmlmeext = &(rtlpriv->mlmeextpriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	int	bssrate_len = 0, sta_bssrate_len = 0;
+	uint8_t	cbw40_enable = 0;
+
+#ifdef CONFIG_DFS
+	u16	cap;
+#endif //CONFIG_DFS
+
+	if ((pmgntframe = alloc_mgtxmitframe(pxmitpriv)) == NULL)
+		goto exit;
+
+	//update attribute
+	pattrib = &pmgntframe->tx_attrib;
+	update_mgntframe_attrib(rtlpriv, pattrib);
+
+
+	memset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);
+
+	pframe = (uint8_t *)(pmgntframe->buf_addr) + TXDESC_OFFSET;
+	pwlanhdr = (struct rtw_ieee80211_hdr *)pframe;
+
+	fctrl = &(pwlanhdr->frame_ctl);
+	*(fctrl) = 0;
+	memcpy(pwlanhdr->addr1, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);
+	memcpy(pwlanhdr->addr2, rtlpriv->mac80211.mac_addr, ETH_ALEN);
+	memcpy(pwlanhdr->addr3, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);
+
+	SetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);
+	pmlmeext->mgnt_seq++;
+	SetFrameSubType(pframe, WIFI_ASSOCREQ);
+
+	pframe += sizeof(struct rtw_ieee80211_hdr_3addr);
+	pattrib->pktlen = sizeof(struct rtw_ieee80211_hdr_3addr);
+
+	//caps
+
+#ifdef CONFIG_DFS
+	memcpy(&cap, rtw_get_capability_from_ie(pmlmeinfo->network.IEs), 2);
+	cap |= BIT(8);
+	memcpy(pframe, &cap, 2);
+#else
+	memcpy(pframe, rtw_get_capability_from_ie(pmlmeinfo->network.IEs), 2);
+#endif //CONFIG_DFS
+
+	pframe += 2;
+	pattrib->pktlen += 2;
+
+	//listen interval
+	//todo: listen interval for power saving
+	val16 = cpu_to_le16(3);
+	memcpy(pframe ,(unsigned char *)&val16, 2);
+	pframe += 2;
+	pattrib->pktlen += 2;
+
+	//SSID
+	pframe = rtw_set_ie(pframe, _SSID_IE_,  pmlmeinfo->network.Ssid.SsidLength, pmlmeinfo->network.Ssid.Ssid, &(pattrib->pktlen));
+
+	//supported rate & extended supported rate
+
+#if 1	// Check if the AP's supported rates are also supported by STA.
+	get_rate_set(rtlpriv, sta_bssrate, &sta_bssrate_len);
+	//DBG_871X("sta_bssrate_len=%d\n", sta_bssrate_len);
+
+	if(pmlmeext->cur_channel == 14)// for JAPAN, channel 14 can only uses B Mode(CCK)
+	{
+		sta_bssrate_len = 4;
+	}
+
+
+	//for (i = 0; i < sta_bssrate_len; i++) {
+	//	DBG_871X("sta_bssrate[%d]=%02X\n", i, sta_bssrate[i]);
+	//}
+
+	for (i = 0; i < NDIS_802_11_LENGTH_RATES_EX; i++) {
+		if (pmlmeinfo->network.SupportedRates[i] == 0) break;
+		DBG_871X("network.SupportedRates[%d]=%02X\n", i, pmlmeinfo->network.SupportedRates[i]);
+	}
+
+
+	for (i = 0; i < NDIS_802_11_LENGTH_RATES_EX; i++) {
+		if (pmlmeinfo->network.SupportedRates[i] == 0) break;
+
+
+		// Check if the AP's supported rates are also supported by STA.
+		for (j=0; j < sta_bssrate_len; j++) {
+			 // Avoid the proprietary data rate (22Mbps) of Handlink WSG-4000 AP
+			if ( (pmlmeinfo->network.SupportedRates[i]|IEEE80211_BASIC_RATE_MASK)
+					== (sta_bssrate[j]|IEEE80211_BASIC_RATE_MASK)) {
+				//DBG_871X("match i = %d, j=%d\n", i, j);
+				break;
+			} else {
+				//DBG_871X("not match: %02X != %02X\n", (pmlmeinfo->network.SupportedRates[i]|IEEE80211_BASIC_RATE_MASK), (sta_bssrate[j]|IEEE80211_BASIC_RATE_MASK));
+			}
+		}
+
+		if (j == sta_bssrate_len) {
+			// the rate is not supported by STA
+			DBG_871X("%s(): the rate[%d]=%02X is not supported by STA!\n",__FUNCTION__, i, pmlmeinfo->network.SupportedRates[i]);
+		} else {
+			// the rate is supported by STA
+			bssrate[index++] = pmlmeinfo->network.SupportedRates[i];
+		}
+	}
+
+	bssrate_len = index;
+	DBG_871X("bssrate_len = %d\n", bssrate_len);
+
+#else	// Check if the AP's supported rates are also supported by STA.
+	for (bssrate_len = 0; bssrate_len < NumRates; bssrate_len++) {
+		if (pmlmeinfo->network.SupportedRates[bssrate_len] == 0) break;
+
+		if (pmlmeinfo->network.SupportedRates[bssrate_len] == 0x2C) // Avoid the proprietary data rate (22Mbps) of Handlink WSG-4000 AP
+			break;
+
+		bssrate[bssrate_len] = pmlmeinfo->network.SupportedRates[bssrate_len];
+	}
+#endif	// Check if the AP's supported rates are also supported by STA.
+
+	if (bssrate_len == 0) {
+		rtw_free_xmitbuf(pxmitpriv, pmgntframe->pxmitbuf);
+		rtw_free_xmitframe(pxmitpriv, pmgntframe);
+		goto exit; //don't connect to AP if no joint supported rate
+	}
+
+
+	if (bssrate_len > 8)
+	{
+		pframe = rtw_set_ie(pframe, _SUPPORTEDRATES_IE_ , 8, bssrate, &(pattrib->pktlen));
+		pframe = rtw_set_ie(pframe, _EXT_SUPPORTEDRATES_IE_ , (bssrate_len - 8), (bssrate + 8), &(pattrib->pktlen));
+	}
+	else
+	{
+		pframe = rtw_set_ie(pframe, _SUPPORTEDRATES_IE_ , bssrate_len , bssrate, &(pattrib->pktlen));
+	}
+
+	//RSN
+	p = rtw_get_ie((pmlmeinfo->network.IEs + sizeof(NDIS_802_11_FIXED_IEs)), _RSN_IE_2_, &ie_len, (pmlmeinfo->network.IELength - sizeof(NDIS_802_11_FIXED_IEs)));
+	if (p != NULL)
+	{
+		pframe = rtw_set_ie(pframe, _RSN_IE_2_, ie_len, (p + 2), &(pattrib->pktlen));
+	}
+
+	//HT caps
+	if(rtlpriv->mlmepriv.htpriv.ht_option==true)
+	{
+		p = rtw_get_ie((pmlmeinfo->network.IEs + sizeof(NDIS_802_11_FIXED_IEs)), _HT_CAPABILITY_IE_, &ie_len, (pmlmeinfo->network.IELength - sizeof(NDIS_802_11_FIXED_IEs)));
+		if ((p != NULL) && (!(is_ap_in_tkip(rtlpriv))))
+		{
+			memcpy(&(pmlmeinfo->HT_caps), (p + 2), sizeof(struct HT_caps_element));
+
+			//to disable 40M Hz support while gd_bw_40MHz_en = 0
+			if (pmlmeext->cur_channel > 14) {
+				if ((0x21 & 0xf0) > 0)
+					cbw40_enable = 1;
+			} else {
+				if ((0x21 & 0x0f) > 0)
+					cbw40_enable = 1;
+			}
+
+			if (cbw40_enable == 0)
+			{
+				pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info &= (~(BIT(6) | BIT(1)));
+			}
+			else
+			{
+				pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info |= BIT(1);
+			}
+
+			//todo: disable SM power save mode
+			pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info |= 0x000c;
+
+			rf_type = rtlpriv->phy.rf_type;
+
+			switch(rf_type)
+			{
+				case RF_1T1R:
+
+					if(pregpriv->rx_stbc)
+						pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info |= cpu_to_le16(0x0100);//RX STBC One spatial stream
+
+					memcpy(pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate, MCS_rate_1R, 16);
+					break;
+
+				case RF_2T2R:
+				case RF_1T2R:
+				default:
+
+					if((pregpriv->rx_stbc == 0x3) ||//enable for 2.4/5 GHz
+						((pmlmeext->cur_wireless_mode & WIRELESS_11_24N) && (pregpriv->rx_stbc == 0x1)) || //enable for 2.4GHz
+						((pmlmeext->cur_wireless_mode & WIRELESS_11_5N) && (pregpriv->rx_stbc == 0x2))) //enable for 5GHz
+					{
+						DBG_871X("declare supporting RX STBC\n");
+						pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info |= cpu_to_le16(0x0200);//RX STBC two spatial stream
+					}
+					#ifdef CONFIG_DISABLE_MCS13TO15
+					if(pmlmeext->cur_bwmode == CHANNEL_WIDTH_40 && (pregpriv->wifi_spec!=1))
+						memcpy(pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate, MCS_rate_2R_MCS13TO15_OFF, 16);
+					else
+					memcpy(pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate, MCS_rate_2R, 16);
+					#else //CONFIG_DISABLE_MCS13TO15
+					memcpy(pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate, MCS_rate_2R, 16);
+					#endif //CONFIG_DISABLE_MCS13TO15
+					break;
+			}
+			pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info = cpu_to_le16(pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info);
+
+
+			pframe = rtw_set_ie(pframe, _HT_CAPABILITY_IE_, ie_len , (uint8_t *)(&(pmlmeinfo->HT_caps)), &(pattrib->pktlen));
+
+		}
+	}
+
+	//vendor specific IE, such as WPA, WMM, WPS
+	for (i = sizeof(NDIS_802_11_FIXED_IEs); i < pmlmeinfo->network.IELength;)
+	{
+		pIE = (PNDIS_802_11_VARIABLE_IEs)(pmlmeinfo->network.IEs + i);
+
+		switch (pIE->ElementID)
+		{
+			case _VENDOR_SPECIFIC_IE_:
+				if ((_rtw_memcmp(pIE->data, RTW_WPA_OUI, 4)) ||
+						(_rtw_memcmp(pIE->data, WMM_OUI, 4)) ||
+						(_rtw_memcmp(pIE->data, WPS_OUI, 4)))
+				{
+					//Commented by Kurt 20110629
+					//In some older APs, WPS handshake
+					//would be fail if we append vender extensions informations to AP
+					if(_rtw_memcmp(pIE->data, WPS_OUI, 4)){
+						pIE->Length=14;
+					}
+					pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, pIE->Length, pIE->data, &(pattrib->pktlen));
+				}
+				break;
+			case EID_VHTCapability:
+				if (rtlpriv->mlmepriv.vhtpriv.vht_option ==true) {
+					pframe = rtw_set_ie(pframe, EID_VHTCapability, pIE->Length, pIE->data, &(pattrib->pktlen));
+				}
+				break;
+
+			case EID_OpModeNotification:
+				if (rtlpriv->mlmepriv.vhtpriv.vht_option ==true) {
+					pframe = rtw_set_ie(pframe, EID_OpModeNotification, pIE->Length, pIE->data, &(pattrib->pktlen));
+				}
+				break;
+			default:
+				break;
+		}
+
+		i += (pIE->Length + 2);
+	}
+
+	if (pmlmeinfo->assoc_AP_vendor == HT_IOT_PEER_REALTEK)
+	{
+		pframe = rtw_set_ie(pframe, _VENDOR_SPECIFIC_IE_, 6 , REALTEK_96B_IE, &(pattrib->pktlen));
+	}
+
+
+	pattrib->last_txcmdsz = pattrib->pktlen;
+	dump_mgntframe(rtlpriv, pmgntframe);
+
+	ret = _SUCCESS;
+
+exit:
+	if (ret == _SUCCESS)
+		rtw_buf_update(&pmlmepriv->assoc_req, &pmlmepriv->assoc_req_len, (uint8_t *)pwlanhdr, pattrib->pktlen);
+	else
+		rtw_buf_free(&pmlmepriv->assoc_req, &pmlmepriv->assoc_req_len);
+
+	return;
+}
+
+//when wait_ack is ture, this function shoule be called at process context
+static int _issue_nulldata(struct rtl_priv *rtlpriv, unsigned char *da, unsigned int power_mode, int wait_ack)
+{
+	int ret = _FAIL;
+	struct xmit_frame			*pmgntframe;
+	struct tx_pkt_attrib			*pattrib;
+	unsigned char					*pframe;
+	struct rtw_ieee80211_hdr	*pwlanhdr;
+	unsigned short				*fctrl;
+	struct xmit_priv	*pxmitpriv;
+	struct mlme_ext_priv	*pmlmeext;
+	struct mlme_ext_info	*pmlmeinfo;
+
+	//DBG_871X("%s:%d\n", __FUNCTION__, power_mode);
+
+	if(!rtlpriv)
+		goto exit;
+
+	pxmitpriv = &(rtlpriv->xmitpriv);
+	pmlmeext = &(rtlpriv->mlmeextpriv);
+	pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	if ((pmgntframe = alloc_mgtxmitframe(pxmitpriv)) == NULL)
+	{
+		goto exit;
+	}
+
+	//update attribute
+	pattrib = &pmgntframe->tx_attrib;
+	update_mgntframe_attrib(rtlpriv, pattrib);
+	pattrib->retry_ctrl = false;
+
+	memset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);
+
+	pframe = (uint8_t *)(pmgntframe->buf_addr) + TXDESC_OFFSET;
+	pwlanhdr = (struct rtw_ieee80211_hdr *)pframe;
+
+	fctrl = &(pwlanhdr->frame_ctl);
+	*(fctrl) = 0;
+
+	if((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE)
+	{
+		SetFrDs(fctrl);
+	}
+	else if((pmlmeinfo->state&0x03) == WIFI_FW_STATION_STATE)
+	{
+		SetToDs(fctrl);
+	}
+
+	if (power_mode)
+	{
+		SetPwrMgt(fctrl);
+	}
+
+	memcpy(pwlanhdr->addr1, da, ETH_ALEN);
+	memcpy(pwlanhdr->addr2, rtlpriv->mac80211.mac_addr, ETH_ALEN);
+	memcpy(pwlanhdr->addr3, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);
+
+	SetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);
+	pmlmeext->mgnt_seq++;
+	SetFrameSubType(pframe, WIFI_DATA_NULL);
+
+	pframe += sizeof(struct rtw_ieee80211_hdr_3addr);
+	pattrib->pktlen = sizeof(struct rtw_ieee80211_hdr_3addr);
+
+	pattrib->last_txcmdsz = pattrib->pktlen;
+
+	if(wait_ack)
+	{
+		ret = dump_mgntframe_and_wait_ack(rtlpriv, pmgntframe);
+	}
+	else
+	{
+		dump_mgntframe(rtlpriv, pmgntframe);
+		ret = _SUCCESS;
+	}
+
+exit:
+	return ret;
+}
+
+
+//when wait_ms >0 , this function shoule be called at process context
+//da == NULL for station mode
+int issue_nulldata(struct rtl_priv *rtlpriv, unsigned char *da, unsigned int power_mode, int try_cnt, int wait_ms)
+{
+	int ret;
+	int i = 0;
+	uint32_t	 start = jiffies;
+	struct mlme_ext_priv	*pmlmeext = &(rtlpriv->mlmeextpriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	/* da == NULL, assum it's null data for sta to ap*/
+	if (da == NULL)
+		da = get_my_bssid(&(pmlmeinfo->network));
+
+	do
+	{
+		ret = _issue_nulldata(rtlpriv, da, power_mode, wait_ms>0?true:false);
+
+		i++;
+
+		if (rtlpriv->bDriverStopped || rtlpriv->bSurpriseRemoved)
+			break;
+
+		if(i < try_cnt && wait_ms > 0 && ret==_FAIL)
+			msleep(wait_ms);
+
+	}while((i<try_cnt) && ((ret==_FAIL)||(wait_ms==0)));
+
+	if (ret != _FAIL) {
+		ret = _SUCCESS;
+		#ifndef DBG_XMIT_ACK
+		goto exit;
+		#endif
+	}
+
+exit:
+	return ret;
+}
+
+//when wait_ack is ture, this function shoule be called at process context
+static int _issue_qos_nulldata(struct rtl_priv *rtlpriv, unsigned char *da, u16 tid, int wait_ack)
+{
+	int ret = _FAIL;
+	struct xmit_frame			*pmgntframe;
+	struct tx_pkt_attrib			*pattrib;
+	unsigned char					*pframe;
+	struct rtw_ieee80211_hdr	*pwlanhdr;
+	unsigned short				*fctrl, *qc;
+	struct xmit_priv			*pxmitpriv = &(rtlpriv->xmitpriv);
+	struct mlme_ext_priv	*pmlmeext = &(rtlpriv->mlmeextpriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	DBG_871X("%s\n", __FUNCTION__);
+
+	if ((pmgntframe = alloc_mgtxmitframe(pxmitpriv)) == NULL)
+	{
+		goto exit;
+	}
+
+	//update attribute
+	pattrib = &pmgntframe->tx_attrib;
+	update_mgntframe_attrib(rtlpriv, pattrib);
+
+	pattrib->hdrlen +=2;
+	pattrib->qos_en = true;
+	pattrib->eosp = 1;
+	pattrib->ack_policy = 0;
+	pattrib->mdata = 0;
+
+	memset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);
+
+	pframe = (uint8_t *)(pmgntframe->buf_addr) + TXDESC_OFFSET;
+	pwlanhdr = (struct rtw_ieee80211_hdr *)pframe;
+
+	fctrl = &(pwlanhdr->frame_ctl);
+	*(fctrl) = 0;
+
+	if((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE)
+	{
+		SetFrDs(fctrl);
+	}
+	else if((pmlmeinfo->state&0x03) == WIFI_FW_STATION_STATE)
+	{
+		SetToDs(fctrl);
+	}
+
+	if(pattrib->mdata)
+		SetMData(fctrl);
+
+	qc = (unsigned short *)(pframe + pattrib->hdrlen - 2);
+
+	SetPriority(qc, tid);
+
+	SetEOSP(qc, pattrib->eosp);
+
+	SetAckpolicy(qc, pattrib->ack_policy);
+
+	memcpy(pwlanhdr->addr1, da, ETH_ALEN);
+	memcpy(pwlanhdr->addr2, rtlpriv->mac80211.mac_addr, ETH_ALEN);
+	memcpy(pwlanhdr->addr3, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);
+
+	SetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);
+	pmlmeext->mgnt_seq++;
+	SetFrameSubType(pframe, WIFI_QOS_DATA_NULL);
+
+	pframe += sizeof(struct rtw_ieee80211_hdr_3addr_qos);
+	pattrib->pktlen = sizeof(struct rtw_ieee80211_hdr_3addr_qos);
+
+	pattrib->last_txcmdsz = pattrib->pktlen;
+
+	if(wait_ack)
+	{
+		ret = dump_mgntframe_and_wait_ack(rtlpriv, pmgntframe);
+	}
+	else
+	{
+		dump_mgntframe(rtlpriv, pmgntframe);
+		ret = _SUCCESS;
+	}
+
+exit:
+	return ret;
+}
+
+//when wait_ms >0 , this function shoule be called at process context
+//da == NULL for station mode
+int issue_qos_nulldata(struct rtl_priv *rtlpriv, unsigned char *da, u16 tid, int try_cnt, int wait_ms)
+{
+	int ret;
+	int i = 0;
+	uint32_t	 start = jiffies;
+	struct mlme_ext_priv	*pmlmeext = &(rtlpriv->mlmeextpriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	/* da == NULL, assum it's null data for sta to ap*/
+	if (da == NULL)
+		da = get_my_bssid(&(pmlmeinfo->network));
+
+	do
+	{
+		ret = _issue_qos_nulldata(rtlpriv, da, tid, wait_ms>0?true:false);
+
+		i++;
+
+		if (rtlpriv->bDriverStopped || rtlpriv->bSurpriseRemoved)
+			break;
+
+		if(i < try_cnt && wait_ms > 0 && ret==_FAIL)
+			msleep(wait_ms);
+
+	}while((i<try_cnt) && ((ret==_FAIL)||(wait_ms==0)));
+
+	if (ret != _FAIL) {
+		ret = _SUCCESS;
+		#ifndef DBG_XMIT_ACK
+		goto exit;
+		#endif
+	}
+
+exit:
+	return ret;
+}
+
+static int _issue_deauth(struct rtl_priv *rtlpriv, unsigned char *da, unsigned short reason, uint8_t wait_ack)
+{
+	struct xmit_frame			*pmgntframe;
+	struct tx_pkt_attrib			*pattrib;
+	unsigned char					*pframe;
+	struct rtw_ieee80211_hdr	*pwlanhdr;
+	unsigned short				*fctrl;
+	struct xmit_priv			*pxmitpriv = &(rtlpriv->xmitpriv);
+	struct mlme_ext_priv	*pmlmeext = &(rtlpriv->mlmeextpriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	int ret = _FAIL;
+
+	//DBG_871X("%s to "MAC_FMT"\n", __func__, MAC_ARG(da));
+
+	if ((pmgntframe = alloc_mgtxmitframe(pxmitpriv)) == NULL)
+	{
+		goto exit;
+	}
+
+	//update attribute
+	pattrib = &pmgntframe->tx_attrib;
+	update_mgntframe_attrib(rtlpriv, pattrib);
+	pattrib->retry_ctrl = false;
+
+	memset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);
+
+	pframe = (uint8_t *)(pmgntframe->buf_addr) + TXDESC_OFFSET;
+	pwlanhdr = (struct rtw_ieee80211_hdr *)pframe;
+
+	fctrl = &(pwlanhdr->frame_ctl);
+	*(fctrl) = 0;
+
+	memcpy(pwlanhdr->addr1, da, ETH_ALEN);
+	memcpy(pwlanhdr->addr2, rtlpriv->mac80211.mac_addr, ETH_ALEN);
+	memcpy(pwlanhdr->addr3, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);
+
+	SetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);
+	pmlmeext->mgnt_seq++;
+	SetFrameSubType(pframe, WIFI_DEAUTH);
+
+	pframe += sizeof(struct rtw_ieee80211_hdr_3addr);
+	pattrib->pktlen = sizeof(struct rtw_ieee80211_hdr_3addr);
+
+	reason = cpu_to_le16(reason);
+	pframe = rtw_set_fixed_ie(pframe, _RSON_CODE_ , (unsigned char *)&reason, &(pattrib->pktlen));
+
+	pattrib->last_txcmdsz = pattrib->pktlen;
+
+
+	if(wait_ack)
+	{
+		ret = dump_mgntframe_and_wait_ack(rtlpriv, pmgntframe);
+	}
+	else
+	{
+		dump_mgntframe(rtlpriv, pmgntframe);
+		ret = _SUCCESS;
+	}
+
+exit:
+	return ret;
+}
+
+int issue_deauth(struct rtl_priv *rtlpriv, unsigned char *da, unsigned short reason)
+{
+	DBG_871X("%s to "MAC_FMT"\n", __func__, MAC_ARG(da));
+	return _issue_deauth(rtlpriv, da, reason, false);
+}
+
+int issue_deauth_ex(struct rtl_priv *rtlpriv, uint8_t *da, unsigned short reason, int try_cnt,
+	int wait_ms)
+{
+	int ret;
+	int i = 0;
+	uint32_t	 start = jiffies;
+
+	do
+	{
+		ret = _issue_deauth(rtlpriv, da, reason, wait_ms>0?true:false);
+
+		i++;
+
+		if (rtlpriv->bDriverStopped || rtlpriv->bSurpriseRemoved)
+			break;
+
+		if(i < try_cnt && wait_ms > 0 && ret==_FAIL)
+			msleep(wait_ms);
+
+	}while((i<try_cnt) && ((ret==_FAIL)||(wait_ms==0)));
+
+	if (ret != _FAIL) {
+		ret = _SUCCESS;
+		#ifndef DBG_XMIT_ACK
+		goto exit;
+		#endif
+	}
+
+exit:
+	return ret;
+}
+
+void issue_action_spct_ch_switch(struct rtl_priv *rtlpriv, uint8_t *ra, uint8_t new_ch, uint8_t ch_offset)
+{
+	struct list_head		*plist, *phead;
+	struct xmit_frame			*pmgntframe;
+	struct tx_pkt_attrib			*pattrib;
+	unsigned char				*pframe;
+	struct rtw_ieee80211_hdr	*pwlanhdr;
+	unsigned short			*fctrl;
+	struct xmit_priv			*pxmitpriv = &(rtlpriv->xmitpriv);
+	struct mlme_priv *pmlmepriv = &rtlpriv->mlmepriv;
+	struct mlme_ext_priv	*pmlmeext = &(rtlpriv->mlmeextpriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+
+	DBG_871X(FUNC_NDEV_FMT" ra="MAC_FMT", ch:%u, offset:%u\n",
+		FUNC_NDEV_ARG(rtlpriv->ndev), MAC_ARG(ra), new_ch, ch_offset);
+
+	if ((pmgntframe = alloc_mgtxmitframe(pxmitpriv)) == NULL)
+		return;
+
+	//update attribute
+	pattrib = &pmgntframe->tx_attrib;
+	update_mgntframe_attrib(rtlpriv, pattrib);
+
+	memset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);
+
+	pframe = (uint8_t *)(pmgntframe->buf_addr) + TXDESC_OFFSET;
+	pwlanhdr = (struct rtw_ieee80211_hdr *)pframe;
+
+	fctrl = &(pwlanhdr->frame_ctl);
+	*(fctrl) = 0;
+
+	memcpy(pwlanhdr->addr1, ra, ETH_ALEN); /* RA */
+	memcpy(pwlanhdr->addr2, rtlpriv->mac80211.mac_addr, ETH_ALEN); /* TA */
+	memcpy(pwlanhdr->addr3, ra, ETH_ALEN); /* DA = RA */
+
+	SetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);
+	pmlmeext->mgnt_seq++;
+	SetFrameSubType(pframe, WIFI_ACTION);
+
+	pframe += sizeof(struct rtw_ieee80211_hdr_3addr);
+	pattrib->pktlen = sizeof(struct rtw_ieee80211_hdr_3addr);
+
+	/* category, action */
+	{
+		uint8_t category, action;
+		category = RTW_WLAN_CATEGORY_SPECTRUM_MGMT;
+		action = RTW_WLAN_ACTION_SPCT_CHL_SWITCH;
+
+		pframe = rtw_set_fixed_ie(pframe, 1, &(category), &(pattrib->pktlen));
+		pframe = rtw_set_fixed_ie(pframe, 1, &(action), &(pattrib->pktlen));
+	}
+
+	pframe = rtw_set_ie_ch_switch(pframe, &(pattrib->pktlen), 0, new_ch, 0);
+	pframe = rtw_set_ie_secondary_ch_offset(pframe, &(pattrib->pktlen),
+		hal_ch_offset_to_secondary_ch_offset(ch_offset));
+
+	pattrib->last_txcmdsz = pattrib->pktlen;
+
+	dump_mgntframe(rtlpriv, pmgntframe);
+
+}
+
+void issue_action_BA(struct rtl_priv *rtlpriv, unsigned char *raddr, unsigned char action, unsigned short status)
+{
+	uint8_t	category = RTW_WLAN_CATEGORY_BACK;
+	u16	start_seq;
+	u16	BA_para_set;
+	u16	reason_code;
+	u16	BA_timeout_value;
+	u16	BA_starting_seqctrl;
+	HT_CAP_AMPDU_FACTOR max_rx_ampdu_factor;
+	struct xmit_frame		*pmgntframe;
+	struct tx_pkt_attrib		*pattrib;
+	uint8_t					*pframe;
+	struct rtw_ieee80211_hdr	*pwlanhdr;
+	u16					*fctrl;
+	struct xmit_priv		*pxmitpriv = &(rtlpriv->xmitpriv);
+	struct mlme_ext_priv	*pmlmeext = &(rtlpriv->mlmeextpriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct sta_info		*psta;
+	struct sta_priv		*pstapriv = &rtlpriv->stapriv;
+	struct registry_priv	 	*pregpriv = &rtlpriv->registrypriv;
+
+	DBG_871X("%s, category=%d, action=%d, status=%d\n", __FUNCTION__, category, action, status);
+
+	if ((pmgntframe = alloc_mgtxmitframe(pxmitpriv)) == NULL)
+	{
+		return;
+	}
+
+	//update attribute
+	pattrib = &pmgntframe->tx_attrib;
+	update_mgntframe_attrib(rtlpriv, pattrib);
+
+	memset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);
+
+	pframe = (uint8_t *)(pmgntframe->buf_addr) + TXDESC_OFFSET;
+	pwlanhdr = (struct rtw_ieee80211_hdr *)pframe;
+
+	fctrl = &(pwlanhdr->frame_ctl);
+	*(fctrl) = 0;
+
+	//memcpy(pwlanhdr->addr1, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);
+	memcpy(pwlanhdr->addr1, raddr, ETH_ALEN);
+	memcpy(pwlanhdr->addr2, rtlpriv->mac80211.mac_addr, ETH_ALEN);
+	memcpy(pwlanhdr->addr3, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);
+
+	SetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);
+	pmlmeext->mgnt_seq++;
+	SetFrameSubType(pframe, WIFI_ACTION);
+
+	pframe += sizeof(struct rtw_ieee80211_hdr_3addr);
+	pattrib->pktlen = sizeof(struct rtw_ieee80211_hdr_3addr);
+
+	pframe = rtw_set_fixed_ie(pframe, 1, &(category), &(pattrib->pktlen));
+	pframe = rtw_set_fixed_ie(pframe, 1, &(action), &(pattrib->pktlen));
+
+      status = cpu_to_le16(status);
+
+
+	if (category == 3)
+	{
+		switch (action)
+		{
+			case 0: //ADDBA req
+				do {
+					pmlmeinfo->dialogToken++;
+				} while (pmlmeinfo->dialogToken == 0);
+				pframe = rtw_set_fixed_ie(pframe, 1, &(pmlmeinfo->dialogToken), &(pattrib->pktlen));
+
+				{
+					BA_para_set = (0x1002 | ((status & 0xf) << 2)); //immediate ack & 64 buffer size
+				}
+				//sys_mib.BA_para_set = 0x0802; //immediate ack & 32 buffer size
+				BA_para_set = cpu_to_le16(BA_para_set);
+				pframe = rtw_set_fixed_ie(pframe, 2, (unsigned char *)(&(BA_para_set)), &(pattrib->pktlen));
+
+				//BA_timeout_value = 0xffff;//max: 65535 TUs(~ 65 ms)
+				BA_timeout_value = 5000;//~ 5ms
+				BA_timeout_value = cpu_to_le16(BA_timeout_value);
+				pframe = rtw_set_fixed_ie(pframe, 2, (unsigned char *)(&(BA_timeout_value)), &(pattrib->pktlen));
+
+				//if ((psta = rtw_get_stainfo(pstapriv, pmlmeinfo->network.MacAddress)) != NULL)
+				if ((psta = rtw_get_stainfo(pstapriv, raddr)) != NULL)
+				{
+					start_seq = (psta->sta_xmitpriv.txseq_tid[status & 0x07]&0xfff) + 1;
+
+					DBG_871X("BA_starting_seqctrl = %d for TID=%d\n", start_seq, status & 0x07);
+
+					psta->BA_starting_seqctrl[status & 0x07] = start_seq;
+
+					BA_starting_seqctrl = start_seq << 4;
+				}
+
+				BA_starting_seqctrl = cpu_to_le16(BA_starting_seqctrl);
+				pframe = rtw_set_fixed_ie(pframe, 2, (unsigned char *)(&(BA_starting_seqctrl)), &(pattrib->pktlen));
+				break;
+
+			case 1: //ADDBA rsp
+				pframe = rtw_set_fixed_ie(pframe, 1, &(pmlmeinfo->ADDBA_req.dialog_token), &(pattrib->pktlen));
+				pframe = rtw_set_fixed_ie(pframe, 2, (unsigned char *)(&status), &(pattrib->pktlen));
+				/*
+				//BA_para_set = cpu_to_le16((le16_to_cpu(pmlmeinfo->ADDBA_req.BA_para_set) & 0x3f) | 0x1000); //64 buffer size
+				*/
+				max_rx_ampdu_factor = MAX_AMPDU_FACTOR_64K;
+				if(MAX_AMPDU_FACTOR_64K == max_rx_ampdu_factor)
+					BA_para_set = ((le16_to_cpu(pmlmeinfo->ADDBA_req.BA_para_set) & 0x3f) | 0x1000); //64 buffer size
+				else if(MAX_AMPDU_FACTOR_32K == max_rx_ampdu_factor)
+					BA_para_set = ((le16_to_cpu(pmlmeinfo->ADDBA_req.BA_para_set) & 0x3f) | 0x0800); //32 buffer size
+				else if(MAX_AMPDU_FACTOR_16K == max_rx_ampdu_factor)
+					BA_para_set = ((le16_to_cpu(pmlmeinfo->ADDBA_req.BA_para_set) & 0x3f) | 0x0400); //16 buffer size
+				else if(MAX_AMPDU_FACTOR_8K == max_rx_ampdu_factor)
+					BA_para_set = ((le16_to_cpu(pmlmeinfo->ADDBA_req.BA_para_set) & 0x3f) | 0x0200); //8 buffer size
+				else
+					BA_para_set = ((le16_to_cpu(pmlmeinfo->ADDBA_req.BA_para_set) & 0x3f) | 0x1000); //64 buffer size
+
+
+				if(pregpriv->ampdu_amsdu==0)//disabled
+					BA_para_set = cpu_to_le16(BA_para_set & ~BIT(0));
+				else if(pregpriv->ampdu_amsdu==1)//enabled
+					BA_para_set = cpu_to_le16(BA_para_set | BIT(0));
+				else //auto
+					BA_para_set = cpu_to_le16(BA_para_set);
+
+				pframe = rtw_set_fixed_ie(pframe, 2, (unsigned char *)(&(BA_para_set)), &(pattrib->pktlen));
+				pframe = rtw_set_fixed_ie(pframe, 2, (unsigned char *)(&(pmlmeinfo->ADDBA_req.BA_timeout_value)), &(pattrib->pktlen));
+				break;
+			case 2://DELBA
+				BA_para_set = (status & 0x1F) << 3;
+				BA_para_set = cpu_to_le16(BA_para_set);
+				pframe = rtw_set_fixed_ie(pframe, 2, (unsigned char *)(&(BA_para_set)), &(pattrib->pktlen));
+
+				reason_code = 37;//Requested from peer STA as it does not want to use the mechanism
+				reason_code = cpu_to_le16(reason_code);
+				pframe = rtw_set_fixed_ie(pframe, 2, (unsigned char *)(&(reason_code)), &(pattrib->pktlen));
+				break;
+			default:
+				break;
+		}
+	}
+
+	pattrib->last_txcmdsz = pattrib->pktlen;
+
+	dump_mgntframe(rtlpriv, pmgntframe);
+}
+
+static void issue_action_BSSCoexistPacket(struct rtl_priv *rtlpriv)
+{
+	struct list_head		*plist, *phead;
+	unsigned char category, action;
+	struct xmit_frame			*pmgntframe;
+	struct tx_pkt_attrib			*pattrib;
+	unsigned char				*pframe;
+	struct rtw_ieee80211_hdr	*pwlanhdr;
+	unsigned short			*fctrl;
+	struct	wlan_network	*pnetwork = NULL;
+	struct xmit_priv			*pxmitpriv = &(rtlpriv->xmitpriv);
+	struct mlme_priv *pmlmepriv = &rtlpriv->mlmepriv;
+	struct mlme_ext_priv	*pmlmeext = &(rtlpriv->mlmeextpriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct __queue		*queue	= &(pmlmepriv->scanned_queue);
+	uint8_t InfoContent[16] = {0};
+	uint8_t ICS[8][15];
+	if((pmlmepriv->num_FortyMHzIntolerant==0) || (pmlmepriv->num_sta_no_ht==0))
+		return;
+
+	if(true == pmlmeinfo->bwmode_updated)
+		return;
+
+
+	DBG_871X("%s\n", __FUNCTION__);
+
+
+	category = RTW_WLAN_CATEGORY_PUBLIC;
+	action = ACT_PUBLIC_BSSCOEXIST;
+
+	if ((pmgntframe = alloc_mgtxmitframe(pxmitpriv)) == NULL)
+	{
+		return;
+	}
+
+	//update attribute
+	pattrib = &pmgntframe->tx_attrib;
+	update_mgntframe_attrib(rtlpriv, pattrib);
+
+	memset(pmgntframe->buf_addr, 0, WLANHDR_OFFSET + TXDESC_OFFSET);
+
+	pframe = (uint8_t *)(pmgntframe->buf_addr) + TXDESC_OFFSET;
+	pwlanhdr = (struct rtw_ieee80211_hdr *)pframe;
+
+	fctrl = &(pwlanhdr->frame_ctl);
+	*(fctrl) = 0;
+
+	memcpy(pwlanhdr->addr1, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);
+	memcpy(pwlanhdr->addr2, rtlpriv->mac80211.mac_addr, ETH_ALEN);
+	memcpy(pwlanhdr->addr3, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);
+
+	SetSeqNum(pwlanhdr, pmlmeext->mgnt_seq);
+	pmlmeext->mgnt_seq++;
+	SetFrameSubType(pframe, WIFI_ACTION);
+
+	pframe += sizeof(struct rtw_ieee80211_hdr_3addr);
+	pattrib->pktlen = sizeof(struct rtw_ieee80211_hdr_3addr);
+
+	pframe = rtw_set_fixed_ie(pframe, 1, &(category), &(pattrib->pktlen));
+	pframe = rtw_set_fixed_ie(pframe, 1, &(action), &(pattrib->pktlen));
+
+
+	//
+	if(pmlmepriv->num_FortyMHzIntolerant>0)
+	{
+		uint8_t iedata=0;
+
+		iedata |= BIT(2);//20 MHz BSS Width Request
+
+		pframe = rtw_set_ie(pframe, EID_BSSCoexistence,  1, &iedata, &(pattrib->pktlen));
+
+	}
+
+
+	//
+	memset(ICS, 0, sizeof(ICS));
+	if(pmlmepriv->num_sta_no_ht>0)
+	{
+		int i;
+
+		spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
+
+		phead = get_list_head(queue);
+		plist = get_next(phead);
+
+		while(1)
+		{
+			int len;
+			uint8_t *p;
+			WLAN_BSSID_EX *pbss_network;
+
+			if (rtw_end_of_queue_search(phead,plist)== true)
+				break;
+
+			pnetwork = container_of(plist, struct wlan_network, list);
+
+			plist = get_next(plist);
+
+			pbss_network = (WLAN_BSSID_EX *)&pnetwork->network;
+
+			p = rtw_get_ie(pbss_network->IEs + _FIXED_IE_LENGTH_, _HT_CAPABILITY_IE_, &len, pbss_network->IELength - _FIXED_IE_LENGTH_);
+			if((p==NULL) || (len==0))//non-HT
+			{
+				if((pbss_network->Configuration.DSConfig<=0) || (pbss_network->Configuration.DSConfig>14))
+					continue;
+
+				ICS[0][pbss_network->Configuration.DSConfig]=1;
+
+				if(ICS[0][0] == 0)
+					ICS[0][0] = 1;
+			}
+
+		}
+
+		spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
+
+
+		for(i= 0;i<8;i++)
+		{
+			if(ICS[i][0] == 1)
+			{
+				int j, k = 0;
+
+				InfoContent[k] = i;
+				//SET_BSS_INTOLERANT_ELE_REG_CLASS(InfoContent,i);
+				k++;
+
+				for(j=1;j<=14;j++)
+				{
+					if(ICS[i][j]==1)
+					{
+						if(k<16)
+						{
+							InfoContent[k] = j; //channel number
+							//SET_BSS_INTOLERANT_ELE_CHANNEL(InfoContent+k, j);
+							k++;
+						}
+					}
+				}
+
+				pframe = rtw_set_ie(pframe, EID_BSSIntolerantChlReport, k, InfoContent, &(pattrib->pktlen));
+
+			}
+
+		}
+
+
+	}
+
+
+	pattrib->last_txcmdsz = pattrib->pktlen;
+
+	dump_mgntframe(rtlpriv, pmgntframe);
+}
+
+unsigned int send_delba(struct rtl_priv *rtlpriv, uint8_t initiator, uint8_t *addr)
+{
+	struct sta_priv *pstapriv = &rtlpriv->stapriv;
+	struct sta_info *psta = NULL;
+	//struct recv_reorder_ctrl *preorder_ctrl;
+	struct mlme_ext_priv	*pmlmeext = &rtlpriv->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	u16 tid;
+
+	if((pmlmeinfo->state&0x03) != WIFI_FW_AP_STATE)
+		if (!(pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS))
+			return _SUCCESS;
+
+	psta = rtw_get_stainfo(pstapriv, addr);
+	if(psta==NULL)
+		return _SUCCESS;
+
+	//DBG_871X("%s:%s\n", __FUNCTION__, (initiator==0)?"RX_DIR":"TX_DIR");
+
+	if(initiator==0) // recipient
+	{
+		for(tid = 0;tid<MAXTID;tid++)
+		{
+			if(psta->recvreorder_ctrl[tid].enable == true)
+			{
+				DBG_871X("rx agg disable tid(%d)\n",tid);
+				issue_action_BA(rtlpriv, addr, RTW_WLAN_ACTION_DELBA, (((tid <<1) |initiator)&0x1F));
+				psta->recvreorder_ctrl[tid].enable = false;
+				psta->recvreorder_ctrl[tid].indicate_seq = 0xffff;
+			}
+		}
+	}
+	else if(initiator == 1)// originator
+	{
+		//DBG_871X("tx agg_enable_bitmap(0x%08x)\n", psta->htpriv.agg_enable_bitmap);
+		for(tid = 0;tid<MAXTID;tid++)
+		{
+			if(psta->htpriv.agg_enable_bitmap & BIT(tid))
+			{
+				DBG_871X("tx agg disable tid(%d)\n",tid);
+				issue_action_BA(rtlpriv, addr, RTW_WLAN_ACTION_DELBA, (((tid <<1) |initiator)&0x1F) );
+				psta->htpriv.agg_enable_bitmap &= ~BIT(tid);
+				psta->htpriv.candidate_tid_bitmap &= ~BIT(tid);
+
+			}
+		}
+	}
+
+	return _SUCCESS;
+
+}
+
+unsigned int send_beacon(struct rtl_priv *rtlpriv)
+{
+	uint8_t	bxmitok = false;
+	int	issue=0;
+	int poll = 0;
+
+
+	uint32_t	 start = jiffies;
+
+	rtlpriv->cfg->ops->set_hw_reg(rtlpriv, HW_VAR_BCN_VALID, NULL);
+	rtlpriv->cfg->ops->set_hw_reg(rtlpriv, HW_VAR_DL_BCN_SEL, NULL);
+	do{
+		issue_beacon(rtlpriv, 100);
+		issue++;
+		do {
+			rtw_yield_os();
+			rtlpriv->cfg->ops->get_hw_reg(rtlpriv, HW_VAR_BCN_VALID, (uint8_t *)(&bxmitok));
+			poll++;
+		}while((poll%10)!=0 && false == bxmitok && !rtlpriv->bSurpriseRemoved && !rtlpriv->bDriverStopped);
+
+	}while(false == bxmitok && issue<100 && !rtlpriv->bSurpriseRemoved && !rtlpriv->bDriverStopped);
+
+	if(rtlpriv->bSurpriseRemoved || rtlpriv->bDriverStopped)
+	{
+		return _FAIL;
+	}
+
+
+	if(false == bxmitok)
+	{
+		DBG_871X("%s fail! %u ms\n", __FUNCTION__, rtw_get_passing_time_ms(start));
+		return _FAIL;
+	}
+	else
+	{
+		uint32_t	 passing_time = rtw_get_passing_time_ms(start);
+
+		if(passing_time > 100 || issue > 3)
+			DBG_871X("%s success, issue:%d, poll:%d, %u ms\n", __FUNCTION__, issue, poll, rtw_get_passing_time_ms(start));
+		//else
+		//	DBG_871X("%s success, issue:%d, poll:%d, %u ms\n", __FUNCTION__, issue, poll, rtw_get_passing_time_ms(start));
+
+		return _SUCCESS;
+	}
+
+
+}
+
+/****************************************************************************
+
+Following are some utitity fuctions for WiFi MLME
+
+*****************************************************************************/
+
+bool IsLegal5GChannel(struct rtl_priv *rtlpriv, uint8_t	channel)
+{
+
+	int i=0;
+	uint8_t Channel_5G[45] = {36,38,40,42,44,46,48,50,52,54,56,58,
+		60,62,64,100,102,104,106,108,110,112,114,116,118,120,122,
+		124,126,128,130,132,134,136,138,140,149,151,153,155,157,159,
+		161,163,165};
+	for(i=0;i<sizeof(Channel_5G);i++)
+		if(channel == Channel_5G[i])
+			return true;
+	return false;
+}
+
+void site_survey(struct rtl_priv *rtlpriv)
+{
+	unsigned char		survey_channel = 0, val8;
+	RT_SCAN_TYPE	ScanType = SCAN_PASSIVE;
+	struct mlme_ext_priv	*pmlmeext = &rtlpriv->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	uint32_t	 initialgain = 0;
+
+	{
+		struct rtw_ieee80211_channel *ch;
+		if (pmlmeext->sitesurvey_res.channel_idx < pmlmeext->sitesurvey_res.ch_num) {
+			ch = &pmlmeext->sitesurvey_res.ch[pmlmeext->sitesurvey_res.channel_idx];
+			survey_channel = ch->hw_value;
+			ScanType = (ch->flags & RTW_IEEE80211_CHAN_PASSIVE_SCAN) ? SCAN_PASSIVE : SCAN_ACTIVE;
+		}
+	}
+
+	if(survey_channel != 0)
+	{
+		//PAUSE 4-AC Queue when site_survey
+		//rtlpriv->cfg->ops->get_hw_reg(rtlpriv, HW_VAR_TXPAUSE, (uint8_t *)(&val8));
+		//val8 |= 0x0f;
+		//rtlpriv->cfg->ops->set_hw_reg(rtlpriv, HW_VAR_TXPAUSE, (uint8_t *)(&val8));
+		if(pmlmeext->sitesurvey_res.channel_idx == 0)
+		{
+#ifdef DBG_FIXED_CHAN
+			if(pmlmeext->fixed_chan !=0xff)
+				set_channel_bwmode(rtlpriv, pmlmeext->fixed_chan, HAL_PRIME_CHNL_OFFSET_DONT_CARE, CHANNEL_WIDTH_20);
+			else
+#endif
+				set_channel_bwmode(rtlpriv, survey_channel, HAL_PRIME_CHNL_OFFSET_DONT_CARE, CHANNEL_WIDTH_20);
+		}
+		else
+		{
+#ifdef DBG_FIXED_CHAN
+			if(pmlmeext->fixed_chan!=0xff)
+				SelectChannel(rtlpriv, pmlmeext->fixed_chan);
+			else
+#endif
+				SelectChannel(rtlpriv, survey_channel);
+		}
+
+
+		if(ScanType == SCAN_ACTIVE) //obey the channel plan setting...
+		{
+			{
+				int i;
+				for(i=0;i<RTW_SSID_SCAN_AMOUNT;i++){
+					if(pmlmeext->sitesurvey_res.ssid[i].SsidLength) {
+						//todo: to issue two probe req???
+						issue_probereq(rtlpriv, &(pmlmeext->sitesurvey_res.ssid[i]), NULL);
+						//msleep(SURVEY_TO>>1);
+						issue_probereq(rtlpriv, &(pmlmeext->sitesurvey_res.ssid[i]), NULL);
+					}
+				}
+
+				if(pmlmeext->sitesurvey_res.scan_mode == SCAN_ACTIVE) {
+					//todo: to issue two probe req???
+					issue_probereq(rtlpriv, NULL, NULL);
+					//msleep(SURVEY_TO>>1);
+					issue_probereq(rtlpriv, NULL, NULL);
+				}
+			}
+		}
+
+			set_survey_timer(pmlmeext, pmlmeext->chan_scan_time);
+
+	}
+	else
+	{
+
+		//	channel number is 0 or this channel is not valid.
+
+
+
+		{
+			pmlmeext->sitesurvey_res.state = SCAN_COMPLETE;
+
+			//switch back to the original channel
+			//SelectChannel(rtlpriv, pmlmeext->cur_channel, pmlmeext->cur_ch_offset);
+
+			{
+			}
+
+			//flush 4-AC Queue after site_survey
+			//val8 = 0;
+			//rtlpriv->cfg->ops->set_hw_reg(rtlpriv, HW_VAR_TXPAUSE, (uint8_t *)(&val8));
+
+			//config MSR
+			Set_MSR(rtlpriv, (pmlmeinfo->state & 0x3));
+
+			initialgain = 0xff; //restore RX GAIN
+			rtlpriv->cfg->ops->set_hw_reg(rtlpriv, HW_VAR_INITIAL_GAIN, (uint8_t *)(&initialgain));
+			//Switch_DM_Func(rtlpriv, DYNAMIC_ALL_FUNC_ENABLE, true);
+
+			if (is_client_associated_to_ap(rtlpriv) == true)
+			{
+				issue_nulldata(rtlpriv, NULL, 0, 3, 500);
+
+			}
+
+			val8 = 0; //survey done
+			rtlpriv->cfg->ops->set_hw_reg(rtlpriv, HW_VAR_MLME_SITESURVEY, (uint8_t *)(&val8));
+
+			report_surveydone_event(rtlpriv);
+
+			pmlmeext->chan_scan_time = SURVEY_TO;
+			pmlmeext->sitesurvey_res.state = SCAN_DISABLE;
+
+			issue_action_BSSCoexistPacket(rtlpriv);
+			issue_action_BSSCoexistPacket(rtlpriv);
+			issue_action_BSSCoexistPacket(rtlpriv);
+
+		}
+
+
+	}
+
+	return;
+
+}
+
+//collect bss info from Beacon and Probe response frames.
+uint8_t collect_bss_info(struct rtl_priv *rtlpriv, struct recv_frame *precv_frame, WLAN_BSSID_EX *bssid)
+{
+	int	i;
+	uint32_t	len;
+	uint8_t	*p;
+	u16	val16, subtype;
+	uint8_t	*pframe = precv_frame->rx_data;
+	uint32_t	packet_len = precv_frame->len;
+	struct registry_priv 	*pregistrypriv = &rtlpriv->registrypriv;
+	struct mlme_ext_priv	*pmlmeext = &rtlpriv->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	len = packet_len - sizeof(struct rtw_ieee80211_hdr_3addr);
+
+	if (len > MAX_IE_SZ)
+	{
+		//DBG_871X("IE too long for survey event\n");
+		return _FAIL;
+	}
+
+	memset(bssid, 0, sizeof(WLAN_BSSID_EX));
+
+	subtype = GetFrameSubType(pframe);
+
+	if(subtype==WIFI_BEACON)
+		bssid->Reserved[0] = 1;
+	else
+		bssid->Reserved[0] = 0;
+
+	bssid->Length = sizeof(WLAN_BSSID_EX) - MAX_IE_SZ + len;
+
+	//below is to copy the information element
+	bssid->IELength = len;
+	memcpy(bssid->IEs, (pframe + sizeof(struct rtw_ieee80211_hdr_3addr)), bssid->IELength);
+
+	//get the signal strength
+	//bssid->Rssi = precv_frame->u.hdr.attrib.SignalStrength; // 0-100 index.
+	bssid->Rssi = precv_frame->attrib.phy_info.RecvSignalPower; // in dBM.raw data
+	bssid->PhyInfo.SignalQuality = precv_frame->attrib.phy_info.SignalQuality;//in percentage
+	bssid->PhyInfo.SignalStrength = precv_frame->attrib.phy_info.SignalStrength;//in percentage
+
+	// checking SSID
+	if ((p = rtw_get_ie(bssid->IEs + _FIXED_IE_LENGTH_, _SSID_IE_, &len, bssid->IELength - _FIXED_IE_LENGTH_)) == NULL)
+	{
+		DBG_871X("marc: cannot find SSID for survey event\n");
+		return _FAIL;
+	}
+
+	if (*(p + 1))
+	{
+		if (len > NDIS_802_11_LENGTH_SSID)
+		{
+			DBG_871X("%s()-%d: IE too long (%d) for survey event\n", __FUNCTION__, __LINE__, len);
+			return _FAIL;
+		}
+		memcpy(bssid->Ssid.Ssid, (p + 2), *(p + 1));
+		bssid->Ssid.SsidLength = *(p + 1);
+	}
+	else
+	{
+		bssid->Ssid.SsidLength = 0;
+	}
+
+	memset(bssid->SupportedRates, 0, NDIS_802_11_LENGTH_RATES_EX);
+
+	//checking rate info...
+	i = 0;
+	p = rtw_get_ie(bssid->IEs + _FIXED_IE_LENGTH_, _SUPPORTEDRATES_IE_, &len, bssid->IELength - _FIXED_IE_LENGTH_);
+	if (p != NULL)
+	{
+		if (len > NDIS_802_11_LENGTH_RATES_EX)
+		{
+			DBG_871X("%s()-%d: IE too long (%d) for survey event\n", __FUNCTION__, __LINE__, len);
+			return _FAIL;
+		}
+		memcpy(bssid->SupportedRates, (p + 2), len);
+		i = len;
+	}
+
+	p = rtw_get_ie(bssid->IEs + _FIXED_IE_LENGTH_, _EXT_SUPPORTEDRATES_IE_, &len, bssid->IELength - _FIXED_IE_LENGTH_);
+	if (p != NULL)
+	{
+		if (len > (NDIS_802_11_LENGTH_RATES_EX-i))
+		{
+			DBG_871X("%s()-%d: IE too long (%d) for survey event\n", __FUNCTION__, __LINE__, len);
+			return _FAIL;
+		}
+		memcpy(bssid->SupportedRates + i, (p + 2), len);
+	}
+
+	//todo:
+	{
+		bssid->NetworkTypeInUse = Ndis802_11OFDM24;
+	}
+
+	if (bssid->IELength < 12)
+		return _FAIL;
+
+	// Checking for DSConfig
+	p = rtw_get_ie(bssid->IEs + _FIXED_IE_LENGTH_, _DSSET_IE_, &len, bssid->IELength - _FIXED_IE_LENGTH_);
+
+	bssid->Configuration.DSConfig = 0;
+	bssid->Configuration.Length = 0;
+
+	if (p)
+	{
+		bssid->Configuration.DSConfig = *(p + 2);
+	}
+	else
+	{// In 5G, some ap do not have DSSET IE
+		// checking HT info for channel
+		p = rtw_get_ie(bssid->IEs + _FIXED_IE_LENGTH_, _HT_ADD_INFO_IE_, &len, bssid->IELength - _FIXED_IE_LENGTH_);
+		if(p)
+		{
+			struct HT_info_element *HT_info = (struct HT_info_element *)(p + 2);
+			bssid->Configuration.DSConfig = HT_info->primary_channel;
+		}
+		else
+		{ // use current channel
+			bssid->Configuration.DSConfig = rtw_get_oper_ch(rtlpriv);
+		}
+	}
+
+	memcpy(&bssid->Configuration.BeaconPeriod, rtw_get_beacon_interval_from_ie(bssid->IEs), 2);
+	bssid->Configuration.BeaconPeriod = le32_to_cpu(bssid->Configuration.BeaconPeriod);
+
+	val16 = rtw_get_capability((WLAN_BSSID_EX *)bssid);
+
+	if (val16 & BIT(0))
+	{
+		bssid->InfrastructureMode = Ndis802_11Infrastructure;
+		memcpy(bssid->MacAddress, GetAddr2Ptr(pframe), ETH_ALEN);
+	}
+	else
+	{
+		bssid->InfrastructureMode = Ndis802_11IBSS;
+		memcpy(bssid->MacAddress, GetAddr3Ptr(pframe), ETH_ALEN);
+	}
+
+	if (val16 & BIT(4))
+		bssid->Privacy = 1;
+	else
+		bssid->Privacy = 0;
+
+	bssid->Configuration.ATIMWindow = 0;
+
+	// mark bss info receving from nearby channel as SignalQuality 101
+	if(bssid->Configuration.DSConfig != rtw_get_oper_ch(rtlpriv))
+	{
+		bssid->PhyInfo.SignalQuality= 101;
+	}
+
+	return _SUCCESS;
+}
+
+void start_create_ibss(struct rtl_priv* rtlpriv)
+{
+	struct rtl_mac *mac = rtl_mac(rtlpriv);
+	unsigned short	caps;
+	uint8_t	val8;
+	uint8_t	join_type;
+	struct mlme_ext_priv	*pmlmeext = &rtlpriv->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	WLAN_BSSID_EX		*pnetwork = (WLAN_BSSID_EX*)(&(pmlmeinfo->network));
+	pmlmeext->cur_channel = (uint8_t)pnetwork->Configuration.DSConfig;
+	mac->beacon_interval = get_beacon_interval(pnetwork);
+
+	//update wireless mode
+	update_wireless_mode(rtlpriv);
+
+	//udpate capability
+	caps = rtw_get_capability((WLAN_BSSID_EX *)pnetwork);
+	update_capinfo(rtlpriv, caps);
+	if(caps&cap_IBSS)//adhoc master
+	{
+		//set_opmode_cmd(rtlpriv, adhoc);//removed
+
+		val8 = 0xcf;
+		rtlpriv->cfg->ops->set_hw_reg(rtlpriv, HW_VAR_SEC_CFG, (uint8_t *)(&val8));
+
+		//switch channel
+		//SelectChannel(rtlpriv, pmlmeext->cur_channel, HAL_PRIME_CHNL_OFFSET_DONT_CARE);
+		set_channel_bwmode(rtlpriv, pmlmeext->cur_channel, HAL_PRIME_CHNL_OFFSET_DONT_CARE, CHANNEL_WIDTH_20);
+
+		beacon_timing_control(rtlpriv);
+
+		//set msr to WIFI_FW_ADHOC_STATE
+		pmlmeinfo->state = WIFI_FW_ADHOC_STATE;
+		Set_MSR(rtlpriv, (pmlmeinfo->state & 0x3));
+
+		//issue beacon
+		if(send_beacon(rtlpriv)==_FAIL)
+		{
+			report_join_res(rtlpriv, -1);
+			pmlmeinfo->state = WIFI_FW_NULL_STATE;
+		}
+		else
+		{
+			rtlpriv->cfg->ops->set_hw_reg(rtlpriv, HW_VAR_BSSID, rtlpriv->registrypriv.dev_network.MacAddress);
+			join_type = 0;
+			rtlpriv->cfg->ops->set_hw_reg(rtlpriv, HW_VAR_MLME_JOIN, (uint8_t *)(&join_type));
+
+			report_join_res(rtlpriv, 1);
+			pmlmeinfo->state |= WIFI_FW_ASSOC_SUCCESS;
+		}
+	}
+	else
+	{
+		DBG_871X("start_create_ibss, invalid cap:%x\n", caps);
+		return;
+	}
+
+}
+
+void start_clnt_join(struct rtl_priv* rtlpriv)
+{
+	struct rtl_mac *mac = rtl_mac(rtlpriv);
+	unsigned short	caps;
+	uint8_t	val8;
+	struct mlme_ext_priv	*pmlmeext = &rtlpriv->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	WLAN_BSSID_EX		*pnetwork = (WLAN_BSSID_EX*)(&(pmlmeinfo->network));
+	int beacon_timeout;
+
+	pmlmeext->cur_channel = (uint8_t)pnetwork->Configuration.DSConfig;
+	mac->beacon_interval = get_beacon_interval(pnetwork);
+
+	//switch channel
+	set_channel_bwmode(rtlpriv, pmlmeext->cur_channel, pmlmeext->cur_ch_offset, pmlmeext->cur_bwmode);
+
+	//update wireless mode
+	update_wireless_mode(rtlpriv);
+
+	//udpate capability
+	caps = rtw_get_capability((WLAN_BSSID_EX *)pnetwork);
+	update_capinfo(rtlpriv, caps);
+	if (caps&cap_ESS)
+	{
+		Set_MSR(rtlpriv, WIFI_FW_STATION_STATE);
+
+		val8 = (pmlmeinfo->auth_algo == dot11AuthAlgrthm_8021X)? 0xcc: 0xcf;
+
+		rtlpriv->cfg->ops->set_hw_reg(rtlpriv, HW_VAR_SEC_CFG, (uint8_t *)(&val8));
+
+		//switch channel
+		//set_channel_bwmode(rtlpriv, pmlmeext->cur_channel, pmlmeext->cur_ch_offset, pmlmeext->cur_bwmode);
+
+		//here wait for receiving the beacon to start auth
+		//and enable a timer
+		beacon_timeout = decide_wait_for_beacon_timeout(mac->beacon_interval);
+		set_link_timer(pmlmeext, beacon_timeout);
+		_set_timer( &rtlpriv->mlmepriv.assoc_timer,
+			(REAUTH_TO * REAUTH_LIMIT) + (REASSOC_TO*REASSOC_LIMIT) +beacon_timeout);
+
+		pmlmeinfo->state = WIFI_FW_AUTH_NULL | WIFI_FW_STATION_STATE;
+	}
+	else if (caps&cap_IBSS) //adhoc client
+	{
+		Set_MSR(rtlpriv, WIFI_FW_ADHOC_STATE);
+
+		val8 = 0xcf;
+		rtlpriv->cfg->ops->set_hw_reg(rtlpriv, HW_VAR_SEC_CFG, (uint8_t *)(&val8));
+
+		//switch channel
+		set_channel_bwmode(rtlpriv, pmlmeext->cur_channel, pmlmeext->cur_ch_offset, pmlmeext->cur_bwmode);
+
+		beacon_timing_control(rtlpriv);
+
+		pmlmeinfo->state = WIFI_FW_ADHOC_STATE;
+
+		report_join_res(rtlpriv, 1);
+	}
+	else
+	{
+		//DBG_871X("marc: invalid cap:%x\n", caps);
+		return;
+	}
+
+}
+
+void start_clnt_auth(struct rtl_priv* rtlpriv)
+{
+	struct mlme_ext_priv	*pmlmeext = &rtlpriv->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	del_timer_sync_ex(&pmlmeext->link_timer);
+
+	pmlmeinfo->state &= (~WIFI_FW_AUTH_NULL);
+	pmlmeinfo->state |= WIFI_FW_AUTH_STATE;
+
+	pmlmeinfo->auth_seq = 1;
+	pmlmeinfo->reauth_count = 0;
+	pmlmeinfo->reassoc_count = 0;
+	pmlmeinfo->link_count = 0;
+	pmlmeext->retry = 0;
+
+
+	// Because of AP's not receiving deauth before
+	// AP may: 1)not response auth or 2)deauth us after link is complete
+	// issue deauth before issuing auth to deal with the situation
+	//	Commented by Albert 2012/07/21
+	//	For the Win8 P2P connection, it will be hard to have a successful connection if this Wi-Fi doesn't connect to it.
+	issue_deauth(rtlpriv, (&(pmlmeinfo->network))->MacAddress, WLAN_REASON_DEAUTH_LEAVING);
+
+	DBG_871X_LEVEL(_drv_always_, "start auth\n");
+	issue_auth(rtlpriv, NULL, 0);
+
+	set_link_timer(pmlmeext, REAUTH_TO);
+
+}
+
+
+void start_clnt_assoc(struct rtl_priv* rtlpriv)
+{
+	struct mlme_ext_priv	*pmlmeext = &rtlpriv->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	del_timer_sync_ex(&pmlmeext->link_timer);
+
+	pmlmeinfo->state &= (~(WIFI_FW_AUTH_NULL | WIFI_FW_AUTH_STATE));
+	pmlmeinfo->state |= (WIFI_FW_AUTH_SUCCESS | WIFI_FW_ASSOC_STATE);
+
+	issue_assocreq(rtlpriv);
+
+	set_link_timer(pmlmeext, REASSOC_TO);
+}
+
+unsigned int receive_disconnect(struct rtl_priv *rtlpriv, unsigned char *MacAddr, unsigned short reason)
+{
+	struct mlme_ext_priv	*pmlmeext = &rtlpriv->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	//check A3
+	if (!(_rtw_memcmp(MacAddr, get_my_bssid(&pmlmeinfo->network), ETH_ALEN)))
+		return _SUCCESS;
+
+	DBG_871X("%s\n", __FUNCTION__);
+
+	if((pmlmeinfo->state&0x03) == WIFI_FW_STATION_STATE)
+	{
+		if (pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS)
+		{
+			pmlmeinfo->state = WIFI_FW_NULL_STATE;
+			report_del_sta_event(rtlpriv, MacAddr, reason);
+
+		}
+		else if (pmlmeinfo->state & WIFI_FW_LINKING_STATE)
+		{
+			pmlmeinfo->state = WIFI_FW_NULL_STATE;
+			report_join_res(rtlpriv, -2);
+		}
+	}
+
+	return _SUCCESS;
+}
+
+
+/****************************************************************************
+
+Following are the functions to report events
+
+*****************************************************************************/
+
+void report_survey_event(struct rtl_priv *rtlpriv, struct recv_frame *precv_frame)
+{
+	struct cmd_obj *pcmd_obj;
+	uint8_t	*pevtcmd;
+	uint32_t	 cmdsz;
+	struct survey_event	*psurvey_evt;
+	struct C2HEvent_Header *pc2h_evt_hdr;
+	struct mlme_ext_priv *pmlmeext;
+	struct cmd_priv *pcmdpriv;
+	//uint8_t *pframe = precv_frame->u.hdr.rx_data;
+	//uint len = precv_frame->u.hdr.len;
+
+	if(!rtlpriv)
+		return;
+
+	pmlmeext = &rtlpriv->mlmeextpriv;
+	pcmdpriv = &rtlpriv->cmdpriv;
+
+
+	if ((pcmd_obj = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj))) == NULL)
+	{
+		return;
+	}
+
+	cmdsz = (sizeof(struct survey_event) + sizeof(struct C2HEvent_Header));
+	if ((pevtcmd = (uint8_t *)rtw_zmalloc(cmdsz)) == NULL)
+	{
+		rtw_mfree(pcmd_obj);
+		return;
+	}
+
+	INIT_LIST_HEAD(&pcmd_obj->list);
+
+	pcmd_obj->cmdcode = GEN_CMD_CODE(_Set_MLME_EVT);
+	pcmd_obj->cmdsz = cmdsz;
+	pcmd_obj->parmbuf = pevtcmd;
+
+	pcmd_obj->rsp = NULL;
+	pcmd_obj->rspsz  = 0;
+
+	pc2h_evt_hdr = (struct C2HEvent_Header*)(pevtcmd);
+	pc2h_evt_hdr->len = sizeof(struct survey_event);
+	pc2h_evt_hdr->ID = GEN_EVT_CODE(_Survey);
+	pc2h_evt_hdr->seq = atomic_inc_return(&pmlmeext->event_seq);
+
+	psurvey_evt = (struct survey_event*)(pevtcmd + sizeof(struct C2HEvent_Header));
+
+	if (collect_bss_info(rtlpriv, precv_frame, (WLAN_BSSID_EX *)&psurvey_evt->bss) == _FAIL)
+	{
+		/* ULLI check usage of cmdsz */
+
+		rtw_mfree(pcmd_obj);
+		rtw_mfree(pevtcmd);
+		return;
+	}
+
+	rtw_enqueue_cmd(pcmdpriv, pcmd_obj);
+
+	pmlmeext->sitesurvey_res.bss_cnt++;
+
+	return;
+
+}
+
+void report_surveydone_event(struct rtl_priv *rtlpriv)
+{
+	struct cmd_obj *pcmd_obj;
+	uint8_t	*pevtcmd;
+	uint32_t	 cmdsz;
+	struct surveydone_event *psurveydone_evt;
+	struct C2HEvent_Header	*pc2h_evt_hdr;
+	struct mlme_ext_priv		*pmlmeext = &rtlpriv->mlmeextpriv;
+	struct cmd_priv *pcmdpriv = &rtlpriv->cmdpriv;
+
+	if ((pcmd_obj = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj))) == NULL)
+	{
+		return;
+	}
+
+	cmdsz = (sizeof(struct surveydone_event) + sizeof(struct C2HEvent_Header));
+	if ((pevtcmd = (uint8_t *)rtw_zmalloc(cmdsz)) == NULL)
+	{
+		rtw_mfree(pcmd_obj);
+		return;
+	}
+
+	INIT_LIST_HEAD(&pcmd_obj->list);
+
+	pcmd_obj->cmdcode = GEN_CMD_CODE(_Set_MLME_EVT);
+	pcmd_obj->cmdsz = cmdsz;
+	pcmd_obj->parmbuf = pevtcmd;
+
+	pcmd_obj->rsp = NULL;
+	pcmd_obj->rspsz  = 0;
+
+	pc2h_evt_hdr = (struct C2HEvent_Header*)(pevtcmd);
+	pc2h_evt_hdr->len = sizeof(struct surveydone_event);
+	pc2h_evt_hdr->ID = GEN_EVT_CODE(_SurveyDone);
+	pc2h_evt_hdr->seq = atomic_inc_return(&pmlmeext->event_seq);
+
+	psurveydone_evt = (struct surveydone_event*)(pevtcmd + sizeof(struct C2HEvent_Header));
+	psurveydone_evt->bss_cnt = pmlmeext->sitesurvey_res.bss_cnt;
+
+	DBG_871X("survey done event(%x)\n", psurveydone_evt->bss_cnt);
+
+	rtw_enqueue_cmd(pcmdpriv, pcmd_obj);
+
+	return;
+
+}
+
+void report_join_res(struct rtl_priv *rtlpriv, int res)
+{
+	struct cmd_obj *pcmd_obj;
+	uint8_t	*pevtcmd;
+	uint32_t	 cmdsz;
+	struct joinbss_event		*pjoinbss_evt;
+	struct C2HEvent_Header	*pc2h_evt_hdr;
+	struct mlme_ext_priv		*pmlmeext = &rtlpriv->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct cmd_priv *pcmdpriv = &rtlpriv->cmdpriv;
+
+	if ((pcmd_obj = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj))) == NULL)
+	{
+		return;
+	}
+
+	cmdsz = (sizeof(struct joinbss_event) + sizeof(struct C2HEvent_Header));
+	if ((pevtcmd = (uint8_t *)rtw_zmalloc(cmdsz)) == NULL)
+	{
+		rtw_mfree(pcmd_obj);
+		return;
+	}
+
+	INIT_LIST_HEAD(&pcmd_obj->list);
+
+	pcmd_obj->cmdcode = GEN_CMD_CODE(_Set_MLME_EVT);
+	pcmd_obj->cmdsz = cmdsz;
+	pcmd_obj->parmbuf = pevtcmd;
+
+	pcmd_obj->rsp = NULL;
+	pcmd_obj->rspsz  = 0;
+
+	pc2h_evt_hdr = (struct C2HEvent_Header*)(pevtcmd);
+	pc2h_evt_hdr->len = sizeof(struct joinbss_event);
+	pc2h_evt_hdr->ID = GEN_EVT_CODE(_JoinBss);
+	pc2h_evt_hdr->seq = atomic_inc_return(&pmlmeext->event_seq);
+
+	pjoinbss_evt = (struct joinbss_event*)(pevtcmd + sizeof(struct C2HEvent_Header));
+	memcpy((unsigned char *)(&(pjoinbss_evt->network.network)), &(pmlmeinfo->network), sizeof(WLAN_BSSID_EX));
+	pjoinbss_evt->network.join_res 	= pjoinbss_evt->network.aid = res;
+
+	DBG_871X("report_join_res(%d)\n", res);
+
+
+	rtw_joinbss_event_prehandle(rtlpriv, (uint8_t *)&pjoinbss_evt->network);
+
+
+	rtw_enqueue_cmd(pcmdpriv, pcmd_obj);
+
+	return;
+
+}
+
+void report_del_sta_event(struct rtl_priv *rtlpriv, unsigned char* MacAddr, unsigned short reason)
+{
+	struct cmd_obj *pcmd_obj;
+	uint8_t	*pevtcmd;
+	uint32_t	 cmdsz;
+	struct sta_info *psta;
+	int	mac_id;
+	struct stadel_event			*pdel_sta_evt;
+	struct C2HEvent_Header	*pc2h_evt_hdr;
+	struct mlme_ext_priv		*pmlmeext = &rtlpriv->mlmeextpriv;
+	struct cmd_priv *pcmdpriv = &rtlpriv->cmdpriv;
+
+	if ((pcmd_obj = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj))) == NULL)
+	{
+		return;
+	}
+
+	cmdsz = (sizeof(struct stadel_event) + sizeof(struct C2HEvent_Header));
+	if ((pevtcmd = (uint8_t *)rtw_zmalloc(cmdsz)) == NULL)
+	{
+		rtw_mfree(pcmd_obj);
+		return;
+	}
+
+	INIT_LIST_HEAD(&pcmd_obj->list);
+
+	pcmd_obj->cmdcode = GEN_CMD_CODE(_Set_MLME_EVT);
+	pcmd_obj->cmdsz = cmdsz;
+	pcmd_obj->parmbuf = pevtcmd;
+
+	pcmd_obj->rsp = NULL;
+	pcmd_obj->rspsz  = 0;
+
+	pc2h_evt_hdr = (struct C2HEvent_Header*)(pevtcmd);
+	pc2h_evt_hdr->len = sizeof(struct stadel_event);
+	pc2h_evt_hdr->ID = GEN_EVT_CODE(_DelSTA);
+	pc2h_evt_hdr->seq = atomic_inc_return(&pmlmeext->event_seq);
+
+	pdel_sta_evt = (struct stadel_event*)(pevtcmd + sizeof(struct C2HEvent_Header));
+	memcpy((unsigned char *)(&(pdel_sta_evt->macaddr)), MacAddr, ETH_ALEN);
+	memcpy((unsigned char *)(pdel_sta_evt->rsvd),(unsigned char *)(&reason),2);
+
+
+	psta = rtw_get_stainfo(&rtlpriv->stapriv, MacAddr);
+	if(psta)
+		mac_id = (int)psta->mac_id;
+	else
+		mac_id = (-1);
+
+	pdel_sta_evt->mac_id = mac_id;
+
+	DBG_871X("report_del_sta_event: delete STA, mac_id=%d\n", mac_id);
+
+	rtw_enqueue_cmd(pcmdpriv, pcmd_obj);
+
+	return;
+}
+
+void report_add_sta_event(struct rtl_priv *rtlpriv, unsigned char* MacAddr, int cam_idx)
+{
+	struct cmd_obj *pcmd_obj;
+	uint8_t	*pevtcmd;
+	uint32_t	 cmdsz;
+	struct stassoc_event		*padd_sta_evt;
+	struct C2HEvent_Header	*pc2h_evt_hdr;
+	struct mlme_ext_priv		*pmlmeext = &rtlpriv->mlmeextpriv;
+	struct cmd_priv *pcmdpriv = &rtlpriv->cmdpriv;
+
+	if ((pcmd_obj = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj))) == NULL)
+	{
+		return;
+	}
+
+	cmdsz = (sizeof(struct stassoc_event) + sizeof(struct C2HEvent_Header));
+	if ((pevtcmd = (uint8_t *)rtw_zmalloc(cmdsz)) == NULL)
+	{
+		rtw_mfree(pcmd_obj);
+		return;
+	}
+
+	INIT_LIST_HEAD(&pcmd_obj->list);
+
+	pcmd_obj->cmdcode = GEN_CMD_CODE(_Set_MLME_EVT);
+	pcmd_obj->cmdsz = cmdsz;
+	pcmd_obj->parmbuf = pevtcmd;
+
+	pcmd_obj->rsp = NULL;
+	pcmd_obj->rspsz  = 0;
+
+	pc2h_evt_hdr = (struct C2HEvent_Header*)(pevtcmd);
+	pc2h_evt_hdr->len = sizeof(struct stassoc_event);
+	pc2h_evt_hdr->ID = GEN_EVT_CODE(_AddSTA);
+	pc2h_evt_hdr->seq = atomic_inc_return(&pmlmeext->event_seq);
+
+	padd_sta_evt = (struct stassoc_event*)(pevtcmd + sizeof(struct C2HEvent_Header));
+	memcpy((unsigned char *)(&(padd_sta_evt->macaddr)), MacAddr, ETH_ALEN);
+	padd_sta_evt->cam_id = cam_idx;
+
+	DBG_871X("report_add_sta_event: add STA\n");
+
+	rtw_enqueue_cmd(pcmdpriv, pcmd_obj);
+
+	return;
+}
+
+
+/****************************************************************************
+
+Following are the event callback functions
+
+*****************************************************************************/
+
+//for sta/adhoc mode
+void update_sta_info(struct rtl_priv *rtlpriv, struct sta_info *psta)
+{
+	struct mlme_priv *pmlmepriv = &(rtlpriv->mlmepriv);
+	struct mlme_ext_priv	*pmlmeext = &rtlpriv->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	//ERP
+	VCS_update(rtlpriv, psta);
+
+	//HT
+	if(pmlmepriv->htpriv.ht_option)
+	{
+		psta->htpriv.ht_option = true;
+
+		psta->htpriv.ampdu_enable = pmlmepriv->htpriv.ampdu_enable;
+
+		if (support_short_GI(rtlpriv, &(pmlmeinfo->HT_caps)))
+			psta->htpriv.sgi = true;
+
+		psta->qos_option = true;
+
+	}
+	else
+	{
+		psta->htpriv.ht_option = false;
+
+		psta->htpriv.ampdu_enable = false;
+
+		psta->htpriv.sgi = false;
+		psta->qos_option = false;
+
+	}
+	psta->htpriv.bwmode = pmlmeext->cur_bwmode;
+	psta->htpriv.ch_offset = pmlmeext->cur_ch_offset;
+
+	psta->htpriv.agg_enable_bitmap = 0x0;//reset
+	psta->htpriv.candidate_tid_bitmap = 0x0;//reset
+
+	//QoS
+	if(pmlmepriv->qospriv.qos_option)
+		psta->qos_option = true;
+
+	if (pmlmepriv->vhtpriv.vht_bwmode < CHANNEL_WIDTH_80)
+		pmlmepriv->vhtpriv.sgi = psta->htpriv.sgi;
+	memcpy(&psta->vhtpriv, &pmlmepriv->vhtpriv, sizeof(struct vht_priv));
+
+	spin_lock_bh(&psta->lock);
+	psta->state = _FW_LINKED;
+	spin_unlock_bh(&psta->lock);
+
+}
+
+void mlmeext_joinbss_event_callback(struct rtl_priv *rtlpriv, int join_res)
+{
+	struct rtl_mac *mac = rtl_mac(rtlpriv);
+	struct sta_info		*psta, *psta_bmc;
+	struct mlme_ext_priv	*pmlmeext = &rtlpriv->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	WLAN_BSSID_EX 		*cur_network = &(pmlmeinfo->network);
+	struct sta_priv		*pstapriv = &rtlpriv->stapriv;
+	uint8_t	join_type;
+	u16 media_status;
+
+	if(join_res < 0)
+	{
+		join_type = 1;
+		rtlpriv->cfg->ops->set_hw_reg(rtlpriv, HW_VAR_MLME_JOIN, (uint8_t *)(&join_type));
+		rtlpriv->cfg->ops->set_hw_reg(rtlpriv, HW_VAR_BSSID, null_addr);
+
+		goto exit_mlmeext_joinbss_event_callback;
+	}
+
+	if((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE)
+	{
+		//for bc/mc
+		psta_bmc = rtw_get_bcmc_stainfo(rtlpriv);
+		if(psta_bmc)
+		{
+			pmlmeinfo->FW_sta_info[psta_bmc->mac_id].psta = psta_bmc;
+			update_bmc_sta_support_rate(rtlpriv, psta_bmc->mac_id);
+			Update_RA_Entry(rtlpriv, psta_bmc);
+		}
+	}
+
+	// update IOT-releated issue
+	update_IOT_info(rtlpriv);
+
+	rtlpriv->cfg->ops->set_hw_reg(rtlpriv, HW_VAR_BASIC_RATE, cur_network->SupportedRates);
+
+	//BCN interval
+	rtlpriv->cfg->ops->set_hw_reg(rtlpriv, HW_VAR_BEACON_INTERVAL, (uint8_t *)(&mac->beacon_interval));
+
+	//udpate capability
+	update_capinfo(rtlpriv, pmlmeinfo->capability);
+
+	//WMM, Update EDCA param
+	WMMOnAssocRsp(rtlpriv);
+
+	//HT
+	HTOnAssocRsp(rtlpriv);
+
+	//VHT
+	VHTOnAssocRsp(rtlpriv);
+
+	psta = rtw_get_stainfo(pstapriv, cur_network->MacAddress);
+	if (psta) //only for infra. mode
+	{
+		pmlmeinfo->FW_sta_info[psta->mac_id].psta = psta;
+
+		//DBG_871X("set_sta_rate\n");
+
+		psta->wireless_mode = pmlmeext->cur_wireless_mode;
+
+		//set per sta rate after updating HT cap.
+		set_sta_rate(rtlpriv, psta);
+
+		#if (RATE_ADAPTIVE_SUPPORT==1)	//for 88E RA
+		rtlpriv->cfg->ops->set_hw_reg(rtlpriv,HW_VAR_TX_RPT_MAX_MACID, (uint8_t *)&psta->mac_id);
+		#endif
+		media_status = (psta->mac_id<<8)|1; //  MACID|OPMODE: 1 means connect
+		rtlpriv->cfg->ops->set_hw_reg(rtlpriv,HW_VAR_H2C_MEDIA_STATUS_RPT,(uint8_t *)&media_status);
+	}
+
+	join_type = 2;
+	rtlpriv->cfg->ops->set_hw_reg(rtlpriv, HW_VAR_MLME_JOIN, (uint8_t *)(&join_type));
+
+	if((pmlmeinfo->state&0x03) == WIFI_FW_STATION_STATE)
+	{
+		// correcting TSF
+		correct_TSF(rtlpriv, pmlmeext);
+
+		//set_link_timer(pmlmeext, DISCONNECT_TO);
+	}
+
+		rtw_lps_ctrl_wk_cmd(rtlpriv, LPS_CTRL_CONNECT, 0);
+
+exit_mlmeext_joinbss_event_callback:
+
+
+	DBG_871X("=>%s\n", __FUNCTION__);
+
+}
+
+//currently only adhoc mode will go here
+void mlmeext_sta_add_event_callback(struct rtl_priv *rtlpriv, struct sta_info *psta)
+{
+	struct mlme_ext_priv	*pmlmeext = &(rtlpriv->mlmeextpriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	uint8_t	join_type;
+
+	DBG_871X("%s\n", __FUNCTION__);
+
+	if((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE)
+	{
+		if(pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS)//adhoc master or sta_count>1
+		{
+			//nothing to do
+		}
+		else//adhoc client
+		{
+			//update TSF Value
+			//update_TSF(pmlmeext, pframe, len);
+
+			// correcting TSF
+			correct_TSF(rtlpriv, pmlmeext);
+
+			//start beacon
+			if(send_beacon(rtlpriv)==_FAIL)
+			{
+				pmlmeinfo->FW_sta_info[psta->mac_id].status = 0;
+
+				pmlmeinfo->state ^= WIFI_FW_ADHOC_STATE;
+
+				return;
+			}
+
+			pmlmeinfo->state |= WIFI_FW_ASSOC_SUCCESS;
+
+		}
+
+		join_type = 2;
+		rtlpriv->cfg->ops->set_hw_reg(rtlpriv, HW_VAR_MLME_JOIN, (uint8_t *)(&join_type));
+	}
+
+	pmlmeinfo->FW_sta_info[psta->mac_id].psta = psta;
+
+	//rate radaptive
+	Update_RA_Entry(rtlpriv, psta);
+
+	//update adhoc sta_info
+	update_sta_info(rtlpriv, psta);
+
+}
+
+void mlmeext_sta_del_event_callback(struct rtl_priv *rtlpriv)
+{
+	struct mlme_ext_priv	*pmlmeext = &rtlpriv->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	if (is_client_associated_to_ap(rtlpriv) || is_IBSS_empty(rtlpriv))
+	{
+		//set_opmode_cmd(rtlpriv, infra_client_with_mlme);
+
+		rtlpriv->cfg->ops->set_hw_reg(rtlpriv, HW_VAR_MLME_DISCONNECT, 0);
+		rtlpriv->cfg->ops->set_hw_reg(rtlpriv, HW_VAR_BSSID, null_addr);
+
+
+		//switch to the 20M Hz mode after disconnect
+		pmlmeext->cur_bwmode = CHANNEL_WIDTH_20;
+		pmlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
+
+		//SelectChannel(rtlpriv, pmlmeext->cur_channel, pmlmeext->cur_ch_offset);
+		set_channel_bwmode(rtlpriv, pmlmeext->cur_channel, pmlmeext->cur_ch_offset, pmlmeext->cur_bwmode);
+
+
+		flush_all_cam_entry(rtlpriv);
+
+		pmlmeinfo->state = WIFI_FW_NULL_STATE;
+
+		//set MSR to no link state -> infra. mode
+		Set_MSR(rtlpriv, _HW_STATE_STATION_);
+
+		del_timer_sync_ex(&pmlmeext->link_timer);
+
+	}
+
+}
+
+/****************************************************************************
+
+Following are the functions for the timer handlers
+
+*****************************************************************************/
+void _linked_info_dump(struct rtl_priv *rtlpriv);
+void _linked_info_dump(struct rtl_priv *rtlpriv)
+{
+	struct mlme_ext_priv    *pmlmeext = &rtlpriv->mlmeextpriv;
+      struct mlme_ext_info    *pmlmeinfo = &(pmlmeext->mlmext_info);
+	uint8_t mac_id;
+	int UndecoratedSmoothedPWDB;
+
+	if((pmlmeinfo->state&0x03) == WIFI_FW_STATION_STATE)
+	{
+		mac_id=0;
+	}
+	else if((pmlmeinfo->state&0x03) == _HW_STATE_AP_)
+	{
+		mac_id=2;
+	}
+}
+
+uint8_t chk_ap_is_alive(struct rtl_priv *rtlpriv, struct sta_info *psta)
+{
+	uint8_t ret = false;
+	struct mlme_ext_priv	*pmlmeext = &rtlpriv->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	#ifdef DBG_EXPIRATION_CHK
+	DBG_871X(FUNC_ADPT_FMT" rx:"STA_PKTS_FMT", beacon:%llu, probersp_to_self:%llu"
+				/*", probersp_bm:%llu, probersp_uo:%llu, probereq:%llu, BI:%u"*/
+				", retry:%u\n"
+		, FUNC_ADPT_ARG(rtlpriv)
+		, STA_RX_PKTS_DIFF_ARG(psta)
+		, psta->sta_stats.rx_beacon_pkts - psta->sta_stats.last_rx_beacon_pkts
+		, psta->sta_stats.rx_probersp_pkts - psta->sta_stats.last_rx_probersp_pkts
+		/*, psta->sta_stats.rx_probersp_bm_pkts - psta->sta_stats.last_rx_probersp_bm_pkts
+		, psta->sta_stats.rx_probersp_uo_pkts - psta->sta_stats.last_rx_probersp_uo_pkts
+		, psta->sta_stats.rx_probereq_pkts - psta->sta_stats.last_rx_probereq_pkts
+		, pmlmeinfo->bcn_interval*/
+		, pmlmeext->retry
+	);
+
+	DBG_871X(FUNC_ADPT_FMT" tx_pkts:%llu, link_count:%u\n", FUNC_ADPT_ARG(rtlpriv)
+		, rtlpriv->xmitpriv.tx_pkts
+		, pmlmeinfo->link_count
+	);
+	#endif
+
+	if((sta_rx_data_pkts(psta) == sta_last_rx_data_pkts(psta))
+		&& sta_rx_beacon_pkts(psta) == sta_last_rx_beacon_pkts(psta)
+		&& sta_rx_probersp_pkts(psta) == sta_last_rx_probersp_pkts(psta)
+	)
+	{
+		ret = false;
+	}
+	else
+	{
+		ret = true;
+	}
+
+	sta_update_last_rx_pkts(psta);
+
+	return ret;
+}
+
+void linked_status_chk(struct rtl_priv *rtlpriv)
+{
+	uint32_t	i;
+	struct sta_info		*psta;
+	struct xmit_priv		*pxmitpriv = &(rtlpriv->xmitpriv);
+	struct mlme_ext_priv	*pmlmeext = &rtlpriv->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct sta_priv		*pstapriv = &rtlpriv->stapriv;
+
+	 _linked_info_dump(rtlpriv);
+
+	if (is_client_associated_to_ap(rtlpriv))
+	{
+		//linked infrastructure client mode
+
+		int tx_chk = _SUCCESS, rx_chk = _SUCCESS;
+		int rx_chk_limit;
+
+		#if defined(DBG_ROAMING_TEST)
+		rx_chk_limit = 1;
+		#else
+		rx_chk_limit = 8;
+		#endif
+
+		if ((psta = rtw_get_stainfo(pstapriv, pmlmeinfo->network.MacAddress)) != NULL)
+		{
+			bool is_p2p_enable = false;
+
+			if (chk_ap_is_alive(rtlpriv, psta) == false)
+				rx_chk = _FAIL;
+
+			if (pxmitpriv->last_tx_pkts == pxmitpriv->tx_pkts)
+				tx_chk = _FAIL;
+
+			{
+				if (rx_chk != _SUCCESS) {
+					if (pmlmeext->retry == 0) {
+						#ifdef DBG_EXPIRATION_CHK
+						DBG_871X("issue_probereq to trigger probersp, retry=%d\n", pmlmeext->retry);
+						#endif
+						issue_probereq(rtlpriv, &pmlmeinfo->network.Ssid, pmlmeinfo->network.MacAddress);
+						issue_probereq(rtlpriv, &pmlmeinfo->network.Ssid, pmlmeinfo->network.MacAddress);
+						issue_probereq(rtlpriv, &pmlmeinfo->network.Ssid, pmlmeinfo->network.MacAddress);
+					}
+				}
+
+				if (tx_chk != _SUCCESS && pmlmeinfo->link_count++ == 0xf) {
+					#ifdef DBG_EXPIRATION_CHK
+					DBG_871X("%s issue_nulldata 0\n", __FUNCTION__);
+					#endif
+					tx_chk = issue_nulldata(rtlpriv, NULL, 0, 1, 0);
+				}
+			}
+
+			if (rx_chk == _FAIL) {
+				pmlmeext->retry++;
+				if (pmlmeext->retry > rx_chk_limit) {
+					DBG_871X_LEVEL(_drv_always_, FUNC_ADPT_FMT" disconnect or roaming\n",
+						FUNC_ADPT_ARG(rtlpriv));
+					receive_disconnect(rtlpriv, pmlmeinfo->network.MacAddress
+						, WLAN_REASON_EXPIRATION_CHK);
+					return;
+				}
+			} else {
+				pmlmeext->retry = 0;
+			}
+
+			if (tx_chk == _FAIL) {
+				pmlmeinfo->link_count &= 0xf;
+			} else {
+				pxmitpriv->last_tx_pkts = pxmitpriv->tx_pkts;
+				pmlmeinfo->link_count = 0;
+			}
+
+		} //end of if ((psta = rtw_get_stainfo(pstapriv, passoc_res->network.MacAddress)) != NULL)
+	}
+	else if (is_client_associated_to_ibss(rtlpriv))
+	{
+		//linked IBSS mode
+		//for each assoc list entry to check the rx pkt counter
+		for (i = IBSS_START_MAC_ID; i < NUM_STA; i++)
+		{
+			if (pmlmeinfo->FW_sta_info[i].status == 1)
+			{
+				psta = pmlmeinfo->FW_sta_info[i].psta;
+
+				if(NULL==psta) continue;
+
+				if (pmlmeinfo->FW_sta_info[i].rx_pkt == sta_rx_pkts(psta))
+				{
+
+					if(pmlmeinfo->FW_sta_info[i].retry<3)
+					{
+						pmlmeinfo->FW_sta_info[i].retry++;
+					}
+					else
+					{
+						pmlmeinfo->FW_sta_info[i].retry = 0;
+						pmlmeinfo->FW_sta_info[i].status = 0;
+						report_del_sta_event(rtlpriv, psta->hwaddr
+							, 65535// indicate disconnect caused by no rx
+						);
+					}
+				}
+				else
+				{
+					pmlmeinfo->FW_sta_info[i].retry = 0;
+					pmlmeinfo->FW_sta_info[i].rx_pkt = (uint32_t)sta_rx_pkts(psta);
+				}
+			}
+		}
+
+		//set_link_timer(pmlmeext, DISCONNECT_TO);
+
+	}
+
+}
+
+void survey_timer_hdl(struct rtl_priv *rtlpriv)
+{
+	struct cmd_obj	*ph2c;
+	struct sitesurvey_parm	*psurveyPara;
+	struct cmd_priv					*pcmdpriv=&rtlpriv->cmdpriv;
+	struct mlme_ext_priv 		*pmlmeext = &rtlpriv->mlmeextpriv;
+
+	//DBG_871X("marc: survey timer\n");
+
+	//issue rtw_sitesurvey_cmd
+	if (pmlmeext->sitesurvey_res.state > SCAN_START)
+	{
+		if(pmlmeext->sitesurvey_res.state ==  SCAN_PROCESS)
+		{
+				pmlmeext->sitesurvey_res.channel_idx++;
+		}
+
+		if(pmlmeext->scan_abort == true)
+		{
+			{
+				pmlmeext->sitesurvey_res.channel_idx = pmlmeext->sitesurvey_res.ch_num;
+				DBG_871X("%s idx:%d\n", __FUNCTION__
+					, pmlmeext->sitesurvey_res.channel_idx
+				);
+			}
+
+			pmlmeext->scan_abort = false;//reset
+		}
+
+		if ((ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj))) == NULL)
+		{
+			goto exit_survey_timer_hdl;
+		}
+
+		if ((psurveyPara = (struct sitesurvey_parm*)rtw_zmalloc(sizeof(struct sitesurvey_parm))) == NULL)
+		{
+			rtw_mfree(ph2c);
+			goto exit_survey_timer_hdl;
+		}
+
+		init_h2fwcmd_w_parm_no_rsp(ph2c, psurveyPara, GEN_CMD_CODE(_SiteSurvey));
+		rtw_enqueue_cmd(pcmdpriv, ph2c);
+	}
+
+
+exit_survey_timer_hdl:
+
+	return;
+}
+
+void link_timer_hdl(struct rtl_priv *rtlpriv)
+{
+	//static unsigned int		rx_pkt = 0;
+	//static u64				tx_cnt = 0;
+	//struct xmit_priv		*pxmitpriv = &(rtlpriv->xmitpriv);
+	struct mlme_ext_priv	*pmlmeext = &rtlpriv->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	//struct sta_priv		*pstapriv = &rtlpriv->stapriv;
+
+
+	if (pmlmeinfo->state & WIFI_FW_AUTH_NULL)
+	{
+		DBG_871X("link_timer_hdl:no beacon while connecting\n");
+		pmlmeinfo->state = WIFI_FW_NULL_STATE;
+		report_join_res(rtlpriv, -3);
+	}
+	else if (pmlmeinfo->state & WIFI_FW_AUTH_STATE)
+	{
+		//re-auth timer
+		if (++pmlmeinfo->reauth_count > REAUTH_LIMIT)
+		{
+			//if (pmlmeinfo->auth_algo != dot11AuthAlgrthm_Auto)
+			//{
+				pmlmeinfo->state = 0;
+				report_join_res(rtlpriv, -1);
+				return;
+			//}
+			//else
+			//{
+			//	pmlmeinfo->auth_algo = dot11AuthAlgrthm_Shared;
+			//	pmlmeinfo->reauth_count = 0;
+			//}
+		}
+
+		DBG_871X("link_timer_hdl: auth timeout and try again\n");
+		pmlmeinfo->auth_seq = 1;
+		issue_auth(rtlpriv, NULL, 0);
+		set_link_timer(pmlmeext, REAUTH_TO);
+	}
+	else if (pmlmeinfo->state & WIFI_FW_ASSOC_STATE)
+	{
+		//re-assoc timer
+		if (++pmlmeinfo->reassoc_count > REASSOC_LIMIT)
+		{
+			pmlmeinfo->state = WIFI_FW_NULL_STATE;
+			report_join_res(rtlpriv, -2);
+			return;
+		}
+
+		DBG_871X("link_timer_hdl: assoc timeout and try again\n");
+		issue_assocreq(rtlpriv);
+		set_link_timer(pmlmeext, REASSOC_TO);
+	}
+
+	return;
+}
+
+void addba_timer_hdl(struct sta_info *psta)
+{
+	struct ht_priv	*phtpriv;
+
+	if(!psta)
+		return;
+
+	phtpriv = &psta->htpriv;
+
+	if((phtpriv->ht_option==true) && (phtpriv->ampdu_enable==true))
+	{
+		if(phtpriv->candidate_tid_bitmap)
+			phtpriv->candidate_tid_bitmap=0x0;
+
+	}
+}
+
+uint8_t NULL_hdl(struct rtl_priv *rtlpriv, uint8_t *pbuf)
+{
+	return H2C_SUCCESS;
+}
+
+
+uint8_t setopmode_hdl(struct rtl_priv *rtlpriv, uint8_t *pbuf)
+{
+	uint8_t	type;
+	struct mlme_ext_priv	*pmlmeext = &rtlpriv->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct setopmode_parm *psetop = (struct setopmode_parm *)pbuf;
+
+	if(psetop->mode == Ndis802_11APMode)
+	{
+		pmlmeinfo->state = WIFI_FW_AP_STATE;
+		type = _HW_STATE_AP_;
+	}
+	else if(psetop->mode == Ndis802_11Infrastructure)
+	{
+		pmlmeinfo->state &= ~(BIT(0)|BIT(1));// clear state
+		pmlmeinfo->state |= WIFI_FW_STATION_STATE;//set to 	STATION_STATE
+		type = _HW_STATE_STATION_;
+	}
+	else if(psetop->mode == Ndis802_11IBSS)
+	{
+		type = _HW_STATE_ADHOC_;
+	}
+	else
+	{
+		type = _HW_STATE_NOLINK_;
+	}
+
+	rtlpriv->cfg->ops->set_network_type(rtlpriv, type);
+	//Set_NETYPE0_MSR(rtlpriv, type);
+
+	return H2C_SUCCESS;
+
+}
+
+uint8_t createbss_hdl(struct rtl_priv *rtlpriv, uint8_t *pbuf)
+{
+	struct mlme_ext_priv	*pmlmeext = &rtlpriv->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	WLAN_BSSID_EX	*pnetwork = (WLAN_BSSID_EX*)(&(pmlmeinfo->network));
+	struct joinbss_parm *pparm = (struct joinbss_parm *)pbuf;
+	//uint32_t	initialgain;
+
+
+	if(pparm->network.InfrastructureMode == Ndis802_11APMode)
+	{
+#ifdef CONFIG_AP_MODE
+
+		if(pmlmeinfo->state == WIFI_FW_AP_STATE)
+		{
+			//todo:
+			return H2C_SUCCESS;
+		}
+#endif
+	}
+
+	//below is for ad-hoc master
+	if(pparm->network.InfrastructureMode == Ndis802_11IBSS)
+	{
+		rtw_joinbss_reset(rtlpriv);
+
+		pmlmeext->cur_bwmode = CHANNEL_WIDTH_20;
+		pmlmeext->cur_ch_offset= HAL_PRIME_CHNL_OFFSET_DONT_CARE;
+		pmlmeinfo->ERP_enable = 0;
+		pmlmeinfo->WMM_enable = 0;
+		pmlmeinfo->HT_enable = 0;
+		pmlmeinfo->HT_caps_enable = 0;
+		pmlmeinfo->HT_info_enable = 0;
+		pmlmeinfo->agg_enable_bitmap = 0;
+		pmlmeinfo->candidate_tid_bitmap = 0;
+
+		//config the initial gain under linking, need to write the BB registers
+		//initialgain = 0x1E;
+		//rtlpriv->cfg->ops->set_hw_reg(rtlpriv, HW_VAR_INITIAL_GAIN, (uint8_t *)(&initialgain));
+
+		//cancel link timer
+		del_timer_sync_ex(&pmlmeext->link_timer);
+
+		//clear CAM
+		flush_all_cam_entry(rtlpriv);
+
+		memcpy(pnetwork, pbuf, FIELD_OFFSET(WLAN_BSSID_EX, IELength));
+		pnetwork->IELength = ((WLAN_BSSID_EX *)pbuf)->IELength;
+
+		if(pnetwork->IELength>MAX_IE_SZ)//Check pbuf->IELength
+			return H2C_PARAMETERS_ERROR;
+
+		memcpy(pnetwork->IEs, ((WLAN_BSSID_EX *)pbuf)->IEs, pnetwork->IELength);
+
+		start_create_ibss(rtlpriv);
+
+	}
+
+	return H2C_SUCCESS;
+
+}
+
+uint8_t join_cmd_hdl(struct rtl_priv *rtlpriv, uint8_t *pbuf)
+{
+	uint8_t	join_type;
+	PNDIS_802_11_VARIABLE_IEs	pIE;
+	struct registry_priv	*pregpriv = &rtlpriv->registrypriv;
+	struct mlme_ext_priv	*pmlmeext = &rtlpriv->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	WLAN_BSSID_EX		*pnetwork = (WLAN_BSSID_EX*)(&(pmlmeinfo->network));
+	uint32_t	 i;
+	uint8_t	cbw40_enable=0;
+        //uint32_t	initialgain;
+	//uint32_t	acparm;
+
+	//check already connecting to AP or not
+	if (pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS)
+	{
+		if (pmlmeinfo->state & WIFI_FW_STATION_STATE)
+		{
+			issue_deauth_ex(rtlpriv, pnetwork->MacAddress, WLAN_REASON_DEAUTH_LEAVING, 5, 100);
+		}
+
+		pmlmeinfo->state = WIFI_FW_NULL_STATE;
+
+		//clear CAM
+		flush_all_cam_entry(rtlpriv);
+
+		del_timer_sync_ex(&pmlmeext->link_timer);
+
+		//set MSR to nolink -> infra. mode
+		//Set_MSR(rtlpriv, _HW_STATE_NOLINK_);
+		Set_MSR(rtlpriv, _HW_STATE_STATION_);
+
+
+		rtlpriv->cfg->ops->set_hw_reg(rtlpriv, HW_VAR_MLME_DISCONNECT, 0);
+	}
+
+	rtw_joinbss_reset(rtlpriv);
+
+	pmlmeext->cur_bwmode = CHANNEL_WIDTH_20;
+	pmlmeext->cur_ch_offset= HAL_PRIME_CHNL_OFFSET_DONT_CARE;
+	pmlmeinfo->ERP_enable = 0;
+	pmlmeinfo->WMM_enable = 0;
+	pmlmeinfo->HT_enable = 0;
+	pmlmeinfo->HT_caps_enable = 0;
+	pmlmeinfo->HT_info_enable = 0;
+	pmlmeinfo->agg_enable_bitmap = 0;
+	pmlmeinfo->candidate_tid_bitmap = 0;
+	pmlmeinfo->bwmode_updated = false;
+	//pmlmeinfo->assoc_AP_vendor = HT_IOT_PEER_MAX;
+	pmlmeinfo->VHT_enable = 0;
+
+	memcpy(pnetwork, pbuf, FIELD_OFFSET(WLAN_BSSID_EX, IELength));
+	pnetwork->IELength = ((WLAN_BSSID_EX *)pbuf)->IELength;
+
+	if(pnetwork->IELength>MAX_IE_SZ)//Check pbuf->IELength
+		return H2C_PARAMETERS_ERROR;
+
+	memcpy(pnetwork->IEs, ((WLAN_BSSID_EX *)pbuf)->IEs, pnetwork->IELength);
+
+	//Check AP vendor to move rtw_joinbss_cmd()
+	//pmlmeinfo->assoc_AP_vendor = check_assoc_AP(pnetwork->IEs, pnetwork->IELength);
+
+	//sizeof(NDIS_802_11_FIXED_IEs)
+	for (i = _FIXED_IE_LENGTH_; i < pnetwork->IELength;)
+	{
+		pIE = (PNDIS_802_11_VARIABLE_IEs)(pnetwork->IEs + i);
+
+		switch (pIE->ElementID)
+		{
+			case _VENDOR_SPECIFIC_IE_://Get WMM IE.
+				if ( _rtw_memcmp(pIE->data, WMM_OUI, 4) )
+				{
+					WMM_param_handler(rtlpriv, pIE);
+				}
+				break;
+
+			case _HT_CAPABILITY_IE_:	//Get HT Cap IE.
+				pmlmeinfo->HT_caps_enable = 1;
+				break;
+
+			case _HT_EXTRA_INFO_IE_:	//Get HT Info IE.
+				pmlmeinfo->HT_info_enable = 1;
+
+				//spec case only for cisco's ap because cisco's ap issue assoc rsp using mcs rate @40MHz or @20MHz
+				{
+					struct HT_info_element *pht_info = (struct HT_info_element *)(pIE->data);
+
+					if (pnetwork->Configuration.DSConfig > 14) {
+						if ((0x21 & 0xf0) > CHANNEL_WIDTH_20)
+							cbw40_enable = 1;
+					} else {
+						if ((0x21 & 0x0f) > CHANNEL_WIDTH_20)
+							cbw40_enable = 1;
+					}
+
+					if ((cbw40_enable) && (pht_info->infos[0] & BIT(2)))
+					{
+						//switch to the 40M Hz mode according to the AP
+						pmlmeext->cur_bwmode = CHANNEL_WIDTH_40;
+						switch (pht_info->infos[0] & 0x3)
+						{
+							case 1:
+								pmlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_LOWER;
+								break;
+
+							case 3:
+								pmlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_UPPER;
+								break;
+
+							default:
+								pmlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
+								break;
+						}
+
+						DBG_871X("set HT ch/bw before connected\n");
+					}
+				}
+				break;
+			case EID_VHTCapability://Get VHT Cap IE.
+				pmlmeinfo->VHT_enable = 1;
+				break;
+
+			case EID_VHTOperation://Get VHT Operation IE.
+				if (pmlmeext->cur_bwmode == CHANNEL_WIDTH_40) {
+					if((GET_VHT_OPERATION_ELE_CHL_WIDTH(pIE->data) >= 1)
+						&& ((0x21 & 0xf0) >= CHANNEL_WIDTH_80)) {
+						pmlmeext->cur_bwmode = CHANNEL_WIDTH_80;
+						DBG_871X("VHT center ch = %d\n", GET_VHT_OPERATION_ELE_CENTER_FREQ1(pIE->data));
+						DBG_871X("set VHT ch/bw before connected\n");
+					}
+				}
+				break;
+			default:
+				break;
+		}
+
+		i += (pIE->Length + 2);
+	}
+	//disable dynamic functions, such as high power, DIG
+	//Switch_DM_Func(rtlpriv, DYNAMIC_FUNC_DISABLE, false);
+
+	//config the initial gain under linking, need to write the BB registers
+	//initialgain = 0x1E;
+	//rtlpriv->cfg->ops->set_hw_reg(rtlpriv, HW_VAR_INITIAL_GAIN, (uint8_t *)(&initialgain));
+
+	rtlpriv->cfg->ops->set_hw_reg(rtlpriv, HW_VAR_BSSID, pmlmeinfo->network.MacAddress);
+	join_type = 0;
+	rtlpriv->cfg->ops->set_hw_reg(rtlpriv, HW_VAR_MLME_JOIN, (uint8_t *)(&join_type));
+
+	//cancel link timer
+	del_timer_sync_ex(&pmlmeext->link_timer);
+
+	start_clnt_join(rtlpriv);
+
+	return H2C_SUCCESS;
+
+}
+
+uint8_t disconnect_hdl(struct rtl_priv *rtlpriv, unsigned char *pbuf)
+{
+	struct disconnect_parm *param = (struct disconnect_parm *)pbuf;
+	struct mlme_ext_priv	*pmlmeext = &rtlpriv->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	WLAN_BSSID_EX		*pnetwork = (WLAN_BSSID_EX*)(&(pmlmeinfo->network));
+	uint8_t	val8;
+
+	if (is_client_associated_to_ap(rtlpriv))
+	{
+		issue_deauth_ex(rtlpriv, pnetwork->MacAddress, WLAN_REASON_DEAUTH_LEAVING, param->deauth_timeout_ms/100, 100);
+	}
+
+	//set_opmode_cmd(rtlpriv, infra_client_with_mlme);
+
+	//pmlmeinfo->state = WIFI_FW_NULL_STATE;
+
+
+	rtlpriv->cfg->ops->set_hw_reg(rtlpriv, HW_VAR_MLME_DISCONNECT, 0);
+	rtlpriv->cfg->ops->set_hw_reg(rtlpriv, HW_VAR_BSSID, null_addr);
+
+	if(((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE) || ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE))
+	{
+		//Stop BCN
+		val8 = 0;
+		rtlpriv->cfg->ops->set_hw_reg(rtlpriv, HW_VAR_BCN_FUNC, (uint8_t *)(&val8));
+	}
+
+
+	//set MSR to no link state -> infra. mode
+	Set_MSR(rtlpriv, _HW_STATE_STATION_);
+
+	pmlmeinfo->state = WIFI_FW_NULL_STATE;
+
+		//switch to the 20M Hz mode after disconnect
+		pmlmeext->cur_bwmode = CHANNEL_WIDTH_20;
+		pmlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
+
+		set_channel_bwmode(rtlpriv, pmlmeext->cur_channel, pmlmeext->cur_ch_offset, pmlmeext->cur_bwmode);
+
+
+	flush_all_cam_entry(rtlpriv);
+
+	del_timer_sync_ex(&pmlmeext->link_timer);
+
+	rtw_free_uc_swdec_pending_queue(rtlpriv);
+
+	return 	H2C_SUCCESS;
+}
+
+int rtw_scan_ch_decision(struct rtl_priv *rtlpriv, struct rtw_ieee80211_channel *out,
+	uint32_t	 out_num, struct rtw_ieee80211_channel *in, uint32_t	 in_num)
+{
+	int i, j;
+	int scan_ch_num = 0;
+	int set_idx;
+	struct mlme_ext_priv	*pmlmeext = &rtlpriv->mlmeextpriv;
+
+	/* clear out first */
+	memset(out, 0, sizeof(struct rtw_ieee80211_channel)*out_num);
+
+	/* acquire channels from in */
+	j = 0;
+	for (i=0;i<in_num;i++) {
+		if (0)
+		DBG_871X(FUNC_ADPT_FMT" "CHAN_FMT"\n", FUNC_ADPT_ARG(rtlpriv), CHAN_ARG(&in[i]));
+		if(in[i].hw_value && !(in[i].flags & RTW_IEEE80211_CHAN_DISABLED)
+			&& (set_idx=rtw_ch_set_search_ch(pmlmeext->channel_set, in[i].hw_value)) >=0
+		)
+		{
+			memcpy(&out[j], &in[i], sizeof(struct rtw_ieee80211_channel));
+
+			if(pmlmeext->channel_set[set_idx].ScanType == SCAN_PASSIVE)
+				out[j].flags &= RTW_IEEE80211_CHAN_PASSIVE_SCAN;
+
+			j++;
+		}
+		if(j>=out_num)
+			break;
+	}
+
+	/* if out is empty, use channel_set as default */
+	if(j == 0) {
+		for (i=0;i<pmlmeext->max_chan_nums;i++) {
+			out[i].hw_value = pmlmeext->channel_set[i].ChannelNum;
+
+			if(pmlmeext->channel_set[i].ScanType == SCAN_PASSIVE)
+				out[i].flags &= RTW_IEEE80211_CHAN_PASSIVE_SCAN;
+
+			j++;
+		}
+	}
+
+	if (rtlpriv->setband == GHZ_24) {				// 2.4G
+		for (i=0; i < j ; i++) {
+			if (out[i].hw_value > 35)
+				memset(&out[i], 0 , sizeof(struct rtw_ieee80211_channel));
+			else
+				scan_ch_num++;
+		}
+		j = scan_ch_num;
+	} else if  (rtlpriv->setband == GHZ_50) {			// 5G
+		for (i=0; i < j ; i++) {
+			if (out[i].hw_value > 35) {
+				memcpy(&out[scan_ch_num++], &out[i], sizeof(struct rtw_ieee80211_channel));
+			}
+		}
+		j = scan_ch_num;
+	} else
+		{}
+
+	return j;
+}
+
+uint8_t sitesurvey_cmd_hdl(struct rtl_priv *rtlpriv, uint8_t *pbuf)
+{
+	struct mlme_ext_priv	*pmlmeext = &rtlpriv->mlmeextpriv;
+	struct sitesurvey_parm	*pparm = (struct sitesurvey_parm *)pbuf;
+	uint8_t	bdelayscan = false;
+	uint8_t	val8;
+	uint32_t	initialgain;
+	uint32_t	i;
+
+	if (pmlmeext->sitesurvey_res.state == SCAN_DISABLE)
+	{
+
+		pmlmeext->sitesurvey_res.state = SCAN_START;
+		pmlmeext->sitesurvey_res.bss_cnt = 0;
+		pmlmeext->sitesurvey_res.channel_idx = 0;
+
+		for(i=0;i<RTW_SSID_SCAN_AMOUNT;i++){
+			if(pparm->ssid[i].SsidLength) {
+				memcpy(pmlmeext->sitesurvey_res.ssid[i].Ssid, pparm->ssid[i].Ssid, IW_ESSID_MAX_SIZE);
+				pmlmeext->sitesurvey_res.ssid[i].SsidLength= pparm->ssid[i].SsidLength;
+			} else {
+				pmlmeext->sitesurvey_res.ssid[i].SsidLength= 0;
+			}
+		}
+
+		pmlmeext->sitesurvey_res.ch_num = rtw_scan_ch_decision(rtlpriv
+			, pmlmeext->sitesurvey_res.ch, RTW_CHANNEL_SCAN_AMOUNT
+			, pparm->ch, pparm->ch_num
+		);
+
+		pmlmeext->sitesurvey_res.scan_mode = pparm->scan_mode;
+
+
+		//issue null data if associating to the AP
+		if (is_client_associated_to_ap(rtlpriv) == true)
+		{
+			pmlmeext->sitesurvey_res.state = SCAN_TXNULL;
+
+			issue_nulldata(rtlpriv, NULL, 1, 3, 500);
+
+			bdelayscan = true;
+		}
+		if(bdelayscan)
+		{
+			//delay 50ms to protect nulldata(1).
+			set_survey_timer(pmlmeext, 50);
+			return H2C_SUCCESS;
+		}
+	}
+
+	if ((pmlmeext->sitesurvey_res.state == SCAN_START) || (pmlmeext->sitesurvey_res.state == SCAN_TXNULL))
+	{
+
+		//config the initial gain under scaning, need to write the BB registers
+			initialgain = 0x1e;
+
+		rtlpriv->cfg->ops->set_hw_reg(rtlpriv, HW_VAR_INITIAL_GAIN, (uint8_t *)(&initialgain));
+
+		//set MSR to no link state
+		Set_MSR(rtlpriv, _HW_STATE_NOLINK_);
+
+		val8 = 1; //under site survey
+		rtlpriv->cfg->ops->set_hw_reg(rtlpriv, HW_VAR_MLME_SITESURVEY, (uint8_t *)(&val8));
+
+		pmlmeext->sitesurvey_res.state = SCAN_PROCESS;
+	}
+
+	site_survey(rtlpriv);
+
+	return H2C_SUCCESS;
+
+}
+
+uint8_t setauth_hdl(struct rtl_priv *rtlpriv, unsigned char *pbuf)
+{
+	struct setauth_parm		*pparm = (struct setauth_parm *)pbuf;
+	struct mlme_ext_priv	*pmlmeext = &rtlpriv->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	if (pparm->mode < 4)
+	{
+		pmlmeinfo->auth_algo = pparm->mode;
+	}
+
+	return 	H2C_SUCCESS;
+}
+
+uint8_t setkey_hdl(struct rtl_priv *rtlpriv, uint8_t *pbuf)
+{
+	struct setkey_parm		*pparm = (struct setkey_parm *)pbuf;
+	struct mlme_ext_priv	*pmlmeext = &rtlpriv->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	unsigned char					null_sta[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
+
+	//main tx key for wep.
+	if(pparm->set_tx)
+		pmlmeinfo->key_index = pparm->keyid;
+
+	rtw_cam_add_one_entry(rtlpriv, null_sta, pparm->keyid, pparm->keyid,
+			      0, pparm->algorithm, pparm->key);
+
+	//allow multicast packets to driver
+        rtlpriv->cfg->ops->set_hw_reg(rtlpriv, HW_VAR_ON_RCR_AM, null_addr);
+
+	return H2C_SUCCESS;
+}
+
+uint8_t set_stakey_hdl(struct rtl_priv *rtlpriv, uint8_t *pbuf)
+{
+	uint8_t cam_id = 0;//cam_entry
+	uint8_t ret = H2C_SUCCESS;
+	struct mlme_ext_priv	*pmlmeext = &rtlpriv->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct set_stakey_parm	*pparm = (struct set_stakey_parm *)pbuf;
+	struct sta_priv *pstapriv = &rtlpriv->stapriv;
+	struct sta_info *psta;
+
+	//cam_entry:
+	//0~3 for default key
+
+	//for concurrent mode (ap+sta, sta+sta):
+	//default key is disable, using sw encrypt/decrypt
+	//camid 0, 1, 2, 3 is default entry for default key/group key
+	//macid = 1 is for bc/mc stainfo, no mapping to camid
+	//macid = 0 mapping to camid 4
+	//for macid >=2, camid = macid+3;
+
+
+	if(pparm->algorithm == NO_ENCRYPTION)	// clear cam entry
+	{
+		clear_cam_entry(rtlpriv, pparm->id);
+		ret = H2C_SUCCESS;
+		goto exit_set_stakey_hdl;
+	}
+
+	if((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE)
+	{
+		psta = rtw_get_stainfo(pstapriv, pparm->addr);
+		if(psta)
+		{
+			DBG_871X("r871x_set_stakey_hdl(): enc_algorithm=%d\n", pparm->algorithm);
+
+			if((psta->mac_id == 1) || (psta->mac_id>(NUM_STA-4)))
+			{
+				DBG_871X("r871x_set_stakey_hdl():set_stakey failed, mac_id(aid)=%d\n", psta->mac_id);
+				ret = H2C_REJECTED;
+				goto exit_set_stakey_hdl;
+			}
+
+			cam_id = (uint8_t)rtw_get_camid(psta->mac_id);//0~3 for default key, cmd_id=macid + 3;
+
+			DBG_871X("Write CAM, mac_addr=%x:%x:%x:%x:%x:%x, cam_entry=%d\n", pparm->addr[0],
+						pparm->addr[1], pparm->addr[2], pparm->addr[3], pparm->addr[4],
+						pparm->addr[5], cam_id);
+
+			rtw_cam_add_one_entry(rtlpriv, pparm->addr, 0, cam_id,
+					pparm->algorithm, 1, pparm->key);
+
+			ret = H2C_SUCCESS_RSP;
+			goto exit_set_stakey_hdl;
+
+		}
+		else
+		{
+			DBG_871X("r871x_set_stakey_hdl(): sta has been free\n");
+			ret = H2C_REJECTED;
+			goto exit_set_stakey_hdl;
+		}
+
+	}
+
+
+	//below for sta mode
+
+	if((psta = rtw_get_stainfo(pstapriv, pmlmeinfo->network.MacAddress)))
+		cam_id = (uint8_t)rtw_get_camid(psta->mac_id);
+	else
+		cam_id = 4;
+
+	rtw_cam_add_one_entry(rtlpriv, pparm->addr, 0, cam_id,
+			pparm->algorithm, 1, pparm->key);
+
+	pmlmeinfo->enc_algo = pparm->algorithm;
+
+exit_set_stakey_hdl:
+
+	DBG_871X_LEVEL(_drv_always_, "set pairwise key to hw: alg:%d(WEP40-1 WEP104-5 TKIP-2 AES-4) camid:%d\n",
+		       	pparm->algorithm, cam_id);
+
+	return ret;
+
+}
+
+uint8_t add_ba_hdl(struct rtl_priv *rtlpriv, unsigned char *pbuf)
+{
+	struct addBaReq_parm 	*pparm = (struct addBaReq_parm *)pbuf;
+	struct mlme_ext_priv	*pmlmeext = &rtlpriv->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	struct sta_info *psta = rtw_get_stainfo(&rtlpriv->stapriv, pparm->addr);
+
+	if(!psta)
+		return 	H2C_SUCCESS;
+
+	if (((pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS) && (pmlmeinfo->HT_enable)) ||
+		((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE))
+	{
+		//pmlmeinfo->ADDBA_retry_count = 0;
+		//pmlmeinfo->candidate_tid_bitmap |= (0x1 << pparm->tid);
+		//psta->htpriv.candidate_tid_bitmap |= BIT(pparm->tid);
+		issue_action_BA(rtlpriv, pparm->addr, RTW_WLAN_ACTION_ADDBA_REQ, (u16)pparm->tid);
+		//_set_timer(&pmlmeext->ADDBA_timer, ADDBA_TO);
+		_set_timer(&psta->addba_retry_timer, ADDBA_TO);
+	}
+	else
+	{
+		psta->htpriv.candidate_tid_bitmap &= ~BIT(pparm->tid);
+	}
+	return 	H2C_SUCCESS;
+}
+
+uint8_t set_tx_beacon_cmd(struct rtl_priv* rtlpriv)
+{
+	struct cmd_obj	*ph2c;
+	struct Tx_Beacon_param 	*ptxBeacon_parm;
+	struct cmd_priv	*pcmdpriv = &(rtlpriv->cmdpriv);
+	struct mlme_ext_priv	*pmlmeext = &rtlpriv->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	uint8_t	res = _SUCCESS;
+	int len_diff = 0;
+
+
+
+	if ((ph2c = (struct cmd_obj*)rtw_zmalloc(sizeof(struct cmd_obj))) == NULL)
+	{
+		res= _FAIL;
+		goto exit;
+	}
+
+	if ((ptxBeacon_parm = (struct Tx_Beacon_param *)rtw_zmalloc(sizeof(struct Tx_Beacon_param))) == NULL)
+	{
+		rtw_mfree(ph2c);
+		res= _FAIL;
+		goto exit;
+	}
+
+	memcpy(&(ptxBeacon_parm->network), &(pmlmeinfo->network), sizeof(WLAN_BSSID_EX));
+
+	len_diff = update_hidden_ssid(
+		ptxBeacon_parm->network.IEs+_BEACON_IE_OFFSET_
+		, ptxBeacon_parm->network.IELength-_BEACON_IE_OFFSET_
+		, pmlmeinfo->hidden_ssid_mode
+	);
+	ptxBeacon_parm->network.IELength += len_diff;
+
+	init_h2fwcmd_w_parm_no_rsp(ph2c, ptxBeacon_parm, GEN_CMD_CODE(_TX_Beacon));
+
+	res = rtw_enqueue_cmd(pcmdpriv, ph2c);
+
+
+exit:
+
+
+
+	return res;
+}
+
+
+uint8_t mlme_evt_hdl(struct rtl_priv *rtlpriv, unsigned char *pbuf)
+{
+	uint8_t evt_code, evt_seq;
+	u16 evt_sz;
+	uint 	*peventbuf;
+	void (*event_callback)(struct rtl_priv *dev, uint8_t *pbuf);
+	struct evt_priv *pevt_priv = &(rtlpriv->evtpriv);
+
+	peventbuf = (uint*)pbuf;
+	evt_sz = (u16)(*peventbuf&0xffff);
+	evt_seq = (uint8_t)((*peventbuf>>24)&0x7f);
+	evt_code = (uint8_t)((*peventbuf>>16)&0xff);
+
+
+	#ifdef CHECK_EVENT_SEQ
+	// checking event sequence...
+	if (evt_seq != (atomic_read(&pevt_priv->event_seq) & 0x7f) )
+	{
+		pevt_priv->event_seq = (evt_seq+1)&0x7f;
+
+		goto _abort_event_;
+	}
+	#endif
+
+	// checking if event code is valid
+	if (evt_code >= MAX_C2HEVT)
+	{
+		goto _abort_event_;
+	}
+
+	// checking if event size match the event parm size
+	if ((wlanevents[evt_code].parmsize != 0) &&
+			(wlanevents[evt_code].parmsize != evt_sz))
+	{
+
+		goto _abort_event_;
+
+	}
+
+	atomic_inc(&pevt_priv->event_seq);
+
+	peventbuf += 2;
+
+	if(peventbuf)
+	{
+		event_callback = wlanevents[evt_code].event_callback;
+		event_callback(rtlpriv, (uint8_t *)peventbuf);
+
+		pevt_priv->evt_done_cnt++;
+	}
+
+
+_abort_event_:
+
+
+	return H2C_SUCCESS;
+
+}
+
+uint8_t tx_beacon_hdl(struct rtl_priv *rtlpriv, unsigned char *pbuf)
+{
+	if(send_beacon(rtlpriv)==_FAIL)
+	{
+		DBG_871X("issue_beacon, fail!\n");
+		return H2C_PARAMETERS_ERROR;
+	}
+#ifdef CONFIG_AP_MODE
+	else //tx bc/mc frames after update TIM
+	{
+		struct sta_info *psta_bmc;
+		struct list_head	*xmitframe_plist, *xmitframe_phead;
+		struct xmit_frame *pxmitframe=NULL;
+		struct xmit_priv *pxmitpriv = &rtlpriv->xmitpriv;
+		struct sta_priv  *pstapriv = &rtlpriv->stapriv;
+
+		//for BC/MC Frames
+		psta_bmc = rtw_get_bcmc_stainfo(rtlpriv);
+		if(!psta_bmc)
+			return H2C_SUCCESS;
+
+		if((pstapriv->tim_bitmap&BIT(0)) && (psta_bmc->sleepq_len>0))
+		{
+			msleep(10);// 10ms, ATIM(HIQ) Windows
+			//spin_lock_bh(&psta_bmc->sleep_q.lock, &irqL);
+			spin_lock_bh(&pxmitpriv->lock);
+
+			xmitframe_phead = get_list_head(&psta_bmc->sleep_q);
+			xmitframe_plist = get_next(xmitframe_phead);
+
+			while ((rtw_end_of_queue_search(xmitframe_phead, xmitframe_plist)) == false)
+			{
+				pxmitframe = container_of(xmitframe_plist, struct xmit_frame, list);
+
+				xmitframe_plist = get_next(xmitframe_plist);
+
+				list_del_init(&pxmitframe->list);
+
+				psta_bmc->sleepq_len--;
+				if(psta_bmc->sleepq_len>0)
+					pxmitframe->tx_attrib.mdata = 1;
+				else
+					pxmitframe->tx_attrib.mdata = 0;
+
+				pxmitframe->tx_attrib.triggered=1;
+
+				pxmitframe->tx_attrib.tx_qsel = 0x11;//HIQ
+
+				rtlpriv->cfg->ops->hal_xmitframe_enqueue(rtlpriv, pxmitframe);
+
+				//pstapriv->tim_bitmap &= ~BIT(0);
+
+			}
+
+			//spin_unlock_bh(&psta_bmc->sleep_q.lock, &irqL);
+			spin_unlock_bh(&pxmitpriv->lock);
+
+
+		}
+
+	}
+#endif
+
+	return H2C_SUCCESS;
+
+}
+
+void change_band_update_ie(struct rtl_priv *rtlpriv, WLAN_BSSID_EX *pnetwork)
+{
+	uint8_t	network_type,rate_len, total_rate_len,remainder_rate_len;
+	struct mlme_ext_priv *pmlmeext = &(rtlpriv->mlmeextpriv);
+	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
+	uint8_t	erpinfo=0x4;
+
+	//DBG_871X("%s\n", __FUNCTION__);
+
+	if(pmlmeext->cur_channel >= 36)
+	{
+		network_type = WIRELESS_11A;
+		total_rate_len = IEEE80211_NUM_OFDM_RATESLEN;
+		DBG_871X("%s(): change to 5G Band\n",__FUNCTION__);
+		rtw_remove_bcn_ie(rtlpriv, pnetwork, _ERPINFO_IE_);
+	}
+	else
+	{
+		network_type = WIRELESS_11BG;
+		total_rate_len = IEEE80211_CCK_RATE_LEN+IEEE80211_NUM_OFDM_RATESLEN;
+		DBG_871X("%s(): change to 2.4G Band\n",__FUNCTION__);
+		rtw_add_bcn_ie(rtlpriv, pnetwork, _ERPINFO_IE_, &erpinfo, 1);
+	}
+
+	rtw_set_supported_rate(pnetwork->SupportedRates, network_type);
+
+	UpdateBrateTbl(rtlpriv, pnetwork->SupportedRates);
+	rtlpriv->cfg->ops->set_hw_reg(rtlpriv, HW_VAR_BASIC_RATE, pnetwork->SupportedRates);
+
+	if(total_rate_len > 8)
+	{
+		rate_len = 8;
+		remainder_rate_len = total_rate_len - 8;
+	}
+	else
+	{
+		rate_len = total_rate_len;
+		remainder_rate_len = 0;
+	}
+
+	rtw_add_bcn_ie(rtlpriv, pnetwork, _SUPPORTEDRATES_IE_, pnetwork->SupportedRates, rate_len);
+
+	if(remainder_rate_len)
+	{
+		rtw_add_bcn_ie(rtlpriv, pnetwork, _EXT_SUPPORTEDRATES_IE_, (pnetwork->SupportedRates+8), remainder_rate_len);
+	}
+	else
+	{
+		rtw_remove_bcn_ie(rtlpriv, pnetwork, _EXT_SUPPORTEDRATES_IE_);
+	}
+}
+
+
+uint8_t set_ch_hdl(struct rtl_priv *rtlpriv, uint8_t *pbuf)
+{
+	struct set_ch_parm *set_ch_parm;
+	struct mlme_priv		*pmlmepriv = &rtlpriv->mlmepriv;
+	struct mlme_ext_priv	*pmlmeext = &rtlpriv->mlmeextpriv;
+
+	if(!pbuf)
+		return H2C_PARAMETERS_ERROR;
+
+	set_ch_parm = (struct set_ch_parm *)pbuf;
+
+	DBG_871X(FUNC_NDEV_FMT" ch:%u, bw:%u, ch_offset:%u\n",
+		FUNC_NDEV_ARG(rtlpriv->ndev),
+		set_ch_parm->ch, set_ch_parm->bw, set_ch_parm->ch_offset);
+
+	pmlmeext->cur_channel = set_ch_parm->ch;
+	pmlmeext->cur_ch_offset = set_ch_parm->ch_offset;
+	pmlmeext->cur_bwmode = set_ch_parm->bw;
+
+	set_channel_bwmode(rtlpriv, set_ch_parm->ch, set_ch_parm->ch_offset, set_ch_parm->bw);
+
+	return 	H2C_SUCCESS;
+}
+
+uint8_t set_csa_hdl(struct rtl_priv *rtlpriv, unsigned char *pbuf)
+{
+#ifdef CONFIG_DFS
+	struct SetChannelSwitch_param *setChannelSwitch_param;
+	struct mlme_priv *pmlmepriv = &rtlpriv->mlmepriv;
+	struct mlme_ext_priv *pmlmeext = &rtlpriv->mlmeextpriv;
+	struct mlme_ext_info *pmlmeinfo = &pmlmeext->mlmext_info;
+	uint8_t new_ch_no;
+	uint8_t gval8 = 0x00, sval8 = 0xff;
+
+	if(!pbuf)
+		return H2C_PARAMETERS_ERROR;
+
+	setChannelSwitch_param = (struct SetChannelSwitch_param *)pbuf;
+	new_ch_no = setChannelSwitch_param->new_ch_no;
+
+	rtlpriv->cfg->ops->get_hw_reg(rtlpriv, HW_VAR_TXPAUSE, &gval8);
+
+	rtlpriv->cfg->ops->set_hw_reg(rtlpriv, HW_VAR_TXPAUSE, &sval8);
+
+	DBG_871X("DFS detected! Swiching channel to %d!\n", new_ch_no);
+	SelectChannel(rtlpriv, new_ch_no);
+
+	rtlpriv->cfg->ops->set_hw_reg(rtlpriv, HW_VAR_TXPAUSE, &gval8);
+
+	rtw_free_network_queue(rtlpriv, true);
+	rtw_indicate_disconnect(rtlpriv);
+
+	if ( ((new_ch_no >= 52) && (new_ch_no <= 64)) ||((new_ch_no >= 100) && (new_ch_no <= 140)) ) {
+		DBG_871X("Switched to DFS band (ch %02x) again!!\n", new_ch_no);
+	}
+
+	return 	H2C_SUCCESS;
+#else
+	return	H2C_REJECTED;
+#endif //CONFIG_DFS
+
+}
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/core/rtw_pwrctrl.c linux-4.9.8821au/drivers/staging/rtl8821au/core/rtw_pwrctrl.c
--- linux-4.9/drivers/staging/rtl8821au/core/rtw_pwrctrl.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/core/rtw_pwrctrl.c	2016-12-11 19:48:25.153645128 -0600
@@ -0,0 +1,668 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#define _RTW_PWRCTRL_C_
+
+#include <drv_types.h>
+#include <../debug.h>
+
+// Should not include hal dependent herader here, it will remove later. Lucas@20130123
+
+/* ULLI : rtw_ prefix for not distrub rtlwifi */
+
+void rtw_ips_enter(struct rtl_priv *rtlpriv)
+{
+	struct pwrctrl_priv *pwrpriv = &rtlpriv->pwrctrlpriv;
+
+	down(&pwrpriv->lock);
+
+	pwrpriv->bips_processing = true;
+
+	/* syn ips_mode with request */
+	pwrpriv->ips_mode = pwrpriv->ips_mode_req;
+
+	pwrpriv->ips_enter_cnts++;
+	RT_TRACE(rtlpriv, COMP_POWER, DBG_DMESG, "==>ips_enter cnts:%d\n",pwrpriv->ips_enter_cnts);
+	if (ERFOFF == pwrpriv->change_rfpwrstate) {
+		pwrpriv->bpower_saving = true;
+		RT_TRACE(rtlpriv, COMP_POWER, DBG_DMESG, "nolinked power save enter\n");
+
+		rtw_ips_pwr_down(rtlpriv);
+		pwrpriv->rf_pwrstate = ERFOFF;
+	}
+	pwrpriv->bips_processing = false;
+
+	up(&pwrpriv->lock);
+
+}
+
+/* ULLI : rtw_ prefix for not distrub rtlwifi */
+
+int rtw_ips_leave(struct rtl_priv * rtlpriv)
+{
+	struct pwrctrl_priv *pwrpriv = &rtlpriv->pwrctrlpriv;
+	struct security_priv* psecuritypriv=&(rtlpriv->securitypriv);
+	struct mlme_priv *pmlmepriv = &(rtlpriv->mlmepriv);
+	int result = _SUCCESS;
+	int keyid;
+
+	down(&pwrpriv->lock);
+
+	if ((pwrpriv->rf_pwrstate == ERFOFF) &&(!pwrpriv->bips_processing)) {
+		pwrpriv->bips_processing = true;
+		pwrpriv->change_rfpwrstate = ERFON;
+		pwrpriv->ips_leave_cnts++;
+		RT_TRACE(rtlpriv, COMP_POWER, DBG_DMESG, "==>ips_leave cnts:%d\n",pwrpriv->ips_leave_cnts);
+
+		if ((result = rtw_ips_pwr_up(rtlpriv)) == _SUCCESS) {
+			pwrpriv->rf_pwrstate = ERFON;
+		}
+		RT_TRACE(rtlpriv, COMP_POWER, DBG_DMESG, "nolinked power save leave\n");
+
+		if ((WEP40_ENCRYPTION == psecuritypriv->dot11PrivacyAlgrthm)
+		   ||(WEP104_ENCRYPTION == psecuritypriv->dot11PrivacyAlgrthm)) {
+			RT_TRACE(rtlpriv, COMP_POWER, DBG_DMESG, "==>%s,channel(%d),processing(%x)\n",__FUNCTION__,rtlpriv->mlmeextpriv.cur_channel,pwrpriv->bips_processing);
+			set_channel_bwmode(rtlpriv, rtlpriv->mlmeextpriv.cur_channel, HAL_PRIME_CHNL_OFFSET_DONT_CARE, CHANNEL_WIDTH_20);
+			for (keyid = 0; keyid < 4; keyid++) {
+				if (pmlmepriv->key_mask & BIT(keyid)) {
+					if (keyid == psecuritypriv->dot11PrivacyKeyIndex)
+						result=rtw_set_key(rtlpriv,psecuritypriv, keyid, 1);
+					else
+						result=rtw_set_key(rtlpriv,psecuritypriv, keyid, 0);
+				}
+			}
+		}
+
+		RT_TRACE(rtlpriv, COMP_POWER, DBG_DMESG, "==> ips_leave.....LED(0x%08x)...\n",rtl_read_dword(rtlpriv,0x4c));
+		pwrpriv->bips_processing = false;
+
+		pwrpriv->bpower_saving = false;
+	}
+
+	up(&pwrpriv->lock);
+
+	return result;
+}
+
+#ifdef CONFIG_AUTOSUSPEND
+extern void autosuspend_enter(struct rtl_priv* rtlpriv);
+extern int autoresume_enter(struct rtl_priv* rtlpriv);
+#endif
+
+bool rtw_pwr_unassociated_idle(struct rtl_priv *rtlpriv)
+{
+	struct mlme_priv *pmlmepriv = &(rtlpriv->mlmepriv);
+	struct xmit_priv *pxmit_priv = &rtlpriv->xmitpriv;
+
+	bool ret = false;
+
+	if (rtlpriv->pwrctrlpriv.ips_deny_time >= jiffies) {
+		//DBG_871X("%s ips_deny_time\n", __func__);
+		goto exit;
+	}
+
+	if (check_fwstate(pmlmepriv, WIFI_ASOC_STATE|WIFI_SITE_MONITOR)
+		|| check_fwstate(pmlmepriv, WIFI_UNDER_LINKING|WIFI_UNDER_WPS)
+		|| check_fwstate(pmlmepriv, WIFI_AP_STATE)
+		|| check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE|WIFI_ADHOC_STATE)
+	) {
+		goto exit;
+	}
+
+	if (pxmit_priv->free_xmitbuf_cnt != NR_XMITBUFF ||
+		pxmit_priv->free_xmit_extbuf_cnt != NR_XMIT_EXTBUFF) {
+		RT_TRACE(rtlpriv, COMP_POWER, DBG_DMESG, "There are some pkts to transmit\n");
+		RT_TRACE(rtlpriv, COMP_POWER, DBG_DMESG, "free_xmitbuf_cnt: %d, free_xmit_extbuf_cnt: %d\n",
+			pxmit_priv->free_xmitbuf_cnt, pxmit_priv->free_xmit_extbuf_cnt);
+		goto exit;
+	}
+
+	ret = true;
+
+exit:
+	return ret;
+}
+
+void rtw_ps_processor(struct rtl_priv *rtlpriv)
+{
+	struct pwrctrl_priv *pwrpriv = &rtlpriv->pwrctrlpriv;
+	struct mlme_priv *pmlmepriv = &(rtlpriv->mlmepriv);
+
+	pwrpriv->ps_processing = true;
+
+	if (pwrpriv->ips_mode_req == IPS_NONE
+	)
+		goto exit;
+
+	if (rtw_pwr_unassociated_idle(rtlpriv) == false)
+		goto exit;
+
+	if ((pwrpriv->rf_pwrstate == ERFON)
+	   && ((pwrpriv->pwr_state_check_cnts%4)==0)) {
+		RT_TRACE(rtlpriv, COMP_POWER, DBG_DMESG, "==>%s .fw_state(%x)\n",__FUNCTION__,get_fwstate(pmlmepriv));
+		pwrpriv->change_rfpwrstate = ERFOFF;
+#ifdef CONFIG_AUTOSUSPEND
+		if (rtlpriv->registrypriv.usbss_enable) {
+			if(pwrpriv->bHWPwrPindetect)
+				pwrpriv->bkeepfwalive = true;
+
+			if(rtlpriv->net_closed == true)
+				pwrpriv->ps_flag = true;
+
+			rtlpriv->bCardDisableWOHSM = true;
+			autosuspend_enter(rtlpriv);
+		} else if(pwrpriv->bHWPwrPindetect) {
+		}
+		else
+#endif
+		{
+
+			rtw_ips_enter(rtlpriv);
+		}
+	}
+exit:
+	rtw_set_pwr_state_check_timer(&rtlpriv->pwrctrlpriv);
+	pwrpriv->ps_processing = false;
+	return;
+}
+
+
+static void pwr_state_check_handler(RTW_TIMER_HDL_ARGS)
+{
+	struct rtl_priv *rtlpriv = (struct rtl_priv *)FunctionContext;
+	rtw_ps_cmd(rtlpriv);
+}
+
+
+/*
+ *
+ * Parameters
+ *	rtlpriv
+ *	pslv			power state level, only could be PS_STATE_S0 ~ PS_STATE_S4
+ *
+ */
+void rtw_set_rpwm(struct rtl_priv *rtlpriv, uint8_t pslv)
+{
+	uint8_t	rpwm;
+	struct pwrctrl_priv *pwrpriv = &rtlpriv->pwrctrlpriv;
+
+
+
+	pslv = PS_STATE(pslv);
+
+	if (true == pwrpriv->btcoex_rfon) {
+		if (pslv < PS_STATE_S4)
+			pslv = PS_STATE_S3;
+	}
+
+#ifdef CONFIG_LPS_RPWM_TIMER
+	if (pwrpriv->brpwmtimeout == true) {
+		RT_TRACE(rtlpriv, COMP_POWER, DBG_DMESG, "%s: RPWM timeout, force to set RPWM(0x%02X) again!\n", __FUNCTION__, pslv);
+	} else
+#endif // CONFIG_LPS_RPWM_TIMER
+	{
+	if ( (pwrpriv->rpwm == pslv)
+		)
+	{
+		return;
+	}
+	}
+
+	if ((rtlpriv->bSurpriseRemoved == true)
+	   || (rtlpriv->hw_init_completed == false)) {
+
+		pwrpriv->cpwm = PS_STATE_S4;
+		return;
+	}
+
+	if (rtlpriv->bDriverStopped == true) {
+
+		if (pslv < PS_STATE_S2) {
+			return;
+		}
+	}
+
+	rpwm = pslv | pwrpriv->tog;
+
+	pwrpriv->rpwm = pslv;
+
+#ifdef CONFIG_LPS_RPWM_TIMER
+	if (rpwm & PS_ACK)
+		_set_timer(&pwrpriv->pwr_rpwm_timer, LPS_RPWM_WAIT_MS);
+#endif // CONFIG_LPS_RPWM_TIMER
+
+	pwrpriv->tog += 0x80;
+
+	{
+		pwrpriv->cpwm = pslv;
+	}
+
+
+}
+
+static uint8_t PS_RDY_CHECK(struct rtl_priv *rtlpriv)
+{
+	uint32_t	 curr_time, delta_time;
+	struct pwrctrl_priv	*pwrpriv = &rtlpriv->pwrctrlpriv;
+	struct mlme_priv	*pmlmepriv = &(rtlpriv->mlmepriv);
+
+	curr_time = jiffies;
+
+	delta_time = curr_time -pwrpriv->DelayLPSLastTimeStamp;
+
+	if(delta_time < LPS_DELAY_TIME) {
+		return false;
+	}
+
+	if ((check_fwstate(pmlmepriv, _FW_LINKED) == false) ||
+		(check_fwstate(pmlmepriv, _FW_UNDER_SURVEY) == true) ||
+		(check_fwstate(pmlmepriv, WIFI_AP_STATE) == true) ||
+		(check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true) ||
+		(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true) )
+		return false;
+	if (true == pwrpriv->bInSuspend )
+		return false;
+	if ((rtlpriv->securitypriv.dot11AuthAlgrthm == dot11AuthAlgrthm_8021X)
+	  && (rtlpriv->securitypriv.binstallGrpkey == false)) {
+		RT_TRACE(rtlpriv, COMP_POWER, DBG_DMESG, "Group handshake still in progress !!!\n");
+		return false;
+	}
+
+	return true;
+}
+
+void rtw_set_ps_mode(struct rtl_priv *rtlpriv, uint8_t ps_mode, uint8_t smart_ps, uint8_t bcn_ant_mode)
+{
+	struct pwrctrl_priv *pwrpriv = &rtlpriv->pwrctrlpriv;
+
+
+
+	if (ps_mode > PM_Card_Disable) {
+		return;
+	}
+
+	if (pwrpriv->pwr_mode == ps_mode) {
+		if (PS_MODE_ACTIVE == ps_mode)
+			return;
+
+		if ((pwrpriv->smart_ps == smart_ps)
+		   && (pwrpriv->bcn_ant_mode == bcn_ant_mode)) {
+			return;
+		}
+	}
+
+	//if(pwrpriv->pwr_mode == PS_MODE_ACTIVE)
+	if(ps_mode == PS_MODE_ACTIVE)
+	{
+		{
+			RT_TRACE(rtlpriv, COMP_POWER, DBG_DMESG, "rtw_set_ps_mode: Leave 802.11 power save\n");
+
+
+			pwrpriv->pwr_mode = ps_mode;
+			rtw_set_rpwm(rtlpriv, PS_STATE_S4);
+			rtlpriv->cfg->ops->set_hw_reg(rtlpriv, HW_VAR_H2C_FW_PWRMODE, (uint8_t *)(&ps_mode));
+			pwrpriv->fw_current_inpsmode = false;
+		}
+	} else 	{
+		if (PS_RDY_CHECK(rtlpriv)) {
+			RT_TRACE(rtlpriv, COMP_POWER, DBG_DMESG, "%s: Enter 802.11 power save\n", __FUNCTION__);
+
+
+			pwrpriv->fw_current_inpsmode = true;
+			pwrpriv->pwr_mode = ps_mode;
+			pwrpriv->smart_ps = smart_ps;
+			pwrpriv->bcn_ant_mode = bcn_ant_mode;
+			rtlpriv->cfg->ops->set_hw_reg(rtlpriv, HW_VAR_H2C_FW_PWRMODE, (uint8_t *)(&ps_mode));
+
+			rtw_set_rpwm(rtlpriv, PS_STATE_S2);
+		}
+	}
+
+
+}
+
+/*
+ * Return:
+ *	0:	Leave OK
+ *	-1:	Timeout
+ *	-2:	Other error
+ */
+int32_t LPS_RF_ON_check(struct rtl_priv *rtlpriv, uint32_t	 delay_ms)
+{
+	uint32_t	 start_time;
+	uint8_t bAwake = false;
+	int32_t err = 0;
+
+
+	start_time = jiffies;
+	while (1) {
+		rtlpriv->cfg->ops->get_hw_reg(rtlpriv, HW_VAR_FWLPS_RF_ON, &bAwake);
+		if (true == bAwake)
+			break;
+
+		if (true == rtlpriv->bSurpriseRemoved) {
+			err = -2;
+			RT_TRACE(rtlpriv, COMP_POWER, DBG_DMESG, "%s: device surprise removed!!\n", __FUNCTION__);
+			break;
+		}
+
+		if (rtw_get_passing_time_ms(start_time) > delay_ms) {
+			err = -1;
+			RT_TRACE(rtlpriv, COMP_POWER, DBG_DMESG, "%s: Wait for FW LPS leave more than %u ms!!!\n", __FUNCTION__, delay_ms);
+			break;
+		}
+		rtw_usleep_os(100);
+	}
+
+	return err;
+}
+
+//
+//	Description:
+//		Enter the leisure power save mode.
+//
+void LPS_Enter(struct rtl_priv *rtlpriv)
+{
+	struct pwrctrl_priv	*pwrpriv = &rtlpriv->pwrctrlpriv;
+	struct mlme_priv	*pmlmepriv = &(rtlpriv->mlmepriv);
+
+
+
+//	DBG_871X("+LeisurePSEnter\n");
+
+
+	if (PS_RDY_CHECK(rtlpriv) == false)
+		return;
+
+	if (pwrpriv->bLeisurePs) {
+		// Idle for a while if we connect to AP a while ago.
+		if(pwrpriv->LpsIdleCount >= 2) { //  4 Sec
+			if(pwrpriv->pwr_mode == PS_MODE_ACTIVE) {
+				pwrpriv->bpower_saving = true;
+				rtw_set_ps_mode(rtlpriv, pwrpriv->power_mgnt, rtlpriv->registrypriv.smart_ps, 0);
+			}
+		} else
+			pwrpriv->LpsIdleCount++;
+	}
+
+//	DBG_871X("-LeisurePSEnter\n");
+
+
+}
+
+//
+//	Description:
+//		Leave the leisure power save mode.
+//
+void LPS_Leave(struct rtl_priv *rtlpriv)
+{
+#define LPS_LEAVE_TIMEOUT_MS 100
+
+	struct pwrctrl_priv	*pwrpriv = &rtlpriv->pwrctrlpriv;
+	uint32_t	 start_time;
+	uint8_t bAwake = false;
+
+
+
+
+//	DBG_871X("+LeisurePSLeave\n");
+
+	if (pwrpriv->bLeisurePs) {
+		if(pwrpriv->pwr_mode != PS_MODE_ACTIVE) {
+			rtw_set_ps_mode(rtlpriv, PS_MODE_ACTIVE, 0, 0);
+
+			if(pwrpriv->pwr_mode == PS_MODE_ACTIVE)
+				LPS_RF_ON_check(rtlpriv, LPS_LEAVE_TIMEOUT_MS);
+		}
+	}
+
+	pwrpriv->bpower_saving = false;
+
+//	DBG_871X("-LeisurePSLeave\n");
+
+
+}
+
+//
+// Description: Leave all power save mode: LPS, FwLPS, IPS if needed.
+// Move code to function by tynli. 2010.03.26.
+//
+void LeaveAllPowerSaveMode(struct rtl_priv *rtlpriv)
+{
+	struct mlme_priv	*pmlmepriv = &(rtlpriv->mlmepriv);
+	uint8_t	enqueue = 0;
+
+
+
+	//DBG_871X("%s.....\n",__FUNCTION__);
+	if (check_fwstate(pmlmepriv, _FW_LINKED) == true)
+	{ //connect
+		rtw_lps_ctrl_wk_cmd(rtlpriv, LPS_CTRL_LEAVE, enqueue);
+
+	} else {
+		if(rtlpriv->pwrctrlpriv.rf_pwrstate== ERFOFF) {
+#ifdef CONFIG_AUTOSUSPEND
+			if(rtlpriv->registrypriv.usbss_enable) 	{
+				usb_disable_autosuspend(rtl_usbdev(rtlpriv)->pusbdev);
+			} else
+#endif
+			{
+			}
+		}
+	}
+
+
+}
+
+void rtw_init_pwrctrl_priv(struct rtl_priv *rtlpriv)
+{
+	struct rtl_hal_cfg *cfg = rtlpriv->cfg;
+	struct pwrctrl_priv *pwrctrlpriv = &rtlpriv->pwrctrlpriv;
+
+
+
+	sema_init(&pwrctrlpriv->lock, 1);
+	pwrctrlpriv->rf_pwrstate = ERFON;
+	pwrctrlpriv->ips_enter_cnts=0;
+	pwrctrlpriv->ips_leave_cnts=0;
+	pwrctrlpriv->bips_processing = false;
+
+	pwrctrlpriv->ips_mode = cfg->mod_params->inactiveps;
+	pwrctrlpriv->ips_mode_req = cfg->mod_params->inactiveps;
+
+	pwrctrlpriv->pwr_state_check_interval = RTW_PWR_STATE_CHK_INTERVAL;
+	pwrctrlpriv->pwr_state_check_cnts = 0;
+	pwrctrlpriv->bInternalAutoSuspend = false;
+	pwrctrlpriv->bInSuspend = false;
+
+	pwrctrlpriv->LpsIdleCount = 0;
+	//pwrctrlpriv->FWCtrlPSMode =rtlpriv->registrypriv.power_mgnt;// PS_MODE_MIN;
+	pwrctrlpriv->power_mgnt =rtlpriv->registrypriv.power_mgnt;// PS_MODE_MIN;
+	pwrctrlpriv->bLeisurePs = (PS_MODE_ACTIVE != pwrctrlpriv->power_mgnt)?true:false;
+
+	pwrctrlpriv->fw_current_inpsmode = false;
+
+	pwrctrlpriv->rpwm = 0;
+	pwrctrlpriv->cpwm = PS_STATE_S4;
+
+	pwrctrlpriv->pwr_mode = PS_MODE_ACTIVE;
+	pwrctrlpriv->smart_ps = rtlpriv->registrypriv.smart_ps;
+	pwrctrlpriv->bcn_ant_mode = 0;
+
+	pwrctrlpriv->tog = 0x80;
+
+	pwrctrlpriv->btcoex_rfon = false;
+
+	_init_timer(&pwrctrlpriv->pwr_state_check_timer, rtlpriv->ndev, 
+		    pwr_state_check_handler, rtlpriv);
+
+
+
+}
+
+/*
+* rtw_pwr_wakeup - Wake the NIC up from: 1)IPS. 2)USB autosuspend
+* @rtlpriv: pointer to struct rtl_priv structure
+* @ips_deffer_ms: the ms wiil prevent from falling into IPS after wakeup
+* Return _SUCCESS or _FAIL
+*/
+
+int _rtw_pwr_wakeup(struct rtl_priv *rtlpriv, uint32_t	 ips_deffer_ms, const char *caller)
+{
+	struct pwrctrl_priv *pwrpriv = &rtlpriv->pwrctrlpriv;
+	struct mlme_priv *pmlmepriv = &rtlpriv->mlmepriv;
+	int ret = _SUCCESS;
+	uint32_t	 start = jiffies;
+
+
+	if (pwrpriv->ips_deny_time < jiffies + rtw_ms_to_systime(ips_deffer_ms))
+		pwrpriv->ips_deny_time = jiffies + rtw_ms_to_systime(ips_deffer_ms);
+
+
+	if (pwrpriv->ps_processing) {
+		RT_TRACE(rtlpriv, COMP_POWER, DBG_DMESG, "%s wait ps_processing...\n", __func__);
+		while (pwrpriv->ps_processing && rtw_get_passing_time_ms(start) <= 3000)
+			msleep(10);
+		if (pwrpriv->ps_processing)
+			RT_TRACE(rtlpriv, COMP_POWER, DBG_DMESG, "%s wait ps_processing timeout\n", __func__);
+		else
+			RT_TRACE(rtlpriv, COMP_POWER, DBG_DMESG, "%s wait ps_processing done\n", __func__);
+	}
+
+	if (pwrpriv->bInternalAutoSuspend == false && pwrpriv->bInSuspend) {
+		RT_TRACE(rtlpriv, COMP_POWER, DBG_DMESG, "%s wait bInSuspend...\n", __func__);
+		while (pwrpriv->bInSuspend
+			&& ((rtw_get_passing_time_ms(start) <= 3000)
+				|| (rtw_get_passing_time_ms(start) <= 500))
+		) {
+			msleep(10);
+		}
+
+		if (pwrpriv->bInSuspend)
+			RT_TRACE(rtlpriv, COMP_POWER, DBG_DMESG, "%s wait bInSuspend timeout\n", __func__);
+		else
+			RT_TRACE(rtlpriv, COMP_POWER, DBG_DMESG, "%s wait bInSuspend done\n", __func__);
+	}
+
+	//System suspend is not allowed to wakeup
+	if ((pwrpriv->bInternalAutoSuspend == false) && (true == pwrpriv->bInSuspend )){
+		ret = _FAIL;
+		goto exit;
+	}
+
+	//block???
+	if ((pwrpriv->bInternalAutoSuspend == true)  && (rtlpriv->net_closed == true)) {
+		ret = _FAIL;
+		goto exit;
+	}
+
+	//I think this should be check in IPS, LPS, autosuspend functions...
+	if (check_fwstate(pmlmepriv, _FW_LINKED) == true) {
+		ret = _SUCCESS;
+		goto exit;
+	}
+
+	if (ERFOFF == pwrpriv->rf_pwrstate ) {
+#ifdef CONFIG_AUTOSUSPEND
+		if (pwrpriv->brfoffbyhw==true) {
+			RT_TRACE(rtlpriv, COMP_POWER, DBG_DMESG, "hw still in ERFOFF state ...........\n");
+			ret = _FAIL;
+			goto exit;
+		} else if (rtlpriv->registrypriv.usbss_enable) {
+			RT_TRACE(rtlpriv, COMP_POWER, DBG_DMESG, "%s call autoresume_enter....\n",__FUNCTION__);
+			if (_FAIL ==  autoresume_enter(rtlpriv)) {
+				RT_TRACE(rtlpriv, COMP_POWER, DBG_DMESG, "======> autoresume fail.............\n");
+				ret = _FAIL;
+				goto exit;
+			}
+		} else
+#endif
+		{
+			RT_TRACE(rtlpriv, COMP_POWER, DBG_DMESG, "%s call ips_leave....\n",__FUNCTION__);
+			if (_FAIL ==  rtw_ips_leave(rtlpriv)) {
+				RT_TRACE(rtlpriv, COMP_POWER, DBG_DMESG, "======> ips_leave fail.............\n");
+				ret = _FAIL;
+				goto exit;
+			}
+		}
+	}
+
+	//TODO: the following checking need to be merged...
+	if (rtlpriv->bDriverStopped
+		|| !rtlpriv->initialized
+		|| !rtlpriv->hw_init_completed
+	){
+		RT_TRACE(rtlpriv, COMP_POWER, DBG_DMESG, "%s: bDriverStopped=%d, initialized=%d, hw_init_completed=%u\n"
+			, caller
+		   	, rtlpriv->bDriverStopped
+		   	, rtlpriv->initialized
+		   	, rtlpriv->hw_init_completed);
+		ret= false;
+		goto exit;
+	}
+
+exit:
+	if (pwrpriv->ips_deny_time < jiffies + rtw_ms_to_systime(ips_deffer_ms))
+		pwrpriv->ips_deny_time = jiffies + rtw_ms_to_systime(ips_deffer_ms);
+	return ret;
+
+}
+
+int rtw_pm_set_lps(struct rtl_priv *rtlpriv, uint8_t mode)
+{
+	int	ret = 0;
+	struct pwrctrl_priv *pwrctrlpriv = &rtlpriv->pwrctrlpriv;
+
+	if (mode < PS_MODE_NUM) {
+		if (pwrctrlpriv->power_mgnt !=mode) {
+			if (PS_MODE_ACTIVE == mode) {
+				LeaveAllPowerSaveMode(rtlpriv);
+			} else {
+				pwrctrlpriv->LpsIdleCount = 2;
+			}
+			pwrctrlpriv->power_mgnt = mode;
+			pwrctrlpriv->bLeisurePs = (PS_MODE_ACTIVE != pwrctrlpriv->power_mgnt)?true:false;
+		}
+	} else {
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+int rtw_pm_set_ips(struct rtl_priv *rtlpriv, uint8_t mode)
+{
+	struct pwrctrl_priv *pwrctrlpriv = &rtlpriv->pwrctrlpriv;
+
+	if (mode == IPS_NORMAL) {
+		pwrctrlpriv->ips_mode_req = mode;
+		RT_TRACE(rtlpriv, COMP_POWER, DBG_DMESG, "%s %s\n", __FUNCTION__, "IPS_NORMAL");
+		return 0;
+	} else if ( mode ==IPS_NONE) {
+		pwrctrlpriv->ips_mode_req = mode;
+		RT_TRACE(rtlpriv, COMP_POWER, DBG_DMESG, "%s %s\n", __FUNCTION__, "IPS_NONE");
+		if ((rtlpriv->bSurpriseRemoved ==0)&&(_FAIL == rtw_pwr_wakeup(rtlpriv)) )
+			return -EFAULT;
+	} else {
+		return -EINVAL;
+	}
+	return 0;
+}
+
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/core/rtw_recv.c linux-4.9.8821au/drivers/staging/rtl8821au/core/rtw_recv.c
--- linux-4.9/drivers/staging/rtl8821au/core/rtw_recv.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/core/rtw_recv.c	2016-12-11 19:48:25.153645128 -0600
@@ -0,0 +1,2622 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#define _RTW_RECV_C_
+
+#include <linux/etherdevice.h>
+#include <drv_types.h>
+#include <rtw_ap.h>
+
+#undef DBG_871X
+static inline void DBG_871X(const char *fmt, ...)
+{
+}
+
+static struct list_head *get_next(struct list_head	*list)
+{
+	return list->next;
+}
+
+#ifdef CONFIG_NEW_SIGNAL_STAT_PROCESS
+void rtw_signal_stat_timer_hdl(RTW_TIMER_HDL_ARGS);
+#endif
+
+
+void _rtw_init_sta_recv_priv(struct sta_recv_priv *psta_recvpriv)
+{
+	memset((uint8_t *)psta_recvpriv, 0, sizeof (struct sta_recv_priv));
+
+	spin_lock_init(&psta_recvpriv->lock);
+
+	/*
+	 * for(i=0; i<MAX_RX_NUMBLKS; i++)
+	 * 	_rtw_init_queue(&psta_recvpriv->blk_strms[i]);
+	 */
+
+	_rtw_init_queue(&psta_recvpriv->defrag_q);
+
+}
+
+int _rtw_init_recv_priv(struct recv_priv *precvpriv, struct rtl_priv *rtlpriv)
+{
+	int i;
+
+	struct recv_frame *precvframe;
+
+	int	res=_SUCCESS;
+
+
+	/*
+	 * We don't need to memset rtlpriv->XXX to zero, because rtlpriv is allocated by rtw_zvmalloc().
+	 * memset((unsigned char *)precvpriv, 0, sizeof (struct  recv_priv));
+	 */
+
+	spin_lock_init(&precvpriv->lock);
+
+	_rtw_init_queue(&precvpriv->free_recv_queue);
+	_rtw_init_queue(&precvpriv->recv_pending_queue);
+	_rtw_init_queue(&precvpriv->uc_swdec_pending_queue);
+
+	precvpriv->rtlpriv = rtlpriv;
+
+	precvpriv->free_recvframe_cnt = NR_RECVFRAME;
+
+	precvpriv->pallocated_frame_buf = rtw_zvmalloc(NR_RECVFRAME * sizeof(struct recv_frame) + RXFRAME_ALIGN_SZ);
+
+	if (precvpriv->pallocated_frame_buf==NULL){
+		res= _FAIL;
+		goto exit;
+	}
+
+	/*
+	 * memset(precvpriv->pallocated_frame_buf, 0, NR_RECVFRAME * sizeof(struct recv_frame) + RXFRAME_ALIGN_SZ);
+	 */
+
+	precvpriv->precv_frame_buf = (uint8_t *)N_BYTE_ALIGMENT((SIZE_PTR)(precvpriv->pallocated_frame_buf), RXFRAME_ALIGN_SZ);
+
+	/*
+	 * precvpriv->precv_frame_buf = precvpriv->pallocated_frame_buf + RXFRAME_ALIGN_SZ -
+	 * 						((SIZE_PTR) (precvpriv->pallocated_frame_buf) &(RXFRAME_ALIGN_SZ-1));
+	 */
+
+	precvframe = (struct recv_frame*) precvpriv->precv_frame_buf;
+
+	for (i = 0; i < NR_RECVFRAME ; i++) {
+		INIT_LIST_HEAD(&(precvframe->list));
+
+		list_add_tail(&(precvframe->list), &(precvpriv->free_recv_queue.list));
+
+		precvframe->skb = NULL;
+		precvframe->len = 0;
+
+		precvframe->rtlpriv =rtlpriv;
+		precvframe++;
+
+	}
+
+
+	precvpriv->rx_pending_cnt=1;
+
+	sema_init(&precvpriv->allrxreturnevt, 0);
+
+
+	res = rtlpriv->cfg->ops->init_recv_priv(rtlpriv);
+
+#ifdef CONFIG_NEW_SIGNAL_STAT_PROCESS
+	_init_timer(&precvpriv->signal_stat_timer, rtlpriv->ndev,
+		    RTW_TIMER_HDL_NAME(signal_stat), rtlpriv);
+
+	precvpriv->signal_stat_sampling_interval = 1000; /* ms */
+	/* precvpriv->signal_stat_converging_constant = 5000; ms */
+
+	rtw_set_signal_stat_timer(precvpriv);
+#endif
+
+exit:
+
+
+
+	return res;
+
+}
+
+void _rtw_free_recv_priv (struct recv_priv *precvpriv)
+{
+	struct rtl_priv	*rtlpriv = precvpriv->rtlpriv;
+
+	rtw_free_uc_swdec_pending_queue(rtlpriv);
+
+	if(precvpriv->pallocated_frame_buf) {
+		rtw_vmfree(precvpriv->pallocated_frame_buf);
+	}
+
+	rtlpriv->cfg->ops->free_recv_priv(rtlpriv);
+}
+
+struct recv_frame *_rtw_alloc_recvframe (struct __queue *pfree_recv_queue)
+{
+
+	struct recv_frame  *precvframe;
+	struct list_head	*plist, *phead;
+	struct rtl_priv *rtlpriv;
+	struct recv_priv *precvpriv;
+
+	if (list_empty(&pfree_recv_queue->list)) {
+		precvframe = NULL;
+	} else {
+		phead = get_list_head(pfree_recv_queue);
+
+		plist = get_next(phead);
+
+		precvframe = container_of(plist, struct recv_frame, list);
+
+		list_del_init(&precvframe->list);
+		rtlpriv=precvframe->rtlpriv;
+		if(rtlpriv !=NULL){
+			precvpriv=&rtlpriv->recvpriv;
+			if(pfree_recv_queue == &precvpriv->free_recv_queue)
+				precvpriv->free_recvframe_cnt--;
+		}
+	}
+
+	return precvframe;
+}
+
+struct recv_frame *rtw_alloc_recvframe (struct __queue *pfree_recv_queue)
+{
+	struct recv_frame  *precvframe;
+
+	spin_lock_bh(&pfree_recv_queue->lock);
+
+	precvframe = _rtw_alloc_recvframe(pfree_recv_queue);
+
+	spin_unlock_bh(&pfree_recv_queue->lock);
+
+	return precvframe;
+}
+
+void rtw_init_recvframe(struct recv_frame *precvframe, struct recv_priv *precvpriv)
+{
+	/* Perry: This can be removed */
+	INIT_LIST_HEAD(&precvframe->list);
+
+	precvframe->len=0;
+}
+
+int rtw_free_recvframe(struct recv_frame *precvframe, struct __queue *pfree_recv_queue)
+{
+	struct rtl_priv *rtlpriv=precvframe->rtlpriv;
+	struct recv_priv *precvpriv = &rtlpriv->recvpriv;
+
+
+
+	rtw_os_free_recvframe(precvframe);
+
+	spin_lock_bh(&pfree_recv_queue->lock);
+
+	list_del_init(&(precvframe->list));
+
+	precvframe->len = 0;
+
+	list_add_tail(&(precvframe->list), get_list_head(pfree_recv_queue));
+
+	if (rtlpriv !=NULL){
+		if(pfree_recv_queue == &precvpriv->free_recv_queue)
+				precvpriv->free_recvframe_cnt++;
+	}
+
+	spin_unlock_bh(&pfree_recv_queue->lock);
+
+	return _SUCCESS;
+}
+
+
+
+
+int _rtw_enqueue_recvframe(struct recv_frame *precvframe, struct __queue *queue)
+{
+
+	struct rtl_priv *rtlpriv=precvframe->rtlpriv;
+	struct recv_priv *precvpriv = &rtlpriv->recvpriv;
+
+	/*INIT_LIST_HEAD(&(precvframe->u.hdr.list)); */
+	list_del_init(&(precvframe->list));
+	list_add_tail(&(precvframe->list), get_list_head(queue));
+
+	if (rtlpriv != NULL) {
+		if (queue == &precvpriv->free_recv_queue)
+			precvpriv->free_recvframe_cnt++;
+	}
+
+	return _SUCCESS;
+}
+
+int rtw_enqueue_recvframe(struct recv_frame *precvframe, struct __queue *queue)
+{
+	int ret;
+
+	/* _spinlock(&pfree_recv_queue->lock); */
+	spin_lock_bh(&queue->lock);
+	ret = _rtw_enqueue_recvframe(precvframe, queue);
+	/* spin_unlock(&pfree_recv_queue->lock); */
+	spin_unlock_bh(&queue->lock);
+
+	return ret;
+}
+
+/*
+int	rtw_enqueue_recvframe(struct recv_frame *precvframe, struct __queue *queue)
+{
+	return rtw_free_recvframe(precvframe, queue);
+}
+*/
+
+
+
+
+/*
+caller : defrag ; recvframe_chk_defrag in recv_thread  (passive)
+pframequeue: defrag_queue : will be accessed in recv_thread  (passive)
+
+using spinlock to protect
+
+*/
+
+void rtw_free_recvframe_queue(struct __queue *pframequeue,  struct __queue *pfree_recv_queue)
+{
+	struct recv_frame *precvframe;
+	struct list_head	*plist, *phead;
+
+	spin_lock(&pframequeue->lock);
+
+	phead = get_list_head(pframequeue);
+	plist = get_next(phead);
+
+	while (rtw_end_of_queue_search(phead, plist) == false) {
+		precvframe = container_of(plist, struct recv_frame, list);
+
+		plist = get_next(plist);
+
+		/*
+		 * list_del_init(&precvframe->u.hdr.list);
+		 * will do this in rtw_free_recvframe()
+		 */
+
+		rtw_free_recvframe(precvframe, pfree_recv_queue);
+	}
+
+	spin_unlock(&pframequeue->lock);
+
+
+}
+
+uint32_t rtw_free_uc_swdec_pending_queue(struct rtl_priv *rtlpriv)
+{
+	uint32_t cnt = 0;
+	struct recv_frame *pending_frame;
+
+	while ((pending_frame=rtw_alloc_recvframe(&rtlpriv->recvpriv.uc_swdec_pending_queue))) {
+		rtw_free_recvframe(pending_frame, &rtlpriv->recvpriv.free_recv_queue);
+		DBG_871X("%s: dequeue uc_swdec_pending_queue\n", __func__);
+		cnt++;
+	}
+
+	return cnt;
+}
+
+
+int rtw_enqueue_recvbuf_to_head(struct recv_buf *precvbuf, struct __queue *queue)
+{
+	spin_lock_bh(&queue->lock);
+
+	list_del_init(&precvbuf->list);
+	list_add(&precvbuf->list, get_list_head(queue));
+
+	spin_unlock_bh(&queue->lock);
+
+	return _SUCCESS;
+}
+
+int rtw_enqueue_recvbuf(struct recv_buf *precvbuf, struct __queue *queue)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&queue->lock, flags);
+
+	list_del_init(&precvbuf->list);
+	list_add_tail(&precvbuf->list, get_list_head(queue));
+	spin_unlock_irqrestore(&queue->lock, flags);
+	return _SUCCESS;
+}
+
+struct recv_buf *rtw_dequeue_recvbuf (struct __queue *queue)
+{
+	unsigned long flags;
+	struct recv_buf *precvbuf;
+	struct list_head	*plist, *phead;
+
+	spin_lock_irqsave(&queue->lock, flags);
+
+	if(list_empty(&queue->list)) {
+		precvbuf = NULL;
+	} else {
+		phead = get_list_head(queue);
+
+		plist = get_next(phead);
+
+		precvbuf = container_of(plist, struct recv_buf, list);
+
+		list_del_init(&precvbuf->list);
+
+	}
+
+	spin_unlock_irqrestore(&queue->lock, flags);
+
+	return precvbuf;
+
+}
+
+int recvframe_chkmic(struct rtl_priv *rtlpriv,  struct recv_frame *precvframe);
+int recvframe_chkmic(struct rtl_priv *rtlpriv,  struct recv_frame *precvframe){
+
+	int	i,res=_SUCCESS;
+	uint32_t	datalen;
+	uint8_t	miccode[8];
+	uint8_t	bmic_err=false,brpt_micerror = true;
+	uint8_t	*pframe, *payload,*pframemic;
+	uint8_t	*mickey;
+	/* uint8_t	*iv,rxdata_key_idx=0; */
+	struct	sta_info		*stainfo;
+	struct	rx_pkt_attrib	*prxattrib=&precvframe->attrib;
+	struct 	security_priv	*psecuritypriv=&rtlpriv->securitypriv;
+
+	struct mlme_ext_priv	*pmlmeext = &rtlpriv->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	stainfo=rtw_get_stainfo(&rtlpriv->stapriv ,&prxattrib->ta[0]);
+
+	if (prxattrib->encrypt == TKIP_ENCRYPTION) {
+		/* calculate mic code */
+		if (stainfo != NULL) {
+			if (is_multicast_ether_addr(prxattrib->ra)) {
+				/*
+				 * mickey=&psecuritypriv->dot118021XGrprxmickey.skey[0];
+				 * iv = precvframe->u.hdr.rx_data+prxattrib->hdrlen;
+				 * rxdata_key_idx =( ((iv[3])>>6)&0x3) ;
+				 * mickey=&psecuritypriv->dot118021XGrprxmickey[prxattrib->key_index].skey[0];
+				 */
+
+				/*
+				 * DBG_871X("\n recvframe_chkmic: bcmc key psecuritypriv->dot118021XGrpKeyid(%d),pmlmeinfo->key_index(%d) ,recv key_id(%d)\n",
+				 * psecuritypriv->dot118021XGrpKeyid,pmlmeinfo->key_index,rxdata_key_idx);
+				 */
+
+				if (psecuritypriv->binstallGrpkey == false) {
+					res=_FAIL;
+					DBG_871X("\n recvframe_chkmic:didn't install group key!!!!!!!!!!\n");
+					goto exit;
+				}
+			} else{
+				mickey=&stainfo->dot11tkiprxmickey.skey[0];
+			}
+
+			datalen=precvframe->len-prxattrib->hdrlen-prxattrib->iv_len-prxattrib->icv_len-8;//icv_len included the mic code
+			pframe=precvframe->rx_data;
+			payload=pframe+prxattrib->hdrlen+prxattrib->iv_len;
+
+			/*
+			 * rtw_seccalctkipmic(&stainfo->dot11tkiprxmickey.skey[0],pframe,payload, datalen ,&miccode[0],(unsigned char)prxattrib->priority); //care the length of the data
+			 */
+
+			rtw_seccalctkipmic(mickey,pframe,payload, datalen ,&miccode[0],(unsigned char)prxattrib->priority); //care the length of the data
+
+			pframemic=payload+datalen;
+
+			bmic_err=false;
+
+			for (i = 0; i < 8; i++) {
+				if (miccode[i] != *(pframemic+i)){
+					bmic_err=true;
+				}
+			}
+
+
+			if (bmic_err == true) {
+				{
+					uint i;
+					for(i=0;i<precvframe->len;i=i+8){
+						;
+					}
+				}
+
+
+				/*
+				 * double check key_index for some timing issue ,
+				 * cannot compare with psecuritypriv->dot118021XGrpKeyid also cause timing issue
+				 */
+
+				if((is_multicast_ether_addr(prxattrib->ra)==true)  && (prxattrib->key_index != pmlmeinfo->key_index ))
+					brpt_micerror = false;
+
+				if((prxattrib->bdecrypted ==true)&& (brpt_micerror == true)) {
+					rtw_handle_tkip_mic_err(rtlpriv,(uint8_t)is_multicast_ether_addr(prxattrib->ra));
+					DBG_871X(" mic error :prxattrib->bdecrypted=%d\n",prxattrib->bdecrypted);
+				} else {
+					DBG_871X(" mic error :prxattrib->bdecrypted=%d\n",prxattrib->bdecrypted);
+				}
+
+				res=_FAIL;
+
+			} else {
+				/* mic checked ok */
+				if((psecuritypriv->bcheck_grpkey ==false)&&(is_multicast_ether_addr(prxattrib->ra)==true)){
+					psecuritypriv->bcheck_grpkey =true;
+				}
+			}
+
+		} else 	{
+		}
+
+		recvframe_pull_tail(precvframe, 8);
+
+	}
+
+exit:
+
+	return res;
+
+}
+
+//decrypt and set the ivlen,icvlen of the recv_frame
+struct recv_frame * decryptor(struct rtl_priv *rtlpriv,struct recv_frame *precv_frame);
+struct recv_frame * decryptor(struct rtl_priv *rtlpriv,struct recv_frame *precv_frame)
+{
+
+	struct rx_pkt_attrib *prxattrib = &precv_frame->attrib;
+	struct security_priv *psecuritypriv=&rtlpriv->securitypriv;
+	struct recv_frame *return_packet=precv_frame;
+	uint32_t	 res=_SUCCESS;
+
+	if (prxattrib->encrypt>0) {
+		uint8_t *iv = precv_frame->rx_data+prxattrib->hdrlen;
+		prxattrib->key_index = ( ((iv[3])>>6)&0x3) ;
+
+		if(prxattrib->key_index > WEP_KEYS) {
+			DBG_871X("prxattrib->key_index(%d) > WEP_KEYS \n", prxattrib->key_index);
+
+			switch(prxattrib->encrypt){
+			case WEP40_ENCRYPTION:
+			case WEP104_ENCRYPTION:
+				prxattrib->key_index = psecuritypriv->dot11PrivacyKeyIndex;
+				break;
+			case TKIP_ENCRYPTION:
+			case AESCCMP_ENCRYPTION:
+			default:
+				prxattrib->key_index = psecuritypriv->dot118021XGrpKeyid;
+				break;
+			}
+		}
+	}
+
+	if ((prxattrib->encrypt>0) && ((prxattrib->bdecrypted==0) ||(psecuritypriv->sw_decrypt==true))) {
+
+		psecuritypriv->hw_decrypted=false;
+
+#ifdef DBG_RX_DECRYPTOR
+		DBG_871X("prxstat->bdecrypted:%d,  prxattrib->encrypt:%d,  Setting psecuritypriv->hw_decrypted = %d\n"
+			, prxattrib->bdecrypted ,prxattrib->encrypt, psecuritypriv->hw_decrypted);
+#endif
+
+		switch (prxattrib->encrypt) {
+		case WEP40_ENCRYPTION:
+		case WEP104_ENCRYPTION:
+			rtw_wep_decrypt(rtlpriv, precv_frame);
+			break;
+		case TKIP_ENCRYPTION:
+			res = rtw_tkip_decrypt(rtlpriv, precv_frame);
+			break;
+		case AESCCMP_ENCRYPTION:
+			res = rtw_aes_decrypt(rtlpriv, precv_frame);
+			break;
+		default:
+				break;
+		}
+	} else if(prxattrib->bdecrypted==1
+		&& prxattrib->encrypt >0
+		&& (psecuritypriv->busetkipkey==1 || prxattrib->encrypt !=TKIP_ENCRYPTION )
+		)
+	{
+		{
+			psecuritypriv->hw_decrypted=true;
+			#ifdef DBG_RX_DECRYPTOR
+			DBG_871X("prxstat->bdecrypted:%d,  prxattrib->encrypt:%d,  Setting psecuritypriv->hw_decrypted = %d\n"
+			, prxattrib->bdecrypted ,prxattrib->encrypt, psecuritypriv->hw_decrypted);
+			#endif
+
+		}
+	} else {
+		#ifdef DBG_RX_DECRYPTOR
+		DBG_871X("prxstat->bdecrypted:%d,  prxattrib->encrypt:%d,  psecuritypriv->hw_decrypted:%d\n"
+		, prxattrib->bdecrypted ,prxattrib->encrypt, psecuritypriv->hw_decrypted);
+		#endif
+	}
+
+	if(res == _FAIL) {
+		rtw_free_recvframe(return_packet,&rtlpriv->recvpriv.free_recv_queue);
+		return_packet = NULL;
+
+	}
+	//recvframe_chkmic(rtlpriv, precv_frame);   //move to recvframme_defrag function
+
+	return return_packet;
+
+}
+//###set the security information in the recv_frame
+struct recv_frame *portctrl(struct rtl_priv *rtlpriv,struct recv_frame * precv_frame);
+struct recv_frame * portctrl(struct rtl_priv *rtlpriv,struct recv_frame * precv_frame)
+{
+	uint8_t   *psta_addr, *ptr;
+	uint  auth_alg;
+	struct sta_info *psta;
+	struct sta_priv *pstapriv ;
+	struct recv_frame *prtnframe;
+	u16	ether_type=0;
+	u16  eapol_type = 0x888e;//for Funia BD's WPA issue
+	struct rx_pkt_attrib *pattrib;
+
+	pstapriv = &rtlpriv->stapriv;
+	psta = rtw_get_stainfo(pstapriv, psta_addr);
+
+	auth_alg = rtlpriv->securitypriv.dot11AuthAlgrthm;
+
+	ptr = get_recvframe_data(precv_frame);
+	pattrib = &precv_frame->attrib;
+	psta_addr = pattrib->ta;
+
+	prtnframe = NULL;
+
+	if (auth_alg == 2) {
+		if ((psta != NULL) && (psta->ieee8021x_blocked)) {
+			/*
+			 * blocked
+			 * only accept EAPOL frame
+			 */
+			prtnframe=precv_frame;
+
+			/* get ether_type */
+			ptr=ptr+precv_frame->attrib.hdrlen+precv_frame->attrib.iv_len+LLC_HEADER_SIZE;
+			memcpy(&ether_type,ptr, 2);
+			ether_type= ntohs((unsigned short )ether_type);
+
+		        if (ether_type == eapol_type) {
+				prtnframe=precv_frame;
+			} else {
+				//free this frame
+				rtw_free_recvframe(precv_frame, &rtlpriv->recvpriv.free_recv_queue);
+				prtnframe=NULL;
+			}
+		} else {
+			/*
+			 * allowed
+			 * check decryption status, and decrypt the frame if needed
+			 */
+
+			if (pattrib->bdecrypted == 0) {
+				;
+			}
+
+			prtnframe=precv_frame;
+			/* check is the EAPOL frame or not (Rekey) */
+			if (ether_type == eapol_type) {
+
+				/* check Rekey */
+
+				prtnframe=precv_frame;
+			} else {
+				;
+			}
+		}
+	} else {
+		prtnframe=precv_frame;
+	}
+
+	return prtnframe;
+
+}
+
+int recv_decache(struct recv_frame *precv_frame, uint8_t bretry, struct stainfo_rxcache *prxcache);
+int recv_decache(struct recv_frame *precv_frame, uint8_t bretry, struct stainfo_rxcache *prxcache)
+{
+	int tid = precv_frame->attrib.priority;
+
+	u16 seq_ctrl = ( (precv_frame->attrib.seq_num&0xffff) << 4) |
+		(precv_frame->attrib.frag_num & 0xf);
+
+	if (tid > 15) {
+		return _FAIL;
+	}
+
+	if (1) { 	/* if(bretry) */
+		if(seq_ctrl == prxcache->tid_rxseq[tid]) {
+			return _FAIL;
+		}
+	}
+
+	prxcache->tid_rxseq[tid] = seq_ctrl;
+
+	return _SUCCESS;
+
+}
+
+void process_pwrbit_data(struct rtl_priv *rtlpriv, struct recv_frame *precv_frame);
+void process_pwrbit_data(struct rtl_priv *rtlpriv, struct recv_frame *precv_frame)
+{
+#ifdef CONFIG_AP_MODE
+	unsigned char pwrbit;
+	uint8_t *ptr = precv_frame->rx_data;
+	struct rx_pkt_attrib *pattrib = &precv_frame->attrib;
+	struct sta_priv *pstapriv = &rtlpriv->stapriv;
+	struct sta_info *psta=NULL;
+
+	psta = rtw_get_stainfo(pstapriv, pattrib->src);
+
+	pwrbit = GetPwrMgt(ptr);
+
+	if (psta) {
+		if (pwrbit) {
+			if (!(psta->state & WIFI_SLEEP_STATE)) {
+				/*
+				 * psta->state |= WIFI_SLEEP_STATE;
+				 * pstapriv->sta_dz_bitmap |= BIT(psta->aid);
+				 */
+
+				stop_sta_xmit(rtlpriv, psta);
+
+				/* DBG_871X("to sleep, sta_dz_bitmap=%x\n", pstapriv->sta_dz_bitmap); */
+			}
+		} else {
+			if (psta->state & WIFI_SLEEP_STATE) {
+				/*
+				 * psta->state ^= WIFI_SLEEP_STATE;
+				 * pstapriv->sta_dz_bitmap &= ~BIT(psta->aid);
+				 */
+
+				 wakeup_sta_to_xmit(rtlpriv, psta);
+
+				/*
+				 *DBG_871X("to wakeup, sta_dz_bitmap=%x\n", pstapriv->sta_dz_bitmap);
+				 */
+
+			}
+		}
+
+	}
+
+#endif
+}
+
+void process_wmmps_data(struct rtl_priv *rtlpriv, struct recv_frame *precv_frame);
+void process_wmmps_data(struct rtl_priv *rtlpriv, struct recv_frame *precv_frame)
+{
+#ifdef CONFIG_AP_MODE
+	struct rx_pkt_attrib *pattrib = &precv_frame->attrib;
+	struct sta_priv *pstapriv = &rtlpriv->stapriv;
+	struct sta_info *psta=NULL;
+
+	psta = rtw_get_stainfo(pstapriv, pattrib->src);
+
+	if (!psta)
+		return;
+
+
+	if(!psta->qos_option)
+		return;
+
+	if(!(psta->qos_info&0xf))
+		return;
+
+
+	if (psta->state & WIFI_SLEEP_STATE) {
+		uint8_t wmmps_ac=0;
+
+		switch (pattrib->priority) {
+		case 1:
+		case 2:
+			wmmps_ac = psta->uapsd_bk&BIT(1);
+			break;
+		case 4:
+		case 5:
+			wmmps_ac = psta->uapsd_vi&BIT(1);
+			break;
+		case 6:
+		case 7:
+			wmmps_ac = psta->uapsd_vo&BIT(1);
+			break;
+		case 0:
+		case 3:
+		default:
+			wmmps_ac = psta->uapsd_be&BIT(1);
+			break;
+		}
+
+		if (wmmps_ac) {
+			if (psta->sleepq_ac_len>0) {
+				/* process received triggered frame */
+				xmit_delivery_enabled_frames(rtlpriv, psta);
+			} else {
+				/* issue one qos null frame with More data bit = 0 and the EOSP bit set (=1) */
+				issue_qos_nulldata(rtlpriv, psta->hwaddr, (u16)pattrib->priority, 0, 0);
+			}
+		}
+
+	}
+
+
+#endif
+
+}
+
+
+void count_rx_stats(struct rtl_priv *rtlpriv, struct recv_frame *prframe, struct sta_info*sta);
+void count_rx_stats(struct rtl_priv *rtlpriv, struct recv_frame *prframe, struct sta_info*sta)
+{
+	int	sz;
+	struct sta_info		*psta = NULL;
+	struct stainfo_stats	*pstats = NULL;
+	struct rx_pkt_attrib	*pattrib = & prframe->attrib;
+	struct recv_priv		*precvpriv = &rtlpriv->recvpriv;
+
+	sz = get_recvframe_len(prframe);
+	precvpriv->rx_bytes += sz;
+
+	rtlpriv->mlmepriv.LinkDetectInfo.NumRxOkInPeriod++;
+
+	if( (!MacAddr_isBcst(pattrib->dst)) && (!is_multicast_ether_addr(pattrib->dst))){
+		rtlpriv->mlmepriv.LinkDetectInfo.NumRxUnicastOkInPeriod++;
+	}
+
+	if(sta)
+		psta = sta;
+	else
+		psta = prframe->psta;
+
+	if(psta) {
+		pstats = &psta->sta_stats;
+
+		pstats->rx_data_pkts++;
+		pstats->rx_bytes += sz;
+	}
+
+}
+
+int sta2sta_data_frame(
+	struct rtl_priv *rtlpriv,
+	struct recv_frame *precv_frame,
+	struct sta_info**psta
+);
+
+int sta2sta_data_frame(
+	struct rtl_priv *rtlpriv,
+	struct recv_frame *precv_frame,
+	struct sta_info**psta)
+{
+	uint8_t *ptr = precv_frame->rx_data;
+	int ret = _SUCCESS;
+	struct rx_pkt_attrib *pattrib = & precv_frame->attrib;
+	struct	sta_priv 		*pstapriv = &rtlpriv->stapriv;
+	struct	mlme_priv	*pmlmepriv = &rtlpriv->mlmepriv;
+	uint8_t *mybssid  = get_bssid(pmlmepriv);
+	uint8_t *myhwaddr = rtlpriv->mac80211.mac_addr;
+	uint8_t * sta_addr = NULL;
+	int bmcast = is_multicast_ether_addr(pattrib->dst);
+
+
+
+
+	if ((check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true) ||
+		(check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true))
+	{
+
+		// filter packets that SA is myself or multicast or broadcast
+		if (_rtw_memcmp(myhwaddr, pattrib->src, ETH_ALEN)){
+			ret= _FAIL;
+			goto exit;
+		}
+
+		if( (!_rtw_memcmp(myhwaddr, pattrib->dst, ETH_ALEN))	&& (!bmcast) ){
+			ret= _FAIL;
+			goto exit;
+		}
+
+		if( _rtw_memcmp(pattrib->bssid, "\x0\x0\x0\x0\x0\x0", ETH_ALEN) ||
+		   _rtw_memcmp(mybssid, "\x0\x0\x0\x0\x0\x0", ETH_ALEN) ||
+		   (!_rtw_memcmp(pattrib->bssid, mybssid, ETH_ALEN)) ) {
+			ret= _FAIL;
+			goto exit;
+		}
+
+		sta_addr = pattrib->src;
+
+	} else if(check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true)
+	{
+		{
+			// For Station mode, sa and bssid should always be BSSID, and DA is my mac-address
+			if(!_rtw_memcmp(pattrib->bssid, pattrib->src, ETH_ALEN) )
+			{
+				ret= _FAIL;
+				goto exit;
+		}
+
+		sta_addr = pattrib->bssid;
+		}
+
+	}
+	else if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == true) {
+		if (bmcast) {
+			// For AP mode, if DA == MCAST, then BSSID should be also MCAST
+			if (!is_multicast_ether_addr(pattrib->bssid)){
+					ret= _FAIL;
+					goto exit;
+			}
+		} else { // not mc-frame
+			// For AP mode, if DA is non-MCAST, then it must be BSSID, and bssid == BSSID
+			if(!_rtw_memcmp(pattrib->bssid, pattrib->dst, ETH_ALEN)) {
+				ret= _FAIL;
+				goto exit;
+			}
+
+			sta_addr = pattrib->src;
+		}
+
+	} else if(check_fwstate(pmlmepriv, WIFI_MP_STATE) == true) {
+		memcpy(pattrib->dst, GetAddr1Ptr(ptr), ETH_ALEN);
+		memcpy(pattrib->src, GetAddr2Ptr(ptr), ETH_ALEN);
+		memcpy(pattrib->bssid, GetAddr3Ptr(ptr), ETH_ALEN);
+		memcpy(pattrib->ra, pattrib->dst, ETH_ALEN);
+		memcpy(pattrib->ta, pattrib->src, ETH_ALEN);
+
+		sta_addr = mybssid;
+	} else {
+		ret  = _FAIL;
+	}
+
+
+
+	if(bmcast)
+		*psta = rtw_get_bcmc_stainfo(rtlpriv);
+	else
+		*psta = rtw_get_stainfo(pstapriv, sta_addr); // get ap_info
+
+
+	if (*psta == NULL) {
+		ret= _FAIL;
+		goto exit;
+	}
+
+exit:
+
+	return ret;
+
+}
+
+int ap2sta_data_frame(
+	struct rtl_priv *rtlpriv,
+	struct recv_frame *precv_frame,
+	struct sta_info**psta );
+int ap2sta_data_frame(
+	struct rtl_priv *rtlpriv,
+	struct recv_frame *precv_frame,
+	struct sta_info**psta )
+{
+	uint8_t *ptr = precv_frame->rx_data;
+	struct rx_pkt_attrib *pattrib = & precv_frame->attrib;
+	int ret = _SUCCESS;
+	struct	sta_priv 		*pstapriv = &rtlpriv->stapriv;
+	struct	mlme_priv	*pmlmepriv = &rtlpriv->mlmepriv;
+	uint8_t *mybssid  = get_bssid(pmlmepriv);
+	uint8_t *myhwaddr = rtlpriv->mac80211.mac_addr;
+	int bmcast = is_multicast_ether_addr(pattrib->dst);
+
+
+
+	if ((check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true)
+		&& (check_fwstate(pmlmepriv, _FW_LINKED) == true
+			|| check_fwstate(pmlmepriv, _FW_UNDER_LINKING) == true	)
+		)
+	{
+
+		/*  filter packets that SA is myself or multicast or broadcast */
+		if (_rtw_memcmp(myhwaddr, pattrib->src, ETH_ALEN)){
+			ret= _FAIL;
+			goto exit;
+		}
+
+		/* da should be for me */
+		if((!_rtw_memcmp(myhwaddr, pattrib->dst, ETH_ALEN))&& (!bmcast))
+		{
+			ret= _FAIL;
+			goto exit;
+		}
+
+
+		/* check BSSID */
+		if( _rtw_memcmp(pattrib->bssid, "\x0\x0\x0\x0\x0\x0", ETH_ALEN) ||
+		     _rtw_memcmp(mybssid, "\x0\x0\x0\x0\x0\x0", ETH_ALEN) ||
+		     (!_rtw_memcmp(pattrib->bssid, mybssid, ETH_ALEN)) )
+		{
+			if(!bmcast)
+			{
+				DBG_871X("issue_deauth to the nonassociated ap=" MAC_FMT " for the reason(7)\n", MAC_ARG(pattrib->bssid));
+				issue_deauth(rtlpriv, pattrib->bssid, WLAN_REASON_CLASS3_FRAME_FROM_NONASSOC_STA);
+			}
+
+			ret= _FAIL;
+			goto exit;
+		}
+
+		if(bmcast)
+			*psta = rtw_get_bcmc_stainfo(rtlpriv);
+		else
+			*psta = rtw_get_stainfo(pstapriv, pattrib->bssid); // get ap_info
+
+		if (*psta == NULL) {
+			ret= _FAIL;
+			goto exit;
+		}
+
+		if ((GetFrameSubType(ptr) & WIFI_QOS_DATA_TYPE) == WIFI_QOS_DATA_TYPE) {
+		}
+
+		if (GetFrameSubType(ptr) & BIT(6)) {
+			/* No data, will not indicate to upper layer, temporily count it here */
+			count_rx_stats(rtlpriv, precv_frame, *psta);
+			ret = RTW_RX_HANDLED;
+			goto exit;
+		}
+
+	} else if ((check_fwstate(pmlmepriv, WIFI_MP_STATE) == true)
+		  && (check_fwstate(pmlmepriv, _FW_LINKED) == true)) {
+		memcpy(pattrib->dst, GetAddr1Ptr(ptr), ETH_ALEN);
+		memcpy(pattrib->src, GetAddr2Ptr(ptr), ETH_ALEN);
+		memcpy(pattrib->bssid, GetAddr3Ptr(ptr), ETH_ALEN);
+		memcpy(pattrib->ra, pattrib->dst, ETH_ALEN);
+		memcpy(pattrib->ta, pattrib->src, ETH_ALEN);
+
+		//
+		memcpy(pattrib->bssid,  mybssid, ETH_ALEN);
+
+
+		*psta = rtw_get_stainfo(pstapriv, pattrib->bssid); // get sta_info
+		if (*psta == NULL) {
+			ret= _FAIL;
+			goto exit;
+		}
+
+
+	} else if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true) {
+		/* Special case */
+		ret = RTW_RX_HANDLED;
+		goto exit;
+	} else {
+		if(_rtw_memcmp(myhwaddr, pattrib->dst, ETH_ALEN)&& (!bmcast)) {
+			*psta = rtw_get_stainfo(pstapriv, pattrib->bssid); // get sta_info
+			if (*psta == NULL) {
+				DBG_871X("issue_deauth to the ap=" MAC_FMT " for the reason(7)\n", MAC_ARG(pattrib->bssid));
+
+				issue_deauth(rtlpriv, pattrib->bssid, WLAN_REASON_CLASS3_FRAME_FROM_NONASSOC_STA);
+			}
+		}
+
+		ret = _FAIL;
+	}
+
+exit:
+
+
+
+	return ret;
+
+}
+
+int sta2ap_data_frame(
+	struct rtl_priv *rtlpriv,
+	struct recv_frame *precv_frame,
+	struct sta_info**psta );
+int sta2ap_data_frame(
+	struct rtl_priv *rtlpriv,
+	struct recv_frame *precv_frame,
+	struct sta_info**psta )
+{
+	uint8_t *ptr = precv_frame->rx_data;
+	struct rx_pkt_attrib *pattrib = & precv_frame->attrib;
+	struct	sta_priv 		*pstapriv = &rtlpriv->stapriv;
+	struct	mlme_priv	*pmlmepriv = &rtlpriv->mlmepriv;
+	unsigned char *mybssid  = get_bssid(pmlmepriv);
+	int ret=_SUCCESS;
+
+
+
+	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)
+	{
+		//For AP mode, RA=BSSID, TX=STA(SRC_ADDR), A3=DST_ADDR
+		if(!_rtw_memcmp(pattrib->bssid, mybssid, ETH_ALEN))
+		{
+			ret= _FAIL;
+			goto exit;
+		}
+
+		*psta = rtw_get_stainfo(pstapriv, pattrib->src);
+		if (*psta == NULL)
+		{
+			DBG_871X("issue_deauth to sta=" MAC_FMT " for the reason(7)\n", MAC_ARG(pattrib->src));
+
+			issue_deauth(rtlpriv, pattrib->src, WLAN_REASON_CLASS3_FRAME_FROM_NONASSOC_STA);
+
+			ret = RTW_RX_HANDLED;
+			goto exit;
+		}
+
+		process_pwrbit_data(rtlpriv, precv_frame);
+
+		if ((GetFrameSubType(ptr) & WIFI_QOS_DATA_TYPE) == WIFI_QOS_DATA_TYPE) {
+			process_wmmps_data(rtlpriv, precv_frame);
+		}
+
+		if (GetFrameSubType(ptr) & BIT(6)) {
+			/* No data, will not indicate to upper layer, temporily count it here */
+			count_rx_stats(rtlpriv, precv_frame, *psta);
+			ret = RTW_RX_HANDLED;
+			goto exit;
+		}
+	}
+	else {
+		uint8_t *myhwaddr = rtlpriv->mac80211.mac_addr;
+		if (!_rtw_memcmp(pattrib->ra, myhwaddr, ETH_ALEN)) {
+			ret = RTW_RX_HANDLED;
+			goto exit;
+		}
+		DBG_871X("issue_deauth to sta=" MAC_FMT " for the reason(7)\n", MAC_ARG(pattrib->src));
+		issue_deauth(rtlpriv, pattrib->src, WLAN_REASON_CLASS3_FRAME_FROM_NONASSOC_STA);
+		ret = RTW_RX_HANDLED;
+		goto exit;
+	}
+
+exit:
+
+
+
+	return ret;
+
+}
+
+int validate_recv_ctrl_frame(struct rtl_priv *rtlpriv, struct recv_frame *precv_frame);
+int validate_recv_ctrl_frame(struct rtl_priv *rtlpriv, struct recv_frame *precv_frame)
+{
+#ifdef CONFIG_AP_MODE
+	struct rx_pkt_attrib *pattrib = &precv_frame->attrib;
+	struct sta_priv *pstapriv = &rtlpriv->stapriv;
+	uint8_t *pframe = precv_frame->rx_data;
+
+	/* uint len = precv_frame->u.hdr.len; */
+
+	/* DBG_871X("+validate_recv_ctrl_frame\n"); */
+
+	if (GetFrameType(pframe) != WIFI_CTRL_TYPE)
+	{
+		return _FAIL;
+	}
+
+	/* receive the frames that ra(a1) is my address */
+	if (!_rtw_memcmp(GetAddr1Ptr(pframe), rtlpriv->mac80211.mac_addr, ETH_ALEN))
+	{
+		return _FAIL;
+	}
+
+	/* only handle ps-poll */
+	if (GetFrameSubType(pframe) == WIFI_PSPOLL)
+	{
+		u16 aid;
+		uint8_t wmmps_ac=0;
+		struct sta_info *psta=NULL;
+
+		aid = GetAid(pframe);
+		psta = rtw_get_stainfo(pstapriv, GetAddr2Ptr(pframe));
+
+		if ((psta==NULL) || (psta->aid!=aid)) {
+			return _FAIL;
+		}
+
+		/* for rx pkt statistics */
+		psta->sta_stats.rx_ctrl_pkts++;
+
+		switch(pattrib->priority) {
+		case 1:
+		case 2:
+			wmmps_ac = psta->uapsd_bk&BIT(0);
+			break;
+		case 4:
+		case 5:
+			wmmps_ac = psta->uapsd_vi&BIT(0);
+			break;
+		case 6:
+		case 7:
+			wmmps_ac = psta->uapsd_vo&BIT(0);
+			break;
+		case 0:
+		case 3:
+		default:
+			wmmps_ac = psta->uapsd_be&BIT(0);
+			break;
+		}
+
+		if(wmmps_ac)
+			return _FAIL;
+
+		if(psta->state & WIFI_STA_ALIVE_CHK_STATE) {
+			DBG_871X("%s alive check-rx ps-poll\n", __func__);
+			psta->expire_to = pstapriv->expire_to;
+			psta->state ^= WIFI_STA_ALIVE_CHK_STATE;
+		}
+
+		if ((psta->state&WIFI_SLEEP_STATE)
+		   && (pstapriv->sta_dz_bitmap&BIT(psta->aid))) {
+			struct list_head	*xmitframe_plist, *xmitframe_phead;
+			struct xmit_frame *pxmitframe=NULL;
+			struct xmit_priv *pxmitpriv = &rtlpriv->xmitpriv;
+
+			/* spin_lock_bh(&psta->sleep_q.lock, &irqL);*/
+			spin_lock_bh(&pxmitpriv->lock);
+
+			xmitframe_phead = get_list_head(&psta->sleep_q);
+			xmitframe_plist = get_next(xmitframe_phead);
+
+			if ((rtw_end_of_queue_search(xmitframe_phead, xmitframe_plist)) == false) {
+				pxmitframe = container_of(xmitframe_plist, struct xmit_frame, list);
+
+				xmitframe_plist = get_next(xmitframe_plist);
+
+				list_del_init(&pxmitframe->list);
+
+				psta->sleepq_len--;
+
+				if(psta->sleepq_len>0)
+					pxmitframe->tx_attrib.mdata = 1;
+                                else
+					pxmitframe->tx_attrib.mdata = 0;
+
+				pxmitframe->tx_attrib.triggered = 1;
+
+	                        /*
+	                         * DBG_871X("handling ps-poll, q_len=%d, tim=%x\n", psta->sleepq_len, pstapriv->tim_bitmap);
+	                         */
+
+				rtlpriv->cfg->ops->hal_xmitframe_enqueue(rtlpriv, pxmitframe);
+
+				if (psta->sleepq_len==0) {
+					pstapriv->tim_bitmap &= ~BIT(psta->aid);
+
+					/*
+					 * DBG_871X("after handling ps-poll, tim=%x\n", pstapriv->tim_bitmap);
+					 */
+
+					/* upate BCN for TIM IE */
+					/* update_BCNTIM(rtlpriv); */
+					update_beacon(rtlpriv, _TIM_IE_, NULL, false);
+				}
+
+				/* spin_unlock_bh(&psta->sleep_q.lock, &irqL); */
+				spin_unlock_bh(&pxmitpriv->lock);
+			} else {
+				/* spin_unlock_bh(&psta->sleep_q.lock, &irqL); */
+				spin_unlock_bh(&pxmitpriv->lock);
+
+				/* DBG_871X("no buffered packets to xmit\n"); */
+				if (pstapriv->tim_bitmap&BIT(psta->aid)) {
+					if(psta->sleepq_len==0) {
+						DBG_871X("no buffered packets to xmit\n");
+
+						/* issue nulldata with More data bit = 0 to indicate we have no buffered packets */
+						issue_nulldata(rtlpriv, psta->hwaddr, 0, 0, 0);
+					} else {
+						DBG_871X("error!psta->sleepq_len=%d\n", psta->sleepq_len);
+						psta->sleepq_len=0;
+					}
+
+					pstapriv->tim_bitmap &= ~BIT(psta->aid);
+
+					/* upate BCN for TIM IE */
+					/* update_BCNTIM(rtlpriv); */
+					update_beacon(rtlpriv, _TIM_IE_, NULL, false);
+				}
+
+			}
+
+		}
+
+	}
+
+#endif
+
+	return _FAIL;
+
+}
+
+struct recv_frame* recvframe_chk_defrag(struct rtl_priv *rtlpriv, struct recv_frame *precv_frame);
+int validate_recv_mgnt_frame(struct rtl_priv *rtlpriv, struct recv_frame *precv_frame);
+int validate_recv_mgnt_frame(struct rtl_priv *rtlpriv, struct recv_frame *precv_frame)
+{
+	/* struct mlme_priv *pmlmepriv = &rtlpriv->mlmepriv; */
+
+	precv_frame = recvframe_chk_defrag(rtlpriv, precv_frame);
+	if (precv_frame == NULL) {
+		return _SUCCESS;
+	}
+
+	{
+		//for rx pkt statistics
+		struct sta_info *psta = rtw_get_stainfo(&rtlpriv->stapriv, GetAddr2Ptr(precv_frame->rx_data));
+		if (psta) {
+			psta->sta_stats.rx_mgnt_pkts++;
+			if (GetFrameSubType(precv_frame->rx_data) == WIFI_BEACON)
+				psta->sta_stats.rx_beacon_pkts++;
+			else if (GetFrameSubType(precv_frame->rx_data) == WIFI_PROBEREQ)
+				psta->sta_stats.rx_probereq_pkts++;
+			else if (GetFrameSubType(precv_frame->rx_data) == WIFI_PROBERSP) {
+				if (_rtw_memcmp(rtlpriv->mac80211.mac_addr, GetAddr1Ptr(precv_frame->rx_data), ETH_ALEN) == true)
+					psta->sta_stats.rx_probersp_pkts++;
+				else if (is_broadcast_mac_addr(GetAddr1Ptr(precv_frame->rx_data))
+					|| is_multicast_mac_addr(GetAddr1Ptr(precv_frame->rx_data)))
+					psta->sta_stats.rx_probersp_bm_pkts++;
+				else
+					psta->sta_stats.rx_probersp_uo_pkts++;
+			}
+		}
+	}
+
+	mgt_dispatcher(rtlpriv, precv_frame);
+
+	return _SUCCESS;
+
+}
+
+int validate_recv_data_frame(struct rtl_priv *rtlpriv, struct recv_frame *precv_frame);
+int validate_recv_data_frame(struct rtl_priv *rtlpriv, struct recv_frame *precv_frame)
+{
+	uint8_t bretry;
+	uint8_t *psa, *pda, *pbssid;
+	struct sta_info *psta = NULL;
+	uint8_t *ptr = precv_frame->rx_data;
+	struct rx_pkt_attrib	*pattrib = & precv_frame->attrib;
+	struct sta_priv 	*pstapriv = &rtlpriv->stapriv;
+	struct security_priv	*psecuritypriv = &rtlpriv->securitypriv;
+	int ret = _SUCCESS;
+
+	bretry = GetRetry(ptr);
+	pda = get_da(ptr);
+	psa = get_sa(ptr);
+	pbssid = get_hdr_bssid(ptr);
+
+	if(pbssid == NULL){
+		ret= _FAIL;
+		goto exit;
+	}
+
+	memcpy(pattrib->dst, pda, ETH_ALEN);
+	memcpy(pattrib->src, psa, ETH_ALEN);
+
+	memcpy(pattrib->bssid, pbssid, ETH_ALEN);
+
+	switch(pattrib->to_fr_ds) {
+	case 0:
+		memcpy(pattrib->ra, pda, ETH_ALEN);
+		memcpy(pattrib->ta, psa, ETH_ALEN);
+		ret = sta2sta_data_frame(rtlpriv, precv_frame, &psta);
+		break;
+
+	case 1:
+		memcpy(pattrib->ra, pda, ETH_ALEN);
+		memcpy(pattrib->ta, pbssid, ETH_ALEN);
+		ret = ap2sta_data_frame(rtlpriv, precv_frame, &psta);
+		break;
+
+	case 2:
+		memcpy(pattrib->ra, pbssid, ETH_ALEN);
+		memcpy(pattrib->ta, psa, ETH_ALEN);
+		ret = sta2ap_data_frame(rtlpriv, precv_frame, &psta);
+		break;
+
+	case 3:
+		memcpy(pattrib->ra, GetAddr1Ptr(ptr), ETH_ALEN);
+		memcpy(pattrib->ta, GetAddr2Ptr(ptr), ETH_ALEN);
+		ret =_FAIL;
+		break;
+
+	default:
+		ret =_FAIL;
+		break;
+	}
+
+	if(ret ==_FAIL){
+		goto exit;
+	} else if (ret == RTW_RX_HANDLED) {
+		goto exit;
+	}
+
+
+	if(psta==NULL){
+		ret= _FAIL;
+		goto exit;
+	}
+
+	/*
+	 * psta->rssi = prxcmd->rssi;
+	 * psta->signal_quality= prxcmd->sq;
+	 */
+
+	precv_frame->psta = psta;
+
+
+	pattrib->amsdu=0;
+	pattrib->ack_policy = 0;
+	/* parsing QC field */
+	if (pattrib->qos == 1) {
+		pattrib->priority = GetPriority((ptr + 24));
+		pattrib->ack_policy = GetAckpolicy((ptr + 24));
+		pattrib->amsdu = GetAMsdu((ptr + 24));
+		pattrib->hdrlen = pattrib->to_fr_ds==3 ? 32 : 26;
+
+		if(pattrib->priority!=0 && pattrib->priority!=3) {
+			rtlpriv->dm.is_any_nonbepkts = true;
+		}
+	} else {
+		pattrib->priority=0;
+		pattrib->hdrlen = pattrib->to_fr_ds==3 ? 30 : 24;
+	}
+
+
+	if(pattrib->order) {//HT-CTRL 11n
+		pattrib->hdrlen += 4;
+	}
+
+	precv_frame->preorder_ctrl = &psta->recvreorder_ctrl[pattrib->priority];
+
+	/* decache, drop duplicate recv packets */
+	if(recv_decache(precv_frame, bretry, &psta->sta_recvpriv.rxcache) == _FAIL) {
+		ret= _FAIL;
+		goto exit;
+	}
+
+	if(pattrib->privacy){
+		GET_ENCRY_ALGO(psecuritypriv, psta, pattrib->encrypt, is_multicast_ether_addr(pattrib->ra));
+
+		SET_ICE_IV_LEN(pattrib->iv_len, pattrib->icv_len, pattrib->encrypt);
+	}
+	else
+	{
+		pattrib->encrypt = 0;
+		pattrib->iv_len = pattrib->icv_len = 0;
+	}
+
+exit:
+
+	return ret;
+}
+
+int validate_recv_frame(struct rtl_priv *rtlpriv, struct recv_frame *precv_frame);
+int validate_recv_frame(struct rtl_priv *rtlpriv, struct recv_frame *precv_frame)
+{
+	/* shall check frame subtype, to / from ds, da, bssid */
+
+	/* then call check if rx seq/frag. duplicated. */
+
+	uint8_t type;
+	uint8_t subtype;
+	int retval = _SUCCESS;
+
+	struct rx_pkt_attrib *pattrib = & precv_frame->attrib;
+
+	uint8_t *ptr = precv_frame->rx_data;
+	uint8_t  ver =(unsigned char) (*ptr)&0x3 ;
+
+
+
+
+	/* add version chk */
+	if (ver != 0){
+		retval= _FAIL;
+		goto exit;
+	}
+
+	type =  GetFrameType(ptr);
+	subtype = GetFrameSubType(ptr); //bit(7)~bit(2)
+
+	pattrib->to_fr_ds = get_tofr_ds(ptr);
+
+	pattrib->frag_num = GetFragNum(ptr);
+	pattrib->seq_num = GetSequence(ptr);
+
+	pattrib->pw_save = GetPwrMgt(ptr);
+	pattrib->mfrag = GetMFrag(ptr);
+	pattrib->mdata = GetMData(ptr);
+	pattrib->privacy = GetPrivacy(ptr);
+	pattrib->order = GetOrder(ptr);
+
+	switch (type) {
+	case WIFI_MGT_TYPE: /* mgnt */
+		retval = validate_recv_mgnt_frame(rtlpriv, precv_frame);
+		if (retval == _FAIL)
+		{
+			;
+		}
+		retval = _FAIL; /* only data frame return _SUCCESS */
+		break;
+	case WIFI_CTRL_TYPE: //ctrl
+		retval = validate_recv_ctrl_frame(rtlpriv, precv_frame);
+		if (retval == _FAIL)
+		{
+			;
+		}
+		retval = _FAIL; /* only data frame return _SUCCESS */
+		break;
+	case WIFI_DATA_TYPE: /* data */
+		pattrib->qos = (subtype & BIT(7))? 1:0;
+		retval = validate_recv_data_frame(rtlpriv, precv_frame);
+		if (retval == _FAIL)
+		{
+			struct recv_priv *precvpriv = &rtlpriv->recvpriv;
+			//RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("validate_recv_data_frame fail\n"));
+			precvpriv->rx_drop++;
+		}
+		break;
+	default:
+		retval = _FAIL;
+		break;
+	}
+
+exit:
+
+	return retval;
+}
+
+
+/* remove the wlanhdr and add the eth_hdr */
+#if 1
+
+int wlanhdr_to_ethhdr ( struct recv_frame *precvframe);
+int wlanhdr_to_ethhdr ( struct recv_frame *precvframe)
+{
+	int rmv_len;
+	u16 eth_type, len;
+	uint8_t	bsnaphdr;
+	uint8_t	*psnap_type;
+	struct ieee80211_snap_hdr *psnap;
+
+	int ret=_SUCCESS;
+	struct rtl_priv *rtlpriv =precvframe->rtlpriv;
+	struct mlme_priv *pmlmepriv = &rtlpriv->mlmepriv;
+
+	uint8_t	*ptr = get_recvframe_data(precvframe) ; /*  point to frame_ctrl field */
+	struct rx_pkt_attrib *pattrib = & precvframe->attrib;
+
+	if (pattrib->encrypt) {
+		recvframe_pull_tail(precvframe, pattrib->icv_len);
+	}
+
+	psnap=(struct ieee80211_snap_hdr	*)(ptr+pattrib->hdrlen + pattrib->iv_len);
+	psnap_type=ptr+pattrib->hdrlen + pattrib->iv_len+SNAP_SIZE;
+
+	/* convert hdr + possible LLC headers into Ethernet header */
+	/* eth_type = (psnap_type[0] << 8) | psnap_type[1]; */
+
+	if((_rtw_memcmp(psnap, rtw_rfc1042_header, SNAP_SIZE) &&
+		(_rtw_memcmp(psnap_type, SNAP_ETH_TYPE_IPX, 2) == false) &&
+		(_rtw_memcmp(psnap_type, SNAP_ETH_TYPE_APPLETALK_AARP, 2)==false) )||
+		/* eth_type != ETH_P_AARP && eth_type != ETH_P_IPX) || */
+		 _rtw_memcmp(psnap, rtw_bridge_tunnel_header, SNAP_SIZE)){
+		 /* remove RFC1042 or Bridge-Tunnel encapsulation and replace EtherType */
+		bsnaphdr = true;
+	}
+	else {
+		/* Leave Ethernet header part of hdr and full payload */
+		bsnaphdr = false;
+	}
+
+	rmv_len = pattrib->hdrlen + pattrib->iv_len +(bsnaphdr?SNAP_SIZE:0);
+	len = precvframe->len - rmv_len;
+
+	memcpy(&eth_type, ptr+rmv_len, 2);
+	eth_type= ntohs((unsigned short )eth_type); //pattrib->ether_type
+	pattrib->eth_type = eth_type;
+
+	if ((check_fwstate(pmlmepriv, WIFI_MP_STATE) == true)) {
+		ptr += rmv_len ;
+		*ptr = 0x87;
+		*(ptr+1) = 0x12;
+
+		eth_type = 0x8712;
+		/* append rx status for mp test packets */
+		ptr = recvframe_pull(precvframe, (rmv_len-sizeof(struct ethhdr)+2)-24);
+		memcpy(ptr, get_rxmem(precvframe), 24);
+		ptr+=24;
+	} else {
+		ptr = recvframe_pull(precvframe, (rmv_len-sizeof(struct ethhdr)+ (bsnaphdr?2:0)));
+	}
+
+	memcpy(ptr, pattrib->dst, ETH_ALEN);
+	memcpy(ptr+ETH_ALEN, pattrib->src, ETH_ALEN);
+
+	if(!bsnaphdr) {
+		len = htons(len);
+		memcpy(ptr+12, &len, 2);
+	}
+
+
+	return ret;
+
+}
+
+#else
+
+int wlanhdr_to_ethhdr ( struct recv_frame *precvframe)
+{
+	int rmv_len;
+	u16 eth_type;
+	uint8_t	bsnaphdr;
+	uint8_t	*psnap_type;
+	struct ieee80211_snap_hdr	*psnap;
+
+	int ret=_SUCCESS;
+	struct rtl_priv	*rtlpriv =precvframe->u.hdr.rtlpriv;
+	struct	mlme_priv	*pmlmepriv = &rtlpriv->mlmepriv;
+
+	uint8_t * ptr = get_recvframe_data(precvframe) ; /* point to frame_ctrl field */
+	struct rx_pkt_attrib *pattrib = & precvframe->u.hdr.attrib;
+	struct _vlan *pvlan = NULL;
+
+
+
+	psnap=(struct ieee80211_snap_hdr *)(ptr+pattrib->hdrlen + pattrib->iv_len);
+	psnap_type=ptr+pattrib->hdrlen + pattrib->iv_len+SNAP_SIZE;
+	if (psnap->dsap==0xaa && psnap->ssap==0xaa && psnap->ctrl==0x03) {
+		if (_rtw_memcmp(psnap->oui, oui_rfc1042, WLAN_IEEE_OUI_LEN))
+			bsnaphdr=true;		/*wlan_pkt_format = WLAN_PKT_FORMAT_SNAP_RFC1042; */
+		else if (_rtw_memcmp(psnap->oui, SNAP_HDR_APPLETALK_DDP, WLAN_IEEE_OUI_LEN) &&
+			_rtw_memcmp(psnap_type, SNAP_ETH_TYPE_APPLETALK_DDP, 2) )
+			bsnaphdr=true;		/* wlan_pkt_format = WLAN_PKT_FORMAT_APPLETALK; */
+		else if (_rtw_memcmp( psnap->oui, oui_8021h, WLAN_IEEE_OUI_LEN))
+			bsnaphdr=true;		/*wlan_pkt_format = WLAN_PKT_FORMAT_SNAP_TUNNEL; */
+		else {
+			ret= _FAIL;
+			goto exit;
+		}
+
+	} else
+		bsnaphdr=false;	/* wlan_pkt_format = WLAN_PKT_FORMAT_OTHERS; */
+
+	rmv_len = pattrib->hdrlen + pattrib->iv_len +(bsnaphdr?SNAP_SIZE:0);
+
+	if (check_fwstate(pmlmepriv, WIFI_MP_STATE) == true) {
+		ptr += rmv_len ;
+		*ptr = 0x87;
+		*(ptr+1) = 0x12;
+
+		/* back to original pointer */
+		ptr -= rmv_len;
+	}
+
+	ptr += rmv_len ;
+
+	memcpy(&eth_type, ptr, 2);
+	eth_type= ntohs((unsigned short )eth_type); //pattrib->ether_type
+	ptr +=2;
+
+	if(pattrib->encrypt){
+		recvframe_pull_tail(precvframe, pattrib->icv_len);
+	}
+
+	if(eth_type == 0x8100) /* vlan */
+	{
+		pvlan = (struct _vlan *) ptr;
+
+		/*
+		 * eth_type = get_vlan_encap_proto(pvlan);
+		 * eth_type = pvlan->h_vlan_encapsulated_proto;//?
+		 */
+		rmv_len += 4;
+		ptr+=4;
+	}
+
+	if(eth_type==0x0800) { /* ip */
+		/*
+		 * struct iphdr*  piphdr = (struct iphdr*) ptr;
+		 * __uint8_t tos = (unsigned char)(pattrib->priority & 0xff);
+		 *
+		 * piphdr->tos = tos;
+		 *
+		 * if (piphdr->protocol == 0x06) {
+		 * 	RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("@@@===recv tcp len:%d @@@===\n", precvframe->u.hdr.len));
+		 * }
+		 */
+
+	} else if(eth_type==0x8712) { 	/* append rx status for mp test packets */
+		/*
+		 * ptr -= 16;
+		 * memcpy(ptr, get_rxmem(precvframe), 16);
+		 */
+	} else {
+	}
+
+	if(eth_type==0x8712) { 	/*  append rx status for mp test packets */
+		ptr = recvframe_pull(precvframe, (rmv_len-sizeof(struct ethhdr)+2)-24);
+		memcpy(ptr, get_rxmem(precvframe), 24);
+		ptr+=24;
+	} else
+		ptr = recvframe_pull(precvframe, (rmv_len-sizeof(struct ethhdr)+2));
+
+	memcpy(ptr, pattrib->dst, ETH_ALEN);
+	memcpy(ptr+ETH_ALEN, pattrib->src, ETH_ALEN);
+
+	eth_type = htons((unsigned short)eth_type) ;
+	memcpy(ptr+12, &eth_type, 2);
+
+exit:
+
+	return ret;
+}
+#endif
+
+/* perform defrag */
+
+struct recv_frame *recvframe_defrag(struct rtl_priv *rtlpriv,struct __queue *defrag_q);
+struct recv_frame *recvframe_defrag(struct rtl_priv *rtlpriv,struct __queue *defrag_q)
+{
+	struct list_head	 *plist, *phead;
+	uint8_t	*data,wlanhdr_offset;
+	uint8_t	curfragnum;
+	struct recv_frame* prframe, *pnextrframe;
+	struct __queue	*pfree_recv_queue;
+
+
+	curfragnum=0;
+	pfree_recv_queue=&rtlpriv->recvpriv.free_recv_queue;
+
+	phead = get_list_head(defrag_q);
+	plist = get_next(phead);
+	prframe = container_of(plist, struct recv_frame, list);
+	list_del_init(&(prframe->list));
+
+	if (curfragnum != prframe->attrib.frag_num) {
+		/*
+		 * the first fragment number must be 0
+		 * free the whole queue
+		 */
+		rtw_free_recvframe(prframe, pfree_recv_queue);
+		rtw_free_recvframe_queue(defrag_q, pfree_recv_queue);
+
+		return NULL;
+	}
+
+
+	curfragnum++;
+
+	plist= get_list_head(defrag_q);
+
+	plist = get_next(plist);
+
+	data=get_recvframe_data(prframe);
+
+	while (rtw_end_of_queue_search(phead, plist) == false) {
+		pnextrframe = container_of(plist, struct recv_frame , list);
+
+		/* check the fragment sequence  (2nd ~n fragment frame) */
+
+		if(curfragnum!=pnextrframe->attrib.frag_num) {
+			/*
+			 * the fragment number must be increasing  (after decache)
+			 * release the defrag_q & prframe
+			 */
+			rtw_free_recvframe(prframe, pfree_recv_queue);
+			rtw_free_recvframe_queue(defrag_q, pfree_recv_queue);
+			return NULL;
+		}
+
+		curfragnum++;
+
+		/*
+		 * copy the 2nd~n fragment frame's payload to the first fragment
+		 * get the 2nd~last fragment frame's payload
+		 */
+
+		wlanhdr_offset = pnextrframe->attrib.hdrlen + pnextrframe->attrib.iv_len;
+
+		recvframe_pull(pnextrframe, wlanhdr_offset);
+
+		/*
+		 * append  to first fragment frame's tail (if privacy frame, pull the ICV)
+		 */
+		recvframe_pull_tail(prframe, prframe->attrib.icv_len);
+
+		/* memcpy */
+		memcpy(prframe->rx_tail, pnextrframe->rx_data, pnextrframe->len);
+
+		recvframe_put(prframe, pnextrframe->len);
+
+		prframe->attrib.icv_len=pnextrframe->attrib.icv_len;
+		plist = get_next(plist);
+
+	};
+
+	/* free the defrag_q queue and return the prframe */
+	rtw_free_recvframe_queue(defrag_q, pfree_recv_queue);
+
+	return prframe;
+}
+
+/* check if need to defrag, if needed queue the frame to defrag_q */
+struct recv_frame* recvframe_chk_defrag(struct rtl_priv *rtlpriv, struct recv_frame *precv_frame)
+{
+	uint8_t	ismfrag;
+	uint8_t	fragnum;
+	uint8_t	*psta_addr;
+	struct sta_info *psta;
+	struct sta_priv *pstapriv;
+	struct list_head *phead;
+	struct recv_frame *prtnframe = NULL;
+	struct __queue *pfree_recv_queue, *pdefrag_q;
+
+	pstapriv = &rtlpriv->stapriv;
+
+	pfree_recv_queue = &rtlpriv->recvpriv.free_recv_queue;
+
+	/* need to define struct of wlan header frame ctrl */
+	ismfrag = precv_frame->attrib.mfrag;
+	fragnum = precv_frame->attrib.frag_num;
+
+	psta_addr = precv_frame->attrib.ta;
+	psta = rtw_get_stainfo(pstapriv, psta_addr);
+	if (psta == NULL) {
+		uint8_t type = GetFrameType(precv_frame->rx_data);
+		if (type != WIFI_DATA_TYPE) {
+			psta = rtw_get_bcmc_stainfo(rtlpriv);
+			pdefrag_q = &psta->sta_recvpriv.defrag_q;
+		} else
+			pdefrag_q = NULL;
+	} else
+		pdefrag_q = &psta->sta_recvpriv.defrag_q;
+
+	if ((ismfrag==0) && (fragnum==0)) {
+		prtnframe = precv_frame;	/* isn't a fragment frame */
+	}
+
+	if (ismfrag==1) {
+		/*
+		 * 0~(n-1) fragment frame
+		 * enqueue to defraf_g
+		 */
+
+		if (pdefrag_q != NULL) {
+			if (fragnum == 0) {
+				/* the first fragment */
+				if(!list_empty(&pdefrag_q->list)) {
+					/* free current defrag_q */
+					rtw_free_recvframe_queue(pdefrag_q, pfree_recv_queue);
+				}
+			}
+
+
+			/* Then enqueue the 0~(n-1) fragment into the defrag_q */
+
+			/* _rtw_spinlock(&pdefrag_q->lock); */
+			phead = get_list_head(pdefrag_q);
+			list_add_tail(&precv_frame->list, phead);
+			/* spin_unlock(&pdefrag_q->lock); */
+
+			prtnframe=NULL;
+
+		} else 	{
+			/* can't find this ta's defrag_queue, so free this recv_frame */
+			rtw_free_recvframe(precv_frame, pfree_recv_queue);
+			prtnframe=NULL;
+		}
+
+	}
+
+	if((ismfrag==0)&&(fragnum!=0)) {
+		/*
+		 * the last fragment frame
+		 * enqueue the last fragment
+		 */
+
+		if (pdefrag_q != NULL) {
+			/* _rtw_spinlock(&pdefrag_q->lock); */
+			phead = get_list_head(pdefrag_q);
+			list_add_tail(&precv_frame->list,phead);
+			/* spin_unlock(&pdefrag_q->lock); */
+
+			/* call recvframe_defrag to defrag */
+			precv_frame = recvframe_defrag(rtlpriv, pdefrag_q);
+			prtnframe=precv_frame;
+
+		} else {
+			/* can't find this ta's defrag_queue, so free this recv_frame */
+			rtw_free_recvframe(precv_frame, pfree_recv_queue);
+			prtnframe=NULL;
+		}
+
+	}
+
+	if((prtnframe!=NULL)&&(prtnframe->attrib.privacy)) {
+		/* after defrag we must check tkip mic code */
+		if(recvframe_chkmic(rtlpriv,  prtnframe)==_FAIL)
+		{
+			rtw_free_recvframe(prtnframe,pfree_recv_queue);
+			prtnframe=NULL;
+		}
+	}
+
+	return prtnframe;
+}
+
+int amsdu_to_msdu(struct rtl_priv *rtlpriv, struct recv_frame *prframe)
+{
+	int	a_len, padding_len;
+	u16	nSubframe_Length;
+	uint8_t	nr_subframes, i;
+	uint8_t	*pdata;
+	struct sk_buff *sub_pkt,*subframes[MAX_SUBFRAME_COUNT];
+	struct recv_priv *precvpriv = &rtlpriv->recvpriv;
+	struct __queue *pfree_recv_queue = &(precvpriv->free_recv_queue);
+	int	ret = _SUCCESS;
+
+	nr_subframes = 0;
+
+	recvframe_pull(prframe, prframe->attrib.hdrlen);
+
+	if (prframe->attrib.iv_len >0) {
+		recvframe_pull(prframe, prframe->attrib.iv_len);
+	}
+
+	a_len = prframe->len;
+
+	pdata = prframe->rx_data;
+
+	while (a_len > ETH_HLEN) {
+		/* Offset 12 denote 2 mac address */
+		nSubframe_Length = RTW_GET_BE16(pdata + 12);
+
+		if (a_len < (ETHERNET_HEADER_SIZE + nSubframe_Length) ) {
+			DBG_871X("nRemain_Length is %d and nSubframe_Length is : %d\n",a_len,nSubframe_Length);
+			break;
+		}
+
+		sub_pkt = rtw_os_alloc_msdu_pkt(prframe, nSubframe_Length, pdata);
+		if (sub_pkt == NULL) {
+			DBG_871X("%s(): allocate sub packet fail !!!\n",__FUNCTION__);
+			break;
+		}
+
+		/* move the data point to data content */
+		pdata += ETH_HLEN;
+		a_len -= ETH_HLEN;
+
+		subframes[nr_subframes++] = sub_pkt;
+
+		if (nr_subframes >= MAX_SUBFRAME_COUNT) {
+			DBG_871X("ParseSubframe(): Too many Subframes! Packets dropped!\n");
+			break;
+		}
+
+		pdata += nSubframe_Length;
+		a_len -= nSubframe_Length;
+		if (a_len != 0) {
+			padding_len = 4 - ((nSubframe_Length + ETH_HLEN) & (4-1));
+			if (padding_len == 4) {
+				padding_len = 0;
+			}
+
+			if (a_len < padding_len) {
+				DBG_871X("ParseSubframe(): a_len < padding_len !\n");
+				break;
+			}
+			pdata += padding_len;
+			a_len -= padding_len;
+		}
+	}
+
+	for (i = 0; i < nr_subframes; i++){
+		sub_pkt = subframes[i];
+
+		/* Indicat the packets to upper layer */
+		if (sub_pkt) {
+			rtw_os_recv_indicate_pkt(rtlpriv, sub_pkt, &prframe->attrib);
+		}
+	}
+
+	prframe->len = 0;
+	rtw_free_recvframe(prframe, pfree_recv_queue);//free this recv_frame
+
+	return ret;
+}
+
+int check_indicate_seq(struct recv_reorder_ctrl *preorder_ctrl, u16 seq_num);
+int check_indicate_seq(struct recv_reorder_ctrl *preorder_ctrl, u16 seq_num)
+{
+	uint8_t	wsize = preorder_ctrl->wsize_b;
+	u16	wend = (preorder_ctrl->indicate_seq + wsize -1) & 0xFFF;//% 4096;
+
+	/*  Rx Reorder initialize condition. */
+	if (preorder_ctrl->indicate_seq == 0xFFFF) {
+		preorder_ctrl->indicate_seq = seq_num;
+
+		/*
+		 * DbgPrint("check_indicate_seq, 1st->indicate_seq=%d\n", precvpriv->indicate_seq);
+		 */
+	}
+
+	/*
+	 * DbgPrint("enter->check_indicate_seq(): IndicateSeq: %d, NewSeq: %d\n", precvpriv->indicate_seq, seq_num);
+	 */
+
+	/* Drop out the packet which SeqNum is smaller than WinStart */
+	if( SN_LESS(seq_num, preorder_ctrl->indicate_seq) ) {
+		/*
+		 * RT_TRACE(COMP_RX_REORDER, DBG_LOUD, ("CheckRxTsIndicateSeq(): Packet Drop! IndicateSeq: %d, NewSeq: %d\n", pTS->RxIndicateSeq, NewSeqNum));
+		 * DbgPrint("CheckRxTsIndicateSeq(): Packet Drop! IndicateSeq: %d, NewSeq: %d\n", precvpriv->indicate_seq, seq_num);
+		 */
+		return false;
+	}
+
+	/*
+	 * Sliding window manipulation. Conditions includes:
+	 * 1. Incoming SeqNum is equal to WinStart =>Window shift 1
+	 * 2. Incoming SeqNum is larger than the WinEnd => Window shift N
+	 */
+
+	if (SN_EQUAL(seq_num, preorder_ctrl->indicate_seq)) {
+		preorder_ctrl->indicate_seq = (preorder_ctrl->indicate_seq + 1) & 0xFFF;
+	} else if(SN_LESS(wend, seq_num)) {
+		/*
+		 * RT_TRACE(COMP_RX_REORDER, DBG_LOUD, ("CheckRxTsIndicateSeq(): Window Shift! IndicateSeq: %d, NewSeq: %d\n", pTS->RxIndicateSeq, NewSeqNum));
+		 * DbgPrint("CheckRxTsIndicateSeq(): Window Shift! IndicateSeq: %d, NewSeq: %d\n", precvpriv->indicate_seq, seq_num);
+		 */
+
+		/* boundary situation, when seq_num cross 0xFFF */
+		if(seq_num >= (wsize - 1))
+			preorder_ctrl->indicate_seq = seq_num + 1 -wsize;
+		else
+			preorder_ctrl->indicate_seq = 0xFFF - (wsize - (seq_num + 1)) + 1;
+
+	}
+
+	/*
+	 * DbgPrint("exit->check_indicate_seq(): IndicateSeq: %d, NewSeq: %d\n", precvpriv->indicate_seq, seq_num);
+	 */
+
+	return true;
+}
+
+int enqueue_reorder_recvframe(struct recv_reorder_ctrl *preorder_ctrl, struct recv_frame *prframe);
+int enqueue_reorder_recvframe(struct recv_reorder_ctrl *preorder_ctrl, struct recv_frame *prframe)
+{
+	struct rx_pkt_attrib *pattrib = &prframe->attrib;
+	struct __queue *ppending_recvframe_queue = &preorder_ctrl->pending_recvframe_queue;
+	struct list_head	*phead, *plist;
+	struct recv_frame *pnextrframe;
+	struct rx_pkt_attrib *pnextattrib;
+
+	/* DbgPrint("+enqueue_reorder_recvframe()\n"); */
+
+	/*
+	 * spin_lock_irqsave(&ppending_recvframe_queue->lock, &irql);
+	 * _rtw_spinlock_ex(&ppending_recvframe_queue->lock);
+	 */
+
+
+	phead = get_list_head(ppending_recvframe_queue);
+	plist = get_next(phead);
+
+	while (rtw_end_of_queue_search(phead, plist) == false) {
+		pnextrframe = container_of(plist, struct recv_frame, list);
+		pnextattrib = &pnextrframe->attrib;
+
+		if (SN_LESS(pnextattrib->seq_num, pattrib->seq_num)) {
+			plist = get_next(plist);
+		} else if( SN_EQUAL(pnextattrib->seq_num, pattrib->seq_num)) {
+			/*
+			 * Duplicate entry is found!! Do not insert current entry.
+			 * RT_TRACE(COMP_RX_REORDER, DBG_TRACE, ("InsertRxReorderList(): Duplicate packet is dropped!! IndicateSeq: %d, NewSeq: %d\n", pTS->RxIndicateSeq, SeqNum));
+			 */
+
+			/*
+			 * spin_unlock_irqrestore(&ppending_recvframe_queue->lock, &irql);
+			 */
+
+			return false;
+		} else {
+			break;
+		}
+
+		/* DbgPrint("enqueue_reorder_recvframe():while\n"); */
+	}
+
+
+	/*
+	 * spin_lock_irqsave(&ppending_recvframe_queue->lock, &irql);
+	 * _rtw_spinlock_ex(&ppending_recvframe_queue->lock);
+	 */
+
+	list_del_init(&(prframe->list));
+
+	list_add_tail(&(prframe->list), plist);
+
+	/*
+	 * _rtw_spinunlock_ex(&ppending_recvframe_queue->lock);
+	 *spin_unlock_irqrestore(&ppending_recvframe_queue->lock, &irql);
+	 */
+
+
+	/*
+	 * RT_TRACE(COMP_RX_REORDER, DBG_TRACE, ("InsertRxReorderList(): Pkt insert into buffer!! IndicateSeq: %d, NewSeq: %d\n", pTS->RxIndicateSeq, SeqNum));
+	 */
+	return true;
+
+}
+
+int recv_indicatepkts_in_order(struct rtl_priv *rtlpriv, struct recv_reorder_ctrl *preorder_ctrl, int bforced);
+int recv_indicatepkts_in_order(struct rtl_priv *rtlpriv, struct recv_reorder_ctrl *preorder_ctrl, int bforced)
+{
+	/* _irqL irql; */
+	/* uint8_t bcancelled; */
+	struct list_head	*phead, *plist;
+	struct recv_frame *prframe;
+	struct rx_pkt_attrib *pattrib;
+	/* uint8_t index = 0; */
+	int bPktInBuf = false;
+	struct recv_priv *precvpriv = &rtlpriv->recvpriv;
+	struct __queue *ppending_recvframe_queue = &preorder_ctrl->pending_recvframe_queue;
+
+	/* DbgPrint("+recv_indicatepkts_in_order\n"); */
+
+	/*
+	 * spin_lock_irqsave(&ppending_recvframe_queue->lock, &irql);
+	 * _rtw_spinlock_ex(&ppending_recvframe_queue->lock);
+	 */
+
+	phead = 	get_list_head(ppending_recvframe_queue);
+	plist = get_next(phead);
+
+	/* Handling some condition for forced indicate case. */
+	if (bforced==true) {
+		if(list_empty(phead)) {
+			/*
+			 * spin_unlock_irqrestore(&ppending_recvframe_queue->lock, &irql);
+			 * _rtw_spinunlock_ex(&ppending_recvframe_queue->lock);
+			 */
+			return true;
+		}
+
+		 prframe = container_of(plist, struct recv_frame, list);
+	        pattrib = &prframe->attrib;
+		preorder_ctrl->indicate_seq = pattrib->seq_num;
+	}
+
+	/*
+	 *  Prepare indication list and indication.
+	 * Check if there is any packet need indicate.
+	 */
+
+	while (!list_empty(phead)) {
+
+		prframe = container_of(plist, struct recv_frame, list);
+		pattrib = &prframe->attrib;
+
+		if(!SN_LESS(preorder_ctrl->indicate_seq, pattrib->seq_num)) {
+			plist = get_next(plist);
+			list_del_init(&(prframe->list));
+
+			if(SN_EQUAL(preorder_ctrl->indicate_seq, pattrib->seq_num)) {
+				preorder_ctrl->indicate_seq = (preorder_ctrl->indicate_seq + 1) & 0xFFF;
+			}
+
+			/*
+			 * Set this as a lock to make sure that only one thread is indicating packet.
+			 * pTS->RxIndicateState = RXTS_INDICATE_PROCESSING;
+			 */
+
+			/*
+			 * Indicate packets
+			 * RT_ASSERT((index<=REORDER_WIN_SIZE), ("RxReorderIndicatePacket(): Rx Reorder buffer full!! \n"));
+			 */
+
+			/*
+			 * indicate this recv_frame
+			 * DbgPrint("recv_indicatepkts_in_order, indicate_seq=%d, seq_num=%d\n", precvpriv->indicate_seq, pattrib->seq_num);
+			 */
+
+			if (!pattrib->amsdu) {
+				/* DBG_871X("recv_indicatepkts_in_order, amsdu!=1, indicate_seq=%d, seq_num=%d\n", preorder_ctrl->indicate_seq, pattrib->seq_num); */
+
+				if ((rtlpriv->bDriverStopped == false)
+				  && (rtlpriv->bSurpriseRemoved == false)) {
+					rtw_recv_indicatepkt(rtlpriv, prframe);//indicate this recv_frame
+
+				}
+			} else if (pattrib->amsdu == 1) {
+				if (amsdu_to_msdu(rtlpriv, prframe) != _SUCCESS) {
+					rtw_free_recvframe(prframe, &precvpriv->free_recv_queue);
+				}
+			} else 	{
+				/* error condition; */
+			}
+
+
+			/* Update local variables. */
+			bPktInBuf = false;
+
+		} else {
+			bPktInBuf = true;
+			break;
+		}
+
+		/* DbgPrint("recv_indicatepkts_in_order():while\n"); */
+
+	}
+
+	/*
+	 * _rtw_spinunlock_ex(&ppending_recvframe_queue->lock);
+	 * spin_unlock_irqrestore(&ppending_recvframe_queue->lock, &irql);
+	 */
+
+
+/*
+	//Release the indication lock and set to new indication step.
+	if(bPktInBuf)
+	{
+		// Set new pending timer.
+		//pTS->RxIndicateState = RXTS_INDICATE_REORDER;
+		//PlatformSetTimer(rtlpriv, &pTS->RxPktPendingTimer, pHTInfo->RxReorderPendingTime);
+		//DBG_871X("_set_timer(&preorder_ctrl->reordering_ctrl_timer, REORDER_WAIT_TIME)\n");
+		_set_timer(&preorder_ctrl->reordering_ctrl_timer, REORDER_WAIT_TIME);
+	}
+	else
+	{
+		//pTS->RxIndicateState = RXTS_INDICATE_IDLE;
+	}
+*/
+	/* spin_unlock_irqrestore(&ppending_recvframe_queue->lock, &irql); */
+
+	/* return true; */
+	return bPktInBuf;
+
+}
+
+int recv_indicatepkt_reorder(struct rtl_priv *rtlpriv, struct recv_frame *prframe);
+int recv_indicatepkt_reorder(struct rtl_priv *rtlpriv, struct recv_frame *prframe)
+{
+	int retval = _SUCCESS;
+	struct rx_pkt_attrib *pattrib = &prframe->attrib;
+	struct recv_reorder_ctrl *preorder_ctrl = prframe->preorder_ctrl;
+	struct __queue *ppending_recvframe_queue = &preorder_ctrl->pending_recvframe_queue;
+
+	if(!pattrib->amsdu)
+	{
+		//s1.
+		wlanhdr_to_ethhdr(prframe);
+
+		if ((pattrib->qos!=1) /*|| pattrib->priority!=0 || is_multicast_ether_addr(pattrib->ra)*/
+			|| (pattrib->eth_type==0x0806) || (pattrib->ack_policy!=0))
+		{
+			if ((rtlpriv->bDriverStopped == false) &&
+			    (rtlpriv->bSurpriseRemoved == false))
+			{
+				rtw_recv_indicatepkt(rtlpriv, prframe);
+				return _SUCCESS;
+
+			}
+
+
+			return _FAIL;
+
+		}
+
+		if (preorder_ctrl->enable == false)
+		{
+			//indicate this recv_frame
+			preorder_ctrl->indicate_seq = pattrib->seq_num;
+
+			rtw_recv_indicatepkt(rtlpriv, prframe);
+
+			preorder_ctrl->indicate_seq = (preorder_ctrl->indicate_seq + 1)%4096;
+
+			return _SUCCESS;
+		}
+
+#ifndef CONFIG_RECV_REORDERING_CTRL
+		//indicate this recv_frame
+		rtw_recv_indicatepkt(rtlpriv, prframe);
+		return _SUCCESS;
+#endif
+
+	}
+	else if(pattrib->amsdu==1) //temp filter -> means didn't support A-MSDUs in a A-MPDU
+	{
+		if (preorder_ctrl->enable == false)
+		{
+			preorder_ctrl->indicate_seq = pattrib->seq_num;
+
+			retval = amsdu_to_msdu(rtlpriv, prframe);
+
+			preorder_ctrl->indicate_seq = (preorder_ctrl->indicate_seq + 1)%4096;
+
+			if(retval != _SUCCESS){
+			}
+
+			return retval;
+		}
+	}
+	else
+	{
+
+	}
+
+	spin_lock_bh(&ppending_recvframe_queue->lock);
+
+	//s2. check if winstart_b(indicate_seq) needs to been updated
+	if(!check_indicate_seq(preorder_ctrl, pattrib->seq_num))
+	{
+		//pHTInfo->RxReorderDropCounter++;
+		//ReturnRFDList(rtlpriv, pRfd);
+		//RT_TRACE(COMP_RX_REORDER, DBG_TRACE, ("RxReorderIndicatePacket() ==> Packet Drop!!\n"));
+		//spin_unlock_irqrestore(&ppending_recvframe_queue->lock, &irql);
+		//return _FAIL;
+
+		goto _err_exit;
+	}
+
+
+	//s3. Insert all packet into Reorder Queue to maintain its ordering.
+	if(!enqueue_reorder_recvframe(preorder_ctrl, prframe))
+	{
+		//DbgPrint("recv_indicatepkt_reorder, enqueue_reorder_recvframe fail!\n");
+		//spin_unlock_irqrestore(&ppending_recvframe_queue->lock, &irql);
+		//return _FAIL;
+		goto _err_exit;
+	}
+
+
+	//s4.
+	// Indication process.
+	// After Packet dropping and Sliding Window shifting as above, we can now just indicate the packets
+	// with the SeqNum smaller than latest WinStart and buffer other packets.
+	//
+	// For Rx Reorder condition:
+	// 1. All packets with SeqNum smaller than WinStart => Indicate
+	// 2. All packets with SeqNum larger than or equal to WinStart => Buffer it.
+	//
+
+	//recv_indicatepkts_in_order(rtlpriv, preorder_ctrl, true);
+	if(recv_indicatepkts_in_order(rtlpriv, preorder_ctrl, false)==true)
+	{
+		_set_timer(&preorder_ctrl->reordering_ctrl_timer, REORDER_WAIT_TIME);
+		spin_unlock_bh(&ppending_recvframe_queue->lock);
+	}
+	else
+	{
+		spin_unlock_bh(&ppending_recvframe_queue->lock);
+		del_timer_sync_ex(&preorder_ctrl->reordering_ctrl_timer);
+	}
+
+
+_success_exit:
+
+	return _SUCCESS;
+
+_err_exit:
+
+        spin_unlock_bh(&ppending_recvframe_queue->lock);
+
+	return _FAIL;
+}
+
+
+void rtw_reordering_ctrl_timeout_handler(void *pcontext)
+{
+	struct recv_reorder_ctrl *preorder_ctrl = (struct recv_reorder_ctrl *)pcontext;
+	struct rtl_priv *rtlpriv = preorder_ctrl->rtlpriv;
+	struct __queue *ppending_recvframe_queue = &preorder_ctrl->pending_recvframe_queue;
+
+
+	if(rtlpriv->bDriverStopped ||rtlpriv->bSurpriseRemoved)
+	{
+		return;
+	}
+
+	//DBG_871X("+rtw_reordering_ctrl_timeout_handler()=>\n");
+
+	spin_lock_bh(&ppending_recvframe_queue->lock);
+
+	if(recv_indicatepkts_in_order(rtlpriv, preorder_ctrl, true)==true)
+	{
+		_set_timer(&preorder_ctrl->reordering_ctrl_timer, REORDER_WAIT_TIME);
+	}
+
+	spin_unlock_bh(&ppending_recvframe_queue->lock);
+
+}
+
+int process_recv_indicatepkts(struct rtl_priv *rtlpriv, struct recv_frame *prframe);
+int process_recv_indicatepkts(struct rtl_priv *rtlpriv, struct recv_frame *prframe)
+{
+	int retval = _SUCCESS;
+	//struct recv_priv *precvpriv = &rtlpriv->recvpriv;
+	//struct rx_pkt_attrib *pattrib = &prframe->u.hdr.attrib;
+	struct mlme_priv	*pmlmepriv = &rtlpriv->mlmepriv;
+
+	struct ht_priv	*phtpriv = &pmlmepriv->htpriv;
+
+	if(phtpriv->ht_option==true)  //B/G/N Mode
+	{
+		//prframe->u.hdr.preorder_ctrl = &precvpriv->recvreorder_ctrl[pattrib->priority];
+
+		if(recv_indicatepkt_reorder(rtlpriv, prframe)!=_SUCCESS)// including perform A-MPDU Rx Ordering Buffer Control
+		{
+
+			if ((rtlpriv->bDriverStopped == false) &&
+			    (rtlpriv->bSurpriseRemoved == false))
+			{
+				retval = _FAIL;
+				return retval;
+			}
+		}
+	}
+	else //B/G mode
+	{
+		retval=wlanhdr_to_ethhdr (prframe);
+		if(retval != _SUCCESS)
+		{
+			return retval;
+		}
+
+		if ((rtlpriv->bDriverStopped ==false)&&( rtlpriv->bSurpriseRemoved==false))
+		{
+			//indicate this recv_frame
+			rtw_recv_indicatepkt(rtlpriv, prframe);
+
+
+		}
+		else
+		{
+			retval = _FAIL;
+			return retval;
+		}
+
+	}
+
+	return retval;
+
+}
+
+int recv_func_prehandle(struct rtl_priv *rtlpriv, struct recv_frame *rframe)
+{
+	int ret = _SUCCESS;
+	struct rx_pkt_attrib *pattrib = &rframe->attrib;
+	struct recv_priv *precvpriv = &rtlpriv->recvpriv;
+	struct __queue *pfree_recv_queue = &rtlpriv->recvpriv.free_recv_queue;
+
+	//check the frame crtl field and decache
+	ret = validate_recv_frame(rtlpriv, rframe);
+	if (ret != _SUCCESS)
+	{
+		rtw_free_recvframe(rframe, pfree_recv_queue);//free this recv_frame
+		goto exit;
+	}
+
+exit:
+	return ret;
+}
+
+int recv_func_posthandle(struct rtl_priv *rtlpriv, struct recv_frame *prframe)
+{
+	int ret = _SUCCESS;
+	struct recv_frame *orig_prframe = prframe;
+	struct rx_pkt_attrib *pattrib = &prframe->attrib;
+	struct recv_priv *precvpriv = &rtlpriv->recvpriv;
+	struct __queue *pfree_recv_queue = &rtlpriv->recvpriv.free_recv_queue;
+
+
+
+
+	// DATA FRAME
+	prframe = decryptor(rtlpriv, prframe);
+	if (prframe == NULL) {
+		ret = _FAIL;
+		goto _recv_data_drop;
+	}
+
+	prframe = recvframe_chk_defrag(rtlpriv, prframe);
+	if(prframe==NULL)	{
+		goto _recv_data_drop;
+	}
+
+	prframe=portctrl(rtlpriv, prframe);
+	if (prframe == NULL) {
+		ret = _FAIL;
+		goto _recv_data_drop;
+	}
+
+	count_rx_stats(rtlpriv, prframe, NULL);
+
+	ret = process_recv_indicatepkts(rtlpriv, prframe);
+	if (ret != _SUCCESS)
+	{
+		rtw_free_recvframe(orig_prframe, pfree_recv_queue);//free this recv_frame
+		goto _recv_data_drop;
+	}
+
+_exit_recv_func:
+	return ret;
+
+_recv_data_drop:
+	precvpriv->rx_drop++;
+	return ret;
+}
+
+
+int recv_func(struct rtl_priv *rtlpriv, struct recv_frame *rframe);
+int recv_func(struct rtl_priv *rtlpriv, struct recv_frame *rframe)
+{
+	int ret;
+	struct rx_pkt_attrib *prxattrib = &rframe->attrib;
+	struct recv_priv *recvpriv = &rtlpriv->recvpriv;
+	struct security_priv *psecuritypriv=&rtlpriv->securitypriv;
+	struct mlme_priv *mlmepriv = &rtlpriv->mlmepriv;
+
+	/* check if need to handle uc_swdec_pending_queue*/
+	if (check_fwstate(mlmepriv, WIFI_STATION_STATE) && psecuritypriv->busetkipkey)
+	{
+		struct recv_frame *pending_frame;
+
+		while((pending_frame=rtw_alloc_recvframe(&rtlpriv->recvpriv.uc_swdec_pending_queue))) {
+			if (recv_func_posthandle(rtlpriv, pending_frame) == _SUCCESS)
+				DBG_871X("%s: dequeue uc_swdec_pending_queue\n", __func__);
+		}
+	}
+
+	ret = recv_func_prehandle(rtlpriv, rframe);
+
+	if(ret == _SUCCESS) {
+
+		/* check if need to enqueue into uc_swdec_pending_queue*/
+		if (check_fwstate(mlmepriv, WIFI_STATION_STATE) &&
+			!is_multicast_ether_addr(prxattrib->ra) && prxattrib->encrypt>0 &&
+			(prxattrib->bdecrypted == 0 ||psecuritypriv->sw_decrypt == true) &&
+			!is_wep_enc(psecuritypriv->dot11PrivacyAlgrthm) &&
+			!psecuritypriv->busetkipkey) {
+			rtw_enqueue_recvframe(rframe, &rtlpriv->recvpriv.uc_swdec_pending_queue);
+			DBG_871X("%s: no key, enqueue uc_swdec_pending_queue\n", __func__);
+			goto exit;
+		}
+
+		ret = recv_func_posthandle(rtlpriv, rframe);
+	}
+
+exit:
+	return ret;
+}
+
+
+int32_t rtw_recv_entry(struct recv_frame *precvframe)
+{
+	struct rtl_priv *rtlpriv;
+	struct recv_priv *precvpriv;
+	int32_t ret=_SUCCESS;
+
+
+
+//	RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("+rtw_recv_entry\n"));
+
+	rtlpriv = precvframe->rtlpriv;
+
+	precvpriv = &rtlpriv->recvpriv;
+
+
+	if ((ret = recv_func(rtlpriv, precvframe)) == _FAIL)
+	{
+		goto _recv_entry_drop;
+	}
+
+
+	precvpriv->rx_pkts++;
+
+
+
+	return ret;
+
+_recv_entry_drop:
+
+	//RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,("_recv_entry_drop\n"));
+
+
+
+	return ret;
+}
+
+#ifdef CONFIG_NEW_SIGNAL_STAT_PROCESS
+void rtw_signal_stat_timer_hdl(RTW_TIMER_HDL_ARGS){
+	struct rtl_priv *rtlpriv = (struct rtl_priv *)FunctionContext;
+	struct recv_priv *recvpriv = &rtlpriv->recvpriv;
+
+	uint32_t	 tmp_s, tmp_q;
+	uint8_t avg_signal_strength = 0;
+	uint8_t avg_signal_qual = 0;
+	uint32_t	 num_signal_strength = 0;
+	uint32_t	 num_signal_qual = 0;
+	uint8_t _alpha = 3; // this value is based on converging_constant = 5000 and sampling_interval = 1000
+
+	if(rtlpriv->recvpriv.is_signal_dbg) {
+		//update the user specific value, signal_strength_dbg, to signal_strength, rssi
+		rtlpriv->recvpriv.signal_strength= rtlpriv->recvpriv.signal_strength_dbg;
+		rtlpriv->recvpriv.rssi=(s8)translate_percentage_to_dbm((uint8_t)rtlpriv->recvpriv.signal_strength_dbg);
+	} else {
+
+		if(recvpriv->signal_strength_data.update_req == 0) {// update_req is clear, means we got rx
+			avg_signal_strength = recvpriv->signal_strength_data.avg_val;
+			num_signal_strength = recvpriv->signal_strength_data.total_num;
+			// after avg_vals are accquired, we can re-stat the signal values
+			recvpriv->signal_strength_data.update_req = 1;
+		}
+
+		if(recvpriv->signal_qual_data.update_req == 0) {// update_req is clear, means we got rx
+			avg_signal_qual = recvpriv->signal_qual_data.avg_val;
+			num_signal_qual = recvpriv->signal_qual_data.total_num;
+			// after avg_vals are accquired, we can re-stat the signal values
+			recvpriv->signal_qual_data.update_req = 1;
+		}
+
+		//update value of signal_strength, rssi, signal_qual
+		if(check_fwstate(&rtlpriv->mlmepriv, _FW_UNDER_SURVEY) == false) {
+			tmp_s = (avg_signal_strength+(_alpha-1)*recvpriv->signal_strength);
+			if(tmp_s %_alpha)
+				tmp_s = tmp_s/_alpha + 1;
+			else
+				tmp_s = tmp_s/_alpha;
+			if(tmp_s>100)
+				tmp_s = 100;
+
+			tmp_q = (avg_signal_qual+(_alpha-1)*recvpriv->signal_qual);
+			if(tmp_q %_alpha)
+				tmp_q = tmp_q/_alpha + 1;
+			else
+				tmp_q = tmp_q/_alpha;
+			if(tmp_q>100)
+				tmp_q = 100;
+
+			recvpriv->signal_strength = tmp_s;
+			recvpriv->rssi = (s8)translate_percentage_to_dbm(tmp_s);
+			recvpriv->signal_qual = tmp_q;
+
+		}
+	}
+	rtw_set_signal_stat_timer(recvpriv);
+
+}
+#endif //CONFIG_NEW_SIGNAL_STAT_PROCESS
+
+
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/core/rtw_rf.c linux-4.9.8821au/drivers/staging/rtl8821au/core/rtw_rf.c
--- linux-4.9/drivers/staging/rtl8821au/core/rtw_rf.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/core/rtw_rf.c	2016-12-11 19:48:25.153645128 -0600
@@ -0,0 +1,89 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#define _RTW_RF_C_
+
+#include <drv_types.h>
+
+
+struct ch_freq {
+	uint32_t	 channel;
+	uint32_t	 frequency;
+};
+
+struct ch_freq ch_freq_map[] = {
+	{  1, 2412}, {  2, 2417}, {  3, 2422}, {  4, 2427}, {  5, 2432},
+	{  6, 2437}, {  7, 2442}, {  8, 2447}, {  9, 2452}, { 10, 2457},
+	{ 11, 2462}, { 12, 2467}, { 13, 2472}, { 14, 2484},
+	/*  UNII */
+	{ 36, 5180}, { 40, 5200}, { 44, 5220}, { 48, 5240}, { 52, 5260},
+	{ 56, 5280}, { 60, 5300}, { 64, 5320}, {149, 5745}, {153, 5765},
+	{157, 5785}, {161, 5805}, {165, 5825}, {167, 5835}, {169, 5845},
+	{171, 5855}, {173, 5865},
+	/* HiperLAN2 */
+	{100, 5500}, {104, 5520}, {108, 5540}, {112, 5560}, {116, 5580},
+	{120, 5600}, {124, 5620}, {128, 5640}, {132, 5660}, {136, 5680},
+	{140, 5700},
+	/* Japan MMAC */
+	{ 34, 5170}, { 38, 5190}, { 42, 5210}, { 46, 5230},
+	/*  Japan */
+	{184, 4920}, {188, 4940}, {192, 4960}, {196, 4980},
+	{208, 5040},/* Japan, means J08 */
+	{212, 5060},/* Japan, means J12 */
+	{216, 5080},/* Japan, means J16 */
+};
+
+int ch_freq_map_num = (sizeof(ch_freq_map) / sizeof(struct ch_freq));
+
+uint32_t rtw_ch2freq(uint32_t channel)
+{
+	uint8_t	i;
+	uint32_t	freq = 0;
+
+	for (i = 0; i < ch_freq_map_num; i++) {
+		if (channel == ch_freq_map[i].channel) {
+			freq = ch_freq_map[i].frequency;
+				break;
+		}
+	}
+
+	if (i == ch_freq_map_num)
+		freq = 2412;
+
+	return freq;
+}
+
+uint32_t rtw_freq2ch(uint32_t freq)
+{
+	uint8_t	i;
+	uint32_t ch = 0;
+
+	for (i = 0; i < ch_freq_map_num; i++) {
+		if (freq == ch_freq_map[i].frequency) {
+			ch = ch_freq_map[i].channel;
+				break;
+		}
+	}
+
+	if (i == ch_freq_map_num)
+		ch = 1;
+
+	return ch;
+}
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/core/rtw_security.c linux-4.9.8821au/drivers/staging/rtl8821au/core/rtw_security.c
--- linux-4.9/drivers/staging/rtl8821au/core/rtw_security.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/core/rtw_security.c	2016-12-11 19:48:25.153645128 -0600
@@ -0,0 +1,2667 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#define  _RTW_SECURITY_C_
+
+#include <linux/etherdevice.h>
+#include <drv_types.h>
+
+#undef DBG_871X
+static inline void DBG_871X(const char *fmt, ...)
+{
+}
+#undef DBG_8192C
+static inline void DBG_8192C(const char *fmt, ...)
+{
+}
+
+//=====WEP related=====
+
+#define CRC32_POLY 0x04c11db7
+
+struct arc4context
+{
+	uint32_t	 x;
+	uint32_t	 y;
+	uint8_t state[256];
+};
+
+
+static void arcfour_init(struct arc4context 	*parc4ctx, uint8_t * key,uint32_t	key_len)
+{
+	uint32_t	t, u;
+	uint32_t	keyindex;
+	uint32_t	stateindex;
+	uint8_t * state;
+	uint32_t	counter;
+
+	state = parc4ctx->state;
+	parc4ctx->x = 0;
+	parc4ctx->y = 0;
+	for (counter = 0; counter < 256; counter++)
+		state[counter] = (uint8_t)counter;
+	keyindex = 0;
+	stateindex = 0;
+	for (counter = 0; counter < 256; counter++)
+	{
+		t = state[counter];
+		stateindex = (stateindex + key[keyindex] + t) & 0xff;
+		u = state[stateindex];
+		state[stateindex] = (uint8_t)t;
+		state[counter] = (uint8_t)u;
+		if (++keyindex >= key_len)
+			keyindex = 0;
+	}
+
+}
+static uint32_t	 arcfour_byte(	struct arc4context	*parc4ctx)
+{
+	uint32_t	 x;
+	uint32_t	 y;
+	uint32_t	 sx, sy;
+	uint8_t * state;
+
+	state = parc4ctx->state;
+	x = (parc4ctx->x + 1) & 0xff;
+	sx = state[x];
+	y = (sx + parc4ctx->y) & 0xff;
+	sy = state[y];
+	parc4ctx->x = x;
+	parc4ctx->y = y;
+	state[y] = (uint8_t)sx;
+	state[x] = (uint8_t)sy;
+
+	return state[(sx + sy) & 0xff];
+}
+
+
+static void arcfour_encrypt(	struct arc4context	*parc4ctx,
+	uint8_t * dest,
+	uint8_t * src,
+	uint32_t	 len)
+{
+	uint32_t	i;
+
+	for (i = 0; i < len; i++)
+		dest[i] = src[i] ^ (unsigned char)arcfour_byte(parc4ctx);
+
+}
+
+static int bcrc32initialized = 0;
+static uint32_t	 crc32_table[256];
+
+
+static uint8_t crc32_reverseBit( uint8_t data)
+{
+	return( (uint8_t)((data<<7)&0x80) | ((data<<5)&0x40) | ((data<<3)&0x20) | ((data<<1)&0x10) | ((data>>1)&0x08) | ((data>>3)&0x04) | ((data>>5)&0x02) | ((data>>7)&0x01) );
+}
+
+static void crc32_init(void)
+{
+
+	if (bcrc32initialized == 1)
+		goto exit;
+	else{
+		int i, j;
+		uint32_t	 c;
+		uint8_t *p=(uint8_t *)&c, *p1;
+		uint8_t k;
+
+		c = 0x12340000;
+
+		for (i = 0; i < 256; ++i)
+		{
+			k = crc32_reverseBit((uint8_t)i);
+			for (c = ((uint32_t)k) << 24, j = 8; j > 0; --j){
+				c = c & 0x80000000 ? (c << 1) ^ CRC32_POLY : (c << 1);
+			}
+			p1 = (uint8_t *)&crc32_table[i];
+
+			p1[0] = crc32_reverseBit(p[3]);
+			p1[1] = crc32_reverseBit(p[2]);
+			p1[2] = crc32_reverseBit(p[1]);
+			p1[3] = crc32_reverseBit(p[0]);
+		}
+		bcrc32initialized= 1;
+	}
+exit:
+	;
+}
+
+static uint32_t	 getcrc32(uint8_t *buf, int len)
+{
+	uint8_t *p;
+	uint32_t	  crc;
+
+	if (bcrc32initialized == 0) crc32_init();
+
+	crc = 0xffffffff;       /* preload shift register, per CRC-32 spec */
+
+	for (p = buf; len > 0; ++p, --len)
+	{
+		crc = crc32_table[ (crc ^ *p) & 0xff] ^ (crc >> 8);
+	}
+
+	return ~crc;    /* transmit complement, per CRC-32 spec */
+}
+
+
+/*
+	Need to consider the fragment  situation
+*/
+void rtw_wep_encrypt(struct rtl_priv *rtlpriv, uint8_t *pxmitframe)
+{																	// exclude ICV
+
+	unsigned char	crc[4];
+	struct arc4context	 mycontext;
+
+	int	curfragnum,length;
+	uint32_t	keylength;
+
+	uint8_t	*pframe, *payload,*iv;    //,*wepkey
+	uint8_t	wepkey[16];
+	uint8_t   hw_hdr_offset=0;
+	struct	tx_pkt_attrib	 *pattrib = &((struct xmit_frame*)pxmitframe)->tx_attrib;
+	struct 	security_priv	*psecuritypriv=&rtlpriv->securitypriv;
+	struct	xmit_priv		*pxmitpriv=&rtlpriv->xmitpriv;
+
+
+
+
+	if(((struct xmit_frame*)pxmitframe)->buf_addr==NULL)
+		return;
+
+	hw_hdr_offset = TXDESC_SIZE +
+		 (((struct xmit_frame*)pxmitframe)->pkt_offset * PACKET_OFFSET_SZ);
+
+	pframe = ((struct xmit_frame*)pxmitframe)->buf_addr + hw_hdr_offset;
+
+	//start to encrypt each fragment
+	if((pattrib->encrypt==WEP40_ENCRYPTION)||(pattrib->encrypt==WEP104_ENCRYPTION))
+	{
+		keylength=psecuritypriv->dot11DefKeylen[psecuritypriv->dot11PrivacyKeyIndex];
+
+		for(curfragnum=0;curfragnum<pattrib->nr_frags;curfragnum++)
+		{
+			iv=pframe+pattrib->hdrlen;
+			memcpy(&wepkey[0], iv, 3);
+			memcpy(&wepkey[3], &psecuritypriv->dot11DefKey[psecuritypriv->dot11PrivacyKeyIndex].skey[0],keylength);
+			payload=pframe+pattrib->iv_len+pattrib->hdrlen;
+
+			if((curfragnum+1)==pattrib->nr_frags)
+			{	//the last fragment
+
+				length=pattrib->last_txcmdsz-pattrib->hdrlen-pattrib->iv_len- pattrib->icv_len;
+
+				*((uint32_t	 *)crc)=cpu_to_le32(getcrc32(payload,length));
+
+				arcfour_init(&mycontext, wepkey,3+keylength);
+				arcfour_encrypt(&mycontext, payload, payload, length);
+				arcfour_encrypt(&mycontext, payload+length, crc, 4);
+
+			}
+			else
+			{
+			length=pxmitpriv->frag_len-pattrib->hdrlen-pattrib->iv_len-pattrib->icv_len ;
+				*((uint32_t	 *)crc)=cpu_to_le32(getcrc32(payload,length));
+				arcfour_init(&mycontext, wepkey,3+keylength);
+				arcfour_encrypt(&mycontext, payload, payload, length);
+				arcfour_encrypt(&mycontext, payload+length, crc, 4);
+
+			pframe+=pxmitpriv->frag_len;
+			pframe=(uint8_t *)RND4((SIZE_PTR)(pframe));
+
+			}
+
+		}
+
+	}
+
+
+
+}
+
+void rtw_wep_decrypt(struct rtl_priv  *rtlpriv, struct recv_frame *precvframe)
+{
+	// exclude ICV
+	uint8_t	crc[4];
+	struct arc4context	 mycontext;
+	int 	length;
+	uint32_t	keylength;
+	uint8_t	*pframe, *payload,*iv,wepkey[16];
+	uint8_t	 keyindex;
+	struct	rx_pkt_attrib	 *prxattrib = &(precvframe->attrib);
+	struct 	security_priv	*psecuritypriv=&rtlpriv->securitypriv;
+
+
+
+	pframe= precvframe->rx_data;
+
+	//start to decrypt recvframe
+	if((prxattrib->encrypt==WEP40_ENCRYPTION)||(prxattrib->encrypt==WEP104_ENCRYPTION))
+	{
+		iv=pframe+prxattrib->hdrlen;
+		//keyindex=(iv[3]&0x3);
+		keyindex = prxattrib->key_index;
+		keylength=psecuritypriv->dot11DefKeylen[keyindex];
+		memcpy(&wepkey[0], iv, 3);
+		//memcpy(&wepkey[3], &psecuritypriv->dot11DefKey[psecuritypriv->dot11PrivacyKeyIndex].skey[0],keylength);
+		memcpy(&wepkey[3], &psecuritypriv->dot11DefKey[keyindex].skey[0],keylength);
+		length= precvframe->len-prxattrib->hdrlen-prxattrib->iv_len;
+
+		payload=pframe+prxattrib->iv_len+prxattrib->hdrlen;
+
+		//decrypt payload include icv
+		arcfour_init(&mycontext, wepkey,3+keylength);
+		arcfour_encrypt(&mycontext, payload, payload,  length);
+
+		//calculate icv and compare the icv
+		*((uint32_t	 *)crc)=le32_to_cpu(getcrc32(payload,length-4));
+
+		if(crc[3]!=payload[length-1] || crc[2]!=payload[length-2] || crc[1]!=payload[length-3] || crc[0]!=payload[length-4])
+		{
+			;
+		}
+
+	}
+
+
+
+	return;
+
+}
+
+//3 		=====TKIP related=====
+
+static uint32_t	 secmicgetuint32( uint8_t * p )
+// Convert from Byte[] to Us4Byte32 in a portable way
+{
+	int32_t i;
+	uint32_t	 res = 0;
+
+	for( i=0; i<4; i++ )
+	{
+		res |= ((uint32_t)(*p++)) << (8*i);
+	}
+
+	return res;
+}
+
+static void secmicputuint32( uint8_t * p, uint32_t	 val )
+// Convert from Us4Byte32 to Byte[] in a portable way
+{
+	long i;
+
+	for( i=0; i<4; i++ )
+	{
+		*p++ = (uint8_t) (val & 0xff);
+		val >>= 8;
+	}
+
+}
+
+static void secmicclear(struct mic_data *pmicdata)
+{
+// Reset the state to the empty message.
+
+	pmicdata->L = pmicdata->K0;
+	pmicdata->R = pmicdata->K1;
+	pmicdata->nBytesInM = 0;
+	pmicdata->M = 0;
+
+}
+
+void rtw_secmicsetkey(struct mic_data *pmicdata, uint8_t * key )
+{
+	// Set the key
+
+	pmicdata->K0 = secmicgetuint32( key );
+	pmicdata->K1 = secmicgetuint32( key + 4 );
+	// and reset the message
+	secmicclear(pmicdata);
+
+}
+
+void rtw_secmicappendbyte(struct mic_data *pmicdata, uint8_t b )
+{
+
+	// Append the byte to our word-sized buffer
+	pmicdata->M |= ((unsigned long)b) << (8*pmicdata->nBytesInM);
+	pmicdata->nBytesInM++;
+	// Process the word if it is full.
+	if( pmicdata->nBytesInM >= 4 )
+	{
+		pmicdata->L ^= pmicdata->M;
+		pmicdata->R ^= ROL32( pmicdata->L, 17 );
+		pmicdata->L += pmicdata->R;
+		pmicdata->R ^= ((pmicdata->L & 0xff00ff00) >> 8) | ((pmicdata->L & 0x00ff00ff) << 8);
+		pmicdata->L += pmicdata->R;
+		pmicdata->R ^= ROL32( pmicdata->L, 3 );
+		pmicdata->L += pmicdata->R;
+		pmicdata->R ^= ROR32( pmicdata->L, 2 );
+		pmicdata->L += pmicdata->R;
+		// Clear the buffer
+		pmicdata->M = 0;
+		pmicdata->nBytesInM = 0;
+	}
+
+}
+
+void rtw_secmicappend(struct mic_data *pmicdata, uint8_t * src, uint32_t	 nbytes )
+{
+
+	// This is simple
+	while( nbytes > 0 )
+	{
+		rtw_secmicappendbyte(pmicdata, *src++ );
+		nbytes--;
+	}
+
+}
+
+void rtw_secgetmic(struct mic_data *pmicdata, uint8_t * dst )
+{
+
+	// Append the minimum padding
+	rtw_secmicappendbyte(pmicdata, 0x5a );
+	rtw_secmicappendbyte(pmicdata, 0 );
+	rtw_secmicappendbyte(pmicdata, 0 );
+	rtw_secmicappendbyte(pmicdata, 0 );
+	rtw_secmicappendbyte(pmicdata, 0 );
+	// and then zeroes until the length is a multiple of 4
+	while( pmicdata->nBytesInM != 0 )
+	{
+		rtw_secmicappendbyte(pmicdata, 0 );
+	}
+	// The appendByte function has already computed the result.
+	secmicputuint32( dst, pmicdata->L );
+	secmicputuint32( dst+4, pmicdata->R );
+	// Reset to the empty message.
+	secmicclear(pmicdata);
+
+}
+
+
+void rtw_seccalctkipmic(uint8_t * key,uint8_t *header,uint8_t *data,uint32_t	 data_len,uint8_t *mic_code, uint8_t pri)
+{
+
+	struct mic_data	micdata;
+	uint8_t priority[4]={0x0,0x0,0x0,0x0};
+
+	rtw_secmicsetkey(&micdata, key);
+	priority[0]=pri;
+
+	/* Michael MIC pseudo header: DA, SA, 3 x 0, Priority */
+	if(header[1]&1){   //ToDS==1
+			rtw_secmicappend(&micdata, &header[16], 6);  //DA
+		if(header[1]&2)  //From Ds==1
+			rtw_secmicappend(&micdata, &header[24], 6);
+		else
+			rtw_secmicappend(&micdata, &header[10], 6);
+	}
+	else{	//ToDS==0
+		rtw_secmicappend(&micdata, &header[4], 6);   //DA
+		if(header[1]&2)  //From Ds==1
+			rtw_secmicappend(&micdata, &header[16], 6);
+		else
+			rtw_secmicappend(&micdata, &header[10], 6);
+
+	}
+	rtw_secmicappend(&micdata, &priority[0], 4);
+
+
+	rtw_secmicappend(&micdata, data, data_len);
+
+	rtw_secgetmic(&micdata,mic_code);
+
+}
+
+
+
+
+/* macros for extraction/creation of unsigned char/unsigned short values  */
+#define RotR1(v16)   ((((v16) >> 1) & 0x7FFF) ^ (((v16) & 1) << 15))
+#define   Lo8(v16)   ((uint8_t)( (v16)       & 0x00FF))
+#define   Hi8(v16)   ((uint8_t)(((v16) >> 8) & 0x00FF))
+#define  Lo16(v32)   ((u16)( (v32)       & 0xFFFF))
+#define  Hi16(v32)   ((u16)(((v32) >>16) & 0xFFFF))
+#define  Mk16(hi,lo) ((lo) ^ (((u16)(hi)) << 8))
+
+/* select the Nth 16-bit word of the temporal key unsigned char array TK[]   */
+#define  TK16(N)     Mk16(tk[2*(N)+1],tk[2*(N)])
+
+/* S-box lookup: 16 bits --> 16 bits */
+#define _S_(v16)     (Sbox1[0][Lo8(v16)] ^ Sbox1[1][Hi8(v16)])
+
+/* fixed algorithm "parameters" */
+#define PHASE1_LOOP_CNT   8    /* this needs to be "big enough"     */
+#define TA_SIZE           6    /*  48-bit transmitter address       */
+#define TK_SIZE          16    /* 128-bit temporal key              */
+#define P1K_SIZE         10    /*  80-bit Phase1 key                */
+#define RC4_KEY_SIZE     16    /* 128-bit RC4KEY (104 bits unknown) */
+
+
+/* 2-unsigned char by 2-unsigned char subset of the full AES S-box table */
+static const unsigned short Sbox1[2][256]=       /* Sbox for hash (can be in ROM)     */
+{ {
+   0xC6A5,0xF884,0xEE99,0xF68D,0xFF0D,0xD6BD,0xDEB1,0x9154,
+   0x6050,0x0203,0xCEA9,0x567D,0xE719,0xB562,0x4DE6,0xEC9A,
+   0x8F45,0x1F9D,0x8940,0xFA87,0xEF15,0xB2EB,0x8EC9,0xFB0B,
+   0x41EC,0xB367,0x5FFD,0x45EA,0x23BF,0x53F7,0xE496,0x9B5B,
+   0x75C2,0xE11C,0x3DAE,0x4C6A,0x6C5A,0x7E41,0xF502,0x834F,
+   0x685C,0x51F4,0xD134,0xF908,0xE293,0xAB73,0x6253,0x2A3F,
+   0x080C,0x9552,0x4665,0x9D5E,0x3028,0x37A1,0x0A0F,0x2FB5,
+   0x0E09,0x2436,0x1B9B,0xDF3D,0xCD26,0x4E69,0x7FCD,0xEA9F,
+   0x121B,0x1D9E,0x5874,0x342E,0x362D,0xDCB2,0xB4EE,0x5BFB,
+   0xA4F6,0x764D,0xB761,0x7DCE,0x527B,0xDD3E,0x5E71,0x1397,
+   0xA6F5,0xB968,0x0000,0xC12C,0x4060,0xE31F,0x79C8,0xB6ED,
+   0xD4BE,0x8D46,0x67D9,0x724B,0x94DE,0x98D4,0xB0E8,0x854A,
+   0xBB6B,0xC52A,0x4FE5,0xED16,0x86C5,0x9AD7,0x6655,0x1194,
+   0x8ACF,0xE910,0x0406,0xFE81,0xA0F0,0x7844,0x25BA,0x4BE3,
+   0xA2F3,0x5DFE,0x80C0,0x058A,0x3FAD,0x21BC,0x7048,0xF104,
+   0x63DF,0x77C1,0xAF75,0x4263,0x2030,0xE51A,0xFD0E,0xBF6D,
+   0x814C,0x1814,0x2635,0xC32F,0xBEE1,0x35A2,0x88CC,0x2E39,
+   0x9357,0x55F2,0xFC82,0x7A47,0xC8AC,0xBAE7,0x322B,0xE695,
+   0xC0A0,0x1998,0x9ED1,0xA37F,0x4466,0x547E,0x3BAB,0x0B83,
+   0x8CCA,0xC729,0x6BD3,0x283C,0xA779,0xBCE2,0x161D,0xAD76,
+   0xDB3B,0x6456,0x744E,0x141E,0x92DB,0x0C0A,0x486C,0xB8E4,
+   0x9F5D,0xBD6E,0x43EF,0xC4A6,0x39A8,0x31A4,0xD337,0xF28B,
+   0xD532,0x8B43,0x6E59,0xDAB7,0x018C,0xB164,0x9CD2,0x49E0,
+   0xD8B4,0xACFA,0xF307,0xCF25,0xCAAF,0xF48E,0x47E9,0x1018,
+   0x6FD5,0xF088,0x4A6F,0x5C72,0x3824,0x57F1,0x73C7,0x9751,
+   0xCB23,0xA17C,0xE89C,0x3E21,0x96DD,0x61DC,0x0D86,0x0F85,
+   0xE090,0x7C42,0x71C4,0xCCAA,0x90D8,0x0605,0xF701,0x1C12,
+   0xC2A3,0x6A5F,0xAEF9,0x69D0,0x1791,0x9958,0x3A27,0x27B9,
+   0xD938,0xEB13,0x2BB3,0x2233,0xD2BB,0xA970,0x0789,0x33A7,
+   0x2DB6,0x3C22,0x1592,0xC920,0x8749,0xAAFF,0x5078,0xA57A,
+   0x038F,0x59F8,0x0980,0x1A17,0x65DA,0xD731,0x84C6,0xD0B8,
+   0x82C3,0x29B0,0x5A77,0x1E11,0x7BCB,0xA8FC,0x6DD6,0x2C3A,
+  },
+
+
+  {  /* second half of table is unsigned char-reversed version of first! */
+   0xA5C6,0x84F8,0x99EE,0x8DF6,0x0DFF,0xBDD6,0xB1DE,0x5491,
+   0x5060,0x0302,0xA9CE,0x7D56,0x19E7,0x62B5,0xE64D,0x9AEC,
+   0x458F,0x9D1F,0x4089,0x87FA,0x15EF,0xEBB2,0xC98E,0x0BFB,
+   0xEC41,0x67B3,0xFD5F,0xEA45,0xBF23,0xF753,0x96E4,0x5B9B,
+   0xC275,0x1CE1,0xAE3D,0x6A4C,0x5A6C,0x417E,0x02F5,0x4F83,
+   0x5C68,0xF451,0x34D1,0x08F9,0x93E2,0x73AB,0x5362,0x3F2A,
+   0x0C08,0x5295,0x6546,0x5E9D,0x2830,0xA137,0x0F0A,0xB52F,
+   0x090E,0x3624,0x9B1B,0x3DDF,0x26CD,0x694E,0xCD7F,0x9FEA,
+   0x1B12,0x9E1D,0x7458,0x2E34,0x2D36,0xB2DC,0xEEB4,0xFB5B,
+   0xF6A4,0x4D76,0x61B7,0xCE7D,0x7B52,0x3EDD,0x715E,0x9713,
+   0xF5A6,0x68B9,0x0000,0x2CC1,0x6040,0x1FE3,0xC879,0xEDB6,
+   0xBED4,0x468D,0xD967,0x4B72,0xDE94,0xD498,0xE8B0,0x4A85,
+   0x6BBB,0x2AC5,0xE54F,0x16ED,0xC586,0xD79A,0x5566,0x9411,
+   0xCF8A,0x10E9,0x0604,0x81FE,0xF0A0,0x4478,0xBA25,0xE34B,
+   0xF3A2,0xFE5D,0xC080,0x8A05,0xAD3F,0xBC21,0x4870,0x04F1,
+   0xDF63,0xC177,0x75AF,0x6342,0x3020,0x1AE5,0x0EFD,0x6DBF,
+   0x4C81,0x1418,0x3526,0x2FC3,0xE1BE,0xA235,0xCC88,0x392E,
+   0x5793,0xF255,0x82FC,0x477A,0xACC8,0xE7BA,0x2B32,0x95E6,
+   0xA0C0,0x9819,0xD19E,0x7FA3,0x6644,0x7E54,0xAB3B,0x830B,
+   0xCA8C,0x29C7,0xD36B,0x3C28,0x79A7,0xE2BC,0x1D16,0x76AD,
+   0x3BDB,0x5664,0x4E74,0x1E14,0xDB92,0x0A0C,0x6C48,0xE4B8,
+   0x5D9F,0x6EBD,0xEF43,0xA6C4,0xA839,0xA431,0x37D3,0x8BF2,
+   0x32D5,0x438B,0x596E,0xB7DA,0x8C01,0x64B1,0xD29C,0xE049,
+   0xB4D8,0xFAAC,0x07F3,0x25CF,0xAFCA,0x8EF4,0xE947,0x1810,
+   0xD56F,0x88F0,0x6F4A,0x725C,0x2438,0xF157,0xC773,0x5197,
+   0x23CB,0x7CA1,0x9CE8,0x213E,0xDD96,0xDC61,0x860D,0x850F,
+   0x90E0,0x427C,0xC471,0xAACC,0xD890,0x0506,0x01F7,0x121C,
+   0xA3C2,0x5F6A,0xF9AE,0xD069,0x9117,0x5899,0x273A,0xB927,
+   0x38D9,0x13EB,0xB32B,0x3322,0xBBD2,0x70A9,0x8907,0xA733,
+   0xB62D,0x223C,0x9215,0x20C9,0x4987,0xFFAA,0x7850,0x7AA5,
+   0x8F03,0xF859,0x8009,0x171A,0xDA65,0x31D7,0xC684,0xB8D0,
+   0xC382,0xB029,0x775A,0x111E,0xCB7B,0xFCA8,0xD66D,0x3A2C,
+  }
+};
+
+ /*
+**********************************************************************
+* Routine: Phase 1 -- generate P1K, given TA, TK, IV32
+*
+* Inputs:
+*     tk[]      = temporal key                         [128 bits]
+*     ta[]      = transmitter's MAC address            [ 48 bits]
+*     iv32      = upper 32 bits of IV                  [ 32 bits]
+* Output:
+*     p1k[]     = Phase 1 key                          [ 80 bits]
+*
+* Note:
+*     This function only needs to be called every 2**16 packets,
+*     although in theory it could be called every packet.
+*
+**********************************************************************
+*/
+static void phase1(u16 *p1k,const uint8_t *tk,const uint8_t *ta,uint32_t	 iv32)
+{
+	int  i;
+
+	/* Initialize the 80 bits of P1K[] from IV32 and TA[0..5]     */
+	p1k[0]      = Lo16(iv32);
+	p1k[1]      = Hi16(iv32);
+	p1k[2]      = Mk16(ta[1],ta[0]); /* use TA[] as little-endian */
+	p1k[3]      = Mk16(ta[3],ta[2]);
+	p1k[4]      = Mk16(ta[5],ta[4]);
+
+	/* Now compute an unbalanced Feistel cipher with 80-bit block */
+	/* size on the 80-bit block P1K[], using the 128-bit key TK[] */
+	for (i=0; i < PHASE1_LOOP_CNT ;i++)
+	{                 /* Each add operation here is mod 2**16 */
+      		p1k[0] += _S_(p1k[4] ^ TK16((i&1)+0));
+		p1k[1] += _S_(p1k[0] ^ TK16((i&1)+2));
+		p1k[2] += _S_(p1k[1] ^ TK16((i&1)+4));
+		p1k[3] += _S_(p1k[2] ^ TK16((i&1)+6));
+		p1k[4] += _S_(p1k[3] ^ TK16((i&1)+0));
+		p1k[4] +=  (unsigned short)i;                    /* avoid "slide attacks" */
+        }
+
+}
+
+
+/*
+**********************************************************************
+* Routine: Phase 2 -- generate RC4KEY, given TK, P1K, IV16
+*
+* Inputs:
+*     tk[]      = Temporal key                         [128 bits]
+*     p1k[]     = Phase 1 output key                   [ 80 bits]
+*     iv16      = low 16 bits of IV counter            [ 16 bits]
+* Output:
+*     rc4key[]  = the key used to encrypt the packet   [128 bits]
+*
+* Note:
+*     The value {TA,IV32,IV16} for Phase1/Phase2 must be unique
+*     across all packets using the same key TK value. Then, for a
+*     given value of TK[], this TKIP48 construction guarantees that
+*     the final RC4KEY value is unique across all packets.
+*
+* Suggested implementation optimization: if PPK[] is "overlaid"
+*     appropriately on RC4KEY[], there is no need for the final
+*     for loop below that copies the PPK[] result into RC4KEY[].
+*
+**********************************************************************
+*/
+static void phase2(uint8_t *rc4key,const uint8_t *tk,const u16 *p1k,u16 iv16)
+{
+	int  i;
+	u16 PPK[6];                          /* temporary key for mixing    */
+
+	/* Note: all adds in the PPK[] equations below are mod 2**16         */
+	for (i=0;i<5;i++) PPK[i]=p1k[i];      /* first, copy P1K to PPK      */
+		PPK[5]  =  p1k[4] +iv16;             /* next,  add in IV16          */
+
+	/* Bijective non-linear mixing of the 96 bits of PPK[0..5]           */
+	PPK[0] +=    _S_(PPK[5] ^ TK16(0));   /* Mix key in each "round"     */
+	PPK[1] +=    _S_(PPK[0] ^ TK16(1));
+	PPK[2] +=    _S_(PPK[1] ^ TK16(2));
+	PPK[3] +=    _S_(PPK[2] ^ TK16(3));
+	PPK[4] +=    _S_(PPK[3] ^ TK16(4));
+	PPK[5] +=    _S_(PPK[4] ^ TK16(5));   /* Total # S-box lookups == 6  */
+
+	/* Final sweep: bijective, "linear". Rotates kill LSB correlations   */
+	PPK[0] +=  RotR1(PPK[5] ^ TK16(6));
+	PPK[1] +=  RotR1(PPK[0] ^ TK16(7));   /* Use all of TK[] in Phase2   */
+	PPK[2] +=  RotR1(PPK[1]);
+	PPK[3] +=  RotR1(PPK[2]);
+	PPK[4] +=  RotR1(PPK[3]);
+	PPK[5] +=  RotR1(PPK[4]);
+	/* Note: At this point, for a given key TK[0..15], the 96-bit output */
+	/*       value PPK[0..5] is guaranteed to be unique, as a function   */
+	/*       of the 96-bit "input" value   {TA,IV32,IV16}. That is, P1K  */
+	/*       is now a keyed permutation of {TA,IV32,IV16}.               */
+
+	/* Set RC4KEY[0..3], which includes "cleartext" portion of RC4 key   */
+	rc4key[0] = Hi8(iv16);                /* RC4KEY[0..2] is the WEP IV  */
+	rc4key[1] =(Hi8(iv16) | 0x20) & 0x7F; /* Help avoid weak (FMS) keys  */
+	rc4key[2] = Lo8(iv16);
+	rc4key[3] = Lo8((PPK[5] ^ TK16(0)) >> 1);
+
+
+	/* Copy 96 bits of PPK[0..5] to RC4KEY[4..15]  (little-endian)       */
+	for (i=0;i<6;i++)
+	{
+		rc4key[4+2*i] = Lo8(PPK[i]);
+		rc4key[5+2*i] = Hi8(PPK[i]);
+	}
+
+}
+
+
+//The hlen isn't include the IV
+uint32_t	rtw_tkip_encrypt(struct rtl_priv *rtlpriv, uint8_t *pxmitframe)
+{																	// exclude ICV
+	u16	pnl;
+	uint32_t	pnh;
+	uint8_t	rc4key[16];
+	uint8_t   ttkey[16];
+	uint8_t	crc[4];
+	uint8_t   hw_hdr_offset = 0;
+	struct arc4context mycontext;
+	int 			curfragnum,length;
+	uint32_t	prwskeylen;
+
+	uint8_t	*pframe, *payload,*iv,*prwskey;
+	union pn48 dot11txpn;
+	//struct	sta_info		*stainfo;
+	struct	tx_pkt_attrib	 *pattrib = &((struct xmit_frame *)pxmitframe)->tx_attrib;
+	struct 	security_priv	*psecuritypriv=&rtlpriv->securitypriv;
+	struct	xmit_priv		*pxmitpriv=&rtlpriv->xmitpriv;
+	uint32_t	res=_SUCCESS;
+
+
+	if(((struct xmit_frame*)pxmitframe)->buf_addr==NULL)
+		return _FAIL;
+
+	hw_hdr_offset = TXDESC_SIZE +
+		 (((struct xmit_frame*)pxmitframe)->pkt_offset * PACKET_OFFSET_SZ);
+
+	pframe = ((struct xmit_frame*)pxmitframe)->buf_addr + hw_hdr_offset;
+	//4 start to encrypt each fragment
+	if(pattrib->encrypt==TKIP_ENCRYPTION){
+
+/*
+		if(pattrib->psta)
+		{
+			stainfo = pattrib->psta;
+		}
+		else
+		{
+			DBG_871X("%s, call rtw_get_stainfo()\n", __func__);
+			stainfo=rtw_get_stainfo(&rtlpriv->stapriv ,&pattrib->ra[0] );
+		}
+*/
+		//if (stainfo!=NULL)
+		{
+/*
+			if(!(stainfo->state &_FW_LINKED))
+			{
+				DBG_871X("%s, psta->state(0x%x) != _FW_LINKED\n", __func__, stainfo->state);
+				return _FAIL;
+			}
+*/
+
+			if(is_multicast_ether_addr(pattrib->ra))
+			{
+				prwskey=psecuritypriv->dot118021XGrpKey[psecuritypriv->dot118021XGrpKeyid].skey;
+			}
+			else
+			{
+				//prwskey=&stainfo->dot118021x_UncstKey.skey[0];
+				prwskey=pattrib->dot118021x_UncstKey.skey;
+			}
+
+			prwskeylen=16;
+
+			for(curfragnum=0;curfragnum<pattrib->nr_frags;curfragnum++){
+				iv=pframe+pattrib->hdrlen;
+				payload=pframe+pattrib->iv_len+pattrib->hdrlen;
+
+				GET_TKIP_PN(iv, dot11txpn);
+
+				pnl=(u16)(dot11txpn.val);
+				pnh=(uint32_t)(dot11txpn.val>>16);
+
+				phase1((u16 *)&ttkey[0],prwskey,&pattrib->ta[0],pnh);
+
+				phase2(&rc4key[0],prwskey,(u16 *)&ttkey[0],pnl);
+
+				if((curfragnum+1)==pattrib->nr_frags){	//4 the last fragment
+					length=pattrib->last_txcmdsz-pattrib->hdrlen-pattrib->iv_len- pattrib->icv_len;
+					*((uint32_t	 *)crc)=cpu_to_le32(getcrc32(payload,length));/* modified by Amy*/
+
+					arcfour_init(&mycontext, rc4key,16);
+					arcfour_encrypt(&mycontext, payload, payload, length);
+					arcfour_encrypt(&mycontext, payload+length, crc, 4);
+
+				}
+				else{
+					length=pxmitpriv->frag_len-pattrib->hdrlen-pattrib->iv_len-pattrib->icv_len ;
+					*((uint32_t	 *)crc)=cpu_to_le32(getcrc32(payload,length));/* modified by Amy*/
+					arcfour_init(&mycontext,rc4key,16);
+					arcfour_encrypt(&mycontext, payload, payload, length);
+					arcfour_encrypt(&mycontext, payload+length, crc, 4);
+
+				pframe+=pxmitpriv->frag_len;
+				pframe=(uint8_t *)RND4((SIZE_PTR)(pframe));
+
+				}
+			}
+
+
+		}
+/*
+		else{
+			RT_TRACE(_module_rtl871x_security_c_,_drv_err_,("rtw_tkip_encrypt: stainfo==NULL!!!\n"));
+                        DBG_871X("%s, psta==NUL\n", __func__);
+			res=_FAIL;
+		}
+*/
+
+	}
+
+	return res;
+
+}
+
+
+//The hlen isn't include the IV
+uint32_t	 rtw_tkip_decrypt(struct rtl_priv *rtlpriv, struct recv_frame  *precvframe)
+{																	// exclude ICV
+	u16 pnl;
+	uint32_t	 pnh;
+	uint8_t   rc4key[16];
+	uint8_t   ttkey[16];
+	uint8_t	crc[4];
+	struct arc4context mycontext;
+	int 			length;
+	uint32_t	prwskeylen;
+
+	uint8_t	*pframe, *payload,*iv,*prwskey;
+	union pn48 dot11txpn;
+	struct	sta_info		*stainfo;
+	struct	rx_pkt_attrib	 *prxattrib = &precvframe->attrib;
+	struct 	security_priv	*psecuritypriv=&rtlpriv->securitypriv;
+//	struct	recv_priv		*precvpriv=&rtlpriv->recvpriv;
+	uint32_t		res=_SUCCESS;
+
+
+
+	pframe = precvframe->rx_data;
+
+	//4 start to decrypt recvframe
+	if(prxattrib->encrypt==TKIP_ENCRYPTION){
+
+		stainfo=rtw_get_stainfo(&rtlpriv->stapriv ,&prxattrib->ta[0] );
+		if (stainfo!=NULL){
+
+			if(is_multicast_ether_addr(prxattrib->ra))
+			{
+				if(psecuritypriv->binstallGrpkey==false)
+				{
+					res=_FAIL;
+					DBG_8192C("%s:rx bc/mc packets,but didn't install group key!!!!!!!!!!\n",__FUNCTION__);
+					goto exit;
+				}
+				//DBG_871X("rx bc/mc packets, to perform sw rtw_tkip_decrypt\n");
+				//prwskey = psecuritypriv->dot118021XGrpKey[psecuritypriv->dot118021XGrpKeyid].skey;
+				prwskey = psecuritypriv->dot118021XGrpKey[prxattrib->key_index].skey;
+				prwskeylen=16;
+			}
+			else
+			{
+				prwskey=&stainfo->dot118021x_UncstKey.skey[0];
+				prwskeylen=16;
+			}
+
+			iv=pframe+prxattrib->hdrlen;
+			payload=pframe+prxattrib->iv_len+prxattrib->hdrlen;
+			length= precvframe->len-prxattrib->hdrlen-prxattrib->iv_len;
+
+			GET_TKIP_PN(iv, dot11txpn);
+
+			pnl=(u16)(dot11txpn.val);
+			pnh=(uint32_t)(dot11txpn.val>>16);
+
+			phase1((u16 *)&ttkey[0],prwskey,&prxattrib->ta[0],pnh);
+			phase2(&rc4key[0],prwskey,(unsigned short *)&ttkey[0],pnl);
+
+			//4 decrypt payload include icv
+
+			arcfour_init(&mycontext, rc4key,16);
+			arcfour_encrypt(&mycontext, payload, payload, length);
+
+			*((uint32_t	 *)crc)=le32_to_cpu(getcrc32(payload,length-4));
+
+			if(crc[3]!=payload[length-1] || crc[2]!=payload[length-2] || crc[1]!=payload[length-3] || crc[0]!=payload[length-4])
+			{
+				res=_FAIL;
+			}
+
+
+		}
+		else{
+			res=_FAIL;
+		}
+
+	}
+
+exit:
+	return res;
+
+}
+
+
+//3			=====AES related=====
+
+
+
+#define MAX_MSG_SIZE	2048
+/*****************************/
+/******** SBOX Table *********/
+/*****************************/
+
+  static  uint8_t sbox_table[256] =
+    {
+        0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5,
+        0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
+        0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0,
+        0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
+        0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc,
+        0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
+        0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a,
+        0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
+        0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0,
+        0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
+        0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b,
+        0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
+        0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85,
+        0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
+        0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5,
+        0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
+        0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17,
+        0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
+        0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88,
+        0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
+        0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c,
+        0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
+        0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9,
+        0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
+        0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6,
+        0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
+        0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e,
+        0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
+        0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94,
+        0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
+        0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68,
+        0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16
+    };
+
+/*****************************/
+/**** Function Prototypes ****/
+/*****************************/
+
+static void bitwise_xor(uint8_t *ina, uint8_t *inb, uint8_t *out);
+static void construct_mic_iv(
+                        uint8_t *mic_header1,
+                        int qc_exists,
+                        int a4_exists,
+                        uint8_t *mpdu,
+                        uint payload_length,
+                        uint8_t * pn_vector);
+static void construct_mic_header1(
+                        uint8_t *mic_header1,
+                        int header_length,
+                        uint8_t *mpdu);
+static void construct_mic_header2(
+                    uint8_t *mic_header2,
+                    uint8_t *mpdu,
+                    int a4_exists,
+                    int qc_exists);
+static void construct_ctr_preload(
+                        uint8_t *ctr_preload,
+                        int a4_exists,
+                        int qc_exists,
+                        uint8_t *mpdu,
+                        uint8_t *pn_vector,
+                        int c);
+static void xor_128(uint8_t *a, uint8_t *b, uint8_t *out);
+static void xor_32(uint8_t *a, uint8_t *b, uint8_t *out);
+static uint8_t sbox(uint8_t a);
+static void next_key(uint8_t *key, int round);
+static void byte_sub(uint8_t *in, uint8_t *out);
+static void shift_row(uint8_t *in, uint8_t *out);
+static void mix_column(uint8_t *in, uint8_t *out);
+static void add_round_key( uint8_t *shiftrow_in,
+                    uint8_t *mcol_in,
+                    uint8_t *block_in,
+                    int round,
+                    uint8_t *out);
+static void aes128k128d(uint8_t *key, uint8_t *data, uint8_t *ciphertext);
+
+
+/****************************************/
+/* aes128k128d()                        */
+/* Performs a 128 bit AES encrypt with  */
+/* 128 bit data.                        */
+/****************************************/
+static void xor_128(uint8_t *a, uint8_t *b, uint8_t *out)
+{
+    int i;
+
+    for (i=0;i<16; i++)
+    {
+        out[i] = a[i] ^ b[i];
+    }
+
+}
+
+
+static void xor_32(uint8_t *a, uint8_t *b, uint8_t *out)
+{
+    int i;
+
+    for (i=0;i<4; i++)
+    {
+        out[i] = a[i] ^ b[i];
+    }
+
+}
+
+
+static uint8_t sbox(uint8_t a)
+{
+    return sbox_table[(int)a];
+}
+
+
+static void next_key(uint8_t *key, int round)
+{
+    uint8_t rcon;
+    uint8_t sbox_key[4];
+    uint8_t rcon_table[12] =
+    {
+        0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80,
+        0x1b, 0x36, 0x36, 0x36
+    };
+
+    sbox_key[0] = sbox(key[13]);
+    sbox_key[1] = sbox(key[14]);
+    sbox_key[2] = sbox(key[15]);
+    sbox_key[3] = sbox(key[12]);
+
+    rcon = rcon_table[round];
+
+    xor_32(&key[0], sbox_key, &key[0]);
+    key[0] = key[0] ^ rcon;
+
+    xor_32(&key[4], &key[0], &key[4]);
+    xor_32(&key[8], &key[4], &key[8]);
+    xor_32(&key[12], &key[8], &key[12]);
+
+}
+
+
+static void byte_sub(uint8_t *in, uint8_t *out)
+{
+    int i;
+
+    for (i=0; i< 16; i++)
+    {
+        out[i] = sbox(in[i]);
+    }
+
+}
+
+
+static void shift_row(uint8_t *in, uint8_t *out)
+{
+
+    out[0] =  in[0];
+    out[1] =  in[5];
+    out[2] =  in[10];
+    out[3] =  in[15];
+    out[4] =  in[4];
+    out[5] =  in[9];
+    out[6] =  in[14];
+    out[7] =  in[3];
+    out[8] =  in[8];
+    out[9] =  in[13];
+    out[10] = in[2];
+    out[11] = in[7];
+    out[12] = in[12];
+    out[13] = in[1];
+    out[14] = in[6];
+    out[15] = in[11];
+
+}
+
+
+static void mix_column(uint8_t *in, uint8_t *out)
+{
+    int i;
+    uint8_t add1b[4];
+    uint8_t add1bf7[4];
+    uint8_t rotl[4];
+    uint8_t swap_halfs[4];
+    uint8_t andf7[4];
+    uint8_t rotr[4];
+    uint8_t temp[4];
+    uint8_t tempb[4];
+
+    for (i=0 ; i<4; i++)
+    {
+        if ((in[i] & 0x80)== 0x80)
+            add1b[i] = 0x1b;
+        else
+            add1b[i] = 0x00;
+    }
+
+    swap_halfs[0] = in[2];    /* Swap halfs */
+    swap_halfs[1] = in[3];
+    swap_halfs[2] = in[0];
+    swap_halfs[3] = in[1];
+
+    rotl[0] = in[3];        /* Rotate left 8 bits */
+    rotl[1] = in[0];
+    rotl[2] = in[1];
+    rotl[3] = in[2];
+
+    andf7[0] = in[0] & 0x7f;
+    andf7[1] = in[1] & 0x7f;
+    andf7[2] = in[2] & 0x7f;
+    andf7[3] = in[3] & 0x7f;
+
+    for (i = 3; i>0; i--)    /* logical shift left 1 bit */
+    {
+        andf7[i] = andf7[i] << 1;
+        if ((andf7[i-1] & 0x80) == 0x80)
+        {
+            andf7[i] = (andf7[i] | 0x01);
+        }
+    }
+    andf7[0] = andf7[0] << 1;
+    andf7[0] = andf7[0] & 0xfe;
+
+    xor_32(add1b, andf7, add1bf7);
+
+    xor_32(in, add1bf7, rotr);
+
+    temp[0] = rotr[0];         /* Rotate right 8 bits */
+    rotr[0] = rotr[1];
+    rotr[1] = rotr[2];
+    rotr[2] = rotr[3];
+    rotr[3] = temp[0];
+
+    xor_32(add1bf7, rotr, temp);
+    xor_32(swap_halfs, rotl,tempb);
+    xor_32(temp, tempb, out);
+
+}
+
+
+static void aes128k128d(uint8_t *key, uint8_t *data, uint8_t *ciphertext)
+{
+    int round;
+    int i;
+    uint8_t intermediatea[16];
+    uint8_t intermediateb[16];
+    uint8_t round_key[16];
+
+    for(i=0; i<16; i++) round_key[i] = key[i];
+
+    for (round = 0; round < 11; round++)
+    {
+        if (round == 0)
+        {
+            xor_128(round_key, data, ciphertext);
+            next_key(round_key, round);
+        }
+        else if (round == 10)
+        {
+            byte_sub(ciphertext, intermediatea);
+            shift_row(intermediatea, intermediateb);
+            xor_128(intermediateb, round_key, ciphertext);
+        }
+        else    /* 1 - 9 */
+        {
+            byte_sub(ciphertext, intermediatea);
+            shift_row(intermediatea, intermediateb);
+            mix_column(&intermediateb[0], &intermediatea[0]);
+            mix_column(&intermediateb[4], &intermediatea[4]);
+            mix_column(&intermediateb[8], &intermediatea[8]);
+            mix_column(&intermediateb[12], &intermediatea[12]);
+            xor_128(intermediatea, round_key, ciphertext);
+            next_key(round_key, round);
+        }
+    }
+
+}
+
+
+/************************************************/
+/* construct_mic_iv()                           */
+/* Builds the MIC IV from header fields and PN  */
+/************************************************/
+static void construct_mic_iv(
+                        uint8_t *mic_iv,
+                        int qc_exists,
+                        int a4_exists,
+                        uint8_t *mpdu,
+                        uint payload_length,
+                        uint8_t *pn_vector
+                        )
+{
+    int i;
+
+    mic_iv[0] = 0x59;
+    if (qc_exists && a4_exists) mic_iv[1] = mpdu[30] & 0x0f;    /* QoS_TC           */
+    if (qc_exists && !a4_exists) mic_iv[1] = mpdu[24] & 0x0f;   /* mute bits 7-4    */
+    if (!qc_exists) mic_iv[1] = 0x00;
+    for (i = 2; i < 8; i++)
+        mic_iv[i] = mpdu[i + 8];                    /* mic_iv[2:7] = A2[0:5] = mpdu[10:15] */
+    #ifdef CONSISTENT_PN_ORDER
+        for (i = 8; i < 14; i++)
+            mic_iv[i] = pn_vector[i - 8];           /* mic_iv[8:13] = PN[0:5] */
+    #else
+        for (i = 8; i < 14; i++)
+            mic_iv[i] = pn_vector[13 - i];          /* mic_iv[8:13] = PN[5:0] */
+    #endif
+    mic_iv[14] = (unsigned char) (payload_length / 256);
+    mic_iv[15] = (unsigned char) (payload_length % 256);
+
+}
+
+
+/************************************************/
+/* construct_mic_header1()                      */
+/* Builds the first MIC header block from       */
+/* header fields.                               */
+/************************************************/
+static void construct_mic_header1(
+                        uint8_t *mic_header1,
+                        int header_length,
+                        uint8_t *mpdu
+                        )
+{
+
+    mic_header1[0] = (uint8_t)((header_length - 2) / 256);
+    mic_header1[1] = (uint8_t)((header_length - 2) % 256);
+    mic_header1[2] = mpdu[0] & 0xcf;    /* Mute CF poll & CF ack bits */
+    mic_header1[3] = mpdu[1] & 0xc7;    /* Mute retry, more data and pwr mgt bits */
+    mic_header1[4] = mpdu[4];       /* A1 */
+    mic_header1[5] = mpdu[5];
+    mic_header1[6] = mpdu[6];
+    mic_header1[7] = mpdu[7];
+    mic_header1[8] = mpdu[8];
+    mic_header1[9] = mpdu[9];
+    mic_header1[10] = mpdu[10];     /* A2 */
+    mic_header1[11] = mpdu[11];
+    mic_header1[12] = mpdu[12];
+    mic_header1[13] = mpdu[13];
+    mic_header1[14] = mpdu[14];
+    mic_header1[15] = mpdu[15];
+
+}
+
+
+/************************************************/
+/* construct_mic_header2()                      */
+/* Builds the last MIC header block from        */
+/* header fields.                               */
+/************************************************/
+static void construct_mic_header2(
+                uint8_t *mic_header2,
+                uint8_t *mpdu,
+                int a4_exists,
+                int qc_exists
+                )
+{
+    int i;
+
+    for (i = 0; i<16; i++) mic_header2[i]=0x00;
+
+    mic_header2[0] = mpdu[16];    /* A3 */
+    mic_header2[1] = mpdu[17];
+    mic_header2[2] = mpdu[18];
+    mic_header2[3] = mpdu[19];
+    mic_header2[4] = mpdu[20];
+    mic_header2[5] = mpdu[21];
+
+    //mic_header2[6] = mpdu[22] & 0xf0;   /* SC */
+    mic_header2[6] = 0x00;
+    mic_header2[7] = 0x00; /* mpdu[23]; */
+
+
+    if (!qc_exists && a4_exists)
+    {
+        for (i=0;i<6;i++) mic_header2[8+i] = mpdu[24+i];   /* A4 */
+
+    }
+
+    if (qc_exists && !a4_exists)
+    {
+        mic_header2[8] = mpdu[24] & 0x0f; /* mute bits 15 - 4 */
+        mic_header2[9] = mpdu[25] & 0x00;
+    }
+
+    if (qc_exists && a4_exists)
+    {
+        for (i=0;i<6;i++) mic_header2[8+i] = mpdu[24+i];   /* A4 */
+
+        mic_header2[14] = mpdu[30] & 0x0f;
+        mic_header2[15] = mpdu[31] & 0x00;
+    }
+
+
+}
+
+
+/************************************************/
+/* construct_mic_header2()                      */
+/* Builds the last MIC header block from        */
+/* header fields.                               */
+/************************************************/
+static void construct_ctr_preload(
+                        uint8_t *ctr_preload,
+                        int a4_exists,
+                        int qc_exists,
+                        uint8_t *mpdu,
+                        uint8_t *pn_vector,
+                        int c
+                        )
+{
+    int i = 0;
+
+    for (i=0; i<16; i++) ctr_preload[i] = 0x00;
+    i = 0;
+
+    ctr_preload[0] = 0x01;                                  /* flag */
+    if (qc_exists && a4_exists)
+		ctr_preload[1] = mpdu[30] & 0x0f;   /* QoC_Control */
+    if (qc_exists && !a4_exists)
+		ctr_preload[1] = mpdu[24] & 0x0f;
+
+    for (i = 2; i < 8; i++)
+        ctr_preload[i] = mpdu[i + 8];                       /* ctr_preload[2:7] = A2[0:5] = mpdu[10:15] */
+    #ifdef CONSISTENT_PN_ORDER
+      for (i = 8; i < 14; i++)
+            ctr_preload[i] =    pn_vector[i - 8];           /* ctr_preload[8:13] = PN[0:5] */
+    #else
+      for (i = 8; i < 14; i++)
+            ctr_preload[i] =    pn_vector[13 - i];          /* ctr_preload[8:13] = PN[5:0] */
+    #endif
+    ctr_preload[14] =  (unsigned char) (c / 256); /* Ctr */
+    ctr_preload[15] =  (unsigned char) (c % 256);
+
+}
+
+
+/************************************/
+/* bitwise_xor()                    */
+/* A 128 bit, bitwise exclusive or  */
+/************************************/
+static void bitwise_xor(uint8_t *ina, uint8_t *inb, uint8_t *out)
+{
+    int i;
+
+    for (i=0; i<16; i++)
+    {
+        out[i] = ina[i] ^ inb[i];
+    }
+
+}
+
+
+static int aes_cipher(uint8_t *key, uint	hdrlen,
+			uint8_t *pframe, uint plen)
+{
+//	/*static*/ unsigned char	message[MAX_MSG_SIZE];
+	uint	qc_exists, a4_exists, i, j, payload_remainder,
+		num_blocks, payload_index;
+
+	uint8_t pn_vector[6];
+	uint8_t mic_iv[16];
+	uint8_t mic_header1[16];
+	uint8_t mic_header2[16];
+	uint8_t ctr_preload[16];
+
+	/* Intermediate Buffers */
+	uint8_t chain_buffer[16];
+	uint8_t aes_out[16];
+	uint8_t padded_buffer[16];
+	uint8_t mic[8];
+//	uint	offset = 0;
+	uint	frtype  = GetFrameType(pframe);
+	uint	frsubtype  = GetFrameSubType(pframe);
+
+
+	frsubtype=frsubtype>>4;
+
+
+	memset((void *)mic_iv, 0, 16);
+	memset((void *)mic_header1, 0, 16);
+	memset((void *)mic_header2, 0, 16);
+	memset((void *)ctr_preload, 0, 16);
+	memset((void *)chain_buffer, 0, 16);
+	memset((void *)aes_out, 0, 16);
+	memset((void *)padded_buffer, 0, 16);
+
+	if ((hdrlen == WLAN_HDR_A3_LEN )||(hdrlen ==  WLAN_HDR_A3_QOS_LEN))
+		a4_exists = 0;
+	else
+		a4_exists = 1;
+
+	if (
+		(frtype == WIFI_DATA_CFACK) ||
+		(frtype == WIFI_DATA_CFPOLL)||
+		(frtype == WIFI_DATA_CFACKPOLL))
+		{
+			qc_exists = 1;
+					if(hdrlen !=  WLAN_HDR_A3_QOS_LEN){
+
+					hdrlen += 2;
+			}
+		}
+	else if (
+		(frsubtype == 0x08) ||
+		(frsubtype == 0x09)||
+		(frsubtype == 0x0a)||
+		(frsubtype == 0x0b))
+		{
+			if(hdrlen !=  WLAN_HDR_A3_QOS_LEN){
+
+					hdrlen += 2;
+			}
+			qc_exists = 1;
+		}
+	else
+		qc_exists = 0;
+
+	pn_vector[0]=pframe[hdrlen];
+	pn_vector[1]=pframe[hdrlen+1];
+	pn_vector[2]=pframe[hdrlen+4];
+	pn_vector[3]=pframe[hdrlen+5];
+	pn_vector[4]=pframe[hdrlen+6];
+	pn_vector[5]=pframe[hdrlen+7];
+
+	construct_mic_iv(
+                        mic_iv,
+                        qc_exists,
+                        a4_exists,
+                        pframe,	 //message,
+                        plen,
+                        pn_vector
+                        );
+
+    construct_mic_header1(
+                            mic_header1,
+                            hdrlen,
+                            pframe	//message
+                            );
+    construct_mic_header2(
+                            mic_header2,
+                            pframe,	//message,
+                            a4_exists,
+                            qc_exists
+                            );
+
+
+	payload_remainder = plen % 16;
+    num_blocks = plen / 16;
+
+    /* Find start of payload */
+    payload_index = (hdrlen + 8);
+
+    /* Calculate MIC */
+    aes128k128d(key, mic_iv, aes_out);
+    bitwise_xor(aes_out, mic_header1, chain_buffer);
+    aes128k128d(key, chain_buffer, aes_out);
+    bitwise_xor(aes_out, mic_header2, chain_buffer);
+    aes128k128d(key, chain_buffer, aes_out);
+
+	for (i = 0; i < num_blocks; i++)
+    {
+        bitwise_xor(aes_out, &pframe[payload_index], chain_buffer);//bitwise_xor(aes_out, &message[payload_index], chain_buffer);
+
+        payload_index += 16;
+        aes128k128d(key, chain_buffer, aes_out);
+    }
+
+    /* Add on the final payload block if it needs padding */
+    if (payload_remainder > 0)
+    {
+        for (j = 0; j < 16; j++) padded_buffer[j] = 0x00;
+        for (j = 0; j < payload_remainder; j++)
+        {
+            padded_buffer[j] = pframe[payload_index++];//padded_buffer[j] = message[payload_index++];
+        }
+        bitwise_xor(aes_out, padded_buffer, chain_buffer);
+        aes128k128d(key, chain_buffer, aes_out);
+
+    }
+
+    for (j = 0 ; j < 8; j++) mic[j] = aes_out[j];
+
+    /* Insert MIC into payload */
+    for (j = 0; j < 8; j++)
+    	pframe[payload_index+j] = mic[j];	//message[payload_index+j] = mic[j];
+
+	payload_index = hdrlen + 8;
+	for (i=0; i< num_blocks; i++)
+    {
+        construct_ctr_preload(
+                                ctr_preload,
+                                a4_exists,
+                                qc_exists,
+                                pframe,	//message,
+                                pn_vector,
+                                i+1);
+        aes128k128d(key, ctr_preload, aes_out);
+        bitwise_xor(aes_out, &pframe[payload_index], chain_buffer);//bitwise_xor(aes_out, &message[payload_index], chain_buffer);
+        for (j=0; j<16;j++) pframe[payload_index++] = chain_buffer[j];//for (j=0; j<16;j++) message[payload_index++] = chain_buffer[j];
+    }
+
+    if (payload_remainder > 0)          /* If there is a short final block, then pad it,*/
+    {                                   /* encrypt it and copy the unpadded part back   */
+        construct_ctr_preload(
+                                ctr_preload,
+                                a4_exists,
+                                qc_exists,
+                                pframe,	//message,
+                                pn_vector,
+                                num_blocks+1);
+
+        for (j = 0; j < 16; j++) padded_buffer[j] = 0x00;
+        for (j = 0; j < payload_remainder; j++)
+        {
+            padded_buffer[j] = pframe[payload_index+j];//padded_buffer[j] = message[payload_index+j];
+        }
+        aes128k128d(key, ctr_preload, aes_out);
+        bitwise_xor(aes_out, padded_buffer, chain_buffer);
+        for (j=0; j<payload_remainder;j++) pframe[payload_index++] = chain_buffer[j];//for (j=0; j<payload_remainder;j++) message[payload_index++] = chain_buffer[j];
+    }
+
+    /* Encrypt the MIC */
+    construct_ctr_preload(
+                        ctr_preload,
+                        a4_exists,
+                        qc_exists,
+                        pframe,	//message,
+                        pn_vector,
+                        0);
+
+    for (j = 0; j < 16; j++) padded_buffer[j] = 0x00;
+    for (j = 0; j < 8; j++)
+    {
+        padded_buffer[j] = pframe[j+hdrlen+8+plen];//padded_buffer[j] = message[j+hdrlen+8+plen];
+    }
+
+    aes128k128d(key, ctr_preload, aes_out);
+    bitwise_xor(aes_out, padded_buffer, chain_buffer);
+    for (j=0; j<8;j++) pframe[payload_index++] = chain_buffer[j];//for (j=0; j<8;j++) message[payload_index++] = chain_buffer[j];
+
+	return _SUCCESS;
+}
+
+
+
+
+
+uint32_t	rtw_aes_encrypt(struct rtl_priv *rtlpriv, uint8_t *pxmitframe)
+{	// exclude ICV
+
+
+	/*static*/
+//	unsigned char	message[MAX_MSG_SIZE];
+
+    	/* Intermediate Buffers */
+	int 	curfragnum,length;
+	uint32_t	prwskeylen;
+	uint8_t	*pframe,*prwskey;	//, *payload,*iv
+	uint8_t   hw_hdr_offset = 0;
+	//struct	sta_info		*stainfo;
+	struct	tx_pkt_attrib	 *pattrib = &((struct xmit_frame *)pxmitframe)->tx_attrib;
+	struct 	security_priv	*psecuritypriv=&rtlpriv->securitypriv;
+	struct	xmit_priv		*pxmitpriv=&rtlpriv->xmitpriv;
+
+//	uint	offset = 0;
+	uint32_t	 res=_SUCCESS;
+
+
+	if(((struct xmit_frame*)pxmitframe)->buf_addr==NULL)
+		return _FAIL;
+
+	hw_hdr_offset = TXDESC_SIZE +
+		 (((struct xmit_frame*)pxmitframe)->pkt_offset * PACKET_OFFSET_SZ);
+
+	pframe = ((struct xmit_frame*)pxmitframe)->buf_addr + hw_hdr_offset;
+
+	//4 start to encrypt each fragment
+	if((pattrib->encrypt==AESCCMP_ENCRYPTION)){
+/*
+		if(pattrib->psta)
+		{
+			stainfo = pattrib->psta;
+		}
+		else
+		{
+			DBG_871X("%s, call rtw_get_stainfo()\n", __func__);
+			stainfo=rtw_get_stainfo(&rtlpriv->stapriv ,&pattrib->ra[0] );
+		}
+*/
+		//if (stainfo!=NULL)
+		{
+/*
+			if(!(stainfo->state &_FW_LINKED))
+			{
+				DBG_871X("%s, psta->state(0x%x) != _FW_LINKED\n", __func__, stainfo->state);
+				return _FAIL;
+			}
+*/
+
+			if(is_multicast_ether_addr(pattrib->ra))
+			{
+				prwskey=psecuritypriv->dot118021XGrpKey[psecuritypriv->dot118021XGrpKeyid].skey;
+			}
+			else
+			{
+				//prwskey=&stainfo->dot118021x_UncstKey.skey[0];
+				prwskey=pattrib->dot118021x_UncstKey.skey;
+			}
+
+
+			prwskeylen=16;
+
+			for(curfragnum=0;curfragnum<pattrib->nr_frags;curfragnum++){
+
+				if((curfragnum+1)==pattrib->nr_frags){	//4 the last fragment
+					length=pattrib->last_txcmdsz-pattrib->hdrlen-pattrib->iv_len- pattrib->icv_len;
+
+					aes_cipher(prwskey,pattrib->hdrlen,pframe, length);
+				}
+				else{
+					length=pxmitpriv->frag_len-pattrib->hdrlen-pattrib->iv_len-pattrib->icv_len ;
+
+					aes_cipher(prwskey,pattrib->hdrlen,pframe, length);
+				pframe+=pxmitpriv->frag_len;
+				pframe=(uint8_t *)RND4((SIZE_PTR)(pframe));
+
+				}
+			}
+
+
+		}
+/*
+		else{
+			RT_TRACE(_module_rtl871x_security_c_,_drv_err_,("rtw_aes_encrypt: stainfo==NULL!!!\n"));
+                        DBG_871X("%s, psta==NUL\n", __func__);
+			res=_FAIL;
+		}
+*/
+
+	}
+
+
+
+
+		return res;
+}
+
+static int aes_decipher(uint8_t *key, uint	hdrlen,
+			uint8_t *pframe, uint plen)
+{
+	static uint8_t	message[MAX_MSG_SIZE];
+	uint	qc_exists, a4_exists, i, j, payload_remainder,
+			num_blocks, payload_index;
+	int res = _SUCCESS;
+	uint8_t pn_vector[6];
+	uint8_t mic_iv[16];
+	uint8_t mic_header1[16];
+	uint8_t mic_header2[16];
+	uint8_t ctr_preload[16];
+
+    /* Intermediate Buffers */
+	uint8_t chain_buffer[16];
+	uint8_t aes_out[16];
+	uint8_t padded_buffer[16];
+	uint8_t mic[8];
+
+
+//	uint	offset = 0;
+	uint	frtype  = GetFrameType(pframe);
+	uint	frsubtype  = GetFrameSubType(pframe);
+
+	frsubtype=frsubtype>>4;
+
+
+	memset((void *)mic_iv, 0, 16);
+	memset((void *)mic_header1, 0, 16);
+	memset((void *)mic_header2, 0, 16);
+	memset((void *)ctr_preload, 0, 16);
+	memset((void *)chain_buffer, 0, 16);
+	memset((void *)aes_out, 0, 16);
+	memset((void *)padded_buffer, 0, 16);
+
+	//start to decrypt the payload
+
+	num_blocks = (plen-8) / 16; //(plen including llc, payload_length and mic )
+
+	payload_remainder = (plen-8) % 16;
+
+	pn_vector[0]  = pframe[hdrlen];
+	pn_vector[1]  = pframe[hdrlen+1];
+	pn_vector[2]  = pframe[hdrlen+4];
+	pn_vector[3]  = pframe[hdrlen+5];
+	pn_vector[4]  = pframe[hdrlen+6];
+	pn_vector[5]  = pframe[hdrlen+7];
+
+	if ((hdrlen == WLAN_HDR_A3_LEN )||(hdrlen ==  WLAN_HDR_A3_QOS_LEN))
+		a4_exists = 0;
+	else
+		a4_exists = 1;
+
+	if (
+		(frtype == WIFI_DATA_CFACK) ||
+		(frtype == WIFI_DATA_CFPOLL)||
+		(frtype == WIFI_DATA_CFACKPOLL))
+		{
+			qc_exists = 1;
+					if(hdrlen !=  WLAN_HDR_A3_QOS_LEN){
+
+					hdrlen += 2;
+			}
+		}
+	else if (
+		(frsubtype == 0x08) ||
+		(frsubtype == 0x09)||
+		(frsubtype == 0x0a)||
+		(frsubtype == 0x0b))
+		{
+			if(hdrlen !=  WLAN_HDR_A3_QOS_LEN){
+
+					hdrlen += 2;
+			}
+			qc_exists = 1;
+		}
+	else
+		qc_exists = 0;
+
+
+	// now, decrypt pframe with hdrlen offset and plen long
+
+	payload_index = hdrlen + 8; // 8 is for extiv
+
+	for (i=0; i< num_blocks; i++)
+    {
+        construct_ctr_preload(
+                                ctr_preload,
+                                a4_exists,
+                                qc_exists,
+                                pframe,
+                                pn_vector,
+                                i+1
+                            );
+
+        aes128k128d(key, ctr_preload, aes_out);
+        bitwise_xor(aes_out, &pframe[payload_index], chain_buffer);
+
+        for (j=0; j<16;j++) pframe[payload_index++] = chain_buffer[j];
+    }
+
+    if (payload_remainder > 0)          /* If there is a short final block, then pad it,*/
+    {                                   /* encrypt it and copy the unpadded part back   */
+        construct_ctr_preload(
+                                ctr_preload,
+                                a4_exists,
+                                qc_exists,
+                                pframe,
+                                pn_vector,
+                                num_blocks+1
+                            );
+
+        for (j = 0; j < 16; j++) padded_buffer[j] = 0x00;
+        for (j = 0; j < payload_remainder; j++)
+        {
+            padded_buffer[j] = pframe[payload_index+j];
+        }
+        aes128k128d(key, ctr_preload, aes_out);
+        bitwise_xor(aes_out, padded_buffer, chain_buffer);
+        for (j=0; j<payload_remainder;j++) pframe[payload_index++] = chain_buffer[j];
+    }
+
+	//start to calculate the mic
+	if((hdrlen +plen+8) <= MAX_MSG_SIZE)
+		memcpy((void *)message, pframe, (hdrlen +plen+8)); //8 is for ext iv len
+
+
+	pn_vector[0]=pframe[hdrlen];
+	pn_vector[1]=pframe[hdrlen+1];
+	pn_vector[2]=pframe[hdrlen+4];
+	pn_vector[3]=pframe[hdrlen+5];
+	pn_vector[4]=pframe[hdrlen+6];
+	pn_vector[5]=pframe[hdrlen+7];
+
+
+
+	construct_mic_iv(
+                        mic_iv,
+                        qc_exists,
+                        a4_exists,
+                        message,
+                        plen-8,
+                        pn_vector
+                        );
+
+    construct_mic_header1(
+                            mic_header1,
+                            hdrlen,
+                            message
+                            );
+    construct_mic_header2(
+                            mic_header2,
+                            message,
+                            a4_exists,
+                            qc_exists
+                            );
+
+
+	payload_remainder = (plen-8) % 16;
+    num_blocks = (plen-8) / 16;
+
+    /* Find start of payload */
+    payload_index = (hdrlen + 8);
+
+    /* Calculate MIC */
+    aes128k128d(key, mic_iv, aes_out);
+    bitwise_xor(aes_out, mic_header1, chain_buffer);
+    aes128k128d(key, chain_buffer, aes_out);
+    bitwise_xor(aes_out, mic_header2, chain_buffer);
+    aes128k128d(key, chain_buffer, aes_out);
+
+	for (i = 0; i < num_blocks; i++)
+    {
+        bitwise_xor(aes_out, &message[payload_index], chain_buffer);
+
+        payload_index += 16;
+        aes128k128d(key, chain_buffer, aes_out);
+    }
+
+    /* Add on the final payload block if it needs padding */
+    if (payload_remainder > 0)
+    {
+        for (j = 0; j < 16; j++) padded_buffer[j] = 0x00;
+        for (j = 0; j < payload_remainder; j++)
+        {
+            padded_buffer[j] = message[payload_index++];
+        }
+        bitwise_xor(aes_out, padded_buffer, chain_buffer);
+        aes128k128d(key, chain_buffer, aes_out);
+
+    }
+
+    for (j = 0 ; j < 8; j++) mic[j] = aes_out[j];
+
+    /* Insert MIC into payload */
+    for (j = 0; j < 8; j++)
+    	message[payload_index+j] = mic[j];
+
+	payload_index = hdrlen + 8;
+	for (i=0; i< num_blocks; i++)
+    {
+        construct_ctr_preload(
+                                ctr_preload,
+                                a4_exists,
+                                qc_exists,
+                                message,
+                                pn_vector,
+                                i+1);
+        aes128k128d(key, ctr_preload, aes_out);
+        bitwise_xor(aes_out, &message[payload_index], chain_buffer);
+        for (j=0; j<16;j++) message[payload_index++] = chain_buffer[j];
+    }
+
+    if (payload_remainder > 0)          /* If there is a short final block, then pad it,*/
+    {                                   /* encrypt it and copy the unpadded part back   */
+        construct_ctr_preload(
+                                ctr_preload,
+                                a4_exists,
+                                qc_exists,
+                                message,
+                                pn_vector,
+                                num_blocks+1);
+
+        for (j = 0; j < 16; j++) padded_buffer[j] = 0x00;
+        for (j = 0; j < payload_remainder; j++)
+        {
+            padded_buffer[j] = message[payload_index+j];
+        }
+        aes128k128d(key, ctr_preload, aes_out);
+        bitwise_xor(aes_out, padded_buffer, chain_buffer);
+        for (j=0; j<payload_remainder;j++) message[payload_index++] = chain_buffer[j];
+    }
+
+    /* Encrypt the MIC */
+    construct_ctr_preload(
+                        ctr_preload,
+                        a4_exists,
+                        qc_exists,
+                        message,
+                        pn_vector,
+                        0);
+
+    for (j = 0; j < 16; j++) padded_buffer[j] = 0x00;
+    for (j = 0; j < 8; j++)
+    {
+        padded_buffer[j] = message[j+hdrlen+8+plen-8];
+    }
+
+    aes128k128d(key, ctr_preload, aes_out);
+    bitwise_xor(aes_out, padded_buffer, chain_buffer);
+    for (j=0; j<8;j++) message[payload_index++] = chain_buffer[j];
+
+	//compare the mic
+	for(i=0;i<8;i++){
+		if(pframe[hdrlen+8+plen-8+i] != message[hdrlen+8+plen-8+i])
+		{
+			DBG_871X("aes_decipher:mic check error mic[%d]: pframe(%x) != message(%x) \n",
+						i,pframe[hdrlen+8+plen-8+i],message[hdrlen+8+plen-8+i]);
+			res = _FAIL;
+		}
+	}
+
+	return res;
+}
+
+uint32_t	rtw_aes_decrypt(struct rtl_priv *rtlpriv, struct recv_frame *precvframe)
+{	// exclude ICV
+
+
+	/*static*/
+//	unsigned char	message[MAX_MSG_SIZE];
+
+
+    	/* Intermediate Buffers */
+
+
+	int 		length;
+	uint32_t	prwskeylen;
+	uint8_t	*pframe,*prwskey;	//, *payload,*iv
+	struct	sta_info		*stainfo;
+	struct	rx_pkt_attrib	 *prxattrib = &precvframe->attrib;
+	struct 	security_priv	*psecuritypriv=&rtlpriv->securitypriv;
+//	struct	recv_priv		*precvpriv=&rtlpriv->recvpriv;
+	uint32_t	res=_SUCCESS;
+
+	pframe= precvframe->rx_data;
+	//4 start to encrypt each fragment
+	if((prxattrib->encrypt==AESCCMP_ENCRYPTION)){
+
+		stainfo=rtw_get_stainfo(&rtlpriv->stapriv ,&prxattrib->ta[0] );
+		if (stainfo!=NULL){
+			if(is_multicast_ether_addr(prxattrib->ra))
+			{
+				//in concurrent we should use sw descrypt in group key, so we remove this message
+				//DBG_871X("rx bc/mc packets, to perform sw rtw_aes_decrypt\n");
+				//prwskey = psecuritypriv->dot118021XGrpKey[psecuritypriv->dot118021XGrpKeyid].skey;
+				if(psecuritypriv->binstallGrpkey==false)
+				{
+					res=_FAIL;
+					DBG_8192C("%s:rx bc/mc packets,but didn't install group key!!!!!!!!!!\n",__FUNCTION__);
+					goto exit;
+				}
+				prwskey = psecuritypriv->dot118021XGrpKey[prxattrib->key_index].skey;
+				if(psecuritypriv->dot118021XGrpKeyid != prxattrib->key_index)
+				{
+					DBG_871X("not match packet_index=%d, install_index=%d \n"
+					, prxattrib->key_index, psecuritypriv->dot118021XGrpKeyid);
+					res=_FAIL;
+					goto exit;
+				}
+			}
+			else
+			{
+				prwskey=&stainfo->dot118021x_UncstKey.skey[0];
+			}
+
+			length= precvframe->len-prxattrib->hdrlen-prxattrib->iv_len;
+
+			res= aes_decipher(prwskey,prxattrib->hdrlen,pframe, length);
+
+
+		}
+		else{
+			res=_FAIL;
+		}
+
+	}
+
+exit:
+	return res;
+}
+/* compress 512-bits */
+static int sha256_compress(struct sha256_state *md, unsigned char *buf)
+{
+	uint32_t	 S[8], W[64], t0, t1;
+	uint32_t	 t;
+	int i;
+
+	/* copy state into S */
+	for (i = 0; i < 8; i++) {
+		S[i] = md->state[i];
+	}
+
+	/* copy the state into 512-bits into W[0..15] */
+	for (i = 0; i < 16; i++)
+		W[i] = WPA_GET_BE32(buf + (4 * i));
+
+	/* fill W[16..63] */
+	for (i = 16; i < 64; i++) {
+		W[i] = Gamma1(W[i - 2]) + W[i - 7] + Gamma0(W[i - 15]) +
+			W[i - 16];
+	}
+
+	/* Compress */
+#define RND(a,b,c,d,e,f,g,h,i)                          \
+	t0 = h + Sigma1(e) + Ch(e, f, g) + K[i] + W[i];	\
+	t1 = Sigma0(a) + Maj(a, b, c);			\
+	d += t0;					\
+	h  = t0 + t1;
+
+	for (i = 0; i < 64; ++i) {
+		RND(S[0], S[1], S[2], S[3], S[4], S[5], S[6], S[7], i);
+		t = S[7]; S[7] = S[6]; S[6] = S[5]; S[5] = S[4];
+		S[4] = S[3]; S[3] = S[2]; S[2] = S[1]; S[1] = S[0]; S[0] = t;
+	}
+
+	/* feedback */
+	for (i = 0; i < 8; i++) {
+		md->state[i] = md->state[i] + S[i];
+	}
+	return 0;
+}
+
+/* Initialize the hash state */
+static void sha256_init(struct sha256_state *md)
+{
+	md->curlen = 0;
+	md->length = 0;
+	md->state[0] = 0x6A09E667UL;
+	md->state[1] = 0xBB67AE85UL;
+	md->state[2] = 0x3C6EF372UL;
+	md->state[3] = 0xA54FF53AUL;
+	md->state[4] = 0x510E527FUL;
+	md->state[5] = 0x9B05688CUL;
+	md->state[6] = 0x1F83D9ABUL;
+	md->state[7] = 0x5BE0CD19UL;
+}
+
+/**
+   Process a block of memory though the hash
+   @param md     The hash state
+   @param in     The data to hash
+   @param inlen  The length of the data (octets)
+   @return CRYPT_OK if successful
+*/
+static int sha256_process(struct sha256_state *md, unsigned char *in,
+			  unsigned long inlen)
+{
+	unsigned long n;
+#define block_size 64
+
+	if (md->curlen > sizeof(md->buf))
+		return -1;
+
+	while (inlen > 0) {
+		if (md->curlen == 0 && inlen >= block_size) {
+			if (sha256_compress(md, (unsigned char *) in) < 0)
+				return -1;
+			md->length += block_size * 8;
+			in += block_size;
+			inlen -= block_size;
+		} else {
+			n = MIN(inlen, (block_size - md->curlen));
+			memcpy(md->buf + md->curlen, in, n);
+			md->curlen += n;
+			in += n;
+			inlen -= n;
+			if (md->curlen == block_size) {
+				if (sha256_compress(md, md->buf) < 0)
+					return -1;
+				md->length += 8 * block_size;
+				md->curlen = 0;
+			}
+		}
+	}
+
+	return 0;
+}
+
+
+/**
+   Terminate the hash to get the digest
+   @param md  The hash state
+   @param out [out] The destination of the hash (32 bytes)
+   @return CRYPT_OK if successful
+*/
+static int sha256_done(struct sha256_state *md, unsigned char *out)
+{
+	int i;
+
+	if (md->curlen >= sizeof(md->buf))
+		return -1;
+
+	/* increase the length of the message */
+	md->length += md->curlen * 8;
+
+	/* append the '1' bit */
+	md->buf[md->curlen++] = (unsigned char) 0x80;
+
+	/* if the length is currently above 56 bytes we append zeros
+	 * then compress.  Then we can fall back to padding zeros and length
+	 * encoding like normal.
+	 */
+	if (md->curlen > 56) {
+		while (md->curlen < 64) {
+			md->buf[md->curlen++] = (unsigned char) 0;
+		}
+		sha256_compress(md, md->buf);
+		md->curlen = 0;
+	}
+
+	/* pad upto 56 bytes of zeroes */
+	while (md->curlen < 56) {
+		md->buf[md->curlen++] = (unsigned char) 0;
+	}
+
+	/* store length */
+	WPA_PUT_BE64(md->buf + 56, md->length);
+	sha256_compress(md, md->buf);
+
+	/* copy output */
+	for (i = 0; i < 8; i++)
+		WPA_PUT_BE32(out + (4 * i), md->state[i]);
+
+	return 0;
+}
+
+/**
+ * sha256_vector - SHA256 hash for data vector
+ * @num_elem: Number of elements in the data vector
+ * @addr: Pointers to the data areas
+ * @len: Lengths of the data blocks
+ * @mac: Buffer for the hash
+ * Returns: 0 on success, -1 of failure
+ */
+static int sha256_vector(size_t num_elem, uint8_t *addr[], size_t *len,
+		  uint8_t *mac)
+{
+	struct sha256_state ctx;
+	size_t i;
+
+	sha256_init(&ctx);
+	for (i = 0; i < num_elem; i++)
+		if (sha256_process(&ctx, addr[i], len[i]))
+			return -1;
+	if (sha256_done(&ctx, mac))
+		return -1;
+	return 0;
+}
+
+static uint8_t os_strlen(const char *s)
+{
+	const char *p = s;
+	while (*p)
+		p++;
+	return p - s;
+}
+
+static int os_memcmp(void *s1, void *s2, uint8_t n)
+{
+	unsigned char *p1 = s1, *p2 = s2;
+
+	if (n == 0)
+		return 0;
+
+	while (*p1 == *p2) {
+		p1++;
+		p2++;
+		n--;
+		if (n == 0)
+			return 0;
+	}
+
+	return *p1 - *p2;
+}
+
+/**
+ * hmac_sha256_vector - HMAC-SHA256 over data vector (RFC 2104)
+ * @key: Key for HMAC operations
+ * @key_len: Length of the key in bytes
+ * @num_elem: Number of elements in the data vector
+ * @addr: Pointers to the data areas
+ * @len: Lengths of the data blocks
+ * @mac: Buffer for the hash (32 bytes)
+ */
+static void hmac_sha256_vector(uint8_t *key, size_t key_len, size_t num_elem,
+			uint8_t *addr[], size_t *len, uint8_t *mac)
+{
+	unsigned char k_pad[64]; /* padding - key XORd with ipad/opad */
+	unsigned char tk[32];
+	uint8_t *_addr[6];
+	size_t _len[6], i;
+
+	if (num_elem > 5) {
+		/*
+		 * Fixed limit on the number of fragments to avoid having to
+		 * allocate memory (which could fail).
+		 */
+		return;
+	}
+
+        /* if key is longer than 64 bytes reset it to key = SHA256(key) */
+        if (key_len > 64) {
+		sha256_vector(1, &key, &key_len, tk);
+		key = tk;
+		key_len = 32;
+        }
+
+	/* the HMAC_SHA256 transform looks like:
+	 *
+	 * SHA256(K XOR opad, SHA256(K XOR ipad, text))
+	 *
+	 * where K is an n byte key
+	 * ipad is the byte 0x36 repeated 64 times
+	 * opad is the byte 0x5c repeated 64 times
+	 * and text is the data being protected */
+
+	/* start out by storing key in ipad */
+	memset(k_pad, 0, sizeof(k_pad));
+	memcpy(k_pad, key, key_len);
+	/* XOR key with ipad values */
+	for (i = 0; i < 64; i++)
+		k_pad[i] ^= 0x36;
+
+	/* perform inner SHA256 */
+	_addr[0] = k_pad;
+	_len[0] = 64;
+	for (i = 0; i < num_elem; i++) {
+		_addr[i + 1] = addr[i];
+		_len[i + 1] = len[i];
+	}
+	sha256_vector(1 + num_elem, _addr, _len, mac);
+
+	memset(k_pad, 0, sizeof(k_pad));
+	memcpy(k_pad, key, key_len);
+	/* XOR key with opad values */
+	for (i = 0; i < 64; i++)
+		k_pad[i] ^= 0x5c;
+
+	/* perform outer SHA256 */
+	_addr[0] = k_pad;
+	_len[0] = 64;
+	_addr[1] = mac;
+	_len[1] = 32;
+	sha256_vector(2, _addr, _len, mac);
+}
+/**
+ * sha256_prf - SHA256-based Pseudo-Random Function (IEEE 802.11r, 8.5.1.5.2)
+ * @key: Key for PRF
+ * @key_len: Length of the key in bytes
+ * @label: A unique label for each purpose of the PRF
+ * @data: Extra data to bind into the key
+ * @data_len: Length of the data
+ * @buf: Buffer for the generated pseudo-random key
+ * @buf_len: Number of bytes of key to generate
+ *
+ * This function is used to derive new, cryptographically separate keys from a
+ * given key.
+ */
+static void sha256_prf(uint8_t *key, size_t key_len, char *label,
+		uint8_t *data, size_t data_len, uint8_t *buf, size_t buf_len)
+{
+	u16 counter = 1;
+	size_t pos, plen;
+	uint8_t hash[SHA256_MAC_LEN];
+	uint8_t *addr[4];
+	size_t len[4];
+	uint8_t counter_le[2], length_le[2];
+
+	addr[0] = counter_le;
+	len[0] = 2;
+	addr[1] = (uint8_t *) label;
+	len[1] = os_strlen(label);
+	addr[2] = data;
+	len[2] = data_len;
+	addr[3] = length_le;
+	len[3] = sizeof(length_le);
+
+	WPA_PUT_LE16(length_le, buf_len * 8);
+	pos = 0;
+	while (pos < buf_len) {
+		plen = buf_len - pos;
+		WPA_PUT_LE16(counter_le, counter);
+		if (plen >= SHA256_MAC_LEN) {
+			hmac_sha256_vector(key, key_len, 4, addr, len,
+					   &buf[pos]);
+			pos += SHA256_MAC_LEN;
+		} else {
+			hmac_sha256_vector(key, key_len, 4, addr, len, hash);
+			memcpy(&buf[pos], hash, plen);
+			break;
+		}
+		counter++;
+	}
+}
+
+/* AES tables*/
+const uint32_t	 Te0[256] = {
+    0xc66363a5U, 0xf87c7c84U, 0xee777799U, 0xf67b7b8dU,
+    0xfff2f20dU, 0xd66b6bbdU, 0xde6f6fb1U, 0x91c5c554U,
+    0x60303050U, 0x02010103U, 0xce6767a9U, 0x562b2b7dU,
+    0xe7fefe19U, 0xb5d7d762U, 0x4dababe6U, 0xec76769aU,
+    0x8fcaca45U, 0x1f82829dU, 0x89c9c940U, 0xfa7d7d87U,
+    0xeffafa15U, 0xb25959ebU, 0x8e4747c9U, 0xfbf0f00bU,
+    0x41adadecU, 0xb3d4d467U, 0x5fa2a2fdU, 0x45afafeaU,
+    0x239c9cbfU, 0x53a4a4f7U, 0xe4727296U, 0x9bc0c05bU,
+    0x75b7b7c2U, 0xe1fdfd1cU, 0x3d9393aeU, 0x4c26266aU,
+    0x6c36365aU, 0x7e3f3f41U, 0xf5f7f702U, 0x83cccc4fU,
+    0x6834345cU, 0x51a5a5f4U, 0xd1e5e534U, 0xf9f1f108U,
+    0xe2717193U, 0xabd8d873U, 0x62313153U, 0x2a15153fU,
+    0x0804040cU, 0x95c7c752U, 0x46232365U, 0x9dc3c35eU,
+    0x30181828U, 0x379696a1U, 0x0a05050fU, 0x2f9a9ab5U,
+    0x0e070709U, 0x24121236U, 0x1b80809bU, 0xdfe2e23dU,
+    0xcdebeb26U, 0x4e272769U, 0x7fb2b2cdU, 0xea75759fU,
+    0x1209091bU, 0x1d83839eU, 0x582c2c74U, 0x341a1a2eU,
+    0x361b1b2dU, 0xdc6e6eb2U, 0xb45a5aeeU, 0x5ba0a0fbU,
+    0xa45252f6U, 0x763b3b4dU, 0xb7d6d661U, 0x7db3b3ceU,
+    0x5229297bU, 0xdde3e33eU, 0x5e2f2f71U, 0x13848497U,
+    0xa65353f5U, 0xb9d1d168U, 0x00000000U, 0xc1eded2cU,
+    0x40202060U, 0xe3fcfc1fU, 0x79b1b1c8U, 0xb65b5bedU,
+    0xd46a6abeU, 0x8dcbcb46U, 0x67bebed9U, 0x7239394bU,
+    0x944a4adeU, 0x984c4cd4U, 0xb05858e8U, 0x85cfcf4aU,
+    0xbbd0d06bU, 0xc5efef2aU, 0x4faaaae5U, 0xedfbfb16U,
+    0x864343c5U, 0x9a4d4dd7U, 0x66333355U, 0x11858594U,
+    0x8a4545cfU, 0xe9f9f910U, 0x04020206U, 0xfe7f7f81U,
+    0xa05050f0U, 0x783c3c44U, 0x259f9fbaU, 0x4ba8a8e3U,
+    0xa25151f3U, 0x5da3a3feU, 0x804040c0U, 0x058f8f8aU,
+    0x3f9292adU, 0x219d9dbcU, 0x70383848U, 0xf1f5f504U,
+    0x63bcbcdfU, 0x77b6b6c1U, 0xafdada75U, 0x42212163U,
+    0x20101030U, 0xe5ffff1aU, 0xfdf3f30eU, 0xbfd2d26dU,
+    0x81cdcd4cU, 0x180c0c14U, 0x26131335U, 0xc3ecec2fU,
+    0xbe5f5fe1U, 0x359797a2U, 0x884444ccU, 0x2e171739U,
+    0x93c4c457U, 0x55a7a7f2U, 0xfc7e7e82U, 0x7a3d3d47U,
+    0xc86464acU, 0xba5d5de7U, 0x3219192bU, 0xe6737395U,
+    0xc06060a0U, 0x19818198U, 0x9e4f4fd1U, 0xa3dcdc7fU,
+    0x44222266U, 0x542a2a7eU, 0x3b9090abU, 0x0b888883U,
+    0x8c4646caU, 0xc7eeee29U, 0x6bb8b8d3U, 0x2814143cU,
+    0xa7dede79U, 0xbc5e5ee2U, 0x160b0b1dU, 0xaddbdb76U,
+    0xdbe0e03bU, 0x64323256U, 0x743a3a4eU, 0x140a0a1eU,
+    0x924949dbU, 0x0c06060aU, 0x4824246cU, 0xb85c5ce4U,
+    0x9fc2c25dU, 0xbdd3d36eU, 0x43acacefU, 0xc46262a6U,
+    0x399191a8U, 0x319595a4U, 0xd3e4e437U, 0xf279798bU,
+    0xd5e7e732U, 0x8bc8c843U, 0x6e373759U, 0xda6d6db7U,
+    0x018d8d8cU, 0xb1d5d564U, 0x9c4e4ed2U, 0x49a9a9e0U,
+    0xd86c6cb4U, 0xac5656faU, 0xf3f4f407U, 0xcfeaea25U,
+    0xca6565afU, 0xf47a7a8eU, 0x47aeaee9U, 0x10080818U,
+    0x6fbabad5U, 0xf0787888U, 0x4a25256fU, 0x5c2e2e72U,
+    0x381c1c24U, 0x57a6a6f1U, 0x73b4b4c7U, 0x97c6c651U,
+    0xcbe8e823U, 0xa1dddd7cU, 0xe874749cU, 0x3e1f1f21U,
+    0x964b4bddU, 0x61bdbddcU, 0x0d8b8b86U, 0x0f8a8a85U,
+    0xe0707090U, 0x7c3e3e42U, 0x71b5b5c4U, 0xcc6666aaU,
+    0x904848d8U, 0x06030305U, 0xf7f6f601U, 0x1c0e0e12U,
+    0xc26161a3U, 0x6a35355fU, 0xae5757f9U, 0x69b9b9d0U,
+    0x17868691U, 0x99c1c158U, 0x3a1d1d27U, 0x279e9eb9U,
+    0xd9e1e138U, 0xebf8f813U, 0x2b9898b3U, 0x22111133U,
+    0xd26969bbU, 0xa9d9d970U, 0x078e8e89U, 0x339494a7U,
+    0x2d9b9bb6U, 0x3c1e1e22U, 0x15878792U, 0xc9e9e920U,
+    0x87cece49U, 0xaa5555ffU, 0x50282878U, 0xa5dfdf7aU,
+    0x038c8c8fU, 0x59a1a1f8U, 0x09898980U, 0x1a0d0d17U,
+    0x65bfbfdaU, 0xd7e6e631U, 0x844242c6U, 0xd06868b8U,
+    0x824141c3U, 0x299999b0U, 0x5a2d2d77U, 0x1e0f0f11U,
+    0x7bb0b0cbU, 0xa85454fcU, 0x6dbbbbd6U, 0x2c16163aU,
+};
+const uint32_t	 Td0[256] = {
+    0x51f4a750U, 0x7e416553U, 0x1a17a4c3U, 0x3a275e96U,
+    0x3bab6bcbU, 0x1f9d45f1U, 0xacfa58abU, 0x4be30393U,
+    0x2030fa55U, 0xad766df6U, 0x88cc7691U, 0xf5024c25U,
+    0x4fe5d7fcU, 0xc52acbd7U, 0x26354480U, 0xb562a38fU,
+    0xdeb15a49U, 0x25ba1b67U, 0x45ea0e98U, 0x5dfec0e1U,
+    0xc32f7502U, 0x814cf012U, 0x8d4697a3U, 0x6bd3f9c6U,
+    0x038f5fe7U, 0x15929c95U, 0xbf6d7aebU, 0x955259daU,
+    0xd4be832dU, 0x587421d3U, 0x49e06929U, 0x8ec9c844U,
+    0x75c2896aU, 0xf48e7978U, 0x99583e6bU, 0x27b971ddU,
+    0xbee14fb6U, 0xf088ad17U, 0xc920ac66U, 0x7dce3ab4U,
+    0x63df4a18U, 0xe51a3182U, 0x97513360U, 0x62537f45U,
+    0xb16477e0U, 0xbb6bae84U, 0xfe81a01cU, 0xf9082b94U,
+    0x70486858U, 0x8f45fd19U, 0x94de6c87U, 0x527bf8b7U,
+    0xab73d323U, 0x724b02e2U, 0xe31f8f57U, 0x6655ab2aU,
+    0xb2eb2807U, 0x2fb5c203U, 0x86c57b9aU, 0xd33708a5U,
+    0x302887f2U, 0x23bfa5b2U, 0x02036abaU, 0xed16825cU,
+    0x8acf1c2bU, 0xa779b492U, 0xf307f2f0U, 0x4e69e2a1U,
+    0x65daf4cdU, 0x0605bed5U, 0xd134621fU, 0xc4a6fe8aU,
+    0x342e539dU, 0xa2f355a0U, 0x058ae132U, 0xa4f6eb75U,
+    0x0b83ec39U, 0x4060efaaU, 0x5e719f06U, 0xbd6e1051U,
+    0x3e218af9U, 0x96dd063dU, 0xdd3e05aeU, 0x4de6bd46U,
+    0x91548db5U, 0x71c45d05U, 0x0406d46fU, 0x605015ffU,
+    0x1998fb24U, 0xd6bde997U, 0x894043ccU, 0x67d99e77U,
+    0xb0e842bdU, 0x07898b88U, 0xe7195b38U, 0x79c8eedbU,
+    0xa17c0a47U, 0x7c420fe9U, 0xf8841ec9U, 0x00000000U,
+    0x09808683U, 0x322bed48U, 0x1e1170acU, 0x6c5a724eU,
+    0xfd0efffbU, 0x0f853856U, 0x3daed51eU, 0x362d3927U,
+    0x0a0fd964U, 0x685ca621U, 0x9b5b54d1U, 0x24362e3aU,
+    0x0c0a67b1U, 0x9357e70fU, 0xb4ee96d2U, 0x1b9b919eU,
+    0x80c0c54fU, 0x61dc20a2U, 0x5a774b69U, 0x1c121a16U,
+    0xe293ba0aU, 0xc0a02ae5U, 0x3c22e043U, 0x121b171dU,
+    0x0e090d0bU, 0xf28bc7adU, 0x2db6a8b9U, 0x141ea9c8U,
+    0x57f11985U, 0xaf75074cU, 0xee99ddbbU, 0xa37f60fdU,
+    0xf701269fU, 0x5c72f5bcU, 0x44663bc5U, 0x5bfb7e34U,
+    0x8b432976U, 0xcb23c6dcU, 0xb6edfc68U, 0xb8e4f163U,
+    0xd731dccaU, 0x42638510U, 0x13972240U, 0x84c61120U,
+    0x854a247dU, 0xd2bb3df8U, 0xaef93211U, 0xc729a16dU,
+    0x1d9e2f4bU, 0xdcb230f3U, 0x0d8652ecU, 0x77c1e3d0U,
+    0x2bb3166cU, 0xa970b999U, 0x119448faU, 0x47e96422U,
+    0xa8fc8cc4U, 0xa0f03f1aU, 0x567d2cd8U, 0x223390efU,
+    0x87494ec7U, 0xd938d1c1U, 0x8ccaa2feU, 0x98d40b36U,
+    0xa6f581cfU, 0xa57ade28U, 0xdab78e26U, 0x3fadbfa4U,
+    0x2c3a9de4U, 0x5078920dU, 0x6a5fcc9bU, 0x547e4662U,
+    0xf68d13c2U, 0x90d8b8e8U, 0x2e39f75eU, 0x82c3aff5U,
+    0x9f5d80beU, 0x69d0937cU, 0x6fd52da9U, 0xcf2512b3U,
+    0xc8ac993bU, 0x10187da7U, 0xe89c636eU, 0xdb3bbb7bU,
+    0xcd267809U, 0x6e5918f4U, 0xec9ab701U, 0x834f9aa8U,
+    0xe6956e65U, 0xaaffe67eU, 0x21bccf08U, 0xef15e8e6U,
+    0xbae79bd9U, 0x4a6f36ceU, 0xea9f09d4U, 0x29b07cd6U,
+    0x31a4b2afU, 0x2a3f2331U, 0xc6a59430U, 0x35a266c0U,
+    0x744ebc37U, 0xfc82caa6U, 0xe090d0b0U, 0x33a7d815U,
+    0xf104984aU, 0x41ecdaf7U, 0x7fcd500eU, 0x1791f62fU,
+    0x764dd68dU, 0x43efb04dU, 0xccaa4d54U, 0xe49604dfU,
+    0x9ed1b5e3U, 0x4c6a881bU, 0xc12c1fb8U, 0x4665517fU,
+    0x9d5eea04U, 0x018c355dU, 0xfa877473U, 0xfb0b412eU,
+    0xb3671d5aU, 0x92dbd252U, 0xe9105633U, 0x6dd64713U,
+    0x9ad7618cU, 0x37a10c7aU, 0x59f8148eU, 0xeb133c89U,
+    0xcea927eeU, 0xb761c935U, 0xe11ce5edU, 0x7a47b13cU,
+    0x9cd2df59U, 0x55f2733fU, 0x1814ce79U, 0x73c737bfU,
+    0x53f7cdeaU, 0x5ffdaa5bU, 0xdf3d6f14U, 0x7844db86U,
+    0xcaaff381U, 0xb968c43eU, 0x3824342cU, 0xc2a3405fU,
+    0x161dc372U, 0xbce2250cU, 0x283c498bU, 0xff0d9541U,
+    0x39a80171U, 0x080cb3deU, 0xd8b4e49cU, 0x6456c190U,
+    0x7bcb8461U, 0xd532b670U, 0x486c5c74U, 0xd0b85742U,
+};
+const uint8_t Td4s[256] = {
+    0x52U, 0x09U, 0x6aU, 0xd5U, 0x30U, 0x36U, 0xa5U, 0x38U,
+    0xbfU, 0x40U, 0xa3U, 0x9eU, 0x81U, 0xf3U, 0xd7U, 0xfbU,
+    0x7cU, 0xe3U, 0x39U, 0x82U, 0x9bU, 0x2fU, 0xffU, 0x87U,
+    0x34U, 0x8eU, 0x43U, 0x44U, 0xc4U, 0xdeU, 0xe9U, 0xcbU,
+    0x54U, 0x7bU, 0x94U, 0x32U, 0xa6U, 0xc2U, 0x23U, 0x3dU,
+    0xeeU, 0x4cU, 0x95U, 0x0bU, 0x42U, 0xfaU, 0xc3U, 0x4eU,
+    0x08U, 0x2eU, 0xa1U, 0x66U, 0x28U, 0xd9U, 0x24U, 0xb2U,
+    0x76U, 0x5bU, 0xa2U, 0x49U, 0x6dU, 0x8bU, 0xd1U, 0x25U,
+    0x72U, 0xf8U, 0xf6U, 0x64U, 0x86U, 0x68U, 0x98U, 0x16U,
+    0xd4U, 0xa4U, 0x5cU, 0xccU, 0x5dU, 0x65U, 0xb6U, 0x92U,
+    0x6cU, 0x70U, 0x48U, 0x50U, 0xfdU, 0xedU, 0xb9U, 0xdaU,
+    0x5eU, 0x15U, 0x46U, 0x57U, 0xa7U, 0x8dU, 0x9dU, 0x84U,
+    0x90U, 0xd8U, 0xabU, 0x00U, 0x8cU, 0xbcU, 0xd3U, 0x0aU,
+    0xf7U, 0xe4U, 0x58U, 0x05U, 0xb8U, 0xb3U, 0x45U, 0x06U,
+    0xd0U, 0x2cU, 0x1eU, 0x8fU, 0xcaU, 0x3fU, 0x0fU, 0x02U,
+    0xc1U, 0xafU, 0xbdU, 0x03U, 0x01U, 0x13U, 0x8aU, 0x6bU,
+    0x3aU, 0x91U, 0x11U, 0x41U, 0x4fU, 0x67U, 0xdcU, 0xeaU,
+    0x97U, 0xf2U, 0xcfU, 0xceU, 0xf0U, 0xb4U, 0xe6U, 0x73U,
+    0x96U, 0xacU, 0x74U, 0x22U, 0xe7U, 0xadU, 0x35U, 0x85U,
+    0xe2U, 0xf9U, 0x37U, 0xe8U, 0x1cU, 0x75U, 0xdfU, 0x6eU,
+    0x47U, 0xf1U, 0x1aU, 0x71U, 0x1dU, 0x29U, 0xc5U, 0x89U,
+    0x6fU, 0xb7U, 0x62U, 0x0eU, 0xaaU, 0x18U, 0xbeU, 0x1bU,
+    0xfcU, 0x56U, 0x3eU, 0x4bU, 0xc6U, 0xd2U, 0x79U, 0x20U,
+    0x9aU, 0xdbU, 0xc0U, 0xfeU, 0x78U, 0xcdU, 0x5aU, 0xf4U,
+    0x1fU, 0xddU, 0xa8U, 0x33U, 0x88U, 0x07U, 0xc7U, 0x31U,
+    0xb1U, 0x12U, 0x10U, 0x59U, 0x27U, 0x80U, 0xecU, 0x5fU,
+    0x60U, 0x51U, 0x7fU, 0xa9U, 0x19U, 0xb5U, 0x4aU, 0x0dU,
+    0x2dU, 0xe5U, 0x7aU, 0x9fU, 0x93U, 0xc9U, 0x9cU, 0xefU,
+    0xa0U, 0xe0U, 0x3bU, 0x4dU, 0xaeU, 0x2aU, 0xf5U, 0xb0U,
+    0xc8U, 0xebU, 0xbbU, 0x3cU, 0x83U, 0x53U, 0x99U, 0x61U,
+    0x17U, 0x2bU, 0x04U, 0x7eU, 0xbaU, 0x77U, 0xd6U, 0x26U,
+    0xe1U, 0x69U, 0x14U, 0x63U, 0x55U, 0x21U, 0x0cU, 0x7dU,
+};
+const uint8_t rcons[] = {
+	0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36
+	/* for 128-bit blocks, Rijndael never uses more than 10 rcon values */
+};
+
+/**
+ * Expand the cipher key into the encryption key schedule.
+ *
+ * @return	the number of rounds for the given cipher key size.
+ */
+static void rijndaelKeySetupEnc(uint32_t	 rk[/*44*/], const uint8_t cipherKey[])
+{
+	int i;
+	uint32_t	 temp;
+
+	rk[0] = GETU32(cipherKey     );
+	rk[1] = GETU32(cipherKey +  4);
+	rk[2] = GETU32(cipherKey +  8);
+	rk[3] = GETU32(cipherKey + 12);
+	for (i = 0; i < 10; i++) {
+		temp  = rk[3];
+		rk[4] = rk[0] ^
+			TE421(temp) ^ TE432(temp) ^ TE443(temp) ^ TE414(temp) ^
+			RCON(i);
+		rk[5] = rk[1] ^ rk[4];
+		rk[6] = rk[2] ^ rk[5];
+		rk[7] = rk[3] ^ rk[6];
+		rk += 4;
+	}
+}
+
+static void rijndaelEncrypt(uint32_t	 rk[/*44*/], uint8_t pt[16], uint8_t ct[16])
+{
+	uint32_t	 s0, s1, s2, s3, t0, t1, t2, t3;
+	int Nr = 10;
+#ifndef FULL_UNROLL
+	int r;
+#endif /* ?FULL_UNROLL */
+
+	/*
+	 * map byte array block to cipher state
+	 * and add initial round key:
+	 */
+	s0 = GETU32(pt     ) ^ rk[0];
+	s1 = GETU32(pt +  4) ^ rk[1];
+	s2 = GETU32(pt +  8) ^ rk[2];
+	s3 = GETU32(pt + 12) ^ rk[3];
+
+#define ROUND(i,d,s) \
+d##0 = TE0(s##0) ^ TE1(s##1) ^ TE2(s##2) ^ TE3(s##3) ^ rk[4 * i]; \
+d##1 = TE0(s##1) ^ TE1(s##2) ^ TE2(s##3) ^ TE3(s##0) ^ rk[4 * i + 1]; \
+d##2 = TE0(s##2) ^ TE1(s##3) ^ TE2(s##0) ^ TE3(s##1) ^ rk[4 * i + 2]; \
+d##3 = TE0(s##3) ^ TE1(s##0) ^ TE2(s##1) ^ TE3(s##2) ^ rk[4 * i + 3]
+
+#ifdef FULL_UNROLL
+
+	ROUND(1,t,s);
+	ROUND(2,s,t);
+	ROUND(3,t,s);
+	ROUND(4,s,t);
+	ROUND(5,t,s);
+	ROUND(6,s,t);
+	ROUND(7,t,s);
+	ROUND(8,s,t);
+	ROUND(9,t,s);
+
+	rk += Nr << 2;
+
+#else  /* !FULL_UNROLL */
+
+	/* Nr - 1 full rounds: */
+	r = Nr >> 1;
+	for (;;) {
+		ROUND(1,t,s);
+		rk += 8;
+		if (--r == 0)
+			break;
+		ROUND(0,s,t);
+	}
+
+#endif /* ?FULL_UNROLL */
+
+#undef ROUND
+
+	/*
+	 * apply last round and
+	 * map cipher state to byte array block:
+	 */
+	s0 = TE41(t0) ^ TE42(t1) ^ TE43(t2) ^ TE44(t3) ^ rk[0];
+	PUTU32(ct     , s0);
+	s1 = TE41(t1) ^ TE42(t2) ^ TE43(t3) ^ TE44(t0) ^ rk[1];
+	PUTU32(ct +  4, s1);
+	s2 = TE41(t2) ^ TE42(t3) ^ TE43(t0) ^ TE44(t1) ^ rk[2];
+	PUTU32(ct +  8, s2);
+	s3 = TE41(t3) ^ TE42(t0) ^ TE43(t1) ^ TE44(t2) ^ rk[3];
+	PUTU32(ct + 12, s3);
+}
+
+static void * aes_encrypt_init(uint8_t *key, size_t len)
+{
+	uint32_t	 *rk;
+	if (len != 16)
+		return NULL;
+	rk = (uint32_t *)rtw_malloc(AES_PRIV_SIZE);
+	if (rk == NULL)
+		return NULL;
+	rijndaelKeySetupEnc(rk, key);
+	return rk;
+}
+
+static void aes_128_encrypt(void *ctx, uint8_t *plain, uint8_t *crypt)
+{
+	rijndaelEncrypt(ctx, plain, crypt);
+}
+
+
+static void gf_mulx(uint8_t *pad)
+{
+	int i, carry;
+
+	carry = pad[0] & 0x80;
+	for (i = 0; i < AES_BLOCK_SIZE - 1; i++)
+		pad[i] = (pad[i] << 1) | (pad[i + 1] >> 7);
+	pad[AES_BLOCK_SIZE - 1] <<= 1;
+	if (carry)
+		pad[AES_BLOCK_SIZE - 1] ^= 0x87;
+}
+
+static void aes_encrypt_deinit(void *ctx)
+{
+	memset(ctx, 0, AES_PRIV_SIZE);
+	rtw_mfree(ctx);
+}
+
+
+/**
+ * omac1_aes_128_vector - One-Key CBC MAC (OMAC1) hash with AES-128
+ * @key: 128-bit key for the hash operation
+ * @num_elem: Number of elements in the data vector
+ * @addr: Pointers to the data areas
+ * @len: Lengths of the data blocks
+ * @mac: Buffer for MAC (128 bits, i.e., 16 bytes)
+ * Returns: 0 on success, -1 on failure
+ *
+ * This is a mode for using block cipher (AES in this case) for authentication.
+ * OMAC1 was standardized with the name CMAC by NIST in a Special Publication
+ * (SP) 800-38B.
+ */
+static int omac1_aes_128_vector(uint8_t *key, size_t num_elem,
+							 uint8_t *addr[], size_t *len, uint8_t *mac)
+{
+	void *ctx;
+	uint8_t cbc[AES_BLOCK_SIZE], pad[AES_BLOCK_SIZE];
+	uint8_t *pos, *end;
+	size_t i, e, left, total_len;
+
+	ctx = aes_encrypt_init(key, 16);
+	if (ctx == NULL)
+		return -1;
+	memset(cbc, 0, AES_BLOCK_SIZE);
+
+	total_len = 0;
+	for (e = 0; e < num_elem; e++)
+		total_len += len[e];
+	left = total_len;
+
+	e = 0;
+	pos = addr[0];
+	end = pos + len[0];
+
+	while (left >= AES_BLOCK_SIZE) {
+		for (i = 0; i < AES_BLOCK_SIZE; i++) {
+			cbc[i] ^= *pos++;
+			if (pos >= end) {
+				e++;
+				pos = addr[e];
+				end = pos + len[e];
+			}
+		}
+		if (left > AES_BLOCK_SIZE)
+			aes_128_encrypt(ctx, cbc, cbc);
+		left -= AES_BLOCK_SIZE;
+	}
+
+	memset(pad, 0, AES_BLOCK_SIZE);
+	aes_128_encrypt(ctx, pad, pad);
+	gf_mulx(pad);
+
+	if (left || total_len == 0) {
+		for (i = 0; i < left; i++) {
+			cbc[i] ^= *pos++;
+			if (pos >= end) {
+				e++;
+				pos = addr[e];
+				end = pos + len[e];
+			}
+		}
+		cbc[left] ^= 0x80;
+		gf_mulx(pad);
+	}
+
+	for (i = 0; i < AES_BLOCK_SIZE; i++)
+		pad[i] ^= cbc[i];
+	aes_128_encrypt(ctx, pad, mac);
+	aes_encrypt_deinit(ctx);
+	return 0;
+}
+
+
+/**
+ * omac1_aes_128 - One-Key CBC MAC (OMAC1) hash with AES-128 (aka AES-CMAC)
+ * @key: 128-bit key for the hash operation
+ * @data: Data buffer for which a MAC is determined
+ * @data_len: Length of data buffer in bytes
+ * @mac: Buffer for MAC (128 bits, i.e., 16 bytes)
+ * Returns: 0 on success, -1 on failure
+ *
+ * This is a mode for using block cipher (AES in this case) for authentication.
+ * OMAC1 was standardized with the name CMAC by NIST in a Special Publication
+ * (SP) 800-38B.
+ */
+static int omac1_aes_128(uint8_t *key, uint8_t *data, size_t data_len, uint8_t *mac)
+{
+	return omac1_aes_128_vector(key, 1, &data, &data_len, mac);
+}
+
+
+void rtw_use_tkipkey_handler(RTW_TIMER_HDL_ARGS)
+{
+        struct rtl_priv *rtlpriv = (struct rtl_priv *)FunctionContext;
+
+
+
+
+/*
+	if(rtlpriv->bDriverStopped ||rtlpriv->bSurpriseRemoved){
+			RT_TRACE(_module_rtl871x_security_c_,_drv_err_,("^^^rtw_use_tkipkey_handler (rtlpriv->bDriverStopped %d)(rtlpriv->bSurpriseRemoved %d)^^^\n",rtlpriv->bDriverStopped,rtlpriv->bSurpriseRemoved));
+
+		return;
+	}
+	*/
+
+	rtlpriv->securitypriv.busetkipkey=true;
+
+
+
+
+}
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/core/rtw_sta_mgt.c linux-4.9.8821au/drivers/staging/rtl8821au/core/rtw_sta_mgt.c
--- linux-4.9/drivers/staging/rtl8821au/core/rtw_sta_mgt.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/core/rtw_sta_mgt.c	2016-12-11 19:48:25.153645128 -0600
@@ -0,0 +1,718 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#define _RTW_STA_MGT_C_
+
+#include <linux/etherdevice.h>
+#include <drv_types.h>
+#include <rtl8812a_hal.h>
+
+#undef DBG_871X
+static inline void DBG_871X(const char *fmt, ...)
+{
+}
+
+static inline struct list_head *get_next(struct list_head	*list)
+{
+	return list->next;
+}
+
+static void _rtw_init_stainfo(struct sta_info *psta)
+{
+	memset((uint8_t *)psta, 0, sizeof (struct sta_info));
+
+	 spin_lock_init(&psta->lock);
+	INIT_LIST_HEAD(&psta->list);
+	INIT_LIST_HEAD(&psta->hash_list);
+	/*
+	 * INIT_LIST_HEAD(&psta->asoc_list);
+	 * INIT_LIST_HEAD(&psta->sleep_list);
+	 * INIT_LIST_HEAD(&psta->wakeup_list);
+	 */
+
+	_rtw_init_queue(&psta->sleep_q);
+	psta->sleepq_len = 0;
+
+	_rtw_init_sta_xmit_priv(&psta->sta_xmitpriv);
+	_rtw_init_sta_recv_priv(&psta->sta_recvpriv);
+
+#ifdef CONFIG_AP_MODE
+
+	INIT_LIST_HEAD(&psta->asoc_list);
+
+	INIT_LIST_HEAD(&psta->auth_list);
+
+	psta->expire_to = 0;
+
+	psta->flags = 0;
+
+	psta->capability = 0;
+
+	psta->bpairwise_key_installed = false;
+
+
+	psta->nonerp_set = 0;
+	psta->no_short_slot_time_set = 0;
+	psta->no_short_preamble_set = 0;
+	psta->no_ht_gf_set = 0;
+	psta->no_ht_set = 0;
+	psta->ht_20mhz_set = 0;
+
+#ifdef CONFIG_TX_MCAST2UNI
+	psta->under_exist_checking = 0;
+#endif
+
+	psta->keep_alive_trycnt = 0;
+
+#endif
+}
+
+uint32_t _rtw_init_sta_priv(struct sta_priv *pstapriv)
+{
+	struct sta_info *psta;
+	int32_t i;
+
+	pstapriv->pallocated_stainfo_buf = rtw_zvmalloc (sizeof(struct sta_info) * NUM_STA+ 4);
+
+	if(!pstapriv->pallocated_stainfo_buf)
+		return _FAIL;
+
+	pstapriv->pstainfo_buf = pstapriv->pallocated_stainfo_buf + 4 -
+		((SIZE_PTR)(pstapriv->pallocated_stainfo_buf ) & 3);
+
+	_rtw_init_queue(&pstapriv->free_sta_queue);
+
+	spin_lock_init(&pstapriv->sta_hash_lock);
+
+	/* _rtw_init_queue(&pstapriv->asoc_q); */
+	pstapriv->asoc_sta_count = 0;
+	_rtw_init_queue(&pstapriv->sleep_q);
+	_rtw_init_queue(&pstapriv->wakeup_q);
+
+	psta = (struct sta_info *)(pstapriv->pstainfo_buf);
+
+
+	for(i = 0; i < NUM_STA; i++) {
+		_rtw_init_stainfo(psta);
+
+		INIT_LIST_HEAD(&(pstapriv->sta_hash[i]));
+
+		list_add_tail(&psta->list, get_list_head(&pstapriv->free_sta_queue));
+
+		psta++;
+	}
+
+
+
+#ifdef CONFIG_AP_MODE
+
+	pstapriv->sta_dz_bitmap = 0;
+	pstapriv->tim_bitmap = 0;
+
+	INIT_LIST_HEAD(&pstapriv->asoc_list);
+	INIT_LIST_HEAD(&pstapriv->auth_list);
+	spin_lock_init(&pstapriv->asoc_list_lock);
+	spin_lock_init(&pstapriv->auth_list_lock);
+	pstapriv->asoc_list_cnt = 0;
+	pstapriv->auth_list_cnt = 0;
+
+	pstapriv->auth_to = 3; 		/* 3*2 = 6 sec */
+	pstapriv->assoc_to = 3;
+
+	/*
+	 * pstapriv->expire_to = 900;// 900*2 = 1800 sec = 30 min, expire after no any traffic.
+	 * pstapriv->expire_to = 30;// 30*2 = 60 sec = 1 min, expire after no any traffic.
+	 */
+	pstapriv->expire_to = 60;	/* 60*2 = 120 sec = 2 min, expire after no any traffic. */
+	pstapriv->max_num_sta = NUM_STA;
+
+#endif
+
+	return _SUCCESS;
+}
+
+inline int rtw_stainfo_offset(struct sta_priv *stapriv, struct sta_info *sta)
+{
+	int offset = (((uint8_t *)sta) - stapriv->pstainfo_buf)/sizeof(struct sta_info);
+
+	if (!stainfo_offset_valid(offset))
+		DBG_871X("%s invalid offset(%d), out of range!!!", __func__, offset);
+
+	return offset;
+}
+
+inline struct sta_info *rtw_get_stainfo_by_offset(struct sta_priv *stapriv, int offset)
+{
+	if (!stainfo_offset_valid(offset))
+		DBG_871X("%s invalid offset(%d), out of range!!!", __func__, offset);
+
+	return (struct sta_info *)(stapriv->pstainfo_buf + offset * sizeof(struct sta_info));
+}
+
+
+/*
+ *  this function is used to free the memory of lock || sema for all stainfos
+ */
+static void rtw_mfree_all_stainfo(struct sta_priv *pstapriv )
+{
+	struct list_head	*plist, *phead;
+	struct sta_info *psta = NULL;
+
+	spin_lock_bh(&pstapriv->sta_hash_lock);
+
+	phead = get_list_head(&pstapriv->free_sta_queue);
+	plist = get_next(phead);
+
+	while ((rtw_end_of_queue_search(phead, plist)) == false) {
+		psta = container_of(plist, struct sta_info ,list);
+		plist = get_next(plist);
+	}
+
+	spin_unlock_bh(&pstapriv->sta_hash_lock);
+
+}
+
+static void rtw_mfree_sta_priv_lock(struct	sta_priv *pstapriv)
+{
+#ifdef CONFIG_AP_MODE
+	struct wlan_acl_pool *pacl_list = &pstapriv->acl_list;
+#endif
+	 rtw_mfree_all_stainfo(pstapriv); /* be done before free sta_hash_lock */
+}
+
+uint32_t _rtw_free_sta_priv(struct sta_priv *pstapriv)
+{
+	struct list_head	*phead, *plist;
+	struct sta_info *psta = NULL;
+	struct recv_reorder_ctrl *preorder_ctrl;
+	int 	index;
+
+	if (pstapriv) {
+
+		/*	delete all reordering_ctrl_timer		*/
+		spin_lock_bh(&pstapriv->sta_hash_lock);
+		for (index = 0; index < NUM_STA; index++) {
+			phead = &(pstapriv->sta_hash[index]);
+			plist = get_next(phead);
+
+			while ((rtw_end_of_queue_search(phead, plist)) == false) {
+				int i;
+				psta = container_of(plist, struct sta_info ,hash_list);
+				plist = get_next(plist);
+
+				for(i=0; i < 16 ; i++) 	{
+					preorder_ctrl = &psta->recvreorder_ctrl[i];
+					del_timer_sync_ex(&preorder_ctrl->reordering_ctrl_timer);
+				}
+			}
+		}
+		spin_unlock_bh(&pstapriv->sta_hash_lock);
+		/*===============================*/
+
+		rtw_mfree_sta_priv_lock(pstapriv);
+
+		if(pstapriv->pallocated_stainfo_buf) {
+			rtw_vmfree(pstapriv->pallocated_stainfo_buf);
+		}
+	}
+
+	return _SUCCESS;
+}
+
+
+struct sta_info *rtw_alloc_stainfo(struct sta_priv *pstapriv, uint8_t *hwaddr)
+{
+	uint tmp_aid;
+	int32_t	index;
+	struct list_head	*phash_list;
+	struct sta_info	*psta;
+	struct __queue *pfree_sta_queue;
+	struct recv_reorder_ctrl *preorder_ctrl;
+	int i = 0;
+	u16  wRxSeqInitialValue = 0xffff;
+
+	pfree_sta_queue = &pstapriv->free_sta_queue;
+
+	/*
+	 * spin_lock_bh(&(pfree_sta_queue->lock), &irqL);
+	 */
+
+	spin_lock_bh(&(pstapriv->sta_hash_lock));
+
+	if (list_empty(&pfree_sta_queue->list)) {
+		/*
+		 * spin_unlock_bh(&(pfree_sta_queue->lock), &irqL);
+		 */
+		spin_unlock_bh(&(pstapriv->sta_hash_lock));
+		psta = NULL;
+	} else {
+		psta = container_of(get_next(&pfree_sta_queue->list), struct sta_info, list);
+
+		list_del_init(&(psta->list));
+
+		/*
+		 * spin_unlock_bh(&(pfree_sta_queue->lock), &irqL);
+		 */
+
+		tmp_aid = psta->aid;
+
+		_rtw_init_stainfo(psta);
+
+		psta->rtlpriv = pstapriv->rtlpriv;
+
+		memcpy(psta->hwaddr, hwaddr, ETH_ALEN);
+
+		index = wifi_mac_hash(hwaddr);
+
+		if (index >= NUM_STA) {
+			psta= NULL;
+			goto exit;
+		}
+		phash_list = &(pstapriv->sta_hash[index]);
+
+		/*
+		 * spin_lock_bh(&(pstapriv->sta_hash_lock), &irqL2);
+		 */
+
+		list_add_tail(&psta->hash_list, phash_list);
+
+		pstapriv->asoc_sta_count ++ ;
+
+		/*
+		 * spin_unlock_bh(&(pstapriv->sta_hash_lock), &irqL2);
+		 */
+
+/*
+ * Commented by Albert 2009/08/13
+ * For the SMC router, the sequence number of first packet of WPS handshake will be 0.
+ * In this case, this packet will be dropped by recv_decache function if we use the 0x00 as the default value for tid_rxseq variable.
+ * So, we initialize the tid_rxseq variable as the 0xffff.
+ */
+
+		for( i = 0; i < 16; i++) {
+                     memcpy( &psta->sta_recvpriv.rxcache.tid_rxseq[ i ], &wRxSeqInitialValue, 2 );
+		}
+
+		init_addba_retry_timer(pstapriv->rtlpriv, psta);
+
+
+		/* for A-MPDU Rx reordering buffer control */
+		for(i = 0; i < 16; i++) {
+			preorder_ctrl = &psta->recvreorder_ctrl[i];
+
+			preorder_ctrl->rtlpriv = pstapriv->rtlpriv;
+
+			preorder_ctrl->enable = false;
+
+			preorder_ctrl->indicate_seq = 0xffff;
+			preorder_ctrl->wend_b= 0xffff;
+			/* preorder_ctrl->wsize_b = (NR_RECVBUFF-2); */
+			preorder_ctrl->wsize_b = 64;//64;
+
+			_rtw_init_queue(&preorder_ctrl->pending_recvframe_queue);
+
+			rtw_init_recv_timer(preorder_ctrl);
+		}
+
+
+		/* init for DM */
+		psta->rssi_stat.UndecoratedSmoothedPWDB = (-1);
+		psta->rssi_stat.UndecoratedSmoothedCCK = (-1);
+
+		/* init for the sequence number of received management frame */
+		psta->RxMgmtFrameSeqNum = 0xffff;
+
+		//alloc mac id for non-bc/mc station,
+		rtw_alloc_macid(pstapriv->rtlpriv, psta);
+
+	}
+
+exit:
+
+	spin_unlock_bh(&(pstapriv->sta_hash_lock));
+
+	return psta;
+
+
+}
+
+
+/* using pstapriv->sta_hash_lock to protect */
+uint32_t rtw_free_stainfo(struct rtl_priv *rtlpriv , struct sta_info *psta)
+{
+	int i;
+	struct __queue *pfree_sta_queue;
+	struct recv_reorder_ctrl *preorder_ctrl;
+	struct	sta_xmit_priv	*pstaxmitpriv;
+	struct	xmit_priv	*pxmitpriv= &rtlpriv->xmitpriv;
+	struct	sta_priv *pstapriv = &rtlpriv->stapriv;
+	struct hw_xmit *phwxmit;
+
+	if (psta == NULL)
+		goto exit;
+
+
+	spin_lock_bh(&psta->lock);
+	psta->state &= ~_FW_LINKED;
+	spin_unlock_bh(&psta->lock);
+
+	pfree_sta_queue = &pstapriv->free_sta_queue;
+
+
+	pstaxmitpriv = &psta->sta_xmitpriv;
+
+	/* list_del_init(&psta->sleep_list); */
+
+	/* list_del_init(&psta->wakeup_list); */
+
+	spin_lock_bh(&pxmitpriv->lock);
+
+	rtw_free_xmitframe_queue(pxmitpriv, &psta->sleep_q);
+	psta->sleepq_len = 0;
+
+	/*
+	 * vo
+	 * enter_critical_bh(&(pxmitpriv->vo_pending.lock), &irqL0);
+	 */
+	rtw_free_xmitframe_queue( pxmitpriv, &pstaxmitpriv->vo_q.sta_pending);
+	list_del_init(&(pstaxmitpriv->vo_q.tx_pending));
+	phwxmit = pxmitpriv->hwxmits;
+
+	/*
+	 * spin_unlock_bh(&(pxmitpriv->vo_pending.lock), &irqL0);
+	 */
+
+	/*
+	 * vi
+	 * spin_lock_bh(&(pxmitpriv->vi_pending.lock), &irqL0);
+	*/
+	rtw_free_xmitframe_queue( pxmitpriv, &pstaxmitpriv->vi_q.sta_pending);
+	list_del_init(&(pstaxmitpriv->vi_q.tx_pending));
+	phwxmit = pxmitpriv->hwxmits+1;
+
+	/*
+	 * spin_unlock_bh(&(pxmitpriv->vi_pending.lock), &irqL0);
+	 */
+
+	/*
+	 * be
+	 * spin_lock_bh(&(pxmitpriv->be_pending.lock), &irqL0);
+	 */
+	rtw_free_xmitframe_queue( pxmitpriv, &pstaxmitpriv->be_q.sta_pending);
+	list_del_init(&(pstaxmitpriv->be_q.tx_pending));
+	phwxmit = pxmitpriv->hwxmits+2;
+
+	/*
+	 * spin_unlock_bh(&(pxmitpriv->be_pending.lock), &irqL0);
+	 */
+
+	/*
+	 * bk
+	 * spin_lock_bh(&(pxmitpriv->bk_pending.lock), &irqL0);
+	 */
+
+	rtw_free_xmitframe_queue( pxmitpriv, &pstaxmitpriv->bk_q.sta_pending);
+	list_del_init(&(pstaxmitpriv->bk_q.tx_pending));
+	phwxmit = pxmitpriv->hwxmits+3;
+
+	/*
+	 * spin_unlock_bh(&(pxmitpriv->bk_pending.lock), &irqL0);
+	 */
+
+	spin_unlock_bh(&pxmitpriv->lock);
+
+	list_del_init(&psta->hash_list);
+	pstapriv->asoc_sta_count --;
+
+	/*
+	 *  re-init sta_info; 20061114 // will be init in alloc_stainfo
+	 * _rtw_init_sta_xmit_priv(&psta->sta_xmitpriv);
+	 * _rtw_init_sta_recv_priv(&psta->sta_recvpriv);
+	 */
+
+
+	del_timer_sync_ex(&psta->addba_retry_timer);
+
+
+	/*
+	 * for A-MPDU Rx reordering buffer control, cancel reordering_ctrl_timer
+	 */
+
+	for(i = 0; i < 16 ; i++) {
+		struct list_head	*phead, *plist;
+		struct recv_frame *prframe;
+		struct __queue *ppending_recvframe_queue;
+		struct __queue *pfree_recv_queue = &rtlpriv->recvpriv.free_recv_queue;
+
+		preorder_ctrl = &psta->recvreorder_ctrl[i];
+
+		del_timer_sync_ex(&preorder_ctrl->reordering_ctrl_timer);
+
+
+		ppending_recvframe_queue = &preorder_ctrl->pending_recvframe_queue;
+
+		spin_lock_bh(&ppending_recvframe_queue->lock);
+
+		phead = 	get_list_head(ppending_recvframe_queue);
+		plist = get_next(phead);
+
+		while(!list_empty(phead)) {
+			prframe = container_of(plist, struct recv_frame, list);
+
+			plist = get_next(plist);
+
+			list_del_init(&(prframe->list));
+
+			rtw_free_recvframe(prframe, pfree_recv_queue);
+		}
+
+		spin_unlock_bh(&ppending_recvframe_queue->lock);
+
+	}
+
+	if (!(psta->state & WIFI_AP_STATE))
+		rtw_set_sta_info(rtlpriv, psta, false);
+
+	/*
+	 * release mac id for non-bc/mc station,
+	 */
+
+	rtw_release_macid(pstapriv->rtlpriv, psta);
+
+#ifdef CONFIG_AP_MODE
+
+	/*
+	 * spin_lock_bh(&pstapriv->asoc_list_lock, &irqL0);
+	 * list_del_init(&psta->asoc_list);
+	 * spin_unlock_bh(&pstapriv->asoc_list_lock, &irqL0);
+	 */
+
+	spin_lock_bh(&pstapriv->auth_list_lock);
+	if (!list_empty(&psta->auth_list)) {
+		list_del_init(&psta->auth_list);
+		pstapriv->auth_list_cnt--;
+	}
+	spin_unlock_bh(&pstapriv->auth_list_lock);
+
+	psta->expire_to = 0;
+
+	psta->sleepq_ac_len = 0;
+	psta->qos_info = 0;
+
+	psta->max_sp_len = 0;
+	psta->uapsd_bk = 0;
+	psta->uapsd_be = 0;
+	psta->uapsd_vi = 0;
+	psta->uapsd_vo = 0;
+
+	psta->has_legacy_ac = 0;
+
+
+	pstapriv->sta_dz_bitmap &=~BIT(psta->aid);
+	pstapriv->tim_bitmap &=~BIT(psta->aid);
+
+	/* rtw_indicate_sta_disassoc_event(rtlpriv, psta); */
+
+	if ((psta->aid >0)&&(pstapriv->sta_aid[psta->aid - 1] == psta)) {
+		pstapriv->sta_aid[psta->aid - 1] = NULL;
+		psta->aid = 0;
+	}
+
+
+#ifdef CONFIG_TX_MCAST2UNI
+	psta->under_exist_checking = 0;
+#endif
+
+#endif
+
+	/*spin_lock_bh(&(pfree_sta_queue->lock), &irqL0); */
+	list_add_tail(&psta->list, get_list_head(pfree_sta_queue));
+	/* spin_unlock_bh(&(pfree_sta_queue->lock), &irqL0); */
+
+exit:
+
+	return _SUCCESS;
+}
+
+/* free all stainfo which in sta_hash[all] */
+
+void rtw_free_all_stainfo(struct rtl_priv *rtlpriv)
+{
+	struct list_head	*plist, *phead;
+	int32_t	index;
+	struct sta_info *psta = NULL;
+	struct sta_priv *pstapriv = &rtlpriv->stapriv;
+	struct sta_info* pbcmc_stainfo =rtw_get_bcmc_stainfo( rtlpriv);
+
+	if(pstapriv->asoc_sta_count==1)
+		return;
+
+	spin_lock_bh(&pstapriv->sta_hash_lock);
+
+	for(index=0; index< NUM_STA; index++) {
+		phead = &(pstapriv->sta_hash[index]);
+		plist = get_next(phead);
+
+		while ((rtw_end_of_queue_search(phead, plist)) == false) {
+			psta = container_of(plist, struct sta_info ,hash_list);
+
+			plist = get_next(plist);
+
+			if(pbcmc_stainfo!=psta)
+				rtw_free_stainfo(rtlpriv , psta);
+
+		}
+	}
+
+	spin_unlock_bh(&pstapriv->sta_hash_lock);
+}
+
+/* any station allocated can be searched by hash list */
+struct sta_info *rtw_get_stainfo(struct sta_priv *pstapriv, uint8_t *hwaddr)
+{
+
+	struct list_head	*plist, *phead;
+
+	struct sta_info *psta = NULL;
+	uint32_t index;
+	uint8_t *addr;
+	uint8_t bc_addr[ETH_ALEN] = {0xff,0xff,0xff,0xff,0xff,0xff};
+
+	if(hwaddr==NULL)
+		return NULL;
+
+	if(is_multicast_ether_addr(hwaddr))
+		addr = bc_addr;
+	else
+		addr = hwaddr;
+
+	index = wifi_mac_hash(addr);
+
+	spin_lock_bh(&pstapriv->sta_hash_lock);
+
+	phead = &(pstapriv->sta_hash[index]);
+	plist = get_next(phead);
+
+	while ((rtw_end_of_queue_search(phead, plist)) == false) {
+
+		psta = container_of(plist, struct sta_info, hash_list);
+
+		if ((_rtw_memcmp(psta->hwaddr, addr, ETH_ALEN))== true) {
+			/* if found the matched address */
+			break;
+		}
+		psta=NULL;
+		plist = get_next(plist);
+	}
+
+	spin_unlock_bh(&pstapriv->sta_hash_lock);
+
+	return psta;
+}
+
+uint32_t rtw_init_bcmc_stainfo(struct rtl_priv* rtlpriv)
+{
+
+	struct sta_info *psta;
+	struct tx_servq *ptxservq;
+	uint32_t res=_SUCCESS;
+	NDIS_802_11_MAC_ADDRESS	bcast_addr= {0xff,0xff,0xff,0xff,0xff,0xff};
+
+	struct	sta_priv *pstapriv = &rtlpriv->stapriv;
+	/* struct __queue	*pstapending = &rtlpriv->xmitpriv.bm_pending; */
+
+	psta = rtw_alloc_stainfo(pstapriv, bcast_addr);
+
+	if(psta == NULL) {
+		res=_FAIL;
+		goto exit;
+	}
+
+	/* default broadcast & multicast use macid 1 */
+	psta->mac_id = 1;
+
+	ptxservq= &(psta->sta_xmitpriv.be_q);
+
+	/*
+	 * spin_lock_irqsave(&pstapending->lock, &irqL0);
+	 *
+	 * if (list_empty(&ptxservq->tx_pending))
+	 * 	list_add_tail(&ptxservq->tx_pending, get_list_head(pstapending));
+	 *
+	 * spin_unlock_irqrestore(&pstapending->lock, &irqL0);
+	 */
+
+exit:
+	return _SUCCESS;
+
+}
+
+
+struct sta_info* rtw_get_bcmc_stainfo(struct rtl_priv *rtlpriv)
+{
+	struct sta_info 	*psta;
+	struct sta_priv 	*pstapriv = &rtlpriv->stapriv;
+	uint8_t bc_addr[ETH_ALEN] = {0xff,0xff,0xff,0xff,0xff,0xff};
+
+	 psta = rtw_get_stainfo(pstapriv, bc_addr);
+
+	return psta;
+}
+
+uint8_t rtw_access_ctrl(struct rtl_priv *rtlpriv, uint8_t *mac_addr)
+{
+	uint8_t res = true;
+#ifdef  CONFIG_AP_MODE
+	struct list_head	*plist, *phead;
+	struct rtw_wlan_acl_node *paclnode;
+	uint8_t match = false;
+	struct sta_priv *pstapriv = &rtlpriv->stapriv;
+	struct wlan_acl_pool *pacl_list = &pstapriv->acl_list;
+	struct __queue	*pacl_node_q =&pacl_list->acl_node_q;
+
+	spin_lock_bh(&(pacl_node_q->lock));
+	phead = get_list_head(pacl_node_q);
+	plist = get_next(phead);
+	while ((rtw_end_of_queue_search(phead, plist)) == false) {
+		paclnode = container_of(plist, struct rtw_wlan_acl_node, list);
+		plist = get_next(plist);
+
+		if(_rtw_memcmp(paclnode->addr, mac_addr, ETH_ALEN)) {
+			if(paclnode->valid == true) {
+				match = true;
+				break;
+			}
+		}
+	}
+
+	spin_unlock_bh(&(pacl_node_q->lock));
+
+
+	if(pacl_list->mode == 1) {	/* accept unless in deny list */
+		res = (match == true) ?  false:true;
+	} else if(pacl_list->mode == 2) { /* deny unless in accept list */
+		res = (match == true) ?  true:false;
+	} else {
+		 res = true;
+	}
+
+#endif
+	return res;
+}
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/core/rtw_vht.c linux-4.9.8821au/drivers/staging/rtl8821au/core/rtw_vht.c
--- linux-4.9/drivers/staging/rtl8821au/core/rtw_vht.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/core/rtw_vht.c	2016-12-11 19:48:25.153645128 -0600
@@ -0,0 +1,624 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#define _RTW_VHT_C
+
+#include <drv_types.h>
+
+#undef DBG_871X
+static inline void DBG_871X(const char *fmt, ...)
+{
+}
+
+/*
+ * 20/40/80,	ShortGI,	MCS Rate
+ */
+
+const u16 VHT_MCS_DATA_RATE[3][2][20] = {
+	{ {		/* Long GI, 20MHz */
+			13, 26, 39, 52, 78, 104, 117, 130, 156, 156,
+			26, 52, 78, 104, 156, 208, 234, 260, 312, 312
+		}, {	/* Short GI, 20MHz */
+			14, 29, 43, 58, 87, 116, 130, 144, 173, 173,
+			29, 58, 87, 116, 173, 231, 260, 289, 347, 347
+		}
+	}, {
+		{	/* Long GI, 40MHz */
+			27, 54, 81, 108, 162, 216, 243, 270, 324, 360,
+			54, 108, 162, 216, 324, 432, 486, 540, 648, 720
+		}, {	/* Short GI, 40MHz */
+			30, 60, 90, 120, 180, 240, 270, 300, 360, 400,
+			60, 120, 180, 240, 360, 480, 540, 600, 720, 800
+		}
+	}, {
+		{	/* Long GI, 80MHz */
+			59, 117,  176, 234, 351, 468, 527, 585, 702, 780,
+			117, 234, 351, 468, 702, 936, 1053, 1170, 1404, 1560
+		},  {	/* Short GI, 80MHz */
+			65, 130, 195, 260, 390, 520, 585, 650, 780, 867,
+			130, 260, 390, 520, 780, 1040, 1170, 1300, 1560, 1734
+		}
+	} };
+
+uint8_t	rtw_get_vht_highest_rate(struct rtl_priv *rtlpriv, uint8_t *pvht_mcs_map)
+{
+	uint8_t	i, j;
+	uint8_t	bit_map;
+	uint8_t	vht_mcs_rate = 0;
+
+	for (i = 0; i < 2; i++) {
+		if (pvht_mcs_map[i] != 0xff) {
+			for (j = 0; j < 8; j += 2) {
+				bit_map = (pvht_mcs_map[i] >> j) & 3;
+
+				if (bit_map != 3)
+					/*
+					 * VHT rate indications begin from 0x90
+					 */
+					vht_mcs_rate = MGN_VHT1SS_MCS7 + 10*j/2 + i*40 + bit_map;
+			}
+		}
+	}
+
+	/*
+	 * DBG_871X("HighestVHTMCSRate is %x\n", vht_mcs_rate);
+	 */
+	return vht_mcs_rate;
+}
+
+u16 rtw_vht_data_rate(uint8_t bw, uint8_t short_GI, uint8_t vht_mcs_rate)
+{
+	if (vht_mcs_rate > MGN_VHT2SS_MCS9)
+		vht_mcs_rate = MGN_VHT2SS_MCS9;
+
+	return VHT_MCS_DATA_RATE[bw][short_GI][((vht_mcs_rate - MGN_VHT1SS_MCS0)&0x3f)];
+}
+
+
+uint32_t	rtw_vht_rate_to_bitmap(uint8_t *pVHTRate)
+{
+
+	uint8_t	i, j, tmpRate;
+	uint32_t RateBitmap = 0;
+
+	for (i = j = 0; i < 4; i += 2, j += 10) {
+		tmpRate = (pVHTRate[0] >> i) & 3;
+
+		switch (tmpRate) {
+		case 2:
+			RateBitmap = RateBitmap | (0x03ff << j);
+			break;
+		case 1:
+			RateBitmap = RateBitmap | (0x01ff << j);
+		break;
+
+		case 0:
+			RateBitmap = RateBitmap | (0x00ff << j);
+		break;
+
+		default:
+			break;
+		}
+	}
+
+	return RateBitmap;
+}
+
+void update_sta_vht_info_apmode(struct rtl_priv *rtlpriv, void *psta)
+{
+	struct mlme_priv *pmlmepriv = &(rtlpriv->mlmepriv);
+	struct vht_priv *pvhtpriv_ap = &pmlmepriv->vhtpriv;
+	struct vht_priv *pvhtpriv_sta = &((struct sta_info *)psta)->vhtpriv;
+	struct ht_priv *phtpriv_sta = &((struct sta_info *)psta)->htpriv;
+	uint8_t	cur_ldpc_cap = 0,
+		cur_stbc_cap = 0,
+		cur_beamform_cap = 0;
+	uint8_t	*pcap_mcs;
+
+	if (pvhtpriv_sta->vht_option == false)
+		return;
+
+	/* B4 Rx LDPC */
+	if (TEST_FLAG(pvhtpriv_ap->ldpc_cap, LDPC_VHT_ENABLE_TX))
+		SET_FLAG(cur_ldpc_cap, GET_VHT_CAPABILITY_ELE_RX_LDPC(pvhtpriv_sta->vht_cap) ? (LDPC_VHT_ENABLE_TX | LDPC_VHT_CAP_TX) : 0);
+
+	pvhtpriv_sta->ldpc_cap = cur_ldpc_cap;
+	DBG_871X("Current STA VHT LDPC = %02X\n", cur_ldpc_cap);
+
+	if (pvhtpriv_sta->vht_bwmode > pvhtpriv_ap->vht_bwmode)
+		pvhtpriv_sta->vht_bwmode = pvhtpriv_ap->vht_bwmode;
+
+	if (pvhtpriv_sta->vht_bwmode == CHANNEL_WIDTH_80) {
+		/* B5 Short GI for 80 MHz */
+		pvhtpriv_sta->sgi = (GET_VHT_CAPABILITY_ELE_SHORT_GI80M(pvhtpriv_sta->vht_cap) & pvhtpriv_ap->sgi) ? true : false;
+		DBG_871X("Current STA ShortGI80MHz = %d\n", pvhtpriv_sta->sgi);
+	} else if (pvhtpriv_sta->vht_bwmode >= CHANNEL_WIDTH_160) {
+		/* B5 Short GI for 80 MHz */
+		pvhtpriv_sta->sgi = (GET_VHT_CAPABILITY_ELE_SHORT_GI160M(pvhtpriv_sta->vht_cap) & pvhtpriv_ap->sgi) ? true : false;
+		DBG_871X("Current STA ShortGI160MHz = %d\n", pvhtpriv_sta->sgi);
+	} else {
+		pvhtpriv_sta->sgi = phtpriv_sta->sgi;
+	}
+
+	/* B8 B9 B10 Rx STBC */
+	if (TEST_FLAG(pvhtpriv_ap->stbc_cap, STBC_VHT_ENABLE_TX)
+	   && GET_VHT_CAPABILITY_ELE_RX_STBC(pvhtpriv_sta->vht_cap)) {
+		SET_FLAG(cur_stbc_cap, (STBC_VHT_ENABLE_TX | STBC_VHT_CAP_TX));
+	}
+	pvhtpriv_sta->stbc_cap = cur_stbc_cap;
+	DBG_871X("Current STA VHT STBC = %02X\n", cur_stbc_cap);
+
+	/*
+	 * B11
+	 * SU Beamformer Capable, the target supports
+	 * Beamformer and we are Beamformee
+	 */
+	if (TEST_FLAG(pvhtpriv_ap->beamform_cap, BEAMFORMING_VHT_BEAMFORMER_ENABLE)
+	   && GET_VHT_CAPABILITY_ELE_SU_BFEE(pvhtpriv_sta->vht_cap)) {
+		SET_FLAG(cur_beamform_cap, BEAMFORMING_VHT_BEAMFORMEE_ENABLE);
+	}
+
+	/* B12
+	 * SU Beamformee Capable, the target supports
+	 * Beamformee and we are Beamformer
+	 */
+	if (TEST_FLAG(pvhtpriv_ap->beamform_cap, BEAMFORMING_VHT_BEAMFORMEE_ENABLE)
+	   && GET_VHT_CAPABILITY_ELE_SU_BFER(pvhtpriv_sta->vht_cap)) {
+		SET_FLAG(cur_beamform_cap, BEAMFORMING_VHT_BEAMFORMER_ENABLE);
+	}
+	pvhtpriv_sta->beamform_cap = cur_beamform_cap;
+	DBG_871X("Current VHT Beamforming Setting = %02X\n", cur_beamform_cap);
+
+	/*
+	 * B23 B24 B25
+	 * Maximum A-MPDU Length Exponent
+	 */
+	pvhtpriv_sta->ampdu_len = GET_VHT_CAPABILITY_ELE_MAX_RXAMPDU_FACTOR(pvhtpriv_sta->vht_cap);
+
+	pcap_mcs = GET_VHT_CAPABILITY_ELE_RX_MCS(pvhtpriv_sta->vht_cap);
+	memcpy(pvhtpriv_sta->vht_mcs_map, pcap_mcs, 2);
+
+	pvhtpriv_sta->vht_highest_rate = rtw_get_vht_highest_rate(rtlpriv, pvhtpriv_sta->vht_mcs_map);
+
+}
+
+void update_hw_vht_param(struct rtl_priv *rtlpriv)
+{
+	struct mlme_priv *pmlmepriv = &rtlpriv->mlmepriv;
+	struct vht_priv *pvhtpriv = &pmlmepriv->vhtpriv;
+	struct mlme_ext_priv *pmlmeext = &rtlpriv->mlmeextpriv;
+	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
+	uint8_t	ht_AMPDU_len;
+
+	ht_AMPDU_len = pmlmeinfo->HT_caps.u.HT_cap_element.AMPDU_para & 0x03;
+
+	if (pvhtpriv->ampdu_len > ht_AMPDU_len)
+		rtlpriv->cfg->ops->set_hw_reg(rtlpriv, HW_VAR_AMPDU_FACTOR, (uint8_t *)(&pvhtpriv->ampdu_len));
+}
+
+void VHT_caps_handler(struct rtl_priv *rtlpriv, PNDIS_802_11_VARIABLE_IEs pIE)
+{
+	struct mlme_priv *pmlmepriv = &rtlpriv->mlmepriv;
+	struct vht_priv *pvhtpriv = &pmlmepriv->vhtpriv;
+	struct mlme_ext_priv *pmlmeext = &rtlpriv->mlmeextpriv;
+	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
+	uint8_t	cur_ldpc_cap = 0,
+		cur_stbc_cap = 0,
+		cur_beamform_cap = 0,
+		rf_type = RF_1T1R;
+	uint8_t	*pcap_mcs;
+	uint8_t	vht_mcs[2];
+
+	if (pIE == NULL)
+		return;
+
+	if (pvhtpriv->vht_option == false)
+		return;
+
+	pmlmeinfo->VHT_enable = 1;
+
+	/*
+	 * B4
+	 * Rx LDPC
+	 */
+	if (TEST_FLAG(pvhtpriv->ldpc_cap, LDPC_VHT_ENABLE_TX))
+		SET_FLAG(cur_ldpc_cap, GET_VHT_CAPABILITY_ELE_RX_LDPC(pIE->data) ? (LDPC_VHT_ENABLE_TX | LDPC_VHT_CAP_TX) : 0);
+
+	pvhtpriv->ldpc_cap = cur_ldpc_cap;
+	DBG_871X("Current VHT LDPC Setting = %02X\n", cur_ldpc_cap);
+
+	/*
+	 * B5
+	 * Short GI for 80 MHz
+	 */
+	pvhtpriv->sgi = (GET_VHT_CAPABILITY_ELE_SHORT_GI80M(pIE->data) & pvhtpriv->sgi) ? true : false;
+	DBG_871X("Current ShortGI80MHz = %d\n", pvhtpriv->sgi);
+
+	/*
+	 * B8 B9 B10
+	 * Rx STBC
+	 */
+	if (TEST_FLAG(pvhtpriv->stbc_cap, STBC_VHT_ENABLE_TX)
+	   && GET_VHT_CAPABILITY_ELE_RX_STBC(pIE->data)) {
+		SET_FLAG(cur_stbc_cap, (STBC_VHT_ENABLE_TX | STBC_VHT_CAP_TX));
+	}
+
+	pvhtpriv->stbc_cap = cur_stbc_cap;
+	DBG_871X("Current VHT STBC Setting = %02X\n", cur_stbc_cap);
+
+	/* B11
+	 * SU Beamformer Capable, the target
+	 * supports Beamformer and we are Beamformee
+	 */
+	if (TEST_FLAG(pvhtpriv->beamform_cap, BEAMFORMING_VHT_BEAMFORMER_ENABLE)
+	   && GET_VHT_CAPABILITY_ELE_SU_BFEE(pIE->data)) {
+		SET_FLAG(cur_beamform_cap, BEAMFORMING_VHT_BEAMFORMEE_ENABLE);
+	}
+
+	/* B12
+	 * SU Beamformee Capable, the target
+	 * supports Beamformee and we are Beamformer
+	 */
+	if (TEST_FLAG(pvhtpriv->beamform_cap, BEAMFORMING_VHT_BEAMFORMEE_ENABLE)
+	   && GET_VHT_CAPABILITY_ELE_SU_BFER(pIE->data)) {
+		SET_FLAG(cur_beamform_cap, BEAMFORMING_VHT_BEAMFORMER_ENABLE);
+	}
+
+	pvhtpriv->beamform_cap = cur_beamform_cap;
+	DBG_871X("Current VHT Beamforming Setting = %02X\n", cur_beamform_cap);
+
+	/*
+	 * B23 B24 B25
+	 * Maximum A-MPDU Length Exponent
+	 */
+
+	pvhtpriv->ampdu_len = GET_VHT_CAPABILITY_ELE_MAX_RXAMPDU_FACTOR(pIE->data);
+
+	pcap_mcs = GET_VHT_CAPABILITY_ELE_RX_MCS(pIE->data);
+	memcpy(vht_mcs, pcap_mcs, 2);
+
+	rf_type = rtlpriv->phy.rf_type;
+	
+	if ((rf_type == RF_1T1R) || (rf_type == RF_1T2R))
+		vht_mcs[0] |= 0xfc;
+	else if (rf_type == RF_2T2R)
+		vht_mcs[0] |= 0xf0;
+
+	memcpy(pvhtpriv->vht_mcs_map, vht_mcs, 2);
+
+	pvhtpriv->vht_highest_rate = rtw_get_vht_highest_rate(rtlpriv, pvhtpriv->vht_mcs_map);
+}
+
+void VHT_operation_handler(struct rtl_priv *rtlpriv, PNDIS_802_11_VARIABLE_IEs pIE)
+{
+	struct mlme_priv  *pmlmepriv = &rtlpriv->mlmepriv;
+	struct ht_priv *phtpriv = &pmlmepriv->htpriv;
+	struct vht_priv *pvhtpriv = &pmlmepriv->vhtpriv;
+	struct registry_priv *pregistrypriv = &rtlpriv->registrypriv;
+	struct mlme_ext_priv *pmlmeext = &rtlpriv->mlmeextpriv;
+
+	if (pIE == NULL)
+		return;
+
+	if (pvhtpriv->vht_option == false)
+		return;
+
+	if ((GET_VHT_OPERATION_ELE_CHL_WIDTH(pIE->data) >= 1)
+	   && ((0x21 & 0xf0) >= CHANNEL_WIDTH_80)) {
+		pvhtpriv->vht_bwmode = CHANNEL_WIDTH_80;
+	} else {
+		pvhtpriv->vht_bwmode = phtpriv->bwmode;
+	}
+}
+
+uint32_t rtw_build_vht_operation_ie(struct rtl_priv *rtlpriv, uint8_t *pbuf, uint8_t channel)
+{
+	struct mlme_priv *pmlmepriv = &rtlpriv->mlmepriv;
+	struct vht_priv *pvhtpriv = &pmlmepriv->vhtpriv;
+	struct mlme_ext_priv *pmlmeext = &rtlpriv->mlmeextpriv;
+	uint8_t	ChnlWidth, center_freq;
+	uint32_t	len = 0;
+	uint8_t	operation[5];
+
+	if (pvhtpriv->vht_bwmode >= CHANNEL_WIDTH_80)
+		ChnlWidth = 1;
+	else
+		ChnlWidth = 0;
+
+	center_freq = rtw_get_center_ch(channel, pvhtpriv->vht_bwmode, HAL_PRIME_CHNL_OFFSET_LOWER);
+
+	SET_VHT_OPERATION_ELE_CHL_WIDTH(operation, ChnlWidth);
+	/*
+	 * center frequency
+	 */
+	SET_VHT_OPERATION_ELE_CHL_CENTER_FREQ1(operation, center_freq); /* Todo: need to set correct center channel */
+	SET_VHT_OPERATION_ELE_CHL_CENTER_FREQ2(operation, 0);
+	SET_VHT_OPERATION_ELE_BASIC_MCS_SET(operation, 0xFFFF);
+
+	pbuf = rtw_set_ie(pbuf, EID_VHTOperation, 12, operation, &len);
+
+	return len;
+}
+
+uint32_t rtw_build_vht_op_mode_notify_ie(struct rtl_priv *rtlpriv, uint8_t *pbuf)
+{
+	struct mlme_priv *pmlmepriv = &rtlpriv->mlmepriv;
+	struct vht_priv *pvhtpriv = &pmlmepriv->vhtpriv;
+	uint32_t len = 0;
+	uint8_t	opmode = 0,
+		rf_type = 0;
+	uint8_t	chnl_width, rx_nss;
+
+	chnl_width = pvhtpriv->vht_bwmode;
+
+	rf_type = rtlpriv->phy.rf_type;
+
+	if (rf_type == RF_1T1R)
+		rx_nss = 1;
+	else
+		rx_nss = 2;
+
+	SET_VHT_OPERATING_MODE_FIELD_CHNL_WIDTH(&opmode, chnl_width);
+	SET_VHT_OPERATING_MODE_FIELD_RX_NSS(&opmode, (rx_nss-1));
+	SET_VHT_OPERATING_MODE_FIELD_RX_NSS_TYPE(&opmode, 0); /* Todo */
+
+	pbuf = rtw_set_ie(pbuf, EID_OpModeNotification, 1, &opmode, &len);
+
+	return len;
+}
+
+uint32_t rtw_build_vht_cap_ie(struct rtl_priv *rtlpriv, uint8_t *pbuf)
+{
+	uint8_t	bw, rf_type;
+	u16 HighestRate;
+	uint8_t	*pcap, *pcap_mcs;
+	uint32_t len = 0;
+	struct registry_priv *pregistrypriv = &rtlpriv->registrypriv;
+	struct mlme_priv *pmlmepriv = &rtlpriv->mlmepriv;
+	struct vht_priv	*pvhtpriv = &pmlmepriv->vhtpriv;
+
+	pcap = pvhtpriv->vht_cap;
+	memset(pcap, 0, 32);
+
+	/*
+	 * B2 B3
+	 * Supported Channel Width Set
+	 */
+	SET_VHT_CAPABILITY_ELE_CHL_WIDTH(pcap, 0);  /* indicate we don't support neither 160M nor 80+80M bandwidth. */
+
+	/*
+	 * B4
+	 * Rx LDPC
+	 */
+	if (TEST_FLAG(pvhtpriv->ldpc_cap, LDPC_VHT_ENABLE_RX)) {
+		SET_VHT_CAPABILITY_ELE_RX_LDPC(pcap, 1);
+	}
+
+	/*
+	 * B5
+	 * ShortGI for 80MHz
+	 */
+	SET_VHT_CAPABILITY_ELE_SHORT_GI80M(pcap, pvhtpriv->sgi ? 1 : 0); /* We can receive Short GI of 80M */
+
+	/*
+	 * B6
+	 * ShortGI for 160MHz
+	 */
+
+	if (pvhtpriv->vht_bwmode > CHANNEL_WIDTH_80) {
+		SET_VHT_CAPABILITY_ELE_SHORT_GI160M(pcap, pvhtpriv->sgi ? 1 : 0);
+	}
+
+	/*
+	 * B7
+	 * Tx STBC
+	 */
+	if (TEST_FLAG(pvhtpriv->stbc_cap, STBC_VHT_ENABLE_TX)) {
+		SET_VHT_CAPABILITY_ELE_TX_STBC(pcap, 1);
+	}
+
+	/*
+	 * B8 B9 B10
+	 * Rx STBC
+	 */
+
+	if (TEST_FLAG(pvhtpriv->stbc_cap, STBC_VHT_ENABLE_RX)) {
+		rf_type = rtlpriv->phy.rf_type;
+
+		if ((rf_type == RF_2T2R) || (rf_type == RF_1T2R)) {
+			SET_VHT_CAPABILITY_ELE_RX_STBC(pcap, 2);
+		} else if (rf_type == RF_1T1R) {
+			SET_VHT_CAPABILITY_ELE_RX_STBC(pcap, 1);
+		}
+	}
+
+	/*
+	 * B11
+	 * SU Beamformer Capable
+	 */
+	if (TEST_FLAG(pvhtpriv->beamform_cap, BEAMFORMING_VHT_BEAMFORMER_ENABLE)) {
+		SET_VHT_CAPABILITY_ELE_SU_BFER(pcap, 1);
+	}
+
+	/*
+	 * B12
+	 * SU Beamformee Capable
+	 */
+	if (TEST_FLAG(pvhtpriv->beamform_cap, BEAMFORMING_VHT_BEAMFORMEE_ENABLE)) {
+		SET_VHT_CAPABILITY_ELE_SU_BFEE(pcap, 1);
+	}
+
+	/*
+	 * B13 14 15
+	 * Compressed Steering Number of Beamformer Antennas Supported
+	 */
+
+	SET_VHT_CAPABILITY_ELE_BFER_ANT_SUPP(pcap, 1);	/* TODO */
+	/*
+	 * B16 17 18
+	 * Number of Sounding Dimensions
+	 */
+	SET_VHT_CAPABILITY_ELE_SOUNDING_DIMENSIONS(pcap, 1);
+
+	/*
+	 * B19 MU Beamformer Capable
+	 */
+	SET_VHT_CAPABILITY_ELE_MU_BFER(pcap, 0);  /* HW don't support mu bfee/bfer */
+	/*
+	 * B20
+	 * MU Beamformee Capable
+	 */
+	SET_VHT_CAPABILITY_ELE_MU_BFEE(pcap, 0);
+	/*
+	 * B21
+	 * VHT TXOP PS
+	 */
+	SET_VHT_CAPABILITY_ELE_TXOP_PS(pcap, 0);
+	/*
+	 * B22
+	 * +HTC-VHT Capable
+	 */
+	SET_VHT_CAPABILITY_ELE_HTC_VHT(pcap, 1);
+	/*
+	 * B23 24 25
+	 * Maximum A-MPDU Length Exponent
+	 */
+	if (7 != 0xFE) {
+		SET_VHT_CAPABILITY_ELE_MAX_RXAMPDU_FACTOR(pcap, 7);
+	} else {
+		SET_VHT_CAPABILITY_ELE_MAX_RXAMPDU_FACTOR(pcap, 7);
+	}
+	/*
+	 * B26 27
+	 * VHT Link Adaptation Capable
+	 */
+	SET_VHT_CAPABILITY_ELE_LINK_ADAPTION(pcap, 0);
+
+	pcap_mcs = GET_VHT_CAPABILITY_ELE_RX_MCS(pcap);
+	memcpy(pcap_mcs, pvhtpriv->vht_mcs_map, 2);
+
+	pcap_mcs = GET_VHT_CAPABILITY_ELE_TX_MCS(pcap);
+	memcpy(pcap_mcs, pvhtpriv->vht_mcs_map, 2);
+
+	bw = (0x21 >> 4) & 0xf;
+	HighestRate = VHT_MCS_DATA_RATE[bw][pvhtpriv->sgi][((pvhtpriv->vht_highest_rate - MGN_VHT1SS_MCS0)&0x3f)];
+	HighestRate = (HighestRate+1) >> 1;
+
+	SET_VHT_CAPABILITY_ELE_MCS_RX_HIGHEST_RATE(pcap, HighestRate); /* indicate we support highest rx rate is 600Mbps. */
+	SET_VHT_CAPABILITY_ELE_MCS_TX_HIGHEST_RATE(pcap, HighestRate); /* indicate we support highest tx rate is 600Mbps. */
+
+	pbuf = rtw_set_ie(pbuf, EID_VHTCapability, 12, pcap, &len);
+
+	return len;
+}
+
+uint32_t rtw_restructure_vht_ie(struct rtl_priv *rtlpriv, uint8_t *in_ie, uint8_t *out_ie, uint in_len, uint *pout_len)
+{
+	uint32_t ielen, out_len;
+	uint8_t	cap_len, notify_len, operation_bw, supported_chnl_width;
+	uint8_t	*p, *pframe;
+	struct registry_priv *pregistrypriv = &rtlpriv->registrypriv;
+	struct mlme_priv	*pmlmepriv = &rtlpriv->mlmepriv;
+	struct vht_priv	*pvhtpriv = &pmlmepriv->vhtpriv;
+
+	rtw_vht_use_default_setting(rtlpriv);
+
+	p = rtw_get_ie(in_ie+12, EID_VHTCapability, &ielen, in_len-12);
+	if (p && ielen > 0) {
+		supported_chnl_width = GET_VHT_CAPABILITY_ELE_CHL_WIDTH(p+2);
+
+		/*
+		 *  VHT Capabilities element
+		 */
+		cap_len = rtw_build_vht_cap_ie(rtlpriv, out_ie + *pout_len);
+		*pout_len += cap_len;
+
+		/*
+		 * Get HT BW
+		 */
+		p = rtw_get_ie(in_ie+12, _HT_EXTRA_INFO_IE_, &ielen, in_len-12);
+		if (p && ielen > 0) {
+			struct HT_info_element *pht_info = (struct HT_info_element *)(p+2);
+			if (pht_info->infos[0] & BIT(2))
+				operation_bw = CHANNEL_WIDTH_40;
+			else
+				operation_bw = CHANNEL_WIDTH_20;
+		}
+
+		/*
+		 *  VHT Operation element
+		 */
+		p = rtw_get_ie(in_ie+12, EID_VHTOperation, &ielen, in_len-12);
+		if (p && ielen > 0) {
+			out_len = *pout_len;
+			if (GET_VHT_OPERATION_ELE_CHL_WIDTH(p+2) >= 1) {
+				if (supported_chnl_width == 2)
+					operation_bw = CHANNEL_WIDTH_80_80;
+				else if (supported_chnl_width == 1)
+					operation_bw = CHANNEL_WIDTH_160;
+				else
+					operation_bw = CHANNEL_WIDTH_80;
+			}
+			pframe = rtw_set_ie(out_ie+out_len, EID_VHTOperation, ielen, p+2 , pout_len);
+		}
+
+		if (pvhtpriv->vht_bwmode > operation_bw)
+			pvhtpriv->vht_bwmode = operation_bw;
+
+		/*
+		 * Operating Mode Notification element
+		 */
+		notify_len = rtw_build_vht_op_mode_notify_ie(rtlpriv, out_ie + *pout_len);
+		*pout_len += notify_len;
+
+		pvhtpriv->vht_option = true;
+	}
+
+	return pvhtpriv->vht_option;
+
+}
+
+void VHTOnAssocRsp(struct rtl_priv *rtlpriv)
+{
+	struct mlme_priv *pmlmepriv = &rtlpriv->mlmepriv;
+	struct vht_priv *pvhtpriv = &pmlmepriv->vhtpriv;
+	struct mlme_ext_priv *pmlmeext = &rtlpriv->mlmeextpriv;
+	struct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);
+	uint8_t	ht_AMPDU_len;
+
+	DBG_871X("%s\n", __FUNCTION__);
+
+	if (!pmlmeinfo->HT_enable)
+		return;
+
+	if (!pmlmeinfo->VHT_enable)
+		return;
+
+	if (pvhtpriv->vht_bwmode >= CHANNEL_WIDTH_80)
+		pmlmeext->cur_bwmode = pvhtpriv->vht_bwmode;
+
+	ht_AMPDU_len = pmlmeinfo->HT_caps.u.HT_cap_element.AMPDU_para & 0x03;
+
+	if (pvhtpriv->ampdu_len > ht_AMPDU_len)
+		rtlpriv->cfg->ops->set_hw_reg(rtlpriv, HW_VAR_AMPDU_FACTOR, (uint8_t *)(&pvhtpriv->ampdu_len));
+
+	rtlpriv->cfg->ops->set_hw_reg(rtlpriv, HW_VAR_AMPDU_MAX_TIME, (uint8_t *)(&pvhtpriv->vht_highest_rate));
+}
+
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/core/rtw_wlan_util.c linux-4.9.8821au/drivers/staging/rtl8821au/core/rtw_wlan_util.c
--- linux-4.9/drivers/staging/rtl8821au/core/rtw_wlan_util.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/core/rtw_wlan_util.c	2016-12-11 19:48:25.156978448 -0600
@@ -0,0 +1,2136 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#define _RTW_WLAN_UTIL_C_
+
+#include <drv_types.h>
+#include <../usb.h>
+#include <../wifi.h>
+#include <../cam.h>
+
+#undef DBG_871X
+static inline void DBG_871X(const char *fmt, ...)
+{
+}
+
+unsigned char ARTHEROS_OUI1[] = {0x00, 0x03, 0x7f};
+unsigned char ARTHEROS_OUI2[] = {0x00, 0x13, 0x74};
+
+unsigned char BROADCOM_OUI1[] = {0x00, 0x10, 0x18};
+unsigned char BROADCOM_OUI2[] = {0x00, 0x0a, 0xf7};
+unsigned char BROADCOM_OUI3[] = {0x00, 0x05, 0xb5};
+
+unsigned char CISCO_OUI[] = {0x00, 0x40, 0x96};
+unsigned char MARVELL_OUI[] = {0x00, 0x50, 0x43};
+unsigned char RALINK_OUI[] = {0x00, 0x0c, 0x43};
+unsigned char REALTEK_OUI[] = {0x00, 0xe0, 0x4c};
+unsigned char AIRGOCAP_OUI[] = {0x00, 0x0a, 0xf5};
+
+unsigned char REALTEK_96B_IE[] = {0x00, 0xe0, 0x4c, 0x02, 0x01, 0x20};
+
+extern unsigned char	MCS_rate_2R[16];
+#ifdef CONFIG_DISABLE_MCS13TO15
+extern unsigned char	MCS_rate_2R_MCS13TO15_OFF[16];
+#endif //CONFIG_DISABLE_MCS13TO15
+extern unsigned char	MCS_rate_1R[16];
+extern unsigned char RTW_WPA_OUI[];
+extern unsigned char WPA_TKIP_CIPHER[4];
+extern unsigned char RSN_TKIP_CIPHER[4];
+
+#define R2T_PHY_DELAY	(0)
+
+//#define WAIT_FOR_BCN_TO_MIN	(3000)
+#define WAIT_FOR_BCN_TO_MIN	(6000)
+#define WAIT_FOR_BCN_TO_MAX	(20000)
+
+static uint8_t rtw_basic_rate_cck[4] = {
+	IEEE80211_CCK_RATE_1MB|IEEE80211_BASIC_RATE_MASK, IEEE80211_CCK_RATE_2MB|IEEE80211_BASIC_RATE_MASK,
+	IEEE80211_CCK_RATE_5MB|IEEE80211_BASIC_RATE_MASK, IEEE80211_CCK_RATE_11MB|IEEE80211_BASIC_RATE_MASK
+};
+
+static uint8_t rtw_basic_rate_ofdm[3] = {
+	IEEE80211_OFDM_RATE_6MB|IEEE80211_BASIC_RATE_MASK, IEEE80211_OFDM_RATE_12MB|IEEE80211_BASIC_RATE_MASK,
+	IEEE80211_OFDM_RATE_24MB|IEEE80211_BASIC_RATE_MASK
+};
+
+static uint8_t rtw_basic_rate_mix[7] = {
+	IEEE80211_CCK_RATE_1MB|IEEE80211_BASIC_RATE_MASK, IEEE80211_CCK_RATE_2MB|IEEE80211_BASIC_RATE_MASK,
+	IEEE80211_CCK_RATE_5MB|IEEE80211_BASIC_RATE_MASK, IEEE80211_CCK_RATE_11MB|IEEE80211_BASIC_RATE_MASK,
+	IEEE80211_OFDM_RATE_6MB|IEEE80211_BASIC_RATE_MASK, IEEE80211_OFDM_RATE_12MB|IEEE80211_BASIC_RATE_MASK,
+	IEEE80211_OFDM_RATE_24MB|IEEE80211_BASIC_RATE_MASK
+};
+
+
+int cckrates_included(unsigned char *rate, int ratelen)
+{
+	int	i;
+
+	for(i = 0; i < ratelen; i++)
+	{
+		if  (  (((rate[i]) & 0x7f) == 2)	|| (((rate[i]) & 0x7f) == 4) ||
+			   (((rate[i]) & 0x7f) == 11)  || (((rate[i]) & 0x7f) == 22) )
+		return true;
+	}
+
+	return false;
+
+}
+
+int cckratesonly_included(unsigned char *rate, int ratelen)
+{
+	int	i;
+
+	for(i = 0; i < ratelen; i++)
+	{
+		if  ( (((rate[i]) & 0x7f) != 2) && (((rate[i]) & 0x7f) != 4) &&
+			   (((rate[i]) & 0x7f) != 11)  && (((rate[i]) & 0x7f) != 22) )
+		return false;
+	}
+
+	return true;
+}
+
+uint8_t networktype_to_raid(struct rtl_priv *rtlpriv,unsigned char network_type)
+{
+	unsigned char raid;
+	switch(network_type)
+	{
+		case WIRELESS_11B:
+			raid = RATR_INX_WIRELESS_B;
+			break;
+		case WIRELESS_11A:
+		case WIRELESS_11G:
+			raid = RATR_INX_WIRELESS_G;
+			break;
+		case WIRELESS_11BG:
+			raid = RATR_INX_WIRELESS_GB;
+			break;
+		case WIRELESS_11_24N:
+		case WIRELESS_11_5N:
+			raid = RATR_INX_WIRELESS_N;
+			break;
+		case WIRELESS_11A_5N:
+		case WIRELESS_11G_24N:
+			raid = RATR_INX_WIRELESS_NG;
+			break;
+		case WIRELESS_11BG_24N:
+			raid = RATR_INX_WIRELESS_NGB;
+			break;
+		default:
+			raid = RATR_INX_WIRELESS_GB;
+			break;
+
+	}
+	return raid;
+
+}
+
+uint8_t networktype_to_raid_ex(struct rtl_priv *rtlpriv,unsigned char network_type)
+{
+	struct mlme_ext_priv	*pmlmeext = &rtlpriv->mlmeextpriv;
+	uint8_t raid, rf_type;
+
+	rf_type = rtlpriv->phy.rf_type;
+
+	switch(network_type)
+	{
+		case WIRELESS_11B:
+			raid = RATEID_IDX_B;
+			break;
+		case WIRELESS_11A:
+		case WIRELESS_11G:
+			raid = RATEID_IDX_G;
+			break;
+		case WIRELESS_11BG:
+			raid = RATEID_IDX_BG;
+			break;
+		case WIRELESS_11_24N:
+		case WIRELESS_11_5N:
+		case WIRELESS_11A_5N:
+		case WIRELESS_11G_24N:
+			if (rf_type == 2)
+				raid = RATEID_IDX_GN_N2SS;
+			else
+				raid = RATEID_IDX_GN_N1SS;
+			break;
+		case WIRELESS_11B_24N:
+		case WIRELESS_11BG_24N:
+			if (pmlmeext->cur_bwmode == CHANNEL_WIDTH_20) {
+				if (rf_type == RF_2T2R)
+					raid = RATEID_IDX_BGN_20M_2SS_BN;
+				else
+					raid = RATEID_IDX_BGN_20M_1SS_BN;
+			} else {
+				if (rf_type == RF_2T2R)
+					raid = RATEID_IDX_BGN_40M_2SS;
+				else
+					raid = RATEID_IDX_BGN_40M_1SS;
+			}
+			break;
+		case WIRELESS_11_5AC:
+		case WIRELESS_11_24AC:
+			if ((rf_type == RF_1T1R) || (rtlpriv->mlmepriv.vhtpriv.vht_highest_rate <= MGN_VHT1SS_MCS9))
+				raid = RATEID_IDX_VHT_1SS;
+			else
+				raid = RATEID_IDX_VHT_2SS;
+			break;
+		default:
+			raid = RATEID_IDX_BGN_40M_2SS;
+			break;
+
+	}
+	return raid;
+
+}
+
+uint8_t judge_network_type(struct rtl_priv *rtlpriv, unsigned char *rate, int ratelen)
+{
+	uint8_t network_type = 0;
+	struct mlme_ext_priv	*pmlmeext = &rtlpriv->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+
+	if(pmlmeext->cur_channel > 14)
+	{
+		if (pmlmeinfo->VHT_enable)
+			network_type = WIRELESS_11AC;
+		else if (pmlmeinfo->HT_enable)
+			network_type = WIRELESS_11_5N;
+
+		network_type |= WIRELESS_11A;
+	}
+	else
+	{
+		if (pmlmeinfo->HT_enable)
+		{
+			network_type = WIRELESS_11_24N;
+		}
+
+		if ((cckratesonly_included(rate, ratelen)) == true)
+		{
+			network_type |= WIRELESS_11B;
+		}
+		else if((cckrates_included(rate, ratelen)) == true)
+		{
+			network_type |= WIRELESS_11BG;
+		}
+		else
+		{
+			network_type |= WIRELESS_11G;
+		}
+	}
+
+	return 	network_type;
+}
+
+unsigned char ratetbl_val_2wifirate(unsigned char rate);
+unsigned char ratetbl_val_2wifirate(unsigned char rate)
+{
+	unsigned char val = 0;
+
+	switch (rate & 0x7f)
+	{
+		case 0:
+			val = IEEE80211_CCK_RATE_1MB;
+			break;
+
+		case 1:
+			val = IEEE80211_CCK_RATE_2MB;
+			break;
+
+		case 2:
+			val = IEEE80211_CCK_RATE_5MB;
+			break;
+
+		case 3:
+			val = IEEE80211_CCK_RATE_11MB;
+			break;
+
+		case 4:
+			val = IEEE80211_OFDM_RATE_6MB;
+			break;
+
+		case 5:
+			val = IEEE80211_OFDM_RATE_9MB;
+			break;
+
+		case 6:
+			val = IEEE80211_OFDM_RATE_12MB;
+			break;
+
+		case 7:
+			val = IEEE80211_OFDM_RATE_18MB;
+			break;
+
+		case 8:
+			val = IEEE80211_OFDM_RATE_24MB;
+			break;
+
+		case 9:
+			val = IEEE80211_OFDM_RATE_36MB;
+			break;
+
+		case 10:
+			val = IEEE80211_OFDM_RATE_48MB;
+			break;
+
+		case 11:
+			val = IEEE80211_OFDM_RATE_54MB;
+			break;
+
+	}
+
+	return val;
+
+}
+
+int is_basicrate(struct rtl_priv *rtlpriv, unsigned char rate);
+int is_basicrate(struct rtl_priv *rtlpriv, unsigned char rate)
+{
+	int i;
+	unsigned char val;
+	struct mlme_ext_priv *pmlmeext = &rtlpriv->mlmeextpriv;
+
+	for(i = 0; i < NumRates; i++)
+	{
+		val = pmlmeext->basicrate[i];
+
+		if ((val != 0xff) && (val != 0xfe))
+		{
+			if (rate == ratetbl_val_2wifirate(val))
+			{
+				return true;
+			}
+		}
+	}
+
+	return false;
+}
+
+unsigned int ratetbl2rateset(struct rtl_priv *rtlpriv, unsigned char *rateset);
+unsigned int ratetbl2rateset(struct rtl_priv *rtlpriv, unsigned char *rateset)
+{
+	int i;
+	unsigned char rate;
+	unsigned int	len = 0;
+	struct mlme_ext_priv *pmlmeext = &rtlpriv->mlmeextpriv;
+
+	for (i = 0; i < NumRates; i++)
+	{
+		rate = pmlmeext->datarate[i];
+
+		switch (rate)
+		{
+			case 0xff:
+				return len;
+
+			case 0xfe:
+				continue;
+
+			default:
+				rate = ratetbl_val_2wifirate(rate);
+
+				if (is_basicrate(rtlpriv, rate) == true)
+				{
+					rate |= IEEE80211_BASIC_RATE_MASK;
+				}
+
+				rateset[len] = rate;
+				len++;
+				break;
+		}
+	}
+	return len;
+}
+
+void get_rate_set(struct rtl_priv *rtlpriv, unsigned char *pbssrate, int *bssrate_len)
+{
+	unsigned char supportedrates[NumRates];
+
+	memset(supportedrates, 0, NumRates);
+	*bssrate_len = ratetbl2rateset(rtlpriv, supportedrates);
+	memcpy(pbssrate, supportedrates, *bssrate_len);
+}
+
+void UpdateBrateTbl(struct rtl_priv *rtlpriv, uint8_t *mBratesOS)
+{
+	uint8_t	i;
+	uint8_t	rate;
+
+	// 1M, 2M, 5.5M, 11M, 6M, 12M, 24M are mandatory.
+	for(i=0;i<NDIS_802_11_LENGTH_RATES_EX;i++)
+	{
+		rate = mBratesOS[i] & 0x7f;
+		switch(rate)
+		{
+			case IEEE80211_CCK_RATE_1MB:
+			case IEEE80211_CCK_RATE_2MB:
+			case IEEE80211_CCK_RATE_5MB:
+			case IEEE80211_CCK_RATE_11MB:
+			case IEEE80211_OFDM_RATE_6MB:
+			case IEEE80211_OFDM_RATE_12MB:
+			case IEEE80211_OFDM_RATE_24MB:
+				mBratesOS[i] |= IEEE80211_BASIC_RATE_MASK;
+				break;
+		}
+	}
+
+}
+
+void UpdateBrateTblForSoftAP(uint8_t *bssrateset, uint32_t	 bssratelen)
+{
+	uint8_t	i;
+	uint8_t	rate;
+
+	for(i=0;i<bssratelen;i++)
+	{
+		rate = bssrateset[i] & 0x7f;
+		switch(rate)
+		{
+			case IEEE80211_CCK_RATE_1MB:
+			case IEEE80211_CCK_RATE_2MB:
+			case IEEE80211_CCK_RATE_5MB:
+			case IEEE80211_CCK_RATE_11MB:
+				bssrateset[i] |= IEEE80211_BASIC_RATE_MASK;
+				break;
+		}
+	}
+
+}
+
+static void Set_NETYPE1_MSR(struct rtl_priv *rtlpriv, uint8_t type)
+{
+	rtlpriv->cfg->ops->set_hw_reg(rtlpriv, HW_VAR_MEDIA_STATUS1, (uint8_t *)(&type));
+}
+
+uint8_t	rtw_get_center_ch(uint8_t channel, uint8_t chnl_bw, uint8_t chnl_offset)
+{
+	uint8_t	center_ch = channel;
+
+	if (chnl_bw == CHANNEL_WIDTH_80) {
+		if((channel == 36) || (channel == 40) || (channel == 44) || (channel == 48) )
+			center_ch = 42;
+		if((channel == 52) || (channel == 56) || (channel == 60) || (channel == 64) )
+			center_ch = 58;
+		if((channel == 100) || (channel == 104) || (channel == 108) || (channel == 112) )
+			center_ch = 106;
+		if((channel == 116) || (channel == 120) || (channel == 124) || (channel == 128) )
+			center_ch = 122;
+		if((channel == 132) || (channel == 136) || (channel == 140) || (channel == 144) )
+			center_ch = 138;
+		if((channel == 149) || (channel == 153) || (channel == 157) || (channel == 161) )
+			center_ch = 155;
+		else if(channel <= 14)
+			center_ch = 7;
+	} else if (chnl_bw == CHANNEL_WIDTH_40) {
+		if (chnl_offset == HAL_PRIME_CHNL_OFFSET_LOWER)
+			center_ch = channel + 2;
+		else
+			center_ch = channel - 2;
+	}
+
+	return center_ch;
+}
+
+void SelectChannel(struct rtl_priv *rtlpriv, unsigned char channel)
+{
+	struct mlme_ext_priv *pmlmeext = &rtlpriv->mlmeextpriv;
+	int _unused;
+
+	_unused = mutex_lock_interruptible(&(rtl_usbdev(rtlpriv)->setch_mutex));
+
+	//saved channel info
+	rtw_set_oper_ch(rtlpriv, channel);
+
+	rtlpriv->cfg->ops->set_channel_handler(rtlpriv, channel);
+
+	mutex_unlock(&(rtl_usbdev(rtlpriv)->setch_mutex));
+}
+
+void SetBWMode(struct rtl_priv *rtlpriv, unsigned short bwmode, unsigned char channel_offset)
+{
+	struct mlme_ext_priv *pmlmeext = &rtlpriv->mlmeextpriv;
+	int _unused;
+
+	_unused = mutex_lock_interruptible(&(rtl_usbdev(rtlpriv)->setbw_mutex));
+
+	rtlpriv->cfg->ops->set_bwmode_handler(rtlpriv, 
+					      (enum CHANNEL_WIDTH)bwmode, channel_offset);
+
+	mutex_unlock(&(rtl_usbdev(rtlpriv)->setbw_mutex));
+}
+
+void set_channel_bwmode(struct rtl_priv *rtlpriv, unsigned char channel, unsigned char channel_offset, unsigned short bwmode)
+{
+	uint8_t center_ch, chnl_offset80 = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
+	struct mlme_ext_priv *pmlmeext = &rtlpriv->mlmeextpriv;
+	int _unused;
+
+	if (rtlpriv->bNotifyChannelChange) {
+		DBG_871X( "[%s] ch = %d, offset = %d, bwmode = %d\n", __FUNCTION__, channel, channel_offset, bwmode );
+	}
+
+	center_ch = rtw_get_center_ch(channel, bwmode, channel_offset);
+
+	if (bwmode == CHANNEL_WIDTH_80) 	{
+		if (center_ch > channel)
+			chnl_offset80 = HAL_PRIME_CHNL_OFFSET_LOWER;
+		else if (center_ch < channel)
+			chnl_offset80 = HAL_PRIME_CHNL_OFFSET_UPPER;
+		else
+			chnl_offset80 = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
+	}
+
+	//set Channel
+
+	_unused = mutex_lock_interruptible(&(rtl_usbdev(rtlpriv)->setch_mutex));
+
+	//saved channel/bw info
+	rtw_set_oper_ch(rtlpriv, channel);
+
+	rtlpriv->cfg->ops->set_chnl_bw_handler(rtlpriv, center_ch, bwmode,
+					       channel_offset, chnl_offset80); // set center channel
+
+	mutex_unlock(&(rtl_usbdev(rtlpriv)->setch_mutex));
+}
+
+int get_bsstype(unsigned short capability)
+{
+	if (capability & BIT(0))
+	{
+		return WIFI_FW_AP_STATE;
+	}
+	else if (capability & BIT(1))
+	{
+		return WIFI_FW_ADHOC_STATE;
+	}
+	else
+	{
+		return 0;
+	}
+}
+
+__inline uint8_t *get_my_bssid(WLAN_BSSID_EX *pnetwork)
+{
+	return (pnetwork->MacAddress);
+}
+
+u16 get_beacon_interval(WLAN_BSSID_EX *bss)
+{
+	unsigned short val;
+	memcpy((unsigned char *)&val, rtw_get_beacon_interval_from_ie(bss->IEs), 2);
+
+	return le16_to_cpu(val);
+
+}
+
+int is_client_associated_to_ap(struct rtl_priv *rtlpriv)
+{
+	struct mlme_ext_priv	*pmlmeext;
+	struct mlme_ext_info	*pmlmeinfo;
+
+	if(!rtlpriv)
+		return _FAIL;
+
+	pmlmeext = &rtlpriv->mlmeextpriv;
+	pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	if ((pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS) && ((pmlmeinfo->state&0x03) == WIFI_FW_STATION_STATE))
+	{
+		return true;
+	}
+	else
+	{
+		return _FAIL;
+	}
+}
+
+int is_client_associated_to_ibss(struct rtl_priv *rtlpriv)
+{
+	struct mlme_ext_priv	*pmlmeext = &rtlpriv->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	if ((pmlmeinfo->state & WIFI_FW_ASSOC_SUCCESS) && ((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE))
+	{
+		return true;
+	}
+	else
+	{
+		return _FAIL;
+	}
+}
+
+int is_IBSS_empty(struct rtl_priv *rtlpriv)
+{
+	unsigned int i;
+	struct mlme_ext_priv	*pmlmeext = &rtlpriv->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	for (i = IBSS_START_MAC_ID; i < NUM_STA; i++)
+	{
+		if (pmlmeinfo->FW_sta_info[i].status == 1)
+		{
+			return _FAIL;
+		}
+	}
+
+	return true;
+
+}
+
+unsigned int decide_wait_for_beacon_timeout(unsigned int bcn_interval)
+{
+	if ((bcn_interval << 2) < WAIT_FOR_BCN_TO_MIN)
+	{
+		return WAIT_FOR_BCN_TO_MIN;
+	}
+	else if ((bcn_interval << 2) > WAIT_FOR_BCN_TO_MAX)
+	{
+		return WAIT_FOR_BCN_TO_MAX;
+	}
+	else
+	{
+		return ((bcn_interval << 2));
+	}
+}
+
+int allocate_fw_sta_entry(struct rtl_priv *rtlpriv)
+{
+	unsigned int mac_id;
+	struct mlme_ext_priv	*pmlmeext = &rtlpriv->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	for (mac_id = IBSS_START_MAC_ID; mac_id < NUM_STA; mac_id++)
+	{
+		if (pmlmeinfo->FW_sta_info[mac_id].status == 0)
+		{
+			pmlmeinfo->FW_sta_info[mac_id].status = 1;
+			pmlmeinfo->FW_sta_info[mac_id].retry = 0;
+			break;
+		}
+	}
+
+	return mac_id;
+}
+
+void flush_all_cam_entry(struct rtl_priv *rtlpriv)
+{
+	struct mlme_ext_priv	*pmlmeext = &rtlpriv->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	rtw_cam_reset_all_entry(rtlpriv);
+
+	memset((uint8_t *)(pmlmeinfo->FW_sta_info), 0, sizeof(pmlmeinfo->FW_sta_info));
+
+}
+
+int WMM_param_handler(struct rtl_priv *rtlpriv, PNDIS_802_11_VARIABLE_IEs	pIE)
+{
+	//struct registry_priv	*pregpriv = &rtlpriv->registrypriv;
+	struct mlme_priv	*pmlmepriv = &(rtlpriv->mlmepriv);
+	struct mlme_ext_priv	*pmlmeext = &rtlpriv->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	if(pmlmepriv->qospriv.qos_option==0)
+	{
+		pmlmeinfo->WMM_enable = 0;
+		return _FAIL;
+	}
+
+	pmlmeinfo->WMM_enable = 1;
+	memcpy(&(pmlmeinfo->WMM_param), (pIE->data + 6), sizeof(struct WMM_para_element));
+	return true;
+
+	/*if (pregpriv->wifi_spec == 1)
+	{
+		if (pmlmeinfo->WMM_enable == 1)
+		{
+			//todo: compare the parameter set count & decide wheher to update or not
+			return _FAIL;
+		}
+		else
+		{
+			pmlmeinfo->WMM_enable = 1;
+			_rtwmemcpy(&(pmlmeinfo->WMM_param), (pIE->data + 6), sizeof(struct WMM_para_element));
+			return true;
+		}
+	}
+	else
+	{
+		pmlmeinfo->WMM_enable = 0;
+		return _FAIL;
+	}*/
+
+}
+
+void WMMOnAssocRsp(struct rtl_priv *rtlpriv)
+{
+	uint8_t	ACI, ACM, AIFS, ECWMin, ECWMax, aSifsTime;
+	uint8_t	acm_mask;
+	u16	TXOP;
+	uint32_t	acParm, i;
+	uint32_t	edca[4], inx[4];
+	struct mlme_ext_priv	*pmlmeext = &rtlpriv->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct xmit_priv		*pxmitpriv = &rtlpriv->xmitpriv;
+	struct registry_priv	*pregpriv = &rtlpriv->registrypriv;
+
+	acm_mask = 0;
+
+	if (IsSupported5G(pmlmeext->cur_wireless_mode) ||
+		(pmlmeext->cur_wireless_mode & WIRELESS_11_24N) )
+		aSifsTime = 16;
+	else
+		aSifsTime = 10;
+
+	if (pmlmeinfo->WMM_enable == 0)
+	{
+		rtlpriv->mlmepriv.acm_mask = 0;
+
+		AIFS = aSifsTime + (2 * pmlmeinfo->slotTime);
+
+		if (pmlmeext->cur_wireless_mode & (WIRELESS_11G |WIRELESS_11A)) {
+			ECWMin = 4;
+			ECWMax = 10;
+		} else if (pmlmeext->cur_wireless_mode & WIRELESS_11B) {
+			ECWMin = 5;
+			ECWMax = 10;
+		}
+
+		TXOP = 0;
+		acParm = AIFS | (ECWMin << 8) | (ECWMax << 12) | (TXOP << 16);
+		rtlpriv->cfg->ops->set_hw_reg(rtlpriv, HW_VAR_AC_PARAM_BE, (uint8_t *)(&acParm));
+		rtlpriv->cfg->ops->set_hw_reg(rtlpriv, HW_VAR_AC_PARAM_BK, (uint8_t *)(&acParm));
+		rtlpriv->cfg->ops->set_hw_reg(rtlpriv, HW_VAR_AC_PARAM_VI, (uint8_t *)(&acParm));
+
+		ECWMin = 2;
+		ECWMax = 3;
+		TXOP = 0x2f;
+		acParm = AIFS | (ECWMin << 8) | (ECWMax << 12) | (TXOP << 16);
+		rtlpriv->cfg->ops->set_hw_reg(rtlpriv, HW_VAR_AC_PARAM_VO, (uint8_t *)(&acParm));
+	}
+	else
+	{
+		for (i = 0; i < 4; i++)
+		{
+			ACI = (pmlmeinfo->WMM_param.ac_param[i].ACI_AIFSN >> 5) & 0x03;
+			ACM = (pmlmeinfo->WMM_param.ac_param[i].ACI_AIFSN >> 4) & 0x01;
+
+			//AIFS = AIFSN * slot time + SIFS - r2t phy delay
+			AIFS = (pmlmeinfo->WMM_param.ac_param[i].ACI_AIFSN & 0x0f) * pmlmeinfo->slotTime + aSifsTime;
+
+			ECWMin = (pmlmeinfo->WMM_param.ac_param[i].CW & 0x0f);
+			ECWMax = (pmlmeinfo->WMM_param.ac_param[i].CW & 0xf0) >> 4;
+			TXOP = le16_to_cpu(pmlmeinfo->WMM_param.ac_param[i].TXOP_limit);
+
+			acParm = AIFS | (ECWMin << 8) | (ECWMax << 12) | (TXOP << 16);
+
+			switch (ACI)
+			{
+				case 0x0:
+					rtlpriv->cfg->ops->set_hw_reg(rtlpriv, HW_VAR_AC_PARAM_BE, (uint8_t *)(&acParm));
+					acm_mask |= (ACM? BIT(1):0);
+					edca[XMIT_BE_QUEUE] = acParm;
+					break;
+
+				case 0x1:
+					rtlpriv->cfg->ops->set_hw_reg(rtlpriv, HW_VAR_AC_PARAM_BK, (uint8_t *)(&acParm));
+					//acm_mask |= (ACM? BIT(0):0);
+					edca[XMIT_BK_QUEUE] = acParm;
+					break;
+
+				case 0x2:
+					rtlpriv->cfg->ops->set_hw_reg(rtlpriv, HW_VAR_AC_PARAM_VI, (uint8_t *)(&acParm));
+					acm_mask |= (ACM? BIT(2):0);
+					edca[XMIT_VI_QUEUE] = acParm;
+					break;
+
+				case 0x3:
+					rtlpriv->cfg->ops->set_hw_reg(rtlpriv, HW_VAR_AC_PARAM_VO, (uint8_t *)(&acParm));
+					acm_mask |= (ACM? BIT(3):0);
+					edca[XMIT_VO_QUEUE] = acParm;
+					break;
+			}
+
+			DBG_871X("WMM(%x): %x, %x\n", ACI, ACM, acParm);
+		}
+
+		if(rtlpriv->registrypriv.acm_method == 1)
+			rtlpriv->cfg->ops->set_hw_reg(rtlpriv, HW_VAR_ACM_CTRL, (uint8_t *)(&acm_mask));
+		else
+			rtlpriv->mlmepriv.acm_mask = acm_mask;
+
+		inx[0] = 0; inx[1] = 1; inx[2] = 2; inx[3] = 3;
+
+		for(i=0; i<4; i++) {
+			pxmitpriv->wmm_para_seq[i] = inx[i];
+			DBG_871X("wmm_para_seq(%d): %d\n", i, pxmitpriv->wmm_para_seq[i]);
+		}
+	}
+}
+
+static void bwmode_update_check(struct rtl_priv *rtlpriv, PNDIS_802_11_VARIABLE_IEs pIE)
+{
+	unsigned char	 new_bwmode;
+	unsigned char  new_ch_offset;
+	struct HT_info_element	 *pHT_info;
+	struct mlme_priv	*pmlmepriv = &(rtlpriv->mlmepriv);
+	struct mlme_ext_priv	*pmlmeext = &rtlpriv->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct registry_priv *pregistrypriv = &rtlpriv->registrypriv;
+	struct ht_priv			*phtpriv = &pmlmepriv->htpriv;
+	uint8_t	cbw40_enable=0;
+
+	if(!pIE)
+		return;
+
+	if(phtpriv->ht_option == false)	return;
+
+	if(pmlmeext->cur_bwmode >= CHANNEL_WIDTH_80)	return;
+
+	if(pIE->Length > sizeof(struct HT_info_element))
+		return;
+
+	pHT_info = (struct HT_info_element *)pIE->data;
+
+	if (pmlmeext->cur_channel > 14) {
+		if ((0x21 & 0xf0) > 0)
+			cbw40_enable = 1;
+	} else {
+		if ((0x21 & 0x0f) > 0)
+			cbw40_enable = 1;
+	}
+
+	if((pHT_info->infos[0] & BIT(2)) && cbw40_enable)
+	{
+		new_bwmode = CHANNEL_WIDTH_40;
+
+		switch (pHT_info->infos[0] & 0x3)
+		{
+			case 1:
+				new_ch_offset = HAL_PRIME_CHNL_OFFSET_LOWER;
+				break;
+
+			case 3:
+				new_ch_offset = HAL_PRIME_CHNL_OFFSET_UPPER;
+				break;
+
+			default:
+				new_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
+				break;
+		}
+	}
+	else
+	{
+		new_bwmode = CHANNEL_WIDTH_20;
+		new_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
+	}
+
+
+	if((new_bwmode!= pmlmeext->cur_bwmode) || (new_ch_offset!=pmlmeext->cur_ch_offset))
+	{
+		pmlmeinfo->bwmode_updated = true;
+
+		pmlmeext->cur_bwmode = new_bwmode;
+		pmlmeext->cur_ch_offset = new_ch_offset;
+
+		//update HT info also
+		HT_info_handler(rtlpriv, pIE);
+	}
+	else
+	{
+		pmlmeinfo->bwmode_updated = false;
+	}
+
+
+	if(true == pmlmeinfo->bwmode_updated)
+	{
+		struct sta_info *psta;
+		WLAN_BSSID_EX 	*cur_network = &(pmlmeinfo->network);
+		struct sta_priv	*pstapriv = &rtlpriv->stapriv;
+
+		//set_channel_bwmode(rtlpriv, pmlmeext->cur_channel, pmlmeext->cur_ch_offset, pmlmeext->cur_bwmode);
+
+
+		//update ap's stainfo
+		psta = rtw_get_stainfo(pstapriv, cur_network->MacAddress);
+		if(psta)
+		{
+			struct ht_priv	*phtpriv_sta = &psta->htpriv;
+
+			if(phtpriv_sta->ht_option)
+			{
+				// bwmode
+				phtpriv_sta->bwmode = pmlmeext->cur_bwmode;
+				phtpriv_sta->ch_offset = pmlmeext->cur_ch_offset;
+			}
+			else
+			{
+				phtpriv_sta->bwmode = CHANNEL_WIDTH_20;
+				phtpriv_sta->ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;
+			}
+
+		}
+
+		//pmlmeinfo->bwmode_updated = false;//bwmode_updated done, reset it!
+
+	}
+}
+
+void HT_caps_handler(struct rtl_priv *rtlpriv, PNDIS_802_11_VARIABLE_IEs pIE)
+{
+	unsigned int	i;
+	uint8_t	rf_type;
+	uint8_t	max_AMPDU_len, min_MPDU_spacing;
+	struct mlme_ext_priv	*pmlmeext = &rtlpriv->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct mlme_priv 		*pmlmepriv = &rtlpriv->mlmepriv;
+	struct ht_priv			*phtpriv = &pmlmepriv->htpriv;
+	struct registry_priv 	*pregistrypriv = &rtlpriv->registrypriv;
+
+	if(pIE==NULL) return;
+
+	if(phtpriv->ht_option == false)	return;
+
+	pmlmeinfo->HT_caps_enable = 1;
+
+	for (i = 0; i < (pIE->Length); i++)
+	{
+		if (i != 2)
+		{
+			//	Commented by Albert 2010/07/12
+			//	Got the endian issue here.
+			pmlmeinfo->HT_caps.u.HT_cap[i] &= (pIE->data[i]);
+		}
+		else
+		{
+			//modify from  fw by Thomas 2010/11/17
+			if ((pmlmeinfo->HT_caps.u.HT_cap_element.AMPDU_para & 0x3) > (pIE->data[i] & 0x3))
+			{
+				max_AMPDU_len = (pIE->data[i] & 0x3);
+			}
+			else
+			{
+				max_AMPDU_len = (pmlmeinfo->HT_caps.u.HT_cap_element.AMPDU_para & 0x3);
+			}
+
+			if ((pmlmeinfo->HT_caps.u.HT_cap_element.AMPDU_para & 0x1c) > (pIE->data[i] & 0x1c))
+			{
+				min_MPDU_spacing = (pmlmeinfo->HT_caps.u.HT_cap_element.AMPDU_para & 0x1c);
+			}
+			else
+			{
+				min_MPDU_spacing = (pIE->data[i] & 0x1c);
+			}
+
+			pmlmeinfo->HT_caps.u.HT_cap_element.AMPDU_para = max_AMPDU_len | min_MPDU_spacing;
+		}
+	}
+
+	//	Commented by Albert 2010/07/12
+	//	Have to handle the endian issue after copying.
+	//	HT_ext_caps didn't be used yet.
+	pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info = le16_to_cpu( pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info );
+	pmlmeinfo->HT_caps.u.HT_cap_element.HT_ext_caps = le16_to_cpu( pmlmeinfo->HT_caps.u.HT_cap_element.HT_ext_caps );
+
+	rf_type = rtlpriv->phy.rf_type;
+
+	//update the MCS rates
+	for (i = 0; i < 16; i++)
+	{
+		if((rf_type == RF_1T1R) || (rf_type == RF_1T2R))
+		{
+			pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate[i] &= MCS_rate_1R[i];
+		}
+		else
+		{
+			#ifdef CONFIG_DISABLE_MCS13TO15
+			if(pmlmeext->cur_bwmode == CHANNEL_WIDTH_40 && (pregistrypriv->wifi_spec!=1))
+				pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate[i] &= MCS_rate_2R_MCS13TO15_OFF[i];
+			else
+			pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate[i] &= MCS_rate_2R[i];
+			#else
+			pmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate[i] &= MCS_rate_2R[i];
+			#endif //CONFIG_DISABLE_MCS13TO15
+		}
+	}
+	return;
+}
+
+void HT_info_handler(struct rtl_priv *rtlpriv, PNDIS_802_11_VARIABLE_IEs pIE)
+{
+	struct mlme_ext_priv	*pmlmeext = &rtlpriv->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct mlme_priv 		*pmlmepriv = &rtlpriv->mlmepriv;
+	struct ht_priv			*phtpriv = &pmlmepriv->htpriv;
+
+	if(pIE==NULL) return;
+
+	if(phtpriv->ht_option == false)	return;
+
+
+	if(pIE->Length > sizeof(struct HT_info_element))
+		return;
+
+	pmlmeinfo->HT_info_enable = 1;
+	memcpy(&(pmlmeinfo->HT_info), pIE->data, pIE->Length);
+	return;
+}
+
+void HTOnAssocRsp(struct rtl_priv *rtlpriv)
+{
+	unsigned char		max_AMPDU_len;
+	unsigned char		min_MPDU_spacing;
+	//struct registry_priv	 *pregpriv = &rtlpriv->registrypriv;
+	struct mlme_ext_priv	*pmlmeext = &rtlpriv->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	DBG_871X("%s\n", __FUNCTION__);
+
+	if ((pmlmeinfo->HT_info_enable) && (pmlmeinfo->HT_caps_enable))
+	{
+		pmlmeinfo->HT_enable = 1;
+	}
+	else
+	{
+		pmlmeinfo->HT_enable = 0;
+		//set_channel_bwmode(rtlpriv, pmlmeext->cur_channel, pmlmeext->cur_ch_offset, pmlmeext->cur_bwmode);
+		return;
+	}
+
+	//handle A-MPDU parameter field
+	/*
+		AMPDU_para [1:0]:Max AMPDU Len => 0:8k , 1:16k, 2:32k, 3:64k
+		AMPDU_para [4:2]:Min MPDU Start Spacing
+	*/
+	max_AMPDU_len = pmlmeinfo->HT_caps.u.HT_cap_element.AMPDU_para & 0x03;
+
+	min_MPDU_spacing = (pmlmeinfo->HT_caps.u.HT_cap_element.AMPDU_para & 0x1c) >> 2;
+
+	rtlpriv->cfg->ops->set_hw_reg(rtlpriv, HW_VAR_AMPDU_MIN_SPACE, (uint8_t *)(&min_MPDU_spacing));
+
+	rtlpriv->cfg->ops->set_hw_reg(rtlpriv, HW_VAR_AMPDU_FACTOR, (uint8_t *)(&max_AMPDU_len));
+
+	//set_channel_bwmode(rtlpriv, pmlmeext->cur_channel, pmlmeext->cur_ch_offset, pmlmeext->cur_bwmode);
+}
+
+void ERP_IE_handler(struct rtl_priv *rtlpriv, PNDIS_802_11_VARIABLE_IEs pIE)
+{
+	struct mlme_ext_priv	*pmlmeext = &rtlpriv->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	if(pIE->Length>1)
+		return;
+
+	pmlmeinfo->ERP_enable = 1;
+	memcpy(&(pmlmeinfo->ERP_IE), pIE->data, pIE->Length);
+}
+
+void VCS_update(struct rtl_priv *rtlpriv, struct sta_info *psta)
+{
+	struct registry_priv	 *pregpriv = &rtlpriv->registrypriv;
+	struct mlme_ext_priv	*pmlmeext = &rtlpriv->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	switch (AUTO_VCS)/* 0:off 1:on 2:auto */
+	{
+		case 0: //off
+			psta->rtsen = 0;
+			psta->cts2self = 0;
+			break;
+
+		case 1: //on
+			if (RTS_CTS == 1) /* 1:RTS/CTS 2:CTS to self */
+			{
+				psta->rtsen = 1;
+				psta->cts2self = 0;
+			}
+			else
+			{
+				psta->rtsen = 0;
+				psta->cts2self = 1;
+			}
+			break;
+
+		case 2: //auto
+		default:
+			if ((pmlmeinfo->ERP_enable) && (pmlmeinfo->ERP_IE & BIT(1)))
+			{
+				if (RTS_CTS == 1)
+				{
+					psta->rtsen = 1;
+					psta->cts2self = 0;
+				}
+				else
+				{
+					psta->rtsen = 0;
+					psta->cts2self = 1;
+				}
+			}
+			else
+			{
+				psta->rtsen = 0;
+				psta->cts2self = 0;
+			}
+			break;
+	}
+}
+
+
+int rtw_check_bcn_info(struct rtl_priv *rtlpriv, uint8_t *pframe, uint32_t	 packet_len)
+{
+	unsigned int		len;
+	unsigned char		*p;
+	unsigned short	val16, subtype;
+	struct wlan_network *cur_network = &(rtlpriv->mlmepriv.cur_network);
+	//uint8_t wpa_ie[255],rsn_ie[255];
+	u16 wpa_len=0,rsn_len=0;
+	uint8_t encryp_protocol = 0;
+	WLAN_BSSID_EX *bssid;
+	int group_cipher = 0, pairwise_cipher = 0, is_8021x = 0;
+	unsigned char *pbuf;
+	uint32_t	 wpa_ielen = 0;
+	uint8_t *pbssid = GetAddr3Ptr(pframe);
+	uint32_t	 hidden_ssid = 0;
+	uint8_t cur_network_type, network_type=0;
+	struct HT_info_element *pht_info = NULL;
+	struct rtw_ieee80211_ht_cap *pht_cap = NULL;
+	uint32_t	 bcn_channel;
+	unsigned short 	ht_cap_info;
+	unsigned char	ht_info_infos_0;
+
+	if (is_client_associated_to_ap(rtlpriv) == false)
+		return true;
+
+	len = packet_len - sizeof(struct rtw_ieee80211_hdr_3addr);
+
+	if (len > MAX_IE_SZ) {
+		DBG_871X("%s IE too long for survey event\n", __func__);
+		return _FAIL;
+	}
+
+	if (_rtw_memcmp(cur_network->network.MacAddress, pbssid, 6) == false) {
+		DBG_871X("Oops: rtw_check_network_encrypt linked but recv other bssid bcn\n" MAC_FMT MAC_FMT,
+				MAC_ARG(pbssid), MAC_ARG(cur_network->network.MacAddress));
+		return true;
+	}
+
+	bssid = (WLAN_BSSID_EX *)rtw_zmalloc(sizeof(WLAN_BSSID_EX));
+
+	subtype = GetFrameSubType(pframe) >> 4;
+
+	if(subtype==WIFI_BEACON)
+		bssid->Reserved[0] = 1;
+
+	bssid->Length = sizeof(WLAN_BSSID_EX) - MAX_IE_SZ + len;
+
+	/* below is to copy the information element */
+	bssid->IELength = len;
+	memcpy(bssid->IEs, (pframe + sizeof(struct rtw_ieee80211_hdr_3addr)), bssid->IELength);
+
+	/* check bw and channel offset */
+	/* parsing HT_CAP_IE */
+	p = rtw_get_ie(bssid->IEs + _FIXED_IE_LENGTH_, _HT_CAPABILITY_IE_, &len, bssid->IELength - _FIXED_IE_LENGTH_);
+	if(p && len>0) {
+			pht_cap = (struct rtw_ieee80211_ht_cap *)(p + 2);
+			ht_cap_info = pht_cap->cap_info;
+	} else {
+			ht_cap_info = 0;
+	}
+	/* parsing HT_INFO_IE */
+	p = rtw_get_ie(bssid->IEs + _FIXED_IE_LENGTH_, _HT_ADD_INFO_IE_, &len, bssid->IELength - _FIXED_IE_LENGTH_);
+	if(p && len>0) {
+			pht_info = (struct HT_info_element *)(p + 2);
+			ht_info_infos_0 = pht_info->infos[0];
+	} else {
+			ht_info_infos_0 = 0;
+	}
+	if (ht_cap_info != cur_network->BcnInfo.ht_cap_info ||
+		((ht_info_infos_0&0x03) != (cur_network->BcnInfo.ht_info_infos_0&0x03))) {
+			DBG_871X("%s bcn now: ht_cap_info:%x ht_info_infos_0:%x\n", __func__,
+						   	ht_cap_info, ht_info_infos_0);
+			DBG_871X("%s bcn link: ht_cap_info:%x ht_info_infos_0:%x\n", __func__,
+						   	cur_network->BcnInfo.ht_cap_info, cur_network->BcnInfo.ht_info_infos_0);
+			DBG_871X("%s bw mode change, disconnect\n", __func__);
+			{
+				//bcn_info_update
+				cur_network->BcnInfo.ht_cap_info = ht_cap_info;
+				cur_network->BcnInfo.ht_info_infos_0 = ht_info_infos_0;
+				//to do : need to check that whether modify related register of BB or not
+			}
+			//goto _mismatch;
+	}
+
+	/* Checking for channel */
+	p = rtw_get_ie(bssid->IEs + _FIXED_IE_LENGTH_, _DSSET_IE_, &len, bssid->IELength - _FIXED_IE_LENGTH_);
+	if (p) {
+			bcn_channel = *(p + 2);
+	} else {/* In 5G, some ap do not have DSSET IE checking HT info for channel */
+			p = rtw_get_ie(bssid->IEs + _FIXED_IE_LENGTH_, _HT_ADD_INFO_IE_, &len, bssid->IELength - _FIXED_IE_LENGTH_);
+			if(pht_info) {
+					bcn_channel = pht_info->primary_channel;
+			} else { /* we don't find channel IE, so don't check it */
+					//DBG_871X("Oops: %s we don't find channel IE, so don't check it \n", __func__);
+					bcn_channel = rtlpriv->mlmeextpriv.cur_channel;
+			}
+	}
+	if (bcn_channel != rtlpriv->mlmeextpriv.cur_channel) {
+			DBG_871X("%s beacon channel:%d cur channel:%d disconnect\n", __func__,
+						   bcn_channel, rtlpriv->mlmeextpriv.cur_channel);
+			goto _mismatch;
+	}
+
+	/* checking SSID */
+	if ((p = rtw_get_ie(bssid->IEs + _FIXED_IE_LENGTH_, _SSID_IE_, &len, bssid->IELength - _FIXED_IE_LENGTH_)) == NULL) {
+		DBG_871X("%s marc: cannot find SSID for survey event\n", __func__);
+		hidden_ssid = true;
+	} else {
+		hidden_ssid = false;
+	}
+
+	if((NULL != p) && (false == hidden_ssid && (*(p + 1)))) {
+		memcpy(bssid->Ssid.Ssid, (p + 2), *(p + 1));
+		bssid->Ssid.SsidLength = *(p + 1);
+	} else {
+		bssid->Ssid.SsidLength = 0;
+		bssid->Ssid.Ssid[0] = '\0';
+	}
+
+	if (_rtw_memcmp(bssid->Ssid.Ssid, cur_network->network.Ssid.Ssid, 32) == false ||
+			bssid->Ssid.SsidLength != cur_network->network.Ssid.SsidLength) {
+		if (bssid->Ssid.Ssid[0] != '\0' && bssid->Ssid.SsidLength != 0) { /* not hidden ssid */
+			DBG_871X("%s(), SSID is not match return FAIL\n", __func__);
+			goto _mismatch;
+		}
+	}
+
+	/* check encryption info */
+	val16 = rtw_get_capability((WLAN_BSSID_EX *)bssid);
+
+	if (val16 & BIT(4))
+		bssid->Privacy = 1;
+	else
+		bssid->Privacy = 0;
+
+	if (cur_network->network.Privacy != bssid->Privacy) {
+		DBG_871X("%s(), privacy is not match return FAIL\n",__func__);
+		goto _mismatch;
+	}
+
+	rtw_get_sec_ie(bssid->IEs, bssid->IELength, NULL,&rsn_len,NULL,&wpa_len);
+
+	if (rsn_len > 0) {
+		encryp_protocol = ENCRYP_PROTOCOL_WPA2;
+	} else if (wpa_len > 0) {
+		encryp_protocol = ENCRYP_PROTOCOL_WPA;
+	} else {
+		if (bssid->Privacy)
+			encryp_protocol = ENCRYP_PROTOCOL_WEP;
+	}
+
+	if (cur_network->BcnInfo.encryp_protocol != encryp_protocol) {
+		DBG_871X("%s(): enctyp is not match ,return FAIL\n",__func__);
+		goto _mismatch;
+	}
+
+	if (encryp_protocol == ENCRYP_PROTOCOL_WPA || encryp_protocol == ENCRYP_PROTOCOL_WPA2) {
+		pbuf = rtw_get_wpa_ie(&bssid->IEs[12], &wpa_ielen, bssid->IELength-12);
+		if(pbuf && (wpa_ielen>0)) {
+			if (_SUCCESS == rtw_parse_wpa_ie(pbuf, wpa_ielen+2, &group_cipher, &pairwise_cipher, &is_8021x)) {
+			}
+		} else {
+			pbuf = rtw_get_wpa2_ie(&bssid->IEs[12], &wpa_ielen, bssid->IELength-12);
+
+			if(pbuf && (wpa_ielen>0)) {
+				if (_SUCCESS == rtw_parse_wpa2_ie(pbuf, wpa_ielen+2, &group_cipher, &pairwise_cipher, &is_8021x)) {
+				}
+			}
+		}
+
+		if (pairwise_cipher != cur_network->BcnInfo.pairwise_cipher || group_cipher != cur_network->BcnInfo.group_cipher) {
+			DBG_871X("%s pairwise_cipher(%x:%x) or group_cipher(%x:%x) is not match ,return FAIL\n",__func__,
+					pairwise_cipher, cur_network->BcnInfo.pairwise_cipher,
+					group_cipher, cur_network->BcnInfo.group_cipher);
+			goto _mismatch;
+		}
+
+		if (is_8021x != cur_network->BcnInfo.is_8021x) {
+			DBG_871X("%s authentication is not match ,return FAIL\n", __func__);
+			goto _mismatch;
+		}
+	}
+
+	rtw_mfree(bssid);
+	return _SUCCESS;
+
+_mismatch:
+	rtw_mfree(bssid);
+	return _FAIL;
+
+	
+}
+
+void update_beacon_info(struct rtl_priv *rtlpriv, uint8_t *pframe, uint pkt_len, struct sta_info *psta)
+{
+	unsigned int i;
+	unsigned int len;
+	PNDIS_802_11_VARIABLE_IEs	pIE;
+
+
+	len = pkt_len - (_BEACON_IE_OFFSET_ + WLAN_HDR_A3_LEN);
+
+	for (i = 0; i < len;)
+	{
+		pIE = (PNDIS_802_11_VARIABLE_IEs)(pframe + (_BEACON_IE_OFFSET_ + WLAN_HDR_A3_LEN) + i);
+
+		switch (pIE->ElementID)
+		{
+			case _HT_EXTRA_INFO_IE_:	//HT info
+				//HT_info_handler(rtlpriv, pIE);
+				bwmode_update_check(rtlpriv, pIE);
+				break;
+
+			case _ERPINFO_IE_:
+				ERP_IE_handler(rtlpriv, pIE);
+				VCS_update(rtlpriv, psta);
+				break;
+
+			default:
+				break;
+		}
+
+		i += (pIE->Length + 2);
+	}
+}
+
+#ifdef CONFIG_DFS
+void process_csa_ie(struct rtl_priv *rtlpriv, uint8_t *pframe, uint pkt_len)
+{
+	unsigned int i;
+	unsigned int len;
+	PNDIS_802_11_VARIABLE_IEs	pIE;
+	uint8_t new_ch_no = 0;
+
+	len = pkt_len - (_BEACON_IE_OFFSET_ + WLAN_HDR_A3_LEN);
+
+	for (i = 0; i < len;)
+	{
+		pIE = (PNDIS_802_11_VARIABLE_IEs)(pframe + (_BEACON_IE_OFFSET_ + WLAN_HDR_A3_LEN) + i);
+
+		switch (pIE->ElementID)
+		{
+			case _CH_SWTICH_ANNOUNCE_:
+				memcpy(&new_ch_no, pIE->data+1, 1);
+				rtw_set_csa_cmd(rtlpriv, new_ch_no);
+				break;
+
+			default:
+				break;
+		}
+
+		i += (pIE->Length + 2);
+	}
+}
+#endif //CONFIG_DFS
+
+unsigned int is_ap_in_tkip(struct rtl_priv *rtlpriv)
+{
+	uint32_t	 i;
+	PNDIS_802_11_VARIABLE_IEs	pIE;
+	struct mlme_ext_priv *pmlmeext = &rtlpriv->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	WLAN_BSSID_EX 		*cur_network = &(pmlmeinfo->network);
+
+	if (rtw_get_capability((WLAN_BSSID_EX *)cur_network) & WLAN_CAPABILITY_PRIVACY)
+	{
+		for (i = sizeof(NDIS_802_11_FIXED_IEs); i < pmlmeinfo->network.IELength;)
+		{
+			pIE = (PNDIS_802_11_VARIABLE_IEs)(pmlmeinfo->network.IEs + i);
+
+			switch (pIE->ElementID)
+			{
+				case _VENDOR_SPECIFIC_IE_:
+					if ((_rtw_memcmp(pIE->data, RTW_WPA_OUI, 4)) && (_rtw_memcmp((pIE->data + 12), WPA_TKIP_CIPHER, 4)))
+					{
+						return true;
+					}
+					break;
+
+				case _RSN_IE_2_:
+					if (_rtw_memcmp((pIE->data + 8), RSN_TKIP_CIPHER, 4))
+					{
+						return true;
+					}
+
+				default:
+					break;
+			}
+
+			i += (pIE->Length + 2);
+		}
+
+		return false;
+	}
+	else
+	{
+		return false;
+	}
+
+}
+
+unsigned int should_forbid_n_rate(struct rtl_priv * rtlpriv)
+{
+	uint32_t	 i;
+	PNDIS_802_11_VARIABLE_IEs	pIE;
+	struct mlme_priv	*pmlmepriv = &rtlpriv->mlmepriv;
+	WLAN_BSSID_EX  *cur_network = &pmlmepriv->cur_network.network;
+
+	if (rtw_get_capability((WLAN_BSSID_EX *)cur_network) & WLAN_CAPABILITY_PRIVACY)
+	{
+		for (i = sizeof(NDIS_802_11_FIXED_IEs); i < cur_network->IELength;)
+		{
+			pIE = (PNDIS_802_11_VARIABLE_IEs)(cur_network->IEs + i);
+
+			switch (pIE->ElementID)
+			{
+				case _VENDOR_SPECIFIC_IE_:
+					if (_rtw_memcmp(pIE->data, RTW_WPA_OUI, 4) &&
+						((_rtw_memcmp((pIE->data + 12), WPA_CIPHER_SUITE_CCMP, 4)) ||
+						  (_rtw_memcmp((pIE->data + 16), WPA_CIPHER_SUITE_CCMP, 4))))
+						return false;
+					break;
+
+				case _RSN_IE_2_:
+					if  ((_rtw_memcmp((pIE->data + 8), RSN_CIPHER_SUITE_CCMP, 4))  ||
+					       (_rtw_memcmp((pIE->data + 12), RSN_CIPHER_SUITE_CCMP, 4)))
+					return false;
+
+				default:
+					break;
+			}
+
+			i += (pIE->Length + 2);
+		}
+
+		return true;
+	}
+	else
+	{
+		return false;
+	}
+
+}
+
+
+unsigned int is_ap_in_wep(struct rtl_priv *rtlpriv)
+{
+	uint32_t	 i;
+	PNDIS_802_11_VARIABLE_IEs	pIE;
+	struct mlme_ext_priv *pmlmeext = &rtlpriv->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	WLAN_BSSID_EX 		*cur_network = &(pmlmeinfo->network);
+
+	if (rtw_get_capability((WLAN_BSSID_EX *)cur_network) & WLAN_CAPABILITY_PRIVACY)
+	{
+		for (i = sizeof(NDIS_802_11_FIXED_IEs); i < pmlmeinfo->network.IELength;)
+		{
+			pIE = (PNDIS_802_11_VARIABLE_IEs)(pmlmeinfo->network.IEs + i);
+
+			switch (pIE->ElementID)
+			{
+				case _VENDOR_SPECIFIC_IE_:
+					if (_rtw_memcmp(pIE->data, RTW_WPA_OUI, 4))
+						return false;
+					break;
+
+				case _RSN_IE_2_:
+					return false;
+
+				default:
+					break;
+			}
+
+			i += (pIE->Length + 2);
+		}
+
+		return true;
+	}
+	else
+	{
+		return false;
+	}
+
+}
+
+int wifirate2_ratetbl_inx(unsigned char rate);
+int wifirate2_ratetbl_inx(unsigned char rate)
+{
+	int	inx = 0;
+	rate = rate & 0x7f;
+
+	switch (rate)
+	{
+		case 54*2:
+			inx = 11;
+			break;
+
+		case 48*2:
+			inx = 10;
+			break;
+
+		case 36*2:
+			inx = 9;
+			break;
+
+		case 24*2:
+			inx = 8;
+			break;
+
+		case 18*2:
+			inx = 7;
+			break;
+
+		case 12*2:
+			inx = 6;
+			break;
+
+		case 9*2:
+			inx = 5;
+			break;
+
+		case 6*2:
+			inx = 4;
+			break;
+
+		case 11*2:
+			inx = 3;
+			break;
+		case 11:
+			inx = 2;
+			break;
+
+		case 2*2:
+			inx = 1;
+			break;
+
+		case 1*2:
+			inx = 0;
+			break;
+
+	}
+	return inx;
+}
+
+unsigned int update_basic_rate(unsigned char *ptn, unsigned int ptn_sz)
+{
+	unsigned int i, num_of_rate;
+	unsigned int mask = 0;
+
+	num_of_rate = (ptn_sz > NumRates)? NumRates: ptn_sz;
+
+	for (i = 0; i < num_of_rate; i++)
+	{
+		if ((*(ptn + i)) & 0x80)
+		{
+			mask |= 0x1 << wifirate2_ratetbl_inx(*(ptn + i));
+		}
+	}
+	return mask;
+}
+
+unsigned int update_supported_rate(unsigned char *ptn, unsigned int ptn_sz)
+{
+	unsigned int i, num_of_rate;
+	unsigned int mask = 0;
+
+	num_of_rate = (ptn_sz > NumRates)? NumRates: ptn_sz;
+
+	for (i = 0; i < num_of_rate; i++)
+	{
+		mask |= 0x1 << wifirate2_ratetbl_inx(*(ptn + i));
+	}
+
+	return mask;
+}
+
+unsigned int update_MCS_rate(struct HT_caps_element *pHT_caps)
+{
+	unsigned int mask = 0;
+
+	mask = ((pHT_caps->u.HT_cap_element.MCS_rate[0] << 12) | (pHT_caps->u.HT_cap_element.MCS_rate[1] << 20));
+
+	return mask;
+}
+
+int support_short_GI(struct rtl_priv *rtlpriv, struct HT_caps_element *pHT_caps)
+{
+	unsigned char					bit_offset;
+	struct mlme_ext_priv	*pmlmeext = &rtlpriv->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	if (!(pmlmeinfo->HT_enable))
+		return _FAIL;
+
+	if ((pmlmeinfo->assoc_AP_vendor == HT_IOT_PEER_RALINK))
+		return _FAIL;
+
+	bit_offset = (pmlmeext->cur_bwmode & CHANNEL_WIDTH_40)? 6: 5;
+
+	if (pHT_caps->u.HT_cap_element.HT_caps_info & (0x1 << bit_offset))
+	{
+		return _SUCCESS;
+	}
+	else
+	{
+		return _FAIL;
+	}
+}
+
+unsigned char get_highest_rate_idx(uint32_t	 mask)
+{
+	int i;
+	unsigned char rate_idx=0;
+
+	for(i=31; i>=0; i--)
+	{
+		if(mask & BIT(i))
+		{
+			rate_idx = i;
+			break;
+		}
+	}
+
+	return rate_idx;
+}
+
+unsigned char get_highest_mcs_rate(struct HT_caps_element *pHT_caps);
+unsigned char get_highest_mcs_rate(struct HT_caps_element *pHT_caps)
+{
+	int i, mcs_rate;
+
+	mcs_rate = (pHT_caps->u.HT_cap_element.MCS_rate[0] | (pHT_caps->u.HT_cap_element.MCS_rate[1] << 8));
+
+	for (i = 15; i >= 0; i--)
+	{
+		if (mcs_rate & (0x1 << i))
+		{
+			break;
+		}
+	}
+
+	return i;
+}
+
+void Update_RA_Entry(struct rtl_priv *rtlpriv, struct sta_info *psta)
+{
+	rtw_hal_update_ra_mask(psta->rtlpriv, psta, 0);
+}
+
+void enable_rate_adaptive(struct rtl_priv *rtlpriv, struct sta_info *psta);
+void enable_rate_adaptive(struct rtl_priv *rtlpriv, struct sta_info *psta)
+{
+	Update_RA_Entry(rtlpriv, psta);
+}
+
+void set_sta_rate(struct rtl_priv *rtlpriv, struct sta_info *psta)
+{
+	//rate adaptive
+	enable_rate_adaptive(rtlpriv, psta);
+}
+
+// Update RRSR and Rate for USERATE
+void update_tx_basic_rate(struct rtl_priv *rtlpriv, uint8_t wirelessmode)
+{
+	NDIS_802_11_RATES_EX	supported_rates;
+	struct mlme_ext_priv	*pmlmeext = &rtlpriv->mlmeextpriv;
+
+	memset(supported_rates, 0, NDIS_802_11_LENGTH_RATES_EX);
+
+	//clear B mod if current channel is in 5G band, avoid tx cck rate in 5G band.
+	if(pmlmeext->cur_channel > 14)
+		wirelessmode &= ~(WIRELESS_11B);
+
+	if ((wirelessmode & WIRELESS_11B) && (wirelessmode == WIRELESS_11B)) {
+		memcpy(supported_rates, rtw_basic_rate_cck, 4);
+	} else if (wirelessmode & WIRELESS_11B) {
+		memcpy(supported_rates, rtw_basic_rate_mix, 7);
+	} else {
+		memcpy(supported_rates, rtw_basic_rate_ofdm, 3);
+	}
+
+	if (wirelessmode & WIRELESS_11B)
+		update_mgnt_tx_rate(rtlpriv, IEEE80211_CCK_RATE_1MB);
+	else
+		update_mgnt_tx_rate(rtlpriv, IEEE80211_OFDM_RATE_6MB);
+
+	rtlpriv->cfg->ops->set_hw_reg(rtlpriv, HW_VAR_BASIC_RATE, supported_rates);
+}
+
+unsigned char check_assoc_AP(uint8_t *pframe, uint len)
+{
+	unsigned int	i;
+	PNDIS_802_11_VARIABLE_IEs	pIE;
+
+	for (i = sizeof(NDIS_802_11_FIXED_IEs); i < len;)
+	{
+		pIE = (PNDIS_802_11_VARIABLE_IEs)(pframe + i);
+
+		switch (pIE->ElementID)
+		{
+			case _VENDOR_SPECIFIC_IE_:
+				if ((_rtw_memcmp(pIE->data, ARTHEROS_OUI1, 3)) || (_rtw_memcmp(pIE->data, ARTHEROS_OUI2, 3)))
+				{
+					DBG_871X("link to Artheros AP\n");
+					return HT_IOT_PEER_ATHEROS;
+				}
+				else if ((_rtw_memcmp(pIE->data, BROADCOM_OUI1, 3))
+							|| (_rtw_memcmp(pIE->data, BROADCOM_OUI2, 3))
+							|| (_rtw_memcmp(pIE->data, BROADCOM_OUI2, 3)))
+				{
+					DBG_871X("link to Broadcom AP\n");
+					return HT_IOT_PEER_BROADCOM;
+				}
+				else if (_rtw_memcmp(pIE->data, MARVELL_OUI, 3))
+				{
+					DBG_871X("link to Marvell AP\n");
+					return HT_IOT_PEER_MARVELL;
+				}
+				else if (_rtw_memcmp(pIE->data, RALINK_OUI, 3))
+				{
+					DBG_871X("link to Ralink AP\n");
+					return HT_IOT_PEER_RALINK;
+				}
+				else if (_rtw_memcmp(pIE->data, CISCO_OUI, 3))
+				{
+					DBG_871X("link to Cisco AP\n");
+					return HT_IOT_PEER_CISCO;
+				}
+				else if (_rtw_memcmp(pIE->data, REALTEK_OUI, 3))
+				{
+					uint32_t	Vender = HT_IOT_PEER_REALTEK;
+
+					if(pIE->Length >= 5) {
+						if(pIE->data[4]==1)
+						{
+							//if(pIE->data[5] & RT_HT_CAP_USE_LONG_PREAMBLE)
+							//	bssDesc->BssHT.RT2RT_HT_Mode |= RT_HT_CAP_USE_LONG_PREAMBLE;
+
+							if(pIE->data[5] & RT_HT_CAP_USE_92SE)
+							{
+								//bssDesc->BssHT.RT2RT_HT_Mode |= RT_HT_CAP_USE_92SE;
+								Vender = HT_IOT_PEER_REALTEK_92SE;
+							}
+						}
+
+						if(pIE->data[5] & RT_HT_CAP_USE_SOFTAP)
+							Vender = HT_IOT_PEER_REALTEK_SOFTAP;
+
+						if(pIE->data[4] == 2)
+						{
+							if(pIE->data[6] & RT_HT_CAP_USE_JAGUAR_BCUT) {
+								Vender = HT_IOT_PEER_REALTEK_JAGUAR_BCUTAP;
+								DBG_871X("link to Realtek JAGUAR_BCUTAP\n");
+							}
+							if(pIE->data[6] & RT_HT_CAP_USE_JAGUAR_CCUT) {
+								Vender = HT_IOT_PEER_REALTEK_JAGUAR_CCUTAP;
+								DBG_871X("link to Realtek JAGUAR_CCUTAP\n");
+							}
+						}
+					}
+
+					DBG_871X("link to Realtek AP\n");
+					return Vender;
+				}
+				else if (_rtw_memcmp(pIE->data, AIRGOCAP_OUI,3))
+				{
+					DBG_871X("link to Airgo Cap\n");
+					return HT_IOT_PEER_AIRGO;
+				}
+				else
+				{
+					break;
+				}
+
+			default:
+				break;
+		}
+
+		i += (pIE->Length + 2);
+	}
+
+	DBG_871X("link to new AP\n");
+	return HT_IOT_PEER_UNKNOWN;
+}
+
+void update_IOT_info(struct rtl_priv *rtlpriv)
+{
+	struct mlme_ext_priv	*pmlmeext = &rtlpriv->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	switch (pmlmeinfo->assoc_AP_vendor)
+	{
+		case HT_IOT_PEER_MARVELL:
+			pmlmeinfo->turboMode_cts2self = 1;
+			pmlmeinfo->turboMode_rtsen = 0;
+			break;
+
+		case HT_IOT_PEER_RALINK:
+			pmlmeinfo->turboMode_cts2self = 0;
+			pmlmeinfo->turboMode_rtsen = 1;
+			break;
+		case HT_IOT_PEER_REALTEK:
+			//rtw_write16(rtlpriv, 0x4cc, 0xffff);
+			//rtw_write16(rtlpriv, 0x546, 0x01c0);
+			//disable high power
+			break;
+		default:
+			pmlmeinfo->turboMode_cts2self = 0;
+			pmlmeinfo->turboMode_rtsen = 1;
+			break;
+	}
+
+}
+
+void update_capinfo(struct rtl_priv *rtlpriv, u16 updateCap)
+{
+	struct mlme_ext_priv	*pmlmeext = &rtlpriv->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	bool		ShortPreamble;
+
+	// Check preamble mode, 2005.01.06, by rcnjko.
+	// Mark to update preamble value forever, 2008.03.18 by lanhsin
+	//if( pMgntInfo->RegPreambleMode == PREAMBLE_AUTO )
+	{
+
+		if(updateCap & cShortPreamble)
+		{ // Short Preamble
+			if(pmlmeinfo->preamble_mode != PREAMBLE_SHORT) // PREAMBLE_LONG or PREAMBLE_AUTO
+			{
+				ShortPreamble = true;
+				pmlmeinfo->preamble_mode = PREAMBLE_SHORT;
+				rtlpriv->cfg->ops->set_hw_reg( rtlpriv, HW_VAR_ACK_PREAMBLE, (uint8_t *)&ShortPreamble );
+			}
+		}
+		else
+		{ // Long Preamble
+			if(pmlmeinfo->preamble_mode != PREAMBLE_LONG)  // PREAMBLE_SHORT or PREAMBLE_AUTO
+			{
+				ShortPreamble = false;
+				pmlmeinfo->preamble_mode = PREAMBLE_LONG;
+				rtlpriv->cfg->ops->set_hw_reg( rtlpriv, HW_VAR_ACK_PREAMBLE, (uint8_t *)&ShortPreamble );
+			}
+		}
+	}
+
+	if ( updateCap & cIBSS ) {
+		//Filen: See 802.11-2007 p.91
+		pmlmeinfo->slotTime = NON_SHORT_SLOT_TIME;
+	}
+	else
+	{
+		//Filen: See 802.11-2007 p.90
+		if( pmlmeext->cur_wireless_mode & (WIRELESS_11G))
+		{
+			if( (updateCap & cShortSlotTime) /* && (!(pMgntInfo->pHTInfo->RT2RT_HT_Mode & RT_HT_CAP_USE_LONG_PREAMBLE)) */)
+			{ // Short Slot Time
+				pmlmeinfo->slotTime = SHORT_SLOT_TIME;
+			}
+			else
+			{ // Long Slot Time
+				pmlmeinfo->slotTime = NON_SHORT_SLOT_TIME;
+			}
+		}
+		else if( pmlmeext->cur_wireless_mode & (WIRELESS_11_24N | WIRELESS_11A | WIRELESS_11_5N | WIRELESS_11AC))
+		{
+			pmlmeinfo->slotTime = SHORT_SLOT_TIME;
+		}
+		else
+		{
+			//B Mode
+			pmlmeinfo->slotTime = NON_SHORT_SLOT_TIME;
+		}
+ 	}
+
+	rtlpriv->cfg->ops->set_hw_reg( rtlpriv, HW_VAR_SLOT_TIME, &pmlmeinfo->slotTime );
+
+}
+
+void update_wireless_mode(struct rtl_priv *rtlpriv)
+{
+	int ratelen, network_type = 0;
+	uint32_t	 SIFS_Timer;
+	struct mlme_ext_priv	*pmlmeext = &rtlpriv->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	WLAN_BSSID_EX 		*cur_network = &(pmlmeinfo->network);
+	unsigned char			*rate = cur_network->SupportedRates;
+
+	ratelen = rtw_get_rateset_len(cur_network->SupportedRates);
+
+	if ((pmlmeinfo->HT_info_enable) && (pmlmeinfo->HT_caps_enable))
+	{
+		pmlmeinfo->HT_enable = 1;
+	}
+
+	if(pmlmeext->cur_channel > 14)
+	{
+		if (pmlmeinfo->VHT_enable)
+			network_type = WIRELESS_11AC;
+		else if (pmlmeinfo->HT_enable)
+			network_type = WIRELESS_11_5N;
+
+		network_type |= WIRELESS_11A;
+	}
+	else
+	{
+		if (pmlmeinfo->VHT_enable)
+			network_type = WIRELESS_11AC;
+		else if (pmlmeinfo->HT_enable)
+			network_type = WIRELESS_11_24N;
+
+		if ((cckratesonly_included(rate, ratelen)) == true)
+		{
+			network_type |= WIRELESS_11B;
+		}
+		else if((cckrates_included(rate, ratelen)) == true)
+		{
+			network_type |= WIRELESS_11BG;
+		}
+		else
+		{
+			network_type |= WIRELESS_11G;
+		}
+	}
+
+	pmlmeext->cur_wireless_mode = network_type & WIRELESS_MODE_MAX;
+/*
+	if((pmlmeext->cur_wireless_mode==WIRELESS_11G) ||
+		(pmlmeext->cur_wireless_mode==WIRELESS_11BG))//WIRELESS_MODE_G)
+		SIFS_Timer = 0x0a0a;//CCK
+	else
+		SIFS_Timer = 0x0e0e;//pHalData->SifsTime; //OFDM
+*/
+
+	SIFS_Timer = 0x0a0a0808; //0x0808 -> for CCK, 0x0a0a -> for OFDM
+                             //change this value if having IOT issues.
+
+	rtlpriv->cfg->ops->set_hw_reg( rtlpriv, HW_VAR_RESP_SIFS,  (uint8_t *)&SIFS_Timer);
+
+	rtlpriv->cfg->ops->set_hw_reg( rtlpriv, HW_VAR_WIRELESS_MODE,  (uint8_t *)&(pmlmeext->cur_wireless_mode));
+
+	if (pmlmeext->cur_wireless_mode & WIRELESS_11B)
+		update_mgnt_tx_rate(rtlpriv, IEEE80211_CCK_RATE_1MB);
+	 else
+		update_mgnt_tx_rate(rtlpriv, IEEE80211_OFDM_RATE_6MB);
+}
+
+void fire_write_MAC_cmd(struct rtl_priv *rtlpriv, unsigned int addr, unsigned int value);
+void fire_write_MAC_cmd(struct rtl_priv *rtlpriv, unsigned int addr, unsigned int value)
+{
+}
+
+void update_bmc_sta_support_rate(struct rtl_priv *rtlpriv, uint32_t	 mac_id)
+{
+	struct mlme_ext_priv	*pmlmeext = &(rtlpriv->mlmeextpriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	if(pmlmeext->cur_wireless_mode & WIRELESS_11B)
+	{
+		// Only B, B/G, and B/G/N AP could use CCK rate
+		memcpy((pmlmeinfo->FW_sta_info[mac_id].SupportedRates), rtw_basic_rate_cck, 4);
+	}
+	else
+	{
+		memcpy((pmlmeinfo->FW_sta_info[mac_id].SupportedRates), rtw_basic_rate_ofdm, 4);
+	}
+}
+
+int update_sta_support_rate(struct rtl_priv *rtlpriv, uint8_t * pvar_ie, uint var_ie_len, int cam_idx)
+{
+	unsigned int	ie_len;
+	PNDIS_802_11_VARIABLE_IEs	pIE;
+	int	supportRateNum = 0;
+	struct mlme_ext_priv	*pmlmeext = &(rtlpriv->mlmeextpriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	pIE = (PNDIS_802_11_VARIABLE_IEs)rtw_get_ie(pvar_ie, _SUPPORTEDRATES_IE_, &ie_len, var_ie_len);
+	if (pIE == NULL)
+	{
+		return _FAIL;
+	}
+
+	memcpy(pmlmeinfo->FW_sta_info[cam_idx].SupportedRates, pIE->data, ie_len);
+	supportRateNum = ie_len;
+
+	pIE = (PNDIS_802_11_VARIABLE_IEs)rtw_get_ie(pvar_ie, _EXT_SUPPORTEDRATES_IE_, &ie_len, var_ie_len);
+	if (pIE)
+	{
+		memcpy((pmlmeinfo->FW_sta_info[cam_idx].SupportedRates + supportRateNum), pIE->data, ie_len);
+	}
+
+	return _SUCCESS;
+
+}
+
+void process_addba_req(struct rtl_priv *rtlpriv, uint8_t *paddba_req, uint8_t *addr)
+{
+	struct sta_info *psta;
+	u16 tid, start_seq, param;
+	struct recv_reorder_ctrl *preorder_ctrl;
+	struct sta_priv *pstapriv = &rtlpriv->stapriv;
+	struct ADDBA_request	*preq = (struct ADDBA_request*)paddba_req;
+	struct mlme_ext_priv	*pmlmeext = &rtlpriv->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	psta = rtw_get_stainfo(pstapriv, addr);
+
+	if(psta)
+	{
+		start_seq = le16_to_cpu(preq->BA_starting_seqctrl) >> 4;
+
+		param = le16_to_cpu(preq->BA_para_set);
+		tid = (param>>2)&0x0f;
+
+		preorder_ctrl = &psta->recvreorder_ctrl[tid];
+
+		#ifdef CONFIG_UPDATE_INDICATE_SEQ_WHILE_PROCESS_ADDBA_REQ
+		preorder_ctrl->indicate_seq = start_seq;
+		#else
+		preorder_ctrl->indicate_seq = 0xffff;
+		#endif
+
+		preorder_ctrl->enable =(pmlmeinfo->bAcceptAddbaReq == true)? true :false;
+	}
+
+}
+
+void update_TSF(struct mlme_ext_priv *pmlmeext, uint8_t *pframe, uint len)
+{
+	uint8_t * pIE;
+	uint32_t	 *pbuf;
+
+	pIE = pframe + sizeof(struct rtw_ieee80211_hdr_3addr);
+	pbuf = (uint32_t *)pIE;
+
+	pmlmeext->TSFValue = le32_to_cpu(*(pbuf+1));
+
+	pmlmeext->TSFValue = pmlmeext->TSFValue << 32;
+
+	pmlmeext->TSFValue |= le32_to_cpu(*pbuf);
+}
+
+void correct_TSF(struct rtl_priv *rtlpriv, struct mlme_ext_priv *pmlmeext)
+{
+	rtlpriv->cfg->ops->set_hw_reg(rtlpriv, HW_VAR_CORRECT_TSF, 0);
+}
+
+void beacon_timing_control(struct rtl_priv *rtlpriv)
+{
+	rtlpriv->cfg->ops->set_bcn_reg(rtlpriv);
+}
+
+uint rtw_get_camid(uint macid)
+{
+	uint camid;
+
+	//camid 0, 1, 2, 3 is default entry for default key/group key
+	//macid = 1 is for bc/mc stainfo, no mapping to camid
+	//macid = 0 mapping to camid 4
+	//for macid >=2, camid = macid+3;
+
+	if(macid==0)
+		camid = 4;
+	else if(macid >=2)
+		camid = macid + 3;
+	else
+		camid = 4;
+
+	return camid;
+}
+
+void rtw_alloc_macid(struct rtl_priv *rtlpriv, struct sta_info *psta)
+{
+	int i;
+	uint8_t bc_addr[ETH_ALEN] = {0xff,0xff,0xff,0xff,0xff,0xff};
+	struct rtl_usb *rtlusb = rtl_usbdev(rtlpriv);
+
+
+	if(_rtw_memcmp(psta->hwaddr, bc_addr, ETH_ALEN))
+		return;
+
+	if(_rtw_memcmp(psta->hwaddr, rtlpriv->mac80211.mac_addr, ETH_ALEN))
+	{
+		psta->mac_id = NUM_STA;
+		return;
+	}
+
+	spin_lock_bh(&rtlusb->lock);
+	for(i=0; i<NUM_STA; i++)
+	{
+		if(rtlusb->macid[i] == false)
+		{
+			rtlusb->macid[i]  = true;
+			break;
+		}
+	}
+	spin_unlock_bh(&rtlusb->lock);
+
+	if( i > (NUM_STA-1))
+	{
+		psta->mac_id = NUM_STA;
+		DBG_871X("  no room for more MACIDs\n");
+	}
+	else
+	{
+		psta->mac_id = i;
+		DBG_871X("%s = %d\n", __FUNCTION__, psta->mac_id);
+	}
+
+}
+
+void rtw_release_macid(struct rtl_priv *rtlpriv, struct sta_info *psta)
+{
+	int i;
+	uint8_t bc_addr[ETH_ALEN] = {0xff,0xff,0xff,0xff,0xff,0xff};
+	struct rtl_usb *rtlusb = rtl_usbdev(rtlpriv);
+
+
+	if(_rtw_memcmp(psta->hwaddr, bc_addr, ETH_ALEN))
+		return;
+
+	if(_rtw_memcmp(psta->hwaddr, rtlpriv->mac80211.mac_addr, ETH_ALEN))
+	{
+		return;
+	}
+
+	spin_lock_bh(&rtlusb->lock);
+	if(psta->mac_id<NUM_STA && psta->mac_id !=1 )
+	{
+		if(rtlusb->macid[psta->mac_id] == true)
+		{
+			DBG_871X("%s = %d\n", __FUNCTION__, psta->mac_id);
+			rtlusb->macid[psta->mac_id]  = false;
+			psta->mac_id = NUM_STA;
+		}
+
+	}
+	spin_unlock_bh(&rtlusb->lock);
+
+}
+
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/core/rtw_xmit.c linux-4.9.8821au/drivers/staging/rtl8821au/core/rtw_xmit.c
--- linux-4.9/drivers/staging/rtl8821au/core/rtw_xmit.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/core/rtw_xmit.c	2016-12-11 19:48:25.156978448 -0600
@@ -0,0 +1,2773 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#define _RTW_XMIT_C_
+
+#include <linux/ip.h>
+#include <linux/etherdevice.h>
+#include <drv_types.h>
+#include <rtw_ap.h>
+#include <linux/udp.h>
+#include <rtl8812a_xmit.h>
+
+#undef DBG_871X
+static inline void DBG_871X(const char *fmt, ...)
+{
+}
+
+#undef DBG_8192C
+static inline void DBG_8192C(const char *fmt, ...)
+{
+}
+
+static struct list_head *get_next(struct list_head	*list)
+{
+	return list->next;
+}
+
+#define _drv_always_		1
+#undef DBG_871X_LEVEL
+static inline void DBG_871X_LEVEL(const int level, const char *fmt, ...)
+{
+}
+
+static uint8_t P802_1H_OUI[P80211_OUI_LEN] = { 0x00, 0x00, 0xf8 };
+static uint8_t RFC1042_OUI[P80211_OUI_LEN] = { 0x00, 0x00, 0x00 };
+
+
+struct pkt_file {
+	struct sk_buff *skb;
+	__kernel_size_t pkt_len;	 //the remainder length of the open_file
+	uint8_t *cur_buffer;
+	uint8_t *buf_start;
+	uint8_t *cur_addr;
+	__kernel_size_t buf_len;
+};
+
+static uint rtw_remainder_len(struct pkt_file *pfile)
+{
+	return (pfile->buf_len - ((SIZE_PTR)(pfile->cur_addr) - (SIZE_PTR)(pfile->buf_start)));
+}
+
+static void _rtw_open_pktfile (struct sk_buff *skb, struct pkt_file *pfile)
+{
+	pfile->skb = skb;
+	pfile->cur_addr = pfile->buf_start = skb->data;
+	pfile->pkt_len = pfile->buf_len = skb->len;
+
+	pfile->cur_buffer = pfile->buf_start ;
+}
+
+static uint _rtw_pktfile_read (struct pkt_file *pfile, uint8_t *rmem, uint rlen)
+{
+	uint	len = 0;
+
+	len =  rtw_remainder_len(pfile);
+	len = (rlen > len)? len: rlen;
+
+	if(rmem)
+		skb_copy_bits(pfile->skb, pfile->buf_len-pfile->pkt_len, rmem, len);
+
+	pfile->cur_addr += len;
+	pfile->pkt_len -= len;
+
+	return len;
+}
+
+
+static void set_qos(struct sk_buff *skb, struct tx_pkt_attrib *pattrib)
+{
+	struct iphdr *ip_hdr;
+	int32_t UserPriority = 0;
+
+	/* get UserPriority from IP hdr */
+	if (pattrib->ether_type == 0x0800) {
+		ip_hdr = (struct iphdr *) (skb->data + ETH_HLEN);
+		/* UserPriority = (ntohs(ip_hdr.tos) >> 5) & 0x3; */
+		UserPriority = ip_hdr->tos >> 5;
+	} else if (pattrib->ether_type == 0x888e) {
+		/*
+		 *  "When priority processing of data frames is supported,
+		 *  a STA's SME should send EAPOL-Key frames at the highest priority."
+		 */
+		UserPriority = 7;
+	}
+
+	pattrib->tx_priority = UserPriority;
+	pattrib->hdrlen = WLAN_HDR_A3_QOS_LEN;
+	pattrib->subtype = WIFI_QOS_DATA_TYPE;
+}
+
+static int rtw_endofpktfile(struct pkt_file *pfile)
+{
+
+	if (pfile->pkt_len == 0) {
+		return true;
+	}
+
+	return false;
+}
+
+static void _init_txservq(struct tx_servq *ptxservq)
+{
+	INIT_LIST_HEAD(&ptxservq->tx_pending);
+	_rtw_init_queue(&ptxservq->sta_pending);
+}
+
+
+void	_rtw_init_sta_xmit_priv(struct sta_xmit_priv *psta_xmitpriv)
+{
+	memset((unsigned char *)psta_xmitpriv, 0, sizeof (struct sta_xmit_priv));
+
+	spin_lock_init(&psta_xmitpriv->lock);
+
+	/*
+	 * for(i = 0 ; i < MAX_NUMBLKS; i++)
+	 * 	_init_txservq(&(psta_xmitpriv->blk_q[i]));
+	 */
+
+	_init_txservq(&psta_xmitpriv->be_q);
+	_init_txservq(&psta_xmitpriv->bk_q);
+	_init_txservq(&psta_xmitpriv->vi_q);
+	_init_txservq(&psta_xmitpriv->vo_q);
+	INIT_LIST_HEAD(&psta_xmitpriv->legacy_dz);
+	INIT_LIST_HEAD(&psta_xmitpriv->apsd);
+}
+
+int32_t	_rtw_init_xmit_priv(struct xmit_priv *pxmitpriv, struct rtl_priv *rtlpriv)
+{
+	int i;
+	struct xmit_buf *pxmitbuf;
+	struct xmit_frame *pxframe;
+	int	res = _SUCCESS;
+	uint32_t	 max_xmit_extbuf_size = MAX_XMIT_EXTBUF_SZ;
+	uint32_t	 num_xmit_extbuf = NR_XMIT_EXTBUFF;
+
+	/*
+	 * We don't need to memset rtlpriv->XXX to zero, because rtlpriv is allocated by rtw_zvmalloc().
+	 * memset((unsigned char *)pxmitpriv, 0, sizeof(struct xmit_priv));
+	 */
+
+	spin_lock_init(&pxmitpriv->lock);
+	spin_lock_init(&pxmitpriv->lock_sctx);
+	sema_init(&pxmitpriv->xmit_sema, 0);
+	sema_init(&pxmitpriv->terminate_xmitthread_sema, 0);
+
+	/*
+	Please insert all the queue initializaiton using _rtw_init_queue below
+	*/
+
+	pxmitpriv->rtlpriv = rtlpriv;
+
+	/*
+	 * for(i = 0 ; i < MAX_NUMBLKS; i++)
+	 * 	_rtw_init_queue(&pxmitpriv->blk_strms[i]);
+	 */
+
+	_rtw_init_queue(&pxmitpriv->be_pending);
+	_rtw_init_queue(&pxmitpriv->bk_pending);
+	_rtw_init_queue(&pxmitpriv->vi_pending);
+	_rtw_init_queue(&pxmitpriv->vo_pending);
+
+	/*
+	 * _rtw_init_queue(&pxmitpriv->legacy_dz_queue);
+	 * _rtw_init_queue(&pxmitpriv->apsd_queue);
+	 */
+
+	_rtw_init_queue(&pxmitpriv->free_xmit_queue);
+
+	/*
+	Please allocate memory with the sz = (struct xmit_frame) * NR_XMITFRAME,
+	and initialize free_xmit_frame below.
+	Please also apply  free_txobj to link_up all the xmit_frames...
+	*/
+
+	pxmitpriv->pallocated_frame_buf = rtw_zvmalloc(NR_XMITFRAME * sizeof(struct xmit_frame) + 4);
+
+	if (pxmitpriv->pallocated_frame_buf == NULL) {
+		pxmitpriv->pxmit_frame_buf = NULL;
+		res = _FAIL;
+		goto exit;
+	}
+	pxmitpriv->pxmit_frame_buf = (uint8_t *)N_BYTE_ALIGMENT((SIZE_PTR)(pxmitpriv->pallocated_frame_buf), 4);
+	/*
+	 * pxmitpriv->pxmit_frame_buf = pxmitpriv->pallocated_frame_buf + 4 -
+	 * 						((SIZE_PTR) (pxmitpriv->pallocated_frame_buf) &3);
+	 */
+
+	pxframe = (struct xmit_frame *) pxmitpriv->pxmit_frame_buf;
+
+	for (i = 0; i < NR_XMITFRAME; i++) {
+		INIT_LIST_HEAD(&(pxframe->list));
+
+		pxframe->rtlpriv = rtlpriv;
+		pxframe->frame_tag = NULL_FRAMETAG;
+
+		pxframe->skb = NULL;
+
+		pxframe->buf_addr = NULL;
+		pxframe->pxmitbuf = NULL;
+
+		list_add_tail(&(pxframe->list), &(pxmitpriv->free_xmit_queue.list));
+
+		pxframe++;
+	}
+
+	pxmitpriv->free_xmitframe_cnt = NR_XMITFRAME;
+
+	pxmitpriv->frag_len = MAX_FRAG_THRESHOLD;
+
+
+	/* init xmit_buf */
+	_rtw_init_queue(&pxmitpriv->free_xmitbuf_queue);
+	_rtw_init_queue(&pxmitpriv->pending_xmitbuf_queue);
+
+	pxmitpriv->pallocated_xmitbuf = rtw_zvmalloc(NR_XMITBUFF * sizeof(struct xmit_buf) + 4);
+
+	if (pxmitpriv->pallocated_xmitbuf == NULL) {
+		res = _FAIL;
+		goto exit;
+	}
+
+	pxmitpriv->pxmitbuf = (uint8_t *)N_BYTE_ALIGMENT((SIZE_PTR)(pxmitpriv->pallocated_xmitbuf), 4);
+	/*
+	 * pxmitpriv->pxmitbuf = pxmitpriv->pallocated_xmitbuf + 4 -
+	 * 						((SIZE_PTR) (pxmitpriv->pallocated_xmitbuf) &3);
+	 */
+
+	pxmitbuf = (struct xmit_buf *)pxmitpriv->pxmitbuf;
+
+	for (i = 0; i < NR_XMITBUFF; i++) {
+		INIT_LIST_HEAD(&pxmitbuf->list);
+
+		pxmitbuf->priv_data = NULL;
+		pxmitbuf->rtlpriv = rtlpriv;
+		pxmitbuf->buf_tag = XMITBUF_DATA;
+
+		/* Tx buf allocation may fail sometimes, so sleep and retry. */
+		res = rtw_os_xmit_resource_alloc(rtlpriv, pxmitbuf, (MAX_XMITBUF_SZ + XMITBUF_ALIGN_SZ), true);
+		if (res == _FAIL) {
+			msleep(10);
+			res = rtw_os_xmit_resource_alloc(rtlpriv, pxmitbuf, (MAX_XMITBUF_SZ + XMITBUF_ALIGN_SZ), true);
+			if (res == _FAIL) {
+				goto exit;
+			}
+		}
+
+
+		pxmitbuf->flags = XMIT_VO_QUEUE;
+
+		list_add_tail(&pxmitbuf->list, &(pxmitpriv->free_xmitbuf_queue.list));
+
+		pxmitbuf++;
+
+	}
+
+	pxmitpriv->free_xmitbuf_cnt = NR_XMITBUFF;
+
+	/* init xframe_ext queue,  the same count as extbuf  */
+	_rtw_init_queue(&pxmitpriv->free_xframe_ext_queue);
+
+	pxmitpriv->xframe_ext_alloc_addr = rtw_zvmalloc(num_xmit_extbuf * sizeof(struct xmit_frame) + 4);
+
+	if (pxmitpriv->xframe_ext_alloc_addr  == NULL) {
+		pxmitpriv->xframe_ext = NULL;
+		res = _FAIL;
+		goto exit;
+	}
+	pxmitpriv->xframe_ext = (uint8_t *)N_BYTE_ALIGMENT((SIZE_PTR)(pxmitpriv->xframe_ext_alloc_addr), 4);
+	pxframe = (struct xmit_frame *)pxmitpriv->xframe_ext;
+
+	for (i = 0; i < num_xmit_extbuf; i++) {
+		INIT_LIST_HEAD(&(pxframe->list));
+
+		pxframe->rtlpriv = rtlpriv;
+		pxframe->frame_tag = NULL_FRAMETAG;
+
+		pxframe->skb = NULL;
+
+		pxframe->buf_addr = NULL;
+		pxframe->pxmitbuf = NULL;
+
+		pxframe->ext_tag = 1;
+
+		list_add_tail(&(pxframe->list), &(pxmitpriv->free_xframe_ext_queue.list));
+
+		pxframe++;
+	}
+	pxmitpriv->free_xframe_ext_cnt = num_xmit_extbuf;
+
+	/* Init xmit extension buff */
+	_rtw_init_queue(&pxmitpriv->free_xmit_extbuf_queue);
+
+	pxmitpriv->pallocated_xmit_extbuf = rtw_zvmalloc(num_xmit_extbuf * sizeof(struct xmit_buf) + 4);
+
+	if (pxmitpriv->pallocated_xmit_extbuf  == NULL) {
+		res = _FAIL;
+		goto exit;
+	}
+
+	pxmitpriv->pxmit_extbuf = (uint8_t *)N_BYTE_ALIGMENT((SIZE_PTR)(pxmitpriv->pallocated_xmit_extbuf), 4);
+
+	pxmitbuf = (struct xmit_buf *)pxmitpriv->pxmit_extbuf;
+
+	for (i = 0; i < num_xmit_extbuf; i++) {
+		INIT_LIST_HEAD(&pxmitbuf->list);
+
+		pxmitbuf->priv_data = NULL;
+		pxmitbuf->rtlpriv = rtlpriv;
+		pxmitbuf->buf_tag = XMITBUF_MGNT;
+
+		res = rtw_os_xmit_resource_alloc(rtlpriv, pxmitbuf, max_xmit_extbuf_size + XMITBUF_ALIGN_SZ, true);
+		if (res == _FAIL) {
+			res = _FAIL;
+			goto exit;
+		}
+
+
+		list_add_tail(&pxmitbuf->list, &(pxmitpriv->free_xmit_extbuf_queue.list));
+		pxmitbuf++;
+
+	}
+
+	pxmitpriv->free_xmit_extbuf_cnt = num_xmit_extbuf;
+
+
+	pxmitbuf = &pxmitpriv->pcmd_xmitbuf;
+	if (pxmitbuf) {
+		INIT_LIST_HEAD(&pxmitbuf->list);
+
+		pxmitbuf->priv_data = NULL;
+		pxmitbuf->rtlpriv = rtlpriv;
+		pxmitbuf->buf_tag = XMITBUF_CMD;
+
+		res = rtw_os_xmit_resource_alloc(rtlpriv, pxmitbuf, 0, true);
+		if (res == _FAIL) {
+			res = _FAIL;
+			goto exit;
+		}
+	}
+
+	rtw_alloc_hwxmits(rtlpriv);
+	rtw_init_hwxmits(pxmitpriv->hwxmits);
+
+	for (i = 0; i < 4; i++) {
+		pxmitpriv->wmm_para_seq[i] = i;
+	}
+
+	pxmitpriv->txirp_cnt = 1;
+
+	sema_init(&(pxmitpriv->tx_retevt), 0);
+
+	tasklet_init(&pxmitpriv->xmit_tasklet,
+	     (void(*)(unsigned long))rtl8812au_xmit_tasklet,
+	     (unsigned long)rtlpriv);
+
+
+exit:
+
+	return res;
+}
+
+
+
+void _rtw_free_xmit_priv (struct xmit_priv *pxmitpriv)
+{
+	int i;
+	struct rtl_priv *rtlpriv = pxmitpriv->rtlpriv;
+	struct xmit_frame *pxmitframe = (struct xmit_frame *) pxmitpriv->pxmit_frame_buf;
+	struct xmit_buf *pxmitbuf = (struct xmit_buf *)pxmitpriv->pxmitbuf;
+	uint32_t	 max_xmit_extbuf_size = MAX_XMIT_EXTBUF_SZ;
+	uint32_t	 num_xmit_extbuf = NR_XMIT_EXTBUFF;
+
+	if (pxmitpriv->pxmit_frame_buf == NULL)
+		goto out;
+
+	for (i = 0; i < NR_XMITFRAME; i++) {
+		rtw_os_xmit_complete(rtlpriv, pxmitframe);
+
+		pxmitframe++;
+	}
+
+	for (i = 0; i < NR_XMITBUFF; i++) {
+		rtw_os_xmit_resource_free(rtlpriv, pxmitbuf, (MAX_XMITBUF_SZ + XMITBUF_ALIGN_SZ), true);
+
+		pxmitbuf++;
+	}
+
+	if (pxmitpriv->pallocated_frame_buf) {
+		rtw_vmfree(pxmitpriv->pallocated_frame_buf);
+	}
+
+
+	if (pxmitpriv->pallocated_xmitbuf) {
+		rtw_vmfree(pxmitpriv->pallocated_xmitbuf);
+	}
+
+	/* free xframe_ext queue,  the same count as extbuf  */
+	pxmitframe = (struct xmit_frame *)pxmitpriv->xframe_ext;
+	if (pxmitframe) {
+		for (i = 0; i < num_xmit_extbuf; i++) {
+			rtw_os_xmit_complete(rtlpriv, pxmitframe);
+			pxmitframe++;
+		}
+	}
+	if (pxmitpriv->xframe_ext_alloc_addr)
+		rtw_vmfree(pxmitpriv->xframe_ext_alloc_addr);
+
+	pxmitbuf = (struct xmit_buf *)pxmitpriv->pxmit_extbuf;
+
+	for (i = 0; i < num_xmit_extbuf; i++) {
+		rtw_os_xmit_resource_free(rtlpriv, pxmitbuf, (max_xmit_extbuf_size + XMITBUF_ALIGN_SZ), true);
+
+		pxmitbuf++;
+	}
+
+	if (pxmitpriv->pallocated_xmit_extbuf) {
+		rtw_vmfree(pxmitpriv->pallocated_xmit_extbuf);
+	}
+
+	pxmitbuf = &pxmitpriv->pcmd_xmitbuf;
+	rtw_os_xmit_resource_free(rtlpriv, pxmitbuf, 0, true);
+out:
+	;
+}
+
+static void update_attrib_vcs_info(struct rtl_priv *rtlpriv, struct xmit_frame *pxmitframe)
+{
+	struct rtl_hal *rtlhal = rtl_hal(rtlpriv);
+	uint32_t	sz;
+	struct tx_pkt_attrib	*pattrib = &pxmitframe->tx_attrib;
+	/* struct sta_info	*psta = pattrib->psta; */
+	struct mlme_ext_priv	*pmlmeext = &(rtlpriv->mlmeextpriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+/*
+	if (pattrib->psta) {
+		psta = pattrib->psta;
+	} else {
+		DBG_871X("%s, call rtw_get_stainfo()\n", __func__);
+		psta=rtw_get_stainfo(&rtlpriv->stapriv ,&pattrib->ra[0] );
+	}
+
+	if (psta==NULL) {
+		DBG_871X("%s, psta==NUL\n", __func__);
+		return;
+	}
+
+	if (!(psta->state &_FW_LINKED)) {
+		DBG_871X("%s, psta->state(0x%x) != _FW_LINKED\n", __func__, psta->state);
+		return;
+	}
+*/
+
+	if (pattrib->nr_frags != 1) {
+		sz = rtlpriv->xmitpriv.frag_len;
+	} else {	/* no frag */
+		sz = pattrib->last_txcmdsz;
+	}
+
+	/*
+	 *  (1) RTS_Threshold is compared to the MPDU, not MSDU.
+	 *  (2) If there are more than one frag in  this MSDU, only the first frag uses protection frame.
+	 * 		Other fragments are protected by previous fragment.
+	 * 		So we only need to check the length of first fragment.
+	 */
+	if (pmlmeext->cur_wireless_mode < WIRELESS_11_24N) {
+		if (sz > rtlpriv->registrypriv.rts_thresh) {
+			pattrib->vcs_mode = RTS_CTS;
+		} else {
+			if (pattrib->rtsen)
+				pattrib->vcs_mode = RTS_CTS;
+			else if (pattrib->cts2self)
+				pattrib->vcs_mode = CTS_TO_SELF;
+			else
+				pattrib->vcs_mode = NONE_VCS;
+		}
+	} else {
+		while (true) {
+			/* IOT action */
+			if ((pmlmeinfo->assoc_AP_vendor == HT_IOT_PEER_ATHEROS)
+			 && (pattrib->ampdu_en == true)
+			 && (rtlpriv->securitypriv.dot11PrivacyAlgrthm == AESCCMP_ENCRYPTION)) {
+				pattrib->vcs_mode = CTS_TO_SELF;
+				break;
+			}
+
+			/* check ERP protection */
+			if (pattrib->rtsen || pattrib->cts2self) {
+				if (pattrib->rtsen)
+					pattrib->vcs_mode = RTS_CTS;
+				else if (pattrib->cts2self)
+					pattrib->vcs_mode = CTS_TO_SELF;
+
+				break;
+			}
+
+			/* check HT op mode */
+			if (pattrib->ht_en) {
+				uint8_t HTOpMode = pmlmeinfo->HT_protection;
+				if ((pmlmeext->cur_bwmode && (HTOpMode == 2 || HTOpMode == 3)) ||
+				  (!pmlmeext->cur_bwmode && HTOpMode == 3)) {
+					pattrib->vcs_mode = RTS_CTS;
+					break;
+				}
+			}
+
+			/* check rts */
+			if (sz > rtlpriv->registrypriv.rts_thresh) {
+				pattrib->vcs_mode = RTS_CTS;
+				break;
+			}
+
+			/* to do list: check MIMO power save condition. */
+
+			/* check AMPDU aggregation for TXOP */
+#if 0			/* ULLI we maqy keep this here */
+			if ((pattrib->ampdu_en == true) && (!IS_HARDWARE_TYPE_JAGUAR(rtlhal))) {
+				pattrib->vcs_mode = RTS_CTS;
+				break;
+			}
+#endif
+			pattrib->vcs_mode = NONE_VCS;
+			break;
+		}
+	}
+}
+
+static void update_attrib_phy_info(struct tx_pkt_attrib *pattrib, struct sta_info *psta)
+{
+	pattrib->rtsen = psta->rtsen;
+	pattrib->cts2self = psta->cts2self;
+
+	pattrib->mdata = 0;
+	pattrib->eosp = 0;
+	pattrib->triggered = 0;
+
+	/* qos_en, ht_en, init rate, ,bw, ch_offset, sgi */
+	pattrib->qos_en = psta->qos_option;
+
+	pattrib->raid = psta->raid;
+
+	if (psta->vhtpriv.vht_option) {
+		pattrib->bwmode = psta->vhtpriv.vht_bwmode;
+		pattrib->sgi = psta->vhtpriv.sgi;
+
+		if (TEST_FLAG(psta->vhtpriv.ldpc_cap, LDPC_VHT_ENABLE_TX))
+			pattrib->ldpc = 1;
+
+		if (TEST_FLAG(psta->vhtpriv.stbc_cap, STBC_VHT_ENABLE_TX))
+			pattrib->stbc = 1;
+	} else
+	{
+		pattrib->bwmode = psta->htpriv.bwmode;
+		pattrib->sgi = psta->htpriv.sgi;
+	}
+
+	pattrib->ht_en = psta->htpriv.ht_option;
+	pattrib->ch_offset = psta->htpriv.ch_offset;
+	pattrib->ampdu_en = false;
+	/*
+	 * if(pattrib->ht_en && psta->htpriv.ampdu_enable) {
+	 * 	if(psta->htpriv.agg_enable_bitmap & BIT(pattrib->priority))
+	 * 		pattrib->ampdu_en = true;
+	 * }
+	 */
+
+	pattrib->retry_ctrl = false;
+
+
+}
+
+static int32_t update_attrib_sec_info(struct rtl_priv *rtlpriv, struct tx_pkt_attrib *pattrib, struct sta_info *psta)
+{
+	int res = _SUCCESS;
+	struct mlme_priv	*pmlmepriv = &rtlpriv->mlmepriv;
+	struct security_priv *psecuritypriv = &rtlpriv->securitypriv;
+	int bmcast = is_multicast_ether_addr(pattrib->ra);
+
+	memset(pattrib->dot118021x_UncstKey.skey,  0, 16);
+	memset(pattrib->dot11tkiptxmickey.skey,  0, 16);
+
+	if (psta->ieee8021x_blocked == true) {
+		pattrib->encrypt = 0;
+
+		if ((pattrib->ether_type != 0x888e)
+		 && (check_fwstate(pmlmepriv, WIFI_MP_STATE) == false)) {
+			res = _FAIL;
+			goto exit;
+		}
+	} else {
+		GET_ENCRY_ALGO(psecuritypriv, psta, pattrib->encrypt, bmcast);
+
+		switch (psecuritypriv->dot11AuthAlgrthm) {
+		case dot11AuthAlgrthm_Open:
+		case dot11AuthAlgrthm_Shared:
+		case dot11AuthAlgrthm_Auto:
+			pattrib->key_idx = (uint8_t)psecuritypriv->dot11PrivacyKeyIndex;
+			break;
+		case dot11AuthAlgrthm_8021X:
+			if (bmcast)
+				pattrib->key_idx = (uint8_t)psecuritypriv->dot118021XGrpKeyid;
+			else
+				pattrib->key_idx = 0;
+			break;
+		default:
+			pattrib->key_idx = 0;
+			break;
+		}
+
+		/* For WPS 1.0 WEP, driver should not encrypt EAPOL Packet for WPS handshake. */
+		if (((pattrib->encrypt == WEP40_ENCRYPTION)
+		 || (pattrib->encrypt == WEP104_ENCRYPTION)) && (pattrib->ether_type == 0x888e))
+			pattrib->encrypt = NO_ENCRYPTION;
+
+	}
+
+	switch (pattrib->encrypt) {
+	case WEP40_ENCRYPTION:
+	case WEP104_ENCRYPTION:
+		pattrib->iv_len = 4;
+		pattrib->icv_len = 4;
+		WEP_IV(pattrib->iv, psta->dot11txpn, pattrib->key_idx);
+		break;
+
+	case TKIP_ENCRYPTION:
+		pattrib->iv_len = 8;
+		pattrib->icv_len = 4;
+
+		if (psecuritypriv->busetkipkey == _FAIL) {
+			res = _FAIL;
+			goto exit;
+		}
+
+		if (bmcast)
+			TKIP_IV(pattrib->iv, psta->dot11txpn, pattrib->key_idx);
+		else
+			TKIP_IV(pattrib->iv, psta->dot11txpn, 0);
+
+
+		memcpy(pattrib->dot11tkiptxmickey.skey, psta->dot11tkiptxmickey.skey, 16);
+
+		break;
+
+	case AESCCMP_ENCRYPTION:
+		pattrib->iv_len = 8;
+		pattrib->icv_len = 8;
+
+		if (bmcast)
+			AES_IV(pattrib->iv, psta->dot11txpn, pattrib->key_idx);
+		else
+			AES_IV(pattrib->iv, psta->dot11txpn, 0);
+
+		break;
+
+	default:
+		pattrib->iv_len = 0;
+		pattrib->icv_len = 0;
+		break;
+	}
+
+	if (pattrib->encrypt > 0)
+		memcpy(pattrib->dot118021x_UncstKey.skey, psta->dot118021x_UncstKey.skey, 16);
+
+exit:
+
+	return res;
+
+}
+
+uint8_t	qos_acm(uint8_t acm_mask, uint8_t priority)
+{
+	uint8_t	change_priority = priority;
+
+	switch (priority) {
+	case 0:
+	case 3:
+		if (acm_mask & BIT(1))
+			change_priority = 1;
+		break;
+	case 1:
+	case 2:
+		break;
+	case 4:
+	case 5:
+		if (acm_mask & BIT(2))
+			change_priority = 0;
+		break;
+	case 6:
+	case 7:
+		if (acm_mask & BIT(3))
+			change_priority = 5;
+		break;
+	default:
+		DBG_871X("qos_acm(): invalid pattrib->priority: %d!!!\n", priority);
+		break;
+	}
+
+	return change_priority;
+}
+
+static int32_t update_attrib(struct rtl_priv *rtlpriv, struct sk_buff *skb, struct tx_pkt_attrib *pattrib)
+{
+	uint i;
+	struct sta_info *psta = NULL;
+	struct ethhdr *etherhdr;
+
+	int bmcast;
+	struct sta_priv		*pstapriv = &rtlpriv->stapriv;
+	struct security_priv	*psecuritypriv = &rtlpriv->securitypriv;
+	struct mlme_priv	*pmlmepriv = &rtlpriv->mlmepriv;
+	struct qos_priv		*pqospriv = &pmlmepriv->qospriv;
+	int res = _SUCCESS;
+
+	etherhdr = (struct ethhdr *) skb->data;
+
+	pattrib->ether_type = ntohs(etherhdr->h_proto);
+
+	memcpy(pattrib->dst, &(etherhdr->h_dest), ETH_ALEN);
+	memcpy(pattrib->src, &(etherhdr->h_source), ETH_ALEN);
+
+	if ((check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true) ||
+		(check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true)) {
+		memcpy(pattrib->ra, pattrib->dst, ETH_ALEN);
+		memcpy(pattrib->ta, pattrib->src, ETH_ALEN);
+	} else if (check_fwstate(pmlmepriv, WIFI_STATION_STATE)) {
+		memcpy(pattrib->ra, get_bssid(pmlmepriv), ETH_ALEN);
+		memcpy(pattrib->ta, pattrib->src, ETH_ALEN);
+	} else if (check_fwstate(pmlmepriv, WIFI_AP_STATE)) {
+		memcpy(pattrib->ra, pattrib->dst, ETH_ALEN);
+		memcpy(pattrib->ta, get_bssid(pmlmepriv), ETH_ALEN);
+	}
+
+	pattrib->pktlen = skb->len - ETH_HLEN;
+
+	if (ETH_P_IP == pattrib->ether_type) {
+#if 0
+		/*
+		 *  The following is for DHCP and ARP packet, we use cck1M to tx these packets and let LPS awake some time
+		 *  to prevent DHCP protocol fail
+		 */
+		uint8_t tmp[24];
+		_rtw_pktfile_read(&pktfile, &tmp[0], 24);
+#endif
+		/* ULLI : get udp header */
+		struct udphdr *udp = (struct udphdr *) skb->data + ETH_HLEN + 20;
+		pattrib->dhcp_pkt = 0;
+
+		if (pattrib->pktlen > 282) {	/* MINIMUM_DHCP_PACKET_SIZE) { */
+			if (ETH_P_IP == pattrib->ether_type) {
+				/* IP header */
+				if (((udp->source == 68) && (udp->dest == 67)) ||
+				    ((udp->source == 67) && (udp->dest == 68))) {
+					/* 68 : UDP BOOTP client */
+					/* 67 : UDP BOOTP server */
+					/*
+					 * Use low rate to send DHCP packet.
+					 * if(pMgntInfo->IOTAction & HT_IOT_ACT_WA_IOT_Broadcom) {
+					 * 	tcb_desc->DataRate = MgntQuery_TxRateExcludeCCKRates(ieee);//0xc;//ofdm 6m
+					 * 	tcb_desc->bTxDisableRateFallBack = false;
+					 * } else
+					 * 	pTcb->DataRate = rtlpriv->MgntInfo.LowestBasicRate;
+					 * RTPRINT(FDM, WA_IOT, ("DHCP TranslateHeader(), pTcb->DataRate = 0x%x\n", pTcb->DataRate));
+					 */
+					pattrib->dhcp_pkt = 1;
+				}
+			}
+		}
+	} else if (0x888e == pattrib->ether_type) {
+		DBG_871X_LEVEL(_drv_always_, "send eapol packet\n");
+	}
+
+	/* If EAPOL , ARP , OR DHCP packet, driver must be in active mode. */
+	if ((pattrib->ether_type == 0x0806) || (pattrib->ether_type == 0x888e) || (pattrib->dhcp_pkt == 1)) {
+		rtw_lps_ctrl_wk_cmd(rtlpriv, LPS_CTRL_SPECIAL_PACKET, 1);
+	}
+
+	bmcast = is_multicast_ether_addr(pattrib->ra);
+
+	/* get sta_info */
+	if (bmcast) {
+		psta = rtw_get_bcmc_stainfo(rtlpriv);
+	} else {
+		psta = rtw_get_stainfo(pstapriv, pattrib->ra);
+		if (psta == NULL) {	/* if we cannot get psta => drrp the pkt */
+			res = _FAIL;
+			goto exit;
+		} else if ((check_fwstate(pmlmepriv, WIFI_AP_STATE) == true) && (!(psta->state & _FW_LINKED))) {
+			res = _FAIL;
+			goto exit;
+		}
+	}
+
+	if (psta == NULL) {	/* if we cannot get psta => drop the pkt */
+		res = _FAIL;
+		goto exit;
+	}
+
+	if (!(psta->state & _FW_LINKED))	{
+		DBG_871X("%s, psta("MAC_FMT")->state(0x%x) != _FW_LINKED\n", __func__, MAC_ARG(psta->hwaddr), psta->state);
+		return _FAIL;
+	}
+
+
+
+	/* TODO:spinlock_t */
+	if (update_attrib_sec_info(rtlpriv, pattrib, psta) == _FAIL) {
+		res = _FAIL;
+		goto exit;
+	}
+
+	update_attrib_phy_info(pattrib, psta);
+
+	pattrib->mac_id = psta->mac_id;
+	/* DBG_8192C("%s ==> mac_id(%d)\n",__FUNCTION__,pattrib->mac_id ); */
+
+	pattrib->psta = psta;
+	/* TODO:_unlock */
+
+	pattrib->pctrl = 0;
+
+	pattrib->ack_policy = 0;
+	/* get ether_hdr_len */
+	pattrib->pkt_hdrlen = ETH_HLEN; /*(pattrib->ether_type == 0x8100) ? (14 + 4 ): 14; //vlan tag */
+
+	pattrib->hdrlen = WLAN_HDR_A3_LEN;
+	pattrib->subtype = WIFI_DATA_TYPE;
+	pattrib->tx_priority = 0;
+
+	if (check_fwstate(pmlmepriv, WIFI_AP_STATE|WIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE)) {
+		if (pattrib->qos_en)
+			set_qos(skb, pattrib);
+	} else {
+		if (pqospriv->qos_option) {
+			set_qos(skb, pattrib);
+
+			if (pmlmepriv->acm_mask != 0) {
+				pattrib->tx_priority = qos_acm(pmlmepriv->acm_mask, pattrib->tx_priority);
+			}
+		}
+	}
+
+	/* pattrib->priority = 5; //force to used VI queue, for testing */
+
+	if (pattrib->encrypt &&
+	    ((rtlpriv->securitypriv.sw_encrypt == true) || (psecuritypriv->hw_decrypted == false))) {
+		pattrib->bswenc = true;
+	} else {
+		pattrib->bswenc = false;
+	}
+
+	rtw_set_tx_chksum_offload(skb, pattrib);
+
+exit:
+
+	return res;
+}
+
+static int32_t xmitframe_addmic(struct rtl_priv *rtlpriv, struct xmit_frame *pxmitframe)
+{
+	int curfragnum, length;
+	uint8_t	*pframe, *payload, mic[8];
+	struct	mic_data		micdata;
+	/* struct	sta_info		*stainfo; */
+	struct	qos_priv   *pqospriv = &(rtlpriv->mlmepriv.qospriv);
+	struct	tx_pkt_attrib	 *pattrib = &pxmitframe->tx_attrib;
+	struct 	security_priv	*psecuritypriv = &rtlpriv->securitypriv;
+	struct	xmit_priv		*pxmitpriv = &rtlpriv->xmitpriv;
+	uint8_t priority[4] = {0x0, 0x0, 0x0, 0x0};
+	uint8_t hw_hdr_offset = 0;
+	int bmcst = is_multicast_ether_addr(pattrib->ra);
+
+/*
+	if(pattrib->psta)
+	{
+		stainfo = pattrib->psta;
+	}
+	else
+	{
+		DBG_871X("%s, call rtw_get_stainfo()\n", __func__);
+		stainfo=rtw_get_stainfo(&rtlpriv->stapriv ,&pattrib->ra[0]);
+	}
+
+	if(stainfo==NULL)
+	{
+		DBG_871X("%s, psta==NUL\n", __func__);
+		return _FAIL;
+	}
+
+	if(!(stainfo->state &_FW_LINKED))
+	{
+		DBG_871X("%s, psta->state(0x%x) != _FW_LINKED\n", __func__, stainfo->state);
+		return _FAIL;
+	}
+*/
+
+	hw_hdr_offset = TXDESC_SIZE + (pxmitframe->pkt_offset * PACKET_OFFSET_SZ);;
+
+	if (pattrib->encrypt == TKIP_ENCRYPTION) {	/* if(psecuritypriv->dot11PrivacyAlgrthm==_TKIP_PRIVACY_) */
+		/*
+		 * encode mic code
+		 * if(stainfo!= NULL)
+		 */
+		{
+			uint8_t null_key[16] = {
+				0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
+				0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 };
+
+			pframe = pxmitframe->buf_addr + hw_hdr_offset;
+
+			if (bmcst) {
+				if (_rtw_memcmp(psecuritypriv->dot118021XGrptxmickey[psecuritypriv->dot118021XGrpKeyid].skey, null_key, 16) == true) {
+					/*
+					 * DbgPrint("\nxmitframe_addmic:stainfo->dot11tkiptxmickey==0\n");
+					 * msleep(10);
+					 */
+					return _FAIL;
+				}
+				/* start to calculate the mic code */
+				rtw_secmicsetkey(&micdata, psecuritypriv->dot118021XGrptxmickey[psecuritypriv->dot118021XGrpKeyid].skey);
+			} else 	{
+				if (_rtw_memcmp(&pattrib->dot11tkiptxmickey.skey[0], null_key, 16) == true) {
+					/*
+					 * DbgPrint("\nxmitframe_addmic:stainfo->dot11tkiptxmickey==0\n");
+					 * msleep(10);
+					 */
+					return _FAIL;
+				}
+				/* start to calculate the mic code */
+				rtw_secmicsetkey(&micdata, &pattrib->dot11tkiptxmickey.skey[0]);
+			}
+
+			if (pframe[1] & 1) {	/* ToDS==1 */
+				rtw_secmicappend(&micdata, &pframe[16], 6);  /* DA */
+				if (pframe[1] & 2)  /* From Ds==1 */
+					rtw_secmicappend(&micdata, &pframe[24], 6);
+				else
+					rtw_secmicappend(&micdata, &pframe[10], 6);
+			} else {	/* ToDS==0 */
+				rtw_secmicappend(&micdata, &pframe[4], 6);   /* DA */
+				if (pframe[1]&2)  /* From Ds==1 */
+					rtw_secmicappend(&micdata, &pframe[16], 6);
+				else
+					rtw_secmicappend(&micdata, &pframe[10], 6);
+
+			}
+
+			/* if(pqospriv->qos_option==1) */
+			if (pattrib->qos_en)
+				priority[0] = (uint8_t)pxmitframe->tx_attrib.tx_priority;
+
+
+			rtw_secmicappend(&micdata, &priority[0], 4);
+
+			payload = pframe;
+
+			for (curfragnum = 0; curfragnum < pattrib->nr_frags; curfragnum++) {
+				payload = (uint8_t *)RND4((SIZE_PTR)(payload));
+
+				payload = payload+pattrib->hdrlen+pattrib->iv_len;
+				if ((curfragnum+1) == pattrib->nr_frags) {
+					length = pattrib->last_txcmdsz-pattrib->hdrlen-pattrib->iv_len-((pattrib->bswenc) ? pattrib->icv_len : 0);
+					rtw_secmicappend(&micdata, payload, length);
+					payload = payload + length;
+				} else {
+					length = pxmitpriv->frag_len-pattrib->hdrlen-pattrib->iv_len-((pattrib->bswenc) ? pattrib->icv_len : 0);
+					rtw_secmicappend(&micdata, payload, length);
+					payload = payload + length+pattrib->icv_len;
+				}
+			}
+			rtw_secgetmic(&micdata, &(mic[0]));
+
+			memcpy(payload, &(mic[0]), 8);
+			pattrib->last_txcmdsz += 8;
+
+			payload = payload-pattrib->last_txcmdsz + 8;
+			for (curfragnum = 0; curfragnum < pattrib->last_txcmdsz; curfragnum = curfragnum + 8)
+				;
+			}
+/*
+			else{
+				RT_TRACE(_module_rtl871x_xmit_c_,_drv_err_,("xmitframe_addmic: rtw_get_stainfo==NULL!!!\n"));
+			}
+*/
+	}
+
+
+
+	return _SUCCESS;
+}
+
+static int32_t xmitframe_swencrypt(struct rtl_priv *rtlpriv, struct xmit_frame *pxmitframe)
+{
+	struct	tx_pkt_attrib	 *pattrib = &pxmitframe->tx_attrib;
+	/* struct 	security_priv	*psecuritypriv=&rtlpriv->securitypriv; */
+
+	/* if((psecuritypriv->sw_encrypt)||(pattrib->bswenc)) */
+	if (pattrib->bswenc) {
+		/* DBG_871X("start xmitframe_swencrypt\n"); */
+		switch (pattrib->encrypt) {
+		case WEP40_ENCRYPTION:
+		case WEP104_ENCRYPTION:
+			rtw_wep_encrypt(rtlpriv, (uint8_t *)pxmitframe);
+			break;
+		case TKIP_ENCRYPTION:
+			rtw_tkip_encrypt(rtlpriv, (uint8_t *)pxmitframe);
+			break;
+		case AESCCMP_ENCRYPTION:
+			rtw_aes_encrypt(rtlpriv, (uint8_t *)pxmitframe);
+			break;
+		default:
+				break;
+		}
+
+	} else {
+		;
+	}
+
+	return _SUCCESS;
+}
+
+int32_t rtw_make_wlanhdr (struct rtl_priv *rtlpriv , uint8_t *hdr, struct tx_pkt_attrib *pattrib)
+{
+	u16 *qc;
+
+	struct rtw_ieee80211_hdr *pwlanhdr = (struct rtw_ieee80211_hdr *)hdr;
+	struct mlme_priv *pmlmepriv = &rtlpriv->mlmepriv;
+	struct qos_priv *pqospriv = &pmlmepriv->qospriv;
+	uint8_t qos_option = false;
+
+	int res = _SUCCESS;
+	u16 *fctrl = &pwlanhdr->frame_ctl;
+
+	/* struct sta_info *psta; */
+
+	/* int bmcst = is_multicast_ether_addr(pattrib->ra); */
+
+
+
+/*
+	psta = rtw_get_stainfo(&rtlpriv->stapriv, pattrib->ra);
+	if(pattrib->psta != psta)
+	{
+		DBG_871X("%s, pattrib->psta(%p) != psta(%p)\n", __func__, pattrib->psta, psta);
+		return;
+	}
+
+	if(psta==NULL)
+	{
+		DBG_871X("%s, psta==NUL\n", __func__);
+		return _FAIL;
+	}
+
+	if(!(psta->state &_FW_LINKED))
+	{
+		DBG_871X("%s, psta->state(0x%x) != _FW_LINKED\n", __func__, psta->state);
+		return _FAIL;
+	}
+*/
+
+	memset(hdr, 0, WLANHDR_OFFSET);
+
+	SetFrameSubType(fctrl, pattrib->subtype);
+
+	if (pattrib->subtype & WIFI_DATA_TYPE) {
+		if ((check_fwstate(pmlmepriv,  WIFI_STATION_STATE) == true)) {
+			/* to_ds = 1, fr_ds = 0; */
+			{
+				/* Data transfer to AP */
+				SetToDs(fctrl);
+				memcpy(pwlanhdr->addr1, get_bssid(pmlmepriv), ETH_ALEN);
+				memcpy(pwlanhdr->addr2, pattrib->src, ETH_ALEN);
+				memcpy(pwlanhdr->addr3, pattrib->dst, ETH_ALEN);
+			}
+
+			if (pqospriv->qos_option)
+				qos_option = true;
+
+		} else if ((check_fwstate(pmlmepriv,  WIFI_AP_STATE) == true)) {
+			/* to_ds = 0, fr_ds = 1; */
+			SetFrDs(fctrl);
+			memcpy(pwlanhdr->addr1, pattrib->dst, ETH_ALEN);
+			memcpy(pwlanhdr->addr2, get_bssid(pmlmepriv), ETH_ALEN);
+			memcpy(pwlanhdr->addr3, pattrib->src, ETH_ALEN);
+
+			if (pattrib->qos_en)
+				qos_option = true;
+		} else if ((check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true)
+		    || (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true)) {
+			memcpy(pwlanhdr->addr1, pattrib->dst, ETH_ALEN);
+			memcpy(pwlanhdr->addr2, pattrib->src, ETH_ALEN);
+			memcpy(pwlanhdr->addr3, get_bssid(pmlmepriv), ETH_ALEN);
+
+			if (pattrib->qos_en)
+				qos_option = true;
+		} else {
+			res = _FAIL;
+			goto exit;
+		}
+
+		if (pattrib->mdata)
+			SetMData(fctrl);
+
+		if (pattrib->encrypt)
+			SetPrivacy(fctrl);
+
+		if (qos_option) {
+			qc = (unsigned short *)(hdr + pattrib->hdrlen - 2);
+
+			if (pattrib->tx_priority)
+				SetPriority(qc, pattrib->tx_priority);
+
+			SetEOSP(qc, pattrib->eosp);
+
+			SetAckpolicy(qc, pattrib->ack_policy);
+		}
+
+		/* TODO: fill HT Control Field */
+
+		/* Update Seq Num will be handled by f/w */
+		{
+			struct sta_info *psta;
+			psta = rtw_get_stainfo(&rtlpriv->stapriv, pattrib->ra);
+			if (pattrib->psta != psta) {
+				DBG_871X("%s, pattrib->psta(%p) != psta(%p)\n", __func__, pattrib->psta, psta);
+				return _FAIL;
+			}
+
+			if (psta == NULL) {
+				DBG_871X("%s, psta==NUL\n", __func__);
+				return _FAIL;
+			}
+
+			if (!(psta->state & _FW_LINKED)) {
+				DBG_871X("%s, psta->state(0x%x) != _FW_LINKED\n", __func__, psta->state);
+				return _FAIL;
+			}
+
+			/* if(psta) */
+			{
+
+				psta->sta_xmitpriv.txseq_tid[pattrib->tx_priority]++;
+				psta->sta_xmitpriv.txseq_tid[pattrib->tx_priority] &= 0xFFF;
+
+				pattrib->seqnum = psta->sta_xmitpriv.txseq_tid[pattrib->tx_priority];
+
+				SetSeqNum(hdr, pattrib->seqnum);
+
+				/* check if enable ampdu */
+				if (pattrib->ht_en && psta->htpriv.ampdu_enable) {
+					if (psta->htpriv.agg_enable_bitmap & BIT(pattrib->tx_priority))
+					pattrib->ampdu_en = true;
+				}
+
+				/* re-check if enable ampdu by BA_starting_seqctrl */
+				if (pattrib->ampdu_en == true) 	{
+					u16 tx_seq;
+
+					tx_seq = psta->BA_starting_seqctrl[pattrib->tx_priority & 0x0f];
+
+					/* check BA_starting_seqctrl */
+					if (SN_LESS(pattrib->seqnum, tx_seq)) {
+						/* DBG_871X("tx ampdu seqnum(%d) < tx_seq(%d)\n", pattrib->seqnum, tx_seq); */
+						pattrib->ampdu_en = false;	/* AGG BK */
+					} else if (SN_EQUAL(pattrib->seqnum, tx_seq)) {
+						psta->BA_starting_seqctrl[pattrib->tx_priority & 0x0f] = (tx_seq+1)&0xfff;
+
+						pattrib->ampdu_en = true;	/* AGG EN */
+					} else 	{
+						/* DBG_871X("tx ampdu over run\n"); */
+						psta->BA_starting_seqctrl[pattrib->tx_priority & 0x0f] = (pattrib->seqnum+1)&0xfff;
+						pattrib->ampdu_en = true;	/* AGG EN */
+					}
+
+				}
+			}
+		}
+
+	} else {
+
+	}
+
+exit:
+
+	return res;
+}
+
+int32_t rtw_txframes_pending(struct rtl_priv *rtlpriv)
+{
+	struct xmit_priv *pxmitpriv = &rtlpriv->xmitpriv;
+
+	return (!list_empty(&pxmitpriv->be_pending.list) ||
+		!list_empty(&pxmitpriv->bk_pending.list) ||
+		!list_empty(&pxmitpriv->vi_pending.list) ||
+		!list_empty(&pxmitpriv->vo_pending.list));
+}
+
+bool rtw_txframes_sta_ac_pending(struct rtl_priv *rtlpriv, struct tx_pkt_attrib *pattrib)
+{
+	struct sta_info *psta;
+	struct tx_servq *ptxservq;
+	int priority = pattrib->tx_priority;
+/*
+	if(pattrib->psta)
+	{
+		psta = pattrib->psta;
+	}
+	else
+	{
+		DBG_871X("%s, call rtw_get_stainfo()\n", __func__);
+		psta=rtw_get_stainfo(&rtlpriv->stapriv ,&pattrib->ra[0]);
+	}
+*/
+	psta = rtw_get_stainfo(&rtlpriv->stapriv, pattrib->ra);
+	if (pattrib->psta != psta) {
+		DBG_871X("%s, pattrib->psta(%p) != psta(%p)\n", __func__, pattrib->psta, psta);
+		return 0;
+	}
+
+	if (psta == NULL) {
+		DBG_871X("%s, psta==NUL\n", __func__);
+		return 0;
+	}
+
+	if (!(psta->state & _FW_LINKED)) {
+		DBG_871X("%s, psta->state(0x%x) != _FW_LINKED\n", __func__, psta->state);
+		return 0;
+	}
+
+	switch (priority) {
+	case 1:
+	case 2:
+		ptxservq = &(psta->sta_xmitpriv.bk_q);
+		break;
+	case 4:
+	case 5:
+		ptxservq = &(psta->sta_xmitpriv.vi_q);
+		break;
+	case 6:
+	case 7:
+		ptxservq = &(psta->sta_xmitpriv.vo_q);
+		break;
+	case 0:
+	case 3:
+	default:
+		ptxservq = &(psta->sta_xmitpriv.be_q);
+	break;
+
+	}
+
+	/* ULLI : return true if !list_empty() */
+
+	return list_empty (&(ptxservq->sta_pending.list)) ? false : true;
+}
+
+/*
+ * Calculate wlan 802.11 packet MAX size from pkt_attrib
+ * This function doesn't consider fragment case
+ */
+uint32_t	 rtw_calculate_wlan_pkt_size_by_attribue(struct tx_pkt_attrib *pattrib)
+{
+	uint32_t	len = 0;
+
+	len = pattrib->hdrlen + pattrib->iv_len;	/* WLAN Header and IV */
+	len += SNAP_SIZE + sizeof(u16);		/* LLC */
+	len += pattrib->pktlen;
+	if (pattrib->encrypt == TKIP_ENCRYPTION)
+		len += 8;	/* MIC */
+	len += ((pattrib->bswenc) ? pattrib->icv_len : 0);	/* ICV */
+
+	return len;
+}
+
+/*
+
+This sub-routine will perform all the following:
+
+1. remove 802.3 header.
+2. create wlan_header, based on the info in pxmitframe
+3. append sta's iv/ext-iv
+4. append LLC
+5. move frag chunk from pframe to pxmitframe->mem
+6. apply sw-encrypt, if necessary.
+
+*/
+int32_t rtw_xmitframe_coalesce(struct rtl_priv *rtlpriv, struct sk_buff *skb,
+			       struct xmit_frame *pxmitframe)
+{
+	struct pkt_file pktfile;
+	int32_t frg_inx, frg_len, mpdu_len, llc_sz, mem_sz;
+	__kernel_size_t addr;
+	u8 *mem_start;
+	u8 hw_hdr_offset;
+	struct xmit_priv	*pxmitpriv = &rtlpriv->xmitpriv;
+	struct tx_pkt_attrib	*pattrib = &pxmitframe->tx_attrib;
+	uint8_t *pbuf_start;
+	int32_t res = _SUCCESS;
+
+	if (pxmitframe->buf_addr == NULL) {
+		DBG_8192C("==> %s buf_addr==NULL \n", __FUNCTION__);
+		return _FAIL;
+	}
+
+	pbuf_start = pxmitframe->buf_addr;
+	hw_hdr_offset =  TXDESC_SIZE + (pxmitframe->pkt_offset * PACKET_OFFSET_SZ);
+	mem_start = pbuf_start + hw_hdr_offset;
+
+	if (rtw_make_wlanhdr(rtlpriv, mem_start, pattrib) == _FAIL) {
+		DBG_8192C("rtw_xmitframe_coalesce: rtw_make_wlanhdr fail; drop pkt\n");
+		res = _FAIL;
+		goto exit;
+	}
+
+	_rtw_open_pktfile(skb, &pktfile);
+	_rtw_pktfile_read(&pktfile, NULL, pattrib->pkt_hdrlen);
+
+	frg_inx = 0;
+	frg_len = pxmitpriv->frag_len - 4;	/* 2346-4 = 2342 */
+
+	while (1) {
+		u8 *pframe;
+		llc_sz = 0;
+
+		mpdu_len = frg_len;
+
+		pframe = mem_start;
+
+		SetMFrag(mem_start);
+
+		pframe += pattrib->hdrlen;
+		mpdu_len -= pattrib->hdrlen;
+
+		/* adding icv, if necessary... */
+		if (pattrib->iv_len) {
+			memcpy(pframe, pattrib->iv, pattrib->iv_len);
+			pframe += pattrib->iv_len;
+			mpdu_len -= pattrib->iv_len;
+		}
+
+		if (frg_inx == 0) {
+			llc_sz = rtw_put_snap(pframe, pattrib->ether_type);
+			pframe += llc_sz;
+			mpdu_len -= llc_sz;
+		}
+
+		if ((pattrib->icv_len > 0) && (pattrib->bswenc)) {
+			mpdu_len -= pattrib->icv_len;
+		}
+
+
+		if (is_multicast_ether_addr(pattrib->ra)) {
+			/* don't do fragment to broadcat/multicast packets */
+			mem_sz = _rtw_pktfile_read(&pktfile, pframe, pattrib->pktlen);
+		} else {
+			mem_sz = _rtw_pktfile_read(&pktfile, pframe, mpdu_len);
+		}
+
+		pframe += mem_sz;
+
+		if ((pattrib->icv_len > 0) && (pattrib->bswenc)) {
+			memcpy(pframe, pattrib->icv, pattrib->icv_len);
+			pframe += pattrib->icv_len;
+		}
+
+		frg_inx++;
+
+		if (is_multicast_ether_addr(pattrib->ra) || (rtw_endofpktfile(&pktfile) == true)) {
+			pattrib->nr_frags = frg_inx;
+
+			pattrib->last_txcmdsz = pattrib->hdrlen + pattrib->iv_len + ((pattrib->nr_frags == 1) ? llc_sz : 0) +
+					((pattrib->bswenc) ? pattrib->icv_len : 0) + mem_sz;
+
+			ClearMFrag(mem_start);
+
+			break;
+		} else {
+			;
+		}
+
+		addr = (SIZE_PTR)(pframe);
+
+		mem_start = (unsigned char *)RND4(addr) + hw_hdr_offset;
+		memcpy(mem_start, pbuf_start + hw_hdr_offset, pattrib->hdrlen);
+
+	}
+
+	if (xmitframe_addmic(rtlpriv, pxmitframe) == _FAIL) {
+		DBG_8192C("xmitframe_addmic(rtlpriv, pxmitframe)==_FAIL\n");
+		res = _FAIL;
+		goto exit;
+	}
+
+	xmitframe_swencrypt(rtlpriv, pxmitframe);
+
+	if (is_multicast_ether_addr(pattrib->ra) == false)
+		update_attrib_vcs_info(rtlpriv, pxmitframe);
+	else
+		pattrib->vcs_mode = NONE_VCS;
+
+exit:
+
+	return res;
+}
+
+/* Logical Link Control(LLC) SubNetwork Attachment Point(SNAP) header
+ * IEEE LLC/SNAP header contains 8 octets
+ * First 3 octets comprise the LLC portion
+ * SNAP portion, 5 octets, is divided into two fields:
+ *	Organizationally Unique Identifier(OUI), 3 octets,
+ *	type, defined by that organization, 2 octets.
+ */
+int32_t rtw_put_snap(uint8_t *data, u16 h_proto)
+{
+	struct ieee80211_snap_hdr *snap;
+	uint8_t *oui;
+
+	snap = (struct ieee80211_snap_hdr *)data;
+	snap->dsap = 0xaa;
+	snap->ssap = 0xaa;
+	snap->ctrl = 0x03;
+
+	if (h_proto == 0x8137 || h_proto == 0x80f3)
+		oui = P802_1H_OUI;
+	else
+		oui = RFC1042_OUI;
+
+	snap->oui[0] = oui[0];
+	snap->oui[1] = oui[1];
+	snap->oui[2] = oui[2];
+
+	*(u16 *)(data + SNAP_SIZE) = htons(h_proto);
+
+	return SNAP_SIZE + sizeof(u16);
+}
+
+void rtw_update_protection(struct rtl_priv *rtlpriv, uint8_t *ie, uint ie_len)
+{
+
+	uint	protection;
+	uint8_t	*perp;
+	int	 erp_len;
+	struct	xmit_priv *pxmitpriv = &rtlpriv->xmitpriv;
+	struct	registry_priv *pregistrypriv = &rtlpriv->registrypriv;
+
+	switch (pxmitpriv->vcs_setting) {
+	case DISABLE_VCS:
+		pxmitpriv->vcs = NONE_VCS;
+		break;
+
+	case ENABLE_VCS:
+		break;
+
+	case AUTO_VCS:
+	default:
+		perp = rtw_get_ie(ie, _ERPINFO_IE_, &erp_len, ie_len);
+		if (perp == NULL) {
+			pxmitpriv->vcs = NONE_VCS;
+		} else {
+			protection = (*(perp + 2)) & BIT(1);
+			if (protection) {
+				if (RTS_CTS == RTS_CTS)
+					pxmitpriv->vcs = RTS_CTS;
+				else
+					pxmitpriv->vcs = CTS_TO_SELF;
+			} else
+				pxmitpriv->vcs = NONE_VCS;
+		}
+
+		break;
+
+	}
+
+}
+
+void rtw_count_tx_stats(struct rtl_priv *rtlpriv, struct xmit_frame *pxmitframe, int sz)
+{
+	struct sta_info *psta = NULL;
+	struct stainfo_stats *pstats = NULL;
+	struct xmit_priv	*pxmitpriv = &rtlpriv->xmitpriv;
+	struct mlme_priv	*pmlmepriv = &rtlpriv->mlmepriv;
+
+	if ((pxmitframe->frame_tag&0x0f) == DATA_FRAMETAG) {
+		pxmitpriv->tx_bytes += sz;
+		pmlmepriv->LinkDetectInfo.NumTxOkInPeriod += pxmitframe->agg_num;
+
+		psta = pxmitframe->tx_attrib.psta;
+		if (psta) {
+			pstats = &psta->sta_stats;
+			pstats->tx_pkts += pxmitframe->agg_num;
+			pstats->tx_bytes += sz;
+		}
+	}
+}
+
+struct xmit_buf *rtw_alloc_cmd_xmitbuf(struct xmit_priv *pxmitpriv, uint32_t	 buffsize)
+{
+	struct xmit_buf *pxmitbuf =  NULL;
+
+	pxmitbuf = &pxmitpriv->pcmd_xmitbuf;
+
+	if (pxmitbuf !=  NULL) {
+		if (rtw_os_xmit_resource_alloc(pxmitpriv->rtlpriv, pxmitbuf, (buffsize + XMITBUF_ALIGN_SZ), false) == _FAIL) {
+			return NULL;
+		}
+
+		pxmitbuf->alloc_sz = buffsize + XMITBUF_ALIGN_SZ;
+
+		pxmitbuf->priv_data = NULL;
+
+
+		if (pxmitbuf->sctx) {
+			DBG_871X("%s pxmitbuf->sctx is not NULL\n", __func__);
+			rtw_sctx_done_err(&pxmitbuf->sctx, RTW_SCTX_DONE_BUF_ALLOC);
+		}
+	} else {
+		DBG_871X("%s fail, no xmitbuf available !!!\n", __func__);
+	}
+
+	return pxmitbuf;
+}
+
+int32_t	rtw_free_cmd_xmitbuf(struct xmit_priv *pxmitpriv)
+{
+	struct xmit_buf *pxmitbuf =  NULL;
+
+	pxmitbuf = &pxmitpriv->pcmd_xmitbuf;
+	if (pxmitbuf == NULL) {
+		DBG_871X("%s fail, no xmitbuf available !!!\n", __func__);
+		return _FAIL;
+	} else {
+		rtw_os_xmit_resource_free(pxmitbuf->rtlpriv, pxmitbuf, pxmitbuf->alloc_sz, false);
+	}
+
+	return _SUCCESS;
+}
+
+struct xmit_frame *rtw_alloc_cmdxmitframe(struct xmit_priv *pxmitpriv, uint32_t	 buffsize)
+{
+	struct xmit_frame		*pcmdframe;
+	struct xmit_buf		*pxmitbuf;
+
+	pcmdframe = rtw_alloc_xmitframe(pxmitpriv);
+	if (pcmdframe == NULL) {
+		DBG_871X("%s, alloc xmitframe fail\n", __FUNCTION__);
+		return NULL;
+	}
+
+	pxmitbuf = rtw_alloc_cmd_xmitbuf(pxmitpriv, buffsize);
+	if (pxmitbuf == NULL) {
+		DBG_871X("%s, alloc xmitbuf fail\n", __FUNCTION__);
+		rtw_free_xmitframe(pxmitpriv, pcmdframe);
+		return NULL;
+	}
+
+	pcmdframe->frame_tag = MGNT_FRAMETAG;
+
+	pcmdframe->pxmitbuf = pxmitbuf;
+
+	pcmdframe->buf_addr = pxmitbuf->pbuf;
+
+	pxmitbuf->priv_data = pcmdframe;
+
+	return pcmdframe;
+
+}
+
+void	rtw_free_cmdxmitframe(struct xmit_priv *pxmitpriv, struct xmit_frame *pxmitframe)
+{
+	rtw_free_xmitframe(pxmitpriv, pxmitframe);
+	rtw_free_cmd_xmitbuf(pxmitpriv);
+}
+
+struct xmit_buf *rtw_alloc_xmitbuf_ext(struct xmit_priv *pxmitpriv)
+{
+	unsigned long flags;
+	struct xmit_buf *pxmitbuf =  NULL;
+	struct list_head *plist, *phead;
+	struct __queue *pfree_queue = &pxmitpriv->free_xmit_extbuf_queue;
+
+	spin_lock_irqsave(&pfree_queue->lock, flags);
+
+	if (list_empty(&pfree_queue->list)) {
+		pxmitbuf = NULL;
+	} else {
+
+		phead = get_list_head(pfree_queue);
+
+		plist = get_next(phead);
+
+		pxmitbuf = container_of(plist, struct xmit_buf, list);
+
+		list_del_init(&(pxmitbuf->list));
+	}
+
+	if (pxmitbuf !=  NULL) {
+		pxmitpriv->free_xmit_extbuf_cnt--;
+
+
+		pxmitbuf->priv_data = NULL;
+
+
+		if (pxmitbuf->sctx) {
+			DBG_871X("%s pxmitbuf->sctx is not NULL\n", __func__);
+			rtw_sctx_done_err(&pxmitbuf->sctx, RTW_SCTX_DONE_BUF_ALLOC);
+		}
+
+	}
+
+	spin_unlock_irqrestore(&pfree_queue->lock, flags);
+
+	return pxmitbuf;
+}
+
+int32_t rtw_free_xmitbuf_ext(struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf)
+{
+	unsigned long flags;
+	struct __queue *pfree_queue = &pxmitpriv->free_xmit_extbuf_queue;
+
+	if (pxmitbuf == NULL) {
+		return _FAIL;
+	}
+
+	spin_lock_irqsave(&pfree_queue->lock, flags);
+
+	list_del_init(&pxmitbuf->list);
+
+	list_add_tail(&(pxmitbuf->list), get_list_head(pfree_queue));
+	pxmitpriv->free_xmit_extbuf_cnt++;
+
+	spin_unlock_irqrestore(&pfree_queue->lock, flags);
+
+	return _SUCCESS;
+}
+
+struct xmit_buf *rtw_alloc_xmitbuf(struct xmit_priv *pxmitpriv)
+{
+	unsigned long flags;
+	struct xmit_buf *pxmitbuf =  NULL;
+	struct list_head *plist, *phead;
+	struct __queue *pfree_xmitbuf_queue = &pxmitpriv->free_xmitbuf_queue;
+
+	/* DBG_871X("+rtw_alloc_xmitbuf\n"); */
+
+	spin_lock_irqsave(&pfree_xmitbuf_queue->lock, flags);
+
+	if (list_empty(&pfree_xmitbuf_queue->list)) {
+		pxmitbuf = NULL;
+	} else {
+
+		phead = get_list_head(pfree_xmitbuf_queue);
+
+		plist = get_next(phead);
+
+		pxmitbuf = container_of(plist, struct xmit_buf, list);
+
+		list_del_init(&(pxmitbuf->list));
+	}
+
+	if (pxmitbuf !=  NULL) {
+		pxmitpriv->free_xmitbuf_cnt--;
+		/* DBG_871X("alloc, free_xmitbuf_cnt=%d\n", pxmitpriv->free_xmitbuf_cnt); */
+
+		pxmitbuf->priv_data = NULL;
+
+
+		if (pxmitbuf->sctx) {
+			DBG_871X("%s pxmitbuf->sctx is not NULL\n", __func__);
+			rtw_sctx_done_err(&pxmitbuf->sctx, RTW_SCTX_DONE_BUF_ALLOC);
+		}
+	}
+
+	spin_unlock_irqrestore(&pfree_xmitbuf_queue->lock, flags);
+
+	return pxmitbuf;
+}
+
+int32_t rtw_free_xmitbuf(struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf)
+{
+	unsigned long flags;
+	struct __queue *pfree_xmitbuf_queue = &pxmitpriv->free_xmitbuf_queue;
+
+	/* DBG_871X("+rtw_free_xmitbuf\n"); */
+
+	if (pxmitbuf == NULL) {
+		return _FAIL;
+	}
+
+	if (pxmitbuf->sctx) {
+		DBG_871X("%s pxmitbuf->sctx is not NULL\n", __func__);
+		rtw_sctx_done_err(&pxmitbuf->sctx, RTW_SCTX_DONE_BUF_FREE);
+	}
+
+	if (pxmitbuf->buf_tag == XMITBUF_CMD) {
+		;
+	} else if (pxmitbuf->buf_tag == XMITBUF_MGNT) {
+		rtw_free_xmitbuf_ext(pxmitpriv, pxmitbuf);
+	} else {
+		spin_lock_irqsave(&pfree_xmitbuf_queue->lock, flags);
+
+		list_del_init(&pxmitbuf->list);
+
+		list_add_tail(&(pxmitbuf->list), get_list_head(pfree_xmitbuf_queue));
+
+		pxmitpriv->free_xmitbuf_cnt++;
+		/* DBG_871X("FREE, free_xmitbuf_cnt=%d\n", pxmitpriv->free_xmitbuf_cnt); */
+		spin_unlock_irqrestore(&pfree_xmitbuf_queue->lock, flags);
+	}
+
+	return _SUCCESS;
+}
+
+void rtw_init_xmitframe(struct xmit_frame *pxframe)
+{
+	if (pxframe !=  NULL) {		/* default value setting */
+		pxframe->buf_addr = NULL;
+		pxframe->pxmitbuf = NULL;
+
+		memset(&pxframe->tx_attrib, 0, sizeof(struct tx_pkt_attrib));
+		/* pxframe->attrib.psta = NULL; */
+
+		pxframe->frame_tag = DATA_FRAMETAG;
+
+		pxframe->skb = NULL;
+		pxframe->pkt_offset = 1;	/*default use pkt_offset to fill tx desc */
+
+		pxframe->agg_num = 1;
+	}
+}
+
+/*
+Calling context:
+1. OS_TXENTRY
+2. RXENTRY (rx_thread or RX_ISR/RX_CallBack)
+
+If we turn on USE_RXTHREAD, then, no need for critical section.
+Otherwise, we must use _enter/_exit critical to protect free_xmit_queue...
+
+Must be very very cautious...
+
+*/
+struct xmit_frame *rtw_alloc_xmitframe(struct xmit_priv *pxmitpriv)	/* (struct __queue *pfree_xmit_queue) */
+{
+	/*
+		Please remember to use all the osdep_service api,
+		and lock/unlock or _enter/_exit critical to protect
+		pfree_xmit_queue
+	*/
+
+	struct xmit_frame *pxframe = NULL;
+	struct list_head *plist, *phead;
+	struct __queue *pfree_xmit_queue = &pxmitpriv->free_xmit_queue;
+
+	spin_lock_bh(&pfree_xmit_queue->lock);
+
+	if (list_empty(&pfree_xmit_queue->list)) {
+		pxframe =  NULL;
+	} else {
+		phead = get_list_head(pfree_xmit_queue);
+
+		plist = get_next(phead);
+
+		pxframe = container_of(plist, struct xmit_frame, list);
+
+		list_del_init(&(pxframe->list));
+		pxmitpriv->free_xmitframe_cnt--;
+	}
+
+	spin_unlock_bh(&pfree_xmit_queue->lock);
+
+	rtw_init_xmitframe(pxframe);
+
+	return pxframe;
+}
+
+struct xmit_frame *rtw_alloc_xmitframe_ext(struct xmit_priv *pxmitpriv)
+{
+	struct xmit_frame *pxframe = NULL;
+	struct list_head *plist, *phead;
+	struct __queue *queue = &pxmitpriv->free_xframe_ext_queue;
+
+	spin_lock_bh(&queue->lock);
+
+	if (list_empty(&queue->list)) {
+		pxframe =  NULL;
+	} else {
+		phead = get_list_head(queue);
+		plist = get_next(phead);
+		pxframe = container_of(plist, struct xmit_frame, list);
+
+		list_del_init(&(pxframe->list));
+		pxmitpriv->free_xframe_ext_cnt--;
+	}
+
+	spin_unlock_bh(&queue->lock);
+
+	rtw_init_xmitframe(pxframe);
+
+	return pxframe;
+}
+
+struct xmit_frame *rtw_alloc_xmitframe_once(struct xmit_priv *pxmitpriv)
+{
+	struct xmit_frame *pxframe = NULL;
+	uint8_t *alloc_addr;
+
+	alloc_addr = rtw_zmalloc(sizeof(struct xmit_frame) + 4);
+
+	if (alloc_addr == NULL)
+		goto exit;
+
+	pxframe = (struct xmit_frame *)N_BYTE_ALIGMENT((SIZE_PTR)(alloc_addr), 4);
+	pxframe->alloc_addr = alloc_addr;
+
+	pxframe->rtlpriv = pxmitpriv->rtlpriv;
+	pxframe->frame_tag = NULL_FRAMETAG;
+
+	pxframe->skb = NULL;
+
+	pxframe->buf_addr = NULL;
+	pxframe->pxmitbuf = NULL;
+
+	rtw_init_xmitframe(pxframe);
+
+	DBG_871X("################## %s ##################\n", __func__);
+
+exit:
+	return pxframe;
+}
+
+int32_t rtw_free_xmitframe(struct xmit_priv *pxmitpriv, struct xmit_frame *pxmitframe)
+{
+	struct __queue *queue;
+	struct rtl_priv *rtlpriv = pxmitpriv->rtlpriv;
+	struct sk_buff *skb = NULL;
+
+	if (pxmitframe == NULL) {
+		goto exit;
+	}
+
+	if (pxmitframe->skb) {
+		skb = pxmitframe->skb;
+		pxmitframe->skb = NULL;
+	}
+
+	if (pxmitframe->alloc_addr) {
+		DBG_871X("################## %s with alloc_addr ##################\n", __func__);
+		rtw_mfree(pxmitframe->alloc_addr);
+		goto check_pkt_complete;
+	}
+
+	if (pxmitframe->ext_tag == 0)
+		queue = &pxmitpriv->free_xmit_queue;
+	else if (pxmitframe->ext_tag == 1)
+		queue = &pxmitpriv->free_xframe_ext_queue;
+	else {
+	}
+
+	spin_lock_bh(&queue->lock);
+
+	list_del_init(&pxmitframe->list);
+	list_add_tail(&pxmitframe->list, get_list_head(queue));
+	if (pxmitframe->ext_tag == 0) {
+		pxmitpriv->free_xmitframe_cnt++;
+	} else if (pxmitframe->ext_tag == 1) {
+		pxmitpriv->free_xframe_ext_cnt++;
+	} else {
+		;
+	}
+
+	spin_unlock_bh(&queue->lock);
+
+check_pkt_complete:
+
+	if (skb)
+		rtw_os_pkt_complete(rtlpriv, skb);
+
+exit:
+
+	return _SUCCESS;
+}
+
+void rtw_free_xmitframe_queue(struct xmit_priv *pxmitpriv, struct __queue *pframequeue)
+{
+	struct list_head	*plist, *phead;
+	struct	xmit_frame 	*pxmitframe;
+
+	spin_lock_bh(&(pframequeue->lock));
+
+	phead = get_list_head(pframequeue);
+	plist = get_next(phead);
+
+	while (rtw_end_of_queue_search(phead, plist) == false) {
+
+		pxmitframe = container_of(plist, struct xmit_frame, list);
+
+		plist = get_next(plist);
+
+		rtw_free_xmitframe(pxmitpriv, pxmitframe);
+
+	}
+	spin_unlock_bh(&(pframequeue->lock));
+
+}
+
+
+int32_t rtw_xmitframe_enqueue(struct rtl_priv *rtlpriv, struct xmit_frame *pxmitframe)
+{
+	if (rtw_xmit_classifier(rtlpriv, pxmitframe) == _FAIL) {
+/*		pxmitframe->pkt = NULL; */
+		return _FAIL;
+	}
+
+	return _SUCCESS;
+}
+
+
+static struct xmit_frame *dequeue_one_xmitframe(struct xmit_priv *pxmitpriv, struct hw_xmit *phwxmit, struct tx_servq *ptxservq, struct __queue *pframe_queue)
+{
+	struct list_head	*xmitframe_plist, *xmitframe_phead;
+	struct	xmit_frame	*pxmitframe = NULL;
+
+	xmitframe_phead = get_list_head(pframe_queue);
+	xmitframe_plist = get_next(xmitframe_phead);
+
+	while ((rtw_end_of_queue_search(xmitframe_phead, xmitframe_plist)) == false) {
+		pxmitframe = container_of(xmitframe_plist, struct xmit_frame, list);
+
+		xmitframe_plist = get_next(xmitframe_plist);
+
+		list_del_init(&pxmitframe->list);
+
+		/* list_add_tail(&pxmitframe->list, &phwxmit->pending); */
+
+		/* ptxservq->qcnt--; */
+
+		break;
+
+		/* ULLI : stupid break ?? */
+		pxmitframe = NULL;
+
+	}
+
+	return pxmitframe;
+}
+
+struct xmit_frame *rtw_dequeue_xframe(struct xmit_priv *pxmitpriv, struct hw_xmit *phwxmit_i)
+{
+	struct list_head *sta_plist, *sta_phead;
+	struct hw_xmit *phwxmit;
+	struct tx_servq *ptxservq = NULL;
+	struct __queue *pframe_queue = NULL;
+	struct xmit_frame *pxmitframe = NULL;
+	struct rtl_priv *rtlpriv = pxmitpriv->rtlpriv;
+	struct registry_priv	*pregpriv = &rtlpriv->registrypriv;
+	int i, inx[4];
+
+	inx[0] = 0; inx[1] = 1; inx[2] = 2; inx[3] = 3;
+
+	spin_lock_bh(&pxmitpriv->lock);
+
+	for (i = 0; i < HWXMIT_ENTRY; i++) {
+		phwxmit = phwxmit_i + inx[i];
+
+		/* spin_lock_irqsave(&phwxmit->sta_queue->lock, &irqL0); */
+
+		sta_phead = get_list_head(phwxmit->sta_queue);
+		sta_plist = get_next(sta_phead);
+
+		while ((rtw_end_of_queue_search(sta_phead, sta_plist)) == false) {
+
+			ptxservq = container_of(sta_plist, struct tx_servq, tx_pending);
+
+			pframe_queue = &ptxservq->sta_pending;
+
+			pxmitframe = dequeue_one_xmitframe(pxmitpriv, phwxmit, ptxservq, pframe_queue);
+
+			if (pxmitframe) {
+				/* Remove sta node when there is no pending packets. */
+				if (list_empty(&pframe_queue->list))	/* must be done after get_next and before break */
+					list_del_init(&ptxservq->tx_pending);
+
+				/* spin_unlock_irqrestore(&phwxmit->sta_queue->lock, &irqL0); */
+
+				goto exit;
+			}
+
+			sta_plist = get_next(sta_plist);
+
+		}
+
+		/* spin_unlock_irqrestore(&phwxmit->sta_queue->lock, &irqL0); */
+
+	}
+
+exit:
+
+	spin_unlock_bh(&pxmitpriv->lock);
+
+	return pxmitframe;
+}
+
+static struct tx_servq *rtw_get_sta_pending(struct rtl_priv *rtlpriv, struct sta_info *psta, int up, uint8_t *ac)
+{
+	struct tx_servq *ptxservq = NULL;
+
+	switch (up) {
+	case 1:
+	case 2:
+		ptxservq = &(psta->sta_xmitpriv.bk_q);
+		*(ac) = 3;
+		break;
+
+	case 4:
+	case 5:
+		ptxservq = &(psta->sta_xmitpriv.vi_q);
+		*(ac) = 1;
+		break;
+
+	case 6:
+	case 7:
+		ptxservq = &(psta->sta_xmitpriv.vo_q);
+		*(ac) = 0;
+		break;
+
+	case 0:
+	case 3:
+	default:
+		ptxservq = &(psta->sta_xmitpriv.be_q);
+		*(ac) = 2;
+	break;
+
+	}
+
+	return ptxservq;
+}
+
+/*
+ * Will enqueue pxmitframe to the proper queue,
+ * and indicate it to xx_pending list.....
+ */
+int32_t rtw_xmit_classifier(struct rtl_priv *rtlpriv, struct xmit_frame *pxmitframe)
+{
+	/* _irqL irqL0; */
+	uint8_t	ac_index;
+	struct sta_info	*psta;
+	struct tx_servq	*ptxservq;
+	struct tx_pkt_attrib	*pattrib = &pxmitframe->tx_attrib;
+	struct sta_priv	*pstapriv = &rtlpriv->stapriv;
+	struct hw_xmit	*phwxmits =  rtlpriv->xmitpriv.hwxmits;
+	int res = _SUCCESS;
+
+/*
+	if (pattrib->psta) {
+		psta = pattrib->psta;
+	} else {
+		DBG_871X("%s, call rtw_get_stainfo()\n", __func__);
+		psta = rtw_get_stainfo(pstapriv, pattrib->ra);
+	}
+*/
+
+	psta = rtw_get_stainfo(&rtlpriv->stapriv, pattrib->ra);
+	if (pattrib->psta != psta) {
+		DBG_871X("%s, pattrib->psta(%p) != psta(%p)\n", __func__, pattrib->psta, psta);
+		return _FAIL;
+	}
+
+	if (psta == NULL) {
+		res = _FAIL;
+		DBG_8192C("rtw_xmit_classifier: psta == NULL\n");
+		goto exit;
+	}
+
+	if (!(psta->state & _FW_LINKED)) {
+		DBG_871X("%s, psta->state(0x%x) != _FW_LINKED\n", __func__, psta->state);
+		return _FAIL;
+	}
+
+	ptxservq = rtw_get_sta_pending(rtlpriv, psta, pattrib->tx_priority, (uint8_t *)(&ac_index));
+
+	/* spin_lock_irqsave(&pstapending->lock, &irqL0); */
+
+	if (list_empty(&ptxservq->tx_pending)) {
+		list_add_tail(&ptxservq->tx_pending, get_list_head(phwxmits[ac_index].sta_queue));
+	}
+
+	/* spin_lock_irqsave(&ptxservq->sta_pending.lock, &irqL1); */
+
+	list_add_tail(&pxmitframe->list, get_list_head(&ptxservq->sta_pending));
+
+	/* spin_unlock_irqrestore(&ptxservq->sta_pending.lock, &irqL1); */
+
+	/* spin_unlock_irqrestore(&pstapending->lock, &irqL0); */
+
+exit:
+
+	return res;
+}
+
+void rtw_alloc_hwxmits(struct rtl_priv *rtlpriv)
+{
+	struct hw_xmit *hwxmits;
+	struct xmit_priv *pxmitpriv = &rtlpriv->xmitpriv;
+
+	hwxmits = pxmitpriv->hwxmits;
+
+		/* pxmitpriv->vo_txqueue.head = 0; */
+		/* hwxmits[0] .phwtxqueue = &pxmitpriv->vo_txqueue; */
+		hwxmits[0].sta_queue = &pxmitpriv->vo_pending;
+
+		/* pxmitpriv->vi_txqueue.head = 0; */
+		/* hwxmits[1] .phwtxqueue = &pxmitpriv->vi_txqueue; */
+		hwxmits[1].sta_queue = &pxmitpriv->vi_pending;
+
+		/* pxmitpriv->be_txqueue.head = 0; */
+		/* hwxmits[2] .phwtxqueue = &pxmitpriv->be_txqueue; */
+		hwxmits[2].sta_queue = &pxmitpriv->be_pending;
+
+		/* pxmitpriv->bk_txqueue.head = 0; */
+		/* hwxmits[3] .phwtxqueue = &pxmitpriv->bk_txqueue; */
+		hwxmits[3].sta_queue = &pxmitpriv->bk_pending;
+}
+
+
+void rtw_init_hwxmits(struct hw_xmit *phwxmit)
+{
+	int i;
+	for (i = 0; i < HWXMIT_ENTRY; i++, phwxmit++) {
+		/*
+		 * spin_lock_init(&phwxmit->xmit_lock);
+		 * INIT_LIST_HEAD(&phwxmit->pending);
+		 * phwxmit->txcmdcnt = 0;
+		 */
+	}
+}
+
+
+static void do_queue_select(struct rtl_priv *rtlpriv, struct tx_pkt_attrib *pattrib)
+{
+	uint8_t qsel;
+
+	qsel = pattrib->tx_priority;
+
+	pattrib->tx_qsel = qsel;
+}
+
+/*
+ * The main transmit(tx) entry
+ *
+ * Return
+ *	1	enqueue
+ *	0	success, hardware will handle this xmit frame(packet)
+ *	<0	fail
+ */
+int32_t rtw_xmit(struct rtl_priv *rtlpriv, struct sk_buff **ppkt)
+{
+	static uint32_t	 start = 0;
+	static uint32_t	 drop_cnt = 0;
+#ifdef CONFIG_AP_MODE
+#endif
+	struct xmit_priv *pxmitpriv = &rtlpriv->xmitpriv;
+	struct xmit_frame *pxmitframe = NULL;
+
+	int32_t res;
+
+	if (start == 0)
+		start = jiffies;
+
+	pxmitframe = rtw_alloc_xmitframe(pxmitpriv);
+
+	if (rtw_get_passing_time_ms(start) > 2000) {
+		if (drop_cnt)
+			DBG_871X("DBG_TX_DROP_FRAME %s no more pxmitframe, drop_cnt:%u\n", __FUNCTION__, drop_cnt);
+		start = jiffies;
+		drop_cnt = 0;
+	}
+
+	if (pxmitframe == NULL) {
+		drop_cnt++;
+		return -1;
+	}
+
+	res = update_attrib(rtlpriv, *ppkt, &pxmitframe->tx_attrib);
+
+	if (res == _FAIL) {
+		rtw_free_xmitframe(pxmitpriv, pxmitframe);
+		return -1;
+	}
+	pxmitframe->skb = *ppkt;
+	do_queue_select(rtlpriv, &pxmitframe->tx_attrib);
+
+#ifdef CONFIG_AP_MODE
+	spin_lock_bh(&pxmitpriv->lock);
+	if (xmitframe_enqueue_for_sleeping_sta(rtlpriv, pxmitframe) == true) {
+		spin_unlock_bh(&pxmitpriv->lock);
+		return 1;
+	}
+	spin_unlock_bh(&pxmitpriv->lock);
+#endif
+
+	if (rtlpriv->cfg->ops->hal_xmit(rtlpriv, pxmitframe) == false)
+		return 1;
+
+	return 0;
+}
+
+
+#if defined(CONFIG_AP_MODE)
+
+int xmitframe_enqueue_for_sleeping_sta(struct rtl_priv *rtlpriv, struct xmit_frame *pxmitframe)
+{
+	int ret = false;
+	struct sta_info *psta = NULL;
+	struct sta_priv *pstapriv = &rtlpriv->stapriv;
+	struct tx_pkt_attrib *pattrib = &pxmitframe->tx_attrib;
+	struct mlme_priv *pmlmepriv = &rtlpriv->mlmepriv;
+	int bmcst = is_multicast_ether_addr(pattrib->ra);
+
+	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == false)
+	    return ret;
+/*
+	if(pattrib->psta)
+	{
+		psta = pattrib->psta;
+	}
+	else
+	{
+		DBG_871X("%s, call rtw_get_stainfo()\n", __func__);
+		psta=rtw_get_stainfo(pstapriv, pattrib->ra);
+	}
+*/
+	psta = rtw_get_stainfo(&rtlpriv->stapriv, pattrib->ra);
+	if (pattrib->psta != psta) {
+		DBG_871X("%s, pattrib->psta(%p) != psta(%p)\n", __func__, pattrib->psta, psta);
+		return false;
+	}
+
+	if (psta == NULL) {
+		DBG_871X("%s, psta==NUL\n", __func__);
+		return false;
+	}
+
+	if (!(psta->state & _FW_LINKED)) {
+		DBG_871X("%s, psta->state(0x%x) != _FW_LINKED\n", __func__, psta->state);
+		return false;
+	}
+
+	if (pattrib->triggered == 1) {
+		/* DBG_871X("directly xmit pspoll_triggered packet\n"); */
+
+		/* pattrib->triggered=0; */
+
+		if (bmcst)
+			pattrib->tx_qsel = 0x11;	/* HIQ */
+
+
+		return ret;
+	}
+
+
+	if (bmcst) {
+		spin_lock_bh(&psta->sleep_q.lock);
+
+		if (pstapriv->sta_dz_bitmap) {
+			/* if anyone sta is in ps mode */
+
+			/* pattrib->qsel = 0x11;//HIQ */
+
+			list_del_init(&pxmitframe->list);
+
+			/* spin_lock_bh(&psta->sleep_q.lock, &irqL); */
+
+			list_add_tail(&pxmitframe->list, get_list_head(&psta->sleep_q));
+
+			psta->sleepq_len++;
+
+			pstapriv->tim_bitmap |= BIT(0);
+			pstapriv->sta_dz_bitmap |= BIT(0);
+
+			/* DBG_871X("enqueue, sq_len=%d, tim=%x\n", psta->sleepq_len, pstapriv->tim_bitmap); */
+
+			update_beacon(rtlpriv, _TIM_IE_, NULL, false);	/* tx bc/mc packets after upate bcn */
+
+			/* spin_unlock_bh(&psta->sleep_q.lock, &irqL); */
+
+			ret = true;
+
+		}
+
+		spin_unlock_bh(&psta->sleep_q.lock);
+
+		return ret;
+
+	}
+
+
+	spin_lock_bh(&psta->sleep_q.lock);
+
+	if (psta->state & WIFI_SLEEP_STATE) {
+		uint8_t wmmps_ac = 0;
+
+		if (pstapriv->sta_dz_bitmap&BIT(psta->aid)) {
+			list_del_init(&pxmitframe->list);
+
+			/*spin_lock_bh(&psta->sleep_q.lock, &irqL); */
+
+			list_add_tail(&pxmitframe->list, get_list_head(&psta->sleep_q));
+
+			psta->sleepq_len++;
+
+			switch (pattrib->tx_priority) {
+			case 1:
+			case 2:
+				wmmps_ac = psta->uapsd_bk&BIT(0);
+				break;
+			case 4:
+			case 5:
+				wmmps_ac = psta->uapsd_vi&BIT(0);
+				break;
+			case 6:
+			case 7:
+				wmmps_ac = psta->uapsd_vo&BIT(0);
+				break;
+			case 0:
+			case 3:
+			default:
+				wmmps_ac = psta->uapsd_be&BIT(0);
+				break;
+			}
+
+			if (wmmps_ac)
+				psta->sleepq_ac_len++;
+
+			if (((psta->has_legacy_ac) && (!wmmps_ac)) || ((!psta->has_legacy_ac) && (wmmps_ac))) {
+				pstapriv->tim_bitmap |= BIT(psta->aid);
+
+				/* DBG_871X("enqueue, sq_len=%d, tim=%x\n", psta->sleepq_len, pstapriv->tim_bitmap); */
+
+				if (psta->sleepq_len == 1) {
+					/* DBG_871X("sleepq_len==1, update BCNTIM\n"); */
+					/* upate BCN for TIM IE */
+					update_beacon(rtlpriv, _TIM_IE_, NULL, false);
+				}
+			}
+
+			/*spin_unlock_bh(&psta->sleep_q.lock, &irqL); */
+
+			/*
+			 * if(psta->sleepq_len > (NR_XMITFRAME>>3)) {
+			 *	wakeup_sta_to_xmit(rtlpriv, psta);
+			 * }
+			 */
+
+			ret = true;
+
+		}
+
+	}
+
+	spin_unlock_bh(&psta->sleep_q.lock);
+
+	return ret;
+
+}
+
+static void dequeue_xmitframes_to_sleeping_queue(struct rtl_priv *rtlpriv, struct sta_info *psta, struct __queue *pframequeue)
+{
+	int ret;
+	struct list_head	*plist, *phead;
+	uint8_t	ac_index;
+	struct tx_servq	*ptxservq;
+	struct tx_pkt_attrib	*pattrib;
+	struct xmit_frame 	*pxmitframe;
+	struct hw_xmit *phwxmits =  rtlpriv->xmitpriv.hwxmits;
+
+	phead = get_list_head(pframequeue);
+	plist = get_next(phead);
+
+	while (rtw_end_of_queue_search(phead, plist) == false) {
+		pxmitframe = container_of(plist, struct xmit_frame, list);
+
+		plist = get_next(plist);
+
+		ret = xmitframe_enqueue_for_sleeping_sta(rtlpriv, pxmitframe);
+
+		if (true == ret) {
+			pattrib = &pxmitframe->tx_attrib;
+
+			ptxservq = rtw_get_sta_pending(rtlpriv, psta, pattrib->tx_priority, (uint8_t *)(&ac_index));
+		} else 	{
+			/* DBG_871X("xmitframe_enqueue_for_sleeping_sta return false\n"); */
+		}
+
+	}
+
+}
+
+void stop_sta_xmit(struct rtl_priv *rtlpriv, struct sta_info *psta)
+{
+	struct sta_info *psta_bmc;
+	struct sta_xmit_priv *pstaxmitpriv;
+	struct sta_priv *pstapriv = &rtlpriv->stapriv;
+	struct xmit_priv *pxmitpriv = &rtlpriv->xmitpriv;
+
+	pstaxmitpriv = &psta->sta_xmitpriv;
+
+	/* for BC/MC Frames */
+	psta_bmc = rtw_get_bcmc_stainfo(rtlpriv);
+
+
+	spin_lock_bh(&pxmitpriv->lock);
+
+	psta->state |= WIFI_SLEEP_STATE;
+
+	pstapriv->sta_dz_bitmap |= BIT(psta->aid);
+
+	dequeue_xmitframes_to_sleeping_queue(rtlpriv, psta, &pstaxmitpriv->vo_q.sta_pending);
+	list_del_init(&(pstaxmitpriv->vo_q.tx_pending));
+
+
+	dequeue_xmitframes_to_sleeping_queue(rtlpriv, psta, &pstaxmitpriv->vi_q.sta_pending);
+	list_del_init(&(pstaxmitpriv->vi_q.tx_pending));
+
+
+	dequeue_xmitframes_to_sleeping_queue(rtlpriv, psta, &pstaxmitpriv->be_q.sta_pending);
+	list_del_init(&(pstaxmitpriv->be_q.tx_pending));
+
+
+	dequeue_xmitframes_to_sleeping_queue(rtlpriv, psta, &pstaxmitpriv->bk_q.sta_pending);
+	list_del_init(&(pstaxmitpriv->bk_q.tx_pending));
+
+	/* for BC/MC Frames */
+	pstaxmitpriv = &psta_bmc->sta_xmitpriv;
+	dequeue_xmitframes_to_sleeping_queue(rtlpriv, psta_bmc, &pstaxmitpriv->be_q.sta_pending);
+	list_del_init(&(pstaxmitpriv->be_q.tx_pending));
+
+	spin_unlock_bh(&pxmitpriv->lock);
+
+
+}
+
+void wakeup_sta_to_xmit(struct rtl_priv *rtlpriv, struct sta_info *psta)
+{
+	uint8_t update_mask = 0, wmmps_ac = 0;
+	struct sta_info *psta_bmc;
+	struct list_head	*xmitframe_plist, *xmitframe_phead;
+	struct xmit_frame *pxmitframe = NULL;
+	struct sta_priv *pstapriv = &rtlpriv->stapriv;
+	struct xmit_priv *pxmitpriv = &rtlpriv->xmitpriv;
+
+	psta_bmc = rtw_get_bcmc_stainfo(rtlpriv);
+
+	/* spin_lock_bh(&psta->sleep_q.lock, &irqL); */
+	spin_lock_bh(&pxmitpriv->lock);
+
+	xmitframe_phead = get_list_head(&psta->sleep_q);
+	xmitframe_plist = get_next(xmitframe_phead);
+
+	while ((rtw_end_of_queue_search(xmitframe_phead, xmitframe_plist)) == false) {
+		pxmitframe = container_of(xmitframe_plist, struct xmit_frame, list);
+
+		xmitframe_plist = get_next(xmitframe_plist);
+
+		list_del_init(&pxmitframe->list);
+
+		switch (pxmitframe->tx_attrib.tx_priority) {
+		case 1:
+		case 2:
+			wmmps_ac = psta->uapsd_bk&BIT(1);
+			break;
+		case 4:
+		case 5:
+			wmmps_ac = psta->uapsd_vi&BIT(1);
+			break;
+		case 6:
+		case 7:
+			wmmps_ac = psta->uapsd_vo&BIT(1);
+			break;
+		case 0:
+		case 3:
+		default:
+			wmmps_ac = psta->uapsd_be&BIT(1);
+			break;
+		}
+
+		psta->sleepq_len--;
+		if (psta->sleepq_len > 0)
+			pxmitframe->tx_attrib.mdata = 1;
+		else
+			pxmitframe->tx_attrib.mdata = 0;
+
+		if (wmmps_ac) {
+			psta->sleepq_ac_len--;
+			if (psta->sleepq_ac_len > 0) {
+				pxmitframe->tx_attrib.mdata = 1;
+				pxmitframe->tx_attrib.eosp = 0;
+			} else {
+				pxmitframe->tx_attrib.mdata = 0;
+				pxmitframe->tx_attrib.eosp = 1;
+			}
+		}
+
+		pxmitframe->tx_attrib.triggered = 1;
+
+/*
+		spin_unlock_bh(&psta->sleep_q.lock, &irqL);
+		if(rtw_hal_xmit(rtlpriv, pxmitframe) == true)
+		{
+			rtw_os_xmit_complete(rtlpriv, pxmitframe);
+		}
+		spin_lock_bh(&psta->sleep_q.lock, &irqL);
+*/
+		rtlpriv->cfg->ops->hal_xmitframe_enqueue(rtlpriv, pxmitframe);
+
+
+	}
+
+	/* for BC/MC Frames */
+	if (!psta_bmc)
+		goto _exit;
+
+	if ((pstapriv->sta_dz_bitmap & 0xfffe) == 0x0) {
+		/* no any sta in ps mode */
+
+		xmitframe_phead = get_list_head(&psta_bmc->sleep_q);
+		xmitframe_plist = get_next(xmitframe_phead);
+
+		while ((rtw_end_of_queue_search(xmitframe_phead, xmitframe_plist)) == false) {
+			pxmitframe = container_of(xmitframe_plist, struct xmit_frame, list);
+
+			xmitframe_plist = get_next(xmitframe_plist);
+
+			list_del_init(&pxmitframe->list);
+
+			psta_bmc->sleepq_len--;
+			if (psta_bmc->sleepq_len > 0)
+				pxmitframe->tx_attrib.mdata = 1;
+			else
+				pxmitframe->tx_attrib.mdata = 0;
+
+
+			pxmitframe->tx_attrib.triggered = 1;
+/*
+			spin_unlock_bh(&psta_bmc->sleep_q.lock, &irqL);
+			if(rtw_hal_xmit(rtlpriv, pxmitframe) == true)
+			{
+				rtw_os_xmit_complete(rtlpriv, pxmitframe);
+			}
+			spin_lock_bh(&psta_bmc->sleep_q.lock, &irqL);
+
+*/
+			rtlpriv->cfg->ops->hal_xmitframe_enqueue(rtlpriv, pxmitframe);
+
+		}
+
+		if (psta_bmc->sleepq_len == 0) {
+			pstapriv->tim_bitmap &= ~BIT(0);
+			pstapriv->sta_dz_bitmap &= ~BIT(0);
+
+			/* DBG_871X("wakeup to xmit, qlen==0, update_BCNTIM, tim=%x\n", pstapriv->tim_bitmap); */
+			/* upate BCN for TIM IE */
+			/* update_BCNTIM(rtlpriv); */
+			update_mask |= BIT(1);
+		}
+
+	}
+
+	if (psta->sleepq_len == 0) {
+		pstapriv->tim_bitmap &= ~BIT(psta->aid);
+
+		/* DBG_871X("wakeup to xmit, qlen==0, update_BCNTIM, tim=%x\n", pstapriv->tim_bitmap); */
+		/* upate BCN for TIM IE */
+		/* update_BCNTIM(rtlpriv); */
+		update_mask = BIT(0);
+
+		if (psta->state & WIFI_SLEEP_STATE)
+			psta->state ^= WIFI_SLEEP_STATE;
+
+		if (psta->state & WIFI_STA_ALIVE_CHK_STATE) {
+			psta->expire_to = pstapriv->expire_to;
+			psta->state ^= WIFI_STA_ALIVE_CHK_STATE;
+		}
+
+		pstapriv->sta_dz_bitmap &= ~BIT(psta->aid);
+	}
+
+_exit:
+
+	/*spin_unlock_bh(&psta_bmc->sleep_q.lock, &irqL); */
+	spin_unlock_bh(&pxmitpriv->lock);
+
+	if (update_mask) {
+		/* update_BCNTIM(rtlpriv); */
+		/* printk("%s => call update_beacon\n",__FUNCTION__); */
+		update_beacon(rtlpriv, _TIM_IE_, NULL, false);
+	}
+
+}
+
+void xmit_delivery_enabled_frames(struct rtl_priv *rtlpriv, struct sta_info *psta)
+{
+	uint8_t wmmps_ac = 0;
+	struct list_head *xmitframe_plist, *xmitframe_phead;
+	struct xmit_frame *pxmitframe = NULL;
+	struct sta_priv *pstapriv = &rtlpriv->stapriv;
+	struct xmit_priv *pxmitpriv = &rtlpriv->xmitpriv;
+
+	/* spin_lock_bh(&psta->sleep_q.lock, &irqL); */
+	spin_lock_bh(&pxmitpriv->lock);
+
+	xmitframe_phead = get_list_head(&psta->sleep_q);
+	xmitframe_plist = get_next(xmitframe_phead);
+
+	while ((rtw_end_of_queue_search(xmitframe_phead, xmitframe_plist)) == false) {
+		pxmitframe = container_of(xmitframe_plist, struct xmit_frame, list);
+
+		xmitframe_plist = get_next(xmitframe_plist);
+
+		switch (pxmitframe->tx_attrib.tx_priority) {
+		case 1:
+		case 2:
+			wmmps_ac = psta->uapsd_bk&BIT(1);
+			break;
+		case 4:
+		case 5:
+			wmmps_ac = psta->uapsd_vi&BIT(1);
+			break;
+		case 6:
+		case 7:
+			wmmps_ac = psta->uapsd_vo&BIT(1);
+			break;
+		case 0:
+		case 3:
+		default:
+			wmmps_ac = psta->uapsd_be&BIT(1);
+			break;
+		}
+
+		if (!wmmps_ac)
+			continue;
+
+		list_del_init(&pxmitframe->list);
+
+		psta->sleepq_len--;
+		psta->sleepq_ac_len--;
+
+		if (psta->sleepq_ac_len > 0) {
+			pxmitframe->tx_attrib.mdata = 1;
+			pxmitframe->tx_attrib.eosp = 0;
+		} else {
+			pxmitframe->tx_attrib.mdata = 0;
+			pxmitframe->tx_attrib.eosp = 1;
+		}
+
+		pxmitframe->tx_attrib.triggered = 1;
+
+/*
+		if(rtw_hal_xmit(rtlpriv, pxmitframe) == true)
+		{
+			rtw_os_xmit_complete(rtlpriv, pxmitframe);
+		}
+*/
+		rtlpriv->cfg->ops->hal_xmitframe_enqueue(rtlpriv, pxmitframe);
+
+		if ((psta->sleepq_ac_len == 0) && (!psta->has_legacy_ac) && (wmmps_ac)) {
+			pstapriv->tim_bitmap &= ~BIT(psta->aid);
+
+			/* DBG_871X("wakeup to xmit, qlen==0, update_BCNTIM, tim=%x\n", pstapriv->tim_bitmap); */
+			/* upate BCN for TIM IE */
+			/* update_BCNTIM(rtlpriv); */
+			update_beacon(rtlpriv, _TIM_IE_, NULL, false);
+			/* update_mask = BIT(0); */
+		}
+
+	}
+
+	/* spin_unlock_bh(&psta->sleep_q.lock, &irqL); */
+	spin_unlock_bh(&pxmitpriv->lock);
+
+}
+
+#endif
+
+
+void rtw_sctx_init(struct submit_ctx *sctx, int timeout_ms)
+{
+	sctx->timeout_ms = timeout_ms;
+	sctx->submit_time = jiffies;
+
+	init_completion(&sctx->done);
+
+	sctx->status = RTW_SCTX_SUBMITTED;
+}
+
+int rtw_sctx_wait(struct submit_ctx *sctx)
+{
+	int ret = _FAIL;
+	unsigned long expire;
+	int status = 0;
+
+	expire = sctx->timeout_ms ? msecs_to_jiffies(sctx->timeout_ms) : MAX_SCHEDULE_TIMEOUT;
+	if (!wait_for_completion_timeout(&sctx->done, expire)) {
+		/* timeout, do something?? */
+		status = RTW_SCTX_DONE_TIMEOUT;
+		DBG_871X("%s timeout\n", __func__);
+	} else {
+		status = sctx->status;
+	}
+
+	if (status == RTW_SCTX_DONE_SUCCESS) {
+		ret = _SUCCESS;
+	}
+
+	return ret;
+}
+
+bool rtw_sctx_chk_waring_status(int status)
+{
+	switch (status) {
+	case RTW_SCTX_DONE_UNKNOWN:
+	case RTW_SCTX_DONE_BUF_ALLOC:
+	case RTW_SCTX_DONE_BUF_FREE:
+
+	case RTW_SCTX_DONE_DRV_STOP:
+	case RTW_SCTX_DONE_DEV_REMOVE:
+		return true;
+	default:
+		return false;
+	}
+}
+
+void rtw_sctx_done_err(struct submit_ctx **sctx, int status)
+{
+	if (*sctx) {
+		if (rtw_sctx_chk_waring_status(status))
+			DBG_871X("%s status:%d\n", __func__, status);
+		(*sctx)->status = status;
+
+		complete(&((*sctx)->done));
+
+		*sctx = NULL;
+	}
+}
+
+void rtw_sctx_done(struct submit_ctx **sctx)
+{
+	rtw_sctx_done_err(sctx, RTW_SCTX_DONE_SUCCESS);
+}
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/debug.c linux-4.9.8821au/drivers/staging/rtl8821au/debug.c
--- linux-4.9/drivers/staging/rtl8821au/debug.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/debug.c	2016-12-11 19:48:25.156978448 -0600
@@ -0,0 +1,48 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2009-2012  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *****************************************************************************/
+
+#include <drv_types.h>
+#include "wifi.h"
+#include <linux/moduleparam.h>
+
+void rtw_dbgp_flag_init(struct rtl_priv *rtlpriv)
+{
+	u8 i;
+
+	rtlpriv->dbg.global_debugcomponents =
+	    COMP_ERR | COMP_FW | COMP_INIT | COMP_RECV | COMP_SEND |
+	    COMP_MLME | COMP_SCAN | COMP_INTR | COMP_LED | COMP_SEC |
+	    COMP_BEACON | COMP_RATE | COMP_RXDESC | COMP_DIG | COMP_TXAGC |
+	    COMP_POWER | COMP_POWER_TRACKING | COMP_BB_POWERSAVING | COMP_SWAS |
+	    COMP_RF | COMP_TURBO | COMP_RATR | COMP_CMD |
+	    COMP_EFUSE | COMP_QOS | COMP_MAC80211 | COMP_REGD | COMP_CHAN |
+	    COMP_EASY_CONCURRENT | COMP_EFUSE | COMP_QOS | COMP_MAC80211 |
+	    COMP_REGD | COMP_CHAN | COMP_BT_COEXIST;
+
+
+	for (i = 0; i < DBGP_TYPE_MAX; i++)
+		rtlpriv->dbg.dbgp_type[i] = 0;
+
+	/*Init Debug flag enable condition */
+}
diff -Naur linux-4.9/drivers/staging/rtl8821au/debug.h linux-4.9.8821au/drivers/staging/rtl8821au/debug.h
--- linux-4.9/drivers/staging/rtl8821au/debug.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/debug.h	2016-12-11 19:48:25.156978448 -0600
@@ -0,0 +1,241 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2009-2012  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *****************************************************************************/
+
+#ifndef __RTL_DEBUG_H__
+#define __RTL_DEBUG_H__
+
+/*--------------------------------------------------------------
+			Debug level
+--------------------------------------------------------------*/
+/*
+ *Fatal bug.
+ *For example, Tx/Rx/IO locked up,
+ *memory access violation,
+ *resource allocation failed,
+ *unexpected HW behavior, HW BUG
+ *and so on.
+ */
+#define DBG_EMERG			0
+
+/*
+ *Abnormal, rare, or unexpeted cases.
+ *For example, Packet/IO Ctl canceled,
+ *device suprisely unremoved and so on.
+ */
+#define	DBG_WARNING			2
+
+/*
+ *Normal case driver developer should
+ *open, we can see link status like
+ *assoc/AddBA/DHCP/adapter start and
+ *so on basic and useful infromations.
+ */
+#define DBG_DMESG			3
+
+/*
+ *Normal case with useful information
+ *about current SW or HW state.
+ *For example, Tx/Rx descriptor to fill,
+ *Tx/Rx descriptor completed status,
+ *SW protocol state change, dynamic
+ *mechanism state change and so on.
+ */
+#define DBG_LOUD			4
+
+/*
+ *Normal case with detail execution
+ *flow or information.
+ */
+#define	DBG_TRACE			5
+
+/*--------------------------------------------------------------
+		Define the rt_trace components
+--------------------------------------------------------------*/
+#define COMP_ERR			BIT(0)
+#define COMP_FW				BIT(1)
+#define COMP_INIT			BIT(2)	/*For init/deinit */
+#define COMP_RECV			BIT(3)	/*For Rx. */
+#define COMP_SEND			BIT(4)	/*For Tx. */
+#define COMP_MLME			BIT(5)	/*For MLME. */
+#define COMP_SCAN			BIT(6)	/*For Scan. */
+#define COMP_INTR			BIT(7)	/*For interrupt Related. */
+#define COMP_LED			BIT(8)	/*For LED. */
+#define COMP_SEC			BIT(9)	/*For sec. */
+#define COMP_BEACON			BIT(10)	/*For beacon. */
+#define COMP_RATE			BIT(11)	/*For rate. */
+#define COMP_RXDESC			BIT(12)	/*For rx desc. */
+#define COMP_DIG			BIT(13)	/*For DIG */
+#define COMP_TXAGC			BIT(14)	/*For Tx power */
+#define COMP_HIPWR			BIT(15)	/*For High Power Mechanism */
+#define COMP_POWER			BIT(16)	/*For lps/ips/aspm. */
+#define COMP_POWER_TRACKING	BIT(17)	/*For TX POWER TRACKING */
+#define COMP_BB_POWERSAVING	BIT(18)
+#define COMP_SWAS			BIT(19)	/*For SW Antenna Switch */
+#define COMP_RF				BIT(20)	/*For RF. */
+#define COMP_TURBO			BIT(21)	/*For EDCA TURBO. */
+#define COMP_RATR			BIT(22)
+#define COMP_CMD			BIT(23)
+#define COMP_EFUSE			BIT(24)
+#define COMP_QOS			BIT(25)
+#define COMP_MAC80211		BIT(26)
+#define COMP_REGD			BIT(27)
+#define COMP_CHAN			BIT(28)
+#define COMP_USB			BIT(29)
+#define COMP_EASY_CONCURRENT	COMP_USB /* reuse of this bit is OK */
+#define COMP_BT_COEXIST			BIT(30)
+#define COMP_IQK			BIT(31)
+
+/*--------------------------------------------------------------
+		Define the rt_print components
+--------------------------------------------------------------*/
+/* Define EEPROM and EFUSE  check module bit*/
+#define EEPROM_W			BIT(0)
+#define EFUSE_PG			BIT(1)
+#define EFUSE_READ_ALL			BIT(2)
+
+/* Define init check for module bit*/
+#define	INIT_EEPROM			BIT(0)
+#define	INIT_TXPOWER			BIT(1)
+#define	INIT_IQK			BIT(2)
+#define	INIT_RF				BIT(3)
+
+/* Define PHY-BB/RF/MAC check module bit */
+#define	PHY_BBR				BIT(0)
+#define	PHY_BBW				BIT(1)
+#define	PHY_RFR				BIT(2)
+#define	PHY_RFW				BIT(3)
+#define	PHY_MACR			BIT(4)
+#define	PHY_MACW			BIT(5)
+#define	PHY_ALLR			BIT(6)
+#define	PHY_ALLW			BIT(7)
+#define	PHY_TXPWR			BIT(8)
+#define	PHY_PWRDIFF			BIT(9)
+
+/* Define Dynamic Mechanism check module bit --> FDM */
+#define WA_IOT				BIT(0)
+#define DM_PWDB				BIT(1)
+#define DM_MONITOR			BIT(2)
+#define DM_DIG				BIT(3)
+#define DM_EDCA_TURBO			BIT(4)
+
+#define DM_PWDB				BIT(1)
+
+enum dbgp_flag_e {
+	FQOS = 0,
+	FTX = 1,
+	FRX = 2,
+	FSEC = 3,
+	FMGNT = 4,
+	FMLME = 5,
+	FRESOURCE = 6,
+	FBEACON = 7,
+	FISR = 8,
+	FPHY = 9,
+	FMP = 10,
+	FEEPROM = 11,
+	FPWR = 12,
+	FDM = 13,
+	FDBGCtrl = 14,
+	FC2H = 15,
+	FBT = 16,
+	FINIT = 17,
+	FIOCTL = 18,
+	DBGP_TYPE_MAX
+};
+
+#ifdef CONFIG_RTLWIFI_DEBUG
+
+#define RT_ASSERT(_exp, fmt, ...)					\
+do {									\
+	if (!(_exp)) {							\
+		printk(KERN_DEBUG KBUILD_MODNAME ":%s(): " fmt,		\
+		       __func__, ##__VA_ARGS__);			\
+	}								\
+} while (0)
+
+#define RT_TRACE(rtlpriv, comp, level, fmt, ...)			\
+do {									\
+	if (unlikely(((comp) & rtlpriv->dbg.global_debugcomponents) &&	\
+		     ((level) <= rtlpriv->dbg.global_debuglevel))) {	\
+		printk(KERN_DEBUG KBUILD_MODNAME ":%s():<%lx-%x> " fmt,	\
+		       __func__, in_interrupt(), in_atomic(),		\
+		       ##__VA_ARGS__);					\
+	}								\
+} while (0)
+
+#define RTPRINT(rtlpriv, dbgtype, dbgflag, fmt, ...)			\
+do {									\
+	if (unlikely(rtlpriv->dbg.dbgp_type[dbgtype] & dbgflag)) {	\
+		printk(KERN_DEBUG KBUILD_MODNAME ": " fmt,		\
+		       ##__VA_ARGS__);					\
+	}								\
+} while (0)
+
+#define RT_PRINT_DATA(rtlpriv, _comp, _level, _titlestring, _hexdata,	\
+		      _hexdatalen)					\
+do {									\
+	if (unlikely(((_comp) & rtlpriv->dbg.global_debugcomponents) &&	\
+		     (_level <= rtlpriv->dbg.global_debuglevel))) {	\
+		printk(KERN_DEBUG "%s: In process \"%s\" (pid %i): %s\n", \
+		       KBUILD_MODNAME, current->comm, current->pid,	\
+		       _titlestring);					\
+		print_hex_dump_bytes("", DUMP_PREFIX_NONE,		\
+				     _hexdata, _hexdatalen);		\
+	}								\
+} while (0)
+
+#else
+
+struct rtl_priv;
+
+__printf(2, 3)
+static inline void RT_ASSERT(int exp, const char *fmt, ...)
+{
+}
+
+__printf(4, 5)
+static inline void RT_TRACE(struct rtl_priv *rtlpriv,
+			    int comp, int level,
+			    const char *fmt, ...)
+{
+}
+
+__printf(4, 5)
+static inline void RTPRINT(struct rtl_priv *rtlpriv,
+			   int dbgtype, int dbgflag,
+			   const char *fmt, ...)
+{
+}
+
+static inline void RT_PRINT_DATA(struct rtl_priv *rtlpriv,
+				 int comp, int level,
+				 const char *titlestring,
+				 const void *hexdata, size_t hexdatalen)
+{
+}
+
+#endif
+
+void rtw_dbgp_flag_init(struct rtl_priv *rtlpriv);
+#endif
diff -Naur linux-4.9/drivers/staging/rtl8821au/efuse.c linux-4.9.8821au/drivers/staging/rtl8821au/efuse.c
--- linux-4.9/drivers/staging/rtl8821au/efuse.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/efuse.c	2016-12-11 19:48:25.156978448 -0600
@@ -0,0 +1,1115 @@
+#include <drv_types.h>
+#include "wifi.h"
+#include <rtl8812a_spec.h>
+#include <rtl8812a_hal.h>
+
+static void efuse_ShadowRead1Byte(struct rtl_priv *rtlpriv, u16	Offset,
+	 	u8 *Value)
+{
+	struct rtl_efuse *rtlefuse = rtl_efuse(rtlpriv);
+
+	*Value = rtlefuse->efuse_map[0][Offset];
+}
+
+static void efuse_ShadowRead2Byte(struct rtl_priv *rtlpriv, u16	Offset,
+		u16 *Value)
+{
+	struct rtl_efuse *rtlefuse = rtl_efuse(rtlpriv);
+
+	*Value = rtlefuse->efuse_map[0][Offset];
+	*Value |= rtlefuse->efuse_map[0][Offset+1] << 8;
+}
+
+//---------------Read Four Bytes
+static void efuse_ShadowRead4Byte(struct rtl_priv *rtlpriv, u16	Offset,
+	 	u32 *Value)
+{
+	struct rtl_efuse *rtlefuse = rtl_efuse(rtlpriv);
+
+	*Value = rtlefuse->efuse_map[0][Offset];
+	*Value |= rtlefuse->efuse_map[0][Offset + 1] << 8;
+	*Value |= rtlefuse->efuse_map[0][Offset + 2] << 16;
+	*Value |= rtlefuse->efuse_map[0][Offset + 3] << 24;
+}
+
+static void efuse_ShadowWrite1Byte(struct rtl_priv *rtlpriv, u16 Offset,
+		u8 Value)
+{
+	struct rtl_efuse *rtlefuse = rtl_efuse(rtlpriv);
+
+	rtlefuse->efuse_map[0][Offset] = Value;
+
+}
+
+static void efuse_ShadowWrite2Byte(struct rtl_priv *rtlpriv, u16 Offset,
+		u16 Value)
+{
+	struct rtl_efuse *rtlefuse = rtl_efuse(rtlpriv);
+
+	rtlefuse->efuse_map[0][Offset] = Value & 0x0ff;
+	rtlefuse->efuse_map[0][Offset+1] = Value >> 8;
+}
+
+static void efuse_ShadowWrite4Byte(struct rtl_priv *rtlpriv, u16 Offset,
+		u32 Value)
+{
+	struct rtl_efuse *rtlefuse = rtl_efuse(rtlpriv);
+
+	rtlefuse->efuse_map[0][Offset] = (u8) (Value & 0x0000000ff);
+	rtlefuse->efuse_map[0][Offset+1] = (u8) ((Value >> 8) & 0x0000ff);
+	rtlefuse->efuse_map[0][Offset+2] = (u8) ((Value >> 16) & 0x00ff);
+	rtlefuse->efuse_map[0][Offset+3] = (u8) ((Value >> 24) & 0xff);
+}
+
+void EFUSE_ShadowRead(struct rtl_priv *rtlpriv, u8 Type,
+		u16 Offset, u32 *Value)
+{
+	if (Type == 1)
+		efuse_ShadowRead1Byte(rtlpriv, Offset, (uint8_t *)Value);
+	else if (Type == 2)
+		efuse_ShadowRead2Byte(rtlpriv, Offset, (u16 *)Value);
+	else if (Type == 4)
+		efuse_ShadowRead4Byte(rtlpriv, Offset, (uint32_t *)Value);
+
+}	// EFUSE_ShadowRead
+
+static void efuse_power_switch(struct rtl_priv *rtlpriv, u8 write, u8 pwrstate)
+{
+	uint8_t	tempval;
+	u16	tmpV16;
+#define EFUSE_ACCESS_ON_JAGUAR 0x69
+#define EFUSE_ACCESS_OFF_JAGUAR 0x00
+	if (pwrstate) {
+		rtl_write_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_ACCESS], EFUSE_ACCESS_ON_JAGUAR);
+
+		/* 1.2V Power: From VDDON with Power Cut(0x0000h[15]), defualt valid */
+		tmpV16 = rtl_read_word(rtlpriv, REG_SYS_ISO_CTRL);
+		if (!(tmpV16 & rtlpriv->cfg->maps[EFUSE_PWC_EV12V])) {
+			tmpV16 |= rtlpriv->cfg->maps[EFUSE_PWC_EV12V];
+			/* rtl_write_word(rtlpriv,REG_SYS_ISO_CTRL,tmpV16); */
+		}
+		/* Reset: 0x0000h[28], default valid */
+		tmpV16 =  rtl_read_word(rtlpriv, REG_SYS_FUNC_EN);
+		if (!(tmpV16 & rtlpriv->cfg->maps[EFUSE_FEN_ELDR])) {
+			tmpV16 |= rtlpriv->cfg->maps[EFUSE_FEN_ELDR] ;
+			rtl_write_word(rtlpriv, REG_SYS_FUNC_EN, tmpV16);
+		}
+
+		/* Clock: Gated(0x0008h[5]) 8M(0x0008h[1]) clock from ANA, default valid */
+		tmpV16 = rtl_read_word(rtlpriv, REG_SYS_CLKR);
+		if ((!(tmpV16 & rtlpriv->cfg->maps[EFUSE_LOADER_CLK_EN])) || 
+		    (!(tmpV16 & rtlpriv->cfg->maps[EFUSE_ANA8M]))) {
+			tmpV16 |= (rtlpriv->cfg->maps[EFUSE_LOADER_CLK_EN] | 
+			           rtlpriv->cfg->maps[EFUSE_ANA8M]);
+			rtl_write_word(rtlpriv, REG_SYS_CLKR, tmpV16);
+		}
+
+		if (write) {
+			/* Enable LDO 2.5V before read/write action */
+			tempval = rtl_read_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_TEST]+3);
+			tempval &= ~(BIT(3) | BIT(4) | BIT(5) | BIT(6));
+			tempval |= (VOLTAGE_V25 << 3);
+			tempval |= BIT(7);
+			rtl_write_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_TEST] + 3, tempval);
+		}
+	} else {
+		rtl_write_byte(rtlpriv, REG_EFUSE_BURN_GNT_8812, EFUSE_ACCESS_OFF_JAGUAR);
+
+		if (write) {
+			/* Disable LDO 2.5V after read/write action */
+			tempval = rtl_read_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_TEST] + 3);
+			rtl_write_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_TEST] + 3, (tempval & 0x7F));
+		}
+	}
+}
+
+
+static void read_efuse(struct rtl_priv *rtlpriv, u16 _offset,  u16 _size_byte, u8 *pbuf)
+{
+	uint8_t	*efuseTbl = NULL;
+	u16	eFuse_Addr = 0;
+	uint8_t	offset = 0, wden = 0;
+	u16	i, j;
+	u16	**eFuseWord = NULL;
+	u16	efuse_utilized = 0;
+	uint8_t	efuse_usage = 0;
+	uint8_t	offset_2_0 = 0;
+	uint8_t	efuseHeader = 0, efuseExtHdr = 0, efuseData = 0;
+	const u16 efuse_max_section =
+		rtlpriv->cfg->maps[EFUSE_MAX_SECTION_MAP];
+	const u32 efuse_len =
+		rtlpriv->cfg->maps[EFUSE_REAL_CONTENT_SIZE];
+
+	/*
+	 * Do NOT excess total size of EFuse table. Added by Roger, 2008.11.10.
+	 */
+	if ((_offset + _size_byte) > rtlpriv->cfg->maps[EFUSE_HWSET_MAX_SIZE]) {
+		/* total E-Fuse table is 512bytes */
+		dev_err(&(rtlpriv->ndev->dev), "Hal_EfuseReadEFuse8812A(): Invalid offset(%#x) with read bytes(%#x)!!\n", _offset, _size_byte);
+		goto exit;
+	}
+
+	efuseTbl = (uint8_t *) rtw_zmalloc(rtlpriv->cfg->maps[EFUSE_HWSET_MAX_SIZE]);
+	if (efuseTbl == NULL) {
+		dev_err(&(rtlpriv->ndev->dev), "%s: alloc efuseTbl fail!\n", __FUNCTION__);
+		goto exit;
+	}
+
+	eFuseWord = (u16 **) rtw_malloc2d(efuse_max_section, EFUSE_MAX_WORD_UNIT, sizeof(u16));
+	if (eFuseWord == NULL) {
+		dev_err(&(rtlpriv->ndev->dev), "%s: alloc eFuseWord fail!\n", __FUNCTION__);
+		goto exit;
+	}
+
+	/* 0. Refresh efuse init map as all oxFF. */
+	for (i = 0; i < efuse_max_section; i++)
+		for (j = 0; j < EFUSE_MAX_WORD_UNIT; j++)
+			eFuseWord[i][j] = 0xFFFF;
+
+	/*
+	 * 1. Read the first byte to check if efuse is empty!!!
+	 */
+	efuse_OneByteRead(rtlpriv, eFuse_Addr++, &efuseHeader);
+
+	if (efuseHeader != 0xFF) {
+		efuse_utilized++;
+	} else {
+		dev_err(&(rtlpriv->ndev->dev), "EFUSE is empty\n");
+		efuse_utilized = 0;
+		goto exit;
+	}
+	/* RT_DISP(FEEPROM, EFUSE_READ_ALL, ("Hal_EfuseReadEFuse8812A(): efuse_utilized: %d\n", efuse_utilized)); */
+
+	/*
+	 * 2. Read real efuse content. Filter PG header and every section data.
+	 */
+	while ((efuseHeader != 0xFF) && AVAILABLE_EFUSE_ADDR_8812(eFuse_Addr)) {
+		/* RTPRINT(FEEPROM, EFUSE_READ_ALL, ("efuse_Addr-%d efuse_data=%x\n", eFuse_Addr-1, *rtemp8)); */
+
+		/* Check PG header for section num. */
+		if (EXT_HEADER(efuseHeader)) {	/* extended header */
+			offset_2_0 = GET_HDR_OFFSET_2_0(efuseHeader);
+			/* RT_DISP(FEEPROM, EFUSE_READ_ALL, ("extended header offset_2_0=%X\n", offset_2_0)); */
+
+			efuse_OneByteRead(rtlpriv, eFuse_Addr++, &efuseExtHdr);
+
+			/* RT_DISP(FEEPROM, EFUSE_READ_ALL, ("efuse[%X]=%X\n", eFuse_Addr-1, efuseExtHdr)); */
+
+			if (efuseExtHdr != 0xff) {
+				efuse_utilized++;
+				if (ALL_WORDS_DISABLED(efuseExtHdr)) {
+					efuse_OneByteRead(rtlpriv, eFuse_Addr++, &efuseHeader);
+					if (efuseHeader != 0xff) {
+						efuse_utilized++;
+					}
+					break;
+				} else {
+					offset = ((efuseExtHdr & 0xF0) >> 1) | offset_2_0;
+					wden = (efuseExtHdr & 0x0F);
+				}
+			} else 	{
+				dev_err(&(rtlpriv->ndev->dev), "Error condition, extended = 0xff\n");
+				/* We should handle this condition. */
+				break;
+			}
+		} else {
+			offset = ((efuseHeader >> 4) & 0x0f);
+			wden = (efuseHeader & 0x0f);
+		}
+
+		if (offset < efuse_max_section) {
+			/* Get word enable value from PG header */
+			/* RT_DISP(FEEPROM, EFUSE_READ_ALL, ("Offset-%X Worden=%X\n", offset, wden)); */
+
+			for (i = 0; i < EFUSE_MAX_WORD_UNIT; i++) {
+				/* Check word enable condition in the section */
+				if (!(wden & (0x01 << i))) {
+					efuse_OneByteRead(rtlpriv, eFuse_Addr++, &efuseData);
+					/* RT_DISP(FEEPROM, EFUSE_READ_ALL, ("efuse[%X]=%X\n", eFuse_Addr-1, efuseData)); */
+					efuse_utilized++;
+					eFuseWord[offset][i] = (efuseData & 0xff);
+
+					if (!AVAILABLE_EFUSE_ADDR_8812(eFuse_Addr))
+						break;
+
+					efuse_OneByteRead(rtlpriv, eFuse_Addr++, &efuseData);
+					/* RT_DISP(FEEPROM, EFUSE_READ_ALL, ("efuse[%X]=%X\n", eFuse_Addr-1, efuseData)); */
+					efuse_utilized++;
+					eFuseWord[offset][i] |= (((u16)efuseData << 8) & 0xff00);
+
+					if (!AVAILABLE_EFUSE_ADDR_8812(eFuse_Addr))
+						break;
+				}
+			}
+		}
+
+		/* Read next PG header */
+		efuse_OneByteRead(rtlpriv, eFuse_Addr++, &efuseHeader);
+		/* RTPRINT(FEEPROM, EFUSE_READ_ALL, ("Addr=%d rtemp 0x%x\n", eFuse_Addr, *rtemp8)); */
+
+		if (efuseHeader != 0xFF) {
+			efuse_utilized++;
+		}
+	}
+
+	/*
+	 * 3. Collect 16 sections and 4 word unit into Efuse map.
+	 */
+	for (i = 0; i < efuse_max_section; i++) {
+		for (j = 0; j < EFUSE_MAX_WORD_UNIT; j++) {
+			efuseTbl[(i*8)+(j*2)] = (eFuseWord[i][j] & 0xff);
+			efuseTbl[(i*8)+((j*2)+1)] = ((eFuseWord[i][j] >> 8) & 0xff);
+		}
+	}
+
+	/* RT_DISP(FEEPROM, EFUSE_READ_ALL, ("Hal_EfuseReadEFuse8812A(): efuse_utilized: %d\n", efuse_utilized)); */
+
+	/*
+	 * 4. Copy from Efuse map to output pointer memory!!!
+	 */
+	for (i = 0; i < _size_byte; i++) {
+		pbuf[i] = efuseTbl[_offset+i];
+	}
+
+	/*
+	 * 5. Calculate Efuse utilization.
+	 */
+	efuse_usage = (u8)((eFuse_Addr*100)/efuse_len);
+	rtlpriv->cfg->ops->set_hw_reg(rtlpriv, HW_VAR_EFUSE_BYTES, (uint8_t *)&eFuse_Addr);
+
+exit:
+	if (efuseTbl)
+		rtw_mfree(efuseTbl);
+
+	if (eFuseWord)
+		rtw_mfree2d((void *)eFuseWord, efuse_max_section, EFUSE_MAX_WORD_UNIT, sizeof(u16));
+}
+
+static void efuse_read_all_map(struct rtl_priv *rtlpriv, uint8_t *Efuse)
+{
+	efuse_power_switch(rtlpriv, false, true);
+	read_efuse(rtlpriv, 0, rtlpriv->cfg->maps[EFUSE_HWSET_MAX_SIZE], Efuse);
+	efuse_power_switch(rtlpriv, false, false);
+}
+
+uint8_t rtw_efuse_map_read(struct rtl_priv *rtlpriv, u16 addr, u16 cnts, uint8_t *data)
+{
+	if ((addr + cnts) > rtlpriv->cfg->maps[EFUSE_HWSET_MAX_SIZE])
+		return _FAIL;
+
+	efuse_power_switch(rtlpriv, false, true);
+	read_efuse(rtlpriv, addr, cnts, data);
+	efuse_power_switch(rtlpriv, false, false);
+
+	return _SUCCESS;
+}
+
+/* ULLI rtw is used for not messing with rtlwifi */
+
+void rtw_efuse_shadow_map_update(struct rtl_priv *rtlpriv)
+{
+	struct rtl_efuse *efuse = rtl_efuse(rtlpriv);
+
+	if (efuse->autoload_failflag == true)
+		memset(&efuse->efuse_map[0][0], 0xFF, rtlpriv->cfg->maps[EFUSE_HWSET_MAX_SIZE]);
+	else
+		efuse_read_all_map(rtlpriv, efuse->efuse_map[0]);
+}
+
+uint8_t
+EFUSE_Read1Byte(
+		struct rtl_priv *rtlpriv,
+		u16		Address)
+{
+	uint8_t	data;
+	uint8_t	Bytetemp = {0x00};
+	uint8_t	temp = {0x00};
+	uint32_t	k=0;
+	u16	contentLen = rtlpriv->cfg->maps[EFUSE_REAL_CONTENT_SIZE];
+
+	if (Address < contentLen)	//E-fuse 512Byte
+	{
+		//Write E-fuse Register address BIT(0)~7
+		temp = Address & 0xFF;
+		rtl_write_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL]+1, temp);
+		Bytetemp = rtl_read_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL]+2);
+		//Write E-fuse Register address bit8~9
+		temp = ((Address >> 8) & 0x03) | (Bytetemp & 0xFC);
+		rtl_write_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL]+2, temp);
+
+		//Write 0x30[31]=0
+		Bytetemp = rtl_read_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL]+3);
+		temp = Bytetemp & 0x7F;
+		rtl_write_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL]+3, temp);
+
+		//Wait Write-ready (0x30[31]=1)
+		Bytetemp = rtl_read_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL]+3);
+		while(!(Bytetemp & 0x80))
+		{
+			Bytetemp = rtl_read_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL]+3);
+			k++;
+			if(k==1000)
+			{
+				k=0;
+				break;
+			}
+		}
+		data=rtl_read_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL]);
+		return data;
+	}
+	else
+		return 0xFF;
+
+}/* EFUSE_Read1Byte */
+
+void
+EFUSE_Write1Byte(
+		struct rtl_priv *rtlpriv,
+		u16		Address,
+		uint8_t		Value)
+{
+	uint8_t	Bytetemp = {0x00};
+	uint8_t	temp = {0x00};
+	uint32_t	k=0;
+	u16	contentLen = rtlpriv->cfg->maps[EFUSE_REAL_CONTENT_SIZE];
+
+	if( Address < contentLen)	//E-fuse 512Byte
+	{
+		rtl_write_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL], Value);
+
+		//Write E-fuse Register address BIT(0)~7
+		temp = Address & 0xFF;
+		rtl_write_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL]+1, temp);
+		Bytetemp = rtl_read_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL]+2);
+
+		//Write E-fuse Register address bit8~9
+		temp = ((Address >> 8) & 0x03) | (Bytetemp & 0xFC);
+		rtl_write_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL]+2, temp);
+
+		//Write 0x30[31]=1
+		Bytetemp = rtl_read_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL]+3);
+		temp = Bytetemp | 0x80;
+		rtl_write_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL]+3, temp);
+
+		//Wait Write-ready (0x30[31]=0)
+		Bytetemp = rtl_read_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL]+3);
+		while(Bytetemp & 0x80)
+		{
+			Bytetemp = rtl_read_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL]+3);
+			k++;
+			if(k==100)
+			{
+				k=0;
+				break;
+			}
+		}
+	}
+}/* EFUSE_Write1Byte */
+
+static u8 Efuse_CalculateWordCnts(u8 word_en)
+{
+	uint8_t word_cnts = 0;
+	if(!(word_en & BIT(0)))	word_cnts++; // 0 : write enable
+	if(!(word_en & BIT(1)))	word_cnts++;
+	if(!(word_en & BIT(2)))	word_cnts++;
+	if(!(word_en & BIT(3)))	word_cnts++;
+	return word_cnts;
+}
+
+static u16 efuse_get_current_size(struct rtl_priv *rtlpriv)
+{
+	int	bContinual = true;
+	u16	efuse_addr = 0;
+	uint8_t	hoffset = 0, hworden = 0;
+	uint8_t	efuse_data, word_cnts = 0;
+
+	rtlpriv->cfg->ops->get_hw_reg(rtlpriv, HW_VAR_EFUSE_BYTES, (uint8_t *)&efuse_addr);
+
+	/* RTPRINT(FEEPROM, EFUSE_PG, ("hal_EfuseGetCurrentSize_8723A(), start_efuse_addr = %d\n", efuse_addr)); */
+
+	while (bContinual && efuse_OneByteRead(rtlpriv, efuse_addr, &efuse_data)
+	     && (efuse_addr  < EFUSE_REAL_CONTENT_LEN_JAGUAR)) {
+		if (efuse_data != 0xFF) {
+			if ((efuse_data & 0x1F) == 0x0F) {	/* extended header */
+				hoffset = efuse_data;
+				efuse_addr++;
+				efuse_OneByteRead(rtlpriv, efuse_addr, &efuse_data);
+				if ((efuse_data & 0x0F) == 0x0F) {
+					efuse_addr++;
+					continue;
+				} else {
+					hoffset = ((hoffset & 0xE0) >> 5) | ((efuse_data & 0xF0) >> 1);
+					hworden = efuse_data & 0x0F;
+				}
+			} else {
+				hoffset = (efuse_data >> 4) & 0x0F;
+				hworden =  efuse_data & 0x0F;
+			}
+			word_cnts = Efuse_CalculateWordCnts(hworden);
+			/* read next header */
+			efuse_addr = efuse_addr + (word_cnts*2)+1;
+		} else {
+			bContinual = false ;
+		}
+	}
+
+	rtlpriv->cfg->ops->set_hw_reg(rtlpriv, HW_VAR_EFUSE_BYTES, (uint8_t *)&efuse_addr);
+
+	return efuse_addr;
+}
+
+static void efuse_WordEnableDataRead(u8 word_en, u8 *sourdata,
+					u8 *targetdata)
+{
+	if (!(word_en&BIT(0)))
+	{
+		targetdata[0] = sourdata[0];
+		targetdata[1] = sourdata[1];
+	}
+	if (!(word_en&BIT(1)))
+	{
+		targetdata[2] = sourdata[2];
+		targetdata[3] = sourdata[3];
+	}
+	if (!(word_en&BIT(2)))
+	{
+		targetdata[4] = sourdata[4];
+		targetdata[5] = sourdata[5];
+	}
+	if (!(word_en&BIT(3)))
+	{
+		targetdata[6] = sourdata[6];
+		targetdata[7] = sourdata[7];
+	}
+}
+
+static int efuse_pg_packet_read(struct rtl_priv *rtlpriv,
+	uint8_t offset, uint8_t *data)
+{
+	uint8_t	ReadState = PG_STATE_HEADER;
+
+	int	bContinual = true;
+	int	bDataEmpty = true ;
+
+	uint8_t	efuse_data, word_cnts = 0;
+	u16 efuse_addr = 0;
+	uint8_t	hoffset = 0, hworden = 0;
+	uint8_t	tmpidx = 0;
+	uint8_t	tmpdata[8];
+	uint8_t	max_section = 0;
+	uint8_t	tmp_header = 0;
+
+	if (data == NULL)
+		return false;
+	if (offset > EFUSE_MAX_SECTION_JAGUAR)
+		return false;
+
+	memset((void *)data, 0xff, sizeof(uint8_t) * PGPKT_DATA_SIZE);
+	memset((void *)tmpdata, 0xff, sizeof(uint8_t) * PGPKT_DATA_SIZE);
+
+
+	/*
+	 * <Roger_TODO> Efuse has been pre-programmed dummy 5Bytes at the end of Efuse by CP.
+	 * Skip dummy parts to prevent unexpected data read from Efuse.
+	 *  By pass right now. 2009.02.19.
+	 */
+	while (bContinual && (efuse_addr  < EFUSE_REAL_CONTENT_LEN_JAGUAR)) {
+		/* -------  Header Read ------------- */
+		if (ReadState & PG_STATE_HEADER) {
+			if (efuse_OneByteRead(rtlpriv, efuse_addr, &efuse_data)
+			    && (efuse_data != 0xFF)) {
+				if (EXT_HEADER(efuse_data)) {
+					tmp_header = efuse_data;
+					efuse_addr++;
+					efuse_OneByteRead(rtlpriv, efuse_addr, &efuse_data);
+					if (!ALL_WORDS_DISABLED(efuse_data)) {
+						hoffset = ((tmp_header & 0xE0) >> 5) | ((efuse_data & 0xF0) >> 1);
+						hworden = efuse_data & 0x0F;
+					} else {
+#if 0	/* ULLI : temporary disabled */					
+						DBG_8192C("Error, All words disabled\n");
+#endif						
+						efuse_addr++;
+						break;
+					}
+				} else {
+					hoffset = (efuse_data >> 4) & 0x0F;
+					hworden =  efuse_data & 0x0F;
+				}
+				word_cnts = Efuse_CalculateWordCnts(hworden);
+				bDataEmpty = true ;
+
+				if (hoffset == offset) {
+					for (tmpidx = 0; tmpidx < word_cnts*2; tmpidx++) {
+						if (efuse_OneByteRead(rtlpriv, efuse_addr+1+tmpidx, &efuse_data)) {
+							tmpdata[tmpidx] = efuse_data;
+							if (efuse_data != 0xff) {
+								bDataEmpty = false;
+							}
+						}
+					}
+					if (bDataEmpty == false) {
+						ReadState = PG_STATE_DATA;
+					} else {	/* read next header */
+						efuse_addr = efuse_addr + (word_cnts*2)+1;
+						ReadState = PG_STATE_HEADER;
+					}
+				} else {	/*read next header */
+					efuse_addr = efuse_addr + (word_cnts*2)+1;
+					ReadState = PG_STATE_HEADER;
+				}
+
+			} else{
+				bContinual = false ;
+			}
+		} else if (ReadState & PG_STATE_DATA) {
+			/* -------  Data section Read ------------- */
+			efuse_WordEnableDataRead(hworden, tmpdata, data);
+			efuse_addr = efuse_addr + (word_cnts*2)+1;
+			ReadState = PG_STATE_HEADER;
+		}
+
+	}
+
+	if ((data[0] == 0xff) && (data[1] == 0xff) && (data[2] == 0xff) &&
+	    (data[3] == 0xff) && (data[4] == 0xff) && (data[5] == 0xff) &&
+	    (data[6] == 0xff) && (data[7] == 0xff))
+		return false;
+	else
+		return true;
+
+}
+
+static u8 efuse_word_enable_data_write(struct rtl_priv *rtlpriv,
+	u16 efuse_addr, uint8_t word_en, uint8_t *data);
+
+
+static int efuse_pg_packet_write(struct rtl_priv *rtlpriv, uint8_t offset,
+	uint8_t	word_en, uint8_t *data)
+{
+	uint8_t WriteState = PG_STATE_HEADER;
+
+	int bContinual = true, bDataEmpty = true;
+	/* int bResult = true; */
+	u16 efuse_addr = 0;
+	uint8_t	efuse_data;
+
+	uint8_t	pg_header = 0, pg_header_temp = 0;
+
+	uint8_t	tmp_word_cnts = 0, target_word_cnts = 0;
+	uint8_t	tmp_header, match_word_en, tmp_word_en;
+
+	struct pgpkt_struct target_pkt;
+	struct pgpkt_struct tmp_pkt;
+
+	uint8_t	originaldata[sizeof(uint8_t) * 8];
+	uint8_t	tmpindex = 0, badworden = 0x0F;
+
+	static int repeat_times = 0;
+
+	bool	bExtendedHeader = false;
+
+	/*
+	 * <Roger_Notes> Efuse has been pre-programmed dummy 5Bytes at the end of Efuse by CP.
+	 * So we have to prevent unexpected data string connection, which will cause
+	 * incorrect data auto-load from HW. The total size is equal or smaller than 498bytes
+	 * (i.e., offset 0~497, and dummy 1bytes) expected after CP test.
+	 * 2009.02.19.
+	 */
+#if 0	 /* ULLI : temporary disabled */
+	if (rtl8812_EfuseGetCurrentSize(rtlpriv) >= (EFUSE_REAL_CONTENT_LEN_JAGUAR-EFUSE_OOB_PROTECT_BYTES_JAGUAR)) {
+		DBG_871X("hal_EfusePgPacketWrite_8812A() error: %x >= %x\n", rtl8812_EfuseGetCurrentSize(rtlpriv), (EFUSE_REAL_CONTENT_LEN_JAGUAR-EFUSE_OOB_PROTECT_BYTES_JAGUAR));
+		return false;
+	}
+#endif
+	/* Init the 8 bytes content as 0xff */
+	target_pkt.offset = offset;
+	target_pkt.word_en = word_en;
+	/* Initial the value to avoid compile warning */
+	tmp_pkt.offset = 0;
+	tmp_pkt.word_en = 0;
+
+	/* DBG_871X("hal_EfusePgPacketWrite_8812A target offset 0x%x word_en 0x%x \n", target_pkt.offset, target_pkt.word_en); */
+
+	memset((void *)target_pkt.data, 0xFF, sizeof(uint8_t)*8);
+
+	efuse_WordEnableDataRead(word_en, data, target_pkt.data);
+	target_word_cnts = Efuse_CalculateWordCnts(target_pkt.word_en);
+
+	/*
+	 * <Roger_Notes> Efuse has been pre-programmed dummy 5Bytes at the end of Efuse by CP.
+	 * So we have to prevent unexpected data string connection, which will cause
+	 * incorrect data auto-load from HW. Dummy 1bytes is additional.
+	 * 2009.02.19.
+	 */
+	while (bContinual && (efuse_addr  < (EFUSE_REAL_CONTENT_LEN_JAGUAR-EFUSE_OOB_PROTECT_BYTES_JAGUAR))) {
+		if (WriteState == PG_STATE_HEADER) {
+			bDataEmpty = true;
+			badworden = 0x0F;
+			/* ************	so ******************* */
+			/* DBG_871X("EFUSE PG_STATE_HEADER\n"); */
+			if (efuse_OneByteRead(rtlpriv, efuse_addr, &efuse_data) &&
+			   (efuse_data != 0xFF)) {
+				if ((efuse_data&0x1F) == 0x0F) {		/* extended header */
+					tmp_header = efuse_data;
+					efuse_addr++;
+					efuse_OneByteRead(rtlpriv, efuse_addr, &efuse_data);
+					if ((efuse_data & 0x0F) == 0x0F) {	/* wren fail */
+						uint8_t next = 0, next_next = 0, data = 0, i = 0;
+						uint8_t s = ((tmp_header & 0xF0) >> 4);
+						efuse_OneByteRead(rtlpriv, efuse_addr+1, &next);
+						efuse_OneByteRead(rtlpriv, efuse_addr+2, &next_next);
+						if (next == 0xFF && next_next == 0xFF) {
+							/* Have enough space to make fake data to recover bad header. */
+							switch (s) {
+							case 0x0:
+							case 0x2:
+							case 0x4:
+							case 0x6:
+							case 0x8:
+							case 0xA:
+							case 0xC:
+								for (i = 0; i < 3; ++i) {
+								efuse_OneByteWrite(rtlpriv, efuse_addr, 0x27);
+									efuse_OneByteRead(rtlpriv, efuse_addr, &data);
+									if (data == 0x27)
+										break;
+								}
+								break;
+							case 0xE:
+								for (i = 0; i < 3; ++i) {
+								efuse_OneByteWrite(rtlpriv, efuse_addr, 0x17);
+									efuse_OneByteRead(rtlpriv, efuse_addr, &data);
+									if (data == 0x17)
+										break;
+								}
+								break;
+							default:
+								break;
+							}
+							efuse_OneByteWrite(rtlpriv, efuse_addr+1, 0xFF);
+							efuse_OneByteWrite(rtlpriv, efuse_addr+2, 0xFF);
+							efuse_addr += 3;
+						} else {
+							efuse_addr++;
+						}
+						continue;
+					} else {
+						tmp_pkt.offset = ((tmp_header & 0xE0) >> 5) | ((efuse_data & 0xF0) >> 1);
+						tmp_pkt.word_en = efuse_data & 0x0F;
+					}
+				} else {
+					uint8_t i = 0, data = 0;
+					tmp_header	=  efuse_data;
+					tmp_pkt.offset	= (tmp_header>>4) & 0x0F;
+					tmp_pkt.word_en = tmp_header & 0x0F;
+
+					if (tmp_pkt.word_en == 0xF) {
+						uint8_t next = 0;
+						efuse_OneByteRead(rtlpriv, efuse_addr+1, &next);
+						if (next == 0xFF) { 	/* Have enough space to make fake data to recover bad header. */
+							tmp_header = (tmp_header & 0xF0) | 0x7;
+							for (i = 0; i < 3; ++i) {
+							efuse_OneByteWrite(rtlpriv, efuse_addr, tmp_header);
+								efuse_OneByteRead(rtlpriv, efuse_addr, &data);
+								if (data == tmp_header)
+									break;
+							}
+							efuse_OneByteWrite(rtlpriv, efuse_addr+1, 0xFF);
+							efuse_OneByteWrite(rtlpriv, efuse_addr+2, 0xFF);
+							efuse_addr += 2;
+						}
+					}
+				}
+				tmp_word_cnts =  Efuse_CalculateWordCnts(tmp_pkt.word_en);
+
+				/* DBG_871X("section offset 0x%x worden 0x%x\n", tmp_pkt.offset, tmp_pkt.word_en); */
+
+				/* ************	so-1 ******************* */
+				if (tmp_pkt.offset  != target_pkt.offset) {
+					efuse_addr = efuse_addr + (tmp_word_cnts * 2) + 1; /* Next pg_packet */
+#if (EFUSE_ERROE_HANDLE == 1)
+					WriteState = PG_STATE_HEADER;
+#endif
+				} else {
+					/* write the same offset */
+					/* DBG_871X("hal_EfusePgPacketWrite_8812A section offset the same\n"); */
+					/* ************	so-2 ******************* */
+					for (tmpindex = 0; tmpindex < (tmp_word_cnts * 2) ; tmpindex++) {
+						if (efuse_OneByteRead(rtlpriv, (efuse_addr + 1 + tmpindex), &efuse_data) && (efuse_data != 0xFF)) {
+							bDataEmpty = false;
+						}
+					}
+					/* ***********	so-2-1 ******************* */
+					if (bDataEmpty == false) {
+						/* DBG_871X("hal_EfusePgPacketWrite_8812A section offset the same and data is NOT empty\n"); */
+						efuse_addr = efuse_addr + (tmp_word_cnts*2) + 1; /* Next pg_packet */
+#if (EFUSE_ERROE_HANDLE == 1)
+						WriteState = PG_STATE_HEADER;
+#endif
+					} else {
+						/* ************  so-2-2 ******************* */
+						/* DBG_871X("hal_EfusePgPacketWrite_8812A section data empty\n"); */
+						match_word_en = 0x0F;			/* same bit as original wren */
+						if (!((target_pkt.word_en & BIT(0)) | (tmp_pkt.word_en & BIT(0)))) {
+							 match_word_en &= (~BIT(0));
+						}
+						if (!((target_pkt.word_en & BIT(1)) | (tmp_pkt.word_en & BIT(1)))) {
+							 match_word_en &= (~BIT(1));
+						}
+						if (!((target_pkt.word_en & BIT(2)) | (tmp_pkt.word_en & BIT(2)))) {
+							 match_word_en &= (~BIT(2));
+						}
+						if (!((target_pkt.word_en & BIT(3)) | (tmp_pkt.word_en & BIT(3)))) {
+							 match_word_en &= (~BIT(3));
+						}
+
+						/* ***********	so-2-2-A ******************* */
+						if ((match_word_en&0x0F) != 0x0F) {
+							badworden = efuse_word_enable_data_write(rtlpriv, efuse_addr + 1, tmp_pkt.word_en, target_pkt.data);
+
+							/************	so-2-2-A-1 ******************* */
+							/* ############################ */
+							if (0x0F != (badworden & 0x0F)) {
+								uint8_t	reorg_offset = offset;
+								uint8_t	reorg_worden = badworden;
+								efuse_pg_packet_write(rtlpriv, reorg_offset, reorg_worden, target_pkt.data);
+							}
+							/* ############################ */
+
+							tmp_word_en = 0x0F;		/* not the same bit as original wren */
+							if ((target_pkt.word_en&BIT(0)) ^ (match_word_en&BIT(0))) {
+								tmp_word_en &= (~BIT(0));
+							}
+							if ((target_pkt.word_en&BIT(1)) ^ (match_word_en&BIT(1))) {
+								tmp_word_en &=	(~BIT(1));
+							}
+							if ((target_pkt.word_en&BIT(2)) ^ (match_word_en&BIT(2))) {
+								tmp_word_en &= (~BIT(2));
+							}
+							if ((target_pkt.word_en&BIT(3)) ^ (match_word_en&BIT(3))) {
+								tmp_word_en &= (~BIT(3));
+							}
+
+							/* ************	so-2-2-A-2 ******************* */
+							if ((tmp_word_en & 0x0F) != 0x0F) {
+								/* reorganize other pg packet */
+								/* efuse_addr = efuse_addr + (2*tmp_word_cnts) +1;//next pg packet addr */
+								efuse_addr = efuse_get_current_size(rtlpriv);
+								/* =========================== */
+								target_pkt.offset = offset;
+								target_pkt.word_en = tmp_word_en;
+								/* =========================== */
+							} else {
+								bContinual = false;
+							}
+#if (EFUSE_ERROE_HANDLE == 1)
+							WriteState = PG_STATE_HEADER;
+							repeat_times++;
+							if (repeat_times > EFUSE_REPEAT_THRESHOLD_) {
+								bContinual = false;
+								/* bResult = false; */
+							}
+#endif
+						} else{
+							/* ************  so-2-2-B ******************* */
+							/* reorganize other pg packet */
+							efuse_addr = efuse_addr + (2 * tmp_word_cnts) + 1;	/* next pg packet addr */
+							/* =========================== */
+							target_pkt.offset = offset;
+							target_pkt.word_en = target_pkt.word_en;
+							/* =========================== */
+#if (EFUSE_ERROE_HANDLE == 1)
+							WriteState = PG_STATE_HEADER;
+#endif
+						}
+					}
+				}
+#if 0	/* ULLI : temporary disabled */	
+				DBG_871X("EFUSE PG_STATE_HEADER-1\n");
+#endif				
+			} else	{
+				/* ***********	s1: header == oxff	******************* */
+				bExtendedHeader = false;
+
+				if (target_pkt.offset >= EFUSE_MAX_SECTION_BASE) {
+					pg_header = ((target_pkt.offset & 0x07) << 5) | 0x0F;
+
+					/* DBG_871X("hal_EfusePgPacketWrite_8812A extended pg_header[2:0] |0x0F 0x%x \n", pg_header); */
+
+					efuse_OneByteWrite(rtlpriv, efuse_addr, pg_header);
+					efuse_OneByteRead(rtlpriv, efuse_addr, &tmp_header);
+
+					while (tmp_header == 0xFF) {
+						/* DBG_871X("hal_EfusePgPacketWrite_8812A extended pg_header[2:0] wirte fail \n"); */
+
+						repeat_times++;
+
+						if (repeat_times > EFUSE_REPEAT_THRESHOLD_) {
+							bContinual = false;
+							/* bResult = false; */
+							efuse_addr++;
+							break;
+						}
+						efuse_OneByteWrite(rtlpriv, efuse_addr, pg_header);
+						efuse_OneByteRead(rtlpriv, efuse_addr, &tmp_header);
+					}
+
+					if (!bContinual)
+						break;
+
+					if (tmp_header == pg_header) {
+						efuse_addr++;
+						pg_header_temp = pg_header;
+						pg_header = ((target_pkt.offset & 0x78) << 1) | target_pkt.word_en;
+
+						/* DBG_871X("hal_EfusePgPacketWrite_8812A extended pg_header[6:3] | worden 0x%x word_en 0x%x \n", pg_header, target_pkt.word_en); */
+
+						efuse_OneByteWrite(rtlpriv, efuse_addr, pg_header);
+						efuse_OneByteRead(rtlpriv, efuse_addr, &tmp_header);
+
+						while (tmp_header == 0xFF) {
+							repeat_times++;
+
+							if (repeat_times > EFUSE_REPEAT_THRESHOLD_) {
+								bContinual = false;
+								/* bResult = false; */
+								break;
+							}
+							efuse_OneByteWrite(rtlpriv, efuse_addr, pg_header);
+							efuse_OneByteRead(rtlpriv, efuse_addr, &tmp_header);
+						}
+
+						if (!bContinual)
+							break;
+
+						if ((tmp_header & 0x0F) == 0x0F) {
+							/* wren PG fail */
+							repeat_times++;
+
+							if (repeat_times > EFUSE_REPEAT_THRESHOLD_) {
+								bContinual = false;
+								/* bResult = false; */
+								break;
+							} else {
+								efuse_addr++;
+								continue;
+							}
+						} else if (pg_header != tmp_header) {	/* offset PG fail */
+							bExtendedHeader = true;
+							tmp_pkt.offset = ((pg_header_temp & 0xE0) >> 5) | ((tmp_header & 0xF0) >> 1);
+							tmp_pkt.word_en =  tmp_header & 0x0F;
+							tmp_word_cnts =  Efuse_CalculateWordCnts(tmp_pkt.word_en);
+						}
+					} else if ((tmp_header & 0x1F) == 0x0F) {	/* wrong extended header */
+						efuse_addr += 2;
+						continue;
+					}
+				} else {
+					pg_header = ((target_pkt.offset << 4) & 0xf0) | target_pkt.word_en;
+					efuse_OneByteWrite(rtlpriv, efuse_addr, pg_header);
+					efuse_OneByteRead(rtlpriv, efuse_addr, &tmp_header);
+				}
+
+				if (tmp_header == pg_header) {
+					/* ***********  s1-1******************* */
+					WriteState = PG_STATE_DATA;
+				}
+#if (EFUSE_ERROE_HANDLE == 1)
+				else if (tmp_header == 0xFF) {
+					/************	s1-3: if Write or read func doesn't work ******************* */
+					/* efuse_addr doesn't change */
+					WriteState = PG_STATE_HEADER;
+					repeat_times++;
+					if (repeat_times > EFUSE_REPEAT_THRESHOLD_) {
+						bContinual = false;
+						/* bResult = false; */
+					}
+				}
+#endif
+				else {
+					/* ***********  s1-2 : fixed the header procedure ******************* */
+					if (!bExtendedHeader) {
+						tmp_pkt.offset = (tmp_header >> 4) & 0x0F;
+						tmp_pkt.word_en =  tmp_header & 0x0F;
+						tmp_word_cnts =  Efuse_CalculateWordCnts(tmp_pkt.word_en);
+					}
+
+					/* ************	s1-2-A :cover the exist data ******************* */
+					memset(originaldata, 0xff, sizeof(uint8_t) * 8);
+
+					if (efuse_pg_packet_read(rtlpriv, tmp_pkt.offset, originaldata)) {
+						/* check if data exist */
+						badworden = efuse_word_enable_data_write(rtlpriv, efuse_addr+1, tmp_pkt.word_en, originaldata);
+						/* ############################ */
+						if (0x0F != (badworden & 0x0F)) {
+							uint8_t	reorg_offset = tmp_pkt.offset;
+							uint8_t	reorg_worden = badworden;
+							efuse_pg_packet_write(rtlpriv, reorg_offset, reorg_worden, originaldata);
+							efuse_addr = efuse_get_current_size(rtlpriv);
+						} else {
+							/* ############################ */
+							efuse_addr = efuse_addr + (tmp_word_cnts*2) + 1; /* Next pg_packet */
+						}
+					} else {
+						/* ************  s1-2-B: wrong address******************* */
+						efuse_addr = efuse_addr + (tmp_word_cnts*2) + 1; /* Next pg_packet */
+					}
+
+#if (EFUSE_ERROE_HANDLE == 1)
+					WriteState = PG_STATE_HEADER;
+					repeat_times++;
+					if (repeat_times > EFUSE_REPEAT_THRESHOLD_) {
+						bContinual = false;
+						/* bResult = false; */
+					}
+#endif
+
+					/* DBG_871X("EFUSE PG_STATE_HEADER-2\n"); */
+				}
+
+			}
+
+		}
+		/* write data state */
+		else if (WriteState == PG_STATE_DATA) {
+			/* ************	s1-1  ******************* */
+			/* DBG_871X("EFUSE PG_STATE_DATA\n"); */
+			badworden = 0x0f;
+			badworden = efuse_word_enable_data_write(rtlpriv, efuse_addr+1, target_pkt.word_en, target_pkt.data);
+			if ((badworden & 0x0F) == 0x0F) {
+				/* ************  s1-1-A ******************* */
+				bContinual = false;
+			} else {
+				/* reorganize other pg packet  */
+				/* ***********  s1-1-B ******************* */
+				efuse_addr = efuse_addr + (2 * target_word_cnts) + 1;	/* next pg packet addr */
+
+				/* =========================== */
+				target_pkt.offset = offset;
+				target_pkt.word_en = badworden;
+				target_word_cnts = Efuse_CalculateWordCnts(target_pkt.word_en);
+				/* =========================== */
+#if (EFUSE_ERROE_HANDLE == 1)
+				WriteState = PG_STATE_HEADER;
+				repeat_times++;
+				if (repeat_times > EFUSE_REPEAT_THRESHOLD_) {
+					bContinual = false;
+					/* bResult = false; */
+				}
+#endif
+				/* DBG_871X("EFUSE PG_STATE_HEADER-3\n"); */
+			}
+		}
+	}
+
+#if 0	/* ULLI : temporary disabled */
+	if (efuse_addr >= (EFUSE_REAL_CONTENT_LEN_JAGUAR-EFUSE_OOB_PROTECT_BYTES_JAGUAR)) {
+		DBG_871X("hal_EfusePgPacketWrite_8812A(): efuse_addr(%#x) Out of size!!\n", efuse_addr);
+	}
+#endif	
+	return true;
+}
+
+static u8 efuse_word_enable_data_write(struct rtl_priv *rtlpriv,
+	u16 efuse_addr, uint8_t word_en, uint8_t *data)
+{
+	u16 tmpaddr = 0;
+	u16 start_addr = efuse_addr;
+	uint8_t	badworden = 0x0F;
+	uint8_t	tmpdata[8];
+
+	memset((void *)tmpdata, 0xff, PGPKT_DATA_SIZE);
+
+	/*
+	 * RT_TRACE(COMP_EFUSE, DBG_LOUD, ("word_en = %x efuse_addr=%x\n", word_en, efuse_addr));
+	 */
+
+	if (!(word_en & BIT(0))) {
+		tmpaddr = start_addr;
+		efuse_OneByteWrite(rtlpriv, start_addr++, data[0]);
+		efuse_OneByteWrite(rtlpriv, start_addr++, data[1]);
+
+		efuse_OneByteRead(rtlpriv, tmpaddr, &tmpdata[0]);
+		efuse_OneByteRead(rtlpriv, tmpaddr+1, &tmpdata[1]);
+		if ((data[0] != tmpdata[0]) || (data[1] != tmpdata[1])) {
+			badworden &= (~BIT(0));
+		}
+	}
+	if (!(word_en & BIT(1))) {
+		tmpaddr = start_addr;
+		efuse_OneByteWrite(rtlpriv, start_addr++, data[2]);
+		efuse_OneByteWrite(rtlpriv, start_addr++, data[3]);
+
+		efuse_OneByteRead(rtlpriv, tmpaddr    , &tmpdata[2]);
+		efuse_OneByteRead(rtlpriv, tmpaddr+1, &tmpdata[3]);
+		if ((data[2] != tmpdata[2]) || (data[3] != tmpdata[3])) {
+			badworden &= (~BIT(1));
+		}
+	}
+	if (!(word_en & BIT(2))) {
+		tmpaddr = start_addr;
+		efuse_OneByteWrite(rtlpriv, start_addr++, data[4]);
+		efuse_OneByteWrite(rtlpriv, start_addr++, data[5]);
+
+		efuse_OneByteRead(rtlpriv, tmpaddr, &tmpdata[4]);
+		efuse_OneByteRead(rtlpriv, tmpaddr+1, &tmpdata[5]);
+		if ((data[4] != tmpdata[4]) || (data[5] != tmpdata[5])) {
+			badworden &= (~BIT(2));
+		}
+	}
+	if (!(word_en & BIT(3))) {
+		tmpaddr = start_addr;
+		efuse_OneByteWrite(rtlpriv, start_addr++, data[6]);
+		efuse_OneByteWrite(rtlpriv, start_addr++, data[7]);
+
+		efuse_OneByteRead(rtlpriv, tmpaddr, &tmpdata[6]);
+		efuse_OneByteRead(rtlpriv, tmpaddr+1, &tmpdata[7]);
+		if ((data[6] != tmpdata[6]) || (data[7] != tmpdata[7])) {
+			badworden &= (~BIT(3));
+		}
+	}
+	return badworden;
+}
+
+void
+ReadEFuseByte(
+		struct rtl_priv *rtlpriv,
+		u16 			_offset,
+		uint8_t 			*pbuf)
+{
+	uint32_t	value32;
+	uint8_t	readbyte;
+	u16	retry;
+	//uint32_t start=jiffies;
+
+	//Write Address
+	rtl_write_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL]+1, (_offset & 0xff));
+	readbyte = rtl_read_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL]+2);
+	rtl_write_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL]+2, ((_offset >> 8) & 0x03) | (readbyte & 0xfc));
+
+	//Write bit 32 0
+	readbyte = rtl_read_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL]+3);
+	rtl_write_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL]+3, (readbyte & 0x7f));
+
+	//Check bit 32 read-ready
+	retry = 0;
+	value32 = rtl_read_dword(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL]);
+	//while(!(((value32 >> 24) & 0xff) & 0x80)  && (retry<10))
+	while(!(((value32 >> 24) & 0xff) & 0x80)  && (retry<10000))
+	{
+		value32 = rtl_read_dword(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL]);
+		retry++;
+	}
+
+	// 20100205 Joseph: Add delay suggested by SD1 Victor.
+	// This fix the problem that Efuse read error in high temperature condition.
+	// Designer says that there shall be some delay after ready bit is set, or the
+	// result will always stay on last data we read.
+	udelay(50);
+	value32 = rtl_read_dword(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL]);
+
+	*pbuf = (uint8_t)(value32 & 0xff);
+	//DBG_871X("ReadEFuseByte _offset:%08u, in %d ms\n",_offset ,rtw_get_passing_time_ms(start));
+
+}
diff -Naur linux-4.9/drivers/staging/rtl8821au/efuse.h linux-4.9.8821au/drivers/staging/rtl8821au/efuse.h
--- linux-4.9/drivers/staging/rtl8821au/efuse.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/efuse.h	2016-12-11 19:48:25.156978448 -0600
@@ -0,0 +1,68 @@
+#ifndef __RTL_EFUSE_H_
+#define __RTL_EFUSE_H_
+
+#define EFUSE_INIT_MAP			0
+#define EFUSE_MODIFY_MAP		1
+#define	EFUSE_ERROE_HANDLE		1
+
+#define	PG_STATE_HEADER 		0x01
+#define	PG_STATE_WORD_0		0x02
+#define	PG_STATE_WORD_1		0x04
+#define	PG_STATE_WORD_2		0x08
+#define	PG_STATE_WORD_3		0x10
+#define	PG_STATE_DATA			0x20
+
+#define	PG_SWBYTE_H			0x01
+#define	PG_SWBYTE_L			0x02
+
+#define	PGPKT_DATA_SIZE		8
+
+#define		EFUSE_MAX_MAP_LEN		256
+#define		EFUSE_MAX_HW_SIZE		512
+#define		EFUSE_MAX_SECTION_BASE	16
+
+#define EXT_HEADER(header) ((header & 0x1F ) == 0x0F)
+#define ALL_WORDS_DISABLED(wde)	((wde & 0x0F) == 0x0F)
+#define GET_HDR_OFFSET_2_0(header) ( (header & 0xE0) >> 5)
+
+#define		EFUSE_REPEAT_THRESHOLD_			3
+
+//=============================================
+//	The following is for BT Efuse definition
+//=============================================
+#define		EFUSE_BT_MAX_MAP_LEN		1024
+#define		EFUSE_MAX_BANK			4
+#define		EFUSE_MAX_BT_BANK		(EFUSE_MAX_BANK-1)
+//=============================================
+/*--------------------------Define Parameters-------------------------------*/
+#define		EFUSE_MAX_WORD_UNIT			4
+
+/*------------------------------Define structure----------------------------*/
+struct pgpkt_struct {
+	u8 offset;
+	u8 word_en;
+	u8 data[8];
+};
+
+/*------------------------------Define structure----------------------------*/
+
+
+/*------------------------Export global variable----------------------------*/
+
+uint8_t	rtw_efuse_map_read(struct rtl_priv *rtlpriv, u16 addr, u16 cnts, uint8_t *data);
+
+void	ReadEFuseByte(struct rtl_priv *rtlpriv, u16 _offset, uint8_t *pbuf) ;
+
+uint8_t	EFUSE_Read1Byte(struct rtl_priv *rtlpriv, u16 Address);
+void	EFUSE_ShadowRead(struct rtl_priv *rtlpriv, uint8_t Type, u16 Offset, u32 *Value);
+
+uint8_t	efuse_OneByteRead(struct rtl_priv *rtlpriv, u16 addr, uint8_t *data);
+uint8_t	efuse_OneByteWrite(struct rtl_priv *rtlpriv, u16 addr, uint8_t data);
+void	rtw_efuse_shadow_map_update(struct rtl_priv *rtlpriv);
+
+enum {
+	VOLTAGE_V25	= 0x03,
+	LDOE25_SHIFT	= 28 ,
+	};
+
+#endif
diff -Naur linux-4.9/drivers/staging/rtl8821au/firmware/rtl8812aufw.bin linux-4.9.8821au/drivers/staging/rtl8821au/firmware/rtl8812aufw.bin
--- linux-4.9/drivers/staging/rtl8821au/firmware/rtl8812aufw.bin	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/firmware/rtl8812aufw.bin	2016-12-11 19:48:25.156978448 -0600
@@ -0,0 +1,104 @@
+ &   S|                LM                                                       l     {a   ,6
+
+                                        ?    ?           
+ 	   
+ 
+ 
+ 
+ 
+  	 $"  $"  $"  $"  $!
+  #!  #
+  "  !  1/  01/ 01, 01* 01(  01$  01  0
+
+
+
+		         $&*   !%'(    #&(*    #&(*    #&(*     %'))*     %'))*    #&(***   #&(***      $ 0 H `    < d x  @  @X @ @ @ < P d  @X  x X	` @ @        $ 0 H ` l  2 < P x    P x  ,X  d  hX  d  hX   ( 2 P x   , < x ,	`
+ d  hX  d  hX 
+ 0@P	
+	
+	
+
+	
+	
+
+	
+
+
+
+	
+			
+	
+ "PQ
+	  8,\`dh\`dh   @                                                                                                                                                                                                                         	F	>	2	x	p	dXLi33"`N`$ P$ P##E#F0s(p8"
+"P	"	"t"):"P	%"
+%"*"+:98""[ZYX"KJIH"BBddE"BBE"`"HMPHHH):HMP%H%H):H'HPHI	"):'HP%H%I	"""%5"""ptptsth`N``"P	"	"""ttt"""2Iu$g4y$t@ @yxp0D"#$ x0 P t%tm`@'$tm`$#$0 00TT|TB"xt`vxxv0LtCu`uy"@"t// D0P!t.ti`				@@"t.i`			$/L/ "@"#$0T
+t/IbP.t/tt/l` "t/t/l`	 "@"#$00 0Ia#$0`-`0P.0`%~0#0TNIbDVTO"A A `T!														
+								`&	
+$(,048<@dhlptx|A  LI@)T$3TD @VF @K~`T?0	T`T%`@X
+_g#(&6@xt?zy"3d`"T`Tp"T0`Tp&`J #t#"pT$TT?T0T$T$%&&6Pct?zy'3dpB'TpTp&`5 (t(p	T'T)) *t@&%%TTO TpOD:``p*tttL*I"&"t {":4ttQtN54I1z&TTzTT0TT@TzTTTT?`Q  &7Tp &7`QTOT33TTO`Tu_TOTTO%%TOT3Tu_TOTTTO\T\%%N$3&7urG%r*o"ue"O &7 &71q4tBt&6{zy4  "O|dt5@pQuRXQ}9R}90h8hP:Q:R:S:"4th<hT:}U:}V:}W:tiTDCrP?!~ } {zyHttt1t1U}1U1Q|tttA1tM'TT3wp~ } {zy8HTq:"T}``$pTTN 0)``$pTO:"$" 1Qq'Dqa}T0a1z0a1opa1pA$pA$`I$pa$`a11pqqQ`0d`a1a1pqqQq61d`a1q6d`a1qva1q61qQq6qvdp]dpUbQq61qQq6qvpqT?0{"z P" " D@q1M'Ttkfp)T},oq}D}1Ut"  `qqt"}!U1KHe~ q"z"`$"}
+Y^n}q
+Y^n"}uTT<fTT`uq@u@`$uv3O uv3_u@"<0X>p(}oquq{XDx>t">dp {W0uqT~x"<TT%OTw>uTTfuTTu`uJHeuq<T"u@He"qpppp"@
+D  "2~ :X}-7tco1U"}x`)"}&dp
+\ Y}'q\ Y"wT?`Z}DvD"Z}TvD@"`,"})Ybn}*qYbnt "}Yh"t	-4"<"xHd`q"dpy@`qxHp1"`1fp,T}+qTD@}1Ut"}oq'Tt"uu" D:0:=J*;tJ*;PPL D@:u(ZJ" 0d`;#"@Dt"#2" @0t"uF"-T`7P(}S""t~ :{}1ht(/4Tt+QaTTOTo}St t"{}| %`1Dt /4T1Tt/1T%%DKt/1t/Qutt)/QT"4"t!/4" TQiDQiTt,1Dt,QuDt,4Dttt,QaTMt/Qa"4"t,4"4"t)-4"  @\~x_"&1`Ou
+1_".Hz-H[. [2[7[<[A[F[K[P [U![Y#[]$[b%[f@[tA[kB[xE[oF[}  [q
+qRq qq2q0qqzqqq`RqqN~q)qqAqqOD-".Hq1Hz&$#T+TN+TN+T@N+T NPOt%40OT:v"t%4"1Hq &7t%4"  6 qr$`$p$`-qJ-t%q>uOpOzrOpvAvssvTvTf hbbbhbbHe9>;;T>>>> 0"ptttt-"He>uq"T>uq"IT$Mp.p%$4@$4@A%$4@$4@,p%$+4A$,4A%$4A$4AI|~}K`,`(@#P#0t-@LK#0)t-@K``@P	KK	MtMK"ur!z 33`"I|KM%"I$"JM"He"$4"O0&4O5TTO37""	)}O%~O%3%% &7% &7%"I$4"~t/St>~t/St=?uT0
+~>t/St>tu/"u>uHe"GA &7vPf~ ::&"&:"Z[N""T"++d$t_:1i`o`=m_Ib0}Q`'&TTNTTOqTTqTTqTTqT TqT@TM !90rq>u!q0qfC}@q[q*0CT0CT0C| C@1p1qT0q2`1!u1d`!1!0sq>C1q0qfC}@q[q*0CT0C1qT0y`1Aq2	}Q@t"+u1}}QK?"'"opa `F`qpApA$`a ja oa fa d`a ^a a a ta `a a ~sgpa\PD8p2-!W	p"N&"M""T?"T"C 0"}te/Mt8/4"}t]nt04t@t]/Mt0`MpMdp"p }7ET$P0xxq'0ZT  (opLD@>:qBqW1Tdp&(o` so`T?0T:Vqo "q'0T0qW6T?0Tp;78@2p0y@p}
+"}
+@
+W"="T"6txt}xqo}qo
+D 	}Q"D"p| 33~ `"p2}xq[}q[}VEpT}QT} tenaHTqo}p`>Gwbx'5 Gwx'5 t0q2p`Fx Q"d" p`Gwbx'5 Gwx'5 `"$`p``p u 0 q2p  `.F`00u$/x Q"ax'5`"T"p`ETp="""?t"W<t"p`EySx"W`H6T?08@
+"TT"}qo}"0TT"q2| 
+}Q" "t"SS} St"Kc,`vp`0vT>0T0T@bdp^Oz0^dp.np)<uvMT<vM"4  P^u
+$t5{0Hz4t%w3 GF/> 5 5}/55F657 G%3-< G%3 5-<0Hq}x33->9TuvA;OT<e@};@SBBA\9@
+A
+t!%Bu$KtA5{-Hz @A0Hq G}/>@Vx-<0HqFP]8@
+\:P]:@
+\:P]<PD\:P]DpF0Hq}Put)x+:@uc*`TT]TATA$| B33~`)t%_S`<'{s}t%_St]@u @u
+.-Hq`-Hq &7| v&@PbT\9@
+\:T==@N`	tFNp(@}SR>ed`DwXT\:0PcVXdpfd
+`($3LP$3\:Pwe`*puuu\:Lt!%4et%4wOT .c.d`>T@u @uvD| &>
+.D?>@$3@q3T.qq@qtq|%p43 @T@EePe
+TevaA"t%4"t%4" GuHeuHeuHe  @t0 dp T! T"t%!v33]pu  u He 	D u TDP053_u u O s}u Tn@E z 33_p"t3M*3_u u O{ s} "t%!4"G/"T'"u Heu_T`d`d`	d	`^t^tnQD%nQ*u$\4@%nQ*\uOTnpTQ@%nQ*nndpuOTuooQTQ@%oQ*`0un33*`!`"@$ nn Po`	oo PooQTQ@%oQ*`+n33*`!`@t ,nnoodpuAuqsuoTpTp@	NppPOp$!puOopq}u6@
+t/Q8tC,@Q2t6@Q2t%@Q2t@Q6tQ6"u He/5"$4"u He"t/\#Tu He.Q*t
+He.Q*uQG.Q*}u
+u{unTt!/t?t!/t/nutt/^<t?qnu_TD	uOTuOTu_D uOTuOD@uOTqnuot/\#d`AItt3ttt/t"uHe$%$T$Tun<Tu$qs3p-%$=4Ct-<$@%TM%P%3%Tp/t0$	3_TWt%$\#0t t$	3Ou$nTCDu$o%$p%u$nu$MT'$M}$a"Tppd	`
+ `D"33]pPB| /5tS:)Q*-5tSuHe)Q*	3_t3T
+pDD He"u"uHet"4"t~ n"ou%n"["%T"uHeuHe/t>"`!u
+	{TD"Heu
+"uHeuOT64`	t2t/tt-@	uA@4@5uqs'a}t/Q8;@OE1@C9t/Q8@1'@%t/Q8
+@	p@u"He"$4"GTd'Ht!%4"%$4t/4"He "GD"sK<vEs"D@"<TuIHeuHHeT~;<4gt"z0[t<t6TX~D"  TpT`= 0dp19d`1W 01O!GT"T"TpU0>dp' 	D1@dpDW19d`1W01OT"DT"D"D5"d`1@`pQ"d`1@d`W"p~{Yht "cT01`}Q1`1`"d"0=~ ~} }Np#01	pQ"TQOTTTN\3T%TNTT1@O &70WTP*tO$:&t$TT.TTO&dO &7TPtO_QUO4Hze]e`4HqOTO"TT"Q0TY0DT``=0q+"<0$TqW0uq[T>tVT"uGHeu  tat{i0i0i0_i0	j0bk0k01k0_l0wl0pl06l0Qtat{ 2<0eR>w"`0HT`="T0TY0DT`=""0}QU0/0/t.0$$tP	,+~ Xop`""E@P%$.""fGwbfx'5 Gwfx'5 Gw'HHMHYG@;0/$$Pt/4dPhzqP@
+zqP_@
+i
+@
+$	it
+Pt.M""""t/4/"HYHMG\x
+'"/"0?~ ~} }Np%0gd
+Q"c2a"`&	Od`Od` a""""e~}coT"X"1Hz&"`dYU!d`	Tp`="` "Td` "pW"} | ~6'HHYfGw'He~7]_u$s46T"6T'HHM'HHzx'T   |'T    PQu
+Gh7]Qu
+Gh@x'T   |'T   P'T    1'T    1'T    1'T<   1'T    1'T   1'T    1'T   1'T    1'T    ~1'T    ~1'T    ~1'T<   ~1'T    ~1'T   ~1'T    ~1'T   ~1'T    ~7]~7]"7]u$4Dt6T'Hu$4Dt"Q'T   1'T   ~	1'T   ~	7]~ :i`p~ :iQ'T    7]qQ6Tx
+'"pP@apAqQp1Q'T   1'T   qQa`A!aqQ`aQ'T   1'T   qQQ'T   qQ61'T   qQ41'T   qQ61'T   qQ4'H`A!`A!"7]u$4D"`$P
+``/`k1'Twwww1'Twwww'TT3wp1'TT3wp'Twwww1'Twwww'T?  |'T   ~J'T?  |'T   +x'T   |'T   w'Twwww'T   |'T    ~J'T?  |'T    +`YpKppKp$`1'Tw3w1'Tw3w'T?  |'T   ~J'T?  |'T   +'Tw3w1'Tw3w'T?  |'T    ~J'T?  |'T    +'Tw3ww1'Tw3ww'T?  |'T   ~J'T?  |'T   +'TT3w1'TT3w'T?  |'T   ~J'T?  |'T   ~J'T  |'T    ~	Kx'T   |'T 3  'Tw3ww'T   |'T   ~J'T?  |'T   ~T"x'5|'H8~Tx",~v6'HxHM'xHM| Gw'Hev7]"pex'T0   |'T    tJ'T   |'T   0H'T   |'T   qx'T0   |'T0   TTdpeTDx'T0   |'T    tJ'T   |'T   0H'T   |'T   qx'T0   |'T    "~7]x"HYGjtTHq~T"4~T"d
+"6""HM'H2e"}e"Hzx'T   |'T    PGp}e m} m'T    }Pfx'T   |'T    Pp9'TwwwwD'TwwwwD'T    D'T    7'T    D'T    D'TwwwwD'TwwwwD7]u$4D'Tyy,$4Dx'T   |'T   Tux'T   |'T   J'T   |'T    P'T  }'T   ^'T V'T ?N'T 	1'T &'T   ~	,$4Dx'T   |'T   'T)   x~	'T   |~	'T F)~	'T   |'T   Pj09u|'T-|'T/}'T7]i0/$4D'Th>`i0`/$4D'T(>7]u|'T|'T7]/$4D'T ,$4D'T8 ,$4D'T    7]`aXU@@aeQP{t.@oQY5Pa@\ae 'HQY 'Htaa`d`Pax'T   |'T    P}TTj'Hf'T  }X| Rx'T   |'T   PHMs'T   'T    x'T   |'T    P'T   }'T   ^'T V'T N'T &'T 	1'T    }x'T   |'T   x~	J'T   |'T    |~	'T   ~	7]i0	'T F'T F~	7]jTTdp0'Twww4D'T   w.'Twww4D'T  w7]x'T   |'T   P/$4D'T8 ,$4D'T ,}'T7]p	'T( 'T(D'T( D
+'T(D7]x'T   |'T    ,H'T HMx'5TTx~	J'T  HMx~	J'T   |'T   P}`Xu@@QQQqqQPptq.q@fuQQQq5PTq@PQ1QQ1 Q'H11 Q'Ht`d`PHM'H'T   'T    W'T   |'T    P1{zG@-1{GP 1{GP_1{zG@N1$4Dx'T  |'T   1$4Dx'T  |'T    F1$4Dx'T  1Q1$4Dx'T  HMxQTu$4HMxGHMx'"Tu"W'T   |'T   P1$4D'T   7]1$4D'T   7]1$4D'T    7]1$4Dx'T  HMQ1$4Dx'T  HMQTu$4"HYu"x'5|'H$4"GOT"tHYGHMG\xG'H"HMG\xG'HHYG'HHMx'5'T    4~6'H`cp$`=x'T 0|'T 0 H'T@   |'T    H'T   |'T   dH'T  |'T  x'T 0|'T 0H'T@   |'T    H'T   <fQH'T   2'T   |'T   >`'T  |'T  'T  |'T  H~Tx'T   |'T   'T   |'T     ~
+:x'T 0|'T 0H'T@   |'T@   H'T   <fQH'T   2'T   |'T   >`'T  |'T@  H~'T  |'T  H~T"d~THMTx"x"T}:qh`0`V$p}f'T   j'T   F'T   j'T   Pf'T   j'T   F'T   j'T   'f'T   j'T    F'T   j'T    R"j'H}| Rf"dcn'HfHM'nfHMj Gwr'HdrHM'Hc9""<tJt>:A;B{zy<K<vNv"lpd	`
+m `	D)m}~ Fmw
+`m"1t?t3{zy1}| "HM'H""""'H"u$t5"u  tt8tt 2{ z yS93QRS{ z yT}93RRTS9T}9u  tlt\0tlt 2   D:"~ :i TUUYUVZUW[UX\YT:ZU:[V:\W:S"u  tta0Q=a0wa0a0Dc0Qc0@c0lc0gQc0gc0yxc0d0d0Qd0d01tt 2TT`/`)T``$p-D-D-Dtzy~!"e!`ltt"T# #u$ 4% r*t% 4  {zy"T"""pw":~ } {zy<HN;N;PCTuv0	t-qw&Mv	3O;~ :;N;@aT33N p&_p}q4u
+u
+w;ur$u
+wuw{q	Hew;:va;$qt;a?"4";u"Heu"TL"He;"L$<4"%$4"0t`L0}0;0cW@TDwn}c[Tt~ "}$q`6|tq)z 33_`u/ "tq.4"ppJ3^J3N"t"`O&0OPTdpwwpdpgT"e~7]e~7] D: rTr:D tt	tTFe D: ~@e@e pTTp"6D'H"Hzpdp%t@: Hq&d"D "{zy}R"}ptdp(tB::T":V ~TT ~7] ooT:D@Z t?TSD d'H'Twwww'Twwwwp{zy}RD"T: D: "~7]~6"~7] " ~7] ~"gt"}#g}$W'D@"&u }t2$)KO%YO%g"&%"`&T<TeRTT:A!O1QOTuVTOTTuVTOTuVTO_11 &71{1\3333T1uHHe\3TuIHeTmp&= &7TT<TOTD} cB"t@51$@t?@5} 1$*t_@5}@1$t@%5}`1$4uQuHe"PQ5uHe>P	u$P	u$u$Q5uHe"1|1"1"&T"&T"uCHeuAHeu?He~ -} {zy<H&pQCp"{zy1~31{zy1~313{zy1~314{zy1~315{zy1~3162:6;&T!TO" p:q:u$t5{Zw
+`tvD"uHel"_g`)@D X
+~ :"Hz~qQ`Q| $ >$>$3$Hq_t",$ Wt -WT?t-4t-4Tt-4Dt-4D"4"Hz &vt /4{Hq@ABuC4,$4{Hq$:@ABC4,Hq &7ml~~ d`@{q`2l
+ `lml pvD"HzHq`t/"u &7Hzx'T   |'T    P`~tu
+Gh@"HqHzx'T   |'T    P}eH}+ H)}eH}+ H) H)"{zyHzzyu{zy!u{zy!nf"{zy4Hzzy1"{zyhHzzyP"Hzx'T   |'T    PP6 "H)"6Hqu"Hzx'T   |'T    P~u &vPt"%$4D"%$4Dt"4"%$4D"%$4D"7]"OiOj4}UVWuXUP:VQ:WR:XS:u]^u_u`r0]^_`"ueufuguhb8efgh"D"Dt~ttt$tIt"}tmt;P%$0 "tmt"t&"4U]aU^bU_cU`d4abcd"<UeiUfjUgkUhl<ijklS"0T0#T4t P@ T:"0"0t0~f#0y`p0d`c{"p00	c2y`W"`DT{"	 	 	"d
+ @D@	"
+X_	 0o`6@D"X_2 @0"q3 T:Q	| pTp:T"QQX"`qPQ"000q& Q"D| pDp::`/0t/t D:Q	 D:~ :d` "t3t  t3t"p d?pp0
+ " "TT`"=d?pu_T0D~~"uoTTuvAuOTOtu%uOTt!%t%\#0 d?p_T0u'syqx`0d-p.uOTPu,uHeTN,u-t%_St@}@J]~ut%_StpYt%_SpNPD_ur!z 33_`ut%\#D
+t%_S`t%_St%\#0Qd?pK_T0u<7ep&_T0 D"tu%'{sy$u4"%$4B"`
+@~ ."`
+,@~ "uHeuvAtu,TunTTNunT@Gt,_Sp=unTt,\>TuTOt,\>%3$2>unt!,uOTO@tu,TB's}T%%"4"%$4"uHe"CunuoTssFuvAuOT(tCuOTDtu/C$!@t/_Sp	0C_Pp	C_[`Ct/_S	d,p4 @-P&u-OTOt._Stp	-Pu,C_Ptp!	p!	FP!EDF@CJ}]~pa!	F@>_Crz 33_`}Ee`@C_PDC_P`DCt._StCFC'{s}Qp[QwRk`HV%Ou%%OXSZTtbt{zyT RQw"tFFPW@V
+P
+$E7t9t1:P1/Q@t;/4{zy7 F"F@P"1Hz &70t!{t"O&4O5O6_u\3M5Q@"$!4" 0> dp6uo-r*]>@ 0_" Td `anx'T   |'T   x'T   |'T   qp q`x'T   |'T   qx'T@   |'T@   2d`xx'T   |'T   H'T@   |'T    Ep q`x'T   |'T   Px'T   |'T   ~T"~Td"<P@x'T  |'T  !f'T  j'T    F'T  j'T    J2P0Px'T  |'T	(  dt2P@Px'T  |'T  >(PtPx'T  |'T  tvPx'T  |'T$  !2P/@P*f'T  j'T  F'T  j'T  f(P/P*f'T  j'T  F'T  j'T  3tP.f'T  j'T  F'T  j'T  RQdpQ0Put*^@Put:SpPutjHPutz=Put2Put'P!utdp2$t$tf'T   t@'T   tf'T   f@'T   j'HR"`~Ttd"t$"P{`*{dp#@{p
+{"T 0"ihz $ >``$p%TDThD"Th"dp@~
+~	|8|,| dpdp|||TL"TTT`,`$`$p*%t%t%t	%t"d@d@ "d@d"$d"x'T   |'T    P"t?PTTx'T   |'T    tJ'T   |'T   F'T   |'T   ~
+Tu?%%t8/4"~ } {zyHTPit"z"tggSg'T"}.oS}QUzt"}!SggWgg}"S}%W$`p$tp7D"dp2Tp)@  T?0	:p" "TS}QUSSSt.4	t"}/S}QUt"SQQt"op>dpp0TQMdp`TQtS"D@D"%Pt"7]u"T4"u$4"u$4"G'H"$4D"jTT"t!%4"6T'Ht"4ttTDt"t% 4"7]u$"| &%5"bax"u$4D"HqKHe~ }"%$=4C"6T"He"t%4"t%4"~6"TT"T""t"Gw'HT"<T""0Hqu""dt"t""v"t "
+T"T333T""t"Cu"}"G""s"D"}2"}1"}0"T"/^""\]N"333TO"TOu"t~ ""&
\ No newline at end of file
diff -Naur linux-4.9/drivers/staging/rtl8821au/firmware/rtl8821aufw.bin linux-4.9.8821au/drivers/staging/rtl8821au/firmware/rtl8821aufw.bin
--- linux-4.9/drivers/staging/rtl8821au/firmware/rtl8821aufw.bin	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/firmware/rtl8821aufw.bin	2016-12-11 19:48:25.156978448 -0600
@@ -0,0 +1,90 @@
+!    	o                Ig             h8             w                             g     o     w                                        ?    ?       
+ 	   
+ 
+ 
+ 
+ 
+  	 $"  $"  $"  $"  $!
+  #!  #
+  "  !  1/  01/ 01, 01* 01(  01$  01  0
+
+
+
+																
+								         $&*   !%'(    #&(*    #&(*    #&(*     %'))*     %'))*    #&(***   #&(***      $ 0 H `    < d x  @  @X @ @ @ < P d  @X  x X	` @ @        $ 0 H ` l  2 < P x    P x  ,X  d  hX  d  hX   ( 2 P x   , < x ,	`
+ d  hX  d  hX 
+ 0@P	
+	
+	
+
+	
+	
+
+	
+
+
+
+	
+			
+	
+ "PQ 	  8,\`dh\`dh   @                                                                                                                                                                                                                                                        2Eu$g4y$t@ @yxp0D"#$ x0 P t%tm`@'$tm`$#$0 00TT|TB"xt`vxxv0JtCu`uy"@"t// D0P!t.ti`				@@"t.i`			$/J/ "@"#$0T
+t/FP.t/tt/l` "t/t/l`	 "@"#$00 0F#$0`-`2P00`'~0%0TNFDVTO"[ZYX"KJIH"BBddE"BBE"I<PIII):I<P%I%I):ImPII"):mP%I%I"""%5"""ptptsth`""ttt"""JF@)T$3TD @VF @J[~`T?0	T`T%`@A A `&M	
+$(,048<@dhlptx|A1  LX`-u P"q av &q '$`$`al&Salt%&f<qTqRqTqoqmNqaTqaTq& q&q&q&q&q&q&q&1Tq{q0Q"ptttt-"1Tq{u"q{u&"R ~::,TQGD@@x t?TSD "u 'P'"TQqDQq"qDQrqTrQD tt	tGTnKx,DQ ~hKhK"Tq_Uq_Vq_Wq_TQUQVQWQS"qTQQ=;jF_tF_`qD@Qu(`&xqDQtG^7Tm1<m!q0>qdp5""!umC-l q{"@q0Q"DQ`/0t/tqDQx_qDQ~ =zuQ1T"TQtTSORITTT0TWIT@TUOVITTYTT?ZVTOUT33TTOY`STuQaTOTTTO%%TORT3TuQaTOWTTTOt%QfTt%QfZ%%NXXu uQl%Xl XXQi"0>8?PQQQRQSA4t?<?TQ}UQ}VQ}WA"O TT"u_>u]1T"7Dm"q Q"uPQQQRQSAqD"\qTQx_T0PT"} REqt"`TumITulITT~;<5z{t"`0Vbp'}oQEQu1mD&bt"bdpl0u1T~."`T"`TT%OTObQuQTTQuQTTuQ!unITuQ4	@!6u
+`$
+u)	o3O u)	o3_
+6	u	!M"`%"}Qx}QExq"oIT~ 1""T}QuTQTT`QQTTQ!uTQ4T!@uTdIT"QEpppp" @
+D  "2~ =zx NP@y  y  y  y    y  y    nP0Py  y	(  et2P@Py  y  ?PtPy  y  tvPy  y$  P.@P)y  y  y  y  eP.P)y  y  y  y  2tP+y  y  y  y  0 dpQ0Pup*^@Pup:SpPupjHPupz=Pup2Pup'P!up dp-$p$py   py   py   y   m0"w#mI<:I< HzmI<m<3"m}| 0"`0`V$p}y   y   y   y   Py   y   y   y   'y   y    y   y    0"wT`TqTQPtOHTuQTOGTTuQTOGTuQTO u/S u{/S333TulITTumITTmp"agTT`TOTD} qi" T|}=,#|}`*"}&Qdp }'QECC q"}"}| "ucIT}oQE'Tt"J==d$tX=n18`o`O+F0
+}}/T0!OR0!op!p!$$p!^$`H$p!$`!1pQ3Q/`pzd`!C!pQ3Q11d`!1d`!QL!11Q1QLdp[2dpSiN11Q1QLpQ3i0+"d`0t@+t " Q'DQERE D@Q'TtRE.L2.`tt"Ep1T},oRE}WiD}Qt""T}-``$pTTOK0,-``$pTOJ"w'THTTTTTTT TT@TM a0qqeuT!0CT}@q{T0CTT0CTT0CT CT@ppw0`w:uTpd`kwk0oqeCT10CT}@q{T0CTT0CTp0
+x`.	}g@t")uTp}}g]?"'T",op`B`lp,pW$`,,,,d`,,,,`,^y,Om,Oa,p[W,%L,A,6,p0,,n ,W,f,p"}AN"tAE~ } {zyttt5Q}QQtttA5VT8W9X:Y;Z0[1\2]3^~ } {zyOpXtQ"gREpt}Adpg`nspc"tt"t"L2t'D@"M""T?"p"T"C 0" 	}g" "}"REt"$t"L2tQt"sd`nWe"0
+x`}gx`"d"d`g`
+pg"` "Td` "p00"WO}!RE.L2.T"K K ""_Odt#D6uu"H>`p`0Tx0T0Tz0QQ@QrpMOR0HpQnp
+Hp-Qnp(RNm=Ru6TNQ6"  PQu
+$t5{BIiVWt%QE /> 5 5/5GHGI %3-< %3 5-<BI`x33->Km=RTSuQoMMTN@"MS@SSRBRSA7S@ASAXXu$t@5{?IiWV P`BI` />@	}QWVxVW-<BI`PQQpFBI`Pt)WVxVW+:@@uYWV @uYYQTU\\?I`\\\?I` | UT@UUTTTUQTUPQU@Pt%Q 0OOtS:O}SO}S6}	}Q+-++@ +t/>QQRQ{TUd`SQ<T[80PU<dpdd
+`($30P$38PWeS`*[pu[[u[u[80t%Q4[t%Q4WSMT d`TU T[@uYWV @uYYDX| PZZZDSQUPT@ZZZZ[$3Z@Z3T.@t_%p[[FE @[ TRE[tPQ2Q{"[t%Q4"t%Q4" uQITt%Q4"t%Q4"Q$Tt%QWTNt%QWTNt%QWT@Nt%QWT NQPOI7t%Q0MT8Qp"ct%]4"CI`TORtTTTNWT%TNTTOG0RTP*t$:t$TT.TTOTPt Zs"/"%$4"t%Q4" T"WVY"u CIi2u  L0Oz 2u  ~0\0000$0r%00h0z000_000 2dd@!drp!dTdTt/33]`sudf% udIT 	D L0udCudM1-11@d1udCudM1{drd"t%d4"Tk"uOaT`d`d`	d	`
+$t$tl%l u$V4@%l \uMTlpT%l lldpuMTummqT%m `3ul335`,`"@$ ll Pm`	mm PmmqT%m `.l335`,`@t ,llmmdpuuNuCTnTn@	NnnPOn$[nuM1nru,6@
+t/
+tO,@t>@t)@t@t"u IT/5"$4"u IT"t/fTu IT. t
+IT. u. u
+uzt/[t?t/gt/ftt/4t?IuOaTD	uMTuMTuOaD uMTuMD@uMTIuCt/fd`jItt3ttt/|t"uQ ITuITTp_pd	`
+ `D"33]pBPBa| /5t) `-5tuIT) 3_t3T
+p^^DD `IT"u"`k{^]hihThTuf%TuhN>p t-<h@iTMiPi>iTp)$3_TE$3Ouhf%TC333TODuhCihpiuhf%uh6Tkh6}h2"4"uITuITt"ToGEo"u  !0v!0Q!0"0#0#0#0$0o$0$0$0 2`0
+1bO"R0$QU`+SUst11"}}t/Mt0/TTT}} tt8/4"TRTNdpST`
+}1iQ11	1q+11i1_C"}t/M}1{}tt0p2}x1{}1{}1	Qp
+QTT}XgQ
+X6txt}x}
+D`Q 	}Xgq"}St}"L2^zT"R0;01qQ"0t`H0Y0	;01q*@TDoTs"`0sQ
+XO"T_| 33\]N `"U0OIVVUTTVP TT#TQTpTUpQpQTT"ZE`apaqdp"p q`"Tq$P0DT03T *op D@?t1i1w q"D"T"FIi1`FI`TOI"QRS HRSOHTSURT!d`d` \w"@Ii?Irt ttttttu u!u#u$u&%u/'u7(u@@uIBuRE  uZ@I`@I`A@I`I@I`1@I`VR@I`]@I`q@I`f@I`@I`@I`Z@I`@I`"@I`@I`N@I`fD@I`D?"OHCtQtE{zyC{%(G(N"zyC{zyzyf{zyzyGd{zyL{zyzyfzyC"{zyFIiy   y    ~8HMM8{@y   y   ~y    y    y    y<   y    y   y    y   y    ~8~8"#I`y   y    ~}eH} I I"$To%Q}OH%Q"y   y    ~H?}e <} <y    }I<m24"I`Ii"QRS""}!{/^"22} | ~7mIHHzmMK~8Xu$4Q7T""~ =z1c	 0o`4@D"X2 @0";1d`;<;@Dt;X<2; @0t"uTD1[T @"1cq`#@D 1\"
+~ =z"Ii~1`Q| $ >$>q$31$I`Qt",$ Q(t -Q(T?t-4t-4Tt-4Dt-4D"4"~~ d`?q{1k`2
+ ` pD"Ii t /4{I`@ABuC4b$4{I`$:@ABqC4bI` "u$t5"pd	`
+ `	D)q}~ c
+`"Nt\tPLSMT{zyNq%up]k`K%O%%Ott{zyq%u"$4"{zyC~3C{zyC~3CE{zyC~3CF{zyC~3CG{zyC~3CHD#LHMa"y    4~7m`^p$`oy 0y 0 y@   y    y   y   dy  y   Ry 0y 0y@   y    y   <py   w8y   y   `y  y  y  y   H~y   y   y   y     ~
+my 0y 0y@   y@   y   <py   w8y   y   `y  y@  H~y  y  H~"xZm~",~7mI<:I< HzmMK8"`y0   y    ty   y  p ~y   y   p~y   y   0y   y   4y   y    y0   y0    TTd`Wy   y  P ~y   y   @~TDy0   y    t~y   y   0~y   y   4~y   y   Qy0   y    q "+`!0$P
+``1`sAywwwwvywwww!yT3wpvyT3wpA4ywwwwvywwww~Qy?  y   ~~y?  y   Ay   y   wQywwww~Qy   y    ~~y?  y    A+`_p!pA p!pA$`Ayw3wvyw3w~Qy?  y   ~~y?  y   Ayw3wvyw3w~Qy?  y    ~~y?  y    Ayw3wwvyw3ww~Qy?  y   ~~y?  y   AyT3wvyT3w~Qy?  y   ~~y?  y   ~~y  y    ~	Py   y 3  Qyw3ww~Qy   y   ~~y?  y   ~~"~	8"~~"~~X"t~T"	qTt%QOH%QW%Q %Q %Qg%Q"Q%Q"|""T:TO"OI0KtLTTOWN"Ktt
+TDt""Q"HVTNT333TTOVTdp!i8O>0O?0t9t St"P\1]2^3W8Z;pZ3]T"[0X9Y:"}-R7tpKZ" p9u$t5{t
+`mTD" "uIT" l"?]~ -} {zy`Tp_W3^_W3Nj"t"t.4"}$b`5|)t)bz )33`u)/ "Z[N"Tt~ "s~ } {zyuttPATu,0	t-o3Ot~ =ztt@T33N p_p}%$4u
+u
+tuku
+uz	ITts2t$ttQ"IT4"tu"ITu"uIT`!u
+nnnn	z(TD("ITu
+"IT"(D@"T"ITt"$u4"%$4t/4"0T"0D"~efee`lttfTgdgu$ 4%dl t%d4dd{zy{%fTfffpou"IiI`gt/"4"uuur0"uuuu b8 "D"DTy[Dt"}tt_P%$01+ "tt"t"_d`1!T`tqPt_01+W0tHT? t 5Q`t'b0tb0TtKt "t"R '`1`t t	t ""`1QX"000QK Q"d` "MO"O?"t"4UUUU4"<U!U"U#U $<!"#$S"0T0#T4t N TJ"0"0t0dpaE`aZNs`"$`p``p ud0d^pdd`-q`qqu$/P& Xc""D"`[EpWYNt0^p`qP& Xc"rd"T?"bax"Ep`P&"Ep`TpXO"W<t"W`f0oM@r"T"T0T0wf0Tp94M@0Ep/gp*"*@
+_Q"XO"TT"Z@P%$"TK"T?"`9Ep5T}+RETWeD@}Zt"t"0>~ ~} }Np$0
+Xg"^\w"0$$tP	},+}~ X""0}Z0/0/t"s""t"^0T70DTtXO"OR0T70DT`XO0@""`0$Tl0upTbtPQ@"ukIT`P[DL"0_x`p0d`	s "r`gd`_Q"r`	TpXO"T"ddTp	TXOd0dpgd`_Qd0P&AT"TpW0=dp# gdp"D1Wgd`_Q0P&AT"D"p{%Qq"{}Q| %`1Dt /4T1T1T%%DK1t/Qtt)/1T"`)"})RW1}*REW1Qq"1T?`
+1D1D"1T1D@"t)-4"t	-4"t/4"t!/4" TQeDQeTt,1Dt,QDt,4Dttt,Q]TMt/Q]"4"t,4"t "!D"4"1`" "TTtzy{%u0?~ ~} }Np%0_b	pXg"KK"d @D@"xt\tK t\t"~3@5PuOaT0Dq"t/4"uMoqTt/uITTK@qTBknrumC]T_umNuouMT^_uMTSt*q_t*^_@_]p``]0_]``p`]q{`
+]``p`]d,p+^ @$^P^u]-^uMTO``p`]-^Pu],``p``p`_P\TS_l__]lU]_@Fku 33UUN` _UtTe``	@U]S]]]^k]nr`
+,@~ "T%%"4"Tu"S%$4B"%$4"`
+@~ ."8u$4Dt7TEmu$w4Dt"y   vy   ~	vy   ~	8~ <y    8$4DTx
+GpP@pB$4DTp&y   y   @`$4DTpNy   y   8$4D7TIm tUy  y   y  y    ~`` "~u"7" d
+"$4D"TT`"3@5PuOaT0D~~"]t/l
+;@QG1@E;t/l
+@2(@&t/l
+
+@	p@u]]]"RSTuMTHF`	t2t/ttS-@
+uRo S@FS@GuRmNTkRnr]umC^c^T_^Tu]oau]MTb_q]g^Ot%]u]MT`t%]`f0 _d?pOYT0u^_^`knn^]`^0a^__d-p/u]MT`Pu^,``u]ITTNa_,u^-a_a@a_@_Pf uc_,@_5Pf ucfDfTf 0fTcdppq    q0]fD_u_u^a__u_u^a_u_u^a_@u_u^a_Pa_@au_u^zcdpyq  q  0f_d,`_-u_6u^6N_d.`_/u_7u^7;_0u_8u^8._1u_9u^9!_2@_4Pu_:u^:_5u_;u^;nifT_bl_abla_aP;]kz 33`_u__^fD
+__^^b^f0V_d?pPOYT0u^A_^<_eap*O\T0^ _D^_%$O4B]t%]a^niu]IT"u]IT"S%$O4B"%$Y4Dt"wy   y    ~qvu {P7h"I`uI"wy   y    ~vgq{I`HMM8{@"%$_4D"u"wy   y    ~P87h"%$o4D"T 0"$#PB`*Bdp#$#@Bp
+$~B"ihz $ >``$p%TDThD"Th"dp@~
+~	|8|,| dpdp|||TL"y   y    ~"t?PTTy   y    t~y   y   8~~y   y    ~o{zH`o{zHpHy  y   y  y    Dy  I<y  I<x~I<xGxZm"y   y   ,~$4Dy   8$4Dy   8$4Dy    8$4Dy  I<$4Dy  I<~O?x|}{zDycy   y    ~$q4Dywwww8$s4Dywwww8$u4Dyyy$4Dy   y   :y   y   ~y@   y@   ~$y4Dy   y w  ${4Dy   y    $}4Dy   y   ~y   y    ~y  }y   y   ?y ?y 	1y `wy   ~	vy   ~$4Dy   y   y)   x~	vy   |~	vy F)y   y   ~0cycy80y@>0y >8$4Dy $4Dy8 $4Dy    8Kp$!4m`@y   y    ~}w#TTmy  }X| U0y   y   ~p`y   y    ~y   }y   y   /y y `y 	1y    }wy   y   x~	~y   y    |~	y   ~	vy Fy   y   ~$4Dy8 $4Dy hyy(@8y   y    ,~y KoTTx~	~y  Tx~	~y   y   ~}phm`Ppy   y    Kk4%%hkdp@x5PqPWt@KP9@4mxQmtd`,#y   y    py   y    @[5Pc4PJt@?P1@-14mxQmtd`	1,1#y   y    %$4"%$4"tIHH/>3"3m"3mIHH%$"I<mI<m"VPWQ%GuITV>VP	uWV$VP	uWV$uWV$Q%GuITW"TUtT@GUQ$@t?T@GU} Q$*t_T@GU}@Q$tT@%GU}`Q$4uUQ9uIT"T1?C"ugIT1QR"ueIT~ } {zyTO@t"^}#OL2}$W}%WQ0[t<tMTX~P.D"T"$`p$tpND"}.oRE}ZQt"'T"baxT?@ t
+/Pt)qdPaq,@q,_@q@
+$	qt
+Ptq"t-4""t.4	t"}/REK}Zt"0op>dp0p0TZdp0`Tt^t"D@D"8u"}ew"~u"%$4"%%$!4I<xG%$4"mIHHd~~I<T"WuITHm"%%$4"t%Q4"u$4D"mII<%%"| %UU5TT"Q%$4"/t>"TNTTO"~ } {zyR""oIT~ }"IHHm4t@p ~8 ~"$4D"IT"%%$-4"$4"t%Q4"t%Q4"d"TT"X"I<xGT"`T"
+"EI<td"t$"BI`u"WV"dt"tUT"VW"QRS"IT"Y"T333T"t"""mu%l"["iT"~7"~ =z
+T"}"$94"T"~8 ~8T""}2"}1"}0"~ <`~~t~ l"TOu"T"J
\ No newline at end of file
diff -Naur linux-4.9/drivers/staging/rtl8821au/hal/Hal8812PwrSeq.c linux-4.9.8821au/drivers/staging/rtl8821au/hal/Hal8812PwrSeq.c
--- linux-4.9/drivers/staging/rtl8821au/hal/Hal8812PwrSeq.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/hal/Hal8812PwrSeq.c	2016-12-11 19:48:25.156978448 -0600
@@ -0,0 +1,98 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+#include "Hal8812PwrSeq.h"
+#include <rtl8812a_hal.h>
+
+/* 
+    drivers should parse below arrays and do the corresponding actions
+*/
+//3 Power on  Array
+struct wlan_pwr_cfg rtl8812_power_on_flow[RTL8812_TRANS_CARDEMU_TO_ACT_STEPS+RTL8812_TRANS_END_STEPS]=
+{
+	RTL8812_TRANS_CARDEMU_TO_ACT
+	RTL8812_TRANS_END
+};
+
+//3Radio off GPIO Array
+struct wlan_pwr_cfg rtl8812_radio_off_flow[RTL8812_TRANS_ACT_TO_CARDEMU_STEPS+RTL8812_TRANS_END_STEPS]=
+{
+	RTL8812_TRANS_ACT_TO_CARDEMU
+	RTL8812_TRANS_END
+};
+
+//3Card Disable Array
+struct wlan_pwr_cfg rtl8812_card_disable_flow[RTL8812_TRANS_ACT_TO_CARDEMU_STEPS+RTL8812_TRANS_CARDEMU_TO_PDN_STEPS+RTL8812_TRANS_END_STEPS]=
+{
+	RTL8812_TRANS_ACT_TO_CARDEMU
+	RTL8812_TRANS_CARDEMU_TO_CARDDIS
+	RTL8812_TRANS_END
+};
+
+//3 Card Enable Array
+struct wlan_pwr_cfg rtl8812_card_enable_flow[RTL8812_TRANS_ACT_TO_CARDEMU_STEPS+RTL8812_TRANS_CARDEMU_TO_PDN_STEPS+RTL8812_TRANS_END_STEPS]=
+{
+	RTL8812_TRANS_CARDDIS_TO_CARDEMU
+	RTL8812_TRANS_CARDEMU_TO_ACT		
+	RTL8812_TRANS_END
+};
+
+//3Suspend Array
+struct wlan_pwr_cfg rtl8812_suspend_flow[RTL8812_TRANS_ACT_TO_CARDEMU_STEPS+RTL8812_TRANS_CARDEMU_TO_SUS_STEPS+RTL8812_TRANS_END_STEPS]=
+{
+	RTL8812_TRANS_ACT_TO_CARDEMU
+	RTL8812_TRANS_CARDEMU_TO_SUS
+	RTL8812_TRANS_END
+};
+
+//3 Resume Array
+struct wlan_pwr_cfg rtl8812_resume_flow[RTL8812_TRANS_ACT_TO_CARDEMU_STEPS+RTL8812_TRANS_CARDEMU_TO_SUS_STEPS+RTL8812_TRANS_END_STEPS]=
+{
+	RTL8812_TRANS_SUS_TO_CARDEMU
+	RTL8812_TRANS_CARDEMU_TO_ACT
+	RTL8812_TRANS_END
+};
+
+
+
+//3HWPDN Array
+struct wlan_pwr_cfg rtl8812_hwpdn_flow[RTL8812_TRANS_ACT_TO_CARDEMU_STEPS+RTL8812_TRANS_CARDEMU_TO_PDN_STEPS+RTL8812_TRANS_END_STEPS]=
+{
+	RTL8812_TRANS_ACT_TO_CARDEMU
+	RTL8812_TRANS_CARDEMU_TO_PDN		
+	RTL8812_TRANS_END
+};
+
+//3 Enter LPS 
+struct wlan_pwr_cfg rtl8812_enter_lps_flow[RTL8812_TRANS_ACT_TO_LPS_STEPS+RTL8812_TRANS_END_STEPS]=
+{
+	//FW behavior
+	RTL8812_TRANS_ACT_TO_LPS	
+	RTL8812_TRANS_END
+};
+
+//3 Leave LPS 
+struct wlan_pwr_cfg rtl8812_leave_lps_flow[RTL8812_TRANS_LPS_TO_ACT_STEPS+RTL8812_TRANS_END_STEPS]=
+{
+	//FW behavior
+	RTL8812_TRANS_LPS_TO_ACT
+	RTL8812_TRANS_END
+};
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/hal/Hal8821APwrSeq.c linux-4.9.8821au/drivers/staging/rtl8821au/hal/Hal8821APwrSeq.c
--- linux-4.9/drivers/staging/rtl8821au/hal/Hal8821APwrSeq.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/hal/Hal8821APwrSeq.c	2016-12-11 19:48:25.156978448 -0600
@@ -0,0 +1,96 @@
+
+/*++
+Copyright (c) Realtek Semiconductor Corp. All rights reserved.
+
+Module Name:
+	Hal8821PwrSeq.c
+	
+Abstract:
+	This file includes all kinds of Power Action event for RTL8821A and corresponding hardware configurtions which are released from HW SD.
+	    
+Major Change History:
+	When       Who               What
+	---------- ---------------   -------------------------------
+	2011-08-08 Roger            Create.
+	
+--*/
+
+
+#include "Hal8821APwrSeq.h"
+#include <rtl8812a_hal.h>
+
+
+/* 
+    drivers should parse below arrays and do the corresponding actions
+*/
+//3 Power on  Array
+struct wlan_pwr_cfg rtl8821A_power_on_flow[RTL8821A_TRANS_CARDEMU_TO_ACT_STEPS+RTL8821A_TRANS_END_STEPS]=
+{
+	RTL8821A_TRANS_CARDEMU_TO_ACT
+	RTL8821A_TRANS_END
+};
+
+//3Radio off GPIO Array
+struct wlan_pwr_cfg rtl8821A_radio_off_flow[RTL8821A_TRANS_ACT_TO_CARDEMU_STEPS+RTL8821A_TRANS_END_STEPS]=
+{
+	RTL8821A_TRANS_ACT_TO_CARDEMU
+	RTL8821A_TRANS_END
+};
+
+//3Card Disable Array
+struct wlan_pwr_cfg rtl8821A_card_disable_flow[RTL8821A_TRANS_ACT_TO_CARDEMU_STEPS+RTL8821A_TRANS_CARDEMU_TO_PDN_STEPS+RTL8821A_TRANS_END_STEPS]=
+{
+	RTL8821A_TRANS_ACT_TO_CARDEMU
+	RTL8821A_TRANS_CARDEMU_TO_CARDDIS
+	RTL8821A_TRANS_END
+};
+
+//3 Card Enable Array
+struct wlan_pwr_cfg rtl8821A_card_enable_flow[RTL8821A_TRANS_CARDDIS_TO_CARDEMU_STEPS+RTL8821A_TRANS_CARDEMU_TO_ACT_STEPS+RTL8821A_TRANS_END_STEPS]=
+{
+	RTL8821A_TRANS_CARDDIS_TO_CARDEMU
+	RTL8821A_TRANS_CARDEMU_TO_ACT		
+	RTL8821A_TRANS_END
+};
+
+//3Suspend Array
+struct wlan_pwr_cfg rtl8821A_suspend_flow[RTL8821A_TRANS_ACT_TO_CARDEMU_STEPS+RTL8821A_TRANS_CARDEMU_TO_SUS_STEPS+RTL8821A_TRANS_END_STEPS]=
+{
+	RTL8821A_TRANS_ACT_TO_CARDEMU
+	RTL8821A_TRANS_CARDEMU_TO_SUS
+	RTL8821A_TRANS_END
+};
+
+//3 Resume Array
+struct wlan_pwr_cfg rtl8821A_resume_flow[RTL8821A_TRANS_ACT_TO_CARDEMU_STEPS+RTL8821A_TRANS_CARDEMU_TO_SUS_STEPS+RTL8821A_TRANS_END_STEPS]=
+{
+	RTL8821A_TRANS_SUS_TO_CARDEMU
+	RTL8821A_TRANS_CARDEMU_TO_ACT
+	RTL8821A_TRANS_END
+};
+
+
+
+//3HWPDN Array
+struct wlan_pwr_cfg rtl8821A_hwpdn_flow[RTL8821A_TRANS_ACT_TO_CARDEMU_STEPS+RTL8821A_TRANS_CARDEMU_TO_PDN_STEPS+RTL8821A_TRANS_END_STEPS]=
+{
+	RTL8821A_TRANS_ACT_TO_CARDEMU
+	RTL8821A_TRANS_CARDEMU_TO_PDN		
+	RTL8821A_TRANS_END
+};
+
+//3 Enter LPS 
+struct wlan_pwr_cfg rtl8821A_enter_lps_flow[RTL8821A_TRANS_ACT_TO_LPS_STEPS+RTL8821A_TRANS_END_STEPS]=
+{
+	//FW behavior
+	RTL8821A_TRANS_ACT_TO_LPS	
+	RTL8821A_TRANS_END
+};
+
+//3 Leave LPS 
+struct wlan_pwr_cfg rtl8821A_leave_lps_flow[RTL8821A_TRANS_LPS_TO_ACT_STEPS+RTL8821A_TRANS_END_STEPS]=
+{
+	//FW behavior
+	RTL8821A_TRANS_LPS_TO_ACT
+	RTL8821A_TRANS_END
+};
diff -Naur linux-4.9/drivers/staging/rtl8821au/hal/hal_com.c linux-4.9.8821au/drivers/staging/rtl8821au/hal/hal_com.c
--- linux-4.9/drivers/staging/rtl8821au/hal/hal_com.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/hal/hal_com.c	2016-12-11 19:48:25.156978448 -0600
@@ -0,0 +1,130 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#define _HAL_COM_C_
+
+#include <drv_types.h>
+#include <odm_precomp.h>
+
+#define	EEPROM_CHANNEL_PLAN_BY_HW_MASK	0x80
+
+/*
+ * 	u8 hw_channel_plan,	channel plan from HW (efuse/eeprom)
+ *	u8 sw_channel_plan,	channel plan from SW (registry/module param)
+ *	u8 def_channel_plan,	channel plan used when the former two is invalid
+ *	bool AutoLoadFail
+ */
+
+#define rtw_is_channel_plan_valid(chplan) (chplan<RT_CHANNEL_DOMAIN_MAX || \
+					   chplan == RT_CHANNEL_DOMAIN_REALTEK_DEFINE)
+
+
+u8 hal_com_get_channel_plan(struct rtl_priv *rtlpriv, u8 hw_channel_plan,	
+			    u8 sw_channel_plan, u8 def_channel_plan,
+			    bool AutoLoadFail)
+{
+	uint8_t swConfig;
+	uint8_t chnlPlan;
+
+	swConfig = true;
+	if (!AutoLoadFail) {
+		if (!rtw_is_channel_plan_valid(sw_channel_plan))
+			swConfig = false;
+		if (hw_channel_plan & EEPROM_CHANNEL_PLAN_BY_HW_MASK)
+			swConfig = false;
+	}
+
+	if (swConfig == true)
+		chnlPlan = sw_channel_plan;
+	else
+		chnlPlan = hw_channel_plan & (~EEPROM_CHANNEL_PLAN_BY_HW_MASK);
+
+	if (!rtw_is_channel_plan_valid(chnlPlan))
+		chnlPlan = def_channel_plan;
+
+	return chnlPlan;
+}
+
+bool HAL_IsLegalChannel(struct rtl_priv *rtlpriv, uint32_t Channel)
+{
+	bool bLegalChannel = true;
+
+	if (Channel > 14) {
+		if(IsSupported5G(WIRELESS_MODE_MAX) == false) {
+			bLegalChannel = false;
+			RT_TRACE(rtlpriv, COMP_ERR, DBG_LOUD, "Channel > 14 but wireless_mode do not support 5G\n");
+		}
+	} else if ((Channel <= 14) && (Channel >=1)){
+		if(IsSupported24G(WIRELESS_MODE_MAX) == false) {
+			bLegalChannel = false;
+			RT_TRACE(rtlpriv, COMP_ERR, DBG_LOUD, "(Channel <= 14) && (Channel >=1) but wireless_mode do not support 2.4G\n");
+		}
+	} else {
+		bLegalChannel = false;
+		RT_TRACE(rtlpriv, COMP_ERR, DBG_LOUD, "Channel is Invalid !!!\n");
+	}
+
+	return bLegalChannel;
+}
+
+void HalSetBrateCfg(struct rtl_priv *rtlpriv, uint8_t *mBratesOS,
+	u16	*pBrateCfg)
+{
+	uint8_t	i, is_brate, brate;
+
+	for(i=0;i<NDIS_802_11_LENGTH_RATES_EX;i++)
+	{
+		is_brate = mBratesOS[i] & IEEE80211_BASIC_RATE_MASK;
+		brate = mBratesOS[i] & 0x7f;
+
+		if( is_brate )
+		{
+			switch(brate)
+			{
+				case IEEE80211_CCK_RATE_1MB:	*pBrateCfg |= RATE_1M;	break;
+				case IEEE80211_CCK_RATE_2MB:	*pBrateCfg |= RATE_2M;	break;
+				case IEEE80211_CCK_RATE_5MB:	*pBrateCfg |= RATE_5_5M;break;
+				case IEEE80211_CCK_RATE_11MB:	*pBrateCfg |= RATE_11M;	break;
+				case IEEE80211_OFDM_RATE_6MB:	*pBrateCfg |= RATE_6M;	break;
+				case IEEE80211_OFDM_RATE_9MB:	*pBrateCfg |= RATE_9M;	break;
+				case IEEE80211_OFDM_RATE_12MB:	*pBrateCfg |= RATE_12M;	break;
+				case IEEE80211_OFDM_RATE_18MB:	*pBrateCfg |= RATE_18M;	break;
+				case IEEE80211_OFDM_RATE_24MB:	*pBrateCfg |= RATE_24M;	break;
+				case IEEE80211_OFDM_RATE_36MB:	*pBrateCfg |= RATE_36M;	break;
+				case IEEE80211_OFDM_RATE_48MB:	*pBrateCfg |= RATE_48M;	break;
+				case IEEE80211_OFDM_RATE_54MB:	*pBrateCfg |= RATE_54M;	break;
+			}
+		}
+	}
+}
+
+uint8_t  rtw_hal_networktype_to_raid(struct rtl_priv *rtlpriv,unsigned char network_type)
+{
+	return networktype_to_raid_ex(rtlpriv,network_type);
+}
+
+uint8_t rtw_get_mgntframe_raid(struct rtl_priv *rtlpriv,unsigned char network_type)
+{
+
+	uint8_t raid;
+	raid = (network_type & WIRELESS_11B) ?RATEID_IDX_B :RATEID_IDX_G;
+	return raid;
+}
+
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/hal/HalHWImg8812A_FW.c linux-4.9.8821au/drivers/staging/rtl8821au/hal/HalHWImg8812A_FW.c
--- linux-4.9/drivers/staging/rtl8821au/hal/HalHWImg8812A_FW.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/hal/HalHWImg8812A_FW.c	2016-12-11 19:48:25.163645087 -0600
@@ -0,0 +1,5467 @@
+/****************************************************************************** 
+* 
+* Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved. 
+* 
+* This program is free software; you can redistribute it and/or modify it 
+* under the terms of version 2 of the GNU General Public License as 
+* published by the Free Software Foundation. 
+* 
+* This program is distributed in the hope that it will be useful, but WITHOUT 
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for 
+* more details. 
+* 
+* You should have received a copy of the GNU General Public License along with 
+* this program; if not, write to the Free Software Foundation, Inc., 
+* 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA 
+* 
+* 
+******************************************************************************/
+
+#include "Mp_Precomp.h"
+#include "../phydm_precomp.h"
+
+#if (RTL8812A_SUPPORT == 1)
+u1Byte Array_MP_8812A_FW_NIC[] = {
+0x01, 0x95, 0x10, 0x00, 0x26, 0x00, 0x00, 0x00, 0x11, 0x04, 0x19, 0x53, 0xA0, 0x7C, 0x00, 0x00, 
+0x81, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x02, 0x4C, 0x4D, 0x02, 0x97, 0xE9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x02, 0x99, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x02, 0x9F, 0xDE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x02, 0x98, 0x6C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x7B, 0x61, 0x00, 0x00, 
+0x00, 0x04, 0x0C, 0x14, 0x2C, 0x36, 0x04, 0x08, 0x08, 0x08, 0x0A, 0x0A, 0x15, 0xF0, 0xFF, 0x0F, 
+0x00, 0x00, 0x00, 0x15, 0xF0, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x05, 0xF0, 0xFF, 0x0F, 0x00, 0x00, 
+0x00, 0x05, 0xF0, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x10, 0xF0, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x10, 
+0xF0, 0x0F, 0x00, 0x00, 0x00, 0x00, 0xF5, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x0F, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0xF0, 0xFF, 0xFF, 0x00, 
+0x00, 0x00, 0x10, 0xF0, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x15, 0xF0, 0x3F, 0x00, 0x00, 0x00, 0x00, 
+0x15, 0xF0, 0xCF, 0xFF, 0x00, 0x00, 0x00, 0x16, 0x0D, 0x17, 0x0E, 0x17, 0x0F, 0x18, 0x10, 0x19, 
+0x11, 0x1A, 0x12, 0x1A, 0x13, 0x1A, 0x14, 0x1A, 0x15, 0x1B, 0xFF, 0x17, 0x0E, 0x18, 0x10, 0x19, 
+0x11, 0x1A, 0x12, 0x1B, 0x15, 0x1C, 0xFF, 0x1D, 0xFF, 0x1E, 0xFF, 0x1F, 0xFF, 0xFF, 0xFF, 0x14, 
+0x0D, 0x0E, 0x15, 0x15, 0x0F, 0x16, 0x10, 0x17, 0x11, 0x18, 0x12, 0x18, 0x13, 0x18, 0xFF, 0x15, 
+0x0D, 0x16, 0x10, 0x10, 0x17, 0x18, 0x12, 0x19, 0xFF, 0x1A, 0xFF, 0x1B, 0xFF, 0x1C, 0xFF, 0x00, 
+0x00, 0x00, 0x00, 0x04, 0x04, 0x0C, 0x0C, 0x0D, 0x0C, 0x0E, 0x0D, 0x0F, 0x17, 0x18, 0x10, 0x19, 
+0x11, 0x19, 0x11, 0x19, 0x12, 0x1A, 0x14, 0x0C, 0x0C, 0x16, 0x0D, 0x17, 0x0F, 0x18, 0x10, 0x19, 
+0x13, 0x1A, 0x14, 0x1B, 0x15, 0x1C, 0x1B, 0x1D, 0x1C, 0x1E, 0x1D, 0x04, 0x04, 0x0C, 0x14, 0x0D, 
+0x14, 0x0E, 0x14, 0x0F, 0x15, 0x10, 0x16, 0x17, 0x11, 0x12, 0x17, 0x0C, 0x0C, 0x14, 0x0E, 0x15, 
+0x0F, 0x16, 0x10, 0x17, 0x12, 0x18, 0x18, 0x19, 0x19, 0x1A, 0x19, 0x0A, 0x08, 0x03, 0x03, 0x00, 
+0x04, 0x09, 0x07, 0x03, 0x03, 0x00, 0x04, 0x08, 0x06, 0x03, 0x02, 0x00, 0x04, 0x08, 0x05, 0x03, 
+0x01, 0x00, 0x04, 0x0D, 0x0A, 0x07, 0x05, 0x00, 0x08, 0x0C, 0x0A, 0x07, 0x04, 0x00, 0x08, 0x0B, 
+0x0A, 0x06, 0x05, 0x00, 0x08, 0x0B, 0x0A, 0x05, 0x03, 0x00, 0x08, 0x0B, 0x0A, 0x03, 0x02, 0x00, 
+0x08, 0x14, 0x12, 0x0C, 0x04, 0x00, 0x10, 0x14, 0x12, 0x09, 0x04, 0x00, 0x10, 0x24, 0x22, 0x1C, 
+0x12, 0x00, 0x20, 0x24, 0x22, 0x18, 0x0C, 0x00, 0x20, 0x24, 0x22, 0x14, 0x06, 0x00, 0x20, 0x24, 
+0x22, 0x0F, 0x04, 0x00, 0x20, 0x24, 0x21, 0x0A, 0x04, 0x00, 0x20, 0x23, 0x21, 0x0C, 0x04, 0x00, 
+0x20, 0x23, 0x1F, 0x0A, 0x04, 0x00, 0x20, 0x22, 0x1F, 0x0F, 0x04, 0x00, 0x20, 0x21, 0x1F, 0x16, 
+0x0C, 0x00, 0x20, 0x31, 0x2F, 0x20, 0x14, 0x00, 0x30, 0x31, 0x2F, 0x18, 0x10, 0x00, 0x30, 0x31, 
+0x2C, 0x18, 0x0C, 0x00, 0x30, 0x31, 0x2A, 0x14, 0x0C, 0x00, 0x30, 0x31, 0x28, 0x14, 0x00, 0x00, 
+0x30, 0x31, 0x24, 0x14, 0x00, 0x00, 0x30, 0x31, 0x1E, 0x14, 0x00, 0x00, 0x30, 0x04, 0x04, 0x04, 
+0x05, 0x04, 0x04, 0x05, 0x07, 0x07, 0x07, 0x08, 0x0A, 0x04, 0x07, 0x0A, 0x0E, 0x11, 0x13, 0x14, 
+0x15, 0x03, 0x04, 0x07, 0x07, 0x08, 0x0B, 0x0D, 0x0F, 0x05, 0x05, 0x07, 0x07, 0x08, 0x0B, 0x0D, 
+0x0F, 0x05, 0x05, 0x07, 0x07, 0x08, 0x0B, 0x0D, 0x0F, 0x07, 0x08, 0x08, 0x0A, 0x0A, 0x0C, 0x0E, 
+0x10, 0x11, 0x11, 0x07, 0x09, 0x09, 0x0B, 0x0B, 0x0D, 0x0F, 0x13, 0x13, 0x14, 0x05, 0x05, 0x07, 
+0x07, 0x08, 0x0B, 0x0D, 0x0F, 0x0F, 0x0F, 0x05, 0x05, 0x07, 0x07, 0x08, 0x0B, 0x0D, 0x0F, 0x0F, 
+0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x26, 0x2A, 0x00, 0x00, 0x00, 
+0x1F, 0x21, 0x25, 0x27, 0x28, 0x00, 0x00, 0x00, 0x00, 0x23, 0x26, 0x28, 0x2A, 0x00, 0x00, 0x00, 
+0x00, 0x23, 0x26, 0x28, 0x2A, 0x00, 0x00, 0x00, 0x00, 0x23, 0x26, 0x28, 0x2A, 0x00, 0x00, 0x00, 
+0x00, 0x20, 0x25, 0x27, 0x29, 0x29, 0x2A, 0x00, 0x00, 0x00, 0x00, 0x20, 0x25, 0x27, 0x29, 0x29, 
+0x2A, 0x00, 0x00, 0x00, 0x00, 0x23, 0x26, 0x28, 0x2A, 0x2A, 0x2A, 0x00, 0x00, 0x00, 0x1F, 0x23, 
+0x26, 0x28, 0x2A, 0x2A, 0x2A, 0x00, 0x04, 0x00, 0x04, 0x00, 0x08, 0x00, 0x10, 0x00, 0x18, 0x00, 
+0x24, 0x00, 0x30, 0x00, 0x48, 0x00, 0x60, 0x00, 0x90, 0x00, 0xC0, 0x00, 0xD8, 0x00, 0x3C, 0x00, 
+0x64, 0x00, 0x78, 0x00, 0xA0, 0x00, 0xF0, 0x01, 0x40, 0x01, 0x90, 0x01, 0xE0, 0x00, 0xA0, 0x00, 
+0xF0, 0x01, 0x40, 0x01, 0x90, 0x02, 0x58, 0x03, 0x20, 0x04, 0xB0, 0x06, 0x40, 0x00, 0xC8, 0x01, 
+0x18, 0x01, 0xE0, 0x02, 0xD0, 0x03, 0xE8, 0x04, 0xB0, 0x06, 0x40, 0x07, 0xD0, 0x00, 0xC8, 0x01, 
+0x18, 0x01, 0xE0, 0x02, 0xD0, 0x03, 0xE8, 0x04, 0xB0, 0x06, 0x40, 0x07, 0xD0, 0x00, 0x3C, 0x00, 
+0x50, 0x00, 0x64, 0x00, 0xA0, 0x00, 0xF0, 0x01, 0x40, 0x01, 0x90, 0x01, 0xE0, 0x02, 0x58, 0x03, 
+0x20, 0x00, 0x78, 0x00, 0xF0, 0x01, 0x90, 0x02, 0x58, 0x03, 0xE8, 0x07, 0xD0, 0x09, 0x60, 0x0F, 
+0xA0, 0x12, 0xC0, 0x15, 0x18, 0x00, 0xC8, 0x01, 0x18, 0x01, 0xE0, 0x02, 0xD0, 0x03, 0xE8, 0x04, 
+0xB0, 0x06, 0x40, 0x07, 0xD0, 0x07, 0xD0, 0x07, 0xD0, 0x00, 0xC8, 0x01, 0x18, 0x01, 0xE0, 0x02, 
+0xD0, 0x03, 0xE8, 0x04, 0xB0, 0x06, 0x40, 0x07, 0xD0, 0x07, 0xD0, 0x07, 0xD0, 0x00, 0x02, 0x00, 
+0x02, 0x00, 0x04, 0x00, 0x08, 0x00, 0x0C, 0x00, 0x12, 0x00, 0x18, 0x00, 0x24, 0x00, 0x30, 0x00, 
+0x48, 0x00, 0x60, 0x00, 0x6C, 0x00, 0x14, 0x00, 0x32, 0x00, 0x3C, 0x00, 0x50, 0x00, 0x78, 0x00, 
+0xA0, 0x00, 0xC8, 0x00, 0xF0, 0x00, 0x50, 0x00, 0x78, 0x00, 0xA0, 0x00, 0xC8, 0x01, 0x2C, 0x01, 
+0x90, 0x02, 0x58, 0x03, 0x20, 0x00, 0x64, 0x00, 0x8C, 0x00, 0xF0, 0x01, 0x68, 0x01, 0xF4, 0x02, 
+0x58, 0x03, 0x20, 0x03, 0xE8, 0x00, 0x64, 0x00, 0x8C, 0x00, 0xF0, 0x01, 0x68, 0x01, 0xF4, 0x02, 
+0x58, 0x03, 0x20, 0x03, 0xE8, 0x00, 0x1E, 0x00, 0x28, 0x00, 0x32, 0x00, 0x50, 0x00, 0x78, 0x00, 
+0xA0, 0x00, 0xC8, 0x00, 0xF0, 0x01, 0x2C, 0x01, 0x90, 0x00, 0x3C, 0x00, 0x78, 0x00, 0xC8, 0x01, 
+0x2C, 0x01, 0xF4, 0x03, 0xE8, 0x04, 0xB0, 0x07, 0xD0, 0x09, 0x60, 0x0A, 0xF0, 0x00, 0x64, 0x00, 
+0x8C, 0x00, 0xF0, 0x01, 0x68, 0x01, 0xF4, 0x02, 0x58, 0x03, 0x20, 0x03, 0xE8, 0x03, 0xE8, 0x03, 
+0xE8, 0x00, 0x64, 0x00, 0x8C, 0x00, 0xF0, 0x01, 0x68, 0x01, 0xF4, 0x02, 0x58, 0x03, 0x20, 0x03, 
+0xE8, 0x03, 0xE8, 0x03, 0xE8, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x10, 0x18, 0x20, 0x30, 0x40, 
+0x50, 0x01, 0x01, 0x01, 0x02, 0x01, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x02, 0x04, 0x06, 
+0x07, 0x07, 0x08, 0x08, 0x08, 0x02, 0x02, 0x03, 0x03, 0x05, 0x05, 0x06, 0x06, 0x05, 0x06, 0x06, 
+0x07, 0x07, 0x08, 0x09, 0x0A, 0x05, 0x06, 0x06, 0x07, 0x07, 0x08, 0x09, 0x0A, 0x05, 0x06, 0x06, 
+0x07, 0x07, 0x08, 0x09, 0x0A, 0x0A, 0x0B, 0x05, 0x06, 0x06, 0x07, 0x07, 0x08, 0x09, 0x0A, 0x0B, 
+0x0B, 0x05, 0x06, 0x06, 0x07, 0x07, 0x08, 0x09, 0x0A, 0x0A, 0x0B, 0x05, 0x06, 0x06, 0x07, 0x07, 
+0x08, 0x09, 0x0A, 0x0A, 0x0B, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 
+0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x02, 0x04, 0x06, 0x07, 0x08, 0x0A, 0x0B, 
+0x0C, 0x03, 0x05, 0x06, 0x07, 0x08, 0x0A, 0x0B, 0x0C, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 
+0x0C, 0x02, 0x04, 0x06, 0x07, 0x08, 0x09, 0x0B, 0x0C, 0x0C, 0x0C, 0x03, 0x05, 0x06, 0x07, 0x08, 
+0x09, 0x0B, 0x0C, 0x0C, 0x0C, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0C, 0x0C, 0x05, 
+0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0C, 0x0C, 0x19, 0x06, 0x04, 0x02, 0x00, 0x18, 0x05, 
+0x22, 0x05, 0x50, 0x05, 0x51, 0x08, 0x08, 0x0A, 0x04, 0x09, 0x0C, 0x0C, 0x00, 0x0E, 0x00, 0x08, 
+0x38, 0x08, 0x2C, 0x0C, 0x5C, 0x0C, 0x60, 0x0C, 0x64, 0x0C, 0x68, 0x0C, 0xB0, 0x0C, 0xB4, 0x0E, 
+0x5C, 0x0E, 0x60, 0x0E, 0x64, 0x0E, 0x68, 0x0E, 0xB0, 0x0E, 0xB4, 0x0C, 0x00, 0x0C, 0x94, 0x0C, 
+0x88, 0x0C, 0x8C, 0x0C, 0xE8, 0x0C, 0x10, 0x0D, 0x00, 0x0C, 0x90, 0x0C, 0xC4, 0x0C, 0xC8, 0x0C, 
+0xCC, 0x0C, 0xD4, 0x0C, 0x80, 0x0C, 0x84, 0x0C, 0xB8, 0x0E, 0x00, 0x0E, 0x94, 0x0E, 0x88, 0x0E, 
+0x8C, 0x0E, 0xE8, 0x0E, 0x10, 0x0D, 0x40, 0x0E, 0x90, 0x0E, 0xC4, 0x0E, 0xC8, 0x0E, 0xCC, 0x0E, 
+0xD4, 0x0E, 0x80, 0x0E, 0x84, 0x0E, 0xB8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0xE7, 0x09, 0xF6, 0x08, 0xDF, 0xFA, 0x80, 0x46, 0xE7, 0x09, 0xF2, 0x08, 0xDF, 0xFA, 0x80, 0x3E, 
+0x88, 0x82, 0x8C, 0x83, 0xE7, 0x09, 0xF0, 0xA3, 0xDF, 0xFA, 0x80, 0x32, 0xE3, 0x09, 0xF6, 0x08, 
+0xDF, 0xFA, 0x80, 0x78, 0xE3, 0x09, 0xF2, 0x08, 0xDF, 0xFA, 0x80, 0x70, 0x88, 0x82, 0x8C, 0x83, 
+0xE3, 0x09, 0xF0, 0xA3, 0xDF, 0xFA, 0x80, 0x64, 0x89, 0x82, 0x8A, 0x83, 0xE0, 0xA3, 0xF6, 0x08, 
+0xDF, 0xFA, 0x80, 0x58, 0x89, 0x82, 0x8A, 0x83, 0xE0, 0xA3, 0xF2, 0x08, 0xDF, 0xFA, 0x80, 0x4C, 
+0x80, 0xD2, 0x80, 0xFA, 0x80, 0xC6, 0x80, 0xD4, 0x80, 0x69, 0x80, 0xF2, 0x80, 0x33, 0x80, 0x10, 
+0x80, 0xA6, 0x80, 0xEA, 0x80, 0x9A, 0x80, 0xA8, 0x80, 0xDA, 0x80, 0xE2, 0x80, 0xCA, 0x80, 0x33, 
+0x89, 0x82, 0x8A, 0x83, 0xEC, 0xFA, 0xE4, 0x93, 0xA3, 0xC8, 0xC5, 0x82, 0xC8, 0xCC, 0xC5, 0x83, 
+0xCC, 0xF0, 0xA3, 0xC8, 0xC5, 0x82, 0xC8, 0xCC, 0xC5, 0x83, 0xCC, 0xDF, 0xE9, 0xDE, 0xE7, 0x80, 
+0x0D, 0x89, 0x82, 0x8A, 0x83, 0xE4, 0x93, 0xA3, 0xF6, 0x08, 0xDF, 0xF9, 0xEC, 0xFA, 0xA9, 0xF0, 
+0xED, 0xFB, 0x22, 0x89, 0x82, 0x8A, 0x83, 0xEC, 0xFA, 0xE0, 0xA3, 0xC8, 0xC5, 0x82, 0xC8, 0xCC, 
+0xC5, 0x83, 0xCC, 0xF0, 0xA3, 0xC8, 0xC5, 0x82, 0xC8, 0xCC, 0xC5, 0x83, 0xCC, 0xDF, 0xEA, 0xDE, 
+0xE8, 0x80, 0xDB, 0x89, 0x82, 0x8A, 0x83, 0xE4, 0x93, 0xA3, 0xF2, 0x08, 0xDF, 0xF9, 0x80, 0xCC, 
+0x88, 0xF0, 0xEF, 0x60, 0x01, 0x0E, 0x4E, 0x60, 0xC3, 0x88, 0xF0, 0xED, 0x24, 0x02, 0xB4, 0x04, 
+0x00, 0x50, 0xB9, 0xF5, 0x82, 0xEB, 0x24, 0x02, 0xB4, 0x04, 0x00, 0x50, 0xAF, 0x23, 0x23, 0x45, 
+0x82, 0x23, 0x90, 0x46, 0x30, 0x73, 0xC5, 0xF0, 0xF8, 0xA3, 0xE0, 0x28, 0xF0, 0xC5, 0xF0, 0xF8, 
+0xE5, 0x82, 0x15, 0x82, 0x70, 0x02, 0x15, 0x83, 0xE0, 0x38, 0xF0, 0x22, 0xBB, 0x01, 0x0A, 0x89, 
+0x82, 0x8A, 0x83, 0xE0, 0xF5, 0xF0, 0xA3, 0xE0, 0x22, 0x50, 0x06, 0x87, 0xF0, 0x09, 0xE7, 0x19, 
+0x22, 0xBB, 0xFE, 0x07, 0xE3, 0xF5, 0xF0, 0x09, 0xE3, 0x19, 0x22, 0x89, 0x82, 0x8A, 0x83, 0xE4, 
+0x93, 0xF5, 0xF0, 0x74, 0x01, 0x93, 0x22, 0xBB, 0x01, 0x10, 0xE5, 0x82, 0x29, 0xF5, 0x82, 0xE5, 
+0x83, 0x3A, 0xF5, 0x83, 0xE0, 0xF5, 0xF0, 0xA3, 0xE0, 0x22, 0x50, 0x09, 0xE9, 0x25, 0x82, 0xF8, 
+0x86, 0xF0, 0x08, 0xE6, 0x22, 0xBB, 0xFE, 0x0A, 0xE9, 0x25, 0x82, 0xF8, 0xE2, 0xF5, 0xF0, 0x08, 
+0xE2, 0x22, 0xE5, 0x83, 0x2A, 0xF5, 0x83, 0xE9, 0x93, 0xF5, 0xF0, 0xA3, 0xE9, 0x93, 0x22, 0xEF, 
+0x2B, 0xFF, 0xEE, 0x3A, 0xFE, 0xED, 0x39, 0xFD, 0xEC, 0x38, 0xFC, 0x22, 0xC3, 0xEF, 0x9B, 0xFF, 
+0xEE, 0x9A, 0xFE, 0xED, 0x99, 0xFD, 0xEC, 0x98, 0xFC, 0x22, 0xEF, 0x5B, 0xFF, 0xEE, 0x5A, 0xFE, 
+0xED, 0x59, 0xFD, 0xEC, 0x58, 0xFC, 0x22, 0xEF, 0x4B, 0xFF, 0xEE, 0x4A, 0xFE, 0xED, 0x49, 0xFD, 
+0xEC, 0x48, 0xFC, 0x22, 0xEB, 0x9F, 0xF5, 0xF0, 0xEA, 0x9E, 0x42, 0xF0, 0xE9, 0x9D, 0x42, 0xF0, 
+0xEC, 0x64, 0x80, 0xC8, 0x64, 0x80, 0x98, 0x45, 0xF0, 0x22, 0xEB, 0x9F, 0xF5, 0xF0, 0xEA, 0x9E, 
+0x42, 0xF0, 0xE9, 0x9D, 0x42, 0xF0, 0xE8, 0x9C, 0x45, 0xF0, 0x22, 0xE8, 0x60, 0x10, 0xEC, 0xA2, 
+0xE7, 0x13, 0xFC, 0xED, 0x13, 0xFD, 0xEE, 0x13, 0xFE, 0xEF, 0x13, 0xFF, 0xD8, 0xF0, 0x22, 0xBB, 
+0x01, 0x07, 0x89, 0x82, 0x8A, 0x83, 0x02, 0x48, 0x4D, 0x50, 0x05, 0xE9, 0xF8, 0x02, 0x48, 0xD5, 
+0xBB, 0xFE, 0x05, 0xE9, 0xF8, 0x02, 0x48, 0xE1, 0x89, 0x82, 0x8A, 0x83, 0x02, 0x48, 0xED, 0xBB, 
+0x01, 0x0D, 0xE5, 0x82, 0x29, 0xF5, 0x82, 0xE5, 0x83, 0x3A, 0xF5, 0x83, 0x02, 0x48, 0x4D, 0x50, 
+0x07, 0xE9, 0x25, 0x82, 0xF8, 0x02, 0x48, 0xD5, 0xBB, 0xFE, 0x07, 0xE9, 0x25, 0x82, 0xF8, 0x02, 
+0x48, 0xE1, 0xE5, 0x82, 0x29, 0xF5, 0x82, 0xE5, 0x83, 0x3A, 0xF5, 0x83, 0x02, 0x48, 0xED, 0xBB, 
+0x01, 0x07, 0x89, 0x82, 0x8A, 0x83, 0x02, 0x27, 0x48, 0x50, 0x05, 0xE9, 0xF8, 0x02, 0x48, 0xFD, 
+0xBB, 0xFE, 0x05, 0xE9, 0xF8, 0x02, 0x49, 0x09, 0x22, 0xBB, 0x01, 0x0D, 0xE5, 0x82, 0x29, 0xF5, 
+0x82, 0xE5, 0x83, 0x3A, 0xF5, 0x83, 0x02, 0x27, 0x48, 0x50, 0x07, 0xE9, 0x25, 0x82, 0xF8, 0x02, 
+0x48, 0xFD, 0xBB, 0xFE, 0x07, 0xE9, 0x25, 0x82, 0xF8, 0x02, 0x49, 0x09, 0x22, 0xE0, 0xFC, 0xA3, 
+0xE0, 0xFD, 0xA3, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x22, 0xE0, 0xF8, 0xA3, 0xE0, 0xF9, 0xA3, 0xE0, 
+0xFA, 0xA3, 0xE0, 0xFB, 0x22, 0xA4, 0x25, 0x82, 0xF5, 0x82, 0xE5, 0xF0, 0x35, 0x83, 0xF5, 0x83, 
+0x22, 0xE0, 0xFB, 0xA3, 0xE0, 0xFA, 0xA3, 0xE0, 0xF9, 0x22, 0xEB, 0xF0, 0xA3, 0xEA, 0xF0, 0xA3, 
+0xE9, 0xF0, 0x22, 0xD0, 0x83, 0xD0, 0x82, 0xF8, 0xE4, 0x93, 0x70, 0x12, 0x74, 0x01, 0x93, 0x70, 
+0x0D, 0xA3, 0xA3, 0x93, 0xF8, 0x74, 0x01, 0x93, 0xF5, 0x82, 0x88, 0x83, 0xE4, 0x73, 0x74, 0x02, 
+0x93, 0x68, 0x60, 0xEF, 0xA3, 0xA3, 0xA3, 0x80, 0xDF, 0xEF, 0x4E, 0x60, 0x12, 0xEF, 0x60, 0x01, 
+0x0E, 0xED, 0xBB, 0x01, 0x0B, 0x89, 0x82, 0x8A, 0x83, 0xF0, 0xA3, 0xDF, 0xFC, 0xDE, 0xFA, 0x22, 
+0x89, 0xF0, 0x50, 0x07, 0xF7, 0x09, 0xDF, 0xFC, 0xA9, 0xF0, 0x22, 0xBB, 0xFE, 0xFC, 0xF3, 0x09, 
+0xDF, 0xFC, 0xA9, 0xF0, 0x22, 0xE6, 0xFC, 0x08, 0xE6, 0xFD, 0x08, 0xE6, 0xFE, 0x08, 0xE6, 0xFF, 
+0x22, 0xE2, 0xFC, 0x08, 0xE2, 0xFD, 0x08, 0xE2, 0xFE, 0x08, 0xE2, 0xFF, 0x22, 0xE4, 0x93, 0xFC, 
+0x74, 0x01, 0x93, 0xFD, 0x74, 0x02, 0x93, 0xFE, 0x74, 0x03, 0x93, 0xFF, 0x22, 0xEC, 0xF6, 0x08, 
+0xED, 0xF6, 0x08, 0xEE, 0xF6, 0x08, 0xEF, 0xF6, 0x22, 0xEC, 0xF2, 0x08, 0xED, 0xF2, 0x08, 0xEE, 
+0xF2, 0x08, 0xEF, 0xF2, 0x22, 0xC2, 0xAF, 0x80, 0xFE, 0x32, 0x12, 0x49, 0x19, 0x85, 0xD0, 0x0B, 
+0x75, 0xD0, 0x08, 0xAA, 0xE0, 0xC2, 0x8C, 0xE5, 0x8A, 0x24, 0x67, 0xF5, 0x8A, 0xE5, 0x8C, 0x34, 
+0x79, 0xF5, 0x8C, 0xD2, 0x8C, 0xEC, 0x24, 0x87, 0xF8, 0xE6, 0xBC, 0x02, 0x02, 0x74, 0xFF, 0xC3, 
+0x95, 0x81, 0xB4, 0x40, 0x00, 0x40, 0xCE, 0x79, 0x03, 0x78, 0x80, 0x16, 0xE6, 0x08, 0x70, 0x0B, 
+0xC2, 0xAF, 0xE6, 0x30, 0xE1, 0x03, 0x44, 0x18, 0xF6, 0xD2, 0xAF, 0x08, 0xD9, 0xED, 0xEA, 0x8B, 
+0xD0, 0x22, 0xE5, 0x0C, 0xFF, 0x23, 0x24, 0x81, 0xF8, 0x0F, 0x08, 0x08, 0xBF, 0x03, 0x04, 0x7F, 
+0x00, 0x78, 0x81, 0xE6, 0x30, 0xE4, 0xF2, 0x00, 0xE5, 0x0C, 0xC3, 0x9F, 0x50, 0x20, 0x05, 0x0C, 
+0x74, 0x86, 0x25, 0x0C, 0xF8, 0xE6, 0xFD, 0xA6, 0x81, 0x08, 0xE6, 0xAE, 0x0C, 0xBE, 0x02, 0x02, 
+0x74, 0xFF, 0xCD, 0xF8, 0xE8, 0x6D, 0x60, 0xE0, 0x08, 0xE6, 0xC0, 0xE0, 0x80, 0xF6, 0xE5, 0x0C, 
+0xD3, 0x9F, 0x40, 0x27, 0xE5, 0x0C, 0x24, 0x87, 0xF8, 0xE6, 0xAE, 0x0C, 0xBE, 0x02, 0x02, 0x74, 
+0xFF, 0xFD, 0x18, 0xE6, 0xCD, 0xF8, 0xE5, 0x81, 0x6D, 0x60, 0x06, 0xD0, 0xE0, 0xF6, 0x18, 0x80, 
+0xF5, 0xE5, 0x0C, 0x24, 0x86, 0xC8, 0xF6, 0x15, 0x0C, 0x80, 0xD3, 0xE5, 0x0C, 0x23, 0x24, 0x81, 
+0xF8, 0x7F, 0x04, 0xC2, 0xAF, 0xE6, 0x30, 0xE0, 0x03, 0x10, 0xE2, 0x0C, 0x7F, 0x00, 0x30, 0xE1, 
+0x07, 0x30, 0xE3, 0x04, 0x7F, 0x08, 0x54, 0xF4, 0x54, 0x7C, 0xC6, 0xD2, 0xAF, 0x54, 0x80, 0x42, 
+0x07, 0x22, 0x78, 0x86, 0xA6, 0x81, 0x74, 0x02, 0x60, 0x06, 0xFF, 0x08, 0x76, 0xFF, 0xDF, 0xFB, 
+0x7F, 0x03, 0xE4, 0x78, 0x80, 0xF6, 0x08, 0xF6, 0x08, 0xDF, 0xFA, 0x78, 0x81, 0x76, 0x30, 0x90, 
+0x4C, 0xD0, 0x74, 0x01, 0x93, 0xC0, 0xE0, 0xE4, 0x93, 0xC0, 0xE0, 0x43, 0x89, 0x01, 0x75, 0x8A, 
+0x60, 0x75, 0x8C, 0x79, 0xD2, 0x8C, 0xD2, 0xAF, 0x22, 0x02, 0xEF, 0xD3, 0x94, 0x02, 0x40, 0x03, 
+0x7F, 0xFF, 0x22, 0x74, 0x81, 0x2F, 0x2F, 0xF8, 0xE6, 0x20, 0xE5, 0xF4, 0xC2, 0xAF, 0xE6, 0x44, 
+0x30, 0xF6, 0xD2, 0xAF, 0xAE, 0x0C, 0xEE, 0xC3, 0x9F, 0x50, 0x21, 0x0E, 0x74, 0x86, 0x2E, 0xF8, 
+0xE6, 0xF9, 0x08, 0xE6, 0x18, 0xBE, 0x02, 0x02, 0x74, 0xFF, 0xFD, 0xED, 0x69, 0x60, 0x09, 0x09, 
+0xE7, 0x19, 0x19, 0xF7, 0x09, 0x09, 0x80, 0xF3, 0x16, 0x16, 0x80, 0xDA, 0xEE, 0xD3, 0x9F, 0x40, 
+0x04, 0x05, 0x81, 0x05, 0x81, 0xEE, 0xD3, 0x9F, 0x40, 0x22, 0x74, 0x86, 0x2E, 0xF8, 0x08, 0xE6, 
+0xF9, 0xEE, 0xB5, 0x0C, 0x02, 0xA9, 0x81, 0x18, 0x06, 0x06, 0xE6, 0xFD, 0xED, 0x69, 0x60, 0x09, 
+0x19, 0x19, 0xE7, 0x09, 0x09, 0xF7, 0x19, 0x80, 0xF3, 0x1E, 0x80, 0xD9, 0xEF, 0x24, 0x86, 0xF8, 
+0xE6, 0x04, 0xF8, 0xEF, 0x2F, 0x04, 0x90, 0x4C, 0xD0, 0x93, 0xF6, 0x08, 0xEF, 0x2F, 0x93, 0xF6, 
+0x7F, 0x00, 0x22, 0xEF, 0xD3, 0x94, 0x02, 0x40, 0x03, 0x7F, 0xFF, 0x22, 0xEF, 0x23, 0x24, 0x81, 
+0xF8, 0xE6, 0x30, 0xE5, 0xF4, 0xC2, 0xAF, 0xE6, 0x54, 0x8C, 0xF6, 0xD2, 0xAF, 0xE5, 0x0C, 0xB5, 
+0x07, 0x0A, 0x74, 0x86, 0x2F, 0xF8, 0xE6, 0xF5, 0x81, 0x02, 0x49, 0x62, 0x50, 0x2E, 0x74, 0x87, 
+0x2F, 0xF8, 0xE6, 0xBF, 0x02, 0x02, 0x74, 0xFF, 0xFD, 0x18, 0xE6, 0xF9, 0x74, 0x86, 0x2F, 0xF8, 
+0xFB, 0xE6, 0xFC, 0xE9, 0x6C, 0x60, 0x08, 0xA8, 0x05, 0xE7, 0xF6, 0x1D, 0x19, 0x80, 0xF4, 0xA8, 
+0x03, 0xA6, 0x05, 0x1F, 0xE5, 0x0C, 0xB5, 0x07, 0xE3, 0x7F, 0x00, 0x22, 0x74, 0x87, 0x2F, 0xF8, 
+0xE6, 0xFD, 0x18, 0x86, 0x01, 0x0F, 0x74, 0x86, 0x2F, 0xF8, 0xA6, 0x01, 0x08, 0x86, 0x04, 0xE5, 
+0x0C, 0xB5, 0x07, 0x02, 0xAC, 0x81, 0xED, 0x6C, 0x60, 0x08, 0x0D, 0x09, 0xA8, 0x05, 0xE6, 0xF7, 
+0x80, 0xF4, 0xE5, 0x0C, 0xB5, 0x07, 0xDE, 0x89, 0x81, 0x7F, 0x00, 0x22, 0xEF, 0xD3, 0x94, 0x02, 
+0x40, 0x03, 0x7F, 0xFF, 0x22, 0xEF, 0x23, 0x24, 0x81, 0xF8, 0xC2, 0xAF, 0xE6, 0x30, 0xE5, 0x05, 
+0x30, 0xE0, 0x02, 0xD2, 0xE4, 0xD2, 0xE2, 0xC6, 0xD2, 0xAF, 0x7F, 0x00, 0x30, 0xE2, 0x01, 0x0F, 
+0x02, 0x49, 0x61, 0x8F, 0xF0, 0xE4, 0xFF, 0xFE, 0xE5, 0x0C, 0x23, 0x24, 0x80, 0xF8, 0xC2, 0xA9, 
+0x30, 0xF7, 0x0D, 0x7F, 0x08, 0xE6, 0x60, 0x0B, 0x2D, 0xF6, 0x60, 0x30, 0x50, 0x2E, 0x80, 0x07, 
+0x30, 0xF1, 0x06, 0xED, 0xF6, 0x60, 0x25, 0x7E, 0x02, 0x08, 0x30, 0xF0, 0x10, 0xC2, 0xAF, 0xE6, 
+0x10, 0xE7, 0x23, 0x0E, 0x30, 0xE2, 0x0C, 0xD2, 0xAF, 0x7F, 0x04, 0x80, 0x12, 0xC2, 0xAF, 0xE6, 
+0x10, 0xE7, 0x13, 0x54, 0xEC, 0x4E, 0xF6, 0xD2, 0xAF, 0x02, 0x49, 0x62, 0x7F, 0x08, 0x08, 0xEF, 
+0x44, 0x83, 0xF4, 0xC2, 0xAF, 0x56, 0xC6, 0xD2, 0xAF, 0x54, 0x80, 0x4F, 0xFF, 0x22, 0x41, 0xA5, 
+0xEB, 0x00, 0x41, 0xA5, 0xEC, 0x00, 0x60, 0x54, 0xA0, 0x21, 0x04, 0x04, 0x04, 0x05, 0x07, 0x07, 
+0x09, 0x09, 0x0C, 0x0E, 0x10, 0x12, 0x05, 0x06, 0x07, 0x0D, 0x10, 0x11, 0x12, 0x12, 0x07, 0x08, 
+0x09, 0x09, 0x0C, 0x0E, 0x11, 0x13, 0x09, 0x09, 0x09, 0x09, 0x0C, 0x0E, 0x11, 0x13, 0x09, 0x09, 
+0x09, 0x09, 0x0C, 0x0E, 0x11, 0x13, 0x05, 0x06, 0x08, 0x09, 0x0C, 0x0E, 0x12, 0x12, 0x13, 0x14, 
+0x07, 0x08, 0x09, 0x0A, 0x0C, 0x0F, 0x12, 0x12, 0x14, 0x16, 0x09, 0x09, 0x09, 0x09, 0x0C, 0x0E, 
+0x11, 0x13, 0x13, 0x13, 0x09, 0x09, 0x09, 0x09, 0x0C, 0x0E, 0x11, 0x13, 0x13, 0x13, 0x60, 0x26, 
+0xA5, 0x14, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 
+0x24, 0x28, 0x2C, 0x30, 0x34, 0x38, 0x3C, 0x40, 0x64, 0x68, 0x6C, 0x70, 0x74, 0x78, 0x7C, 0x80, 
+0x84, 0x88, 0x8C, 0x95, 0x99, 0x9D, 0xA1, 0xA5, 0x41, 0xA6, 0x03, 0x00, 0x00, 0x02, 0x4C, 0x8B, 
+0x02, 0x49, 0xF2, 0xE4, 0x93, 0xA3, 0xF8, 0xE4, 0x93, 0xA3, 0x40, 0x03, 0xF6, 0x80, 0x01, 0xF2, 
+0x08, 0xDF, 0xF4, 0x80, 0x29, 0xE4, 0x93, 0xA3, 0xF8, 0x54, 0x07, 0x24, 0x0C, 0xC8, 0xC3, 0x33, 
+0xC4, 0x54, 0x0F, 0x44, 0x20, 0xC8, 0x83, 0x40, 0x04, 0xF4, 0x56, 0x80, 0x01, 0x46, 0xF6, 0xDF, 
+0xE4, 0x80, 0x0B, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x90, 0x4B, 0xBE, 0xE4, 0x7E, 
+0x01, 0x93, 0x60, 0xBC, 0xA3, 0xFF, 0x54, 0x3F, 0x30, 0xE5, 0x09, 0x54, 0x1F, 0xFE, 0xE4, 0x93, 
+0xA3, 0x60, 0x01, 0x0E, 0xCF, 0x54, 0xC0, 0x25, 0xE0, 0x60, 0xA8, 0x40, 0xB8, 0xE4, 0x93, 0xA3, 
+0xFA, 0xE4, 0x93, 0xA3, 0xF8, 0xE4, 0x93, 0xA3, 0xC8, 0xC5, 0x82, 0xC8, 0xCA, 0xC5, 0x83, 0xCA, 
+0xF0, 0xA3, 0xC8, 0xC5, 0x82, 0xC8, 0xCA, 0xC5, 0x83, 0xCA, 0xDF, 0xE9, 0xDE, 0xE7, 0x80, 0xBE, 
+0x58, 0x0A, 0x5F, 0xF5, 0x67, 0xF3, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0xE4, 0x90, 0xA4, 
+0x23, 0xF0, 0x90, 0xA4, 0x28, 0xF0, 0x90, 0xA4, 0x26, 0xF0, 0xD1, 0x36, 0x40, 0x02, 0xA1, 0x78, 
+0xC3, 0x74, 0xFD, 0xD1, 0x3F, 0x7A, 0xA4, 0x79, 0x22, 0x12, 0x33, 0xC7, 0xEF, 0x64, 0x01, 0x60, 
+0x02, 0xA1, 0xD4, 0x90, 0xA4, 0x22, 0xE0, 0xFF, 0x54, 0xC0, 0xFE, 0x60, 0x05, 0xEF, 0x54, 0x0C, 
+0x70, 0x1C, 0x90, 0xA4, 0x22, 0xE0, 0xFF, 0x54, 0x30, 0x60, 0x05, 0xEF, 0x54, 0x03, 0x70, 0x08, 
+0x90, 0xA4, 0x26, 0xE0, 0x60, 0x4A, 0x80, 0x00, 0x90, 0xA4, 0x23, 0x74, 0x01, 0xF0, 0x90, 0xA4, 
+0x23, 0xE0, 0x90, 0xA4, 0x22, 0x70, 0x17, 0xE0, 0xFF, 0xEE, 0xC4, 0x13, 0x13, 0x54, 0x03, 0x90, 
+0xA4, 0x24, 0xF0, 0xEF, 0x54, 0x0C, 0x13, 0x13, 0x54, 0x3F, 0xA3, 0xF0, 0x80, 0x10, 0xE0, 0xFF, 
+0x54, 0x30, 0xC4, 0x54, 0x0F, 0x90, 0xA4, 0x24, 0xF0, 0xEF, 0x54, 0x03, 0xA3, 0xF0, 0x90, 0xA4, 
+0x24, 0xE0, 0x90, 0xA4, 0x1E, 0xF0, 0x90, 0xA4, 0x25, 0xE0, 0x90, 0xA4, 0x1F, 0xF0, 0x80, 0x08, 
+0x90, 0xA4, 0x26, 0xE0, 0x04, 0xF0, 0x81, 0xEA, 0xE4, 0x90, 0xA4, 0x26, 0xF0, 0xD1, 0x36, 0x50, 
+0x63, 0xC3, 0x74, 0xFB, 0xD1, 0x3F, 0x7A, 0xA4, 0x79, 0x27, 0x12, 0x33, 0xC7, 0xEF, 0x64, 0x01, 
+0x70, 0x42, 0x90, 0xA4, 0x27, 0xE0, 0xFF, 0x54, 0xE0, 0xFE, 0x70, 0x13, 0xEF, 0x54, 0x0E, 0x70, 
+0x08, 0x90, 0xA4, 0x26, 0xE0, 0x60, 0x35, 0x80, 0x00, 0x90, 0xA4, 0x28, 0x74, 0x01, 0xF0, 0x90, 
+0xA4, 0x28, 0xE0, 0x70, 0x09, 0xEE, 0xC4, 0x13, 0x54, 0x07, 0xA3, 0xF0, 0x80, 0x0C, 0x90, 0xA4, 
+0x27, 0xE0, 0x54, 0x0E, 0xC3, 0x13, 0x90, 0xA4, 0x29, 0xF0, 0x90, 0xA4, 0x29, 0xE0, 0x90, 0xA4, 
+0x20, 0xF0, 0x80, 0x10, 0x90, 0xA4, 0x2A, 0x74, 0x01, 0xF0, 0x80, 0x40, 0x90, 0xA4, 0x26, 0xE0, 
+0x04, 0xF0, 0x80, 0x99, 0x90, 0xA4, 0x1F, 0xE0, 0x25, 0xE0, 0x25, 0xE0, 0x54, 0x0C, 0xFF, 0x90, 
+0xA4, 0x1E, 0xE0, 0x54, 0x03, 0x4F, 0xFF, 0x90, 0xA4, 0x20, 0xE0, 0xFE, 0xC4, 0x54, 0x70, 0x4F, 
+0x44, 0x80, 0xFD, 0x7F, 0x8B, 0x12, 0x3A, 0x96, 0x90, 0xA4, 0x1E, 0xE0, 0x60, 0x08, 0xA3, 0xE0, 
+0x60, 0x04, 0xA3, 0xE0, 0x70, 0x1B, 0x90, 0xA4, 0x2A, 0x74, 0x03, 0xF0, 0x90, 0x01, 0xC4, 0x74, 
+0xD6, 0xF0, 0x74, 0x4C, 0xA3, 0xF0, 0x90, 0xA4, 0x2A, 0xE0, 0x90, 0x01, 0xC8, 0xD1, 0x49, 0x80, 
+0xEB, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0xA4, 0x26, 0xE0, 0xFF, 0xC3, 0x94, 0x02, 0x22, 0x9F, 
+0xFF, 0x74, 0x03, 0x94, 0x00, 0xFE, 0x7B, 0x01, 0x22, 0xF0, 0xE4, 0xFD, 0x7F, 0x1F, 0x02, 0x3A, 
+0x96, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0xA4, 0x34, 0xEF, 0xF0, 0xA3, 0x74, 0x02, 
+0xF0, 0x90, 0x01, 0xC4, 0x74, 0x51, 0xF0, 0x74, 0x4E, 0xA3, 0xF0, 0x90, 0xA4, 0x35, 0xE0, 0x90, 
+0x01, 0xC8, 0xF0, 0x90, 0xA4, 0x34, 0xE0, 0x90, 0x01, 0xC9, 0xD1, 0x49, 0x80, 0xE3, 0x90, 0xA4, 
+0x31, 0x11, 0x7A, 0x12, 0x26, 0x1E, 0x54, 0x7F, 0xF5, 0x0D, 0xF1, 0xBD, 0xFF, 0x54, 0x1F, 0xF5, 
+0x0F, 0x12, 0x7A, 0xF2, 0xF5, 0x0E, 0xF1, 0xB6, 0xFF, 0x54, 0x03, 0xF5, 0x10, 0xEF, 0x54, 0x30, 
+0xC4, 0x54, 0x0F, 0xF5, 0x13, 0xF1, 0xB6, 0xFF, 0x54, 0x40, 0xC4, 0x13, 0x13, 0x54, 0x03, 0xF5, 
+0x11, 0x12, 0x7A, 0xF2, 0xF5, 0x12, 0xF1, 0xB6, 0xFF, 0x54, 0x08, 0xFE, 0x13, 0x13, 0x13, 0x54, 
+0x1F, 0xF5, 0x15, 0xEF, 0x54, 0x04, 0x13, 0x13, 0x54, 0x3F, 0xF5, 0x16, 0x90, 0xA4, 0x1F, 0xE0, 
+0xB4, 0x02, 0x08, 0xE5, 0x13, 0x60, 0x04, 0xE4, 0xFF, 0xD1, 0x51, 0x90, 0xA4, 0x20, 0xE0, 0xB4, 
+0x01, 0x18, 0xF1, 0xC4, 0x90, 0x00, 0x05, 0x12, 0x26, 0x37, 0x54, 0xF0, 0x70, 0x08, 0x90, 0x00, 
+0x06, 0x12, 0x26, 0x37, 0x60, 0x04, 0x7F, 0x01, 0xD1, 0x51, 0xE5, 0x12, 0x12, 0xBC, 0x02, 0xF1, 
+0xA7, 0x54, 0x7F, 0x4F, 0xF0, 0xE5, 0x11, 0x54, 0x01, 0xC4, 0x33, 0x33, 0x54, 0xC0, 0xF1, 0xA7, 
+0x54, 0xBF, 0x4F, 0xF0, 0xE5, 0x15, 0x60, 0x02, 0xE1, 0xA6, 0xE5, 0x0F, 0x54, 0x1F, 0xFF, 0x75, 
+0xF0, 0x04, 0xE5, 0x0D, 0x12, 0x5F, 0xA6, 0x54, 0xE0, 0x4F, 0xF0, 0xE5, 0x10, 0x54, 0x03, 0xF1, 
+0xA7, 0x54, 0xFC, 0x4F, 0xF0, 0xEF, 0x25, 0xE0, 0x25, 0xE0, 0xF1, 0xA7, 0x54, 0xF3, 0x4F, 0xF0, 
+0xE5, 0x0E, 0x54, 0x01, 0xC4, 0x33, 0x54, 0xE0, 0xFF, 0x75, 0xF0, 0x04, 0xE5, 0x0D, 0x12, 0x5F, 
+0xA6, 0x54, 0xDF, 0x4F, 0xF0, 0xE5, 0x13, 0x54, 0x03, 0xC4, 0x54, 0xF0, 0xF1, 0xA7, 0x54, 0xCF, 
+0x4F, 0x12, 0x5C, 0x1E, 0xE0, 0x54, 0xFB, 0x12, 0x5C, 0x1E, 0xE0, 0xFF, 0xE5, 0x16, 0x25, 0xE0, 
+0x25, 0xE0, 0xFE, 0xEF, 0x4E, 0xF0, 0xE4, 0xF5, 0x14, 0xE5, 0x14, 0x24, 0x03, 0xFF, 0xE4, 0x33, 
+0xFE, 0xF1, 0xC4, 0x8F, 0x82, 0x8E, 0x83, 0x12, 0x26, 0x37, 0xFF, 0x75, 0xF0, 0x08, 0xE5, 0x0D, 
+0x12, 0x72, 0x47, 0x25, 0x14, 0x12, 0x72, 0x2A, 0xEF, 0xF0, 0x05, 0x14, 0xE5, 0x14, 0xB4, 0x04, 
+0xD8, 0xAF, 0x0D, 0x12, 0x6F, 0xF5, 0x22, 0xFF, 0x75, 0xF0, 0x04, 0xE5, 0x0D, 0x90, 0x96, 0x14, 
+0x11, 0x65, 0xE0, 0x22, 0x4F, 0xF0, 0x90, 0x00, 0x02, 0x02, 0x26, 0x37, 0xF0, 0x90, 0x00, 0x01, 
+0x02, 0x26, 0x37, 0xF0, 0x90, 0xA4, 0x31, 0x01, 0x71, 0x12, 0x7F, 0x8F, 0xF1, 0xC4, 0xF1, 0xB6, 
+0x90, 0xA5, 0xD3, 0xF0, 0xE4, 0xFB, 0xFD, 0x12, 0xB3, 0xC8, 0x90, 0xA4, 0x34, 0x74, 0x10, 0xF0, 
+0x90, 0xA4, 0x42, 0x74, 0x07, 0xF1, 0xC3, 0x12, 0x26, 0x1E, 0x90, 0xA4, 0x36, 0xF0, 0x7B, 0x01, 
+0x7A, 0xA4, 0x79, 0x34, 0x12, 0x97, 0x1F, 0x7F, 0x04, 0x02, 0x97, 0x04, 0x90, 0x00, 0xF0, 0xE0, 
+0x7F, 0x01, 0x20, 0xE2, 0x02, 0x7F, 0x03, 0x22, 0x12, 0x4F, 0xFC, 0x90, 0xA1, 0x7C, 0xEF, 0xF0, 
+0x11, 0x1B, 0x90, 0x01, 0x64, 0x74, 0x01, 0xF0, 0x02, 0x35, 0x95, 0x11, 0x40, 0x11, 0x70, 0x12, 
+0xA7, 0xF2, 0x12, 0xA8, 0x11, 0x12, 0xA7, 0xCC, 0xE4, 0xF5, 0x51, 0x75, 0x52, 0x58, 0xAB, 0x51, 
+0x7D, 0x02, 0x7F, 0x01, 0x12, 0x39, 0x04, 0xAB, 0x52, 0x7D, 0x03, 0x7F, 0x01, 0x02, 0x39, 0x04, 
+0x90, 0x01, 0x30, 0xE4, 0x11, 0x68, 0x90, 0x01, 0x38, 0x11, 0x68, 0xFD, 0x7F, 0x50, 0x12, 0x3A, 
+0x96, 0xE4, 0xFD, 0x7F, 0x51, 0x12, 0x3A, 0x96, 0xE4, 0xFD, 0x7F, 0x52, 0x12, 0x3A, 0x96, 0xE4, 
+0xFD, 0x7F, 0x53, 0x02, 0x3A, 0x96, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0x22, 
+0x90, 0x01, 0x34, 0x74, 0xFF, 0x11, 0x68, 0x90, 0x01, 0x3C, 0x11, 0x68, 0xFD, 0x7F, 0x54, 0x12, 
+0x3A, 0x96, 0x7D, 0xFF, 0x7F, 0x55, 0x12, 0x3A, 0x96, 0x7D, 0xFF, 0x7F, 0x56, 0x12, 0x3A, 0x96, 
+0x7D, 0xFF, 0x7F, 0x57, 0x02, 0x3A, 0x96, 0x90, 0xA4, 0x16, 0x74, 0xFF, 0xF0, 0xE4, 0x11, 0x69, 
+0xA3, 0xE0, 0x54, 0xFC, 0x44, 0x02, 0xF0, 0xE4, 0x80, 0xBF, 0x12, 0x9F, 0xB1, 0x12, 0xA3, 0x43, 
+0x12, 0x72, 0x50, 0x12, 0xB8, 0x3F, 0x11, 0xBD, 0x12, 0xA2, 0x21, 0x80, 0xDA, 0x7E, 0x00, 0x7F, 
+0xAC, 0x7D, 0x00, 0x7B, 0x01, 0x7A, 0xA2, 0x79, 0x88, 0x12, 0x48, 0xA9, 0x90, 0xA2, 0x8B, 0x74, 
+0x02, 0xF0, 0x90, 0xA2, 0x92, 0x14, 0xF0, 0xA3, 0xF0, 0xA3, 0x74, 0x08, 0xF0, 0x90, 0xA2, 0x98, 
+0xE4, 0xF0, 0xA3, 0x74, 0x02, 0x31, 0xB8, 0x74, 0x08, 0xF0, 0xE4, 0xFD, 0xFF, 0x31, 0x55, 0x7D, 
+0x0C, 0x7F, 0x02, 0x31, 0x55, 0x31, 0x51, 0x90, 0xA1, 0x7C, 0xE0, 0xFF, 0xB4, 0x01, 0x08, 0x90, 
+0xA2, 0x97, 0x74, 0xFF, 0xF0, 0x80, 0x0F, 0xEF, 0x90, 0xA2, 0x97, 0xB4, 0x03, 0x05, 0x74, 0xD4, 
+0xF0, 0x80, 0x03, 0x74, 0x41, 0xF0, 0x12, 0xBA, 0xB4, 0x31, 0xB8, 0x74, 0x08, 0xF0, 0x7F, 0x01, 
+0x12, 0xB9, 0x4D, 0x90, 0xA2, 0x9A, 0x12, 0x27, 0x54, 0x54, 0x33, 0x77, 0x70, 0x7E, 0x00, 0x7F, 
+0x02, 0x7D, 0x00, 0x7B, 0x01, 0x7A, 0xA3, 0x79, 0x38, 0x12, 0x48, 0xA9, 0x90, 0x06, 0x04, 0xE0, 
+0x54, 0x7F, 0x12, 0xBB, 0xF9, 0x71, 0xCB, 0xE4, 0x90, 0xA3, 0x3A, 0xF0, 0x22, 0xE0, 0x54, 0x7F, 
+0xF0, 0x7D, 0x0C, 0x7F, 0x01, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0xAC, 0x07, 0xEF, 0x14, 
+0x60, 0x15, 0x14, 0x60, 0x19, 0x24, 0x02, 0x70, 0x1A, 0xED, 0x54, 0x01, 0xFE, 0x90, 0xA2, 0x88, 
+0xE0, 0x54, 0xFE, 0x4E, 0xF0, 0x80, 0x0C, 0x90, 0xA2, 0x8F, 0xED, 0xF0, 0x80, 0x05, 0x90, 0xA2, 
+0x8E, 0xED, 0xF0, 0x90, 0x00, 0x8F, 0xE0, 0x30, 0xE4, 0x29, 0xEC, 0x14, 0x60, 0x07, 0x14, 0x60, 
+0x18, 0x24, 0x02, 0x70, 0x1E, 0x90, 0xA2, 0x88, 0xE0, 0x12, 0xBC, 0x02, 0xFF, 0x90, 0xA2, 0x8F, 
+0xE0, 0x54, 0x7F, 0x4F, 0xFD, 0x7F, 0x88, 0x80, 0x07, 0x90, 0xA2, 0x8E, 0xE0, 0xFD, 0x7F, 0x89, 
+0x12, 0x3A, 0x96, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xF0, 0x90, 0xA2, 0xC2, 0xE0, 0x24, 0x04, 0x90, 
+0xA2, 0xA4, 0xF0, 0xA3, 0x22, 0x90, 0xA2, 0x89, 0xE0, 0xC3, 0x13, 0x20, 0xE0, 0x04, 0x31, 0x51, 
+0x80, 0x0E, 0x12, 0xBA, 0x03, 0x71, 0xBE, 0x90, 0x05, 0x27, 0xE0, 0x44, 0x80, 0xF0, 0x71, 0xB7, 
+0xE4, 0xFD, 0xFF, 0x61, 0xE1, 0x7D, 0x01, 0x7F, 0x04, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 
+0x90, 0xA6, 0x01, 0xED, 0xF0, 0x90, 0xA2, 0x88, 0xE0, 0xFE, 0xC4, 0x13, 0x13, 0x54, 0x03, 0x30, 
+0xE0, 0x02, 0x61, 0x31, 0xEE, 0x12, 0x7A, 0xF5, 0x30, 0xE0, 0x02, 0x61, 0x31, 0x90, 0xA2, 0x8F, 
+0xE0, 0xFE, 0x6F, 0x70, 0x02, 0x61, 0x31, 0xEF, 0x70, 0x02, 0x41, 0xA7, 0x24, 0xFE, 0x70, 0x02, 
+0x41, 0xE0, 0x24, 0xFE, 0x60, 0x49, 0x24, 0xFC, 0x70, 0x02, 0x61, 0x1B, 0x24, 0xFC, 0x60, 0x02, 
+0x61, 0x31, 0xEE, 0xB4, 0x0E, 0x02, 0x31, 0xC5, 0x90, 0xA2, 0x8F, 0xE0, 0x70, 0x04, 0x7F, 0x01, 
+0x71, 0xA5, 0x90, 0xA2, 0x8F, 0xE0, 0xB4, 0x06, 0x02, 0x71, 0x51, 0x90, 0xA2, 0x8F, 0xE0, 0xB4, 
+0x04, 0x0E, 0x90, 0xA6, 0x01, 0xE0, 0xFF, 0x60, 0x04, 0xF1, 0xBA, 0x80, 0x03, 0x12, 0xB9, 0x30, 
+0x90, 0xA2, 0x8F, 0xE0, 0x64, 0x08, 0x60, 0x02, 0x61, 0x31, 0x12, 0xB9, 0x93, 0x61, 0x31, 0x90, 
+0xA2, 0x8F, 0xE0, 0x70, 0x04, 0x7F, 0x01, 0x71, 0xA5, 0x90, 0xA2, 0x8F, 0xE0, 0xB4, 0x06, 0x02, 
+0x71, 0x51, 0x90, 0xA2, 0x8F, 0xE0, 0xB4, 0x0E, 0x07, 0x71, 0x36, 0xBF, 0x01, 0x02, 0x31, 0xC5, 
+0x90, 0xA2, 0x8F, 0xE0, 0x64, 0x0C, 0x60, 0x02, 0x61, 0x31, 0x71, 0x36, 0xEF, 0x64, 0x01, 0x60, 
+0x02, 0x61, 0x31, 0x71, 0x76, 0x61, 0x31, 0x90, 0xA2, 0x8F, 0xE0, 0xB4, 0x0E, 0x07, 0x71, 0x36, 
+0xBF, 0x01, 0x02, 0x31, 0xC5, 0x90, 0xA2, 0x8F, 0xE0, 0xB4, 0x06, 0x02, 0x71, 0x51, 0x90, 0xA2, 
+0x8F, 0xE0, 0xB4, 0x0C, 0x07, 0x71, 0x36, 0xBF, 0x01, 0x02, 0x71, 0x76, 0x90, 0xA2, 0x8F, 0xE0, 
+0x64, 0x04, 0x70, 0x5D, 0x12, 0xB8, 0xF3, 0xEF, 0x64, 0x01, 0x70, 0x55, 0xD1, 0x62, 0x80, 0x51, 
+0x90, 0xA2, 0x8F, 0xE0, 0xB4, 0x0E, 0x07, 0x71, 0x36, 0xBF, 0x01, 0x02, 0x31, 0xC5, 0x90, 0xA2, 
+0x8F, 0xE0, 0xB4, 0x06, 0x02, 0x71, 0x51, 0x90, 0xA2, 0x8F, 0xE0, 0xB4, 0x0C, 0x07, 0x71, 0x36, 
+0xBF, 0x01, 0x02, 0x71, 0x76, 0x90, 0xA2, 0x8F, 0xE0, 0x70, 0x04, 0x7F, 0x01, 0x71, 0xA5, 0x90, 
+0xA2, 0x8F, 0xE0, 0xB4, 0x04, 0x1B, 0x12, 0xB8, 0x82, 0x80, 0x16, 0x90, 0xA2, 0x8F, 0xE0, 0xB4, 
+0x0C, 0x0F, 0x90, 0xA2, 0x89, 0xE0, 0xFF, 0x13, 0x13, 0x54, 0x3F, 0x30, 0xE0, 0x03, 0x12, 0xB9, 
+0x7B, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x12, 0x7F, 0xBE, 0xBF, 0x01, 0x12, 0x12, 0x7F, 0x7A, 0x20, 
+0xE0, 0x0C, 0x90, 0xA2, 0x8E, 0xE0, 0xD3, 0x94, 0x04, 0x50, 0x03, 0x7F, 0x01, 0x22, 0x7F, 0x00, 
+0x22, 0x90, 0xA2, 0x89, 0xE0, 0x90, 0x06, 0x04, 0x20, 0xE0, 0x07, 0xE0, 0x44, 0x40, 0x71, 0xBE, 
+0x80, 0x0F, 0x31, 0x4D, 0x90, 0x05, 0x27, 0xE0, 0x54, 0x7F, 0xF0, 0x90, 0xA2, 0x87, 0x74, 0x0C, 
+0xF0, 0xE4, 0xFD, 0xFF, 0x80, 0x6B, 0x12, 0x66, 0x1B, 0x70, 0x29, 0x90, 0xA2, 0x89, 0xE0, 0x54, 
+0xFD, 0xF0, 0x7D, 0x2C, 0x7F, 0x6F, 0x71, 0xE1, 0x7D, 0x08, 0x7F, 0x01, 0xD1, 0x85, 0xBF, 0x01, 
+0x13, 0x90, 0xA2, 0x88, 0xE0, 0x44, 0x80, 0xF0, 0x7D, 0x0E, 0x7F, 0x01, 0x31, 0x55, 0x90, 0xA2, 
+0x87, 0x74, 0x0E, 0xF0, 0x22, 0x90, 0xA6, 0x00, 0xEF, 0xF0, 0x12, 0x9D, 0xA8, 0x90, 0xA6, 0x00, 
+0xE0, 0x60, 0x02, 0x71, 0xCB, 0x71, 0xBF, 0x90, 0xA2, 0x87, 0x74, 0x04, 0xF0, 0x22, 0xF0, 0x7D, 
+0x04, 0x7F, 0x01, 0x21, 0x55, 0xE4, 0xFD, 0x7F, 0x0C, 0x31, 0xE9, 0xE4, 0xFD, 0xFF, 0x80, 0x11, 
+0x90, 0xA3, 0x4B, 0x12, 0x48, 0x65, 0xE0, 0xFF, 0x7E, 0x00, 0xE4, 0xFD, 0x71, 0xEC, 0xE4, 0xFD, 
+0xFF, 0x90, 0x05, 0x22, 0xEF, 0xF0, 0x90, 0xA1, 0x7A, 0xED, 0xF0, 0x22, 0xD3, 0x10, 0xAF, 0x01, 
+0xC3, 0xC0, 0xD0, 0x90, 0xA5, 0x9D, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0xA3, 0xED, 0xF0, 0x90, 0x04, 
+0x1D, 0xE0, 0x60, 0x24, 0x90, 0x05, 0x22, 0xE0, 0x90, 0xA5, 0xA2, 0xF0, 0x7D, 0x13, 0xD1, 0x1A, 
+0xBF, 0x01, 0x0A, 0x12, 0x59, 0x5E, 0x90, 0xA5, 0xA0, 0xF1, 0x6E, 0xD1, 0xDE, 0x90, 0xA5, 0xA2, 
+0xE0, 0xFF, 0x7D, 0x15, 0x71, 0xE1, 0x80, 0x0A, 0x12, 0x59, 0x5E, 0x90, 0xA5, 0xA0, 0xF1, 0x6E, 
+0xD1, 0xDE, 0x12, 0xBB, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x8F, 0x10, 0x7D, 0x17, 0xD1, 0x1A, 
+0x75, 0xF0, 0x0E, 0xE5, 0x10, 0x12, 0xA2, 0x1B, 0xE0, 0xFC, 0xD1, 0x0D, 0xFE, 0x54, 0x03, 0xFD, 
+0xEE, 0x13, 0x13, 0x54, 0x07, 0xFB, 0x90, 0xA3, 0x3C, 0xE0, 0xFE, 0x12, 0xBC, 0x66, 0xAF, 0x04, 
+0x12, 0xB3, 0xC8, 0xD1, 0x0D, 0xFE, 0x54, 0x03, 0xFF, 0xEE, 0xC4, 0x13, 0x54, 0x07, 0xFD, 0xD1, 
+0x0D, 0x12, 0x95, 0x60, 0x75, 0xF0, 0x0E, 0xE5, 0x10, 0x71, 0xD0, 0xAD, 0x10, 0xE4, 0xFF, 0xD3, 
+0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0xA5, 0xCC, 0x12, 0xBC, 0x0B, 0x90, 0xA5, 0xCE, 0xE0, 
+0xFF, 0xC3, 0x94, 0x02, 0x40, 0x02, 0xA1, 0x1C, 0x90, 0xA5, 0xCD, 0xE0, 0xFE, 0x12, 0xA2, 0x0E, 
+0x75, 0xF0, 0x03, 0xEF, 0x12, 0xBB, 0x40, 0xE0, 0x90, 0xA5, 0xCF, 0xF0, 0x90, 0xA5, 0xCC, 0xE0, 
+0x60, 0x24, 0x90, 0xA5, 0xCF, 0xE0, 0xFF, 0x75, 0xF0, 0x0E, 0xEE, 0x12, 0xA2, 0x08, 0xC0, 0x83, 
+0xC0, 0x82, 0x90, 0xA5, 0xCE, 0xE0, 0xD0, 0x82, 0xD0, 0x83, 0x12, 0x76, 0x03, 0x80, 0x02, 0xC3, 
+0x33, 0xD8, 0xFC, 0x4F, 0x80, 0x20, 0x12, 0xBB, 0xAA, 0x75, 0xF0, 0x0E, 0x12, 0xA2, 0x08, 0xC0, 
+0x83, 0xC0, 0x82, 0x90, 0xA5, 0xCE, 0xE0, 0xD0, 0x82, 0xD0, 0x83, 0x12, 0x76, 0x03, 0x80, 0x02, 
+0xC3, 0x33, 0xD8, 0xFC, 0xF4, 0x5F, 0x90, 0xA5, 0xCF, 0xF0, 0x12, 0xBB, 0xAA, 0x12, 0xA2, 0x0E, 
+0xC0, 0x83, 0xC0, 0x82, 0x90, 0xA5, 0xCE, 0xE0, 0xD0, 0x82, 0xD0, 0x83, 0x75, 0xF0, 0x03, 0x12, 
+0xBB, 0x40, 0xEF, 0xF0, 0x90, 0xA5, 0xCE, 0xE0, 0x04, 0xF0, 0x81, 0x8C, 0xD0, 0xD0, 0x92, 0xAF, 
+0x22, 0x90, 0xA3, 0x3C, 0xE0, 0x30, 0xE0, 0x58, 0x90, 0xA3, 0x3E, 0xE0, 0x70, 0x28, 0x7D, 0x16, 
+0x7F, 0x6F, 0x71, 0xE1, 0xD1, 0x1E, 0xD1, 0x04, 0x75, 0xF0, 0x0E, 0x12, 0xBB, 0x1B, 0x71, 0xEC, 
+0xD1, 0x04, 0x12, 0x7B, 0x58, 0xE0, 0x44, 0x01, 0xF0, 0x12, 0xBC, 0x14, 0x12, 0x78, 0x14, 0x90, 
+0xA3, 0x3E, 0x74, 0x01, 0xF0, 0x22, 0x90, 0xA3, 0x3E, 0xE0, 0x64, 0x01, 0x70, 0x20, 0xD1, 0x04, 
+0x12, 0x7B, 0x57, 0xE0, 0x30, 0xE0, 0x17, 0x75, 0xF0, 0x0E, 0xEF, 0x12, 0xBB, 0x1B, 0x71, 0xEC, 
+0x12, 0xBC, 0x14, 0xF0, 0xE4, 0xFB, 0xFD, 0x7F, 0x54, 0x7E, 0x01, 0x02, 0x78, 0x1C, 0xB1, 0x81, 
+0x22, 0x90, 0xA3, 0x3C, 0xE0, 0xFF, 0xC3, 0x13, 0xFE, 0xEF, 0x54, 0xF1, 0xFF, 0xEE, 0x04, 0x54, 
+0x07, 0x25, 0xE0, 0x4F, 0xF0, 0xA3, 0xE0, 0xFF, 0x12, 0xBB, 0xA0, 0xB5, 0x07, 0x04, 0xEE, 0x54, 
+0xF1, 0xF0, 0x12, 0x77, 0xED, 0xE4, 0x90, 0xA3, 0x3E, 0xF0, 0xD1, 0x1E, 0x12, 0xBB, 0xA0, 0x12, 
+0xA2, 0x17, 0xE0, 0xFA, 0x75, 0xF0, 0x0E, 0xED, 0xD1, 0x12, 0xFC, 0x54, 0x03, 0xFD, 0xEC, 0x13, 
+0x13, 0x54, 0x07, 0xFB, 0xEE, 0x12, 0xBC, 0x66, 0xAF, 0x02, 0x12, 0xB3, 0xC8, 0xD1, 0x04, 0xFE, 
+0x75, 0xF0, 0x0E, 0xD1, 0x12, 0xFD, 0x54, 0x03, 0xFF, 0xED, 0xC4, 0x13, 0x54, 0x07, 0xFD, 0x75, 
+0xF0, 0x0E, 0xEE, 0xD1, 0x12, 0x12, 0x95, 0x60, 0xD1, 0x04, 0xFF, 0x75, 0xF0, 0x0E, 0x90, 0xA3, 
+0x4A, 0x12, 0x48, 0x65, 0xE0, 0x04, 0xF0, 0x75, 0xF0, 0x0E, 0xEF, 0x71, 0xD0, 0xD1, 0x04, 0xFD, 
+0xE4, 0xFF, 0x81, 0x7F, 0x90, 0xA3, 0x3C, 0xE0, 0xC3, 0x13, 0x54, 0x07, 0x22, 0x75, 0xF0, 0x0E, 
+0xE5, 0x10, 0x90, 0xA3, 0x40, 0x12, 0x48, 0x65, 0xE0, 0x22, 0x7F, 0xFF, 0x71, 0xE1, 0xE4, 0x90, 
+0xA5, 0xF1, 0xF0, 0xA3, 0xF0, 0x90, 0x05, 0xF8, 0xE0, 0x70, 0x0F, 0xA3, 0xE0, 0x70, 0x0B, 0xA3, 
+0xE0, 0x70, 0x07, 0xA3, 0xE0, 0x70, 0x03, 0x7F, 0x01, 0x22, 0xD3, 0x90, 0xA5, 0xF2, 0xE0, 0x94, 
+0xE8, 0x90, 0xA5, 0xF1, 0xE0, 0x94, 0x03, 0x40, 0x0A, 0x90, 0x01, 0xC0, 0xE0, 0x44, 0x20, 0xF0, 
+0x7F, 0x00, 0x22, 0x7F, 0x32, 0x7E, 0x00, 0x12, 0x3A, 0xF7, 0x90, 0xA5, 0xF1, 0x12, 0x58, 0xB3, 
+0x80, 0xC3, 0x7D, 0x2D, 0xD1, 0x1A, 0x90, 0x01, 0x37, 0x74, 0x02, 0xF0, 0xFD, 0x7F, 0x03, 0x12, 
+0x63, 0x6F, 0x12, 0x9E, 0xEF, 0xE4, 0xFD, 0x7F, 0x01, 0x31, 0x55, 0xE4, 0x90, 0xA2, 0x87, 0xF0, 
+0x22, 0x7D, 0x08, 0xE4, 0xFF, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0xA5, 0xB3, 0xEF, 
+0xF0, 0xA3, 0xED, 0xF0, 0x90, 0xA1, 0x78, 0xE0, 0x04, 0xF0, 0x90, 0x04, 0x1D, 0xE0, 0x60, 0x29, 
+0x90, 0x05, 0x22, 0xE0, 0x90, 0xA5, 0xB7, 0xF0, 0x7D, 0x26, 0xD1, 0x1A, 0xEF, 0x64, 0x01, 0x70, 
+0x0A, 0xF1, 0x5C, 0xF1, 0x83, 0x20, 0xE0, 0x03, 0x12, 0x59, 0xFB, 0x90, 0xA5, 0xB7, 0xE0, 0xFF, 
+0x7D, 0x27, 0x71, 0xE1, 0x12, 0xB9, 0xA3, 0x80, 0x0D, 0x12, 0xB9, 0xA3, 0xF1, 0x5C, 0xF1, 0x83, 
+0x20, 0xE0, 0x03, 0x12, 0x59, 0xFB, 0x12, 0xBB, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0xA5, 
+0x9F, 0xE0, 0xFF, 0xF1, 0x77, 0x54, 0x3F, 0xF0, 0xEF, 0x60, 0x0B, 0x12, 0x5A, 0x7D, 0x44, 0x10, 
+0xF1, 0x76, 0x44, 0x80, 0xF0, 0x22, 0x12, 0x5A, 0x7D, 0x54, 0xEF, 0xF1, 0x76, 0x44, 0x40, 0xF0, 
+0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0xA5, 0xD8, 0xEF, 0xF0, 0x90, 0x04, 0x1D, 
+0xE0, 0x60, 0x2C, 0x90, 0x05, 0x22, 0xE0, 0x90, 0xA5, 0xDB, 0xF0, 0x7D, 0x29, 0xD1, 0x1A, 0xBF, 
+0x01, 0x12, 0x90, 0xA1, 0x80, 0x12, 0x59, 0x62, 0x90, 0xA5, 0xD9, 0xF1, 0x6E, 0x90, 0xA5, 0xD8, 
+0xE0, 0xFF, 0xD1, 0xE3, 0x90, 0xA5, 0xDB, 0xE0, 0xFF, 0x7D, 0x2A, 0x71, 0xE1, 0x80, 0x12, 0x90, 
+0xA1, 0x80, 0x12, 0x59, 0x62, 0x90, 0xA5, 0xD9, 0xF1, 0x6E, 0x90, 0xA5, 0xD8, 0xE0, 0xFF, 0xD1, 
+0xE3, 0x90, 0x04, 0x1F, 0x74, 0x20, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0xA1, 0x7F, 0xE0, 
+0xFF, 0x90, 0xA5, 0xB4, 0xE0, 0xFB, 0x7D, 0x01, 0x12, 0x59, 0x68, 0x90, 0xA5, 0xB5, 0xEE, 0xF0, 
+0xFC, 0xA3, 0xEF, 0xF0, 0xFD, 0x22, 0xF0, 0x74, 0x09, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 
+0x83, 0xE0, 0x22, 0x90, 0xA5, 0xB3, 0xE0, 0xFF, 0xD1, 0xE3, 0x90, 0xA3, 0x3C, 0xE0, 0x22, 0x12, 
+0x78, 0x48, 0x90, 0xA2, 0x8F, 0xE0, 0x64, 0x0C, 0x60, 0x04, 0x71, 0xC5, 0xD1, 0x81, 0x22, 0x90, 
+0xA2, 0x8C, 0xE0, 0x64, 0x01, 0x70, 0x12, 0x12, 0x79, 0x40, 0x60, 0x05, 0x71, 0xC5, 0x02, 0x78, 
+0x48, 0x90, 0xA2, 0x8F, 0xE0, 0x70, 0x02, 0x31, 0xE5, 0x22, 0xEF, 0x60, 0x31, 0x12, 0x66, 0x1B, 
+0x70, 0x2C, 0x90, 0xA2, 0x89, 0xE0, 0x54, 0xFE, 0xF0, 0x7D, 0x2B, 0x7F, 0x0F, 0x71, 0xE1, 0x90, 
+0x06, 0x04, 0xE0, 0x54, 0xBF, 0xF0, 0xD1, 0x81, 0xBF, 0x01, 0x13, 0x90, 0xA2, 0x88, 0xE0, 0x44, 
+0x40, 0xF0, 0x7D, 0x06, 0x7F, 0x01, 0x31, 0x55, 0x90, 0xA2, 0x87, 0x74, 0x06, 0xF0, 0x22, 0x7D, 
+0x1F, 0x7F, 0x6F, 0x71, 0xE1, 0x90, 0x05, 0x27, 0xE0, 0x54, 0xBF, 0xF0, 0x90, 0xA2, 0x86, 0x74, 
+0x04, 0xF0, 0x22, 0x75, 0xE8, 0x03, 0x75, 0xA8, 0x85, 0x22, 0x90, 0x00, 0x80, 0xE0, 0x44, 0x80, 
+0xFD, 0x7F, 0x80, 0x12, 0x3A, 0x96, 0x12, 0xA8, 0x30, 0x12, 0x3A, 0xB8, 0x12, 0xA8, 0x3D, 0xF1, 
+0xB8, 0x7F, 0x01, 0x12, 0x4A, 0x2A, 0x90, 0xA3, 0x3B, 0x74, 0x02, 0xF0, 0xFF, 0x12, 0x4A, 0x2A, 
+0x90, 0xA3, 0x3B, 0xE0, 0x04, 0xF0, 0x12, 0x50, 0x08, 0x12, 0x50, 0xAA, 0x12, 0x4C, 0xD6, 0x90, 
+0x00, 0x80, 0xE0, 0x44, 0x40, 0xFD, 0x7F, 0x80, 0x12, 0x3A, 0x96, 0x75, 0x28, 0xFF, 0x11, 0x03, 
+0x11, 0x5A, 0x12, 0xA8, 0xA1, 0xE4, 0xFF, 0x02, 0x4A, 0xB3, 0xE4, 0x90, 0xA4, 0x22, 0xF0, 0xA3, 
+0xF0, 0x90, 0x01, 0x98, 0xE0, 0x7F, 0x00, 0x30, 0xE4, 0x02, 0x7F, 0x01, 0xEF, 0x64, 0x01, 0x60, 
+0x3B, 0xC3, 0x90, 0xA4, 0x23, 0xE0, 0x94, 0x88, 0x90, 0xA4, 0x22, 0xE0, 0x94, 0x13, 0x40, 0x0F, 
+0x90, 0x01, 0xC1, 0xE0, 0x44, 0x10, 0xF0, 0x90, 0x01, 0xC7, 0x74, 0xFD, 0xF0, 0x80, 0x1D, 0x90, 
+0xA4, 0x22, 0x11, 0xB3, 0xF1, 0xBF, 0xD3, 0x90, 0xA4, 0x23, 0xE0, 0x94, 0x32, 0x90, 0xA4, 0x22, 
+0xE0, 0x94, 0x00, 0x40, 0xBC, 0x90, 0x01, 0xC6, 0xE0, 0x30, 0xE3, 0xB5, 0x90, 0x01, 0xC7, 0x74, 
+0xFE, 0xF0, 0x22, 0xE4, 0x75, 0xF0, 0x01, 0x02, 0x46, 0xD6, 0xE4, 0x90, 0xA5, 0xE8, 0xF0, 0xA3, 
+0xF0, 0x90, 0x05, 0x22, 0xE0, 0x90, 0xA5, 0xEA, 0xF0, 0x90, 0x04, 0x2D, 0xE0, 0x54, 0x01, 0xF0, 
+0x90, 0x04, 0x1D, 0xE0, 0x60, 0x37, 0xC3, 0x90, 0xA5, 0xE9, 0xE0, 0x94, 0xD0, 0x90, 0xA5, 0xE8, 
+0xE0, 0x94, 0x07, 0x50, 0x28, 0x90, 0xA4, 0x16, 0xE0, 0xB4, 0xFF, 0x0D, 0x7D, 0x18, 0x7F, 0xFF, 
+0x12, 0x53, 0xE1, 0xE4, 0x90, 0xA4, 0x1D, 0xF0, 0x22, 0x90, 0x05, 0x22, 0x74, 0xFF, 0xF0, 0x7F, 
+0x01, 0x7E, 0x00, 0x12, 0x3A, 0xF7, 0x90, 0xA5, 0xE8, 0x11, 0xB3, 0x80, 0xC3, 0x90, 0xA4, 0x16, 
+0xE0, 0xFF, 0x7B, 0x18, 0x7D, 0x01, 0x31, 0x68, 0xAB, 0x07, 0xAA, 0x06, 0x74, 0x28, 0x2F, 0xF5, 
+0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0xB4, 0x54, 0x03, 0x12, 0xB8, 0x1C, 0x74, 0x14, 0x2B, 
+0x51, 0x61, 0xE0, 0xC4, 0x13, 0x54, 0x03, 0xFF, 0x90, 0xA4, 0x1A, 0xE0, 0x54, 0xFC, 0x4F, 0xF0, 
+0x90, 0xA5, 0xEA, 0xE0, 0x54, 0x6F, 0xFF, 0x7D, 0x19, 0x12, 0x53, 0xE1, 0x90, 0x04, 0x1F, 0x74, 
+0x20, 0xF0, 0x90, 0xA4, 0x1B, 0x11, 0xB3, 0x90, 0xA4, 0x1D, 0x74, 0x01, 0xF0, 0x22, 0x90, 0xA5, 
+0x9D, 0xA3, 0xE0, 0xFF, 0x7B, 0x08, 0x7D, 0x01, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 
+0xA5, 0xE0, 0xED, 0xF0, 0xA3, 0xEB, 0xF0, 0x90, 0xA5, 0xDF, 0xEF, 0xF0, 0xE4, 0xFD, 0xFC, 0x12, 
+0xBA, 0x0E, 0x7C, 0x00, 0xAD, 0x07, 0x90, 0xA5, 0xDF, 0xE0, 0x90, 0x04, 0x25, 0xF0, 0x90, 0xA5, 
+0xE0, 0xE0, 0x60, 0x05, 0x31, 0xEF, 0x44, 0x80, 0xF0, 0xAF, 0x05, 0x74, 0x20, 0x2F, 0xF5, 0x82, 
+0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x54, 0xC0, 0xF0, 0x31, 0xEF, 0x54, 0xC0, 0xF0, 0xAF, 0x05, 
+0x74, 0x12, 0x2F, 0x31, 0xE7, 0xE0, 0x54, 0x01, 0xFE, 0x90, 0xA5, 0xE1, 0xE0, 0x25, 0xE0, 0x25, 
+0xE0, 0xFB, 0xEE, 0x44, 0x02, 0x4B, 0xFE, 0x74, 0x12, 0x2F, 0x31, 0xE7, 0xEE, 0xF0, 0x74, 0x11, 
+0x2F, 0x51, 0x75, 0x74, 0xFF, 0xF0, 0x74, 0x29, 0x2F, 0x51, 0x80, 0x54, 0xF7, 0xF0, 0xAE, 0x04, 
+0xAF, 0x05, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0x22, 0x74, 
+0x21, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x22, 0x90, 0xA5, 0xB5, 0xE0, 0xFE, 
+0xA3, 0xE0, 0xFF, 0x90, 0x81, 0x00, 0xE0, 0x54, 0x0F, 0xFD, 0xAC, 0x07, 0x51, 0x69, 0x44, 0x01, 
+0xF0, 0x51, 0x69, 0x54, 0xFB, 0xF0, 0xAC, 0x07, 0x74, 0x12, 0x2C, 0x31, 0xE7, 0xE0, 0x44, 0xFA, 
+0xF0, 0x74, 0x11, 0x2C, 0x51, 0x75, 0xE0, 0x44, 0x1F, 0xF0, 0xAC, 0x07, 0x74, 0x06, 0x2C, 0xF5, 
+0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x44, 0x0E, 0xF0, 0x90, 0x04, 0xA7, 0xE4, 0xF0, 0x90, 
+0x04, 0xA6, 0xF0, 0x90, 0x04, 0xA5, 0x74, 0xFF, 0xF0, 0x90, 0x04, 0xA4, 0x74, 0xFD, 0xF0, 0x74, 
+0x14, 0x2C, 0x51, 0x61, 0xE0, 0x54, 0xC0, 0x4D, 0xFD, 0x74, 0x14, 0x2F, 0x51, 0x61, 0xED, 0xF0, 
+0x22, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0x22, 0x74, 0x0D, 0x2C, 0xF5, 0x82, 0xE4, 0x34, 
+0xFC, 0xF5, 0x83, 0xE0, 0x22, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0x22, 0x74, 0x29, 0x2D, 
+0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x22, 0x11, 0xBA, 0xD3, 0x90, 0xA4, 0x18, 0xE0, 
+0x94, 0x00, 0x90, 0xA4, 0x17, 0xE0, 0x94, 0x00, 0x40, 0x17, 0xE0, 0xFC, 0xA3, 0xE0, 0xFD, 0xEC, 
+0x90, 0xA5, 0x9B, 0xF0, 0xA3, 0xED, 0xF0, 0xE4, 0xFB, 0xFD, 0x7F, 0x5C, 0x7E, 0x01, 0x02, 0x78, 
+0x1C, 0x90, 0x01, 0x5F, 0xE4, 0xF0, 0x22, 0x12, 0x26, 0x1E, 0x90, 0xA4, 0x31, 0xF0, 0xF4, 0x60, 
+0x17, 0xE0, 0x90, 0xA4, 0x16, 0x12, 0x4F, 0xB5, 0x75, 0xF0, 0x0A, 0xA4, 0xFF, 0x90, 0xA4, 0x17, 
+0xE5, 0xF0, 0xF0, 0xA3, 0xEF, 0xF0, 0x80, 0xB1, 0x90, 0xA4, 0x31, 0xE0, 0x90, 0xA4, 0x16, 0xF1, 
+0xE6, 0x90, 0x01, 0x5F, 0xF0, 0x22, 0x90, 0xA4, 0x2E, 0x12, 0x48, 0x7A, 0x90, 0xA4, 0x2D, 0xEF, 
+0xF0, 0x12, 0x48, 0x83, 0x5B, 0x2E, 0x00, 0x5B, 0x32, 0x01, 0x5B, 0x37, 0x02, 0x5B, 0x3C, 0x10, 
+0x5B, 0x41, 0x11, 0x5B, 0x46, 0x12, 0x5B, 0x4B, 0x14, 0x5B, 0x50, 0x20, 0x5B, 0x55, 0x21, 0x5B, 
+0x59, 0x23, 0x5B, 0x5D, 0x24, 0x5B, 0x62, 0x25, 0x5B, 0x66, 0x40, 0x5B, 0x74, 0x41, 0x5B, 0x6B, 
+0x42, 0x5B, 0x78, 0x45, 0x5B, 0x6F, 0x46, 0x5B, 0x7D, 0x87, 0x00, 0x00, 0x5B, 0x82, 0x71, 0x92, 
+0xE1, 0x0A, 0x71, 0x92, 0x02, 0x9D, 0x52, 0x71, 0x92, 0x02, 0x7F, 0x20, 0x71, 0x92, 0x02, 0xA0, 
+0x0F, 0x71, 0x92, 0x02, 0xA0, 0x32, 0x71, 0x92, 0x02, 0xA2, 0x30, 0x71, 0x92, 0x02, 0xA2, 0xD0, 
+0x71, 0x92, 0x02, 0x7A, 0x1A, 0x71, 0x92, 0xC1, 0xE0, 0x71, 0x92, 0xE1, 0xCD, 0x71, 0x92, 0x02, 
+0x60, 0x52, 0x71, 0x92, 0xE1, 0xD5, 0x71, 0x92, 0x02, 0x4E, 0x7E, 0x71, 0x92, 0x80, 0x29, 0x71, 
+0x92, 0x02, 0xB1, 0xF1, 0x71, 0x92, 0x41, 0xB7, 0x71, 0x92, 0x02, 0xA7, 0xB8, 0x71, 0x92, 0x02, 
+0x4F, 0xC9, 0x90, 0x01, 0xC0, 0xE0, 0x44, 0x01, 0xF0, 0x90, 0xA4, 0x2D, 0xE0, 0x90, 0x01, 0xC2, 
+0xF0, 0x22, 0x90, 0xA4, 0x2E, 0x02, 0x48, 0x71, 0x90, 0xA4, 0x31, 0x12, 0x48, 0x7A, 0x12, 0x26, 
+0x1E, 0xF5, 0x0D, 0x24, 0x91, 0x91, 0x23, 0xE0, 0x54, 0x9C, 0x91, 0x1E, 0xC0, 0x83, 0xC0, 0x82, 
+0x91, 0x2B, 0x54, 0x01, 0xFE, 0xEF, 0x4E, 0xD0, 0x82, 0xD0, 0x83, 0x91, 0x1E, 0xC0, 0x83, 0xC0, 
+0x82, 0x91, 0x2B, 0x54, 0x02, 0xFE, 0xEF, 0x4E, 0xD0, 0x82, 0xD0, 0x83, 0x91, 0x1E, 0xC0, 0x83, 
+0xC0, 0x82, 0x91, 0x2B, 0x54, 0x40, 0xFE, 0xEF, 0x4E, 0xD0, 0x82, 0xD0, 0x83, 0x91, 0x1E, 0xC0, 
+0x83, 0xC0, 0x82, 0x91, 0x2B, 0x54, 0x20, 0xFE, 0xEF, 0x4E, 0xD0, 0x82, 0xD0, 0x83, 0xF0, 0xE5, 
+0x0D, 0xC3, 0x94, 0x80, 0x50, 0x11, 0x12, 0x4F, 0xB6, 0xFF, 0x74, 0x11, 0x25, 0x0D, 0xF5, 0x82, 
+0xE4, 0x34, 0x9A, 0xF5, 0x83, 0xEF, 0xF0, 0x91, 0x1F, 0xE0, 0x30, 0xE5, 0x10, 0x12, 0x4F, 0xA8, 
+0x13, 0x13, 0x54, 0x03, 0xFB, 0x91, 0x3A, 0xFD, 0xAF, 0x0D, 0x12, 0x76, 0xB3, 0x22, 0xF0, 0x74, 
+0x91, 0x25, 0x0D, 0xF5, 0x82, 0xE4, 0x34, 0x99, 0xF5, 0x83, 0x22, 0xE0, 0xFF, 0x90, 0xA4, 0x31, 
+0x12, 0x48, 0x71, 0x90, 0x00, 0x03, 0x02, 0x26, 0x37, 0xFF, 0x74, 0x11, 0x25, 0x0D, 0xF5, 0x82, 
+0xE4, 0x34, 0x9A, 0xF5, 0x83, 0xE0, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x00, 
+0x8F, 0xE0, 0x20, 0xE6, 0x02, 0xA1, 0x36, 0x90, 0x00, 0x8C, 0xE0, 0xF5, 0x71, 0xA3, 0xE0, 0xFF, 
+0xA3, 0xE0, 0xF5, 0x72, 0xEF, 0x24, 0xFC, 0x60, 0x13, 0x24, 0xEE, 0x70, 0x02, 0x81, 0xF2, 0x24, 
+0x15, 0x60, 0x02, 0xA1, 0x2D, 0xAF, 0x71, 0x12, 0xB2, 0x4A, 0xA1, 0x2D, 0x74, 0x11, 0x25, 0x71, 
+0x91, 0x3E, 0xFB, 0xE4, 0xFD, 0xB1, 0x75, 0x12, 0x4F, 0xAD, 0x13, 0x13, 0xB1, 0x70, 0x12, 0x4F, 
+0xAD, 0x12, 0x7A, 0xF5, 0xB1, 0x72, 0x12, 0x4F, 0xAD, 0xC4, 0xB1, 0x70, 0x12, 0x76, 0x41, 0xE0, 
+0xFB, 0xE4, 0xFD, 0x0F, 0xB1, 0x76, 0x12, 0x73, 0x73, 0xE0, 0xFB, 0x0D, 0xB1, 0x76, 0xF1, 0xA6, 
+0xC4, 0x13, 0x54, 0x01, 0xFB, 0x0D, 0x7F, 0x01, 0xB1, 0x76, 0xF1, 0xA6, 0x54, 0x1F, 0xB1, 0x66, 
+0x90, 0x89, 0x00, 0xD1, 0xC9, 0xB1, 0x68, 0x90, 0x89, 0x01, 0xB1, 0x62, 0x90, 0x89, 0x02, 0xB1, 
+0x62, 0x90, 0x89, 0x03, 0xB1, 0x62, 0x90, 0x89, 0x04, 0xD1, 0xC9, 0xB1, 0x68, 0x90, 0x89, 0x05, 
+0xB1, 0x62, 0x90, 0x89, 0x06, 0xB1, 0x62, 0x90, 0x89, 0x07, 0x12, 0x48, 0x65, 0xE0, 0xFB, 0x0D, 
+0x80, 0x39, 0x90, 0xA4, 0x16, 0xE0, 0xFB, 0xE4, 0xFD, 0xFF, 0xB1, 0x3E, 0x90, 0xA4, 0x17, 0xA3, 
+0xB1, 0x3B, 0x90, 0xA4, 0x19, 0xB1, 0x3B, 0x90, 0xA4, 0x1A, 0xE0, 0x54, 0x03, 0xFB, 0x0D, 0xB1, 
+0x3E, 0x90, 0xA4, 0x1B, 0xA3, 0xE0, 0xFB, 0xE4, 0xFD, 0x0F, 0xB1, 0x3E, 0x90, 0xA4, 0x1B, 0xE0, 
+0xFB, 0x0D, 0xB1, 0x3E, 0x90, 0xA4, 0x1D, 0xE0, 0xFB, 0x1D, 0x0F, 0xB1, 0x3E, 0x90, 0x00, 0x8F, 
+0xE0, 0x30, 0xE0, 0x02, 0xF1, 0xC6, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xE0, 0xFB, 0x0D, 0xEF, 0x70, 
+0x04, 0x74, 0xF0, 0x80, 0x16, 0xEF, 0xB4, 0x01, 0x04, 0x74, 0xF4, 0x80, 0x0E, 0xEF, 0xB4, 0x02, 
+0x04, 0x74, 0xF8, 0x80, 0x06, 0xEF, 0xB4, 0x03, 0x08, 0x74, 0xFC, 0x2D, 0x12, 0xA7, 0x90, 0xEB, 
+0xF0, 0x22, 0x12, 0x48, 0x65, 0xE0, 0xFB, 0x0D, 0xB1, 0x3E, 0x75, 0xF0, 0x08, 0xE5, 0x71, 0x22, 
+0x54, 0x03, 0xFB, 0x0D, 0xE4, 0xFF, 0xB1, 0x3E, 0x75, 0xF0, 0x04, 0xE5, 0x71, 0x22, 0x90, 0xA4, 
+0x49, 0xEB, 0xF0, 0xEF, 0x54, 0x7F, 0x24, 0xF4, 0x90, 0xA4, 0x4D, 0xF0, 0xED, 0x70, 0x2E, 0xD1, 
+0xC1, 0x70, 0x15, 0xE0, 0x25, 0xE0, 0x24, 0xDF, 0xF5, 0x82, 0xE4, 0x34, 0x40, 0xD1, 0xA1, 0x24, 
+0xE0, 0xF5, 0x82, 0xE4, 0x34, 0x40, 0x80, 0x41, 0xE0, 0x25, 0xE0, 0x24, 0xB7, 0xF5, 0x82, 0xE4, 
+0x34, 0x40, 0xD1, 0xA1, 0x24, 0xB8, 0xF5, 0x82, 0xE4, 0x34, 0x40, 0x80, 0x2C, 0xD1, 0xC1, 0x70, 
+0x15, 0xE0, 0x25, 0xE0, 0x24, 0x2B, 0xF5, 0x82, 0xE4, 0x34, 0x41, 0xD1, 0xA1, 0x24, 0x2C, 0xF5, 
+0x82, 0xE4, 0x34, 0x41, 0x80, 0x13, 0xE0, 0x25, 0xE0, 0x24, 0x03, 0xF5, 0x82, 0xE4, 0x34, 0x41, 
+0xD1, 0xA1, 0x24, 0x04, 0xF5, 0x82, 0xE4, 0x34, 0x41, 0xF5, 0x83, 0xE4, 0x93, 0xFF, 0x90, 0xA4, 
+0x49, 0xE0, 0xFD, 0xD1, 0x7C, 0xA9, 0x07, 0x7F, 0x0C, 0x7E, 0x12, 0x7D, 0x10, 0x90, 0xA4, 0x4B, 
+0xE0, 0xFC, 0xF4, 0x60, 0x2C, 0xE9, 0xF4, 0x60, 0x28, 0xE9, 0xC3, 0x9F, 0x40, 0x23, 0xE9, 0xD3, 
+0x9D, 0x50, 0x1E, 0xD1, 0xB9, 0x91, 0x23, 0xE0, 0x30, 0xE1, 0x16, 0x74, 0xF5, 0x2D, 0xD1, 0xD8, 
+0xE0, 0xC3, 0x94, 0x02, 0x40, 0x0B, 0x90, 0xA4, 0x4C, 0xE9, 0xF0, 0xA9, 0x04, 0x90, 0xA4, 0x4B, 
+0xF0, 0xD1, 0xB9, 0x91, 0x23, 0xE0, 0x30, 0xE6, 0x29, 0x74, 0xF5, 0x2D, 0xD1, 0xD8, 0xE0, 0xC3, 
+0x94, 0x02, 0x40, 0x1E, 0x90, 0xA4, 0x4B, 0xE0, 0xFD, 0xF4, 0x60, 0x16, 0xE9, 0xF4, 0x60, 0x12, 
+0xE9, 0x9F, 0x40, 0x0E, 0xE9, 0xD3, 0x9E, 0x50, 0x09, 0xA3, 0xE9, 0xF0, 0xA9, 0x05, 0x90, 0xA4, 
+0x4B, 0xF0, 0x90, 0xA4, 0x4B, 0xE0, 0xB4, 0xFF, 0x09, 0xE9, 0xF0, 0xF1, 0x4D, 0x74, 0xFF, 0xF0, 
+0x80, 0x04, 0xF1, 0x4D, 0xE9, 0xF0, 0x90, 0xA4, 0x4B, 0xE0, 0xFF, 0x22, 0xAC, 0x07, 0xF1, 0xED, 
+0x75, 0xF0, 0x08, 0xED, 0x12, 0x72, 0x21, 0xE0, 0xFB, 0x7A, 0x00, 0xEC, 0x12, 0x9C, 0xAE, 0x80, 
+0x05, 0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 0xF9, 0xF1, 0xDD, 0x7F, 0xFF, 0x60, 0x02, 0xAF, 0x04, 
+0x22, 0xF5, 0x83, 0xE4, 0x93, 0xFF, 0x90, 0xA4, 0x49, 0xE0, 0xFD, 0xD1, 0x7C, 0x90, 0xA4, 0x4B, 
+0xEF, 0xF0, 0x90, 0xA4, 0x4D, 0xE0, 0x25, 0xE0, 0x22, 0x90, 0xA4, 0x49, 0xE0, 0xFD, 0x24, 0x91, 
+0x22, 0x90, 0xA4, 0x4A, 0xE0, 0x90, 0xA4, 0x4D, 0x22, 0x12, 0x48, 0x65, 0xE0, 0xFB, 0xE4, 0xFD, 
+0x0F, 0x22, 0x90, 0xA5, 0xC8, 0xE0, 0x24, 0xF5, 0xF5, 0x82, 0xE4, 0x34, 0xA0, 0xF5, 0x83, 0x22, 
+0x12, 0x4F, 0xB6, 0xFF, 0x30, 0xE0, 0x1E, 0x12, 0x26, 0x1E, 0x90, 0xA3, 0x34, 0x12, 0x4F, 0xBC, 
+0x90, 0xA3, 0x35, 0xF0, 0xEF, 0x54, 0xFE, 0xFF, 0xA3, 0xE0, 0x54, 0x01, 0x4F, 0xF0, 0x91, 0x33, 
+0x90, 0xA3, 0x37, 0xF0, 0x22, 0x12, 0xBA, 0xB4, 0xF0, 0x22, 0x90, 0x02, 0x09, 0x12, 0xA0, 0x29, 
+0x90, 0xA1, 0x7D, 0x12, 0x4F, 0xBC, 0x25, 0x0D, 0x90, 0xA1, 0x7E, 0x12, 0x4F, 0xB5, 0x25, 0x0D, 
+0x90, 0xA1, 0x7F, 0xF0, 0x91, 0x33, 0x25, 0x0D, 0x90, 0xA1, 0x80, 0xF0, 0xF1, 0xB2, 0x25, 0x0D, 
+0x90, 0xA1, 0x81, 0xF0, 0x90, 0x00, 0x05, 0x12, 0x26, 0x37, 0x25, 0x0D, 0x90, 0xA1, 0x82, 0xF0, 
+0x90, 0x00, 0x06, 0x12, 0x26, 0x37, 0x25, 0x0D, 0x90, 0xA1, 0x83, 0xF0, 0x22, 0x90, 0xA4, 0x49, 
+0xE0, 0x24, 0xA1, 0xF5, 0x82, 0xE4, 0x34, 0x9D, 0xF5, 0x83, 0x22, 0x7E, 0xFF, 0x74, 0xA1, 0x2F, 
+0xF1, 0x53, 0x74, 0xFF, 0xF0, 0xED, 0xB4, 0x3E, 0x0C, 0x7E, 0xBD, 0x74, 0xA1, 0x2F, 0xF1, 0x53, 
+0x74, 0x3D, 0xF0, 0x80, 0x1B, 0xED, 0xB4, 0x3F, 0x17, 0x75, 0xF0, 0x04, 0xEF, 0xF1, 0xA6, 0xC4, 
+0x13, 0x54, 0x07, 0x30, 0xE0, 0x0A, 0x7E, 0x3E, 0x74, 0xA1, 0x2F, 0xF1, 0x53, 0x74, 0x3E, 0xF0, 
+0xED, 0x14, 0xFD, 0x74, 0x75, 0x2F, 0x12, 0xAD, 0xBE, 0xED, 0xF0, 0xAF, 0x06, 0x22, 0x75, 0x1B, 
+0x3E, 0x75, 0xF0, 0x04, 0xE5, 0x19, 0x90, 0x96, 0x13, 0x12, 0x48, 0x65, 0xE0, 0x22, 0x81, 0x47, 
+0x41, 0x89, 0x90, 0x00, 0x04, 0x02, 0x26, 0x37, 0xE4, 0x90, 0xA1, 0x76, 0x02, 0x50, 0x66, 0x7F, 
+0x14, 0x7E, 0x00, 0x02, 0x3A, 0xF7, 0xE4, 0xFD, 0x7F, 0x8D, 0x02, 0x3A, 0x96, 0x12, 0x26, 0x1E, 
+0x90, 0xA2, 0x97, 0xF0, 0x22, 0x12, 0x26, 0x1E, 0x90, 0xA3, 0x3A, 0xF0, 0x22, 0xFF, 0xEE, 0x5A, 
+0xFE, 0xEF, 0x5B, 0x4E, 0x22, 0xEF, 0xF0, 0xE4, 0xA3, 0xF0, 0xA3, 0xF0, 0x22, 0xEC, 0x13, 0x13, 
+0x13, 0x54, 0x1F, 0xFF, 0x22, 0xE4, 0x90, 0xA4, 0x2B, 0xF0, 0x90, 0xA4, 0x2B, 0xE0, 0x64, 0x01, 
+0xF0, 0x24, 0xF5, 0x90, 0x01, 0xC4, 0xF0, 0x74, 0x5F, 0xA3, 0xF0, 0x12, 0x3A, 0xEB, 0xBF, 0x01, 
+0x03, 0x12, 0x31, 0x69, 0x90, 0xA2, 0x8C, 0xE0, 0x60, 0x0E, 0x90, 0xA2, 0x8F, 0xE0, 0xFF, 0x90, 
+0xA2, 0x8E, 0xE0, 0x6F, 0x60, 0x02, 0x11, 0x3D, 0xC2, 0xAF, 0x12, 0xA8, 0x6D, 0xBF, 0x01, 0x03, 
+0x12, 0xAA, 0xA7, 0xD2, 0xAF, 0x12, 0x5F, 0xAE, 0x12, 0x49, 0x62, 0x80, 0xBD, 0x90, 0xA2, 0x83, 
+0xE0, 0x90, 0xA2, 0x8E, 0x30, 0xE0, 0x04, 0xE0, 0xFF, 0xE1, 0xAE, 0xE0, 0xFF, 0x7D, 0x01, 0x02, 
+0x51, 0xE9, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x12, 0x7F, 0x60, 0x90, 0x05, 0x27, 0xE0, 
+0xF5, 0x10, 0x12, 0x26, 0x1E, 0xFF, 0x54, 0x01, 0xFE, 0x90, 0xA2, 0x83, 0xE0, 0x54, 0xFE, 0x4E, 
+0xFE, 0xF0, 0xEF, 0x54, 0x02, 0xFF, 0xEE, 0x54, 0xFD, 0x4F, 0x71, 0x06, 0x54, 0x04, 0xFD, 0xEF, 
+0x54, 0xFB, 0x71, 0x0D, 0x54, 0x08, 0xFE, 0xEF, 0x54, 0xF7, 0x71, 0x05, 0x54, 0x10, 0xFD, 0xEF, 
+0x54, 0xEF, 0x71, 0x0D, 0x54, 0x20, 0xFE, 0xEF, 0x54, 0xDF, 0x71, 0x05, 0x54, 0x40, 0xFD, 0xEF, 
+0x54, 0xBF, 0x4D, 0x90, 0xA2, 0x83, 0xF0, 0xEE, 0xC3, 0x13, 0x20, 0xE0, 0x02, 0x21, 0x39, 0xE0, 
+0x30, 0xE0, 0x72, 0x71, 0x3E, 0x75, 0x10, 0x21, 0x71, 0x1E, 0x30, 0xE0, 0x07, 0x71, 0x66, 0x43, 
+0x10, 0x08, 0x80, 0x0C, 0xE4, 0x90, 0xA2, 0x84, 0xF0, 0xA3, 0xF0, 0x7D, 0x40, 0xFF, 0x71, 0x5B, 
+0x90, 0xA2, 0x83, 0x71, 0x2A, 0x30, 0xE0, 0x03, 0x43, 0x10, 0x12, 0xEF, 0xC4, 0x54, 0x0F, 0x30, 
+0xE0, 0x03, 0x43, 0x10, 0x14, 0x90, 0xA2, 0x83, 0xE0, 0xC4, 0x13, 0x54, 0x07, 0x30, 0xE0, 0x03, 
+0x43, 0x10, 0x80, 0x90, 0xA2, 0x83, 0x12, 0xBB, 0x7C, 0x20, 0xE0, 0x03, 0x43, 0x10, 0x40, 0x31, 
+0xE3, 0x90, 0xA2, 0x86, 0xE0, 0x70, 0x04, 0x7F, 0x01, 0x31, 0xEA, 0x71, 0x15, 0x54, 0x03, 0x30, 
+0xE0, 0x04, 0x7F, 0x04, 0x80, 0x0B, 0x71, 0x32, 0xEF, 0x60, 0x04, 0x7F, 0x01, 0x80, 0x02, 0x7F, 
+0x02, 0x31, 0xEA, 0x21, 0xAB, 0x75, 0x10, 0x01, 0x31, 0xE3, 0x90, 0xA2, 0x86, 0xE0, 0x64, 0x04, 
+0x60, 0x02, 0x21, 0xDE, 0xFF, 0x31, 0xEA, 0x21, 0xDE, 0x90, 0xA2, 0x83, 0xE0, 0x30, 0xE0, 0x73, 
+0x71, 0x3E, 0x43, 0x10, 0x31, 0x71, 0x1E, 0x30, 0xE0, 0x07, 0x71, 0x66, 0x43, 0x10, 0x08, 0x80, 
+0x06, 0x7D, 0x40, 0xE4, 0xFF, 0x71, 0x5B, 0x90, 0xA2, 0x83, 0x71, 0x2A, 0x30, 0xE0, 0x03, 0x43, 
+0x10, 0x02, 0xEF, 0xC4, 0x54, 0x0F, 0x30, 0xE0, 0x03, 0x43, 0x10, 0x04, 0x31, 0xE3, 0x71, 0x15, 
+0x54, 0x03, 0x30, 0xE0, 0x0B, 0x12, 0x79, 0xCD, 0x60, 0x31, 0xE4, 0xFD, 0x7F, 0x02, 0x80, 0x1E, 
+0x12, 0x9F, 0xCD, 0x90, 0xA2, 0x87, 0xE0, 0xB4, 0x02, 0x19, 0x12, 0xB9, 0x41, 0x71, 0x32, 0xBF, 
+0x01, 0x09, 0x90, 0xA2, 0x8E, 0xE0, 0xFF, 0x7D, 0x01, 0x80, 0x03, 0xE4, 0xFD, 0xFF, 0x12, 0x51, 
+0xE9, 0x80, 0x08, 0x90, 0xA2, 0x8F, 0xE0, 0x90, 0xA2, 0x87, 0xF0, 0x90, 0x05, 0x40, 0x74, 0x22, 
+0xF0, 0x80, 0x2B, 0x75, 0x10, 0x01, 0x31, 0xE3, 0x90, 0xA2, 0x87, 0xE0, 0xB4, 0x02, 0x06, 0x7D, 
+0x01, 0x7F, 0x04, 0x80, 0x0B, 0x90, 0xA2, 0x87, 0xE0, 0xB4, 0x08, 0x07, 0x7D, 0x01, 0x7F, 0x0C, 
+0x12, 0x51, 0xE9, 0x12, 0x7F, 0xD7, 0x90, 0xA2, 0x8E, 0x11, 0x4B, 0x12, 0xB8, 0x3F, 0xD0, 0xD0, 
+0x92, 0xAF, 0x22, 0x90, 0x05, 0x27, 0xE5, 0x10, 0xF0, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 
+0xD0, 0x90, 0xA2, 0x86, 0xE0, 0x90, 0xA5, 0xFF, 0xF0, 0x6F, 0x70, 0x02, 0x61, 0x00, 0xEF, 0x14, 
+0x60, 0x46, 0x14, 0x60, 0x71, 0x14, 0x70, 0x02, 0x41, 0xA4, 0x14, 0x70, 0x02, 0x41, 0xD3, 0x24, 
+0x04, 0x60, 0x02, 0x61, 0x00, 0x90, 0xA5, 0xFF, 0xE0, 0xB4, 0x04, 0x05, 0x12, 0xB8, 0x6A, 0x61, 
+0x00, 0x90, 0xA5, 0xFF, 0xE0, 0xB4, 0x02, 0x05, 0x12, 0xB8, 0x6F, 0x61, 0x00, 0x90, 0xA5, 0xFF, 
+0xE0, 0xB4, 0x03, 0x05, 0x12, 0xB8, 0x66, 0x61, 0x00, 0x90, 0xA5, 0xFF, 0xE0, 0x64, 0x01, 0x60, 
+0x02, 0x61, 0x00, 0x12, 0xB8, 0x5E, 0x61, 0x00, 0x90, 0xA5, 0xFF, 0xE0, 0xB4, 0x04, 0x04, 0xF1, 
+0xD2, 0x61, 0x00, 0x90, 0xA5, 0xFF, 0xE0, 0xB4, 0x02, 0x04, 0xF1, 0xDA, 0x61, 0x00, 0x90, 0xA5, 
+0xFF, 0xE0, 0xB4, 0x03, 0x05, 0x12, 0xB8, 0x74, 0x61, 0x00, 0x90, 0xA5, 0xFF, 0xE0, 0x60, 0x02, 
+0x61, 0x00, 0xF1, 0xCB, 0x61, 0x00, 0x90, 0xA5, 0xFF, 0xE0, 0xB4, 0x04, 0x05, 0x12, 0x9F, 0xBF, 
+0x80, 0x7E, 0x90, 0xA5, 0xFF, 0xE0, 0xB4, 0x01, 0x04, 0xF1, 0xE2, 0x80, 0x73, 0x90, 0xA5, 0xFF, 
+0xE0, 0xB4, 0x03, 0x05, 0x12, 0x9F, 0xAE, 0x80, 0x67, 0x90, 0xA5, 0xFF, 0xE0, 0x70, 0x61, 0x12, 
+0xB8, 0xAE, 0x80, 0x5C, 0x90, 0xA5, 0xFF, 0xE0, 0xB4, 0x04, 0x05, 0x12, 0xB8, 0xB4, 0x80, 0x50, 
+0x90, 0xA5, 0xFF, 0xE0, 0xB4, 0x01, 0x05, 0x12, 0xB8, 0x99, 0x80, 0x44, 0x90, 0xA5, 0xFF, 0xE0, 
+0xB4, 0x02, 0x05, 0x12, 0x9F, 0xB6, 0x80, 0x38, 0x90, 0xA5, 0xFF, 0xE0, 0x70, 0x32, 0x12, 0xB8, 
+0xA3, 0x80, 0x2D, 0x90, 0xA5, 0xFF, 0xE0, 0xB4, 0x03, 0x05, 0x12, 0xB8, 0xC1, 0x80, 0x21, 0x90, 
+0xA5, 0xFF, 0xE0, 0xB4, 0x01, 0x05, 0x12, 0x57, 0xEF, 0x80, 0x15, 0x90, 0xA5, 0xFF, 0xE0, 0xB4, 
+0x02, 0x05, 0x12, 0x9F, 0xC6, 0x80, 0x09, 0x90, 0xA5, 0xFF, 0xE0, 0x70, 0x03, 0x12, 0xB8, 0xA8, 
+0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x4E, 0xFF, 0xF0, 0x12, 0x26, 0x1E, 0xFE, 0x22, 0x4D, 0xFF, 0x90, 
+0xA2, 0x83, 0xF0, 0xEE, 0x22, 0x90, 0xA2, 0x83, 0xE0, 0xFF, 0xC4, 0x13, 0x13, 0x22, 0x90, 0xA2, 
+0x83, 0xE0, 0x13, 0x13, 0x54, 0x3F, 0x22, 0x90, 0xA2, 0x89, 0xE0, 0xFF, 0x13, 0x13, 0x13, 0x54, 
+0x1F, 0x22, 0x90, 0x05, 0x43, 0xE0, 0x7F, 0x00, 0x30, 0xE7, 0x02, 0x7F, 0x01, 0x22, 0x7D, 0x03, 
+0x7F, 0x02, 0x74, 0x65, 0x2F, 0xF8, 0xE6, 0x4D, 0xFE, 0xF6, 0x74, 0x38, 0x2F, 0xF5, 0x82, 0xE4, 
+0x34, 0x01, 0xF5, 0x83, 0xEE, 0xF0, 0x22, 0x7D, 0x02, 0x7F, 0x02, 0x74, 0x5D, 0x12, 0xBC, 0x6E, 
+0xFE, 0xF6, 0x74, 0x30, 0x80, 0xE6, 0x90, 0x01, 0x34, 0x74, 0x40, 0xF0, 0xFD, 0xE4, 0xFF, 0x74, 
+0x5D, 0x2F, 0xF8, 0xE6, 0x4D, 0xFE, 0xF6, 0x74, 0x30, 0x80, 0xD1, 0x12, 0xBA, 0xF7, 0xCE, 0xC3, 
+0x13, 0xCE, 0x13, 0xD8, 0xF9, 0xFF, 0x90, 0xA4, 0xF8, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0xD1, 0x1B, 
+0x60, 0x02, 0x81, 0x4D, 0x90, 0xA2, 0x8C, 0xE0, 0x70, 0x02, 0x81, 0x4D, 0xF1, 0x06, 0x64, 0x01, 
+0x70, 0x22, 0x90, 0x06, 0xAB, 0xE0, 0x90, 0xA2, 0x93, 0xF0, 0x90, 0x06, 0xAA, 0xE0, 0x90, 0xA2, 
+0x92, 0xF0, 0xA3, 0xE0, 0xFF, 0x70, 0x08, 0x90, 0xA2, 0x92, 0xE0, 0xFE, 0xFF, 0x80, 0x00, 0x90, 
+0xA2, 0x93, 0xEF, 0xF0, 0x12, 0x7D, 0x37, 0xE4, 0x90, 0xA2, 0x95, 0x12, 0x7F, 0x84, 0xF1, 0x45, 
+0xF1, 0x8A, 0x54, 0xEF, 0xF0, 0xF1, 0x06, 0x24, 0xFD, 0x50, 0x02, 0x80, 0x0F, 0x90, 0xA2, 0x83, 
+0xE0, 0x30, 0xE0, 0x05, 0x12, 0x78, 0xCE, 0x80, 0x03, 0x12, 0x78, 0x80, 0x71, 0x27, 0x30, 0xE0, 
+0x5A, 0xEF, 0xC4, 0x13, 0x13, 0x54, 0x03, 0x20, 0xE0, 0x20, 0xF1, 0x28, 0x6F, 0x70, 0x4C, 0x90, 
+0xA2, 0x89, 0xE0, 0x44, 0x40, 0xF0, 0x12, 0xBC, 0x3E, 0xF1, 0x3A, 0x71, 0x42, 0x12, 0x9C, 0xA7, 
+0x71, 0x57, 0x90, 0xA2, 0x93, 0xE0, 0x14, 0xF0, 0x80, 0x31, 0x90, 0xA2, 0x8A, 0xE0, 0xC4, 0x54, 
+0x0F, 0x64, 0x01, 0x70, 0x26, 0xF1, 0x28, 0xFE, 0x6F, 0x60, 0x20, 0x90, 0x05, 0x73, 0xE0, 0xFF, 
+0xEE, 0x6F, 0x60, 0x17, 0x90, 0xA2, 0x89, 0xE0, 0xFF, 0x13, 0x13, 0x54, 0x3F, 0x30, 0xE0, 0x0B, 
+0xEF, 0x54, 0xBF, 0xF1, 0x3A, 0xB1, 0x56, 0xF1, 0x92, 0x71, 0x6F, 0x91, 0xF3, 0x90, 0xA2, 0x83, 
+0xE0, 0xC3, 0x13, 0x20, 0xE0, 0x02, 0x91, 0xF3, 0x22, 0x71, 0x27, 0x30, 0xE0, 0x0B, 0xEF, 0xC4, 
+0x13, 0x13, 0x54, 0x03, 0x30, 0xE0, 0x02, 0x71, 0x57, 0x12, 0xBC, 0x36, 0x54, 0x3F, 0x30, 0xE0, 
+0x08, 0xF1, 0x86, 0x54, 0x07, 0x70, 0x3B, 0x80, 0x37, 0x12, 0xBA, 0x38, 0x40, 0x32, 0xD1, 0x1B, 
+0x70, 0x30, 0x12, 0x79, 0x40, 0x70, 0x07, 0x12, 0x7D, 0x0A, 0x91, 0xB3, 0xF0, 0x22, 0x12, 0x7D, 
+0x0A, 0x90, 0xA2, 0x96, 0xE0, 0x04, 0xF0, 0xE0, 0xD3, 0x94, 0x02, 0x40, 0x0A, 0x91, 0xB3, 0xF0, 
+0xE4, 0x90, 0xA2, 0x96, 0xF0, 0x80, 0x03, 0x12, 0x57, 0x8F, 0xE4, 0x90, 0xA2, 0x95, 0xF0, 0x22, 
+0x11, 0x3D, 0x22, 0x90, 0xA2, 0x89, 0xE0, 0x54, 0xFB, 0x22, 0x90, 0x01, 0x36, 0x74, 0x78, 0xF0, 
+0xA3, 0x74, 0x02, 0xF0, 0x7D, 0x78, 0xFF, 0x71, 0x6F, 0x7D, 0x02, 0x7F, 0x03, 0x71, 0x6F, 0x90, 
+0x06, 0x0A, 0xE0, 0x44, 0x07, 0x12, 0x7F, 0x84, 0xE4, 0xFF, 0x91, 0xFB, 0xBF, 0x01, 0x11, 0x91, 
+0xB3, 0xF0, 0x90, 0xA2, 0x8F, 0xE0, 0x20, 0xE2, 0x09, 0x7D, 0x01, 0x7F, 0x04, 0x02, 0x51, 0xE9, 
+0x91, 0xF3, 0x22, 0x90, 0xA2, 0x89, 0xE0, 0x44, 0x04, 0xF0, 0x22, 0x12, 0xBB, 0x70, 0x12, 0x9D, 
+0x0B, 0xE0, 0xFD, 0x7C, 0x00, 0x12, 0x9C, 0xB1, 0x80, 0x05, 0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 
+0xF9, 0x12, 0xBC, 0x7E, 0x7F, 0x00, 0x60, 0x02, 0x7F, 0x01, 0x22, 0xEF, 0x70, 0x32, 0x7D, 0x78, 
+0x7F, 0x02, 0x71, 0x5B, 0x7D, 0x02, 0x7F, 0x03, 0x71, 0x5B, 0x7D, 0xC8, 0x7F, 0x02, 0xB1, 0x56, 
+0xF1, 0x45, 0xE4, 0xFF, 0x91, 0xFB, 0xEF, 0x70, 0x07, 0xF1, 0x9D, 0x54, 0x7F, 0xF0, 0x80, 0x07, 
+0x7D, 0x01, 0x7F, 0x0C, 0x12, 0x51, 0xE9, 0x90, 0xA2, 0x88, 0xE0, 0x54, 0xF7, 0x02, 0xBB, 0xF9, 
+0x81, 0xBA, 0x7D, 0x20, 0xE4, 0xFF, 0x74, 0x65, 0x12, 0xBC, 0x6E, 0x61, 0x48, 0x90, 0xA2, 0x88, 
+0xE0, 0x54, 0xFB, 0xF0, 0xE4, 0x90, 0xA2, 0x95, 0xF0, 0xA3, 0xF0, 0x90, 0xA2, 0x90, 0xF0, 0x90, 
+0xA2, 0x89, 0xF1, 0xA6, 0xF1, 0x92, 0x71, 0x6F, 0x7D, 0x10, 0x7F, 0x03, 0x80, 0xD8, 0xE4, 0x90, 
+0xA5, 0x08, 0xF0, 0x90, 0xA2, 0x8C, 0xE0, 0x70, 0x02, 0xC1, 0x1A, 0xD1, 0x1B, 0x60, 0x02, 0xC1, 
+0x1A, 0x12, 0xBC, 0x3E, 0xD1, 0xE5, 0x12, 0x47, 0x77, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 
+0x07, 0x90, 0x05, 0x62, 0xD1, 0xFF, 0x78, 0x10, 0x12, 0x27, 0x35, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 
+0x01, 0xD0, 0x00, 0x12, 0x47, 0x77, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0xA3, 0xD1, 
+0xFF, 0x78, 0x18, 0x12, 0x27, 0x35, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0x12, 0xBB, 
+0x8D, 0x90, 0xA5, 0x08, 0x74, 0x01, 0xF0, 0xE4, 0x90, 0xA2, 0x93, 0xF0, 0x90, 0xA2, 0x83, 0xE0, 
+0x30, 0xE0, 0x15, 0x90, 0xA2, 0x87, 0xE0, 0xB4, 0x02, 0x05, 0xE4, 0x90, 0xA5, 0x08, 0xF0, 0x71, 
+0x32, 0xEF, 0x70, 0x04, 0x90, 0xA5, 0x08, 0xF0, 0x90, 0xA5, 0x08, 0xE0, 0x60, 0x1C, 0x12, 0xBC, 
+0x46, 0xE4, 0x90, 0xA5, 0x9B, 0xF0, 0x90, 0xA2, 0x94, 0xE0, 0x90, 0xA5, 0x9C, 0x12, 0x78, 0x14, 
+0x90, 0xA2, 0x8F, 0xE0, 0x20, 0xE2, 0x03, 0x12, 0x51, 0xE5, 0x22, 0xE4, 0xFF, 0x91, 0xFB, 0xEF, 
+0x64, 0x01, 0x22, 0xE4, 0xF5, 0x20, 0x90, 0xA2, 0x8C, 0xE0, 0x70, 0x02, 0xC1, 0xE4, 0xD1, 0x1B, 
+0x60, 0x02, 0xC1, 0xE4, 0xD1, 0xE6, 0x12, 0x47, 0x77, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 
+0x07, 0x90, 0x05, 0x62, 0xD1, 0xFF, 0x78, 0x10, 0x12, 0x27, 0x35, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 
+0x01, 0xD0, 0x00, 0x12, 0x47, 0x77, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0xA3, 0xD1, 
+0xFF, 0x78, 0x18, 0x12, 0x27, 0x35, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0x12, 0xBB, 
+0x8D, 0xF1, 0x06, 0x60, 0x22, 0x24, 0xFE, 0x60, 0x03, 0x04, 0x70, 0x1E, 0x90, 0xA2, 0x93, 0xE0, 
+0x14, 0xF0, 0xE0, 0xFF, 0x60, 0x06, 0x90, 0xA2, 0x95, 0xE0, 0x60, 0x0E, 0xEF, 0x70, 0x08, 0x90, 
+0xA2, 0x92, 0xE0, 0xA3, 0xF0, 0x80, 0x00, 0x75, 0x20, 0x01, 0x90, 0xA2, 0x83, 0xE0, 0x30, 0xE0, 
+0x11, 0x90, 0xA2, 0x87, 0xE0, 0xB4, 0x02, 0x03, 0xE4, 0xF5, 0x20, 0x71, 0x32, 0xEF, 0x70, 0x02, 
+0xF5, 0x20, 0xE5, 0x20, 0x60, 0x2E, 0x12, 0xBC, 0x46, 0x90, 0xA2, 0x95, 0xE0, 0x60, 0x03, 0xB4, 
+0x01, 0x04, 0xF1, 0x30, 0x80, 0x08, 0xF1, 0x30, 0x75, 0xF0, 0x03, 0xA4, 0x24, 0xFE, 0xFF, 0x90, 
+0xA2, 0x94, 0xE0, 0x2F, 0x90, 0xA5, 0x9C, 0x12, 0x78, 0x14, 0x90, 0xA2, 0x8F, 0xE0, 0x20, 0xE2, 
+0x03, 0x12, 0x51, 0xE5, 0x22, 0xF0, 0x90, 0x05, 0x61, 0xE0, 0xFF, 0xE4, 0xFC, 0xFD, 0xFE, 0x78, 
+0x08, 0x12, 0x27, 0x35, 0xA8, 0x04, 0xA9, 0x05, 0xAA, 0x06, 0xAB, 0x07, 0x90, 0x05, 0x60, 0xE0, 
+0xFF, 0xE4, 0xFC, 0xFD, 0xFE, 0x22, 0x90, 0xA2, 0x8A, 0xE0, 0xFF, 0xC4, 0x54, 0x0F, 0x22, 0xD1, 
+0x1B, 0x70, 0x14, 0x90, 0xA2, 0x8C, 0xE0, 0x60, 0x0E, 0xF1, 0x45, 0x90, 0xA2, 0x88, 0xE0, 0xF1, 
+0x87, 0x54, 0x07, 0x70, 0x02, 0x11, 0x3D, 0x22, 0x90, 0xA2, 0x92, 0xE0, 0xFF, 0xA3, 0xE0, 0x22, 
+0xE4, 0x90, 0xA5, 0x9B, 0xF0, 0x90, 0xA2, 0x95, 0xE0, 0x22, 0xF0, 0x90, 0x01, 0x3F, 0x74, 0x10, 
+0xF0, 0xFD, 0x7F, 0x03, 0x22, 0x90, 0x01, 0x57, 0xE4, 0xF0, 0x90, 0x01, 0x3C, 0x74, 0x02, 0xF0, 
+0x22, 0xD1, 0x1B, 0x70, 0x0E, 0x90, 0xA2, 0x8C, 0xE0, 0x60, 0x08, 0xF1, 0x45, 0x12, 0x79, 0x53, 
+0x12, 0x78, 0x14, 0x22, 0x90, 0x01, 0x57, 0xE0, 0x60, 0x1B, 0xF1, 0x48, 0x12, 0xBC, 0x36, 0x54, 
+0x3F, 0x30, 0xE0, 0x02, 0x80, 0x10, 0x12, 0xBA, 0x38, 0x40, 0x0A, 0xE4, 0xFF, 0x91, 0xFB, 0xBF, 
+0x01, 0x03, 0x91, 0xB3, 0xF0, 0x22, 0xEF, 0x54, 0xFB, 0xF0, 0x90, 0xA2, 0x90, 0xE0, 0x54, 0xFD, 
+0xF0, 0x22, 0x7D, 0x01, 0x7F, 0x02, 0x71, 0x6F, 0x7D, 0x02, 0x7F, 0x02, 0x22, 0x12, 0x9D, 0xA8, 
+0x12, 0xB9, 0x30, 0x90, 0xA2, 0x88, 0xE0, 0x54, 0xF7, 0xF0, 0x54, 0xBF, 0xF0, 0x22, 0xAE, 0x07, 
+0x71, 0x32, 0xBF, 0x01, 0x13, 0x90, 0xA2, 0x83, 0x12, 0xBB, 0x7C, 0x20, 0xE0, 0x0A, 0xAF, 0x06, 
+0x7D, 0x01, 0x12, 0x51, 0xE9, 0x7F, 0x01, 0x22, 0x7F, 0x00, 0x22, 0x90, 0xA2, 0x86, 0x74, 0x01, 
+0xF0, 0x22, 0x12, 0x53, 0xCB, 0x12, 0x9F, 0xCD, 0x80, 0xF1, 0x12, 0x9D, 0xA8, 0x12, 0x53, 0xCB, 
+0x80, 0xE9, 0x7D, 0x20, 0x7F, 0xFF, 0x12, 0x53, 0xE1, 0x12, 0x9E, 0xEF, 0x90, 0xA2, 0x86, 0x74, 
+0x02, 0xF0, 0x22, 0xE4, 0xFB, 0xFA, 0xFD, 0x7F, 0x01, 0x12, 0x4B, 0x63, 0x90, 0xA4, 0x2C, 0xEF, 
+0xF0, 0x60, 0xF0, 0x90, 0xA1, 0x76, 0xE0, 0xFF, 0x70, 0x04, 0xA3, 0xE0, 0x60, 0xE5, 0xC2, 0xAF, 
+0xEF, 0x30, 0xE0, 0x0E, 0x90, 0xA1, 0x76, 0xE0, 0x54, 0xFE, 0xF0, 0xE4, 0xFF, 0x12, 0x9A, 0xC1, 
+0x11, 0x3E, 0x12, 0xBB, 0xE6, 0x30, 0xE1, 0x06, 0x54, 0xFD, 0xF0, 0x12, 0xA2, 0xDF, 0x12, 0xBB, 
+0xE6, 0x30, 0xE2, 0x06, 0x54, 0xFB, 0xF0, 0x12, 0xA4, 0xDA, 0xD2, 0xAF, 0x80, 0xC5, 0xE4, 0xF5, 
+0x0D, 0x90, 0xA2, 0x81, 0xE0, 0xFF, 0xE5, 0x0D, 0xC3, 0x9F, 0x40, 0x02, 0xC1, 0x62, 0xAF, 0x0D, 
+0x12, 0x64, 0xFB, 0xEF, 0x70, 0x02, 0xC1, 0x5E, 0x12, 0x4F, 0xA8, 0x12, 0x7A, 0xF5, 0x30, 0xE0, 
+0x02, 0xC1, 0x5E, 0x90, 0x04, 0xA0, 0xE0, 0xFF, 0xA3, 0xE0, 0xFE, 0xEF, 0x64, 0x01, 0x70, 0x2E, 
+0xE5, 0x0D, 0x6E, 0x70, 0x29, 0xA3, 0xE0, 0xF5, 0x0E, 0xA3, 0xE0, 0x90, 0xA4, 0x3C, 0xF1, 0xE9, 
+0xE5, 0x0E, 0xF0, 0x75, 0xF0, 0x10, 0xE5, 0x0D, 0x12, 0x76, 0x4D, 0xE0, 0x54, 0xFC, 0xFF, 0x90, 
+0xA4, 0x3C, 0xE0, 0x12, 0xBC, 0x8E, 0xE5, 0x0D, 0x12, 0x76, 0x4D, 0xEF, 0xF0, 0x22, 0xE5, 0x0D, 
+0x12, 0x9C, 0x34, 0xE0, 0xFE, 0xA3, 0xE0, 0xD3, 0x94, 0x00, 0xEE, 0x94, 0x00, 0x50, 0x02, 0xC1, 
+0x5E, 0xE5, 0x0D, 0x75, 0xF0, 0x0A, 0xA4, 0x24, 0x01, 0xF9, 0x74, 0x8D, 0x35, 0xF0, 0xFA, 0x7B, 
+0x01, 0x90, 0xA4, 0x30, 0x12, 0x48, 0x7A, 0xE5, 0x0D, 0x12, 0x9C, 0x34, 0xE0, 0xF5, 0x12, 0xA3, 
+0xE0, 0xF5, 0x13, 0x74, 0x91, 0x25, 0x0D, 0x12, 0x77, 0xB7, 0xE0, 0xFF, 0x90, 0xA4, 0x33, 0xE4, 
+0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0x00, 0x02, 0x12, 0x47, 0x17, 0xFF, 0xAE, 0xF0, 0x12, 0x46, 0xEC, 
+0x2F, 0xFF, 0xE5, 0xF0, 0x3E, 0xFE, 0x90, 0x00, 0x04, 0xF1, 0xDB, 0x35, 0xF0, 0xFE, 0x90, 0x00, 
+0x06, 0xF1, 0xDB, 0x35, 0xF0, 0xFE, 0xD1, 0x7D, 0x2F, 0xFF, 0xEE, 0x35, 0xF0, 0x90, 0xA4, 0x35, 
+0xF0, 0xA3, 0xEF, 0xF0, 0x12, 0x46, 0xEC, 0xFF, 0xC3, 0x90, 0xA4, 0x36, 0xE0, 0x9F, 0xFE, 0x90, 
+0xA4, 0x35, 0xE0, 0x95, 0xF0, 0x90, 0xA4, 0x37, 0xF0, 0xA3, 0xCE, 0xF0, 0x90, 0x00, 0x06, 0x12, 
+0x47, 0x17, 0xFD, 0xAC, 0xF0, 0x25, 0xE0, 0xFF, 0xEC, 0x33, 0xFE, 0xEF, 0x2D, 0xFD, 0xEE, 0x3C, 
+0xFC, 0x90, 0x00, 0x04, 0x12, 0x47, 0x17, 0x25, 0xE0, 0xFF, 0xE5, 0xF0, 0x33, 0xFE, 0x90, 0x00, 
+0x02, 0xF1, 0xDB, 0x35, 0xF0, 0xCF, 0x2D, 0xFD, 0xEF, 0x3C, 0xFC, 0x90, 0xA4, 0x30, 0x12, 0x48, 
+0x71, 0xD1, 0x7D, 0xAE, 0xF0, 0x78, 0x02, 0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 0xF9, 0x2D, 0xFF, 
+0xEC, 0x3E, 0x90, 0xA4, 0x39, 0xF0, 0xA3, 0xEF, 0xF1, 0xE9, 0xE0, 0xF5, 0x0E, 0x54, 0x7F, 0xF5, 
+0x0F, 0x75, 0xF0, 0x04, 0xE5, 0x0D, 0x12, 0x76, 0x41, 0xE0, 0x90, 0xA4, 0x3B, 0xF0, 0x12, 0x4F, 
+0xA8, 0xFF, 0x13, 0x13, 0x54, 0x03, 0x90, 0xA4, 0x3C, 0xF0, 0xD1, 0x65, 0xE0, 0xC3, 0x94, 0x05, 
+0x40, 0x02, 0x81, 0x7D, 0x90, 0xA4, 0x3B, 0xE0, 0xFF, 0xE5, 0x0F, 0x9F, 0x40, 0x08, 0x8F, 0x0F, 
+0x53, 0x0E, 0x80, 0xEF, 0x42, 0x0E, 0xE5, 0x0F, 0x90, 0x42, 0x41, 0x93, 0x12, 0x5C, 0x39, 0xC3, 
+0x9F, 0x40, 0x0A, 0xE5, 0x0F, 0x90, 0x41, 0xED, 0x93, 0xF5, 0x14, 0x80, 0x0A, 0x74, 0x21, 0x25, 
+0x0F, 0x12, 0xB2, 0x42, 0xE0, 0xF5, 0x14, 0xE5, 0x14, 0x75, 0xF0, 0x06, 0xA4, 0x24, 0x4B, 0xF9, 
+0x74, 0x41, 0x35, 0xF0, 0xFA, 0x7B, 0xFF, 0x90, 0xA4, 0x2D, 0x12, 0x48, 0x7A, 0xC3, 0xE5, 0x13, 
+0x94, 0x0F, 0xE5, 0x12, 0x94, 0x00, 0x40, 0x02, 0x41, 0x82, 0x90, 0xA4, 0x30, 0x12, 0x48, 0x71, 
+0x90, 0x00, 0x06, 0x12, 0x47, 0x17, 0xFF, 0xAE, 0xF0, 0xD1, 0x7D, 0x2F, 0xFD, 0xE5, 0xF0, 0x3E, 
+0xFC, 0x12, 0xBB, 0xDC, 0xD3, 0xED, 0x9F, 0xEC, 0x9E, 0x40, 0x02, 0x81, 0x56, 0xE5, 0x13, 0xAE, 
+0x12, 0x78, 0x02, 0xCE, 0xC3, 0x13, 0xCE, 0x13, 0xD8, 0xF9, 0xFD, 0xAC, 0x06, 0xE5, 0x12, 0xC3, 
+0x13, 0xFE, 0xE5, 0x13, 0x13, 0x2D, 0xFF, 0xEE, 0x3C, 0xFE, 0x90, 0xA4, 0x30, 0x12, 0x48, 0x71, 
+0x12, 0x46, 0xEC, 0xD3, 0x9F, 0xE5, 0xF0, 0x9E, 0x50, 0x02, 0x81, 0x5D, 0xE5, 0x0F, 0x94, 0x38, 
+0x40, 0x0A, 0x12, 0x5C, 0x3A, 0xC3, 0x94, 0x0F, 0x50, 0x02, 0x81, 0x5D, 0xE5, 0x0F, 0xC3, 0x94, 
+0x3A, 0x40, 0x0A, 0x12, 0x5C, 0x3A, 0xC3, 0x94, 0x14, 0x50, 0x02, 0x81, 0x5D, 0xE5, 0x0F, 0xC3, 
+0x94, 0x3C, 0x50, 0x02, 0x81, 0x44, 0x12, 0x5C, 0x3A, 0xC3, 0x94, 0x19, 0x50, 0x02, 0x81, 0x5D, 
+0x81, 0x44, 0xE5, 0x0D, 0x70, 0x46, 0x90, 0xA4, 0x30, 0x12, 0x48, 0x71, 0xD1, 0x7D, 0xFD, 0xAC, 
+0xF0, 0x12, 0xBB, 0xDC, 0xC3, 0xED, 0x9F, 0xEC, 0x9E, 0x50, 0x08, 0x90, 0xA1, 0x75, 0x74, 0x01, 
+0xF0, 0x80, 0x29, 0xE5, 0x13, 0xAE, 0x12, 0x78, 0x03, 0xCE, 0xC3, 0x13, 0xCE, 0x13, 0xD8, 0xF9, 
+0xFB, 0xAA, 0x06, 0xE5, 0x12, 0xC3, 0x13, 0xFE, 0xE5, 0x13, 0x13, 0x2B, 0xFF, 0xEE, 0x3A, 0xFE, 
+0xD3, 0xED, 0x9F, 0xEC, 0x9E, 0x40, 0x05, 0xE4, 0x90, 0xA1, 0x75, 0xF0, 0xD1, 0x83, 0x12, 0x63, 
+0x2A, 0xFE, 0x60, 0x12, 0xD1, 0x83, 0xEF, 0x54, 0x07, 0xFF, 0xC3, 0xEE, 0x94, 0x01, 0x54, 0x1F, 
+0x12, 0xBC, 0x86, 0xF0, 0x81, 0x5D, 0xE5, 0x0D, 0x13, 0x13, 0x13, 0x54, 0x1F, 0x90, 0xA4, 0x41, 
+0xF0, 0xE5, 0x0D, 0x54, 0x07, 0xA3, 0xF0, 0x90, 0xA4, 0x41, 0xE0, 0x24, 0x11, 0xF1, 0xD3, 0xE0, 
+0xFD, 0x7C, 0x00, 0x90, 0xA4, 0x42, 0xE0, 0x12, 0x9C, 0xB0, 0x80, 0x05, 0xC3, 0x33, 0xCE, 0x33, 
+0xCE, 0xD8, 0xF9, 0x12, 0xBC, 0x7E, 0x60, 0x29, 0x74, 0xA1, 0x25, 0x0D, 0x12, 0x5F, 0x53, 0xE0, 
+0xFF, 0xF4, 0x60, 0x1D, 0x8F, 0x0E, 0x90, 0xA4, 0x3C, 0xE0, 0xF5, 0x27, 0x7B, 0x01, 0xAD, 0x0E, 
+0xAF, 0x0D, 0x12, 0x73, 0x7D, 0x74, 0xA1, 0x25, 0x0D, 0x12, 0x5F, 0x53, 0x74, 0xFF, 0xF0, 0x81, 
+0x5D, 0x12, 0xBB, 0xBE, 0x40, 0x05, 0x75, 0x15, 0x05, 0x80, 0x13, 0xD3, 0xE5, 0x13, 0x94, 0xC8, 
+0xE5, 0x12, 0x94, 0x00, 0x40, 0x05, 0x75, 0x15, 0x02, 0x80, 0x03, 0xE4, 0xF5, 0x15, 0xE5, 0x0D, 
+0x12, 0xAE, 0xC0, 0xE0, 0xF5, 0x10, 0xA3, 0xE0, 0xF5, 0x11, 0xE4, 0xF5, 0x18, 0x12, 0xBB, 0xB4, 
+0xE5, 0x18, 0x12, 0xA7, 0x0A, 0x12, 0xBC, 0x2E, 0x08, 0x80, 0x05, 0xCE, 0xC3, 0x13, 0xCE, 0x13, 
+0xD8, 0xF9, 0xFF, 0x90, 0xA4, 0x2D, 0x12, 0x48, 0x71, 0x85, 0x18, 0x82, 0x12, 0xA5, 0x60, 0x12, 
+0xBA, 0xE6, 0x05, 0x18, 0xE5, 0x18, 0xB4, 0x05, 0xD4, 0x90, 0xA4, 0x2D, 0x12, 0x48, 0x71, 0x90, 
+0x00, 0x05, 0x12, 0x26, 0x37, 0xFD, 0x7C, 0x00, 0x12, 0xBC, 0x76, 0x80, 0x05, 0xCE, 0xC3, 0x13, 
+0xCE, 0x13, 0xD8, 0xF9, 0xFF, 0x12, 0x26, 0x98, 0xD3, 0xE5, 0x11, 0x9F, 0xE5, 0x10, 0x9E, 0x40, 
+0x0C, 0xE5, 0x11, 0x9F, 0xF5, 0x11, 0xE5, 0x10, 0x9E, 0xF5, 0x10, 0x80, 0x05, 0xE4, 0xF5, 0x10, 
+0xF5, 0x11, 0xE5, 0x0D, 0x12, 0xAE, 0xC0, 0xE5, 0x10, 0xF0, 0xA3, 0xE5, 0x11, 0xF0, 0x12, 0xAD, 
+0xC6, 0xF5, 0x83, 0xC3, 0x12, 0xBB, 0xD2, 0x50, 0x62, 0x12, 0xAE, 0xCC, 0x54, 0x7F, 0x12, 0x5C, 
+0x39, 0xFE, 0xD3, 0x9F, 0x40, 0x03, 0xEE, 0x80, 0x0A, 0x12, 0x5C, 0x3A, 0xFF, 0x12, 0xAE, 0xCC, 
+0x54, 0x7F, 0xC3, 0x9F, 0x90, 0xA4, 0x3D, 0xF0, 0x90, 0xA4, 0x3D, 0xE0, 0xD3, 0x94, 0x04, 0x40, 
+0x08, 0xD1, 0x8E, 0xE4, 0xF0, 0xA3, 0xF0, 0x80, 0x12, 0xD1, 0x8E, 0xE0, 0xFE, 0xA3, 0xE0, 0x4E, 
+0x60, 0x09, 0xD1, 0x8E, 0x74, 0xFF, 0xF5, 0xF0, 0x12, 0x46, 0xD6, 0x12, 0xAD, 0xC6, 0x12, 0x82, 
+0x11, 0xE5, 0x0D, 0x12, 0xAE, 0xC0, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0xD1, 0x8E, 0xE0, 0xFE, 0xA3, 
+0xE0, 0x4E, 0x70, 0x19, 0xAF, 0x0D, 0x12, 0xAB, 0xAC, 0x80, 0x12, 0xE5, 0x0F, 0x12, 0xBB, 0x28, 
+0xD3, 0x12, 0xBB, 0xD2, 0x40, 0x07, 0x7D, 0x01, 0xAF, 0x0D, 0x12, 0xAE, 0xD9, 0xE5, 0x0D, 0x12, 
+0xAE, 0xC0, 0xA3, 0xE0, 0x90, 0xA5, 0x53, 0xF0, 0x90, 0xA5, 0x52, 0xE5, 0x0E, 0xF0, 0xAB, 0x0D, 
+0xE4, 0xFD, 0xFF, 0x12, 0xB1, 0x18, 0xE4, 0xF5, 0x10, 0xF5, 0x11, 0xC1, 0x3E, 0xD1, 0x65, 0xE0, 
+0xFC, 0x64, 0x05, 0x60, 0x02, 0xA1, 0x44, 0xAD, 0x0F, 0xAF, 0x0D, 0x12, 0x77, 0x16, 0x12, 0xBB, 
+0x58, 0xEF, 0xD1, 0x99, 0xE0, 0x54, 0x07, 0xF5, 0x17, 0x12, 0x5C, 0x3A, 0xFF, 0xC3, 0x94, 0x30, 
+0x50, 0x06, 0xE4, 0xD1, 0x63, 0xE4, 0x80, 0x56, 0x12, 0xBB, 0x58, 0xE0, 0x64, 0x01, 0x70, 0x66, 
+0x12, 0xBA, 0x91, 0xE0, 0x64, 0x0A, 0x60, 0x28, 0xEF, 0x24, 0x05, 0xFF, 0xE4, 0x33, 0xFE, 0x12, 
+0xBB, 0x4C, 0xE0, 0xFD, 0x12, 0xBB, 0xC8, 0x50, 0x17, 0xED, 0x24, 0x05, 0xFF, 0xE4, 0x33, 0xFE, 
+0x12, 0x5C, 0x3A, 0x12, 0xBB, 0xC8, 0x50, 0x08, 0x12, 0x77, 0x97, 0xE0, 0x65, 0x0F, 0x60, 0x2A, 
+0xE5, 0x17, 0x70, 0x05, 0x75, 0x17, 0x01, 0x80, 0x0D, 0xE5, 0x17, 0xB4, 0x01, 0x05, 0x75, 0x17, 
+0x03, 0x80, 0x03, 0x75, 0x17, 0x05, 0x12, 0x5C, 0x3A, 0xFF, 0x12, 0xBB, 0x4C, 0xEF, 0xF0, 0x74, 
+0x21, 0x25, 0x0D, 0xF5, 0x82, 0xE4, 0x34, 0x9D, 0x80, 0x18, 0xD1, 0x65, 0xE4, 0xF0, 0x12, 0xBA, 
+0x91, 0xE0, 0x04, 0xF0, 0x80, 0x10, 0xE4, 0xF5, 0x17, 0x74, 0xA1, 0x25, 0x0D, 0xF5, 0x82, 0xE4, 
+0x34, 0x9E, 0xF5, 0x83, 0xE4, 0xF0, 0x12, 0x77, 0x97, 0xE5, 0x0F, 0xF0, 0x12, 0x4F, 0xA8, 0xC4, 
+0x13, 0x13, 0x54, 0x03, 0x20, 0xE0, 0x02, 0xC1, 0x2E, 0x12, 0xBA, 0x91, 0xE4, 0xF0, 0xD1, 0x63, 
+0xE4, 0xF0, 0xC1, 0x2E, 0xEC, 0x64, 0x06, 0x60, 0x02, 0xC1, 0x3E, 0xF5, 0x10, 0xF5, 0x11, 0xD1, 
+0x9A, 0xE0, 0x54, 0x07, 0xF5, 0x17, 0x12, 0xBB, 0xBE, 0x40, 0x05, 0x75, 0x15, 0x05, 0x80, 0x13, 
+0xD3, 0xE5, 0x13, 0x94, 0xFA, 0xE5, 0x12, 0x94, 0x00, 0x40, 0x05, 0x75, 0x15, 0x02, 0x80, 0x03, 
+0xE4, 0xF5, 0x15, 0x12, 0xBC, 0x76, 0x80, 0x05, 0xCE, 0xC3, 0x13, 0xCE, 0x13, 0xD8, 0xF9, 0xFF, 
+0x90, 0x44, 0x9E, 0xE4, 0x93, 0xFD, 0x7C, 0x00, 0x12, 0x26, 0x98, 0x90, 0xA4, 0x3E, 0xEE, 0xF0, 
+0xA3, 0xEF, 0xF0, 0xE4, 0xF5, 0x16, 0x12, 0xBB, 0xB4, 0xE5, 0x16, 0x12, 0xA7, 0x0A, 0x12, 0xBC, 
+0x2E, 0x08, 0x80, 0x05, 0xCE, 0xC3, 0x13, 0xCE, 0x13, 0xD8, 0xF9, 0xFF, 0xE5, 0x16, 0x90, 0x44, 
+0x99, 0x93, 0x12, 0xBA, 0xE6, 0xC3, 0x90, 0xA4, 0x3F, 0xE0, 0x95, 0x11, 0x90, 0xA4, 0x3E, 0xE0, 
+0x95, 0x10, 0x40, 0x07, 0x05, 0x16, 0xE5, 0x16, 0xB4, 0x05, 0xCB, 0xE5, 0x16, 0xC3, 0x13, 0xF5, 
+0x16, 0xE5, 0x17, 0x24, 0x01, 0xFF, 0xE4, 0x33, 0xA2, 0xE7, 0x13, 0xEF, 0x13, 0xFF, 0xD3, 0x95, 
+0x16, 0x40, 0x06, 0xEF, 0x95, 0x16, 0xFF, 0x80, 0x02, 0xE4, 0xFF, 0xD1, 0x71, 0xE0, 0xC3, 0x13, 
+0xFE, 0xEF, 0xC4, 0x33, 0x54, 0xE0, 0x2E, 0x04, 0xFE, 0xD1, 0x71, 0xEE, 0xF0, 0xD1, 0x71, 0xE0, 
+0xC3, 0x94, 0xC0, 0x40, 0x05, 0xD1, 0x71, 0x74, 0xC0, 0xF0, 0xD1, 0x71, 0x12, 0xBB, 0x7C, 0x25, 
+0xE0, 0xFF, 0x70, 0x04, 0xF5, 0x17, 0x80, 0x04, 0xEF, 0x14, 0xF5, 0x17, 0xD3, 0x90, 0xA4, 0x34, 
+0xE0, 0x94, 0x03, 0x90, 0xA4, 0x33, 0xE0, 0x94, 0x00, 0x40, 0x03, 0xE4, 0xF5, 0x17, 0xD1, 0x9A, 
+0xE0, 0x54, 0xF8, 0x90, 0xA4, 0x40, 0xF0, 0x45, 0x17, 0xFF, 0xD1, 0x99, 0xEF, 0xF0, 0xD1, 0x65, 
+0xE0, 0xD3, 0x94, 0x05, 0x50, 0x07, 0xD1, 0x65, 0xE0, 0x04, 0xF0, 0x80, 0x0A, 0xD1, 0x83, 0xE0, 
+0x54, 0xF8, 0xF0, 0xD1, 0x65, 0xE4, 0xF0, 0xE4, 0xFD, 0xAF, 0x0D, 0x12, 0x76, 0x61, 0x05, 0x0D, 
+0x01, 0x41, 0x22, 0xF5, 0x17, 0x74, 0xA1, 0x25, 0x0D, 0xF5, 0x82, 0xE4, 0x34, 0x9E, 0xF5, 0x83, 
+0x22, 0x74, 0x01, 0x25, 0x0D, 0xF5, 0x82, 0xE4, 0x34, 0x93, 0xF5, 0x83, 0x22, 0x90, 0x00, 0x08, 
+0x02, 0x47, 0x17, 0x75, 0xF0, 0x04, 0xE5, 0x0D, 0x90, 0x9B, 0x11, 0x02, 0x48, 0x65, 0x75, 0xF0, 
+0x04, 0xE5, 0x0D, 0x90, 0x9B, 0x12, 0x02, 0x48, 0x65, 0xF0, 0x75, 0xF0, 0x10, 0xE5, 0x0D, 0x90, 
+0x81, 0x01, 0x02, 0x48, 0x65, 0xE4, 0xF5, 0x20, 0x90, 0xA2, 0x81, 0xE0, 0xFF, 0xE5, 0x20, 0xC3, 
+0x9F, 0x40, 0x02, 0xE1, 0xCE, 0x90, 0x04, 0xCF, 0x74, 0x30, 0xF0, 0xAF, 0x20, 0x12, 0x64, 0xFB, 
+0xEF, 0x70, 0x02, 0xE1, 0xCA, 0xE5, 0x20, 0x13, 0x13, 0x13, 0x54, 0x1F, 0xF5, 0x21, 0xE5, 0x20, 
+0x54, 0x07, 0xF5, 0x22, 0x74, 0x81, 0x25, 0x21, 0x12, 0x76, 0x11, 0xE0, 0xFD, 0x12, 0xBC, 0x96, 
+0x80, 0x05, 0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 0xF9, 0xFF, 0xEF, 0x5D, 0x70, 0x02, 0xE1, 0xCA, 
+0x75, 0xF0, 0x10, 0xE5, 0x20, 0xD1, 0x9F, 0xE0, 0x20, 0xE7, 0x02, 0x80, 0x10, 0x75, 0xF0, 0x10, 
+0xE5, 0x20, 0x90, 0x81, 0x02, 0x12, 0x48, 0x65, 0xE0, 0xFF, 0x20, 0xE7, 0x09, 0x90, 0x01, 0xC1, 
+0xE0, 0x44, 0x20, 0xF0, 0xE1, 0xCA, 0x75, 0xF0, 0x04, 0xE5, 0x20, 0xD1, 0x88, 0xE0, 0x54, 0x07, 
+0x44, 0x50, 0xF0, 0xEF, 0x30, 0xE6, 0x35, 0xF1, 0xCF, 0x12, 0xBB, 0x83, 0x80, 0x02, 0xC3, 0x33, 
+0xD8, 0xFC, 0xF4, 0x5F, 0xF0, 0x75, 0xF0, 0x10, 0xE5, 0x20, 0xF1, 0xEF, 0xE0, 0xFD, 0x75, 0xF0, 
+0x04, 0xE5, 0x20, 0x12, 0x4F, 0xAD, 0xF1, 0xE2, 0xE4, 0xFB, 0xAF, 0x20, 0x12, 0x73, 0x7D, 0x75, 
+0xF0, 0x04, 0xE5, 0x20, 0xD1, 0x88, 0xE0, 0x54, 0xF8, 0xF0, 0x80, 0x6E, 0x12, 0xBA, 0xC9, 0xE0, 
+0x04, 0xF0, 0x12, 0xBA, 0xC9, 0xE0, 0xD3, 0x94, 0x01, 0x40, 0x45, 0xAF, 0x20, 0x12, 0xAD, 0xF9, 
+0x12, 0xBA, 0xC9, 0xE4, 0xF0, 0xF1, 0xCF, 0xE0, 0xFD, 0xFB, 0x7A, 0x00, 0x12, 0xBC, 0x96, 0x80, 
+0x05, 0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 0xF9, 0x12, 0x5F, 0xDD, 0x70, 0x13, 0xF1, 0xCF, 0xAF, 
+0x22, 0x74, 0x01, 0xA8, 0x07, 0x08, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0x4D, 0xF0, 0x80, 0x2A, 
+0xF1, 0xCF, 0x12, 0xBB, 0x83, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0xF4, 0x5F, 0xF0, 0x80, 0x1A, 
+0x75, 0xF0, 0x10, 0xE5, 0x20, 0xF1, 0xEF, 0xE0, 0xFD, 0x75, 0xF0, 0x04, 0xE5, 0x20, 0x12, 0x4F, 
+0xAD, 0xF1, 0xE2, 0x7B, 0x01, 0xAF, 0x20, 0x12, 0x73, 0x7D, 0x05, 0x20, 0xC1, 0xA8, 0x22, 0x74, 
+0x11, 0x25, 0x21, 0xF5, 0x82, 0xE4, 0x34, 0x9D, 0xF5, 0x83, 0x22, 0x12, 0x47, 0x17, 0x2F, 0xFF, 
+0xEE, 0x22, 0x13, 0x13, 0x54, 0x03, 0xF5, 0x27, 0x22, 0xF0, 0x75, 0xF0, 0x10, 0xE5, 0x0D, 0x90, 
+0x81, 0x00, 0x02, 0x48, 0x65, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0xA5, 0xC8, 0xEF, 
+0xF0, 0x75, 0xF0, 0x04, 0x12, 0x5F, 0xA6, 0x54, 0x1F, 0xFB, 0x60, 0x12, 0x64, 0x02, 0x60, 0x0E, 
+0xEB, 0x64, 0x04, 0x60, 0x09, 0xEB, 0x64, 0x09, 0x60, 0x04, 0xEB, 0xB4, 0x0C, 0x08, 0x12, 0x5E, 
+0xD2, 0x74, 0x02, 0xF0, 0x80, 0x06, 0x12, 0x5E, 0xD2, 0x74, 0x01, 0xF0, 0xE4, 0xF5, 0x6E, 0x90, 
+0xA5, 0xC8, 0xE0, 0xFD, 0x51, 0x44, 0x25, 0x6E, 0x51, 0x2A, 0xE0, 0xFE, 0xEB, 0x75, 0xF0, 0x07, 
+0xA4, 0x24, 0x5C, 0xF5, 0x82, 0xE4, 0x34, 0x40, 0xF5, 0x83, 0xE5, 0x82, 0x25, 0x6E, 0x51, 0x2A, 
+0xE4, 0x93, 0xFC, 0xEE, 0x5C, 0x90, 0xA5, 0xCB, 0xF0, 0x75, 0xF0, 0x04, 0xED, 0x12, 0x4F, 0xAD, 
+0x54, 0x03, 0xFF, 0xBF, 0x02, 0x0B, 0xE5, 0x6E, 0x70, 0x07, 0x90, 0xA5, 0xCB, 0xE0, 0x54, 0xF0, 
+0xF0, 0x90, 0xA5, 0xCB, 0xE0, 0xFF, 0x51, 0x40, 0x25, 0x6E, 0x51, 0x2A, 0xEF, 0xF0, 0x05, 0x6E, 
+0xE5, 0x6E, 0x64, 0x07, 0x70, 0xA9, 0x90, 0xA5, 0xC8, 0xE0, 0x75, 0xF0, 0x04, 0x12, 0x4F, 0xAD, 
+0xFF, 0xC4, 0x54, 0x03, 0xFD, 0xE4, 0x90, 0xA5, 0xC9, 0xF0, 0x75, 0x6F, 0x06, 0xE5, 0x6F, 0xB4, 
+0x06, 0x07, 0x51, 0x19, 0xE0, 0x54, 0x0F, 0x80, 0x07, 0x51, 0x40, 0x25, 0x6F, 0x51, 0x2A, 0xE0, 
+0x90, 0xA5, 0xCA, 0xF0, 0x90, 0xA5, 0xCA, 0xE0, 0x60, 0x30, 0x75, 0x6E, 0x07, 0xD1, 0x19, 0x80, 
+0x05, 0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 0xF9, 0xD1, 0x2A, 0x60, 0x15, 0xD1, 0x21, 0x90, 0xA5, 
+0xC9, 0xF0, 0xED, 0x60, 0x22, 0xE0, 0xD3, 0x94, 0x0B, 0x40, 0x1C, 0xE0, 0x24, 0x20, 0xF0, 0x80, 
+0x16, 0x15, 0x6E, 0xE5, 0x6E, 0xC3, 0x94, 0x00, 0x50, 0xD3, 0xE5, 0x6F, 0x60, 0x09, 0x15, 0x6F, 
+0xE5, 0x6F, 0xC3, 0x94, 0x00, 0x50, 0xA6, 0xE4, 0xFC, 0xF5, 0x6F, 0xE5, 0x6F, 0xB4, 0x06, 0x07, 
+0x51, 0x19, 0xE0, 0x54, 0x0F, 0x80, 0x07, 0x51, 0x40, 0x25, 0x6F, 0x51, 0x2A, 0xE0, 0x90, 0xA5, 
+0xCA, 0xF0, 0x90, 0xA5, 0xCA, 0xE0, 0x60, 0x2B, 0xE4, 0xF5, 0x6E, 0xD1, 0x19, 0x80, 0x05, 0xC3, 
+0x33, 0xCE, 0x33, 0xCE, 0xD8, 0xF9, 0xD1, 0x2A, 0x60, 0x12, 0xD1, 0x21, 0xFC, 0xED, 0x60, 0x1B, 
+0xEC, 0xD3, 0x94, 0x0B, 0x40, 0x15, 0x74, 0x20, 0x2C, 0xFC, 0x80, 0x0F, 0x05, 0x6E, 0xE5, 0x6E, 
+0xB4, 0x08, 0xD8, 0x05, 0x6F, 0xE5, 0x6F, 0x64, 0x07, 0x70, 0xB0, 0x90, 0xA5, 0xC9, 0xE0, 0xFF, 
+0x90, 0xA5, 0xC8, 0xE0, 0xFE, 0x75, 0xF0, 0x04, 0xD1, 0x41, 0xEF, 0xF0, 0x75, 0xF0, 0x04, 0xEE, 
+0x71, 0x73, 0xEC, 0xF0, 0x75, 0xF0, 0x10, 0xEE, 0x12, 0x6F, 0xEF, 0xE0, 0xFE, 0x54, 0x7F, 0xF5, 
+0x70, 0xEE, 0x54, 0x80, 0xFE, 0xE5, 0x70, 0xD3, 0x9F, 0x40, 0x09, 0x90, 0xA5, 0xC9, 0xE0, 0x4E, 
+0xF5, 0x70, 0x80, 0x0C, 0xE5, 0x70, 0xC3, 0x9C, 0x50, 0x06, 0xAF, 0x06, 0xEC, 0x4F, 0xF5, 0x70, 
+0x90, 0xA5, 0xC8, 0xE0, 0xFF, 0x24, 0x21, 0xF1, 0x9B, 0xE5, 0x70, 0xF0, 0x75, 0xF0, 0x04, 0xEF, 
+0x12, 0x4F, 0xAD, 0x12, 0x6F, 0xE2, 0x90, 0xA5, 0xC8, 0xE0, 0xFF, 0xE4, 0xFB, 0xAD, 0x70, 0x71, 
+0x7D, 0x90, 0xA5, 0xC8, 0xE0, 0xFF, 0x75, 0xF0, 0x10, 0xD1, 0xAD, 0xE4, 0xF0, 0x90, 0xA5, 0xC9, 
+0xE0, 0xFE, 0xC3, 0x94, 0x36, 0x40, 0x0A, 0x74, 0x91, 0x2F, 0x51, 0x38, 0x74, 0x05, 0xF0, 0x80, 
+0x43, 0xEE, 0xC3, 0x94, 0x2C, 0x40, 0x07, 0x51, 0x32, 0x74, 0x04, 0xF0, 0x80, 0x36, 0x90, 0xA5, 
+0xC9, 0xE0, 0xFF, 0xC3, 0x94, 0x14, 0x40, 0x07, 0x51, 0x32, 0x74, 0x03, 0xF0, 0x80, 0x25, 0xEF, 
+0xC3, 0x94, 0x0C, 0x40, 0x07, 0x51, 0x32, 0x74, 0x02, 0xF0, 0x80, 0x18, 0x90, 0xA5, 0xC9, 0xE0, 
+0xC3, 0x94, 0x04, 0x90, 0xA5, 0xC8, 0xE0, 0x40, 0x07, 0x51, 0x36, 0x74, 0x01, 0xF0, 0x80, 0x04, 
+0x51, 0x36, 0xE4, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xFF, 0x90, 0xA5, 0xC8, 0xE0, 0x75, 0xF0, 
+0x08, 0x90, 0x89, 0x00, 0x12, 0x48, 0x65, 0xE5, 0x82, 0x2F, 0xF5, 0x82, 0xE4, 0x35, 0x83, 0xF5, 
+0x83, 0x22, 0x90, 0xA5, 0xC8, 0xE0, 0x24, 0x91, 0xF5, 0x82, 0xE4, 0x34, 0x95, 0xF5, 0x83, 0x22, 
+0x90, 0xA5, 0xC8, 0xE0, 0x75, 0xF0, 0x08, 0x90, 0x89, 0x00, 0x12, 0x48, 0x65, 0xE5, 0x82, 0x22, 
+0xE4, 0xFF, 0xE4, 0xFE, 0x74, 0x91, 0x2F, 0x12, 0x5C, 0x23, 0xE0, 0x54, 0xFE, 0xF0, 0x75, 0xF0, 
+0x10, 0xEF, 0x90, 0x81, 0x00, 0xBE, 0x03, 0x0D, 0x12, 0x48, 0x65, 0xE5, 0x82, 0x2E, 0x51, 0x2A, 
+0x74, 0x80, 0xF0, 0x80, 0x0A, 0x12, 0x48, 0x65, 0xE5, 0x82, 0x2E, 0x51, 0x2A, 0xE4, 0xF0, 0x75, 
+0xF0, 0x08, 0xEF, 0x51, 0x47, 0x2E, 0x51, 0x2A, 0xE4, 0xF0, 0x0E, 0xBE, 0x10, 0xC6, 0x0F, 0xBF, 
+0x80, 0xC0, 0xE4, 0x90, 0xAF, 0x7D, 0xF0, 0xFF, 0xE4, 0xFE, 0x75, 0xF0, 0x0A, 0xEF, 0xF1, 0xBF, 
+0x75, 0xF0, 0x02, 0xEE, 0xF1, 0x7B, 0xF0, 0x0E, 0xBE, 0x05, 0xEF, 0x75, 0xF0, 0x04, 0xEF, 0x12, 
+0x6E, 0x88, 0xE0, 0x54, 0x07, 0xF0, 0x74, 0x21, 0x2F, 0xF1, 0x9B, 0x74, 0x3F, 0xF0, 0x74, 0x21, 
+0x2F, 0x12, 0xBA, 0x95, 0xE4, 0xF0, 0x74, 0x01, 0x2F, 0x12, 0x6E, 0x75, 0x74, 0xC0, 0xF0, 0x74, 
+0xF5, 0x2F, 0x12, 0x5E, 0xD8, 0xE4, 0xF1, 0xA3, 0xE4, 0xD1, 0x3C, 0x74, 0x3F, 0x71, 0x6E, 0xE4, 
+0xF0, 0x75, 0xF0, 0x04, 0xEF, 0x12, 0x5F, 0xA6, 0x54, 0xE0, 0x44, 0x09, 0xF0, 0x75, 0xF0, 0x04, 
+0xEF, 0x12, 0x4F, 0xAD, 0x54, 0xF3, 0xF0, 0x75, 0xF0, 0x04, 0xEF, 0x12, 0x4F, 0xAD, 0x54, 0xFC, 
+0xF0, 0x75, 0xF0, 0x04, 0xEF, 0x12, 0x5F, 0xA6, 0x44, 0x20, 0xF0, 0x75, 0xF0, 0x04, 0xEF, 0x12, 
+0x4F, 0xAD, 0x54, 0xCF, 0xF0, 0x75, 0xF0, 0x04, 0xEF, 0x12, 0x4F, 0xAD, 0x44, 0x40, 0xF0, 0x75, 
+0xF0, 0x04, 0xEF, 0x12, 0x4F, 0xAD, 0x54, 0x7F, 0x71, 0x6E, 0xE0, 0xFE, 0x75, 0xF0, 0x10, 0xEF, 
+0x12, 0x6F, 0xEF, 0xEE, 0xF0, 0x74, 0x91, 0x2F, 0x12, 0x5C, 0x23, 0xE4, 0xF0, 0x0F, 0xEF, 0x64, 
+0x80, 0x60, 0x02, 0x41, 0x98, 0x90, 0x04, 0x49, 0x74, 0xF0, 0xF0, 0xA3, 0xE4, 0xF0, 0xA3, 0x74, 
+0xFF, 0xF0, 0x90, 0x04, 0x33, 0x74, 0x02, 0xF0, 0xA3, 0x74, 0x04, 0xF0, 0xA3, 0x04, 0xF0, 0xA3, 
+0x04, 0xF0, 0xA3, 0x04, 0xF0, 0x74, 0x11, 0x2F, 0xF1, 0x84, 0x74, 0xFF, 0xF0, 0x22, 0xF0, 0x75, 
+0xF0, 0x04, 0xEF, 0x90, 0x96, 0x12, 0x02, 0x48, 0x65, 0xAD, 0x1A, 0xAF, 0x19, 0xD3, 0x10, 0xAF, 
+0x01, 0xC3, 0xC0, 0xD0, 0x8F, 0x24, 0x8D, 0x25, 0xE4, 0x90, 0xA5, 0x8D, 0xF0, 0xE5, 0x24, 0x13, 
+0x13, 0x13, 0x54, 0x1F, 0x90, 0xA5, 0x88, 0xF0, 0xE5, 0x24, 0x54, 0x07, 0x90, 0xA5, 0x8A, 0xF0, 
+0x75, 0xF0, 0x10, 0xEF, 0x12, 0x6E, 0x9F, 0xE0, 0x90, 0xA5, 0x8B, 0xD1, 0x3C, 0xE0, 0x54, 0x7F, 
+0x90, 0xA5, 0x8E, 0xF0, 0x75, 0xF0, 0x04, 0xE5, 0x24, 0x71, 0x73, 0xE0, 0x90, 0xA5, 0x8F, 0xF0, 
+0xD1, 0x33, 0xEB, 0x70, 0x2D, 0xE0, 0xFF, 0x25, 0xE0, 0x24, 0x3D, 0xF5, 0x82, 0xE4, 0x34, 0x43, 
+0x12, 0xA7, 0x87, 0xFD, 0xEF, 0x12, 0xAD, 0xC8, 0xF5, 0x83, 0x74, 0x01, 0x93, 0x2D, 0xFF, 0xE4, 
+0x93, 0x3C, 0xC3, 0x13, 0xFE, 0xEF, 0x13, 0xFF, 0xE5, 0x24, 0x12, 0xAE, 0xC0, 0xEE, 0xF0, 0xA3, 
+0xEF, 0xF0, 0x90, 0xA5, 0x8E, 0xE0, 0xFF, 0x90, 0xA5, 0x89, 0xE0, 0xFE, 0xD3, 0x9F, 0x40, 0x0B, 
+0xE5, 0x25, 0x54, 0x80, 0xFD, 0xEF, 0x4D, 0xF5, 0x25, 0x80, 0x0C, 0x90, 0xA5, 0x8F, 0xE0, 0xFF, 
+0xEE, 0xC3, 0x9F, 0x50, 0x02, 0x8F, 0x25, 0xD1, 0x33, 0xE5, 0x25, 0x54, 0x80, 0x90, 0xA5, 0x8C, 
+0xF0, 0xEB, 0x70, 0x2F, 0x90, 0x04, 0xCF, 0x74, 0x30, 0xF0, 0x90, 0xA5, 0x88, 0xE0, 0x24, 0x81, 
+0xD1, 0x11, 0xC0, 0x83, 0xC0, 0x82, 0xE0, 0xFF, 0x90, 0xA5, 0x8A, 0xD1, 0x09, 0x80, 0x02, 0xC3, 
+0x33, 0xD8, 0xFC, 0xF4, 0x5F, 0xD0, 0x82, 0xD0, 0x83, 0xF0, 0x90, 0xA5, 0x8B, 0xE0, 0x54, 0x7F, 
+0xF0, 0x80, 0x57, 0x74, 0x91, 0x25, 0x24, 0x12, 0x5C, 0x23, 0xE0, 0x90, 0x04, 0xCF, 0x30, 0xE0, 
+0x05, 0x74, 0x20, 0xF0, 0x80, 0x03, 0x74, 0x08, 0xF0, 0x90, 0xA5, 0x88, 0xE0, 0x24, 0x81, 0xD1, 
+0x11, 0xC0, 0x83, 0xC0, 0x82, 0xE0, 0xFF, 0x90, 0xA5, 0x8A, 0xD1, 0x09, 0x80, 0x02, 0xC3, 0x33, 
+0xD8, 0xFC, 0x4F, 0xD0, 0x82, 0xD0, 0x83, 0xF0, 0x75, 0xF0, 0x10, 0xE5, 0x24, 0x12, 0x6E, 0x9F, 
+0xE0, 0x54, 0x07, 0xFF, 0x90, 0xA5, 0x8B, 0xF0, 0x90, 0xA5, 0x89, 0xE0, 0x90, 0x43, 0xF1, 0x93, 
+0x12, 0xBC, 0x86, 0x90, 0xA5, 0x8B, 0xF0, 0x44, 0x80, 0xF0, 0x75, 0xF0, 0x10, 0xE5, 0x24, 0x12, 
+0x6F, 0xEF, 0xE5, 0x25, 0xF0, 0xE5, 0x24, 0x70, 0x06, 0x90, 0x01, 0xC8, 0xE5, 0x25, 0xF0, 0x90, 
+0xA5, 0x8B, 0xE0, 0xFF, 0x75, 0xF0, 0x10, 0xE5, 0x24, 0x12, 0x6E, 0x9F, 0xEF, 0xF0, 0x75, 0xF0, 
+0x10, 0xE5, 0x24, 0xD1, 0x4D, 0xE0, 0x54, 0xFC, 0xFF, 0xE5, 0x27, 0x12, 0xBC, 0x8E, 0xE5, 0x24, 
+0xD1, 0x4D, 0xEF, 0xF0, 0x7D, 0x01, 0xAF, 0x24, 0xD1, 0x61, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 
+0x01, 0xCC, 0xE0, 0x54, 0x0F, 0x90, 0xA5, 0xED, 0xF0, 0x90, 0xA5, 0xED, 0xE0, 0xFD, 0x70, 0x02, 
+0xA1, 0xF9, 0x90, 0xA1, 0xD4, 0xE0, 0xFF, 0x70, 0x06, 0xA3, 0xE0, 0x64, 0x09, 0x60, 0x0A, 0xEF, 
+0x14, 0xFF, 0x90, 0xA1, 0xD5, 0xE0, 0xB5, 0x07, 0x04, 0x7F, 0x01, 0x80, 0x02, 0x7F, 0x00, 0xEF, 
+0x60, 0x08, 0x90, 0x01, 0xC1, 0xE0, 0x44, 0x01, 0xF0, 0x22, 0x90, 0xA5, 0xEB, 0xE0, 0x12, 0x9C, 
+0xB0, 0x80, 0x05, 0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 0xF9, 0xFF, 0xEF, 0x5D, 0x70, 0x02, 0xA1, 
+0xDC, 0xE4, 0x90, 0xA5, 0xEE, 0xF0, 0x90, 0xA5, 0xEE, 0xE0, 0xF9, 0xC3, 0x94, 0x04, 0x50, 0x42, 
+0xB1, 0xFB, 0xA4, 0xFF, 0xE9, 0xFD, 0x7C, 0x00, 0x2F, 0xFF, 0xEC, 0x35, 0xF0, 0xFE, 0x74, 0xD0, 
+0xD1, 0x53, 0xE0, 0x12, 0xA3, 0x3A, 0xE5, 0x82, 0x29, 0x51, 0x2A, 0xEF, 0xB1, 0xFA, 0xA4, 0x2D, 
+0xFF, 0xEC, 0x35, 0xF0, 0xFE, 0x74, 0xF0, 0xD1, 0x53, 0xE0, 0x75, 0xF0, 0x08, 0x90, 0xA1, 0x88, 
+0x12, 0x48, 0x65, 0xE5, 0x82, 0x29, 0x51, 0x2A, 0xEF, 0xF0, 0x90, 0xA5, 0xEE, 0xE0, 0x04, 0xF0, 
+0x80, 0xB4, 0x90, 0xA5, 0xED, 0xE0, 0xFF, 0x90, 0xA5, 0xEB, 0xD1, 0x09, 0x80, 0x02, 0xC3, 0x33, 
+0xD8, 0xFC, 0xF4, 0x5F, 0x90, 0xA5, 0xED, 0xF0, 0x90, 0xA5, 0xEB, 0xE0, 0xFF, 0x74, 0x01, 0xA8, 
+0x07, 0x08, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0x90, 0x01, 0xCC, 0xF0, 0x90, 0xA5, 0xEB, 0xE0, 
+0x04, 0xF0, 0xE0, 0x54, 0x03, 0xF0, 0x90, 0xA1, 0xD5, 0xF1, 0xC5, 0xB4, 0x0A, 0x02, 0x7F, 0x01, 
+0xEF, 0x70, 0x02, 0x81, 0xF9, 0xE4, 0x90, 0xA1, 0xD5, 0xF0, 0x81, 0xF9, 0x90, 0x01, 0xC0, 0xE0, 
+0x44, 0x02, 0xF0, 0x90, 0xA5, 0xEB, 0xE0, 0x44, 0x80, 0x90, 0x00, 0x8A, 0xB1, 0xFA, 0x90, 0x01, 
+0xD0, 0x12, 0x48, 0x65, 0xE0, 0x90, 0x01, 0xC3, 0xF0, 0x22, 0xF0, 0x90, 0xA5, 0xEB, 0xE0, 0x75, 
+0xF0, 0x04, 0x22, 0x75, 0xF0, 0x03, 0x12, 0x48, 0x65, 0xE0, 0xFE, 0x74, 0x01, 0xA8, 0x06, 0x08, 
+0x22, 0xF5, 0x82, 0xE4, 0x34, 0x94, 0xF5, 0x83, 0x22, 0x74, 0x01, 0x7E, 0x00, 0xA8, 0x6E, 0x08, 
+0x22, 0xE5, 0x6F, 0x75, 0xF0, 0x08, 0xA4, 0x25, 0x6E, 0x22, 0xFF, 0x90, 0xA5, 0xCA, 0xE0, 0xFB, 
+0xEF, 0x5B, 0x22, 0xE5, 0x25, 0x54, 0x7F, 0x90, 0xA5, 0x89, 0xF0, 0x22, 0xF0, 0x75, 0xF0, 0x04, 
+0xEF, 0x90, 0x96, 0x11, 0x02, 0x48, 0x65, 0x8F, 0x13, 0x75, 0xF0, 0x10, 0xEF, 0x90, 0x81, 0x05, 
+0x02, 0x48, 0x65, 0x2F, 0xF5, 0x82, 0x74, 0x01, 0x3E, 0xF5, 0x83, 0xE0, 0xFF, 0x90, 0xA1, 0xD5, 
+0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0xED, 0x60, 0x21, 0x75, 0xF0, 0x0A, 0xEF, 0x90, 
+0x8D, 0x01, 0xD1, 0x9D, 0x90, 0x8D, 0x03, 0xD1, 0x9D, 0x90, 0x8D, 0x05, 0xD1, 0x9D, 0x90, 0x8D, 
+0x07, 0xD1, 0x9D, 0x90, 0x8D, 0x09, 0xF1, 0x7B, 0xF1, 0xA3, 0xE4, 0xF0, 0xD1, 0xA9, 0xE0, 0x54, 
+0xBF, 0x44, 0x80, 0xFE, 0xD1, 0xA9, 0xEE, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x12, 0x48, 0x65, 
+0xE4, 0xF0, 0xA3, 0xF0, 0x75, 0xF0, 0x0A, 0xEF, 0x22, 0x75, 0xF0, 0x10, 0xEF, 0x90, 0x81, 0x03, 
+0x02, 0x48, 0x65, 0x8F, 0x0E, 0x8D, 0x0F, 0x8B, 0x10, 0x75, 0xF0, 0x04, 0xEF, 0x12, 0x4F, 0xAD, 
+0xC4, 0x54, 0x03, 0x90, 0xA4, 0x36, 0xF0, 0x90, 0xA4, 0x34, 0x60, 0x09, 0x74, 0x32, 0xF0, 0xA3, 
+0x74, 0x2F, 0xF0, 0x80, 0x07, 0x74, 0x11, 0xF0, 0xA3, 0x74, 0x0F, 0xF0, 0xE5, 0x0F, 0xD3, 0x94, 
+0x2D, 0x40, 0x09, 0x75, 0xF0, 0x04, 0xE5, 0x0E, 0xD1, 0x41, 0x80, 0x1F, 0xE5, 0x0F, 0xD3, 0x94, 
+0x1E, 0x40, 0x05, 0x90, 0xA4, 0x34, 0x80, 0x13, 0xE5, 0x0F, 0xD3, 0x94, 0x14, 0x40, 0x05, 0x90, 
+0xA4, 0x35, 0x80, 0x07, 0x75, 0xF0, 0x04, 0xE5, 0x0E, 0x71, 0x73, 0xE0, 0xFD, 0x85, 0x10, 0x27, 
+0xE4, 0xFB, 0xAF, 0x0E, 0x61, 0x7D, 0xE4, 0xF5, 0x19, 0x74, 0x91, 0x2F, 0x51, 0x38, 0xE0, 0xFE, 
+0xB4, 0x05, 0x08, 0xED, 0xC3, 0x94, 0x3B, 0x40, 0x4F, 0x80, 0x45, 0xEE, 0xB4, 0x04, 0x08, 0xED, 
+0xC3, 0x94, 0x31, 0x40, 0x43, 0x80, 0x39, 0x74, 0x91, 0x2F, 0x51, 0x38, 0xE0, 0xFE, 0xB4, 0x03, 
+0x08, 0xED, 0xC3, 0x94, 0x19, 0x40, 0x31, 0x80, 0x27, 0xEE, 0xB4, 0x02, 0x08, 0xED, 0xC3, 0x94, 
+0x11, 0x40, 0x25, 0x80, 0x1B, 0x74, 0x91, 0x2F, 0x51, 0x38, 0xE0, 0xFE, 0xB4, 0x01, 0x08, 0xED, 
+0xC3, 0x94, 0x0A, 0x40, 0x13, 0x80, 0x09, 0xEE, 0x70, 0x0B, 0xED, 0xC3, 0x94, 0x03, 0x40, 0x08, 
+0x75, 0x19, 0x01, 0x80, 0x03, 0xE4, 0xF5, 0x19, 0xAF, 0x19, 0x22, 0x12, 0x48, 0x65, 0xE4, 0xF0, 
+0xA3, 0x22, 0x24, 0x11, 0xF5, 0x82, 0xE4, 0x34, 0x99, 0xF5, 0x83, 0x22, 0xD1, 0x47, 0xE0, 0x54, 
+0xFB, 0x12, 0xBB, 0x64, 0x02, 0x27, 0x48, 0x74, 0x21, 0x25, 0x0D, 0xF5, 0x82, 0xE4, 0x34, 0x9F, 
+0xF5, 0x83, 0x22, 0xF0, 0xEF, 0x25, 0xE0, 0x24, 0x01, 0xF5, 0x82, 0xE4, 0x34, 0x92, 0xF5, 0x83, 
+0xE4, 0xF0, 0xA3, 0xF0, 0x74, 0x91, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x98, 0xF5, 0x83, 0x22, 0x90, 
+0x8D, 0x01, 0x02, 0x48, 0x65, 0xE0, 0x04, 0xF0, 0xE0, 0x7F, 0x00, 0x22, 0xD1, 0x47, 0xE0, 0x44, 
+0x04, 0xF0, 0x22, 0x91, 0xEF, 0x7F, 0x02, 0x8F, 0x73, 0x7F, 0x02, 0x12, 0x4B, 0x3C, 0x90, 0xA1, 
+0x76, 0xE0, 0x45, 0x73, 0xF0, 0x22, 0xD1, 0xA9, 0xE0, 0x44, 0x40, 0xF0, 0x22, 0x90, 0xA3, 0x3C, 
+0xE0, 0xC3, 0x13, 0x54, 0x07, 0xFF, 0x75, 0xF0, 0x0E, 0x90, 0xA3, 0x49, 0x12, 0x48, 0x65, 0xE0, 
+0xFE, 0x75, 0xF0, 0x0E, 0xEF, 0x90, 0xA3, 0x48, 0x12, 0x48, 0x65, 0xE0, 0x90, 0xA5, 0x9C, 0xF0, 
+0x90, 0xA5, 0x9B, 0xEE, 0xF0, 0xE4, 0xFB, 0xFD, 0x7F, 0x54, 0x7E, 0x01, 0xD3, 0x10, 0xAF, 0x01, 
+0xC3, 0xC0, 0xD0, 0x90, 0xA5, 0x97, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0xA5, 0x9B, 0xE0, 0xF5, 
+0x3B, 0xA3, 0xE0, 0xF5, 0x3C, 0x12, 0x34, 0x8C, 0x90, 0xA5, 0x97, 0xF1, 0x67, 0xA3, 0xA3, 0xA3, 
+0x74, 0x05, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xF1, 0x7A, 0x30, 0xE0, 0x05, 0x90, 0x01, 0x5B, 
+0xE4, 0xF0, 0x90, 0x06, 0x92, 0x74, 0x02, 0xF0, 0x90, 0x01, 0x3C, 0x74, 0x04, 0xF0, 0xE4, 0x90, 
+0xA5, 0x9B, 0xF0, 0x90, 0xA3, 0x36, 0xE0, 0xC3, 0x13, 0x54, 0x7F, 0x90, 0xA5, 0x9C, 0xF0, 0xE4, 
+0xFB, 0xFD, 0x7F, 0x58, 0x7E, 0x01, 0x11, 0x1C, 0x90, 0xA2, 0x88, 0xE0, 0x44, 0x08, 0xF0, 0x22, 
+0xE4, 0xF5, 0x20, 0x90, 0x06, 0xA9, 0xE0, 0xF5, 0x20, 0x54, 0xC0, 0x70, 0x08, 0x11, 0xC6, 0x54, 
+0xFD, 0xF0, 0x02, 0x60, 0x3D, 0xE5, 0x20, 0x30, 0xE6, 0x17, 0x90, 0xA2, 0x8C, 0xE0, 0x64, 0x01, 
+0x70, 0x11, 0x31, 0x39, 0x64, 0x02, 0x60, 0x04, 0x31, 0x92, 0x80, 0x07, 0x12, 0x57, 0x8F, 0x80, 
+0x02, 0x11, 0xC6, 0xE5, 0x20, 0x90, 0xA2, 0x90, 0x30, 0xE7, 0x06, 0x31, 0x4F, 0x11, 0x14, 0x21, 
+0x47, 0xE0, 0x54, 0xFD, 0xF0, 0x22, 0x90, 0xA2, 0x90, 0xE0, 0x54, 0xFE, 0xF0, 0x22, 0x90, 0x06, 
+0xA9, 0xE0, 0x90, 0xA4, 0xFA, 0xF0, 0xE0, 0xFD, 0x54, 0xC0, 0x70, 0x04, 0x11, 0xC6, 0x80, 0x55, 
+0xED, 0x30, 0xE6, 0x3E, 0x90, 0xA2, 0x8C, 0xE0, 0x64, 0x02, 0x70, 0x27, 0x90, 0xA2, 0x88, 0xE0, 
+0xFF, 0xC3, 0x13, 0x20, 0xE0, 0x09, 0x90, 0xA2, 0x90, 0xE0, 0x44, 0x01, 0xF0, 0x80, 0x1A, 0x31, 
+0x40, 0x64, 0x01, 0x70, 0x1F, 0x90, 0xA2, 0x90, 0xE0, 0x44, 0x04, 0xF0, 0x7F, 0x01, 0x12, 0x57, 
+0x01, 0x80, 0x11, 0x31, 0x39, 0x64, 0x02, 0x60, 0x04, 0x31, 0x92, 0x80, 0x07, 0x12, 0x57, 0x8F, 
+0x80, 0x02, 0x11, 0xC6, 0x90, 0xA4, 0xFA, 0xE0, 0x90, 0xA2, 0x90, 0x30, 0xE7, 0x06, 0x31, 0x4F, 
+0x11, 0x14, 0x80, 0x13, 0xE0, 0x54, 0xFD, 0xF0, 0x22, 0x90, 0xA2, 0x90, 0xE0, 0x44, 0x01, 0xF0, 
+0x90, 0xA2, 0x8A, 0xE0, 0x54, 0x0F, 0x22, 0x90, 0xA2, 0x88, 0xE0, 0x44, 0x04, 0xF0, 0x22, 0xE0, 
+0x44, 0x02, 0xF0, 0xE4, 0x90, 0xA5, 0x9B, 0xF0, 0x90, 0xA3, 0x35, 0xE0, 0x90, 0xA5, 0x9C, 0x22, 
+0x90, 0xA2, 0x8C, 0xE0, 0x64, 0x02, 0x60, 0x0F, 0x31, 0x40, 0x60, 0x0B, 0xF1, 0xBE, 0xEF, 0x70, 
+0x06, 0xFD, 0x7F, 0x0C, 0x12, 0x51, 0xE9, 0x22, 0xE4, 0xFF, 0x12, 0x64, 0xFB, 0xBF, 0x01, 0x11, 
+0x90, 0xA2, 0x8C, 0xE0, 0x60, 0x0B, 0x31, 0x40, 0x64, 0x02, 0x60, 0x02, 0x80, 0x04, 0x12, 0x57, 
+0x8F, 0x22, 0x90, 0x04, 0x1D, 0xE0, 0x70, 0x1A, 0x90, 0xA1, 0x7E, 0xE0, 0xFF, 0x7B, 0x18, 0xE4, 
+0xFD, 0x12, 0x59, 0x68, 0x90, 0xA5, 0xF9, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0x04, 0x1F, 0x74, 
+0x20, 0xF0, 0x22, 0x12, 0x63, 0x15, 0x54, 0x03, 0x30, 0xE0, 0x0B, 0x31, 0xCD, 0x60, 0x07, 0x7D, 
+0x01, 0x7F, 0x02, 0x12, 0x51, 0xE9, 0x31, 0xCD, 0x60, 0x02, 0x31, 0x60, 0x22, 0x90, 0xA2, 0x87, 
+0xE0, 0x64, 0x02, 0x22, 0x90, 0xA2, 0x83, 0xE0, 0xFF, 0x30, 0xE0, 0x3D, 0x90, 0xA2, 0x87, 0xE0, 
+0x7E, 0x00, 0xB4, 0x02, 0x02, 0x7E, 0x01, 0x90, 0xA2, 0x86, 0xE0, 0x7D, 0x00, 0xB4, 0x04, 0x02, 
+0x7D, 0x01, 0xED, 0x4E, 0x70, 0x23, 0xEF, 0xC3, 0x13, 0x30, 0xE0, 0x02, 0xC1, 0xFA, 0x31, 0xB3, 
+0x90, 0xA2, 0x87, 0xE0, 0xB4, 0x08, 0x06, 0xE4, 0xFD, 0x7F, 0x0C, 0x80, 0x09, 0x90, 0xA2, 0x87, 
+0xE0, 0x70, 0x06, 0xFD, 0x7F, 0x04, 0x12, 0x51, 0xE9, 0x22, 0xF1, 0x8F, 0x54, 0x7F, 0x90, 0xA2, 
+0x8C, 0xF0, 0xEF, 0x51, 0xF5, 0xA3, 0x12, 0x4F, 0xBC, 0xFF, 0x54, 0xF0, 0xC4, 0x54, 0x0F, 0xFE, 
+0x90, 0xA2, 0x8A, 0xE0, 0x54, 0xF0, 0x4E, 0xF0, 0x12, 0x5C, 0x33, 0x54, 0x01, 0x25, 0xE0, 0xFE, 
+0x90, 0xA2, 0x88, 0xE0, 0x54, 0xFD, 0x4E, 0xF0, 0xEF, 0x54, 0x0F, 0xC4, 0x54, 0xF0, 0xFF, 0x31, 
+0x40, 0x12, 0x4F, 0xB4, 0x90, 0xA2, 0x8B, 0xF0, 0x90, 0x00, 0x06, 0x12, 0x26, 0x37, 0x30, 0xE0, 
+0x57, 0xC3, 0x13, 0x54, 0x07, 0xFF, 0xC3, 0x94, 0x04, 0x90, 0xA2, 0x9F, 0x50, 0x04, 0xEF, 0xF0, 
+0x80, 0x2A, 0x74, 0x03, 0x12, 0x4F, 0xC3, 0xE9, 0x24, 0x06, 0xF9, 0xE4, 0x3A, 0xFA, 0x12, 0x26, 
+0x1E, 0xFF, 0x74, 0x03, 0x24, 0xFD, 0xFE, 0xEF, 0xC4, 0x54, 0x0F, 0xFD, 0xEF, 0x54, 0x0F, 0xFF, 
+0xED, 0x2E, 0x54, 0x0F, 0xFE, 0xC4, 0x54, 0xF0, 0x4F, 0x12, 0x26, 0x64, 0x12, 0x4F, 0xC4, 0x90, 
+0x00, 0x06, 0x12, 0x26, 0x37, 0xC4, 0x54, 0x0F, 0xFF, 0xC3, 0x94, 0x04, 0x90, 0xA2, 0x94, 0x50, 
+0x05, 0x74, 0x04, 0xF0, 0x80, 0x02, 0xEF, 0xF0, 0x12, 0x4F, 0xC4, 0x12, 0x5F, 0xB2, 0xFD, 0x7F, 
+0x02, 0x12, 0x51, 0x55, 0x12, 0x4F, 0xC4, 0x90, 0xA4, 0x34, 0x12, 0x48, 0x7A, 0x12, 0x65, 0x5D, 
+0x90, 0xA2, 0x8C, 0xE0, 0xFF, 0x12, 0x65, 0x1B, 0x90, 0xA2, 0x8C, 0xE0, 0x60, 0x13, 0x90, 0xA4, 
+0x34, 0x12, 0x48, 0x71, 0x12, 0x4F, 0xBD, 0x54, 0x0F, 0xFF, 0x12, 0x4F, 0xB6, 0xFD, 0x12, 0xB8, 
+0xC6, 0x22, 0xEF, 0x54, 0x80, 0xC4, 0x13, 0x13, 0x13, 0x54, 0x01, 0x22, 0x90, 0xA2, 0x88, 0xE0, 
+0xFF, 0x51, 0xF5, 0x30, 0xE0, 0x1B, 0xEF, 0x54, 0x7F, 0x91, 0x59, 0x30, 0xE1, 0x06, 0xE0, 0x44, 
+0x02, 0xF0, 0x80, 0x04, 0xE0, 0x54, 0xFD, 0xF0, 0x90, 0xA2, 0x8C, 0xE0, 0x60, 0x03, 0x12, 0x60, 
+0x3D, 0x90, 0x04, 0xE0, 0xE0, 0x30, 0xE1, 0x02, 0x71, 0x2B, 0x22, 0x90, 0xA3, 0x3C, 0xE0, 0x30, 
+0xE0, 0x24, 0xC3, 0x13, 0x54, 0x07, 0x71, 0x57, 0xE0, 0xFE, 0x30, 0xE0, 0x19, 0x75, 0xF0, 0x0E, 
+0xEF, 0x71, 0x5B, 0xEE, 0x54, 0xFE, 0xF0, 0x90, 0xA3, 0x3E, 0x74, 0x05, 0xF0, 0x12, 0x56, 0x04, 
+0xFD, 0x7F, 0x01, 0x12, 0x54, 0x7F, 0x22, 0xFF, 0x75, 0xF0, 0x0E, 0x90, 0xA3, 0x47, 0x02, 0x48, 
+0x65, 0xC0, 0xE0, 0xC0, 0xF0, 0xC0, 0x83, 0xC0, 0x82, 0xC0, 0xD0, 0x75, 0xD0, 0x00, 0xC0, 0x00, 
+0xC0, 0x01, 0xC0, 0x02, 0xC0, 0x03, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0x01, 
+0xC4, 0x74, 0x61, 0xF0, 0x74, 0x7B, 0xA3, 0xF0, 0x12, 0xA8, 0xD8, 0xE5, 0x69, 0x30, 0xE1, 0x02, 
+0xF1, 0x9A, 0xE5, 0x69, 0x30, 0xE2, 0x02, 0x91, 0x1C, 0xE5, 0x69, 0x30, 0xE3, 0x03, 0x12, 0x5F, 
+0xB0, 0xE5, 0x69, 0x30, 0xE5, 0x02, 0x91, 0x09, 0xE5, 0x6A, 0x30, 0xE0, 0x02, 0x91, 0x62, 0xE5, 
+0x6B, 0x30, 0xE1, 0x02, 0xD1, 0xB2, 0xE5, 0x6B, 0x30, 0xE0, 0x02, 0x31, 0xD4, 0xE5, 0x6B, 0x30, 
+0xE3, 0x02, 0xF1, 0x5F, 0xE5, 0x6C, 0x30, 0xE1, 0x05, 0x7F, 0x04, 0x12, 0x77, 0xD7, 0xE5, 0x6C, 
+0x30, 0xE4, 0x02, 0xF1, 0x70, 0xE5, 0x6C, 0x30, 0xE5, 0x02, 0x91, 0x36, 0xE5, 0x6C, 0x30, 0xE6, 
+0x02, 0x51, 0xFC, 0x74, 0x61, 0x04, 0x90, 0x01, 0xC4, 0xF0, 0x74, 0x7B, 0xA3, 0xF0, 0xD0, 0x07, 
+0xD0, 0x06, 0xD0, 0x05, 0xD0, 0x04, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0xD0, 0xD0, 
+0xD0, 0x82, 0xD0, 0x83, 0xD0, 0xF0, 0xD0, 0xE0, 0x32, 0x90, 0xA3, 0x3C, 0xE0, 0x30, 0xE0, 0x0B, 
+0x12, 0x65, 0x52, 0xE4, 0x90, 0xA3, 0x3E, 0xF0, 0x12, 0x77, 0xED, 0x22, 0x90, 0xA2, 0x8C, 0xE0, 
+0x60, 0x13, 0x90, 0x06, 0x92, 0xE0, 0x30, 0xE1, 0x02, 0x01, 0x48, 0x90, 0xA2, 0x88, 0xE0, 0x54, 
+0xF7, 0xF0, 0x12, 0x60, 0x3D, 0x22, 0x90, 0xA2, 0x88, 0xE0, 0xFF, 0xC4, 0x13, 0x13, 0x54, 0x03, 
+0x30, 0xE0, 0x15, 0xEF, 0x54, 0xBF, 0x91, 0x59, 0x30, 0xE0, 0x06, 0xE0, 0x44, 0x01, 0xF0, 0x80, 
+0x04, 0xE0, 0x54, 0xFE, 0xF0, 0x12, 0x60, 0x3D, 0x22, 0xF0, 0x90, 0x04, 0xE0, 0xE0, 0x90, 0xA2, 
+0x89, 0x22, 0x12, 0xA9, 0xC6, 0x90, 0xA5, 0x08, 0xEF, 0xF0, 0x30, 0xE0, 0x05, 0x7D, 0x01, 0xE4, 
+0x80, 0x02, 0xE4, 0xFD, 0xFF, 0x12, 0x51, 0x55, 0x90, 0xA5, 0x08, 0xE0, 0x30, 0xE6, 0x11, 0x90, 
+0x01, 0x2F, 0xE0, 0x30, 0xE7, 0x04, 0xE4, 0xF0, 0x80, 0x06, 0x90, 0x01, 0x2F, 0x74, 0x80, 0xF0, 
+0xB1, 0x2E, 0x90, 0xA2, 0xA5, 0xE0, 0xFB, 0xAC, 0x07, 0x90, 0xA2, 0x88, 0xE0, 0x30, 0xE0, 0x16, 
+0x90, 0xA2, 0xC2, 0xE0, 0x24, 0x04, 0x90, 0xA2, 0xA1, 0xF0, 0x90, 0xA2, 0xC2, 0xE0, 0x24, 0x03, 
+0x90, 0xA2, 0xA0, 0xF0, 0x80, 0x0B, 0x90, 0xA2, 0xA1, 0x74, 0x02, 0xF0, 0x90, 0xA2, 0xA0, 0x14, 
+0xF0, 0x90, 0xA2, 0xA0, 0xE0, 0xFA, 0x90, 0xA2, 0x9F, 0xE0, 0xD3, 0x9A, 0x50, 0x09, 0x90, 0xA2, 
+0x94, 0xEB, 0xB1, 0x02, 0x2C, 0x80, 0x0B, 0xAD, 0x02, 0xC3, 0xED, 0x9D, 0x2B, 0x90, 0xA2, 0x94, 
+0xB1, 0x02, 0x90, 0xA2, 0xA4, 0xF0, 0x90, 0xA2, 0xA4, 0xE0, 0xFF, 0x7E, 0x00, 0x90, 0xA2, 0x98, 
+0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0x05, 0x58, 0xE0, 0x6F, 0x70, 0x01, 0xE4, 0x60, 0x02, 0xF1, 
+0x85, 0x22, 0xF0, 0x90, 0xA2, 0xA1, 0xE0, 0xC3, 0x9D, 0x22, 0x12, 0xBA, 0x45, 0x40, 0x1E, 0x90, 
+0xA2, 0xA6, 0xE0, 0x04, 0xF0, 0xE0, 0xFF, 0x94, 0x04, 0x50, 0x12, 0x90, 0xA2, 0x9E, 0xEF, 0xF0, 
+0x25, 0xE0, 0x24, 0x08, 0x90, 0xA2, 0xA5, 0xF0, 0xFB, 0xB1, 0x2E, 0x91, 0x97, 0x22, 0x90, 0xA2, 
+0x9E, 0xE0, 0xFF, 0xA3, 0xE0, 0xFD, 0x22, 0xE4, 0x90, 0xA4, 0xFA, 0xF0, 0xA3, 0xF0, 0xA3, 0x12, 
+0x66, 0xE5, 0x12, 0x47, 0x77, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0x05, 0x62, 
+0x12, 0x66, 0xFF, 0x78, 0x10, 0x12, 0x27, 0x35, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 
+0x12, 0x47, 0x77, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0xA3, 0x12, 0x66, 0xFF, 0x78, 
+0x18, 0x12, 0x27, 0x35, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0x12, 0x47, 0x77, 0x90, 
+0xA2, 0xC5, 0x12, 0x27, 0x48, 0x90, 0xA2, 0xC9, 0x12, 0x48, 0x4D, 0x90, 0xA2, 0xC5, 0x12, 0x48, 
+0x59, 0xC3, 0x12, 0x47, 0x9A, 0x40, 0x3B, 0x90, 0xA2, 0x88, 0xE0, 0x90, 0xA2, 0xC9, 0x30, 0xE0, 
+0x0C, 0xD1, 0x99, 0xFF, 0x90, 0xA2, 0xC2, 0xE0, 0x2F, 0x24, 0x0C, 0x80, 0x04, 0xD1, 0x99, 0x24, 
+0x08, 0x90, 0xA4, 0xFB, 0xF0, 0x90, 0xA4, 0xFB, 0xE0, 0xFF, 0xC3, 0x94, 0x19, 0x50, 0x13, 0x74, 
+0xA9, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0xA2, 0xF5, 0x83, 0xE0, 0x04, 0xF0, 0x90, 0xA2, 0xA2, 0xE0, 
+0x04, 0xF0, 0x90, 0xA2, 0xA2, 0xE0, 0xC3, 0x94, 0x64, 0x50, 0x02, 0xC1, 0x68, 0xD1, 0x7A, 0xD1, 
+0x71, 0x50, 0x18, 0xD1, 0x84, 0x94, 0x05, 0x40, 0x0A, 0x90, 0xA4, 0xFA, 0xE0, 0x90, 0xA4, 0xFD, 
+0xF0, 0x80, 0x08, 0x90, 0xA4, 0xFA, 0xE0, 0x04, 0xF0, 0x80, 0xE4, 0xD1, 0x7A, 0xD1, 0x71, 0x50, 
+0x18, 0xD1, 0x84, 0x94, 0x5F, 0x40, 0x0A, 0x90, 0xA4, 0xFA, 0xE0, 0x90, 0xA4, 0xFE, 0xF0, 0x80, 
+0x08, 0x90, 0xA4, 0xFA, 0xE0, 0x04, 0xF0, 0x80, 0xE4, 0x90, 0xA4, 0xFD, 0xE0, 0x90, 0xA2, 0xA7, 
+0xF0, 0x90, 0xA4, 0xFE, 0xE0, 0x90, 0xA2, 0xA8, 0xD1, 0x69, 0x94, 0x0A, 0x40, 0x0A, 0xEF, 0x24, 
+0xF6, 0x90, 0xA2, 0x9F, 0xF0, 0xE4, 0x80, 0x09, 0xE4, 0x90, 0xA2, 0x9F, 0xD1, 0x69, 0x74, 0x0A, 
+0x9F, 0x90, 0xA2, 0x9E, 0xF0, 0x90, 0xA2, 0xA7, 0xE0, 0xFF, 0xA3, 0xE0, 0xC3, 0x9F, 0x90, 0xA2, 
+0xA5, 0xF0, 0xC3, 0x94, 0x08, 0x50, 0x03, 0x74, 0x08, 0xF0, 0xB1, 0x2E, 0x90, 0xA2, 0xA5, 0xE0, 
+0xFB, 0x91, 0x97, 0xE4, 0xFF, 0x12, 0xB9, 0x4D, 0x22, 0xF0, 0x90, 0xA2, 0xA7, 0xE0, 0xFF, 0xC3, 
+0x22, 0x90, 0xA4, 0xFA, 0xE0, 0xFF, 0xC3, 0x94, 0x19, 0x22, 0xE4, 0x90, 0xA4, 0xFC, 0xF0, 0x90, 
+0xA4, 0xFA, 0xF0, 0x22, 0x74, 0xA9, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0xA2, 0xF5, 0x83, 0xE0, 0xFF, 
+0x90, 0xA4, 0xFC, 0xE0, 0x2F, 0xF0, 0xE0, 0xD3, 0x22, 0x12, 0x48, 0x59, 0x90, 0xA2, 0xC5, 0x12, 
+0x48, 0x4D, 0x12, 0x47, 0x5C, 0x78, 0x0A, 0x12, 0x27, 0x22, 0x90, 0xA2, 0xA4, 0xE0, 0xF4, 0x04, 
+0x2F, 0x22, 0x90, 0xA2, 0x83, 0xE0, 0xFF, 0x30, 0xE0, 0x3F, 0x90, 0xA2, 0x87, 0xE0, 0x7E, 0x00, 
+0xB4, 0x02, 0x02, 0x7E, 0x01, 0x90, 0xA2, 0x86, 0xE0, 0x7D, 0x00, 0xB4, 0x04, 0x02, 0x7D, 0x01, 
+0xED, 0x4E, 0x70, 0x25, 0xEF, 0xC3, 0x13, 0x30, 0xE0, 0x02, 0x80, 0x1E, 0x12, 0x67, 0x64, 0x90, 
+0xA2, 0x87, 0xE0, 0xB4, 0x0C, 0x06, 0xE4, 0xFD, 0x7F, 0x08, 0x80, 0x0A, 0x90, 0xA2, 0x87, 0xE0, 
+0xB4, 0x04, 0x06, 0xE4, 0xFD, 0xFF, 0x12, 0x51, 0xE9, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 
+0xD0, 0x90, 0xA2, 0x82, 0xE0, 0xB4, 0x01, 0x04, 0x7F, 0x04, 0x80, 0x0C, 0x12, 0x63, 0x32, 0xBF, 
+0x01, 0x04, 0x7F, 0x01, 0x80, 0x02, 0x7F, 0x02, 0x12, 0x61, 0xEA, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 
+0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0xF1, 0x60, 0x12, 0x26, 0x1E, 0xFF, 0x90, 0xA2, 0x82, 
+0xF0, 0xBF, 0x01, 0x09, 0x12, 0x4F, 0xBD, 0x64, 0x01, 0x60, 0x1F, 0x80, 0x1B, 0xAB, 0x0D, 0xAA, 
+0x0E, 0xA9, 0x0F, 0x12, 0x4F, 0xBD, 0x64, 0x01, 0x60, 0x10, 0x90, 0xA2, 0x83, 0xE0, 0x20, 0xE0, 
+0x07, 0xE4, 0xFF, 0x12, 0x61, 0xEA, 0x80, 0x02, 0xD1, 0xFA, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x22, 
+0x8B, 0x0D, 0x8A, 0x0E, 0x89, 0x0F, 0x22, 0xE0, 0xFE, 0xA3, 0xE0, 0xF5, 0x82, 0x8E, 0x83, 0x22, 
+0x12, 0x65, 0x7E, 0x7D, 0x02, 0x7F, 0x02, 0x02, 0x63, 0x6F, 0x90, 0xA2, 0x88, 0xE0, 0x13, 0x13, 
+0x13, 0x54, 0x1F, 0x22, 0xF0, 0x90, 0xA2, 0x98, 0xA3, 0xE0, 0x90, 0x05, 0x58, 0xF0, 0x22, 0x90, 
+0xA4, 0x31, 0x12, 0x48, 0x7A, 0x12, 0x26, 0x1E, 0xFF, 0x22, 0x90, 0xA2, 0x8C, 0xE0, 0x60, 0x03, 
+0x12, 0x64, 0x59, 0x02, 0x55, 0x21, 0xE4, 0xFF, 0x12, 0x64, 0xFB, 0xBF, 0x01, 0x0F, 0x90, 0xA2, 
+0x8C, 0xE0, 0x60, 0x09, 0x11, 0xC6, 0x54, 0x07, 0x70, 0x03, 0x12, 0x60, 0x3D, 0x22, 0x90, 0x04, 
+0x1A, 0xE0, 0xF4, 0x60, 0x03, 0x7F, 0x00, 0x22, 0x90, 0x04, 0x1B, 0xE0, 0x54, 0x07, 0x64, 0x07, 
+0x7F, 0x01, 0x60, 0x02, 0x7F, 0x00, 0x22, 0xF1, 0xBE, 0xEF, 0x70, 0x03, 0x12, 0x57, 0x9F, 0x22, 
+0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0xA5, 0x90, 0xEF, 0xF0, 0xA3, 0xED, 0xF0, 0xFB, 
+0x7D, 0x00, 0x7C, 0x00, 0xE4, 0x90, 0xA5, 0x96, 0xF0, 0xEB, 0x90, 0xA5, 0x91, 0xF0, 0x7F, 0xB0, 
+0x7E, 0x08, 0x12, 0x36, 0xCE, 0xE4, 0xFF, 0xEC, 0x90, 0xA5, 0x92, 0x12, 0x27, 0x48, 0x90, 0xA5, 
+0x92, 0x12, 0x48, 0x59, 0x90, 0xA5, 0x91, 0x12, 0x66, 0xFF, 0x12, 0x47, 0x77, 0xA3, 0x12, 0x27, 
+0x48, 0x90, 0xA5, 0x92, 0x11, 0x65, 0x7F, 0xB0, 0x7E, 0x08, 0x12, 0x37, 0x5D, 0x12, 0x5F, 0xBF, 
+0x90, 0xA5, 0x90, 0xE0, 0x75, 0xF0, 0x08, 0xA4, 0x24, 0x73, 0xF5, 0x82, 0xE4, 0x34, 0xAF, 0xF5, 
+0x83, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x12, 0x36, 0xCE, 0xED, 0x54, 0x0F, 0xFD, 0xE4, 0xFC, 0xD0, 
+0xD0, 0x92, 0xAF, 0x22, 0x12, 0x36, 0xCE, 0xEF, 0x54, 0xFC, 0xFF, 0xEC, 0x90, 0xA5, 0xAF, 0x12, 
+0x27, 0x48, 0x90, 0xA5, 0xAF, 0x12, 0x48, 0x4D, 0x90, 0xAC, 0xB9, 0x02, 0x27, 0x48, 0x90, 0xA4, 
+0x98, 0x12, 0x48, 0x7A, 0x90, 0xA5, 0x78, 0x12, 0x27, 0x54, 0x80, 0x00, 0x00, 0x00, 0x90, 0xA5, 
+0x7C, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0x00, 0xD1, 0x50, 0xE4, 0x90, 0xA4, 0x9E, 0xF0, 0x90, 
+0xA4, 0x9E, 0xE0, 0xFD, 0x12, 0xA7, 0x98, 0x51, 0x11, 0xC0, 0x06, 0xC0, 0x07, 0xF1, 0xAC, 0x75, 
+0xF0, 0x04, 0xED, 0x12, 0xA7, 0x0A, 0x12, 0x47, 0xDF, 0x11, 0x68, 0xD0, 0x07, 0xD0, 0x06, 0x12, 
+0x37, 0x5D, 0x90, 0xA4, 0x9E, 0xE0, 0xFD, 0x12, 0xA7, 0xA2, 0x51, 0x11, 0xC0, 0x06, 0xC0, 0x07, 
+0x12, 0xA5, 0xD9, 0x75, 0xF0, 0x04, 0xED, 0x12, 0xA7, 0x0A, 0x12, 0x47, 0xDF, 0x11, 0x68, 0xD0, 
+0x07, 0xD0, 0x06, 0x12, 0xA7, 0xAC, 0x94, 0x06, 0x40, 0xB5, 0x90, 0xA5, 0x78, 0x12, 0x27, 0x54, 
+0x80, 0x00, 0x00, 0x00, 0x90, 0xA5, 0x7C, 0x12, 0x27, 0x54, 0x80, 0x00, 0x00, 0x00, 0xD1, 0x50, 
+0x90, 0xAC, 0xB9, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x80, 0x31, 0xCE, 0x12, 0x27, 
+0x54, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x84, 0x31, 0xCE, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0x00, 
+0x7F, 0x88, 0x31, 0xCE, 0x12, 0x27, 0x54, 0x3C, 0x00, 0x00, 0x00, 0x7F, 0x8C, 0x31, 0xCE, 0x12, 
+0x27, 0x54, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xB8, 0x31, 0xCE, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 
+0x80, 0x7F, 0x90, 0x31, 0xCE, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x94, 0x31, 0xCE, 
+0x12, 0x27, 0x54, 0x20, 0x04, 0x00, 0x00, 0x7F, 0xC4, 0x31, 0xCE, 0x12, 0x27, 0x54, 0x20, 0x00, 
+0x00, 0x00, 0x7F, 0xC8, 0x31, 0xCE, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x80, 0x7E, 
+0x0E, 0x31, 0xD0, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x84, 0x7E, 0x0E, 0x31, 0xD0, 
+0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x88, 0x7E, 0x0E, 0x31, 0xD0, 0x12, 0x27, 0x54, 
+0x3C, 0x00, 0x00, 0x00, 0x7F, 0x8C, 0x7E, 0x0E, 0x31, 0xD0, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 
+0x00, 0x7F, 0xB8, 0x7E, 0x0E, 0x31, 0xD0, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0x80, 0x7F, 0x90, 
+0x7E, 0x0E, 0x31, 0xD0, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x94, 0x7E, 0x0E, 0x31, 
+0xD0, 0x12, 0x27, 0x54, 0x20, 0x04, 0x00, 0x00, 0x7F, 0xC4, 0x7E, 0x0E, 0x31, 0xD0, 0x12, 0x27, 
+0x54, 0x20, 0x00, 0x00, 0x00, 0x7F, 0xC8, 0x7E, 0x0E, 0x02, 0x37, 0x5D, 0x7F, 0xB0, 0x7E, 0x0C, 
+0x12, 0x37, 0x5D, 0x90, 0xAC, 0xB9, 0x22, 0x12, 0x37, 0x5D, 0x90, 0xA4, 0xEA, 0xE0, 0x75, 0xF0, 
+0x1E, 0xA4, 0x24, 0xD7, 0xF5, 0x82, 0xE4, 0x34, 0x44, 0xF5, 0x83, 0xE4, 0x93, 0xFE, 0x74, 0x01, 
+0x93, 0xFF, 0x12, 0x36, 0xCE, 0xE4, 0xFF, 0xFE, 0xEC, 0x54, 0x07, 0xFC, 0x90, 0xA5, 0x0C, 0x12, 
+0x27, 0x48, 0x90, 0xA4, 0xEA, 0xE0, 0x75, 0xF0, 0x1E, 0xA4, 0x24, 0xE7, 0xF5, 0x82, 0xE4, 0x34, 
+0x44, 0xF5, 0x83, 0xE4, 0x93, 0xFE, 0x74, 0x01, 0x93, 0xFF, 0x22, 0x90, 0xA4, 0xEA, 0x12, 0xBC, 
+0x0B, 0x51, 0x02, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0xAC, 0xB9, 0x12, 0x27, 0x54, 0x00, 0x10, 0x00, 
+0x00, 0xD0, 0x07, 0xD0, 0x06, 0x31, 0xD0, 0x12, 0x27, 0x54, 0xFA, 0x00, 0x00, 0x00, 0x7F, 0x80, 
+0x7E, 0x09, 0x31, 0xD0, 0x12, 0x27, 0x54, 0xF8, 0x00, 0x00, 0x00, 0x7F, 0x80, 0x7E, 0x09, 0x12, 
+0x37, 0x5D, 0x7F, 0x03, 0x7E, 0x00, 0x12, 0x3A, 0x69, 0x90, 0xA4, 0xEA, 0xE0, 0x60, 0x04, 0xA3, 
+0xE0, 0x70, 0x07, 0x7F, 0x04, 0x7E, 0x00, 0x12, 0x3A, 0x69, 0x51, 0x02, 0xC0, 0x06, 0xC0, 0x07, 
+0x90, 0xAC, 0xB9, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0x00, 0xD0, 0x07, 0xD0, 0x06, 0x12, 0x37, 
+0x5D, 0xE4, 0x90, 0xA4, 0xED, 0xF0, 0x71, 0xD1, 0x51, 0x11, 0x12, 0x36, 0xCE, 0xE4, 0xFF, 0xEE, 
+0x54, 0x04, 0xFE, 0xE4, 0xFD, 0xFC, 0x78, 0x0A, 0x12, 0x27, 0x22, 0xEF, 0x70, 0x14, 0x90, 0xA4, 
+0xED, 0xE0, 0xD3, 0x94, 0x14, 0x50, 0x0B, 0x12, 0x98, 0xD8, 0x90, 0xA4, 0xED, 0xE0, 0x04, 0xF0, 
+0x80, 0xD4, 0x90, 0xA4, 0xED, 0xE0, 0xC3, 0x94, 0x14, 0x40, 0x02, 0x61, 0xC2, 0x90, 0xA4, 0xEB, 
+0xE0, 0x70, 0x41, 0x71, 0xD1, 0x51, 0x11, 0xF1, 0xD8, 0x70, 0x31, 0x51, 0x02, 0xC0, 0x06, 0xC0, 
+0x07, 0x90, 0xAC, 0xB9, 0x12, 0x27, 0x54, 0x02, 0x00, 0x00, 0x00, 0xD0, 0x07, 0xD0, 0x06, 0x31, 
+0xD7, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0xAC, 0xB9, 0x12, 0x27, 0x54, 0x04, 0x00, 0x00, 0x00, 0xD0, 
+0x07, 0xD0, 0x06, 0x71, 0xCE, 0x51, 0x11, 0x12, 0xBA, 0x9D, 0x61, 0xC8, 0xF1, 0xC9, 0x60, 0x02, 
+0x41, 0x21, 0x61, 0xC8, 0x71, 0xD1, 0x51, 0x11, 0xF1, 0xD8, 0x60, 0x02, 0x61, 0xBA, 0x51, 0x02, 
+0xC0, 0x06, 0xC0, 0x07, 0x90, 0xAC, 0xB9, 0x12, 0x27, 0x54, 0x06, 0x00, 0x00, 0x00, 0xD0, 0x07, 
+0xD0, 0x06, 0x31, 0xD7, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0xAC, 0xB9, 0x12, 0x27, 0x54, 0x08, 0x00, 
+0x00, 0x00, 0xD0, 0x07, 0xD0, 0x06, 0x71, 0xCE, 0x51, 0x11, 0x12, 0xBA, 0x9D, 0x51, 0x02, 0xC0, 
+0x06, 0xC0, 0x07, 0x90, 0xAC, 0xB9, 0x12, 0x27, 0x54, 0x05, 0x00, 0x00, 0x00, 0xD0, 0x07, 0xD0, 
+0x06, 0x71, 0xCE, 0x51, 0x11, 0x12, 0x36, 0xCE, 0x90, 0xA4, 0xF0, 0x31, 0xFF, 0xC0, 0x06, 0xC0, 
+0x07, 0x90, 0xAC, 0xB9, 0x12, 0x27, 0x54, 0x06, 0x00, 0x00, 0x00, 0xD0, 0x07, 0xD0, 0x06, 0x71, 
+0xCE, 0x51, 0x11, 0x12, 0xBB, 0x34, 0x90, 0xA4, 0xF4, 0x31, 0xFF, 0xC0, 0x06, 0xC0, 0x07, 0x90, 
+0xAC, 0xB9, 0x12, 0x27, 0x54, 0x07, 0x00, 0x00, 0x00, 0xD0, 0x07, 0xD0, 0x06, 0x71, 0xCE, 0x51, 
+0x11, 0x12, 0x36, 0xCE, 0x90, 0xA4, 0xF0, 0x31, 0xFF, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0xAC, 0xB9, 
+0x12, 0x27, 0x54, 0x08, 0x00, 0x00, 0x00, 0xD0, 0x07, 0xD0, 0x06, 0x71, 0xCE, 0x51, 0x11, 0x12, 
+0xBB, 0x34, 0x90, 0xA4, 0xF4, 0x12, 0x27, 0x48, 0x80, 0x0E, 0xF1, 0xC9, 0x60, 0x02, 0x41, 0x21, 
+0x80, 0x06, 0xF1, 0xC9, 0x60, 0x02, 0x41, 0x21, 0x90, 0xA4, 0xEF, 0xE0, 0xFF, 0x22, 0x12, 0x37, 
+0x5D, 0x90, 0xA4, 0xEA, 0xE0, 0x75, 0xF0, 0x1E, 0xA4, 0x24, 0xD7, 0xF5, 0x82, 0xE4, 0x34, 0x44, 
+0x22, 0x90, 0xA5, 0xFE, 0xED, 0xF0, 0xEF, 0x60, 0x02, 0x81, 0xAC, 0xE0, 0x24, 0xFD, 0x50, 0x0A, 
+0x60, 0x1D, 0x14, 0x60, 0x2F, 0x14, 0x60, 0x6B, 0xC1, 0x31, 0x90, 0xAC, 0xB9, 0x12, 0x27, 0x54, 
+0x77, 0x77, 0x77, 0x77, 0x31, 0xCC, 0x12, 0x27, 0x54, 0x77, 0x77, 0x77, 0x77, 0xA1, 0x1F, 0x90, 
+0xAC, 0xB9, 0x12, 0x27, 0x54, 0x54, 0x33, 0x77, 0x70, 0x31, 0xCC, 0x12, 0x27, 0x54, 0x54, 0x33, 
+0x77, 0x70, 0xA1, 0x9D, 0x90, 0xAC, 0xB9, 0x12, 0x27, 0x54, 0x77, 0x77, 0x77, 0x77, 0x31, 0xCC, 
+0x12, 0x27, 0x54, 0x77, 0x77, 0x77, 0x77, 0xF1, 0x92, 0x12, 0x27, 0x54, 0x3F, 0xF0, 0x00, 0x00, 
+0x90, 0xA5, 0x7C, 0x12, 0x27, 0x54, 0x00, 0x10, 0x00, 0x00, 0x7F, 0xB4, 0x7E, 0x0C, 0xD1, 0x4A, 
+0x12, 0x27, 0x54, 0x3F, 0xF0, 0x00, 0x00, 0x90, 0xA5, 0x7C, 0x12, 0x27, 0x54, 0x00, 0x10, 0x00, 
+0x00, 0xC1, 0x2B, 0x90, 0xA5, 0x78, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0xFF, 0x90, 0xA5, 0x7C, 
+0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0x77, 0xF1, 0xB2, 0x12, 0x27, 0x54, 0x77, 0x77, 0x77, 0x77, 
+0xF1, 0x92, 0x12, 0x27, 0x54, 0x01, 0x00, 0x00, 0x00, 0x90, 0xA5, 0x7C, 0x12, 0x27, 0x54, 0x00, 
+0x00, 0x00, 0x00, 0x7F, 0xB4, 0x7E, 0x0C, 0xD1, 0x4A, 0x12, 0x27, 0x54, 0x3F, 0xF0, 0x00, 0x00, 
+0x90, 0xA5, 0x7C, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0x00, 0xC1, 0x2B, 0x90, 0xA5, 0xFE, 0xE0, 
+0x14, 0x60, 0x59, 0x14, 0x70, 0x02, 0xA1, 0x4B, 0x14, 0x70, 0x02, 0xA1, 0x8A, 0x14, 0x70, 0x02, 
+0xA1, 0x4B, 0x14, 0x70, 0x02, 0xA1, 0xE4, 0x24, 0x05, 0x60, 0x02, 0xC1, 0x31, 0x90, 0xAC, 0xB9, 
+0x12, 0x27, 0x54, 0x77, 0x33, 0x77, 0x17, 0x31, 0xCC, 0x12, 0x27, 0x54, 0x77, 0x33, 0x77, 0x17, 
+0xF1, 0x92, 0x12, 0x27, 0x54, 0x3F, 0xF0, 0x00, 0x00, 0x90, 0xA5, 0x7C, 0x12, 0x27, 0x54, 0x01, 
+0x00, 0x00, 0x00, 0x7F, 0xB4, 0x7E, 0x0C, 0xD1, 0x4A, 0x12, 0x27, 0x54, 0x3F, 0xF0, 0x00, 0x00, 
+0x90, 0xA5, 0x7C, 0x12, 0x27, 0x54, 0x01, 0x00, 0x00, 0x00, 0xC1, 0x2B, 0x90, 0xAC, 0xB9, 0x12, 
+0x27, 0x54, 0x77, 0x33, 0x77, 0x17, 0x31, 0xCC, 0x12, 0x27, 0x54, 0x77, 0x33, 0x77, 0x17, 0xF1, 
+0x92, 0x12, 0x27, 0x54, 0x3F, 0xF0, 0x00, 0x00, 0x90, 0xA5, 0x7C, 0x12, 0x27, 0x54, 0x00, 0x00, 
+0x00, 0x00, 0x7F, 0xB4, 0x7E, 0x0C, 0xD1, 0x4A, 0x12, 0x27, 0x54, 0x3F, 0xF0, 0x00, 0x00, 0x90, 
+0xA5, 0x7C, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0x00, 0xC1, 0x2B, 0x90, 0xAC, 0xB9, 0x12, 0x27, 
+0x54, 0x77, 0x33, 0x77, 0x77, 0x31, 0xCC, 0x12, 0x27, 0x54, 0x77, 0x33, 0x77, 0x77, 0xF1, 0x92, 
+0x12, 0x27, 0x54, 0x3F, 0xF0, 0x00, 0x00, 0x90, 0xA5, 0x7C, 0x12, 0x27, 0x54, 0x01, 0x00, 0x00, 
+0x00, 0x7F, 0xB4, 0x7E, 0x0C, 0xD1, 0x4A, 0x12, 0x27, 0x54, 0x3F, 0xF0, 0x00, 0x00, 0x90, 0xA5, 
+0x7C, 0x12, 0x27, 0x54, 0x01, 0x00, 0x00, 0x00, 0xC1, 0x2B, 0x90, 0xAC, 0xB9, 0x12, 0x27, 0x54, 
+0x54, 0x33, 0x77, 0x17, 0x31, 0xCC, 0x12, 0x27, 0x54, 0x54, 0x33, 0x77, 0x17, 0xF1, 0x92, 0x12, 
+0x27, 0x54, 0x3F, 0xF0, 0x00, 0x00, 0x90, 0xA5, 0x7C, 0x12, 0x27, 0x54, 0x01, 0x00, 0x00, 0x00, 
+0x7F, 0xB4, 0x7E, 0x0C, 0xD1, 0x4A, 0x12, 0x27, 0x54, 0x3F, 0xF0, 0x00, 0x00, 0x90, 0xA5, 0x7C, 
+0x12, 0x27, 0x54, 0x01, 0x00, 0x00, 0x00, 0x7F, 0xB4, 0x7E, 0x0E, 0xD1, 0x4A, 0x12, 0x27, 0x54, 
+0x00, 0x00, 0x03, 0x03, 0x90, 0xA5, 0x7C, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0x01, 0x7F, 0x00, 
+0x7E, 0x09, 0x80, 0x4B, 0x90, 0xA5, 0x78, 0x12, 0x27, 0x54, 0x00, 0xFF, 0x00, 0x00, 0x90, 0xA5, 
+0x7C, 0x12, 0x27, 0x54, 0x00, 0x33, 0x00, 0x00, 0xF1, 0xB2, 0x12, 0x27, 0x54, 0x77, 0x33, 0x77, 
+0x77, 0xF1, 0x92, 0x12, 0x27, 0x54, 0x01, 0x00, 0x00, 0x00, 0x90, 0xA5, 0x7C, 0x12, 0x27, 0x54, 
+0x01, 0x00, 0x00, 0x00, 0x7F, 0xB4, 0x7E, 0x0C, 0xD1, 0x4A, 0x12, 0x27, 0x54, 0x3F, 0xF0, 0x00, 
+0x00, 0x90, 0xA5, 0x7C, 0x12, 0x27, 0x54, 0x01, 0x00, 0x00, 0x00, 0x7F, 0xB4, 0x7E, 0x0E, 0xD1, 
+0x54, 0x22, 0x90, 0xA5, 0xA4, 0xE0, 0xFF, 0xE4, 0xFC, 0xFD, 0xFE, 0x78, 0x1C, 0x12, 0x27, 0x35, 
+0x90, 0xA5, 0x7C, 0x12, 0x27, 0x48, 0x7F, 0x38, 0x7E, 0x08, 0xD1, 0x54, 0x90, 0xA5, 0x78, 0x22, 
+0x7F, 0x2C, 0x7E, 0x08, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0xA5, 0x76, 0xEE, 0xF0, 
+0xA3, 0xEF, 0xF0, 0x12, 0x36, 0xCE, 0x90, 0xA5, 0x80, 0x12, 0x27, 0x48, 0x90, 0xA5, 0x78, 0x12, 
+0x48, 0x4D, 0x12, 0x27, 0x15, 0x90, 0xA5, 0x80, 0xF1, 0x9D, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 
+0xC0, 0x07, 0x90, 0xA5, 0x78, 0x12, 0x48, 0x4D, 0x90, 0xA5, 0x7C, 0xF1, 0x9D, 0xD0, 0x03, 0xD0, 
+0x02, 0xD0, 0x01, 0xD0, 0x00, 0x12, 0x47, 0x77, 0x90, 0xA5, 0x84, 0x12, 0x27, 0x48, 0x90, 0xA5, 
+0x84, 0x11, 0x65, 0x90, 0xA5, 0x76, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x12, 0x37, 0x5D, 0xD0, 0xD0, 
+0x92, 0xAF, 0x22, 0x90, 0xA5, 0xE6, 0xED, 0xF0, 0x90, 0xA5, 0xE5, 0xEF, 0xF0, 0x70, 0x65, 0x90, 
+0xA5, 0x78, 0x12, 0x27, 0x54, 0x30, 0x00, 0x00, 0x00, 0x90, 0xA5, 0x7C, 0x12, 0x27, 0x54, 0x00, 
+0x00, 0x00, 0x00, 0x74, 0x08, 0xFF, 0xFE, 0xD1, 0x4A, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0x0E, 
+0x90, 0xA5, 0x7C, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0x08, 0x7F, 0x30, 0xD1, 0x48, 0x12, 0x27, 
+0x54, 0x00, 0x00, 0x00, 0x03, 0x90, 0xA5, 0x7C, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0x01, 0xF1, 
+0xBC, 0xE0, 0xFD, 0x71, 0xE1, 0x90, 0xA5, 0x78, 0x12, 0x27, 0x54, 0x30, 0x00, 0x00, 0x00, 0x90, 
+0xA5, 0x7C, 0x12, 0x27, 0x54, 0x30, 0x00, 0x00, 0x00, 0xF1, 0xA3, 0x90, 0x04, 0x54, 0xE0, 0x54, 
+0x7F, 0x02, 0xBB, 0x96, 0x90, 0xA5, 0xE5, 0xE0, 0x64, 0x01, 0x70, 0x65, 0x90, 0x04, 0x54, 0xE0, 
+0x44, 0x80, 0x12, 0xBB, 0x96, 0x90, 0xA5, 0x78, 0x12, 0x27, 0x54, 0x30, 0x00, 0x00, 0x00, 0x90, 
+0xA5, 0x7C, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0x00, 0x74, 0x08, 0xFF, 0xFE, 0xD1, 0x4A, 0x12, 
+0x27, 0x54, 0x00, 0x00, 0x00, 0x0E, 0x90, 0xA5, 0x7C, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0x06, 
+0x7F, 0x30, 0xD1, 0x48, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0x03, 0x90, 0xA5, 0x7C, 0x12, 0x27, 
+0x54, 0x00, 0x00, 0x00, 0x02, 0xF1, 0xBC, 0xE0, 0xFD, 0x71, 0xE1, 0x90, 0xA5, 0x78, 0x12, 0x27, 
+0x54, 0x30, 0x00, 0x00, 0x00, 0x90, 0xA5, 0x7C, 0x12, 0x27, 0x54, 0x20, 0x00, 0x00, 0x00, 0xF1, 
+0xA3, 0x22, 0x7F, 0xB0, 0x7E, 0x0E, 0x12, 0x37, 0x5D, 0x90, 0xA5, 0x78, 0x22, 0x12, 0x48, 0x59, 
+0x02, 0x47, 0x6A, 0x74, 0x08, 0xFF, 0xFE, 0xC1, 0x54, 0xFF, 0xF1, 0xE1, 0x90, 0xA4, 0x98, 0x02, 
+0x48, 0x71, 0x7F, 0xB0, 0x7E, 0x0C, 0xD1, 0x54, 0x90, 0xAC, 0xB9, 0x22, 0x7F, 0x34, 0x7E, 0x08, 
+0xD1, 0x54, 0x90, 0xA5, 0xE5, 0xE0, 0xFF, 0xA3, 0x22, 0xE4, 0x90, 0xA4, 0xEF, 0xF0, 0x90, 0xA4, 
+0xEC, 0xE0, 0x04, 0xF0, 0xE0, 0x64, 0x0A, 0x22, 0x12, 0x36, 0xCE, 0xE4, 0x90, 0xA4, 0xEE, 0xF0, 
+0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x12, 0x7F, 0xE0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 
+0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0xC0, 0x07, 0xC0, 0x05, 0x90, 0xA4, 0xEC, 0x12, 0x48, 
+0x4D, 0x90, 0xAC, 0x9C, 0x12, 0x27, 0x48, 0xD0, 0x05, 0xD0, 0x07, 0x12, 0x32, 0x65, 0xD0, 0xD0, 
+0x92, 0xAF, 0x22, 0x90, 0xA4, 0x98, 0xE0, 0xFF, 0x7D, 0x65, 0x12, 0x87, 0xF0, 0x90, 0xA4, 0xEC, 
+0x22, 0x90, 0xA4, 0x98, 0xEF, 0xF0, 0xA3, 0x12, 0x48, 0x7A, 0x90, 0xA5, 0x78, 0x12, 0x27, 0x54, 
+0x80, 0x00, 0x00, 0x00, 0x90, 0xA5, 0x7C, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0x00, 0x12, 0x86, 
+0x50, 0x12, 0xBB, 0x15, 0x12, 0x47, 0xBF, 0x12, 0xBA, 0x70, 0x7D, 0x65, 0x12, 0xBB, 0x12, 0x90, 
+0x00, 0x04, 0x12, 0xBA, 0x6D, 0x7D, 0x8F, 0x12, 0xBB, 0x12, 0x90, 0x00, 0x08, 0x12, 0xBA, 0x6D, 
+0xE4, 0xFD, 0x11, 0x1A, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0x00, 0x90, 0xA4, 0x98, 0xE0, 0xFF, 
+0x7D, 0xEF, 0x02, 0x87, 0xF0, 0x90, 0xA4, 0x98, 0xEF, 0xF0, 0xE4, 0xA3, 0xF0, 0x90, 0xA4, 0xE4, 
+0x12, 0x50, 0x66, 0xA3, 0xF0, 0x90, 0xA5, 0x78, 0x12, 0x27, 0x54, 0x80, 0x00, 0x00, 0x00, 0x90, 
+0xA5, 0x7C, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0x00, 0x12, 0x86, 0x50, 0x90, 0xA4, 0x98, 0xE0, 
+0x90, 0xAC, 0xB9, 0x70, 0x39, 0x12, 0x27, 0x54, 0x77, 0x77, 0x77, 0x77, 0x90, 0x44, 0xB5, 0x12, 
+0x82, 0x13, 0x12, 0x81, 0xD0, 0x12, 0x27, 0x54, 0x77, 0x77, 0x77, 0x77, 0x90, 0x44, 0xB7, 0x12, 
+0x82, 0x13, 0x12, 0x81, 0xD0, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0x00, 0x90, 0x44, 0xC1, 0x12, 
+0x82, 0x13, 0x12, 0x81, 0xD0, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0x00, 0x80, 0x37, 0x12, 0x27, 
+0x54, 0x00, 0x00, 0x00, 0x00, 0x90, 0x44, 0xB5, 0x12, 0x82, 0x13, 0x12, 0x81, 0xD0, 0x12, 0x27, 
+0x54, 0x00, 0x00, 0x00, 0x00, 0x90, 0x44, 0xB7, 0x12, 0x82, 0x13, 0x12, 0x81, 0xD0, 0x12, 0x27, 
+0x54, 0x77, 0x77, 0x77, 0x77, 0x90, 0x44, 0xC1, 0x12, 0x82, 0x13, 0x12, 0x81, 0xD0, 0x12, 0x27, 
+0x54, 0x77, 0x77, 0x77, 0x77, 0x90, 0x44, 0xC3, 0x12, 0x82, 0x13, 0x12, 0x37, 0x5D, 0x90, 0xA4, 
+0x98, 0xE0, 0x75, 0xF0, 0x0C, 0xA4, 0x24, 0xB9, 0xF5, 0x82, 0xE4, 0x34, 0x44, 0x12, 0x82, 0x11, 
+0xC0, 0x06, 0xC0, 0x07, 0x90, 0xAC, 0xB9, 0x12, 0x27, 0x54, 0x19, 0x79, 0x19, 0x79, 0xD0, 0x07, 
+0xD0, 0x06, 0x12, 0xBA, 0x2C, 0x24, 0xCB, 0xF5, 0x82, 0xE4, 0x34, 0x44, 0x12, 0x82, 0x11, 0xC0, 
+0x06, 0xC0, 0x07, 0x90, 0xA5, 0x78, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0x0F, 0x90, 0xA5, 0x7C, 
+0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0x04, 0xD0, 0x07, 0xD0, 0x06, 0x12, 0x86, 0x54, 0x90, 0xA4, 
+0x98, 0xE0, 0x75, 0xF0, 0x0C, 0xA4, 0x12, 0xA7, 0x9A, 0x12, 0x82, 0x11, 0xC0, 0x06, 0xC0, 0x07, 
+0x90, 0xA5, 0x78, 0x12, 0x27, 0x54, 0x07, 0x00, 0x00, 0x00, 0x90, 0xA5, 0x7C, 0x12, 0x27, 0x54, 
+0x07, 0x00, 0x00, 0x00, 0xD0, 0x07, 0xD0, 0x06, 0x12, 0x86, 0x4A, 0x12, 0x27, 0x54, 0x80, 0x00, 
+0x00, 0x00, 0x90, 0xA5, 0x7C, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0x00, 0x12, 0x86, 0x50, 0x90, 
+0xA4, 0xEC, 0x12, 0x27, 0x54, 0x00, 0x08, 0x00, 0x02, 0x90, 0xA4, 0x98, 0xE0, 0xFF, 0x7D, 0xEF, 
+0x11, 0x1A, 0x12, 0x27, 0x54, 0x00, 0x02, 0x00, 0x00, 0x12, 0xBC, 0x5E, 0x11, 0x1A, 0x12, 0x27, 
+0x54, 0x00, 0x03, 0xFF, 0xFD, 0x12, 0xBC, 0x56, 0x11, 0x1A, 0x12, 0x27, 0x54, 0x00, 0x0F, 0xE8, 
+0x3F, 0x12, 0xBC, 0x4E, 0x11, 0x1A, 0x12, 0x27, 0x54, 0x00, 0x09, 0x31, 0xD5, 0x11, 0x13, 0x12, 
+0x27, 0x54, 0x00, 0x08, 0xA0, 0x01, 0x12, 0xBC, 0x26, 0x12, 0x87, 0xF0, 0x90, 0xAC, 0xB9, 0x12, 
+0x27, 0x54, 0x00, 0x00, 0x80, 0x00, 0x7F, 0x0C, 0x7E, 0x09, 0x12, 0xBA, 0x2C, 0x24, 0xCD, 0xF5, 
+0x82, 0xE4, 0x34, 0x44, 0x12, 0x82, 0x11, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0xA5, 0x78, 0x12, 0x27, 
+0x54, 0x00, 0x00, 0x00, 0x01, 0x90, 0xA5, 0x7C, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0x01, 0xD0, 
+0x07, 0xD0, 0x06, 0x12, 0x87, 0xB6, 0x12, 0x27, 0x54, 0x29, 0x00, 0x20, 0x00, 0x7F, 0x78, 0x7E, 
+0x09, 0x12, 0x81, 0xD0, 0x12, 0x27, 0x54, 0xA9, 0x00, 0x20, 0x00, 0x7F, 0x7C, 0x7E, 0x09, 0x12, 
+0x81, 0xD0, 0x12, 0x27, 0x54, 0x00, 0x46, 0x29, 0x10, 0x7F, 0x84, 0x7E, 0x09, 0x12, 0x87, 0x96, 
+0x12, 0x27, 0x54, 0x80, 0x00, 0x00, 0x00, 0x90, 0xA5, 0x7C, 0x12, 0x27, 0x54, 0x80, 0x00, 0x00, 
+0x00, 0x12, 0x86, 0x50, 0x90, 0xA3, 0x6A, 0xE0, 0x30, 0xE0, 0x39, 0x12, 0xBA, 0x89, 0x90, 0xA4, 
+0x98, 0xE0, 0x75, 0xF0, 0x1E, 0xBF, 0x01, 0x16, 0x12, 0xBA, 0x7C, 0x12, 0x82, 0x11, 0xC0, 0x06, 
+0xC0, 0x07, 0x90, 0xAC, 0xB9, 0x12, 0x27, 0x54, 0x82, 0x14, 0x03, 0xE3, 0x80, 0x2D, 0x12, 0xBA, 
+0x7C, 0x12, 0x82, 0x11, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0xAC, 0xB9, 0x12, 0x27, 0x54, 0x82, 0x14, 
+0x03, 0xF7, 0x80, 0x17, 0x12, 0xBA, 0x2F, 0x12, 0xBA, 0x7D, 0x12, 0x82, 0x11, 0xC0, 0x06, 0xC0, 
+0x07, 0x90, 0xAC, 0xB9, 0x12, 0x27, 0x54, 0x82, 0x14, 0x03, 0xF1, 0xD0, 0x07, 0xD0, 0x06, 0x12, 
+0x37, 0x5D, 0x90, 0xA3, 0x69, 0xE0, 0x30, 0xE5, 0x1D, 0x12, 0xBA, 0x2F, 0x24, 0xD1, 0xF5, 0x82, 
+0xE4, 0x34, 0x44, 0x12, 0x82, 0x11, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0xAC, 0xB9, 0x12, 0x27, 0x54, 
+0x68, 0x16, 0x3E, 0x96, 0x80, 0x60, 0x90, 0xA3, 0x69, 0xE0, 0x30, 0xE4, 0x60, 0x12, 0xBA, 0x2F, 
+0x24, 0xD1, 0xF5, 0x82, 0xE4, 0x34, 0x44, 0x12, 0x82, 0x11, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0xAC, 
+0xB9, 0x12, 0x27, 0x54, 0x28, 0x16, 0x3E, 0x96, 0xD0, 0x07, 0xD0, 0x06, 0x12, 0x37, 0x5D, 0x12, 
+0xBA, 0x85, 0x90, 0xA4, 0x98, 0xE0, 0x75, 0xF0, 0x1E, 0xBF, 0x03, 0x16, 0x12, 0xBA, 0x7C, 0x12, 
+0x82, 0x11, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0xAC, 0xB9, 0x12, 0x27, 0x54, 0x82, 0x14, 0x03, 0xE3, 
+0x80, 0x14, 0x12, 0xBA, 0x7C, 0x12, 0x82, 0x11, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0xAC, 0xB9, 0x12, 
+0x27, 0x54, 0x82, 0x14, 0x03, 0xF7, 0xD0, 0x07, 0xD0, 0x06, 0x12, 0x37, 0x5D, 0x12, 0xBA, 0x2F, 
+0x24, 0xE3, 0xF5, 0x82, 0xE4, 0x34, 0x44, 0x12, 0x82, 0x11, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0xAC, 
+0xB9, 0x12, 0x27, 0x54, 0x18, 0x00, 0x8C, 0x10, 0xD0, 0x07, 0xD0, 0x06, 0x12, 0xBA, 0x2C, 0x24, 
+0xE5, 0xF5, 0x82, 0xE4, 0x34, 0x44, 0x12, 0x82, 0x11, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0xAC, 0xB9, 
+0x12, 0x27, 0x54, 0x38, 0x00, 0x8C, 0x10, 0xD0, 0x07, 0xD0, 0x06, 0x12, 0xBA, 0x2C, 0x24, 0xD3, 
+0xF5, 0x82, 0xE4, 0x34, 0x44, 0x12, 0x82, 0x11, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0xAC, 0xB9, 0x12, 
+0x27, 0x54, 0x00, 0x00, 0x00, 0x00, 0xD0, 0x07, 0xD0, 0x06, 0x12, 0x37, 0x5D, 0xE4, 0x90, 0xA4, 
+0x99, 0xF0, 0x90, 0xA4, 0x98, 0xE0, 0xFF, 0xE4, 0xFD, 0x12, 0x82, 0x1B, 0x90, 0xA4, 0xE8, 0xEF, 
+0xF0, 0x90, 0xA5, 0x0C, 0x12, 0x93, 0x60, 0x90, 0xA4, 0xE4, 0xE0, 0xFB, 0x12, 0xBA, 0x61, 0x12, 
+0x93, 0x58, 0xEB, 0x12, 0xBA, 0x55, 0x12, 0x97, 0xD2, 0x90, 0xA4, 0xE4, 0x12, 0x97, 0xBD, 0x40, 
+0x02, 0x81, 0x9E, 0xEE, 0x04, 0xA3, 0xF0, 0x90, 0xA4, 0xE4, 0x12, 0x97, 0xB3, 0x40, 0x02, 0x81, 
+0x96, 0xEE, 0x12, 0xBA, 0x61, 0x12, 0x92, 0xDB, 0x12, 0xBA, 0x65, 0x12, 0x93, 0x18, 0x12, 0x93, 
+0x51, 0x50, 0x7B, 0x74, 0xFF, 0x7F, 0xFC, 0x12, 0x93, 0x2E, 0x12, 0x93, 0x11, 0x40, 0x6F, 0x12, 
+0xBA, 0x51, 0x12, 0x92, 0xDB, 0x12, 0xBA, 0x59, 0x12, 0x93, 0x35, 0x50, 0x61, 0x12, 0x93, 0x07, 
+0x40, 0x5C, 0x90, 0xA4, 0x9B, 0xE0, 0x12, 0xBA, 0x61, 0x12, 0x91, 0xE6, 0xC0, 0x04, 0xC0, 0x05, 
+0xC0, 0x06, 0xC0, 0x07, 0x12, 0x92, 0xE0, 0x12, 0xBA, 0x65, 0x12, 0x91, 0xE6, 0xD0, 0x03, 0xD0, 
+0x02, 0xD0, 0x01, 0xD0, 0x00, 0x12, 0x92, 0xFC, 0x90, 0xA4, 0xB4, 0x12, 0x27, 0x48, 0x12, 0xBA, 
+0x51, 0x12, 0x91, 0xE6, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0x12, 0x92, 0xE0, 0x12, 
+0xBA, 0x59, 0x12, 0x91, 0xE6, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0x12, 0x92, 0xFC, 
+0x90, 0xA4, 0xB8, 0x12, 0x27, 0x48, 0x90, 0xA4, 0xE6, 0x74, 0x01, 0xF0, 0x80, 0x08, 0x90, 0xA4, 
+0x9B, 0xE0, 0x04, 0xF0, 0x61, 0xF7, 0x90, 0xA4, 0x9A, 0xE0, 0x04, 0xF0, 0x61, 0xE9, 0x90, 0xA4, 
+0xE8, 0xE0, 0x60, 0x06, 0x90, 0xA4, 0xE4, 0xE0, 0x04, 0xF0, 0x90, 0xA4, 0xE6, 0xE0, 0x64, 0x01, 
+0x60, 0x07, 0x12, 0x97, 0xC7, 0x50, 0x02, 0x61, 0xC2, 0x90, 0xA5, 0x78, 0x12, 0x27, 0x54, 0x80, 
+0x00, 0x00, 0x00, 0x90, 0xA5, 0x7C, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0x00, 0x12, 0x86, 0x50, 
+0x90, 0xA4, 0x98, 0xE0, 0xFF, 0x7D, 0x08, 0x12, 0x87, 0xE1, 0xE4, 0xFF, 0xEE, 0x54, 0xFC, 0xFE, 
+0xED, 0x54, 0x0F, 0xFD, 0xE4, 0xFC, 0x90, 0xA5, 0x6A, 0x12, 0x27, 0x48, 0x90, 0xA5, 0x66, 0x12, 
+0x27, 0x54, 0x00, 0x07, 0xFE, 0x00, 0x90, 0xA4, 0x98, 0xE0, 0xFF, 0x7D, 0x58, 0x7C, 0x00, 0x12, 
+0x96, 0x52, 0x90, 0xA5, 0x78, 0x12, 0x27, 0x54, 0x80, 0x00, 0x00, 0x00, 0x90, 0xA5, 0x7C, 0x12, 
+0x27, 0x54, 0x80, 0x00, 0x00, 0x00, 0x12, 0x86, 0x50, 0x90, 0xA4, 0xE6, 0xE0, 0xB4, 0x01, 0x17, 
+0x90, 0xA4, 0xB4, 0x12, 0x97, 0xA1, 0x90, 0xA4, 0xB8, 0x12, 0x48, 0x4D, 0x90, 0xA4, 0xEF, 0x12, 
+0xBA, 0x73, 0x12, 0x92, 0x07, 0x80, 0x1F, 0x90, 0xA4, 0xEB, 0x12, 0x27, 0x54, 0x00, 0x00, 0x02, 
+0x00, 0x90, 0xA4, 0xEF, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0x00, 0x90, 0xA4, 0x98, 0xE0, 0xFF, 
+0x12, 0x92, 0x07, 0x02, 0x90, 0xBA, 0x90, 0xA5, 0x78, 0x12, 0x27, 0x54, 0x80, 0x00, 0x00, 0x00, 
+0x90, 0xA5, 0x7C, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0x00, 0x12, 0x86, 0x50, 0x90, 0xA4, 0xEC, 
+0x12, 0x27, 0x54, 0x00, 0x08, 0x00, 0x00, 0x90, 0xA4, 0x98, 0xE0, 0xFF, 0x7D, 0xEF, 0x11, 0x1A, 
+0x12, 0x27, 0x54, 0x00, 0x03, 0x00, 0x00, 0x12, 0xBC, 0x5E, 0x11, 0x1A, 0x12, 0x27, 0x54, 0x00, 
+0x03, 0xF7, 0xFF, 0x12, 0xBC, 0x56, 0x11, 0x1A, 0x12, 0x27, 0x54, 0x00, 0x0F, 0xE7, 0xBF, 0x12, 
+0xBC, 0x4E, 0x11, 0x1A, 0x12, 0x27, 0x54, 0x00, 0x08, 0x80, 0x01, 0x12, 0xBC, 0x26, 0x11, 0x1A, 
+0x12, 0x27, 0x54, 0x00, 0x09, 0x31, 0xD1, 0x11, 0x13, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0x00, 
+0x90, 0xA4, 0x98, 0xE0, 0xFF, 0x7D, 0xEF, 0x12, 0x87, 0xF0, 0x90, 0xA5, 0x78, 0x12, 0x27, 0x54, 
+0x80, 0x00, 0x00, 0x00, 0x90, 0xA5, 0x7C, 0x12, 0x27, 0x54, 0x80, 0x00, 0x00, 0x00, 0x7F, 0x78, 
+0x7E, 0x09, 0x12, 0x86, 0x4A, 0x12, 0x27, 0x54, 0x80, 0x00, 0x00, 0x00, 0x90, 0xA5, 0x7C, 0x12, 
+0x27, 0x54, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x7C, 0x7E, 0x09, 0x12, 0x87, 0xB6, 0x12, 0x27, 0x54, 
+0x00, 0x00, 0x80, 0x00, 0x7F, 0x0C, 0x7E, 0x09, 0x12, 0x37, 0x5D, 0x90, 0xA3, 0x69, 0xE0, 0x90, 
+0xAC, 0xB9, 0x30, 0xE5, 0x09, 0x12, 0x27, 0x54, 0x00, 0x46, 0xA8, 0x91, 0x80, 0x07, 0x12, 0x27, 
+0x54, 0x00, 0x46, 0xA8, 0x90, 0x7F, 0x84, 0x7E, 0x09, 0x12, 0x37, 0x5D, 0x90, 0xA3, 0x6A, 0xE0, 
+0x54, 0xE0, 0xC4, 0x13, 0x54, 0x07, 0x64, 0x01, 0x90, 0xA4, 0x98, 0x70, 0x30, 0x12, 0xBB, 0x05, 
+0x12, 0x82, 0x11, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0xAC, 0xB9, 0x12, 0x27, 0x54, 0x77, 0x77, 0x77, 
+0x17, 0xD0, 0x07, 0xD0, 0x06, 0x12, 0xBA, 0xD5, 0x34, 0x44, 0x12, 0x82, 0x11, 0xC0, 0x06, 0xC0, 
+0x07, 0x90, 0xAC, 0xB9, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0x77, 0x80, 0x2E, 0x12, 0xBB, 0x05, 
+0x12, 0x82, 0x11, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0xAC, 0xB9, 0x12, 0x27, 0x54, 0x77, 0x77, 0x77, 
+0x17, 0xD0, 0x07, 0xD0, 0x06, 0x12, 0xBA, 0xD5, 0x34, 0x44, 0x12, 0x82, 0x11, 0xC0, 0x06, 0xC0, 
+0x07, 0x90, 0xAC, 0xB9, 0x12, 0x27, 0x54, 0x02, 0x00, 0x00, 0x77, 0xD0, 0x07, 0xD0, 0x06, 0x12, 
+0x37, 0x5D, 0x90, 0xA5, 0x78, 0x12, 0x27, 0x54, 0x80, 0x00, 0x00, 0x00, 0x90, 0xA5, 0x7C, 0x12, 
+0x27, 0x54, 0x80, 0x00, 0x00, 0x00, 0x12, 0x86, 0x50, 0x12, 0xBA, 0x2F, 0x24, 0xE3, 0xF5, 0x82, 
+0xE4, 0x34, 0x44, 0x12, 0x82, 0x11, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0xAC, 0xB9, 0x12, 0x27, 0x54, 
+0x38, 0x00, 0x8C, 0x10, 0xD0, 0x07, 0xD0, 0x06, 0x12, 0xBA, 0x2C, 0x24, 0xE5, 0xF5, 0x82, 0xE4, 
+0x34, 0x44, 0x12, 0x82, 0x11, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0xAC, 0xB9, 0x12, 0x27, 0x54, 0x18, 
+0x00, 0x8C, 0x10, 0xD0, 0x07, 0xD0, 0x06, 0x12, 0xBA, 0x2C, 0x12, 0xBA, 0x7D, 0x12, 0x82, 0x11, 
+0xC0, 0x06, 0xC0, 0x07, 0x90, 0xAC, 0xB9, 0x12, 0x27, 0x54, 0x82, 0x14, 0x01, 0x19, 0xD0, 0x07, 
+0xD0, 0x06, 0x12, 0x37, 0x5D, 0x90, 0xA4, 0x98, 0xE0, 0x70, 0x1E, 0x12, 0xBA, 0x85, 0x90, 0xAC, 
+0xB9, 0xBF, 0x01, 0x09, 0x12, 0x27, 0x54, 0x28, 0x16, 0x15, 0x00, 0x80, 0x07, 0x12, 0x27, 0x54, 
+0x28, 0x16, 0x0C, 0xC0, 0x90, 0x44, 0xD1, 0x80, 0x1F, 0x12, 0xBA, 0x85, 0x90, 0xAC, 0xB9, 0xBF, 
+0x01, 0x0C, 0x12, 0x27, 0x54, 0x28, 0x16, 0x15, 0x00, 0x90, 0x44, 0xEF, 0x80, 0x0A, 0x12, 0x27, 
+0x54, 0x28, 0x16, 0x0C, 0xA0, 0x90, 0x44, 0xEF, 0x12, 0x82, 0x13, 0x12, 0x37, 0x5D, 0x90, 0xA5, 
+0x78, 0x12, 0x27, 0x54, 0x80, 0x00, 0x00, 0x00, 0x90, 0xA5, 0x7C, 0x12, 0x27, 0x54, 0x00, 0x00, 
+0x00, 0x00, 0x7F, 0x2C, 0x12, 0x86, 0x48, 0x12, 0x27, 0x54, 0x03, 0xFF, 0x80, 0x00, 0x90, 0xA4, 
+0xB4, 0x12, 0x48, 0x4D, 0x78, 0x0F, 0x12, 0x27, 0x35, 0xE4, 0xFF, 0xEE, 0x54, 0x80, 0xFE, 0xEC, 
+0x54, 0x03, 0xFC, 0x12, 0x92, 0xEE, 0x7F, 0x78, 0x7E, 0x09, 0x12, 0x86, 0x4A, 0x12, 0x27, 0x54, 
+0x00, 0x00, 0x07, 0xFF, 0x90, 0xA4, 0xB8, 0x12, 0x48, 0x4D, 0x12, 0x92, 0xFF, 0x12, 0x92, 0xEE, 
+0x7F, 0x78, 0x7E, 0x09, 0x12, 0x86, 0x4A, 0x12, 0x27, 0x54, 0x80, 0x00, 0x00, 0x00, 0x90, 0xA5, 
+0x7C, 0x12, 0x27, 0x54, 0x80, 0x00, 0x00, 0x00, 0x12, 0x86, 0x50, 0xE4, 0x90, 0xA4, 0x99, 0xF0, 
+0x90, 0xA4, 0x98, 0xE0, 0xFF, 0x7D, 0x01, 0x12, 0x82, 0x1B, 0x90, 0xA4, 0xE9, 0xEF, 0xF0, 0x90, 
+0xA5, 0x0C, 0x12, 0x93, 0x60, 0x90, 0xA4, 0xE5, 0xE0, 0xFB, 0x12, 0x92, 0xCF, 0x12, 0x93, 0x58, 
+0xEB, 0x75, 0xF0, 0x08, 0xA4, 0x12, 0x92, 0xF4, 0x12, 0x97, 0xD2, 0x90, 0xA4, 0xE5, 0xF1, 0xBD, 
+0x40, 0x02, 0x01, 0x9F, 0xEE, 0x04, 0xA3, 0xF0, 0x90, 0xA4, 0xE5, 0xF1, 0xB3, 0x40, 0x02, 0x01, 
+0x96, 0xEE, 0x51, 0xCF, 0x51, 0xDB, 0x51, 0xD3, 0x71, 0x18, 0x71, 0x51, 0x50, 0x70, 0x74, 0xFF, 
+0x7F, 0xFC, 0x71, 0x2E, 0x71, 0x11, 0x40, 0x66, 0x90, 0xA4, 0x9B, 0xE0, 0x75, 0xF0, 0x08, 0xA4, 
+0x51, 0xF4, 0x51, 0xDB, 0x51, 0xF4, 0x71, 0x35, 0x50, 0x54, 0x71, 0x07, 0x40, 0x50, 0x90, 0xA4, 
+0x9B, 0xE0, 0x51, 0xCF, 0x31, 0xE6, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0x51, 0xE0, 
+0x51, 0xD3, 0x31, 0xE6, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0x51, 0xFC, 0x90, 0xA4, 
+0xDC, 0x12, 0x27, 0x48, 0x90, 0xA4, 0x9B, 0x31, 0xDA, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 
+0x07, 0x90, 0xA4, 0x9A, 0x31, 0xDA, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0x51, 0xFC, 
+0x90, 0xA4, 0xE0, 0x12, 0x27, 0x48, 0x90, 0xA4, 0xE7, 0x74, 0x01, 0xF0, 0x80, 0x08, 0x90, 0xA4, 
+0x9B, 0xE0, 0x04, 0xF0, 0x01, 0x08, 0x90, 0xA4, 0x9A, 0xE0, 0x04, 0xF0, 0x02, 0x8F, 0xFB, 0x90, 
+0xA4, 0xE9, 0xE0, 0x60, 0x06, 0x90, 0xA4, 0xE5, 0xE0, 0x04, 0xF0, 0x90, 0xA4, 0xE7, 0xE0, 0x64, 
+0x01, 0x60, 0x07, 0xF1, 0xC7, 0x50, 0x03, 0x02, 0x8F, 0xD0, 0x90, 0xA4, 0xE7, 0xE0, 0xB4, 0x01, 
+0x13, 0x90, 0xA4, 0xDC, 0xF1, 0xA1, 0x90, 0xA4, 0xE0, 0x12, 0x48, 0x4D, 0x90, 0xA4, 0xEF, 0x12, 
+0x27, 0x48, 0x80, 0x14, 0x90, 0xA4, 0xEB, 0x12, 0x27, 0x54, 0x00, 0x00, 0x02, 0x00, 0x90, 0xA4, 
+0xEF, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0x00, 0x90, 0xA4, 0x98, 0xE0, 0xFF, 0xB1, 0x57, 0x12, 
+0x27, 0x54, 0x80, 0x00, 0x00, 0x00, 0x90, 0xA5, 0x7C, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0x00, 
+0x12, 0x86, 0x50, 0x31, 0xF0, 0xE4, 0x7B, 0x12, 0x7A, 0x01, 0xF9, 0xF8, 0xD3, 0x12, 0x47, 0x9A, 
+0x40, 0x2D, 0x31, 0xF0, 0xE4, 0x7B, 0xEE, 0x1A, 0xF8, 0xC3, 0x12, 0x47, 0x9A, 0x50, 0x20, 0x90, 
+0xA4, 0xEF, 0x31, 0xF3, 0xE4, 0x7B, 0x12, 0xF8, 0xD3, 0x12, 0x47, 0x9A, 0x50, 0x5F, 0x90, 0xA4, 
+0xEF, 0x31, 0xF3, 0xE4, 0x7B, 0xEE, 0x7A, 0x03, 0xF8, 0xC3, 0x12, 0x47, 0x9A, 0x40, 0x4E, 0x31, 
+0xFE, 0x24, 0xD5, 0xF5, 0x82, 0xE4, 0x34, 0x44, 0x12, 0x82, 0x11, 0xC0, 0x06, 0xC0, 0x07, 0x90, 
+0xA5, 0x78, 0x12, 0x27, 0x54, 0x00, 0x00, 0x03, 0xFF, 0x90, 0xA5, 0x7C, 0x12, 0x27, 0x54, 0x00, 
+0x00, 0x01, 0x00, 0xD0, 0x07, 0xD0, 0x06, 0x31, 0xFB, 0x24, 0xD5, 0xF5, 0x82, 0xE4, 0x34, 0x44, 
+0x12, 0x82, 0x11, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0xA5, 0x78, 0x12, 0x27, 0x54, 0x03, 0xFF, 0x00, 
+0x00, 0x90, 0xA5, 0x7C, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0x00, 0x80, 0x46, 0x31, 0xFE, 0x24, 
+0xD5, 0xF5, 0x82, 0xE4, 0x34, 0x44, 0x12, 0x82, 0x11, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0xA5, 0x78, 
+0x12, 0x27, 0x54, 0x00, 0x00, 0x03, 0xFF, 0x31, 0xF0, 0x51, 0xEE, 0xD0, 0x07, 0xD0, 0x06, 0x31, 
+0xFB, 0x24, 0xD5, 0xF5, 0x82, 0xE4, 0x34, 0x44, 0x12, 0x82, 0x11, 0xC0, 0x06, 0xC0, 0x07, 0x90, 
+0xA5, 0x78, 0x12, 0x27, 0x54, 0x03, 0xFF, 0x00, 0x00, 0x90, 0xA4, 0xEF, 0x12, 0x48, 0x4D, 0x78, 
+0x0F, 0x51, 0xEB, 0xD0, 0x07, 0xD0, 0x06, 0x02, 0x86, 0x54, 0xE0, 0x75, 0xF0, 0x08, 0xA4, 0x24, 
+0xC8, 0xF5, 0x82, 0xE4, 0x34, 0xA4, 0xF5, 0x83, 0x12, 0x48, 0x4D, 0x78, 0x16, 0x02, 0x47, 0xAB, 
+0x90, 0xA4, 0xEB, 0x12, 0x48, 0x4D, 0x78, 0x01, 0x02, 0x27, 0x22, 0x12, 0x86, 0x54, 0x90, 0xA4, 
+0xEA, 0xE0, 0x75, 0xF0, 0x1E, 0xA4, 0x22, 0xB1, 0x57, 0x12, 0x27, 0x54, 0x80, 0x00, 0x00, 0x00, 
+0x90, 0xA5, 0x7C, 0x12, 0x27, 0x54, 0x80, 0x00, 0x00, 0x00, 0x12, 0x86, 0x50, 0x31, 0xFE, 0x24, 
+0xD9, 0xF5, 0x82, 0xE4, 0x34, 0x44, 0x12, 0x82, 0x11, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0xAC, 0xB9, 
+0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0x80, 0xD0, 0x07, 0xD0, 0x06, 0x12, 0x37, 0x5D, 0x31, 0xFE, 
+0x24, 0xDB, 0xF5, 0x82, 0xE4, 0x34, 0x44, 0x12, 0x82, 0x11, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0xAC, 
+0xB9, 0x12, 0x27, 0x54, 0x20, 0x04, 0x00, 0x00, 0xD0, 0x07, 0xD0, 0x06, 0x12, 0x37, 0x5D, 0x31, 
+0xFE, 0x24, 0xDD, 0xF5, 0x82, 0xE4, 0x34, 0x44, 0x12, 0x82, 0x11, 0xC0, 0x06, 0xC0, 0x07, 0x90, 
+0xAC, 0xB9, 0x12, 0x27, 0x54, 0x20, 0x00, 0x00, 0x00, 0xD0, 0x07, 0xD0, 0x06, 0x12, 0x37, 0x5D, 
+0x31, 0xFE, 0x24, 0xDF, 0xF5, 0x82, 0xE4, 0x34, 0x44, 0x12, 0x82, 0x11, 0xC0, 0x06, 0xC0, 0x07, 
+0x90, 0xA5, 0x78, 0x12, 0x27, 0x54, 0x00, 0x00, 0x07, 0xFF, 0x90, 0xA4, 0xEF, 0x12, 0x48, 0x4D, 
+0x51, 0xEE, 0xD0, 0x07, 0xD0, 0x06, 0x31, 0xFB, 0x24, 0xE1, 0xF5, 0x82, 0xE4, 0x34, 0x44, 0x12, 
+0x82, 0x11, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0xA5, 0x78, 0x12, 0x27, 0x54, 0x00, 0x00, 0x07, 0xFF, 
+0x90, 0xA4, 0xEB, 0x12, 0x48, 0x4D, 0x51, 0xEE, 0xD0, 0x07, 0xD0, 0x06, 0x02, 0x86, 0x54, 0x75, 
+0xF0, 0x08, 0xA4, 0x24, 0xC4, 0xF5, 0x82, 0xE4, 0x34, 0xA4, 0x22, 0xF5, 0x83, 0x12, 0x48, 0x59, 
+0x90, 0xA4, 0x9A, 0xE0, 0x75, 0xF0, 0x08, 0xA4, 0x22, 0x78, 0x02, 0x12, 0x27, 0x35, 0x90, 0xA5, 
+0x7C, 0x02, 0x27, 0x48, 0x24, 0xC8, 0xF5, 0x82, 0xE4, 0x34, 0xA4, 0x22, 0x12, 0x47, 0x4F, 0xEE, 
+0x54, 0x07, 0xFE, 0xE4, 0xFD, 0xFC, 0x22, 0x74, 0xFF, 0x7F, 0xFC, 0xFE, 0xFD, 0xFC, 0x90, 0xA4, 
+0xC0, 0x12, 0x48, 0x59, 0xD3, 0x02, 0x47, 0x84, 0xF5, 0x83, 0x12, 0x48, 0x4D, 0x12, 0x47, 0x5C, 
+0x78, 0x15, 0x12, 0x47, 0xAB, 0x90, 0xA4, 0xBC, 0x12, 0x27, 0x48, 0xE4, 0x7F, 0x04, 0xFE, 0xFD, 
+0xFC, 0x90, 0xA4, 0xBC, 0x22, 0xF5, 0x83, 0x12, 0x48, 0x4D, 0x12, 0x47, 0x5C, 0x78, 0x15, 0x12, 
+0x47, 0xAB, 0x90, 0xA4, 0xC0, 0x12, 0x27, 0x48, 0xE4, 0x7F, 0x04, 0xFE, 0xFD, 0xFC, 0x90, 0xA4, 
+0xC0, 0x12, 0x48, 0x59, 0xC3, 0x02, 0x47, 0x84, 0xF5, 0x83, 0x12, 0x27, 0x48, 0x90, 0xA5, 0x10, 
+0x12, 0x48, 0x4D, 0x78, 0x05, 0x02, 0x27, 0x35, 0x90, 0xA5, 0xA3, 0xD1, 0xCA, 0x12, 0x27, 0x54, 
+0x00, 0x00, 0x00, 0x00, 0x7F, 0x34, 0x7E, 0x08, 0x12, 0x36, 0xCE, 0x90, 0xA5, 0xA5, 0x12, 0x27, 
+0x48, 0x90, 0xA5, 0xA3, 0xE0, 0x14, 0x60, 0x63, 0x14, 0x70, 0x02, 0x81, 0xAC, 0x24, 0x02, 0x60, 
+0x02, 0xA1, 0x3D, 0x90, 0xA5, 0x78, 0x12, 0x27, 0x54, 0x00, 0x30, 0x03, 0xC3, 0x90, 0xA5, 0x7C, 
+0x12, 0x27, 0x54, 0x00, 0x30, 0x02, 0x00, 0x7F, 0xAC, 0x12, 0x86, 0x48, 0x12, 0x27, 0x54, 0x40, 
+0x00, 0x00, 0x00, 0x90, 0xA5, 0x7C, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xC4, 0x12, 
+0x86, 0x48, 0x12, 0x27, 0x54, 0x00, 0x1C, 0x00, 0x00, 0x90, 0xA5, 0x7C, 0x12, 0x27, 0x54, 0x00, 
+0x10, 0x00, 0x00, 0x7F, 0x64, 0x12, 0x86, 0x48, 0x12, 0x27, 0x54, 0x03, 0xC0, 0x00, 0x00, 0x90, 
+0xA5, 0x7C, 0x12, 0x27, 0x54, 0x01, 0xC0, 0x00, 0x00, 0xA1, 0x1F, 0x90, 0xA5, 0x78, 0x12, 0x27, 
+0x54, 0x00, 0x30, 0x03, 0xC3, 0x90, 0xA5, 0x7C, 0x12, 0x27, 0x54, 0x00, 0x30, 0x02, 0x01, 0x7F, 
+0xAC, 0x12, 0x86, 0x48, 0x12, 0x27, 0x54, 0x40, 0x00, 0x00, 0x00, 0x90, 0xA5, 0x7C, 0x12, 0x27, 
+0x54, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xC4, 0x12, 0x86, 0x48, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 
+0x3C, 0x90, 0xA5, 0xA4, 0x12, 0x66, 0xFF, 0x51, 0xE9, 0x7F, 0xAC, 0x12, 0x86, 0x48, 0x12, 0x27, 
+0x54, 0xF0, 0x00, 0x00, 0x00, 0x12, 0x86, 0x32, 0x12, 0x27, 0x54, 0x00, 0x1C, 0x00, 0x00, 0x90, 
+0xA5, 0x7C, 0x12, 0x27, 0x54, 0x00, 0x08, 0x00, 0x00, 0xB1, 0x3E, 0x60, 0x13, 0x12, 0x27, 0x54, 
+0x03, 0xC0, 0x00, 0x00, 0x90, 0xA5, 0x7C, 0x12, 0x27, 0x54, 0x01, 0x80, 0x00, 0x00, 0x80, 0x11, 
+0x12, 0x27, 0x54, 0x03, 0xC0, 0x00, 0x00, 0x90, 0xA5, 0x7C, 0x12, 0x27, 0x54, 0x01, 0xC0, 0x00, 
+0x00, 0x7F, 0x48, 0x7E, 0x08, 0x12, 0x86, 0x54, 0x90, 0xA5, 0xA4, 0xE0, 0x90, 0xA5, 0x78, 0xB4, 
+0x01, 0x13, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0x10, 0x90, 0xA5, 0x7C, 0x12, 0x27, 0x54, 0x00, 
+0x00, 0x00, 0x10, 0x80, 0x11, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0x10, 0x90, 0xA5, 0x7C, 0x12, 
+0x27, 0x54, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x00, 0x7E, 0x0A, 0xA1, 0x3A, 0x90, 0xA5, 0x78, 0x12, 
+0x27, 0x54, 0x00, 0x30, 0x03, 0xC3, 0x90, 0xA5, 0x7C, 0x12, 0x27, 0x54, 0x00, 0x30, 0x02, 0x02, 
+0x7F, 0xAC, 0x12, 0x86, 0x48, 0x12, 0x27, 0x54, 0x40, 0x00, 0x00, 0x00, 0x90, 0xA5, 0x7C, 0x12, 
+0x27, 0x54, 0x40, 0x00, 0x00, 0x00, 0x7F, 0xC4, 0x12, 0x86, 0x48, 0x12, 0x27, 0x54, 0x00, 0x00, 
+0x00, 0x3C, 0x90, 0xA5, 0xA4, 0x12, 0x66, 0xFF, 0x51, 0xE9, 0x7F, 0xAC, 0x12, 0x86, 0x48, 0x12, 
+0x27, 0x54, 0xF0, 0x00, 0x00, 0x00, 0x12, 0x86, 0x32, 0x12, 0x27, 0x54, 0x00, 0x1C, 0x00, 0x00, 
+0x90, 0xA5, 0x7C, 0x12, 0x27, 0x54, 0x00, 0x08, 0x00, 0x00, 0xB1, 0x3E, 0x60, 0x17, 0x12, 0x27, 
+0x54, 0x03, 0xC0, 0x00, 0x00, 0x90, 0xA5, 0x7C, 0x12, 0x27, 0x54, 0x01, 0x40, 0x00, 0x00, 0x7F, 
+0x48, 0x7E, 0x08, 0x80, 0x15, 0x12, 0x27, 0x54, 0x03, 0xC0, 0x00, 0x00, 0x90, 0xA5, 0x7C, 0x12, 
+0x27, 0x54, 0x01, 0x80, 0x00, 0x00, 0x7F, 0x48, 0x7E, 0x08, 0x12, 0x86, 0x54, 0x22, 0x7F, 0x64, 
+0x7E, 0x08, 0x12, 0x86, 0x54, 0x90, 0xA5, 0xA5, 0x12, 0x48, 0x4D, 0xE4, 0xFF, 0xFE, 0xFD, 0xEC, 
+0x54, 0x04, 0xFC, 0x90, 0xA5, 0x78, 0x22, 0x90, 0xA4, 0xEA, 0xEF, 0xF0, 0x90, 0xA5, 0x78, 0x22, 
+0xFE, 0x13, 0x13, 0x54, 0x07, 0xFB, 0x90, 0xA5, 0xD4, 0xD1, 0xCA, 0xEB, 0xF0, 0xE4, 0xFE, 0x7D, 
+0x18, 0xFF, 0x12, 0x3A, 0xA9, 0x90, 0xA5, 0xD7, 0xEF, 0xF0, 0x90, 0xA5, 0xD4, 0xE0, 0xFF, 0x12, 
+0xB6, 0x87, 0x90, 0xA5, 0xD4, 0xF1, 0xAA, 0x12, 0xB6, 0xDE, 0xAE, 0x07, 0x90, 0x04, 0x83, 0xEE, 
+0xF0, 0x90, 0xA5, 0xD4, 0xE0, 0xFF, 0xAD, 0x06, 0x71, 0x68, 0x90, 0xA5, 0xD7, 0xE0, 0xFF, 0x90, 
+0xA5, 0xD4, 0xE0, 0xFD, 0x12, 0xB2, 0xA0, 0x90, 0xA5, 0xD4, 0xE0, 0xFF, 0xD3, 0x10, 0xAF, 0x01, 
+0xC3, 0xC0, 0xD0, 0xEF, 0x14, 0x60, 0x30, 0x14, 0x60, 0x56, 0x24, 0x02, 0x70, 0x7D, 0x90, 0xA5, 
+0x66, 0x12, 0x27, 0x54, 0x00, 0x00, 0x0C, 0x00, 0x90, 0xA5, 0x6A, 0x12, 0x27, 0x54, 0x00, 0x00, 
+0x0C, 0x00, 0xD1, 0x46, 0x12, 0x27, 0x54, 0x00, 0x00, 0x0C, 0x00, 0x90, 0xA5, 0x6A, 0x12, 0x27, 
+0x54, 0x00, 0x00, 0x0C, 0x00, 0x80, 0x50, 0x90, 0xA5, 0x66, 0x12, 0x27, 0x54, 0x00, 0x00, 0x0C, 
+0x00, 0x90, 0xA5, 0x6A, 0x12, 0x27, 0x54, 0x00, 0x00, 0x04, 0x00, 0xD1, 0x46, 0x12, 0x27, 0x54, 
+0x00, 0x00, 0x0C, 0x00, 0x90, 0xA5, 0x6A, 0x12, 0x27, 0x54, 0x00, 0x00, 0x04, 0x00, 0x80, 0x27, 
+0x90, 0xA5, 0x66, 0x12, 0x27, 0x54, 0x00, 0x00, 0x0C, 0x00, 0x90, 0xA5, 0x6A, 0x12, 0x27, 0x54, 
+0x00, 0x00, 0x00, 0x00, 0xD1, 0x46, 0x12, 0x27, 0x54, 0x00, 0x00, 0x0C, 0x00, 0x90, 0xA5, 0x6A, 
+0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0x00, 0xF1, 0x9A, 0xD1, 0x52, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 
+0x90, 0xA5, 0x6A, 0x12, 0x27, 0x48, 0x7D, 0x18, 0x7C, 0x00, 0xE4, 0xFF, 0xD1, 0x52, 0x90, 0xA5, 
+0x66, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0xA5, 0x64, 0xEC, 0xF0, 0xA3, 0xED, 
+0xF0, 0x90, 0xA5, 0x63, 0xEF, 0xF0, 0xA3, 0xA3, 0xE0, 0xFD, 0x12, 0x87, 0xE1, 0x90, 0xA5, 0x6E, 
+0x12, 0x27, 0x48, 0x90, 0xA5, 0x66, 0x12, 0x48, 0x4D, 0x12, 0x27, 0x15, 0x90, 0xA5, 0x6E, 0x12, 
+0x87, 0x9D, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0xA5, 0x66, 0x12, 0x48, 0x4D, 
+0x90, 0xA5, 0x6A, 0x12, 0x87, 0x9D, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0x12, 0x47, 
+0x77, 0x90, 0xA5, 0x72, 0x12, 0x27, 0x48, 0x90, 0xA5, 0x64, 0xA3, 0xE0, 0xFD, 0xC0, 0x05, 0x90, 
+0xA5, 0x72, 0x12, 0x48, 0x4D, 0x90, 0xAC, 0x96, 0x12, 0x27, 0x48, 0x90, 0xA5, 0x63, 0xE0, 0xFF, 
+0xD0, 0x05, 0x12, 0x39, 0xBA, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xEF, 0xF0, 0xA3, 0xED, 0xF0, 0xA3, 
+0x22, 0x90, 0xA4, 0x3C, 0x74, 0x12, 0xF0, 0x90, 0xA4, 0x4A, 0x74, 0x05, 0xF0, 0x90, 0xA4, 0x3E, 
+0xD1, 0xCA, 0xEB, 0xF0, 0x90, 0xA4, 0x3A, 0xE0, 0x90, 0xA4, 0x41, 0xF0, 0x90, 0xA4, 0x3B, 0xE0, 
+0x90, 0xA4, 0x42, 0xF0, 0x7B, 0x01, 0x7A, 0xA4, 0x79, 0x3C, 0xF1, 0x1F, 0x7F, 0x04, 0x80, 0x04, 
+0xF1, 0x1F, 0x7F, 0x04, 0x90, 0xA5, 0xFB, 0xEF, 0xF0, 0x7F, 0x02, 0x12, 0x4B, 0x3C, 0x90, 0xA1, 
+0x76, 0xE0, 0xFF, 0x90, 0xA5, 0xFB, 0xE0, 0xFE, 0xEF, 0x4E, 0x90, 0xA1, 0x76, 0xF0, 0x22, 0xD3, 
+0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0xA2, 0x6C, 0xE0, 0xFF, 0x70, 0x06, 0xA3, 0xE0, 0x64, 
+0x09, 0x60, 0x0A, 0xEF, 0x14, 0xFF, 0x90, 0xA2, 0x6D, 0xE0, 0xB5, 0x07, 0x04, 0x7F, 0x01, 0x80, 
+0x02, 0x7F, 0x00, 0xEF, 0x60, 0x09, 0x90, 0x01, 0xC1, 0xE0, 0x44, 0x02, 0xF0, 0x80, 0x29, 0xC0, 
+0x01, 0x90, 0xA2, 0x6D, 0xE0, 0xF1, 0xDD, 0xA8, 0x01, 0xFC, 0x7D, 0x01, 0xD0, 0x01, 0x7E, 0x00, 
+0x7F, 0x0F, 0x12, 0x46, 0xB0, 0x90, 0xA2, 0x6D, 0x12, 0x77, 0xC5, 0xB4, 0x0A, 0x02, 0x7F, 0x01, 
+0xEF, 0x60, 0x05, 0xE4, 0x90, 0xA2, 0x6D, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0xA4, 0x31, 
+0x74, 0x11, 0xF0, 0x90, 0xA4, 0x3F, 0x74, 0x01, 0xF0, 0x90, 0xA4, 0x33, 0xEF, 0xF0, 0x7B, 0x01, 
+0x7A, 0xA4, 0x79, 0x31, 0xF1, 0x1F, 0x7F, 0x04, 0xE1, 0x04, 0x7D, 0x18, 0x7C, 0x00, 0x7F, 0x01, 
+0x22, 0x12, 0x48, 0x4D, 0x90, 0xA4, 0xEB, 0x02, 0x27, 0x48, 0xE0, 0xFF, 0xA3, 0xE0, 0xFD, 0xA3, 
+0xE0, 0xFB, 0x22, 0xE0, 0xFF, 0x90, 0xA4, 0x9B, 0xE0, 0xFE, 0xD3, 0x9F, 0x22, 0xE0, 0xFF, 0x90, 
+0xA4, 0x9A, 0xE0, 0xFE, 0xD3, 0x9F, 0x22, 0x90, 0xA4, 0x99, 0xE0, 0x04, 0xF0, 0xE0, 0xC3, 0x94, 
+0x03, 0x22, 0xF5, 0x83, 0x12, 0x27, 0x48, 0xE4, 0x90, 0xA4, 0x9A, 0xF0, 0x22, 0x75, 0xF0, 0x0F, 
+0xA4, 0x24, 0xD6, 0xF9, 0x74, 0xA1, 0x35, 0xF0, 0x22, 0xC0, 0xE0, 0xC0, 0xF0, 0xC0, 0x83, 0xC0, 
+0x82, 0xC0, 0xD0, 0x75, 0xD0, 0x00, 0xC0, 0x00, 0xC0, 0x01, 0xC0, 0x02, 0xC0, 0x03, 0xC0, 0x04, 
+0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0x01, 0xC4, 0x74, 0xE9, 0xF0, 0x74, 0x97, 0xA3, 0xF0, 
+0x11, 0x38, 0x74, 0xE9, 0x04, 0x90, 0x01, 0xC4, 0xF0, 0x74, 0x97, 0xA3, 0xF0, 0xD0, 0x07, 0xD0, 
+0x06, 0xD0, 0x05, 0xD0, 0x04, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 
+0x82, 0xD0, 0x83, 0xD0, 0xF0, 0xD0, 0xE0, 0x32, 0x7B, 0x00, 0x7A, 0x00, 0x79, 0x53, 0xE4, 0xFD, 
+0x7F, 0x01, 0x12, 0x39, 0x33, 0xE5, 0x51, 0x52, 0x53, 0x7B, 0x00, 0x7A, 0x00, 0x79, 0x54, 0x7D, 
+0x01, 0x7F, 0x01, 0x12, 0x39, 0x33, 0xE5, 0x52, 0x52, 0x54, 0xAB, 0x53, 0xE4, 0xFD, 0x7F, 0x01, 
+0x12, 0x39, 0x04, 0xAB, 0x54, 0x7D, 0x01, 0x7F, 0x01, 0x02, 0x39, 0x04, 0xC0, 0xE0, 0xC0, 0xF0, 
+0xC0, 0x83, 0xC0, 0x82, 0xC0, 0xD0, 0x75, 0xD0, 0x00, 0xC0, 0x00, 0xC0, 0x01, 0xC0, 0x02, 0xC0, 
+0x03, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0x01, 0xC4, 0x74, 0x6C, 0xF0, 0x74, 
+0x98, 0xA3, 0xF0, 0x11, 0xDF, 0xE5, 0x5C, 0x30, 0xE7, 0x02, 0x11, 0xC2, 0x74, 0x6C, 0x04, 0x90, 
+0x01, 0xC4, 0xF0, 0x74, 0x98, 0xA3, 0xF0, 0xD0, 0x07, 0xD0, 0x06, 0xD0, 0x05, 0xD0, 0x04, 0xD0, 
+0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x82, 0xD0, 0x83, 0xD0, 0xF0, 0xD0, 
+0xE0, 0x32, 0x11, 0xD8, 0x90, 0x00, 0xF2, 0xE0, 0x20, 0xE6, 0x0C, 0x90, 0x00, 0x05, 0xE0, 0x44, 
+0x80, 0xFD, 0x7F, 0x05, 0x12, 0x3A, 0x96, 0x22, 0x7F, 0x01, 0x7E, 0x00, 0x02, 0x3A, 0x69, 0x90, 
+0x00, 0x54, 0xE0, 0x55, 0x55, 0xF5, 0x59, 0xA3, 0xE0, 0x55, 0x56, 0xF5, 0x5A, 0xA3, 0xE0, 0x55, 
+0x57, 0xF5, 0x5B, 0xA3, 0xE0, 0x55, 0x58, 0xF5, 0x5C, 0xAD, 0x59, 0x7F, 0x54, 0x12, 0x3A, 0x96, 
+0xAD, 0x5A, 0x7F, 0x55, 0x12, 0x3A, 0x96, 0xAD, 0x5B, 0x7F, 0x56, 0x12, 0x3A, 0x96, 0xAD, 0x5C, 
+0x7F, 0x57, 0x12, 0x3A, 0x96, 0x53, 0x91, 0xEF, 0x22, 0xC0, 0xE0, 0xC0, 0xF0, 0xC0, 0x83, 0xC0, 
+0x82, 0xC0, 0xD0, 0x75, 0xD0, 0x00, 0xC0, 0x00, 0xC0, 0x01, 0xC0, 0x02, 0xC0, 0x03, 0xC0, 0x04, 
+0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0x01, 0xC4, 0x74, 0x19, 0xF0, 0x74, 0x99, 0xA3, 0xF0, 
+0x12, 0xA8, 0xAB, 0xE5, 0x61, 0x30, 0xE1, 0x02, 0x51, 0x3D, 0xE5, 0x61, 0x30, 0xE4, 0x03, 0x12, 
+0x77, 0xD3, 0xE5, 0x61, 0x30, 0xE5, 0x03, 0x12, 0xA9, 0x08, 0xE5, 0x61, 0x30, 0xE6, 0x03, 0x12, 
+0xA9, 0x44, 0xE5, 0x63, 0x30, 0xE0, 0x03, 0x12, 0xA9, 0x51, 0xE5, 0x63, 0x30, 0xE1, 0x02, 0x91, 
+0x40, 0xE5, 0x63, 0x30, 0xE2, 0x03, 0x12, 0xA9, 0x6C, 0xE5, 0x63, 0x30, 0xE3, 0x03, 0x12, 0x67, 
+0x51, 0xE5, 0x63, 0x30, 0xE4, 0x03, 0x12, 0x67, 0x0F, 0xE5, 0x63, 0x30, 0xE5, 0x03, 0x12, 0x79, 
+0x78, 0xE5, 0x63, 0x30, 0xE6, 0x03, 0x12, 0x7F, 0xA6, 0xE5, 0x64, 0x30, 0xE1, 0x03, 0x12, 0xA9, 
+0x8F, 0xE5, 0x64, 0x30, 0xE4, 0x02, 0x51, 0xBF, 0xE5, 0x64, 0x30, 0xE5, 0x02, 0x91, 0xA4, 0xE5, 
+0x64, 0x30, 0xE6, 0x02, 0x31, 0xDC, 0x74, 0x19, 0x04, 0x90, 0x01, 0xC4, 0xF0, 0x74, 0x99, 0xA3, 
+0xF0, 0xD0, 0x07, 0xD0, 0x06, 0xD0, 0x05, 0xD0, 0x04, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 
+0x00, 0xD0, 0xD0, 0xD0, 0x82, 0xD0, 0x83, 0xD0, 0xF0, 0xD0, 0xE0, 0x32, 0x90, 0x07, 0x1F, 0xE0, 
+0x54, 0x7F, 0xF0, 0x90, 0x07, 0x1C, 0xE0, 0x54, 0x01, 0xFF, 0x60, 0x2F, 0x90, 0xA4, 0x1D, 0xE0, 
+0x60, 0x29, 0x90, 0xA4, 0x1A, 0xE0, 0x54, 0x03, 0x14, 0x60, 0x10, 0x14, 0x60, 0x16, 0x24, 0x02, 
+0x70, 0x19, 0x90, 0x04, 0x2D, 0xE0, 0x44, 0x02, 0xF0, 0x80, 0x10, 0x90, 0x04, 0x2D, 0xE0, 0x44, 
+0x06, 0xF0, 0x80, 0x07, 0x90, 0x04, 0x2D, 0xE0, 0x44, 0x0E, 0xF0, 0xE4, 0x90, 0xA4, 0x1D, 0xF0, 
+0x90, 0xA4, 0xFA, 0xEF, 0xF0, 0x90, 0xA4, 0xF8, 0x74, 0x02, 0xF0, 0x90, 0xA5, 0x06, 0x14, 0xF0, 
+0xFB, 0x7A, 0xA4, 0x79, 0xF8, 0x12, 0x97, 0x1F, 0x7F, 0x04, 0x02, 0x97, 0x04, 0xE4, 0xFF, 0x90, 
+0xA4, 0xF8, 0xEF, 0xF0, 0x90, 0x04, 0x7E, 0xE0, 0xF5, 0x21, 0xA3, 0xE0, 0xF5, 0x22, 0x65, 0x21, 
+0x60, 0x6C, 0x90, 0xA4, 0xF9, 0x74, 0x03, 0xF0, 0x90, 0xA5, 0x07, 0x74, 0x08, 0xF0, 0xE5, 0x22, 
+0x04, 0x54, 0x0F, 0xF5, 0x23, 0xE4, 0xF5, 0x20, 0xE5, 0x23, 0x75, 0xF0, 0x08, 0xA4, 0x24, 0x00, 
+0xF5, 0x82, 0xE4, 0x34, 0x80, 0xF5, 0x83, 0xE5, 0x82, 0x25, 0x20, 0x12, 0x72, 0x2A, 0xE0, 0xFF, 
+0x74, 0xFB, 0x25, 0x20, 0xF5, 0x82, 0xE4, 0x34, 0xA4, 0xF5, 0x83, 0xEF, 0xF0, 0x05, 0x20, 0xE5, 
+0x20, 0xB4, 0x08, 0xD4, 0x7B, 0x01, 0x7A, 0xA4, 0x79, 0xF9, 0x12, 0x97, 0x1F, 0xE5, 0x22, 0x04, 
+0x54, 0x0F, 0xF5, 0x22, 0xB4, 0x0F, 0x03, 0xE4, 0xF5, 0x22, 0x90, 0x04, 0x7F, 0xE5, 0x22, 0xF0, 
+0x90, 0xA4, 0xF8, 0xE0, 0x7F, 0x04, 0x70, 0x03, 0x02, 0x77, 0xD7, 0x12, 0x97, 0x04, 0x22, 0xE4, 
+0xFF, 0x90, 0xA5, 0x3A, 0xEF, 0xF0, 0x7E, 0x00, 0x7F, 0x10, 0x7D, 0x00, 0x7B, 0x01, 0x7A, 0xA5, 
+0x79, 0x3C, 0x12, 0x48, 0xA9, 0x90, 0xA2, 0x81, 0xE0, 0x90, 0xA5, 0x4E, 0xF0, 0xE4, 0x90, 0xA5, 
+0x3B, 0xF0, 0x90, 0xA5, 0x4E, 0xE0, 0xFE, 0x90, 0xA5, 0x3B, 0xE0, 0xFD, 0xC3, 0x9E, 0x50, 0x43, 
+0xED, 0x91, 0x10, 0xED, 0x54, 0x07, 0xA3, 0xF0, 0x75, 0xF0, 0x10, 0xED, 0x12, 0x76, 0xAD, 0xE0, 
+0x30, 0xE7, 0x09, 0x74, 0x81, 0x2D, 0x71, 0xF6, 0xE4, 0xF0, 0x80, 0x1F, 0xAF, 0x05, 0x12, 0x77, 
+0xE6, 0x91, 0x26, 0xC0, 0x83, 0xC0, 0x82, 0xE0, 0xFF, 0x90, 0xA5, 0x4D, 0x12, 0x76, 0x09, 0x80, 
+0x02, 0xC3, 0x33, 0xD8, 0xFC, 0x4F, 0xD0, 0x82, 0xD0, 0x83, 0xF0, 0x90, 0xA5, 0x3B, 0xE0, 0x04, 
+0xF0, 0x80, 0xAF, 0x7F, 0x0C, 0x7E, 0x00, 0x12, 0x3A, 0xF7, 0xE4, 0x90, 0xA5, 0x3B, 0xF0, 0x90, 
+0xA5, 0x4E, 0xE0, 0xFF, 0x90, 0xA5, 0x3B, 0xE0, 0xFE, 0xC3, 0x9F, 0x40, 0x02, 0x61, 0xF5, 0xEE, 
+0x91, 0x10, 0xEE, 0x54, 0x07, 0xA3, 0xF0, 0xE0, 0x91, 0xB0, 0x80, 0x05, 0xC3, 0x33, 0xCE, 0x33, 
+0xCE, 0xD8, 0xF9, 0x4E, 0x7F, 0x00, 0x70, 0x02, 0x7F, 0x01, 0x91, 0x26, 0xE0, 0x5F, 0x70, 0x7D, 
+0x71, 0xFE, 0x90, 0x81, 0x06, 0x91, 0x07, 0xEF, 0x90, 0x81, 0x07, 0x91, 0x1A, 0xFC, 0x91, 0x34, 
+0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x75, 0xF0, 0x10, 0xEC, 0x90, 0x81, 0x0A, 0x91, 0x07, 0xEC, 0x90, 
+0x81, 0x0B, 0x91, 0x1A, 0x75, 0xF0, 0x0A, 0x12, 0x77, 0xBF, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x7F, 
+0x01, 0x90, 0xA5, 0x3B, 0xE0, 0xFE, 0x75, 0xF0, 0x10, 0x90, 0x81, 0x0B, 0x12, 0x72, 0x24, 0xE0, 
+0xFD, 0x75, 0xF0, 0x0A, 0xEE, 0x12, 0x77, 0xBF, 0x75, 0xF0, 0x02, 0xEF, 0x12, 0x77, 0x7B, 0xED, 
+0xF0, 0x0F, 0xEF, 0xB4, 0x05, 0xDB, 0x71, 0xFE, 0x90, 0x81, 0x09, 0x12, 0x48, 0x65, 0xE0, 0xFE, 
+0x12, 0x77, 0xB4, 0xEE, 0xF0, 0x90, 0xA5, 0x3B, 0xE0, 0xFF, 0x90, 0xA5, 0x3A, 0xE0, 0xFD, 0x12, 
+0x76, 0x61, 0x90, 0xA5, 0x3B, 0xE0, 0x24, 0x81, 0x71, 0xF6, 0x74, 0x01, 0xF0, 0x90, 0xA5, 0x3B, 
+0xE0, 0x04, 0xF0, 0x61, 0x3F, 0x22, 0xF5, 0x82, 0xE4, 0x34, 0x93, 0xF5, 0x83, 0x22, 0x90, 0xA5, 
+0x3B, 0xE0, 0xFF, 0x75, 0xF0, 0x10, 0x22, 0x12, 0x48, 0x65, 0xE0, 0xFD, 0x75, 0xF0, 0x10, 0x22, 
+0x13, 0x13, 0x13, 0x54, 0x1F, 0x90, 0xA5, 0x4C, 0xF0, 0x22, 0x12, 0x48, 0x65, 0xE0, 0xFE, 0xED, 
+0xFF, 0x90, 0xA5, 0x3B, 0xE0, 0x22, 0x90, 0xA5, 0x4C, 0xE0, 0x24, 0x3C, 0xF5, 0x82, 0xE4, 0x34, 
+0xA5, 0xF5, 0x83, 0x22, 0x25, 0xE0, 0x24, 0x01, 0xF5, 0x82, 0xE4, 0x34, 0x92, 0xF5, 0x83, 0x22, 
+0x90, 0xA2, 0x83, 0xE0, 0x30, 0xE0, 0x06, 0x90, 0xA2, 0x85, 0x74, 0x01, 0xF0, 0x90, 0xA2, 0x8C, 
+0xE0, 0x60, 0x4C, 0x90, 0xA2, 0x88, 0xE0, 0x30, 0xE0, 0x19, 0x90, 0xA2, 0xA3, 0xE0, 0x04, 0xF0, 
+0x12, 0xBA, 0xF7, 0xCE, 0xC3, 0x13, 0xCE, 0x13, 0xD8, 0xF9, 0xFF, 0x90, 0xA2, 0xC3, 0xEE, 0xF0, 
+0xA3, 0xEF, 0xF0, 0x90, 0xA2, 0x89, 0x12, 0x7F, 0x7D, 0x30, 0xE0, 0x0C, 0x90, 0x01, 0x3B, 0xE0, 
+0x30, 0xE4, 0x05, 0x12, 0x63, 0x57, 0x91, 0xA7, 0x90, 0xA5, 0xFD, 0xE0, 0x04, 0xF0, 0xE0, 0xC3, 
+0x94, 0x80, 0x40, 0x0B, 0x90, 0x01, 0x98, 0xE0, 0x54, 0xFE, 0xF0, 0xE0, 0x44, 0x01, 0xF0, 0x7F, 
+0x01, 0x02, 0x77, 0xD7, 0x02, 0x6E, 0xA5, 0x7D, 0x01, 0x7F, 0x02, 0x02, 0x63, 0x5B, 0x54, 0x07, 
+0xFF, 0x74, 0x01, 0x7E, 0x00, 0xA8, 0x07, 0x08, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 
+0x7D, 0x10, 0xED, 0x14, 0xF9, 0x24, 0x71, 0xB1, 0x0E, 0xE0, 0x60, 0x36, 0x7C, 0x08, 0xEC, 0x14, 
+0x90, 0xA5, 0xFC, 0xF0, 0x74, 0x71, 0x29, 0xB1, 0x0E, 0xE0, 0xFB, 0x7A, 0x00, 0x90, 0xA5, 0xFC, 
+0xE0, 0x91, 0xB0, 0x80, 0x05, 0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 0xF9, 0x12, 0x5F, 0xDD, 0x60, 
+0x0F, 0xE9, 0x75, 0xF0, 0x08, 0xA4, 0xFF, 0x90, 0xA5, 0xFC, 0xE0, 0x2F, 0x04, 0xFF, 0x80, 0x06, 
+0xDC, 0xCC, 0xDD, 0xBE, 0x7F, 0x00, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x74, 0x71, 0x2E, 0xF5, 0x82, 
+0xE4, 0x34, 0xA2, 0xF5, 0x83, 0x22, 0x12, 0xBB, 0x70, 0xED, 0x70, 0x12, 0xB1, 0x0B, 0xC0, 0x83, 
+0xC0, 0x82, 0xB1, 0x4A, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0xF4, 0x5E, 0x80, 0x0F, 0xB1, 0x0B, 
+0xC0, 0x83, 0xC0, 0x82, 0xB1, 0x4A, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0x4E, 0xD0, 0x82, 0xD0, 
+0x83, 0xF0, 0x91, 0xB9, 0x90, 0xA2, 0x81, 0xEF, 0xF0, 0x22, 0xE0, 0xFE, 0x74, 0x01, 0xA8, 0x07, 
+0x08, 0x22, 0x12, 0x7F, 0x60, 0x12, 0x4F, 0xBD, 0xFF, 0xF5, 0x11, 0x12, 0x26, 0x1E, 0xFE, 0xC3, 
+0x13, 0x30, 0xE0, 0x07, 0x12, 0x4F, 0xB6, 0xF5, 0x12, 0x80, 0x02, 0x8F, 0x12, 0x85, 0x11, 0x10, 
+0xE5, 0x10, 0xD3, 0x95, 0x12, 0x50, 0x1F, 0xF1, 0xD5, 0x54, 0x01, 0xFD, 0xAF, 0x10, 0xB1, 0x16, 
+0xAF, 0x10, 0x12, 0x64, 0xFB, 0xEF, 0xAF, 0x10, 0x70, 0x05, 0x12, 0x77, 0xCC, 0x80, 0x03, 0x12, 
+0x77, 0x8C, 0x05, 0x10, 0x80, 0xDA, 0xE5, 0x11, 0x70, 0x0D, 0xFF, 0x12, 0x64, 0xFB, 0xEF, 0x70, 
+0x06, 0x12, 0x67, 0x9D, 0x54, 0x7F, 0xF0, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 
+0xA2, 0x9A, 0x12, 0x80, 0x65, 0x7F, 0xB0, 0x7E, 0x0C, 0x12, 0x37, 0x5D, 0x90, 0xA2, 0x9A, 0x12, 
+0x80, 0x65, 0x7F, 0xB0, 0x7E, 0x0E, 0x12, 0x37, 0x5D, 0x90, 0x00, 0x10, 0xE0, 0x44, 0x0C, 0xFD, 
+0x7F, 0x10, 0x12, 0x3A, 0x96, 0x90, 0x00, 0x72, 0xE0, 0x54, 0xF3, 0xFD, 0x7F, 0x72, 0x12, 0x3A, 
+0x96, 0x90, 0x01, 0x01, 0xE0, 0x44, 0x02, 0xF0, 0x90, 0x01, 0x00, 0x74, 0xFF, 0xF0, 0x90, 0x06, 
+0xB7, 0x74, 0x09, 0xF0, 0x90, 0x06, 0xB4, 0x74, 0x86, 0xF0, 0xF1, 0x8F, 0x54, 0xBF, 0xD1, 0x46, 
+0x12, 0x80, 0x65, 0xF1, 0x88, 0x90, 0x00, 0x02, 0xE0, 0x44, 0x01, 0xFD, 0x7F, 0x02, 0x12, 0x3A, 
+0x96, 0x7F, 0x00, 0x7E, 0x0C, 0xD1, 0x40, 0x12, 0x80, 0x65, 0xF1, 0xA2, 0xD1, 0x40, 0x12, 0x80, 
+0x65, 0x7F, 0x00, 0xF1, 0x98, 0x70, 0x14, 0xD1, 0x96, 0xE0, 0x54, 0xE7, 0xD1, 0xA6, 0xD1, 0x96, 
+0xE0, 0x54, 0x18, 0x70, 0x06, 0x90, 0x01, 0xBF, 0xE0, 0x04, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 
+0x12, 0x36, 0xCE, 0xEF, 0x44, 0x03, 0xFF, 0xEC, 0x90, 0xA5, 0xA9, 0x12, 0x27, 0x48, 0x90, 0xA5, 
+0xA9, 0x22, 0x90, 0xA5, 0xC4, 0x12, 0x48, 0x7A, 0xEF, 0x70, 0x07, 0x90, 0xA5, 0xC7, 0x04, 0xF0, 
+0x80, 0x0B, 0xEF, 0x64, 0x01, 0x70, 0x25, 0x90, 0xA5, 0xC7, 0x74, 0x40, 0xF0, 0x7F, 0xE2, 0x12, 
+0x3A, 0x96, 0x90, 0xA5, 0xC7, 0xE0, 0xD1, 0xE9, 0x90, 0x00, 0xE1, 0xE0, 0xFF, 0x90, 0xA5, 0xC4, 
+0x12, 0x48, 0x71, 0xEF, 0x12, 0x26, 0x64, 0xD1, 0xE8, 0x7F, 0x01, 0x22, 0x90, 0x01, 0xC2, 0xE0, 
+0x44, 0x01, 0xF0, 0x7F, 0x00, 0x22, 0x7B, 0x01, 0x7A, 0xA5, 0x79, 0xAD, 0x7D, 0x08, 0x7F, 0x01, 
+0xD1, 0x52, 0x90, 0xA5, 0xAD, 0x22, 0xFB, 0x7D, 0x08, 0x7F, 0x01, 0x90, 0xA5, 0xEF, 0xEB, 0xF0, 
+0xEF, 0x70, 0x06, 0xA3, 0x74, 0x03, 0xF0, 0x80, 0x0B, 0xEF, 0x64, 0x01, 0x70, 0x28, 0x90, 0xA5, 
+0xF0, 0x74, 0x42, 0xF0, 0x7F, 0xE2, 0x12, 0x3A, 0x96, 0x90, 0xA5, 0xEF, 0xE0, 0xFD, 0x7F, 0xE0, 
+0x12, 0x3A, 0x96, 0x90, 0xA5, 0xF0, 0xE0, 0xD1, 0xE9, 0x90, 0xA5, 0xF0, 0xE0, 0x54, 0xFD, 0xD1, 
+0xE9, 0xD1, 0xE8, 0x7F, 0x01, 0x22, 0x80, 0xA4, 0xE4, 0xFD, 0x7F, 0xE3, 0x02, 0x3A, 0x96, 0xD3, 
+0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x12, 0x56, 0x1E, 0x7F, 0x00, 0x7E, 0x0C, 0x12, 0x80, 0x54, 
+0xF1, 0xA2, 0x12, 0x80, 0x54, 0x7F, 0x00, 0x7E, 0x0E, 0x12, 0x37, 0x5D, 0x90, 0x00, 0x02, 0xE0, 
+0xF1, 0x6F, 0xF1, 0x6F, 0x54, 0xFE, 0xFD, 0x7F, 0x02, 0x12, 0x3A, 0x96, 0xF1, 0x8F, 0x44, 0x40, 
+0x12, 0x80, 0x5A, 0xF1, 0x88, 0x90, 0x01, 0x00, 0x74, 0x3F, 0xF0, 0xA3, 0xE0, 0x54, 0xFD, 0xF0, 
+0x90, 0x05, 0x53, 0xE0, 0x44, 0x20, 0x12, 0xBB, 0x64, 0x12, 0x27, 0x48, 0x90, 0xAC, 0xB9, 0x12, 
+0x27, 0x54, 0x77, 0x77, 0x77, 0x77, 0x12, 0x81, 0xCC, 0x12, 0x27, 0x54, 0x77, 0x77, 0x77, 0x77, 
+0x7F, 0xB0, 0xF1, 0x98, 0x70, 0x14, 0x7B, 0x01, 0x7A, 0xA5, 0x79, 0xAE, 0x7D, 0x08, 0x7F, 0x01, 
+0xD1, 0x52, 0x90, 0xA5, 0xAE, 0xE0, 0x44, 0x18, 0xD1, 0xA6, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x54, 
+0xFE, 0xFD, 0x7F, 0x02, 0x12, 0x3A, 0x96, 0x90, 0x00, 0x02, 0xE0, 0x44, 0x01, 0xFD, 0x7F, 0x02, 
+0x12, 0x3A, 0x96, 0x90, 0x00, 0x02, 0xE0, 0x22, 0x7F, 0xB4, 0x7E, 0x08, 0x02, 0x37, 0x5D, 0x7F, 
+0xB4, 0x7E, 0x08, 0x12, 0x36, 0xCE, 0xEF, 0x22, 0x7E, 0x0E, 0x12, 0x37, 0x5D, 0x90, 0x00, 0xFF, 
+0xE0, 0x22, 0x7F, 0x00, 0x7E, 0x0C, 0x12, 0x37, 0x5D, 0x7F, 0x00, 0x7E, 0x0E, 0x22, 0x02, 0x67, 
+0xE9, 0xE4, 0xFD, 0xFF, 0xA1, 0x16, 0xB1, 0xA8, 0x90, 0xA2, 0x86, 0x74, 0x03, 0xF0, 0x22, 0xF1, 
+0xCD, 0x7D, 0x23, 0x02, 0x67, 0xE4, 0xB1, 0xA8, 0x7D, 0x24, 0x02, 0x57, 0xF1, 0x90, 0x05, 0x27, 
+0xE0, 0x44, 0x40, 0xF0, 0x22, 0xAB, 0x0D, 0xAA, 0x0E, 0xA9, 0x0F, 0x02, 0x26, 0x1E, 0xC0, 0xE0, 
+0xC0, 0x83, 0xC0, 0x82, 0xC0, 0xD0, 0x75, 0xD0, 0x00, 0xC0, 0x05, 0xC0, 0x07, 0x7D, 0xDE, 0x90, 
+0x01, 0xC4, 0xED, 0xF0, 0x74, 0x9F, 0xFF, 0xA3, 0xF0, 0xED, 0x04, 0x90, 0x01, 0xC4, 0xF0, 0xA3, 
+0xEF, 0xF0, 0xD0, 0x07, 0xD0, 0x05, 0xD0, 0xD0, 0xD0, 0x82, 0xD0, 0x83, 0xD0, 0xE0, 0x32, 0x90, 
+0x04, 0x24, 0x11, 0x29, 0x90, 0xA3, 0x4B, 0x12, 0x4F, 0xBC, 0x25, 0x0D, 0x90, 0xA3, 0x59, 0x12, 
+0x4F, 0xB5, 0x25, 0x0D, 0x90, 0xA3, 0x67, 0xF0, 0x22, 0xE0, 0xF5, 0x0D, 0x12, 0x26, 0x1E, 0x25, 
+0x0D, 0x22, 0x12, 0x7F, 0x60, 0x12, 0x26, 0x1E, 0xC4, 0x54, 0x0F, 0xFF, 0xBF, 0x0F, 0x15, 0x90, 
+0xA3, 0x3C, 0xE0, 0x54, 0xFE, 0xF0, 0x12, 0x65, 0x52, 0x12, 0x9F, 0xD5, 0x54, 0x0F, 0xFF, 0x12, 
+0x54, 0x3A, 0x41, 0x21, 0xAB, 0x0D, 0xAA, 0x0E, 0xA9, 0x0F, 0x12, 0x4F, 0xBD, 0x31, 0xFC, 0x51, 
+0x17, 0xEF, 0x12, 0x4F, 0xB5, 0x54, 0x03, 0xFF, 0x75, 0xF0, 0x0E, 0xED, 0x12, 0x56, 0x12, 0x54, 
+0xFC, 0x12, 0x4F, 0xB4, 0x54, 0x1C, 0xFF, 0xEE, 0x54, 0x0F, 0xFE, 0x75, 0xF0, 0x0E, 0x12, 0x56, 
+0x12, 0x54, 0xE3, 0x12, 0x4F, 0xB4, 0x54, 0xE0, 0xFF, 0x75, 0xF0, 0x0E, 0xEE, 0x12, 0x56, 0x12, 
+0x54, 0x1F, 0x4F, 0xF0, 0x12, 0x5F, 0xB2, 0x31, 0xF4, 0xE4, 0xFB, 0x31, 0xED, 0xA9, 0x0F, 0x90, 
+0x00, 0x05, 0x12, 0x26, 0x37, 0x31, 0xF4, 0x7B, 0x01, 0x31, 0xED, 0xA9, 0x0F, 0x12, 0x5C, 0x33, 
+0x33, 0x33, 0x33, 0x54, 0xF8, 0x31, 0xFC, 0xFD, 0x75, 0xF0, 0x0E, 0x90, 0xA3, 0x48, 0x12, 0x48, 
+0x65, 0xEF, 0xF0, 0x12, 0x5C, 0x33, 0xC4, 0x13, 0x54, 0x07, 0xFF, 0x75, 0xF0, 0x0E, 0xED, 0x90, 
+0xA3, 0x49, 0x12, 0x48, 0x65, 0xEF, 0xF0, 0xEE, 0xC4, 0x54, 0x0F, 0xFF, 0x14, 0x6D, 0x70, 0x26, 
+0x90, 0xA3, 0x3D, 0xEF, 0xF0, 0x90, 0x00, 0x06, 0x12, 0x26, 0x37, 0x54, 0x0F, 0xC4, 0x54, 0xF0, 
+0xFF, 0x90, 0xA3, 0x3C, 0xE0, 0x54, 0x0F, 0x4F, 0xF0, 0x54, 0xF1, 0xF0, 0x44, 0x01, 0xF0, 0x7D, 
+0x20, 0xE4, 0xFF, 0x12, 0x63, 0x42, 0x22, 0x8F, 0x10, 0x8D, 0x11, 0xAE, 0x03, 0x74, 0x1F, 0xC3, 
+0x95, 0x10, 0x40, 0x0F, 0x90, 0xA4, 0x35, 0xEE, 0xF0, 0xAB, 0x11, 0xE4, 0xFD, 0x31, 0xE5, 0x24, 
+0xD4, 0x80, 0x40, 0x74, 0x3F, 0xC3, 0x95, 0x10, 0x40, 0x0F, 0x90, 0xA4, 0x35, 0xEE, 0xF0, 0xAB, 
+0x11, 0x7D, 0x20, 0x31, 0xE3, 0x24, 0x88, 0x80, 0x2A, 0x74, 0x5F, 0xC3, 0x95, 0x10, 0x40, 0x0F, 
+0x90, 0xA4, 0x35, 0xEE, 0xF0, 0xAB, 0x11, 0x7D, 0x40, 0x31, 0xE3, 0x24, 0xD0, 0x80, 0x14, 0x74, 
+0x7F, 0xC3, 0x95, 0x10, 0x40, 0x25, 0x90, 0xA4, 0x35, 0xEE, 0xF0, 0xAB, 0x11, 0x7D, 0x60, 0x31, 
+0xE3, 0x24, 0x84, 0xFD, 0xE4, 0x34, 0x04, 0xFC, 0x75, 0xF0, 0x0E, 0xE5, 0x11, 0x51, 0x11, 0x75, 
+0xF0, 0x03, 0xEE, 0x12, 0x48, 0x65, 0xEC, 0xF0, 0xA3, 0xED, 0xF0, 0x22, 0xC3, 0xEF, 0x9D, 0xF5, 
+0x12, 0xC3, 0x94, 0x08, 0x50, 0x1C, 0xE4, 0xF5, 0x13, 0x51, 0x04, 0xC0, 0x83, 0xC0, 0x82, 0x90, 
+0xA4, 0x35, 0xE0, 0xD0, 0x82, 0xD0, 0x83, 0x75, 0xF0, 0x03, 0x12, 0x48, 0x65, 0xE5, 0x12, 0xF0, 
+0x80, 0x3E, 0xE5, 0x12, 0xC3, 0x94, 0x10, 0x50, 0x09, 0x75, 0x13, 0x01, 0xE5, 0x12, 0x24, 0xF8, 
+0x80, 0x17, 0xE5, 0x12, 0xC3, 0x94, 0x18, 0x50, 0x09, 0x75, 0x13, 0x02, 0xE5, 0x12, 0x24, 0xF0, 
+0x80, 0x07, 0x75, 0x13, 0x03, 0xE5, 0x12, 0x24, 0xE8, 0xFF, 0x51, 0x04, 0xC0, 0x83, 0xC0, 0x82, 
+0x90, 0xA4, 0x35, 0xE0, 0xD0, 0x82, 0xD0, 0x83, 0x75, 0xF0, 0x03, 0x12, 0x48, 0x65, 0xEF, 0xF0, 
+0xAF, 0x13, 0x22, 0xAF, 0x10, 0x31, 0x7C, 0x90, 0xA4, 0x31, 0xEF, 0xF0, 0x22, 0x31, 0x07, 0xAB, 
+0x0D, 0xAA, 0x0E, 0x22, 0xFF, 0x12, 0x26, 0x1E, 0x54, 0x0F, 0xFD, 0x22, 0xFF, 0x12, 0x26, 0x1E, 
+0xFE, 0x54, 0x0F, 0x22, 0x75, 0xF0, 0x0E, 0xEB, 0x90, 0xA3, 0x43, 0x02, 0x48, 0x65, 0x75, 0xF0, 
+0x0E, 0x90, 0xA3, 0x41, 0x02, 0x48, 0x65, 0xFD, 0x75, 0xF0, 0x0E, 0x90, 0xA3, 0x3F, 0x02, 0x48, 
+0x65, 0x7E, 0x00, 0x7F, 0x2D, 0x7D, 0x00, 0x7B, 0x01, 0x7A, 0xA3, 0x79, 0x3C, 0x02, 0x48, 0xA9, 
+0x12, 0x26, 0x1E, 0xFF, 0x90, 0xA2, 0x70, 0xF0, 0xBF, 0x01, 0x07, 0x51, 0x43, 0xE4, 0x90, 0xA2, 
+0x70, 0xF0, 0x22, 0x7B, 0x01, 0x7A, 0xA4, 0x79, 0x31, 0x7F, 0xF5, 0x7E, 0x03, 0x12, 0x33, 0xC7, 
+0xBF, 0x01, 0x06, 0x90, 0xA4, 0x31, 0xE0, 0xA3, 0xF0, 0x7B, 0x01, 0x7A, 0xA4, 0x79, 0x31, 0x7F, 
+0xF6, 0x7E, 0x03, 0x12, 0x33, 0xC7, 0xBF, 0x01, 0x08, 0x90, 0xA4, 0x31, 0xE0, 0x90, 0xA4, 0x33, 
+0xF0, 0x7B, 0x01, 0x7A, 0xA4, 0x79, 0x31, 0x7F, 0xF4, 0x7E, 0x03, 0x12, 0x33, 0xC7, 0xBF, 0x01, 
+0x08, 0x90, 0xA4, 0x31, 0xE0, 0x90, 0xA4, 0x34, 0xF0, 0x7B, 0x01, 0x7A, 0xA4, 0x79, 0x31, 0x7F, 
+0xF3, 0x7E, 0x03, 0x12, 0x33, 0xC7, 0xBF, 0x01, 0x08, 0x90, 0xA4, 0x31, 0xE0, 0x90, 0xA4, 0x35, 
+0xF0, 0x7B, 0x01, 0x7A, 0xA4, 0x79, 0x31, 0x7F, 0xF2, 0x7E, 0x03, 0x12, 0x33, 0xC7, 0xBF, 0x01, 
+0x08, 0x90, 0xA4, 0x31, 0xE0, 0x90, 0xA4, 0x36, 0xF0, 0x90, 0xA4, 0x32, 0x12, 0x97, 0xAA, 0xA3, 
+0xE0, 0x90, 0xA4, 0x3A, 0xF0, 0x90, 0xA4, 0x36, 0xE0, 0x90, 0xA4, 0x3B, 0xF0, 0x02, 0x96, 0xD1, 
+0x12, 0x26, 0x1E, 0x54, 0x01, 0xFF, 0x90, 0xA4, 0x21, 0xE0, 0x54, 0xFE, 0x4F, 0xF0, 0x22, 0xD3, 
+0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0xA1, 0xD5, 0xE0, 0xFF, 0x90, 0xA1, 0xD4, 0xE0, 0xB5, 
+0x07, 0x04, 0x7F, 0x01, 0x80, 0x02, 0x7F, 0x00, 0xEF, 0x70, 0x3A, 0x90, 0xA1, 0xD4, 0xE0, 0xFE, 
+0x71, 0x3A, 0xE0, 0xFD, 0xEE, 0x75, 0xF0, 0x08, 0xA4, 0x24, 0x85, 0xF9, 0x74, 0xA1, 0x35, 0xF0, 
+0xFA, 0x7B, 0x01, 0xAF, 0x05, 0x12, 0x5A, 0xE6, 0x90, 0xA1, 0xD4, 0x12, 0x77, 0xC5, 0xB4, 0x0A, 
+0x02, 0x7F, 0x01, 0xEF, 0x60, 0x05, 0xE4, 0x90, 0xA1, 0xD4, 0xF0, 0x12, 0x74, 0xEF, 0x90, 0xA1, 
+0x76, 0xE0, 0x44, 0x02, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x75, 0xF0, 0x08, 0x90, 0xA1, 0x84, 
+0x02, 0x48, 0x65, 0xE4, 0x90, 0xA2, 0x6C, 0xF0, 0xA3, 0xF0, 0x90, 0xA1, 0xD4, 0xF0, 0xA3, 0xF0, 
+0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0xA5, 0xB8, 0xEE, 0xF0, 0xA3, 0x12, 0x5F, 
+0xE5, 0x90, 0xA5, 0xB8, 0x12, 0x7F, 0x67, 0xE0, 0x60, 0x29, 0xC3, 0x90, 0xA5, 0xBB, 0xE0, 0x94, 
+0xE8, 0x90, 0xA5, 0xBA, 0xE0, 0x94, 0x03, 0x40, 0x0B, 0x90, 0x01, 0xC0, 0xE0, 0x44, 0x80, 0xF0, 
+0x7F, 0x00, 0x80, 0x11, 0x90, 0xA5, 0xBA, 0x12, 0x58, 0xB3, 0x7F, 0x0A, 0x7E, 0x00, 0x12, 0x3A, 
+0xF7, 0x80, 0xCE, 0x7F, 0x01, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 
+0xD0, 0x90, 0xA5, 0xC0, 0x12, 0x48, 0x7A, 0x7F, 0x96, 0x7E, 0x02, 0x71, 0x51, 0xEF, 0x60, 0x51, 
+0x90, 0x01, 0x17, 0xE0, 0xFE, 0x90, 0x01, 0x16, 0xE0, 0x7C, 0x00, 0x24, 0x00, 0xFF, 0xEC, 0x3E, 
+0xFE, 0xEF, 0x24, 0x01, 0xFF, 0xE4, 0x3E, 0xFE, 0x90, 0xA5, 0xC3, 0xEF, 0xF0, 0xEE, 0xFF, 0x90, 
+0xFD, 0x11, 0xF0, 0x90, 0xA5, 0xC3, 0xE0, 0xFD, 0x90, 0x02, 0x94, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 
+0xA5, 0xC0, 0x91, 0xD1, 0x24, 0x02, 0xFF, 0xE4, 0x33, 0xFE, 0x91, 0x06, 0x90, 0xA5, 0xC3, 0xE0, 
+0x24, 0x18, 0xFF, 0x90, 0xA5, 0xC0, 0x12, 0x48, 0x71, 0x91, 0x5F, 0x90, 0x02, 0x96, 0x74, 0x01, 
+0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xE4, 0xFC, 0xED, 0x2C, 0x24, 0x00, 0x91, 0x57, 0xE4, 0xF0, 
+0x0C, 0xEC, 0xB4, 0x18, 0xF3, 0x74, 0x00, 0x2D, 0x91, 0x57, 0xEF, 0xF0, 0xEE, 0x54, 0x3F, 0xFF, 
+0x74, 0x01, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 0xFB, 0xF5, 0x83, 0xEF, 0xF0, 0x74, 0x02, 0x2D, 0xF5, 
+0x82, 0xE4, 0x34, 0xFB, 0xF5, 0x83, 0xE0, 0x54, 0xF0, 0xF0, 0x74, 0x03, 0x2D, 0xF5, 0x82, 0xE4, 
+0x34, 0xFB, 0xF5, 0x83, 0xE0, 0x44, 0x80, 0xF0, 0x74, 0x0B, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 0xFB, 
+0xF5, 0x83, 0xE0, 0x44, 0x10, 0xF0, 0x22, 0xF5, 0x82, 0xE4, 0x34, 0xFB, 0xF5, 0x83, 0x22, 0x90, 
+0xA5, 0xBC, 0xEF, 0xF0, 0xA3, 0x12, 0x48, 0x7A, 0x90, 0xA5, 0xEC, 0xE0, 0xFE, 0x04, 0xF0, 0x90, 
+0x00, 0x01, 0xEE, 0x12, 0x26, 0x76, 0x74, 0x00, 0x2F, 0xF9, 0xE4, 0x34, 0xFB, 0xFA, 0x7B, 0x01, 
+0xC0, 0x03, 0xC0, 0x02, 0xC0, 0x01, 0x90, 0xA5, 0xBD, 0x12, 0x48, 0x71, 0x8B, 0x40, 0x8A, 0x41, 
+0x89, 0x42, 0x75, 0x43, 0x02, 0xD0, 0x01, 0xD0, 0x02, 0xD0, 0x03, 0x12, 0x34, 0x2C, 0x90, 0xA5, 
+0xBC, 0xE0, 0x24, 0x02, 0xF9, 0xE4, 0x34, 0xFB, 0xFA, 0x7B, 0x01, 0xC0, 0x03, 0xC0, 0x02, 0xC0, 
+0x01, 0xA3, 0x12, 0x48, 0x71, 0xE9, 0x24, 0x02, 0xF9, 0xE4, 0x3A, 0x8B, 0x40, 0xF5, 0x41, 0x89, 
+0x42, 0x90, 0xA5, 0xBD, 0x91, 0xD1, 0xF5, 0x43, 0xD0, 0x01, 0xD0, 0x02, 0xD0, 0x03, 0x02, 0x34, 
+0x2C, 0x12, 0x48, 0x71, 0x90, 0x00, 0x0E, 0x02, 0x26, 0x37, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 
+0xD0, 0xE4, 0xFF, 0x90, 0xA2, 0x6D, 0xE0, 0xFE, 0x90, 0xA2, 0x6C, 0xE0, 0xFD, 0xB5, 0x06, 0x04, 
+0x7E, 0x01, 0x80, 0x02, 0x7E, 0x00, 0xEE, 0x64, 0x01, 0x60, 0x40, 0xED, 0x12, 0x97, 0xDD, 0xFA, 
+0x7B, 0x01, 0x71, 0x9A, 0x7F, 0x01, 0xEF, 0x60, 0x32, 0x90, 0xA2, 0x6C, 0xE0, 0x04, 0xF0, 0xE0, 
+0xB4, 0x0A, 0x02, 0x80, 0x02, 0x7F, 0x00, 0xEF, 0x60, 0x05, 0xE4, 0x90, 0xA2, 0x6C, 0xF0, 0x90, 
+0xA2, 0x6D, 0xE0, 0xFF, 0x90, 0xA2, 0x6C, 0xE0, 0xB5, 0x07, 0x04, 0x7F, 0x01, 0x80, 0x02, 0x7F, 
+0x00, 0xEF, 0x70, 0x07, 0x90, 0xA1, 0x76, 0xE0, 0x44, 0x04, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 
+0x90, 0xA5, 0xDC, 0x12, 0x48, 0x7A, 0xE4, 0xFF, 0x90, 0xA5, 0xDC, 0x12, 0x48, 0x71, 0x8F, 0x82, 
+0xB1, 0x60, 0xFE, 0x74, 0xF0, 0x2F, 0xF1, 0x90, 0xEE, 0xF0, 0x0F, 0xEF, 0xB4, 0x10, 0xE9, 0x22, 
+0x75, 0x83, 0x00, 0x02, 0x26, 0x37, 0x90, 0xA4, 0x98, 0x12, 0x48, 0x7A, 0x90, 0xA5, 0x78, 0x12, 
+0x27, 0x54, 0x80, 0x00, 0x00, 0x00, 0x90, 0xA5, 0x7C, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0x00, 
+0x12, 0x86, 0x50, 0xE4, 0x90, 0xA4, 0x9E, 0xF0, 0x12, 0x87, 0xAC, 0x90, 0xA4, 0x9E, 0xE0, 0xFF, 
+0xF5, 0x82, 0xB1, 0x60, 0xFE, 0xEF, 0xF1, 0x7E, 0xF5, 0x82, 0x8C, 0x83, 0xEE, 0xF0, 0x90, 0xA4, 
+0x9E, 0xE0, 0x04, 0xF0, 0xE0, 0xB4, 0x03, 0xE0, 0xE4, 0x90, 0xA4, 0x9E, 0xF0, 0x90, 0xA4, 0x9E, 
+0xE0, 0xFD, 0xF1, 0x74, 0x12, 0x82, 0x11, 0xC0, 0x06, 0xC0, 0x07, 0xB1, 0xD9, 0x75, 0xF0, 0x04, 
+0xED, 0xF1, 0x0A, 0x12, 0x47, 0xDF, 0x12, 0x80, 0x68, 0xD0, 0x07, 0xD0, 0x06, 0xF1, 0xAC, 0x94, 
+0x07, 0x40, 0xDA, 0x22, 0x7F, 0x01, 0x12, 0x87, 0xE1, 0x90, 0xA4, 0x9B, 0x02, 0x48, 0x71, 0x90, 
+0xA4, 0x98, 0x12, 0x48, 0x7A, 0x90, 0xA5, 0x78, 0x12, 0x27, 0x54, 0x80, 0x00, 0x00, 0x00, 0x90, 
+0xA5, 0x7C, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0x00, 0x12, 0x86, 0x50, 0x7D, 0x65, 0xE4, 0x12, 
+0x87, 0xA9, 0x12, 0x48, 0x0F, 0x7D, 0x8F, 0xE4, 0x12, 0x87, 0xA9, 0xD1, 0x2B, 0x12, 0x87, 0xA9, 
+0x90, 0x00, 0x08, 0x12, 0x48, 0x29, 0x7D, 0x65, 0xB1, 0xD4, 0x12, 0x48, 0x0F, 0x7D, 0x8F, 0xB1, 
+0xD4, 0xD1, 0x2B, 0xB1, 0xD4, 0x90, 0x00, 0x08, 0x02, 0x48, 0x29, 0x90, 0x00, 0x04, 0x12, 0x48, 
+0x29, 0xE4, 0xFD, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0xD1, 0x86, 0xF1, 0x11, 0xD1, 
+0x97, 0xD1, 0xA8, 0x7B, 0x01, 0x7A, 0xA4, 0x79, 0x8C, 0x90, 0xA4, 0x9B, 0x12, 0x48, 0x7A, 0x7A, 
+0xA4, 0x79, 0x80, 0xB1, 0xDF, 0x12, 0xB7, 0xAC, 0xE4, 0xFF, 0x12, 0x88, 0x75, 0x7B, 0x01, 0x7A, 
+0xA4, 0x79, 0x80, 0xE4, 0xFF, 0x12, 0x88, 0x21, 0x7F, 0x01, 0x12, 0x88, 0x75, 0x7B, 0x01, 0x7A, 
+0xA4, 0x79, 0x8C, 0x7F, 0x01, 0x12, 0x88, 0x21, 0xD1, 0x97, 0x12, 0x80, 0x6E, 0xD1, 0x86, 0xB1, 
+0x66, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x7B, 0x01, 0x7A, 0xA4, 0x79, 0x34, 0x90, 0xA4, 0x9B, 0x12, 
+0x48, 0x7A, 0x7A, 0xA4, 0x79, 0x31, 0x22, 0x7B, 0x01, 0x7A, 0xA4, 0x79, 0x68, 0x90, 0xA4, 0x9B, 
+0x12, 0x48, 0x7A, 0x7A, 0xA4, 0x79, 0x50, 0x22, 0x90, 0xA4, 0x98, 0x12, 0x48, 0x7A, 0x90, 0xA5, 
+0x78, 0x12, 0x27, 0x54, 0x80, 0x00, 0x00, 0x00, 0x90, 0xA5, 0x7C, 0x12, 0x27, 0x54, 0x00, 0x00, 
+0x00, 0x00, 0x12, 0x86, 0x50, 0xE4, 0x90, 0xA4, 0x9E, 0xF0, 0x90, 0xA4, 0x9E, 0xE0, 0xFF, 0xC3, 
+0x94, 0x06, 0x50, 0x1D, 0xEF, 0xF1, 0x98, 0x12, 0x82, 0x11, 0x12, 0x36, 0xCE, 0x90, 0xA4, 0x98, 
+0xF1, 0x00, 0xD1, 0xF2, 0xF1, 0xA2, 0x12, 0x82, 0x11, 0xD1, 0xFA, 0xD1, 0xF2, 0x04, 0xF0, 0x80, 
+0xD9, 0x22, 0x12, 0x48, 0x29, 0x90, 0xA4, 0x9E, 0xE0, 0x22, 0x12, 0x36, 0xCE, 0x90, 0xA4, 0x9B, 
+0x12, 0x48, 0x71, 0x90, 0xA4, 0x9E, 0xE0, 0x75, 0xF0, 0x04, 0xA4, 0xF5, 0x82, 0x85, 0xF0, 0x83, 
+0x22, 0x90, 0xA4, 0x98, 0x12, 0x48, 0x7A, 0x90, 0xA5, 0x78, 0x12, 0x27, 0x54, 0x80, 0x00, 0x00, 
+0x00, 0x90, 0xA5, 0x7C, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0x00, 0x12, 0x86, 0x50, 0xE4, 0x90, 
+0xA4, 0x9E, 0xF0, 0x90, 0xA4, 0x9E, 0xE0, 0xFF, 0xF1, 0x7E, 0xF5, 0x82, 0x8C, 0x83, 0xE0, 0xFE, 
+0x12, 0x87, 0xAC, 0x8F, 0x82, 0x75, 0x83, 0x00, 0xEE, 0x12, 0x26, 0x76, 0x90, 0xA4, 0x9E, 0xE0, 
+0x04, 0xF0, 0xE0, 0xB4, 0x03, 0xDD, 0xE4, 0x90, 0xA4, 0x9E, 0xF0, 0x90, 0xA4, 0x9E, 0xE0, 0xFF, 
+0xC3, 0x94, 0x07, 0x50, 0x0E, 0xEF, 0xF1, 0x74, 0x12, 0x82, 0x11, 0xD1, 0xFA, 0xD1, 0xF2, 0x04, 
+0xF0, 0x80, 0xE8, 0x22, 0x25, 0xE0, 0x24, 0xA5, 0xF5, 0x82, 0xE4, 0x34, 0x44, 0x22, 0x25, 0xE0, 
+0x24, 0x9F, 0xF5, 0x82, 0xE4, 0x34, 0x44, 0xF5, 0x83, 0xE4, 0x93, 0xFC, 0x74, 0x01, 0x93, 0x22, 
+0xF5, 0x82, 0xE4, 0x34, 0x02, 0xF5, 0x83, 0x22, 0x25, 0xE0, 0x24, 0xB3, 0xF5, 0x82, 0xE4, 0x34, 
+0x44, 0x22, 0x25, 0xE0, 0x24, 0xBF, 0xF5, 0x82, 0xE4, 0x34, 0x44, 0x22, 0x12, 0x37, 0x5D, 0x90, 
+0xA4, 0x9E, 0xE0, 0x04, 0xF0, 0xE0, 0xC3, 0x22, 0x12, 0x4F, 0xBD, 0x90, 0xA3, 0x69, 0x12, 0x4F, 
+0xB5, 0x90, 0xA3, 0x6A, 0xF0, 0xD1, 0x34, 0x7F, 0x01, 0x02, 0x97, 0x7D, 0xE4, 0xF5, 0x55, 0xF5, 
+0x56, 0xF5, 0x57, 0x75, 0x58, 0x80, 0xAD, 0x55, 0x7F, 0x50, 0x12, 0x3A, 0x96, 0xAD, 0x56, 0x7F, 
+0x51, 0x12, 0x3A, 0x96, 0xAD, 0x57, 0x7F, 0x52, 0x12, 0x3A, 0x96, 0xAD, 0x58, 0x7F, 0x53, 0x02, 
+0x3A, 0x96, 0x75, 0x5D, 0x12, 0xE4, 0xF5, 0x5E, 0x75, 0x5F, 0x07, 0x75, 0x60, 0x72, 0x90, 0x01, 
+0x30, 0xE5, 0x5D, 0xF0, 0xA3, 0xE5, 0x5E, 0xF0, 0xA3, 0xE5, 0x5F, 0xF0, 0xA3, 0xE5, 0x60, 0xF0, 
+0x22, 0x75, 0x65, 0x0E, 0x75, 0x66, 0x01, 0x75, 0x67, 0x03, 0x75, 0x68, 0x62, 0x90, 0x01, 0x38, 
+0xE5, 0x65, 0xF0, 0xA3, 0xE5, 0x66, 0xF0, 0xA3, 0xE5, 0x67, 0xF0, 0xA3, 0xE5, 0x68, 0xF0, 0x22, 
+0x90, 0x01, 0x94, 0xE0, 0x44, 0x01, 0xF0, 0x90, 0x01, 0xC7, 0xE4, 0xF0, 0x22, 0x90, 0x01, 0x01, 
+0xE0, 0x44, 0x04, 0xF0, 0x90, 0x01, 0x9C, 0x74, 0x7E, 0xF0, 0xA3, 0x74, 0x92, 0xF0, 0xA3, 0x74, 
+0xA0, 0xF0, 0xA3, 0x74, 0x24, 0xF0, 0x90, 0x01, 0x9B, 0x74, 0x49, 0xF0, 0x90, 0x01, 0x9A, 0x74, 
+0xE0, 0xF0, 0x90, 0x01, 0x99, 0xE4, 0xF0, 0x90, 0x01, 0x98, 0x04, 0xF0, 0x22, 0x7D, 0x02, 0x90, 
+0x01, 0xC4, 0x74, 0x6D, 0xF0, 0x74, 0xA8, 0xA3, 0xF0, 0x90, 0xA3, 0x3B, 0xE0, 0xFF, 0xED, 0xC3, 
+0x9F, 0x50, 0x10, 0xED, 0x25, 0xE0, 0x24, 0x81, 0xF8, 0xE6, 0x30, 0xE4, 0x03, 0x7F, 0x00, 0x22, 
+0x0D, 0x80, 0xE6, 0x74, 0x6D, 0x04, 0x90, 0x01, 0xC4, 0xF0, 0x74, 0xA8, 0xA3, 0xF0, 0x7F, 0x01, 
+0x22, 0x90, 0x01, 0xE4, 0x74, 0x26, 0xF0, 0xA3, 0xE4, 0xF0, 0x22, 0x90, 0x01, 0x34, 0xE0, 0x55, 
+0x5D, 0xF5, 0x61, 0xA3, 0xE0, 0x55, 0x5E, 0xF5, 0x62, 0xA3, 0xE0, 0x55, 0x5F, 0xF5, 0x63, 0xA3, 
+0xE0, 0x55, 0x60, 0xF5, 0x64, 0x90, 0x01, 0x34, 0xE5, 0x61, 0xF0, 0xA3, 0xE5, 0x62, 0xF0, 0xA3, 
+0xE5, 0x63, 0xF0, 0xA3, 0xE5, 0x64, 0xF0, 0x22, 0x90, 0x01, 0x3C, 0xE0, 0x55, 0x65, 0xF5, 0x69, 
+0xA3, 0xE0, 0x55, 0x66, 0xF5, 0x6A, 0xA3, 0xE0, 0x55, 0x67, 0xF5, 0x6B, 0xA3, 0xE0, 0x55, 0x68, 
+0xF5, 0x6C, 0x90, 0x01, 0x3C, 0xE5, 0x69, 0xF0, 0xA3, 0xE5, 0x6A, 0xF0, 0xA3, 0xE5, 0x6B, 0xF0, 
+0xA3, 0xE5, 0x6C, 0xF0, 0x53, 0x91, 0xDF, 0x22, 0x90, 0x01, 0xCF, 0xE0, 0x90, 0xA4, 0xF8, 0xF0, 
+0xE0, 0xFF, 0x30, 0xE0, 0x07, 0x90, 0x01, 0xCF, 0xE0, 0x54, 0xFE, 0xF0, 0xEF, 0x30, 0xE5, 0x23, 
+0x90, 0x01, 0xCF, 0xE0, 0x54, 0xDF, 0xF0, 0x90, 0x01, 0x34, 0x74, 0x20, 0xF0, 0xE4, 0xF5, 0xA8, 
+0xF5, 0xE8, 0x12, 0x50, 0x40, 0x90, 0x00, 0x03, 0xE0, 0x54, 0xFB, 0xFD, 0x7F, 0x03, 0x12, 0x3A, 
+0x96, 0x80, 0xFE, 0x22, 0x90, 0xA2, 0x83, 0xE0, 0x30, 0xE0, 0x05, 0xE4, 0xA3, 0xF0, 0xA3, 0xF0, 
+0x22, 0x90, 0xA2, 0x83, 0xE0, 0x30, 0xE0, 0x11, 0xA3, 0x74, 0x01, 0xF0, 0x90, 0xA2, 0x83, 0xE0, 
+0xFF, 0xC3, 0x13, 0x30, 0xE0, 0x03, 0x12, 0x7E, 0xFA, 0x02, 0x66, 0x23, 0x90, 0xA2, 0x83, 0xE0, 
+0xFF, 0x30, 0xE0, 0x05, 0x12, 0x79, 0xCD, 0x60, 0x15, 0x90, 0xA2, 0x8C, 0xE0, 0x70, 0x04, 0xEF, 
+0x30, 0xE0, 0x0B, 0x90, 0xA2, 0x8F, 0xE0, 0x64, 0x02, 0x60, 0x03, 0x12, 0x63, 0x7B, 0x22, 0x90, 
+0xA2, 0x8C, 0xE0, 0x70, 0x07, 0x90, 0xA2, 0x83, 0xE0, 0x30, 0xE0, 0x13, 0x90, 0xA2, 0x83, 0xE0, 
+0x30, 0xE0, 0x09, 0x12, 0x63, 0x32, 0xBF, 0x01, 0x06, 0x02, 0x79, 0x60, 0x12, 0x57, 0x9F, 0x22, 
+0xEF, 0x90, 0x02, 0x86, 0x60, 0x06, 0xE0, 0x44, 0x04, 0xF0, 0x80, 0x04, 0xE0, 0x54, 0xFB, 0xF0, 
+0x90, 0xA1, 0x7B, 0xED, 0xF0, 0x22, 0xE4, 0x90, 0xA5, 0x09, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0x90, 
+0x00, 0x83, 0xE0, 0x90, 0xA5, 0x09, 0xF0, 0x90, 0x00, 0x83, 0xE0, 0xFE, 0x90, 0xA5, 0x09, 0xE0, 
+0xFF, 0xB5, 0x06, 0x01, 0x22, 0xC3, 0x90, 0xA5, 0x0B, 0xE0, 0x94, 0x64, 0x90, 0xA5, 0x0A, 0xE0, 
+0x94, 0x00, 0x40, 0x0D, 0x90, 0x01, 0xC0, 0xE0, 0x44, 0x40, 0xF0, 0x90, 0xA5, 0x09, 0xE0, 0xFF, 
+0x22, 0x90, 0xA5, 0x0A, 0x12, 0x58, 0xB3, 0x80, 0xC6, 0x90, 0xA5, 0xE2, 0x12, 0x5F, 0xE5, 0x90, 
+0x01, 0x09, 0xE0, 0x7F, 0x00, 0x30, 0xE7, 0x02, 0x7F, 0x01, 0x90, 0xA5, 0xE2, 0xE0, 0x6F, 0x60, 
+0x36, 0xC3, 0x90, 0xA5, 0xE4, 0xE0, 0x94, 0x88, 0x90, 0xA5, 0xE3, 0xE0, 0x94, 0x13, 0x40, 0x08, 
+0x90, 0x01, 0xC0, 0xE0, 0x44, 0x10, 0xF0, 0x22, 0x90, 0xA5, 0xE3, 0x12, 0x58, 0xB3, 0x12, 0x5F, 
+0xBF, 0xD3, 0x90, 0xA5, 0xE4, 0xE0, 0x94, 0x32, 0x90, 0xA5, 0xE3, 0xE0, 0x94, 0x00, 0x40, 0xBF, 
+0x90, 0x01, 0xC6, 0xE0, 0x30, 0xE0, 0xB8, 0x22, 0x71, 0x33, 0x90, 0x00, 0x08, 0xE0, 0x54, 0xEF, 
+0xFD, 0x7F, 0x08, 0x12, 0x3A, 0x96, 0xE4, 0xFF, 0x51, 0x09, 0x90, 0xA1, 0x7C, 0xE0, 0xB4, 0x03, 
+0x0C, 0x90, 0x00, 0x70, 0xE0, 0x54, 0x7F, 0xFD, 0x7F, 0x70, 0x12, 0x3A, 0x96, 0x90, 0xA2, 0x89, 
+0xE0, 0x54, 0xEF, 0xF0, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x51, 0xC7, 0x51, 0x58, 
+0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0xA2, 0x8F, 0xE0, 0xFF, 0x60, 0x03, 0xB4, 0x08, 0x07, 0x71, 
+0x50, 0xBF, 0x01, 0x02, 0x51, 0x85, 0x22, 0x90, 0xA2, 0x88, 0xE0, 0x30, 0xE0, 0x18, 0x90, 0xA2, 
+0x83, 0xE0, 0xFF, 0x30, 0xE0, 0x0E, 0xC3, 0x13, 0x30, 0xE0, 0x07, 0x71, 0x26, 0xBF, 0x01, 0x06, 
+0x80, 0x02, 0x80, 0x00, 0x51, 0x95, 0x22, 0x90, 0xA2, 0x89, 0xE0, 0x44, 0x10, 0xF0, 0x90, 0xA1, 
+0x7C, 0xE0, 0xB4, 0x03, 0x0C, 0x90, 0x00, 0x70, 0xE0, 0x44, 0x80, 0xFD, 0x7F, 0x70, 0x12, 0x3A, 
+0x96, 0x90, 0xA2, 0x97, 0xE0, 0xFD, 0x7F, 0x93, 0x12, 0x3A, 0x96, 0x90, 0xA2, 0x8D, 0xE0, 0x60, 
+0x12, 0x90, 0x01, 0x2F, 0xE0, 0x30, 0xE7, 0x05, 0x74, 0x10, 0xF0, 0x80, 0x06, 0x90, 0x01, 0x2F, 
+0x74, 0x90, 0xF0, 0x90, 0x00, 0x08, 0xE0, 0x44, 0x10, 0xFD, 0x7F, 0x08, 0x12, 0x3A, 0x96, 0x7F, 
+0x01, 0x51, 0x09, 0x90, 0x00, 0x90, 0xE0, 0x44, 0x01, 0xFD, 0x7F, 0x90, 0x12, 0x3A, 0x96, 0x7F, 
+0x14, 0x7E, 0x00, 0x02, 0x3A, 0xF7, 0x90, 0xA2, 0x86, 0xE0, 0x64, 0x02, 0x7F, 0x01, 0x60, 0x02, 
+0x7F, 0x00, 0x22, 0x90, 0x01, 0xC4, 0x74, 0x33, 0xF0, 0x74, 0xAB, 0xA3, 0xF0, 0x90, 0x00, 0x90, 
+0xE0, 0x20, 0xE0, 0xF9, 0x74, 0x33, 0x04, 0x90, 0x01, 0xC4, 0xF0, 0x74, 0xAB, 0xA3, 0xF0, 0x22, 
+0x90, 0x02, 0x87, 0xE0, 0x70, 0x1F, 0x90, 0x01, 0x00, 0xE0, 0x64, 0x3F, 0x70, 0x17, 0x90, 0x02, 
+0x96, 0xE0, 0x70, 0x11, 0x90, 0x02, 0x86, 0xE0, 0x30, 0xE1, 0x0A, 0x90, 0x02, 0x86, 0xE0, 0x20, 
+0xE3, 0x03, 0x7F, 0x01, 0x22, 0x7F, 0x00, 0x22, 0xED, 0x54, 0x7F, 0xFC, 0xED, 0x54, 0x80, 0x60, 
+0x03, 0xAF, 0x04, 0x22, 0xEC, 0xB4, 0x3D, 0x02, 0x80, 0x14, 0xEC, 0x64, 0x3F, 0x70, 0x18, 0x75, 
+0xF0, 0x04, 0xEF, 0x12, 0x5F, 0xA6, 0xC4, 0x13, 0x54, 0x07, 0x30, 0xE0, 0x06, 0xEC, 0x44, 0x80, 
+0xFE, 0x80, 0x06, 0x7E, 0xFF, 0x80, 0x02, 0x7E, 0xFF, 0xAF, 0x06, 0x22, 0x8F, 0x19, 0x75, 0xF0, 
+0x10, 0xEF, 0x12, 0x6F, 0xEF, 0xE0, 0xF5, 0x1A, 0xE4, 0xF5, 0x1F, 0xE5, 0x1A, 0x54, 0x7F, 0xF5, 
+0x1B, 0xE5, 0x1A, 0x54, 0x80, 0xFF, 0x75, 0xF0, 0x04, 0xE5, 0x19, 0x12, 0x76, 0x41, 0xE0, 0xF5, 
+0x1D, 0x75, 0xF0, 0x04, 0xE5, 0x19, 0x12, 0x4F, 0xAD, 0xFE, 0xC4, 0x54, 0x03, 0xF5, 0x1E, 0xE5, 
+0x1B, 0xB1, 0xC8, 0x12, 0xA7, 0x87, 0xFD, 0xD1, 0xBE, 0xEC, 0xF0, 0xA3, 0xED, 0xF0, 0xE5, 0x1A, 
+0x4F, 0xFF, 0x74, 0x75, 0x25, 0x19, 0xB1, 0xBE, 0xEF, 0xF0, 0x75, 0xF0, 0x04, 0xE5, 0x19, 0x12, 
+0x4F, 0xAD, 0x13, 0x13, 0x54, 0x03, 0xF5, 0x1C, 0x74, 0x21, 0x25, 0x19, 0xD1, 0xB6, 0xE5, 0x1C, 
+0xF0, 0x74, 0x91, 0x25, 0x19, 0x12, 0x5C, 0x23, 0xE0, 0x30, 0xE0, 0x20, 0xE5, 0x1B, 0x64, 0x3F, 
+0x70, 0x1A, 0x12, 0x5F, 0x9E, 0xC4, 0x13, 0x54, 0x07, 0x30, 0xE0, 0x05, 0x75, 0x1A, 0xBE, 0x80, 
+0x03, 0x85, 0x1B, 0x1A, 0x85, 0x1C, 0x27, 0xE4, 0xFB, 0x12, 0x73, 0x79, 0xAD, 0x1A, 0xAF, 0x19, 
+0x71, 0x78, 0xEF, 0xF4, 0x60, 0x0B, 0x8F, 0x1A, 0xEF, 0x30, 0xE7, 0x02, 0xA1, 0xB4, 0x85, 0x1A, 
+0x1B, 0xE5, 0x1B, 0x64, 0x2D, 0x70, 0x2E, 0x75, 0xF0, 0x04, 0xE5, 0x19, 0x12, 0x4F, 0xAD, 0xFF, 
+0x54, 0x03, 0xFE, 0xE5, 0x1C, 0xC3, 0x9E, 0x50, 0x1C, 0x75, 0x1A, 0x2C, 0x05, 0x1C, 0xE5, 0x1C, 
+0xD1, 0xAF, 0xFE, 0x75, 0xF0, 0x04, 0xE5, 0x19, 0x90, 0x96, 0x14, 0x12, 0x48, 0x65, 0xEF, 0x54, 
+0xF3, 0x4E, 0xF0, 0x80, 0x08, 0xE5, 0x1B, 0xB4, 0x2C, 0x0F, 0x75, 0x1A, 0x2D, 0x74, 0xA1, 0x25, 
+0x19, 0x12, 0x5F, 0x53, 0x74, 0xFF, 0xF0, 0xA1, 0xB4, 0xE5, 0x1B, 0xC3, 0x95, 0x1D, 0x40, 0x02, 
+0xA1, 0x7D, 0xAD, 0x1B, 0xAF, 0x1E, 0xB1, 0xE5, 0x8F, 0x1B, 0xAD, 0x1D, 0xAF, 0x1E, 0xB1, 0xE5, 
+0x8F, 0x1D, 0xE5, 0x1B, 0xD3, 0x94, 0x0B, 0x40, 0x13, 0x90, 0xA4, 0x4A, 0xE5, 0x1E, 0xF0, 0xAB, 
+0x19, 0xE4, 0xFD, 0xAF, 0x1B, 0x12, 0x5D, 0x7E, 0x8F, 0x1A, 0x80, 0x0D, 0x75, 0x1A, 0xFF, 0x74, 
+0xA1, 0x25, 0x19, 0x12, 0x5F, 0x53, 0x74, 0xFF, 0xF0, 0xE5, 0x1A, 0xF4, 0x70, 0x59, 0x74, 0xA1, 
+0x25, 0x19, 0x12, 0x5F, 0x53, 0xE0, 0xF4, 0x70, 0x4E, 0xE5, 0x1B, 0x04, 0xFD, 0xED, 0xD3, 0x95, 
+0x1D, 0x50, 0x44, 0xED, 0x12, 0x5F, 0xEE, 0x75, 0xF0, 0x08, 0xE5, 0x19, 0x12, 0x72, 0x21, 0xE0, 
+0xFB, 0x7A, 0x00, 0xED, 0x12, 0x9C, 0xAE, 0x80, 0x05, 0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 0xF9, 
+0x12, 0x5F, 0xDD, 0x60, 0x1F, 0xE5, 0x1B, 0xB4, 0x13, 0x13, 0x75, 0x1B, 0x18, 0x85, 0x1B, 0x1A, 
+0x74, 0x91, 0x25, 0x19, 0x12, 0x5C, 0x23, 0xE0, 0x44, 0x04, 0xF0, 0x80, 0x0A, 0x8D, 0x1B, 0x85, 
+0x1B, 0x1A, 0x80, 0x03, 0x0D, 0x80, 0xB6, 0xAD, 0x1A, 0xAF, 0x1E, 0xB1, 0xD2, 0x8F, 0x1A, 0x74, 
+0xA1, 0x25, 0x19, 0x12, 0x5F, 0x53, 0xE0, 0xFD, 0xF4, 0x60, 0x0D, 0xAF, 0x1E, 0xB1, 0xD2, 0x74, 
+0xA1, 0x25, 0x19, 0x12, 0x5F, 0x53, 0xEF, 0xF0, 0x74, 0x91, 0x25, 0x19, 0x12, 0x5C, 0x23, 0xE0, 
+0x30, 0xE0, 0x51, 0xE5, 0x1B, 0x64, 0x3F, 0x70, 0x4B, 0x12, 0x5F, 0x9E, 0xC4, 0x13, 0x54, 0x07, 
+0x30, 0xE0, 0x05, 0x75, 0x1A, 0xBE, 0x80, 0x3C, 0x85, 0x1B, 0x1A, 0x80, 0x37, 0xE5, 0x1B, 0x65, 
+0x1D, 0x70, 0x26, 0x12, 0x5F, 0xA1, 0xC4, 0x13, 0x54, 0x07, 0x30, 0xE0, 0x0D, 0xE5, 0x1A, 0x20, 
+0xE7, 0x08, 0xE5, 0x1B, 0x44, 0x80, 0xF5, 0x1A, 0x80, 0x1A, 0xE5, 0x1B, 0xB1, 0xC8, 0x12, 0x82, 
+0x11, 0xD1, 0xBE, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x22, 0x74, 0x75, 0x25, 0x19, 0xB1, 0xBE, 0xE5, 
+0x1D, 0xF0, 0xF5, 0x1A, 0x85, 0x1C, 0x27, 0x7B, 0x01, 0x02, 0x73, 0x79, 0x24, 0x75, 0xF5, 0x82, 
+0xE4, 0x34, 0xA0, 0xF5, 0x83, 0x22, 0xE5, 0x0F, 0x25, 0xE0, 0x24, 0x95, 0xF5, 0x82, 0xE4, 0x34, 
+0x42, 0x22, 0xEF, 0x60, 0x0A, 0xED, 0xD3, 0x94, 0x0B, 0x40, 0x04, 0x7E, 0x20, 0x80, 0x02, 0xE4, 
+0xFE, 0xED, 0x2E, 0xFF, 0x22, 0xEF, 0x60, 0x0A, 0xED, 0xC3, 0x94, 0x2C, 0x40, 0x04, 0x7E, 0x20, 
+0x80, 0x02, 0xE4, 0xFE, 0xC3, 0xED, 0x9E, 0xFF, 0x22, 0xAC, 0x07, 0x75, 0xF0, 0x04, 0xEC, 0x90, 
+0x96, 0x14, 0x12, 0x48, 0x65, 0x75, 0xF0, 0x04, 0xEC, 0x12, 0x76, 0x41, 0xE0, 0xFA, 0x74, 0x75, 
+0x2C, 0xB1, 0xBE, 0xE0, 0x54, 0x7F, 0xFD, 0x75, 0xF0, 0x04, 0xEC, 0x12, 0x6E, 0x88, 0xE0, 0xFF, 
+0x54, 0xF8, 0xFE, 0xEF, 0x04, 0x54, 0x07, 0x4E, 0xF0, 0x75, 0xF0, 0x04, 0xEC, 0x12, 0x6E, 0x88, 
+0xE0, 0xFF, 0x54, 0x07, 0xD3, 0x94, 0x02, 0x40, 0x47, 0x74, 0xA1, 0x2C, 0x12, 0x5F, 0x53, 0xE0, 
+0xF4, 0x70, 0x3D, 0x75, 0xF0, 0x04, 0xEC, 0x12, 0x6E, 0x88, 0xEF, 0x54, 0xF8, 0xF0, 0x74, 0x11, 
+0x2C, 0x12, 0x5C, 0x3E, 0x54, 0x7F, 0xFF, 0x75, 0xF0, 0x04, 0xEC, 0xD1, 0xD1, 0x54, 0x80, 0x4F, 
+0xF0, 0x74, 0x11, 0x2C, 0x12, 0x5C, 0x3E, 0x25, 0xE0, 0xFF, 0xE4, 0x33, 0xFE, 0xEF, 0x24, 0x32, 
+0xFF, 0xE4, 0x3E, 0xFE, 0x75, 0xF0, 0x04, 0xEC, 0x12, 0x6E, 0x93, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 
+0x74, 0x21, 0x2C, 0xD1, 0xB6, 0xE0, 0xFB, 0xD1, 0xAF, 0xFF, 0x75, 0xF0, 0x04, 0xEC, 0x12, 0x4F, 
+0xAD, 0x54, 0xF3, 0x4F, 0xF0, 0xED, 0xD3, 0x9A, 0x40, 0x02, 0xAD, 0x02, 0x74, 0x75, 0x2C, 0xB1, 
+0xBE, 0xE0, 0x54, 0x80, 0x42, 0x05, 0xAF, 0x04, 0x8B, 0x27, 0xE4, 0xFB, 0x02, 0x73, 0x7D, 0x54, 
+0x03, 0x25, 0xE0, 0x25, 0xE0, 0x22, 0xF5, 0x82, 0xE4, 0x34, 0x9E, 0xF5, 0x83, 0x22, 0xE5, 0x19, 
+0x25, 0xE0, 0x24, 0x91, 0xF5, 0x82, 0xE4, 0x34, 0x94, 0xF5, 0x83, 0x22, 0x75, 0xF0, 0x04, 0xE5, 
+0x0D, 0x90, 0x9B, 0x14, 0x12, 0x48, 0x65, 0xE0, 0x22, 0xA9, 0x05, 0x90, 0xA4, 0x43, 0xEF, 0xF0, 
+0xE0, 0xFE, 0x75, 0xF0, 0x04, 0x12, 0x6E, 0x93, 0xE4, 0xF0, 0xA3, 0xF0, 0x75, 0xF0, 0x10, 0xEE, 
+0x12, 0x6F, 0xEF, 0xE0, 0xF5, 0x19, 0x54, 0x7F, 0xF5, 0x1B, 0x12, 0xBC, 0x1D, 0x12, 0x73, 0x73, 
+0xE0, 0x90, 0xA4, 0x46, 0xF0, 0x75, 0xF0, 0x04, 0xEE, 0x12, 0x76, 0x41, 0xE0, 0xFC, 0x75, 0xF0, 
+0x04, 0xEF, 0x12, 0x4F, 0xAD, 0x13, 0x13, 0x54, 0x03, 0xF5, 0x1A, 0xE5, 0x1B, 0x12, 0xBB, 0x28, 
+0xE4, 0x93, 0xFA, 0x74, 0x01, 0x93, 0xFB, 0xEF, 0xD1, 0xC0, 0xEA, 0xF0, 0xA3, 0xEB, 0xF0, 0x90, 
+0xA4, 0x43, 0xE0, 0xFF, 0x75, 0xF0, 0x04, 0x12, 0x4F, 0xAD, 0xFE, 0xC4, 0x54, 0x03, 0x90, 0xA4, 
+0x44, 0xF0, 0x74, 0x75, 0x2F, 0xB1, 0xBE, 0xE5, 0x1B, 0xF0, 0x90, 0xA4, 0x43, 0xE0, 0xFF, 0x24, 
+0x21, 0xD1, 0xB6, 0xE5, 0x1A, 0xF0, 0xE5, 0x1B, 0xD3, 0x9C, 0x40, 0x0E, 0x8C, 0x1B, 0x8C, 0x19, 
+0xAE, 0x04, 0x74, 0xA1, 0x2F, 0x12, 0x5F, 0x53, 0xEE, 0xF0, 0xE9, 0x70, 0x03, 0x02, 0xB1, 0x09, 
+0xAF, 0x01, 0x8F, 0x1C, 0xE5, 0x19, 0x30, 0xE7, 0x0E, 0x85, 0x1B, 0x19, 0x90, 0xA4, 0x43, 0x12, 
+0x5F, 0x50, 0xE5, 0x1B, 0xF0, 0x15, 0x1C, 0xE5, 0x1C, 0x70, 0x03, 0x02, 0xB1, 0x09, 0x90, 0xA4, 
+0x43, 0xE0, 0xFF, 0xAD, 0x19, 0x12, 0x5F, 0x5B, 0xEF, 0xF4, 0x60, 0x19, 0x8F, 0x19, 0xD5, 0x1C, 
+0x14, 0x90, 0xA4, 0x43, 0xE0, 0xFF, 0xB1, 0xBC, 0xE0, 0xFE, 0x74, 0xA1, 0x2F, 0x12, 0x5F, 0x53, 
+0xEE, 0xF0, 0x02, 0xB1, 0x09, 0xE5, 0x19, 0x64, 0x2C, 0x70, 0x34, 0xE5, 0x1A, 0xD3, 0x94, 0x00, 
+0x40, 0x2D, 0xE5, 0x1A, 0xD3, 0x94, 0x02, 0x50, 0x26, 0x15, 0x1A, 0x75, 0x19, 0x2D, 0xE5, 0x1A, 
+0xD1, 0xAF, 0xFF, 0x12, 0xBC, 0x1D, 0x12, 0x4F, 0xAD, 0x54, 0xF3, 0x4F, 0xF0, 0x74, 0xA1, 0x2E, 
+0x12, 0x5F, 0x53, 0x74, 0xFF, 0xF0, 0x15, 0x1C, 0xE5, 0x1C, 0x70, 0x03, 0x02, 0xB1, 0x09, 0xE5, 
+0x19, 0xB4, 0x2D, 0x1B, 0xE5, 0x1A, 0xD3, 0x94, 0x02, 0x50, 0x14, 0x75, 0x19, 0x2C, 0x90, 0xA4, 
+0x43, 0x12, 0x5F, 0x50, 0x74, 0xFF, 0xF0, 0x15, 0x1C, 0xE5, 0x1C, 0x70, 0x02, 0x21, 0x09, 0xE5, 
+0x1C, 0x70, 0x02, 0x21, 0x09, 0x90, 0xA4, 0x46, 0xE0, 0xFF, 0xE5, 0x1B, 0xD3, 0x9F, 0x50, 0x02, 
+0x21, 0x03, 0xE4, 0x90, 0xA4, 0x45, 0xF0, 0x90, 0xA4, 0x44, 0xE0, 0xFF, 0xAD, 0x1B, 0x12, 0xAD, 
+0xE5, 0x8F, 0x1B, 0x85, 0x1B, 0x19, 0xE0, 0xFF, 0x90, 0xA4, 0x46, 0xE0, 0xFD, 0x12, 0xAD, 0xE5, 
+0xEF, 0xF0, 0xE5, 0x19, 0xD3, 0x94, 0x0B, 0x40, 0x1B, 0x90, 0xA4, 0x43, 0xE0, 0xFB, 0xA3, 0xE0, 
+0x90, 0xA4, 0x4A, 0xF0, 0x7D, 0x01, 0xAF, 0x1B, 0x12, 0x5D, 0x7E, 0x8F, 0x19, 0xE5, 0x19, 0xF4, 
+0x70, 0x61, 0x21, 0x09, 0xAD, 0x19, 0xE5, 0x1B, 0x14, 0xFC, 0x90, 0xA4, 0x46, 0xE0, 0xFF, 0xEC, 
+0xC3, 0x9F, 0x40, 0x3E, 0x12, 0x5F, 0xED, 0x90, 0xA4, 0x43, 0x12, 0x72, 0x1D, 0xE0, 0xFB, 0x7A, 
+0x00, 0xEC, 0x12, 0x9C, 0xAE, 0x80, 0x05, 0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 0xF9, 0x12, 0x5F, 
+0xDD, 0x60, 0x1C, 0xE5, 0x1B, 0xAD, 0x04, 0xB4, 0x14, 0x02, 0x7D, 0x0C, 0x90, 0xA4, 0x45, 0xE0, 
+0x04, 0xF0, 0xE0, 0x65, 0x1C, 0x60, 0x0B, 0xA3, 0xE0, 0xFF, 0xED, 0xD3, 0x9F, 0x40, 0x03, 0x1C, 
+0x80, 0xB8, 0x90, 0xA4, 0x43, 0x12, 0x5F, 0x50, 0xED, 0xF0, 0xE5, 0x19, 0xB4, 0xFF, 0x04, 0xAF, 
+0x05, 0x8F, 0x19, 0x90, 0xA4, 0x44, 0xE0, 0xFF, 0xAD, 0x19, 0x12, 0xAD, 0xD2, 0x8F, 0x19, 0x90, 
+0xA4, 0x43, 0x12, 0x5F, 0x50, 0xE0, 0xFD, 0xF4, 0x60, 0x1D, 0x90, 0xA4, 0x44, 0xE0, 0xFF, 0x12, 
+0xAD, 0xD2, 0x90, 0xA4, 0x43, 0xE0, 0xFE, 0x12, 0xAD, 0xBC, 0xEF, 0xF0, 0x74, 0xA1, 0x2E, 0x12, 
+0x5F, 0x53, 0x74, 0xFF, 0xF0, 0x80, 0x12, 0x90, 0xA4, 0x43, 0xE0, 0x12, 0xAD, 0xBC, 0xE5, 0x19, 
+0xF0, 0x80, 0x06, 0x90, 0xA4, 0x46, 0xE0, 0xF5, 0x19, 0x90, 0xA4, 0x43, 0xE0, 0xFF, 0x85, 0x1A, 
+0x27, 0x7B, 0x01, 0xAD, 0x19, 0x02, 0x73, 0x7D, 0x90, 0xA5, 0x51, 0xEB, 0xF0, 0x70, 0x5B, 0x90, 
+0xA5, 0x51, 0xE0, 0xFE, 0x12, 0x77, 0x82, 0xE0, 0xFC, 0x90, 0xA5, 0x52, 0xE0, 0xFB, 0xEC, 0x6B, 
+0x60, 0x48, 0x90, 0xA5, 0x56, 0xEB, 0xF0, 0xA3, 0xEE, 0xF0, 0xAE, 0x05, 0xEE, 0x25, 0xE0, 0x4F, 
+0xFF, 0x90, 0xA1, 0x75, 0xE0, 0xFE, 0x25, 0xE0, 0x25, 0xE0, 0x4F, 0x90, 0xA5, 0x58, 0xF0, 0x90, 
+0xA5, 0x53, 0xE0, 0x90, 0xA5, 0x5A, 0xF0, 0x90, 0xA5, 0x54, 0x74, 0x0C, 0xF0, 0x90, 0xA5, 0x62, 
+0x74, 0x04, 0xF0, 0x7B, 0x01, 0x7A, 0xA5, 0x79, 0x54, 0x12, 0x97, 0x00, 0x90, 0xA5, 0x52, 0xE0, 
+0xFF, 0x90, 0xA5, 0x51, 0xE0, 0x12, 0x77, 0x82, 0xEF, 0xF0, 0x22, 0x90, 0x04, 0xA6, 0x74, 0x06, 
+0xF0, 0xE4, 0x90, 0xA4, 0x46, 0xF0, 0x90, 0xA4, 0x46, 0xE0, 0xFF, 0xC3, 0x94, 0x06, 0x50, 0x57, 
+0xEF, 0x90, 0x40, 0x56, 0x93, 0xFF, 0x94, 0x0A, 0x50, 0x02, 0x80, 0x02, 0x7F, 0x0A, 0xAE, 0x07, 
+0xEF, 0x24, 0x02, 0x90, 0xA4, 0x45, 0xF0, 0x90, 0xA4, 0x37, 0x74, 0x0E, 0xF0, 0x90, 0xA4, 0x39, 
+0x74, 0x01, 0xF0, 0x31, 0xE8, 0x90, 0xA4, 0x3A, 0xF0, 0xE4, 0xFF, 0xEF, 0xC3, 0x9E, 0x50, 0x16, 
+0x31, 0xE8, 0x2F, 0x51, 0x40, 0xE0, 0xFD, 0x74, 0x3B, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0xA4, 0xF5, 
+0x83, 0xED, 0xF0, 0x0F, 0x80, 0xE5, 0x7B, 0x01, 0x7A, 0xA4, 0x79, 0x37, 0x12, 0x97, 0x00, 0x90, 
+0xA4, 0x46, 0xE0, 0x04, 0xF0, 0x80, 0x9F, 0x22, 0x90, 0xA4, 0x46, 0xE0, 0x90, 0x40, 0x50, 0x93, 
+0x22, 0x90, 0xA4, 0x31, 0x12, 0x48, 0x7A, 0x90, 0x00, 0x05, 0x12, 0x26, 0x37, 0x30, 0xE1, 0x08, 
+0x90, 0x04, 0xA0, 0x74, 0x11, 0xF0, 0x21, 0x7B, 0x90, 0x04, 0xA0, 0x74, 0x22, 0x12, 0x4F, 0xC3, 
+0x12, 0x26, 0x1E, 0x90, 0xA4, 0x34, 0x12, 0x4F, 0xBC, 0x90, 0xA4, 0x35, 0x12, 0x4F, 0xB5, 0x90, 
+0xA4, 0x36, 0xF0, 0x12, 0x5F, 0xB2, 0x75, 0xF0, 0x10, 0xA4, 0xFF, 0x12, 0x5C, 0x33, 0xFD, 0xEF, 
+0x4D, 0xFF, 0x90, 0xA4, 0x35, 0xE0, 0xB4, 0x01, 0x06, 0xA3, 0xE0, 0x51, 0x40, 0xEF, 0xF0, 0x22, 
+0x24, 0x21, 0xF5, 0x82, 0xE4, 0x34, 0xA0, 0xF5, 0x83, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 
+0xD0, 0x90, 0xA5, 0xF3, 0xEF, 0xF0, 0x90, 0x00, 0x8F, 0xE0, 0x30, 0xE6, 0x3E, 0x90, 0x00, 0x8D, 
+0xE0, 0x64, 0x01, 0x70, 0x36, 0x90, 0xA5, 0xF4, 0xF0, 0x90, 0xA5, 0xF4, 0xE0, 0xFD, 0x90, 0xA5, 
+0xF3, 0xE0, 0x75, 0xF0, 0x10, 0x12, 0x6F, 0xEF, 0xE5, 0x82, 0x2D, 0x12, 0x72, 0x2A, 0xE0, 0xFB, 
+0xE4, 0xFF, 0x12, 0x5D, 0x3E, 0x90, 0xA5, 0xF4, 0xE0, 0x04, 0xF0, 0xE0, 0xC3, 0x94, 0x10, 0x40, 
+0xD8, 0x90, 0x00, 0x8F, 0xE0, 0x30, 0xE0, 0x03, 0x12, 0x5F, 0xC6, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 
+0x90, 0xA5, 0xF5, 0xEF, 0xF0, 0xA3, 0xED, 0xF0, 0x90, 0x00, 0xF1, 0xE0, 0x54, 0xF0, 0x64, 0x20, 
+0x60, 0x02, 0x61, 0x6E, 0x90, 0xA5, 0xF6, 0xE0, 0xB4, 0x01, 0x1D, 0x90, 0xA5, 0xF5, 0xE0, 0xB4, 
+0x0B, 0x16, 0x90, 0xA5, 0x78, 0x12, 0x27, 0x54, 0x00, 0x00, 0x0C, 0x00, 0x90, 0xA5, 0x7C, 0x12, 
+0x27, 0x54, 0x00, 0x00, 0x0C, 0x00, 0x80, 0x14, 0x90, 0xA5, 0x78, 0x12, 0x27, 0x54, 0x00, 0x00, 
+0x0C, 0x00, 0x90, 0xA5, 0x7C, 0x12, 0x27, 0x54, 0x00, 0x00, 0x08, 0x00, 0x71, 0xB9, 0x90, 0xA5, 
+0xF6, 0xE0, 0x70, 0x20, 0x71, 0xC0, 0x60, 0x04, 0xEF, 0xB4, 0x0E, 0x18, 0x90, 0xA5, 0x78, 0x12, 
+0x27, 0x54, 0x00, 0x00, 0x03, 0x00, 0x90, 0xA5, 0x7C, 0x12, 0x27, 0x54, 0x00, 0x00, 0x03, 0x00, 
+0x71, 0xB9, 0x80, 0x0E, 0x90, 0xA5, 0xF6, 0xE0, 0xB4, 0x01, 0x1D, 0x90, 0xA5, 0xF5, 0xE0, 0xB4, 
+0x0B, 0x16, 0x90, 0xA5, 0x78, 0x12, 0x27, 0x54, 0x40, 0x00, 0x00, 0x00, 0x90, 0xA5, 0x7C, 0x12, 
+0x27, 0x54, 0x40, 0x00, 0x00, 0x00, 0x80, 0x32, 0x90, 0xA5, 0xF6, 0xE0, 0x64, 0x02, 0x60, 0x78, 
+0x90, 0xA5, 0x78, 0x12, 0x27, 0x54, 0x00, 0x00, 0x03, 0x00, 0x90, 0xA5, 0x7C, 0x12, 0x27, 0x54, 
+0x00, 0x00, 0x02, 0x00, 0x7F, 0xAC, 0x12, 0x86, 0x48, 0x12, 0x27, 0x54, 0x40, 0x00, 0x00, 0x00, 
+0x90, 0xA5, 0x7C, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xC4, 0x80, 0x45, 0x90, 0xA5, 
+0xF6, 0xE0, 0x70, 0x20, 0x71, 0xC0, 0x60, 0x04, 0xEF, 0xB4, 0x0E, 0x18, 0x90, 0xA5, 0x78, 0x12, 
+0x27, 0x54, 0x00, 0x00, 0x03, 0x00, 0x90, 0xA5, 0x7C, 0x12, 0x27, 0x54, 0x00, 0x00, 0x03, 0x00, 
+0x7F, 0xAC, 0x80, 0x1F, 0x90, 0xA5, 0xF5, 0xE0, 0xD3, 0x94, 0x0E, 0x50, 0x1B, 0x90, 0xA5, 0x78, 
+0x12, 0x27, 0x54, 0x00, 0x00, 0x03, 0x00, 0x90, 0xA5, 0x7C, 0x12, 0x27, 0x54, 0x00, 0x00, 0x02, 
+0x00, 0x7F, 0xAC, 0x7E, 0x08, 0x12, 0x86, 0x54, 0x22, 0x7F, 0xAC, 0x7E, 0x08, 0x02, 0x86, 0x54, 
+0x90, 0xA5, 0xF5, 0xE0, 0xFF, 0x64, 0x0D, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 
+0xA5, 0xD1, 0xED, 0xF0, 0xA3, 0xEB, 0xF0, 0x90, 0xA5, 0xD0, 0xEF, 0xF0, 0x90, 0xA5, 0xD3, 0xE0, 
+0xFD, 0xD1, 0x3C, 0x90, 0xA5, 0xD0, 0xE0, 0xC3, 0x94, 0x0E, 0x50, 0x40, 0x90, 0xA5, 0x78, 0x12, 
+0x27, 0x54, 0x1F, 0xFE, 0x00, 0x00, 0x90, 0xA5, 0x7C, 0x12, 0x27, 0x54, 0x12, 0xD4, 0x00, 0x00, 
+0xD1, 0x21, 0x90, 0xA5, 0x66, 0x12, 0x27, 0x54, 0x00, 0x07, 0x03, 0x00, 0x90, 0xA5, 0x6A, 0x12, 
+0x27, 0x54, 0x00, 0x00, 0x00, 0x00, 0x12, 0x96, 0x46, 0x12, 0x27, 0x54, 0x00, 0x07, 0x03, 0x00, 
+0x90, 0xA5, 0x6A, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0x00, 0xA1, 0x4A, 0xD1, 0x32, 0x50, 0x1B, 
+0xEF, 0x94, 0x30, 0x50, 0x16, 0x90, 0xA5, 0x78, 0x12, 0x27, 0x54, 0x1F, 0xFE, 0x00, 0x00, 0x90, 
+0xA5, 0x7C, 0x12, 0x27, 0x54, 0x09, 0x28, 0x00, 0x00, 0x80, 0x64, 0x90, 0xA5, 0xD0, 0xE0, 0xFF, 
+0x74, 0x32, 0xD3, 0x9F, 0x50, 0x1B, 0xEF, 0x94, 0x40, 0x50, 0x16, 0x90, 0xA5, 0x78, 0x12, 0x27, 
+0x54, 0x1F, 0xFE, 0x00, 0x00, 0x90, 0xA5, 0x7C, 0x12, 0x27, 0x54, 0x08, 0xA6, 0x00, 0x00, 0x80, 
+0x3E, 0xD1, 0x28, 0x50, 0x1B, 0xEF, 0x94, 0x74, 0x50, 0x16, 0x90, 0xA5, 0x78, 0x12, 0x27, 0x54, 
+0x1F, 0xFE, 0x00, 0x00, 0x90, 0xA5, 0x7C, 0x12, 0x27, 0x54, 0x08, 0xA4, 0x00, 0x00, 0x80, 0x1F, 
+0x90, 0xA5, 0xD0, 0xE0, 0xFF, 0x74, 0x76, 0xD3, 0x9F, 0x50, 0x16, 0x90, 0xA5, 0x78, 0x12, 0x27, 
+0x54, 0x1F, 0xFE, 0x00, 0x00, 0x90, 0xA5, 0x7C, 0x12, 0x27, 0x54, 0x08, 0x24, 0x00, 0x00, 0xD1, 
+0x21, 0xD1, 0x32, 0x50, 0x2F, 0xEF, 0x94, 0x40, 0x50, 0x2A, 0x90, 0xA5, 0x66, 0x12, 0x27, 0x54, 
+0x00, 0x07, 0x03, 0x00, 0x90, 0xA5, 0x6A, 0x12, 0x27, 0x54, 0x00, 0x01, 0x01, 0x00, 0x12, 0x96, 
+0x46, 0x12, 0x27, 0x54, 0x00, 0x07, 0x03, 0x00, 0x90, 0xA5, 0x6A, 0x12, 0x27, 0x54, 0x00, 0x01, 
+0x01, 0x00, 0x80, 0x66, 0xD1, 0x28, 0x50, 0x2F, 0xEF, 0x94, 0x8C, 0x50, 0x2A, 0x90, 0xA5, 0x66, 
+0x12, 0x27, 0x54, 0x00, 0x07, 0x03, 0x00, 0x90, 0xA5, 0x6A, 0x12, 0x27, 0x54, 0x00, 0x03, 0x01, 
+0x00, 0x12, 0x96, 0x46, 0x12, 0x27, 0x54, 0x00, 0x07, 0x03, 0x00, 0x90, 0xA5, 0x6A, 0x12, 0x27, 
+0x54, 0x00, 0x03, 0x01, 0x00, 0x80, 0x33, 0x90, 0xA5, 0xD0, 0xE0, 0xFF, 0x74, 0x8C, 0xC3, 0x9F, 
+0x50, 0x2E, 0x90, 0xA5, 0x66, 0x12, 0x27, 0x54, 0x00, 0x07, 0x03, 0x00, 0x90, 0xA5, 0x6A, 0x12, 
+0x27, 0x54, 0x00, 0x05, 0x01, 0x00, 0x12, 0x96, 0x46, 0x12, 0x27, 0x54, 0x00, 0x07, 0x03, 0x00, 
+0x90, 0xA5, 0x6A, 0x12, 0x27, 0x54, 0x00, 0x05, 0x01, 0x00, 0x12, 0x97, 0x9A, 0x12, 0x96, 0x52, 
+0x90, 0xA5, 0xD0, 0xE0, 0xFF, 0xA3, 0xE0, 0xFD, 0x51, 0xA0, 0x90, 0xA5, 0xD1, 0xE0, 0x64, 0x02, 
+0x70, 0x51, 0x90, 0xA5, 0xD0, 0xE0, 0xFF, 0xD3, 0x94, 0x30, 0x50, 0x05, 0x75, 0x74, 0x2A, 0x80, 
+0x5E, 0xEF, 0xD3, 0x94, 0x40, 0x50, 0x05, 0x75, 0x74, 0x3A, 0x80, 0x53, 0xEF, 0xD3, 0x94, 0x70, 
+0x50, 0x05, 0x75, 0x74, 0x6A, 0x80, 0x48, 0xEF, 0xD3, 0x94, 0x80, 0x50, 0x05, 0x75, 0x74, 0x7A, 
+0x80, 0x3D, 0xEF, 0xD3, 0x94, 0x90, 0x50, 0x05, 0x75, 0x74, 0x8A, 0x80, 0x32, 0xEF, 0xD3, 0x94, 
+0xA1, 0x50, 0x05, 0x75, 0x74, 0x9B, 0x80, 0x27, 0xEF, 0xD3, 0x94, 0xB1, 0x50, 0x21, 0x75, 0x74, 
+0xAB, 0x80, 0x1C, 0x90, 0xA5, 0xD1, 0xE0, 0x64, 0x01, 0x70, 0x32, 0xA3, 0xE0, 0x90, 0xA5, 0xD0, 
+0xB4, 0x01, 0x07, 0xE0, 0x24, 0x02, 0xF5, 0x74, 0x80, 0x05, 0xE0, 0x24, 0xFE, 0xF5, 0x74, 0x90, 
+0xA5, 0x66, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0xFF, 0xAF, 0x74, 0xE4, 0xFC, 0xFD, 0xFE, 0x12, 
+0x96, 0x40, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0xFF, 0xAF, 0x74, 0x80, 0x1F, 0x90, 0xA5, 0x66, 
+0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0xFF, 0x90, 0xA5, 0xD0, 0x12, 0x66, 0xFF, 0x12, 0x96, 0x40, 
+0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0xFF, 0x90, 0xA5, 0xD0, 0xE0, 0xFF, 0xE4, 0xFC, 0xFD, 0xFE, 
+0x90, 0xA5, 0x6A, 0x12, 0x27, 0x48, 0x12, 0x97, 0x9A, 0x12, 0x96, 0x52, 0xD0, 0xD0, 0x92, 0xAF, 
+0x22, 0x7F, 0x60, 0x7E, 0x08, 0x02, 0x86, 0x54, 0x90, 0xA5, 0xD0, 0xE0, 0xFF, 0x74, 0x64, 0xD3, 
+0x9F, 0x22, 0x90, 0xA5, 0xD0, 0xE0, 0xFF, 0x74, 0x24, 0xD3, 0x9F, 0x22, 0x90, 0xA5, 0xF8, 0xED, 
+0xF0, 0x90, 0xA5, 0xF7, 0xEF, 0xF0, 0xD3, 0x94, 0x0E, 0x50, 0x15, 0xD1, 0x7B, 0xEF, 0x60, 0x2A, 
+0xD1, 0x7B, 0xEF, 0x64, 0x01, 0x70, 0x23, 0x90, 0xA5, 0xF8, 0xE0, 0xFD, 0xE4, 0xFF, 0x80, 0x15, 
+0x90, 0xA5, 0xF7, 0xE0, 0xD3, 0x94, 0x0E, 0x40, 0x11, 0xD1, 0x7B, 0xEF, 0x70, 0x0A, 0x90, 0xA5, 
+0xF8, 0xE0, 0xFD, 0x7F, 0x01, 0x02, 0x86, 0xB3, 0xD1, 0x7B, 0x22, 0x90, 0x04, 0x54, 0xE0, 0x7F, 
+0x00, 0x30, 0xE7, 0x02, 0x7F, 0x01, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0xA9, 0x07, 
+0x90, 0x06, 0x69, 0xE0, 0xFE, 0x90, 0x06, 0x68, 0xE0, 0x7A, 0x00, 0x24, 0x00, 0xFF, 0xEA, 0x3E, 
+0xFE, 0xE9, 0x14, 0x60, 0x0F, 0x14, 0x60, 0x1E, 0x24, 0x02, 0x70, 0x25, 0xEE, 0x54, 0xFE, 0xFE, 
+0xD1, 0xD6, 0x80, 0x1A, 0xEF, 0x44, 0x80, 0xFF, 0xEE, 0x54, 0xFE, 0xFC, 0x90, 0x06, 0x68, 0xEF, 
+0xF0, 0xEC, 0xA3, 0xF0, 0x80, 0x0B, 0xEE, 0x44, 0x01, 0xFC, 0xD1, 0xD6, 0xAE, 0x04, 0xEE, 0xA3, 
+0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xEF, 0x54, 0x7F, 0x90, 0x06, 0x68, 0xF0, 0x22, 0xE4, 0xFE, 
+0xFC, 0xEF, 0x64, 0x02, 0x70, 0x40, 0xED, 0xB4, 0x01, 0x04, 0x7E, 0x0A, 0x80, 0x06, 0xED, 0xB4, 
+0x02, 0x02, 0x7E, 0x09, 0xEB, 0xB4, 0x01, 0x08, 0xED, 0xB4, 0x01, 0x04, 0x7C, 0x04, 0x80, 0x38, 
+0xEB, 0xB4, 0x02, 0x08, 0xED, 0xB4, 0x01, 0x04, 0x7C, 0x02, 0x80, 0x2C, 0xEB, 0xB4, 0x01, 0x08, 
+0xED, 0xB4, 0x02, 0x04, 0x7C, 0x01, 0x80, 0x20, 0xEB, 0x64, 0x02, 0x70, 0x1B, 0xED, 0x64, 0x02, 
+0x70, 0x16, 0x7C, 0x03, 0x80, 0x12, 0xEF, 0xB4, 0x01, 0x0E, 0xEB, 0xB4, 0x02, 0x04, 0x7C, 0x01, 
+0x80, 0x06, 0xEB, 0xB4, 0x01, 0x02, 0x7C, 0x02, 0xAF, 0x06, 0xEF, 0xC4, 0x54, 0xF0, 0x4C, 0xFF, 
+0x22, 0xE4, 0xFE, 0xEF, 0x54, 0xE0, 0xC4, 0x13, 0x54, 0x07, 0xFD, 0xEF, 0x54, 0x1F, 0xFF, 0xED, 
+0x60, 0x2C, 0x14, 0x60, 0x1E, 0x24, 0xFD, 0x60, 0x0F, 0x24, 0xFE, 0x70, 0x2A, 0xEF, 0x25, 0xE0, 
+0xFF, 0xC3, 0x74, 0xDE, 0x9F, 0xFE, 0x80, 0x1F, 0xEF, 0x25, 0xE0, 0xFF, 0xC3, 0x74, 0xF2, 0x9F, 
+0xFE, 0x80, 0x14, 0xEF, 0x25, 0xE0, 0xFF, 0xC3, 0x74, 0x06, 0x9F, 0xFE, 0x80, 0x09, 0xEF, 0x25, 
+0xE0, 0xFF, 0xC3, 0x74, 0x10, 0x9F, 0xFE, 0xAF, 0x06, 0x22, 0xD3, 0xEF, 0x64, 0x80, 0x94, 0x1C, 
+0x40, 0x07, 0xEF, 0x64, 0x80, 0x94, 0x94, 0x40, 0x03, 0x7F, 0x00, 0x22, 0xC3, 0xEF, 0x64, 0x80, 
+0x94, 0x80, 0x40, 0x03, 0x7F, 0x64, 0x22, 0xEF, 0x24, 0x64, 0xFF, 0x22, 0x90, 0xA5, 0x78, 0x12, 
+0x27, 0x54, 0x80, 0x00, 0x00, 0x00, 0x90, 0xA5, 0x7C, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0x00, 
+0x12, 0x86, 0x50, 0x90, 0x05, 0x22, 0x74, 0x3F, 0xF0, 0x90, 0x05, 0x50, 0xE0, 0x54, 0xF7, 0xF0, 
+0xA3, 0xE0, 0x54, 0xF7, 0xF0, 0x90, 0xA5, 0x78, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0xFF, 0x90, 
+0xA5, 0x7C, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0x00, 0x74, 0x08, 0xFF, 0xFE, 0x12, 0x86, 0x4A, 
+0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0x0F, 0x90, 0xA5, 0x7C, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 
+0x0C, 0x12, 0x86, 0x46, 0x12, 0x27, 0x54, 0xFF, 0x00, 0x00, 0x00, 0x90, 0xA5, 0x7C, 0x12, 0x27, 
+0x54, 0x00, 0x00, 0x00, 0x0F, 0x7F, 0x04, 0x7E, 0x0A, 0x02, 0x86, 0x54, 0x90, 0xA4, 0x19, 0xE0, 
+0x75, 0xF0, 0x3F, 0x84, 0xAD, 0xF0, 0xED, 0x25, 0xE0, 0x25, 0xE0, 0xFD, 0x74, 0x38, 0x2F, 0xF5, 
+0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xED, 0xF0, 0x90, 0xA4, 0x19, 0xE0, 0x04, 0xF0, 0x22, 0x7E, 
+0x00, 0x7F, 0x01, 0x7D, 0x00, 0x7B, 0x01, 0x7A, 0xA2, 0x79, 0x83, 0x12, 0x48, 0xA9, 0x90, 0xA2, 
+0x83, 0xE0, 0x54, 0xFD, 0xF0, 0xE4, 0x12, 0x50, 0x69, 0xA3, 0x74, 0x0C, 0xF0, 0x22, 0x11, 0x7A, 
+0xE4, 0x90, 0xA2, 0x86, 0xF0, 0x22, 0x11, 0x74, 0x80, 0xF4, 0x12, 0x67, 0xD2, 0x80, 0xEF, 0x12, 
+0x67, 0xDA, 0x80, 0xEA, 0x12, 0x53, 0xCB, 0x02, 0x67, 0xCB, 0x90, 0x05, 0x27, 0xE0, 0x54, 0xBF, 
+0xF0, 0x22, 0x7D, 0x2E, 0x7F, 0x6F, 0x12, 0x53, 0xE1, 0x7D, 0x02, 0x7F, 0x01, 0x12, 0x51, 0x55, 
+0x11, 0x7A, 0x90, 0xA2, 0x87, 0x74, 0x02, 0xF0, 0x22, 0x7D, 0x21, 0x7F, 0xFF, 0x12, 0x53, 0xE1, 
+0x02, 0x9F, 0xB8, 0x12, 0x67, 0xCB, 0x80, 0xF1, 0x12, 0x67, 0xCB, 0x02, 0x57, 0xEF, 0x12, 0x67, 
+0xCB, 0x02, 0x67, 0xE2, 0x7D, 0x22, 0x7F, 0xFF, 0x12, 0x53, 0xE1, 0x12, 0x9F, 0xCD, 0x02, 0x9F, 
+0xB8, 0x7D, 0x25, 0x02, 0x57, 0xF1, 0xEF, 0x24, 0xFE, 0x60, 0x0B, 0x04, 0x70, 0x24, 0x90, 0xA2, 
+0x92, 0x74, 0x02, 0xF0, 0x80, 0x13, 0xED, 0x70, 0x06, 0x90, 0xA3, 0x37, 0xE0, 0x80, 0x02, 0xED, 
+0x14, 0x90, 0xA2, 0x92, 0xF0, 0x90, 0xA2, 0x92, 0xE0, 0xA3, 0xF0, 0x90, 0xA2, 0x89, 0xE0, 0x44, 
+0x08, 0xF0, 0x22, 0x12, 0x7F, 0xBE, 0xEF, 0x64, 0x01, 0x70, 0x32, 0x90, 0xA2, 0x90, 0xE0, 0xFF, 
+0x54, 0x03, 0x70, 0x29, 0x90, 0xA2, 0x8E, 0xE0, 0xFE, 0xE4, 0xC3, 0x9E, 0x40, 0x1F, 0xEF, 0x20, 
+0xE2, 0x1B, 0x90, 0xA2, 0x90, 0xE0, 0x20, 0xE4, 0x14, 0x90, 0xA2, 0x89, 0xE0, 0x13, 0x13, 0x54, 
+0x3F, 0x30, 0xE0, 0x09, 0x90, 0xA3, 0x3A, 0xE0, 0x70, 0x03, 0x7F, 0x01, 0x22, 0x7F, 0x00, 0x22, 
+0x90, 0x06, 0x04, 0xE0, 0x54, 0x7F, 0xF0, 0x12, 0x53, 0xCB, 0x7D, 0x0C, 0x7F, 0x01, 0x02, 0x51, 
+0x55, 0x12, 0x53, 0xCB, 0x12, 0x53, 0xBF, 0x12, 0x9F, 0xCD, 0x02, 0x53, 0xB7, 0xE4, 0xFE, 0x74, 
+0xA9, 0x2E, 0xF5, 0x82, 0xE4, 0x34, 0xA2, 0xF5, 0x83, 0xE4, 0xF0, 0x0E, 0xEE, 0xB4, 0x19, 0xEF, 
+0xE4, 0x90, 0xA2, 0xA2, 0xF0, 0x90, 0xA2, 0xA6, 0xF0, 0x90, 0xA2, 0x9E, 0xF0, 0xEF, 0xB4, 0x01, 
+0x09, 0x90, 0xA2, 0xA7, 0x74, 0x19, 0xF0, 0xE4, 0xA3, 0xF0, 0x22, 0x7D, 0x2F, 0x7F, 0xFF, 0x12, 
+0x53, 0xE1, 0x12, 0x9E, 0xEF, 0x7D, 0x08, 0x7F, 0x01, 0x12, 0x51, 0x55, 0x90, 0xA2, 0x87, 0x74, 
+0x08, 0xF0, 0x22, 0x12, 0x9D, 0xA8, 0x12, 0x53, 0xCB, 0x12, 0x51, 0x51, 0x90, 0xA2, 0x87, 0x74, 
+0x0C, 0xF0, 0x22, 0x90, 0xA5, 0xB3, 0xE0, 0xFF, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 
+0xA6, 0x02, 0xEF, 0xF0, 0x90, 0xA1, 0x7F, 0xE0, 0xFF, 0x90, 0x04, 0x1C, 0xE0, 0x6F, 0x70, 0x3E, 
+0x90, 0xA2, 0x8F, 0xE0, 0x64, 0x0E, 0x70, 0x15, 0x90, 0xA6, 0x02, 0xE0, 0x70, 0x30, 0x90, 0xA2, 
+0x88, 0xE0, 0x54, 0x7F, 0xF0, 0x90, 0x06, 0x04, 0x12, 0x51, 0x4D, 0x80, 0x1E, 0x90, 0xA2, 0x8F, 
+0xE0, 0x64, 0x06, 0x70, 0x19, 0x90, 0xA6, 0x02, 0xE0, 0x60, 0x13, 0x90, 0xA2, 0x88, 0xE0, 0x54, 
+0xBF, 0xF0, 0x51, 0x03, 0xF0, 0x90, 0xA2, 0x8F, 0x74, 0x04, 0xF0, 0x12, 0x53, 0xCB, 0xD0, 0xD0, 
+0x92, 0xAF, 0x22, 0x90, 0x06, 0x04, 0xE0, 0x44, 0x40, 0xF0, 0xE0, 0x44, 0x80, 0x22, 0xE4, 0xFE, 
+0xEF, 0x25, 0xE0, 0xFD, 0xEF, 0xC3, 0x94, 0x80, 0x90, 0xFD, 0x12, 0x50, 0x04, 0xE4, 0xF0, 0x80, 
+0x03, 0x74, 0x01, 0xF0, 0x90, 0xFD, 0x10, 0xED, 0xF0, 0xAF, 0x06, 0x22, 0x12, 0x37, 0x5D, 0x90, 
+0xA4, 0x98, 0xE0, 0x75, 0xF0, 0x1E, 0xA4, 0x22, 0x90, 0xA2, 0x95, 0xE0, 0x04, 0xF0, 0x90, 0xA2, 
+0x90, 0xE0, 0x54, 0xEF, 0xF0, 0x90, 0xA3, 0x34, 0xE0, 0xFF, 0x90, 0xA2, 0x95, 0xE0, 0xD3, 0x9F, 
+0x22, 0x90, 0xA4, 0x9B, 0xE0, 0x75, 0xF0, 0x08, 0xA4, 0x24, 0xA0, 0xF5, 0x82, 0xE4, 0x34, 0xA4, 
+0x22, 0x75, 0xF0, 0x08, 0xA4, 0x24, 0x9C, 0xF5, 0x82, 0xE4, 0x34, 0xA4, 0x22, 0x12, 0x47, 0xDF, 
+0x90, 0xA4, 0xEC, 0x12, 0x27, 0x48, 0x90, 0xA4, 0x98, 0xE0, 0xFF, 0x22, 0xA4, 0x24, 0xCF, 0xF5, 
+0x82, 0xE4, 0x34, 0x44, 0x22, 0x90, 0xA3, 0x6A, 0xE0, 0x54, 0xE0, 0xC4, 0x13, 0x54, 0x07, 0xFF, 
+0x22, 0x74, 0x21, 0x25, 0x0D, 0xF5, 0x82, 0xE4, 0x34, 0x9D, 0xF5, 0x83, 0x22, 0x12, 0x36, 0xCE, 
+0xE4, 0xFF, 0xFE, 0xEC, 0x54, 0x07, 0xFC, 0x90, 0xA5, 0x10, 0x12, 0x27, 0x48, 0x90, 0xA4, 0xEF, 
+0x74, 0x01, 0xF0, 0x22, 0x90, 0xA3, 0x34, 0x74, 0x02, 0xF0, 0xA3, 0x74, 0x0F, 0xF0, 0xA3, 0xE0, 
+0x54, 0x01, 0x44, 0x1E, 0xF0, 0xA3, 0x74, 0x07, 0x22, 0x74, 0xA1, 0x25, 0x20, 0xF5, 0x82, 0xE4, 
+0x34, 0x9F, 0xF5, 0x83, 0x22, 0x12, 0x37, 0x5D, 0x90, 0xA4, 0x98, 0xE0, 0x75, 0xF0, 0x0C, 0xA4, 
+0x24, 0xBD, 0xF5, 0x82, 0xE4, 0x22, 0xFD, 0x7C, 0x00, 0x12, 0x26, 0x98, 0xEF, 0x25, 0x11, 0xF5, 
+0x11, 0xEE, 0x35, 0x10, 0xF5, 0x10, 0x22, 0x90, 0x05, 0x62, 0xE0, 0xFE, 0x90, 0x05, 0x61, 0xE0, 
+0xFD, 0xED, 0x78, 0x02, 0x22, 0xE0, 0x75, 0xF0, 0x0C, 0xA4, 0x24, 0xBB, 0xF5, 0x82, 0xE4, 0x34, 
+0x44, 0x22, 0x12, 0x87, 0xF0, 0x90, 0xA4, 0x99, 0x02, 0x48, 0x71, 0x90, 0xA3, 0x4B, 0x12, 0x48, 
+0x65, 0xE0, 0xFF, 0x7E, 0x00, 0x7D, 0x01, 0x22, 0x25, 0xE0, 0x24, 0x3D, 0xF5, 0x82, 0xE4, 0x34, 
+0x43, 0xF5, 0x83, 0x22, 0x12, 0x36, 0xCE, 0xEF, 0x54, 0x1F, 0xFF, 0xE4, 0xFE, 0xFD, 0xFC, 0x22, 
+0x12, 0x48, 0x65, 0xE0, 0xFC, 0xA3, 0xE0, 0xF5, 0x82, 0x8C, 0x83, 0x22, 0x74, 0x01, 0x25, 0x0D, 
+0xF5, 0x82, 0xE4, 0x34, 0x94, 0xF5, 0x83, 0x22, 0x74, 0x91, 0x25, 0x0D, 0xF5, 0x82, 0xE4, 0x34, 
+0x9A, 0xF5, 0x83, 0x22, 0xF0, 0x7F, 0xB0, 0x7E, 0x0C, 0x12, 0x36, 0xCE, 0x90, 0xA2, 0x9A, 0x22, 
+0xEF, 0x13, 0x13, 0x13, 0x54, 0x1F, 0xFE, 0xEF, 0x54, 0x07, 0xFF, 0x22, 0xE0, 0xC4, 0x13, 0x13, 
+0x54, 0x03, 0x22, 0xE0, 0xFF, 0xAE, 0x22, 0x74, 0x01, 0xA8, 0x06, 0x08, 0x22, 0x12, 0x47, 0x77, 
+0x90, 0xA2, 0xC9, 0x02, 0x27, 0x48, 0x90, 0xA5, 0xE7, 0xF0, 0xE0, 0x90, 0x04, 0x54, 0xF0, 0x22, 
+0x90, 0xA3, 0x3C, 0xE0, 0xFE, 0xC3, 0x13, 0x54, 0x07, 0x22, 0x90, 0xA5, 0xCF, 0xE0, 0xFF, 0x90, 
+0xA5, 0xCD, 0xE0, 0x22, 0x90, 0xA4, 0x30, 0x12, 0x48, 0x71, 0x75, 0xF0, 0x02, 0x22, 0xD3, 0xE5, 
+0x13, 0x94, 0xE8, 0xE5, 0x12, 0x94, 0x03, 0x22, 0xD3, 0x9F, 0xEE, 0x64, 0x80, 0xF8, 0x74, 0x80, 
+0x98, 0x22, 0x74, 0x01, 0x93, 0x95, 0x11, 0xE4, 0x93, 0x95, 0x10, 0x22, 0xE5, 0x12, 0xC3, 0x13, 
+0xFE, 0xE5, 0x13, 0x13, 0xFF, 0x22, 0xD2, 0xAF, 0xC2, 0xAF, 0x90, 0xA1, 0x76, 0xE0, 0xFF, 0x22, 
+0x90, 0x04, 0x1F, 0x74, 0x20, 0xF0, 0x7F, 0x01, 0x22, 0xF0, 0x90, 0x06, 0x0A, 0xE0, 0x54, 0xF8, 
+0xF0, 0x22, 0x54, 0x01, 0xC4, 0x33, 0x33, 0x33, 0x54, 0x80, 0x22, 0xEF, 0xF0, 0xA3, 0xED, 0xF0, 
+0xE4, 0xA3, 0xF0, 0x22, 0xE4, 0x90, 0xA5, 0x9B, 0xF0, 0xA3, 0x74, 0x03, 0x22, 0x90, 0xA4, 0x43, 
+0xE0, 0xFE, 0x75, 0xF0, 0x04, 0x22, 0x90, 0xA4, 0x98, 0xE0, 0xFF, 0x7D, 0x8F, 0x22, 0x12, 0x47, 
+0x17, 0xAE, 0xF0, 0xA8, 0x15, 0x22, 0x90, 0xA2, 0x88, 0xE0, 0xFF, 0x13, 0x13, 0x22, 0x90, 0xA2, 
+0x92, 0xE0, 0x90, 0x05, 0x73, 0x22, 0x90, 0xA2, 0x90, 0xE0, 0x44, 0x10, 0xF0, 0x22, 0x90, 0xA4, 
+0x98, 0xE0, 0xFF, 0x7D, 0x32, 0x22, 0x90, 0xA4, 0x98, 0xE0, 0xFF, 0x7D, 0x31, 0x22, 0x90, 0xA4, 
+0x98, 0xE0, 0xFF, 0x7D, 0x30, 0x22, 0xC4, 0x54, 0x0F, 0x90, 0xA5, 0xD3, 0xF0, 0x22, 0x2F, 0xF8, 
+0xE6, 0xFE, 0xED, 0xF4, 0x5E, 0x22, 0xE5, 0x13, 0xAE, 0x12, 0xA8, 0x15, 0x08, 0x22, 0xFF, 0xEE, 
+0x5C, 0xFE, 0xEF, 0x5D, 0x4E, 0x22, 0xFE, 0x33, 0x33, 0x33, 0x54, 0xF8, 0x4F, 0x22, 0x54, 0x03, 
+0x4F, 0xFF, 0x75, 0xF0, 0x10, 0x22, 0x74, 0x01, 0x7E, 0x00, 0xA8, 0x22, 0x08, 0x22, 0xEE, 0x26, 
+
+};
+u4Byte ArrayLength_MP_8812A_FW_NIC = 31936;
+
+
+void
+ODM_ReadFirmware_MP_8812A_FW_NIC(
+     IN   PDM_ODM_T    pDM_Odm,
+     OUT  u1Byte       *pFirmware,
+     OUT  u4Byte       *pFirmwareSize
+)
+{
+#if (DM_ODM_SUPPORT_TYPE & (ODM_CE))
+	*((SIZE_PTR *)pFirmware) = (SIZE_PTR)Array_MP_8812A_FW_NIC;
+#else
+	ODM_MoveMemory(pDM_Odm, pFirmware, Array_MP_8812A_FW_NIC, ArrayLength_MP_8812A_FW_NIC);
+#endif
+	*pFirmwareSize = ArrayLength_MP_8812A_FW_NIC;
+}
+
+
+u1Byte Array_MP_8812A_FW_NIC_BT[] = {
+0x01, 0x95, 0x13, 0x00, 0x26, 0x00, 0x00, 0x00, 0x11, 0x04, 0x19, 0x54, 0xA4, 0x74, 0x00, 0x00, 
+0x81, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x02, 0x4A, 0x9A, 0x02, 0x88, 0x9E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x02, 0x89, 0xCC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x02, 0x97, 0xE3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x02, 0x89, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x8F, 0xE8, 0x00, 0x00, 
+0x00, 0x04, 0x0C, 0x14, 0x2C, 0x36, 0x04, 0x08, 0x08, 0x08, 0x0A, 0x0A, 0x15, 0xF0, 0xFF, 0x0F, 
+0x00, 0x00, 0x00, 0x15, 0xF0, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x05, 0xF0, 0xFF, 0x0F, 0x00, 0x00, 
+0x00, 0x05, 0xF0, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x10, 0xF0, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x10, 
+0xF0, 0x0F, 0x00, 0x00, 0x00, 0x00, 0xF5, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x0F, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0xF0, 0xFF, 0xFF, 0x00, 
+0x00, 0x00, 0x10, 0xF0, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x15, 0xF0, 0x3F, 0x00, 0x00, 0x00, 0x00, 
+0x15, 0xF0, 0xCF, 0xFF, 0x00, 0x00, 0x00, 0x16, 0x0D, 0x17, 0x0E, 0x17, 0x0F, 0x18, 0x10, 0x19, 
+0x11, 0x1A, 0x12, 0x1A, 0x13, 0x1A, 0x14, 0x1A, 0x15, 0x1B, 0xFF, 0x17, 0x0E, 0x18, 0x10, 0x19, 
+0x11, 0x1A, 0x12, 0x1B, 0x15, 0x1C, 0xFF, 0x1D, 0xFF, 0x1E, 0xFF, 0x1F, 0xFF, 0xFF, 0xFF, 0x14, 
+0x0D, 0x0E, 0x15, 0x15, 0x0F, 0x16, 0x10, 0x17, 0x11, 0x18, 0x12, 0x18, 0x13, 0x18, 0xFF, 0x15, 
+0x0D, 0x16, 0x10, 0x10, 0x17, 0x18, 0x12, 0x19, 0xFF, 0x1A, 0xFF, 0x1B, 0xFF, 0x1C, 0xFF, 0x00, 
+0x00, 0x00, 0x00, 0x04, 0x04, 0x0C, 0x0C, 0x0D, 0x0C, 0x0E, 0x0D, 0x0F, 0x17, 0x18, 0x10, 0x19, 
+0x11, 0x19, 0x11, 0x19, 0x12, 0x1A, 0x14, 0x0C, 0x0C, 0x16, 0x0D, 0x17, 0x0F, 0x18, 0x10, 0x19, 
+0x13, 0x1A, 0x14, 0x1B, 0x15, 0x1C, 0x1B, 0x1D, 0x1C, 0x1E, 0x1D, 0x04, 0x04, 0x0C, 0x14, 0x0D, 
+0x14, 0x0E, 0x14, 0x0F, 0x15, 0x10, 0x16, 0x17, 0x11, 0x12, 0x17, 0x0C, 0x0C, 0x14, 0x0E, 0x15, 
+0x0F, 0x16, 0x10, 0x17, 0x12, 0x18, 0x18, 0x19, 0x19, 0x1A, 0x19, 0x0A, 0x08, 0x03, 0x03, 0x00, 
+0x04, 0x09, 0x07, 0x03, 0x03, 0x00, 0x04, 0x08, 0x06, 0x03, 0x02, 0x00, 0x04, 0x08, 0x05, 0x03, 
+0x01, 0x00, 0x04, 0x0D, 0x0A, 0x07, 0x05, 0x00, 0x08, 0x0C, 0x0A, 0x07, 0x04, 0x00, 0x08, 0x0B, 
+0x0A, 0x06, 0x05, 0x00, 0x08, 0x0B, 0x0A, 0x05, 0x03, 0x00, 0x08, 0x0B, 0x0A, 0x03, 0x02, 0x00, 
+0x08, 0x14, 0x12, 0x0C, 0x04, 0x00, 0x10, 0x14, 0x12, 0x09, 0x04, 0x00, 0x10, 0x24, 0x22, 0x1C, 
+0x12, 0x00, 0x20, 0x24, 0x22, 0x18, 0x0C, 0x00, 0x20, 0x24, 0x22, 0x14, 0x06, 0x00, 0x20, 0x24, 
+0x22, 0x0F, 0x04, 0x00, 0x20, 0x24, 0x21, 0x0A, 0x04, 0x00, 0x20, 0x23, 0x21, 0x0C, 0x04, 0x00, 
+0x20, 0x23, 0x1F, 0x0A, 0x04, 0x00, 0x20, 0x22, 0x1F, 0x0F, 0x04, 0x00, 0x20, 0x21, 0x1F, 0x16, 
+0x0C, 0x00, 0x20, 0x31, 0x2F, 0x20, 0x14, 0x00, 0x30, 0x31, 0x2F, 0x18, 0x10, 0x00, 0x30, 0x31, 
+0x2C, 0x18, 0x0C, 0x00, 0x30, 0x31, 0x2A, 0x14, 0x0C, 0x00, 0x30, 0x31, 0x28, 0x14, 0x00, 0x00, 
+0x30, 0x31, 0x24, 0x14, 0x00, 0x00, 0x30, 0x31, 0x1E, 0x14, 0x00, 0x00, 0x30, 0x04, 0x04, 0x04, 
+0x05, 0x04, 0x04, 0x05, 0x07, 0x07, 0x07, 0x08, 0x0A, 0x04, 0x07, 0x0A, 0x0E, 0x11, 0x13, 0x14, 
+0x15, 0x03, 0x04, 0x07, 0x07, 0x08, 0x0B, 0x0D, 0x0F, 0x05, 0x05, 0x07, 0x07, 0x08, 0x0B, 0x0D, 
+0x0F, 0x05, 0x05, 0x07, 0x07, 0x08, 0x0B, 0x0D, 0x0F, 0x07, 0x08, 0x08, 0x0A, 0x0A, 0x0C, 0x0E, 
+0x10, 0x11, 0x11, 0x07, 0x09, 0x09, 0x0B, 0x0B, 0x0D, 0x0F, 0x13, 0x13, 0x14, 0x05, 0x05, 0x07, 
+0x07, 0x08, 0x0B, 0x0D, 0x0F, 0x0F, 0x0F, 0x05, 0x05, 0x07, 0x07, 0x08, 0x0B, 0x0D, 0x0F, 0x0F, 
+0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x26, 0x2A, 0x00, 0x00, 0x00, 
+0x1F, 0x21, 0x25, 0x27, 0x28, 0x00, 0x00, 0x00, 0x00, 0x23, 0x26, 0x28, 0x2A, 0x00, 0x00, 0x00, 
+0x00, 0x23, 0x26, 0x28, 0x2A, 0x00, 0x00, 0x00, 0x00, 0x23, 0x26, 0x28, 0x2A, 0x00, 0x00, 0x00, 
+0x00, 0x20, 0x25, 0x27, 0x29, 0x29, 0x2A, 0x00, 0x00, 0x00, 0x00, 0x20, 0x25, 0x27, 0x29, 0x29, 
+0x2A, 0x00, 0x00, 0x00, 0x00, 0x23, 0x26, 0x28, 0x2A, 0x2A, 0x2A, 0x00, 0x00, 0x00, 0x1F, 0x23, 
+0x26, 0x28, 0x2A, 0x2A, 0x2A, 0x00, 0x04, 0x00, 0x04, 0x00, 0x08, 0x00, 0x10, 0x00, 0x18, 0x00, 
+0x24, 0x00, 0x30, 0x00, 0x48, 0x00, 0x60, 0x00, 0x90, 0x00, 0xC0, 0x00, 0xD8, 0x00, 0x3C, 0x00, 
+0x64, 0x00, 0x78, 0x00, 0xA0, 0x00, 0xF0, 0x01, 0x40, 0x01, 0x90, 0x01, 0xE0, 0x00, 0xA0, 0x00, 
+0xF0, 0x01, 0x40, 0x01, 0x90, 0x02, 0x58, 0x03, 0x20, 0x04, 0xB0, 0x06, 0x40, 0x00, 0xC8, 0x01, 
+0x18, 0x01, 0xE0, 0x02, 0xD0, 0x03, 0xE8, 0x04, 0xB0, 0x06, 0x40, 0x07, 0xD0, 0x00, 0xC8, 0x01, 
+0x18, 0x01, 0xE0, 0x02, 0xD0, 0x03, 0xE8, 0x04, 0xB0, 0x06, 0x40, 0x07, 0xD0, 0x00, 0x3C, 0x00, 
+0x50, 0x00, 0x64, 0x00, 0xA0, 0x00, 0xF0, 0x01, 0x40, 0x01, 0x90, 0x01, 0xE0, 0x02, 0x58, 0x03, 
+0x20, 0x00, 0x78, 0x00, 0xF0, 0x01, 0x90, 0x02, 0x58, 0x03, 0xE8, 0x07, 0xD0, 0x09, 0x60, 0x0F, 
+0xA0, 0x12, 0xC0, 0x15, 0x18, 0x00, 0xC8, 0x01, 0x18, 0x01, 0xE0, 0x02, 0xD0, 0x03, 0xE8, 0x04, 
+0xB0, 0x06, 0x40, 0x07, 0xD0, 0x07, 0xD0, 0x07, 0xD0, 0x00, 0xC8, 0x01, 0x18, 0x01, 0xE0, 0x02, 
+0xD0, 0x03, 0xE8, 0x04, 0xB0, 0x06, 0x40, 0x07, 0xD0, 0x07, 0xD0, 0x07, 0xD0, 0x00, 0x02, 0x00, 
+0x02, 0x00, 0x04, 0x00, 0x08, 0x00, 0x0C, 0x00, 0x12, 0x00, 0x18, 0x00, 0x24, 0x00, 0x30, 0x00, 
+0x48, 0x00, 0x60, 0x00, 0x6C, 0x00, 0x14, 0x00, 0x32, 0x00, 0x3C, 0x00, 0x50, 0x00, 0x78, 0x00, 
+0xA0, 0x00, 0xC8, 0x00, 0xF0, 0x00, 0x50, 0x00, 0x78, 0x00, 0xA0, 0x00, 0xC8, 0x01, 0x2C, 0x01, 
+0x90, 0x02, 0x58, 0x03, 0x20, 0x00, 0x64, 0x00, 0x8C, 0x00, 0xF0, 0x01, 0x68, 0x01, 0xF4, 0x02, 
+0x58, 0x03, 0x20, 0x03, 0xE8, 0x00, 0x64, 0x00, 0x8C, 0x00, 0xF0, 0x01, 0x68, 0x01, 0xF4, 0x02, 
+0x58, 0x03, 0x20, 0x03, 0xE8, 0x00, 0x1E, 0x00, 0x28, 0x00, 0x32, 0x00, 0x50, 0x00, 0x78, 0x00, 
+0xA0, 0x00, 0xC8, 0x00, 0xF0, 0x01, 0x2C, 0x01, 0x90, 0x00, 0x3C, 0x00, 0x78, 0x00, 0xC8, 0x01, 
+0x2C, 0x01, 0xF4, 0x03, 0xE8, 0x04, 0xB0, 0x07, 0xD0, 0x09, 0x60, 0x0A, 0xF0, 0x00, 0x64, 0x00, 
+0x8C, 0x00, 0xF0, 0x01, 0x68, 0x01, 0xF4, 0x02, 0x58, 0x03, 0x20, 0x03, 0xE8, 0x03, 0xE8, 0x03, 
+0xE8, 0x00, 0x64, 0x00, 0x8C, 0x00, 0xF0, 0x01, 0x68, 0x01, 0xF4, 0x02, 0x58, 0x03, 0x20, 0x03, 
+0xE8, 0x03, 0xE8, 0x03, 0xE8, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x10, 0x18, 0x20, 0x30, 0x40, 
+0x50, 0x01, 0x01, 0x01, 0x02, 0x01, 0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x02, 0x04, 0x06, 
+0x07, 0x07, 0x08, 0x08, 0x08, 0x02, 0x02, 0x03, 0x03, 0x05, 0x05, 0x06, 0x06, 0x05, 0x06, 0x06, 
+0x07, 0x07, 0x08, 0x09, 0x0A, 0x05, 0x06, 0x06, 0x07, 0x07, 0x08, 0x09, 0x0A, 0x05, 0x06, 0x06, 
+0x07, 0x07, 0x08, 0x09, 0x0A, 0x0A, 0x0B, 0x05, 0x06, 0x06, 0x07, 0x07, 0x08, 0x09, 0x0A, 0x0B, 
+0x0B, 0x05, 0x06, 0x06, 0x07, 0x07, 0x08, 0x09, 0x0A, 0x0A, 0x0B, 0x05, 0x06, 0x06, 0x07, 0x07, 
+0x08, 0x09, 0x0A, 0x0A, 0x0B, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 
+0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x02, 0x04, 0x06, 0x07, 0x08, 0x0A, 0x0B, 
+0x0C, 0x03, 0x05, 0x06, 0x07, 0x08, 0x0A, 0x0B, 0x0C, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 
+0x0C, 0x02, 0x04, 0x06, 0x07, 0x08, 0x09, 0x0B, 0x0C, 0x0C, 0x0C, 0x03, 0x05, 0x06, 0x07, 0x08, 
+0x09, 0x0B, 0x0C, 0x0C, 0x0C, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0C, 0x0C, 0x05, 
+0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0C, 0x0C, 0x19, 0x06, 0x04, 0x02, 0x00, 0x18, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0xC2, 0xAF, 0x80, 0xFE, 0x32, 0x12, 0x45, 0xE4, 0x85, 0xD0, 0x0B, 0x75, 0xD0, 0x08, 0xAA, 0xE0, 
+0xC2, 0x8C, 0xE5, 0x8A, 0x24, 0x67, 0xF5, 0x8A, 0xE5, 0x8C, 0x34, 0x79, 0xF5, 0x8C, 0xD2, 0x8C, 
+0xEC, 0x24, 0x87, 0xF8, 0xE6, 0xBC, 0x02, 0x02, 0x74, 0xFF, 0xC3, 0x95, 0x81, 0xB4, 0x40, 0x00, 
+0x40, 0xCE, 0x79, 0x03, 0x78, 0x80, 0x16, 0xE6, 0x08, 0x70, 0x0B, 0xC2, 0xAF, 0xE6, 0x30, 0xE1, 
+0x03, 0x44, 0x18, 0xF6, 0xD2, 0xAF, 0x08, 0xD9, 0xED, 0xEA, 0x8B, 0xD0, 0x22, 0xE5, 0x0C, 0xFF, 
+0x23, 0x24, 0x81, 0xF8, 0x0F, 0x08, 0x08, 0xBF, 0x03, 0x04, 0x7F, 0x00, 0x78, 0x81, 0xE6, 0x30, 
+0xE4, 0xF2, 0x00, 0xE5, 0x0C, 0xC3, 0x9F, 0x50, 0x20, 0x05, 0x0C, 0x74, 0x86, 0x25, 0x0C, 0xF8, 
+0xE6, 0xFD, 0xA6, 0x81, 0x08, 0xE6, 0xAE, 0x0C, 0xBE, 0x02, 0x02, 0x74, 0xFF, 0xCD, 0xF8, 0xE8, 
+0x6D, 0x60, 0xE0, 0x08, 0xE6, 0xC0, 0xE0, 0x80, 0xF6, 0xE5, 0x0C, 0xD3, 0x9F, 0x40, 0x27, 0xE5, 
+0x0C, 0x24, 0x87, 0xF8, 0xE6, 0xAE, 0x0C, 0xBE, 0x02, 0x02, 0x74, 0xFF, 0xFD, 0x18, 0xE6, 0xCD, 
+0xF8, 0xE5, 0x81, 0x6D, 0x60, 0x06, 0xD0, 0xE0, 0xF6, 0x18, 0x80, 0xF5, 0xE5, 0x0C, 0x24, 0x86, 
+0xC8, 0xF6, 0x15, 0x0C, 0x80, 0xD3, 0xE5, 0x0C, 0x23, 0x24, 0x81, 0xF8, 0x7F, 0x04, 0xC2, 0xAF, 
+0xE6, 0x30, 0xE0, 0x03, 0x10, 0xE2, 0x0C, 0x7F, 0x00, 0x30, 0xE1, 0x07, 0x30, 0xE3, 0x04, 0x7F, 
+0x08, 0x54, 0xF4, 0x54, 0x7C, 0xC6, 0xD2, 0xAF, 0x54, 0x80, 0x42, 0x07, 0x22, 0x78, 0x86, 0xA6, 
+0x81, 0x74, 0x02, 0x60, 0x06, 0xFF, 0x08, 0x76, 0xFF, 0xDF, 0xFB, 0x7F, 0x03, 0xE4, 0x78, 0x80, 
+0xF6, 0x08, 0xF6, 0x08, 0xDF, 0xFA, 0x78, 0x81, 0x76, 0x30, 0x90, 0x4B, 0x8A, 0x74, 0x01, 0x93, 
+0xC0, 0xE0, 0xE4, 0x93, 0xC0, 0xE0, 0x43, 0x89, 0x01, 0x75, 0x8A, 0x60, 0x75, 0x8C, 0x79, 0xD2, 
+0x8C, 0xD2, 0xAF, 0x22, 0x02, 0xEF, 0xD3, 0x94, 0x02, 0x40, 0x03, 0x7F, 0xFF, 0x22, 0x74, 0x81, 
+0x2F, 0x2F, 0xF8, 0xE6, 0x20, 0xE5, 0xF4, 0xC2, 0xAF, 0xE6, 0x44, 0x30, 0xF6, 0xD2, 0xAF, 0xAE, 
+0x0C, 0xEE, 0xC3, 0x9F, 0x50, 0x21, 0x0E, 0x74, 0x86, 0x2E, 0xF8, 0xE6, 0xF9, 0x08, 0xE6, 0x18, 
+0xBE, 0x02, 0x02, 0x74, 0xFF, 0xFD, 0xED, 0x69, 0x60, 0x09, 0x09, 0xE7, 0x19, 0x19, 0xF7, 0x09, 
+0x09, 0x80, 0xF3, 0x16, 0x16, 0x80, 0xDA, 0xEE, 0xD3, 0x9F, 0x40, 0x04, 0x05, 0x81, 0x05, 0x81, 
+0xEE, 0xD3, 0x9F, 0x40, 0x22, 0x74, 0x86, 0x2E, 0xF8, 0x08, 0xE6, 0xF9, 0xEE, 0xB5, 0x0C, 0x02, 
+0xA9, 0x81, 0x18, 0x06, 0x06, 0xE6, 0xFD, 0xED, 0x69, 0x60, 0x09, 0x19, 0x19, 0xE7, 0x09, 0x09, 
+0xF7, 0x19, 0x80, 0xF3, 0x1E, 0x80, 0xD9, 0xEF, 0x24, 0x86, 0xF8, 0xE6, 0x04, 0xF8, 0xEF, 0x2F, 
+0x04, 0x90, 0x4B, 0x8A, 0x93, 0xF6, 0x08, 0xEF, 0x2F, 0x93, 0xF6, 0x7F, 0x00, 0x22, 0xEF, 0xD3, 
+0x94, 0x02, 0x40, 0x03, 0x7F, 0xFF, 0x22, 0xEF, 0x23, 0x24, 0x81, 0xF8, 0xE6, 0x30, 0xE5, 0xF4, 
+0xC2, 0xAF, 0xE6, 0x54, 0x8C, 0xF6, 0xD2, 0xAF, 0xE5, 0x0C, 0xB5, 0x07, 0x0A, 0x74, 0x86, 0x2F, 
+0xF8, 0xE6, 0xF5, 0x81, 0x02, 0x46, 0x2D, 0x50, 0x2E, 0x74, 0x87, 0x2F, 0xF8, 0xE6, 0xBF, 0x02, 
+0x02, 0x74, 0xFF, 0xFD, 0x18, 0xE6, 0xF9, 0x74, 0x86, 0x2F, 0xF8, 0xFB, 0xE6, 0xFC, 0xE9, 0x6C, 
+0x60, 0x08, 0xA8, 0x05, 0xE7, 0xF6, 0x1D, 0x19, 0x80, 0xF4, 0xA8, 0x03, 0xA6, 0x05, 0x1F, 0xE5, 
+0x0C, 0xB5, 0x07, 0xE3, 0x7F, 0x00, 0x22, 0x74, 0x87, 0x2F, 0xF8, 0xE6, 0xFD, 0x18, 0x86, 0x01, 
+0x0F, 0x74, 0x86, 0x2F, 0xF8, 0xA6, 0x01, 0x08, 0x86, 0x04, 0xE5, 0x0C, 0xB5, 0x07, 0x02, 0xAC, 
+0x81, 0xED, 0x6C, 0x60, 0x08, 0x0D, 0x09, 0xA8, 0x05, 0xE6, 0xF7, 0x80, 0xF4, 0xE5, 0x0C, 0xB5, 
+0x07, 0xDE, 0x89, 0x81, 0x7F, 0x00, 0x22, 0xEF, 0xD3, 0x94, 0x02, 0x40, 0x03, 0x7F, 0xFF, 0x22, 
+0xEF, 0x23, 0x24, 0x81, 0xF8, 0xC2, 0xAF, 0xE6, 0x30, 0xE5, 0x05, 0x30, 0xE0, 0x02, 0xD2, 0xE4, 
+0xD2, 0xE2, 0xC6, 0xD2, 0xAF, 0x7F, 0x00, 0x30, 0xE2, 0x01, 0x0F, 0x02, 0x46, 0x2C, 0x8F, 0xF0, 
+0xE4, 0xFF, 0xFE, 0xE5, 0x0C, 0x23, 0x24, 0x80, 0xF8, 0xC2, 0xA9, 0x30, 0xF7, 0x0D, 0x7F, 0x08, 
+0xE6, 0x60, 0x0B, 0x2D, 0xF6, 0x60, 0x30, 0x50, 0x2E, 0x80, 0x07, 0x30, 0xF1, 0x06, 0xED, 0xF6, 
+0x60, 0x25, 0x7E, 0x02, 0x08, 0x30, 0xF0, 0x10, 0xC2, 0xAF, 0xE6, 0x10, 0xE7, 0x23, 0x0E, 0x30, 
+0xE2, 0x0C, 0xD2, 0xAF, 0x7F, 0x04, 0x80, 0x12, 0xC2, 0xAF, 0xE6, 0x10, 0xE7, 0x13, 0x54, 0xEC, 
+0x4E, 0xF6, 0xD2, 0xAF, 0x02, 0x46, 0x2D, 0x7F, 0x08, 0x08, 0xEF, 0x44, 0x83, 0xF4, 0xC2, 0xAF, 
+0x56, 0xC6, 0xD2, 0xAF, 0x54, 0x80, 0x4F, 0xFF, 0x22, 0xE7, 0x09, 0xF6, 0x08, 0xDF, 0xFA, 0x80, 
+0x46, 0xE7, 0x09, 0xF2, 0x08, 0xDF, 0xFA, 0x80, 0x3E, 0x88, 0x82, 0x8C, 0x83, 0xE7, 0x09, 0xF0, 
+0xA3, 0xDF, 0xFA, 0x80, 0x32, 0xE3, 0x09, 0xF6, 0x08, 0xDF, 0xFA, 0x80, 0x78, 0xE3, 0x09, 0xF2, 
+0x08, 0xDF, 0xFA, 0x80, 0x70, 0x88, 0x82, 0x8C, 0x83, 0xE3, 0x09, 0xF0, 0xA3, 0xDF, 0xFA, 0x80, 
+0x64, 0x89, 0x82, 0x8A, 0x83, 0xE0, 0xA3, 0xF6, 0x08, 0xDF, 0xFA, 0x80, 0x58, 0x89, 0x82, 0x8A, 
+0x83, 0xE0, 0xA3, 0xF2, 0x08, 0xDF, 0xFA, 0x80, 0x4C, 0x80, 0xD2, 0x80, 0xFA, 0x80, 0xC6, 0x80, 
+0xD4, 0x80, 0x69, 0x80, 0xF2, 0x80, 0x33, 0x80, 0x10, 0x80, 0xA6, 0x80, 0xEA, 0x80, 0x9A, 0x80, 
+0xA8, 0x80, 0xDA, 0x80, 0xE2, 0x80, 0xCA, 0x80, 0x33, 0x89, 0x82, 0x8A, 0x83, 0xEC, 0xFA, 0xE4, 
+0x93, 0xA3, 0xC8, 0xC5, 0x82, 0xC8, 0xCC, 0xC5, 0x83, 0xCC, 0xF0, 0xA3, 0xC8, 0xC5, 0x82, 0xC8, 
+0xCC, 0xC5, 0x83, 0xCC, 0xDF, 0xE9, 0xDE, 0xE7, 0x80, 0x0D, 0x89, 0x82, 0x8A, 0x83, 0xE4, 0x93, 
+0xA3, 0xF6, 0x08, 0xDF, 0xF9, 0xEC, 0xFA, 0xA9, 0xF0, 0xED, 0xFB, 0x22, 0x89, 0x82, 0x8A, 0x83, 
+0xEC, 0xFA, 0xE0, 0xA3, 0xC8, 0xC5, 0x82, 0xC8, 0xCC, 0xC5, 0x83, 0xCC, 0xF0, 0xA3, 0xC8, 0xC5, 
+0x82, 0xC8, 0xCC, 0xC5, 0x83, 0xCC, 0xDF, 0xEA, 0xDE, 0xE8, 0x80, 0xDB, 0x89, 0x82, 0x8A, 0x83, 
+0xE4, 0x93, 0xA3, 0xF2, 0x08, 0xDF, 0xF9, 0x80, 0xCC, 0x88, 0xF0, 0xEF, 0x60, 0x01, 0x0E, 0x4E, 
+0x60, 0xC3, 0x88, 0xF0, 0xED, 0x24, 0x02, 0xB4, 0x04, 0x00, 0x50, 0xB9, 0xF5, 0x82, 0xEB, 0x24, 
+0x02, 0xB4, 0x04, 0x00, 0x50, 0xAF, 0x23, 0x23, 0x45, 0x82, 0x23, 0x90, 0x48, 0xD9, 0x73, 0xC5, 
+0xF0, 0xF8, 0xA3, 0xE0, 0x28, 0xF0, 0xC5, 0xF0, 0xF8, 0xE5, 0x82, 0x15, 0x82, 0x70, 0x02, 0x15, 
+0x83, 0xE0, 0x38, 0xF0, 0x22, 0xBB, 0x01, 0x0A, 0x89, 0x82, 0x8A, 0x83, 0xE0, 0xF5, 0xF0, 0xA3, 
+0xE0, 0x22, 0x50, 0x06, 0x87, 0xF0, 0x09, 0xE7, 0x19, 0x22, 0xBB, 0xFE, 0x07, 0xE3, 0xF5, 0xF0, 
+0x09, 0xE3, 0x19, 0x22, 0x89, 0x82, 0x8A, 0x83, 0xE4, 0x93, 0xF5, 0xF0, 0x74, 0x01, 0x93, 0x22, 
+0xBB, 0x01, 0x10, 0xE5, 0x82, 0x29, 0xF5, 0x82, 0xE5, 0x83, 0x3A, 0xF5, 0x83, 0xE0, 0xF5, 0xF0, 
+0xA3, 0xE0, 0x22, 0x50, 0x09, 0xE9, 0x25, 0x82, 0xF8, 0x86, 0xF0, 0x08, 0xE6, 0x22, 0xBB, 0xFE, 
+0x0A, 0xE9, 0x25, 0x82, 0xF8, 0xE2, 0xF5, 0xF0, 0x08, 0xE2, 0x22, 0xE5, 0x83, 0x2A, 0xF5, 0x83, 
+0xE9, 0x93, 0xF5, 0xF0, 0xA3, 0xE9, 0x93, 0x22, 0xEF, 0x5B, 0xFF, 0xEE, 0x5A, 0xFE, 0xED, 0x59, 
+0xFD, 0xEC, 0x58, 0xFC, 0x22, 0xEF, 0x4B, 0xFF, 0xEE, 0x4A, 0xFE, 0xED, 0x49, 0xFD, 0xEC, 0x48, 
+0xFC, 0x22, 0xE0, 0xFC, 0xA3, 0xE0, 0xFD, 0xA3, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x22, 0xE0, 0xF8, 
+0xA3, 0xE0, 0xF9, 0xA3, 0xE0, 0xFA, 0xA3, 0xE0, 0xFB, 0x22, 0xA4, 0x25, 0x82, 0xF5, 0x82, 0xE5, 
+0xF0, 0x35, 0x83, 0xF5, 0x83, 0x22, 0xE0, 0xFB, 0xA3, 0xE0, 0xFA, 0xA3, 0xE0, 0xF9, 0x22, 0xEB, 
+0xF0, 0xA3, 0xEA, 0xF0, 0xA3, 0xE9, 0xF0, 0x22, 0xD0, 0x83, 0xD0, 0x82, 0xF8, 0xE4, 0x93, 0x70, 
+0x12, 0x74, 0x01, 0x93, 0x70, 0x0D, 0xA3, 0xA3, 0x93, 0xF8, 0x74, 0x01, 0x93, 0xF5, 0x82, 0x88, 
+0x83, 0xE4, 0x73, 0x74, 0x02, 0x93, 0x68, 0x60, 0xEF, 0xA3, 0xA3, 0xA3, 0x80, 0xDF, 0xEF, 0x4E, 
+0x60, 0x12, 0xEF, 0x60, 0x01, 0x0E, 0xED, 0xBB, 0x01, 0x0B, 0x89, 0x82, 0x8A, 0x83, 0xF0, 0xA3, 
+0xDF, 0xFC, 0xDE, 0xFA, 0x22, 0x89, 0xF0, 0x50, 0x07, 0xF7, 0x09, 0xDF, 0xFC, 0xA9, 0xF0, 0x22, 
+0xBB, 0xFE, 0xFC, 0xF3, 0x09, 0xDF, 0xFC, 0xA9, 0xF0, 0x22, 0x02, 0x4A, 0xD8, 0x02, 0x46, 0xBD, 
+0xE4, 0x93, 0xA3, 0xF8, 0xE4, 0x93, 0xA3, 0x40, 0x03, 0xF6, 0x80, 0x01, 0xF2, 0x08, 0xDF, 0xF4, 
+0x80, 0x29, 0xE4, 0x93, 0xA3, 0xF8, 0x54, 0x07, 0x24, 0x0C, 0xC8, 0xC3, 0x33, 0xC4, 0x54, 0x0F, 
+0x44, 0x20, 0xC8, 0x83, 0x40, 0x04, 0xF4, 0x56, 0x80, 0x01, 0x46, 0xF6, 0xDF, 0xE4, 0x80, 0x0B, 
+0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x90, 0x4B, 0x1D, 0xE4, 0x7E, 0x01, 0x93, 0x60, 
+0xBC, 0xA3, 0xFF, 0x54, 0x3F, 0x30, 0xE5, 0x09, 0x54, 0x1F, 0xFE, 0xE4, 0x93, 0xA3, 0x60, 0x01, 
+0x0E, 0xCF, 0x54, 0xC0, 0x25, 0xE0, 0x60, 0xA8, 0x40, 0xB8, 0xE4, 0x93, 0xA3, 0xFA, 0xE4, 0x93, 
+0xA3, 0xF8, 0xE4, 0x93, 0xA3, 0xC8, 0xC5, 0x82, 0xC8, 0xCA, 0xC5, 0x83, 0xCA, 0xF0, 0xA3, 0xC8, 
+0xC5, 0x82, 0xC8, 0xCA, 0xC5, 0x83, 0xCA, 0xDF, 0xE9, 0xDE, 0xE7, 0x80, 0xBE, 0x41, 0xA4, 0x6A, 
+0x00, 0x41, 0xA4, 0x6B, 0x00, 0x41, 0xA4, 0x6C, 0x00, 0x60, 0x54, 0xA0, 0x21, 0x04, 0x04, 0x04, 
+0x05, 0x07, 0x07, 0x09, 0x09, 0x0C, 0x0E, 0x10, 0x12, 0x05, 0x06, 0x07, 0x0D, 0x10, 0x11, 0x12, 
+0x12, 0x07, 0x08, 0x09, 0x09, 0x0C, 0x0E, 0x11, 0x13, 0x09, 0x09, 0x09, 0x09, 0x0C, 0x0E, 0x11, 
+0x13, 0x09, 0x09, 0x09, 0x09, 0x0C, 0x0E, 0x11, 0x13, 0x05, 0x06, 0x08, 0x09, 0x0C, 0x0E, 0x12, 
+0x12, 0x13, 0x14, 0x07, 0x08, 0x09, 0x0A, 0x0C, 0x0F, 0x12, 0x12, 0x14, 0x16, 0x09, 0x09, 0x09, 
+0x09, 0x0C, 0x0E, 0x11, 0x13, 0x13, 0x13, 0x09, 0x09, 0x09, 0x09, 0x0C, 0x0E, 0x11, 0x13, 0x13, 
+0x13, 0x41, 0xA4, 0x8F, 0x00, 0x41, 0xA4, 0x93, 0x00, 0x00, 0x58, 0x02, 0x5F, 0xFF, 0x77, 0xF6, 
+0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0xE4, 0x90, 0xA3, 0x6B, 0xF0, 0x90, 0xA3, 0x70, 0xF0, 
+0x90, 0xA3, 0x6E, 0xF0, 0x91, 0xF0, 0x40, 0x02, 0x81, 0x32, 0xC3, 0x74, 0xFD, 0x91, 0xF9, 0x7A, 
+0xA3, 0x79, 0x6A, 0x12, 0x33, 0xC7, 0xEF, 0x64, 0x01, 0x60, 0x02, 0x81, 0x8E, 0x90, 0xA3, 0x6A, 
+0xE0, 0xFF, 0x54, 0xC0, 0xFE, 0x60, 0x05, 0xEF, 0x54, 0x0C, 0x70, 0x1C, 0x90, 0xA3, 0x6A, 0xE0, 
+0xFF, 0x54, 0x30, 0x60, 0x05, 0xEF, 0x54, 0x03, 0x70, 0x08, 0x90, 0xA3, 0x6E, 0xE0, 0x60, 0x4A, 
+0x80, 0x00, 0x90, 0xA3, 0x6B, 0x74, 0x01, 0xF0, 0x90, 0xA3, 0x6B, 0xE0, 0x90, 0xA3, 0x6A, 0x70, 
+0x17, 0xE0, 0xFF, 0xEE, 0xC4, 0x13, 0x13, 0x54, 0x03, 0x90, 0xA3, 0x6C, 0xF0, 0xEF, 0x54, 0x0C, 
+0x13, 0x13, 0x54, 0x3F, 0xA3, 0xF0, 0x80, 0x10, 0xE0, 0xFF, 0x54, 0x30, 0xC4, 0x54, 0x0F, 0x90, 
+0xA3, 0x6C, 0xF0, 0xEF, 0x54, 0x03, 0xA3, 0xF0, 0x90, 0xA3, 0x6C, 0xE0, 0x90, 0xA3, 0x66, 0xF0, 
+0x90, 0xA3, 0x6D, 0xE0, 0x90, 0xA3, 0x67, 0xF0, 0x80, 0x08, 0x90, 0xA3, 0x6E, 0xE0, 0x04, 0xF0, 
+0x61, 0xA4, 0xE4, 0x90, 0xA3, 0x6E, 0xF0, 0x91, 0xF0, 0x50, 0x63, 0xC3, 0x74, 0xFB, 0x91, 0xF9, 
+0x7A, 0xA3, 0x79, 0x6F, 0x12, 0x33, 0xC7, 0xEF, 0x64, 0x01, 0x70, 0x42, 0x90, 0xA3, 0x6F, 0xE0, 
+0xFF, 0x54, 0xE0, 0xFE, 0x70, 0x13, 0xEF, 0x54, 0x0E, 0x70, 0x08, 0x90, 0xA3, 0x6E, 0xE0, 0x60, 
+0x35, 0x80, 0x00, 0x90, 0xA3, 0x70, 0x74, 0x01, 0xF0, 0x90, 0xA3, 0x70, 0xE0, 0x70, 0x09, 0xEE, 
+0xC4, 0x13, 0x54, 0x07, 0xA3, 0xF0, 0x80, 0x0C, 0x90, 0xA3, 0x6F, 0xE0, 0x54, 0x0E, 0xC3, 0x13, 
+0x90, 0xA3, 0x71, 0xF0, 0x90, 0xA3, 0x71, 0xE0, 0x90, 0xA3, 0x68, 0xF0, 0x80, 0x10, 0x90, 0xA3, 
+0x72, 0x74, 0x01, 0xF0, 0x80, 0x40, 0x90, 0xA3, 0x6E, 0xE0, 0x04, 0xF0, 0x80, 0x99, 0x90, 0xA3, 
+0x67, 0xE0, 0x25, 0xE0, 0x25, 0xE0, 0x54, 0x0C, 0xFF, 0x90, 0xA3, 0x66, 0xE0, 0x54, 0x03, 0x4F, 
+0xFF, 0x90, 0xA3, 0x68, 0xE0, 0xFE, 0xC4, 0x54, 0x70, 0x4F, 0x44, 0x80, 0xFD, 0x7F, 0x8B, 0x12, 
+0x3A, 0x96, 0x90, 0xA3, 0x66, 0xE0, 0x60, 0x08, 0xA3, 0xE0, 0x60, 0x04, 0xA3, 0xE0, 0x70, 0x1B, 
+0x90, 0xA3, 0x72, 0x74, 0x03, 0xF0, 0x90, 0x01, 0xC4, 0x74, 0x90, 0xF0, 0x74, 0x4B, 0xA3, 0xF0, 
+0x90, 0xA3, 0x72, 0xE0, 0x90, 0x01, 0xC8, 0xB1, 0x03, 0x80, 0xEB, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 
+0x90, 0xA3, 0x6E, 0xE0, 0xFF, 0xC3, 0x94, 0x02, 0x22, 0x9F, 0xFF, 0x74, 0x03, 0x94, 0x00, 0xFE, 
+0x7B, 0x01, 0x22, 0xF0, 0xE4, 0xFD, 0x7F, 0x1F, 0x02, 0x3A, 0x96, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 
+0xC0, 0xD0, 0x90, 0xA3, 0x7C, 0xEF, 0xF0, 0xA3, 0x74, 0x02, 0xF0, 0x90, 0x01, 0xC4, 0x74, 0x0B, 
+0xF0, 0x74, 0x4D, 0xA3, 0xF0, 0x90, 0xA3, 0x7D, 0xE0, 0x90, 0x01, 0xC8, 0xF0, 0x90, 0xA3, 0x7C, 
+0xE0, 0x90, 0x01, 0xC9, 0xB1, 0x03, 0x80, 0xE3, 0xF1, 0xE9, 0x54, 0x7F, 0xF5, 0x0D, 0x12, 0x51, 
+0x7C, 0xFF, 0x54, 0x1F, 0xF5, 0x0F, 0xEF, 0x54, 0x80, 0xF1, 0xF5, 0xF5, 0x0E, 0xF1, 0xD1, 0xFF, 
+0x54, 0x03, 0xF5, 0x10, 0xEF, 0x54, 0x30, 0xC4, 0x54, 0x0F, 0xF5, 0x13, 0xF1, 0xD1, 0xFF, 0x54, 
+0x40, 0xC4, 0x13, 0x13, 0x54, 0x03, 0xF5, 0x11, 0xEF, 0x54, 0x80, 0xF1, 0xF5, 0xF5, 0x12, 0xF1, 
+0xD1, 0xFF, 0x54, 0x08, 0xFE, 0x13, 0x13, 0x13, 0x54, 0x1F, 0xF5, 0x15, 0xEF, 0x54, 0x04, 0x13, 
+0x13, 0x54, 0x3F, 0xF5, 0x16, 0x90, 0xA3, 0x67, 0xE0, 0xB4, 0x02, 0x08, 0xE5, 0x13, 0x60, 0x04, 
+0xE4, 0xFF, 0xB1, 0x0B, 0x90, 0xA3, 0x68, 0xE0, 0xB4, 0x01, 0x12, 0xF1, 0xE4, 0x12, 0x76, 0xC7, 
+0x54, 0xF0, 0x70, 0x05, 0x12, 0x86, 0xD2, 0x60, 0x04, 0x7F, 0x01, 0xB1, 0x0B, 0xE5, 0x12, 0x12, 
+0xB4, 0x21, 0xF1, 0x37, 0x54, 0x7F, 0x4F, 0xF0, 0xE5, 0x11, 0x12, 0x9E, 0x4F, 0xF1, 0x37, 0x54, 
+0xBF, 0x4F, 0xF0, 0xE5, 0x15, 0x60, 0x02, 0xC1, 0x53, 0xE5, 0x0F, 0x54, 0x1F, 0xFF, 0x75, 0xF0, 
+0x04, 0xE5, 0x0D, 0x12, 0x6B, 0xE5, 0x54, 0xE0, 0x4F, 0xF0, 0xE5, 0x10, 0x54, 0x03, 0xF1, 0x37, 
+0x54, 0xFC, 0x4F, 0xF0, 0xEF, 0x25, 0xE0, 0x25, 0xE0, 0xF1, 0x37, 0x54, 0xF3, 0x4F, 0xF0, 0xE5, 
+0x0E, 0x54, 0x01, 0xC4, 0x33, 0x54, 0xE0, 0xFF, 0x75, 0xF0, 0x04, 0xE5, 0x0D, 0x12, 0x6B, 0xE5, 
+0x54, 0xDF, 0x4F, 0xF0, 0xE5, 0x13, 0x54, 0x03, 0xC4, 0x54, 0xF0, 0xF1, 0x37, 0x54, 0xCF, 0x4F, 
+0xF1, 0x44, 0xE0, 0x54, 0xFB, 0xF1, 0x44, 0xE0, 0xFF, 0xE5, 0x16, 0x25, 0xE0, 0x25, 0xE0, 0xFE, 
+0xEF, 0x4E, 0xF0, 0xE4, 0xF5, 0x14, 0xE5, 0x14, 0x24, 0x03, 0xFF, 0xE4, 0x33, 0xFE, 0xF1, 0xE4, 
+0x8F, 0x82, 0x8E, 0x83, 0x12, 0x26, 0x37, 0xFF, 0x75, 0xF0, 0x08, 0xE5, 0x0D, 0x12, 0x6A, 0xB8, 
+0x25, 0x14, 0x12, 0x6A, 0x9B, 0xEF, 0xF0, 0x05, 0x14, 0xE5, 0x14, 0xB4, 0x04, 0xD8, 0xAF, 0x0D, 
+0x12, 0x68, 0x63, 0x22, 0x90, 0xA3, 0x76, 0x51, 0x3F, 0x90, 0xA3, 0x75, 0xEF, 0xF0, 0x51, 0x48, 
+0x4E, 0xAC, 0x00, 0x4E, 0xB1, 0x01, 0x4E, 0xB6, 0x02, 0x4E, 0xBB, 0x10, 0x4E, 0xC0, 0x11, 0x4E, 
+0xC5, 0x12, 0x4E, 0xCA, 0x14, 0x4E, 0xCF, 0x20, 0x4E, 0xD4, 0x21, 0x4E, 0xD9, 0x23, 0x4E, 0xDE, 
+0x25, 0x4E, 0xE3, 0x40, 0x4E, 0xF0, 0x41, 0x4E, 0xE7, 0x42, 0x4E, 0xEB, 0x46, 0x4E, 0xF5, 0x60, 
+0x4E, 0xFA, 0x64, 0x4E, 0xFF, 0x65, 0x4F, 0x04, 0x6B, 0x4F, 0x09, 0x6D, 0x4F, 0x0E, 0x6E, 0x4F, 
+0x13, 0x6F, 0x4F, 0x18, 0x70, 0x4F, 0x1D, 0x87, 0x00, 0x00, 0x4F, 0x22, 0xF1, 0x32, 0x02, 0x98, 
+0x14, 0xF1, 0x32, 0x02, 0x98, 0x72, 0xF1, 0x32, 0x02, 0x99, 0x7C, 0xF1, 0x32, 0x02, 0x98, 0x58, 
+0xF1, 0x32, 0x02, 0x81, 0x55, 0xF1, 0x32, 0x02, 0x99, 0xB8, 0xF1, 0x32, 0x02, 0x9A, 0x8D, 0xF1, 
+0x32, 0x02, 0x9A, 0x9C, 0xF1, 0x32, 0x02, 0x9C, 0x4C, 0xF1, 0x32, 0x02, 0x9C, 0x88, 0xF1, 0x32, 
+0x02, 0x9C, 0x90, 0xF1, 0x32, 0xA1, 0x38, 0xF1, 0x32, 0x80, 0x66, 0xF1, 0x32, 0x02, 0xAA, 0x7D, 
+0xF1, 0x32, 0x02, 0x7B, 0x14, 0xF1, 0x32, 0x02, 0x51, 0x82, 0xF1, 0x32, 0x02, 0x9C, 0xCD, 0xF1, 
+0x32, 0x02, 0x9E, 0x6D, 0xF1, 0x32, 0x02, 0x50, 0x95, 0xF1, 0x32, 0x02, 0x9E, 0x7B, 0xF1, 0x32, 
+0x02, 0x9E, 0xE9, 0xF1, 0x32, 0x02, 0x9F, 0x15, 0xF1, 0x32, 0x02, 0x9F, 0x38, 0xF1, 0x32, 0x02, 
+0xAB, 0x3F, 0x90, 0x01, 0xC0, 0xE0, 0x44, 0x01, 0xF0, 0x90, 0xA3, 0x75, 0xE0, 0x90, 0x01, 0xC2, 
+0xF0, 0x22, 0x90, 0xA3, 0x76, 0x41, 0x36, 0xFF, 0x75, 0xF0, 0x04, 0xE5, 0x0D, 0x90, 0x96, 0x14, 
+0x51, 0x2A, 0xE0, 0x22, 0xF0, 0x74, 0x91, 0x25, 0x0D, 0xF5, 0x82, 0xE4, 0x34, 0x99, 0xF5, 0x83, 
+0x22, 0xF1, 0xE9, 0xF5, 0x0D, 0x24, 0x91, 0xF1, 0x49, 0xE0, 0x54, 0x9C, 0xF1, 0x44, 0xC0, 0x83, 
+0xC0, 0x82, 0xF1, 0xD7, 0x54, 0x01, 0xFE, 0xEF, 0x4E, 0xD0, 0x82, 0xD0, 0x83, 0xF1, 0x44, 0xC0, 
+0x83, 0xC0, 0x82, 0xF1, 0xD7, 0x54, 0x02, 0xFE, 0xEF, 0x4E, 0xD0, 0x82, 0xD0, 0x83, 0xF1, 0x44, 
+0xC0, 0x83, 0xC0, 0x82, 0xF1, 0xD7, 0x54, 0x40, 0xFE, 0xEF, 0x4E, 0xD0, 0x82, 0xD0, 0x83, 0xF1, 
+0x44, 0xC0, 0x83, 0xC0, 0x82, 0xF1, 0xD7, 0x54, 0x20, 0xFE, 0xEF, 0x4E, 0xD0, 0x82, 0xD0, 0x83, 
+0xF0, 0xE5, 0x0D, 0xC3, 0x94, 0x80, 0x50, 0x10, 0xF1, 0xD1, 0xFF, 0x74, 0x11, 0x25, 0x0D, 0xF5, 
+0x82, 0xE4, 0x34, 0x9A, 0xF5, 0x83, 0xEF, 0xF0, 0xF1, 0x45, 0xE0, 0x30, 0xE5, 0x10, 0xF1, 0x38, 
+0x13, 0x13, 0x54, 0x03, 0xFB, 0x12, 0x61, 0x84, 0xFD, 0xAF, 0x0D, 0x12, 0xAA, 0x17, 0x22, 0x4F, 
+0xF0, 0x90, 0x00, 0x02, 0x02, 0x26, 0x37, 0xE0, 0xFF, 0x90, 0xA3, 0x79, 0x51, 0x36, 0x90, 0x00, 
+0x03, 0x02, 0x26, 0x37, 0x90, 0xA3, 0x79, 0x41, 0x36, 0x90, 0xA3, 0x79, 0x51, 0x3F, 0x02, 0x26, 
+0x1E, 0x90, 0xA2, 0xD2, 0xE0, 0xC4, 0x13, 0x13, 0x13, 0x54, 0x01, 0x22, 0x90, 0x00, 0xF0, 0xE0, 
+0x7F, 0x01, 0x20, 0xE2, 0x02, 0x7F, 0x03, 0x22, 0x12, 0x4F, 0xFC, 0x90, 0xA1, 0x7C, 0xEF, 0xF0, 
+0x11, 0x1B, 0x90, 0x01, 0x64, 0x74, 0x01, 0xF0, 0x02, 0x35, 0x95, 0x11, 0x40, 0x11, 0x6E, 0x12, 
+0xA0, 0x7A, 0x12, 0xA0, 0x99, 0x12, 0xA0, 0x54, 0xE4, 0xF5, 0x51, 0x75, 0x52, 0x58, 0xAB, 0x51, 
+0x7D, 0x02, 0x7F, 0x01, 0x12, 0x39, 0x04, 0xAB, 0x52, 0x7D, 0x03, 0x7F, 0x01, 0x02, 0x39, 0x04, 
+0x90, 0x01, 0x30, 0xE4, 0x11, 0x66, 0x90, 0x01, 0x38, 0x11, 0x66, 0xFD, 0x7F, 0x50, 0x12, 0x3A, 
+0x96, 0xE4, 0xFD, 0x7F, 0x51, 0x12, 0x3A, 0x96, 0xE4, 0xFD, 0x7F, 0x52, 0x12, 0x3A, 0x96, 0xE4, 
+0xFD, 0x7F, 0x53, 0x02, 0x3A, 0x96, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0x22, 0x90, 0x01, 
+0x34, 0x74, 0xFF, 0x11, 0x66, 0x90, 0x01, 0x3C, 0x11, 0x66, 0xFD, 0x7F, 0x54, 0x12, 0x3A, 0x96, 
+0x7D, 0xFF, 0x7F, 0x55, 0x12, 0x3A, 0x96, 0x7D, 0xFF, 0x7F, 0x56, 0x12, 0x3A, 0x96, 0x7D, 0xFF, 
+0x7F, 0x57, 0x02, 0x3A, 0x96, 0x12, 0x26, 0x1E, 0xFF, 0x54, 0x01, 0xFE, 0x90, 0xA3, 0x1D, 0xE0, 
+0x54, 0xFE, 0x4E, 0xFE, 0xF0, 0xEF, 0x54, 0x06, 0xFF, 0xEE, 0x54, 0xF9, 0x4F, 0xFF, 0xF0, 0x12, 
+0x26, 0x1E, 0xFE, 0x54, 0x08, 0xFD, 0xEF, 0x54, 0xF7, 0x4D, 0xFF, 0x90, 0xA3, 0x1D, 0xF1, 0x7D, 
+0x12, 0x26, 0x1E, 0x54, 0x20, 0xFE, 0xEF, 0x54, 0xDF, 0x4E, 0x90, 0xA3, 0x1D, 0x31, 0x7B, 0xFF, 
+0x54, 0x03, 0xFE, 0x90, 0xA3, 0x1E, 0xE0, 0x54, 0xFC, 0x4E, 0xFE, 0xF0, 0xEF, 0x54, 0x04, 0xFF, 
+0xEE, 0x54, 0xFB, 0x4F, 0xFF, 0x31, 0x7B, 0xFE, 0x54, 0x30, 0xFD, 0xEF, 0x54, 0xCF, 0x4D, 0xFF, 
+0x90, 0xA3, 0x1E, 0xF1, 0x68, 0x12, 0x4F, 0xD0, 0x90, 0xA3, 0x1F, 0xF0, 0x12, 0x4F, 0xDE, 0x90, 
+0xA3, 0x20, 0x91, 0x1F, 0x90, 0xA3, 0x21, 0xF0, 0x90, 0xA3, 0x1F, 0x31, 0x70, 0xEF, 0x78, 0x05, 
+0xCE, 0xC3, 0x13, 0xCE, 0x13, 0xD8, 0xF9, 0xFF, 0x90, 0xA3, 0x27, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 
+0x90, 0xA3, 0x20, 0x31, 0x70, 0xEF, 0x78, 0x05, 0xCE, 0xC3, 0x13, 0xCE, 0x13, 0xD8, 0xF9, 0xFF, 
+0x90, 0xA3, 0x29, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0xA3, 0x21, 0x31, 0x70, 0x90, 0xA3, 0x2B, 
+0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0xA3, 0x1D, 0xE0, 0x30, 0xE0, 0x14, 0x90, 0xA3, 0x22, 0x74, 
+0x01, 0xF0, 0xA3, 0xF0, 0xA3, 0x12, 0x7B, 0x44, 0x90, 0x07, 0x83, 0xE0, 0x44, 0x20, 0xF0, 0x22, 
+0xE4, 0x90, 0xA3, 0x22, 0x11, 0x66, 0xA3, 0xF0, 0x90, 0x07, 0x83, 0xE0, 0x54, 0xDF, 0xF0, 0x22, 
+0xE0, 0xFF, 0x7E, 0x00, 0x7C, 0x01, 0x7D, 0x40, 0x02, 0x26, 0x98, 0xF0, 0x90, 0x00, 0x01, 0x02, 
+0x26, 0x37, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x12, 0x4F, 0xE9, 0xFF, 0x54, 0x01, 0xFE, 
+0x90, 0xA2, 0xCF, 0xF1, 0xC4, 0xFF, 0xF0, 0x12, 0x26, 0x1E, 0xF1, 0x5E, 0x90, 0xA2, 0xCF, 0xF1, 
+0x7D, 0x12, 0x26, 0x1E, 0xF1, 0xBA, 0x90, 0xA2, 0xCF, 0xF1, 0x68, 0xFF, 0xF0, 0x12, 0x26, 0x1E, 
+0xF1, 0xA9, 0x90, 0xA2, 0xCF, 0xF0, 0x12, 0x4F, 0xDE, 0xFF, 0x54, 0x01, 0xFE, 0x90, 0xA2, 0xD2, 
+0xF1, 0xC4, 0xFF, 0xF0, 0x12, 0x4F, 0xDE, 0xF1, 0x5E, 0x90, 0xA2, 0xD2, 0xF1, 0x7D, 0x12, 0x4F, 
+0xDE, 0xF1, 0xBA, 0x90, 0xA2, 0xD2, 0xF1, 0x68, 0xFF, 0xF0, 0x12, 0x4F, 0xDE, 0xF1, 0xA9, 0x90, 
+0xA2, 0xD2, 0x91, 0x1F, 0xFF, 0x54, 0x20, 0xFE, 0x90, 0xA2, 0xD3, 0xE0, 0x54, 0xDF, 0x4E, 0xFE, 
+0xF0, 0xEF, 0x54, 0x40, 0xFF, 0xEE, 0x54, 0xBF, 0x4F, 0x91, 0x1E, 0xFE, 0x54, 0x80, 0xFD, 0xEF, 
+0x54, 0x7F, 0x4D, 0xFF, 0x90, 0xA2, 0xD3, 0xF0, 0xEE, 0x54, 0x01, 0xFE, 0xEF, 0x54, 0xFE, 0x91, 
+0x1D, 0xF1, 0x5E, 0x90, 0xA2, 0xD3, 0xF0, 0xEE, 0x54, 0x02, 0xFE, 0xEF, 0x54, 0xFD, 0x91, 0x1D, 
+0x12, 0x9C, 0x09, 0x90, 0xA2, 0xD3, 0x12, 0x9C, 0x00, 0x4E, 0xF0, 0x90, 0xA2, 0x87, 0xE0, 0x70, 
+0x08, 0x12, 0x93, 0xF6, 0x20, 0xE0, 0x02, 0xF1, 0xB1, 0x12, 0x4F, 0xE4, 0x12, 0x26, 0x1E, 0x20, 
+0xE0, 0x02, 0x61, 0x90, 0x90, 0x05, 0x54, 0xE0, 0x90, 0xA2, 0xE0, 0xF0, 0xE0, 0xC3, 0x13, 0x90, 
+0xA2, 0xDF, 0x12, 0x92, 0xB2, 0x30, 0xE0, 0x0E, 0x31, 0x7C, 0x90, 0xA2, 0xD0, 0x12, 0x4F, 0xD0, 
+0x90, 0xA2, 0xD1, 0xF0, 0x80, 0x41, 0x31, 0x7C, 0xFF, 0xC3, 0x94, 0x2A, 0x50, 0x12, 0xEF, 0xC3, 
+0x94, 0x03, 0x90, 0xA2, 0xD0, 0x50, 0x05, 0x74, 0x03, 0xF0, 0x80, 0x0A, 0xEF, 0xF0, 0x80, 0x06, 
+0x90, 0xA2, 0xD0, 0x74, 0x2A, 0xF0, 0x12, 0x4F, 0xD1, 0xFF, 0xC3, 0x94, 0x2A, 0x50, 0x12, 0xEF, 
+0xC3, 0x94, 0x03, 0x90, 0xA2, 0xD1, 0x50, 0x05, 0x74, 0x03, 0xF0, 0x80, 0x0A, 0xEF, 0xF0, 0x80, 
+0x06, 0x90, 0xA2, 0xD1, 0x74, 0x2A, 0xF0, 0x12, 0x5F, 0xED, 0x30, 0xE0, 0x3D, 0x90, 0xA2, 0xD0, 
+0xE0, 0x75, 0xF0, 0x03, 0x84, 0x90, 0xA2, 0xD8, 0xF0, 0xE0, 0xC3, 0x13, 0xA3, 0xF0, 0x90, 0xA2, 
+0xD1, 0xE0, 0x75, 0xF0, 0x03, 0x84, 0x90, 0xA2, 0xDA, 0xF0, 0x90, 0xA2, 0xD0, 0xE0, 0xC3, 0x13, 
+0x90, 0xA2, 0xDB, 0xF0, 0x90, 0xA2, 0xD1, 0xE0, 0xC3, 0x13, 0x90, 0xA2, 0xDC, 0xF0, 0x90, 0x01, 
+0x3E, 0x74, 0x08, 0xF0, 0xFD, 0x7F, 0x02, 0x12, 0x86, 0xD8, 0xE4, 0x90, 0xA3, 0x0E, 0xF0, 0x12, 
+0x4F, 0xD9, 0xC4, 0x13, 0x13, 0x54, 0x03, 0x20, 0xE0, 0x36, 0x90, 0xA2, 0xCF, 0xE0, 0xC3, 0x13, 
+0x20, 0xE0, 0x06, 0x12, 0x4F, 0xF4, 0x30, 0xE0, 0x27, 0x12, 0x26, 0x1E, 0x13, 0x13, 0x13, 0x54, 
+0x1F, 0x30, 0xE0, 0x08, 0x90, 0xA3, 0x10, 0xE0, 0x60, 0x08, 0x80, 0x0B, 0x90, 0xA3, 0x10, 0xE0, 
+0x60, 0x05, 0x75, 0x0D, 0x01, 0x80, 0x03, 0xE4, 0xF5, 0x0D, 0x7D, 0x02, 0xAF, 0x0D, 0x91, 0x2B, 
+0x90, 0xA2, 0xCF, 0xE0, 0xC4, 0x54, 0x0F, 0x30, 0xE0, 0x13, 0xF1, 0xE6, 0x54, 0x07, 0x30, 0xE0, 
+0x07, 0x7D, 0x04, 0x7F, 0x02, 0x12, 0x58, 0xF6, 0xF1, 0xA1, 0x74, 0x11, 0xF0, 0x90, 0x05, 0x58, 
+0x74, 0x02, 0xF0, 0x90, 0xA2, 0xD7, 0xE0, 0xB4, 0x01, 0x08, 0x90, 0xA2, 0xE2, 0x74, 0x01, 0xF0, 
+0x80, 0x27, 0x90, 0xA2, 0xD7, 0xE0, 0xB4, 0x04, 0x08, 0x90, 0xA2, 0xE2, 0x74, 0x04, 0xF0, 0x80, 
+0x18, 0x90, 0xA2, 0xD7, 0xE0, 0xB4, 0x06, 0x08, 0x90, 0xA2, 0xE2, 0x74, 0x02, 0xF0, 0x80, 0x09, 
+0x90, 0xA2, 0xD7, 0xE0, 0xB4, 0x07, 0x02, 0xF1, 0xED, 0xE4, 0x90, 0xA2, 0xD7, 0xF0, 0x80, 0x54, 
+0x12, 0x4F, 0xD9, 0xF1, 0xF4, 0x30, 0xE0, 0x05, 0x75, 0x0E, 0x02, 0x80, 0x11, 0x12, 0x26, 0x1E, 
+0x12, 0xA7, 0x04, 0x30, 0xE0, 0x05, 0x75, 0x0E, 0x01, 0x80, 0x03, 0xE4, 0xF5, 0x0E, 0x12, 0x9E, 
+0x57, 0x90, 0xA3, 0x2F, 0xE0, 0x30, 0xE0, 0x04, 0x7D, 0xA0, 0x80, 0x02, 0x7D, 0x20, 0x7F, 0x40, 
+0x12, 0x3A, 0x96, 0x12, 0x4F, 0xD9, 0x13, 0x13, 0x13, 0x54, 0x1F, 0x30, 0xE0, 0x04, 0x7F, 0x03, 
+0x80, 0x02, 0x7F, 0x01, 0x12, 0x95, 0x54, 0xAD, 0x0E, 0x7F, 0x02, 0x91, 0x2B, 0xF1, 0xB4, 0xF1, 
+0xA1, 0x74, 0x43, 0xF0, 0x12, 0x97, 0xDA, 0x90, 0xA2, 0xE1, 0xF0, 0x12, 0x4F, 0xF1, 0x30, 0xE0, 
+0x09, 0x90, 0xA3, 0x01, 0xE0, 0x44, 0x02, 0xF0, 0x80, 0x0B, 0x7F, 0x01, 0xF1, 0x0D, 0x90, 0xA3, 
+0x01, 0xE0, 0x54, 0xFD, 0xF0, 0x7F, 0x03, 0x12, 0x97, 0x2E, 0x90, 0xA2, 0xCF, 0xE0, 0x20, 0xE0, 
+0x07, 0x90, 0xA2, 0xD3, 0xE0, 0x54, 0xBF, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x4E, 0xFF, 0xF0, 
+0x90, 0x00, 0x04, 0x02, 0x26, 0x37, 0xE0, 0xFF, 0xA3, 0xE0, 0xFD, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 
+0xC0, 0xD0, 0x8F, 0x74, 0x8D, 0x75, 0xE5, 0x74, 0x64, 0x02, 0x60, 0x23, 0xF1, 0x72, 0x91, 0xB2, 
+0xE5, 0x74, 0x90, 0xA4, 0x08, 0xB4, 0x01, 0x08, 0x12, 0x4A, 0x12, 0xEC, 0x44, 0x08, 0x80, 0x06, 
+0x12, 0x4A, 0x12, 0xEC, 0x44, 0x04, 0x91, 0xB2, 0x90, 0xA4, 0x08, 0x91, 0xCA, 0xF1, 0x48, 0xE5, 
+0x75, 0x64, 0x02, 0x60, 0x48, 0x12, 0x77, 0xB8, 0xE4, 0x91, 0xB2, 0xE5, 0x75, 0x70, 0x08, 0xF1, 
+0x56, 0x44, 0x77, 0x91, 0xB2, 0x80, 0x2A, 0xF1, 0x56, 0x44, 0x66, 0x91, 0xB2, 0xF1, 0x72, 0xF1, 
+0x4F, 0x90, 0xA3, 0x10, 0xE0, 0x90, 0xA4, 0x0C, 0x60, 0x08, 0x12, 0x4A, 0x12, 0xEC, 0x44, 0x04, 
+0x80, 0x06, 0x12, 0x4A, 0x12, 0xEC, 0x44, 0x08, 0xF1, 0x4F, 0x90, 0xA4, 0x0C, 0x91, 0xCA, 0xF1, 
+0x48, 0x90, 0xA4, 0x08, 0x91, 0xCA, 0x7F, 0xB0, 0x7E, 0x0C, 0x12, 0x37, 0x5D, 0xD0, 0xD0, 0x92, 
+0xAF, 0x22, 0xFC, 0x90, 0xA4, 0x08, 0x02, 0x27, 0x48, 0x12, 0x36, 0xCE, 0xEF, 0x54, 0xFC, 0xFF, 
+0xEC, 0x90, 0xA4, 0x1F, 0x12, 0x27, 0x48, 0x90, 0xA4, 0x1F, 0x12, 0x4A, 0x12, 0x90, 0xAC, 0xB9, 
+0x02, 0x27, 0x48, 0x7F, 0xAC, 0x7E, 0x08, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0xA3, 
+0xEE, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x12, 0x36, 0xCE, 0x90, 0xA3, 0xF8, 0x12, 0x27, 0x48, 0x90, 
+0xA3, 0xF0, 0x12, 0x4A, 0x12, 0x12, 0x27, 0x15, 0x90, 0xA3, 0xF8, 0xF1, 0x3B, 0xC0, 0x04, 0xC0, 
+0x05, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0xA3, 0xF0, 0x12, 0x4A, 0x12, 0x90, 0xA3, 0xF4, 0xF1, 0x3B, 
+0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0x12, 0x4A, 0x05, 0x90, 0xA3, 0xFC, 0x12, 0x27, 
+0x48, 0x90, 0xA3, 0xFC, 0x91, 0xCA, 0x90, 0xA3, 0xEE, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x12, 0x37, 
+0x5D, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0xA4, 0x37, 0xEF, 0xF0, 0xA3, 0xED, 0xF0, 0xA3, 0x12, 
+0x27, 0x54, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x34, 0x7E, 0x08, 0x12, 0x36, 0xCE, 0x90, 0xA4, 0x39, 
+0x12, 0x27, 0x48, 0x90, 0xA4, 0x37, 0xE0, 0x14, 0x60, 0x5E, 0x14, 0x70, 0x02, 0xC1, 0x6B, 0x24, 
+0x02, 0x60, 0x02, 0xC1, 0xEE, 0x90, 0xA3, 0xF0, 0x12, 0x27, 0x54, 0x00, 0x30, 0x03, 0xC3, 0x90, 
+0xA3, 0xF4, 0x12, 0x27, 0x54, 0x00, 0x30, 0x02, 0x00, 0xF1, 0x03, 0x12, 0x27, 0x54, 0x40, 0x00, 
+0x00, 0x00, 0x90, 0xA3, 0xF4, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xC4, 0xF1, 0x05, 
+0x12, 0x27, 0x54, 0x00, 0x1C, 0x00, 0x00, 0x90, 0xA3, 0xF4, 0x12, 0x27, 0x54, 0x00, 0x10, 0x00, 
+0x00, 0x7F, 0x64, 0xF1, 0x05, 0x12, 0x27, 0x54, 0x03, 0xC0, 0x00, 0x00, 0x90, 0xA3, 0xF4, 0x12, 
+0x27, 0x54, 0x01, 0xC0, 0x00, 0x00, 0xC1, 0xD1, 0x90, 0xA3, 0xF0, 0x12, 0x27, 0x54, 0x00, 0x30, 
+0x03, 0xC3, 0x90, 0xA3, 0xF4, 0x12, 0x27, 0x54, 0x00, 0x30, 0x02, 0x01, 0xF1, 0x03, 0x12, 0x27, 
+0x54, 0x40, 0x00, 0x00, 0x00, 0x90, 0xA3, 0xF4, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0x00, 0x7F, 
+0xC4, 0xF1, 0x05, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0x3C, 0xD1, 0xEF, 0x12, 0x27, 0x54, 0xF0, 
+0x00, 0x00, 0x00, 0x12, 0xB3, 0x20, 0xF1, 0x05, 0x12, 0x27, 0x54, 0x00, 0x1C, 0x00, 0x00, 0x90, 
+0xA3, 0xF4, 0x12, 0x27, 0x54, 0x00, 0x08, 0x00, 0x00, 0xF1, 0x89, 0x60, 0x13, 0x12, 0x27, 0x54, 
+0x03, 0xC0, 0x00, 0x00, 0x90, 0xA3, 0xF4, 0x12, 0x27, 0x54, 0x01, 0x80, 0x00, 0x00, 0x80, 0x11, 
+0x12, 0x27, 0x54, 0x03, 0xC0, 0x00, 0x00, 0x90, 0xA3, 0xF4, 0x12, 0x27, 0x54, 0x01, 0xC0, 0x00, 
+0x00, 0x7F, 0x48, 0x7E, 0x08, 0x91, 0xD7, 0x90, 0xA4, 0x38, 0xE0, 0x90, 0xA3, 0xF0, 0xB4, 0x01, 
+0x13, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0x10, 0x90, 0xA3, 0xF4, 0x12, 0x27, 0x54, 0x00, 0x00, 
+0x00, 0x10, 0x80, 0x11, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0x10, 0x90, 0xA3, 0xF4, 0x12, 0x27, 
+0x54, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x00, 0x7E, 0x0A, 0xC1, 0xEC, 0x90, 0xA3, 0xF0, 0x12, 0x27, 
+0x54, 0x00, 0x30, 0x03, 0xC3, 0x90, 0xA3, 0xF4, 0x12, 0x27, 0x54, 0x00, 0x30, 0x02, 0x02, 0xF1, 
+0x03, 0x12, 0x27, 0x54, 0x40, 0x00, 0x00, 0x00, 0x90, 0xA3, 0xF4, 0x12, 0x27, 0x54, 0x40, 0x00, 
+0x00, 0x00, 0x7F, 0xC4, 0xF1, 0x05, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0x3C, 0xD1, 0xEF, 0x12, 
+0x27, 0x54, 0xF0, 0x00, 0x00, 0x00, 0x12, 0xB3, 0x20, 0xF1, 0x05, 0x12, 0x27, 0x54, 0x00, 0x1C, 
+0x00, 0x00, 0x90, 0xA3, 0xF4, 0x12, 0x27, 0x54, 0x00, 0x08, 0x00, 0x00, 0xF1, 0x89, 0x60, 0x17, 
+0x12, 0x27, 0x54, 0x03, 0xC0, 0x00, 0x00, 0x90, 0xA3, 0xF4, 0x12, 0x27, 0x54, 0x01, 0x40, 0x00, 
+0x00, 0x7F, 0x48, 0x7E, 0x08, 0x80, 0x15, 0x12, 0x27, 0x54, 0x03, 0xC0, 0x00, 0x00, 0x90, 0xA3, 
+0xF4, 0x12, 0x27, 0x54, 0x01, 0x80, 0x00, 0x00, 0x7F, 0x48, 0x7E, 0x08, 0x91, 0xD7, 0x22, 0x90, 
+0xA4, 0x38, 0xE0, 0xFF, 0xE4, 0xFC, 0xFD, 0xFE, 0x78, 0x02, 0x12, 0x27, 0x35, 0x90, 0xA3, 0xF4, 
+0x12, 0x27, 0x48, 0x7F, 0xAC, 0x7E, 0x08, 0x91, 0xD7, 0x90, 0xA3, 0xF0, 0x22, 0x90, 0xA3, 0x01, 
+0xE0, 0xFE, 0xC3, 0x13, 0x30, 0xE0, 0x23, 0xEF, 0xB4, 0x01, 0x0C, 0x90, 0xA3, 0x08, 0x91, 0xCA, 
+0xF1, 0x41, 0x90, 0xA3, 0x08, 0x80, 0x0A, 0x90, 0xA3, 0x04, 0x91, 0xCA, 0xF1, 0x41, 0x90, 0xA3, 
+0x04, 0x91, 0xCA, 0x7F, 0x58, 0x7E, 0x0E, 0x12, 0x37, 0x5D, 0x22, 0x12, 0x4A, 0x1E, 0x02, 0x49, 
+0xF8, 0x7F, 0x58, 0x7E, 0x0C, 0x02, 0x37, 0x5D, 0x7F, 0xB4, 0x7E, 0x0C, 0x02, 0x37, 0x5D, 0xFC, 
+0x90, 0xA4, 0x0C, 0x02, 0x27, 0x48, 0x90, 0xA4, 0x08, 0x12, 0x4A, 0x12, 0xEC, 0x22, 0xFE, 0x54, 
+0x04, 0xFD, 0xEF, 0x54, 0xFB, 0x4D, 0xFF, 0x22, 0xF0, 0xEE, 0x54, 0x40, 0xFE, 0xEF, 0x54, 0xBF, 
+0x4E, 0x22, 0x7F, 0xB4, 0x7E, 0x0C, 0x12, 0x36, 0xCE, 0xEC, 0x54, 0xF3, 0x22, 0xF0, 0xEE, 0x54, 
+0x10, 0xFE, 0xEF, 0x54, 0xEF, 0x4E, 0xFF, 0xF0, 0x22, 0x7F, 0x64, 0x7E, 0x08, 0x91, 0xD7, 0x90, 
+0xA4, 0x39, 0x12, 0x4A, 0x12, 0xE4, 0xFF, 0xFE, 0xFD, 0xEC, 0x54, 0x04, 0xFC, 0x90, 0xA3, 0xF0, 
+0x22, 0x90, 0x05, 0x00, 0x74, 0x1C, 0xF0, 0xA3, 0x22, 0x54, 0x80, 0xFE, 0xEF, 0x54, 0x7F, 0x4E, 
+0x22, 0x12, 0x8E, 0xB2, 0xE4, 0xFD, 0xFF, 0x02, 0x5B, 0x63, 0xFE, 0x54, 0x20, 0xFD, 0xEF, 0x54, 
+0xDF, 0x4D, 0xFF, 0x22, 0xE0, 0x54, 0xFE, 0x4E, 0xFE, 0xF0, 0xEF, 0x54, 0x02, 0xFF, 0xEE, 0x54, 
+0xFD, 0x4F, 0x22, 0x90, 0xA3, 0x5E, 0x74, 0xFF, 0xF0, 0xE4, 0x11, 0x67, 0xA3, 0xE0, 0x54, 0xFC, 
+0x44, 0x02, 0xF0, 0xE4, 0x01, 0x67, 0x90, 0xA2, 0xD3, 0xE0, 0xC4, 0x13, 0x22, 0x90, 0xA2, 0xE2, 
+0x74, 0x05, 0xF0, 0x22, 0xFF, 0xC4, 0x13, 0x13, 0x54, 0x03, 0x22, 0x75, 0xE8, 0x03, 0x75, 0xA8, 
+0x85, 0x22, 0x90, 0x00, 0x80, 0xE0, 0x44, 0x80, 0xFD, 0x7F, 0x80, 0x12, 0x3A, 0x96, 0x12, 0xA0, 
+0xBB, 0x12, 0x3A, 0xB8, 0x12, 0xA0, 0xC8, 0x12, 0xA1, 0x2C, 0x7F, 0x01, 0x12, 0x46, 0xF5, 0x90, 
+0xA3, 0x30, 0x74, 0x02, 0xF0, 0xFF, 0x12, 0x46, 0xF5, 0x90, 0xA3, 0x30, 0xE0, 0x04, 0xF0, 0x12, 
+0x50, 0x08, 0x11, 0x54, 0x12, 0x4B, 0x90, 0x90, 0x00, 0x80, 0xE0, 0x44, 0x40, 0xFD, 0x7F, 0x80, 
+0x12, 0x3A, 0x96, 0x75, 0x28, 0xFF, 0x12, 0x57, 0xFB, 0x12, 0x7C, 0x42, 0x12, 0xA1, 0x36, 0xE4, 
+0xFF, 0x02, 0x47, 0x7E, 0x12, 0x99, 0x6B, 0x12, 0x9F, 0x9F, 0x12, 0x6A, 0xC1, 0x11, 0x68, 0x12, 
+0xAB, 0x30, 0x12, 0x9D, 0x2E, 0x02, 0x57, 0xD3, 0x7E, 0x00, 0x7F, 0x45, 0x7D, 0x00, 0x7B, 0x01, 
+0x7A, 0xA2, 0x79, 0x83, 0x12, 0x4A, 0x6E, 0x90, 0xA2, 0x86, 0x74, 0x02, 0xF0, 0x90, 0xA2, 0x8D, 
+0x14, 0xF0, 0xA3, 0xF0, 0xA3, 0x74, 0x08, 0xF0, 0x90, 0xA2, 0x93, 0xE4, 0xF0, 0xA3, 0x74, 0x02, 
+0xF0, 0x31, 0x59, 0x74, 0x08, 0xF0, 0xE4, 0xFD, 0xFF, 0x11, 0xF6, 0x7D, 0x0C, 0x7F, 0x02, 0x11, 
+0xF6, 0x11, 0xF2, 0x90, 0xA1, 0x7C, 0xE0, 0xFF, 0xB4, 0x01, 0x08, 0x90, 0xA2, 0x92, 0x74, 0xFF, 
+0xF0, 0x80, 0x0F, 0xEF, 0x90, 0xA2, 0x92, 0xB4, 0x03, 0x05, 0x74, 0xD4, 0xF0, 0x80, 0x03, 0x74, 
+0x41, 0xF0, 0x12, 0x9C, 0x72, 0x31, 0x59, 0x74, 0x08, 0xF0, 0x90, 0xA2, 0x95, 0x12, 0x27, 0x54, 
+0x54, 0x33, 0x77, 0x70, 0x7E, 0x00, 0x7F, 0x02, 0x7D, 0x00, 0x7B, 0x01, 0x7A, 0xA2, 0x79, 0xCC, 
+0x12, 0x4A, 0x6E, 0x12, 0xB2, 0x8F, 0x12, 0xB4, 0x69, 0x12, 0x57, 0xB4, 0xE4, 0x90, 0xA2, 0xCE, 
+0xF0, 0x22, 0x7D, 0x0C, 0x7F, 0x01, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0xAC, 0x07, 0xEF, 
+0x14, 0x60, 0x15, 0x14, 0x60, 0x19, 0x24, 0x02, 0x70, 0x1A, 0xED, 0x54, 0x01, 0xFE, 0x90, 0xA2, 
+0x83, 0xE0, 0x54, 0xFE, 0x4E, 0xF0, 0x80, 0x0C, 0x90, 0xA2, 0x8A, 0xED, 0xF0, 0x80, 0x05, 0x90, 
+0xA2, 0x89, 0xED, 0xF0, 0x90, 0x00, 0x8F, 0xE0, 0x30, 0xE4, 0x29, 0xEC, 0x14, 0x60, 0x07, 0x14, 
+0x60, 0x18, 0x24, 0x02, 0x70, 0x1E, 0x90, 0xA2, 0x83, 0xE0, 0x12, 0xB4, 0x21, 0xFF, 0x90, 0xA2, 
+0x8A, 0xE0, 0x54, 0x7F, 0x4F, 0xFD, 0x7F, 0x88, 0x80, 0x07, 0x90, 0xA2, 0x89, 0xE0, 0xFD, 0x7F, 
+0x89, 0x12, 0x3A, 0x96, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0xA2, 0xBD, 0xE0, 0x24, 0x04, 0x90, 
+0xA2, 0x9F, 0xF0, 0xA3, 0x22, 0x90, 0xA4, 0x90, 0xEF, 0xF0, 0x12, 0x8E, 0xB2, 0x90, 0xA4, 0x90, 
+0xE0, 0x60, 0x03, 0x12, 0x57, 0xB4, 0x7D, 0x04, 0x7F, 0x01, 0x01, 0xF6, 0x7D, 0x01, 0x7F, 0x04, 
+0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0xA4, 0x91, 0xED, 0xF0, 0x90, 0xA2, 0x83, 0xE0, 
+0xFE, 0xC4, 0x13, 0x13, 0x54, 0x03, 0x30, 0xE0, 0x02, 0x41, 0xC6, 0xEE, 0x12, 0x4F, 0xF5, 0x30, 
+0xE0, 0x02, 0x41, 0xC6, 0x90, 0xA2, 0x8A, 0xE0, 0xFE, 0x6F, 0x70, 0x02, 0x41, 0xC6, 0xEF, 0x70, 
+0x02, 0x41, 0x3F, 0x24, 0xFE, 0x70, 0x02, 0x41, 0x78, 0x24, 0xFE, 0x60, 0x4A, 0x24, 0xFC, 0x70, 
+0x02, 0x41, 0xB3, 0x24, 0xFC, 0x60, 0x02, 0x41, 0xC6, 0xEE, 0xB4, 0x0E, 0x02, 0x51, 0xF9, 0x90, 
+0xA2, 0x8A, 0xE0, 0x70, 0x04, 0x7F, 0x01, 0x31, 0x65, 0x90, 0xA2, 0x8A, 0xE0, 0xB4, 0x06, 0x02, 
+0x71, 0x14, 0x90, 0xA2, 0x8A, 0xE0, 0xB4, 0x04, 0x0F, 0x90, 0xA4, 0x91, 0xE0, 0xFF, 0x60, 0x05, 
+0x12, 0xA2, 0x26, 0x80, 0x03, 0x12, 0x8F, 0x8C, 0x90, 0xA2, 0x8A, 0xE0, 0x64, 0x08, 0x60, 0x02, 
+0x41, 0xC6, 0x12, 0xB2, 0x27, 0x41, 0xC6, 0x90, 0xA2, 0x8A, 0xE0, 0x70, 0x04, 0x7F, 0x01, 0x31, 
+0x65, 0x90, 0xA2, 0x8A, 0xE0, 0xB4, 0x06, 0x02, 0x71, 0x14, 0x90, 0xA2, 0x8A, 0xE0, 0xB4, 0x0E, 
+0x07, 0x51, 0xCB, 0xBF, 0x01, 0x02, 0x51, 0xF9, 0x90, 0xA2, 0x8A, 0xE0, 0x64, 0x0C, 0x60, 0x02, 
+0x41, 0xC6, 0x51, 0xCB, 0xEF, 0x64, 0x01, 0x60, 0x02, 0x41, 0xC6, 0x71, 0x35, 0x41, 0xC6, 0x90, 
+0xA2, 0x8A, 0xE0, 0xB4, 0x0E, 0x07, 0x51, 0xCB, 0xBF, 0x01, 0x02, 0x51, 0xF9, 0x90, 0xA2, 0x8A, 
+0xE0, 0xB4, 0x06, 0x02, 0x71, 0x14, 0x90, 0xA2, 0x8A, 0xE0, 0xB4, 0x0C, 0x07, 0x51, 0xCB, 0xBF, 
+0x01, 0x02, 0x71, 0x35, 0x90, 0xA2, 0x8A, 0xE0, 0x64, 0x04, 0x70, 0x5A, 0x12, 0xB1, 0x7B, 0xEF, 
+0x64, 0x01, 0x70, 0x52, 0xF1, 0xC2, 0x80, 0x4E, 0x90, 0xA2, 0x8A, 0xE0, 0xB4, 0x0E, 0x07, 0x51, 
+0xCB, 0xBF, 0x01, 0x02, 0x51, 0xF9, 0x90, 0xA2, 0x8A, 0xE0, 0xB4, 0x06, 0x02, 0x71, 0x14, 0x90, 
+0xA2, 0x8A, 0xE0, 0xB4, 0x0C, 0x07, 0x51, 0xCB, 0xBF, 0x01, 0x02, 0x71, 0x35, 0x90, 0xA2, 0x8A, 
+0xE0, 0x70, 0x04, 0x7F, 0x01, 0x31, 0x65, 0x90, 0xA2, 0x8A, 0xE0, 0xB4, 0x04, 0x18, 0x12, 0xB1, 
+0xFD, 0x80, 0x13, 0x90, 0xA2, 0x8A, 0xE0, 0xB4, 0x0C, 0x0C, 0x90, 0xA2, 0x84, 0x12, 0x93, 0xF9, 
+0x30, 0xE0, 0x03, 0x12, 0xB2, 0x16, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0xA2, 0xCF, 0xE0, 0x30, 
+0xE0, 0x0D, 0x90, 0xA2, 0xD5, 0xE0, 0xC4, 0x13, 0x54, 0x07, 0x30, 0xE0, 0x08, 0x80, 0x17, 0x12, 
+0xB1, 0x62, 0xBF, 0x01, 0x11, 0xF1, 0xAD, 0x20, 0xE0, 0x0C, 0x90, 0xA2, 0x89, 0xE0, 0xD3, 0x94, 
+0x04, 0x50, 0x03, 0x7F, 0x01, 0x22, 0x7F, 0x00, 0x22, 0x90, 0xA2, 0x84, 0xE0, 0xC3, 0x13, 0x20, 
+0xE0, 0x04, 0x7D, 0x0C, 0x80, 0x05, 0x12, 0xB2, 0x97, 0x7D, 0x04, 0x7F, 0x01, 0x11, 0xF6, 0xE4, 
+0xFD, 0xFF, 0x80, 0x4F, 0x90, 0xA2, 0x84, 0xE0, 0x90, 0x06, 0x04, 0x20, 0xE0, 0x08, 0xE0, 0x44, 
+0x40, 0xF0, 0x7D, 0x04, 0x80, 0x06, 0xE0, 0x54, 0x7F, 0xF0, 0x7D, 0x0C, 0x7F, 0x01, 0x11, 0xF6, 
+0xE4, 0xFD, 0xFF, 0x80, 0x2E, 0x12, 0xA1, 0xF7, 0x70, 0x1F, 0x90, 0xA2, 0x84, 0xE0, 0x54, 0xFD, 
+0xF0, 0x7D, 0x2C, 0x7F, 0x6F, 0x71, 0x63, 0x71, 0x6E, 0xBF, 0x01, 0x0D, 0x90, 0xA2, 0x83, 0xE0, 
+0x44, 0x80, 0xF0, 0x7D, 0x0E, 0x7F, 0x01, 0x11, 0xF6, 0x22, 0xE4, 0xFD, 0x7F, 0x0C, 0x31, 0x80, 
+0xE4, 0xFD, 0xFF, 0x90, 0x05, 0x22, 0xEF, 0xF0, 0x90, 0xA1, 0x7A, 0xED, 0xF0, 0x22, 0x90, 0xA2, 
+0xD6, 0xE0, 0x44, 0x02, 0xF0, 0x7D, 0x08, 0x7F, 0x01, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 
+0x90, 0xA4, 0x3D, 0xEF, 0xF0, 0xA3, 0xED, 0xF0, 0x90, 0xA1, 0x78, 0xE0, 0x04, 0xF0, 0x90, 0x04, 
+0x1D, 0xE0, 0x60, 0x33, 0x90, 0x05, 0x22, 0xE0, 0x90, 0xA4, 0x41, 0xF0, 0x7D, 0x26, 0xD1, 0x0D, 
+0xEF, 0x64, 0x01, 0x70, 0x07, 0x91, 0x39, 0x20, 0xE0, 0x0F, 0x80, 0x0A, 0xF1, 0xED, 0x30, 0xE0, 
+0x08, 0x91, 0x39, 0x20, 0xE0, 0x03, 0x12, 0x7A, 0x73, 0x90, 0xA4, 0x41, 0xE0, 0xFF, 0x7D, 0x27, 
+0x71, 0x63, 0x12, 0xB2, 0x31, 0x80, 0x0B, 0x12, 0xB2, 0x31, 0x91, 0x39, 0x20, 0xE0, 0x03, 0x12, 
+0x7A, 0x73, 0x90, 0xA2, 0xCF, 0xE0, 0x30, 0xE0, 0x0B, 0xF1, 0xED, 0x30, 0xE0, 0x06, 0xF1, 0xF7, 
+0x7D, 0x28, 0x71, 0x63, 0xD1, 0xD5, 0x7F, 0x01, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0xA4, 0x33, 
+0xE0, 0xFF, 0x12, 0xB3, 0x38, 0x54, 0x3F, 0xF0, 0xEF, 0x60, 0x32, 0x12, 0xB3, 0x70, 0x44, 0x10, 
+0x12, 0xB3, 0x37, 0x44, 0x80, 0xF0, 0x12, 0x57, 0xE6, 0x54, 0x07, 0x30, 0xE0, 0x2A, 0x12, 0x93, 
+0xD9, 0x50, 0x0C, 0xEF, 0x25, 0xE0, 0x25, 0xE0, 0xFF, 0x74, 0x2B, 0x2D, 0x02, 0xB3, 0xEC, 0x74, 
+0x2B, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0x74, 0x7F, 0xF0, 0x22, 0x12, 0xB3, 0x70, 
+0x54, 0xEF, 0x12, 0xB3, 0x37, 0x44, 0x40, 0xF0, 0x22, 0x90, 0xA1, 0x7F, 0xE0, 0xFF, 0x90, 0xA4, 
+0x3E, 0xE0, 0xFB, 0x7D, 0x01, 0x91, 0xA9, 0x90, 0xA4, 0x3F, 0xEE, 0xF0, 0xFC, 0xA3, 0xEF, 0xF0, 
+0xFD, 0x90, 0xA4, 0x3D, 0xE0, 0xFF, 0x71, 0xF2, 0x90, 0xA3, 0x31, 0xE0, 0x22, 0xD3, 0x10, 0xAF, 
+0x01, 0xC3, 0xC0, 0xD0, 0x90, 0xA4, 0x31, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0xA3, 0xED, 0xF0, 0x90, 
+0x04, 0x1D, 0xE0, 0x60, 0x1E, 0x90, 0x05, 0x22, 0xE0, 0x90, 0xA4, 0x36, 0xF0, 0x7D, 0x13, 0xD1, 
+0x0D, 0xBF, 0x01, 0x04, 0xB1, 0x7B, 0x71, 0xED, 0x90, 0xA4, 0x36, 0xE0, 0xFF, 0x7D, 0x15, 0x71, 
+0x63, 0x80, 0x04, 0xB1, 0x7B, 0x71, 0xED, 0xD1, 0xD5, 0x7F, 0x01, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 
+0x90, 0xA1, 0x81, 0xE0, 0xFF, 0x7B, 0x08, 0x7D, 0x01, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 
+0x90, 0xA4, 0x71, 0xED, 0xF0, 0xA3, 0xEB, 0xF0, 0x90, 0xA4, 0x70, 0xEF, 0xF0, 0xE4, 0xFD, 0xFC, 
+0x12, 0xB2, 0xF3, 0x7C, 0x00, 0xAD, 0x07, 0x90, 0xA4, 0x70, 0xE0, 0x90, 0x04, 0x25, 0xF0, 0x90, 
+0xA4, 0x71, 0xE0, 0x60, 0x06, 0x12, 0xB3, 0xC1, 0x44, 0x80, 0xF0, 0xAF, 0x05, 0x74, 0x20, 0x2F, 
+0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x54, 0xC0, 0xF0, 0x12, 0xB3, 0xC1, 0x54, 0xC0, 
+0xF0, 0xAF, 0x05, 0xF1, 0xB7, 0xE0, 0x54, 0x01, 0xFE, 0x90, 0xA4, 0x72, 0xE0, 0x25, 0xE0, 0x25, 
+0xE0, 0xFB, 0xEE, 0x44, 0x02, 0x4B, 0xFE, 0xF1, 0xB7, 0xEE, 0xF0, 0x74, 0x11, 0x2F, 0x12, 0xB4, 
+0x79, 0x74, 0xFF, 0xF0, 0x74, 0x29, 0x2F, 0x12, 0xB3, 0x73, 0x54, 0xF7, 0xF0, 0xAE, 0x04, 0xAF, 
+0x05, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0xA4, 0x66, 
+0xEF, 0xF0, 0x90, 0x04, 0x1D, 0xE0, 0x60, 0x2B, 0x90, 0x05, 0x22, 0xE0, 0x90, 0xA4, 0x69, 0xF0, 
+0x7D, 0x29, 0xD1, 0x0D, 0xBF, 0x01, 0x11, 0x90, 0xA1, 0x80, 0x91, 0xA3, 0x90, 0xA4, 0x67, 0xB1, 
+0x8A, 0x90, 0xA4, 0x66, 0xE0, 0xFF, 0x71, 0xF2, 0x90, 0xA4, 0x69, 0xE0, 0xFF, 0x7D, 0x2A, 0x71, 
+0x63, 0x80, 0x11, 0x90, 0xA1, 0x80, 0x91, 0xA3, 0x90, 0xA4, 0x67, 0xB1, 0x8A, 0x90, 0xA4, 0x66, 
+0xE0, 0xFF, 0x71, 0xF2, 0xD1, 0xD5, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0xA4, 0x31, 0xA3, 0xE0, 
+0xFF, 0x7B, 0x08, 0x7D, 0x01, 0x91, 0xA9, 0x90, 0xA4, 0x34, 0xEE, 0xF0, 0xFC, 0xA3, 0xEF, 0xF0, 
+0xFD, 0x22, 0x90, 0xA3, 0xA7, 0xF1, 0xE4, 0x90, 0x04, 0x1D, 0xE0, 0x60, 0x25, 0x90, 0x05, 0x22, 
+0xE0, 0x90, 0xA3, 0xAC, 0xF0, 0x7D, 0x01, 0xD1, 0x0D, 0xEF, 0x64, 0x01, 0x70, 0x09, 0x91, 0xA0, 
+0x90, 0xA3, 0xAA, 0xB1, 0x8A, 0xF1, 0x41, 0x90, 0xA3, 0xAC, 0xE0, 0xFF, 0x7D, 0x02, 0x71, 0x63, 
+0x80, 0x09, 0x91, 0xA0, 0x90, 0xA3, 0xAA, 0xB1, 0x8A, 0xF1, 0x41, 0xC1, 0xD5, 0xD3, 0x10, 0xAF, 
+0x01, 0xC3, 0xC0, 0xD0, 0x90, 0xA3, 0xA9, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0x04, 0x1D, 0xE0, 
+0x60, 0x1D, 0x90, 0x05, 0x22, 0xE0, 0x90, 0xA3, 0xAD, 0xF0, 0x7D, 0x36, 0xD1, 0x0D, 0xBF, 0x01, 
+0x03, 0x12, 0xB2, 0xA3, 0x90, 0xA3, 0xAD, 0xE0, 0xFF, 0x7D, 0x37, 0x71, 0x63, 0x80, 0x03, 0x12, 
+0xB2, 0xA3, 0xF1, 0xF7, 0x7D, 0x38, 0xD1, 0xD3, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x7F, 0xFF, 0x71, 
+0x63, 0xE4, 0x90, 0xA4, 0x80, 0xF0, 0xA3, 0xF0, 0x90, 0x05, 0xF8, 0xE0, 0x70, 0x0F, 0xA3, 0xE0, 
+0x70, 0x0B, 0xA3, 0xE0, 0x70, 0x07, 0xA3, 0xE0, 0x70, 0x03, 0x7F, 0x01, 0x22, 0xF1, 0xED, 0x30, 
+0xE0, 0x15, 0xD3, 0x90, 0xA4, 0x81, 0xE0, 0x94, 0x03, 0x90, 0xA4, 0x80, 0xE0, 0x94, 0x00, 0x40, 
+0x02, 0x80, 0x13, 0x7F, 0x01, 0x80, 0x1B, 0xD3, 0x90, 0xA4, 0x81, 0xE0, 0x94, 0xE8, 0x90, 0xA4, 
+0x80, 0xE0, 0x94, 0x03, 0x40, 0x0A, 0x90, 0x01, 0xC0, 0xE0, 0x44, 0x20, 0xF0, 0x7F, 0x00, 0x22, 
+0x7F, 0x32, 0x7E, 0x00, 0x12, 0x3A, 0xF7, 0x90, 0xA4, 0x80, 0x12, 0x79, 0xC5, 0x80, 0xA9, 0x90, 
+0xA3, 0xA6, 0xF1, 0xE4, 0x90, 0xA3, 0x1D, 0xF1, 0xB0, 0x20, 0xE0, 0x0D, 0x90, 0xA3, 0xA7, 0xE0, 
+0xB4, 0x01, 0x06, 0x7D, 0x36, 0x7F, 0x6F, 0x71, 0x63, 0x90, 0xA3, 0xA6, 0xE0, 0x70, 0x0B, 0x90, 
+0xA3, 0xA8, 0xE0, 0xFF, 0x7D, 0x05, 0x71, 0x79, 0x80, 0x26, 0x90, 0xA3, 0xA6, 0xE0, 0xB4, 0x01, 
+0x09, 0x90, 0xA3, 0xA8, 0xE0, 0xFF, 0xB1, 0x26, 0x80, 0x16, 0x90, 0xA3, 0xA6, 0xE0, 0xB4, 0x02, 
+0x0F, 0xA3, 0xE0, 0xB4, 0x01, 0x0A, 0x90, 0xA3, 0x2B, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0xB1, 0xCD, 
+0x90, 0xA3, 0x1D, 0xF1, 0xB0, 0x20, 0xE0, 0x0A, 0x90, 0xA3, 0xA7, 0xE0, 0x70, 0x04, 0xFD, 0xFF, 
+0x71, 0x63, 0x22, 0x71, 0x63, 0x90, 0x04, 0x1F, 0x74, 0x20, 0xF0, 0x22, 0x90, 0xA3, 0x31, 0xE0, 
+0x30, 0xE0, 0x5D, 0x90, 0xA3, 0x33, 0xE0, 0x70, 0x2C, 0x7D, 0x16, 0x7F, 0x6F, 0x71, 0x63, 0xD1, 
+0x11, 0xF1, 0xDB, 0x75, 0xF0, 0x0E, 0x12, 0xB3, 0x15, 0x7D, 0x01, 0x91, 0x5D, 0xF1, 0xDB, 0x12, 
+0xA6, 0xEF, 0xE0, 0x44, 0x01, 0xF0, 0x12, 0xB3, 0xF6, 0x74, 0x03, 0x12, 0x7C, 0xC9, 0x90, 0xA3, 
+0x33, 0x74, 0x01, 0xF0, 0x22, 0x90, 0xA3, 0x33, 0xE0, 0x64, 0x01, 0x70, 0x20, 0xF1, 0xDB, 0x12, 
+0xA6, 0xEE, 0xE0, 0x30, 0xE0, 0x17, 0x12, 0xB3, 0x11, 0x7D, 0x01, 0x91, 0x5D, 0x12, 0xB3, 0xF6, 
+0x74, 0x03, 0xF0, 0xE4, 0xFB, 0xFD, 0x7F, 0x54, 0x7E, 0x01, 0x02, 0x7C, 0xD1, 0x12, 0x7F, 0x2A, 
+0x22, 0x90, 0xA3, 0xA7, 0xE0, 0xFF, 0xA3, 0xE0, 0xFB, 0xA3, 0xE0, 0x90, 0xA3, 0xB1, 0xF0, 0x90, 
+0xA3, 0xAE, 0xEC, 0xF1, 0xE5, 0x90, 0xA3, 0xAE, 0xE0, 0xFC, 0xA3, 0xE0, 0xFD, 0x71, 0xF2, 0x90, 
+0xA3, 0xAE, 0xA3, 0xE0, 0xFF, 0xFD, 0x24, 0x0D, 0x12, 0x7A, 0xDE, 0x44, 0x80, 0xF0, 0x74, 0x0D, 
+0x2D, 0x12, 0x7A, 0xDE, 0x54, 0xEF, 0xF0, 0xF1, 0xB7, 0xE0, 0x44, 0x02, 0xF0, 0xF1, 0xB7, 0xE0, 
+0x54, 0x03, 0xF0, 0x90, 0xA3, 0xB0, 0xE0, 0xFF, 0x90, 0xA3, 0xAE, 0xA3, 0xE0, 0xFE, 0x24, 0x2A, 
+0x12, 0xB2, 0xE9, 0x90, 0xA3, 0xB1, 0xE0, 0xFF, 0x74, 0x2B, 0x2E, 0x12, 0xB3, 0xEC, 0x74, 0x2C, 
+0x2E, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x24, 0x02, 0xF0, 0x22, 0x90, 0xA2, 0x83, 
+0xE0, 0x13, 0x13, 0x13, 0x54, 0x1F, 0x22, 0x74, 0x12, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 
+0x83, 0x22, 0x7D, 0x2D, 0xD1, 0x0D, 0x90, 0x01, 0x37, 0x74, 0x02, 0xF0, 0xFD, 0x7F, 0x03, 0x12, 
+0x87, 0xCE, 0x12, 0x95, 0x8E, 0xE4, 0xFD, 0x7F, 0x01, 0x01, 0xF6, 0x90, 0xA3, 0x31, 0xE0, 0xC3, 
+0x13, 0x54, 0x07, 0x22, 0xEF, 0xF0, 0xA3, 0xED, 0xF0, 0xA3, 0xEB, 0xF0, 0x22, 0x90, 0xA2, 0xD3, 
+0xE0, 0xC4, 0x13, 0x13, 0x54, 0x03, 0x22, 0x90, 0x05, 0x22, 0xE0, 0x54, 0x6F, 0xFF, 0x22, 0xE4, 
+0x90, 0xA3, 0x73, 0xF0, 0x90, 0xA3, 0x73, 0xE0, 0x64, 0x01, 0xF0, 0x24, 0xFF, 0x90, 0x01, 0xC4, 
+0xF0, 0x74, 0x5F, 0xA3, 0xF0, 0x12, 0x3A, 0xEB, 0xBF, 0x01, 0x03, 0x12, 0x31, 0x69, 0x90, 0xA2, 
+0x87, 0xE0, 0x60, 0x0F, 0x90, 0xA2, 0x8A, 0xE0, 0xFF, 0x90, 0xA2, 0x89, 0xE0, 0x6F, 0x60, 0x03, 
+0x12, 0xA4, 0xED, 0xC2, 0xAF, 0x12, 0xA0, 0xF8, 0xBF, 0x01, 0x03, 0x12, 0xB2, 0x0B, 0xD2, 0xAF, 
+0x11, 0x47, 0x12, 0x46, 0x2D, 0x80, 0xBD, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x00, 
+0x8F, 0xE0, 0x20, 0xE6, 0x02, 0x21, 0x3B, 0x90, 0x00, 0x8C, 0xE0, 0xF5, 0x72, 0xA3, 0xE0, 0xFF, 
+0xA3, 0xE0, 0xF5, 0x73, 0xEF, 0x24, 0xFC, 0x60, 0x13, 0x24, 0xEE, 0x70, 0x02, 0x01, 0xF6, 0x24, 
+0x15, 0x60, 0x02, 0x21, 0x31, 0xAF, 0x72, 0x12, 0xAA, 0xD4, 0x21, 0x31, 0x74, 0x11, 0x25, 0x72, 
+0x31, 0x88, 0xFB, 0xE4, 0xFD, 0x31, 0x7A, 0x12, 0x4F, 0x3D, 0x13, 0x13, 0x31, 0x75, 0x12, 0x4F, 
+0x3D, 0x12, 0x4F, 0xF5, 0x31, 0x77, 0x12, 0x4F, 0x3D, 0xC4, 0x31, 0x75, 0x12, 0x6F, 0xF9, 0xE0, 
+0xFB, 0xE4, 0xFD, 0x0F, 0x31, 0x7B, 0x12, 0x6B, 0xDB, 0xE0, 0xFB, 0x0D, 0x31, 0x7B, 0x12, 0x6B, 
+0xE5, 0xC4, 0x13, 0x54, 0x01, 0xFB, 0x0D, 0x7F, 0x01, 0x31, 0x7B, 0x12, 0x6B, 0xE5, 0x54, 0x1F, 
+0x31, 0x6B, 0x90, 0x89, 0x00, 0x12, 0xB4, 0x18, 0x31, 0x6D, 0x90, 0x89, 0x01, 0x31, 0x67, 0x90, 
+0x89, 0x02, 0x31, 0x67, 0x90, 0x89, 0x03, 0x31, 0x67, 0x90, 0x89, 0x04, 0x12, 0xB4, 0x18, 0x31, 
+0x6D, 0x90, 0x89, 0x05, 0x31, 0x67, 0x90, 0x89, 0x06, 0x31, 0x67, 0x90, 0x89, 0x07, 0x12, 0x4A, 
+0x2A, 0xE0, 0xFB, 0x0D, 0x80, 0x39, 0x90, 0xA3, 0x5E, 0xE0, 0xFB, 0xE4, 0xFD, 0xFF, 0x31, 0x43, 
+0x90, 0xA3, 0x5F, 0xA3, 0x31, 0x40, 0x90, 0xA3, 0x61, 0x31, 0x40, 0x90, 0xA3, 0x62, 0xE0, 0x54, 
+0x03, 0xFB, 0x0D, 0x31, 0x43, 0x90, 0xA3, 0x63, 0xA3, 0xE0, 0xFB, 0xE4, 0xFD, 0x0F, 0x31, 0x43, 
+0x90, 0xA3, 0x63, 0xE0, 0xFB, 0x0D, 0x31, 0x43, 0x90, 0xA3, 0x65, 0xE0, 0xFB, 0x1D, 0x0F, 0x31, 
+0x43, 0x90, 0x00, 0x8F, 0xE0, 0x30, 0xE0, 0x03, 0x12, 0xAB, 0x29, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 
+0xE0, 0xFB, 0x0D, 0xEF, 0x70, 0x04, 0x74, 0xF0, 0x80, 0x16, 0xEF, 0xB4, 0x01, 0x04, 0x74, 0xF4, 
+0x80, 0x0E, 0xEF, 0xB4, 0x02, 0x04, 0x74, 0xF8, 0x80, 0x06, 0xEF, 0xB4, 0x03, 0x08, 0x74, 0xFC, 
+0x2D, 0x12, 0xA0, 0x4C, 0xEB, 0xF0, 0x22, 0x12, 0x4A, 0x2A, 0xE0, 0xFB, 0x0D, 0x31, 0x43, 0x75, 
+0xF0, 0x08, 0xE5, 0x72, 0x22, 0x54, 0x03, 0xFB, 0x0D, 0xE4, 0xFF, 0x31, 0x43, 0x75, 0xF0, 0x04, 
+0xE5, 0x72, 0x22, 0xFF, 0x74, 0x11, 0x25, 0x0D, 0xF5, 0x82, 0xE4, 0x34, 0x9A, 0xF5, 0x83, 0xE0, 
+0x22, 0xAC, 0x07, 0x75, 0xF0, 0x04, 0xEC, 0x90, 0x96, 0x14, 0x12, 0x4A, 0x2A, 0x75, 0xF0, 0x04, 
+0xEC, 0x12, 0x6F, 0xF9, 0xE0, 0xFA, 0x74, 0x75, 0x2C, 0x91, 0x84, 0xE0, 0x54, 0x7F, 0xFD, 0x75, 
+0xF0, 0x04, 0xEC, 0x12, 0x76, 0x92, 0xE0, 0xFF, 0x54, 0xF8, 0xFE, 0xEF, 0x04, 0x54, 0x07, 0x4E, 
+0xF0, 0x75, 0xF0, 0x04, 0xEC, 0x12, 0x76, 0x92, 0xE0, 0xFF, 0x54, 0x07, 0xD3, 0x94, 0x02, 0x40, 
+0x45, 0x74, 0xA1, 0x2C, 0x51, 0x4C, 0xE0, 0xF4, 0x70, 0x3C, 0x75, 0xF0, 0x04, 0xEC, 0x12, 0x76, 
+0x92, 0xEF, 0x54, 0xF8, 0xF0, 0x74, 0x11, 0x2C, 0x31, 0x88, 0x54, 0x7F, 0xFF, 0x75, 0xF0, 0x04, 
+0xEC, 0x12, 0x77, 0x60, 0x54, 0x80, 0x4F, 0xF0, 0x74, 0x11, 0x2C, 0x31, 0x88, 0x25, 0xE0, 0xFF, 
+0xE4, 0x33, 0xFE, 0xEF, 0x24, 0x32, 0xFF, 0xE4, 0x3E, 0xFE, 0x75, 0xF0, 0x04, 0xEC, 0x12, 0x76, 
+0x9D, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x74, 0x21, 0x2C, 0x12, 0xB3, 0xB9, 0xE0, 0xFB, 0x12, 0xB4, 
+0x11, 0xFF, 0x75, 0xF0, 0x04, 0xEC, 0x12, 0x4F, 0x3D, 0x54, 0xF3, 0x4F, 0xF0, 0xED, 0xD3, 0x9A, 
+0x40, 0x02, 0xAD, 0x02, 0x74, 0x75, 0x2C, 0x91, 0x84, 0xE0, 0x54, 0x80, 0x42, 0x05, 0xAF, 0x04, 
+0x8B, 0x71, 0xE4, 0xFB, 0xC1, 0xB4, 0x90, 0xA3, 0x91, 0xE0, 0x24, 0xA1, 0xF5, 0x82, 0xE4, 0x34, 
+0x9D, 0xF5, 0x83, 0x22, 0xA9, 0x05, 0x90, 0xA3, 0x8B, 0xEF, 0xF0, 0xE0, 0xFE, 0x75, 0xF0, 0x04, 
+0x12, 0x76, 0x9D, 0xE4, 0xF0, 0xA3, 0xF0, 0x75, 0xF0, 0x10, 0xEE, 0x12, 0x76, 0xD3, 0xE0, 0xF5, 
+0x1A, 0x54, 0x7F, 0xF5, 0x1C, 0x12, 0xB4, 0x3C, 0x12, 0x6B, 0xDB, 0xE0, 0x90, 0xA3, 0x8E, 0xF0, 
+0x75, 0xF0, 0x04, 0xEE, 0x12, 0x6F, 0xF9, 0xE0, 0xFC, 0x75, 0xF0, 0x04, 0xEF, 0x12, 0x4F, 0x3D, 
+0x13, 0x13, 0x54, 0x03, 0xF5, 0x1B, 0xE5, 0x1C, 0x12, 0xB3, 0x44, 0xE4, 0x93, 0xFA, 0x74, 0x01, 
+0x93, 0xFB, 0xEF, 0x12, 0x76, 0xB1, 0xEA, 0xF0, 0xA3, 0xEB, 0xF0, 0x90, 0xA3, 0x8B, 0xE0, 0xFF, 
+0x75, 0xF0, 0x04, 0x12, 0x4F, 0x3D, 0xFE, 0xC4, 0x54, 0x03, 0x90, 0xA3, 0x8C, 0xF0, 0x74, 0x75, 
+0x2F, 0x91, 0x84, 0xE5, 0x1C, 0xF0, 0x90, 0xA3, 0x8B, 0xE0, 0xFF, 0x24, 0x21, 0x12, 0xB3, 0xB9, 
+0xE5, 0x1B, 0xF0, 0xE5, 0x1C, 0xD3, 0x9C, 0x40, 0x0D, 0x8C, 0x1C, 0x8C, 0x1A, 0xAE, 0x04, 0x74, 
+0xA1, 0x2F, 0x51, 0x4C, 0xEE, 0xF0, 0xE9, 0x70, 0x02, 0x81, 0x74, 0xAF, 0x01, 0x8F, 0x1D, 0xE5, 
+0x1A, 0x30, 0xE7, 0x0D, 0x85, 0x1C, 0x1A, 0x90, 0xA3, 0x8B, 0x51, 0x49, 0xE5, 0x1C, 0xF0, 0x15, 
+0x1D, 0xE5, 0x1D, 0x70, 0x02, 0x81, 0x74, 0x90, 0xA3, 0x8B, 0xE0, 0xFF, 0xAD, 0x1A, 0x12, 0xA8, 
+0xAA, 0xEF, 0xF4, 0x60, 0x17, 0x8F, 0x1A, 0xD5, 0x1D, 0x12, 0x90, 0xA3, 0x8B, 0xE0, 0xFF, 0x91, 
+0x82, 0xE0, 0xFE, 0x74, 0xA1, 0x2F, 0x51, 0x4C, 0xEE, 0xF0, 0x81, 0x74, 0xE5, 0x1A, 0x64, 0x2C, 
+0x70, 0x33, 0xE5, 0x1B, 0xD3, 0x94, 0x00, 0x40, 0x2C, 0xE5, 0x1B, 0xD3, 0x94, 0x02, 0x50, 0x25, 
+0x15, 0x1B, 0x75, 0x1A, 0x2D, 0xE5, 0x1B, 0x12, 0xB4, 0x11, 0xFF, 0x12, 0xB4, 0x3C, 0x12, 0x4F, 
+0x3D, 0x54, 0xF3, 0x4F, 0xF0, 0x74, 0xA1, 0x2E, 0x51, 0x4C, 0x74, 0xFF, 0xF0, 0x15, 0x1D, 0xE5, 
+0x1D, 0x70, 0x02, 0x81, 0x74, 0xE5, 0x1A, 0xB4, 0x2D, 0x1A, 0xE5, 0x1B, 0xD3, 0x94, 0x02, 0x50, 
+0x13, 0x75, 0x1A, 0x2C, 0x90, 0xA3, 0x8B, 0x51, 0x49, 0x74, 0xFF, 0xF0, 0x15, 0x1D, 0xE5, 0x1D, 
+0x70, 0x02, 0x81, 0x74, 0xE5, 0x1D, 0x70, 0x02, 0x81, 0x74, 0x90, 0xA3, 0x8E, 0xE0, 0xFF, 0xE5, 
+0x1C, 0xD3, 0x9F, 0x50, 0x02, 0x81, 0x6E, 0xE4, 0x90, 0xA3, 0x8D, 0xF0, 0x90, 0xA3, 0x8C, 0xE0, 
+0xFF, 0xAD, 0x1C, 0x12, 0xA9, 0x88, 0x8F, 0x1C, 0x85, 0x1C, 0x1A, 0xE0, 0xFF, 0x90, 0xA3, 0x8E, 
+0xE0, 0xFD, 0x12, 0xA9, 0x88, 0xEF, 0xF0, 0xE5, 0x1A, 0xD3, 0x94, 0x0B, 0x40, 0x1B, 0x90, 0xA3, 
+0x8B, 0xE0, 0xFB, 0xA3, 0xE0, 0x90, 0xA3, 0x92, 0xF0, 0x7D, 0x01, 0xAF, 0x1C, 0x12, 0x6B, 0xFB, 
+0x8F, 0x1A, 0xE5, 0x1A, 0xF4, 0x70, 0x5B, 0x81, 0x74, 0xAD, 0x1A, 0xE5, 0x1C, 0x14, 0xFC, 0x90, 
+0xA3, 0x8E, 0xE0, 0xFF, 0xEC, 0xC3, 0x9F, 0x40, 0x39, 0x12, 0xB3, 0xE4, 0x90, 0xA3, 0x8B, 0x12, 
+0x6A, 0x8E, 0x12, 0x6F, 0x8B, 0x80, 0x05, 0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 0xF9, 0x12, 0x8F, 
+0xE0, 0x60, 0x1C, 0xE5, 0x1C, 0xAD, 0x04, 0xB4, 0x14, 0x02, 0x7D, 0x0C, 0x90, 0xA3, 0x8D, 0xE0, 
+0x04, 0xF0, 0xE0, 0x65, 0x1D, 0x60, 0x0B, 0xA3, 0xE0, 0xFF, 0xED, 0xD3, 0x9F, 0x40, 0x03, 0x1C, 
+0x80, 0xBD, 0x90, 0xA3, 0x8B, 0x51, 0x49, 0xED, 0xF0, 0xE5, 0x1A, 0xB4, 0xFF, 0x04, 0xAF, 0x05, 
+0x8F, 0x1A, 0x90, 0xA3, 0x8C, 0xE0, 0xFF, 0xAD, 0x1A, 0x12, 0xA9, 0x9C, 0x8F, 0x1A, 0x90, 0xA3, 
+0x8B, 0x51, 0x49, 0xE0, 0xFD, 0xF4, 0x60, 0x1B, 0x90, 0xA3, 0x8C, 0xE0, 0xFF, 0x12, 0xA9, 0x9C, 
+0x90, 0xA3, 0x8B, 0xE0, 0xFE, 0x91, 0x82, 0xEF, 0xF0, 0x74, 0xA1, 0x2E, 0x51, 0x4C, 0x74, 0xFF, 
+0xF0, 0x80, 0x11, 0x90, 0xA3, 0x8B, 0xE0, 0x91, 0x82, 0xE5, 0x1A, 0xF0, 0x80, 0x06, 0x90, 0xA3, 
+0x8E, 0xE0, 0xF5, 0x1A, 0x90, 0xA3, 0x8B, 0xE0, 0xFF, 0x85, 0x1B, 0x71, 0x7B, 0x01, 0xAD, 0x1A, 
+0xC1, 0xB4, 0x24, 0x75, 0xF5, 0x82, 0xE4, 0x34, 0xA0, 0xF5, 0x83, 0x22, 0x8F, 0x1A, 0x75, 0xF0, 
+0x10, 0xEF, 0x12, 0x76, 0xD3, 0xE0, 0xF5, 0x1B, 0xE4, 0xF5, 0x20, 0xE5, 0x1B, 0x54, 0x7F, 0xF5, 
+0x1C, 0xE5, 0x1B, 0x54, 0x80, 0xFF, 0x75, 0xF0, 0x04, 0xE5, 0x1A, 0x12, 0x6F, 0xF9, 0xE0, 0xF5, 
+0x1E, 0x75, 0xF0, 0x04, 0xE5, 0x1A, 0x12, 0x4F, 0x3D, 0xFE, 0xC4, 0x54, 0x03, 0xF5, 0x1F, 0xE5, 
+0x1C, 0x12, 0x77, 0x6A, 0x12, 0xB4, 0x71, 0xE5, 0x1A, 0x12, 0x76, 0xB1, 0xEC, 0xF0, 0xA3, 0xED, 
+0xF0, 0xE5, 0x1B, 0x4F, 0xFF, 0x74, 0x75, 0x25, 0x1A, 0x91, 0x84, 0xEF, 0xF0, 0x75, 0xF0, 0x04, 
+0xE5, 0x1A, 0x12, 0x4F, 0x3D, 0x13, 0x13, 0x54, 0x03, 0xF5, 0x1D, 0x74, 0x21, 0x25, 0x1A, 0x12, 
+0xB3, 0xB9, 0xE5, 0x1D, 0xF0, 0x74, 0x91, 0x25, 0x1A, 0x12, 0x4F, 0x49, 0xE0, 0x30, 0xE0, 0x22, 
+0xE5, 0x1C, 0x64, 0x3F, 0x70, 0x1C, 0x12, 0xB4, 0x45, 0x12, 0x6B, 0xE5, 0xC4, 0x13, 0x54, 0x07, 
+0x30, 0xE0, 0x05, 0x75, 0x1B, 0xBE, 0x80, 0x03, 0x85, 0x1C, 0x1B, 0x85, 0x1D, 0x71, 0xE4, 0xFB, 
+0xD1, 0xB0, 0xAD, 0x1B, 0xAF, 0x1A, 0x12, 0xA8, 0xED, 0xEF, 0xF4, 0x60, 0x0B, 0x8F, 0x1B, 0xEF, 
+0x30, 0xE7, 0x02, 0xC1, 0xAB, 0x85, 0x1B, 0x1C, 0xE5, 0x1C, 0x64, 0x2D, 0x70, 0x2F, 0x75, 0xF0, 
+0x04, 0xE5, 0x1A, 0x12, 0x4F, 0x3D, 0xFF, 0x54, 0x03, 0xFE, 0xE5, 0x1D, 0xC3, 0x9E, 0x50, 0x1D, 
+0x75, 0x1B, 0x2C, 0x05, 0x1D, 0xE5, 0x1D, 0x12, 0xB4, 0x11, 0xFE, 0x75, 0xF0, 0x04, 0xE5, 0x1A, 
+0x90, 0x96, 0x14, 0x12, 0x4A, 0x2A, 0xEF, 0x54, 0xF3, 0x4E, 0xF0, 0x80, 0x08, 0xE5, 0x1C, 0xB4, 
+0x2C, 0x0E, 0x75, 0x1B, 0x2D, 0x74, 0xA1, 0x25, 0x1A, 0x51, 0x4C, 0x74, 0xFF, 0xF0, 0xC1, 0xAB, 
+0xE5, 0x1C, 0xC3, 0x95, 0x1E, 0x40, 0x02, 0xC1, 0x67, 0xAD, 0x1C, 0xAF, 0x1F, 0x12, 0xA9, 0x88, 
+0x8F, 0x1C, 0xAD, 0x1E, 0xAF, 0x1F, 0x12, 0xA9, 0x88, 0x8F, 0x1E, 0xE5, 0x1C, 0xD3, 0x94, 0x0B, 
+0x40, 0x13, 0x90, 0xA3, 0x92, 0xE5, 0x1F, 0xF0, 0xAB, 0x1A, 0xE4, 0xFD, 0xAF, 0x1C, 0x12, 0x6B, 
+0xFB, 0x8F, 0x1B, 0x80, 0x0C, 0x75, 0x1B, 0xFF, 0x74, 0xA1, 0x25, 0x1A, 0x51, 0x4C, 0x74, 0xFF, 
+0xF0, 0xE5, 0x1B, 0xF4, 0x70, 0x58, 0x74, 0xA1, 0x25, 0x1A, 0x51, 0x4C, 0xE0, 0xF4, 0x70, 0x4E, 
+0xE5, 0x1C, 0x04, 0xFD, 0xED, 0xD3, 0x95, 0x1E, 0x50, 0x44, 0xED, 0x12, 0xB3, 0xE5, 0x75, 0xF0, 
+0x08, 0xE5, 0x1A, 0x12, 0x6A, 0x92, 0xE0, 0xFB, 0x7A, 0x00, 0xED, 0x12, 0x6F, 0x90, 0x80, 0x05, 
+0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 0xF9, 0x12, 0x8F, 0xE0, 0x60, 0x1F, 0xE5, 0x1C, 0xB4, 0x13, 
+0x13, 0x75, 0x1C, 0x18, 0x85, 0x1C, 0x1B, 0x74, 0x91, 0x25, 0x1A, 0x12, 0x4F, 0x49, 0xE0, 0x44, 
+0x04, 0xF0, 0x80, 0x0A, 0x8D, 0x1C, 0x85, 0x1C, 0x1B, 0x80, 0x03, 0x0D, 0x80, 0xB6, 0xAD, 0x1B, 
+0xAF, 0x1F, 0x12, 0xA9, 0x9C, 0x8F, 0x1B, 0x74, 0xA1, 0x25, 0x1A, 0x51, 0x4C, 0xE0, 0xFD, 0xF4, 
+0x60, 0x0D, 0xAF, 0x1F, 0x12, 0xA9, 0x9C, 0x74, 0xA1, 0x25, 0x1A, 0x51, 0x4C, 0xEF, 0xF0, 0x74, 
+0x91, 0x25, 0x1A, 0x12, 0x4F, 0x49, 0xE0, 0x30, 0xE0, 0x61, 0xE5, 0x1C, 0x64, 0x3F, 0x70, 0x5B, 
+0x12, 0xB4, 0x45, 0x12, 0x6B, 0xE5, 0xC4, 0x13, 0x54, 0x07, 0x30, 0xE0, 0x05, 0x75, 0x1B, 0xBE, 
+0x80, 0x49, 0x85, 0x1C, 0x1B, 0x80, 0x44, 0xE5, 0x1C, 0x65, 0x1E, 0x70, 0x33, 0x75, 0xF0, 0x04, 
+0xE5, 0x1A, 0x12, 0x6B, 0xE5, 0xC4, 0x13, 0x54, 0x07, 0x30, 0xE0, 0x0D, 0xE5, 0x1B, 0x20, 0xE7, 
+0x08, 0xE5, 0x1C, 0x44, 0x80, 0xF5, 0x1B, 0x80, 0x22, 0xE5, 0x1C, 0x12, 0x77, 0x6A, 0xE4, 0x93, 
+0xFE, 0x74, 0x01, 0x93, 0xFF, 0xE5, 0x1A, 0x12, 0x76, 0xB1, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x22, 
+0x74, 0x75, 0x25, 0x1A, 0x91, 0x84, 0xE5, 0x1E, 0xF0, 0xF5, 0x1B, 0x85, 0x1D, 0x71, 0x7B, 0x01, 
+0xAD, 0x1B, 0xAF, 0x1A, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x8F, 0x6E, 0x8D, 0x6F, 0xE4, 
+0x90, 0xA4, 0x05, 0xF0, 0xE5, 0x6E, 0x13, 0x13, 0x13, 0x54, 0x1F, 0x90, 0xA4, 0x00, 0xF0, 0xE5, 
+0x6E, 0x54, 0x07, 0x90, 0xA4, 0x02, 0xF0, 0x75, 0xF0, 0x10, 0xEF, 0x12, 0x76, 0xA9, 0xE0, 0x90, 
+0xA4, 0x03, 0x12, 0x6F, 0xF4, 0xE0, 0x54, 0x7F, 0x90, 0xA4, 0x06, 0xF0, 0x75, 0xF0, 0x04, 0xE5, 
+0x6E, 0x12, 0x6B, 0xDB, 0xE0, 0x90, 0xA4, 0x07, 0xF0, 0x12, 0xB4, 0x4E, 0xEB, 0x70, 0x24, 0xE0, 
+0xFF, 0x12, 0xB3, 0x44, 0x12, 0xB4, 0x71, 0xEF, 0x12, 0x77, 0x6A, 0x74, 0x01, 0x93, 0x2D, 0xFF, 
+0xE4, 0x93, 0x3C, 0xC3, 0x13, 0xFE, 0xEF, 0x13, 0xFF, 0xE5, 0x6E, 0x12, 0x76, 0xB1, 0xEE, 0xF0, 
+0xA3, 0xEF, 0xF0, 0x90, 0xA4, 0x06, 0xE0, 0xFF, 0x90, 0xA4, 0x01, 0xE0, 0xFE, 0xD3, 0x9F, 0x40, 
+0x0B, 0xE5, 0x6F, 0x54, 0x80, 0xFD, 0xEF, 0x4D, 0xF5, 0x6F, 0x80, 0x0C, 0x90, 0xA4, 0x07, 0xE0, 
+0xFF, 0xEE, 0xC3, 0x9F, 0x50, 0x02, 0x8F, 0x6F, 0x12, 0xB4, 0x4E, 0xE5, 0x6F, 0x54, 0x80, 0x90, 
+0xA4, 0x04, 0xF0, 0xEB, 0x70, 0x26, 0x90, 0x04, 0xCF, 0x74, 0x30, 0xF0, 0x12, 0xB3, 0x50, 0xC0, 
+0x83, 0xC0, 0x82, 0x12, 0x86, 0x2A, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0xF4, 0x5F, 0xD0, 0x82, 
+0xD0, 0x83, 0xF0, 0x90, 0xA4, 0x03, 0xE0, 0x54, 0x7F, 0xF0, 0x80, 0x4E, 0x74, 0x91, 0x25, 0x6E, 
+0x12, 0x4F, 0x49, 0xE0, 0x90, 0x04, 0xCF, 0x30, 0xE0, 0x05, 0x74, 0x20, 0xF0, 0x80, 0x03, 0x74, 
+0x08, 0xF0, 0x12, 0xB3, 0x50, 0xC0, 0x83, 0xC0, 0x82, 0x12, 0x86, 0x2A, 0x80, 0x02, 0xC3, 0x33, 
+0xD8, 0xFC, 0x4F, 0xD0, 0x82, 0xD0, 0x83, 0xF0, 0x75, 0xF0, 0x10, 0xE5, 0x6E, 0x12, 0x76, 0xA9, 
+0xE0, 0x54, 0x07, 0xFF, 0x90, 0xA4, 0x03, 0xF0, 0x90, 0xA4, 0x01, 0xE0, 0x90, 0x43, 0xF1, 0x93, 
+0x12, 0x77, 0xE6, 0x90, 0xA4, 0x03, 0xF0, 0x44, 0x80, 0xF0, 0x75, 0xF0, 0x10, 0xE5, 0x6E, 0x12, 
+0x76, 0xD3, 0xE5, 0x6F, 0xF0, 0xE5, 0x6E, 0x70, 0x06, 0x90, 0x01, 0xC8, 0xE5, 0x6F, 0xF0, 0x90, 
+0xA4, 0x03, 0xE0, 0xFF, 0x75, 0xF0, 0x10, 0xE5, 0x6E, 0x12, 0x76, 0xA9, 0xEF, 0xF0, 0x75, 0xF0, 
+0x10, 0xE5, 0x6E, 0x12, 0x76, 0xEB, 0xE0, 0x54, 0xFC, 0xFF, 0xE5, 0x71, 0x12, 0x77, 0xEE, 0xE5, 
+0x6E, 0x12, 0x76, 0xEB, 0xEF, 0xF0, 0x7D, 0x01, 0xAF, 0x6E, 0x11, 0x11, 0xD0, 0xD0, 0x92, 0xAF, 
+0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0xED, 0x60, 0x21, 0x75, 0xF0, 0x0A, 0xEF, 0x90, 
+0x8D, 0x01, 0x11, 0x4D, 0x90, 0x8D, 0x03, 0x11, 0x4D, 0x90, 0x8D, 0x05, 0x11, 0x4D, 0x90, 0x8D, 
+0x07, 0x11, 0x4D, 0x90, 0x8D, 0x09, 0xF1, 0x84, 0xF1, 0x9B, 0xE4, 0xF0, 0x11, 0x59, 0xE0, 0x54, 
+0xBF, 0x44, 0x80, 0xFE, 0x11, 0x59, 0xEE, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x12, 0x4A, 0x2A, 
+0xE4, 0xF0, 0xA3, 0xF0, 0x75, 0xF0, 0x0A, 0xEF, 0x22, 0x75, 0xF0, 0x10, 0xEF, 0x90, 0x81, 0x03, 
+0x02, 0x4A, 0x2A, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0xA4, 0x52, 0xEF, 0xF0, 0x75, 
+0xF0, 0x04, 0x71, 0xE5, 0x54, 0x1F, 0xFB, 0x60, 0x12, 0x64, 0x02, 0x60, 0x0E, 0xEB, 0x64, 0x04, 
+0x60, 0x09, 0xEB, 0x64, 0x09, 0x60, 0x04, 0xEB, 0xB4, 0x0C, 0x07, 0x71, 0xED, 0x74, 0x02, 0xF0, 
+0x80, 0x05, 0x71, 0xED, 0x74, 0x01, 0xF0, 0xE4, 0xF5, 0x25, 0x90, 0xA4, 0x52, 0xE0, 0xFD, 0x51, 
+0xB5, 0x25, 0x25, 0x51, 0x9B, 0xE0, 0xFE, 0xEB, 0x75, 0xF0, 0x07, 0xA4, 0x24, 0x5C, 0xF5, 0x82, 
+0xE4, 0x34, 0x40, 0xF5, 0x83, 0xE5, 0x82, 0x25, 0x25, 0x51, 0x9B, 0xE4, 0x93, 0xFC, 0xEE, 0x5C, 
+0x90, 0xA4, 0x55, 0xF0, 0x75, 0xF0, 0x04, 0xED, 0x12, 0x4F, 0x3D, 0x54, 0x03, 0xFF, 0xBF, 0x02, 
+0x0B, 0xE5, 0x25, 0x70, 0x07, 0x90, 0xA4, 0x55, 0xE0, 0x54, 0xF0, 0xF0, 0x90, 0xA4, 0x55, 0xE0, 
+0xFF, 0x51, 0xB1, 0x25, 0x25, 0x51, 0x9B, 0xEF, 0xF0, 0x05, 0x25, 0xE5, 0x25, 0x64, 0x07, 0x70, 
+0xA9, 0x90, 0xA4, 0x52, 0xE0, 0x75, 0xF0, 0x04, 0x12, 0x4F, 0x3D, 0xFF, 0xC4, 0x54, 0x03, 0xFD, 
+0xE4, 0x90, 0xA4, 0x53, 0xF0, 0x75, 0x26, 0x06, 0xE5, 0x26, 0xB4, 0x06, 0x07, 0x51, 0x8A, 0xE0, 
+0x54, 0x0F, 0x80, 0x07, 0x51, 0xB1, 0x25, 0x26, 0x51, 0x9B, 0xE0, 0x90, 0xA4, 0x54, 0xF0, 0x90, 
+0xA4, 0x54, 0xE0, 0x60, 0x32, 0x75, 0x25, 0x07, 0xF1, 0xC6, 0x80, 0x05, 0xC3, 0x33, 0xCE, 0x33, 
+0xCE, 0xD8, 0xF9, 0x12, 0xB4, 0x33, 0x60, 0x16, 0x12, 0xB4, 0x2A, 0x90, 0xA4, 0x53, 0xF0, 0xED, 
+0x60, 0x22, 0xE0, 0xD3, 0x94, 0x0B, 0x40, 0x1C, 0xE0, 0x24, 0x20, 0xF0, 0x80, 0x16, 0x15, 0x25, 
+0xE5, 0x25, 0xC3, 0x94, 0x00, 0x50, 0xD1, 0xE5, 0x26, 0x60, 0x09, 0x15, 0x26, 0xE5, 0x26, 0xC3, 
+0x94, 0x00, 0x50, 0xA4, 0xE4, 0xFC, 0xF5, 0x26, 0xE5, 0x26, 0xB4, 0x06, 0x07, 0x51, 0x8A, 0xE0, 
+0x54, 0x0F, 0x80, 0x07, 0x51, 0xB1, 0x25, 0x26, 0x51, 0x9B, 0xE0, 0x90, 0xA4, 0x54, 0xF0, 0x90, 
+0xA4, 0x54, 0xE0, 0x60, 0x2D, 0xE4, 0xF5, 0x25, 0xF1, 0xC6, 0x80, 0x05, 0xC3, 0x33, 0xCE, 0x33, 
+0xCE, 0xD8, 0xF9, 0x12, 0xB4, 0x33, 0x60, 0x13, 0x12, 0xB4, 0x2A, 0xFC, 0xED, 0x60, 0x1B, 0xEC, 
+0xD3, 0x94, 0x0B, 0x40, 0x15, 0x74, 0x20, 0x2C, 0xFC, 0x80, 0x0F, 0x05, 0x25, 0xE5, 0x25, 0xB4, 
+0x08, 0xD6, 0x05, 0x26, 0xE5, 0x26, 0x64, 0x07, 0x70, 0xAE, 0x90, 0xA4, 0x53, 0xE0, 0xFF, 0x90, 
+0xA4, 0x52, 0xE0, 0xFE, 0x75, 0xF0, 0x04, 0xF1, 0xF9, 0xEF, 0xF0, 0x75, 0xF0, 0x04, 0xEE, 0x71, 
+0xDB, 0xEC, 0xF0, 0x75, 0xF0, 0x10, 0xEE, 0x12, 0x76, 0xD3, 0xE0, 0xFE, 0x54, 0x7F, 0xF5, 0x27, 
+0xEE, 0x54, 0x80, 0xFE, 0xE5, 0x27, 0xD3, 0x9F, 0x40, 0x09, 0x90, 0xA4, 0x53, 0xE0, 0x4E, 0xF5, 
+0x27, 0x80, 0x0C, 0xE5, 0x27, 0xC3, 0x9C, 0x50, 0x06, 0xAF, 0x06, 0xEC, 0x4F, 0xF5, 0x27, 0x90, 
+0xA4, 0x52, 0xE0, 0xFF, 0x24, 0x21, 0x12, 0x77, 0x3B, 0xE5, 0x27, 0xF0, 0x75, 0xF0, 0x04, 0xEF, 
+0x12, 0x4F, 0x3D, 0x12, 0x8B, 0xBD, 0x90, 0xA4, 0x52, 0xE0, 0xFF, 0xE4, 0xFB, 0xAD, 0x27, 0x12, 
+0x66, 0xB4, 0x90, 0xA4, 0x52, 0xE0, 0xFF, 0x75, 0xF0, 0x10, 0x11, 0x5D, 0xE4, 0xF0, 0x90, 0xA4, 
+0x53, 0xE0, 0xFE, 0xC3, 0x94, 0x36, 0x40, 0x0A, 0x74, 0x91, 0x2F, 0x51, 0xA9, 0x74, 0x05, 0xF0, 
+0x80, 0x43, 0xEE, 0xC3, 0x94, 0x2C, 0x40, 0x07, 0x51, 0xA3, 0x74, 0x04, 0xF0, 0x80, 0x36, 0x90, 
+0xA4, 0x53, 0xE0, 0xFF, 0xC3, 0x94, 0x14, 0x40, 0x07, 0x51, 0xA3, 0x74, 0x03, 0xF0, 0x80, 0x25, 
+0xEF, 0xC3, 0x94, 0x0C, 0x40, 0x07, 0x51, 0xA3, 0x74, 0x02, 0xF0, 0x80, 0x18, 0x90, 0xA4, 0x53, 
+0xE0, 0xC3, 0x94, 0x04, 0x90, 0xA4, 0x52, 0xE0, 0x40, 0x07, 0x51, 0xA7, 0x74, 0x01, 0xF0, 0x80, 
+0x04, 0x51, 0xA7, 0xE4, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xFF, 0x90, 0xA4, 0x52, 0xE0, 0x75, 
+0xF0, 0x08, 0x90, 0x89, 0x00, 0x12, 0x4A, 0x2A, 0xE5, 0x82, 0x2F, 0xF5, 0x82, 0xE4, 0x35, 0x83, 
+0xF5, 0x83, 0x22, 0x90, 0xA4, 0x52, 0xE0, 0x24, 0x91, 0xF5, 0x82, 0xE4, 0x34, 0x95, 0xF5, 0x83, 
+0x22, 0x90, 0xA4, 0x52, 0xE0, 0x75, 0xF0, 0x08, 0x90, 0x89, 0x00, 0x12, 0x4A, 0x2A, 0xE5, 0x82, 
+0x22, 0xE4, 0xFF, 0xE4, 0xFE, 0x74, 0x91, 0x2F, 0x12, 0x4F, 0x49, 0xE0, 0x54, 0xFE, 0xF0, 0x75, 
+0xF0, 0x10, 0xEF, 0x90, 0x81, 0x00, 0xBE, 0x03, 0x0D, 0x12, 0x4A, 0x2A, 0xE5, 0x82, 0x2E, 0x51, 
+0x9B, 0x74, 0x80, 0xF0, 0x80, 0x0A, 0x12, 0x4A, 0x2A, 0xE5, 0x82, 0x2E, 0x51, 0x9B, 0xE4, 0xF0, 
+0x75, 0xF0, 0x08, 0xEF, 0x51, 0xB8, 0x2E, 0x51, 0x9B, 0xE4, 0xF0, 0x0E, 0xBE, 0x10, 0xC6, 0x0F, 
+0xBF, 0x80, 0xC0, 0xE4, 0x90, 0xAF, 0x7D, 0xF0, 0xFF, 0xE4, 0xFE, 0x75, 0xF0, 0x0A, 0xEF, 0xF1, 
+0x7E, 0x75, 0xF0, 0x02, 0xEE, 0xF1, 0x84, 0xF0, 0x0E, 0xBE, 0x05, 0xEF, 0x75, 0xF0, 0x04, 0xEF, 
+0x12, 0x76, 0x92, 0xE0, 0x54, 0x07, 0xF0, 0x74, 0x21, 0x2F, 0x12, 0x77, 0x3B, 0x74, 0x3F, 0xF0, 
+0x74, 0x21, 0x2F, 0x12, 0x76, 0xF5, 0xE4, 0xF0, 0x74, 0x01, 0x2F, 0x12, 0x76, 0x7F, 0x74, 0xC0, 
+0xF0, 0x74, 0xF5, 0x2F, 0x71, 0xF3, 0xE4, 0xF1, 0x9B, 0xE4, 0xF1, 0xF4, 0x74, 0x3F, 0x71, 0xD6, 
+0xE4, 0xF0, 0x71, 0xE1, 0x54, 0xE0, 0x44, 0x09, 0xF0, 0x75, 0xF0, 0x04, 0xEF, 0x12, 0x4F, 0x3D, 
+0x54, 0xF3, 0xF0, 0x75, 0xF0, 0x04, 0xEF, 0x12, 0x4F, 0x3D, 0x54, 0xFC, 0xF0, 0x71, 0xE1, 0x44, 
+0x20, 0xF0, 0x75, 0xF0, 0x04, 0xEF, 0x12, 0x4F, 0x3D, 0x54, 0xCF, 0xF0, 0x75, 0xF0, 0x04, 0xEF, 
+0x12, 0x4F, 0x3D, 0x44, 0x40, 0xF0, 0x75, 0xF0, 0x04, 0xEF, 0x12, 0x4F, 0x3D, 0x54, 0x7F, 0x71, 
+0xD6, 0xE0, 0xFE, 0x75, 0xF0, 0x10, 0xEF, 0x12, 0x76, 0xD3, 0xEE, 0xF0, 0x74, 0x91, 0x2F, 0x12, 
+0x4F, 0x49, 0xE4, 0xF0, 0x0F, 0xEF, 0x64, 0x80, 0x60, 0x02, 0x61, 0x09, 0x90, 0x04, 0x49, 0x74, 
+0xF0, 0xF0, 0xA3, 0xE4, 0xF0, 0xA3, 0x74, 0xFF, 0xF0, 0x90, 0x04, 0x33, 0x74, 0x02, 0xF0, 0xA3, 
+0x74, 0x04, 0xF0, 0xA3, 0x04, 0xF0, 0xA3, 0x04, 0xF0, 0xA3, 0x04, 0xF0, 0x74, 0x11, 0x2F, 0x12, 
+0xA9, 0x80, 0x74, 0xFF, 0xF0, 0x22, 0xF0, 0x75, 0xF0, 0x04, 0xEF, 0x90, 0x96, 0x12, 0x02, 0x4A, 
+0x2A, 0x75, 0xF0, 0x04, 0xEF, 0x90, 0x96, 0x13, 0x12, 0x4A, 0x2A, 0xE0, 0x22, 0x90, 0xA4, 0x52, 
+0xE0, 0x24, 0xF5, 0xF5, 0x82, 0xE4, 0x34, 0xA0, 0xF5, 0x83, 0x22, 0x90, 0xA3, 0x91, 0xEB, 0xF0, 
+0xEF, 0x54, 0x7F, 0x24, 0xF4, 0x90, 0xA3, 0x95, 0xF0, 0xED, 0x70, 0x2E, 0xF1, 0xD6, 0x70, 0x15, 
+0xE0, 0x25, 0xE0, 0x24, 0xDF, 0xF5, 0x82, 0xE4, 0x34, 0x40, 0xB1, 0x1D, 0x24, 0xE0, 0xF5, 0x82, 
+0xE4, 0x34, 0x40, 0x80, 0x41, 0xE0, 0x25, 0xE0, 0x24, 0xB7, 0xF5, 0x82, 0xE4, 0x34, 0x40, 0xB1, 
+0x1D, 0x24, 0xB8, 0xF5, 0x82, 0xE4, 0x34, 0x40, 0x80, 0x2C, 0xF1, 0xD6, 0x70, 0x15, 0xE0, 0x25, 
+0xE0, 0x24, 0x2B, 0xF5, 0x82, 0xE4, 0x34, 0x41, 0xB1, 0x1D, 0x24, 0x2C, 0xF5, 0x82, 0xE4, 0x34, 
+0x41, 0x80, 0x13, 0xE0, 0x25, 0xE0, 0x24, 0x03, 0xF5, 0x82, 0xE4, 0x34, 0x41, 0xB1, 0x1D, 0x24, 
+0x04, 0xF5, 0x82, 0xE4, 0x34, 0x41, 0xF5, 0x83, 0xE4, 0x93, 0xFF, 0x90, 0xA3, 0x91, 0xE0, 0xFD, 
+0x91, 0xFD, 0xA9, 0x07, 0x7F, 0x0C, 0x7E, 0x12, 0x7D, 0x10, 0x90, 0xA3, 0x93, 0xE0, 0xFC, 0xF4, 
+0x60, 0x2D, 0xE9, 0xF4, 0x60, 0x29, 0xE9, 0xC3, 0x9F, 0x40, 0x24, 0xE9, 0xD3, 0x9D, 0x50, 0x1F, 
+0xF1, 0xCE, 0x12, 0x4F, 0x49, 0xE0, 0x30, 0xE1, 0x16, 0x74, 0xF5, 0x2D, 0x71, 0xF3, 0xE0, 0xC3, 
+0x94, 0x02, 0x40, 0x0B, 0x90, 0xA3, 0x94, 0xE9, 0xF0, 0xA9, 0x04, 0x90, 0xA3, 0x93, 0xF0, 0xF1, 
+0xCE, 0x12, 0x4F, 0x49, 0xE0, 0x30, 0xE6, 0x29, 0x74, 0xF5, 0x2D, 0x71, 0xF3, 0xE0, 0xC3, 0x94, 
+0x02, 0x40, 0x1E, 0x90, 0xA3, 0x93, 0xE0, 0xFD, 0xF4, 0x60, 0x16, 0xE9, 0xF4, 0x60, 0x12, 0xE9, 
+0x9F, 0x40, 0x0E, 0xE9, 0xD3, 0x9E, 0x50, 0x09, 0xA3, 0xE9, 0xF0, 0xA9, 0x05, 0x90, 0xA3, 0x93, 
+0xF0, 0x90, 0xA3, 0x93, 0xE0, 0xB4, 0xFF, 0x0A, 0xE9, 0xF0, 0x12, 0x62, 0x46, 0x74, 0xFF, 0xF0, 
+0x80, 0x05, 0x12, 0x62, 0x46, 0xE9, 0xF0, 0x90, 0xA3, 0x93, 0xE0, 0xFF, 0x22, 0xAC, 0x07, 0x12, 
+0xB3, 0xE4, 0x75, 0xF0, 0x08, 0xED, 0x51, 0x92, 0xF1, 0x8B, 0x80, 0x05, 0xC3, 0x33, 0xCE, 0x33, 
+0xCE, 0xD8, 0xF9, 0x12, 0x8F, 0xE0, 0x7F, 0xFF, 0x60, 0x02, 0xAF, 0x04, 0x22, 0xF5, 0x83, 0xE4, 
+0x93, 0xFF, 0x90, 0xA3, 0x91, 0xE0, 0xFD, 0x91, 0xFD, 0x90, 0xA3, 0x93, 0xEF, 0xF0, 0x90, 0xA3, 
+0x95, 0xE0, 0x25, 0xE0, 0x22, 0x90, 0x01, 0xCC, 0xE0, 0x54, 0x0F, 0x90, 0xA4, 0x7C, 0xF0, 0x90, 
+0xA4, 0x7C, 0xE0, 0xFD, 0x70, 0x02, 0xC1, 0x40, 0x90, 0xA1, 0xD4, 0xE0, 0xFF, 0x70, 0x06, 0xA3, 
+0xE0, 0x64, 0x09, 0x60, 0x0A, 0xEF, 0x14, 0xFF, 0x90, 0xA1, 0xD5, 0xE0, 0xB5, 0x07, 0x04, 0x7F, 
+0x01, 0x80, 0x02, 0x7F, 0x00, 0xEF, 0x60, 0x08, 0x90, 0x01, 0xC1, 0xE0, 0x44, 0x01, 0xF0, 0x22, 
+0x90, 0xA4, 0x6B, 0xE0, 0xF1, 0x92, 0x80, 0x05, 0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 0xF9, 0xFF, 
+0xEF, 0x5D, 0x70, 0x02, 0xC1, 0x23, 0xE4, 0x90, 0xA4, 0x7D, 0xF0, 0x90, 0xA4, 0x7D, 0xE0, 0xF9, 
+0xC3, 0x94, 0x04, 0x50, 0x42, 0xD1, 0x42, 0xA4, 0xFF, 0xE9, 0xFD, 0x7C, 0x00, 0x2F, 0xFF, 0xEC, 
+0x35, 0xF0, 0xFE, 0x74, 0xD0, 0x12, 0xB3, 0x5E, 0x90, 0xA1, 0x84, 0x12, 0x4A, 0x2A, 0xE5, 0x82, 
+0x29, 0x51, 0x9B, 0xEF, 0xD1, 0x41, 0xA4, 0x2D, 0xFF, 0xEC, 0x35, 0xF0, 0xFE, 0x74, 0xF0, 0x12, 
+0xB3, 0x5E, 0x90, 0xA1, 0x88, 0x12, 0x4A, 0x2A, 0xE5, 0x82, 0x29, 0x51, 0x9B, 0xEF, 0xF0, 0x90, 
+0xA4, 0x7D, 0xE0, 0x04, 0xF0, 0x80, 0xB4, 0x90, 0xA4, 0x7C, 0xE0, 0xFF, 0x90, 0xA4, 0x6B, 0x12, 
+0x86, 0x2F, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0xF4, 0x5F, 0x90, 0xA4, 0x7C, 0xF0, 0x90, 0xA4, 
+0x6B, 0xE0, 0xFF, 0x74, 0x01, 0xA8, 0x07, 0x08, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0x90, 0x01, 
+0xCC, 0xF0, 0x90, 0xA4, 0x6B, 0xE0, 0x04, 0xF0, 0xE0, 0x54, 0x03, 0xF0, 0x90, 0xA1, 0xD5, 0x12, 
+0x8F, 0xC4, 0xB4, 0x0A, 0x02, 0x7F, 0x01, 0xEF, 0x70, 0x02, 0xA1, 0x3F, 0xE4, 0x90, 0xA1, 0xD5, 
+0xF0, 0xA1, 0x3F, 0x90, 0x01, 0xC0, 0xE0, 0x44, 0x02, 0xF0, 0x90, 0xA4, 0x6B, 0xE0, 0x44, 0x80, 
+0x90, 0x00, 0x8A, 0xD1, 0x41, 0x90, 0x01, 0xD0, 0x12, 0x4A, 0x2A, 0xE0, 0x90, 0x01, 0xC3, 0xF0, 
+0x22, 0xF0, 0x90, 0xA4, 0x6B, 0xE0, 0x75, 0xF0, 0x04, 0x22, 0x90, 0xA3, 0xB2, 0xEF, 0xF0, 0x7E, 
+0x00, 0x7F, 0x10, 0x7D, 0x00, 0x7B, 0x01, 0x7A, 0xA3, 0x79, 0xB4, 0x12, 0x4A, 0x6E, 0x90, 0xA2, 
+0x81, 0xE0, 0x90, 0xA3, 0xC6, 0xF0, 0xE4, 0x90, 0xA3, 0xB3, 0xF0, 0x90, 0xA3, 0xC6, 0xE0, 0xFE, 
+0x90, 0xA3, 0xB3, 0xE0, 0xFD, 0xC3, 0x9E, 0x50, 0x43, 0xED, 0x12, 0xB4, 0x07, 0xED, 0x54, 0x07, 
+0xA3, 0xF0, 0x75, 0xF0, 0x10, 0xED, 0x11, 0x5D, 0xE0, 0x30, 0xE7, 0x09, 0x74, 0x81, 0x2D, 0xF1, 
+0xBE, 0xE4, 0xF0, 0x80, 0x1F, 0xAF, 0x05, 0xF1, 0xB7, 0x12, 0xB3, 0x87, 0xC0, 0x83, 0xC0, 0x82, 
+0xE0, 0xFF, 0x90, 0xA3, 0xC5, 0x12, 0x86, 0x2F, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0x4F, 0xD0, 
+0x82, 0xD0, 0x83, 0xF0, 0x90, 0xA3, 0xB3, 0xE0, 0x04, 0xF0, 0x80, 0xAF, 0x7F, 0x0C, 0x7E, 0x00, 
+0x12, 0x3A, 0xF7, 0xE4, 0x90, 0xA3, 0xB3, 0xF0, 0x90, 0xA3, 0xC6, 0xE0, 0xFF, 0x90, 0xA3, 0xB3, 
+0xE0, 0xFE, 0xC3, 0x9F, 0x40, 0x02, 0xE1, 0x7D, 0xEE, 0x12, 0xB4, 0x07, 0xEE, 0x54, 0x07, 0xA3, 
+0xF0, 0xE0, 0xF1, 0x92, 0x80, 0x05, 0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 0xF9, 0x4E, 0x7F, 0x00, 
+0x70, 0x02, 0x7F, 0x01, 0x12, 0xB3, 0x87, 0xE0, 0x5F, 0x70, 0x7A, 0xF1, 0xDE, 0x90, 0x81, 0x06, 
+0xF1, 0xE7, 0xEF, 0x90, 0x81, 0x07, 0x12, 0xB3, 0xAD, 0xFC, 0x12, 0x77, 0x78, 0xEE, 0xF0, 0xA3, 
+0xEF, 0xF0, 0x75, 0xF0, 0x10, 0xEC, 0x90, 0x81, 0x0A, 0xF1, 0xE7, 0xEC, 0x90, 0x81, 0x0B, 0x12, 
+0xB3, 0xAD, 0x75, 0xF0, 0x0A, 0xF1, 0x7E, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x7F, 0x01, 0x90, 0xA3, 
+0xB3, 0xE0, 0xFE, 0x75, 0xF0, 0x10, 0x90, 0x81, 0x0B, 0x51, 0x95, 0xE0, 0xFD, 0x75, 0xF0, 0x0A, 
+0xEE, 0xF1, 0x7E, 0x75, 0xF0, 0x02, 0xEF, 0xF1, 0x84, 0xED, 0xF0, 0x0F, 0xEF, 0xB4, 0x05, 0xDE, 
+0xF1, 0xDE, 0x90, 0x81, 0x09, 0x12, 0x4A, 0x2A, 0xE0, 0xFE, 0xF1, 0xAC, 0xEE, 0xF0, 0x90, 0xA3, 
+0xB3, 0xE0, 0xFF, 0x90, 0xA3, 0xB2, 0xE0, 0xFD, 0x11, 0x11, 0x90, 0xA3, 0xB3, 0xE0, 0x24, 0x81, 
+0xF1, 0xBE, 0x74, 0x01, 0xF0, 0x90, 0xA3, 0xB3, 0xE0, 0x04, 0xF0, 0xC1, 0xC8, 0x22, 0x90, 0x8D, 
+0x01, 0x02, 0x4A, 0x2A, 0x12, 0x4A, 0x2A, 0xE4, 0xF0, 0xA3, 0x22, 0xE0, 0xFB, 0x7A, 0x00, 0xEC, 
+0x54, 0x07, 0xFF, 0x74, 0x01, 0x7E, 0x00, 0xA8, 0x07, 0x08, 0x22, 0xF0, 0xEF, 0x25, 0xE0, 0x24, 
+0x01, 0xF5, 0x82, 0xE4, 0x34, 0x92, 0xF5, 0x83, 0xE4, 0xF0, 0xA3, 0xF0, 0x74, 0x91, 0x2F, 0xF5, 
+0x82, 0xE4, 0x34, 0x98, 0xF5, 0x83, 0x22, 0x11, 0x59, 0xE0, 0x44, 0x40, 0xF0, 0x22, 0xF5, 0x82, 
+0xE4, 0x34, 0x93, 0xF5, 0x83, 0x22, 0x74, 0x01, 0x7E, 0x00, 0xA8, 0x25, 0x08, 0x22, 0x90, 0xA3, 
+0x91, 0xE0, 0xFD, 0x24, 0x91, 0x22, 0x90, 0xA3, 0x92, 0xE0, 0x90, 0xA3, 0x95, 0x22, 0x90, 0xA3, 
+0xB3, 0xE0, 0xFF, 0x75, 0xF0, 0x10, 0x22, 0x12, 0x4A, 0x2A, 0xE0, 0xFD, 0x75, 0xF0, 0x10, 0x22, 
+0xE4, 0xFF, 0xC1, 0x4A, 0xF0, 0x75, 0xF0, 0x04, 0xEF, 0x90, 0x96, 0x11, 0x02, 0x4A, 0x2A, 0xE4, 
+0xF5, 0x0D, 0x90, 0xA2, 0x81, 0xE0, 0xFF, 0xE5, 0x0D, 0xC3, 0x9F, 0x40, 0x02, 0xC1, 0x6C, 0xAF, 
+0x0D, 0xF1, 0xC7, 0xEF, 0x70, 0x02, 0xC1, 0x68, 0x12, 0x4F, 0x38, 0x12, 0x4F, 0xF5, 0x30, 0xE0, 
+0x02, 0xC1, 0x68, 0x90, 0x04, 0xA0, 0xE0, 0xFF, 0xA3, 0xE0, 0xFE, 0xEF, 0x64, 0x01, 0x70, 0x2B, 
+0xE5, 0x0D, 0x6E, 0x70, 0x26, 0xA3, 0xE0, 0xF5, 0x0E, 0xA3, 0xE0, 0x90, 0xA3, 0x84, 0xD1, 0xCD, 
+0xE5, 0x0E, 0xF0, 0x75, 0xF0, 0x10, 0xE5, 0x0D, 0xD1, 0xEB, 0xE0, 0x54, 0xFC, 0xFF, 0x90, 0xA3, 
+0x84, 0xE0, 0xF1, 0xEE, 0xE5, 0x0D, 0xD1, 0xEB, 0xEF, 0xF0, 0x22, 0xF1, 0x76, 0xE0, 0xFE, 0xA3, 
+0xE0, 0xD3, 0x94, 0x00, 0xEE, 0x94, 0x00, 0x50, 0x02, 0xC1, 0x68, 0xE5, 0x0D, 0x75, 0xF0, 0x0A, 
+0xA4, 0x24, 0x01, 0xF9, 0x74, 0x8D, 0x35, 0xF0, 0xFA, 0x7B, 0x01, 0x90, 0xA3, 0x78, 0x12, 0x4A, 
+0x3F, 0xF1, 0x76, 0xE0, 0xF5, 0x12, 0xA3, 0xE0, 0xF5, 0x13, 0x74, 0x91, 0x25, 0x0D, 0x12, 0x6F, 
+0xAF, 0xE0, 0xFF, 0x90, 0xA3, 0x7B, 0xE4, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0x00, 0x02, 0x12, 0x49, 
+0xC0, 0xFF, 0xAE, 0xF0, 0x12, 0x49, 0x95, 0x2F, 0xFF, 0xE5, 0xF0, 0x3E, 0xFE, 0x90, 0x00, 0x04, 
+0xD1, 0xBD, 0x35, 0xF0, 0xFE, 0x90, 0x00, 0x06, 0xD1, 0xBD, 0x35, 0xF0, 0xFE, 0xD1, 0x87, 0x2F, 
+0xFF, 0xEE, 0x35, 0xF0, 0x90, 0xA3, 0x7D, 0xF0, 0xA3, 0xEF, 0xF0, 0x12, 0x49, 0x95, 0xFF, 0xC3, 
+0x90, 0xA3, 0x7E, 0xE0, 0x9F, 0xFE, 0x90, 0xA3, 0x7D, 0xE0, 0x95, 0xF0, 0x90, 0xA3, 0x7F, 0xF0, 
+0xA3, 0xCE, 0xF0, 0x90, 0x00, 0x06, 0x12, 0x49, 0xC0, 0xFD, 0xAC, 0xF0, 0x25, 0xE0, 0xFF, 0xEC, 
+0x33, 0xFE, 0xEF, 0x2D, 0xFD, 0xEE, 0x3C, 0xFC, 0x90, 0x00, 0x04, 0x12, 0x49, 0xC0, 0x25, 0xE0, 
+0xFF, 0xE5, 0xF0, 0x33, 0xFE, 0x90, 0x00, 0x02, 0xD1, 0xBD, 0x35, 0xF0, 0xCF, 0x2D, 0xFD, 0xEF, 
+0x3C, 0xFC, 0x90, 0xA3, 0x78, 0x12, 0x4A, 0x36, 0xD1, 0x87, 0xAE, 0xF0, 0x78, 0x02, 0xC3, 0x33, 
+0xCE, 0x33, 0xCE, 0xD8, 0xF9, 0x2D, 0xFF, 0xEC, 0x3E, 0x90, 0xA3, 0x81, 0xF0, 0xA3, 0xEF, 0xD1, 
+0xCD, 0xE0, 0xF5, 0x0E, 0x54, 0x7F, 0xF5, 0x0F, 0x75, 0xF0, 0x04, 0xE5, 0x0D, 0x12, 0x6F, 0xF9, 
+0xE0, 0x90, 0xA3, 0x83, 0xF0, 0x12, 0x4F, 0x38, 0xFF, 0x13, 0x13, 0x54, 0x03, 0x90, 0xA3, 0x84, 
+0xF0, 0xD1, 0x6F, 0xE0, 0xC3, 0x94, 0x05, 0x40, 0x02, 0x81, 0x9A, 0x90, 0xA3, 0x83, 0xE0, 0xFF, 
+0xE5, 0x0F, 0x9F, 0x40, 0x08, 0x8F, 0x0F, 0x53, 0x0E, 0x80, 0xEF, 0x42, 0x0E, 0xE5, 0x0F, 0x90, 
+0x42, 0x41, 0x93, 0x12, 0x61, 0x83, 0xC3, 0x9F, 0x40, 0x0A, 0xE5, 0x0F, 0x90, 0x41, 0xED, 0x93, 
+0xF5, 0x14, 0x80, 0x0A, 0x74, 0x21, 0x25, 0x0F, 0x12, 0xAA, 0xCC, 0xE0, 0xF5, 0x14, 0x90, 0xA3, 
+0x12, 0xE0, 0x60, 0x7D, 0xE5, 0x0F, 0x64, 0x13, 0x60, 0x05, 0xE5, 0x0F, 0xB4, 0x0B, 0x05, 0x90, 
+0xA3, 0x14, 0x80, 0x23, 0xE5, 0x0F, 0x64, 0x12, 0x60, 0x05, 0xE5, 0x0F, 0xB4, 0x0A, 0x05, 0x90, 
+0xA3, 0x15, 0x80, 0x13, 0xE5, 0x0F, 0x64, 0x11, 0x60, 0x05, 0xE5, 0x0F, 0xB4, 0x09, 0x05, 0x90, 
+0xA3, 0x16, 0x80, 0x03, 0x90, 0xA3, 0x13, 0xE0, 0xF5, 0x18, 0xE5, 0x18, 0xC3, 0x94, 0x80, 0x50, 
+0x28, 0xE5, 0x18, 0x94, 0x1B, 0x40, 0x02, 0x80, 0x13, 0xE5, 0x14, 0x25, 0x18, 0xFF, 0xE4, 0x33, 
+0xFE, 0xD3, 0xEF, 0x94, 0x1B, 0xEE, 0x64, 0x80, 0x94, 0x80, 0x40, 0x05, 0x75, 0x14, 0x1B, 0x80, 
+0x20, 0xE5, 0x18, 0x25, 0x14, 0xF5, 0x14, 0x80, 0x18, 0xC3, 0xE4, 0x95, 0x18, 0xF5, 0x18, 0xE5, 
+0x14, 0xD3, 0x95, 0x18, 0x40, 0x08, 0xE5, 0x14, 0x95, 0x18, 0xF5, 0x14, 0x80, 0x03, 0xE4, 0xF5, 
+0x14, 0xE5, 0x14, 0x75, 0xF0, 0x06, 0xA4, 0x24, 0x4B, 0xF9, 0x74, 0x41, 0x35, 0xF0, 0xFA, 0x7B, 
+0xFF, 0x90, 0xA3, 0x75, 0x12, 0x4A, 0x3F, 0xC3, 0xE5, 0x13, 0x94, 0x0F, 0xE5, 0x12, 0x94, 0x00, 
+0x40, 0x02, 0x41, 0xBB, 0x90, 0xA3, 0x78, 0x12, 0x4A, 0x36, 0x90, 0x00, 0x06, 0x12, 0x49, 0xC0, 
+0xFF, 0xAE, 0xF0, 0xD1, 0x87, 0x2F, 0xFD, 0xE5, 0xF0, 0x3E, 0xFC, 0xF1, 0x2D, 0xD3, 0xED, 0x9F, 
+0xEC, 0x9E, 0x40, 0x02, 0x81, 0x76, 0xE5, 0x13, 0xAE, 0x12, 0x78, 0x02, 0xCE, 0xC3, 0x13, 0xCE, 
+0x13, 0xD8, 0xF9, 0xFD, 0xAC, 0x06, 0xE5, 0x12, 0xC3, 0x13, 0xFE, 0xE5, 0x13, 0x13, 0x2D, 0xFF, 
+0xEE, 0x3C, 0xFE, 0x90, 0xA3, 0x78, 0x12, 0x4A, 0x36, 0x12, 0x49, 0x95, 0xD3, 0x9F, 0xE5, 0xF0, 
+0x9E, 0x50, 0x02, 0x81, 0x7D, 0xE5, 0x0F, 0x94, 0x38, 0x40, 0x0A, 0x12, 0x61, 0x84, 0xC3, 0x94, 
+0x0F, 0x50, 0x02, 0x81, 0x7D, 0xE5, 0x0F, 0xC3, 0x94, 0x3A, 0x40, 0x0A, 0x12, 0x61, 0x84, 0xC3, 
+0x94, 0x14, 0x50, 0x02, 0x81, 0x7D, 0xE5, 0x0F, 0xC3, 0x94, 0x3C, 0x50, 0x02, 0x81, 0x65, 0x12, 
+0x61, 0x84, 0xC3, 0x94, 0x19, 0x50, 0x02, 0x81, 0x7D, 0x81, 0x65, 0xE5, 0x0D, 0x70, 0x45, 0x90, 
+0xA3, 0x78, 0x12, 0x4A, 0x36, 0xD1, 0x87, 0xFD, 0xAC, 0xF0, 0xF1, 0x2D, 0xC3, 0xED, 0x9F, 0xEC, 
+0x9E, 0x50, 0x08, 0x90, 0xA1, 0x75, 0x74, 0x01, 0xF0, 0x80, 0x29, 0xE5, 0x13, 0xAE, 0x12, 0x78, 
+0x03, 0xCE, 0xC3, 0x13, 0xCE, 0x13, 0xD8, 0xF9, 0xFB, 0xAA, 0x06, 0xE5, 0x12, 0xC3, 0x13, 0xFE, 
+0xE5, 0x13, 0x13, 0x2B, 0xFF, 0xEE, 0x3A, 0xFE, 0xD3, 0xED, 0x9F, 0xEC, 0x9E, 0x40, 0x05, 0xE4, 
+0x90, 0xA1, 0x75, 0xF0, 0xD1, 0x8D, 0x12, 0xA7, 0x03, 0xFE, 0x60, 0x11, 0xD1, 0x8D, 0xEF, 0x54, 
+0x07, 0xFF, 0xC3, 0xEE, 0x94, 0x01, 0x54, 0x1F, 0xF1, 0xE6, 0xF0, 0x81, 0x7D, 0xE5, 0x0D, 0x13, 
+0x13, 0x13, 0x54, 0x1F, 0x90, 0xA3, 0x89, 0xF0, 0xE5, 0x0D, 0x54, 0x07, 0xA3, 0xF0, 0x90, 0xA3, 
+0x89, 0xE0, 0x24, 0x11, 0xD1, 0xDD, 0xE0, 0xFD, 0x7C, 0x00, 0x90, 0xA3, 0x8A, 0xE0, 0x12, 0x6F, 
+0x92, 0x80, 0x05, 0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 0xF9, 0xF1, 0xBF, 0x60, 0x29, 0x74, 0xA1, 
+0x25, 0x0D, 0x12, 0x62, 0x4C, 0xE0, 0xFF, 0xF4, 0x60, 0x1D, 0x8F, 0x0E, 0x90, 0xA3, 0x84, 0xE0, 
+0xF5, 0x71, 0x7B, 0x01, 0xAD, 0x0E, 0xAF, 0x0D, 0x12, 0x66, 0xB4, 0x74, 0xA1, 0x25, 0x0D, 0x12, 
+0x62, 0x4C, 0x74, 0xFF, 0xF0, 0x81, 0x7D, 0xF1, 0x19, 0x40, 0x05, 0x75, 0x15, 0x05, 0x80, 0x13, 
+0xD3, 0xE5, 0x13, 0x94, 0xC8, 0xE5, 0x12, 0x94, 0x00, 0x40, 0x05, 0x75, 0x15, 0x02, 0x80, 0x03, 
+0xE4, 0xF5, 0x15, 0xD1, 0xAF, 0xE0, 0xF5, 0x10, 0xA3, 0xE0, 0xF5, 0x11, 0xE4, 0xF5, 0x19, 0xF1, 
+0x0F, 0xE5, 0x19, 0xF1, 0x84, 0x08, 0x80, 0x05, 0xCE, 0xC3, 0x13, 0xCE, 0x13, 0xD8, 0xF9, 0xFF, 
+0x90, 0xA3, 0x75, 0x12, 0x4A, 0x36, 0x85, 0x19, 0x82, 0x75, 0x83, 0x00, 0x12, 0x26, 0x37, 0xF1, 
+0x9F, 0x05, 0x19, 0xE5, 0x19, 0xB4, 0x05, 0xD7, 0x90, 0xA3, 0x75, 0x12, 0x4A, 0x36, 0xD1, 0xC7, 
+0xFD, 0x7C, 0x00, 0xD1, 0xFD, 0x80, 0x05, 0xCE, 0xC3, 0x13, 0xCE, 0x13, 0xD8, 0xF9, 0xFF, 0x12, 
+0x26, 0x98, 0xD3, 0xE5, 0x11, 0x9F, 0xE5, 0x10, 0x9E, 0x40, 0x0C, 0xE5, 0x11, 0x9F, 0xF5, 0x11, 
+0xE5, 0x10, 0x9E, 0xF5, 0x10, 0x80, 0x05, 0xE4, 0xF5, 0x10, 0xF5, 0x11, 0xD1, 0xAF, 0xE5, 0x10, 
+0xF0, 0xA3, 0xE5, 0x11, 0xF0, 0xF1, 0x68, 0xC3, 0xF1, 0x23, 0x50, 0x60, 0xF1, 0x5B, 0x54, 0x7F, 
+0x12, 0x61, 0x83, 0xFE, 0xD3, 0x9F, 0x40, 0x03, 0xEE, 0x80, 0x09, 0x12, 0x61, 0x84, 0xFF, 0xF1, 
+0x5B, 0x54, 0x7F, 0xC3, 0x9F, 0x90, 0xA3, 0x85, 0xF0, 0x90, 0xA3, 0x85, 0xE0, 0xD3, 0x94, 0x04, 
+0x40, 0x08, 0xD1, 0x98, 0xE4, 0xF0, 0xA3, 0xF0, 0x80, 0x12, 0xD1, 0x98, 0xE0, 0xFE, 0xA3, 0xE0, 
+0x4E, 0x60, 0x09, 0xD1, 0x98, 0x74, 0xFF, 0xF5, 0xF0, 0x12, 0x49, 0x7F, 0xF1, 0x68, 0xE4, 0x93, 
+0xFE, 0x74, 0x01, 0x93, 0xFF, 0xD1, 0xAF, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0xD1, 0x98, 0xE0, 0xFE, 
+0xA3, 0xE0, 0x4E, 0x70, 0x18, 0xAF, 0x0D, 0x12, 0x64, 0x8C, 0x80, 0x11, 0xE5, 0x0F, 0x12, 0xB3, 
+0x44, 0xD3, 0xF1, 0x23, 0x40, 0x07, 0x7D, 0x01, 0xAF, 0x0D, 0x12, 0x62, 0x54, 0xD1, 0xAF, 0xA3, 
+0xE0, 0x90, 0xA3, 0xCB, 0xF0, 0x90, 0xA3, 0xCA, 0xE5, 0x0E, 0xF0, 0xAB, 0x0D, 0xE4, 0xFD, 0xFF, 
+0x12, 0xA9, 0x1D, 0xE4, 0xF5, 0x10, 0xF5, 0x11, 0xC1, 0x48, 0xD1, 0x6F, 0xE0, 0xFC, 0x64, 0x05, 
+0x60, 0x02, 0xA1, 0x56, 0xAD, 0x0F, 0xAF, 0x0D, 0x12, 0xA9, 0xAF, 0xF1, 0x4F, 0xEF, 0xD1, 0xA3, 
+0xE0, 0x54, 0x07, 0xF5, 0x17, 0x12, 0x61, 0x84, 0xFF, 0xC3, 0x94, 0x30, 0x50, 0x06, 0xE4, 0xD1, 
+0x6D, 0xE4, 0x80, 0x4F, 0xF1, 0x4F, 0xE0, 0x64, 0x01, 0x70, 0x5F, 0xD1, 0xF1, 0xE0, 0x64, 0x0A, 
+0x60, 0x24, 0xEF, 0x24, 0x05, 0xFF, 0xE4, 0x33, 0xFE, 0xF1, 0x43, 0xE0, 0xFD, 0xF1, 0x05, 0x50, 
+0x15, 0xED, 0x24, 0x05, 0xFF, 0xE4, 0x33, 0xFE, 0x12, 0x61, 0x84, 0xF1, 0x05, 0x50, 0x07, 0xF1, 
+0x37, 0xE0, 0x65, 0x0F, 0x60, 0x29, 0xE5, 0x17, 0x70, 0x05, 0x75, 0x17, 0x01, 0x80, 0x0D, 0xE5, 
+0x17, 0xB4, 0x01, 0x05, 0x75, 0x17, 0x03, 0x80, 0x03, 0x75, 0x17, 0x05, 0x12, 0x61, 0x84, 0xFF, 
+0xF1, 0x43, 0xEF, 0xF0, 0x74, 0x21, 0x25, 0x0D, 0xF5, 0x82, 0xE4, 0x34, 0x9D, 0x80, 0x17, 0xD1, 
+0x6F, 0xE4, 0xF0, 0xD1, 0xF1, 0xE0, 0x04, 0xF0, 0x80, 0x10, 0xE4, 0xF5, 0x17, 0x74, 0xA1, 0x25, 
+0x0D, 0xF5, 0x82, 0xE4, 0x34, 0x9E, 0xF5, 0x83, 0xE4, 0xF0, 0xF1, 0x37, 0xE5, 0x0F, 0xF0, 0x12, 
+0x4F, 0x38, 0xC4, 0x13, 0x13, 0x54, 0x03, 0x20, 0xE0, 0x02, 0xC1, 0x38, 0xD1, 0xF1, 0xE4, 0xF0, 
+0xD1, 0x6D, 0xE4, 0xF0, 0xC1, 0x38, 0xEC, 0x64, 0x06, 0x60, 0x02, 0xC1, 0x48, 0xF5, 0x10, 0xF5, 
+0x11, 0xD1, 0xA4, 0xE0, 0x54, 0x07, 0xF5, 0x17, 0xF1, 0x19, 0x40, 0x05, 0x75, 0x15, 0x05, 0x80, 
+0x13, 0xD3, 0xE5, 0x13, 0x94, 0xFA, 0xE5, 0x12, 0x94, 0x00, 0x40, 0x05, 0x75, 0x15, 0x02, 0x80, 
+0x03, 0xE4, 0xF5, 0x15, 0xD1, 0xFD, 0x80, 0x05, 0xCE, 0xC3, 0x13, 0xCE, 0x13, 0xD8, 0xF9, 0xFF, 
+0x90, 0x44, 0x9E, 0xE4, 0x93, 0xFD, 0x7C, 0x00, 0x12, 0x26, 0x98, 0x90, 0xA3, 0x86, 0xEE, 0xF0, 
+0xA3, 0xEF, 0xF0, 0xE4, 0xF5, 0x16, 0xF1, 0x0F, 0xE5, 0x16, 0xF1, 0x84, 0x08, 0x80, 0x05, 0xCE, 
+0xC3, 0x13, 0xCE, 0x13, 0xD8, 0xF9, 0xFF, 0xE5, 0x16, 0x90, 0x44, 0x99, 0x93, 0xF1, 0x9F, 0xC3, 
+0x90, 0xA3, 0x87, 0xE0, 0x95, 0x11, 0x90, 0xA3, 0x86, 0xE0, 0x95, 0x10, 0x40, 0x07, 0x05, 0x16, 
+0xE5, 0x16, 0xB4, 0x05, 0xD1, 0xE5, 0x16, 0xC3, 0x13, 0xF5, 0x16, 0xE5, 0x17, 0x24, 0x01, 0xFF, 
+0xE4, 0x33, 0xA2, 0xE7, 0x13, 0xEF, 0x13, 0xFF, 0xD3, 0x95, 0x16, 0x40, 0x06, 0xEF, 0x95, 0x16, 
+0xFF, 0x80, 0x02, 0xE4, 0xFF, 0xD1, 0x7B, 0xE0, 0xC3, 0x13, 0xFE, 0xEF, 0xC4, 0x33, 0x54, 0xE0, 
+0x2E, 0x04, 0xFE, 0xD1, 0x7B, 0xEE, 0xF0, 0xD1, 0x7B, 0xE0, 0xC3, 0x94, 0xC0, 0x40, 0x05, 0xD1, 
+0x7B, 0x74, 0xC0, 0xF0, 0xD1, 0x7B, 0x12, 0x5F, 0xF0, 0x25, 0xE0, 0xFF, 0x70, 0x04, 0xF5, 0x17, 
+0x80, 0x04, 0xEF, 0x14, 0xF5, 0x17, 0xD3, 0x90, 0xA3, 0x7C, 0xE0, 0x94, 0x03, 0x90, 0xA3, 0x7B, 
+0xE0, 0x94, 0x00, 0x40, 0x03, 0xE4, 0xF5, 0x17, 0xD1, 0xA4, 0xE0, 0x54, 0xF8, 0x90, 0xA3, 0x88, 
+0xF0, 0x45, 0x17, 0xFF, 0xD1, 0xA3, 0xEF, 0xF0, 0xD1, 0x6F, 0xE0, 0xD3, 0x94, 0x05, 0x50, 0x07, 
+0xD1, 0x6F, 0xE0, 0x04, 0xF0, 0x80, 0x0A, 0xD1, 0x8D, 0xE0, 0x54, 0xF8, 0xF0, 0xD1, 0x6F, 0xE4, 
+0xF0, 0xE4, 0xFD, 0xAF, 0x0D, 0x12, 0x68, 0x11, 0x05, 0x0D, 0x01, 0x02, 0x22, 0xF5, 0x17, 0x74, 
+0xA1, 0x25, 0x0D, 0xF5, 0x82, 0xE4, 0x34, 0x9E, 0xF5, 0x83, 0x22, 0x74, 0x01, 0x25, 0x0D, 0xF5, 
+0x82, 0xE4, 0x34, 0x93, 0xF5, 0x83, 0x22, 0x90, 0x00, 0x08, 0x02, 0x49, 0xC0, 0x75, 0xF0, 0x04, 
+0xE5, 0x0D, 0x90, 0x9B, 0x11, 0x02, 0x4A, 0x2A, 0x75, 0xF0, 0x04, 0xE5, 0x0D, 0x90, 0x9B, 0x12, 
+0x02, 0x4A, 0x2A, 0xF0, 0x75, 0xF0, 0x10, 0xE5, 0x0D, 0x90, 0x81, 0x01, 0x02, 0x4A, 0x2A, 0xE5, 
+0x0D, 0x25, 0xE0, 0x24, 0x91, 0xF5, 0x82, 0xE4, 0x34, 0x94, 0xF5, 0x83, 0x22, 0x12, 0x49, 0xC0, 
+0x2F, 0xFF, 0xEE, 0x22, 0x4E, 0xFF, 0xF0, 0x90, 0x00, 0x05, 0x02, 0x26, 0x37, 0xF0, 0x75, 0xF0, 
+0x10, 0xE5, 0x0D, 0x90, 0x81, 0x00, 0x02, 0x4A, 0x2A, 0x74, 0x11, 0x25, 0x22, 0xF5, 0x82, 0xE4, 
+0x34, 0x9D, 0xF5, 0x83, 0x22, 0x8F, 0x13, 0x75, 0xF0, 0x10, 0xEF, 0x90, 0x81, 0x05, 0x02, 0x4A, 
+0x2A, 0x74, 0x21, 0x25, 0x0D, 0xF5, 0x82, 0xE4, 0x34, 0x9D, 0xF5, 0x83, 0x22, 0xE5, 0x13, 0xAE, 
+0x12, 0xA8, 0x15, 0x08, 0x22, 0xD3, 0x9F, 0xEE, 0x64, 0x80, 0xF8, 0x74, 0x80, 0x98, 0x22, 0x90, 
+0xA3, 0x78, 0x12, 0x4A, 0x36, 0x75, 0xF0, 0x02, 0x22, 0xD3, 0xE5, 0x13, 0x94, 0xE8, 0xE5, 0x12, 
+0x94, 0x03, 0x22, 0x74, 0x01, 0x93, 0x95, 0x11, 0xE4, 0x93, 0x95, 0x10, 0x22, 0xE5, 0x12, 0xC3, 
+0x13, 0xFE, 0xE5, 0x13, 0x13, 0xFF, 0x22, 0x74, 0x21, 0x25, 0x0D, 0xF5, 0x82, 0xE4, 0x34, 0x9F, 
+0xF5, 0x83, 0x22, 0x74, 0x01, 0x25, 0x0D, 0xF5, 0x82, 0xE4, 0x34, 0x94, 0xF5, 0x83, 0x22, 0x74, 
+0x91, 0x25, 0x0D, 0xF5, 0x82, 0xE4, 0x34, 0x9A, 0xF5, 0x83, 0x22, 0x75, 0xF0, 0x04, 0xE5, 0x0D, 
+0x90, 0x9B, 0x14, 0x12, 0x4A, 0x2A, 0xE0, 0x22, 0xE5, 0x0F, 0x25, 0xE0, 0x24, 0x95, 0xF5, 0x82, 
+0xE4, 0x34, 0x42, 0xF5, 0x83, 0x22, 0xE5, 0x0D, 0x25, 0xE0, 0x24, 0x01, 0xF5, 0x82, 0xE4, 0x34, 
+0x92, 0xF5, 0x83, 0x22, 0xA4, 0xF5, 0x82, 0x85, 0xF0, 0x83, 0x12, 0x49, 0xC0, 0xAE, 0xF0, 0xA8, 
+0x15, 0x22, 0xD1, 0xE5, 0xE0, 0x54, 0xFB, 0xF1, 0xB7, 0x90, 0xA2, 0x95, 0x02, 0x27, 0x48, 0xFD, 
+0x7C, 0x00, 0x12, 0x26, 0x98, 0xEF, 0x25, 0x11, 0xF5, 0x11, 0xEE, 0x35, 0x10, 0xF5, 0x10, 0x22, 
+0xD1, 0xE5, 0xE0, 0x44, 0x04, 0xF0, 0x22, 0xF0, 0x7F, 0xB0, 0x7E, 0x0C, 0x02, 0x36, 0xCE, 0xFF, 
+0xEE, 0x5C, 0xFE, 0xEF, 0x5D, 0x4E, 0x22, 0x12, 0x99, 0x70, 0x12, 0x99, 0x0D, 0xE0, 0xFD, 0x7C, 
+0x00, 0x12, 0x6F, 0x93, 0x80, 0x05, 0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 0xF9, 0xF1, 0xBF, 0x7F, 
+0x00, 0x60, 0x02, 0x7F, 0x01, 0x22, 0xFE, 0x33, 0x33, 0x33, 0x54, 0xF8, 0x4F, 0x22, 0x54, 0x03, 
+0x4F, 0xFF, 0x75, 0xF0, 0x10, 0x22, 0xE4, 0xFB, 0xFA, 0xFD, 0x7F, 0x01, 0x12, 0x48, 0x2E, 0x90, 
+0xA3, 0x74, 0xEF, 0xF0, 0x60, 0xF0, 0x90, 0xA1, 0x76, 0xE0, 0xFF, 0x70, 0x04, 0xA3, 0xE0, 0x60, 
+0xE5, 0xC2, 0xAF, 0xEF, 0x30, 0xE0, 0x0F, 0x90, 0xA1, 0x76, 0xE0, 0x54, 0xFE, 0xF0, 0xE4, 0xFF, 
+0x12, 0x6E, 0x4A, 0x12, 0x6F, 0xFF, 0x11, 0x3E, 0x30, 0xE1, 0x05, 0x54, 0xFD, 0xF0, 0x11, 0x48, 
+0x11, 0x3E, 0x30, 0xE2, 0x05, 0x54, 0xFB, 0xF0, 0x11, 0xAA, 0xD2, 0xAF, 0x80, 0xC8, 0xD2, 0xAF, 
+0xC2, 0xAF, 0x90, 0xA1, 0x76, 0xE0, 0xFF, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 
+0xA1, 0xD5, 0xE0, 0xFF, 0x90, 0xA1, 0xD4, 0xE0, 0xB5, 0x07, 0x04, 0x7F, 0x01, 0x80, 0x02, 0x7F, 
+0x00, 0xEF, 0x70, 0x41, 0x90, 0xA1, 0xD4, 0xE0, 0xFE, 0x75, 0xF0, 0x08, 0x90, 0xA1, 0x84, 0x12, 
+0x4A, 0x2A, 0xE0, 0xFD, 0xEE, 0x75, 0xF0, 0x08, 0xA4, 0x24, 0x85, 0xF9, 0x74, 0xA1, 0x35, 0xF0, 
+0xFA, 0x7B, 0x01, 0xAF, 0x05, 0x12, 0x4E, 0x54, 0x90, 0xA1, 0xD4, 0x12, 0x8F, 0xC4, 0xB4, 0x0A, 
+0x02, 0x7F, 0x01, 0xEF, 0x60, 0x05, 0xE4, 0x90, 0xA1, 0xD4, 0xF0, 0x12, 0x6D, 0x35, 0x90, 0xA1, 
+0x76, 0xE0, 0x44, 0x02, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 
+0xD0, 0xE4, 0xFF, 0x90, 0xA2, 0x6D, 0xE0, 0xFE, 0x90, 0xA2, 0x6C, 0xE0, 0xFD, 0xB5, 0x06, 0x04, 
+0x7E, 0x01, 0x80, 0x02, 0x7E, 0x00, 0xEE, 0x64, 0x01, 0x60, 0x40, 0xED, 0x12, 0xB3, 0xCD, 0xFA, 
+0x7B, 0x01, 0x31, 0x10, 0x7F, 0x01, 0xEF, 0x60, 0x32, 0x90, 0xA2, 0x6C, 0xE0, 0x04, 0xF0, 0xE0, 
+0xB4, 0x0A, 0x02, 0x80, 0x02, 0x7F, 0x00, 0xEF, 0x60, 0x05, 0xE4, 0x90, 0xA2, 0x6C, 0xF0, 0x90, 
+0xA2, 0x6D, 0xE0, 0xFF, 0x90, 0xA2, 0x6C, 0xE0, 0xB5, 0x07, 0x04, 0x7F, 0x01, 0x80, 0x02, 0x7F, 
+0x00, 0xEF, 0x70, 0x07, 0x90, 0xA1, 0x76, 0xE0, 0x44, 0x04, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 
+0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0xA4, 0x4A, 0x12, 0x4A, 0x3F, 0x7F, 0x96, 0x7E, 
+0x02, 0x31, 0x7E, 0xEF, 0x60, 0x53, 0x90, 0x01, 0x17, 0xE0, 0xFE, 0x90, 0x01, 0x16, 0xE0, 0x7C, 
+0x00, 0x24, 0x00, 0xFF, 0xEC, 0x3E, 0xFE, 0xEF, 0x24, 0x01, 0xFF, 0xE4, 0x3E, 0xFE, 0x90, 0xA4, 
+0x4D, 0xEF, 0xF0, 0xEE, 0xFF, 0x90, 0xFD, 0x11, 0xF0, 0x90, 0xA4, 0x4D, 0xE0, 0xFD, 0x90, 0x02, 
+0x94, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0xA4, 0x4A, 0x12, 0xA0, 0x1F, 0x24, 0x02, 0xFF, 0xE4, 0x33, 
+0xFE, 0x71, 0xE9, 0x90, 0xA4, 0x4D, 0xE0, 0x24, 0x18, 0xFF, 0x90, 0xA4, 0x4A, 0x12, 0x4A, 0x36, 
+0x12, 0x9F, 0xAD, 0x90, 0x02, 0x96, 0x74, 0x01, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xD3, 0x10, 
+0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0xA4, 0x42, 0xEE, 0xF0, 0xA3, 0x71, 0x43, 0x90, 0xA4, 0x42, 
+0x12, 0xB4, 0x60, 0xE0, 0x60, 0x28, 0xC3, 0x90, 0xA4, 0x45, 0xE0, 0x94, 0xE8, 0x90, 0xA4, 0x44, 
+0xE0, 0x94, 0x03, 0x40, 0x0B, 0x90, 0x01, 0xC0, 0xE0, 0x44, 0x80, 0xF0, 0x7F, 0x00, 0x80, 0x10, 
+0x90, 0xA4, 0x44, 0x31, 0xC5, 0x7F, 0x0A, 0x7E, 0x00, 0x12, 0x3A, 0xF7, 0x80, 0xCF, 0x7F, 0x01, 
+0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xE4, 0x75, 0xF0, 0x01, 0x02, 0x49, 0x7F, 0xE4, 0x90, 0xA4, 0x79, 
+0xF0, 0xA3, 0xF0, 0x90, 0x05, 0x22, 0xE0, 0x90, 0xA4, 0x7B, 0xF0, 0x90, 0x04, 0x2D, 0xE0, 0x54, 
+0x01, 0xF0, 0x90, 0x04, 0x1D, 0xE0, 0x60, 0x37, 0xC3, 0x90, 0xA4, 0x7A, 0xE0, 0x94, 0xD0, 0x90, 
+0xA4, 0x79, 0xE0, 0x94, 0x07, 0x50, 0x28, 0x90, 0xA3, 0x5E, 0xE0, 0xB4, 0xFF, 0x0D, 0x7D, 0x18, 
+0x7F, 0xFF, 0x12, 0x5B, 0x63, 0xE4, 0x90, 0xA3, 0x65, 0xF0, 0x22, 0x90, 0x05, 0x22, 0x74, 0xFF, 
+0xF0, 0x7F, 0x01, 0x7E, 0x00, 0x12, 0x3A, 0xF7, 0x90, 0xA4, 0x79, 0x31, 0xC5, 0x80, 0xC3, 0x90, 
+0xA3, 0x5E, 0xE0, 0xFF, 0x7B, 0x18, 0x7D, 0x01, 0x12, 0x5C, 0xA9, 0xAB, 0x07, 0xAA, 0x06, 0x74, 
+0x28, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0xB4, 0x54, 0x03, 0x12, 0xB1, 0x3F, 
+0x74, 0x14, 0x2B, 0x51, 0x6B, 0xE0, 0xC4, 0x13, 0x54, 0x03, 0xFF, 0x90, 0xA3, 0x62, 0xE0, 0x54, 
+0xFC, 0x4F, 0xF0, 0x90, 0xA4, 0x7B, 0xE0, 0x54, 0x6F, 0xFF, 0x7D, 0x19, 0x12, 0x5E, 0xD3, 0x90, 
+0xA3, 0x63, 0x31, 0xC5, 0x90, 0xA3, 0x65, 0x74, 0x01, 0xF0, 0x22, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 
+0xF5, 0x83, 0x22, 0x90, 0xA4, 0x3F, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x90, 0x81, 0x00, 0xE0, 0x54, 
+0x0F, 0xFD, 0xAC, 0x07, 0x51, 0xDB, 0x44, 0x01, 0xF0, 0x51, 0xDB, 0x54, 0xFB, 0xF0, 0xAC, 0x07, 
+0x74, 0x12, 0x2C, 0x12, 0x5F, 0xBA, 0xE0, 0x44, 0xFA, 0xF0, 0x74, 0x11, 0x2C, 0x12, 0xB4, 0x79, 
+0xE0, 0x44, 0x1F, 0xF0, 0xAC, 0x07, 0x74, 0x06, 0x2C, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 
+0xE0, 0x44, 0x0E, 0xF0, 0x90, 0x04, 0xA7, 0xE4, 0xF0, 0x90, 0x04, 0xA6, 0xF0, 0x90, 0x04, 0xA5, 
+0x74, 0xFF, 0xF0, 0x90, 0x04, 0xA4, 0x74, 0xFD, 0xF0, 0x74, 0x14, 0x2C, 0x51, 0x6B, 0xE0, 0x54, 
+0xC0, 0x4D, 0xFD, 0x74, 0x14, 0x2F, 0x51, 0x6B, 0xED, 0xF0, 0x22, 0x74, 0x0D, 0x2C, 0xF5, 0x82, 
+0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x22, 0x31, 0xCC, 0xD3, 0x90, 0xA3, 0x60, 0xE0, 0x94, 0x00, 
+0x90, 0xA3, 0x5F, 0xE0, 0x94, 0x00, 0x40, 0x16, 0xE0, 0xFC, 0xA3, 0xE0, 0xFD, 0xEC, 0x90, 0xA4, 
+0x29, 0xF0, 0xA3, 0xED, 0xF0, 0xE4, 0xFB, 0xFD, 0x7F, 0x5C, 0x7E, 0x01, 0x81, 0xD1, 0x90, 0x01, 
+0x5F, 0xE4, 0xF0, 0x22, 0x12, 0x26, 0x1E, 0x90, 0xA3, 0x79, 0xF0, 0xF4, 0x60, 0x17, 0xE0, 0x90, 
+0xA3, 0x5E, 0x12, 0x4F, 0xD0, 0x75, 0xF0, 0x0A, 0xA4, 0xFF, 0x90, 0xA3, 0x5F, 0xE5, 0xF0, 0xF0, 
+0xA3, 0xEF, 0xF0, 0x80, 0xB2, 0x90, 0xA3, 0x79, 0xE0, 0x90, 0xA3, 0x5E, 0x71, 0x44, 0x90, 0x01, 
+0x5F, 0xF0, 0x22, 0xEF, 0xF0, 0xE4, 0xA3, 0xF0, 0xA3, 0xF0, 0x22, 0x90, 0xA4, 0x73, 0x71, 0x43, 
+0x90, 0x01, 0x09, 0xE0, 0x7F, 0x00, 0x30, 0xE7, 0x02, 0x7F, 0x01, 0x90, 0xA4, 0x73, 0xE0, 0x6F, 
+0x60, 0x34, 0xC3, 0x90, 0xA4, 0x75, 0xE0, 0x94, 0x88, 0x90, 0xA4, 0x74, 0xE0, 0x94, 0x13, 0x40, 
+0x08, 0x90, 0x01, 0xC0, 0xE0, 0x44, 0x10, 0xF0, 0x22, 0x90, 0xA4, 0x74, 0x31, 0xC5, 0x91, 0x9B, 
+0xD3, 0x90, 0xA4, 0x75, 0xE0, 0x94, 0x32, 0x90, 0xA4, 0x74, 0xE0, 0x94, 0x00, 0x40, 0xC1, 0x90, 
+0x01, 0xC6, 0xE0, 0x30, 0xE0, 0xBA, 0x22, 0x12, 0xA8, 0x2D, 0x90, 0x00, 0x08, 0xE0, 0x54, 0xEF, 
+0xFD, 0x7F, 0x08, 0x12, 0x3A, 0x96, 0xE4, 0xFF, 0x71, 0x4B, 0x90, 0xA1, 0x7C, 0xE0, 0xB4, 0x03, 
+0x0C, 0x90, 0x00, 0x70, 0xE0, 0x54, 0x7F, 0xFD, 0x7F, 0x70, 0x12, 0x3A, 0x96, 0x90, 0xA2, 0x84, 
+0xE0, 0x54, 0xEF, 0xF0, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x12, 0xA8, 0x4A, 0x71, 
+0x97, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0xA2, 0x8A, 0xE0, 0xFF, 0x60, 0x03, 0xB4, 0x08, 0x08, 
+0x12, 0xB1, 0xD5, 0xBF, 0x01, 0x02, 0x71, 0xC5, 0x22, 0xE4, 0xFC, 0xED, 0x2C, 0x24, 0x00, 0x91, 
+0x3A, 0xE4, 0xF0, 0x0C, 0xEC, 0xB4, 0x18, 0xF3, 0x74, 0x00, 0x2D, 0x91, 0x3A, 0xEF, 0xF0, 0xEE, 
+0x54, 0x3F, 0xFF, 0x74, 0x01, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 0xFB, 0xF5, 0x83, 0xEF, 0xF0, 0x74, 
+0x02, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 0xFB, 0xF5, 0x83, 0xE0, 0x54, 0xF0, 0xF0, 0x74, 0x03, 0x2D, 
+0xF5, 0x82, 0xE4, 0x34, 0xFB, 0xF5, 0x83, 0xE0, 0x44, 0x80, 0xF0, 0x74, 0x0B, 0x2D, 0xF5, 0x82, 
+0xE4, 0x34, 0xFB, 0xF5, 0x83, 0xE0, 0x44, 0x10, 0xF0, 0x22, 0xF5, 0x82, 0xE4, 0x34, 0xFB, 0xF5, 
+0x83, 0x22, 0xE4, 0x90, 0xA3, 0x6A, 0xF0, 0xA3, 0xF0, 0x90, 0x01, 0x98, 0xE0, 0x7F, 0x00, 0x30, 
+0xE4, 0x02, 0x7F, 0x01, 0xEF, 0x64, 0x01, 0x60, 0x3B, 0xC3, 0x90, 0xA3, 0x6B, 0xE0, 0x94, 0x88, 
+0x90, 0xA3, 0x6A, 0xE0, 0x94, 0x13, 0x40, 0x0F, 0x90, 0x01, 0xC1, 0xE0, 0x44, 0x10, 0xF0, 0x90, 
+0x01, 0xC7, 0x74, 0xFD, 0xF0, 0x80, 0x1D, 0x90, 0xA3, 0x6A, 0x31, 0xC5, 0x91, 0x9B, 0xD3, 0x90, 
+0xA3, 0x6B, 0xE0, 0x94, 0x32, 0x90, 0xA3, 0x6A, 0xE0, 0x94, 0x00, 0x40, 0xBC, 0x90, 0x01, 0xC6, 
+0xE0, 0x30, 0xE3, 0xB5, 0x90, 0x01, 0xC7, 0x74, 0xFE, 0xF0, 0x22, 0x7F, 0x14, 0x7E, 0x00, 0x02, 
+0x3A, 0xF7, 0x90, 0xA3, 0x31, 0xE0, 0xC3, 0x13, 0x54, 0x07, 0xFF, 0x75, 0xF0, 0x0E, 0x90, 0xA3, 
+0x3E, 0x12, 0x4A, 0x2A, 0xE0, 0xFE, 0x75, 0xF0, 0x0E, 0xEF, 0x90, 0xA3, 0x3D, 0x12, 0x4A, 0x2A, 
+0xE0, 0x90, 0xA4, 0x2A, 0xF0, 0x90, 0xA4, 0x29, 0xEE, 0xF0, 0xE4, 0xFB, 0xFD, 0x7F, 0x54, 0x7E, 
+0x01, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0xA4, 0x25, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 
+0x90, 0xA4, 0x29, 0xE0, 0xF5, 0x3B, 0xA3, 0xE0, 0xF5, 0x3C, 0x12, 0x34, 0x8C, 0x90, 0xA4, 0x25, 
+0x12, 0xB4, 0x60, 0xA3, 0xA3, 0xA3, 0x74, 0x05, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x12, 0xB3, 
+0xF6, 0xEF, 0xF0, 0xE4, 0xFB, 0xFD, 0x7F, 0x50, 0x7E, 0x01, 0x80, 0xC5, 0xD3, 0x10, 0xAF, 0x01, 
+0xC3, 0xC0, 0xD0, 0x90, 0xA4, 0x62, 0xEF, 0xF0, 0xA3, 0x74, 0x02, 0xF0, 0xE4, 0xFF, 0x12, 0x93, 
+0xF4, 0x30, 0xE0, 0x03, 0x12, 0x8E, 0xB2, 0x90, 0xA2, 0xD3, 0xE0, 0x30, 0xE0, 0x04, 0x7F, 0x01, 
+0x80, 0x37, 0x90, 0xA2, 0xCF, 0x12, 0x5F, 0xF0, 0x30, 0xE0, 0x04, 0x7F, 0x0D, 0x80, 0x2A, 0x90, 
+0xA2, 0xD2, 0xE0, 0xFF, 0xC4, 0x54, 0x0F, 0x30, 0xE0, 0x10, 0xEF, 0x13, 0x13, 0x54, 0x3F, 0x30, 
+0xE0, 0x04, 0x7F, 0x09, 0x80, 0x13, 0x7F, 0x03, 0x80, 0x0F, 0x90, 0xA2, 0xD2, 0xE0, 0xC3, 0x13, 
+0x30, 0xE0, 0x04, 0x7F, 0x03, 0x80, 0x02, 0x7F, 0x09, 0x12, 0x95, 0x54, 0x90, 0xA4, 0x62, 0xE0, 
+0x64, 0x03, 0x70, 0x70, 0x12, 0x5F, 0xED, 0x30, 0xE0, 0x62, 0x90, 0xA2, 0xD9, 0xE0, 0xFF, 0x90, 
+0xA2, 0xE4, 0xE0, 0xFE, 0xD3, 0x9F, 0x40, 0x3A, 0xEE, 0x75, 0xF0, 0x03, 0xA4, 0xFF, 0x90, 0xA2, 
+0xDB, 0xE0, 0xFE, 0xC3, 0xEF, 0x9E, 0xFF, 0x24, 0x03, 0xFD, 0xE4, 0x33, 0xFC, 0x90, 0xA2, 0xD1, 
+0xE0, 0xFE, 0xD3, 0x9D, 0xEC, 0x12, 0x77, 0x08, 0x40, 0x08, 0xEE, 0x9F, 0x90, 0xA4, 0x65, 0xF0, 
+0x80, 0x06, 0x90, 0xA4, 0x65, 0x74, 0x03, 0xF0, 0x90, 0xA4, 0x65, 0xD1, 0xDA, 0xE0, 0x04, 0xF0, 
+0x80, 0x13, 0x90, 0xA2, 0xDC, 0xE0, 0xFF, 0x91, 0xFE, 0x90, 0xA2, 0xD7, 0x74, 0x04, 0xF0, 0xE4, 
+0x90, 0xA2, 0xE2, 0xD1, 0xE7, 0xE4, 0x90, 0xA2, 0xE4, 0xF0, 0x80, 0x08, 0x90, 0xA2, 0xD1, 0xD1, 
+0xDA, 0xE0, 0x04, 0xF0, 0x90, 0xA2, 0xCF, 0x12, 0x4F, 0xF4, 0x30, 0xE0, 0x07, 0xE4, 0x90, 0xA4, 
+0x64, 0xF0, 0x80, 0x06, 0x90, 0xA4, 0x64, 0x74, 0x01, 0xF0, 0x12, 0x97, 0xD1, 0x20, 0xE0, 0x13, 
+0x90, 0xA3, 0x10, 0xE0, 0x60, 0x07, 0xE4, 0x90, 0xA4, 0x63, 0xF0, 0x80, 0x06, 0x90, 0xA4, 0x63, 
+0x74, 0x01, 0xF0, 0x90, 0xA4, 0x63, 0x12, 0x54, 0x26, 0x90, 0xA2, 0xE1, 0x74, 0x01, 0xF0, 0x12, 
+0x97, 0x95, 0x30, 0xE0, 0x0D, 0x90, 0xA4, 0x62, 0xE0, 0x70, 0x3F, 0xFD, 0xFF, 0x12, 0x5B, 0x63, 
+0x80, 0x38, 0x90, 0xA2, 0xCF, 0xE0, 0xC4, 0x54, 0x0F, 0x30, 0xE0, 0x1A, 0x90, 0xA2, 0xD5, 0xE0, 
+0x44, 0x20, 0xF0, 0x90, 0xA2, 0xCE, 0xE0, 0x60, 0x04, 0x7D, 0x01, 0x80, 0x18, 0x12, 0x57, 0xB4, 
+0x7D, 0x01, 0x7F, 0x0C, 0x80, 0x11, 0x90, 0xA4, 0x62, 0xE0, 0xB4, 0x03, 0x0D, 0x90, 0xA2, 0x87, 
+0xE0, 0x60, 0x07, 0xE4, 0xFD, 0x7F, 0x04, 0x12, 0x59, 0x80, 0x90, 0xA2, 0xCE, 0xE0, 0x60, 0x18, 
+0x90, 0xA4, 0x62, 0xE0, 0x70, 0x04, 0x7D, 0x04, 0x80, 0x0A, 0x90, 0xA4, 0x62, 0xE0, 0x64, 0x03, 
+0x70, 0x31, 0x7D, 0x0B, 0x7F, 0x6F, 0x80, 0x28, 0x90, 0xA4, 0x62, 0xE0, 0x70, 0x04, 0xFD, 0xFF, 
+0x80, 0x1E, 0x90, 0xA4, 0x62, 0xE0, 0xB4, 0x03, 0x1A, 0x90, 0xA2, 0xCF, 0x12, 0x97, 0xCA, 0x20, 
+0xE0, 0x0B, 0xEF, 0x13, 0x13, 0x54, 0x3F, 0x30, 0xE0, 0x03, 0x12, 0xA5, 0xCD, 0xE4, 0xFD, 0xFF, 
+0x12, 0x5B, 0x63, 0x12, 0x4F, 0xF1, 0x30, 0xE0, 0x05, 0x7F, 0x01, 0x12, 0x57, 0x0D, 0x90, 0xA2, 
+0xD3, 0xE0, 0xC3, 0x13, 0x30, 0xE0, 0x0E, 0x90, 0x06, 0xCD, 0xE0, 0x44, 0x10, 0xF0, 0x90, 0x06, 
+0xCF, 0xE0, 0x44, 0x10, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xE0, 0xFF, 0x91, 0xFE, 0x90, 0xA2, 
+0xE2, 0x22, 0x90, 0xA2, 0xD7, 0x74, 0x09, 0xF0, 0x90, 0x06, 0x92, 0x74, 0x04, 0xF0, 0x22, 0xE4, 
+0xFF, 0x90, 0xA2, 0xCF, 0xE0, 0x30, 0xE0, 0x31, 0xA3, 0xE0, 0xC3, 0x9F, 0xD1, 0xDB, 0x74, 0x01, 
+0xF0, 0x90, 0xA2, 0xE1, 0xF0, 0x90, 0xA2, 0xCE, 0xE0, 0x60, 0x07, 0x7D, 0x05, 0x7F, 0x6F, 0x02, 
+0x5B, 0x63, 0x12, 0x57, 0xB4, 0x90, 0xA2, 0xCF, 0x12, 0x97, 0xCA, 0x20, 0xE0, 0x0B, 0xEF, 0x13, 
+0x13, 0x54, 0x3F, 0x30, 0xE0, 0x03, 0x12, 0xA5, 0xCD, 0x22, 0x90, 0xA3, 0x31, 0xE0, 0xFF, 0xC3, 
+0x13, 0xFE, 0xEF, 0x54, 0xF1, 0xFF, 0xEE, 0x04, 0x54, 0x07, 0x25, 0xE0, 0x4F, 0xF0, 0xA3, 0xE0, 
+0xFF, 0x12, 0xB3, 0xFD, 0xB5, 0x07, 0x04, 0xEE, 0x54, 0xF1, 0xF0, 0x91, 0xA2, 0xE4, 0x90, 0xA3, 
+0x33, 0xF0, 0x12, 0x5E, 0x11, 0x12, 0xB3, 0xFD, 0x12, 0x87, 0xEA, 0xE0, 0xFA, 0x75, 0xF0, 0x0E, 
+0xED, 0x12, 0x82, 0x21, 0xFC, 0x54, 0x03, 0xFD, 0xEC, 0x13, 0x13, 0x54, 0x07, 0xFB, 0xEE, 0x12, 
+0xB4, 0x91, 0xAF, 0x02, 0x12, 0x82, 0x78, 0x12, 0x5F, 0xDB, 0xFE, 0x75, 0xF0, 0x0E, 0x12, 0x82, 
+0x21, 0xFD, 0x54, 0x03, 0xFF, 0xED, 0xC4, 0x13, 0x54, 0x07, 0xFD, 0x75, 0xF0, 0x0E, 0xEE, 0x12, 
+0x82, 0x21, 0x12, 0x86, 0x82, 0x12, 0x5F, 0xDB, 0xFF, 0x75, 0xF0, 0x0E, 0x90, 0xA3, 0x3F, 0x12, 
+0x4A, 0x2A, 0xE0, 0x04, 0xF0, 0x12, 0xB3, 0x11, 0xE4, 0xFD, 0x12, 0x5C, 0x5D, 0x12, 0x57, 0xB4, 
+0x12, 0x5F, 0xDB, 0xFD, 0xE4, 0xFF, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0xA4, 0x56, 
+0xEF, 0xF0, 0xA3, 0xED, 0xF0, 0xE4, 0xA3, 0xF0, 0x90, 0xA4, 0x58, 0xE0, 0xFF, 0xC3, 0x94, 0x02, 
+0x40, 0x03, 0x02, 0x80, 0x60, 0x90, 0xA4, 0x57, 0xE0, 0xFE, 0x12, 0x86, 0x03, 0x75, 0xF0, 0x03, 
+0xEF, 0x12, 0xB3, 0xA1, 0xE0, 0x90, 0xA4, 0x59, 0xF0, 0x90, 0xA4, 0x56, 0xE0, 0x60, 0x29, 0x90, 
+0xA4, 0x59, 0xE0, 0xFF, 0x75, 0xF0, 0x0E, 0xEE, 0x12, 0x80, 0x69, 0xC0, 0x83, 0xC0, 0x82, 0x90, 
+0xA4, 0x58, 0xE0, 0xD0, 0x82, 0xD0, 0x83, 0x75, 0xF0, 0x03, 0x12, 0x4A, 0x2A, 0xD1, 0x2F, 0x80, 
+0x02, 0xC3, 0x33, 0xD8, 0xFC, 0x4F, 0x80, 0x23, 0xD1, 0x20, 0x75, 0xF0, 0x0E, 0x11, 0x69, 0xC0, 
+0x83, 0xC0, 0x82, 0x90, 0xA4, 0x58, 0xE0, 0xD0, 0x82, 0xD0, 0x83, 0x75, 0xF0, 0x03, 0x12, 0x4A, 
+0x2A, 0xD1, 0x2F, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0xF4, 0x5F, 0x90, 0xA4, 0x59, 0xF0, 0xD1, 
+0x20, 0xD1, 0x03, 0xC0, 0x83, 0xC0, 0x82, 0x90, 0xA4, 0x58, 0xE0, 0xD0, 0x82, 0xD0, 0x83, 0x75, 
+0xF0, 0x03, 0x12, 0xB3, 0xA1, 0xEF, 0xF0, 0x90, 0xA4, 0x58, 0xE0, 0x04, 0xF0, 0x02, 0x7F, 0xC8, 
+0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x75, 0xF0, 0x0E, 0xEB, 0x90, 0xA3, 0x38, 0x02, 0x4A, 0x2A, 0xC3, 
+0xEF, 0x9D, 0xF5, 0x12, 0xC3, 0x94, 0x08, 0x50, 0x1C, 0xE4, 0xF5, 0x13, 0x11, 0x65, 0xC0, 0x83, 
+0xC0, 0x82, 0x90, 0xA3, 0x7D, 0xE0, 0xD0, 0x82, 0xD0, 0x83, 0x75, 0xF0, 0x03, 0x12, 0x4A, 0x2A, 
+0xE5, 0x12, 0xF0, 0x80, 0x3E, 0xE5, 0x12, 0xC3, 0x94, 0x10, 0x50, 0x09, 0x75, 0x13, 0x01, 0xE5, 
+0x12, 0x24, 0xF8, 0x80, 0x17, 0xE5, 0x12, 0xC3, 0x94, 0x18, 0x50, 0x09, 0x75, 0x13, 0x02, 0xE5, 
+0x12, 0x24, 0xF0, 0x80, 0x07, 0x75, 0x13, 0x03, 0xE5, 0x12, 0x24, 0xE8, 0xFF, 0x11, 0x65, 0xC0, 
+0x83, 0xC0, 0x82, 0x90, 0xA3, 0x7D, 0xE0, 0xD0, 0x82, 0xD0, 0x83, 0x75, 0xF0, 0x03, 0x12, 0x4A, 
+0x2A, 0xEF, 0xF0, 0xAF, 0x13, 0x22, 0x8F, 0x10, 0x8D, 0x11, 0xAE, 0x03, 0x74, 0x1F, 0xC3, 0x95, 
+0x10, 0x40, 0x0F, 0x90, 0xA3, 0x7D, 0xEE, 0xF0, 0xAB, 0x11, 0xE4, 0xFD, 0x31, 0x4D, 0x24, 0xD4, 
+0x80, 0x40, 0x74, 0x3F, 0xC3, 0x95, 0x10, 0x40, 0x0F, 0x90, 0xA3, 0x7D, 0xEE, 0xF0, 0xAB, 0x11, 
+0x7D, 0x20, 0x31, 0x4B, 0x24, 0x88, 0x80, 0x2A, 0x74, 0x5F, 0xC3, 0x95, 0x10, 0x40, 0x0F, 0x90, 
+0xA3, 0x7D, 0xEE, 0xF0, 0xAB, 0x11, 0x7D, 0x40, 0x31, 0x4B, 0x24, 0xD0, 0x80, 0x14, 0x74, 0x7F, 
+0xC3, 0x95, 0x10, 0x40, 0x25, 0x90, 0xA3, 0x7D, 0xEE, 0xF0, 0xAB, 0x11, 0x7D, 0x60, 0x31, 0x4B, 
+0x24, 0x84, 0xFD, 0xE4, 0x34, 0x04, 0xFC, 0x75, 0xF0, 0x0E, 0xE5, 0x11, 0xD1, 0x06, 0x75, 0xF0, 
+0x03, 0xEE, 0x12, 0x4A, 0x2A, 0xEC, 0xF0, 0xA3, 0xED, 0xF0, 0x22, 0xAF, 0x10, 0x11, 0x6F, 0x90, 
+0xA3, 0x79, 0xEF, 0xF0, 0x22, 0x12, 0x99, 0xAF, 0xC4, 0x54, 0x0F, 0xFF, 0xBF, 0x0F, 0x16, 0x90, 
+0xA3, 0x31, 0xE0, 0x54, 0xFE, 0xF0, 0xD1, 0xED, 0x51, 0x15, 0x12, 0x26, 0x1E, 0x54, 0x0F, 0xFF, 
+0x51, 0x29, 0x02, 0xAB, 0x30, 0x51, 0x15, 0x12, 0x51, 0x7C, 0xB1, 0xFB, 0xF1, 0xEA, 0xEF, 0x12, 
+0x4F, 0xD0, 0x54, 0x03, 0xFF, 0x75, 0xF0, 0x0E, 0xED, 0x51, 0x21, 0x54, 0xFC, 0x12, 0x4F, 0xCF, 
+0x54, 0x1C, 0xFF, 0xEE, 0x54, 0x0F, 0xFE, 0x75, 0xF0, 0x0E, 0x51, 0x21, 0x54, 0xE3, 0x12, 0x4F, 
+0xCF, 0x54, 0xE0, 0xFF, 0x75, 0xF0, 0x0E, 0xEE, 0x51, 0x21, 0x54, 0x1F, 0x4F, 0x12, 0x54, 0x1F, 
+0xB1, 0xF3, 0xE4, 0xFB, 0x51, 0x13, 0x12, 0x76, 0xC7, 0xB1, 0xF3, 0x7B, 0x01, 0x51, 0x13, 0x12, 
+0x4F, 0xDE, 0x33, 0x33, 0x33, 0x54, 0xF8, 0xB1, 0xFB, 0xFD, 0x75, 0xF0, 0x0E, 0x90, 0xA3, 0x3D, 
+0x12, 0x4A, 0x2A, 0xEF, 0xF0, 0x12, 0x4F, 0xDE, 0xC4, 0x13, 0x54, 0x07, 0xFF, 0x75, 0xF0, 0x0E, 
+0xED, 0x90, 0xA3, 0x3E, 0x12, 0x4A, 0x2A, 0xEF, 0xF0, 0xEE, 0xC4, 0x54, 0x0F, 0xFF, 0x14, 0x6D, 
+0x70, 0x20, 0x90, 0xA3, 0x32, 0xEF, 0xD1, 0xD1, 0x54, 0x0F, 0xC4, 0x54, 0xF0, 0xFF, 0x90, 0xA3, 
+0x31, 0xE0, 0x54, 0x0F, 0x4F, 0xF0, 0x54, 0xF1, 0xF0, 0x44, 0x01, 0xF0, 0x7D, 0x20, 0xE4, 0xFF, 
+0xD1, 0xD8, 0x22, 0x11, 0xD6, 0xAB, 0x0D, 0xAA, 0x0E, 0xA9, 0x0F, 0x22, 0x75, 0xF0, 0x0E, 0xE5, 
+0x10, 0x90, 0xA3, 0x35, 0x12, 0x4A, 0x2A, 0xE0, 0x22, 0x8F, 0x10, 0x7D, 0x17, 0x12, 0x5E, 0x0D, 
+0x75, 0xF0, 0x0E, 0xE5, 0x10, 0xF1, 0xEE, 0xE0, 0xFC, 0x51, 0x1C, 0xFE, 0x54, 0x03, 0xFD, 0xEE, 
+0x13, 0x13, 0x54, 0x07, 0xFB, 0x90, 0xA3, 0x31, 0xE0, 0xFE, 0x12, 0xB4, 0x91, 0xAF, 0x04, 0x51, 
+0x78, 0x51, 0x1C, 0xFE, 0x54, 0x03, 0xFF, 0xEE, 0xC4, 0x13, 0x54, 0x07, 0xFD, 0x51, 0x1C, 0xD1, 
+0x82, 0x75, 0xF0, 0x0E, 0xE5, 0x10, 0x12, 0xB3, 0x15, 0xE4, 0xFD, 0x12, 0x5C, 0x5D, 0x12, 0x57, 
+0xB4, 0xAD, 0x10, 0xE4, 0xFF, 0x02, 0x7F, 0xB6, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 
+0xA4, 0x5B, 0xED, 0xF0, 0xA3, 0xEB, 0xF0, 0x90, 0xA4, 0x5A, 0xEF, 0xF0, 0x90, 0xA4, 0x5D, 0xE0, 
+0xFD, 0xD1, 0x37, 0x90, 0xA4, 0x5A, 0xE0, 0xC3, 0x94, 0x0E, 0x50, 0x3F, 0x90, 0xA3, 0xF0, 0x12, 
+0x27, 0x54, 0x1F, 0xFE, 0x00, 0x00, 0x90, 0xA3, 0xF4, 0x12, 0x27, 0x54, 0x12, 0xD4, 0x00, 0x00, 
+0xB1, 0xEC, 0x90, 0xA3, 0xDE, 0x12, 0x27, 0x54, 0x00, 0x07, 0x03, 0x00, 0x90, 0xA3, 0xE2, 0x12, 
+0x27, 0x54, 0x00, 0x00, 0x00, 0x00, 0xB1, 0x45, 0x12, 0x27, 0x54, 0x00, 0x07, 0x03, 0x00, 0x90, 
+0xA3, 0xE2, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0x00, 0x61, 0xF6, 0xD1, 0x16, 0x50, 0x1B, 0xEF, 
+0x94, 0x30, 0x50, 0x16, 0x90, 0xA3, 0xF0, 0x12, 0x27, 0x54, 0x1F, 0xFE, 0x00, 0x00, 0x90, 0xA3, 
+0xF4, 0x12, 0x27, 0x54, 0x09, 0x28, 0x00, 0x00, 0x80, 0x64, 0x90, 0xA4, 0x5A, 0xE0, 0xFF, 0x74, 
+0x32, 0xD3, 0x9F, 0x50, 0x1B, 0xEF, 0x94, 0x40, 0x50, 0x16, 0x90, 0xA3, 0xF0, 0x12, 0x27, 0x54, 
+0x1F, 0xFE, 0x00, 0x00, 0x90, 0xA3, 0xF4, 0x12, 0x27, 0x54, 0x08, 0xA6, 0x00, 0x00, 0x80, 0x3E, 
+0xD1, 0x0C, 0x50, 0x1B, 0xEF, 0x94, 0x74, 0x50, 0x16, 0x90, 0xA3, 0xF0, 0x12, 0x27, 0x54, 0x1F, 
+0xFE, 0x00, 0x00, 0x90, 0xA3, 0xF4, 0x12, 0x27, 0x54, 0x08, 0xA4, 0x00, 0x00, 0x80, 0x1F, 0x90, 
+0xA4, 0x5A, 0xE0, 0xFF, 0x74, 0x76, 0xD3, 0x9F, 0x50, 0x16, 0x90, 0xA3, 0xF0, 0x12, 0x27, 0x54, 
+0x1F, 0xFE, 0x00, 0x00, 0x90, 0xA3, 0xF4, 0x12, 0x27, 0x54, 0x08, 0x24, 0x00, 0x00, 0xB1, 0xEC, 
+0xD1, 0x16, 0x50, 0x2E, 0xEF, 0x94, 0x40, 0x50, 0x29, 0x90, 0xA3, 0xDE, 0x12, 0x27, 0x54, 0x00, 
+0x07, 0x03, 0x00, 0x90, 0xA3, 0xE2, 0x12, 0x27, 0x54, 0x00, 0x01, 0x01, 0x00, 0xB1, 0x45, 0x12, 
+0x27, 0x54, 0x00, 0x07, 0x03, 0x00, 0x90, 0xA3, 0xE2, 0x12, 0x27, 0x54, 0x00, 0x01, 0x01, 0x00, 
+0x80, 0x64, 0xD1, 0x0C, 0x50, 0x2E, 0xEF, 0x94, 0x8C, 0x50, 0x29, 0x90, 0xA3, 0xDE, 0x12, 0x27, 
+0x54, 0x00, 0x07, 0x03, 0x00, 0x90, 0xA3, 0xE2, 0x12, 0x27, 0x54, 0x00, 0x03, 0x01, 0x00, 0xB1, 
+0x45, 0x12, 0x27, 0x54, 0x00, 0x07, 0x03, 0x00, 0x90, 0xA3, 0xE2, 0x12, 0x27, 0x54, 0x00, 0x03, 
+0x01, 0x00, 0x80, 0x32, 0x90, 0xA4, 0x5A, 0xE0, 0xFF, 0x74, 0x8C, 0xC3, 0x9F, 0x50, 0x2B, 0x90, 
+0xA3, 0xDE, 0x12, 0x27, 0x54, 0x00, 0x07, 0x03, 0x00, 0x90, 0xA3, 0xE2, 0x12, 0x27, 0x54, 0x00, 
+0x05, 0x01, 0x00, 0xB1, 0x45, 0x12, 0x27, 0x54, 0x00, 0x07, 0x03, 0x00, 0x90, 0xA3, 0xE2, 0x12, 
+0x27, 0x54, 0x00, 0x05, 0x01, 0x00, 0xB1, 0xE5, 0x91, 0xC3, 0x90, 0xA4, 0x5A, 0xE0, 0xFF, 0xA3, 
+0xE0, 0xFD, 0x12, 0xAB, 0x77, 0x90, 0xA4, 0x5B, 0xE0, 0x64, 0x02, 0x70, 0x51, 0x90, 0xA4, 0x5A, 
+0xE0, 0xFF, 0xD3, 0x94, 0x30, 0x50, 0x05, 0x75, 0x77, 0x2A, 0x80, 0x5E, 0xEF, 0xD3, 0x94, 0x40, 
+0x50, 0x05, 0x75, 0x77, 0x3A, 0x80, 0x53, 0xEF, 0xD3, 0x94, 0x70, 0x50, 0x05, 0x75, 0x77, 0x6A, 
+0x80, 0x48, 0xEF, 0xD3, 0x94, 0x80, 0x50, 0x05, 0x75, 0x77, 0x7A, 0x80, 0x3D, 0xEF, 0xD3, 0x94, 
+0x90, 0x50, 0x05, 0x75, 0x77, 0x8A, 0x80, 0x32, 0xEF, 0xD3, 0x94, 0xA1, 0x50, 0x05, 0x75, 0x77, 
+0x9B, 0x80, 0x27, 0xEF, 0xD3, 0x94, 0xB1, 0x50, 0x21, 0x75, 0x77, 0xAB, 0x80, 0x1C, 0x90, 0xA4, 
+0x5B, 0xE0, 0x64, 0x01, 0x70, 0x2D, 0xA3, 0xE0, 0x90, 0xA4, 0x5A, 0xB4, 0x01, 0x07, 0xE0, 0x24, 
+0x02, 0xF5, 0x77, 0x80, 0x05, 0xE0, 0x24, 0xFE, 0xF5, 0x77, 0x90, 0xA3, 0xDE, 0x12, 0x27, 0x54, 
+0x00, 0x00, 0x00, 0xFF, 0xAF, 0x77, 0xB1, 0x3B, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0xFF, 0xAF, 
+0x77, 0x80, 0x1D, 0x90, 0xA3, 0xDE, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0xFF, 0x90, 0xA4, 0x5A, 
+0xE0, 0xFF, 0xB1, 0x3B, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0xFF, 0x90, 0xA4, 0x5A, 0xE0, 0xFF, 
+0xE4, 0xFC, 0xFD, 0xFE, 0x90, 0xA3, 0xE2, 0x12, 0x27, 0x48, 0xB1, 0xE5, 0x91, 0xC3, 0xD0, 0xD0, 
+0x92, 0xAF, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0xA3, 0xDC, 0xEC, 0xF0, 0xA3, 
+0xED, 0xF0, 0x90, 0xA3, 0xDB, 0xEF, 0xF0, 0xA3, 0xA3, 0xE0, 0xFD, 0x12, 0x88, 0x6C, 0x90, 0xA3, 
+0xE6, 0x12, 0x27, 0x48, 0x90, 0xA3, 0xDE, 0x12, 0x4A, 0x12, 0x12, 0x27, 0x15, 0x90, 0xA3, 0xE6, 
+0x12, 0x57, 0x3B, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0xA3, 0xDE, 0x12, 0x4A, 
+0x12, 0x90, 0xA3, 0xE2, 0x12, 0x57, 0x3B, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0x12, 
+0x4A, 0x05, 0x90, 0xA3, 0xEA, 0x12, 0x27, 0x48, 0x90, 0xA3, 0xDC, 0xA3, 0xE0, 0xFD, 0xC0, 0x05, 
+0x90, 0xA3, 0xEA, 0x12, 0x4A, 0x12, 0x90, 0xAC, 0x96, 0x12, 0x27, 0x48, 0x90, 0xA3, 0xDB, 0xE0, 
+0xFF, 0xD0, 0x05, 0x12, 0x39, 0xBA, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xE4, 0xFC, 0xFD, 0xFE, 0x90, 
+0xA3, 0xE2, 0x12, 0x27, 0x48, 0x7D, 0x18, 0x7C, 0x00, 0xE4, 0xFF, 0x91, 0xC3, 0x90, 0xA3, 0xDE, 
+0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0xEF, 0x14, 0x60, 0x30, 0x14, 0x60, 0x56, 0x24, 
+0x02, 0x70, 0x7D, 0x90, 0xA3, 0xDE, 0x12, 0x27, 0x54, 0x00, 0x00, 0x0C, 0x00, 0x90, 0xA3, 0xE2, 
+0x12, 0x27, 0x54, 0x00, 0x00, 0x0C, 0x00, 0xB1, 0x45, 0x12, 0x27, 0x54, 0x00, 0x00, 0x0C, 0x00, 
+0x90, 0xA3, 0xE2, 0x12, 0x27, 0x54, 0x00, 0x00, 0x0C, 0x00, 0x80, 0x50, 0x90, 0xA3, 0xDE, 0x12, 
+0x27, 0x54, 0x00, 0x00, 0x0C, 0x00, 0x90, 0xA3, 0xE2, 0x12, 0x27, 0x54, 0x00, 0x00, 0x04, 0x00, 
+0xB1, 0x45, 0x12, 0x27, 0x54, 0x00, 0x00, 0x0C, 0x00, 0x90, 0xA3, 0xE2, 0x12, 0x27, 0x54, 0x00, 
+0x00, 0x04, 0x00, 0x80, 0x27, 0x90, 0xA3, 0xDE, 0x12, 0x27, 0x54, 0x00, 0x00, 0x0C, 0x00, 0x90, 
+0xA3, 0xE2, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0x00, 0xB1, 0x45, 0x12, 0x27, 0x54, 0x00, 0x00, 
+0x0C, 0x00, 0x90, 0xA3, 0xE2, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0x00, 0xB1, 0xE5, 0x91, 0xC3, 
+0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x7D, 0x18, 0x7C, 0x00, 0x7F, 0x01, 0x22, 0x7F, 0x60, 0x7E, 0x08, 
+0x02, 0x54, 0xD7, 0xFF, 0x12, 0x26, 0x1E, 0x54, 0x0F, 0xFD, 0x22, 0xFF, 0x12, 0x26, 0x1E, 0xFE, 
+0x54, 0x0F, 0x22, 0x75, 0xF0, 0x0E, 0x90, 0xA3, 0x36, 0x02, 0x4A, 0x2A, 0x90, 0xA4, 0x5A, 0xE0, 
+0xFF, 0x74, 0x64, 0xD3, 0x9F, 0x22, 0x90, 0xA4, 0x5A, 0xE0, 0xFF, 0x74, 0x24, 0xD3, 0x9F, 0x22, 
+0x90, 0xA4, 0x59, 0xE0, 0xFF, 0x90, 0xA4, 0x57, 0xE0, 0x22, 0xE0, 0xFF, 0x90, 0xA4, 0x02, 0xE0, 
+0xFE, 0x74, 0x01, 0xA8, 0x06, 0x08, 0x22, 0x90, 0xA4, 0x87, 0xED, 0xF0, 0x90, 0xA4, 0x86, 0xEF, 
+0xF0, 0xD3, 0x94, 0x0E, 0x50, 0x15, 0xD1, 0x76, 0xEF, 0x60, 0x2A, 0xD1, 0x76, 0xEF, 0x64, 0x01, 
+0x70, 0x23, 0x90, 0xA4, 0x87, 0xE0, 0xFD, 0xE4, 0xFF, 0x80, 0x15, 0x90, 0xA4, 0x86, 0xE0, 0xD3, 
+0x94, 0x0E, 0x40, 0x11, 0xD1, 0x76, 0xEF, 0x70, 0x0A, 0x90, 0xA4, 0x87, 0xE0, 0xFD, 0x7F, 0x01, 
+0x02, 0xAC, 0xEF, 0xD1, 0x76, 0x22, 0x90, 0x04, 0x54, 0xE0, 0x7F, 0x00, 0x30, 0xE7, 0x02, 0x7F, 
+0x01, 0x22, 0xFE, 0x13, 0x13, 0x54, 0x07, 0xFB, 0x90, 0xA4, 0x5E, 0x12, 0x5F, 0xE4, 0xE4, 0xFE, 
+0x7D, 0x18, 0xFF, 0x12, 0x3A, 0xA9, 0x90, 0xA4, 0x61, 0xEF, 0xF0, 0x90, 0xA4, 0x5E, 0xE0, 0xFF, 
+0x12, 0xAC, 0x98, 0x90, 0xA4, 0x5E, 0x12, 0x9A, 0x84, 0x12, 0xAD, 0xEB, 0xAE, 0x07, 0x90, 0x04, 
+0x83, 0xEE, 0xF0, 0x90, 0xA4, 0x5E, 0xE0, 0xFF, 0xAD, 0x06, 0x12, 0x55, 0x36, 0x90, 0xA4, 0x61, 
+0xE0, 0xFF, 0x90, 0xA4, 0x5E, 0xE0, 0xFD, 0x12, 0xAB, 0x77, 0x90, 0xA4, 0x5E, 0xE0, 0xFF, 0xA1, 
+0x51, 0xF0, 0x90, 0x00, 0x06, 0x02, 0x26, 0x37, 0x74, 0x65, 0x2F, 0xF8, 0xE6, 0x4D, 0xFE, 0xF6, 
+0x74, 0x38, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x01, 0xF5, 0x83, 0xEE, 0xF0, 0x22, 0x7D, 0x20, 0xE4, 
+0xFF, 0x74, 0x65, 0x12, 0xB4, 0x99, 0x80, 0xE6, 0x90, 0x05, 0x62, 0xE0, 0xFE, 0x90, 0x05, 0x61, 
+0xE0, 0xFD, 0xED, 0x78, 0x02, 0xCE, 0xC3, 0x13, 0xCE, 0x13, 0xD8, 0xF9, 0xFF, 0x90, 0xA3, 0x96, 
+0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x12, 0xA1, 0xF7, 0x60, 0x02, 0xE1, 0xCD, 0x90, 0xA2, 0x87, 0xE0, 
+0x70, 0x02, 0xE1, 0xCD, 0xF1, 0xDA, 0x64, 0x01, 0x70, 0x22, 0x90, 0x06, 0xAB, 0xE0, 0x90, 0xA2, 
+0x8E, 0xF0, 0x90, 0x06, 0xAA, 0xE0, 0x90, 0xA2, 0x8D, 0xF0, 0xA3, 0xE0, 0xFF, 0x70, 0x08, 0x90, 
+0xA2, 0x8D, 0xE0, 0xFE, 0xFF, 0x80, 0x00, 0x90, 0xA2, 0x8E, 0xEF, 0xF0, 0xE4, 0x90, 0xA2, 0x90, 
+0x12, 0xB3, 0x7C, 0x12, 0xA2, 0x1A, 0x12, 0xA4, 0xFA, 0xF0, 0x54, 0xEF, 0xF0, 0x90, 0xA2, 0x85, 
+0xE0, 0xFF, 0xC4, 0x54, 0x0F, 0x24, 0xFD, 0x50, 0x02, 0x80, 0x03, 0x12, 0xA5, 0x11, 0x12, 0xA7, 
+0x00, 0x30, 0xE0, 0x56, 0xEF, 0xC4, 0x13, 0x13, 0x54, 0x03, 0x20, 0xE0, 0x22, 0xF1, 0xE2, 0x6F, 
+0x70, 0x48, 0x90, 0xA2, 0x84, 0xE0, 0x44, 0x40, 0xF0, 0x12, 0xA6, 0xF8, 0x12, 0xB3, 0xD9, 0xD1, 
+0xD8, 0x12, 0x8E, 0x1C, 0x12, 0x8E, 0x22, 0x90, 0xA2, 0x8E, 0xE0, 0x14, 0xF0, 0x80, 0x2B, 0xF1, 
+0xDA, 0x64, 0x01, 0x70, 0x25, 0xF1, 0xE2, 0xFE, 0x6F, 0x60, 0x1F, 0x90, 0x05, 0x73, 0xE0, 0xFF, 
+0xEE, 0x6F, 0x60, 0x16, 0x90, 0xA2, 0x84, 0x12, 0x93, 0xF9, 0x30, 0xE0, 0x0D, 0xEF, 0x54, 0xBF, 
+0x12, 0xB3, 0xD9, 0xD1, 0xF1, 0x12, 0x9C, 0x13, 0xF1, 0xCE, 0x12, 0xB4, 0x89, 0x22, 0x74, 0x5D, 
+0x2F, 0xF8, 0xE6, 0x4D, 0xFE, 0xF6, 0x74, 0x30, 0xC1, 0xE2, 0x90, 0xA2, 0x85, 0xE0, 0xC4, 0x54, 
+0x0F, 0x22, 0x90, 0xA2, 0x8D, 0xE0, 0xFF, 0xA3, 0xE0, 0x22, 0xFD, 0x75, 0xF0, 0x0E, 0x90, 0xA3, 
+0x34, 0x02, 0x4A, 0x2A, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0xA4, 0x10, 0xEF, 0xF0, 
+0xA3, 0xED, 0xF0, 0xFB, 0x7D, 0x00, 0x7C, 0x00, 0xE4, 0x90, 0xA4, 0x16, 0xF0, 0xEB, 0x90, 0xA4, 
+0x11, 0xF0, 0x7F, 0xB0, 0x7E, 0x08, 0x12, 0x36, 0xCE, 0xE4, 0xFF, 0xEC, 0x90, 0xA4, 0x12, 0x12, 
+0x27, 0x48, 0x90, 0xA4, 0x12, 0x12, 0x4A, 0x1E, 0x90, 0xA4, 0x11, 0xE0, 0xFF, 0xE4, 0xFC, 0xFD, 
+0xFE, 0x12, 0x4A, 0x05, 0xA3, 0x12, 0x27, 0x48, 0x90, 0xA4, 0x12, 0x12, 0x54, 0xCA, 0x7F, 0xB0, 
+0x7E, 0x08, 0x12, 0x37, 0x5D, 0x12, 0x7C, 0x9B, 0x90, 0xA4, 0x10, 0xE0, 0x75, 0xF0, 0x08, 0xA4, 
+0x24, 0x73, 0xF5, 0x82, 0xE4, 0x34, 0xAF, 0xF5, 0x83, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x12, 0x36, 
+0xCE, 0xED, 0x54, 0x0F, 0xFD, 0xE4, 0xFC, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xD3, 0x10, 0xAF, 0x01, 
+0xC3, 0xC0, 0xD0, 0x12, 0x87, 0xF4, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 
+0xC0, 0xD0, 0xC0, 0x07, 0xC0, 0x05, 0x90, 0xA4, 0x2D, 0x12, 0x4A, 0x12, 0x90, 0xAC, 0x9C, 0x12, 
+0x27, 0x48, 0xD0, 0x05, 0xD0, 0x07, 0x12, 0x32, 0x65, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xC0, 0xE0, 
+0xC0, 0xF0, 0xC0, 0x83, 0xC0, 0x82, 0xC0, 0xD0, 0x75, 0xD0, 0x00, 0xC0, 0x00, 0xC0, 0x01, 0xC0, 
+0x02, 0xC0, 0x03, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0x01, 0xC4, 0x74, 0x9E, 
+0xF0, 0x74, 0x88, 0xA3, 0xF0, 0x11, 0xED, 0x74, 0x9E, 0x04, 0x90, 0x01, 0xC4, 0xF0, 0x74, 0x88, 
+0xA3, 0xF0, 0xD0, 0x07, 0xD0, 0x06, 0xD0, 0x05, 0xD0, 0x04, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 
+0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x82, 0xD0, 0x83, 0xD0, 0xF0, 0xD0, 0xE0, 0x32, 0x7B, 0x00, 0x7A, 
+0x00, 0x79, 0x53, 0xE4, 0xFD, 0x7F, 0x01, 0x12, 0x39, 0x33, 0xE5, 0x51, 0x52, 0x53, 0x7B, 0x00, 
+0x7A, 0x00, 0x79, 0x54, 0x7D, 0x01, 0x7F, 0x01, 0x12, 0x39, 0x33, 0xE5, 0x52, 0x52, 0x54, 0xAB, 
+0x53, 0xE4, 0xFD, 0x7F, 0x01, 0x12, 0x39, 0x04, 0xAB, 0x54, 0x7D, 0x01, 0x7F, 0x01, 0x02, 0x39, 
+0x04, 0xC0, 0xE0, 0xC0, 0xF0, 0xC0, 0x83, 0xC0, 0x82, 0xC0, 0xD0, 0x75, 0xD0, 0x00, 0xC0, 0x00, 
+0xC0, 0x01, 0xC0, 0x02, 0xC0, 0x03, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0x01, 
+0xC4, 0x74, 0x21, 0xF0, 0x74, 0x89, 0xA3, 0xF0, 0x31, 0x92, 0xE5, 0x5C, 0x30, 0xE7, 0x02, 0x31, 
+0x77, 0x74, 0x21, 0x04, 0x90, 0x01, 0xC4, 0xF0, 0x74, 0x89, 0xA3, 0xF0, 0xD0, 0x07, 0xD0, 0x06, 
+0xD0, 0x05, 0xD0, 0x04, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x82, 
+0xD0, 0x83, 0xD0, 0xF0, 0xD0, 0xE0, 0x32, 0x7F, 0x01, 0x7E, 0x00, 0x12, 0x3A, 0x69, 0x90, 0x00, 
+0xF2, 0xE0, 0x20, 0xE6, 0x0C, 0x90, 0x00, 0x05, 0xE0, 0x44, 0x80, 0xFD, 0x7F, 0x05, 0x12, 0x3A, 
+0x96, 0x22, 0x90, 0x00, 0x54, 0xE0, 0x55, 0x55, 0xF5, 0x59, 0xA3, 0xE0, 0x55, 0x56, 0xF5, 0x5A, 
+0xA3, 0xE0, 0x55, 0x57, 0xF5, 0x5B, 0xA3, 0xE0, 0x55, 0x58, 0xF5, 0x5C, 0xAD, 0x59, 0x7F, 0x54, 
+0x12, 0x3A, 0x96, 0xAD, 0x5A, 0x7F, 0x55, 0x12, 0x3A, 0x96, 0xAD, 0x5B, 0x7F, 0x56, 0x12, 0x3A, 
+0x96, 0xAD, 0x5C, 0x7F, 0x57, 0x12, 0x3A, 0x96, 0x53, 0x91, 0xEF, 0x22, 0xC0, 0xE0, 0xC0, 0xF0, 
+0xC0, 0x83, 0xC0, 0x82, 0xC0, 0xD0, 0x75, 0xD0, 0x00, 0xC0, 0x00, 0xC0, 0x01, 0xC0, 0x02, 0xC0, 
+0x03, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0x01, 0xC4, 0x74, 0xCC, 0xF0, 0x74, 
+0x89, 0xA3, 0xF0, 0x12, 0xA1, 0x40, 0xE5, 0x61, 0x30, 0xE1, 0x02, 0x91, 0x35, 0xE5, 0x61, 0x30, 
+0xE4, 0x02, 0xB1, 0xB7, 0xE5, 0x61, 0x30, 0xE5, 0x03, 0x12, 0xA1, 0x9D, 0xE5, 0x63, 0x30, 0xE0, 
+0x02, 0xB1, 0xA7, 0xE5, 0x63, 0x30, 0xE1, 0x02, 0xB1, 0xCB, 0xE5, 0x63, 0x30, 0xE2, 0x03, 0x12, 
+0xA1, 0xD9, 0xE5, 0x63, 0x30, 0xE3, 0x03, 0x12, 0xA1, 0xE5, 0xE5, 0x63, 0x30, 0xE4, 0x03, 0x12, 
+0xA2, 0x00, 0xE5, 0x63, 0x30, 0xE5, 0x03, 0x12, 0xA5, 0xAD, 0xE5, 0x63, 0x30, 0xE6, 0x03, 0x12, 
+0xA5, 0x96, 0xE5, 0x64, 0x30, 0xE1, 0x03, 0x12, 0xA7, 0x22, 0xE5, 0x64, 0x30, 0xE4, 0x03, 0x12, 
+0x6F, 0xF0, 0xE5, 0x64, 0x30, 0xE5, 0x02, 0x51, 0x86, 0xE5, 0x64, 0x30, 0xE6, 0x02, 0x71, 0xD6, 
+0x74, 0xCC, 0x04, 0x90, 0x01, 0xC4, 0xF0, 0x74, 0x89, 0xA3, 0xF0, 0xD0, 0x07, 0xD0, 0x06, 0xD0, 
+0x05, 0xD0, 0x04, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x82, 0xD0, 
+0x83, 0xD0, 0xF0, 0xD0, 0xE0, 0x32, 0xE4, 0xF5, 0x21, 0x90, 0xA2, 0x81, 0xE0, 0xFF, 0xE5, 0x21, 
+0xC3, 0x9F, 0x40, 0x02, 0x61, 0xB0, 0x90, 0x04, 0xCF, 0x74, 0x30, 0xF0, 0xAF, 0x21, 0x12, 0x77, 
+0xC7, 0xEF, 0x70, 0x02, 0x61, 0xAC, 0xE5, 0x21, 0x13, 0x13, 0x13, 0x54, 0x1F, 0xF5, 0x22, 0xE5, 
+0x21, 0x54, 0x07, 0xF5, 0x23, 0x74, 0x81, 0x25, 0x22, 0x12, 0xB3, 0x56, 0xE0, 0xFD, 0x71, 0xC4, 
+0x80, 0x05, 0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 0xF9, 0xFF, 0xEF, 0x5D, 0x70, 0x02, 0x61, 0xAC, 
+0x75, 0xF0, 0x10, 0xE5, 0x21, 0x12, 0x76, 0xA9, 0xE0, 0x20, 0xE7, 0x02, 0x80, 0x10, 0x75, 0xF0, 
+0x10, 0xE5, 0x21, 0x90, 0x81, 0x02, 0x12, 0x4A, 0x2A, 0xE0, 0xFF, 0x20, 0xE7, 0x09, 0x90, 0x01, 
+0xC1, 0xE0, 0x44, 0x20, 0xF0, 0x61, 0xAC, 0x75, 0xF0, 0x04, 0xE5, 0x21, 0x12, 0x76, 0x92, 0xE0, 
+0x54, 0x07, 0x44, 0x50, 0xF0, 0xEF, 0x30, 0xE6, 0x37, 0x12, 0x76, 0xD9, 0x71, 0xCC, 0x80, 0x02, 
+0xC3, 0x33, 0xD8, 0xFC, 0xF4, 0x5F, 0xF0, 0x75, 0xF0, 0x10, 0xE5, 0x21, 0x12, 0x76, 0xD3, 0xE0, 
+0xFD, 0x75, 0xF0, 0x04, 0xE5, 0x21, 0x12, 0x4F, 0x3D, 0x71, 0xBD, 0xE4, 0xFB, 0xAF, 0x21, 0x12, 
+0x66, 0xB4, 0x75, 0xF0, 0x04, 0xE5, 0x21, 0x12, 0x76, 0x92, 0xE0, 0x54, 0xF8, 0xF0, 0x80, 0x6C, 
+0x71, 0xB1, 0xE0, 0x04, 0xF0, 0x71, 0xB1, 0xE0, 0xD3, 0x94, 0x01, 0x40, 0x44, 0xAF, 0x21, 0x12, 
+0x61, 0x91, 0x71, 0xB1, 0xE4, 0xF0, 0x12, 0x76, 0xD9, 0xE0, 0xFD, 0xFB, 0x7A, 0x00, 0x71, 0xC4, 
+0x80, 0x05, 0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 0xF9, 0xF1, 0xE0, 0x70, 0x14, 0x12, 0x76, 0xD9, 
+0xAF, 0x23, 0x74, 0x01, 0xA8, 0x07, 0x08, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0x4D, 0xF0, 0x80, 
+0x2B, 0x12, 0x76, 0xD9, 0x71, 0xCC, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0xF4, 0x5F, 0xF0, 0x80, 
+0x1B, 0x75, 0xF0, 0x10, 0xE5, 0x21, 0x12, 0x76, 0xD3, 0xE0, 0xFD, 0x75, 0xF0, 0x04, 0xE5, 0x21, 
+0x12, 0x4F, 0x3D, 0x71, 0xBD, 0x7B, 0x01, 0xAF, 0x21, 0x12, 0x66, 0xB4, 0x05, 0x21, 0x41, 0x89, 
+0x22, 0x74, 0xA1, 0x25, 0x21, 0xF5, 0x82, 0xE4, 0x34, 0x9F, 0xF5, 0x83, 0x22, 0x13, 0x13, 0x54, 
+0x03, 0xF5, 0x71, 0x22, 0x74, 0x01, 0x7E, 0x00, 0xA8, 0x23, 0x08, 0x22, 0xE0, 0xFF, 0xAE, 0x23, 
+0x74, 0x01, 0xA8, 0x06, 0x08, 0x22, 0x90, 0x07, 0x1F, 0xE0, 0x54, 0x7F, 0xF0, 0x90, 0x07, 0x1C, 
+0xE0, 0x54, 0x01, 0xFF, 0x60, 0x2F, 0x90, 0xA3, 0x65, 0xE0, 0x60, 0x29, 0x90, 0xA3, 0x62, 0xE0, 
+0x54, 0x03, 0x14, 0x60, 0x10, 0x14, 0x60, 0x16, 0x24, 0x02, 0x70, 0x19, 0x90, 0x04, 0x2D, 0xE0, 
+0x44, 0x02, 0xF0, 0x80, 0x10, 0x90, 0x04, 0x2D, 0xE0, 0x44, 0x06, 0xF0, 0x80, 0x07, 0x90, 0x04, 
+0x2D, 0xE0, 0x44, 0x0E, 0xF0, 0xE4, 0x90, 0xA3, 0x65, 0xF0, 0x90, 0xA3, 0x98, 0xEF, 0xF0, 0x90, 
+0xA3, 0x96, 0x74, 0x02, 0xF0, 0x90, 0xA3, 0xA4, 0x14, 0xF0, 0xFB, 0x7A, 0xA3, 0x79, 0x96, 0x91, 
+0xD3, 0x7F, 0x04, 0x81, 0xB8, 0xE4, 0xFF, 0x90, 0xA3, 0x96, 0xEF, 0xF0, 0x90, 0x04, 0x7E, 0xE0, 
+0xF5, 0x22, 0xA3, 0xE0, 0xF5, 0x23, 0x65, 0x22, 0x60, 0x69, 0x90, 0xA3, 0x97, 0x74, 0x03, 0xF0, 
+0x90, 0xA3, 0xA5, 0x74, 0x08, 0xF0, 0xE5, 0x23, 0x04, 0x54, 0x0F, 0xF5, 0x24, 0xE4, 0xF5, 0x21, 
+0xE5, 0x24, 0x75, 0xF0, 0x08, 0xA4, 0x24, 0x00, 0xF5, 0x82, 0xE4, 0x34, 0x80, 0xF5, 0x83, 0xE5, 
+0x82, 0x25, 0x21, 0x12, 0x6A, 0x9B, 0xE0, 0xFF, 0x74, 0x99, 0x25, 0x21, 0xF5, 0x82, 0xE4, 0x34, 
+0xA3, 0xF5, 0x83, 0xEF, 0xF0, 0x05, 0x21, 0xE5, 0x21, 0xB4, 0x08, 0xD4, 0x7B, 0x01, 0x7A, 0xA3, 
+0x79, 0x97, 0x91, 0xD3, 0xE5, 0x23, 0x04, 0x54, 0x0F, 0xF5, 0x23, 0xB4, 0x0F, 0x03, 0xE4, 0xF5, 
+0x23, 0x90, 0x04, 0x7F, 0xE5, 0x23, 0xF0, 0x90, 0xA3, 0x96, 0xE0, 0x7F, 0x04, 0x70, 0x02, 0xA1, 
+0xBC, 0x91, 0xB8, 0x22, 0x91, 0xD3, 0x7F, 0x04, 0x90, 0xA4, 0x8A, 0xEF, 0xF0, 0x7F, 0x02, 0x12, 
+0x48, 0x07, 0x90, 0xA1, 0x76, 0xE0, 0xFF, 0x90, 0xA4, 0x8A, 0xE0, 0xFE, 0xEF, 0x4E, 0x90, 0xA1, 
+0x76, 0xF0, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0xA2, 0x6C, 0xE0, 0xFF, 0x70, 
+0x06, 0xA3, 0xE0, 0x64, 0x09, 0x60, 0x0A, 0xEF, 0x14, 0xFF, 0x90, 0xA2, 0x6D, 0xE0, 0xB5, 0x07, 
+0x04, 0x7F, 0x01, 0x80, 0x02, 0x7F, 0x00, 0xEF, 0x60, 0x09, 0x90, 0x01, 0xC1, 0xE0, 0x44, 0x02, 
+0xF0, 0x80, 0x29, 0xC0, 0x01, 0x90, 0xA2, 0x6D, 0xE0, 0x12, 0xB3, 0xCD, 0xA8, 0x01, 0xFC, 0x7D, 
+0x01, 0xD0, 0x01, 0x7E, 0x00, 0x7F, 0x0F, 0x12, 0x49, 0x59, 0x90, 0xA2, 0x6D, 0xF1, 0xC4, 0xB4, 
+0x0A, 0x02, 0x7F, 0x01, 0xEF, 0x60, 0x05, 0xE4, 0x90, 0xA2, 0x6D, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 
+0x22, 0x90, 0x04, 0xA6, 0x74, 0x06, 0xF0, 0xE4, 0x90, 0xA3, 0x8E, 0xF0, 0x90, 0xA3, 0x8E, 0xE0, 
+0xFF, 0xC3, 0x94, 0x06, 0x50, 0x57, 0xEF, 0x90, 0x40, 0x56, 0x93, 0xFF, 0x94, 0x0A, 0x50, 0x02, 
+0x80, 0x02, 0x7F, 0x0A, 0xAE, 0x07, 0xEF, 0x24, 0x02, 0x90, 0xA3, 0x8D, 0xF0, 0x90, 0xA3, 0x7F, 
+0x74, 0x0E, 0xF0, 0x90, 0xA3, 0x81, 0x74, 0x01, 0xF0, 0xB1, 0x9E, 0x90, 0xA3, 0x82, 0xF0, 0xE4, 
+0xFF, 0xEF, 0xC3, 0x9E, 0x50, 0x17, 0xB1, 0x9E, 0x2F, 0x12, 0xAA, 0xCA, 0xE0, 0xFD, 0x74, 0x83, 
+0x2F, 0xF5, 0x82, 0xE4, 0x34, 0xA3, 0xF5, 0x83, 0xED, 0xF0, 0x0F, 0x80, 0xE4, 0x7B, 0x01, 0x7A, 
+0xA3, 0x79, 0x7F, 0x91, 0xB4, 0x90, 0xA3, 0x8E, 0xE0, 0x04, 0xF0, 0x80, 0x9F, 0x22, 0x90, 0xA3, 
+0x8E, 0xE0, 0x90, 0x40, 0x50, 0x93, 0x22, 0x12, 0xA3, 0xFB, 0x90, 0xA2, 0xCF, 0xE0, 0x30, 0xE0, 
+0x05, 0xE4, 0xFF, 0x12, 0x7D, 0x0C, 0x22, 0x12, 0x6D, 0x35, 0x7F, 0x02, 0x8F, 0x76, 0x7F, 0x02, 
+0x12, 0x48, 0x07, 0x90, 0xA1, 0x76, 0xE0, 0x45, 0x76, 0xF0, 0x22, 0x12, 0x7E, 0xEF, 0x12, 0x5F, 
+0xED, 0x30, 0xE0, 0x13, 0x90, 0xA3, 0x19, 0xE0, 0x04, 0xF0, 0xE0, 0xB4, 0x14, 0x09, 0x90, 0x04, 
+0x9C, 0xE4, 0xF0, 0x90, 0xA3, 0x19, 0xF0, 0x90, 0xA2, 0x87, 0xE0, 0x60, 0x2B, 0x90, 0xA2, 0x84, 
+0x12, 0x5F, 0xB0, 0x30, 0xE0, 0x0B, 0x90, 0x01, 0x3B, 0xE0, 0x30, 0xE4, 0x04, 0xD1, 0x22, 0xD1, 
+0x1C, 0x90, 0xA4, 0x8D, 0xE0, 0x04, 0xF0, 0xE0, 0xC3, 0x94, 0x80, 0x40, 0x0B, 0x90, 0x01, 0x98, 
+0xE0, 0x54, 0xFE, 0xF0, 0xE0, 0x44, 0x01, 0xF0, 0x7F, 0x01, 0x80, 0xA0, 0x7D, 0x01, 0x7F, 0x02, 
+0x80, 0x04, 0x7D, 0x02, 0x7F, 0x02, 0x74, 0x5D, 0x12, 0xB4, 0x99, 0xFE, 0xF6, 0x74, 0x30, 0x02, 
+0x86, 0xE2, 0xEF, 0x70, 0x34, 0x7D, 0x78, 0x7F, 0x02, 0xD1, 0x26, 0x7D, 0x02, 0x7F, 0x03, 0xD1, 
+0x26, 0x7D, 0xC8, 0x7F, 0x02, 0x12, 0x86, 0xF1, 0x12, 0xA2, 0x1A, 0xE4, 0xFF, 0x12, 0x77, 0xC7, 
+0xEF, 0x70, 0x0A, 0xD1, 0xA6, 0x54, 0xBF, 0xF0, 0x54, 0x7F, 0xF0, 0x80, 0x07, 0x7D, 0x01, 0x7F, 
+0x0C, 0x12, 0x59, 0x80, 0xD1, 0xAA, 0x02, 0xB4, 0x69, 0x90, 0x01, 0x36, 0x74, 0x78, 0xF0, 0xA3, 
+0x74, 0x02, 0xF0, 0x7D, 0x78, 0xFF, 0x12, 0x87, 0xCE, 0x7D, 0x02, 0x7F, 0x03, 0x12, 0x87, 0xCE, 
+0x90, 0x06, 0x0A, 0xE0, 0x44, 0x07, 0x12, 0xB3, 0x7C, 0xE4, 0xFF, 0x12, 0x77, 0xC7, 0xBF, 0x01, 
+0x11, 0x12, 0xA4, 0xE5, 0x90, 0xA2, 0x8A, 0xE0, 0x20, 0xE2, 0x0A, 0x7D, 0x01, 0x7F, 0x04, 0x02, 
+0x59, 0x80, 0x12, 0xB4, 0x89, 0x22, 0xD1, 0xB2, 0xF1, 0x8C, 0x90, 0xA2, 0x83, 0xE0, 0x54, 0xF7, 
+0xF0, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0xA2, 0x95, 0x12, 0x54, 0xCA, 0x7F, 
+0xB0, 0x7E, 0x0C, 0x12, 0x37, 0x5D, 0x90, 0xA2, 0x95, 0x12, 0x54, 0xCA, 0xF1, 0xD9, 0x90, 0x00, 
+0x10, 0xE0, 0x44, 0x0C, 0xFD, 0x7F, 0x10, 0x12, 0x3A, 0x96, 0x90, 0x00, 0x72, 0xE0, 0x54, 0xF3, 
+0xFD, 0x7F, 0x72, 0x12, 0x3A, 0x96, 0x90, 0x01, 0x01, 0xE0, 0x44, 0x02, 0xF0, 0x90, 0x01, 0x00, 
+0x74, 0xFF, 0xF0, 0x90, 0xA2, 0xCD, 0x12, 0x5F, 0xB0, 0x30, 0xE0, 0x05, 0x7F, 0x03, 0x12, 0x95, 
+0x54, 0x90, 0xA2, 0xEA, 0xE0, 0x20, 0xE0, 0x32, 0xF1, 0xBD, 0x13, 0x30, 0xE0, 0x2C, 0x90, 0xA3, 
+0x10, 0xE0, 0x60, 0x07, 0xE4, 0x90, 0xA4, 0x1B, 0xF0, 0x80, 0x06, 0x90, 0xA4, 0x1B, 0x74, 0x01, 
+0xF0, 0xEF, 0xC4, 0x13, 0x54, 0x07, 0x90, 0xA4, 0x1C, 0x30, 0xE0, 0x05, 0x74, 0x01, 0xF0, 0x80, 
+0x03, 0x74, 0x02, 0xF0, 0x90, 0xA4, 0x1B, 0x12, 0x54, 0x26, 0x90, 0x06, 0xB7, 0x74, 0x09, 0xF0, 
+0x90, 0x06, 0xB4, 0x74, 0x86, 0xF0, 0x12, 0xB4, 0x57, 0x54, 0xBF, 0xF1, 0x9F, 0x12, 0x54, 0xCA, 
+0xF1, 0xCB, 0x90, 0x00, 0x02, 0xE0, 0x44, 0x01, 0x12, 0x96, 0x73, 0x7F, 0x00, 0x7E, 0x0C, 0xF1, 
+0x99, 0x12, 0x54, 0xCA, 0x12, 0xB3, 0x95, 0xF1, 0x99, 0x12, 0x54, 0xCA, 0xF1, 0xD2, 0x90, 0x00, 
+0xFF, 0xE0, 0x70, 0x13, 0xF1, 0xAB, 0x54, 0xE7, 0x12, 0x96, 0xE5, 0xF1, 0xAB, 0x54, 0x18, 0x70, 
+0x06, 0x90, 0x01, 0xBF, 0xE0, 0x04, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x12, 0xB2, 0x8F, 0x12, 
+0x57, 0xB4, 0x7D, 0x0C, 0x7F, 0x01, 0x02, 0x58, 0xF6, 0x12, 0x36, 0xCE, 0xEF, 0x44, 0x03, 0xFF, 
+0xEC, 0x90, 0xA4, 0x17, 0x12, 0x27, 0x48, 0x90, 0xA4, 0x17, 0x22, 0x7B, 0x01, 0x7A, 0xA4, 0x79, 
+0x1D, 0x7D, 0x08, 0x7F, 0x01, 0x12, 0x96, 0xA1, 0x90, 0xA4, 0x1D, 0xE0, 0x22, 0x90, 0xA2, 0xCD, 
+0xE0, 0xFF, 0xC3, 0x22, 0xE0, 0x04, 0xF0, 0xE0, 0x7F, 0x00, 0x22, 0x7F, 0xB4, 0x7E, 0x08, 0x02, 
+0x37, 0x5D, 0x7F, 0x00, 0x7E, 0x0E, 0x02, 0x37, 0x5D, 0x7F, 0xB0, 0x7E, 0x0E, 0x02, 0x37, 0x5D, 
+0xFF, 0xEE, 0x5A, 0xFE, 0xEF, 0x5B, 0x4E, 0x22, 0xC0, 0xE0, 0xC0, 0xF0, 0xC0, 0x83, 0xC0, 0x82, 
+0xC0, 0xD0, 0x75, 0xD0, 0x00, 0xC0, 0x00, 0xC0, 0x01, 0xC0, 0x02, 0xC0, 0x03, 0xC0, 0x04, 0xC0, 
+0x05, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0x01, 0xC4, 0x74, 0xE8, 0xF0, 0x74, 0x8F, 0xA3, 0xF0, 0x12, 
+0xA1, 0x6D, 0xE5, 0x69, 0x30, 0xE0, 0x11, 0x11, 0x96, 0xE5, 0x6B, 0x30, 0xE2, 0x0A, 0x12, 0xA3, 
+0xC9, 0x90, 0x07, 0x8F, 0xE0, 0x44, 0x10, 0xF0, 0xE5, 0x69, 0x30, 0xE1, 0x03, 0x12, 0xA7, 0x0B, 
+0xE5, 0x69, 0x30, 0xE2, 0x03, 0x12, 0xA5, 0x81, 0xE5, 0x69, 0x30, 0xE3, 0x02, 0xF1, 0xC7, 0xE5, 
+0x69, 0x30, 0xE5, 0x02, 0xF1, 0x82, 0xE5, 0x6A, 0x30, 0xE0, 0x03, 0x12, 0xA7, 0x2C, 0xE5, 0x6C, 
+0x30, 0xE1, 0x05, 0x7F, 0x04, 0x12, 0x8D, 0xBC, 0xE5, 0x6C, 0x30, 0xE4, 0x03, 0x12, 0xA7, 0x16, 
+0xE5, 0x6C, 0x30, 0xE5, 0x03, 0x12, 0xA5, 0xF5, 0xE5, 0x6C, 0x30, 0xE6, 0x03, 0x12, 0xA6, 0x5E, 
+0x74, 0xE8, 0x04, 0x90, 0x01, 0xC4, 0xF0, 0x74, 0x8F, 0xA3, 0xF0, 0xD0, 0x07, 0xD0, 0x06, 0xD0, 
+0x05, 0xD0, 0x04, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x82, 0xD0, 
+0x83, 0xD0, 0xF0, 0xD0, 0xE0, 0x32, 0x90, 0xA2, 0xCF, 0xE0, 0x30, 0xE0, 0x35, 0x11, 0xD3, 0x90, 
+0xA2, 0xE2, 0xE0, 0xFF, 0xB4, 0x01, 0x02, 0x80, 0x1D, 0x90, 0xA2, 0xE2, 0xE0, 0xFF, 0xB4, 0x02, 
+0x02, 0x80, 0x1D, 0x90, 0xA2, 0xE2, 0xE0, 0xFF, 0xB4, 0x03, 0x03, 0x02, 0x7D, 0x0C, 0x90, 0xA2, 
+0xE2, 0xE0, 0xFF, 0xB4, 0x04, 0x02, 0x41, 0xBB, 0x90, 0xA2, 0xE2, 0xE0, 0xFF, 0xB4, 0x05, 0x02, 
+0x91, 0x00, 0x22, 0x12, 0x5F, 0xED, 0x20, 0xE0, 0x02, 0x41, 0x81, 0x90, 0xA2, 0xD7, 0xE0, 0x64, 
+0x01, 0x70, 0x2F, 0x90, 0x06, 0x92, 0xE0, 0x20, 0xE2, 0x06, 0x90, 0x04, 0xE3, 0xE0, 0x60, 0x1D, 
+0x12, 0x7E, 0xE8, 0x90, 0xA2, 0xE4, 0xE0, 0x04, 0xF0, 0x90, 0xA2, 0xDB, 0xE0, 0x75, 0xF0, 0x03, 
+0x84, 0xFF, 0x90, 0xA2, 0xE4, 0xE0, 0xB5, 0x07, 0x02, 0x80, 0x02, 0x41, 0x6B, 0x71, 0xEB, 0x04, 
+0xF0, 0x22, 0x90, 0xA2, 0xD7, 0xE0, 0x64, 0x04, 0x70, 0x2C, 0x90, 0x06, 0x92, 0xE0, 0x20, 0xE2, 
+0x06, 0x90, 0x04, 0xE3, 0xE0, 0x60, 0x19, 0x12, 0x7E, 0xE8, 0x90, 0xA2, 0xE4, 0xE0, 0x04, 0xF0, 
+0x90, 0xA2, 0xDA, 0xE0, 0xFF, 0x90, 0xA2, 0xE4, 0xE0, 0xB5, 0x07, 0x02, 0x80, 0x02, 0x41, 0x6B, 
+0x71, 0xEB, 0x74, 0x04, 0xF0, 0x22, 0x90, 0xA2, 0xD7, 0xE0, 0x64, 0x06, 0x60, 0x02, 0x21, 0xEB, 
+0x51, 0x82, 0x50, 0x08, 0x90, 0xA2, 0xE5, 0xE0, 0x94, 0x03, 0x40, 0x1A, 0x51, 0xB3, 0x90, 0xA2, 
+0xE2, 0x30, 0xE0, 0x05, 0x74, 0x05, 0xF0, 0x80, 0x03, 0x74, 0x02, 0xF0, 0xE4, 0x90, 0xA2, 0xD7, 
+0xF0, 0x90, 0xA2, 0xE5, 0xF0, 0x22, 0x90, 0xA2, 0xD6, 0x71, 0xF9, 0x30, 0xE0, 0x3A, 0xEF, 0x54, 
+0xFB, 0xF0, 0xE4, 0xA3, 0x51, 0xB2, 0x30, 0xE0, 0x0B, 0x90, 0xA2, 0xF4, 0xE0, 0x20, 0xE0, 0x02, 
+0x41, 0x1D, 0x41, 0x15, 0x51, 0x82, 0x40, 0x0B, 0x90, 0xA2, 0xF4, 0xE0, 0x30, 0xE0, 0x02, 0x80, 
+0x74, 0x80, 0x7A, 0x90, 0xA2, 0xF4, 0xE0, 0x30, 0xE0, 0x07, 0x12, 0x7E, 0xE2, 0x71, 0xE2, 0x80, 
+0x77, 0x90, 0xA2, 0xE2, 0x74, 0x02, 0xF0, 0x22, 0x12, 0x5B, 0x6E, 0x90, 0xA2, 0xE5, 0xE0, 0x04, 
+0xF0, 0x7F, 0x03, 0x12, 0x7C, 0xFE, 0x51, 0x82, 0x50, 0x0A, 0x90, 0xA2, 0xE5, 0xE0, 0x94, 0x03, 
+0x50, 0x02, 0x41, 0x81, 0x7F, 0x03, 0xB1, 0x54, 0x90, 0x05, 0x22, 0xE0, 0x44, 0x10, 0xFF, 0x7D, 
+0x03, 0x12, 0x5B, 0x63, 0x90, 0x04, 0x9C, 0xE0, 0x04, 0xF0, 0x22, 0x90, 0xA2, 0xD7, 0xE0, 0x64, 
+0x07, 0x70, 0x38, 0x90, 0xA2, 0xE5, 0xE0, 0xB4, 0x04, 0x05, 0x12, 0x57, 0xED, 0x80, 0x66, 0x90, 
+0xA2, 0xD6, 0x71, 0xF9, 0x30, 0xE0, 0x19, 0xEF, 0x54, 0xFB, 0xF0, 0xE4, 0xA3, 0xF0, 0x90, 0xA2, 
+0xF4, 0xE0, 0x30, 0xE0, 0x08, 0x12, 0x7E, 0xE2, 0x71, 0xE2, 0x04, 0x80, 0x0B, 0x02, 0x57, 0xED, 
+0x12, 0x5B, 0x6E, 0x90, 0xA2, 0xE5, 0xE0, 0x04, 0xF0, 0x80, 0x40, 0x90, 0xA2, 0xD7, 0xE0, 0x64, 
+0x09, 0x70, 0x4E, 0x90, 0xA2, 0xD6, 0xE0, 0x30, 0xE0, 0x0B, 0x12, 0x57, 0xED, 0x90, 0xA2, 0xD6, 
+0xE0, 0x54, 0xFE, 0xF0, 0x22, 0x90, 0x06, 0x92, 0xE0, 0x30, 0xE2, 0x24, 0x74, 0x04, 0xF0, 0x90, 
+0xA2, 0xE4, 0xE0, 0x04, 0xF0, 0xE0, 0xB4, 0x02, 0x12, 0x51, 0xAA, 0x60, 0x05, 0x74, 0x05, 0xF0, 
+0x80, 0x03, 0x74, 0x02, 0xF0, 0xE4, 0x90, 0xA2, 0xD7, 0xF0, 0x22, 0x7F, 0x03, 0x02, 0x7C, 0xFE, 
+0x51, 0xAA, 0x60, 0x05, 0x74, 0x05, 0xF0, 0x80, 0x03, 0x74, 0x02, 0xF0, 0xE4, 0x90, 0xA2, 0xD7, 
+0xF0, 0x22, 0x90, 0xA2, 0xE5, 0xE0, 0xFF, 0x90, 0xA2, 0xE4, 0xE0, 0x2F, 0xFF, 0xE4, 0x33, 0xFE, 
+0x7C, 0x00, 0x7D, 0x03, 0x12, 0x26, 0x98, 0x90, 0xA2, 0xDB, 0xE0, 0x2F, 0xFF, 0xEC, 0x3E, 0xFE, 
+0xC3, 0xEF, 0x94, 0x41, 0xEE, 0x64, 0x80, 0x94, 0x80, 0x22, 0x90, 0xA4, 0x8F, 0xE0, 0x90, 0xA2, 
+0xE2, 0x22, 0xF0, 0x90, 0xA2, 0xD2, 0xE0, 0xC4, 0x54, 0x0F, 0x22, 0x90, 0xA3, 0xA6, 0xEF, 0xF0, 
+0x7F, 0x03, 0x12, 0x7C, 0xFE, 0x51, 0xB3, 0x90, 0xA2, 0xE2, 0x30, 0xE0, 0x05, 0x74, 0x05, 0xF0, 
+0x80, 0x03, 0xE0, 0x04, 0xF0, 0x90, 0xA2, 0xD3, 0xF1, 0xCA, 0x20, 0xE0, 0x09, 0xEF, 0x13, 0x13, 
+0x13, 0x54, 0x1F, 0x30, 0xE0, 0x37, 0x51, 0xB3, 0x30, 0xE0, 0x0A, 0x90, 0xA2, 0xD0, 0xE0, 0xFF, 
+0x90, 0xA2, 0xE0, 0x80, 0x21, 0x90, 0xA3, 0xA6, 0xE0, 0xFC, 0xB4, 0x01, 0x0D, 0x90, 0xA2, 0xD0, 
+0xE0, 0xFE, 0x90, 0xA2, 0xDF, 0xE0, 0xC3, 0x9E, 0x80, 0x0F, 0xEC, 0xB4, 0x04, 0x0F, 0x90, 0xA2, 
+0xD1, 0xE0, 0xFF, 0x90, 0xA2, 0xDF, 0xE0, 0xC3, 0x9F, 0x90, 0xA2, 0xE6, 0xF0, 0xF1, 0x95, 0x30, 
+0xE0, 0x23, 0x12, 0x57, 0xE6, 0x54, 0x07, 0x20, 0xE0, 0x02, 0x61, 0xB0, 0x71, 0xD9, 0x50, 0x0A, 
+0xEF, 0x25, 0xE0, 0x25, 0xE0, 0xFB, 0xE4, 0xFD, 0x80, 0x05, 0x7B, 0x7F, 0x7D, 0xFF, 0xE4, 0xFF, 
+0x12, 0x5D, 0x92, 0x80, 0x6B, 0x90, 0xA2, 0xCF, 0xE0, 0xC4, 0x54, 0x0F, 0x30, 0xE0, 0x48, 0xF1, 
+0xDA, 0xFD, 0x7F, 0x04, 0x12, 0x59, 0x80, 0x12, 0x5F, 0xED, 0x30, 0xE0, 0x3A, 0x90, 0xA2, 0xD6, 
+0xE0, 0x44, 0x02, 0xF0, 0x54, 0xFB, 0xF0, 0xE4, 0x90, 0xA2, 0xE5, 0xF0, 0x90, 0xA2, 0xE2, 0xF0, 
+0x90, 0xA3, 0xA6, 0xE0, 0xFF, 0xB4, 0x01, 0x08, 0x90, 0xA2, 0xD7, 0x74, 0x06, 0xF0, 0x80, 0x0A, 
+0xEF, 0xB4, 0x04, 0x06, 0x90, 0xA2, 0xD7, 0x74, 0x07, 0xF0, 0x90, 0xA2, 0xCE, 0xE0, 0x60, 0x07, 
+0x90, 0xA2, 0xD6, 0xE0, 0x44, 0x04, 0xF0, 0x90, 0xA3, 0xA6, 0xE0, 0xB4, 0x01, 0x04, 0x7D, 0x06, 
+0x80, 0x09, 0x90, 0xA3, 0xA6, 0xE0, 0xB4, 0x04, 0x07, 0x7D, 0x0C, 0x7F, 0x6F, 0x12, 0x5B, 0x63, 
+0x90, 0xA2, 0xD3, 0x12, 0x5F, 0xB0, 0x30, 0xE0, 0x15, 0x71, 0xD9, 0x50, 0x0A, 0xEF, 0x7F, 0x00, 
+0x25, 0xE0, 0x25, 0xE0, 0xFE, 0x80, 0x04, 0x7F, 0xFF, 0x7E, 0x7F, 0x12, 0x5D, 0xCD, 0x90, 0xA2, 
+0xD2, 0xE0, 0x30, 0xE0, 0x03, 0x12, 0x57, 0xB4, 0x22, 0x90, 0xA2, 0xE6, 0xE0, 0xFF, 0xC3, 0x94, 
+0x20, 0x22, 0xE4, 0x90, 0xA2, 0xE4, 0xF0, 0x90, 0xA4, 0x8F, 0x22, 0xE4, 0x90, 0xA2, 0xD7, 0xF0, 
+0x90, 0xA2, 0xE2, 0x22, 0xF1, 0x2E, 0x90, 0xA2, 0xD3, 0xE0, 0xFF, 0x13, 0x13, 0x54, 0x3F, 0x22, 
+0x90, 0xA3, 0xA6, 0xEF, 0xF0, 0x90, 0xA3, 0xA8, 0x74, 0x02, 0xF0, 0x7F, 0x01, 0x71, 0xF4, 0x30, 
+0xE0, 0x21, 0x90, 0xA3, 0xA6, 0xE0, 0xB4, 0x02, 0x04, 0x7D, 0x07, 0x80, 0x09, 0x90, 0xA3, 0xA6, 
+0xE0, 0xB4, 0x05, 0x07, 0x7D, 0x0D, 0x7F, 0xFF, 0x12, 0x5B, 0x63, 0x12, 0x5E, 0x11, 0xBF, 0x01, 
+0x02, 0xB1, 0x8E, 0x90, 0xA2, 0xD3, 0x12, 0x4F, 0xF4, 0x30, 0xE0, 0x04, 0x7F, 0x03, 0x80, 0x02, 
+0x7F, 0x01, 0xB1, 0x54, 0x90, 0xA3, 0xA6, 0xE0, 0xB4, 0x02, 0x11, 0x90, 0xA2, 0xD0, 0xE0, 0x24, 
+0x03, 0xFF, 0x90, 0xA2, 0xDF, 0xE0, 0xC3, 0x9F, 0xFF, 0x12, 0x7C, 0xFE, 0x90, 0xA2, 0xCF, 0xE0, 
+0xC3, 0x13, 0x30, 0xE0, 0x07, 0xE4, 0x90, 0xA3, 0xA7, 0xF0, 0x80, 0x06, 0x90, 0xA3, 0xA7, 0x74, 
+0x01, 0xF0, 0xF1, 0xD1, 0x20, 0xE0, 0x13, 0x90, 0xA3, 0x10, 0xE0, 0x60, 0x08, 0x90, 0xA3, 0xA8, 
+0x74, 0x01, 0xF0, 0x80, 0x05, 0xE4, 0x90, 0xA3, 0xA8, 0xF0, 0x90, 0xA3, 0xA8, 0xE0, 0xFF, 0x90, 
+0xA3, 0xA7, 0xE0, 0xFD, 0x12, 0x54, 0x2B, 0xE4, 0x90, 0xA2, 0xE1, 0xF0, 0x90, 0xA3, 0xA6, 0xE0, 
+0xFF, 0xB4, 0x02, 0x08, 0x90, 0xA2, 0xE2, 0xE0, 0x04, 0xF0, 0x80, 0x09, 0xEF, 0xB4, 0x05, 0x05, 
+0xE4, 0x90, 0xA2, 0xE2, 0xF0, 0xF1, 0x95, 0x30, 0xE0, 0x17, 0x90, 0xA3, 0xA6, 0xE0, 0xB4, 0x02, 
+0x04, 0x7D, 0x08, 0x80, 0x53, 0x90, 0xA3, 0xA6, 0xE0, 0x64, 0x05, 0x70, 0x50, 0x7D, 0x0E, 0x80, 
+0x47, 0x90, 0xA2, 0xCF, 0xE0, 0xC4, 0x54, 0x0F, 0x30, 0xE0, 0x21, 0x12, 0x57, 0xE6, 0x54, 0x07, 
+0x20, 0xE0, 0x02, 0xB1, 0x4A, 0x90, 0xA3, 0xA6, 0xE0, 0xB4, 0x02, 0x04, 0x7D, 0x09, 0x80, 0x28, 
+0x90, 0xA3, 0xA6, 0xE0, 0x64, 0x05, 0x70, 0x25, 0x7D, 0x0F, 0x80, 0x1C, 0x90, 0xA2, 0x87, 0xE0, 
+0x60, 0x1B, 0xB1, 0x4A, 0x90, 0xA3, 0xA6, 0xE0, 0xB4, 0x02, 0x04, 0x7D, 0x0A, 0x80, 0x09, 0x90, 
+0xA3, 0xA6, 0xE0, 0xB4, 0x05, 0x07, 0x7D, 0x10, 0x7F, 0x6F, 0x12, 0x5B, 0x63, 0x90, 0xA2, 0xD2, 
+0xE0, 0x30, 0xE0, 0x03, 0x12, 0x57, 0xB4, 0x12, 0x4F, 0xF1, 0x30, 0xE0, 0x05, 0xE4, 0xFF, 0x12, 
+0x57, 0x0D, 0x90, 0xA2, 0xD3, 0xE0, 0xC3, 0x13, 0x30, 0xE0, 0x0E, 0x90, 0x06, 0xCD, 0xE0, 0x54, 
+0xEF, 0xF0, 0x90, 0x06, 0xCF, 0xE0, 0x54, 0xEF, 0xF0, 0x22, 0x90, 0xA2, 0x89, 0xE0, 0xFF, 0xE4, 
+0xFD, 0x02, 0x59, 0x80, 0x90, 0xA2, 0xF4, 0x12, 0x5F, 0xB0, 0x30, 0xE0, 0x07, 0x90, 0x07, 0x78, 
+0x74, 0x09, 0xF0, 0x22, 0x90, 0xA3, 0x2F, 0xE0, 0x30, 0xE0, 0x1D, 0xEF, 0x24, 0xFD, 0x60, 0x0E, 
+0x24, 0xFA, 0x60, 0x0E, 0x24, 0xFC, 0x60, 0x0E, 0x24, 0x0C, 0x7F, 0x02, 0x80, 0x0A, 0x7F, 0x03, 
+0x80, 0x06, 0x7F, 0x0B, 0x80, 0x02, 0x7F, 0x0E, 0x90, 0x07, 0x78, 0xEF, 0xF0, 0x22, 0xD3, 0x10, 
+0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x12, 0x5E, 0x11, 0x7F, 0x00, 0x7E, 0x0C, 0x12, 0x54, 0xB9, 0x12, 
+0xB3, 0x95, 0x12, 0x54, 0xB9, 0x12, 0x8F, 0xD2, 0xD1, 0x6D, 0xD1, 0x61, 0xD1, 0x61, 0x12, 0xB4, 
+0x57, 0x44, 0x40, 0x12, 0x54, 0xBF, 0x12, 0x8F, 0xCB, 0x90, 0x01, 0x00, 0x74, 0x3F, 0xF0, 0xA3, 
+0xE0, 0x54, 0xFD, 0xF0, 0x90, 0x05, 0x53, 0xE0, 0x44, 0x20, 0x12, 0x77, 0xB7, 0x90, 0xA2, 0x95, 
+0x12, 0x27, 0x48, 0x90, 0xAC, 0xB9, 0x12, 0x27, 0x54, 0x77, 0x77, 0x77, 0x77, 0xD1, 0x56, 0x12, 
+0x27, 0x54, 0x77, 0x77, 0x77, 0x77, 0x12, 0x8F, 0xD9, 0x90, 0xA2, 0xCD, 0x12, 0x5F, 0xB0, 0x30, 
+0xE0, 0x04, 0x7F, 0x01, 0xB1, 0x54, 0x12, 0x8F, 0xBD, 0x13, 0x30, 0xE0, 0x32, 0x90, 0xA3, 0x10, 
+0xE0, 0x60, 0x08, 0x90, 0xA4, 0x23, 0x74, 0x01, 0xF0, 0x80, 0x05, 0xE4, 0x90, 0xA4, 0x23, 0xF0, 
+0xEF, 0xC4, 0x13, 0x54, 0x07, 0x30, 0xE0, 0x07, 0xE4, 0x90, 0xA4, 0x24, 0xF0, 0x80, 0x06, 0x90, 
+0xA4, 0x24, 0x74, 0x02, 0xF0, 0x90, 0xA4, 0x23, 0x12, 0x54, 0x26, 0x7F, 0x01, 0xB1, 0x54, 0x90, 
+0xA2, 0xCC, 0xE0, 0x60, 0x02, 0xE4, 0xF0, 0x90, 0x00, 0xFF, 0xE0, 0x70, 0x14, 0x7B, 0x01, 0x7A, 
+0xA4, 0x79, 0x1E, 0x7D, 0x08, 0x7F, 0x01, 0xD1, 0xA1, 0x90, 0xA4, 0x1E, 0xE0, 0x44, 0x18, 0xD1, 
+0xE5, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x7F, 0xB0, 0x7E, 0x0C, 0x12, 0x37, 0x5D, 0x90, 0xAC, 0xB9, 
+0x22, 0x90, 0x00, 0x02, 0xE0, 0x44, 0x01, 0xFD, 0x7F, 0x02, 0x12, 0x3A, 0x96, 0x90, 0x00, 0x02, 
+0xE0, 0x54, 0xFE, 0xFD, 0x7F, 0x02, 0x02, 0x3A, 0x96, 0x12, 0x8F, 0xBD, 0x13, 0x30, 0xE0, 0x20, 
+0xEF, 0x13, 0x13, 0x13, 0x54, 0x1F, 0x20, 0xE0, 0x17, 0x51, 0xB3, 0x30, 0xE0, 0x04, 0x7F, 0x03, 
+0x80, 0x0C, 0x12, 0x9C, 0xC4, 0x30, 0xE0, 0x04, 0x7F, 0x0D, 0x80, 0x02, 0x7F, 0x09, 0xB1, 0x54, 
+0x22, 0x90, 0xA4, 0x4E, 0x12, 0x4A, 0x3F, 0xEF, 0x70, 0x07, 0x90, 0xA4, 0x51, 0x04, 0xF0, 0x80, 
+0x0B, 0xEF, 0x64, 0x01, 0x70, 0x25, 0x90, 0xA4, 0x51, 0x74, 0x40, 0xF0, 0x7F, 0xE2, 0x12, 0x3A, 
+0x96, 0x90, 0xA4, 0x51, 0xE0, 0xF1, 0x28, 0x90, 0x00, 0xE1, 0xE0, 0xFF, 0x90, 0xA4, 0x4E, 0x12, 
+0x4A, 0x36, 0xEF, 0x12, 0x26, 0x64, 0xF1, 0x27, 0x7F, 0x01, 0x22, 0x90, 0x01, 0xC2, 0xE0, 0x44, 
+0x01, 0xF0, 0x7F, 0x00, 0x22, 0xFB, 0x7D, 0x08, 0x7F, 0x01, 0x90, 0xA4, 0x7E, 0xEB, 0xF0, 0xEF, 
+0x70, 0x06, 0xA3, 0x74, 0x03, 0xF0, 0x80, 0x0B, 0xEF, 0x64, 0x01, 0x70, 0x28, 0x90, 0xA4, 0x7F, 
+0x74, 0x42, 0xF0, 0x7F, 0xE2, 0x12, 0x3A, 0x96, 0x90, 0xA4, 0x7E, 0xE0, 0xFD, 0x7F, 0xE0, 0x12, 
+0x3A, 0x96, 0x90, 0xA4, 0x7F, 0xE0, 0xF1, 0x28, 0x90, 0xA4, 0x7F, 0xE0, 0x54, 0xFD, 0xF1, 0x28, 
+0xF1, 0x27, 0x7F, 0x01, 0x22, 0x80, 0xB4, 0xE4, 0xFD, 0x7F, 0xE3, 0x02, 0x3A, 0x96, 0xD3, 0x10, 
+0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0xEF, 0xB4, 0x03, 0x10, 0x90, 0xA2, 0xD2, 0x12, 0x5F, 0xF0, 0x90, 
+0x06, 0xCC, 0x30, 0xE0, 0x35, 0xE4, 0xF0, 0x80, 0x34, 0x90, 0xA2, 0xD3, 0xE0, 0xC4, 0x54, 0x0F, 
+0x30, 0xE0, 0x0C, 0xEF, 0x90, 0x06, 0xCC, 0x70, 0x03, 0xF0, 0x80, 0x03, 0x74, 0x03, 0xF0, 0x90, 
+0xA3, 0x1D, 0xE0, 0x30, 0xE0, 0x17, 0xC4, 0x54, 0x0F, 0x30, 0xE0, 0x0B, 0xEF, 0x90, 0x06, 0xCC, 
+0x70, 0x03, 0xF0, 0x80, 0x08, 0x80, 0x03, 0x90, 0x06, 0xCC, 0x74, 0x03, 0xF0, 0xD0, 0xD0, 0x92, 
+0xAF, 0x22, 0x90, 0xA3, 0x31, 0xE0, 0x30, 0xE0, 0x0B, 0x12, 0x86, 0xED, 0xE4, 0x90, 0xA3, 0x33, 
+0xF0, 0x12, 0x7C, 0xA2, 0x22, 0x90, 0xA2, 0xCF, 0xE0, 0xC4, 0x13, 0x54, 0x07, 0x22, 0x90, 0xA2, 
+0xCF, 0xE0, 0x20, 0xE0, 0x21, 0x90, 0xA2, 0x87, 0xE0, 0x64, 0x01, 0x70, 0x19, 0xD1, 0x79, 0x90, 
+0xA2, 0x85, 0xE0, 0x54, 0x0F, 0x60, 0x06, 0x12, 0x5B, 0x5A, 0x02, 0xA6, 0x24, 0x90, 0xA2, 0x8A, 
+0xE0, 0x70, 0x03, 0x12, 0x59, 0x7C, 0x22, 0x02, 0x7A, 0xE7, 0xE0, 0xFF, 0xC4, 0x13, 0x54, 0x07, 
+0x22, 0x90, 0xA2, 0xD2, 0xE0, 0xC4, 0x13, 0x54, 0x07, 0x22, 0x90, 0xA2, 0xD5, 0xE0, 0x54, 0xDF, 
+0xF0, 0xE4, 0x22, 0xC0, 0xE0, 0xC0, 0x83, 0xC0, 0x82, 0xC0, 0xD0, 0x75, 0xD0, 0x00, 0xC0, 0x05, 
+0xC0, 0x07, 0x7D, 0xE3, 0x90, 0x01, 0xC4, 0xED, 0xF0, 0x74, 0x97, 0xFF, 0xA3, 0xF0, 0xED, 0x04, 
+0x90, 0x01, 0xC4, 0xF0, 0xA3, 0xEF, 0xF0, 0xD0, 0x07, 0xD0, 0x05, 0xD0, 0xD0, 0xD0, 0x82, 0xD0, 
+0x83, 0xD0, 0xE0, 0x32, 0x90, 0x02, 0x09, 0x11, 0x4F, 0x90, 0xA1, 0x7D, 0x12, 0x51, 0x7B, 0x25, 
+0x0D, 0x90, 0xA1, 0x7E, 0x12, 0x4F, 0xD0, 0x25, 0x0D, 0x90, 0xA1, 0x7F, 0xF0, 0x12, 0x4F, 0xDE, 
+0x25, 0x0D, 0x90, 0xA1, 0x80, 0x12, 0x54, 0x1F, 0x25, 0x0D, 0x90, 0xA1, 0x81, 0x12, 0x76, 0xC6, 
+0x25, 0x0D, 0x90, 0xA1, 0x82, 0x12, 0x86, 0xD1, 0x25, 0x0D, 0x90, 0xA1, 0x83, 0xF0, 0x22, 0xE0, 
+0xF5, 0x0D, 0x12, 0x26, 0x1E, 0x25, 0x0D, 0x22, 0x90, 0x04, 0x24, 0x11, 0x4F, 0x90, 0xA3, 0x40, 
+0x12, 0x51, 0x7B, 0x25, 0x0D, 0x90, 0xA3, 0x4E, 0x12, 0x4F, 0xD0, 0x25, 0x0D, 0x90, 0xA3, 0x5C, 
+0xF0, 0x22, 0x8B, 0x0D, 0x8A, 0x0E, 0x89, 0x0F, 0x12, 0x51, 0x7C, 0xFF, 0xF5, 0x11, 0x12, 0x26, 
+0x1E, 0xFE, 0xC3, 0x13, 0x30, 0xE0, 0x07, 0x12, 0x4F, 0xD1, 0xF5, 0x12, 0x80, 0x02, 0x8F, 0x12, 
+0x85, 0x11, 0x10, 0xE5, 0x10, 0xD3, 0x95, 0x12, 0x50, 0x23, 0x12, 0x82, 0x15, 0x12, 0x26, 0x1E, 
+0x54, 0x01, 0xFD, 0xAF, 0x10, 0x11, 0xD2, 0xAF, 0x10, 0x12, 0x77, 0xC7, 0xEF, 0xAF, 0x10, 0x70, 
+0x05, 0x12, 0x77, 0xB0, 0x80, 0x03, 0x12, 0x77, 0x92, 0x05, 0x10, 0x80, 0xD6, 0xE5, 0x11, 0x70, 
+0x10, 0xFF, 0x12, 0x77, 0xC7, 0xEF, 0x70, 0x09, 0x12, 0x8E, 0xA6, 0x54, 0xBF, 0xF0, 0x54, 0x7F, 
+0xF0, 0x22, 0x31, 0x70, 0xED, 0x70, 0x12, 0x31, 0x0D, 0xC0, 0x83, 0xC0, 0x82, 0x31, 0x05, 0x80, 
+0x02, 0xC3, 0x33, 0xD8, 0xFC, 0xF4, 0x5E, 0x80, 0x0F, 0x31, 0x0D, 0xC0, 0x83, 0xC0, 0x82, 0x31, 
+0x05, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0x4E, 0xD0, 0x82, 0xD0, 0x83, 0xF0, 0x31, 0x18, 0x90, 
+0xA2, 0x81, 0xEF, 0xF0, 0x22, 0xE0, 0xFE, 0x74, 0x01, 0xA8, 0x07, 0x08, 0x22, 0x74, 0x71, 0x2E, 
+0xF5, 0x82, 0xE4, 0x34, 0xA2, 0xF5, 0x83, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x7D, 
+0x10, 0xED, 0x14, 0xF9, 0x24, 0x71, 0x31, 0x10, 0xE0, 0x60, 0x37, 0x7C, 0x08, 0xEC, 0x14, 0x90, 
+0xA4, 0x8B, 0xF0, 0x74, 0x71, 0x29, 0x31, 0x10, 0xE0, 0xFB, 0x7A, 0x00, 0x90, 0xA4, 0x8B, 0xE0, 
+0x12, 0x6F, 0x92, 0x80, 0x05, 0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 0xF9, 0x12, 0x8F, 0xE0, 0x60, 
+0x0F, 0xE9, 0x75, 0xF0, 0x08, 0xA4, 0xFF, 0x90, 0xA4, 0x8B, 0xE0, 0x2F, 0x04, 0xFF, 0x80, 0x06, 
+0xDC, 0xCB, 0xDD, 0xBD, 0x7F, 0x00, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xE4, 0xFD, 0xFF, 0x01, 0xD2, 
+0xEF, 0x13, 0x13, 0x13, 0x54, 0x1F, 0xFE, 0xEF, 0x54, 0x07, 0xFF, 0x22, 0xD3, 0x10, 0xAF, 0x01, 
+0xC3, 0xC0, 0xD0, 0x31, 0xAF, 0xFF, 0x90, 0xA2, 0x82, 0xF0, 0xBF, 0x01, 0x0D, 0x12, 0x51, 0x7C, 
+0x64, 0x01, 0x60, 0x16, 0x7D, 0x13, 0x7F, 0x6F, 0x80, 0x0D, 0x12, 0x82, 0x15, 0x12, 0x51, 0x7C, 
+0x64, 0x01, 0x60, 0x06, 0xE4, 0xFD, 0xFF, 0x12, 0x5B, 0x63, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x8B, 
+0x0D, 0x8A, 0x0E, 0x89, 0x0F, 0x02, 0x26, 0x1E, 0x12, 0x26, 0x1E, 0xFF, 0x90, 0xA2, 0x70, 0xF0, 
+0xBF, 0x01, 0x07, 0x31, 0xCB, 0xE4, 0x90, 0xA2, 0x70, 0xF0, 0x22, 0x7B, 0x01, 0x7A, 0xA3, 0x79, 
+0x79, 0x7F, 0xF5, 0x7E, 0x03, 0x12, 0x33, 0xC7, 0xBF, 0x01, 0x06, 0x90, 0xA3, 0x79, 0xE0, 0xA3, 
+0xF0, 0x7B, 0x01, 0x7A, 0xA3, 0x79, 0x79, 0x7F, 0xF6, 0x7E, 0x03, 0x12, 0x33, 0xC7, 0xBF, 0x01, 
+0x08, 0x90, 0xA3, 0x79, 0xE0, 0x90, 0xA3, 0x7B, 0xF0, 0x7B, 0x01, 0x7A, 0xA3, 0x79, 0x79, 0x7F, 
+0xF4, 0x7E, 0x03, 0x12, 0x33, 0xC7, 0xBF, 0x01, 0x08, 0x90, 0xA3, 0x79, 0xE0, 0x90, 0xA3, 0x7C, 
+0xF0, 0x7B, 0x01, 0x7A, 0xA3, 0x79, 0x79, 0x7F, 0xF3, 0x7E, 0x03, 0x12, 0x33, 0xC7, 0xBF, 0x01, 
+0x08, 0x90, 0xA3, 0x79, 0xE0, 0x90, 0xA3, 0x7D, 0xF0, 0x7B, 0x01, 0x7A, 0xA3, 0x79, 0x79, 0x7F, 
+0xF2, 0x7E, 0x03, 0x12, 0x33, 0xC7, 0xBF, 0x01, 0x08, 0x90, 0xA3, 0x79, 0xE0, 0x90, 0xA3, 0x7E, 
+0xF0, 0x90, 0xA3, 0x7A, 0x51, 0x84, 0xA3, 0xE0, 0x90, 0xA3, 0x82, 0xF0, 0x90, 0xA3, 0x7E, 0xE0, 
+0x90, 0xA3, 0x83, 0xF0, 0x90, 0xA3, 0x84, 0x74, 0x12, 0xF0, 0x90, 0xA3, 0x92, 0x74, 0x05, 0xF0, 
+0x90, 0xA3, 0x86, 0x12, 0x5F, 0xE4, 0x90, 0xA3, 0x82, 0xE0, 0x90, 0xA3, 0x89, 0xF0, 0x90, 0xA3, 
+0x83, 0xE0, 0x90, 0xA3, 0x8A, 0xF0, 0x7B, 0x01, 0x7A, 0xA3, 0x79, 0x84, 0x12, 0x8C, 0xD3, 0x7F, 
+0x04, 0x02, 0x8C, 0xB8, 0xE0, 0xFF, 0xA3, 0xE0, 0xFD, 0xA3, 0xE0, 0xFB, 0x22, 0x12, 0x26, 0x1E, 
+0x54, 0x01, 0xFF, 0x90, 0xA3, 0x69, 0xE0, 0x54, 0xFE, 0x4F, 0xF0, 0x22, 0x12, 0x4F, 0xE9, 0xFF, 
+0x54, 0x7F, 0x90, 0xA2, 0x87, 0xF0, 0xEF, 0x12, 0x4F, 0xF5, 0xA3, 0x12, 0x51, 0x7B, 0xFF, 0x54, 
+0xF0, 0xC4, 0x54, 0x0F, 0xFE, 0x90, 0xA2, 0x85, 0xE0, 0x54, 0xF0, 0x4E, 0xF0, 0x12, 0x4F, 0xDE, 
+0x54, 0x01, 0x25, 0xE0, 0xFE, 0x90, 0xA2, 0x83, 0xE0, 0x54, 0xFD, 0x4E, 0xF0, 0xEF, 0x54, 0x0F, 
+0xC4, 0x54, 0xF0, 0xFF, 0x90, 0xA2, 0x85, 0xE0, 0x54, 0x0F, 0x12, 0x4F, 0xCF, 0x90, 0xA2, 0x86, 
+0x12, 0x86, 0xD1, 0x30, 0xE0, 0x55, 0xC3, 0x13, 0x54, 0x07, 0xFF, 0xC3, 0x94, 0x04, 0x90, 0xA2, 
+0x9A, 0x50, 0x04, 0xEF, 0xF0, 0x80, 0x2B, 0x74, 0x03, 0xF0, 0x12, 0x4F, 0xE4, 0xE9, 0x24, 0x06, 
+0xF9, 0xE4, 0x3A, 0xFA, 0x12, 0x26, 0x1E, 0xFF, 0x74, 0x03, 0x24, 0xFD, 0xFE, 0xEF, 0xC4, 0x54, 
+0x0F, 0xFD, 0xEF, 0x54, 0x0F, 0xFF, 0xED, 0x2E, 0x54, 0x0F, 0xFE, 0xC4, 0x54, 0xF0, 0x4F, 0x12, 
+0x26, 0x64, 0x12, 0x4F, 0xE4, 0x12, 0x86, 0xD2, 0xC4, 0x54, 0x0F, 0xFF, 0xC3, 0x94, 0x04, 0x90, 
+0xA2, 0x8F, 0x50, 0x05, 0x74, 0x04, 0xF0, 0x80, 0x02, 0xEF, 0xF0, 0x12, 0x4F, 0xE4, 0x12, 0x54, 
+0x20, 0xFD, 0x7F, 0x02, 0x12, 0x58, 0xF6, 0x12, 0x4F, 0xE4, 0x12, 0x76, 0xC7, 0xFF, 0x54, 0x01, 
+0xFE, 0x90, 0xA2, 0xCD, 0x12, 0x57, 0xC4, 0x12, 0x76, 0xC5, 0x12, 0x57, 0x5E, 0x90, 0xA2, 0xCD, 
+0x91, 0x00, 0x12, 0x76, 0xC4, 0x91, 0x09, 0x90, 0xA2, 0xCD, 0xF0, 0xEE, 0x54, 0x20, 0xFE, 0xEF, 
+0x54, 0xDF, 0x12, 0x76, 0xC4, 0x12, 0x57, 0x6A, 0x90, 0xA2, 0xCD, 0xF0, 0xE0, 0x12, 0x57, 0xF4, 
+0x20, 0xE0, 0x29, 0xEF, 0xC3, 0x13, 0x20, 0xE0, 0x0B, 0x75, 0x0E, 0x01, 0x90, 0xA3, 0x10, 0xE0, 
+0x60, 0x0B, 0x80, 0x0E, 0xE4, 0xF5, 0x0E, 0x90, 0xA3, 0x10, 0xE0, 0x60, 0x05, 0xE4, 0xF5, 0x0D, 
+0x80, 0x03, 0x75, 0x0D, 0x01, 0xAD, 0x0E, 0xAF, 0x0D, 0x12, 0x54, 0x2B, 0x12, 0x4F, 0xE4, 0x90, 
+0xA3, 0x7C, 0x12, 0x4A, 0x3F, 0x71, 0xD8, 0x90, 0xA2, 0x87, 0xE0, 0xFF, 0x12, 0x8E, 0x32, 0x90, 
+0xA2, 0x87, 0xE0, 0x60, 0x12, 0x90, 0xA3, 0x7C, 0x12, 0x4A, 0x36, 0x12, 0x51, 0x7C, 0x54, 0x0F, 
+0xFF, 0x12, 0x4F, 0xD1, 0xFD, 0x91, 0x1F, 0x22, 0x90, 0xA2, 0x83, 0xE0, 0x54, 0xFB, 0xF0, 0xE4, 
+0x90, 0xA2, 0x90, 0xF0, 0xA3, 0xF0, 0x90, 0xA2, 0x8B, 0xF0, 0x90, 0xA2, 0x84, 0xE0, 0x54, 0xF7, 
+0xF0, 0x54, 0xBF, 0xF0, 0x91, 0x13, 0x12, 0x87, 0xCE, 0x7D, 0x10, 0x7F, 0x03, 0x02, 0x86, 0xF1, 
+0xF0, 0xEE, 0x54, 0x08, 0xFE, 0xEF, 0x54, 0xF7, 0x22, 0xFE, 0x54, 0x10, 0xFD, 0xEF, 0x54, 0xEF, 
+0x4D, 0xFF, 0x22, 0x7D, 0x01, 0x7F, 0x02, 0x12, 0x87, 0xCE, 0x7D, 0x02, 0x7F, 0x02, 0x22, 0xEF, 
+0x24, 0xFE, 0x60, 0x0B, 0x04, 0x70, 0x24, 0x90, 0xA2, 0x8D, 0x74, 0x02, 0xF0, 0x80, 0x13, 0xED, 
+0x70, 0x06, 0x90, 0xA2, 0xCB, 0xE0, 0x80, 0x02, 0xED, 0x14, 0x90, 0xA2, 0x8D, 0xF0, 0x90, 0xA2, 
+0x8D, 0xE0, 0xA3, 0xF0, 0x90, 0xA2, 0x84, 0xE0, 0x44, 0x08, 0xF0, 0x22, 0x12, 0x4F, 0xD1, 0xFF, 
+0x30, 0xE0, 0x1F, 0x12, 0x26, 0x1E, 0x90, 0xA2, 0xC8, 0x12, 0x51, 0x7B, 0x90, 0xA2, 0xC9, 0xF0, 
+0xEF, 0x54, 0xFE, 0xFF, 0xA3, 0xE0, 0x54, 0x01, 0x4F, 0xF0, 0x12, 0x4F, 0xDE, 0x90, 0xA2, 0xCB, 
+0xF0, 0x22, 0x90, 0xA2, 0xC8, 0x74, 0x02, 0xF0, 0xA3, 0x74, 0x0F, 0xF0, 0xA3, 0xE0, 0x54, 0x01, 
+0x44, 0x1E, 0xF0, 0xA3, 0x74, 0x07, 0xF0, 0x22, 0x12, 0x26, 0x1E, 0x90, 0xA2, 0x92, 0xF0, 0x22, 
+0x12, 0x26, 0x1E, 0x90, 0xA2, 0xCE, 0xF0, 0x60, 0x2A, 0xA3, 0xE0, 0x20, 0xE0, 0x25, 0xE4, 0xFD, 
+0x7F, 0x04, 0x12, 0x59, 0x80, 0x12, 0x8F, 0xBD, 0x13, 0x30, 0xE0, 0x17, 0xEF, 0x13, 0x13, 0x13, 
+0x54, 0x1F, 0x20, 0xE0, 0x0E, 0x91, 0xC4, 0x30, 0xE0, 0x04, 0x7F, 0x0D, 0x80, 0x02, 0x7F, 0x09, 
+0x12, 0x95, 0x54, 0x22, 0x90, 0xA2, 0xCD, 0xE0, 0x13, 0x13, 0x54, 0x3F, 0x22, 0x90, 0xA3, 0x79, 
+0x12, 0x4A, 0x3F, 0x90, 0xA4, 0x6A, 0xE0, 0x70, 0x08, 0xB1, 0x21, 0x90, 0xA4, 0x6A, 0x74, 0x01, 
+0xF0, 0x12, 0x4F, 0xE4, 0x12, 0x26, 0x1E, 0xFF, 0xE4, 0x8F, 0x10, 0xF5, 0x0F, 0xF5, 0x0E, 0xF5, 
+0x0D, 0x90, 0xA3, 0x08, 0x12, 0x4A, 0x12, 0xEC, 0x54, 0xC1, 0xFC, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 
+0x06, 0xC0, 0x07, 0xAF, 0x10, 0xAE, 0x0F, 0xAD, 0x0E, 0xAC, 0x0D, 0x78, 0x19, 0x12, 0x27, 0x35, 
+0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0x12, 0x4A, 0x05, 0x90, 0xA3, 0x04, 0x02, 0x27, 
+0x48, 0x7F, 0x58, 0x7E, 0x0C, 0x12, 0x36, 0xCE, 0x90, 0xA3, 0x08, 0x02, 0x27, 0x48, 0x7E, 0x00, 
+0x7F, 0x19, 0x7D, 0x00, 0x7B, 0x01, 0x7A, 0xA3, 0x79, 0x01, 0x12, 0x4A, 0x6E, 0xB1, 0x21, 0x90, 
+0xA3, 0x08, 0x12, 0x4A, 0x12, 0x90, 0xA3, 0x04, 0x12, 0x27, 0x48, 0x90, 0xA1, 0x7C, 0xE0, 0xFF, 
+0x64, 0x02, 0x70, 0x22, 0xD1, 0x48, 0x30, 0xE0, 0x02, 0x7E, 0x01, 0x90, 0xA3, 0x10, 0xEE, 0xF0, 
+0xD1, 0x48, 0x30, 0xE1, 0x02, 0x7E, 0x01, 0x90, 0xA3, 0x11, 0xEE, 0xF0, 0x90, 0xFD, 0x80, 0xE0, 
+0x90, 0x02, 0xFB, 0xF0, 0x80, 0x3A, 0xEF, 0x64, 0x01, 0x70, 0x15, 0xB1, 0xE1, 0x30, 0xE0, 0x02, 
+0x7F, 0x01, 0x90, 0xA3, 0x10, 0xEF, 0xF0, 0xB1, 0xE1, 0x30, 0xE1, 0x02, 0x7F, 0x01, 0x80, 0x1B, 
+0x90, 0xA1, 0x7C, 0xE0, 0x64, 0x03, 0x70, 0x18, 0xB1, 0xDA, 0x30, 0xE0, 0x02, 0x7F, 0x01, 0x90, 
+0xA3, 0x10, 0xEF, 0xF0, 0xB1, 0xDA, 0x30, 0xE1, 0x02, 0x7F, 0x01, 0x90, 0xA3, 0x11, 0xEF, 0xF0, 
+0x90, 0xFD, 0x68, 0xE0, 0x44, 0x02, 0xF0, 0x7F, 0x01, 0x12, 0x95, 0x54, 0xB1, 0xE8, 0xD1, 0x57, 
+0x90, 0xA2, 0xE8, 0x74, 0x01, 0xF0, 0x90, 0xA3, 0x1D, 0xE0, 0x54, 0xFE, 0xF0, 0x90, 0x04, 0x8F, 
+0xE4, 0xF0, 0x90, 0xA3, 0x2F, 0xE0, 0x54, 0xFE, 0xF0, 0x22, 0x90, 0xFD, 0x78, 0xE0, 0x7F, 0x00, 
+0x22, 0x90, 0xFD, 0x70, 0xE0, 0x7F, 0x00, 0x22, 0x7E, 0x00, 0x7F, 0x32, 0x7D, 0x00, 0x7B, 0x01, 
+0x7A, 0xA2, 0x79, 0xCF, 0x12, 0x4A, 0x6E, 0x90, 0xA2, 0xD0, 0x74, 0x0B, 0xF0, 0xA3, 0x74, 0x08, 
+0xF0, 0x90, 0xA1, 0x7C, 0xE0, 0xFC, 0x64, 0x02, 0x70, 0x14, 0xD1, 0x48, 0x30, 0xE2, 0x02, 0x7E, 
+0x01, 0xEE, 0xD1, 0x4F, 0xFE, 0x90, 0xA2, 0xD2, 0xE0, 0x54, 0xBF, 0x4E, 0xF0, 0x22, 0xEC, 0x64, 
+0x01, 0x70, 0x09, 0xB1, 0xE1, 0x30, 0xE2, 0x02, 0x7F, 0x01, 0x80, 0x0F, 0x90, 0xA1, 0x7C, 0xE0, 
+0x64, 0x03, 0x70, 0x13, 0xB1, 0xDA, 0x30, 0xE2, 0x02, 0x7F, 0x01, 0xEF, 0xD1, 0x4F, 0xFF, 0x90, 
+0xA2, 0xD2, 0xE0, 0x54, 0xBF, 0x4F, 0xF0, 0x22, 0x90, 0xFD, 0x80, 0xE0, 0x7E, 0x00, 0x22, 0x54, 
+0x01, 0xC4, 0x33, 0x33, 0x54, 0xC0, 0x22, 0x7E, 0x00, 0x7F, 0x0A, 0x7D, 0x00, 0x7B, 0x01, 0x7A, 
+0xA2, 0x79, 0xF7, 0x12, 0x4A, 0x6E, 0x90, 0xA2, 0xE3, 0x74, 0x02, 0xF0, 0x22, 0x12, 0x26, 0x1E, 
+0x90, 0xA3, 0x10, 0x12, 0x51, 0x7B, 0x90, 0xA3, 0x11, 0xF0, 0x22, 0x12, 0x26, 0x1E, 0x54, 0x01, 
+0xD1, 0xE1, 0x54, 0xFD, 0x4F, 0xF0, 0xE0, 0xC3, 0x13, 0xFF, 0x54, 0x01, 0x90, 0x01, 0xE6, 0xF0, 
+0xA3, 0xE0, 0x54, 0xFE, 0xF0, 0xEF, 0x30, 0xE0, 0x40, 0x90, 0x00, 0xA3, 0xE0, 0x54, 0xF8, 0x44, 
+0x05, 0xFD, 0x7F, 0xA3, 0x12, 0x3A, 0x96, 0x90, 0x00, 0xA0, 0xE0, 0x54, 0x0F, 0x64, 0x04, 0x70, 
+0x20, 0x90, 0xA3, 0x17, 0xE0, 0x30, 0xE0, 0x02, 0x80, 0x1F, 0x90, 0xFD, 0x62, 0xE0, 0xB4, 0xAD, 
+0x0E, 0xA3, 0xE0, 0xB4, 0x35, 0x09, 0xD1, 0xD9, 0x90, 0x01, 0xE5, 0x74, 0xDF, 0xF0, 0x22, 0x80, 
+0x00, 0x90, 0x01, 0xE7, 0xE0, 0x44, 0x01, 0xF0, 0x22, 0x90, 0x01, 0xE7, 0xE0, 0x54, 0xFE, 0xF0, 
+0x22, 0x25, 0xE0, 0xFF, 0x90, 0xA2, 0xF4, 0xE0, 0x22, 0x12, 0x26, 0x1E, 0x54, 0x01, 0x25, 0xE0, 
+0xD1, 0xE1, 0x54, 0xFB, 0x4F, 0xF0, 0xE0, 0x13, 0x13, 0x54, 0x3F, 0x30, 0xE0, 0x08, 0x90, 0x07, 
+0x65, 0xE0, 0x44, 0x18, 0xF0, 0x22, 0x90, 0xA3, 0x17, 0xE0, 0x20, 0xE0, 0x07, 0x90, 0x07, 0x65, 
+0xE0, 0x54, 0xE7, 0xF0, 0x22, 0x12, 0x26, 0x1E, 0x54, 0x01, 0x33, 0x33, 0x33, 0x54, 0xF8, 0xFF, 
+0x90, 0xA2, 0xF4, 0xE0, 0x54, 0xF7, 0x4F, 0xF0, 0x12, 0x5F, 0xB0, 0x90, 0x07, 0x65, 0x30, 0xE0, 
+0x04, 0x74, 0x18, 0xF0, 0x22, 0xE4, 0xF0, 0x22, 0x12, 0x26, 0x1E, 0x54, 0x01, 0xFF, 0x90, 0xA3, 
+0x2F, 0xE0, 0x54, 0xFE, 0x4F, 0xF0, 0x30, 0xE0, 0x55, 0x90, 0x00, 0x40, 0xE0, 0x54, 0xBF, 0x44, 
+0xA0, 0xFD, 0x7F, 0x40, 0x12, 0x3A, 0x96, 0x90, 0x00, 0x41, 0xE0, 0x44, 0x04, 0xFD, 0x7F, 0x41, 
+0x12, 0x3A, 0x96, 0x90, 0x00, 0x6A, 0xE0, 0x54, 0xFB, 0xFD, 0x7F, 0x6A, 0x12, 0x3A, 0x96, 0x90, 
+0x07, 0x6E, 0x74, 0x55, 0xF0, 0xA3, 0x74, 0x12, 0xF0, 0x90, 0x07, 0x78, 0xE0, 0x54, 0xF2, 0x44, 
+0x02, 0xF0, 0x90, 0x06, 0xCC, 0xE0, 0x44, 0x03, 0xF0, 0x90, 0x07, 0x65, 0xE0, 0x54, 0xF5, 0xF0, 
+0x90, 0x05, 0x23, 0xE0, 0x54, 0x7F, 0xF0, 0xE4, 0xFD, 0x7F, 0x66, 0x12, 0x3A, 0x96, 0x22, 0xE4, 
+0x90, 0xA2, 0x6C, 0xF0, 0xA3, 0xF0, 0x90, 0xA1, 0xD4, 0xF0, 0xA3, 0xF0, 0x22, 0x90, 0xA4, 0x46, 
+0xEF, 0xF0, 0xA3, 0x12, 0x4A, 0x3F, 0x90, 0xA4, 0x6C, 0xE0, 0xFE, 0x04, 0xF0, 0x90, 0x00, 0x01, 
+0xEE, 0x12, 0x26, 0x76, 0x74, 0x00, 0x2F, 0xF9, 0xE4, 0x34, 0xFB, 0xFA, 0x7B, 0x01, 0xC0, 0x03, 
+0xC0, 0x02, 0xC0, 0x01, 0x90, 0xA4, 0x47, 0x12, 0x4A, 0x36, 0x8B, 0x40, 0x8A, 0x41, 0x89, 0x42, 
+0x75, 0x43, 0x02, 0xD0, 0x01, 0xD0, 0x02, 0xD0, 0x03, 0x12, 0x34, 0x2C, 0x90, 0xA4, 0x46, 0xE0, 
+0x24, 0x02, 0xF9, 0xE4, 0x34, 0xFB, 0xFA, 0x7B, 0x01, 0xC0, 0x03, 0xC0, 0x02, 0xC0, 0x01, 0xA3, 
+0x12, 0x4A, 0x36, 0xE9, 0x24, 0x02, 0xF9, 0xE4, 0x3A, 0x8B, 0x40, 0xF5, 0x41, 0x89, 0x42, 0x90, 
+0xA4, 0x47, 0x11, 0x1F, 0xF5, 0x43, 0xD0, 0x01, 0xD0, 0x02, 0xD0, 0x03, 0x02, 0x34, 0x2C, 0x12, 
+0x4A, 0x36, 0x90, 0x00, 0x0E, 0x02, 0x26, 0x37, 0x90, 0xA4, 0x6D, 0x12, 0x4A, 0x3F, 0xE4, 0xFF, 
+0x90, 0xA4, 0x6D, 0x12, 0x4A, 0x36, 0x8F, 0x82, 0x75, 0x83, 0x00, 0x12, 0x26, 0x37, 0xFE, 0x74, 
+0xF0, 0x2F, 0x11, 0x4C, 0xEE, 0xF0, 0x0F, 0xEF, 0xB4, 0x10, 0xE5, 0x22, 0xF5, 0x82, 0xE4, 0x34, 
+0x02, 0xF5, 0x83, 0x22, 0xE4, 0xF5, 0x55, 0xF5, 0x56, 0xF5, 0x57, 0x75, 0x58, 0x80, 0xAD, 0x55, 
+0x7F, 0x50, 0x12, 0x3A, 0x96, 0xAD, 0x56, 0x7F, 0x51, 0x12, 0x3A, 0x96, 0xAD, 0x57, 0x7F, 0x52, 
+0x12, 0x3A, 0x96, 0xAD, 0x58, 0x7F, 0x53, 0x02, 0x3A, 0x96, 0x75, 0x5D, 0x12, 0xE4, 0xF5, 0x5E, 
+0x75, 0x5F, 0x07, 0x75, 0x60, 0x72, 0x90, 0x01, 0x30, 0xE5, 0x5D, 0xF0, 0xA3, 0xE5, 0x5E, 0xF0, 
+0xA3, 0xE5, 0x5F, 0xF0, 0xA3, 0xE5, 0x60, 0xF0, 0x22, 0x75, 0x65, 0x0E, 0x75, 0x66, 0x01, 0x75, 
+0x67, 0x03, 0x75, 0x68, 0x62, 0x43, 0x65, 0x01, 0x90, 0x01, 0x38, 0xE5, 0x65, 0xF0, 0xA3, 0xE5, 
+0x66, 0xF0, 0xA3, 0xE5, 0x67, 0xF0, 0xA3, 0xE5, 0x68, 0xF0, 0x22, 0x90, 0x01, 0x94, 0xE0, 0x44, 
+0x01, 0xF0, 0x90, 0x01, 0xC7, 0xE4, 0xF0, 0x22, 0x90, 0x01, 0x01, 0xE0, 0x44, 0x04, 0xF0, 0x90, 
+0x01, 0x9C, 0x74, 0x7E, 0xF0, 0xA3, 0x74, 0x92, 0xF0, 0xA3, 0x74, 0xA0, 0xF0, 0xA3, 0x74, 0x24, 
+0xF0, 0x90, 0x01, 0x9B, 0x74, 0x49, 0xF0, 0x90, 0x01, 0x9A, 0x74, 0xE0, 0xF0, 0x90, 0x01, 0x99, 
+0xE4, 0xF0, 0x90, 0x01, 0x98, 0x04, 0xF0, 0x22, 0x7D, 0x02, 0x90, 0x01, 0xC4, 0x74, 0xF8, 0xF0, 
+0x74, 0xA0, 0xA3, 0xF0, 0x90, 0xA3, 0x30, 0xE0, 0xFF, 0xED, 0xC3, 0x9F, 0x50, 0x10, 0xED, 0x25, 
+0xE0, 0x24, 0x81, 0xF8, 0xE6, 0x30, 0xE4, 0x03, 0x7F, 0x00, 0x22, 0x0D, 0x80, 0xE6, 0x74, 0xF8, 
+0x04, 0x90, 0x01, 0xC4, 0xF0, 0x74, 0xA0, 0xA3, 0xF0, 0x7F, 0x01, 0x22, 0xE4, 0x90, 0xA1, 0x76, 
+0x12, 0x50, 0x66, 0xA3, 0xF0, 0x22, 0x90, 0x01, 0xE4, 0x74, 0x26, 0xF0, 0xA3, 0xE4, 0xF0, 0x22, 
+0x90, 0x01, 0x34, 0xE0, 0x55, 0x5D, 0xF5, 0x61, 0xA3, 0xE0, 0x55, 0x5E, 0xF5, 0x62, 0xA3, 0xE0, 
+0x55, 0x5F, 0xF5, 0x63, 0xA3, 0xE0, 0x55, 0x60, 0xF5, 0x64, 0x90, 0x01, 0x34, 0xE5, 0x61, 0xF0, 
+0xA3, 0xE5, 0x62, 0xF0, 0xA3, 0xE5, 0x63, 0xF0, 0xA3, 0xE5, 0x64, 0xF0, 0x22, 0x90, 0x01, 0x3C, 
+0xE0, 0x55, 0x65, 0xF5, 0x69, 0xA3, 0xE0, 0x55, 0x66, 0xF5, 0x6A, 0xA3, 0xE0, 0x55, 0x67, 0xF5, 
+0x6B, 0xA3, 0xE0, 0x55, 0x68, 0xF5, 0x6C, 0x90, 0x01, 0x3C, 0xE5, 0x69, 0xF0, 0xA3, 0xE5, 0x6A, 
+0xF0, 0xA3, 0xE5, 0x6B, 0xF0, 0xA3, 0xE5, 0x6C, 0xF0, 0x53, 0x91, 0xDF, 0x22, 0x90, 0x01, 0xCF, 
+0xE0, 0x90, 0xA3, 0x96, 0xF0, 0xE0, 0xFF, 0x30, 0xE0, 0x07, 0x90, 0x01, 0xCF, 0xE0, 0x54, 0xFE, 
+0xF0, 0xEF, 0x30, 0xE5, 0x23, 0x90, 0x01, 0xCF, 0xE0, 0x54, 0xDF, 0xF0, 0x90, 0x01, 0x34, 0x74, 
+0x20, 0xF0, 0xE4, 0xF5, 0xA8, 0xF5, 0xE8, 0x12, 0x50, 0x40, 0x90, 0x00, 0x03, 0xE0, 0x54, 0xFB, 
+0xFD, 0x7F, 0x03, 0x12, 0x3A, 0x96, 0x80, 0xFE, 0x22, 0x90, 0xA2, 0x8A, 0xE0, 0x64, 0x02, 0x60, 
+0x03, 0x12, 0x86, 0xF8, 0x22, 0x31, 0xF7, 0x70, 0x0D, 0x90, 0xA2, 0x87, 0xE0, 0x60, 0x07, 0x51, 
+0x1A, 0xB1, 0x74, 0x12, 0x7C, 0xC9, 0x22, 0xE4, 0xFF, 0x12, 0x77, 0xC7, 0xEF, 0x64, 0x01, 0x22, 
+0x31, 0xF7, 0x70, 0x15, 0x90, 0xA2, 0x87, 0xE0, 0x60, 0x0F, 0x51, 0x1A, 0x90, 0xA2, 0x83, 0xE0, 
+0x91, 0xF7, 0xF0, 0x54, 0x07, 0x70, 0x02, 0x91, 0xED, 0x22, 0x90, 0x01, 0x57, 0xE4, 0xF0, 0x90, 
+0x01, 0x3C, 0x74, 0x02, 0xF0, 0x22, 0xEF, 0x60, 0x2C, 0x31, 0xF7, 0x70, 0x28, 0x90, 0xA2, 0x84, 
+0xE0, 0x54, 0xFE, 0xF0, 0x7D, 0x2B, 0x7F, 0x0F, 0x12, 0x5B, 0x63, 0x90, 0x06, 0x04, 0xE0, 0x54, 
+0xBF, 0xF0, 0xB1, 0x6D, 0xBF, 0x01, 0x0E, 0x90, 0xA2, 0x83, 0xE0, 0x44, 0x40, 0xF0, 0x7D, 0x06, 
+0x7F, 0x01, 0x12, 0x58, 0xF6, 0x22, 0xE4, 0x90, 0xA3, 0xA6, 0xF0, 0x90, 0xA2, 0x87, 0xE0, 0x60, 
+0x2F, 0x31, 0xF7, 0x70, 0x2B, 0xD1, 0xF8, 0xF0, 0x51, 0x91, 0xE4, 0x90, 0xA2, 0x8E, 0xF0, 0x04, 
+0x60, 0x1E, 0x91, 0x71, 0xE4, 0x90, 0xA4, 0x29, 0xF0, 0x90, 0xA2, 0x8F, 0xE0, 0x90, 0xA4, 0x2A, 
+0x12, 0x7C, 0xC9, 0x90, 0xA2, 0x8A, 0xE0, 0x20, 0xE2, 0x03, 0x12, 0x59, 0x7C, 0x12, 0x96, 0x79, 
+0x22, 0x90, 0xA3, 0xA6, 0x74, 0x01, 0xF0, 0x22, 0xAD, 0x07, 0xED, 0x70, 0x19, 0x71, 0x1C, 0x70, 
+0x02, 0x80, 0x17, 0xBC, 0x01, 0x02, 0x80, 0x19, 0x71, 0x1C, 0xBC, 0x02, 0x02, 0x80, 0x1B, 0xEC, 
+0x64, 0x03, 0x70, 0x22, 0x80, 0x1B, 0x71, 0x24, 0x70, 0x04, 0x7F, 0x01, 0x80, 0x15, 0xBC, 0x01, 
+0x04, 0x7F, 0x03, 0x80, 0x0E, 0x71, 0x24, 0xBC, 0x02, 0x04, 0x7F, 0x09, 0x80, 0x05, 0xBC, 0x03, 
+0x05, 0x7F, 0x0D, 0x12, 0x95, 0x54, 0x90, 0xA3, 0x1D, 0xE0, 0xC4, 0x13, 0x54, 0x07, 0x30, 0xE0, 
+0x3A, 0xED, 0x70, 0x1B, 0xA3, 0xE0, 0x13, 0x13, 0x54, 0x3F, 0x30, 0xE0, 0x07, 0xE4, 0x90, 0xA3, 
+0xA6, 0xF0, 0x80, 0x02, 0x51, 0x91, 0x90, 0xA3, 0xA6, 0xE0, 0xFD, 0xE4, 0xFF, 0x80, 0x19, 0x90, 
+0xA3, 0x1E, 0x12, 0x5F, 0xF0, 0x30, 0xE0, 0x07, 0xE4, 0x90, 0xA3, 0xA6, 0xF0, 0x80, 0x02, 0x51, 
+0x91, 0x90, 0xA3, 0xA6, 0xE0, 0xFD, 0x7F, 0x01, 0x12, 0x54, 0x2B, 0x22, 0x90, 0xA3, 0x1E, 0xE0, 
+0x54, 0x03, 0xFC, 0x22, 0x90, 0xA3, 0x1E, 0xE0, 0xC4, 0x54, 0x03, 0xFC, 0x22, 0xD3, 0x10, 0xAF, 
+0x01, 0xC3, 0xC0, 0xD0, 0x90, 0xA3, 0x24, 0xE0, 0xB4, 0x01, 0x02, 0x80, 0x43, 0x90, 0xA3, 0x24, 
+0xE0, 0xB4, 0x02, 0x11, 0x71, 0xA2, 0x7F, 0x01, 0x12, 0x97, 0x2E, 0x51, 0x98, 0x90, 0xA3, 0x24, 
+0x74, 0x03, 0xF0, 0x80, 0x3E, 0x90, 0xA3, 0x24, 0xE0, 0x64, 0x03, 0x70, 0x1C, 0x90, 0xA3, 0x27, 
+0x71, 0xA5, 0xE4, 0xFF, 0x12, 0x97, 0x2E, 0x51, 0x98, 0x71, 0x98, 0xE4, 0xFB, 0xFD, 0x12, 0x5E, 
+0x6F, 0x90, 0xA3, 0x24, 0x74, 0x04, 0xF0, 0x80, 0x1A, 0x90, 0xA3, 0x24, 0xE0, 0xB4, 0x04, 0x13, 
+0x71, 0x98, 0x7B, 0x01, 0x7D, 0x01, 0x12, 0x5E, 0x6F, 0x90, 0xA3, 0x24, 0x74, 0x02, 0xF0, 0x90, 
+0xA3, 0x22, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0xA3, 0x1D, 0xE0, 0xC3, 0x13, 0x54, 0x03, 
+0xFF, 0x22, 0x90, 0xA3, 0x29, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0xAD, 0x07, 0xEE, 0xFF, 0x90, 0x01, 
+0x53, 0xE4, 0xF0, 0x8F, 0x35, 0xAF, 0x05, 0x8F, 0x36, 0xFB, 0xFD, 0x7F, 0x50, 0x7E, 0x01, 0x12, 
+0x39, 0x62, 0x90, 0x01, 0x53, 0x74, 0x05, 0xF0, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 
+0x90, 0xA3, 0x1D, 0xE0, 0x30, 0xE0, 0x1F, 0x90, 0xA3, 0x22, 0xE0, 0xB4, 0x01, 0x0C, 0xA3, 0xE0, 
+0xB4, 0x01, 0x13, 0x74, 0x02, 0xF0, 0x71, 0xA2, 0x80, 0x0C, 0x90, 0xA3, 0x22, 0xE0, 0xB4, 0x02, 
+0x05, 0x74, 0x03, 0xF0, 0x71, 0x2D, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xE4, 0xF5, 0x21, 0x90, 0xA2, 
+0x87, 0xE0, 0x60, 0x62, 0x31, 0xF7, 0x70, 0x5E, 0x12, 0x87, 0xDA, 0x60, 0x22, 0x24, 0xFE, 0x60, 
+0x03, 0x04, 0x70, 0x1E, 0x90, 0xA2, 0x8E, 0xE0, 0x14, 0xF0, 0xE0, 0xFF, 0x60, 0x06, 0x90, 0xA2, 
+0x90, 0xE0, 0x60, 0x0E, 0xEF, 0x70, 0x08, 0x90, 0xA2, 0x8D, 0xE0, 0xA3, 0xF0, 0x80, 0x00, 0x75, 
+0x21, 0x01, 0xE5, 0x21, 0x60, 0x30, 0x91, 0x71, 0x90, 0xA2, 0x90, 0xE0, 0x60, 0x03, 0xB4, 0x01, 
+0x04, 0x91, 0x67, 0x80, 0x08, 0x91, 0x67, 0x75, 0xF0, 0x03, 0xA4, 0x24, 0xFE, 0xFF, 0x90, 0xA2, 
+0x8F, 0xE0, 0x2F, 0x90, 0xA4, 0x2A, 0x12, 0x7C, 0xC9, 0x90, 0xA2, 0x8A, 0xE0, 0x20, 0xE2, 0x03, 
+0x12, 0x59, 0x7C, 0x12, 0x96, 0x79, 0x22, 0xE4, 0x90, 0xA4, 0x29, 0xF0, 0x90, 0xA2, 0x90, 0xE0, 
+0x22, 0x90, 0xA2, 0x8B, 0xE0, 0x44, 0x10, 0xF0, 0x22, 0xF1, 0x00, 0x30, 0xE0, 0x0C, 0xEF, 0xC4, 
+0x13, 0x13, 0x54, 0x03, 0x30, 0xE0, 0x03, 0x12, 0x8E, 0x22, 0x90, 0xA2, 0x83, 0x12, 0x93, 0xF9, 
+0x30, 0xE0, 0x0A, 0xEF, 0x91, 0xF7, 0xF0, 0x54, 0x07, 0x70, 0x49, 0x80, 0x45, 0x90, 0xA2, 0x90, 
+0xE0, 0x04, 0xF0, 0x90, 0xA2, 0x8B, 0xE0, 0x54, 0xEF, 0xF0, 0x90, 0xA2, 0xC8, 0xE0, 0xFF, 0x90, 
+0xA2, 0x90, 0xE0, 0xD3, 0x9F, 0x40, 0x2B, 0x31, 0xF7, 0x70, 0x29, 0x90, 0xA2, 0x85, 0xE0, 0x54, 
+0x0F, 0x70, 0x02, 0x80, 0x20, 0x90, 0xA2, 0x91, 0xE0, 0x04, 0xF0, 0xE0, 0xD3, 0x94, 0x02, 0x40, 
+0x09, 0x91, 0xE5, 0xE4, 0x90, 0xA2, 0x91, 0xF0, 0x80, 0x02, 0xB1, 0x01, 0xE4, 0x90, 0xA2, 0x90, 
+0xF0, 0x22, 0x91, 0xED, 0x22, 0x90, 0xA2, 0x84, 0xE0, 0x54, 0xFB, 0xF0, 0x22, 0x90, 0xA2, 0x89, 
+0xE0, 0xFF, 0x7D, 0x01, 0x02, 0x59, 0x80, 0x54, 0xFB, 0xF0, 0x90, 0xA2, 0x8B, 0xE0, 0x54, 0xFD, 
+0x22, 0xD1, 0x24, 0x90, 0xA2, 0x8A, 0xE0, 0x64, 0x0C, 0x60, 0x05, 0x12, 0x5B, 0x5A, 0xB1, 0x6D, 
+0x22, 0xE4, 0xF5, 0x21, 0x90, 0x06, 0xA9, 0xE0, 0xF5, 0x21, 0x54, 0xC0, 0x70, 0x07, 0xB1, 0x65, 
+0x54, 0xFD, 0xF0, 0x80, 0xC8, 0xE5, 0x21, 0x30, 0xE6, 0x1B, 0x90, 0xA2, 0x87, 0xE0, 0x64, 0x01, 
+0x70, 0x15, 0x90, 0xA2, 0x8B, 0xE0, 0x44, 0x01, 0xF0, 0xB1, 0xC4, 0x60, 0x04, 0xB1, 0xCD, 0x80, 
+0x06, 0xB1, 0x01, 0x80, 0x02, 0xB1, 0x65, 0xE5, 0x21, 0x90, 0xA2, 0x8B, 0x30, 0xE7, 0x11, 0xE0, 
+0x44, 0x02, 0xF0, 0xB1, 0x74, 0x12, 0x7C, 0xC9, 0x90, 0xA2, 0x83, 0xE0, 0x44, 0x04, 0xF0, 0x22, 
+0xE0, 0x54, 0xFD, 0xF0, 0x22, 0x90, 0xA2, 0x8B, 0xE0, 0x54, 0xFE, 0xF0, 0x22, 0x7D, 0x08, 0xE4, 
+0xFF, 0x02, 0x5B, 0x79, 0xE4, 0x90, 0xA4, 0x29, 0xF0, 0x90, 0xA2, 0xC9, 0xE0, 0x90, 0xA4, 0x2A, 
+0x22, 0x90, 0xA2, 0x87, 0xE0, 0x60, 0x0E, 0x90, 0x06, 0x92, 0xE0, 0x30, 0xE1, 0x02, 0xC1, 0x24, 
+0x12, 0x8E, 0xAA, 0x91, 0xED, 0x22, 0xE4, 0xFF, 0x12, 0x77, 0xC7, 0xBF, 0x01, 0x0E, 0x90, 0xA2, 
+0x87, 0xE0, 0x60, 0x08, 0xB1, 0x65, 0x54, 0x07, 0x70, 0x02, 0x91, 0xED, 0x22, 0xE4, 0xFF, 0x12, 
+0x77, 0xC7, 0xBF, 0x01, 0x0E, 0x90, 0xA2, 0x87, 0xE0, 0x60, 0x08, 0xB1, 0xC4, 0x60, 0x02, 0x80, 
+0x0C, 0xB1, 0x01, 0x22, 0x90, 0xA2, 0x85, 0xE0, 0x54, 0x0F, 0x64, 0x02, 0x22, 0x90, 0xA2, 0xCD, 
+0xE0, 0xC4, 0x54, 0x0F, 0x20, 0xE0, 0x1D, 0x90, 0x04, 0x1D, 0xE0, 0x70, 0x17, 0x90, 0xA1, 0x7E, 
+0xE0, 0xFF, 0x7B, 0x18, 0xE4, 0xFD, 0x12, 0x5C, 0xA9, 0x90, 0xA4, 0x88, 0xEE, 0xF0, 0xA3, 0xEF, 
+0xF0, 0x12, 0x5E, 0xD5, 0x22, 0x90, 0xA2, 0x83, 0xE0, 0x12, 0x57, 0xF4, 0x30, 0xE0, 0x24, 0xEF, 
+0x54, 0xBF, 0xD1, 0xB9, 0x30, 0xE0, 0x06, 0xE0, 0x44, 0x01, 0xF0, 0x80, 0x04, 0xE0, 0x54, 0xFE, 
+0xF0, 0x90, 0xA2, 0xD5, 0x12, 0x97, 0xCA, 0x30, 0xE0, 0x07, 0x7D, 0x01, 0x7F, 0x0C, 0x02, 0x59, 
+0x80, 0x91, 0xED, 0x22, 0x12, 0x5F, 0xAD, 0x30, 0xE0, 0x05, 0x90, 0x01, 0x5B, 0xE4, 0xF0, 0x90, 
+0x06, 0x92, 0x74, 0x02, 0xF0, 0x90, 0x01, 0x3C, 0x74, 0x04, 0xF0, 0xE4, 0x90, 0xA4, 0x29, 0xF0, 
+0x90, 0xA2, 0xCA, 0xE0, 0xC3, 0x13, 0x54, 0x7F, 0x90, 0xA4, 0x2A, 0xF0, 0xE4, 0xFB, 0xFD, 0x7F, 
+0x58, 0x7E, 0x01, 0x12, 0x7C, 0xD1, 0x90, 0xA2, 0x83, 0xE0, 0x44, 0x08, 0xF0, 0x22, 0x90, 0xA2, 
+0x83, 0xE0, 0xFF, 0x12, 0x4F, 0xF5, 0x30, 0xE0, 0x1A, 0xEF, 0x54, 0x7F, 0xD1, 0xB9, 0x30, 0xE1, 
+0x06, 0xE0, 0x44, 0x02, 0xF0, 0x80, 0x04, 0xE0, 0x54, 0xFD, 0xF0, 0x90, 0xA2, 0x87, 0xE0, 0x60, 
+0x02, 0x91, 0xED, 0x90, 0xA2, 0xD3, 0xE0, 0x12, 0x57, 0xF4, 0x30, 0xE0, 0x22, 0x90, 0xA2, 0xD6, 
+0xE0, 0xFF, 0xC3, 0x13, 0x30, 0xE0, 0x18, 0xEF, 0x54, 0xFD, 0xF0, 0x90, 0x04, 0xE0, 0xE0, 0x90, 
+0xA2, 0xD6, 0x30, 0xE1, 0x06, 0xE0, 0x44, 0x04, 0xF0, 0x80, 0x04, 0xE0, 0x54, 0xFB, 0xF0, 0x90, 
+0x04, 0xE0, 0xE0, 0x30, 0xE1, 0x02, 0xD1, 0xC2, 0x22, 0xF0, 0x90, 0x04, 0xE0, 0xE0, 0x90, 0xA2, 
+0x84, 0x22, 0x90, 0xA3, 0x31, 0xE0, 0x30, 0xE0, 0x24, 0xC3, 0x13, 0x54, 0x07, 0xD1, 0xEE, 0xE0, 
+0xFE, 0x30, 0xE0, 0x19, 0x75, 0xF0, 0x0E, 0xEF, 0xD1, 0xF2, 0xEE, 0x54, 0xFE, 0xF0, 0x90, 0xA3, 
+0x33, 0x74, 0x05, 0xF0, 0x12, 0x5F, 0xDB, 0xFD, 0x7F, 0x01, 0x12, 0x7F, 0xB6, 0x22, 0xFF, 0x75, 
+0xF0, 0x0E, 0x90, 0xA3, 0x3C, 0x02, 0x4A, 0x2A, 0x90, 0xA2, 0x8D, 0xE0, 0x90, 0x05, 0x73, 0x22, 
+0x90, 0xA2, 0x84, 0xE0, 0xFF, 0x13, 0x13, 0x13, 0x54, 0x1F, 0x22, 0x90, 0xA2, 0x87, 0xE0, 0x60, 
+0x02, 0x91, 0x79, 0x02, 0x5E, 0xDC, 0x51, 0x56, 0x7D, 0x02, 0x7F, 0x02, 0x12, 0x87, 0xCE, 0x02, 
+0x8D, 0xAA, 0x90, 0xA2, 0x87, 0xE0, 0x60, 0x03, 0x12, 0x97, 0x9E, 0x22, 0xF1, 0xEA, 0x90, 0xA3, 
+0xA6, 0xEF, 0xF0, 0x30, 0xE0, 0x05, 0x7D, 0x01, 0xE4, 0x80, 0x02, 0xE4, 0xFD, 0xFF, 0x12, 0x58, 
+0xF6, 0x90, 0xA3, 0xA6, 0xE0, 0x30, 0xE6, 0x11, 0x90, 0x01, 0x2F, 0xE0, 0x30, 0xE7, 0x04, 0xE4, 
+0xF0, 0x80, 0x06, 0x90, 0x01, 0x2F, 0x74, 0x80, 0xF0, 0x90, 0xA2, 0x99, 0xE0, 0xFF, 0xA3, 0xE0, 
+0xFD, 0x90, 0xA2, 0xA0, 0xE0, 0xFB, 0xAC, 0x07, 0x90, 0xA2, 0x83, 0xE0, 0x30, 0xE0, 0x16, 0x90, 
+0xA2, 0xBD, 0xE0, 0x24, 0x04, 0x90, 0xA2, 0x9C, 0xF0, 0x90, 0xA2, 0xBD, 0xE0, 0x24, 0x03, 0x90, 
+0xA2, 0x9B, 0xF0, 0x80, 0x0B, 0x90, 0xA2, 0x9C, 0x74, 0x02, 0xF0, 0x90, 0xA2, 0x9B, 0x14, 0xF0, 
+0x90, 0xA2, 0x9B, 0xE0, 0xFA, 0x90, 0xA2, 0x9A, 0xE0, 0xD3, 0x9A, 0x50, 0x0A, 0x90, 0xA2, 0x8F, 
+0xEB, 0x12, 0xB4, 0x81, 0x2C, 0x80, 0x0C, 0xAD, 0x02, 0xC3, 0xED, 0x9D, 0x2B, 0x90, 0xA2, 0x8F, 
+0x12, 0xB4, 0x81, 0x90, 0xA2, 0x9F, 0xF0, 0x90, 0xA2, 0x9F, 0xE0, 0xFF, 0x7E, 0x00, 0x90, 0xA2, 
+0x93, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0x05, 0x58, 0xE0, 0x6F, 0x70, 0x01, 0xE4, 0x60, 0x03, 
+0x12, 0xB3, 0x7D, 0x22, 0xEF, 0x90, 0x02, 0x86, 0x60, 0x06, 0xE0, 0x44, 0x04, 0xF0, 0x80, 0x04, 
+0xE0, 0x54, 0xFB, 0xF0, 0x90, 0xA1, 0x7B, 0xED, 0xF0, 0x22, 0xE4, 0x90, 0xA3, 0xA7, 0xF0, 0xA3, 
+0xF0, 0xA3, 0xF0, 0x90, 0x00, 0x83, 0xE0, 0x90, 0xA3, 0xA7, 0xF0, 0x90, 0x00, 0x83, 0xE0, 0xFE, 
+0x90, 0xA3, 0xA7, 0xE0, 0xFF, 0xB5, 0x06, 0x01, 0x22, 0xC3, 0x90, 0xA3, 0xA9, 0xE0, 0x94, 0x64, 
+0x90, 0xA3, 0xA8, 0xE0, 0x94, 0x00, 0x40, 0x0D, 0x90, 0x01, 0xC0, 0xE0, 0x44, 0x40, 0xF0, 0x90, 
+0xA3, 0xA7, 0xE0, 0xFF, 0x22, 0x90, 0xA3, 0xA8, 0x12, 0x79, 0xC5, 0x80, 0xC6, 0x90, 0x01, 0xC4, 
+0x74, 0x2D, 0xF0, 0x74, 0xA8, 0xA3, 0xF0, 0x90, 0x00, 0x90, 0xE0, 0x20, 0xE0, 0xF9, 0x74, 0x2D, 
+0x04, 0x90, 0x01, 0xC4, 0xF0, 0x74, 0xA8, 0xA3, 0xF0, 0x22, 0x90, 0xA2, 0x84, 0xE0, 0x44, 0x10, 
+0xF0, 0x90, 0xA1, 0x7C, 0xE0, 0xB4, 0x03, 0x0C, 0x90, 0x00, 0x70, 0xE0, 0x44, 0x80, 0xFD, 0x7F, 
+0x70, 0x12, 0x3A, 0x96, 0x90, 0xA2, 0x92, 0xE0, 0xFD, 0x7F, 0x93, 0x12, 0x3A, 0x96, 0x90, 0xA2, 
+0x88, 0xE0, 0x60, 0x12, 0x90, 0x01, 0x2F, 0xE0, 0x30, 0xE7, 0x05, 0x74, 0x10, 0xF0, 0x80, 0x06, 
+0x90, 0x01, 0x2F, 0x74, 0x90, 0xF0, 0x90, 0x00, 0x08, 0xE0, 0x44, 0x10, 0xFD, 0x7F, 0x08, 0x12, 
+0x3A, 0x96, 0x7F, 0x01, 0x12, 0x7B, 0x4B, 0x90, 0x00, 0x90, 0xE0, 0x44, 0x01, 0xFD, 0x7F, 0x90, 
+0x12, 0x3A, 0x96, 0x7F, 0x14, 0x7E, 0x00, 0x02, 0x3A, 0xF7, 0x7E, 0xFF, 0x74, 0xA1, 0x2F, 0x12, 
+0x62, 0x4C, 0x74, 0xFF, 0xF0, 0xED, 0xB4, 0x3E, 0x0D, 0x7E, 0xBD, 0x74, 0xA1, 0x2F, 0x12, 0x62, 
+0x4C, 0x74, 0x3D, 0xF0, 0x80, 0x19, 0xED, 0xB4, 0x3F, 0x15, 0x12, 0x6B, 0xE1, 0xC4, 0x13, 0x54, 
+0x07, 0x30, 0xE0, 0x0B, 0x7E, 0x3E, 0x74, 0xA1, 0x2F, 0x12, 0x62, 0x4C, 0x74, 0x3E, 0xF0, 0xED, 
+0x14, 0xFD, 0x74, 0x75, 0x2F, 0x12, 0x64, 0x84, 0xED, 0xF0, 0xAF, 0x06, 0x22, 0xED, 0x54, 0x7F, 
+0xFC, 0xED, 0x54, 0x80, 0x60, 0x03, 0xAF, 0x04, 0x22, 0xEC, 0xB4, 0x3D, 0x02, 0x80, 0x10, 0xEC, 
+0x64, 0x3F, 0x70, 0x14, 0x12, 0x6B, 0xE1, 0xC4, 0x13, 0x54, 0x07, 0x30, 0xE0, 0x06, 0xEC, 0x44, 
+0x80, 0xFE, 0x80, 0x06, 0x7E, 0xFF, 0x80, 0x02, 0x7E, 0xFF, 0xAF, 0x06, 0x22, 0x90, 0xA3, 0xC9, 
+0xEB, 0xF0, 0x70, 0x59, 0x90, 0xA3, 0xC9, 0xE0, 0xFE, 0x31, 0x7E, 0xE0, 0xFC, 0x90, 0xA3, 0xCA, 
+0xE0, 0xFB, 0xEC, 0x6B, 0x60, 0x47, 0x90, 0xA3, 0xCE, 0xEB, 0xF0, 0xA3, 0xEE, 0xF0, 0xAE, 0x05, 
+0xEE, 0x25, 0xE0, 0x4F, 0xFF, 0x90, 0xA1, 0x75, 0xE0, 0xFE, 0x25, 0xE0, 0x25, 0xE0, 0x4F, 0x90, 
+0xA3, 0xD0, 0xF0, 0x90, 0xA3, 0xCB, 0xE0, 0x90, 0xA3, 0xD2, 0xF0, 0x90, 0xA3, 0xCC, 0x74, 0x0C, 
+0xF0, 0x90, 0xA3, 0xDA, 0x74, 0x04, 0xF0, 0x7B, 0x01, 0x7A, 0xA3, 0x79, 0xCC, 0x12, 0x8C, 0xB4, 
+0x90, 0xA3, 0xCA, 0xE0, 0xFF, 0x90, 0xA3, 0xC9, 0xE0, 0x31, 0x7E, 0xEF, 0xF0, 0x22, 0x24, 0x11, 
+0xF5, 0x82, 0xE4, 0x34, 0x99, 0xF5, 0x83, 0x22, 0xEF, 0x60, 0x0A, 0xED, 0xC3, 0x94, 0x2C, 0x40, 
+0x04, 0x7E, 0x20, 0x80, 0x02, 0xE4, 0xFE, 0xC3, 0xED, 0x9E, 0xFF, 0x22, 0xEF, 0x60, 0x0A, 0xED, 
+0xD3, 0x94, 0x0B, 0x40, 0x04, 0x7E, 0x20, 0x80, 0x02, 0xE4, 0xFE, 0xED, 0x2E, 0xFF, 0x22, 0xE4, 
+0xF5, 0x1A, 0x74, 0x91, 0x2F, 0x12, 0x6A, 0xA9, 0xE0, 0xFE, 0xB4, 0x05, 0x08, 0xED, 0xC3, 0x94, 
+0x3B, 0x40, 0x51, 0x80, 0x47, 0xEE, 0xB4, 0x04, 0x08, 0xED, 0xC3, 0x94, 0x31, 0x40, 0x45, 0x80, 
+0x3B, 0x74, 0x91, 0x2F, 0x12, 0x6A, 0xA9, 0xE0, 0xFE, 0xB4, 0x03, 0x08, 0xED, 0xC3, 0x94, 0x19, 
+0x40, 0x32, 0x80, 0x28, 0xEE, 0xB4, 0x02, 0x08, 0xED, 0xC3, 0x94, 0x11, 0x40, 0x26, 0x80, 0x1C, 
+0x74, 0x91, 0x2F, 0x12, 0x6A, 0xA9, 0xE0, 0xFE, 0xB4, 0x01, 0x08, 0xED, 0xC3, 0x94, 0x0A, 0x40, 
+0x13, 0x80, 0x09, 0xEE, 0x70, 0x0B, 0xED, 0xC3, 0x94, 0x03, 0x40, 0x08, 0x75, 0x1A, 0x01, 0x80, 
+0x03, 0xE4, 0xF5, 0x1A, 0xAF, 0x1A, 0x22, 0x8F, 0x0E, 0x8D, 0x0F, 0x8B, 0x10, 0x75, 0xF0, 0x04, 
+0xEF, 0x12, 0x4F, 0x3D, 0xC4, 0x54, 0x03, 0x90, 0xA3, 0x7E, 0xF0, 0x90, 0xA3, 0x7C, 0x60, 0x09, 
+0x74, 0x32, 0xF0, 0xA3, 0x74, 0x2F, 0xF0, 0x80, 0x07, 0x74, 0x11, 0xF0, 0xA3, 0x74, 0x0F, 0xF0, 
+0xE5, 0x0F, 0xD3, 0x94, 0x2D, 0x40, 0x0A, 0x75, 0xF0, 0x04, 0xE5, 0x0E, 0x12, 0x6F, 0xF9, 0x80, 
+0x20, 0xE5, 0x0F, 0xD3, 0x94, 0x1E, 0x40, 0x05, 0x90, 0xA3, 0x7C, 0x80, 0x14, 0xE5, 0x0F, 0xD3, 
+0x94, 0x14, 0x40, 0x05, 0x90, 0xA3, 0x7D, 0x80, 0x08, 0x75, 0xF0, 0x04, 0xE5, 0x0E, 0x12, 0x6B, 
+0xDB, 0xE0, 0xFD, 0x85, 0x10, 0x71, 0xE4, 0xFB, 0xAF, 0x0E, 0x02, 0x66, 0xB4, 0x90, 0xA3, 0x79, 
+0x12, 0x4A, 0x3F, 0x12, 0x76, 0xC7, 0x30, 0xE1, 0x09, 0x90, 0x04, 0xA0, 0x74, 0x11, 0xF0, 0x02, 
+0x8D, 0x31, 0x90, 0x04, 0xA0, 0x74, 0x22, 0xF0, 0x12, 0x4F, 0xE4, 0x12, 0x26, 0x1E, 0x90, 0xA3, 
+0x7C, 0x12, 0x51, 0x7B, 0x90, 0xA3, 0x7D, 0x12, 0x4F, 0xD0, 0x90, 0xA3, 0x7E, 0x12, 0x54, 0x1F, 
+0x75, 0xF0, 0x10, 0xA4, 0xFF, 0x12, 0x4F, 0xDE, 0xFD, 0xEF, 0x4D, 0xFF, 0x90, 0xA3, 0x7D, 0xE0, 
+0xB4, 0x01, 0x06, 0xA3, 0xE0, 0x51, 0xCA, 0xEF, 0xF0, 0x22, 0x24, 0x21, 0xF5, 0x82, 0xE4, 0x34, 
+0xA0, 0xF5, 0x83, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0xA4, 0x82, 0xEF, 0xF0, 
+0x90, 0x00, 0x8F, 0xE0, 0x30, 0xE6, 0x3D, 0x90, 0x00, 0x8D, 0xE0, 0x64, 0x01, 0x70, 0x35, 0x90, 
+0xA4, 0x83, 0xF0, 0x90, 0xA4, 0x83, 0xE0, 0xFD, 0x90, 0xA4, 0x82, 0xE0, 0x75, 0xF0, 0x10, 0x12, 
+0x76, 0xD3, 0xE5, 0x82, 0x2D, 0x12, 0x6A, 0x9B, 0xE0, 0xFB, 0xE4, 0xFF, 0x12, 0x61, 0x43, 0x90, 
+0xA4, 0x83, 0xE0, 0x04, 0xF0, 0xE0, 0xC3, 0x94, 0x10, 0x40, 0xD8, 0x90, 0x00, 0x8F, 0xE0, 0x30, 
+0xE0, 0x02, 0x71, 0x29, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xE4, 0xFD, 0x7F, 0x8D, 0x02, 0x3A, 0x96, 
+0x7E, 0x00, 0x7F, 0x2D, 0x7D, 0x00, 0x7B, 0x01, 0x7A, 0xA3, 0x79, 0x31, 0x02, 0x4A, 0x6E, 0x12, 
+0x4F, 0xE9, 0xFF, 0x12, 0x4F, 0xE4, 0x12, 0x4F, 0xD1, 0x90, 0xA4, 0x5D, 0xF0, 0xE4, 0xFB, 0xFD, 
+0x12, 0x82, 0x78, 0x90, 0xA3, 0x7C, 0x74, 0x10, 0xF0, 0x90, 0xA3, 0x8A, 0x74, 0x07, 0xF0, 0x12, 
+0x4F, 0xE4, 0x12, 0x26, 0x1E, 0x90, 0xA3, 0x7E, 0xF0, 0x7B, 0x01, 0x7A, 0xA3, 0x79, 0x7C, 0x12, 
+0x8C, 0xD3, 0x7F, 0x04, 0x02, 0x8C, 0xB8, 0x90, 0xA4, 0x84, 0xEF, 0xF0, 0xA3, 0xED, 0xF0, 0x90, 
+0x00, 0xF1, 0xE0, 0x54, 0xF0, 0x64, 0x20, 0x60, 0x02, 0x81, 0x45, 0x90, 0xA4, 0x85, 0xE0, 0xB4, 
+0x01, 0x1D, 0x90, 0xA4, 0x84, 0xE0, 0xB4, 0x0B, 0x16, 0x90, 0xA3, 0xF0, 0x12, 0x27, 0x54, 0x00, 
+0x00, 0x0C, 0x00, 0x90, 0xA3, 0xF4, 0x12, 0x27, 0x54, 0x00, 0x00, 0x0C, 0x00, 0x80, 0x14, 0x90, 
+0xA3, 0xF0, 0x12, 0x27, 0x54, 0x00, 0x00, 0x0C, 0x00, 0x90, 0xA3, 0xF4, 0x12, 0x27, 0x54, 0x00, 
+0x00, 0x08, 0x00, 0x12, 0x54, 0xD3, 0x90, 0xA4, 0x85, 0xE0, 0x70, 0x21, 0x91, 0x90, 0x60, 0x04, 
+0xEF, 0xB4, 0x0E, 0x19, 0x90, 0xA3, 0xF0, 0x12, 0x27, 0x54, 0x00, 0x00, 0x03, 0x00, 0x90, 0xA3, 
+0xF4, 0x12, 0x27, 0x54, 0x00, 0x00, 0x03, 0x00, 0x12, 0x54, 0xD3, 0x80, 0x0E, 0x90, 0xA4, 0x85, 
+0xE0, 0xB4, 0x01, 0x1D, 0x90, 0xA4, 0x84, 0xE0, 0xB4, 0x0B, 0x16, 0x90, 0xA3, 0xF0, 0x12, 0x27, 
+0x54, 0x40, 0x00, 0x00, 0x00, 0x90, 0xA3, 0xF4, 0x12, 0x27, 0x54, 0x40, 0x00, 0x00, 0x00, 0x80, 
+0x30, 0x90, 0xA4, 0x85, 0xE0, 0x64, 0x02, 0x60, 0x76, 0x90, 0xA3, 0xF0, 0x12, 0x27, 0x54, 0x00, 
+0x00, 0x03, 0x00, 0x90, 0xA3, 0xF4, 0x12, 0x27, 0x54, 0x00, 0x00, 0x02, 0x00, 0x12, 0x57, 0x03, 
+0x12, 0x27, 0x54, 0x40, 0x00, 0x00, 0x00, 0x90, 0xA3, 0xF4, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 
+0x00, 0x7F, 0xC4, 0x80, 0x45, 0x90, 0xA4, 0x85, 0xE0, 0x70, 0x20, 0x91, 0x90, 0x60, 0x04, 0xEF, 
+0xB4, 0x0E, 0x18, 0x90, 0xA3, 0xF0, 0x12, 0x27, 0x54, 0x00, 0x00, 0x03, 0x00, 0x90, 0xA3, 0xF4, 
+0x12, 0x27, 0x54, 0x00, 0x00, 0x03, 0x00, 0x7F, 0xAC, 0x80, 0x1F, 0x90, 0xA4, 0x84, 0xE0, 0xD3, 
+0x94, 0x0E, 0x50, 0x1B, 0x90, 0xA3, 0xF0, 0x12, 0x27, 0x54, 0x00, 0x00, 0x03, 0x00, 0x90, 0xA3, 
+0xF4, 0x12, 0x27, 0x54, 0x00, 0x00, 0x02, 0x00, 0x7F, 0xAC, 0x7E, 0x08, 0x12, 0x54, 0xD7, 0x22, 
+0x90, 0xA4, 0x84, 0xE0, 0xFF, 0x64, 0x0D, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0xA9, 
+0x07, 0x90, 0x06, 0x69, 0xE0, 0xFE, 0x90, 0x06, 0x68, 0xE0, 0x7A, 0x00, 0x24, 0x00, 0xFF, 0xEA, 
+0x3E, 0xFE, 0xE9, 0x14, 0x60, 0x0F, 0x14, 0x60, 0x1E, 0x24, 0x02, 0x70, 0x25, 0xEE, 0x54, 0xFE, 
+0xFE, 0x91, 0xE7, 0x80, 0x1A, 0xEF, 0x44, 0x80, 0xFF, 0xEE, 0x54, 0xFE, 0xFC, 0x90, 0x06, 0x68, 
+0xEF, 0xF0, 0xEC, 0xA3, 0xF0, 0x80, 0x0B, 0xEE, 0x44, 0x01, 0xFC, 0x91, 0xE7, 0xAE, 0x04, 0xEE, 
+0xA3, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xEF, 0x54, 0x7F, 0x90, 0x06, 0x68, 0xF0, 0x22, 0x90, 
+0xA4, 0x77, 0xED, 0xF0, 0x90, 0xA4, 0x76, 0xEF, 0xF0, 0x70, 0x64, 0x90, 0xA3, 0xF0, 0x12, 0x27, 
+0x54, 0x30, 0x00, 0x00, 0x00, 0x90, 0xA3, 0xF4, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0x00, 0x74, 
+0x08, 0xFF, 0xFE, 0x12, 0x57, 0x07, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0x0E, 0x90, 0xA3, 0xF4, 
+0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0x08, 0x7F, 0x30, 0x12, 0x57, 0x05, 0x12, 0x27, 0x54, 0x00, 
+0x00, 0x00, 0x03, 0x90, 0xA3, 0xF4, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0x01, 0xB1, 0xD6, 0x12, 
+0x27, 0x54, 0x30, 0x00, 0x00, 0x00, 0x90, 0xA3, 0xF4, 0x12, 0x27, 0x54, 0x30, 0x00, 0x00, 0x00, 
+0x74, 0x08, 0xFF, 0xFE, 0x12, 0x54, 0xD7, 0x90, 0x04, 0x54, 0xE0, 0x54, 0x7F, 0x80, 0x6D, 0x90, 
+0xA4, 0x76, 0xE0, 0x64, 0x01, 0x70, 0x64, 0x90, 0x04, 0x54, 0xE0, 0x44, 0x80, 0xB1, 0xCC, 0x90, 
+0xA3, 0xF0, 0x12, 0x27, 0x54, 0x30, 0x00, 0x00, 0x00, 0x90, 0xA3, 0xF4, 0x12, 0x27, 0x54, 0x00, 
+0x00, 0x00, 0x00, 0x74, 0x08, 0xFF, 0xFE, 0x12, 0x57, 0x07, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 
+0x0E, 0x90, 0xA3, 0xF4, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0x06, 0x7F, 0x30, 0x12, 0x57, 0x05, 
+0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0x03, 0x90, 0xA3, 0xF4, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 
+0x02, 0xB1, 0xD6, 0x12, 0x27, 0x54, 0x30, 0x00, 0x00, 0x00, 0x90, 0xA3, 0xF4, 0x12, 0x27, 0x54, 
+0x20, 0x00, 0x00, 0x00, 0x74, 0x08, 0xFF, 0xFE, 0x12, 0x54, 0xD7, 0x22, 0x90, 0xA4, 0x78, 0xF0, 
+0xE0, 0x90, 0x04, 0x54, 0xF0, 0x22, 0x7F, 0x34, 0x7E, 0x08, 0x12, 0x54, 0xD7, 0x90, 0xA4, 0x76, 
+0xE0, 0xFF, 0xA3, 0xE0, 0xFD, 0xD1, 0x4E, 0x90, 0xA3, 0xF0, 0x22, 0xE4, 0xFE, 0xFC, 0xEF, 0x64, 
+0x02, 0x70, 0x40, 0xED, 0xB4, 0x01, 0x04, 0x7E, 0x0A, 0x80, 0x06, 0xED, 0xB4, 0x02, 0x02, 0x7E, 
+0x09, 0xEB, 0xB4, 0x01, 0x08, 0xED, 0xB4, 0x01, 0x04, 0x7C, 0x04, 0x80, 0x38, 0xEB, 0xB4, 0x02, 
+0x08, 0xED, 0xB4, 0x01, 0x04, 0x7C, 0x02, 0x80, 0x2C, 0xEB, 0xB4, 0x01, 0x08, 0xED, 0xB4, 0x02, 
+0x04, 0x7C, 0x01, 0x80, 0x20, 0xEB, 0x64, 0x02, 0x70, 0x1B, 0xED, 0x64, 0x02, 0x70, 0x16, 0x7C, 
+0x03, 0x80, 0x12, 0xEF, 0xB4, 0x01, 0x0E, 0xEB, 0xB4, 0x02, 0x04, 0x7C, 0x01, 0x80, 0x06, 0xEB, 
+0xB4, 0x01, 0x02, 0x7C, 0x02, 0xAF, 0x06, 0xEF, 0xC4, 0x54, 0xF0, 0x4C, 0xFF, 0x22, 0x90, 0xA4, 
+0x8E, 0xED, 0xF0, 0xEF, 0x60, 0x02, 0xE1, 0x25, 0xE0, 0x24, 0xFD, 0x50, 0x0B, 0x60, 0x1F, 0x14, 
+0x60, 0x33, 0x14, 0x60, 0x73, 0x02, 0xB0, 0xBD, 0x90, 0xAC, 0xB9, 0x12, 0x27, 0x54, 0x77, 0x77, 
+0x77, 0x77, 0x12, 0x96, 0x56, 0x12, 0x27, 0x54, 0x77, 0x77, 0x77, 0x77, 0xE1, 0xA0, 0x90, 0xAC, 
+0xB9, 0x12, 0x27, 0x54, 0x54, 0x33, 0x77, 0x70, 0x12, 0x96, 0x56, 0x12, 0x27, 0x54, 0x54, 0x33, 
+0x77, 0x70, 0x02, 0xB0, 0x25, 0x90, 0xAC, 0xB9, 0x12, 0x27, 0x54, 0x77, 0x77, 0x77, 0x77, 0x12, 
+0x96, 0x56, 0x12, 0x27, 0x54, 0x77, 0x77, 0x77, 0x77, 0x12, 0xB0, 0xBE, 0x12, 0x27, 0x54, 0x3F, 
+0xF0, 0x00, 0x00, 0x90, 0xA3, 0xF4, 0x12, 0x27, 0x54, 0x00, 0x10, 0x00, 0x00, 0x7F, 0xB4, 0x7E, 
+0x0C, 0x12, 0x57, 0x07, 0x12, 0x27, 0x54, 0x3F, 0xF0, 0x00, 0x00, 0x90, 0xA3, 0xF4, 0x12, 0x27, 
+0x54, 0x00, 0x10, 0x00, 0x00, 0x02, 0xB0, 0xB6, 0x90, 0xA3, 0xF0, 0x12, 0x27, 0x54, 0x00, 0x00, 
+0x00, 0xFF, 0x90, 0xA3, 0xF4, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0x77, 0x12, 0xB0, 0xC9, 0x12, 
+0x27, 0x54, 0x77, 0x77, 0x77, 0x77, 0x12, 0xB0, 0xBE, 0x12, 0x27, 0x54, 0x01, 0x00, 0x00, 0x00, 
+0x90, 0xA3, 0xF4, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xB4, 0x7E, 0x0C, 0x12, 0x57, 
+0x07, 0x12, 0x27, 0x54, 0x3F, 0xF0, 0x00, 0x00, 0x90, 0xA3, 0xF4, 0x12, 0x27, 0x54, 0x00, 0x00, 
+0x00, 0x00, 0x02, 0xB0, 0xB6, 0x90, 0xA4, 0x8E, 0xE0, 0x14, 0x60, 0x60, 0x14, 0x70, 0x02, 0xE1, 
+0xCF, 0x14, 0x70, 0x03, 0x02, 0xB0, 0x11, 0x14, 0x70, 0x02, 0xE1, 0xCF, 0x14, 0x70, 0x03, 0x02, 
+0xB0, 0x6E, 0x24, 0x05, 0x60, 0x03, 0x02, 0xB0, 0xBD, 0x90, 0xAC, 0xB9, 0x12, 0x27, 0x54, 0x77, 
+0x33, 0x77, 0x17, 0x12, 0x96, 0x56, 0x12, 0x27, 0x54, 0x77, 0x33, 0x77, 0x17, 0x12, 0xB0, 0xBE, 
+0x12, 0x27, 0x54, 0x3F, 0xF0, 0x00, 0x00, 0x90, 0xA3, 0xF4, 0x12, 0x27, 0x54, 0x01, 0x00, 0x00, 
+0x00, 0x7F, 0xB4, 0x7E, 0x0C, 0x12, 0x57, 0x07, 0x12, 0x27, 0x54, 0x3F, 0xF0, 0x00, 0x00, 0x90, 
+0xA3, 0xF4, 0x12, 0x27, 0x54, 0x01, 0x00, 0x00, 0x00, 0x02, 0xB0, 0xB6, 0x90, 0xAC, 0xB9, 0x12, 
+0x27, 0x54, 0x77, 0x33, 0x77, 0x17, 0x12, 0x96, 0x56, 0x12, 0x27, 0x54, 0x77, 0x33, 0x77, 0x17, 
+0x12, 0xB0, 0xBE, 0x12, 0x27, 0x54, 0x3F, 0xF0, 0x00, 0x00, 0x90, 0xA3, 0xF4, 0x12, 0x27, 0x54, 
+0x00, 0x00, 0x00, 0x00, 0x7F, 0xB4, 0x7E, 0x0C, 0x12, 0x57, 0x07, 0x12, 0x27, 0x54, 0x3F, 0xF0, 
+0x00, 0x00, 0x90, 0xA3, 0xF4, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0x00, 0x02, 0xB0, 0xB6, 0x90, 
+0xAC, 0xB9, 0x12, 0x27, 0x54, 0x77, 0x33, 0x77, 0x77, 0x12, 0x96, 0x56, 0x12, 0x27, 0x54, 0x77, 
+0x33, 0x77, 0x77, 0x12, 0xB0, 0xBE, 0x12, 0x27, 0x54, 0x3F, 0xF0, 0x00, 0x00, 0x90, 0xA3, 0xF4, 
+0x12, 0x27, 0x54, 0x01, 0x00, 0x00, 0x00, 0x7F, 0xB4, 0x7E, 0x0C, 0x12, 0x57, 0x07, 0x12, 0x27, 
+0x54, 0x3F, 0xF0, 0x00, 0x00, 0x90, 0xA3, 0xF4, 0x12, 0x27, 0x54, 0x01, 0x00, 0x00, 0x00, 0x01, 
+0xB6, 0x90, 0xAC, 0xB9, 0x12, 0x27, 0x54, 0x54, 0x33, 0x77, 0x17, 0x12, 0x96, 0x56, 0x12, 0x27, 
+0x54, 0x54, 0x33, 0x77, 0x17, 0x11, 0xBE, 0x12, 0x27, 0x54, 0x3F, 0xF0, 0x00, 0x00, 0x90, 0xA3, 
+0xF4, 0x12, 0x27, 0x54, 0x01, 0x00, 0x00, 0x00, 0x7F, 0xB4, 0x7E, 0x0C, 0x12, 0x57, 0x07, 0x12, 
+0x27, 0x54, 0x3F, 0xF0, 0x00, 0x00, 0x90, 0xA3, 0xF4, 0x12, 0x27, 0x54, 0x01, 0x00, 0x00, 0x00, 
+0x7F, 0xB4, 0x7E, 0x0E, 0x12, 0x57, 0x07, 0x12, 0x27, 0x54, 0x00, 0x00, 0x03, 0x03, 0x90, 0xA3, 
+0xF4, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0x01, 0x7F, 0x00, 0x7E, 0x09, 0x80, 0x4C, 0x90, 0xA3, 
+0xF0, 0x12, 0x27, 0x54, 0x00, 0xFF, 0x00, 0x00, 0x90, 0xA3, 0xF4, 0x12, 0x27, 0x54, 0x00, 0x33, 
+0x00, 0x00, 0x11, 0xC9, 0x12, 0x27, 0x54, 0x77, 0x33, 0x77, 0x77, 0x11, 0xBE, 0x12, 0x27, 0x54, 
+0x01, 0x00, 0x00, 0x00, 0x90, 0xA3, 0xF4, 0x12, 0x27, 0x54, 0x01, 0x00, 0x00, 0x00, 0x7F, 0xB4, 
+0x7E, 0x0C, 0x12, 0x57, 0x07, 0x12, 0x27, 0x54, 0x3F, 0xF0, 0x00, 0x00, 0x90, 0xA3, 0xF4, 0x12, 
+0x27, 0x54, 0x01, 0x00, 0x00, 0x00, 0x7F, 0xB4, 0x7E, 0x0E, 0x12, 0x54, 0xD7, 0x22, 0x7F, 0xB0, 
+0x7E, 0x0E, 0x12, 0x37, 0x5D, 0x90, 0xA3, 0xF0, 0x22, 0x7F, 0xB0, 0x7E, 0x0C, 0x12, 0x54, 0xD7, 
+0x90, 0xAC, 0xB9, 0x22, 0xE4, 0xFE, 0xEF, 0x54, 0xE0, 0xC4, 0x13, 0x54, 0x07, 0xFD, 0xEF, 0x54, 
+0x1F, 0xFF, 0xED, 0x60, 0x2C, 0x14, 0x60, 0x1E, 0x24, 0xFD, 0x60, 0x0F, 0x24, 0xFE, 0x70, 0x2A, 
+0xEF, 0x25, 0xE0, 0xFF, 0xC3, 0x74, 0xDE, 0x9F, 0xFE, 0x80, 0x1F, 0xEF, 0x25, 0xE0, 0xFF, 0xC3, 
+0x74, 0xF2, 0x9F, 0xFE, 0x80, 0x14, 0xEF, 0x25, 0xE0, 0xFF, 0xC3, 0x74, 0x06, 0x9F, 0xFE, 0x80, 
+0x09, 0xEF, 0x25, 0xE0, 0xFF, 0xC3, 0x74, 0x10, 0x9F, 0xFE, 0xAF, 0x06, 0x22, 0xD3, 0xEF, 0x64, 
+0x80, 0x94, 0x1C, 0x40, 0x07, 0xEF, 0x64, 0x80, 0x94, 0x94, 0x40, 0x03, 0x7F, 0x00, 0x22, 0xC3, 
+0xEF, 0x64, 0x80, 0x94, 0x80, 0x40, 0x03, 0x7F, 0x64, 0x22, 0xEF, 0x24, 0x64, 0xFF, 0x22, 0x90, 
+0xA3, 0x61, 0xE0, 0x75, 0xF0, 0x3F, 0x84, 0xAD, 0xF0, 0xED, 0x25, 0xE0, 0x25, 0xE0, 0xFD, 0x74, 
+0x38, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xED, 0xF0, 0x90, 0xA3, 0x61, 0xE0, 0x04, 
+0xF0, 0x22, 0x90, 0x04, 0x1A, 0xE0, 0xF4, 0x60, 0x03, 0x7F, 0x00, 0x22, 0x90, 0x04, 0x1B, 0xE0, 
+0x54, 0x07, 0x64, 0x07, 0x7F, 0x01, 0x60, 0x02, 0x7F, 0x00, 0x22, 0x90, 0xA2, 0xCF, 0xE0, 0x30, 
+0xE0, 0x17, 0x90, 0xA2, 0xE1, 0xE0, 0x70, 0x4A, 0x90, 0xA2, 0x89, 0xE0, 0xD3, 0x94, 0x00, 0x50, 
+0x41, 0x90, 0xA2, 0xCE, 0xE0, 0x60, 0x38, 0x80, 0x39, 0x31, 0x62, 0xEF, 0x64, 0x01, 0x70, 0x32, 
+0x90, 0xA2, 0x8B, 0xE0, 0xFF, 0x54, 0x03, 0x70, 0x29, 0x90, 0xA2, 0x89, 0xE0, 0xFE, 0xE4, 0xC3, 
+0x9E, 0x40, 0x1F, 0xEF, 0x20, 0xE2, 0x1B, 0x90, 0xA2, 0x8B, 0xE0, 0x20, 0xE4, 0x14, 0x90, 0xA2, 
+0x84, 0xE0, 0x13, 0x13, 0x54, 0x3F, 0x30, 0xE0, 0x09, 0x90, 0xA2, 0xCE, 0xE0, 0x70, 0x03, 0x7F, 
+0x01, 0x22, 0x7F, 0x00, 0x22, 0x90, 0x02, 0x87, 0xE0, 0x70, 0x1F, 0x90, 0x01, 0x00, 0xE0, 0x64, 
+0x3F, 0x70, 0x17, 0x90, 0x02, 0x96, 0xE0, 0x70, 0x11, 0x90, 0x02, 0x86, 0xE0, 0x30, 0xE1, 0x0A, 
+0x90, 0x02, 0x86, 0xE0, 0x20, 0xE3, 0x03, 0x7F, 0x01, 0x22, 0x7F, 0x00, 0x22, 0x7D, 0x2E, 0x7F, 
+0x6F, 0x12, 0x5B, 0x63, 0x7D, 0x02, 0x7F, 0x01, 0x02, 0x58, 0xF6, 0x90, 0xA2, 0x83, 0xE0, 0x30, 
+0xE0, 0x03, 0x12, 0x7B, 0xD6, 0x22, 0x7D, 0x2F, 0x7F, 0xFF, 0x12, 0x5B, 0x63, 0x12, 0x95, 0x8E, 
+0x7D, 0x08, 0x7F, 0x01, 0x02, 0x58, 0xF6, 0x12, 0x57, 0xB1, 0x7D, 0x0C, 0x7F, 0x01, 0x02, 0x58, 
+0xF6, 0x90, 0xA4, 0x3D, 0xE0, 0xFF, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0xA4, 0x92, 
+0xEF, 0xF0, 0x90, 0xA1, 0x7F, 0xE0, 0xFF, 0x90, 0x04, 0x1C, 0xE0, 0x6F, 0x70, 0x3C, 0x90, 0xA2, 
+0x8A, 0xE0, 0x64, 0x0E, 0x70, 0x14, 0x90, 0xA4, 0x92, 0xE0, 0x70, 0x2E, 0x90, 0xA2, 0x83, 0xE0, 
+0x54, 0x7F, 0xF0, 0x51, 0x8F, 0x12, 0x58, 0xF2, 0x80, 0x1D, 0x90, 0xA2, 0x8A, 0xE0, 0x64, 0x06, 
+0x70, 0x18, 0x90, 0xA4, 0x92, 0xE0, 0x60, 0x12, 0x90, 0xA2, 0x83, 0xE0, 0x54, 0xBF, 0xF0, 0x51, 
+0x97, 0x90, 0xA2, 0x8A, 0x74, 0x04, 0xF0, 0x12, 0x57, 0xB4, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 
+0x06, 0x04, 0xE0, 0x54, 0x7F, 0xF0, 0x22, 0x90, 0x06, 0x04, 0xE0, 0x44, 0x40, 0xF0, 0xE0, 0x44, 
+0x80, 0xF0, 0x22, 0x90, 0xA1, 0x82, 0xE0, 0xFF, 0xE4, 0xFB, 0x7D, 0x01, 0x12, 0x5C, 0xA9, 0x90, 
+0xA3, 0xAB, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0xA3, 0xA9, 0xE0, 0xFC, 0xA3, 0xE0, 0xFD, 0xD3, 
+0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0xAB, 0x07, 0x90, 0xA3, 0xAE, 0xED, 0xF0, 0xEC, 0xF9, 0xE0, 
+0xFF, 0xAE, 0x03, 0x74, 0x2A, 0x2E, 0x51, 0xE9, 0x74, 0x2B, 0x2E, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 
+0xF5, 0x83, 0xE9, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 
+0xEF, 0xF0, 0x22, 0xE4, 0xFE, 0xEF, 0x25, 0xE0, 0xFD, 0xEF, 0xC3, 0x94, 0x80, 0x90, 0xFD, 0x12, 
+0x50, 0x04, 0xE4, 0xF0, 0x80, 0x03, 0x74, 0x01, 0xF0, 0x90, 0xFD, 0x10, 0xED, 0xF0, 0xAF, 0x06, 
+0x22, 0x75, 0xF0, 0x0E, 0xEF, 0x90, 0xA3, 0x40, 0x12, 0x4A, 0x2A, 0xE0, 0xFF, 0x7E, 0x00, 0x22, 
+0x90, 0xA4, 0x38, 0xE0, 0xFF, 0xE4, 0xFC, 0xFD, 0xFE, 0x78, 0x1C, 0x12, 0x27, 0x35, 0x90, 0xA3, 
+0xF4, 0x12, 0x27, 0x48, 0x7F, 0x38, 0x22, 0xF0, 0x74, 0x09, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 
+0xF5, 0x83, 0xE0, 0x22, 0x25, 0xE0, 0x24, 0x3D, 0xF5, 0x82, 0xE4, 0x34, 0x43, 0xF5, 0x83, 0x22, 
+0x90, 0xA4, 0x00, 0xE0, 0x24, 0x81, 0xF5, 0x82, 0xE4, 0x34, 0x94, 0xF5, 0x83, 0x22, 0x2F, 0xF5, 
+0x82, 0x74, 0x01, 0x3E, 0xF5, 0x83, 0xE0, 0xFF, 0x90, 0xA1, 0xD5, 0xE0, 0x75, 0xF0, 0x08, 0x22, 
+0x74, 0x29, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x22, 0xF0, 0x90, 0xA2, 0x93, 
+0xA3, 0xE0, 0x90, 0x05, 0x58, 0xF0, 0x22, 0x90, 0xA3, 0xC4, 0xE0, 0x24, 0xB4, 0xF5, 0x82, 0xE4, 
+0x34, 0xA3, 0xF5, 0x83, 0x22, 0x7F, 0x00, 0x7E, 0x0C, 0x12, 0x37, 0x5D, 0x7F, 0x00, 0x7E, 0x0E, 
+0x22, 0x12, 0x4A, 0x2A, 0xE0, 0xFC, 0xA3, 0xE0, 0xF5, 0x82, 0x8C, 0x83, 0x22, 0x12, 0x4A, 0x2A, 
+0xE0, 0xFE, 0xED, 0xFF, 0x90, 0xA3, 0xB3, 0xE0, 0x22, 0xF5, 0x82, 0xE4, 0x34, 0x9E, 0xF5, 0x83, 
+0x22, 0x74, 0x21, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x22, 0x75, 0xF0, 0x0F, 
+0xA4, 0x24, 0xD6, 0xF9, 0x74, 0xA1, 0x35, 0xF0, 0x22, 0xF0, 0x90, 0x01, 0x3F, 0x74, 0x10, 0xF0, 
+0xFD, 0x7F, 0x03, 0x22, 0xEC, 0x13, 0x13, 0x13, 0x54, 0x1F, 0xFF, 0x22, 0xF5, 0x82, 0xE4, 0x34, 
+0xFC, 0xF5, 0x83, 0xEF, 0xF0, 0x22, 0xE4, 0x90, 0xA4, 0x29, 0xF0, 0xA3, 0x22, 0x90, 0xA3, 0x31, 
+0xE0, 0xFE, 0xC3, 0x13, 0x54, 0x07, 0x22, 0x13, 0x13, 0x13, 0x54, 0x1F, 0x90, 0xA3, 0xC4, 0xF0, 
+0x22, 0x54, 0x03, 0x25, 0xE0, 0x25, 0xE0, 0x22, 0x12, 0x4A, 0x2A, 0xE0, 0xFB, 0xE4, 0xFD, 0x0F, 
+0x22, 0x54, 0x01, 0xC4, 0x33, 0x33, 0x33, 0x54, 0x80, 0x22, 0xE5, 0x26, 0x75, 0xF0, 0x08, 0xA4, 
+0x25, 0x25, 0x22, 0xFF, 0x90, 0xA4, 0x54, 0xE0, 0xFB, 0xEF, 0x5B, 0x22, 0x90, 0xA3, 0x8B, 0xE0, 
+0xFE, 0x75, 0xF0, 0x04, 0x22, 0x75, 0x1C, 0x3E, 0x75, 0xF0, 0x04, 0xE5, 0x1A, 0x22, 0xE5, 0x6F, 
+0x54, 0x7F, 0x90, 0xA4, 0x01, 0xF0, 0x22, 0x7F, 0xB4, 0x7E, 0x08, 0x12, 0x36, 0xCE, 0xEF, 0x22, 
+0xE0, 0xFE, 0xA3, 0xE0, 0xF5, 0x82, 0x8E, 0x83, 0x22, 0x90, 0x06, 0x0A, 0xE0, 0x54, 0xF8, 0xF0, 
+0x22, 0xE4, 0x93, 0xFC, 0x74, 0x01, 0x93, 0xFD, 0x22, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 
+0x22, 0xF0, 0x90, 0xA2, 0x9C, 0xE0, 0xC3, 0x9D, 0x22, 0x90, 0xA2, 0x84, 0xE0, 0x44, 0x04, 0xF0, 
+0x22, 0xC4, 0x54, 0x0F, 0x90, 0xA4, 0x5D, 0xF0, 0x22, 0x2F, 0xF8, 0xE6, 0xFE, 0xED, 0xF4, 0x5E, 
+0x22, 0x00, 0xCB, 0x74, 
+};
+u4Byte ArrayLength_MP_8812A_FW_NIC_BT = 29892;
+
+
+void
+ODM_ReadFirmware_MP_8812A_FW_NIC_BT(
+     IN   PDM_ODM_T    pDM_Odm,
+     OUT  u1Byte       *pFirmware,
+     OUT  u4Byte       *pFirmwareSize
+)
+{
+#if (DM_ODM_SUPPORT_TYPE & (ODM_CE))
+	*((SIZE_PTR *)pFirmware) = (SIZE_PTR)Array_MP_8812A_FW_NIC_BT;
+#else
+	ODM_MoveMemory(pDM_Odm, pFirmware, Array_MP_8812A_FW_NIC_BT, ArrayLength_MP_8812A_FW_NIC_BT);
+#endif
+	*pFirmwareSize = ArrayLength_MP_8812A_FW_NIC_BT;
+}
+
+
+u1Byte Array_MP_8812A_FW_WoWLAN[] = {
+0x01, 0x95, 0x30, 0x00, 0x26, 0x00, 0x00, 0x00, 0x11, 0x04, 0x19, 0x54, 0x4A, 0x5E, 0x00, 0x00, 
+0x81, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x02, 0x4C, 0x0D, 0x02, 0x78, 0xF3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x02, 0x7A, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x02, 0x7F, 0xDE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x02, 0x79, 0x76, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x7E, 0x71, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 
+0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0xE7, 0x09, 0xF6, 0x08, 0xDF, 0xFA, 0x80, 0x46, 0xE7, 0x09, 0xF2, 0x08, 0xDF, 0xFA, 0x80, 0x3E, 
+0x88, 0x82, 0x8C, 0x83, 0xE7, 0x09, 0xF0, 0xA3, 0xDF, 0xFA, 0x80, 0x32, 0xE3, 0x09, 0xF6, 0x08, 
+0xDF, 0xFA, 0x80, 0x78, 0xE3, 0x09, 0xF2, 0x08, 0xDF, 0xFA, 0x80, 0x70, 0x88, 0x82, 0x8C, 0x83, 
+0xE3, 0x09, 0xF0, 0xA3, 0xDF, 0xFA, 0x80, 0x64, 0x89, 0x82, 0x8A, 0x83, 0xE0, 0xA3, 0xF6, 0x08, 
+0xDF, 0xFA, 0x80, 0x58, 0x89, 0x82, 0x8A, 0x83, 0xE0, 0xA3, 0xF2, 0x08, 0xDF, 0xFA, 0x80, 0x4C, 
+0x80, 0xD2, 0x80, 0xFA, 0x80, 0xC6, 0x80, 0xD4, 0x80, 0x69, 0x80, 0xF2, 0x80, 0x33, 0x80, 0x10, 
+0x80, 0xA6, 0x80, 0xEA, 0x80, 0x9A, 0x80, 0xA8, 0x80, 0xDA, 0x80, 0xE2, 0x80, 0xCA, 0x80, 0x33, 
+0x89, 0x82, 0x8A, 0x83, 0xEC, 0xFA, 0xE4, 0x93, 0xA3, 0xC8, 0xC5, 0x82, 0xC8, 0xCC, 0xC5, 0x83, 
+0xCC, 0xF0, 0xA3, 0xC8, 0xC5, 0x82, 0xC8, 0xCC, 0xC5, 0x83, 0xCC, 0xDF, 0xE9, 0xDE, 0xE7, 0x80, 
+0x0D, 0x89, 0x82, 0x8A, 0x83, 0xE4, 0x93, 0xA3, 0xF6, 0x08, 0xDF, 0xF9, 0xEC, 0xFA, 0xA9, 0xF0, 
+0xED, 0xFB, 0x22, 0x89, 0x82, 0x8A, 0x83, 0xEC, 0xFA, 0xE0, 0xA3, 0xC8, 0xC5, 0x82, 0xC8, 0xCC, 
+0xC5, 0x83, 0xCC, 0xF0, 0xA3, 0xC8, 0xC5, 0x82, 0xC8, 0xCC, 0xC5, 0x83, 0xCC, 0xDF, 0xEA, 0xDE, 
+0xE8, 0x80, 0xDB, 0x89, 0x82, 0x8A, 0x83, 0xE4, 0x93, 0xA3, 0xF2, 0x08, 0xDF, 0xF9, 0x80, 0xCC, 
+0x88, 0xF0, 0xEF, 0x60, 0x01, 0x0E, 0x4E, 0x60, 0xC3, 0x88, 0xF0, 0xED, 0x24, 0x02, 0xB4, 0x04, 
+0x00, 0x50, 0xB9, 0xF5, 0x82, 0xEB, 0x24, 0x02, 0xB4, 0x04, 0x00, 0x50, 0xAF, 0x23, 0x23, 0x45, 
+0x82, 0x23, 0x90, 0x46, 0x30, 0x73, 0xC5, 0xF0, 0xF8, 0xA3, 0xE0, 0x28, 0xF0, 0xC5, 0xF0, 0xF8, 
+0xE5, 0x82, 0x15, 0x82, 0x70, 0x02, 0x15, 0x83, 0xE0, 0x38, 0xF0, 0x22, 0xEF, 0x2B, 0xFF, 0xEE, 
+0x3A, 0xFE, 0xED, 0x39, 0xFD, 0xEC, 0x38, 0xFC, 0x22, 0xC3, 0xEF, 0x9B, 0xFF, 0xEE, 0x9A, 0xFE, 
+0xED, 0x99, 0xFD, 0xEC, 0x98, 0xFC, 0x22, 0xEF, 0x5B, 0xFF, 0xEE, 0x5A, 0xFE, 0xED, 0x59, 0xFD, 
+0xEC, 0x58, 0xFC, 0x22, 0xEF, 0x4B, 0xFF, 0xEE, 0x4A, 0xFE, 0xED, 0x49, 0xFD, 0xEC, 0x48, 0xFC, 
+0x22, 0xEB, 0x9F, 0xF5, 0xF0, 0xEA, 0x9E, 0x42, 0xF0, 0xE9, 0x9D, 0x42, 0xF0, 0xE8, 0x9C, 0x45, 
+0xF0, 0x22, 0xE0, 0xFC, 0xA3, 0xE0, 0xFD, 0xA3, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x22, 0xE0, 0xF8, 
+0xA3, 0xE0, 0xF9, 0xA3, 0xE0, 0xFA, 0xA3, 0xE0, 0xFB, 0x22, 0xA4, 0x25, 0x82, 0xF5, 0x82, 0xE5, 
+0xF0, 0x35, 0x83, 0xF5, 0x83, 0x22, 0xE0, 0xFB, 0xA3, 0xE0, 0xFA, 0xA3, 0xE0, 0xF9, 0x22, 0xEB, 
+0xF0, 0xA3, 0xEA, 0xF0, 0xA3, 0xE9, 0xF0, 0x22, 0xD0, 0x83, 0xD0, 0x82, 0xF8, 0xE4, 0x93, 0x70, 
+0x12, 0x74, 0x01, 0x93, 0x70, 0x0D, 0xA3, 0xA3, 0x93, 0xF8, 0x74, 0x01, 0x93, 0xF5, 0x82, 0x88, 
+0x83, 0xE4, 0x73, 0x74, 0x02, 0x93, 0x68, 0x60, 0xEF, 0xA3, 0xA3, 0xA3, 0x80, 0xDF, 0xE3, 0xF5, 
+0xF0, 0x09, 0xE2, 0x08, 0xB5, 0xF0, 0x6B, 0xDF, 0xF5, 0x80, 0x67, 0xE3, 0xF5, 0xF0, 0x09, 0xE6, 
+0x08, 0xB5, 0xF0, 0x5E, 0xDF, 0xF5, 0x80, 0x5A, 0x87, 0xF0, 0x09, 0xE6, 0x08, 0xB5, 0xF0, 0x52, 
+0xDF, 0xF6, 0x80, 0x4E, 0x87, 0xF0, 0x09, 0xE2, 0x08, 0xB5, 0xF0, 0x46, 0xDF, 0xF6, 0x80, 0x42, 
+0x88, 0x82, 0x8C, 0x83, 0x87, 0xF0, 0x09, 0xE0, 0xA3, 0xB5, 0xF0, 0x36, 0xDF, 0xF6, 0x80, 0x32, 
+0x88, 0x82, 0x8C, 0x83, 0x87, 0xF0, 0x09, 0xE4, 0x93, 0xA3, 0xB5, 0xF0, 0x25, 0xDF, 0xF5, 0x80, 
+0x21, 0x88, 0x82, 0x8C, 0x83, 0xE3, 0xF5, 0xF0, 0x09, 0xE0, 0xA3, 0xB5, 0xF0, 0x14, 0xDF, 0xF5, 
+0x80, 0x10, 0x88, 0x82, 0x8C, 0x83, 0xE3, 0xF5, 0xF0, 0x09, 0xE4, 0x93, 0xA3, 0xB5, 0xF0, 0x02, 
+0xDF, 0xF4, 0x02, 0x48, 0xBD, 0x80, 0x87, 0x80, 0xE9, 0x80, 0x90, 0x80, 0xD4, 0x80, 0x3E, 0x80, 
+0x15, 0x80, 0x6E, 0x80, 0x7E, 0x80, 0x9D, 0x80, 0xB7, 0x80, 0x8D, 0x80, 0xA3, 0x80, 0x51, 0x80, 
+0x74, 0x80, 0x3C, 0x02, 0x48, 0xC9, 0x89, 0x82, 0x8A, 0x83, 0xEC, 0xFA, 0xE4, 0x93, 0xF5, 0xF0, 
+0xA3, 0xC8, 0xC5, 0x82, 0xC8, 0xCC, 0xC5, 0x83, 0xCC, 0xE4, 0x93, 0xA3, 0xC8, 0xC5, 0x82, 0xC8, 
+0xCC, 0xC5, 0x83, 0xCC, 0xB5, 0xF0, 0x76, 0xDF, 0xE3, 0xDE, 0xE1, 0x80, 0x70, 0x89, 0x82, 0x8A, 
+0x83, 0xE4, 0x93, 0xF5, 0xF0, 0xA3, 0xE2, 0x08, 0xB5, 0xF0, 0x62, 0xDF, 0xF4, 0x80, 0x5E, 0x89, 
+0x82, 0x8A, 0x83, 0xE0, 0xF5, 0xF0, 0xA3, 0xE6, 0x08, 0xB5, 0xF0, 0x51, 0xDF, 0xF5, 0x80, 0x4D, 
+0x89, 0x82, 0x8A, 0x83, 0xE0, 0xF5, 0xF0, 0xA3, 0xE2, 0x08, 0xB5, 0xF0, 0x40, 0xDF, 0xF5, 0x80, 
+0x3C, 0x89, 0x82, 0x8A, 0x83, 0xE4, 0x93, 0xF5, 0xF0, 0xA3, 0xE6, 0x08, 0xB5, 0xF0, 0x2E, 0xDF, 
+0xF4, 0x80, 0x2A, 0x80, 0x02, 0x80, 0x57, 0x89, 0x82, 0x8A, 0x83, 0xEC, 0xFA, 0xE4, 0x93, 0xF5, 
+0xF0, 0xA3, 0xC8, 0xC5, 0x82, 0xC8, 0xCC, 0xC5, 0x83, 0xCC, 0xE0, 0xA3, 0xC8, 0xC5, 0x82, 0xC8, 
+0xCC, 0xC5, 0x83, 0xCC, 0xB5, 0xF0, 0x06, 0xDF, 0xE4, 0xDE, 0xE2, 0x80, 0x00, 0x7F, 0xFF, 0xB5, 
+0xF0, 0x02, 0x0F, 0x22, 0x40, 0x02, 0x7F, 0x01, 0x22, 0x89, 0x82, 0x8A, 0x83, 0xEC, 0xFA, 0xE0, 
+0xF5, 0xF0, 0xA3, 0xC8, 0xC5, 0x82, 0xC8, 0xCC, 0xC5, 0x83, 0xCC, 0xE0, 0xA3, 0xC8, 0xC5, 0x82, 
+0xC8, 0xCC, 0xC5, 0x83, 0xCC, 0xB5, 0xF0, 0xD5, 0xDF, 0xE5, 0xDE, 0xE3, 0x80, 0xCF, 0x89, 0x82, 
+0x8A, 0x83, 0xEC, 0xFA, 0xE0, 0xF5, 0xF0, 0xA3, 0xC8, 0xC5, 0x82, 0xC8, 0xCC, 0xC5, 0x83, 0xCC, 
+0xE4, 0x93, 0xA3, 0xC8, 0xC5, 0x82, 0xC8, 0xCC, 0xC5, 0x83, 0xCC, 0xB5, 0xF0, 0xAF, 0xDF, 0xE4, 
+0xDE, 0xE2, 0x80, 0xA9, 0x88, 0xF0, 0xEF, 0x60, 0x01, 0x0E, 0x4E, 0x60, 0xAB, 0xED, 0x24, 0x02, 
+0xB4, 0x04, 0x00, 0x50, 0x98, 0xF5, 0x82, 0xEB, 0x24, 0x02, 0xB4, 0x04, 0x00, 0x50, 0x8E, 0x23, 
+0x23, 0x45, 0x82, 0x23, 0x90, 0x48, 0x05, 0x73, 0xEF, 0x4E, 0x60, 0x12, 0xEF, 0x60, 0x01, 0x0E, 
+0xED, 0xBB, 0x01, 0x0B, 0x89, 0x82, 0x8A, 0x83, 0xF0, 0xA3, 0xDF, 0xFC, 0xDE, 0xFA, 0x22, 0x89, 
+0xF0, 0x50, 0x07, 0xF7, 0x09, 0xDF, 0xFC, 0xA9, 0xF0, 0x22, 0xBB, 0xFE, 0xFC, 0xF3, 0x09, 0xDF, 
+0xFC, 0xA9, 0xF0, 0x22, 0xC2, 0xAF, 0x80, 0xFE, 0x32, 0x12, 0x49, 0x68, 0x85, 0xD0, 0x0B, 0x75, 
+0xD0, 0x08, 0xAA, 0xE0, 0xC2, 0x8C, 0xE5, 0x8A, 0x24, 0x67, 0xF5, 0x8A, 0xE5, 0x8C, 0x34, 0x79, 
+0xF5, 0x8C, 0xD2, 0x8C, 0xEC, 0x24, 0x87, 0xF8, 0xE6, 0xBC, 0x02, 0x02, 0x74, 0xFF, 0xC3, 0x95, 
+0x81, 0xB4, 0x40, 0x00, 0x40, 0xCE, 0x79, 0x03, 0x78, 0x80, 0x16, 0xE6, 0x08, 0x70, 0x0B, 0xC2, 
+0xAF, 0xE6, 0x30, 0xE1, 0x03, 0x44, 0x18, 0xF6, 0xD2, 0xAF, 0x08, 0xD9, 0xED, 0xEA, 0x8B, 0xD0, 
+0x22, 0xE5, 0x0C, 0xFF, 0x23, 0x24, 0x81, 0xF8, 0x0F, 0x08, 0x08, 0xBF, 0x03, 0x04, 0x7F, 0x00, 
+0x78, 0x81, 0xE6, 0x30, 0xE4, 0xF2, 0x00, 0xE5, 0x0C, 0xC3, 0x9F, 0x50, 0x20, 0x05, 0x0C, 0x74, 
+0x86, 0x25, 0x0C, 0xF8, 0xE6, 0xFD, 0xA6, 0x81, 0x08, 0xE6, 0xAE, 0x0C, 0xBE, 0x02, 0x02, 0x74, 
+0xFF, 0xCD, 0xF8, 0xE8, 0x6D, 0x60, 0xE0, 0x08, 0xE6, 0xC0, 0xE0, 0x80, 0xF6, 0xE5, 0x0C, 0xD3, 
+0x9F, 0x40, 0x27, 0xE5, 0x0C, 0x24, 0x87, 0xF8, 0xE6, 0xAE, 0x0C, 0xBE, 0x02, 0x02, 0x74, 0xFF, 
+0xFD, 0x18, 0xE6, 0xCD, 0xF8, 0xE5, 0x81, 0x6D, 0x60, 0x06, 0xD0, 0xE0, 0xF6, 0x18, 0x80, 0xF5, 
+0xE5, 0x0C, 0x24, 0x86, 0xC8, 0xF6, 0x15, 0x0C, 0x80, 0xD3, 0xE5, 0x0C, 0x23, 0x24, 0x81, 0xF8, 
+0x7F, 0x04, 0xC2, 0xAF, 0xE6, 0x30, 0xE0, 0x03, 0x10, 0xE2, 0x0C, 0x7F, 0x00, 0x30, 0xE1, 0x07, 
+0x30, 0xE3, 0x04, 0x7F, 0x08, 0x54, 0xF4, 0x54, 0x7C, 0xC6, 0xD2, 0xAF, 0x54, 0x80, 0x42, 0x07, 
+0x22, 0x78, 0x86, 0xA6, 0x81, 0x74, 0x02, 0x60, 0x06, 0xFF, 0x08, 0x76, 0xFF, 0xDF, 0xFB, 0x7F, 
+0x03, 0xE4, 0x78, 0x80, 0xF6, 0x08, 0xF6, 0x08, 0xDF, 0xFA, 0x78, 0x81, 0x76, 0x30, 0x90, 0x4C, 
+0xA1, 0x74, 0x01, 0x93, 0xC0, 0xE0, 0xE4, 0x93, 0xC0, 0xE0, 0x43, 0x89, 0x01, 0x75, 0x8A, 0x60, 
+0x75, 0x8C, 0x79, 0xD2, 0x8C, 0xD2, 0xAF, 0x22, 0x02, 0xEF, 0xD3, 0x94, 0x02, 0x40, 0x03, 0x7F, 
+0xFF, 0x22, 0x74, 0x81, 0x2F, 0x2F, 0xF8, 0xE6, 0x20, 0xE5, 0xF4, 0xC2, 0xAF, 0xE6, 0x44, 0x30, 
+0xF6, 0xD2, 0xAF, 0xAE, 0x0C, 0xEE, 0xC3, 0x9F, 0x50, 0x21, 0x0E, 0x74, 0x86, 0x2E, 0xF8, 0xE6, 
+0xF9, 0x08, 0xE6, 0x18, 0xBE, 0x02, 0x02, 0x74, 0xFF, 0xFD, 0xED, 0x69, 0x60, 0x09, 0x09, 0xE7, 
+0x19, 0x19, 0xF7, 0x09, 0x09, 0x80, 0xF3, 0x16, 0x16, 0x80, 0xDA, 0xEE, 0xD3, 0x9F, 0x40, 0x04, 
+0x05, 0x81, 0x05, 0x81, 0xEE, 0xD3, 0x9F, 0x40, 0x22, 0x74, 0x86, 0x2E, 0xF8, 0x08, 0xE6, 0xF9, 
+0xEE, 0xB5, 0x0C, 0x02, 0xA9, 0x81, 0x18, 0x06, 0x06, 0xE6, 0xFD, 0xED, 0x69, 0x60, 0x09, 0x19, 
+0x19, 0xE7, 0x09, 0x09, 0xF7, 0x19, 0x80, 0xF3, 0x1E, 0x80, 0xD9, 0xEF, 0x24, 0x86, 0xF8, 0xE6, 
+0x04, 0xF8, 0xEF, 0x2F, 0x04, 0x90, 0x4C, 0xA1, 0x93, 0xF6, 0x08, 0xEF, 0x2F, 0x93, 0xF6, 0x7F, 
+0x00, 0x22, 0xEF, 0xD3, 0x94, 0x02, 0x40, 0x03, 0x7F, 0xFF, 0x22, 0xEF, 0x23, 0x24, 0x81, 0xF8, 
+0xE6, 0x30, 0xE5, 0xF4, 0xC2, 0xAF, 0xE6, 0x54, 0x8C, 0xF6, 0xD2, 0xAF, 0xE5, 0x0C, 0xB5, 0x07, 
+0x0A, 0x74, 0x86, 0x2F, 0xF8, 0xE6, 0xF5, 0x81, 0x02, 0x49, 0xB1, 0x50, 0x2E, 0x74, 0x87, 0x2F, 
+0xF8, 0xE6, 0xBF, 0x02, 0x02, 0x74, 0xFF, 0xFD, 0x18, 0xE6, 0xF9, 0x74, 0x86, 0x2F, 0xF8, 0xFB, 
+0xE6, 0xFC, 0xE9, 0x6C, 0x60, 0x08, 0xA8, 0x05, 0xE7, 0xF6, 0x1D, 0x19, 0x80, 0xF4, 0xA8, 0x03, 
+0xA6, 0x05, 0x1F, 0xE5, 0x0C, 0xB5, 0x07, 0xE3, 0x7F, 0x00, 0x22, 0x74, 0x87, 0x2F, 0xF8, 0xE6, 
+0xFD, 0x18, 0x86, 0x01, 0x0F, 0x74, 0x86, 0x2F, 0xF8, 0xA6, 0x01, 0x08, 0x86, 0x04, 0xE5, 0x0C, 
+0xB5, 0x07, 0x02, 0xAC, 0x81, 0xED, 0x6C, 0x60, 0x08, 0x0D, 0x09, 0xA8, 0x05, 0xE6, 0xF7, 0x80, 
+0xF4, 0xE5, 0x0C, 0xB5, 0x07, 0xDE, 0x89, 0x81, 0x7F, 0x00, 0x22, 0xEF, 0xD3, 0x94, 0x02, 0x40, 
+0x03, 0x7F, 0xFF, 0x22, 0xEF, 0x23, 0x24, 0x81, 0xF8, 0xC2, 0xAF, 0xE6, 0x30, 0xE5, 0x05, 0x30, 
+0xE0, 0x02, 0xD2, 0xE4, 0xD2, 0xE2, 0xC6, 0xD2, 0xAF, 0x7F, 0x00, 0x30, 0xE2, 0x01, 0x0F, 0x02, 
+0x49, 0xB0, 0x8F, 0xF0, 0xE4, 0xFF, 0xFE, 0xE5, 0x0C, 0x23, 0x24, 0x80, 0xF8, 0xC2, 0xA9, 0x30, 
+0xF7, 0x0D, 0x7F, 0x08, 0xE6, 0x60, 0x0B, 0x2D, 0xF6, 0x60, 0x30, 0x50, 0x2E, 0x80, 0x07, 0x30, 
+0xF1, 0x06, 0xED, 0xF6, 0x60, 0x25, 0x7E, 0x02, 0x08, 0x30, 0xF0, 0x10, 0xC2, 0xAF, 0xE6, 0x10, 
+0xE7, 0x23, 0x0E, 0x30, 0xE2, 0x0C, 0xD2, 0xAF, 0x7F, 0x04, 0x80, 0x12, 0xC2, 0xAF, 0xE6, 0x10, 
+0xE7, 0x13, 0x54, 0xEC, 0x4E, 0xF6, 0xD2, 0xAF, 0x02, 0x49, 0xB1, 0x7F, 0x08, 0x08, 0xEF, 0x44, 
+0x83, 0xF4, 0xC2, 0xAF, 0x56, 0xC6, 0xD2, 0xAF, 0x54, 0x80, 0x4F, 0xFF, 0x22, 0x02, 0x4C, 0x4B, 
+0x02, 0x4A, 0x41, 0xE4, 0x93, 0xA3, 0xF8, 0xE4, 0x93, 0xA3, 0x40, 0x03, 0xF6, 0x80, 0x01, 0xF2, 
+0x08, 0xDF, 0xF4, 0x80, 0x29, 0xE4, 0x93, 0xA3, 0xF8, 0x54, 0x07, 0x24, 0x0C, 0xC8, 0xC3, 0x33, 
+0xC4, 0x54, 0x0F, 0x44, 0x20, 0xC8, 0x83, 0x40, 0x04, 0xF4, 0x56, 0x80, 0x01, 0x46, 0xF6, 0xDF, 
+0xE4, 0x80, 0x0B, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x90, 0x4C, 0x90, 0xE4, 0x7E, 
+0x01, 0x93, 0x60, 0xBC, 0xA3, 0xFF, 0x54, 0x3F, 0x30, 0xE5, 0x09, 0x54, 0x1F, 0xFE, 0xE4, 0x93, 
+0xA3, 0x60, 0x01, 0x0E, 0xCF, 0x54, 0xC0, 0x25, 0xE0, 0x60, 0xA8, 0x40, 0xB8, 0xE4, 0x93, 0xA3, 
+0xFA, 0xE4, 0x93, 0xA3, 0xF8, 0xE4, 0x93, 0xA3, 0xC8, 0xC5, 0x82, 0xC8, 0xCA, 0xC5, 0x83, 0xCA, 
+0xF0, 0xA3, 0xC8, 0xC5, 0x82, 0xC8, 0xCA, 0xC5, 0x83, 0xCA, 0xDF, 0xE9, 0xDE, 0xE7, 0x80, 0xBE, 
+0x41, 0x92, 0xBF, 0x00, 0x41, 0x92, 0xC0, 0x00, 0x41, 0x92, 0xD4, 0x00, 0x41, 0x92, 0xD8, 0x00, 
+0x00, 0x50, 0x00, 0x57, 0xFD, 0x5F, 0xF6, 0x90, 0x00, 0xF0, 0xE0, 0x7F, 0x01, 0x20, 0xE2, 0x02, 
+0x7F, 0x03, 0x22, 0x91, 0xA7, 0x90, 0x8D, 0x07, 0xEF, 0xF0, 0x91, 0xC5, 0x90, 0x01, 0x64, 0x74, 
+0x01, 0xF0, 0x02, 0x35, 0x95, 0x91, 0xEA, 0xB1, 0xF3, 0x12, 0x8F, 0x69, 0x12, 0x8F, 0x88, 0x12, 
+0x8F, 0x43, 0xE4, 0xF5, 0x51, 0x75, 0x52, 0x58, 0xAB, 0x51, 0x7D, 0x02, 0x7F, 0x01, 0x12, 0x39, 
+0x04, 0xAB, 0x52, 0x7D, 0x03, 0x7F, 0x01, 0x02, 0x39, 0x04, 0x90, 0x01, 0x30, 0xE4, 0xB1, 0x12, 
+0x90, 0x01, 0x38, 0xB1, 0x12, 0xFD, 0x7F, 0x50, 0x12, 0x3A, 0x96, 0xE4, 0xFD, 0x7F, 0x51, 0x12, 
+0x3A, 0x96, 0xE4, 0xFD, 0x7F, 0x52, 0x12, 0x3A, 0x96, 0xE4, 0xFD, 0x7F, 0x53, 0x02, 0x3A, 0x96, 
+0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0x22, 0x12, 0x63, 0x57, 0xE4, 0x90, 0x90, 
+0xDE, 0xB1, 0x12, 0x90, 0x90, 0x7C, 0xB1, 0x10, 0xA3, 0xB1, 0x10, 0x90, 0x90, 0x8E, 0xF0, 0xA3, 
+0xF0, 0x90, 0x90, 0xD0, 0xF0, 0xA3, 0xF0, 0x22, 0x90, 0x91, 0x50, 0xEF, 0xF0, 0xA3, 0x12, 0x47, 
+0x5F, 0xB1, 0xED, 0x8B, 0x40, 0x8A, 0x41, 0xB1, 0xD6, 0x24, 0x02, 0xB1, 0x9C, 0xB1, 0xED, 0xE9, 
+0x24, 0x04, 0xB1, 0xCF, 0x24, 0x03, 0xB1, 0x9C, 0xB1, 0xED, 0xE9, 0x24, 0x08, 0xB1, 0xCF, 0x24, 
+0x04, 0xB1, 0x9C, 0xB1, 0xED, 0xE9, 0x24, 0x0C, 0xB1, 0xCF, 0x24, 0x05, 0xB1, 0x9C, 0x90, 0x91, 
+0x50, 0xE0, 0xFE, 0x44, 0x50, 0x90, 0x91, 0x54, 0xF0, 0xA3, 0x74, 0x80, 0xF0, 0xA3, 0x74, 0xFF, 
+0xF0, 0xA3, 0xF0, 0xEE, 0x75, 0xF0, 0x08, 0xA4, 0xB1, 0x9C, 0x90, 0x91, 0x54, 0x74, 0xFF, 0xB1, 
+0x12, 0xB1, 0xE4, 0x04, 0xB1, 0x9C, 0x90, 0x06, 0x72, 0xE4, 0xF0, 0x22, 0xFF, 0x7B, 0x01, 0x7A, 
+0x91, 0x79, 0x54, 0x12, 0x26, 0x1E, 0x90, 0x06, 0x74, 0xD1, 0xCD, 0x90, 0x06, 0x75, 0xF1, 0xF0, 
+0x90, 0x06, 0x76, 0xF1, 0xAD, 0x90, 0x06, 0x77, 0xF0, 0x90, 0x06, 0x70, 0xEF, 0xF0, 0xA3, 0xE4, 
+0xF0, 0xA3, 0x04, 0xF0, 0xA3, 0x74, 0x80, 0xF0, 0x7F, 0x01, 0x7E, 0x00, 0x02, 0x3A, 0xF7, 0xF9, 
+0xE4, 0x3A, 0x8B, 0x40, 0xF5, 0x41, 0x89, 0x42, 0x75, 0x43, 0x04, 0x7B, 0x01, 0x7A, 0x91, 0x79, 
+0x54, 0x12, 0x34, 0x2C, 0x90, 0x91, 0x50, 0xE0, 0x75, 0xF0, 0x08, 0xA4, 0x22, 0x90, 0x91, 0x51, 
+0x02, 0x47, 0x56, 0x90, 0x01, 0x34, 0x74, 0xFF, 0xB1, 0x12, 0x90, 0x01, 0x3C, 0xB1, 0x12, 0xFD, 
+0x7F, 0x54, 0x12, 0x3A, 0x96, 0x7D, 0xFF, 0x7F, 0x55, 0x12, 0x3A, 0x96, 0x7D, 0xFF, 0x7F, 0x56, 
+0x12, 0x3A, 0x96, 0x7D, 0xFF, 0x7F, 0x57, 0x02, 0x3A, 0x96, 0x7E, 0x00, 0x7F, 0x25, 0x7D, 0x00, 
+0x7B, 0x01, 0x7A, 0x8E, 0x79, 0xC5, 0x31, 0x38, 0x90, 0x06, 0x90, 0xE0, 0x44, 0x20, 0xF0, 0x12, 
+0x8F, 0x30, 0xB1, 0x1A, 0x90, 0x8D, 0x07, 0xE0, 0xFF, 0x64, 0x02, 0x70, 0x29, 0xD1, 0xC5, 0x30, 
+0xE0, 0x02, 0x7E, 0x01, 0x90, 0x8E, 0xE4, 0xD1, 0xC3, 0x30, 0xE1, 0x02, 0x7E, 0x01, 0x90, 0x8E, 
+0xE2, 0xD1, 0xC3, 0x30, 0xE2, 0x02, 0x7E, 0x01, 0x90, 0x8E, 0xE3, 0xEE, 0xF0, 0x90, 0xFD, 0x80, 
+0xE0, 0x90, 0x02, 0xFB, 0xF0, 0x22, 0xEF, 0x64, 0x01, 0x70, 0x1D, 0xD1, 0xBC, 0x30, 0xE0, 0x02, 
+0x7F, 0x01, 0x90, 0x8E, 0xE4, 0xD1, 0xBA, 0x30, 0xE1, 0x02, 0x7F, 0x01, 0x90, 0x8E, 0xE2, 0xD1, 
+0xBA, 0x30, 0xE2, 0x02, 0x7F, 0x01, 0x80, 0x23, 0x90, 0x8D, 0x07, 0xE0, 0x64, 0x03, 0x70, 0x20, 
+0xD1, 0xB3, 0x30, 0xE0, 0x02, 0x7F, 0x01, 0x90, 0x8E, 0xE4, 0xD1, 0xB1, 0x30, 0xE1, 0x02, 0x7F, 
+0x01, 0x90, 0x8E, 0xE2, 0xD1, 0xB1, 0x30, 0xE2, 0x02, 0x7F, 0x01, 0x90, 0x8E, 0xE3, 0xEF, 0xF0, 
+0x22, 0xEF, 0xF0, 0x90, 0xFD, 0x78, 0xE0, 0x7F, 0x00, 0x22, 0xEF, 0xF0, 0x90, 0xFD, 0x70, 0xE0, 
+0x7F, 0x00, 0x22, 0xEE, 0xF0, 0x90, 0xFD, 0x80, 0xE0, 0x7E, 0x00, 0x22, 0x4E, 0xF0, 0x90, 0x00, 
+0x01, 0x02, 0x26, 0x37, 0x90, 0x92, 0x5D, 0x12, 0x47, 0x5F, 0x12, 0x26, 0x1E, 0x90, 0x92, 0x62, 
+0xD1, 0xCD, 0x90, 0x92, 0x63, 0x12, 0x80, 0x4C, 0x90, 0x92, 0x64, 0x12, 0x81, 0xD0, 0x90, 0x92, 
+0x65, 0x12, 0x81, 0x4F, 0x90, 0x92, 0x66, 0xF0, 0x90, 0x00, 0x07, 0x12, 0x26, 0x37, 0x90, 0x92, 
+0x67, 0xF1, 0xAD, 0x90, 0x92, 0x6A, 0xF0, 0xED, 0x70, 0x19, 0xFF, 0xF1, 0xA2, 0xE0, 0xB4, 0xFF, 
+0x06, 0xF1, 0xA2, 0xE4, 0xF0, 0x80, 0x07, 0xF1, 0xA2, 0xE0, 0x04, 0xF0, 0x80, 0x05, 0x0F, 0xEF, 
+0xB4, 0x06, 0xE8, 0x90, 0x92, 0x61, 0xE0, 0xFF, 0xB4, 0x04, 0x14, 0xA3, 0xE0, 0xFE, 0xF1, 0x9C, 
+0xEE, 0xF1, 0xB4, 0xFE, 0xF1, 0x9C, 0x12, 0x8D, 0xEF, 0x90, 0x00, 0x02, 0xE4, 0x80, 0x21, 0xEF, 
+0xB4, 0x02, 0x20, 0x90, 0x92, 0x63, 0xE0, 0xF1, 0x9B, 0xEF, 0xF1, 0xB4, 0x44, 0x20, 0x54, 0x7F, 
+0xF1, 0x9B, 0x90, 0x00, 0x01, 0xEF, 0x12, 0x26, 0x76, 0x90, 0x92, 0x62, 0xE0, 0x90, 0x00, 0x02, 
+0x12, 0x26, 0x76, 0xF1, 0x9C, 0xE9, 0x24, 0x03, 0x12, 0x9D, 0xF8, 0x44, 0x20, 0x12, 0x26, 0x64, 
+0x90, 0x92, 0x64, 0xE0, 0xF1, 0x9B, 0x90, 0x00, 0x04, 0xEF, 0x12, 0x26, 0x76, 0x90, 0x92, 0x65, 
+0xE0, 0x90, 0x00, 0x05, 0x12, 0x26, 0x76, 0x90, 0x92, 0x66, 0xE0, 0x90, 0x00, 0x06, 0x12, 0x26, 
+0x76, 0x90, 0x92, 0x67, 0xE0, 0x90, 0x00, 0x07, 0x02, 0x26, 0x76, 0xFF, 0x90, 0x92, 0x5D, 0x02, 
+0x47, 0x56, 0x74, 0x62, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x92, 0xF5, 0x83, 0x22, 0xF0, 0x90, 0x00, 
+0x03, 0x02, 0x26, 0x37, 0x12, 0x26, 0x64, 0x90, 0x92, 0x63, 0xE0, 0x22, 0x90, 0x8E, 0xC5, 0x12, 
+0x7F, 0xC1, 0x30, 0xE0, 0x02, 0xB1, 0x1A, 0x22, 0xF1, 0xF1, 0xFF, 0x30, 0xE0, 0x1C, 0x12, 0x26, 
+0x1E, 0x90, 0x8E, 0xBA, 0xD1, 0xCD, 0x90, 0x8E, 0xBB, 0xF0, 0xEF, 0x54, 0xFE, 0xFF, 0xA3, 0xE0, 
+0x54, 0x01, 0x4F, 0xF1, 0xAD, 0x90, 0x8E, 0xBD, 0xF0, 0x22, 0x12, 0x9C, 0xF9, 0xF0, 0x22, 0x4F, 
+0xF0, 0x90, 0x00, 0x02, 0x02, 0x26, 0x37, 0x80, 0xC3, 0x75, 0xE8, 0x03, 0x75, 0xA8, 0x85, 0x22, 
+0x90, 0x00, 0x80, 0xE0, 0x44, 0x80, 0xFD, 0x7F, 0x80, 0x12, 0x3A, 0x96, 0x12, 0x8F, 0xA7, 0x12, 
+0x3A, 0xB8, 0x12, 0x8F, 0xB4, 0x12, 0x90, 0x18, 0x7F, 0x01, 0x12, 0x4A, 0x79, 0x90, 0x90, 0xE3, 
+0x74, 0x02, 0xF0, 0xFF, 0x12, 0x4A, 0x79, 0x90, 0x90, 0xE3, 0xE0, 0x04, 0xF0, 0x12, 0x4C, 0xB3, 
+0x11, 0x4F, 0x90, 0x00, 0x80, 0xE0, 0x44, 0x40, 0xFD, 0x7F, 0x80, 0x12, 0x3A, 0x96, 0x75, 0x28, 
+0xFF, 0x12, 0x4F, 0xF9, 0x12, 0x78, 0x67, 0x12, 0x90, 0x1F, 0xE4, 0xFF, 0x02, 0x4B, 0x02, 0x12, 
+0x88, 0xF2, 0x12, 0x8A, 0x80, 0x11, 0x80, 0x12, 0x99, 0x4C, 0x12, 0x4E, 0x1A, 0x12, 0x97, 0x39, 
+0x12, 0x8A, 0x40, 0x90, 0x90, 0xF0, 0xE0, 0x54, 0x7F, 0xF0, 0x54, 0xBF, 0xF0, 0x54, 0xDF, 0xF0, 
+0x54, 0xF0, 0xF0, 0xE4, 0x90, 0x90, 0xF2, 0xF0, 0x90, 0x90, 0xF0, 0xE0, 0x54, 0xEF, 0xF0, 0x22, 
+0x7E, 0x00, 0x7F, 0xAC, 0x7D, 0x00, 0x7B, 0x01, 0x7A, 0x8E, 0x79, 0x0E, 0x12, 0x49, 0x38, 0x12, 
+0x99, 0x51, 0x12, 0x49, 0x38, 0x90, 0x8E, 0x11, 0x74, 0x02, 0xF0, 0x90, 0x8E, 0x18, 0x14, 0x12, 
+0x9E, 0x37, 0x90, 0x8E, 0x1E, 0xE4, 0xF0, 0xA3, 0x74, 0x02, 0x31, 0x78, 0xE4, 0xFD, 0xFF, 0x31, 
+0x10, 0x7D, 0x0C, 0x7F, 0x02, 0x31, 0x10, 0x31, 0x0C, 0x90, 0x8D, 0x07, 0xE0, 0xFF, 0xB4, 0x01, 
+0x08, 0x90, 0x8E, 0x1D, 0x74, 0xFF, 0xF0, 0x80, 0x0F, 0xEF, 0x90, 0x8E, 0x1D, 0xB4, 0x03, 0x05, 
+0x74, 0xD4, 0xF0, 0x80, 0x03, 0x74, 0x41, 0xF0, 0x12, 0x9C, 0xF9, 0x31, 0x78, 0x7F, 0x01, 0x12, 
+0x99, 0x1B, 0x90, 0x8E, 0x20, 0x12, 0x27, 0x54, 0x54, 0x33, 0x77, 0x70, 0x7E, 0x00, 0x7F, 0x02, 
+0x7D, 0x00, 0x7B, 0x01, 0x7A, 0x8E, 0x79, 0xBE, 0x12, 0x49, 0x38, 0xF1, 0xF6, 0xF0, 0x90, 0x06, 
+0x0A, 0xE0, 0x54, 0xF8, 0xF1, 0xDC, 0xE4, 0x90, 0x8E, 0xC0, 0xF0, 0x22, 0x7D, 0x0C, 0x7F, 0x01, 
+0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0xAC, 0x07, 0xEF, 0x14, 0x60, 0x15, 0x14, 0x60, 0x19, 
+0x24, 0x02, 0x70, 0x1A, 0xED, 0x54, 0x01, 0xFE, 0x90, 0x8E, 0x0E, 0xE0, 0x54, 0xFE, 0x4E, 0xF0, 
+0x80, 0x0C, 0x90, 0x8E, 0x15, 0xED, 0xF0, 0x80, 0x05, 0x90, 0x8E, 0x14, 0xED, 0xF0, 0x90, 0x00, 
+0x8F, 0xE0, 0x30, 0xE4, 0x2E, 0xEC, 0x14, 0x60, 0x07, 0x14, 0x60, 0x1D, 0x24, 0x02, 0x70, 0x23, 
+0x90, 0x8E, 0x0E, 0xE0, 0x54, 0x01, 0xC4, 0x33, 0x33, 0x33, 0x54, 0x80, 0xFF, 0x90, 0x8E, 0x15, 
+0xE0, 0x54, 0x7F, 0x4F, 0xFD, 0x7F, 0x88, 0x80, 0x07, 0x90, 0x8E, 0x14, 0xE0, 0xFD, 0x7F, 0x89, 
+0x12, 0x3A, 0x96, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xF0, 0x90, 0x8E, 0x48, 0xE0, 0x24, 0x04, 0x90, 
+0x8E, 0x2A, 0xF0, 0xA3, 0x74, 0x08, 0xF0, 0x22, 0x90, 0x92, 0xD5, 0xEF, 0xF0, 0xD1, 0xCF, 0x90, 
+0x92, 0xD5, 0xE0, 0x60, 0x02, 0xF1, 0xDD, 0x7D, 0x04, 0x7F, 0x01, 0x21, 0x10, 0x7D, 0x01, 0x7F, 
+0x04, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x92, 0xD6, 0xED, 0xF0, 0x90, 0x8E, 0x0E, 
+0xE0, 0xFE, 0xC4, 0x13, 0x13, 0x54, 0x03, 0x30, 0xE0, 0x02, 0x41, 0xE3, 0xEE, 0x12, 0x63, 0x02, 
+0x30, 0xE0, 0x02, 0x41, 0xE3, 0x90, 0x8E, 0x15, 0xE0, 0xFE, 0x6F, 0x70, 0x02, 0x41, 0xE3, 0xEF, 
+0x70, 0x02, 0x41, 0x5E, 0x24, 0xFE, 0x70, 0x02, 0x41, 0x97, 0x24, 0xFE, 0x60, 0x48, 0x24, 0xFC, 
+0x70, 0x02, 0x41, 0xD2, 0x24, 0xFC, 0x60, 0x02, 0x41, 0xE3, 0xEE, 0xB4, 0x0E, 0x02, 0x71, 0x03, 
+0x90, 0x8E, 0x15, 0xE0, 0x70, 0x04, 0x7F, 0x01, 0x31, 0x88, 0x90, 0x8E, 0x15, 0xE0, 0xB4, 0x06, 
+0x02, 0x71, 0x1E, 0x90, 0x8E, 0x15, 0xE0, 0xB4, 0x04, 0x0E, 0x90, 0x92, 0xD6, 0xE0, 0xFF, 0x60, 
+0x05, 0x12, 0x98, 0xD9, 0x80, 0x02, 0xF1, 0xEC, 0x90, 0x8E, 0x15, 0xE0, 0x64, 0x08, 0x60, 0x02, 
+0x41, 0xE3, 0xF1, 0xE2, 0x41, 0xE3, 0x90, 0x8E, 0x15, 0xE0, 0x70, 0x04, 0x7F, 0x01, 0x31, 0x88, 
+0x90, 0x8E, 0x15, 0xE0, 0xB4, 0x06, 0x02, 0x71, 0x1E, 0x90, 0x8E, 0x15, 0xE0, 0xB4, 0x0E, 0x07, 
+0x51, 0xE8, 0xBF, 0x01, 0x02, 0x71, 0x03, 0x90, 0x8E, 0x15, 0xE0, 0x64, 0x0C, 0x60, 0x02, 0x41, 
+0xE3, 0x51, 0xE8, 0xEF, 0x64, 0x01, 0x60, 0x02, 0x41, 0xE3, 0x71, 0x3F, 0x41, 0xE3, 0x90, 0x8E, 
+0x15, 0xE0, 0xB4, 0x0E, 0x07, 0x51, 0xE8, 0xBF, 0x01, 0x02, 0x71, 0x03, 0x90, 0x8E, 0x15, 0xE0, 
+0xB4, 0x06, 0x02, 0x71, 0x1E, 0x90, 0x8E, 0x15, 0xE0, 0xB4, 0x0C, 0x07, 0x51, 0xE8, 0xBF, 0x01, 
+0x02, 0x71, 0x3F, 0x90, 0x8E, 0x15, 0xE0, 0x64, 0x04, 0x70, 0x58, 0x12, 0x98, 0x58, 0xEF, 0x64, 
+0x01, 0x70, 0x50, 0xD1, 0x15, 0x80, 0x4C, 0x90, 0x8E, 0x15, 0xE0, 0xB4, 0x0E, 0x07, 0x51, 0xE8, 
+0xBF, 0x01, 0x02, 0x71, 0x03, 0x90, 0x8E, 0x15, 0xE0, 0xB4, 0x06, 0x02, 0x71, 0x1E, 0x90, 0x8E, 
+0x15, 0xE0, 0xB4, 0x0C, 0x07, 0x51, 0xE8, 0xBF, 0x01, 0x02, 0x71, 0x3F, 0x90, 0x8E, 0x15, 0xE0, 
+0x70, 0x04, 0x7F, 0x01, 0x31, 0x88, 0x90, 0x8E, 0x15, 0xE0, 0xB4, 0x04, 0x16, 0x12, 0x99, 0x0D, 
+0x80, 0x11, 0x90, 0x8E, 0x15, 0xE0, 0xB4, 0x0C, 0x0A, 0x12, 0x70, 0xAA, 0x54, 0x3F, 0x30, 0xE0, 
+0x02, 0xB1, 0xF7, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x12, 0x98, 0x3F, 0xBF, 0x01, 0x12, 0x12, 0x98, 
+0x35, 0x20, 0xE0, 0x0C, 0x90, 0x8E, 0x14, 0xE0, 0xD3, 0x94, 0x04, 0x50, 0x03, 0x7F, 0x01, 0x22, 
+0x7F, 0x00, 0x22, 0x90, 0x8E, 0x0F, 0xE0, 0xC3, 0x13, 0x20, 0xE0, 0x04, 0x7D, 0x0C, 0x80, 0x05, 
+0x12, 0x9D, 0x50, 0x7D, 0x04, 0x7F, 0x01, 0x31, 0x10, 0xE4, 0xFD, 0xFF, 0x80, 0x56, 0x90, 0x8E, 
+0x0F, 0xE0, 0x90, 0x06, 0x04, 0x20, 0xE0, 0x08, 0xE0, 0x44, 0x40, 0xF0, 0x7D, 0x04, 0x80, 0x06, 
+0xE0, 0x54, 0x7F, 0xF0, 0x7D, 0x0C, 0x7F, 0x01, 0x31, 0x10, 0xE4, 0xFD, 0xFF, 0x80, 0x35, 0x12, 
+0x6F, 0x25, 0x64, 0x01, 0x70, 0x24, 0x90, 0x8E, 0x0F, 0xE0, 0x54, 0xFD, 0xF0, 0x7D, 0x2C, 0x7F, 
+0x6F, 0x71, 0x74, 0x7D, 0x08, 0x7F, 0x01, 0x12, 0x74, 0xE6, 0xBF, 0x01, 0x0D, 0x90, 0x8E, 0x0E, 
+0xE0, 0x44, 0x80, 0xF0, 0x7D, 0x0E, 0x7F, 0x01, 0x31, 0x10, 0x22, 0xE4, 0xFD, 0x7F, 0x0C, 0x31, 
+0xA1, 0xE4, 0xFD, 0xFF, 0x90, 0x05, 0x22, 0xEF, 0xF0, 0x90, 0x8D, 0x05, 0xED, 0xF0, 0x22, 0xD3, 
+0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x91, 0x1C, 0x12, 0x8B, 0xF6, 0x90, 0x91, 0x34, 0x74, 
+0x18, 0xF0, 0x7E, 0x00, 0x7F, 0x80, 0x7D, 0x00, 0x7B, 0x01, 0x7A, 0x91, 0x79, 0x3C, 0x12, 0x49, 
+0x38, 0x90, 0x01, 0xC4, 0x74, 0x7F, 0xF0, 0x74, 0x53, 0xA3, 0xF0, 0x90, 0x90, 0xD7, 0xE0, 0xFF, 
+0x12, 0x77, 0xB7, 0x90, 0x91, 0x33, 0xEF, 0xF0, 0xF9, 0xE0, 0xFE, 0x24, 0x29, 0x12, 0x75, 0xD6, 
+0x74, 0x41, 0xF0, 0xEE, 0x24, 0x28, 0xFD, 0xE4, 0x33, 0xFC, 0x90, 0x91, 0x34, 0xE0, 0x7A, 0x00, 
+0x2D, 0xFE, 0xEA, 0x3C, 0x90, 0x91, 0x38, 0xF0, 0xA3, 0xCE, 0xF0, 0x74, 0x28, 0x29, 0x12, 0x9D, 
+0x25, 0x90, 0x91, 0x1E, 0xE0, 0xFD, 0x12, 0x80, 0x53, 0xD1, 0x01, 0x90, 0x91, 0x38, 0xE0, 0xFF, 
+0xA3, 0xE0, 0x90, 0x91, 0x36, 0xCF, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0x91, 0x3C, 0x74, 0x01, 0xF0, 
+0xA3, 0x74, 0x03, 0xF0, 0xE4, 0xA3, 0xF0, 0xA3, 0x74, 0x5F, 0xF0, 0x90, 0x91, 0x38, 0xE4, 0x75, 
+0xF0, 0x04, 0x12, 0x46, 0xD6, 0x90, 0x8F, 0xE6, 0xE0, 0xFF, 0x7E, 0x02, 0xB4, 0xFE, 0x02, 0x7E, 
+0xFE, 0x90, 0x91, 0x38, 0xA3, 0xE0, 0xFD, 0xB1, 0xED, 0xEE, 0xF0, 0x74, 0x00, 0x2D, 0xB1, 0xEF, 
+0xE0, 0x90, 0x91, 0x40, 0xF0, 0x90, 0x91, 0x38, 0x12, 0x59, 0x26, 0x90, 0x90, 0x7B, 0xE0, 0x90, 
+0x91, 0x1C, 0xB4, 0x01, 0x0B, 0xE0, 0x44, 0x03, 0xFC, 0xA3, 0xE0, 0x44, 0x10, 0xFD, 0x80, 0x09, 
+0xE0, 0x44, 0x03, 0xFC, 0xA3, 0xE0, 0x44, 0x20, 0xFD, 0x90, 0x91, 0x3A, 0xEC, 0xF0, 0xA3, 0xED, 
+0xF0, 0x90, 0x91, 0x41, 0x74, 0x03, 0xF0, 0xA3, 0x74, 0x12, 0xF0, 0x12, 0x9E, 0x07, 0x12, 0x46, 
+0xD6, 0xEF, 0x64, 0xFE, 0x70, 0x27, 0x90, 0x91, 0x38, 0xA3, 0xE0, 0x24, 0x00, 0x12, 0x87, 0xBC, 
+0xC0, 0x03, 0x8B, 0x40, 0x12, 0x9D, 0x70, 0xD0, 0x03, 0x12, 0x34, 0x2C, 0x75, 0x40, 0x01, 0x12, 
+0x9D, 0x70, 0x7B, 0x01, 0x7A, 0x91, 0x79, 0x43, 0x12, 0x34, 0x2C, 0x80, 0x58, 0x90, 0x90, 0xD2, 
+0xE0, 0xFF, 0xB4, 0x02, 0x27, 0x90, 0x91, 0x38, 0xE0, 0xFC, 0xA3, 0xE0, 0xFD, 0x24, 0x00, 0xF5, 
+0x82, 0x74, 0xFC, 0x3C, 0xF5, 0x83, 0xE4, 0xF0, 0x74, 0x01, 0x2D, 0xF5, 0x82, 0x74, 0xFC, 0x3C, 
+0xF5, 0x83, 0x74, 0x20, 0x12, 0x9E, 0x0F, 0x74, 0x20, 0xF0, 0x80, 0x29, 0xEF, 0xB4, 0x04, 0x25, 
+0x90, 0x91, 0x38, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x24, 0x00, 0xF5, 0x82, 0x74, 0xFC, 0x3E, 0xF5, 
+0x83, 0xE4, 0xF0, 0x74, 0x01, 0x2F, 0xF5, 0x82, 0x74, 0xFC, 0x3E, 0xF5, 0x83, 0x74, 0x10, 0x12, 
+0x9E, 0x0F, 0x74, 0x10, 0xF0, 0x12, 0x9E, 0x07, 0x12, 0x46, 0xD6, 0xE4, 0x90, 0x91, 0x35, 0xF0, 
+0x12, 0x9A, 0x90, 0xE0, 0xFE, 0x90, 0x91, 0x38, 0xA3, 0xE0, 0xFD, 0xEF, 0x2D, 0xB1, 0xED, 0xEE, 
+0xF0, 0x12, 0x9A, 0x90, 0xE0, 0xFE, 0x74, 0x45, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x91, 0xF5, 0x83, 
+0xEE, 0x12, 0x9D, 0xFF, 0xE0, 0xB4, 0x08, 0xD8, 0xD1, 0x0B, 0x90, 0x91, 0x38, 0xE4, 0x75, 0xF0, 
+0x20, 0x12, 0x46, 0xD6, 0x90, 0x91, 0x38, 0x12, 0x5B, 0xBD, 0xD1, 0x01, 0x7B, 0x01, 0x7A, 0x91, 
+0x79, 0x3C, 0x90, 0x91, 0xC3, 0x12, 0x47, 0x5F, 0x90, 0x91, 0xC6, 0x74, 0x63, 0xF0, 0x7A, 0x91, 
+0x79, 0x1F, 0xA3, 0x12, 0x47, 0x5F, 0x7A, 0x8F, 0x79, 0xA2, 0x7D, 0x10, 0x12, 0x59, 0x2D, 0xE4, 
+0x90, 0x91, 0x35, 0xF0, 0x90, 0x91, 0x35, 0xE0, 0xFF, 0xC3, 0x94, 0x10, 0x50, 0x3C, 0x90, 0x91, 
+0x39, 0xE0, 0x2F, 0xFF, 0x90, 0x91, 0x38, 0xE0, 0x34, 0x00, 0xFE, 0x90, 0x91, 0xBC, 0xF0, 0xA3, 
+0xEF, 0xF0, 0x90, 0x90, 0xD7, 0xE0, 0xFD, 0x12, 0x91, 0x02, 0x90, 0x91, 0x33, 0xEF, 0xF0, 0x90, 
+0x91, 0x35, 0xE0, 0x24, 0x1F, 0xF5, 0x82, 0xE4, 0x34, 0x91, 0xF5, 0x83, 0xE0, 0xFF, 0x90, 0x91, 
+0x33, 0xE0, 0xB1, 0xED, 0xEF, 0x12, 0x9D, 0xFF, 0x80, 0xBA, 0x90, 0x04, 0x1D, 0xE0, 0x60, 0x1D, 
+0x90, 0x05, 0x22, 0xE0, 0x90, 0x91, 0xBE, 0xF0, 0x7D, 0x1D, 0xF1, 0x94, 0xBF, 0x01, 0x03, 0x12, 
+0x9C, 0x91, 0x90, 0x91, 0xBE, 0xE0, 0xFF, 0x7D, 0x1E, 0x71, 0x74, 0x80, 0x03, 0x12, 0x9C, 0x91, 
+0x12, 0x77, 0x70, 0x90, 0x8E, 0x15, 0xE0, 0x70, 0x04, 0x7F, 0x01, 0x31, 0x88, 0x74, 0x7F, 0x04, 
+0x90, 0x01, 0xC4, 0xF0, 0x74, 0x53, 0xA3, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x24, 0x00, 0xF5, 
+0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0x22, 0x7D, 0x2F, 0xD1, 0x2D, 0x7D, 0x08, 0x7F, 0x01, 0x21, 
+0x10, 0x90, 0x91, 0x38, 0xE4, 0x75, 0xF0, 0x08, 0x12, 0x46, 0xD6, 0x90, 0x91, 0x38, 0xE4, 0x75, 
+0xF0, 0x08, 0x02, 0x46, 0xD6, 0x7D, 0x2D, 0xF1, 0x94, 0x90, 0x01, 0x37, 0x74, 0x02, 0xF0, 0xFD, 
+0x7F, 0x03, 0x12, 0x72, 0x6E, 0xD1, 0x31, 0xE4, 0xFD, 0x7F, 0x01, 0x21, 0x10, 0x7F, 0xFF, 0x71, 
+0x74, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0xF1, 0x98, 0x7F, 0x00, 0x7E, 0x0C, 0xD1, 0xB5, 
+0x12, 0x9D, 0x44, 0xD1, 0xB5, 0x7F, 0x00, 0x7E, 0x0E, 0x12, 0x37, 0x5D, 0x90, 0x00, 0x02, 0xE0, 
+0x12, 0x9C, 0x78, 0x12, 0x9C, 0x78, 0x54, 0xFE, 0xFD, 0x7F, 0x02, 0x12, 0x3A, 0x96, 0x12, 0x9D, 
+0xD0, 0x44, 0x40, 0xD1, 0xBB, 0x12, 0x9D, 0xE9, 0x90, 0x01, 0x00, 0x74, 0x3F, 0xF0, 0xA3, 0xE0, 
+0x54, 0xFD, 0xF0, 0x90, 0x05, 0x53, 0xE0, 0x44, 0x20, 0x12, 0x88, 0xF7, 0x12, 0x27, 0x48, 0x90, 
+0xAC, 0xB9, 0x12, 0x27, 0x54, 0x77, 0x77, 0x77, 0x77, 0x12, 0x96, 0x4A, 0x12, 0x27, 0x54, 0x77, 
+0x77, 0x77, 0x77, 0x7F, 0xB0, 0x12, 0x9D, 0xAA, 0x70, 0x16, 0x7B, 0x01, 0x7A, 0x92, 0x79, 0x91, 
+0x7D, 0x08, 0x7F, 0x01, 0x12, 0x91, 0x64, 0x90, 0x92, 0x91, 0xE0, 0x44, 0x18, 0x12, 0x91, 0x13, 
+0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x12, 0x36, 0xCE, 0xEF, 0x54, 0xFC, 0xFF, 0xEC, 0x90, 0x92, 0x92, 
+0x12, 0x27, 0x48, 0x90, 0x92, 0x92, 0x12, 0x47, 0x32, 0x90, 0xAC, 0xB9, 0x02, 0x27, 0x48, 0xD3, 
+0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x8E, 0x20, 0xD1, 0xC6, 0x7F, 0xB0, 0x7E, 0x0C, 0x12, 
+0x37, 0x5D, 0x90, 0x8E, 0x20, 0xD1, 0xC6, 0x7F, 0xB0, 0x7E, 0x0E, 0x12, 0x37, 0x5D, 0x90, 0x00, 
+0x10, 0xE0, 0x44, 0x0C, 0xFD, 0x7F, 0x10, 0x12, 0x3A, 0x96, 0x90, 0x00, 0x72, 0xE0, 0x54, 0xF3, 
+0xFD, 0x7F, 0x72, 0x12, 0x3A, 0x96, 0x90, 0x01, 0x01, 0xE0, 0x44, 0x02, 0xF0, 0x90, 0x01, 0x00, 
+0x74, 0xFF, 0xF0, 0x90, 0x06, 0xB7, 0x74, 0x09, 0xF0, 0x90, 0x06, 0xB4, 0x74, 0x86, 0xF0, 0x12, 
+0x9D, 0xD0, 0x54, 0xBF, 0xF1, 0x6D, 0xD1, 0xC6, 0x12, 0x9D, 0xE9, 0x90, 0x00, 0x02, 0xE0, 0x44, 
+0x01, 0xFD, 0x7F, 0x02, 0x12, 0x3A, 0x96, 0x7F, 0x00, 0x7E, 0x0C, 0xF1, 0x67, 0xD1, 0xC6, 0x12, 
+0x9D, 0x44, 0xF1, 0x67, 0xD1, 0xC6, 0x7F, 0x00, 0x12, 0x9D, 0xAA, 0x70, 0x15, 0x12, 0x91, 0xA0, 
+0x54, 0xE7, 0x12, 0x91, 0x13, 0x12, 0x91, 0xA0, 0x54, 0x18, 0x70, 0x06, 0x90, 0x01, 0xBF, 0xE0, 
+0x04, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x12, 0x36, 0xCE, 0xEF, 0x44, 0x03, 0xFF, 0xEC, 0x90, 
+0x92, 0x8C, 0x12, 0x27, 0x48, 0x90, 0x92, 0x8C, 0x22, 0x90, 0x8E, 0x12, 0xE0, 0x64, 0x01, 0x70, 
+0x12, 0x12, 0x74, 0x1B, 0x60, 0x05, 0x71, 0x6B, 0x02, 0x97, 0xFB, 0x90, 0x8E, 0x15, 0xE0, 0x70, 
+0x02, 0x31, 0x9D, 0x22, 0x7F, 0xFF, 0x71, 0x74, 0xE4, 0x90, 0x92, 0xC5, 0xF0, 0xA3, 0xF0, 0x90, 
+0x05, 0xF8, 0xE0, 0x70, 0x0F, 0xA3, 0xE0, 0x70, 0x0B, 0xA3, 0xE0, 0x70, 0x07, 0xA3, 0xE0, 0x70, 
+0x03, 0x7F, 0x01, 0x22, 0xD3, 0x90, 0x92, 0xC6, 0xE0, 0x94, 0xE8, 0x90, 0x92, 0xC5, 0xE0, 0x94, 
+0x03, 0x40, 0x0A, 0x90, 0x01, 0xC0, 0xE0, 0x44, 0x20, 0xF0, 0x7F, 0x00, 0x22, 0x7F, 0x32, 0x7E, 
+0x00, 0x12, 0x3A, 0xF7, 0x90, 0x92, 0xC5, 0x12, 0x59, 0x26, 0x80, 0xC3, 0xF0, 0xE4, 0xFD, 0xFF, 
+0x61, 0x74, 0xD1, 0xCF, 0xF1, 0xDD, 0x7D, 0x0C, 0x7F, 0x01, 0x21, 0x10, 0xF1, 0xF6, 0xF1, 0xDC, 
+0x7D, 0x0C, 0x7F, 0x01, 0x21, 0x10, 0x90, 0x06, 0x04, 0xE0, 0x54, 0x7F, 0x22, 0xE4, 0x90, 0x90, 
+0xF8, 0xF0, 0x90, 0x90, 0xF8, 0xE0, 0x64, 0x01, 0xF0, 0x24, 0xFD, 0x90, 0x01, 0xC4, 0xF0, 0x74, 
+0x57, 0xA3, 0xF0, 0x12, 0x3A, 0xEB, 0xBF, 0x01, 0x03, 0x12, 0x31, 0x69, 0x90, 0x8E, 0x12, 0xE0, 
+0x60, 0x0F, 0x90, 0x8E, 0x15, 0xE0, 0xFF, 0x90, 0x8E, 0x14, 0xE0, 0x6F, 0x60, 0x03, 0x12, 0x77, 
+0x97, 0xC2, 0xAF, 0x12, 0x8F, 0xE4, 0xBF, 0x01, 0x02, 0x11, 0x71, 0xD2, 0xAF, 0x11, 0x44, 0x12, 
+0x49, 0xB1, 0x80, 0xBE, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x00, 0x8F, 0xE0, 0x30, 
+0xE6, 0x1A, 0x90, 0x00, 0x8C, 0xE0, 0xF5, 0x15, 0xA3, 0xE0, 0xA3, 0xE0, 0xF5, 0x16, 0x90, 0x00, 
+0x8F, 0xE0, 0x30, 0xE0, 0x07, 0xE4, 0xFD, 0x7F, 0x8D, 0x12, 0x3A, 0x96, 0xD0, 0xD0, 0x92, 0xAF, 
+0x22, 0x90, 0x8E, 0x0E, 0xE0, 0x30, 0xE0, 0x02, 0x11, 0x7B, 0x22, 0x90, 0x8E, 0x15, 0xE0, 0xFF, 
+0x60, 0x03, 0xB4, 0x08, 0x08, 0x12, 0x98, 0x94, 0xBF, 0x01, 0x02, 0x11, 0x8E, 0x22, 0xD3, 0x10, 
+0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x12, 0x92, 0x27, 0x11, 0x9F, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x12, 
+0x92, 0x0A, 0x90, 0x00, 0x08, 0xE0, 0x54, 0xEF, 0xFD, 0x7F, 0x08, 0x12, 0x3A, 0x96, 0xE4, 0xFF, 
+0x11, 0xCD, 0x90, 0x8D, 0x07, 0xE0, 0xB4, 0x03, 0x0C, 0x90, 0x00, 0x70, 0xE0, 0x54, 0x7F, 0xFD, 
+0x7F, 0x70, 0x12, 0x3A, 0x96, 0x90, 0x8E, 0x0F, 0xE0, 0x54, 0xEF, 0xF0, 0x22, 0x90, 0x92, 0xB9, 
+0xEF, 0x12, 0x97, 0x49, 0x90, 0x01, 0x09, 0xE0, 0x7F, 0x00, 0x30, 0xE7, 0x02, 0x7F, 0x01, 0x90, 
+0x92, 0xB9, 0xE0, 0x6F, 0x60, 0x35, 0xC3, 0x90, 0x92, 0xBB, 0xE0, 0x94, 0x88, 0x90, 0x92, 0xBA, 
+0xE0, 0x94, 0x13, 0x40, 0x08, 0x90, 0x01, 0xC0, 0xE0, 0x44, 0x10, 0xF0, 0x22, 0x90, 0x92, 0xBA, 
+0x31, 0x26, 0x12, 0x78, 0x60, 0xD3, 0x90, 0x92, 0xBB, 0xE0, 0x94, 0x32, 0x90, 0x92, 0xBA, 0xE0, 
+0x94, 0x00, 0x40, 0xC0, 0x90, 0x01, 0xC6, 0xE0, 0x30, 0xE0, 0xB9, 0x22, 0x7F, 0x01, 0x7E, 0x00, 
+0x12, 0x3A, 0xF7, 0x90, 0x92, 0x0F, 0xE4, 0x75, 0xF0, 0x01, 0x02, 0x46, 0xD6, 0xD3, 0x10, 0xAF, 
+0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x91, 0xBF, 0x12, 0x47, 0x5F, 0x90, 0x91, 0xC2, 0xED, 0xF0, 0xE4, 
+0x90, 0x92, 0x0E, 0xF0, 0x71, 0xB1, 0x50, 0x06, 0x51, 0xFA, 0x71, 0x96, 0x80, 0xF6, 0x90, 0x91, 
+0xBF, 0x71, 0xDD, 0x12, 0x9C, 0xCF, 0x71, 0x21, 0x94, 0x40, 0x50, 0x0A, 0x51, 0xFA, 0xE0, 0x64, 
+0x36, 0xF0, 0x51, 0xE8, 0x80, 0xF0, 0x90, 0x91, 0xC3, 0x12, 0x47, 0x56, 0x90, 0x91, 0xC6, 0x71, 
+0x8E, 0x74, 0x80, 0x12, 0x26, 0x76, 0xEF, 0x75, 0xF0, 0x08, 0xA4, 0x24, 0x00, 0xFF, 0xE5, 0xF0, 
+0x34, 0x02, 0xFC, 0x90, 0x00, 0x7E, 0x12, 0x26, 0x76, 0xEF, 0x90, 0x00, 0x7F, 0x71, 0xC4, 0xF0, 
+0x71, 0xA8, 0xC3, 0x94, 0xC0, 0xEE, 0x94, 0x00, 0x50, 0x58, 0x71, 0x86, 0x50, 0x09, 0x12, 0x9C, 
+0x30, 0x71, 0x76, 0x7B, 0x01, 0x80, 0x05, 0x12, 0x9B, 0xB3, 0x71, 0x7E, 0x12, 0x9D, 0x0E, 0xE4, 
+0x51, 0xDE, 0x90, 0x01, 0x8C, 0xE0, 0x30, 0xE4, 0x0B, 0x51, 0xEF, 0xE0, 0x94, 0x03, 0x50, 0x04, 
+0x31, 0x1C, 0x80, 0xEE, 0x71, 0x12, 0x40, 0x08, 0x90, 0x06, 0x31, 0xE0, 0x44, 0x01, 0x71, 0x0B, 
+0x71, 0x9F, 0x70, 0x1A, 0x51, 0xDE, 0x90, 0x01, 0x8C, 0xE0, 0x20, 0xE5, 0x0B, 0x51, 0xEF, 0xE0, 
+0x94, 0x03, 0x50, 0x04, 0x31, 0x1C, 0x80, 0xEE, 0x71, 0x12, 0x40, 0x02, 0x71, 0x05, 0x71, 0xBA, 
+0x80, 0x9E, 0x71, 0x28, 0x7D, 0x84, 0x12, 0x33, 0x2F, 0xE4, 0x90, 0x92, 0x0E, 0xF0, 0x71, 0xB1, 
+0x50, 0x06, 0x51, 0xFA, 0x71, 0x96, 0x80, 0xF6, 0x90, 0x91, 0xBF, 0x71, 0xDD, 0x12, 0x9C, 0xCF, 
+0x71, 0x21, 0x94, 0x40, 0x50, 0x0A, 0x51, 0xFA, 0xE0, 0x64, 0x5C, 0xF0, 0x51, 0xE8, 0x80, 0xF0, 
+0xE4, 0x90, 0x91, 0xCA, 0xF0, 0x71, 0x70, 0x90, 0x91, 0xCA, 0x71, 0x8E, 0x12, 0x26, 0x37, 0xFE, 
+0x71, 0xCE, 0xEE, 0x51, 0xE5, 0xE0, 0xB4, 0x14, 0xEC, 0x90, 0x91, 0xC3, 0x12, 0x47, 0x56, 0x90, 
+0x00, 0x14, 0x74, 0x80, 0x12, 0x26, 0x76, 0x90, 0x91, 0xCA, 0x74, 0x15, 0xF0, 0x71, 0x21, 0x94, 
+0x3E, 0x50, 0x07, 0x71, 0xCE, 0xE4, 0x51, 0xE5, 0x80, 0xF3, 0x90, 0x91, 0xC3, 0x12, 0x47, 0x56, 
+0x90, 0x00, 0x3E, 0x74, 0x02, 0x12, 0x26, 0x76, 0x90, 0x00, 0x3F, 0x74, 0xA0, 0x71, 0xC4, 0xF0, 
+0x71, 0xA8, 0xC3, 0x94, 0x80, 0xEE, 0x94, 0x00, 0x50, 0x58, 0x71, 0x86, 0x50, 0x09, 0x12, 0x9C, 
+0x30, 0x71, 0x76, 0x7B, 0x01, 0x80, 0x05, 0x12, 0x9B, 0xB3, 0x71, 0x7E, 0x12, 0x9D, 0x0E, 0xE4, 
+0x51, 0xDE, 0x90, 0x01, 0x8C, 0xE0, 0x30, 0xE4, 0x0B, 0x51, 0xEF, 0xE0, 0x94, 0x03, 0x50, 0x04, 
+0x31, 0x1C, 0x80, 0xEE, 0x71, 0x12, 0x40, 0x08, 0x90, 0x06, 0x31, 0xE0, 0x44, 0x01, 0x71, 0x0B, 
+0x71, 0x9F, 0x70, 0x1A, 0x51, 0xDE, 0x90, 0x01, 0x8C, 0xE0, 0x20, 0xE5, 0x0B, 0x51, 0xEF, 0xE0, 
+0x94, 0x03, 0x50, 0x04, 0x31, 0x1C, 0x80, 0xEE, 0x71, 0x12, 0x40, 0x02, 0x71, 0x05, 0x71, 0xBA, 
+0x80, 0x9E, 0x71, 0x28, 0x7D, 0x84, 0x12, 0x33, 0x2F, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0x92, 
+0x0F, 0xF0, 0xA3, 0xF0, 0x22, 0x12, 0x26, 0x76, 0x90, 0x91, 0xCA, 0xE0, 0x04, 0xF0, 0x22, 0xC3, 
+0x90, 0x92, 0x10, 0xE0, 0x94, 0xE8, 0x90, 0x92, 0x0F, 0x22, 0x74, 0xCB, 0x2F, 0xF5, 0x82, 0xE4, 
+0x34, 0x91, 0xF5, 0x83, 0x22, 0x90, 0x06, 0x31, 0xE0, 0x44, 0x02, 0xF0, 0xEE, 0x90, 0x06, 0x36, 
+0xF0, 0x22, 0x90, 0x92, 0x0F, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0xC3, 0x94, 0xE8, 0xEE, 0x94, 0x03, 
+0x22, 0x90, 0x91, 0xCA, 0xE0, 0xFF, 0xC3, 0x22, 0x90, 0x91, 0xC7, 0x12, 0x47, 0x56, 0xE9, 0x24, 
+0x10, 0xF9, 0xE4, 0x3A, 0xFA, 0x7D, 0x80, 0x12, 0x33, 0x2F, 0x90, 0x91, 0xC7, 0x12, 0x47, 0x56, 
+0xE9, 0x24, 0x0C, 0xF9, 0xE4, 0x3A, 0xFA, 0x7D, 0x81, 0x12, 0x33, 0x2F, 0x90, 0x91, 0xC7, 0x12, 
+0x47, 0x56, 0xE9, 0x24, 0x08, 0xF9, 0xE4, 0x3A, 0xFA, 0x7D, 0x82, 0x12, 0x33, 0x2F, 0x90, 0x91, 
+0xC7, 0x12, 0x47, 0x56, 0xE9, 0x24, 0x04, 0xF9, 0xE4, 0x3A, 0xFA, 0x7D, 0x83, 0x12, 0x33, 0x2F, 
+0x90, 0x91, 0xC7, 0x02, 0x47, 0x56, 0x24, 0xD7, 0xF9, 0xE4, 0x34, 0x91, 0xFA, 0x22, 0x24, 0xCC, 
+0xF9, 0xEA, 0x34, 0xFF, 0xFA, 0x22, 0xC3, 0xEF, 0x94, 0x40, 0xEE, 0x94, 0x00, 0x22, 0xE0, 0xFF, 
+0xF5, 0x82, 0x75, 0x83, 0x00, 0x22, 0xE4, 0xF0, 0x90, 0x92, 0x0E, 0xE0, 0x04, 0xF0, 0x22, 0x90, 
+0x92, 0x0C, 0xE0, 0x54, 0x3F, 0x64, 0x30, 0x22, 0x90, 0x92, 0x0B, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 
+0x22, 0x90, 0x92, 0x0E, 0xE0, 0xFF, 0xC3, 0x94, 0x40, 0x22, 0x90, 0x92, 0x0B, 0xE4, 0x75, 0xF0, 
+0x10, 0x02, 0x46, 0xD6, 0x12, 0x26, 0x76, 0xE4, 0x90, 0x92, 0x0B, 0xF0, 0xA3, 0x22, 0x90, 0x91, 
+0xC3, 0x12, 0x47, 0x56, 0x8F, 0x82, 0x75, 0x83, 0x00, 0x22, 0x90, 0x92, 0x4E, 0x12, 0x47, 0x56, 
+0x8B, 0x40, 0x8A, 0x41, 0x89, 0x42, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x92, 
+0x4B, 0x12, 0x47, 0x5F, 0x78, 0x57, 0x7C, 0x92, 0x7D, 0x01, 0x7B, 0xFF, 0x7A, 0x40, 0x79, 0x5E, 
+0xF1, 0xD3, 0x90, 0x05, 0x22, 0xE0, 0x90, 0x92, 0x56, 0xF0, 0x90, 0x04, 0x1D, 0xE0, 0x60, 0x0A, 
+0x7D, 0x33, 0x12, 0x57, 0x94, 0xBF, 0x01, 0x16, 0x80, 0x00, 0x90, 0x90, 0xD5, 0xE0, 0xFF, 0x7B, 
+0x18, 0x7D, 0x01, 0x12, 0x74, 0x57, 0x90, 0x92, 0x53, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0x92, 
+0x53, 0x12, 0x81, 0xE4, 0x90, 0x92, 0x55, 0xEF, 0xF0, 0x90, 0x92, 0x53, 0x12, 0x9D, 0x21, 0x90, 
+0x92, 0x51, 0xE0, 0xFD, 0x12, 0x80, 0x53, 0x90, 0x92, 0x52, 0xE0, 0x70, 0x49, 0xF1, 0xE2, 0xFA, 
+0x7B, 0x01, 0xC0, 0x03, 0xC0, 0x02, 0xC0, 0x01, 0x71, 0xDA, 0x75, 0x43, 0x06, 0xD0, 0x01, 0xD0, 
+0x02, 0xD0, 0x03, 0x91, 0xFA, 0x12, 0x9D, 0x5C, 0x7B, 0x01, 0xC0, 0x03, 0xC0, 0x02, 0xC0, 0x01, 
+0x71, 0xDA, 0x75, 0x43, 0x06, 0xD0, 0x01, 0xD0, 0x02, 0xD0, 0x03, 0x91, 0xFA, 0x12, 0x9D, 0x66, 
+0x7B, 0x01, 0xC0, 0x03, 0xC0, 0x02, 0xC0, 0x01, 0x90, 0x92, 0x4B, 0x71, 0xDD, 0x75, 0x43, 0x04, 
+0xD0, 0x01, 0xD0, 0x02, 0x80, 0x46, 0x90, 0x92, 0x52, 0xE0, 0x64, 0x01, 0x70, 0x43, 0xF1, 0xE2, 
+0xFA, 0x7B, 0x01, 0xC0, 0x03, 0x8B, 0x40, 0x75, 0x41, 0x8E, 0x75, 0x42, 0xEA, 0x75, 0x43, 0x06, 
+0xD0, 0x03, 0x91, 0xFA, 0x12, 0x9D, 0x5C, 0x7B, 0x01, 0xC0, 0x03, 0x8B, 0x40, 0x75, 0x41, 0x8E, 
+0x75, 0x42, 0xF4, 0x75, 0x43, 0x06, 0xD0, 0x03, 0x91, 0xFA, 0x12, 0x9D, 0x66, 0x7B, 0x01, 0xC0, 
+0x03, 0x8B, 0x40, 0x75, 0x41, 0x8E, 0x75, 0x42, 0xFA, 0x75, 0x43, 0x04, 0xD0, 0x03, 0x12, 0x34, 
+0x2C, 0x90, 0x06, 0x30, 0xE0, 0x44, 0x10, 0xF0, 0x90, 0x92, 0x56, 0xE0, 0xFF, 0x7D, 0x34, 0x12, 
+0x53, 0x74, 0x12, 0x77, 0x70, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x12, 0x34, 0x2C, 0x90, 0x92, 0x53, 
+0xA3, 0xE0, 0xFF, 0xA3, 0x22, 0x12, 0x8B, 0xF3, 0x78, 0x17, 0x7C, 0x91, 0x7D, 0x01, 0x7B, 0xFF, 
+0x7A, 0x40, 0x79, 0x50, 0xF1, 0xD3, 0x78, 0x1D, 0x7C, 0x91, 0x7D, 0x01, 0x7B, 0xFF, 0x7A, 0x40, 
+0x79, 0x56, 0xF1, 0xCC, 0x78, 0x21, 0x7C, 0x91, 0x7D, 0x01, 0x7B, 0xFF, 0x7A, 0x40, 0x79, 0x5A, 
+0xF1, 0xCC, 0xE4, 0x90, 0x91, 0x26, 0xF0, 0xD1, 0xF8, 0xCF, 0x24, 0x06, 0xCF, 0xF1, 0x2A, 0xEF, 
+0x64, 0x08, 0x60, 0x02, 0xC1, 0x3C, 0xD1, 0xF8, 0xCF, 0x24, 0x07, 0xCF, 0xF1, 0x2A, 0xEF, 0x64, 
+0x06, 0x60, 0x02, 0xC1, 0x3C, 0x90, 0x91, 0x26, 0x04, 0xF0, 0xE4, 0x90, 0x91, 0x25, 0xF0, 0xF1, 
+0x0A, 0x94, 0x06, 0x50, 0x1B, 0x90, 0x91, 0x0F, 0xE0, 0x24, 0x0A, 0xFD, 0x90, 0x91, 0x0E, 0xD1, 
+0x46, 0x90, 0x91, 0x25, 0xE0, 0x24, 0x11, 0xF5, 0x82, 0xE4, 0x34, 0x91, 0xF1, 0x1A, 0x80, 0xDF, 
+0x78, 0x11, 0x7C, 0x91, 0x7D, 0x01, 0x7B, 0x01, 0x7A, 0x8E, 0x79, 0xD5, 0x12, 0x8B, 0xEA, 0x60, 
+0x02, 0xC1, 0x3C, 0x90, 0x91, 0x25, 0xF0, 0xF1, 0x0A, 0x94, 0x04, 0x50, 0x19, 0xF1, 0xC0, 0xF1, 
+0x03, 0xCD, 0x24, 0x20, 0xCD, 0xD1, 0x47, 0x90, 0x91, 0x25, 0xE0, 0x24, 0x21, 0xF5, 0x82, 0xE4, 
+0x34, 0x91, 0xF1, 0x1A, 0x80, 0xE1, 0x78, 0x21, 0x7C, 0x91, 0x12, 0x8C, 0x95, 0x70, 0x74, 0x90, 
+0x06, 0x30, 0xE0, 0x44, 0x01, 0x54, 0xDF, 0xF0, 0x90, 0x8E, 0xC7, 0xE0, 0x30, 0xE0, 0x0A, 0x90, 
+0x01, 0xC7, 0x74, 0x09, 0xF0, 0xF1, 0xDA, 0x80, 0x63, 0xE4, 0x90, 0x91, 0x25, 0xF0, 0xF1, 0x0A, 
+0x94, 0x06, 0x50, 0x19, 0xF1, 0xC0, 0xF1, 0x03, 0xCD, 0x24, 0x10, 0xCD, 0xD1, 0x47, 0x90, 0x91, 
+0x25, 0xE0, 0x24, 0x17, 0xF5, 0x82, 0xE4, 0x34, 0x91, 0xF1, 0x1A, 0x80, 0xE1, 0xE4, 0x90, 0x91, 
+0x25, 0xF0, 0xF1, 0x0A, 0x94, 0x04, 0x50, 0x19, 0xF1, 0xC0, 0xF1, 0x03, 0xCD, 0x24, 0x16, 0xCD, 
+0xD1, 0x47, 0x90, 0x91, 0x25, 0xE0, 0x24, 0x1D, 0xF5, 0x82, 0xE4, 0x34, 0x91, 0xF1, 0x1A, 0x80, 
+0xE1, 0x7B, 0x01, 0x7A, 0x91, 0x79, 0x17, 0x12, 0x96, 0xEE, 0xF0, 0x7A, 0x91, 0x79, 0x1D, 0x71, 
+0xE7, 0x80, 0x09, 0x90, 0x06, 0x30, 0xE0, 0x44, 0x21, 0x54, 0xEF, 0xF0, 0x90, 0x91, 0x26, 0xE0, 
+0xFF, 0x22, 0xFD, 0x90, 0x91, 0x17, 0xE0, 0x34, 0x00, 0xFC, 0x7E, 0x00, 0xED, 0x2F, 0xFF, 0xEE, 
+0x3C, 0xFE, 0xE4, 0xFD, 0xAB, 0x07, 0xAA, 0x06, 0xED, 0x2B, 0xFB, 0xE4, 0x3A, 0xFA, 0xC3, 0x90, 
+0x8D, 0xFA, 0xE0, 0x9B, 0x90, 0x8D, 0xF9, 0xE0, 0x9A, 0x50, 0x0A, 0xA3, 0x12, 0x87, 0xCF, 0xEB, 
+0x9F, 0xFB, 0xEA, 0x9E, 0xFA, 0x12, 0x87, 0x8F, 0x74, 0x00, 0x2F, 0x12, 0x8D, 0x5D, 0xE0, 0xFF, 
+0x22, 0x90, 0x91, 0x1E, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x7D, 0x09, 0xD1, 0x54, 0xEF, 0x64, 0x06, 
+0x70, 0x24, 0xF1, 0x11, 0x7D, 0x14, 0xD1, 0x54, 0xEF, 0x70, 0x1B, 0xF1, 0x11, 0x7D, 0x15, 0xD1, 
+0x54, 0xEF, 0x64, 0x50, 0x70, 0x10, 0xF1, 0x11, 0x7D, 0x21, 0xD1, 0x54, 0xEF, 0x20, 0xE0, 0x03, 
+0x30, 0xE2, 0x03, 0x7F, 0x01, 0x22, 0x90, 0x8E, 0xC6, 0xE0, 0x13, 0x13, 0x54, 0x3F, 0x30, 0xE0, 
+0x34, 0xF1, 0x11, 0x7D, 0x09, 0xD1, 0x54, 0xEF, 0x64, 0x11, 0x70, 0x29, 0x90, 0x91, 0x1F, 0xE0, 
+0x24, 0x14, 0x12, 0x8B, 0xE1, 0x90, 0x91, 0x20, 0xF0, 0xA3, 0xEF, 0xF0, 0x7D, 0x02, 0xD1, 0x54, 
+0xEF, 0x70, 0x12, 0x90, 0x91, 0x20, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x7D, 0x03, 0xD1, 0x54, 0xBF, 
+0x89, 0x03, 0x7F, 0x01, 0x22, 0x7F, 0x00, 0x22, 0x90, 0x91, 0x10, 0xE0, 0xFF, 0x90, 0x91, 0x0F, 
+0xE0, 0x2F, 0xFF, 0x90, 0x91, 0x0E, 0xE0, 0x34, 0x00, 0x22, 0x90, 0x91, 0x25, 0xE0, 0xFF, 0xC3, 
+0x22, 0x90, 0x91, 0x1E, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x22, 0xF5, 0x83, 0xEF, 0xF0, 0x90, 0x91, 
+0x25, 0xE0, 0x04, 0xF0, 0x22, 0xFF, 0x90, 0x91, 0x17, 0xE0, 0x34, 0x00, 0xFE, 0xE4, 0xFD, 0xC1, 
+0x54, 0x90, 0x91, 0x10, 0xED, 0xF0, 0xA3, 0xEB, 0xF0, 0x12, 0x8A, 0xE1, 0x90, 0x91, 0x13, 0xF0, 
+0xFD, 0xD1, 0x54, 0xEF, 0x54, 0x0C, 0x64, 0x08, 0x70, 0x60, 0xF1, 0xB0, 0xA3, 0xE0, 0xF1, 0xB9, 
+0x64, 0x88, 0x70, 0x56, 0xF1, 0xB0, 0xA3, 0xE0, 0x24, 0x07, 0xFD, 0xD1, 0x54, 0xEF, 0x64, 0x8E, 
+0x70, 0x48, 0x90, 0x91, 0x13, 0x04, 0xF0, 0xF1, 0xB0, 0xF1, 0xEC, 0x2D, 0x04, 0xFD, 0xD1, 0x54, 
+0xEF, 0x64, 0x03, 0x70, 0x35, 0xF1, 0xB0, 0xF1, 0xEC, 0x2D, 0xF1, 0xB9, 0x30, 0xE3, 0x07, 0x90, 
+0x01, 0xC7, 0x74, 0x01, 0x80, 0x21, 0x90, 0x8E, 0xC5, 0x12, 0x98, 0x38, 0x30, 0xE0, 0x0A, 0xF1, 
+0xB0, 0xA3, 0xE0, 0xFD, 0x12, 0x99, 0x5E, 0x80, 0x11, 0x90, 0x8E, 0xC8, 0x12, 0x9D, 0x3D, 0x30, 
+0xE0, 0x08, 0x90, 0x01, 0xC7, 0x74, 0x02, 0xF0, 0xF1, 0xDA, 0x90, 0x91, 0x13, 0xE0, 0xFF, 0x22, 
+0x90, 0x91, 0x0E, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x22, 0x24, 0x06, 0xFD, 0xD1, 0x54, 0xEF, 0x22, 
+0x90, 0x91, 0x10, 0xE0, 0xFD, 0x90, 0x91, 0x0F, 0xE0, 0x2D, 0xFD, 0x22, 0x7E, 0x00, 0x7F, 0x04, 
+0x02, 0x46, 0xB0, 0x7E, 0x00, 0x7F, 0x06, 0x02, 0x46, 0xB0, 0x90, 0x8E, 0xCE, 0xE0, 0x44, 0x01, 
+0xF0, 0x22, 0xA3, 0xA3, 0xE0, 0x24, 0x38, 0xF9, 0xE4, 0x34, 0xFC, 0x22, 0x90, 0x91, 0x11, 0xE0, 
+0xFD, 0x90, 0x91, 0x10, 0xE0, 0x22, 0xE4, 0xFB, 0xFA, 0xFD, 0x7F, 0x01, 0x12, 0x4B, 0xB2, 0x90, 
+0x90, 0xF9, 0xEF, 0xF0, 0x60, 0xF0, 0x90, 0x8D, 0x01, 0xE0, 0xFF, 0x70, 0x04, 0xA3, 0xE0, 0x60, 
+0xE5, 0xC2, 0xAF, 0xEF, 0x30, 0xE1, 0x0A, 0x90, 0x8D, 0x01, 0xE0, 0x54, 0xFD, 0xF0, 0x12, 0x7D, 
+0x6C, 0x12, 0x9D, 0xB4, 0x30, 0xE2, 0x06, 0x54, 0xFB, 0xF0, 0x12, 0x8D, 0xF6, 0x12, 0x9D, 0xB4, 
+0x30, 0xE4, 0x0B, 0x54, 0xEF, 0xF0, 0x12, 0x8C, 0xA6, 0xBF, 0x01, 0x02, 0x11, 0x42, 0xD2, 0xAF, 
+0x80, 0xC4, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0xE4, 0x90, 0x91, 0x03, 0x12, 0x9E, 0x37, 
+0xA3, 0x12, 0x97, 0x49, 0x90, 0x91, 0x0B, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0x90, 0x01, 0xC4, 0x74, 
+0x42, 0xF0, 0x74, 0x60, 0xA3, 0xF0, 0x12, 0x87, 0xB0, 0x12, 0x83, 0x67, 0x90, 0x90, 0xFA, 0xF0, 
+0xA3, 0xEF, 0xF0, 0x90, 0x02, 0x82, 0xE0, 0x90, 0x91, 0x02, 0xF0, 0x90, 0x8E, 0xC5, 0xE0, 0x20, 
+0xE0, 0x02, 0x41, 0xDC, 0xE4, 0x90, 0x91, 0x01, 0xF0, 0x90, 0x91, 0x02, 0xE0, 0xFF, 0x90, 0x91, 
+0x01, 0xE0, 0xC3, 0x9F, 0x40, 0x02, 0x41, 0xDC, 0x90, 0x90, 0xFA, 0x12, 0x87, 0x9F, 0x90, 0xFD, 
+0x11, 0xF0, 0x90, 0x91, 0x0B, 0xEF, 0xF0, 0x12, 0x85, 0xA6, 0x54, 0x3F, 0xFE, 0x90, 0x90, 0xFC, 
+0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0x91, 0x07, 0xEE, 0x12, 0x8D, 0x65, 0xE0, 0x54, 0x03, 0xFE, 0xEF, 
+0x24, 0x18, 0x2E, 0xFF, 0x90, 0x91, 0x0C, 0xF0, 0x90, 0x90, 0xFB, 0xE0, 0x2F, 0xFF, 0x90, 0x90, 
+0xFA, 0xE0, 0x34, 0x00, 0xFE, 0x90, 0x90, 0xFE, 0x12, 0x9D, 0x8D, 0xC0, 0x07, 0x51, 0xED, 0x7D, 
+0x01, 0x12, 0x5E, 0x54, 0xC0, 0x07, 0x51, 0xED, 0x7D, 0x04, 0x12, 0x5E, 0x54, 0xAB, 0x07, 0xD0, 
+0x05, 0xD0, 0x07, 0x12, 0x82, 0x0A, 0x90, 0x91, 0x03, 0xEF, 0x51, 0xEC, 0xE4, 0xFD, 0x12, 0x5E, 
+0x54, 0xEF, 0x54, 0xFC, 0x90, 0x91, 0x00, 0xF0, 0x90, 0x91, 0x0C, 0xE0, 0xFF, 0x90, 0x90, 0xFC, 
+0xE4, 0x8F, 0xF0, 0x12, 0x46, 0xD6, 0x90, 0x90, 0xFC, 0x12, 0x86, 0x51, 0x90, 0x90, 0xFC, 0xEE, 
+0xF0, 0xA3, 0xEF, 0xF0, 0x12, 0x9D, 0xC7, 0x7D, 0x0F, 0x12, 0x5E, 0x54, 0x90, 0x90, 0xFC, 0xE0, 
+0xFC, 0xA3, 0xE0, 0xFD, 0x90, 0x90, 0xFA, 0xEC, 0x8D, 0xF0, 0x12, 0x87, 0x97, 0xFC, 0xA3, 0xE0, 
+0xFD, 0xD3, 0x90, 0x90, 0xFB, 0xE0, 0x9D, 0x90, 0x90, 0xFA, 0xE0, 0x9C, 0x40, 0x1B, 0x90, 0x8D, 
+0xFA, 0xE0, 0x24, 0x01, 0xFD, 0x90, 0x8D, 0xF9, 0xE0, 0x34, 0x00, 0xFC, 0xC3, 0x90, 0x90, 0xFB, 
+0xE0, 0x9D, 0xF0, 0x90, 0x90, 0xFA, 0xE0, 0x9C, 0xF0, 0xEF, 0x30, 0xE6, 0x06, 0x90, 0x01, 0xC7, 
+0x74, 0x22, 0xF0, 0xEF, 0x30, 0xE7, 0x06, 0x90, 0x01, 0xC7, 0x74, 0x21, 0xF0, 0xEF, 0x30, 0xE5, 
+0x06, 0x90, 0x01, 0xC7, 0x74, 0x23, 0xF0, 0x90, 0x91, 0x00, 0xE0, 0x24, 0x40, 0x60, 0x04, 0x24, 
+0x20, 0x70, 0x29, 0x90, 0x8E, 0xC8, 0x71, 0x00, 0x20, 0xE0, 0x02, 0x41, 0x79, 0x90, 0x8E, 0xDB, 
+0xE0, 0x04, 0x51, 0xEC, 0x12, 0x8A, 0xEB, 0xEF, 0x70, 0x02, 0x41, 0x79, 0x90, 0x91, 0x00, 0xE0, 
+0xFF, 0x12, 0x97, 0x9F, 0x90, 0x8E, 0xDC, 0xE0, 0x04, 0xF0, 0x41, 0x79, 0x12, 0x9D, 0x3A, 0x30, 
+0xE0, 0x5B, 0x90, 0x91, 0x03, 0xE0, 0xFF, 0x90, 0x90, 0xFF, 0xE0, 0x2F, 0xFF, 0x90, 0x90, 0xFE, 
+0xE0, 0x34, 0x00, 0xCF, 0x24, 0x08, 0xCF, 0x34, 0x00, 0xFE, 0x90, 0x91, 0x09, 0x12, 0x9D, 0x8D, 
+0xEF, 0x64, 0x45, 0x70, 0x38, 0x51, 0xF7, 0x12, 0x8C, 0xDA, 0xEF, 0x64, 0x01, 0x70, 0x2E, 0x51, 
+0xF7, 0x12, 0x9B, 0x7A, 0xEF, 0x64, 0x01, 0x70, 0x24, 0x90, 0x91, 0x0D, 0x04, 0x51, 0xF6, 0xA3, 
+0xE0, 0xFD, 0x12, 0x8C, 0x3A, 0xEF, 0x70, 0x0D, 0x90, 0x91, 0x0B, 0xE0, 0xFD, 0x90, 0xFD, 0x11, 
+0x51, 0xF6, 0x12, 0x8B, 0xFF, 0x90, 0x91, 0x0B, 0xE0, 0x90, 0xFD, 0x11, 0xF0, 0x51, 0xED, 0x12, 
+0x8A, 0xEB, 0xEF, 0x60, 0x20, 0x51, 0xED, 0x90, 0x91, 0x03, 0xE0, 0xFD, 0x90, 0x91, 0x06, 0xE0, 
+0xFB, 0x90, 0x91, 0x0B, 0xE0, 0x90, 0x91, 0x12, 0xF0, 0x12, 0x5F, 0x31, 0xEF, 0x60, 0x06, 0x90, 
+0x91, 0x0D, 0x74, 0x01, 0xF0, 0x90, 0x8E, 0xC5, 0xE0, 0xC3, 0x13, 0x30, 0xE0, 0x13, 0x51, 0xED, 
+0x90, 0x91, 0x03, 0xE0, 0xFD, 0x12, 0x5D, 0x05, 0xEF, 0x60, 0x06, 0x90, 0x91, 0x0D, 0x74, 0x01, 
+0xF0, 0x90, 0x8E, 0xC5, 0x71, 0x00, 0x30, 0xE0, 0x10, 0x90, 0x91, 0x0D, 0xE0, 0x70, 0x0A, 0x51, 
+0xED, 0x90, 0x91, 0x03, 0xE0, 0xFD, 0x12, 0x8B, 0x35, 0x12, 0x97, 0xB1, 0xEF, 0x64, 0x01, 0x60, 
+0x07, 0x90, 0x01, 0x3F, 0xE0, 0x30, 0xE2, 0x04, 0x7F, 0x01, 0x71, 0x09, 0x12, 0x97, 0x74, 0xEF, 
+0x64, 0x01, 0x70, 0x37, 0x90, 0x8E, 0xDD, 0xE0, 0x04, 0xF0, 0x12, 0x97, 0x5E, 0xAD, 0x07, 0xEF, 
+0x64, 0x01, 0x60, 0x1F, 0x12, 0x5F, 0xDA, 0xED, 0xB4, 0x02, 0x08, 0x90, 0x01, 0xC7, 0x74, 0x42, 
+0xF0, 0x80, 0x0A, 0xED, 0xB4, 0x04, 0x06, 0x90, 0x01, 0xC7, 0x74, 0x43, 0xF0, 0x7F, 0x01, 0x71, 
+0x09, 0x80, 0x19, 0x12, 0x9D, 0xC7, 0x12, 0x97, 0x50, 0x80, 0x09, 0x90, 0x8E, 0xC5, 0xE0, 0x54, 
+0xFE, 0xF0, 0x80, 0x08, 0x90, 0x91, 0x01, 0xE0, 0x04, 0xF0, 0x01, 0x89, 0x74, 0x42, 0x04, 0x90, 
+0x01, 0xC4, 0xF0, 0x74, 0x60, 0xA3, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xF0, 0x90, 0x90, 0xFE, 
+0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x22, 0xF0, 0x90, 0x91, 0x09, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x22, 
+0xE0, 0xFF, 0xC4, 0x13, 0x13, 0x13, 0x54, 0x01, 0x22, 0x90, 0x92, 0xD3, 0xEF, 0xF0, 0x90, 0x8D, 
+0x07, 0xE0, 0x64, 0x02, 0x70, 0x22, 0x90, 0x92, 0xD3, 0xE0, 0xFD, 0x64, 0x01, 0x70, 0x34, 0x12, 
+0x5F, 0xDA, 0x90, 0x8E, 0xC9, 0xE0, 0x71, 0x02, 0x30, 0xE0, 0x09, 0x90, 0x01, 0x4D, 0xE0, 0x64, 
+0x80, 0xF0, 0x80, 0x1F, 0xAF, 0x05, 0x80, 0x19, 0x90, 0x01, 0x00, 0x74, 0xFF, 0xF0, 0x7F, 0x64, 
+0x7E, 0x00, 0x12, 0x3A, 0xF7, 0x90, 0x06, 0x90, 0xE0, 0x44, 0x01, 0xF0, 0x90, 0x92, 0xD3, 0xE0, 
+0xFF, 0x71, 0x5F, 0x12, 0x8A, 0x39, 0xF0, 0x90, 0x8E, 0xC5, 0xE0, 0x54, 0xBF, 0xF0, 0x22, 0xAD, 
+0x07, 0x90, 0x8E, 0xCA, 0xE0, 0x75, 0xF0, 0x40, 0xA4, 0xFF, 0x90, 0x92, 0xAF, 0xE5, 0xF0, 0xF0, 
+0xA3, 0xEF, 0xF0, 0xE4, 0xA3, 0xF0, 0x90, 0x8E, 0xCB, 0xE0, 0xC3, 0x13, 0x54, 0x7F, 0x90, 0x92, 
+0xB2, 0xF0, 0xED, 0x64, 0x01, 0x70, 0x68, 0x90, 0x92, 0xAF, 0xE0, 0x70, 0x02, 0xA3, 0xE0, 0x60, 
+0x0B, 0x90, 0x92, 0xAF, 0x74, 0xFF, 0x75, 0xF0, 0xD0, 0x12, 0x46, 0xD6, 0x91, 0xDA, 0x13, 0x54, 
+0x07, 0x7D, 0x00, 0x20, 0xE0, 0x02, 0x7D, 0x01, 0x71, 0xF4, 0x91, 0xDA, 0x71, 0xF0, 0x90, 0x8E, 
+0xCB, 0xE0, 0x30, 0xE0, 0x3A, 0x91, 0xCF, 0x13, 0x54, 0x07, 0x7D, 0x00, 0x20, 0xE0, 0x02, 0x7D, 
+0x01, 0x71, 0xF4, 0xE4, 0x90, 0x92, 0xB1, 0xF0, 0x90, 0x92, 0xB2, 0xE0, 0xFF, 0x90, 0x92, 0xB1, 
+0xE0, 0xC3, 0x9F, 0x50, 0x1A, 0x91, 0xCF, 0x71, 0xF0, 0x91, 0xCF, 0x13, 0x54, 0x07, 0x7D, 0x00, 
+0x20, 0xE0, 0x02, 0x7D, 0x01, 0x71, 0xF4, 0x90, 0x92, 0xB1, 0xE0, 0x04, 0xF0, 0x80, 0xD9, 0x22, 
+0x13, 0x54, 0x01, 0xFD, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x92, 0xCC, 0xED, 0xF0, 
+0x90, 0x92, 0xCB, 0xEF, 0xF0, 0xD3, 0x94, 0x07, 0x50, 0x4C, 0x91, 0xC7, 0x80, 0x02, 0xC3, 0x33, 
+0xD8, 0xFC, 0xF4, 0xFF, 0x90, 0x00, 0x47, 0xE0, 0x5F, 0xFD, 0x7F, 0x47, 0x91, 0xC1, 0x80, 0x02, 
+0xC3, 0x33, 0xD8, 0xFC, 0xFF, 0x90, 0x00, 0x46, 0xE0, 0x4F, 0xFD, 0x7F, 0x46, 0x12, 0x9E, 0x3F, 
+0x60, 0x10, 0x91, 0xC4, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0xFF, 0x90, 0x00, 0x45, 0xE0, 0x4F, 
+0x80, 0x0F, 0x91, 0xC4, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0xF4, 0xFF, 0x90, 0x00, 0x45, 0xE0, 
+0x5F, 0xFD, 0x7F, 0x45, 0x80, 0x63, 0x90, 0x92, 0xCB, 0xE0, 0x24, 0xF8, 0xF0, 0xE0, 0x24, 0x04, 
+0x91, 0xC8, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0xF4, 0xFF, 0x90, 0x00, 0x43, 0xE0, 0x5F, 0xFD, 
+0x7F, 0x43, 0x91, 0xC1, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0xFF, 0x90, 0x00, 0x43, 0xE0, 0x4F, 
+0xFD, 0x7F, 0x43, 0x12, 0x9E, 0x3F, 0x60, 0x19, 0x90, 0x92, 0xCB, 0xE0, 0x24, 0x04, 0x91, 0xC8, 
+0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0xFF, 0x90, 0x00, 0x42, 0xE0, 0x4F, 0xFD, 0x7F, 0x42, 0x80, 
+0x18, 0x90, 0x92, 0xCB, 0xE0, 0x24, 0x04, 0x91, 0xC8, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0xF4, 
+0xFF, 0x90, 0x00, 0x42, 0xE0, 0x5F, 0xFD, 0x7F, 0x42, 0x12, 0x3A, 0x96, 0xD0, 0xD0, 0x92, 0xAF, 
+0x22, 0x12, 0x3A, 0x96, 0x90, 0x92, 0xCB, 0xE0, 0xFF, 0x74, 0x01, 0xA8, 0x07, 0x08, 0x22, 0x90, 
+0x92, 0xAF, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x12, 0x3A, 0xF7, 0x90, 0x8E, 0xC9, 0xE0, 0x54, 0x7F, 
+0xFF, 0x90, 0x8E, 0xC8, 0xE0, 0xFE, 0xC4, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x12, 
+0x8A, 0x1E, 0x12, 0x26, 0x1E, 0x20, 0xE0, 0x05, 0x12, 0x8F, 0x0B, 0xA1, 0xB9, 0x90, 0x8F, 0x9E, 
+0x74, 0x05, 0xF0, 0x12, 0x89, 0xDE, 0x90, 0x8E, 0xC8, 0xD1, 0x7B, 0x54, 0x04, 0xFD, 0xEF, 0x54, 
+0xFB, 0xD1, 0x73, 0x12, 0x9D, 0xD9, 0xD1, 0x89, 0x54, 0x10, 0xFD, 0xEF, 0x54, 0xEF, 0xD1, 0x73, 
+0x12, 0x9D, 0xE1, 0xD1, 0x89, 0x54, 0x40, 0xFD, 0xEF, 0x54, 0xBF, 0xD1, 0x73, 0x54, 0x80, 0xFE, 
+0xEF, 0x54, 0x7F, 0x12, 0x4E, 0xCC, 0x54, 0x80, 0xFF, 0x90, 0x8E, 0xC9, 0xE0, 0x54, 0x7F, 0x4F, 
+0xF0, 0x12, 0x26, 0x1E, 0x13, 0x13, 0x54, 0x3F, 0x30, 0xE0, 0x07, 0x90, 0x06, 0x90, 0xE0, 0x44, 
+0x04, 0xF0, 0xF1, 0x3A, 0x12, 0x26, 0x1E, 0x13, 0x13, 0x13, 0x54, 0x1F, 0x30, 0xE0, 0x07, 0x90, 
+0x06, 0x90, 0xE0, 0x44, 0x08, 0xF0, 0x90, 0x8D, 0x07, 0xE0, 0xB4, 0x02, 0x09, 0x90, 0x8E, 0xC9, 
+0xE0, 0x71, 0x02, 0x20, 0xE0, 0x35, 0x12, 0x4E, 0xCE, 0x54, 0x7F, 0xFF, 0x90, 0x8E, 0xC9, 0xE0, 
+0x54, 0x80, 0x12, 0x4F, 0xEF, 0x90, 0x8E, 0xCA, 0x12, 0x4F, 0xAD, 0xFF, 0x54, 0x01, 0xFE, 0x90, 
+0x8E, 0xCB, 0x12, 0x89, 0xB7, 0x54, 0xFE, 0xFF, 0xEE, 0x54, 0x01, 0x4F, 0xF0, 0x91, 0xDA, 0x13, 
+0x54, 0x07, 0x7D, 0x00, 0x20, 0xE0, 0x02, 0x7D, 0x01, 0x71, 0xF4, 0x90, 0x8D, 0x07, 0xE0, 0xB4, 
+0x01, 0x07, 0x90, 0xFE, 0x10, 0xE0, 0x44, 0x04, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0x90, 
+0xFB, 0x12, 0x47, 0x5F, 0x90, 0x90, 0xFA, 0xEF, 0xF0, 0x12, 0x47, 0x68, 0x66, 0x06, 0x00, 0x66, 
+0x0B, 0x01, 0x66, 0x10, 0x02, 0x66, 0x15, 0x03, 0x66, 0x1A, 0x04, 0x66, 0x1F, 0x12, 0x66, 0x24, 
+0x14, 0x66, 0x29, 0x20, 0x66, 0x2D, 0x21, 0x66, 0x32, 0x23, 0x66, 0x37, 0x25, 0x66, 0x3C, 0x27, 
+0x66, 0x45, 0x80, 0x66, 0x41, 0x81, 0x66, 0x49, 0x82, 0x66, 0x4E, 0x83, 0x66, 0x53, 0x84, 0x66, 
+0x58, 0x88, 0x00, 0x00, 0x66, 0x5D, 0xD1, 0x6D, 0x02, 0x80, 0x0F, 0xD1, 0x6D, 0x02, 0x87, 0xDC, 
+0xD1, 0x6D, 0x02, 0x89, 0x20, 0xD1, 0x6D, 0x02, 0x89, 0xBF, 0xD1, 0x6D, 0x02, 0x89, 0xEC, 0xD1, 
+0x6D, 0x02, 0x89, 0x5D, 0xD1, 0x6D, 0x02, 0x89, 0x71, 0xD1, 0x6D, 0xE1, 0x40, 0xD1, 0x6D, 0x02, 
+0x4F, 0xC8, 0xD1, 0x6D, 0x02, 0x89, 0x80, 0xD1, 0x6D, 0x02, 0x89, 0x88, 0xD1, 0x6D, 0x02, 0x89, 
+0x90, 0xD1, 0x6D, 0x80, 0x4B, 0xD1, 0x6D, 0x81, 0xE8, 0xD1, 0x6D, 0x02, 0x97, 0xD5, 0xD1, 0x6D, 
+0x02, 0x81, 0x56, 0xD1, 0x6D, 0x02, 0x81, 0x93, 0xD1, 0x6D, 0x02, 0x97, 0xEB, 0x90, 0x01, 0xC0, 
+0xE0, 0x44, 0x01, 0xF0, 0x90, 0x90, 0xFA, 0xE0, 0x90, 0x01, 0xC2, 0xF0, 0x22, 0x90, 0x90, 0xFB, 
+0x02, 0x47, 0x56, 0x4D, 0xFF, 0x90, 0x8E, 0xC8, 0xF0, 0xEE, 0x22, 0xE0, 0x54, 0xFE, 0x4E, 0xFE, 
+0xF0, 0xEF, 0x54, 0x02, 0xFF, 0xEE, 0x54, 0xFD, 0x4F, 0xFF, 0xF0, 0x12, 0x26, 0x1E, 0xFE, 0x22, 
+0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x12, 0x89, 0xE4, 0x90, 0x8E, 0xC5, 0xD1, 0x7B, 0x54, 
+0x04, 0xFD, 0xEF, 0x54, 0xFB, 0xF1, 0x32, 0x12, 0x9D, 0xD9, 0xD1, 0x89, 0x54, 0x10, 0xFD, 0xEF, 
+0x54, 0xEF, 0xF1, 0x32, 0x12, 0x9D, 0xE1, 0xD1, 0x89, 0x54, 0x40, 0xFD, 0xEF, 0x54, 0xBF, 0xF1, 
+0x32, 0x54, 0x80, 0xFE, 0xEF, 0x54, 0x7F, 0x4E, 0x12, 0x4F, 0xF0, 0xFF, 0x54, 0x01, 0xFE, 0x90, 
+0x8E, 0xC7, 0xE0, 0x54, 0xFE, 0x12, 0x4E, 0xCC, 0xFE, 0x54, 0x01, 0xFD, 0x90, 0x8E, 0xC6, 0xE0, 
+0x54, 0xFE, 0x4D, 0xFD, 0xF0, 0xEE, 0x54, 0x04, 0xFE, 0xED, 0x54, 0xFB, 0x4E, 0xF0, 0xEF, 0x54, 
+0x10, 0xFF, 0xA3, 0xE0, 0x54, 0xEF, 0x4F, 0x12, 0x83, 0x5E, 0x12, 0x9D, 0xF0, 0x90, 0x8E, 0xC5, 
+0xE0, 0xC3, 0x13, 0x54, 0x01, 0xFF, 0x12, 0x87, 0xC4, 0x90, 0x8E, 0xC5, 0xE0, 0x13, 0x13, 0x13, 
+0x54, 0x01, 0xFF, 0x12, 0x8A, 0x5A, 0x90, 0x8E, 0xC5, 0xE0, 0xC4, 0x13, 0x13, 0x54, 0x01, 0xFF, 
+0x12, 0x85, 0x9E, 0x90, 0x8E, 0xC5, 0xE0, 0x54, 0x01, 0xFF, 0x12, 0x72, 0xF2, 0xD0, 0xD0, 0x92, 
+0xAF, 0x22, 0x4D, 0xFF, 0x90, 0x8E, 0xC5, 0xF0, 0xEE, 0x22, 0x90, 0x90, 0xFE, 0x02, 0x47, 0x56, 
+0x12, 0x8A, 0x1E, 0x12, 0x26, 0x1E, 0xFF, 0x54, 0x7F, 0x90, 0x8E, 0x12, 0xF0, 0xEF, 0x71, 0x02, 
+0xA3, 0x12, 0x4E, 0xCD, 0xFF, 0x54, 0xF0, 0xC4, 0x54, 0x0F, 0xFE, 0x90, 0x8E, 0x10, 0xE0, 0x54, 
+0xF0, 0x4E, 0x12, 0x4F, 0xAD, 0x54, 0x01, 0x25, 0xE0, 0xFE, 0x90, 0x8E, 0x0E, 0xE0, 0x54, 0xFD, 
+0x4E, 0xF0, 0xEF, 0x54, 0x0F, 0xC4, 0x54, 0xF0, 0xFF, 0x12, 0x74, 0x1B, 0x12, 0x4F, 0xEF, 0x90, 
+0x8E, 0x11, 0x12, 0x81, 0x4F, 0x30, 0xE0, 0x4F, 0xC3, 0x13, 0x54, 0x07, 0xFF, 0xC3, 0x94, 0x04, 
+0x90, 0x8E, 0x25, 0x50, 0x04, 0xEF, 0xF0, 0x80, 0x26, 0x74, 0x03, 0xF0, 0xF1, 0x3A, 0xE9, 0x24, 
+0x06, 0x12, 0x9D, 0xF8, 0xFF, 0x74, 0x03, 0x24, 0xFD, 0xFE, 0xEF, 0xC4, 0x54, 0x0F, 0xFD, 0xEF, 
+0x54, 0x0F, 0xFF, 0xED, 0x2E, 0x54, 0x0F, 0xFE, 0xC4, 0x54, 0xF0, 0x4F, 0x12, 0x26, 0x64, 0xF1, 
+0x3A, 0x12, 0x81, 0x50, 0xC4, 0x54, 0x0F, 0xFF, 0xC3, 0x94, 0x04, 0x90, 0x8E, 0x1A, 0x50, 0x05, 
+0x74, 0x04, 0xF0, 0x80, 0x02, 0xEF, 0xF0, 0xF1, 0x3A, 0x12, 0x80, 0x4D, 0xFD, 0x7F, 0x02, 0x12, 
+0x51, 0x10, 0xF1, 0x3A, 0x90, 0x91, 0x01, 0x12, 0x47, 0x5F, 0x12, 0x72, 0xD2, 0x90, 0x8E, 0x12, 
+0xE0, 0xFF, 0x12, 0x6F, 0x94, 0x90, 0x8E, 0x12, 0xE0, 0x60, 0x12, 0x90, 0x91, 0x01, 0x12, 0x47, 
+0x56, 0x12, 0x4E, 0xCE, 0x54, 0x0F, 0xFF, 0x12, 0x4F, 0xF1, 0xFD, 0x11, 0x0E, 0x22, 0xEF, 0x24, 
+0xFE, 0x60, 0x0B, 0x04, 0x70, 0x24, 0x90, 0x8E, 0x18, 0x74, 0x02, 0xF0, 0x80, 0x13, 0xED, 0x70, 
+0x06, 0x90, 0x8E, 0xBD, 0xE0, 0x80, 0x02, 0xED, 0x14, 0x90, 0x8E, 0x18, 0xF0, 0x90, 0x8E, 0x18, 
+0xE0, 0xA3, 0xF0, 0x90, 0x8E, 0x0F, 0xE0, 0x44, 0x08, 0xF0, 0x22, 0xF0, 0xE4, 0x90, 0x92, 0x7E, 
+0xF0, 0x90, 0x8E, 0xBB, 0xE0, 0x90, 0x92, 0x7F, 0xF0, 0xE4, 0xFB, 0xFD, 0x7F, 0x54, 0x7E, 0x01, 
+0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x92, 0x7A, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 
+0x92, 0x7E, 0xE0, 0xF5, 0x3B, 0xA3, 0xE0, 0xF5, 0x3C, 0x12, 0x34, 0x8C, 0x90, 0x92, 0x7A, 0x12, 
+0x8A, 0xD8, 0xA3, 0xA3, 0xA3, 0x74, 0x05, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xE4, 0x90, 0x92, 
+0x22, 0xF0, 0x90, 0x8E, 0x12, 0xE0, 0x60, 0x6B, 0xF1, 0x25, 0x64, 0x01, 0x70, 0x65, 0x12, 0x9E, 
+0x27, 0x11, 0xF4, 0x12, 0x47, 0x14, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0x05, 
+0x62, 0x31, 0x0E, 0x78, 0x10, 0x12, 0x27, 0x35, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 
+0x12, 0x47, 0x14, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0xA3, 0x31, 0x0E, 0x78, 0x18, 
+0x12, 0x27, 0x35, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0x12, 0x9D, 0x84, 0x90, 0x92, 
+0x22, 0x74, 0x01, 0xF0, 0xE4, 0x90, 0x8E, 0x19, 0xF0, 0x04, 0x60, 0x17, 0x12, 0x9E, 0x2F, 0xE4, 
+0x90, 0x92, 0x7E, 0xF0, 0x90, 0x8E, 0x1A, 0x11, 0x44, 0x90, 0x8E, 0x15, 0xE0, 0x20, 0xE2, 0x03, 
+0x12, 0x51, 0x9D, 0x22, 0xF0, 0x90, 0x05, 0x61, 0xE0, 0xFF, 0xE4, 0xFC, 0xFD, 0xFE, 0x78, 0x08, 
+0x12, 0x27, 0x35, 0xA8, 0x04, 0xA9, 0x05, 0xAA, 0x06, 0xAB, 0x07, 0x90, 0x05, 0x60, 0xE0, 0xFF, 
+0xE4, 0xFC, 0xFD, 0xFE, 0x22, 0xE4, 0xF5, 0x14, 0x90, 0x8E, 0x12, 0xE0, 0x70, 0x02, 0x21, 0xBD, 
+0xF1, 0x25, 0x64, 0x01, 0x60, 0x02, 0x21, 0xBD, 0x11, 0xF5, 0x12, 0x47, 0x14, 0xC0, 0x04, 0xC0, 
+0x05, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0x05, 0x62, 0x31, 0x0E, 0x78, 0x10, 0x12, 0x27, 0x35, 0xD0, 
+0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0x12, 0x47, 0x14, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 
+0xC0, 0x07, 0xA3, 0x31, 0x0E, 0x78, 0x18, 0x12, 0x27, 0x35, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 
+0xD0, 0x00, 0x12, 0x9D, 0x84, 0x12, 0x9E, 0x1F, 0x60, 0x22, 0x24, 0xFE, 0x60, 0x03, 0x04, 0x70, 
+0x1E, 0x90, 0x8E, 0x19, 0xE0, 0x14, 0xF0, 0xE0, 0xFF, 0x60, 0x06, 0x90, 0x8E, 0x1B, 0xE0, 0x60, 
+0x0E, 0xEF, 0x70, 0x08, 0x90, 0x8E, 0x18, 0xE0, 0xA3, 0xF0, 0x80, 0x00, 0x75, 0x14, 0x01, 0xE5, 
+0x14, 0x60, 0x2A, 0x12, 0x9E, 0x2F, 0x90, 0x8E, 0x1B, 0xE0, 0x60, 0x03, 0xB4, 0x01, 0x04, 0xF1, 
+0x61, 0x80, 0x08, 0xF1, 0x61, 0x75, 0xF0, 0x03, 0xA4, 0x24, 0xFE, 0xFF, 0x90, 0x8E, 0x1A, 0xE0, 
+0x2F, 0x11, 0x45, 0x90, 0x8E, 0x15, 0xE0, 0x20, 0xE2, 0x03, 0x12, 0x51, 0x9D, 0x22, 0xD3, 0x10, 
+0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x92, 0xAC, 0xED, 0xF0, 0xA3, 0xEB, 0xF0, 0x90, 0x92, 0xAB, 
+0xEF, 0xF0, 0x90, 0x92, 0xAE, 0xE0, 0xFD, 0x12, 0x93, 0xB8, 0x90, 0x92, 0xAB, 0xE0, 0xC3, 0x94, 
+0x0E, 0x50, 0x3F, 0x90, 0x92, 0x3B, 0x12, 0x27, 0x54, 0x1F, 0xFE, 0x00, 0x00, 0x90, 0x92, 0x3F, 
+0x12, 0x27, 0x54, 0x12, 0xD4, 0x00, 0x00, 0xF1, 0x1E, 0x90, 0x92, 0x29, 0x12, 0x27, 0x54, 0x00, 
+0x07, 0x03, 0x00, 0x90, 0x92, 0x2D, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0x00, 0x91, 0x8D, 0x12, 
+0x27, 0x54, 0x00, 0x07, 0x03, 0x00, 0x90, 0x92, 0x2D, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0x00, 
+0x61, 0x41, 0x12, 0x9D, 0xA0, 0x50, 0x1B, 0xEF, 0x94, 0x30, 0x50, 0x16, 0x90, 0x92, 0x3B, 0x12, 
+0x27, 0x54, 0x1F, 0xFE, 0x00, 0x00, 0x90, 0x92, 0x3F, 0x12, 0x27, 0x54, 0x09, 0x28, 0x00, 0x00, 
+0x80, 0x65, 0x90, 0x92, 0xAB, 0xE0, 0xFF, 0x74, 0x32, 0xD3, 0x9F, 0x50, 0x1B, 0xEF, 0x94, 0x40, 
+0x50, 0x16, 0x90, 0x92, 0x3B, 0x12, 0x27, 0x54, 0x1F, 0xFE, 0x00, 0x00, 0x90, 0x92, 0x3F, 0x12, 
+0x27, 0x54, 0x08, 0xA6, 0x00, 0x00, 0x80, 0x3F, 0x12, 0x9D, 0x96, 0x50, 0x1B, 0xEF, 0x94, 0x74, 
+0x50, 0x16, 0x90, 0x92, 0x3B, 0x12, 0x27, 0x54, 0x1F, 0xFE, 0x00, 0x00, 0x90, 0x92, 0x3F, 0x12, 
+0x27, 0x54, 0x08, 0xA4, 0x00, 0x00, 0x80, 0x1F, 0x90, 0x92, 0xAB, 0xE0, 0xFF, 0x74, 0x76, 0xD3, 
+0x9F, 0x50, 0x16, 0x90, 0x92, 0x3B, 0x12, 0x27, 0x54, 0x1F, 0xFE, 0x00, 0x00, 0x90, 0x92, 0x3F, 
+0x12, 0x27, 0x54, 0x08, 0x24, 0x00, 0x00, 0xF1, 0x1E, 0x12, 0x9D, 0xA0, 0x50, 0x2E, 0xEF, 0x94, 
+0x40, 0x50, 0x29, 0x90, 0x92, 0x29, 0x12, 0x27, 0x54, 0x00, 0x07, 0x03, 0x00, 0x90, 0x92, 0x2D, 
+0x12, 0x27, 0x54, 0x00, 0x01, 0x01, 0x00, 0x91, 0x8D, 0x12, 0x27, 0x54, 0x00, 0x07, 0x03, 0x00, 
+0x90, 0x92, 0x2D, 0x12, 0x27, 0x54, 0x00, 0x01, 0x01, 0x00, 0x80, 0x65, 0x12, 0x9D, 0x96, 0x50, 
+0x2E, 0xEF, 0x94, 0x8C, 0x50, 0x29, 0x90, 0x92, 0x29, 0x12, 0x27, 0x54, 0x00, 0x07, 0x03, 0x00, 
+0x90, 0x92, 0x2D, 0x12, 0x27, 0x54, 0x00, 0x03, 0x01, 0x00, 0x91, 0x8D, 0x12, 0x27, 0x54, 0x00, 
+0x07, 0x03, 0x00, 0x90, 0x92, 0x2D, 0x12, 0x27, 0x54, 0x00, 0x03, 0x01, 0x00, 0x80, 0x32, 0x90, 
+0x92, 0xAB, 0xE0, 0xFF, 0x74, 0x8C, 0xC3, 0x9F, 0x50, 0x29, 0x90, 0x92, 0x29, 0x12, 0x27, 0x54, 
+0x00, 0x07, 0x03, 0x00, 0x90, 0x92, 0x2D, 0x12, 0x27, 0x54, 0x00, 0x05, 0x01, 0x00, 0x91, 0x8D, 
+0x12, 0x27, 0x54, 0x00, 0x07, 0x03, 0x00, 0x90, 0x92, 0x2D, 0x12, 0x27, 0x54, 0x00, 0x05, 0x01, 
+0x00, 0x91, 0x0E, 0x90, 0x92, 0xAB, 0xE0, 0xFF, 0xA3, 0xE0, 0xFD, 0x12, 0x92, 0x87, 0x90, 0x92, 
+0xAC, 0xE0, 0x64, 0x02, 0x70, 0x51, 0x90, 0x92, 0xAB, 0xE0, 0xFF, 0xD3, 0x94, 0x30, 0x50, 0x05, 
+0x75, 0x18, 0x2A, 0x80, 0x5E, 0xEF, 0xD3, 0x94, 0x40, 0x50, 0x05, 0x75, 0x18, 0x3A, 0x80, 0x53, 
+0xEF, 0xD3, 0x94, 0x70, 0x50, 0x05, 0x75, 0x18, 0x6A, 0x80, 0x48, 0xEF, 0xD3, 0x94, 0x80, 0x50, 
+0x05, 0x75, 0x18, 0x7A, 0x80, 0x3D, 0xEF, 0xD3, 0x94, 0x90, 0x50, 0x05, 0x75, 0x18, 0x8A, 0x80, 
+0x32, 0xEF, 0xD3, 0x94, 0xA1, 0x50, 0x05, 0x75, 0x18, 0x9B, 0x80, 0x27, 0xEF, 0xD3, 0x94, 0xB1, 
+0x50, 0x21, 0x75, 0x18, 0xAB, 0x80, 0x1C, 0x90, 0x92, 0xAC, 0xE0, 0x64, 0x01, 0x70, 0x31, 0xA3, 
+0xE0, 0x90, 0x92, 0xAB, 0xB4, 0x01, 0x07, 0xE0, 0x24, 0x02, 0xF5, 0x18, 0x80, 0x05, 0xE0, 0x24, 
+0xFE, 0xF5, 0x18, 0x90, 0x92, 0x29, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0xFF, 0xAF, 0x18, 0xE4, 
+0xFC, 0xFD, 0xFE, 0x91, 0x87, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0xFF, 0xAF, 0x18, 0x80, 0x1D, 
+0x90, 0x92, 0x29, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0xFF, 0x90, 0x92, 0xAB, 0x31, 0x0E, 0x91, 
+0x87, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0xFF, 0x90, 0x92, 0xAB, 0xE0, 0xFF, 0xE4, 0xFC, 0xFD, 
+0xFE, 0x90, 0x92, 0x2D, 0x12, 0x27, 0x48, 0x91, 0x0E, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x7D, 0x18, 
+0x7C, 0x00, 0x7F, 0x01, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x92, 0x27, 0xEC, 0xF0, 
+0xA3, 0xED, 0xF0, 0x90, 0x92, 0x26, 0xEF, 0xF0, 0xA3, 0xA3, 0xE0, 0xFD, 0x12, 0x78, 0xC1, 0x90, 
+0x92, 0x31, 0x12, 0x27, 0x48, 0x90, 0x92, 0x29, 0x12, 0x87, 0x89, 0x90, 0x92, 0x31, 0xB1, 0xCC, 
+0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0x92, 0x29, 0x12, 0x47, 0x32, 0x90, 0x92, 
+0x2D, 0xB1, 0xCC, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0x12, 0x47, 0x14, 0x90, 0x92, 
+0x35, 0x12, 0x27, 0x48, 0x90, 0x92, 0x27, 0xA3, 0xE0, 0xFD, 0xC0, 0x05, 0x90, 0x92, 0x35, 0x12, 
+0x47, 0x32, 0x90, 0xAC, 0x96, 0x12, 0x27, 0x48, 0x90, 0x92, 0x26, 0xE0, 0xFF, 0xD0, 0x05, 0x12, 
+0x39, 0xBA, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0x92, 0x2D, 0x12, 0x27, 0x48, 0x7D, 0x18, 0x7C, 
+0x00, 0xE4, 0xFF, 0x91, 0x14, 0x90, 0x92, 0x29, 0x22, 0xE4, 0x90, 0x92, 0x13, 0xF0, 0xA3, 0xF0, 
+0xA3, 0x11, 0xF4, 0x12, 0x47, 0x14, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0x05, 
+0x62, 0x31, 0x0E, 0x78, 0x10, 0x12, 0x27, 0x35, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 
+0x12, 0x47, 0x14, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0xA3, 0x31, 0x0E, 0x78, 0x18, 
+0x12, 0x27, 0x35, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0x12, 0x47, 0x14, 0x90, 0x8E, 
+0x4B, 0x12, 0x27, 0x48, 0x90, 0x8E, 0x4F, 0x12, 0x47, 0x32, 0x90, 0x8E, 0x4B, 0x12, 0x47, 0x3E, 
+0xC3, 0x12, 0x47, 0x21, 0x40, 0x39, 0x90, 0x8E, 0x0E, 0xE0, 0x90, 0x8E, 0x4F, 0x30, 0xE0, 0x0D, 
+0x12, 0x9C, 0xAB, 0xFF, 0x90, 0x8E, 0x48, 0xE0, 0x2F, 0x24, 0x0C, 0x80, 0x05, 0x12, 0x9C, 0xAB, 
+0x24, 0x08, 0x90, 0x92, 0x14, 0xF0, 0x90, 0x92, 0x14, 0xE0, 0xFF, 0xC3, 0x94, 0x19, 0x50, 0x0F, 
+0x74, 0x2F, 0x2F, 0x12, 0x99, 0x44, 0xE0, 0x04, 0xF0, 0x90, 0x8E, 0x28, 0xE0, 0x04, 0xF0, 0x90, 
+0x8E, 0x28, 0xE0, 0xC3, 0x94, 0x64, 0x50, 0x02, 0xA1, 0xCB, 0x12, 0x9D, 0x7A, 0x12, 0x9D, 0xBE, 
+0x50, 0x19, 0x12, 0x9C, 0xE4, 0x94, 0x05, 0x40, 0x0A, 0x90, 0x92, 0x13, 0xE0, 0x90, 0x92, 0x16, 
+0xF0, 0x80, 0x08, 0x90, 0x92, 0x13, 0xE0, 0x04, 0xF0, 0x80, 0xE2, 0x12, 0x9D, 0x7A, 0x12, 0x9D, 
+0xBE, 0x50, 0x19, 0x12, 0x9C, 0xE4, 0x94, 0x5F, 0x40, 0x0A, 0x90, 0x92, 0x13, 0xE0, 0x90, 0x92, 
+0x17, 0xF0, 0x80, 0x08, 0x90, 0x92, 0x13, 0xE0, 0x04, 0xF0, 0x80, 0xE2, 0x90, 0x92, 0x16, 0xE0, 
+0x90, 0x8E, 0x2D, 0xF0, 0x90, 0x92, 0x17, 0xE0, 0x90, 0x8E, 0x2E, 0x12, 0x9E, 0x17, 0x94, 0x0A, 
+0x40, 0x0A, 0xEF, 0x24, 0xF6, 0x90, 0x8E, 0x25, 0xF0, 0xE4, 0x80, 0x0A, 0xE4, 0x90, 0x8E, 0x25, 
+0x12, 0x9E, 0x17, 0x74, 0x0A, 0x9F, 0x90, 0x8E, 0x24, 0xF0, 0x90, 0x8E, 0x2D, 0xE0, 0xFF, 0xA3, 
+0xE0, 0xC3, 0x9F, 0x90, 0x8E, 0x2B, 0xF0, 0xC3, 0x94, 0x08, 0x50, 0x03, 0x74, 0x08, 0xF0, 0x12, 
+0x9D, 0x2D, 0xFB, 0x12, 0x7F, 0x46, 0xE4, 0xFF, 0x12, 0x99, 0x1B, 0x22, 0x12, 0x47, 0x3E, 0x02, 
+0x47, 0x07, 0x7F, 0xAC, 0x7E, 0x08, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x92, 0x39, 
+0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x12, 0x36, 0xCE, 0x90, 0x92, 0x43, 0x12, 0x27, 0x48, 0x90, 0x92, 
+0x3B, 0x12, 0x87, 0x89, 0x90, 0x92, 0x43, 0xB1, 0xCC, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 
+0x07, 0x90, 0x92, 0x3B, 0x12, 0x47, 0x32, 0x90, 0x92, 0x3F, 0xB1, 0xCC, 0xD0, 0x03, 0xD0, 0x02, 
+0xD0, 0x01, 0xD0, 0x00, 0x12, 0x47, 0x14, 0x90, 0x92, 0x47, 0x12, 0x27, 0x48, 0x90, 0x92, 0x47, 
+0x12, 0x56, 0xC6, 0x90, 0x92, 0x39, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x12, 0x37, 0x5D, 0xD0, 0xD0, 
+0x92, 0xAF, 0x22, 0x90, 0x92, 0xBD, 0xED, 0xF0, 0x90, 0x92, 0xBC, 0xEF, 0xF0, 0x70, 0x63, 0x90, 
+0x92, 0x3B, 0x12, 0x27, 0x54, 0x30, 0x00, 0x00, 0x00, 0x90, 0x92, 0x3F, 0x12, 0x27, 0x54, 0x00, 
+0x00, 0x00, 0x00, 0x74, 0x08, 0xFF, 0xFE, 0xF1, 0x12, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0x0E, 
+0x90, 0x92, 0x3F, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0x08, 0x7F, 0x30, 0x7E, 0x08, 0xF1, 0x12, 
+0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0x03, 0x90, 0x92, 0x3F, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 
+0x01, 0x12, 0x93, 0xF7, 0x90, 0x92, 0x3B, 0x12, 0x27, 0x54, 0x30, 0x00, 0x00, 0x00, 0x90, 0x92, 
+0x3F, 0x12, 0x27, 0x54, 0x30, 0x00, 0x00, 0x00, 0xF1, 0x18, 0x90, 0x04, 0x54, 0xE0, 0x54, 0x7F, 
+0xE1, 0x6B, 0x90, 0x92, 0xBC, 0xE0, 0x64, 0x01, 0x70, 0x63, 0x90, 0x04, 0x54, 0xE0, 0x44, 0x80, 
+0xF1, 0x6B, 0x90, 0x92, 0x3B, 0x12, 0x27, 0x54, 0x30, 0x00, 0x00, 0x00, 0x90, 0x92, 0x3F, 0x12, 
+0x27, 0x54, 0x00, 0x00, 0x00, 0x00, 0x74, 0x08, 0xFF, 0xFE, 0xF1, 0x12, 0x12, 0x27, 0x54, 0x00, 
+0x00, 0x00, 0x0E, 0x90, 0x92, 0x3F, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0x06, 0x7F, 0x30, 0x7E, 
+0x08, 0xF1, 0x12, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0x03, 0x90, 0x92, 0x3F, 0x12, 0x27, 0x54, 
+0x00, 0x00, 0x00, 0x02, 0x12, 0x93, 0xF7, 0x90, 0x92, 0x3B, 0x12, 0x27, 0x54, 0x30, 0x00, 0x00, 
+0x00, 0x90, 0x92, 0x3F, 0x12, 0x27, 0x54, 0x20, 0x00, 0x00, 0x00, 0xF1, 0x18, 0x22, 0x7F, 0xB4, 
+0x7E, 0x0C, 0xB1, 0xD6, 0x90, 0x92, 0x3B, 0x22, 0x74, 0x08, 0xFF, 0xFE, 0xA1, 0xD6, 0x7F, 0x60, 
+0x7E, 0x08, 0xA1, 0xD6, 0xF0, 0xE4, 0xFF, 0xF1, 0x2B, 0xEF, 0x22, 0x12, 0x89, 0x03, 0x12, 0x88, 
+0x91, 0xE0, 0xFD, 0x7C, 0x00, 0x12, 0x7D, 0xDB, 0x80, 0x05, 0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 
+0xF9, 0xFF, 0xEE, 0x5C, 0xFE, 0xEF, 0x5D, 0x4E, 0x7F, 0x00, 0x60, 0x02, 0x7F, 0x01, 0x22, 0xF1, 
+0x25, 0x64, 0x01, 0x70, 0x0B, 0x90, 0x8E, 0x12, 0xE0, 0x60, 0x05, 0x12, 0x9C, 0xC4, 0x11, 0x3B, 
+0x22, 0xE4, 0x90, 0x92, 0x7E, 0xF0, 0x90, 0x8E, 0x1B, 0xE0, 0x22, 0x90, 0x92, 0xBE, 0xF0, 0xE0, 
+0x90, 0x04, 0x54, 0xF0, 0x22, 0xF1, 0x25, 0x64, 0x01, 0x70, 0x18, 0x90, 0x8E, 0x12, 0xE0, 0x60, 
+0x12, 0x12, 0x9C, 0xC4, 0xF0, 0x90, 0x8E, 0x0E, 0xE0, 0x12, 0x73, 0x8C, 0x54, 0x07, 0x70, 0x03, 
+0x12, 0x77, 0x97, 0x22, 0xEF, 0x70, 0x36, 0x7D, 0x78, 0x7F, 0x02, 0x12, 0x71, 0x96, 0x7D, 0x02, 
+0x7F, 0x03, 0x12, 0x71, 0x96, 0x7D, 0xC8, 0x7F, 0x02, 0x12, 0x72, 0xB3, 0x12, 0x9C, 0xC4, 0xF1, 
+0x24, 0x70, 0x08, 0x12, 0x89, 0x0F, 0x54, 0x7F, 0xF0, 0x80, 0x07, 0x7D, 0x01, 0x7F, 0x0C, 0x12, 
+0x51, 0xA1, 0x12, 0x7F, 0xB9, 0x90, 0x06, 0x0A, 0xE0, 0x54, 0xF8, 0xF0, 0x22, 0x90, 0x01, 0x36, 
+0x74, 0x78, 0xF0, 0xA3, 0x74, 0x02, 0xF0, 0x7D, 0x78, 0xFF, 0x12, 0x72, 0x6E, 0x7D, 0x02, 0x7F, 
+0x03, 0x12, 0x72, 0x6E, 0x90, 0x06, 0x0A, 0xE0, 0x44, 0x07, 0x12, 0x7F, 0xD3, 0xE4, 0xFF, 0xF1, 
+0x2B, 0xBF, 0x01, 0x11, 0x12, 0x70, 0x08, 0x90, 0x8E, 0x15, 0xE0, 0x20, 0xE2, 0x09, 0x7D, 0x01, 
+0x7F, 0x04, 0x02, 0x51, 0xA1, 0x71, 0x52, 0x22, 0x90, 0x8E, 0x0F, 0xE0, 0x54, 0xFB, 0xF0, 0x22, 
+0x11, 0xAA, 0x13, 0x54, 0x1F, 0x30, 0xE0, 0x0B, 0xEF, 0xC4, 0x13, 0x13, 0x54, 0x03, 0x30, 0xE0, 
+0x02, 0x11, 0xA4, 0x90, 0x8E, 0x0E, 0xE0, 0xFF, 0x13, 0x13, 0x54, 0x3F, 0x30, 0xE0, 0x09, 0xEF, 
+0x71, 0x8C, 0x54, 0x07, 0x70, 0x43, 0x80, 0x3F, 0x90, 0x8E, 0x1B, 0xE0, 0x04, 0xF0, 0x90, 0x8E, 
+0x16, 0xE0, 0x54, 0xEF, 0xF0, 0x71, 0x97, 0x40, 0x2E, 0x12, 0x6F, 0x25, 0x64, 0x01, 0x70, 0x29, 
+0x91, 0x1B, 0x70, 0x04, 0x11, 0x7A, 0x80, 0xB0, 0x11, 0x7A, 0x90, 0x8E, 0x1C, 0xE0, 0x04, 0xF0, 
+0xE0, 0xD3, 0x94, 0x02, 0x40, 0x09, 0x11, 0x08, 0xE4, 0x90, 0x8E, 0x1C, 0xF0, 0x80, 0x02, 0x71, 
+0xAF, 0xE4, 0x90, 0x8E, 0x1B, 0xF0, 0x22, 0xF1, 0x97, 0x22, 0x71, 0x97, 0x40, 0x25, 0x90, 0x8E, 
+0x2C, 0xE0, 0x04, 0xF0, 0xE0, 0xFF, 0x94, 0x04, 0x50, 0x19, 0x90, 0x8E, 0x24, 0xEF, 0xF0, 0x25, 
+0xE0, 0x24, 0x08, 0x90, 0x8E, 0x2B, 0xF0, 0xFB, 0x90, 0x8E, 0x24, 0xE0, 0xFF, 0xA3, 0xE0, 0xFD, 
+0x12, 0x7F, 0x46, 0x22, 0x7D, 0x02, 0x7F, 0x02, 0x21, 0x96, 0x90, 0x8E, 0x0F, 0xE0, 0xFF, 0x13, 
+0x13, 0x22, 0x71, 0xA3, 0x78, 0x02, 0xCE, 0xC3, 0x13, 0xCE, 0x13, 0xD8, 0xF9, 0xFF, 0xF1, 0x87, 
+0x12, 0x6F, 0x24, 0x64, 0x01, 0x60, 0x02, 0x21, 0x71, 0x90, 0x8E, 0x12, 0xE0, 0x70, 0x02, 0x21, 
+0x71, 0x31, 0x83, 0x64, 0x01, 0x70, 0x22, 0x90, 0x06, 0xAB, 0xE0, 0x90, 0x8E, 0x19, 0xF0, 0x90, 
+0x06, 0xAA, 0xE0, 0x90, 0x8E, 0x18, 0xF0, 0xA3, 0xE0, 0xFF, 0x70, 0x08, 0x90, 0x8E, 0x18, 0xE0, 
+0xFE, 0xFF, 0x80, 0x00, 0x90, 0x8E, 0x19, 0xEF, 0xF0, 0x12, 0x6C, 0x99, 0xE4, 0x90, 0x8E, 0x1B, 
+0x12, 0x7F, 0xD3, 0x12, 0x9C, 0xC4, 0x71, 0x8E, 0x54, 0xEF, 0xF0, 0x31, 0x83, 0x24, 0xFD, 0x50, 
+0x02, 0x80, 0x02, 0x71, 0xC0, 0x11, 0xAA, 0x13, 0x54, 0x1F, 0x30, 0xE0, 0x52, 0xEF, 0xC4, 0x13, 
+0x13, 0x54, 0x03, 0x20, 0xE0, 0x21, 0x31, 0x72, 0x6F, 0x70, 0x44, 0x90, 0x8E, 0x0F, 0xE0, 0x44, 
+0x40, 0xF0, 0x12, 0x9E, 0x27, 0x31, 0x7A, 0x7F, 0x03, 0x51, 0xCA, 0x31, 0x92, 0x11, 0xA4, 0x90, 
+0x8E, 0x19, 0xE0, 0x14, 0xF0, 0x80, 0x28, 0x12, 0x9E, 0x1F, 0x64, 0x01, 0x70, 0x21, 0x31, 0x72, 
+0xFE, 0x6F, 0x60, 0x1B, 0x90, 0x05, 0x73, 0xE0, 0xFF, 0xEE, 0x6F, 0x60, 0x12, 0x11, 0xAA, 0x54, 
+0x3F, 0x30, 0xE0, 0x0B, 0xEF, 0x54, 0xBF, 0x31, 0x7A, 0x7F, 0x03, 0x51, 0xB3, 0x51, 0x64, 0x71, 
+0x52, 0x22, 0x90, 0x8E, 0x18, 0xE0, 0xFF, 0xA3, 0xE0, 0x22, 0xF0, 0x90, 0x01, 0x3F, 0x74, 0x10, 
+0xF0, 0xFD, 0x22, 0x90, 0x8E, 0x10, 0xE0, 0xFF, 0xC4, 0x54, 0x0F, 0x22, 0x7D, 0x02, 0x7F, 0x02, 
+0x31, 0x96, 0x7D, 0x01, 0x7F, 0x02, 0x74, 0x5D, 0x71, 0x5A, 0xFE, 0xF6, 0x74, 0x30, 0x41, 0xBB, 
+0x90, 0x8E, 0x12, 0xE0, 0x60, 0x49, 0x90, 0x8E, 0x0E, 0xE0, 0x30, 0xE0, 0x1A, 0x90, 0x8E, 0x29, 
+0xE0, 0x04, 0xF0, 0x71, 0xA3, 0x78, 0x02, 0xCE, 0xC3, 0x13, 0xCE, 0x13, 0xD8, 0xF9, 0xFF, 0x90, 
+0x8E, 0x49, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x11, 0xAA, 0x13, 0x54, 0x1F, 0x30, 0xE0, 0x09, 0x90, 
+0x01, 0x3B, 0xE0, 0x30, 0xE4, 0x02, 0x31, 0x8C, 0x90, 0x92, 0xD1, 0xE0, 0x04, 0xF0, 0xE0, 0xC3, 
+0x94, 0x80, 0x40, 0x0B, 0x90, 0x01, 0x98, 0xE0, 0x54, 0xFE, 0xF0, 0xE0, 0x44, 0x01, 0xF0, 0xD1, 
+0x80, 0x12, 0x96, 0xFB, 0xE4, 0x90, 0x90, 0xE7, 0xF0, 0x51, 0x53, 0x12, 0x9D, 0x3A, 0x30, 0xE0, 
+0x51, 0x90, 0x90, 0x7C, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x7C, 0x00, 0x7D, 0x64, 0x12, 0x26, 0xAA, 
+0x90, 0x90, 0xD0, 0xE0, 0x6E, 0x70, 0x03, 0xA3, 0xE0, 0x6F, 0x60, 0x0A, 0x90, 0x90, 0xD0, 0xE4, 
+0x75, 0xF0, 0x01, 0x02, 0x46, 0xD6, 0x90, 0x90, 0x80, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x90, 0x90, 
+0x8E, 0xE0, 0xB5, 0x06, 0x14, 0xA3, 0xE0, 0xB5, 0x07, 0x0F, 0xEF, 0x4E, 0x60, 0x0B, 0x90, 0x01, 
+0xC7, 0x74, 0x31, 0xF0, 0x7F, 0x01, 0x02, 0x63, 0x09, 0xD1, 0xF3, 0xE4, 0x90, 0x90, 0xD0, 0xF0, 
+0xA3, 0xF0, 0x22, 0x90, 0x8E, 0xC1, 0xE0, 0x30, 0xE0, 0x09, 0x90, 0x01, 0x3B, 0xE0, 0x30, 0xE4, 
+0x02, 0x31, 0x8C, 0x22, 0x7D, 0x01, 0x7F, 0x02, 0x51, 0x6E, 0x7D, 0x02, 0x7F, 0x02, 0x74, 0x5D, 
+0x2F, 0xF8, 0xE6, 0x4D, 0xFE, 0xF6, 0x74, 0x30, 0x80, 0x41, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 
+0xD0, 0xEF, 0x64, 0x01, 0x70, 0x1B, 0x90, 0x8E, 0xC3, 0xE0, 0x7D, 0x10, 0x7F, 0x03, 0x60, 0x08, 
+0x51, 0xB3, 0x51, 0xC6, 0x71, 0x83, 0x80, 0x04, 0x51, 0xB3, 0x31, 0x8C, 0x12, 0x55, 0xF7, 0x80, 
+0x0D, 0x51, 0xC6, 0x51, 0x6A, 0x7D, 0x01, 0x7F, 0x02, 0x51, 0x6E, 0x12, 0x57, 0xE2, 0xD0, 0xD0, 
+0x92, 0xAF, 0x22, 0x74, 0x65, 0x71, 0x5A, 0xFE, 0xF6, 0x74, 0x38, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 
+0x01, 0xF5, 0x83, 0xEE, 0xF0, 0x22, 0x7D, 0x10, 0x7F, 0x03, 0x74, 0x65, 0x2F, 0xF8, 0xE6, 0x4D, 
+0x80, 0xE5, 0x90, 0x8E, 0x0E, 0xE0, 0x54, 0xFB, 0xF0, 0xE4, 0x90, 0x8E, 0x1B, 0xF0, 0xA3, 0xF0, 
+0x90, 0x8E, 0x16, 0xF0, 0x90, 0x8E, 0x0F, 0x12, 0x89, 0x18, 0x51, 0x64, 0x7D, 0x10, 0x7F, 0x03, 
+0x80, 0xC1, 0xEF, 0x60, 0x3F, 0x90, 0x90, 0xD4, 0xE0, 0xFF, 0x60, 0x02, 0xF1, 0xA1, 0x90, 0x01, 
+0xC7, 0xE4, 0x12, 0x83, 0x5E, 0x12, 0x9D, 0xF0, 0x90, 0x06, 0x09, 0xE0, 0x54, 0xFE, 0xF0, 0x7D, 
+0x35, 0x12, 0x56, 0x2D, 0x90, 0x02, 0x86, 0xE0, 0x44, 0x04, 0xF0, 0x12, 0x86, 0xDB, 0x71, 0x51, 
+0x12, 0x56, 0xCF, 0x12, 0x57, 0xDD, 0x12, 0x8E, 0xB7, 0x90, 0x01, 0x34, 0x74, 0x08, 0xF0, 0xFD, 
+0xE4, 0xFF, 0x41, 0x6E, 0x7D, 0x08, 0xE4, 0xFF, 0x31, 0x96, 0x90, 0x06, 0x90, 0xE0, 0x54, 0xF0, 
+0xF0, 0x90, 0x02, 0x86, 0xE0, 0x54, 0xFB, 0xF0, 0x12, 0x8F, 0x0B, 0x12, 0x4F, 0xF7, 0x02, 0x4E, 
+0x1A, 0x22, 0x90, 0x8E, 0x0F, 0xE0, 0x44, 0x04, 0xF0, 0x22, 0x2F, 0xF8, 0xE6, 0xFE, 0xED, 0xF4, 
+0x5E, 0x22, 0x12, 0x68, 0x7D, 0x51, 0x6A, 0x90, 0x8E, 0xC1, 0xE0, 0x30, 0xE0, 0x14, 0x71, 0x83, 
+0x90, 0x8E, 0xC4, 0xE0, 0x60, 0x05, 0x14, 0xF0, 0x02, 0x55, 0xF7, 0x12, 0x8A, 0x24, 0xE4, 0xFF, 
+0x51, 0x7A, 0x22, 0x90, 0x8E, 0xC3, 0xE0, 0x90, 0x05, 0x73, 0xF0, 0x22, 0x54, 0xFB, 0xF0, 0x90, 
+0x8E, 0x16, 0xE0, 0x54, 0xFD, 0xF0, 0x22, 0x90, 0x8E, 0xBA, 0xE0, 0xFF, 0x90, 0x8E, 0x1B, 0xE0, 
+0xD3, 0x9F, 0x22, 0x90, 0x05, 0x62, 0xE0, 0xFE, 0x90, 0x05, 0x61, 0xE0, 0xFD, 0xED, 0x22, 0x12, 
+0x97, 0xFB, 0x90, 0x8E, 0x15, 0xE0, 0x64, 0x0C, 0x60, 0x05, 0x12, 0x53, 0x6B, 0x91, 0xE2, 0x22, 
+0xE4, 0xF5, 0x14, 0x90, 0x06, 0xA9, 0xE0, 0xF5, 0x14, 0x54, 0xC0, 0x70, 0x07, 0x91, 0x13, 0x54, 
+0xFD, 0xF0, 0xE1, 0x97, 0xE5, 0x14, 0x30, 0xE6, 0x1D, 0x90, 0x8E, 0x12, 0xE0, 0x64, 0x01, 0x70, 
+0x17, 0x90, 0x8E, 0x16, 0xE0, 0x44, 0x01, 0xF0, 0x91, 0x1B, 0x64, 0x02, 0x60, 0x04, 0x91, 0x3B, 
+0x80, 0x06, 0x71, 0xAF, 0x80, 0x02, 0x91, 0x13, 0xE5, 0x14, 0x90, 0x8E, 0x16, 0x30, 0xE7, 0x0E, 
+0xE0, 0x44, 0x02, 0x12, 0x68, 0x3B, 0x90, 0x8E, 0x0E, 0xE0, 0x44, 0x04, 0xF0, 0x22, 0xE0, 0x54, 
+0xFD, 0xF0, 0x22, 0x90, 0x8E, 0x16, 0xE0, 0x54, 0xFE, 0xF0, 0x22, 0x90, 0x8E, 0x10, 0xE0, 0x54, 
+0x0F, 0x22, 0xE4, 0xFF, 0x12, 0x6F, 0x2B, 0xBF, 0x01, 0x10, 0x90, 0x8E, 0x12, 0xE0, 0x60, 0x0A, 
+0x91, 0x1B, 0x64, 0x02, 0x60, 0x02, 0x80, 0x03, 0x71, 0xAF, 0x22, 0x90, 0x04, 0x1D, 0xE0, 0x70, 
+0x15, 0x90, 0x8D, 0x09, 0xE0, 0xFF, 0x7B, 0x18, 0xE4, 0xFD, 0x91, 0x57, 0x90, 0x92, 0xCD, 0xEE, 
+0xF0, 0xA3, 0xEF, 0xF0, 0xF1, 0x70, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x92, 
+0xB7, 0xED, 0xF0, 0xA3, 0xEB, 0xF0, 0x90, 0x92, 0xB6, 0xEF, 0xF0, 0xE4, 0xFD, 0xFC, 0xF1, 0x80, 
+0x90, 0x92, 0xB6, 0xE0, 0x90, 0x04, 0x25, 0xF0, 0x90, 0x92, 0xB7, 0xE0, 0x60, 0x05, 0xD1, 0x13, 
+0x44, 0x80, 0xF0, 0xAF, 0x05, 0x74, 0x20, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 
+0x54, 0xC0, 0xF0, 0xD1, 0x13, 0x54, 0xC0, 0xF0, 0x90, 0x00, 0x8B, 0xE0, 0xD3, 0x94, 0x03, 0x74, 
+0x10, 0x40, 0x07, 0xB1, 0xFE, 0x74, 0x04, 0xF0, 0x80, 0x04, 0xB1, 0xFE, 0xE4, 0xF0, 0xAF, 0x05, 
+0xB1, 0xDE, 0xE0, 0x54, 0x01, 0xFE, 0x90, 0x92, 0xB8, 0xE0, 0x25, 0xE0, 0x25, 0xE0, 0xFB, 0xEE, 
+0x44, 0x02, 0x4B, 0xFE, 0xB1, 0xDE, 0xEE, 0xF0, 0x74, 0x11, 0x2F, 0xF1, 0x8F, 0x74, 0xFF, 0xF0, 
+0x74, 0x29, 0x2F, 0xB1, 0xD6, 0xE0, 0x54, 0xF7, 0xF0, 0xAE, 0x04, 0xAF, 0x05, 0xD0, 0xD0, 0x92, 
+0xAF, 0x22, 0x7D, 0x08, 0xE4, 0xFF, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x92, 0x96, 
+0xEF, 0xF0, 0xA3, 0xED, 0xF0, 0x90, 0x8D, 0x03, 0xE0, 0x04, 0xF0, 0x90, 0x04, 0x1D, 0xE0, 0x60, 
+0x22, 0x90, 0x05, 0x22, 0xE0, 0x90, 0x92, 0x9A, 0xF0, 0x7D, 0x26, 0x12, 0x57, 0x94, 0xEF, 0x64, 
+0x01, 0x70, 0x02, 0xB1, 0x30, 0x90, 0x92, 0x9A, 0xE0, 0xFF, 0x7D, 0x27, 0x12, 0x53, 0x74, 0xD1, 
+0x1F, 0x80, 0x04, 0xD1, 0x1F, 0xB1, 0x30, 0xF1, 0x70, 0x7F, 0x01, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 
+0x90, 0x8D, 0x0A, 0xE0, 0xFF, 0x90, 0x92, 0x97, 0xE0, 0xFB, 0x7D, 0x01, 0x91, 0x57, 0x90, 0x92, 
+0x98, 0xEE, 0xF0, 0xFC, 0xA3, 0xEF, 0xF0, 0xFD, 0x90, 0x92, 0x96, 0xE0, 0xFF, 0xB1, 0xB5, 0x90, 
+0x92, 0x98, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x90, 0x81, 0x00, 0xE0, 0x54, 0x0F, 0xFD, 0xAC, 0x07, 
+0xD1, 0x07, 0x44, 0x01, 0xF0, 0xD1, 0x07, 0x54, 0xFB, 0xF0, 0xAC, 0x07, 0x74, 0x12, 0x2C, 0xB1, 
+0xE1, 0xE0, 0x44, 0xFA, 0xF0, 0x74, 0x11, 0x2C, 0xF1, 0x8F, 0xE0, 0x44, 0x1F, 0xF0, 0xAC, 0x07, 
+0x74, 0x06, 0x2C, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x44, 0x0E, 0xF0, 0x90, 0x04, 
+0xA7, 0xE4, 0xF0, 0x90, 0x04, 0xA6, 0xF0, 0x90, 0x04, 0xA5, 0x74, 0xFF, 0xF0, 0x90, 0x04, 0xA4, 
+0x74, 0xFD, 0xF0, 0x74, 0x14, 0x2C, 0xB1, 0xF6, 0xE0, 0x54, 0xC0, 0x4D, 0xFD, 0x74, 0x14, 0x2F, 
+0xB1, 0xF6, 0xED, 0xF0, 0x22, 0xB1, 0xEA, 0x54, 0x3F, 0xF0, 0xEF, 0x60, 0x0B, 0xB1, 0xD3, 0xE0, 
+0x44, 0x10, 0xB1, 0xE9, 0x44, 0x80, 0xF0, 0x22, 0xB1, 0xD3, 0xE0, 0x54, 0xEF, 0xB1, 0xE9, 0x44, 
+0x40, 0xF0, 0x22, 0x74, 0x29, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0x22, 0x74, 0x12, 
+0x2F, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0x22, 0xF0, 0x74, 0x09, 0x2D, 0xF5, 0x82, 0xE4, 
+0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x22, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0x22, 0x2D, 0xF5, 
+0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0x22, 0x74, 0x0D, 0x2C, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 
+0x83, 0xE0, 0x22, 0x74, 0x21, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x22, 0x90, 
+0x92, 0x96, 0xE0, 0xFF, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x92, 0xD7, 0xEF, 0xF0, 
+0x90, 0x8D, 0x0A, 0xE0, 0xFF, 0x90, 0x04, 0x1C, 0xE0, 0x6F, 0x70, 0x3F, 0x90, 0x8E, 0x15, 0xE0, 
+0x64, 0x0E, 0x70, 0x16, 0x90, 0x92, 0xD7, 0xE0, 0x70, 0x31, 0x90, 0x8E, 0x0E, 0xE0, 0x54, 0x7F, 
+0xF0, 0x12, 0x57, 0xF6, 0xF0, 0x12, 0x51, 0x0C, 0x80, 0x1E, 0x90, 0x8E, 0x15, 0xE0, 0x64, 0x06, 
+0x70, 0x19, 0x90, 0x92, 0xD7, 0xE0, 0x60, 0x13, 0x90, 0x8E, 0x0E, 0xE0, 0x54, 0xBF, 0xF0, 0x12, 
+0x9D, 0x50, 0x90, 0x8E, 0x15, 0x74, 0x04, 0xF0, 0x12, 0x57, 0xDD, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 
+0x90, 0x90, 0xE8, 0xE0, 0x30, 0xE0, 0x6B, 0x90, 0x90, 0xEC, 0xE0, 0x04, 0xF0, 0x90, 0x90, 0xEF, 
+0xE0, 0x64, 0x01, 0x70, 0x21, 0x90, 0x90, 0xE8, 0xE0, 0x13, 0x13, 0x54, 0x3F, 0x30, 0xE0, 0x16, 
+0x90, 0x90, 0xEE, 0xE0, 0x70, 0x10, 0x90, 0x90, 0xEB, 0xE0, 0xFF, 0xA3, 0xE0, 0xC3, 0x9F, 0x40, 
+0x05, 0x12, 0x8A, 0x2E, 0xF0, 0x22, 0x90, 0x90, 0xEC, 0xE0, 0xFF, 0x90, 0x90, 0xE9, 0xE0, 0xD3, 
+0x9F, 0x50, 0x2F, 0x90, 0x06, 0x92, 0xE0, 0x20, 0xE2, 0x19, 0x90, 0x90, 0xEE, 0xE0, 0x70, 0x13, 
+0x7D, 0x08, 0xFF, 0x91, 0xE6, 0x90, 0x90, 0xED, 0xE0, 0x04, 0xF0, 0x90, 0x90, 0xE7, 0xE0, 0x04, 
+0xF0, 0x80, 0x06, 0x90, 0x06, 0x92, 0x74, 0x04, 0xF0, 0xE4, 0x90, 0x90, 0xEC, 0xF0, 0x90, 0x90, 
+0xEE, 0xF0, 0x22, 0xE4, 0x90, 0x92, 0x14, 0xF0, 0xA3, 0xF0, 0x90, 0x06, 0x32, 0xE0, 0x44, 0x20, 
+0xF0, 0x12, 0x90, 0xD4, 0xEF, 0x64, 0x01, 0x70, 0x66, 0x90, 0x90, 0xDF, 0xE0, 0xFF, 0x7B, 0x08, 
+0x7D, 0x01, 0x91, 0x57, 0xF1, 0x87, 0xF0, 0x90, 0x92, 0x11, 0x12, 0x81, 0xE4, 0x90, 0x92, 0x13, 
+0xEF, 0xF0, 0x90, 0x92, 0x11, 0x12, 0x9D, 0x21, 0xE4, 0xFD, 0x12, 0x80, 0x53, 0x90, 0x92, 0x13, 
+0xE0, 0xFF, 0x90, 0x92, 0x12, 0xE0, 0x2F, 0xFF, 0x90, 0x92, 0x11, 0xE0, 0x34, 0x00, 0xCF, 0x24, 
+0x30, 0xCF, 0x34, 0x00, 0xFE, 0x90, 0x92, 0x14, 0xF0, 0xA3, 0xEF, 0xF0, 0x12, 0x86, 0x78, 0xF1, 
+0x77, 0x90, 0x90, 0xDF, 0xE0, 0xFB, 0xE4, 0xFF, 0x12, 0x83, 0x91, 0xF1, 0x77, 0x90, 0x90, 0xDB, 
+0xE0, 0xFB, 0x7F, 0x11, 0x12, 0x83, 0x91, 0xF1, 0x70, 0x90, 0x90, 0x8E, 0x12, 0x59, 0x26, 0x22, 
+0x90, 0x04, 0x1F, 0x74, 0x20, 0xF0, 0x22, 0x90, 0x92, 0x14, 0xE0, 0xFC, 0xA3, 0xE0, 0xFD, 0x22, 
+0xF1, 0xB7, 0x7C, 0x00, 0xAD, 0x07, 0x22, 0x90, 0x92, 0x11, 0xEE, 0xF0, 0xA3, 0xEF, 0x22, 0xF5, 
+0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0x22, 0x90, 0x8E, 0x14, 0xE0, 0xFF, 0x7D, 0x01, 0x02, 0x51, 
+0xA1, 0xF1, 0xB7, 0x7E, 0x00, 0x74, 0x00, 0x2F, 0x12, 0x82, 0x8C, 0x75, 0x43, 0x08, 0x7B, 0x01, 
+0x7A, 0x8F, 0x79, 0x96, 0x02, 0x34, 0x2C, 0xE4, 0xFE, 0xEF, 0x25, 0xE0, 0xFD, 0xEF, 0xC3, 0x94, 
+0x80, 0x90, 0xFD, 0x12, 0x50, 0x04, 0xE4, 0xF0, 0x80, 0x03, 0x74, 0x01, 0xF0, 0x90, 0xFD, 0x10, 
+0xED, 0xF0, 0xAF, 0x06, 0x22, 0xE4, 0xFF, 0x12, 0x6F, 0x2B, 0xBF, 0x01, 0x0E, 0x90, 0x8E, 0x12, 
+0xE0, 0x60, 0x08, 0x91, 0x13, 0x54, 0x07, 0x70, 0x02, 0xF1, 0x97, 0x22, 0xD3, 0x10, 0xAF, 0x01, 
+0xC3, 0xC0, 0xD0, 0x90, 0x92, 0x73, 0xEF, 0xF0, 0xA3, 0xED, 0xF0, 0xFB, 0x7D, 0x00, 0x7C, 0x00, 
+0xE4, 0x90, 0x92, 0x79, 0xF0, 0xEB, 0x90, 0x92, 0x74, 0xF0, 0x7F, 0xB0, 0x7E, 0x08, 0x12, 0x36, 
+0xCE, 0xE4, 0xFF, 0xEC, 0x90, 0x92, 0x75, 0x12, 0x27, 0x48, 0x90, 0x92, 0x75, 0x12, 0x47, 0x3E, 
+0x90, 0x92, 0x74, 0x12, 0x69, 0x0E, 0x12, 0x47, 0x14, 0xA3, 0x12, 0x27, 0x48, 0x90, 0x92, 0x75, 
+0x12, 0x56, 0xC6, 0x7F, 0xB0, 0x7E, 0x08, 0x12, 0x37, 0x5D, 0x11, 0x60, 0x90, 0x92, 0x73, 0xE0, 
+0x75, 0xF0, 0x08, 0xA4, 0x24, 0x73, 0xF5, 0x82, 0xE4, 0x34, 0xAF, 0xF5, 0x83, 0xE0, 0xFE, 0xA3, 
+0xE0, 0xFF, 0x12, 0x36, 0xCE, 0xED, 0x54, 0x0F, 0xFD, 0xE4, 0xFC, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 
+0x7F, 0x14, 0x7E, 0x00, 0x02, 0x3A, 0xF7, 0xE4, 0x90, 0x90, 0xF6, 0xF0, 0xA3, 0xF0, 0x90, 0x01, 
+0x98, 0xE0, 0x7F, 0x00, 0x30, 0xE4, 0x02, 0x7F, 0x01, 0xEF, 0x64, 0x01, 0x60, 0x3C, 0xC3, 0x90, 
+0x90, 0xF7, 0xE0, 0x94, 0x88, 0x90, 0x90, 0xF6, 0xE0, 0x94, 0x13, 0x40, 0x0F, 0x90, 0x01, 0xC1, 
+0xE0, 0x44, 0x10, 0xF0, 0x90, 0x01, 0xC7, 0x74, 0xFD, 0xF0, 0x80, 0x1E, 0x90, 0x90, 0xF6, 0x12, 
+0x59, 0x26, 0x11, 0x60, 0xD3, 0x90, 0x90, 0xF7, 0xE0, 0x94, 0x32, 0x90, 0x90, 0xF6, 0xE0, 0x94, 
+0x00, 0x40, 0xBB, 0x90, 0x01, 0xC6, 0xE0, 0x30, 0xE3, 0xB4, 0x90, 0x01, 0xC7, 0x74, 0xFE, 0xF0, 
+0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x12, 0x77, 0xEC, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 
+0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0xC0, 0x07, 0xC0, 0x05, 0x90, 0x92, 0x82, 0x12, 0x47, 
+0x32, 0x90, 0xAC, 0x9C, 0x12, 0x27, 0x48, 0xD0, 0x05, 0xD0, 0x07, 0x12, 0x32, 0x65, 0xD0, 0xD0, 
+0x92, 0xAF, 0x22, 0xC0, 0xE0, 0xC0, 0xF0, 0xC0, 0x83, 0xC0, 0x82, 0xC0, 0xD0, 0x75, 0xD0, 0x00, 
+0xC0, 0x00, 0xC0, 0x01, 0xC0, 0x02, 0xC0, 0x03, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 
+0x90, 0x01, 0xC4, 0x74, 0xF3, 0xF0, 0x74, 0x78, 0xA3, 0xF0, 0x31, 0x42, 0x74, 0xF3, 0x04, 0x90, 
+0x01, 0xC4, 0xF0, 0x74, 0x78, 0xA3, 0xF0, 0xD0, 0x07, 0xD0, 0x06, 0xD0, 0x05, 0xD0, 0x04, 0xD0, 
+0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x82, 0xD0, 0x83, 0xD0, 0xF0, 0xD0, 
+0xE0, 0x32, 0x7B, 0x00, 0x7A, 0x00, 0x79, 0x53, 0xE4, 0xFD, 0x7F, 0x01, 0x12, 0x39, 0x33, 0xE5, 
+0x51, 0x52, 0x53, 0x7B, 0x00, 0x7A, 0x00, 0x79, 0x54, 0x7D, 0x01, 0x7F, 0x01, 0x12, 0x39, 0x33, 
+0xE5, 0x52, 0x52, 0x54, 0xAB, 0x53, 0xE4, 0xFD, 0x7F, 0x01, 0x12, 0x39, 0x04, 0xAB, 0x54, 0x7D, 
+0x01, 0x7F, 0x01, 0x02, 0x39, 0x04, 0xC0, 0xE0, 0xC0, 0xF0, 0xC0, 0x83, 0xC0, 0x82, 0xC0, 0xD0, 
+0x75, 0xD0, 0x00, 0xC0, 0x00, 0xC0, 0x01, 0xC0, 0x02, 0xC0, 0x03, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 
+0x06, 0xC0, 0x07, 0x90, 0x01, 0xC4, 0x74, 0x76, 0xF0, 0x74, 0x79, 0xA3, 0xF0, 0x31, 0xE7, 0xE5, 
+0x5C, 0x30, 0xE7, 0x02, 0x31, 0xCC, 0x74, 0x76, 0x04, 0x90, 0x01, 0xC4, 0xF0, 0x74, 0x79, 0xA3, 
+0xF0, 0xD0, 0x07, 0xD0, 0x06, 0xD0, 0x05, 0xD0, 0x04, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 
+0x00, 0xD0, 0xD0, 0xD0, 0x82, 0xD0, 0x83, 0xD0, 0xF0, 0xD0, 0xE0, 0x32, 0x7F, 0x01, 0x7E, 0x00, 
+0x12, 0x3A, 0x69, 0x90, 0x00, 0xF2, 0xE0, 0x20, 0xE6, 0x0C, 0x90, 0x00, 0x05, 0xE0, 0x44, 0x80, 
+0xFD, 0x7F, 0x05, 0x12, 0x3A, 0x96, 0x22, 0x90, 0x00, 0x54, 0xE0, 0x55, 0x55, 0xF5, 0x59, 0xA3, 
+0xE0, 0x55, 0x56, 0xF5, 0x5A, 0xA3, 0xE0, 0x55, 0x57, 0xF5, 0x5B, 0xA3, 0xE0, 0x55, 0x58, 0xF5, 
+0x5C, 0xAD, 0x59, 0x7F, 0x54, 0x12, 0x3A, 0x96, 0xAD, 0x5A, 0x7F, 0x55, 0x12, 0x3A, 0x96, 0xAD, 
+0x5B, 0x7F, 0x56, 0x12, 0x3A, 0x96, 0xAD, 0x5C, 0x7F, 0x57, 0x12, 0x3A, 0x96, 0x53, 0x91, 0xEF, 
+0x22, 0xC0, 0xE0, 0xC0, 0xF0, 0xC0, 0x83, 0xC0, 0x82, 0xC0, 0xD0, 0x75, 0xD0, 0x00, 0xC0, 0x00, 
+0xC0, 0x01, 0xC0, 0x02, 0xC0, 0x03, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0x01, 
+0xC4, 0x74, 0x21, 0xF0, 0x74, 0x7A, 0xA3, 0xF0, 0x12, 0x90, 0x29, 0xE5, 0x61, 0x30, 0xE3, 0x02, 
+0x91, 0x44, 0xE5, 0x61, 0x30, 0xE4, 0x02, 0x71, 0x0D, 0xE5, 0x61, 0x30, 0xE5, 0x03, 0x12, 0x90, 
+0x86, 0xE5, 0x63, 0x30, 0xE0, 0x02, 0xB1, 0xCC, 0xE5, 0x63, 0x30, 0xE1, 0x03, 0x12, 0x71, 0xA0, 
+0xE5, 0x63, 0x30, 0xE2, 0x03, 0x12, 0x90, 0xC2, 0xE5, 0x63, 0x30, 0xE3, 0x03, 0x12, 0x6F, 0x4F, 
+0xE5, 0x63, 0x30, 0xE4, 0x03, 0x12, 0x6F, 0x75, 0xE5, 0x63, 0x30, 0xE5, 0x03, 0x12, 0x74, 0x22, 
+0xE5, 0x63, 0x30, 0xE6, 0x03, 0x12, 0x77, 0xD5, 0xE5, 0x64, 0x30, 0xE1, 0x02, 0xB1, 0xCF, 0xE5, 
+0x64, 0x30, 0xE6, 0x02, 0x51, 0xCC, 0x74, 0x21, 0x04, 0x90, 0x01, 0xC4, 0xF0, 0x74, 0x7A, 0xA3, 
+0xF0, 0xD0, 0x07, 0xD0, 0x06, 0xD0, 0x05, 0xD0, 0x04, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 
+0x00, 0xD0, 0xD0, 0xD0, 0x82, 0xD0, 0x83, 0xD0, 0xF0, 0xD0, 0xE0, 0x32, 0x90, 0x07, 0x1F, 0xE0, 
+0x54, 0x7F, 0xF0, 0x90, 0x07, 0x1C, 0xE0, 0x54, 0x01, 0xFF, 0x90, 0x92, 0x13, 0xF0, 0x90, 0x92, 
+0x11, 0x74, 0x02, 0xF0, 0x90, 0x92, 0x1F, 0x14, 0xF0, 0xFB, 0x7A, 0x92, 0x79, 0x11, 0xB1, 0x07, 
+0x7F, 0x04, 0x90, 0x92, 0xCF, 0xEF, 0xF0, 0x7F, 0x02, 0x12, 0x4B, 0x8B, 0x90, 0x8D, 0x01, 0xE0, 
+0xFF, 0x90, 0x92, 0xCF, 0xE0, 0xFE, 0xEF, 0x4E, 0x90, 0x8D, 0x01, 0xF0, 0x22, 0x71, 0x20, 0x7F, 
+0x02, 0x8F, 0x17, 0x7F, 0x02, 0x12, 0x4B, 0x8B, 0x90, 0x8D, 0x01, 0xE0, 0x45, 0x17, 0xF0, 0x22, 
+0x90, 0x01, 0xCC, 0xE0, 0x54, 0x0F, 0x90, 0x92, 0xC1, 0xF0, 0x90, 0x92, 0xC1, 0xE0, 0xFD, 0x70, 
+0x02, 0x81, 0x19, 0x90, 0x8D, 0x5F, 0xE0, 0xFF, 0x70, 0x06, 0xA3, 0xE0, 0x64, 0x09, 0x60, 0x0A, 
+0xEF, 0x14, 0xFF, 0x90, 0x8D, 0x60, 0xE0, 0xB5, 0x07, 0x04, 0x7F, 0x01, 0x80, 0x02, 0x7F, 0x00, 
+0xEF, 0x60, 0x08, 0x90, 0x01, 0xC1, 0xE0, 0x44, 0x01, 0xF0, 0x22, 0x90, 0x92, 0xBF, 0xB1, 0xD9, 
+0x80, 0x05, 0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 0xF9, 0xFF, 0xEF, 0x5D, 0x70, 0x02, 0x61, 0xFB, 
+0xE4, 0x90, 0x92, 0xC2, 0xF0, 0x90, 0x92, 0xC2, 0xE0, 0xF9, 0xC3, 0x94, 0x04, 0x50, 0x31, 0x91, 
+0x1A, 0xA4, 0xFF, 0xE9, 0xFD, 0x7C, 0x00, 0x2F, 0xFF, 0xEC, 0x35, 0xF0, 0xFE, 0x74, 0xD0, 0x91, 
+0x32, 0x90, 0x8D, 0x0F, 0x91, 0x22, 0x91, 0x1A, 0xA4, 0x2D, 0xFF, 0xEC, 0x35, 0xF0, 0xFE, 0x74, 
+0xF0, 0x91, 0x32, 0x90, 0x8D, 0x13, 0x91, 0x22, 0x90, 0x92, 0xC2, 0xE0, 0x04, 0xF0, 0x80, 0xC5, 
+0x90, 0x92, 0xC1, 0xE0, 0xFF, 0x90, 0x92, 0xBF, 0xE0, 0xFE, 0x74, 0x01, 0xA8, 0x06, 0x08, 0x80, 
+0x02, 0xC3, 0x33, 0xD8, 0xFC, 0xF4, 0x5F, 0x90, 0x92, 0xC1, 0xF0, 0x90, 0x92, 0xBF, 0x12, 0x64, 
+0xC7, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0x90, 0x01, 0xCC, 0xF0, 0x90, 0x92, 0xBF, 0xE0, 0x04, 
+0xF0, 0xE0, 0x54, 0x03, 0xF0, 0x90, 0x8D, 0x60, 0xB1, 0x65, 0xB4, 0x0A, 0x02, 0x7F, 0x01, 0xEF, 
+0x70, 0x02, 0x61, 0x2A, 0xE4, 0x90, 0x8D, 0x60, 0xF0, 0x61, 0x2A, 0x90, 0x01, 0xC0, 0xE0, 0x44, 
+0x02, 0xF0, 0x90, 0x92, 0xBF, 0xE0, 0x44, 0x80, 0x90, 0x00, 0x8A, 0xF0, 0x91, 0x1A, 0x90, 0x01, 
+0xD0, 0x12, 0x47, 0x4A, 0xE0, 0x90, 0x01, 0xC3, 0xF0, 0x22, 0x90, 0x92, 0xBF, 0xE0, 0x75, 0xF0, 
+0x04, 0x22, 0x12, 0x47, 0x4A, 0xE5, 0x82, 0x29, 0xF5, 0x82, 0xE4, 0x35, 0x83, 0xF5, 0x83, 0xEF, 
+0xF0, 0x22, 0x2F, 0xF5, 0x82, 0x74, 0x01, 0x3E, 0xF5, 0x83, 0xE0, 0xFF, 0x90, 0x8D, 0x60, 0xE0, 
+0x75, 0xF0, 0x08, 0x22, 0x90, 0x8E, 0xC5, 0xE0, 0x30, 0xE0, 0x04, 0x7F, 0x10, 0x71, 0x11, 0x22, 
+0x90, 0x91, 0x09, 0x74, 0x12, 0xF0, 0x90, 0x91, 0x17, 0x74, 0x05, 0xF0, 0x90, 0x91, 0x0B, 0xEF, 
+0xF0, 0xA3, 0xED, 0xF0, 0xA3, 0xEB, 0xF0, 0x90, 0x91, 0x07, 0xE0, 0x90, 0x91, 0x0E, 0xF0, 0x90, 
+0x91, 0x08, 0xE0, 0x90, 0x91, 0x0F, 0xF0, 0x7B, 0x01, 0x7A, 0x91, 0x79, 0x09, 0xB1, 0x07, 0x7F, 
+0x04, 0x41, 0xF2, 0xB1, 0x00, 0x7F, 0xF5, 0x7E, 0x03, 0x12, 0x33, 0xC7, 0xBF, 0x01, 0x06, 0x90, 
+0x90, 0xFE, 0xE0, 0xA3, 0xF0, 0xB1, 0x00, 0x7F, 0xF6, 0x7E, 0x03, 0x12, 0x33, 0xC7, 0xBF, 0x01, 
+0x08, 0x90, 0x90, 0xFE, 0xE0, 0x90, 0x91, 0x00, 0xF0, 0xB1, 0x00, 0x7F, 0xF4, 0x7E, 0x03, 0x12, 
+0x33, 0xC7, 0xBF, 0x01, 0x08, 0x90, 0x90, 0xFE, 0xE0, 0x90, 0x91, 0x01, 0xF0, 0xB1, 0x00, 0x7F, 
+0xF3, 0x7E, 0x03, 0x12, 0x33, 0xC7, 0xBF, 0x01, 0x08, 0x90, 0x90, 0xFE, 0xE0, 0x90, 0x91, 0x02, 
+0xF0, 0xB1, 0x00, 0x7F, 0xF2, 0x7E, 0x03, 0x12, 0x33, 0xC7, 0xBF, 0x01, 0x08, 0x90, 0x90, 0xFE, 
+0xE0, 0x90, 0x91, 0x03, 0xF0, 0x90, 0x90, 0xFF, 0xE0, 0xFF, 0xA3, 0xE0, 0xFD, 0xA3, 0xE0, 0xFB, 
+0xA3, 0xE0, 0x90, 0x91, 0x07, 0xF0, 0x90, 0x91, 0x03, 0xE0, 0x90, 0x91, 0x08, 0xF0, 0x81, 0x50, 
+0x7B, 0x01, 0x7A, 0x90, 0x79, 0xFE, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x8D, 
+0xF7, 0xE0, 0xFF, 0x70, 0x06, 0xA3, 0xE0, 0x64, 0x09, 0x60, 0x0A, 0xEF, 0x14, 0xFF, 0x90, 0x8D, 
+0xF8, 0xE0, 0xB5, 0x07, 0x04, 0x7F, 0x01, 0x80, 0x02, 0x7F, 0x00, 0xEF, 0x60, 0x09, 0x90, 0x01, 
+0xC1, 0xE0, 0x44, 0x02, 0xF0, 0x80, 0x29, 0xC0, 0x01, 0x90, 0x8D, 0xF8, 0xE0, 0x12, 0x8E, 0x5C, 
+0xA8, 0x01, 0xFC, 0x7D, 0x01, 0xD0, 0x01, 0x7E, 0x00, 0x7F, 0x0F, 0x12, 0x46, 0xB0, 0x90, 0x8D, 
+0xF8, 0xB1, 0x65, 0xB4, 0x0A, 0x02, 0x7F, 0x01, 0xEF, 0x60, 0x05, 0xE4, 0x90, 0x8D, 0xF8, 0xF0, 
+0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xE0, 0x04, 0xF0, 0xE0, 0x7F, 0x00, 0x22, 0xD3, 0x10, 0xAF, 0x01, 
+0xC3, 0xC0, 0xD0, 0x90, 0x8D, 0x60, 0xE0, 0xFF, 0x90, 0x8D, 0x5F, 0xE0, 0xB5, 0x07, 0x04, 0x7F, 
+0x01, 0x80, 0x02, 0x7F, 0x00, 0xEF, 0x70, 0x3F, 0x90, 0x8D, 0x5F, 0xE0, 0xFE, 0x75, 0xF0, 0x08, 
+0x90, 0x8D, 0x0F, 0x12, 0x47, 0x4A, 0xE0, 0xFD, 0xEE, 0x75, 0xF0, 0x08, 0xA4, 0x24, 0x10, 0xF9, 
+0x74, 0x8D, 0x35, 0xF0, 0xFA, 0x7B, 0x01, 0xAF, 0x05, 0x12, 0x65, 0xBE, 0x90, 0x8D, 0x5F, 0xB1, 
+0x65, 0xB4, 0x0A, 0x02, 0x7F, 0x01, 0xEF, 0x60, 0x05, 0xE4, 0x90, 0x8D, 0x5F, 0xF0, 0x71, 0x20, 
+0x90, 0x8D, 0x01, 0xE0, 0x44, 0x02, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x02, 0x69, 0x15, 0x90, 
+0x8E, 0x12, 0xE0, 0x60, 0x03, 0x12, 0x57, 0x79, 0x22, 0xE0, 0xFF, 0x74, 0x01, 0x7E, 0x00, 0xA8, 
+0x07, 0x08, 0x22, 0x90, 0x90, 0xE8, 0xE0, 0x30, 0xE0, 0x3D, 0x90, 0x90, 0xED, 0xE0, 0xFD, 0x60, 
+0x36, 0xB1, 0xDB, 0x80, 0x05, 0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 0xF9, 0xFF, 0x90, 0x04, 0xE0, 
+0xE0, 0xFB, 0xEF, 0x5B, 0x60, 0x0B, 0xE4, 0x90, 0x90, 0xED, 0xF0, 0x90, 0x90, 0xEF, 0x04, 0xF0, 
+0x22, 0x90, 0x90, 0xEA, 0xE0, 0xD3, 0x9D, 0x50, 0x05, 0x12, 0x8A, 0x2E, 0xF0, 0x22, 0x12, 0x74, 
+0xE2, 0x90, 0x90, 0xED, 0xE0, 0x04, 0xF0, 0x22, 0x90, 0x8E, 0x0E, 0xF1, 0xC1, 0x30, 0xE0, 0x15, 
+0xEF, 0x54, 0xBF, 0xD1, 0xF5, 0x30, 0xE0, 0x06, 0xE0, 0x44, 0x01, 0xF0, 0x80, 0x04, 0xE0, 0x54, 
+0xFE, 0xF0, 0x12, 0x77, 0x97, 0xE4, 0xFF, 0x80, 0x9A, 0x90, 0x8E, 0x0E, 0x12, 0x63, 0x00, 0x30, 
+0xE0, 0x1B, 0xEF, 0x54, 0x7F, 0xD1, 0xF5, 0x30, 0xE1, 0x06, 0xE0, 0x44, 0x02, 0xF0, 0x80, 0x04, 
+0xE0, 0x54, 0xFD, 0xF0, 0x90, 0x8E, 0x12, 0xE0, 0x60, 0x03, 0x12, 0x77, 0x97, 0x7F, 0x01, 0xA1, 
+0xE3, 0xC0, 0xE0, 0xC0, 0xF0, 0xC0, 0x83, 0xC0, 0x82, 0xC0, 0xD0, 0x75, 0xD0, 0x00, 0xC0, 0x00, 
+0xC0, 0x01, 0xC0, 0x02, 0xC0, 0x03, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0x01, 
+0xC4, 0x74, 0x71, 0xF0, 0x74, 0x7E, 0xA3, 0xF0, 0x12, 0x90, 0x56, 0xE5, 0x69, 0x30, 0xE1, 0x02, 
+0xF1, 0xC9, 0xE5, 0x69, 0x30, 0xE2, 0x02, 0xD1, 0xFE, 0xE5, 0x6A, 0x30, 0xE0, 0x02, 0xF1, 0x14, 
+0xE5, 0x6C, 0x30, 0xE1, 0x04, 0x7F, 0x04, 0x71, 0x11, 0xE5, 0x6C, 0x30, 0xE4, 0x03, 0x12, 0x73, 
+0x62, 0xE5, 0x6C, 0x30, 0xE5, 0x02, 0xD1, 0x28, 0xE5, 0x6C, 0x30, 0xE6, 0x02, 0xD1, 0x49, 0x74, 
+0x71, 0x04, 0x90, 0x01, 0xC4, 0xF0, 0x74, 0x7E, 0xA3, 0xF0, 0xD0, 0x07, 0xD0, 0x06, 0xD0, 0x05, 
+0xD0, 0x04, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x82, 0xD0, 0x83, 
+0xD0, 0xF0, 0xD0, 0xE0, 0x32, 0xF0, 0x90, 0x04, 0xE0, 0xE0, 0x90, 0x8E, 0x0F, 0x22, 0x90, 0x8E, 
+0x12, 0xE0, 0x60, 0x0F, 0x90, 0x06, 0x92, 0xE0, 0x30, 0xE1, 0x03, 0x02, 0x97, 0xFB, 0xF1, 0xB9, 
+0x12, 0x77, 0x97, 0x22, 0x12, 0x91, 0xC7, 0x90, 0x92, 0x22, 0xEF, 0xF0, 0x30, 0xE0, 0x05, 0x7D, 
+0x01, 0xE4, 0x80, 0x02, 0xE4, 0xFD, 0xFF, 0x12, 0x51, 0x10, 0x90, 0x92, 0x22, 0xE0, 0x30, 0xE6, 
+0x11, 0x90, 0x01, 0x2F, 0xE0, 0x30, 0xE7, 0x04, 0xE4, 0xF0, 0x80, 0x06, 0x90, 0x01, 0x2F, 0x74, 
+0x80, 0xF0, 0x12, 0x9D, 0x2D, 0xFB, 0xAC, 0x07, 0x90, 0x8E, 0x0E, 0xE0, 0x30, 0xE0, 0x16, 0x90, 
+0x8E, 0x48, 0xE0, 0x24, 0x04, 0x90, 0x8E, 0x27, 0xF0, 0x90, 0x8E, 0x48, 0xE0, 0x24, 0x03, 0x90, 
+0x8E, 0x26, 0xF0, 0x80, 0x0B, 0x90, 0x8E, 0x27, 0x74, 0x02, 0xF0, 0x90, 0x8E, 0x26, 0x14, 0xF0, 
+0x90, 0x8E, 0x26, 0xE0, 0xFA, 0x90, 0x8E, 0x25, 0xE0, 0xD3, 0x9A, 0x50, 0x09, 0x90, 0x8E, 0x1A, 
+0xEB, 0xF1, 0xB1, 0x2C, 0x80, 0x0B, 0xAD, 0x02, 0xC3, 0xED, 0x9D, 0x2B, 0x90, 0x8E, 0x1A, 0xF1, 
+0xB1, 0x90, 0x8E, 0x2A, 0xF0, 0x90, 0x8E, 0x2A, 0xE0, 0xFF, 0x7E, 0x00, 0x90, 0x8E, 0x1E, 0xEE, 
+0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0x05, 0x58, 0xE0, 0x6F, 0x70, 0x01, 0xE4, 0x60, 0x02, 0xF1, 0xD4, 
+0x22, 0xF0, 0x90, 0x8E, 0x27, 0xE0, 0xC3, 0x9D, 0x22, 0x90, 0x8E, 0x0E, 0xE0, 0x54, 0xF7, 0xF0, 
+0x22, 0xE0, 0xFF, 0xC4, 0x13, 0x13, 0x54, 0x03, 0x22, 0x90, 0x8E, 0x12, 0xE0, 0x60, 0x03, 0x12, 
+0x70, 0x10, 0x22, 0xF0, 0x90, 0x8E, 0x1E, 0xA3, 0xE0, 0x90, 0x05, 0x58, 0xF0, 0x22, 0xC0, 0xE0, 
+0xC0, 0x83, 0xC0, 0x82, 0xC0, 0xD0, 0x75, 0xD0, 0x00, 0xC0, 0x05, 0xC0, 0x07, 0x7D, 0xDE, 0x90, 
+0x01, 0xC4, 0xED, 0xF0, 0x74, 0x7F, 0xFF, 0xA3, 0xF0, 0xED, 0x04, 0x90, 0x01, 0xC4, 0xF0, 0xA3, 
+0xEF, 0xF0, 0xD0, 0x07, 0xD0, 0x05, 0xD0, 0xD0, 0xD0, 0x82, 0xD0, 0x83, 0xD0, 0xE0, 0x32, 0x90, 
+0x02, 0x09, 0xE0, 0xF5, 0x0D, 0x12, 0x26, 0x1E, 0x25, 0x0D, 0x90, 0x8D, 0x08, 0x12, 0x4E, 0xCD, 
+0x25, 0x0D, 0x90, 0x8D, 0x09, 0x12, 0x4F, 0xF0, 0x25, 0x0D, 0x90, 0x8D, 0x0A, 0x12, 0x4F, 0xAD, 
+0x25, 0x0D, 0x90, 0x8D, 0x0B, 0x11, 0x4C, 0x25, 0x0D, 0x90, 0x8D, 0x0C, 0x31, 0xD0, 0x25, 0x0D, 
+0x90, 0x8D, 0x0D, 0x31, 0x4F, 0x25, 0x0D, 0x90, 0x8D, 0x0E, 0xF0, 0x22, 0xF0, 0x90, 0x00, 0x04, 
+0x02, 0x26, 0x37, 0x90, 0x92, 0x89, 0xED, 0xF0, 0x90, 0x92, 0x86, 0x12, 0x47, 0x5F, 0xE4, 0x90, 
+0x92, 0x8A, 0xF0, 0xA3, 0xF0, 0x12, 0x26, 0x1E, 0xFF, 0x12, 0x4E, 0xCE, 0xFD, 0x11, 0x4D, 0xFB, 
+0x51, 0x0A, 0x90, 0x92, 0x8A, 0xEF, 0xF0, 0x90, 0x92, 0x86, 0x12, 0x47, 0x56, 0x11, 0x4D, 0xFF, 
+0xD1, 0x9C, 0x90, 0x92, 0x8B, 0xEF, 0xF0, 0x90, 0x8F, 0x9F, 0xE0, 0x24, 0xFE, 0x60, 0x14, 0x24, 
+0xFE, 0x60, 0x10, 0x14, 0x60, 0x07, 0x14, 0x60, 0x04, 0x24, 0x05, 0x70, 0x41, 0x11, 0xDF, 0x11, 
+0xEB, 0x80, 0x0D, 0x11, 0xDF, 0x90, 0x8F, 0x9F, 0xE0, 0x90, 0x92, 0x61, 0xF0, 0x12, 0x4E, 0xD4, 
+0x90, 0x92, 0x8B, 0xE0, 0xFF, 0x90, 0x92, 0x86, 0x12, 0x47, 0x56, 0x90, 0x92, 0x8A, 0xE0, 0x7C, 
+0x00, 0x29, 0xF9, 0xEC, 0x3A, 0xFA, 0xC3, 0xE9, 0x9F, 0xF9, 0xEA, 0x94, 0x00, 0xFA, 0x75, 0x40, 
+0x01, 0x75, 0x41, 0x8F, 0x75, 0x42, 0x96, 0xA3, 0xE0, 0xF5, 0x43, 0x12, 0x34, 0x2C, 0x22, 0x7B, 
+0x01, 0x7A, 0x8F, 0x79, 0x96, 0x90, 0x92, 0x89, 0xE0, 0xFD, 0x22, 0x90, 0x92, 0x6E, 0xED, 0xF0, 
+0x90, 0x92, 0x6B, 0x12, 0x47, 0x5F, 0x12, 0x4F, 0xAE, 0x90, 0x92, 0x72, 0xF0, 0x90, 0x92, 0x6B, 
+0x12, 0x5B, 0xDD, 0x75, 0x43, 0x03, 0x7B, 0x01, 0x7A, 0x92, 0x79, 0x6F, 0x12, 0x34, 0x2C, 0x90, 
+0x92, 0x6E, 0xE0, 0x70, 0x2E, 0xFF, 0x31, 0x44, 0xE0, 0xB4, 0xFF, 0x06, 0x31, 0x44, 0xE4, 0xF0, 
+0x80, 0x07, 0x31, 0x44, 0xE0, 0x04, 0xF0, 0x80, 0x05, 0x0F, 0xEF, 0xB4, 0x03, 0xE8, 0x75, 0x40, 
+0x01, 0x75, 0x41, 0x92, 0x75, 0x42, 0x6F, 0x75, 0x43, 0x03, 0x90, 0x92, 0x6B, 0x12, 0x47, 0x56, 
+0x12, 0x34, 0x2C, 0x22, 0x74, 0x6F, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x92, 0xF5, 0x83, 0x22, 0xF0, 
+0x90, 0x00, 0x06, 0x02, 0x26, 0x37, 0x31, 0xD7, 0x2E, 0x90, 0x90, 0xD4, 0x12, 0x4E, 0xCD, 0xFF, 
+0xED, 0x2F, 0x90, 0x90, 0xD5, 0x12, 0x4F, 0xF0, 0xFF, 0xED, 0x2F, 0x90, 0x90, 0xD6, 0x12, 0x4F, 
+0xAD, 0xFF, 0xED, 0x2F, 0x90, 0x90, 0xD7, 0x11, 0x4C, 0xFF, 0xED, 0x2F, 0x90, 0x90, 0xD8, 0x31, 
+0xD0, 0xFF, 0xED, 0x2F, 0x90, 0x90, 0xD9, 0x31, 0x4F, 0xFF, 0xAE, 0x05, 0xED, 0x2F, 0x90, 0x90, 
+0xDA, 0xF0, 0x22, 0x31, 0xD7, 0x2E, 0x90, 0x90, 0xDB, 0x12, 0x4E, 0xCD, 0xFF, 0xED, 0x2F, 0x90, 
+0x90, 0xDC, 0x12, 0x4F, 0xF0, 0xFF, 0xED, 0x2F, 0x90, 0x90, 0xDD, 0x12, 0x4F, 0xAD, 0xFF, 0xED, 
+0x2F, 0x90, 0x90, 0xDE, 0x11, 0x4C, 0xFF, 0xED, 0x2F, 0x90, 0x90, 0xDF, 0x31, 0xD0, 0xFF, 0xED, 
+0x2F, 0x90, 0x90, 0xE0, 0x31, 0x4F, 0xFF, 0xAE, 0x05, 0xED, 0x2F, 0x90, 0x90, 0xE1, 0xF0, 0x22, 
+0xF0, 0x90, 0x00, 0x05, 0x02, 0x26, 0x37, 0x90, 0x02, 0x09, 0xE0, 0xFD, 0x12, 0x26, 0x1E, 0xFE, 
+0xAF, 0x05, 0xED, 0x22, 0xA3, 0xE0, 0xFE, 0x24, 0x28, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 
+0xE0, 0xFF, 0x74, 0x29, 0x2E, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0xFD, 0x74, 0x2C, 
+0x2E, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0xFB, 0xE4, 0xFE, 0xEF, 0x30, 0xE7, 0x04, 
+0x7C, 0x02, 0x80, 0x02, 0xE4, 0xFC, 0xED, 0x30, 0xE6, 0x08, 0xAF, 0x03, 0xD1, 0x9C, 0xAE, 0x07, 
+0x80, 0x02, 0xE4, 0xFE, 0xEC, 0x24, 0x18, 0x2E, 0xFF, 0x22, 0x12, 0x77, 0xB7, 0x90, 0x90, 0xFE, 
+0xE4, 0xD1, 0x49, 0x31, 0xE4, 0x90, 0x91, 0x00, 0xEF, 0xF0, 0x90, 0x90, 0xFE, 0x12, 0x5F, 0xE3, 
+0x51, 0x90, 0x75, 0x43, 0x06, 0x7B, 0x01, 0x7A, 0x8E, 0x79, 0xEA, 0x71, 0x52, 0x2F, 0x24, 0x3E, 
+0xF9, 0xE4, 0x34, 0xFC, 0x51, 0x90, 0x75, 0x43, 0x04, 0x7B, 0x01, 0x7A, 0x8E, 0x79, 0xF0, 0x71, 
+0x52, 0x2F, 0x24, 0x42, 0xF9, 0xE4, 0x34, 0xFC, 0x51, 0x90, 0x75, 0x43, 0x06, 0x7B, 0x01, 0x7A, 
+0x8E, 0x79, 0xF4, 0x71, 0x52, 0x2F, 0x24, 0x48, 0xF9, 0xE4, 0x34, 0xFC, 0x51, 0x90, 0x75, 0x43, 
+0x04, 0x7B, 0x01, 0x7A, 0x8E, 0x79, 0xFA, 0x02, 0x34, 0x2C, 0x24, 0x00, 0xF9, 0xE4, 0x34, 0xFC, 
+0x75, 0x40, 0x01, 0xF5, 0x41, 0x89, 0x42, 0x22, 0x90, 0x90, 0xDF, 0x71, 0x47, 0xE0, 0xFE, 0x24, 
+0x28, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0xFF, 0x74, 0x29, 0x2E, 0x12, 0x75, 0xD6, 
+0xE0, 0xFD, 0x90, 0x90, 0xFE, 0xE0, 0x24, 0x2C, 0x51, 0x01, 0x90, 0x90, 0xFE, 0xE0, 0x2F, 0x24, 
+0x30, 0xA3, 0xF0, 0xE0, 0xFD, 0x24, 0x04, 0xB1, 0x8E, 0xE0, 0xFE, 0x74, 0x05, 0x2D, 0xB1, 0x96, 
+0x71, 0x67, 0x90, 0x90, 0x86, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0x90, 0xFF, 0xE0, 0x24, 0x0C, 0xF9, 
+0xE4, 0x34, 0xFC, 0x51, 0x90, 0x75, 0x43, 0x04, 0x7B, 0x01, 0x7A, 0x90, 0x79, 0x88, 0x12, 0x34, 
+0x2C, 0x90, 0x90, 0xFF, 0xE0, 0x24, 0x14, 0xF0, 0xE0, 0xFD, 0x24, 0x01, 0x71, 0x89, 0xE0, 0xFE, 
+0x74, 0x00, 0x2D, 0x12, 0x55, 0xEF, 0x71, 0x67, 0x90, 0x90, 0x8C, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 
+0x90, 0xE0, 0x71, 0x47, 0x90, 0x90, 0x82, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x4E, 0x60, 0x11, 0x90, 
+0x90, 0xFE, 0xE0, 0x51, 0x8A, 0x8F, 0x43, 0x7B, 0x01, 0x7A, 0x90, 0x79, 0x90, 0x12, 0x34, 0x2C, 
+0x90, 0x90, 0xE1, 0x71, 0x47, 0x51, 0x8A, 0x90, 0x90, 0x84, 0xA3, 0xE0, 0xF5, 0x43, 0x7B, 0x01, 
+0x7A, 0x90, 0x79, 0xB0, 0x02, 0x34, 0x2C, 0xE0, 0xFF, 0x12, 0x77, 0xB7, 0x90, 0x90, 0xFE, 0xEF, 
+0xF0, 0x22, 0x12, 0x34, 0x2C, 0x90, 0x90, 0xFE, 0xA3, 0xE0, 0xFF, 0xA3, 0xE0, 0x22, 0xF0, 0x90, 
+0x01, 0x17, 0xE0, 0xFE, 0x90, 0x01, 0x16, 0xE0, 0x7C, 0x00, 0x24, 0x00, 0xFF, 0xEC, 0x3E, 0x22, 
+0xFD, 0xE4, 0x33, 0x90, 0x92, 0x20, 0xF0, 0xA3, 0xED, 0xF0, 0xFE, 0x24, 0x00, 0xF5, 0x82, 0xE4, 
+0x34, 0xFC, 0xF5, 0x83, 0xE4, 0xF0, 0x74, 0x01, 0x2E, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 
+0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x92, 0x16, 0xEC, 0xF0, 0xA3, 0xED, 0xF0, 
+0xAA, 0x07, 0x90, 0x92, 0x1C, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0x00, 0x90, 0xFD, 0x10, 0xEB, 
+0xF0, 0xEA, 0x24, 0xEF, 0x60, 0x30, 0x24, 0xD7, 0x70, 0x02, 0x81, 0x64, 0x24, 0x3A, 0x60, 0x02, 
+0x81, 0x8B, 0x91, 0xA3, 0x24, 0x0A, 0x71, 0x70, 0xE4, 0xF0, 0xFE, 0x74, 0x00, 0x2F, 0x91, 0xB3, 
+0x7D, 0x14, 0x7C, 0x00, 0x91, 0xAA, 0x7B, 0x00, 0x7A, 0x00, 0x79, 0x00, 0x91, 0xC4, 0x7D, 0x14, 
+0x7C, 0x00, 0xE4, 0xFF, 0x80, 0x79, 0x90, 0x92, 0x16, 0xE4, 0x75, 0xF0, 0x14, 0x12, 0x46, 0xD6, 
+0x90, 0x92, 0x16, 0xA3, 0xE0, 0xFB, 0xFF, 0x24, 0x06, 0xFC, 0xE4, 0x33, 0x90, 0x92, 0x20, 0xF0, 
+0xA3, 0xCC, 0xF0, 0x90, 0x92, 0x20, 0xA3, 0xE0, 0x71, 0x7A, 0xE4, 0xF0, 0x74, 0x04, 0x2F, 0xB1, 
+0x8E, 0xE0, 0xFE, 0xAD, 0x03, 0x74, 0x05, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xB1, 0xBA, 0x90, 
+0x92, 0x1A, 0xF0, 0xA3, 0xEF, 0xF0, 0xED, 0x7E, 0x00, 0x24, 0x00, 0x91, 0xB3, 0x91, 0xBB, 0x91, 
+0xAA, 0x90, 0x92, 0x16, 0x74, 0xFF, 0x75, 0xF0, 0xEC, 0x12, 0x46, 0xD6, 0x91, 0xA3, 0x7E, 0x00, 
+0x24, 0x0C, 0xF9, 0xEE, 0x34, 0xFC, 0xFA, 0x7B, 0x01, 0xC0, 0x02, 0xC0, 0x01, 0x74, 0x10, 0x2F, 
+0xF9, 0xEE, 0x34, 0xFC, 0xFA, 0x91, 0xC4, 0x91, 0xBB, 0xD0, 0x01, 0xD0, 0x02, 0x7F, 0x11, 0x12, 
+0x1F, 0x66, 0x80, 0x1F, 0x91, 0xA3, 0x24, 0x2A, 0x71, 0x70, 0xE4, 0xF0, 0xF1, 0xB9, 0x7D, 0x48, 
+0x7C, 0x00, 0x12, 0x28, 0xE6, 0x91, 0xD6, 0xE4, 0xFD, 0xFC, 0x91, 0xD6, 0x91, 0xAD, 0x90, 0x92, 
+0x1C, 0xF1, 0x89, 0x90, 0x92, 0x18, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0x92, 0x18, 0xF1, 0x9F, 
+0x90, 0x92, 0x20, 0xA3, 0xE0, 0xFE, 0x12, 0x55, 0xED, 0xEF, 0x71, 0x85, 0xED, 0xF0, 0xD0, 0xD0, 
+0x92, 0xAF, 0x22, 0x90, 0x92, 0x16, 0xA3, 0xE0, 0xFF, 0x22, 0x12, 0x28, 0xE6, 0x90, 0x92, 0x1C, 
+0x02, 0x27, 0x48, 0xF9, 0xEE, 0x34, 0xFC, 0xFA, 0x7B, 0x01, 0x22, 0x90, 0x92, 0x1A, 0xE0, 0xFC, 
+0xA3, 0xE0, 0xFD, 0x22, 0x90, 0xAE, 0x61, 0x12, 0x47, 0x5F, 0x90, 0x92, 0x1C, 0x12, 0x47, 0x32, 
+0x90, 0xAE, 0x64, 0x02, 0x27, 0x48, 0x90, 0x92, 0x1C, 0x12, 0x27, 0x48, 0x90, 0x92, 0x1C, 0x12, 
+0x47, 0x32, 0x78, 0x10, 0x12, 0x27, 0x22, 0x90, 0x92, 0x1C, 0x12, 0x47, 0x3E, 0x02, 0x46, 0xEC, 
+0xE4, 0xFD, 0xFC, 0x90, 0x90, 0xDE, 0xE0, 0xFF, 0x12, 0x77, 0x80, 0xAB, 0x05, 0x74, 0x01, 0x2B, 
+0x71, 0x89, 0xE0, 0xFE, 0x74, 0x00, 0x2B, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xB1, 0xBA, 0x90, 0x90, 
+0x7C, 0xF0, 0xA3, 0xEF, 0xF0, 0x74, 0x03, 0x2B, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 
+0xFE, 0x74, 0x02, 0x2B, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xB1, 0x87, 0xEA, 0x3E, 0x90, 0x90, 0x7E, 
+0xF0, 0xA3, 0xEF, 0xF0, 0x74, 0x05, 0x2B, 0xB1, 0x96, 0xE0, 0xFE, 0x74, 0x04, 0x2B, 0xB1, 0x8E, 
+0xE0, 0x24, 0x00, 0xFF, 0xEA, 0x3E, 0x90, 0x90, 0x80, 0xF0, 0xA3, 0xEF, 0xF0, 0x74, 0x07, 0x2B, 
+0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0xFE, 0x74, 0x06, 0x2B, 0xF5, 0x82, 0xE4, 0x34, 
+0xFC, 0xB1, 0x87, 0xEA, 0x3E, 0x90, 0x90, 0x82, 0xF0, 0xA3, 0xEF, 0xF0, 0x74, 0x09, 0x2B, 0x12, 
+0x75, 0xED, 0xFE, 0x74, 0x08, 0x2B, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xB1, 0x87, 0xEC, 0x3E, 0x90, 
+0x90, 0x84, 0xF0, 0xA3, 0xEF, 0xF0, 0x22, 0xF5, 0x83, 0xE0, 0x24, 0x00, 0xFF, 0x22, 0xF5, 0x82, 
+0xE4, 0x34, 0xFC, 0xF5, 0x83, 0x22, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0x22, 0xEF, 0x60, 
+0x04, 0x91, 0xF0, 0x51, 0x98, 0x22, 0x74, 0x01, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 0xFB, 0xF5, 0x83, 
+0xE0, 0xFE, 0x74, 0x00, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 0xFB, 0xF5, 0x83, 0xE0, 0x7A, 0x00, 0x24, 
+0x00, 0xFF, 0xEA, 0x3E, 0x22, 0xF1, 0xB0, 0x71, 0x67, 0x90, 0x90, 0xFE, 0xF0, 0xA3, 0xEF, 0xF0, 
+0x90, 0x02, 0x87, 0xE0, 0xF9, 0x90, 0x8E, 0xC5, 0xE0, 0x30, 0xE0, 0x6C, 0xEC, 0xC3, 0x99, 0x50, 
+0x67, 0x90, 0x90, 0xFE, 0xE0, 0xFA, 0xA3, 0xE0, 0xFB, 0xF1, 0x8F, 0xAD, 0x07, 0xB1, 0xA6, 0x54, 
+0x3F, 0x90, 0x91, 0x00, 0x12, 0x8D, 0x65, 0xE0, 0x54, 0x03, 0xFB, 0xEF, 0x24, 0x18, 0xFF, 0xE4, 
+0x33, 0xCF, 0x2B, 0xCF, 0x3A, 0x90, 0x91, 0x00, 0x8F, 0xF0, 0x12, 0x46, 0xD6, 0x90, 0x91, 0x00, 
+0xD1, 0x51, 0x90, 0x91, 0x00, 0xEE, 0xD1, 0x49, 0xEE, 0x8F, 0xF0, 0xF1, 0x97, 0xFE, 0xA3, 0xE0, 
+0xFF, 0xD3, 0x90, 0x90, 0xFF, 0xE0, 0x9F, 0x90, 0x90, 0xFE, 0xE0, 0x9E, 0x40, 0x11, 0x90, 0x8D, 
+0xFA, 0xF1, 0xCF, 0x90, 0x90, 0xFF, 0xE0, 0x9F, 0xF0, 0x90, 0x90, 0xFE, 0xE0, 0x9E, 0xF0, 0x12, 
+0x62, 0xED, 0x12, 0x97, 0x50, 0x0C, 0x80, 0x94, 0x22, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0x90, 0xFE, 
+0x22, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x7D, 0x07, 0xEF, 0x5D, 0xC3, 0x60, 0x0A, 0xD1, 0x6B, 0x24, 
+0x08, 0xFF, 0xE4, 0x3E, 0xFE, 0x80, 0x03, 0xD1, 0x6B, 0xFF, 0x22, 0x74, 0xFF, 0x9D, 0xFD, 0x74, 
+0xFF, 0x94, 0x00, 0x5E, 0xFE, 0xED, 0x5F, 0x22, 0xAD, 0x07, 0x90, 0x90, 0x86, 0x12, 0x59, 0x26, 
+0x90, 0x90, 0x86, 0xE0, 0xFF, 0xAE, 0x05, 0x74, 0x04, 0x2E, 0xB1, 0x8E, 0xEF, 0xF0, 0x90, 0x90, 
+0x86, 0xA3, 0xE0, 0xFF, 0x74, 0x05, 0x2E, 0xB1, 0x96, 0xEF, 0xF0, 0x22, 0xD3, 0x10, 0xAF, 0x01, 
+0xC3, 0xC0, 0xD0, 0xEF, 0x20, 0xE0, 0x05, 0x90, 0x90, 0xD2, 0x80, 0x03, 0x90, 0x90, 0xD3, 0xE0, 
+0x90, 0x8F, 0x9F, 0xF0, 0x90, 0x8F, 0x9F, 0xE0, 0x14, 0x60, 0x13, 0x14, 0x60, 0x14, 0x24, 0xFE, 
+0x60, 0x10, 0x14, 0x60, 0x09, 0x14, 0x60, 0x06, 0x24, 0x06, 0xE4, 0xFE, 0x80, 0x06, 0x7E, 0x04, 
+0x80, 0x02, 0x7E, 0x08, 0xAF, 0x06, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x12, 0x97, 0x5E, 0xAD, 0x07, 
+0x90, 0x01, 0xC4, 0x74, 0xDB, 0xF0, 0x74, 0x86, 0xA3, 0xF0, 0xED, 0x64, 0x01, 0x60, 0x1E, 0x12, 
+0x5F, 0xDA, 0xED, 0xB4, 0x02, 0x08, 0x90, 0x01, 0xC7, 0x74, 0x40, 0xF0, 0x80, 0x0A, 0xED, 0xB4, 
+0x04, 0x06, 0x90, 0x01, 0xC7, 0x74, 0x41, 0xF0, 0x7F, 0x01, 0x02, 0x63, 0x09, 0xB1, 0xC5, 0x90, 
+0x02, 0x87, 0xE0, 0x70, 0xF8, 0x90, 0x06, 0x90, 0xE0, 0x44, 0x02, 0xF0, 0x74, 0xDB, 0x04, 0x90, 
+0x01, 0xC4, 0xF0, 0x74, 0x86, 0xA3, 0xF0, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 
+0x92, 0xA3, 0x12, 0x47, 0x5F, 0x7F, 0x96, 0x7E, 0x02, 0x12, 0x8A, 0x8E, 0xEF, 0x60, 0x45, 0x71, 
+0x5F, 0xFE, 0xEF, 0x24, 0x01, 0xFF, 0xE4, 0x3E, 0xFE, 0x90, 0x92, 0xA6, 0xEF, 0xF0, 0xEE, 0xFF, 
+0x90, 0xFD, 0x11, 0xF0, 0x90, 0x92, 0xA6, 0xE0, 0xFD, 0x90, 0x02, 0x94, 0xF0, 0xA3, 0xEF, 0xF0, 
+0x90, 0x92, 0xA3, 0xF1, 0xA7, 0x24, 0x02, 0xFF, 0xE4, 0x33, 0xFE, 0x12, 0x8D, 0x14, 0x90, 0x92, 
+0xA6, 0xE0, 0x24, 0x18, 0xFF, 0x90, 0x92, 0xA3, 0x12, 0x47, 0x56, 0x12, 0x8D, 0x87, 0x90, 0x02, 
+0x96, 0x74, 0x01, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x12, 0x47, 0x32, 0x02, 0x27, 0x15, 0xEA, 
+0x90, 0xFD, 0x11, 0xF0, 0xAF, 0x03, 0x22, 0x12, 0x46, 0xD6, 0x90, 0x8D, 0xF9, 0xE0, 0x22, 0xE0, 
+0xFC, 0xA3, 0xE0, 0xFD, 0xEC, 0xFF, 0x22, 0x12, 0x47, 0x56, 0x90, 0x00, 0x0E, 0x02, 0x26, 0x37, 
+0x90, 0x01, 0x1F, 0xE0, 0xFE, 0x90, 0x01, 0x1E, 0x22, 0x74, 0x00, 0x2F, 0xF9, 0xE4, 0x34, 0xFC, 
+0xFA, 0x7B, 0x01, 0x22, 0xEF, 0x60, 0x07, 0x90, 0x90, 0xD5, 0xE0, 0xFF, 0x51, 0x2A, 0x22, 0xE0, 
+0x24, 0x01, 0xFF, 0x90, 0x8D, 0xF9, 0xE0, 0x34, 0x00, 0xFE, 0xC3, 0x22, 0x8B, 0x0D, 0x8A, 0x0E, 
+0x89, 0x0F, 0x12, 0x4E, 0xCE, 0xFF, 0xF5, 0x11, 0x12, 0x26, 0x1E, 0xFE, 0xC3, 0x13, 0x30, 0xE0, 
+0x07, 0x12, 0x4F, 0xF1, 0xF5, 0x12, 0x80, 0x02, 0x8F, 0x12, 0x85, 0x11, 0x10, 0xE5, 0x10, 0xD3, 
+0x95, 0x12, 0x50, 0x24, 0xAB, 0x0D, 0xAA, 0x0E, 0xA9, 0x0F, 0x12, 0x26, 0x1E, 0x54, 0x01, 0xFD, 
+0xAF, 0x10, 0x11, 0x56, 0xAF, 0x10, 0x12, 0x6F, 0x2B, 0xEF, 0xAF, 0x10, 0x70, 0x04, 0x11, 0x39, 
+0x80, 0x02, 0x11, 0x40, 0x05, 0x10, 0x80, 0xD5, 0xE5, 0x11, 0x70, 0x0C, 0xFF, 0x12, 0x6F, 0x2B, 
+0xEF, 0x70, 0x05, 0x31, 0x0F, 0x54, 0x7F, 0xF0, 0x22, 0x11, 0x4A, 0xE0, 0x44, 0x04, 0xF0, 0x22, 
+0x11, 0x4A, 0xE0, 0x54, 0xFB, 0x11, 0xF7, 0x02, 0x27, 0x48, 0x8F, 0x13, 0x75, 0xF0, 0x10, 0xEF, 
+0x90, 0x81, 0x05, 0x02, 0x47, 0x4A, 0x31, 0x03, 0xED, 0x70, 0x12, 0x11, 0x91, 0xC0, 0x83, 0xC0, 
+0x82, 0x11, 0x89, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0xF4, 0x5E, 0x80, 0x0F, 0x11, 0x91, 0xC0, 
+0x83, 0xC0, 0x82, 0x11, 0x89, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0x4E, 0xD0, 0x82, 0xD0, 0x83, 
+0xF0, 0x11, 0x9C, 0x90, 0x8E, 0x0C, 0xEF, 0xF0, 0x22, 0xE0, 0xFE, 0x74, 0x01, 0xA8, 0x07, 0x08, 
+0x22, 0x74, 0xFC, 0x2E, 0xF5, 0x82, 0xE4, 0x34, 0x8D, 0xF5, 0x83, 0x22, 0xD3, 0x10, 0xAF, 0x01, 
+0xC3, 0xC0, 0xD0, 0x7D, 0x10, 0xED, 0x14, 0xF9, 0x24, 0xFC, 0x11, 0x94, 0xE0, 0x60, 0x3A, 0x7C, 
+0x08, 0xEC, 0x14, 0x90, 0x92, 0xD0, 0xF0, 0x74, 0xFC, 0x29, 0x11, 0x94, 0xE0, 0xFB, 0x7A, 0x00, 
+0x90, 0x92, 0xD0, 0x12, 0x7D, 0xD9, 0x80, 0x05, 0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 0xF9, 0xFF, 
+0xEE, 0x5A, 0xFE, 0xEF, 0x5B, 0x4E, 0x60, 0x0F, 0xE9, 0x75, 0xF0, 0x08, 0xA4, 0xFF, 0x90, 0x92, 
+0xD0, 0xE0, 0x2F, 0x04, 0xFF, 0x80, 0x06, 0xDC, 0xC8, 0xDD, 0xBA, 0x7F, 0x00, 0xD0, 0xD0, 0x92, 
+0xAF, 0x22, 0xE4, 0xFD, 0xFF, 0x01, 0x56, 0xF0, 0x7F, 0xB0, 0x7E, 0x0C, 0x12, 0x36, 0xCE, 0x90, 
+0x8E, 0x20, 0x22, 0xEF, 0x13, 0x13, 0x13, 0x54, 0x1F, 0xFE, 0xEF, 0x54, 0x07, 0xFF, 0x22, 0x12, 
+0x56, 0xCF, 0x12, 0x57, 0xEC, 0x90, 0x8E, 0x0E, 0xE0, 0x54, 0xF7, 0xF0, 0x54, 0xBF, 0xF0, 0x22, 
+0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x8B, 0x0D, 0x8A, 0x0E, 0x89, 0x0F, 0x12, 0x26, 0x1E, 
+0xFF, 0x90, 0x8E, 0x0D, 0xF0, 0xBF, 0x01, 0x0D, 0x12, 0x4E, 0xCE, 0x64, 0x01, 0x60, 0x19, 0x7D, 
+0x13, 0x7F, 0x6F, 0x80, 0x10, 0xAB, 0x0D, 0xAA, 0x0E, 0xA9, 0x0F, 0x12, 0x4E, 0xCE, 0x64, 0x01, 
+0x60, 0x06, 0xE4, 0xFD, 0xFF, 0x12, 0x53, 0x74, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x12, 0x26, 0x1E, 
+0xFF, 0x90, 0x8D, 0xFB, 0xF0, 0xBF, 0x01, 0x08, 0x12, 0x7C, 0x83, 0xE4, 0x90, 0x8D, 0xFB, 0xF0, 
+0x22, 0x12, 0x26, 0x1E, 0x54, 0x01, 0xFF, 0x90, 0x90, 0xF5, 0xE0, 0x54, 0xFE, 0x4F, 0xF0, 0x22, 
+0x12, 0x26, 0x1E, 0x90, 0x8E, 0x1D, 0xF0, 0x22, 0x12, 0x26, 0x1E, 0x90, 0x8E, 0xC0, 0xF0, 0x22, 
+0x31, 0xE4, 0x90, 0x8E, 0xC1, 0x31, 0xB7, 0x54, 0x02, 0xFF, 0xEE, 0x54, 0xFD, 0x4F, 0x12, 0x4E, 
+0xCD, 0x90, 0x8E, 0xC2, 0x12, 0x4F, 0xF0, 0x90, 0x8E, 0xC3, 0xF0, 0x51, 0x24, 0x90, 0x8E, 0xC1, 
+0xE0, 0x54, 0x01, 0xFF, 0x02, 0x72, 0x7A, 0xE0, 0x54, 0xFE, 0x4E, 0xFE, 0xF0, 0xEF, 0x22, 0x31, 
+0xE4, 0x90, 0x90, 0xE4, 0x31, 0xB7, 0x54, 0x04, 0xFF, 0xEE, 0x54, 0xFB, 0x4F, 0xF0, 0x12, 0x26, 
+0x1E, 0xC3, 0x13, 0x30, 0xE0, 0x07, 0x12, 0x4E, 0xCE, 0x90, 0x90, 0xE5, 0xF0, 0x22, 0x90, 0x90, 
+0xFE, 0x12, 0x47, 0x56, 0x12, 0x26, 0x1E, 0xFF, 0x54, 0x01, 0xFE, 0x22, 0x51, 0x1E, 0x51, 0x40, 
+0x31, 0xDE, 0x51, 0x39, 0x4E, 0xF0, 0xEF, 0xC3, 0x13, 0x30, 0xE0, 0x21, 0x12, 0x4E, 0xCE, 0x90, 
+0x90, 0xE9, 0x12, 0x4F, 0xF0, 0x90, 0x90, 0xEA, 0xF0, 0x12, 0x26, 0x1E, 0x54, 0x04, 0xFF, 0x90, 
+0x90, 0xE8, 0xE0, 0x54, 0xFB, 0x4F, 0x12, 0x4F, 0xAD, 0x90, 0x90, 0xEB, 0xF0, 0x22, 0x90, 0x90, 
+0xFE, 0x02, 0x47, 0x5F, 0x90, 0x8E, 0xC2, 0xE0, 0x14, 0x90, 0x8E, 0xC4, 0xF0, 0x22, 0x90, 0x01, 
+0xC7, 0x74, 0x10, 0xF0, 0x7F, 0x01, 0x12, 0x63, 0x09, 0x90, 0x90, 0xE8, 0xE0, 0x54, 0xFE, 0x22, 
+0x7E, 0x00, 0x7F, 0x08, 0x7D, 0x00, 0x7B, 0x01, 0x7A, 0x90, 0x79, 0xE8, 0x12, 0x49, 0x38, 0x90, 
+0x90, 0xE9, 0x74, 0x08, 0xF0, 0xA3, 0x74, 0x03, 0xF0, 0x22, 0xE4, 0xFD, 0xFC, 0xEF, 0x60, 0x1F, 
+0x90, 0x90, 0xD8, 0xE0, 0xFF, 0x12, 0x77, 0x80, 0x12, 0x87, 0xB9, 0x51, 0x1E, 0x90, 0x90, 0xFE, 
+0x12, 0x5B, 0xDD, 0x75, 0x43, 0x42, 0x7B, 0x01, 0x7A, 0x8F, 0x79, 0xA0, 0x12, 0x34, 0x2C, 0x22, 
+0xE4, 0x90, 0x8D, 0xF7, 0xF0, 0xA3, 0xF0, 0x90, 0x8D, 0x5F, 0xF0, 0xA3, 0xF0, 0x22, 0xD3, 0x10, 
+0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x92, 0x9B, 0x51, 0xE4, 0xA3, 0xF0, 0xA3, 0xF0, 0x90, 0x92, 
+0x9B, 0x51, 0xD8, 0xE0, 0x60, 0x24, 0xC3, 0x90, 0x92, 0x9E, 0xE0, 0x94, 0xE8, 0x90, 0x92, 0x9D, 
+0xE0, 0x94, 0x03, 0x40, 0x0B, 0x90, 0x01, 0xC0, 0xE0, 0x44, 0x80, 0xF0, 0x7F, 0x00, 0x80, 0x0C, 
+0x90, 0x92, 0x9D, 0x12, 0x59, 0x26, 0x51, 0xD1, 0x80, 0xD4, 0x7F, 0x01, 0xD0, 0xD0, 0x92, 0xAF, 
+0x22, 0x7F, 0x0A, 0x7E, 0x00, 0x02, 0x3A, 0xF7, 0xE0, 0xFE, 0xA3, 0xE0, 0xF5, 0x82, 0x8E, 0x83, 
+0x22, 0x90, 0x91, 0x0E, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0xE4, 0x22, 0x90, 0x91, 0x1E, 0x51, 0xE4, 
+0x90, 0x91, 0x26, 0xF0, 0x90, 0x91, 0x26, 0xE0, 0xFD, 0xC3, 0x94, 0x06, 0x50, 0x22, 0x90, 0x91, 
+0x1F, 0xE0, 0x24, 0x04, 0x71, 0xE1, 0x12, 0x5E, 0x54, 0x90, 0x91, 0x26, 0xE0, 0x24, 0x20, 0xF5, 
+0x82, 0xE4, 0x34, 0x91, 0xF5, 0x83, 0xEF, 0xF0, 0x90, 0x91, 0x26, 0xE0, 0x04, 0xF0, 0x80, 0xD4, 
+0x78, 0xCF, 0x7C, 0x8E, 0x7D, 0x01, 0x7B, 0x01, 0x7A, 0x91, 0x79, 0x20, 0x71, 0xEA, 0x7F, 0x00, 
+0x70, 0x02, 0x7F, 0x01, 0x22, 0x71, 0xF3, 0x78, 0x11, 0x7C, 0x91, 0x7D, 0x01, 0x7B, 0xFF, 0x7A, 
+0x40, 0x79, 0x64, 0x12, 0x5F, 0xD3, 0x78, 0x18, 0x7C, 0x91, 0x7D, 0x01, 0x7B, 0xFF, 0x7A, 0x40, 
+0x79, 0x6A, 0x12, 0x5F, 0xCC, 0x12, 0x5F, 0xB0, 0x51, 0xEB, 0xEF, 0x70, 0x02, 0x61, 0xE0, 0x12, 
+0x5E, 0xF8, 0xFE, 0x90, 0x91, 0x1C, 0xF0, 0xA3, 0xEF, 0xF0, 0x24, 0x06, 0xFF, 0xE4, 0x3E, 0x12, 
+0x5F, 0x2C, 0xEF, 0x64, 0x08, 0x70, 0x69, 0x90, 0x91, 0x1D, 0xE0, 0x24, 0x07, 0xFF, 0x90, 0x91, 
+0x1C, 0x12, 0x5F, 0x29, 0xEF, 0x70, 0x59, 0x90, 0x91, 0x17, 0xF0, 0x90, 0x91, 0x17, 0xE0, 0xFF, 
+0xC3, 0x94, 0x04, 0x50, 0x24, 0x90, 0x91, 0x1D, 0xE0, 0x24, 0x18, 0xFD, 0x90, 0x91, 0x1C, 0x12, 
+0x5E, 0x46, 0x90, 0x91, 0x17, 0xE0, 0x24, 0x18, 0xF5, 0x82, 0xE4, 0x34, 0x91, 0xF5, 0x83, 0xEF, 
+0xF0, 0x90, 0x91, 0x17, 0xE0, 0x04, 0xF0, 0x80, 0xD2, 0x78, 0x18, 0x7C, 0x91, 0x91, 0x95, 0x70, 
+0x1F, 0x90, 0x91, 0x1D, 0xE0, 0x24, 0x08, 0xFF, 0x90, 0x91, 0x1C, 0xE0, 0x34, 0x00, 0xFE, 0x12, 
+0x5E, 0x81, 0xEF, 0x64, 0x01, 0x60, 0x09, 0x90, 0x01, 0xC7, 0x74, 0x22, 0xF0, 0x12, 0x5F, 0xDA, 
+0x22, 0xFF, 0x90, 0x91, 0x1E, 0xE0, 0x34, 0x00, 0xFE, 0x22, 0x7E, 0x00, 0x7F, 0x06, 0x12, 0x49, 
+0x14, 0xEF, 0x22, 0x90, 0x91, 0x0E, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0xA3, 0xED, 0xF0, 0x22, 0x71, 
+0xF3, 0xE4, 0xA3, 0xF0, 0x91, 0x80, 0x50, 0x1A, 0x12, 0x5F, 0xB0, 0x91, 0x89, 0x24, 0xB0, 0xF5, 
+0x82, 0xE4, 0x34, 0x90, 0xF5, 0x83, 0xE0, 0xB5, 0x07, 0x1D, 0x90, 0x91, 0x11, 0xE0, 0x04, 0xF0, 
+0x80, 0xE2, 0x90, 0x06, 0x32, 0xE0, 0x44, 0x80, 0xF0, 0x90, 0x01, 0xC7, 0x74, 0x30, 0xF0, 0x7F, 
+0x01, 0x12, 0x63, 0x09, 0x7F, 0x01, 0x22, 0x7F, 0x00, 0x22, 0x71, 0xF3, 0x90, 0x90, 0x82, 0xE0, 
+0x70, 0x02, 0xA3, 0xE0, 0x60, 0x26, 0xE4, 0x90, 0x91, 0x11, 0xF0, 0x91, 0x80, 0x50, 0x20, 0x12, 
+0x5F, 0xB0, 0x91, 0x89, 0x24, 0x90, 0xF5, 0x82, 0xE4, 0x34, 0x90, 0xF5, 0x83, 0xE0, 0x6F, 0x60, 
+0x03, 0x7F, 0x00, 0x22, 0x90, 0x91, 0x11, 0xE0, 0x04, 0xF0, 0x80, 0xDF, 0x7F, 0x00, 0x22, 0x90, 
+0x06, 0x32, 0xE0, 0x44, 0x40, 0xF0, 0xE4, 0x90, 0x90, 0x8E, 0xF0, 0xA3, 0xF0, 0x7F, 0x01, 0x22, 
+0x90, 0x91, 0x11, 0xE0, 0xFD, 0xC3, 0x94, 0x02, 0x22, 0xED, 0x24, 0x1C, 0xFD, 0x12, 0x5E, 0x54, 
+0x90, 0x91, 0x11, 0xE0, 0x22, 0x7D, 0x01, 0x7B, 0x01, 0x7A, 0x8E, 0x79, 0xF0, 0x7E, 0x00, 0x7F, 
+0x04, 0x12, 0x49, 0x14, 0xEF, 0x22, 0xE4, 0x90, 0x90, 0xFA, 0xF0, 0xA3, 0xF0, 0x90, 0x02, 0x86, 
+0xE0, 0x20, 0xE1, 0x23, 0xC3, 0x90, 0x90, 0xFB, 0xE0, 0x94, 0xD0, 0x90, 0x90, 0xFA, 0xE0, 0x94, 
+0x07, 0x40, 0x0A, 0x90, 0x01, 0xC1, 0xE0, 0x44, 0x04, 0xF0, 0x7F, 0x00, 0x22, 0x90, 0x90, 0xFA, 
+0x12, 0x59, 0x26, 0x51, 0xD1, 0x80, 0xD6, 0x7F, 0x01, 0x22, 0x51, 0xE1, 0xA3, 0xF0, 0x90, 0x91, 
+0x10, 0xE0, 0xFD, 0xC3, 0x94, 0x04, 0x50, 0x29, 0x90, 0x91, 0x0F, 0xE0, 0x24, 0x10, 0x12, 0x5F, 
+0x02, 0xFE, 0x12, 0x5E, 0x54, 0x90, 0x91, 0x10, 0xE0, 0x24, 0x88, 0xF5, 0x82, 0xE4, 0x34, 0x90, 
+0xF5, 0x83, 0xE0, 0x6F, 0x60, 0x03, 0x7F, 0x00, 0x22, 0x90, 0x91, 0x10, 0xE0, 0x04, 0xF0, 0x80, 
+0xCD, 0x7F, 0x01, 0x22, 0xE4, 0xFC, 0xED, 0x2C, 0x24, 0x00, 0xB1, 0x5D, 0xE4, 0xF0, 0x0C, 0xEC, 
+0xB4, 0x18, 0xF3, 0x74, 0x00, 0x2D, 0xB1, 0x5D, 0xEF, 0xF0, 0xEE, 0x54, 0x3F, 0xFF, 0x74, 0x01, 
+0x2D, 0xF5, 0x82, 0xE4, 0x34, 0xFB, 0xF5, 0x83, 0xEF, 0xF0, 0x74, 0x02, 0x2D, 0xF5, 0x82, 0xE4, 
+0x34, 0xFB, 0xF5, 0x83, 0xE0, 0x54, 0xF0, 0xF0, 0xB1, 0x7C, 0xE0, 0x44, 0x80, 0xF0, 0x74, 0x0B, 
+0x2D, 0xF5, 0x82, 0xE4, 0x34, 0xFB, 0xF5, 0x83, 0xE0, 0x44, 0x10, 0xF0, 0x22, 0xF5, 0x82, 0xE4, 
+0x34, 0xFB, 0xF5, 0x83, 0x22, 0xF0, 0xA3, 0xEF, 0xF0, 0x74, 0x02, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 
+0xFB, 0xF5, 0x83, 0xE0, 0x54, 0x0F, 0x33, 0x33, 0x33, 0x54, 0xF8, 0xFF, 0x74, 0x03, 0x2D, 0xF5, 
+0x82, 0xE4, 0x34, 0xFB, 0xF5, 0x83, 0x22, 0x90, 0x92, 0x9F, 0xEF, 0xF0, 0xA3, 0x12, 0x47, 0x5F, 
+0x90, 0x92, 0xC0, 0xE0, 0xFE, 0x04, 0xF0, 0xB1, 0xEF, 0x74, 0x00, 0x2F, 0xF9, 0xE4, 0x34, 0xFB, 
+0xFA, 0x7B, 0x01, 0xC0, 0x03, 0xC0, 0x02, 0xC0, 0x01, 0x90, 0x92, 0xA0, 0x12, 0x5B, 0xDD, 0x75, 
+0x43, 0x02, 0xD0, 0x01, 0xD0, 0x02, 0xD0, 0x03, 0x12, 0x34, 0x2C, 0x90, 0x92, 0x9F, 0xE0, 0x24, 
+0x02, 0xF9, 0xE4, 0x34, 0xFB, 0xFA, 0x7B, 0x01, 0xC0, 0x03, 0xC0, 0x02, 0xC0, 0x01, 0xA3, 0x12, 
+0x47, 0x56, 0xE9, 0x24, 0x02, 0xF9, 0xE4, 0x3A, 0x8B, 0x40, 0xF5, 0x41, 0x89, 0x42, 0x90, 0x92, 
+0xA0, 0x12, 0x87, 0xA7, 0xF5, 0x43, 0xD0, 0x01, 0xD0, 0x02, 0xD0, 0x03, 0x02, 0x34, 0x2C, 0x90, 
+0x00, 0x01, 0xEE, 0x02, 0x26, 0x76, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0xE4, 0xFF, 0x90, 
+0x8D, 0xF8, 0xE0, 0xFE, 0x90, 0x8D, 0xF7, 0xE0, 0xFD, 0xB5, 0x06, 0x04, 0x7E, 0x01, 0x80, 0x02, 
+0x7E, 0x00, 0xEE, 0x64, 0x01, 0x60, 0x40, 0xED, 0xD1, 0x5C, 0xFA, 0x7B, 0x01, 0x12, 0x87, 0x28, 
+0x7F, 0x01, 0xEF, 0x60, 0x32, 0x90, 0x8D, 0xF7, 0xE0, 0x04, 0xF0, 0xE0, 0xB4, 0x0A, 0x02, 0x80, 
+0x02, 0x7F, 0x00, 0xEF, 0x60, 0x05, 0xE4, 0x90, 0x8D, 0xF7, 0xF0, 0x90, 0x8D, 0xF8, 0xE0, 0xFF, 
+0x90, 0x8D, 0xF7, 0xE0, 0xB5, 0x07, 0x04, 0x7F, 0x01, 0x80, 0x02, 0x7F, 0x00, 0xEF, 0x70, 0x07, 
+0x90, 0x8D, 0x01, 0xE0, 0x44, 0x04, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x75, 0xF0, 0x0F, 0xA4, 
+0x24, 0x61, 0xF9, 0x74, 0x8D, 0x35, 0xF0, 0x22, 0xEF, 0x70, 0x04, 0x74, 0xF0, 0x80, 0x16, 0xEF, 
+0xB4, 0x01, 0x04, 0x74, 0xF4, 0x80, 0x0E, 0xEF, 0xB4, 0x02, 0x04, 0x74, 0xF8, 0x80, 0x06, 0xEF, 
+0xB4, 0x03, 0x0C, 0x74, 0xFC, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 0x02, 0xF5, 0x83, 0xEB, 0xF0, 0x22, 
+0x90, 0x92, 0xB3, 0x12, 0x47, 0x5F, 0xE4, 0xFF, 0x90, 0x92, 0xB3, 0x12, 0x5B, 0xD1, 0x12, 0x26, 
+0x37, 0xFE, 0x74, 0xF0, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x02, 0xD1, 0xB0, 0xB4, 0x10, 0xE9, 0x22, 
+0xF5, 0x83, 0xEE, 0xF0, 0x0F, 0xEF, 0x22, 0xE4, 0xFF, 0x74, 0x18, 0xD1, 0xDD, 0xFE, 0x74, 0xD5, 
+0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x8E, 0xF5, 0x83, 0xEE, 0xF0, 0x74, 0x10, 0xD1, 0xDD, 0xFE, 0x74, 
+0xCF, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x8E, 0xD1, 0xB0, 0xB4, 0x06, 0xDD, 0x22, 0x2F, 0xF5, 0x82, 
+0xE4, 0x34, 0x06, 0xF5, 0x83, 0xE0, 0x22, 0xE4, 0xFF, 0x74, 0x96, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 
+0x8F, 0xF5, 0x83, 0xE0, 0xFE, 0x74, 0x84, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x04, 0xD1, 0xB0, 0xB4, 
+0x08, 0xE7, 0x90, 0x8F, 0x9E, 0xE0, 0x90, 0x04, 0x8C, 0xF0, 0x22, 0xF1, 0x30, 0xD1, 0xE7, 0x90, 
+0x01, 0x3F, 0x74, 0x04, 0xF0, 0x90, 0x8D, 0x07, 0xE0, 0xFF, 0xB4, 0x01, 0x07, 0x90, 0xFD, 0x00, 
+0xE0, 0x54, 0xEF, 0xF0, 0xEF, 0xB4, 0x01, 0x07, 0x90, 0xFE, 0x10, 0xE0, 0x54, 0xFB, 0xF0, 0x22, 
+0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0xE4, 0xFD, 0x7F, 0x8F, 0x12, 0x3A, 0x96, 0xD0, 0xD0, 
+0x92, 0xAF, 0x22, 0xE4, 0xF5, 0x55, 0xF5, 0x56, 0xF5, 0x57, 0x75, 0x58, 0x80, 0xAD, 0x55, 0x7F, 
+0x50, 0x12, 0x3A, 0x96, 0xAD, 0x56, 0x7F, 0x51, 0x12, 0x3A, 0x96, 0xAD, 0x57, 0x7F, 0x52, 0x12, 
+0x3A, 0x96, 0xAD, 0x58, 0x7F, 0x53, 0x02, 0x3A, 0x96, 0x75, 0x5D, 0x10, 0xE4, 0xF5, 0x5E, 0x75, 
+0x5F, 0x07, 0x75, 0x60, 0x42, 0x90, 0x01, 0x30, 0xE5, 0x5D, 0xF0, 0xA3, 0xE5, 0x5E, 0xF0, 0xA3, 
+0xE5, 0x5F, 0xF0, 0xA3, 0xE5, 0x60, 0xF0, 0x22, 0x75, 0x65, 0x06, 0x75, 0x66, 0x01, 0x75, 0x67, 
+0x03, 0x75, 0x68, 0x62, 0x90, 0x01, 0x38, 0xE5, 0x65, 0xF0, 0xA3, 0xE5, 0x66, 0xF0, 0xA3, 0xE5, 
+0x67, 0xF0, 0xA3, 0xE5, 0x68, 0xF0, 0x22, 0x90, 0x01, 0x94, 0xE0, 0x44, 0x01, 0xF0, 0x90, 0x01, 
+0xC7, 0xE4, 0xF0, 0x22, 0x90, 0x01, 0x01, 0xE0, 0x44, 0x04, 0xF0, 0x90, 0x01, 0x9C, 0x74, 0x7E, 
+0xF0, 0xA3, 0x74, 0x92, 0xF0, 0xA3, 0x74, 0xA0, 0xF0, 0xA3, 0x74, 0x24, 0xF0, 0x90, 0x01, 0x9B, 
+0x74, 0x49, 0xF0, 0x90, 0x01, 0x9A, 0x74, 0xE0, 0xF0, 0x90, 0x01, 0x99, 0xE4, 0xF0, 0x90, 0x01, 
+0x98, 0x04, 0xF0, 0x22, 0x7D, 0x02, 0x90, 0x01, 0xC4, 0x74, 0xE4, 0xF0, 0x74, 0x8F, 0xA3, 0xF0, 
+0x90, 0x90, 0xE3, 0xE0, 0xFF, 0xED, 0xC3, 0x9F, 0x50, 0x10, 0xED, 0x25, 0xE0, 0x24, 0x81, 0xF8, 
+0xE6, 0x30, 0xE4, 0x03, 0x7F, 0x00, 0x22, 0x0D, 0x80, 0xE6, 0x74, 0xE4, 0x04, 0x90, 0x01, 0xC4, 
+0xF0, 0x74, 0x8F, 0xA3, 0xF0, 0x7F, 0x01, 0x22, 0xE4, 0x90, 0x8D, 0x01, 0x02, 0x4D, 0x10, 0x90, 
+0x01, 0xE4, 0x74, 0x26, 0xF0, 0xA3, 0xE4, 0xF0, 0x22, 0x90, 0x01, 0x34, 0xE0, 0x55, 0x5D, 0xF5, 
+0x61, 0xA3, 0xE0, 0x55, 0x5E, 0xF5, 0x62, 0xA3, 0xE0, 0x55, 0x5F, 0xF5, 0x63, 0xA3, 0xE0, 0x55, 
+0x60, 0xF5, 0x64, 0x90, 0x01, 0x34, 0xE5, 0x61, 0xF0, 0xA3, 0xE5, 0x62, 0xF0, 0xA3, 0xE5, 0x63, 
+0xF0, 0xA3, 0xE5, 0x64, 0xF0, 0x22, 0x90, 0x01, 0x3C, 0xE0, 0x55, 0x65, 0xF5, 0x69, 0xA3, 0xE0, 
+0x55, 0x66, 0xF5, 0x6A, 0xA3, 0xE0, 0x55, 0x67, 0xF5, 0x6B, 0xA3, 0xE0, 0x55, 0x68, 0xF5, 0x6C, 
+0x90, 0x01, 0x3C, 0xE5, 0x69, 0xF0, 0xA3, 0xE5, 0x6A, 0xF0, 0xA3, 0xE5, 0x6B, 0xF0, 0xA3, 0xE5, 
+0x6C, 0xF0, 0x53, 0x91, 0xDF, 0x22, 0x90, 0x01, 0xCF, 0xE0, 0x90, 0x92, 0x11, 0xF0, 0xE0, 0xFF, 
+0x30, 0xE0, 0x07, 0x90, 0x01, 0xCF, 0xE0, 0x54, 0xFE, 0xF0, 0xEF, 0x30, 0xE5, 0x23, 0x90, 0x01, 
+0xCF, 0xE0, 0x54, 0xDF, 0xF0, 0x90, 0x01, 0x34, 0x74, 0x20, 0xF0, 0xE4, 0xF5, 0xA8, 0xF5, 0xE8, 
+0x12, 0x4C, 0xEA, 0x90, 0x00, 0x03, 0xE0, 0x54, 0xFB, 0xFD, 0x7F, 0x03, 0x12, 0x3A, 0x96, 0x80, 
+0xFE, 0x22, 0x90, 0x90, 0xEE, 0xE0, 0x04, 0xF0, 0x90, 0x8E, 0x15, 0xE0, 0x64, 0x02, 0x60, 0x03, 
+0x12, 0x70, 0xB2, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x04, 0x1D, 0xE0, 0x60, 
+0x1A, 0x90, 0x05, 0x22, 0xE0, 0x54, 0x90, 0x60, 0x07, 0x90, 0x01, 0xC0, 0xE0, 0x44, 0x08, 0xF0, 
+0x90, 0x01, 0xC6, 0xE0, 0x30, 0xE1, 0xE4, 0x7F, 0x00, 0x80, 0x02, 0x7F, 0x01, 0xD0, 0xD0, 0x92, 
+0xAF, 0x22, 0xC3, 0xEE, 0x94, 0x01, 0x40, 0x0A, 0x0D, 0xED, 0x13, 0x90, 0xFD, 0x10, 0xF0, 0xE4, 
+0x2F, 0xFF, 0x22, 0xFB, 0x7D, 0x08, 0x7F, 0x01, 0x90, 0x92, 0xC3, 0xEB, 0xF0, 0xEF, 0x70, 0x06, 
+0xA3, 0x74, 0x03, 0xF0, 0x80, 0x0B, 0xEF, 0x64, 0x01, 0x70, 0x28, 0x90, 0x92, 0xC4, 0x74, 0x42, 
+0xF0, 0x7F, 0xE2, 0x12, 0x3A, 0x96, 0x90, 0x92, 0xC3, 0xE0, 0xFD, 0x7F, 0xE0, 0x12, 0x3A, 0x96, 
+0x90, 0x92, 0xC4, 0xE0, 0x31, 0x5E, 0x90, 0x92, 0xC4, 0xE0, 0x54, 0xFD, 0x31, 0x5E, 0x31, 0x5D, 
+0x7F, 0x01, 0x22, 0x90, 0x01, 0xC2, 0xE0, 0x44, 0x01, 0xF0, 0x7F, 0x00, 0x22, 0xE4, 0xFD, 0x7F, 
+0xE3, 0x02, 0x3A, 0x96, 0x90, 0x92, 0xA7, 0x12, 0x47, 0x5F, 0xEF, 0x70, 0x07, 0x90, 0x92, 0xAA, 
+0x04, 0xF0, 0x80, 0x0B, 0xEF, 0x64, 0x01, 0x70, 0x25, 0x90, 0x92, 0xAA, 0x74, 0x40, 0xF0, 0x7F, 
+0xE2, 0x12, 0x3A, 0x96, 0x90, 0x92, 0xAA, 0xE0, 0x31, 0x5E, 0x90, 0x00, 0xE1, 0xE0, 0xFF, 0x90, 
+0x92, 0xA7, 0x12, 0x47, 0x56, 0xEF, 0x12, 0x26, 0x64, 0x31, 0x5D, 0x7F, 0x01, 0x22, 0x80, 0xB3, 
+0x7B, 0x01, 0x7A, 0x92, 0x79, 0x90, 0x7D, 0x08, 0x7F, 0x01, 0x31, 0x64, 0x90, 0x92, 0x90, 0xE0, 
+0x22, 0xEF, 0x90, 0x02, 0x86, 0x60, 0x06, 0xE0, 0x44, 0x04, 0xF0, 0x80, 0x04, 0xE0, 0x54, 0xFB, 
+0xF0, 0x90, 0x8D, 0x06, 0xED, 0xF0, 0x22, 0xE4, 0x90, 0x92, 0x23, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 
+0x90, 0x00, 0x83, 0xE0, 0x90, 0x92, 0x23, 0xF0, 0x90, 0x00, 0x83, 0xE0, 0xFE, 0x90, 0x92, 0x23, 
+0xE0, 0xFF, 0xB5, 0x06, 0x01, 0x22, 0xC3, 0x90, 0x92, 0x25, 0xE0, 0x94, 0x64, 0x90, 0x92, 0x24, 
+0xE0, 0x94, 0x00, 0x40, 0x0D, 0x90, 0x01, 0xC0, 0xE0, 0x44, 0x40, 0xF0, 0x90, 0x92, 0x23, 0xE0, 
+0xFF, 0x22, 0x90, 0x92, 0x24, 0x12, 0x59, 0x26, 0x80, 0xC6, 0x90, 0x01, 0xC4, 0x74, 0x0A, 0xF0, 
+0x74, 0x92, 0xA3, 0xF0, 0x90, 0x00, 0x90, 0xE0, 0x20, 0xE0, 0xF9, 0x74, 0x0A, 0x04, 0x90, 0x01, 
+0xC4, 0xF0, 0x74, 0x92, 0xA3, 0xF0, 0x22, 0x90, 0x8E, 0x0F, 0xE0, 0x44, 0x10, 0xF0, 0x90, 0x8D, 
+0x07, 0xE0, 0xB4, 0x03, 0x0C, 0x90, 0x00, 0x70, 0xE0, 0x44, 0x80, 0xFD, 0x7F, 0x70, 0x12, 0x3A, 
+0x96, 0x90, 0x8E, 0x1D, 0xE0, 0xFD, 0x7F, 0x93, 0x12, 0x3A, 0x96, 0x90, 0x8E, 0x13, 0xE0, 0x60, 
+0x12, 0x90, 0x01, 0x2F, 0xE0, 0x30, 0xE7, 0x05, 0x74, 0x10, 0xF0, 0x80, 0x06, 0x90, 0x01, 0x2F, 
+0x74, 0x90, 0xF0, 0x90, 0x00, 0x08, 0xE0, 0x44, 0x10, 0xFD, 0x7F, 0x08, 0x12, 0x3A, 0x96, 0x7F, 
+0x01, 0x12, 0x58, 0xCD, 0x90, 0x00, 0x90, 0xE0, 0x44, 0x01, 0xFD, 0x7F, 0x90, 0x12, 0x3A, 0x96, 
+0x7F, 0x14, 0x7E, 0x00, 0x02, 0x3A, 0xF7, 0x90, 0x92, 0xC7, 0xEF, 0xF0, 0xA3, 0xED, 0xF0, 0x90, 
+0x00, 0xF1, 0xE0, 0x54, 0xF0, 0x64, 0x20, 0x60, 0x02, 0x61, 0x59, 0x90, 0x92, 0xC8, 0xE0, 0xB4, 
+0x01, 0x1D, 0x90, 0x92, 0xC7, 0xE0, 0xB4, 0x0B, 0x16, 0x90, 0x92, 0x3B, 0x12, 0x27, 0x54, 0x00, 
+0x00, 0x0C, 0x00, 0x90, 0x92, 0x3F, 0x12, 0x27, 0x54, 0x00, 0x00, 0x0C, 0x00, 0x80, 0x14, 0x90, 
+0x92, 0x3B, 0x12, 0x27, 0x54, 0x00, 0x00, 0x0C, 0x00, 0x90, 0x92, 0x3F, 0x12, 0x27, 0x54, 0x00, 
+0x00, 0x08, 0x00, 0x12, 0x6D, 0xD2, 0x90, 0x92, 0xC8, 0xE0, 0x70, 0x21, 0x71, 0xA4, 0x60, 0x04, 
+0xEF, 0xB4, 0x0E, 0x19, 0x90, 0x92, 0x3B, 0x12, 0x27, 0x54, 0x00, 0x00, 0x03, 0x00, 0x90, 0x92, 
+0x3F, 0x12, 0x27, 0x54, 0x00, 0x00, 0x03, 0x00, 0x12, 0x6D, 0xD2, 0x80, 0x0E, 0x90, 0x92, 0xC8, 
+0xE0, 0xB4, 0x01, 0x1D, 0x90, 0x92, 0xC7, 0xE0, 0xB4, 0x0B, 0x16, 0x90, 0x92, 0x3B, 0x12, 0x27, 
+0x54, 0x40, 0x00, 0x00, 0x00, 0x90, 0x92, 0x3F, 0x12, 0x27, 0x54, 0x40, 0x00, 0x00, 0x00, 0x80, 
+0x34, 0x90, 0x92, 0xC8, 0xE0, 0x64, 0x02, 0x60, 0x7A, 0x90, 0x92, 0x3B, 0x12, 0x27, 0x54, 0x00, 
+0x00, 0x03, 0x00, 0x90, 0x92, 0x3F, 0x12, 0x27, 0x54, 0x00, 0x00, 0x02, 0x00, 0x7F, 0xAC, 0x7E, 
+0x08, 0x12, 0x6F, 0x12, 0x12, 0x27, 0x54, 0x40, 0x00, 0x00, 0x00, 0x90, 0x92, 0x3F, 0x12, 0x27, 
+0x54, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xC4, 0x80, 0x45, 0x90, 0x92, 0xC8, 0xE0, 0x70, 0x20, 0x71, 
+0xA4, 0x60, 0x04, 0xEF, 0xB4, 0x0E, 0x18, 0x90, 0x92, 0x3B, 0x12, 0x27, 0x54, 0x00, 0x00, 0x03, 
+0x00, 0x90, 0x92, 0x3F, 0x12, 0x27, 0x54, 0x00, 0x00, 0x03, 0x00, 0x7F, 0xAC, 0x80, 0x1F, 0x90, 
+0x92, 0xC7, 0xE0, 0xD3, 0x94, 0x0E, 0x50, 0x1B, 0x90, 0x92, 0x3B, 0x12, 0x27, 0x54, 0x00, 0x00, 
+0x03, 0x00, 0x90, 0x92, 0x3F, 0x12, 0x27, 0x54, 0x00, 0x00, 0x02, 0x00, 0x7F, 0xAC, 0x7E, 0x08, 
+0x12, 0x6D, 0xD6, 0x22, 0x90, 0x92, 0xC7, 0xE0, 0xFF, 0x64, 0x0D, 0x22, 0x90, 0x04, 0x54, 0xE0, 
+0x7F, 0x00, 0x30, 0xE7, 0x02, 0x7F, 0x01, 0x22, 0x90, 0x92, 0xCA, 0xED, 0xF0, 0x90, 0x92, 0xC9, 
+0xEF, 0xF0, 0xD3, 0x94, 0x0E, 0x50, 0x15, 0x71, 0xAC, 0xEF, 0x60, 0x2A, 0x71, 0xAC, 0xEF, 0x64, 
+0x01, 0x70, 0x23, 0x90, 0x92, 0xCA, 0xE0, 0xFD, 0xE4, 0xFF, 0x80, 0x15, 0x90, 0x92, 0xC9, 0xE0, 
+0xD3, 0x94, 0x0E, 0x40, 0x11, 0x71, 0xAC, 0xEF, 0x70, 0x0A, 0x90, 0x92, 0xCA, 0xE0, 0xFD, 0x7F, 
+0x01, 0x02, 0x6E, 0x33, 0x71, 0xAC, 0x22, 0x7F, 0x34, 0x7E, 0x08, 0x12, 0x6D, 0xD6, 0x90, 0x92, 
+0xBC, 0xE0, 0xFF, 0xA3, 0xE0, 0xFD, 0x90, 0x92, 0xD2, 0xED, 0xF0, 0xEF, 0x60, 0x02, 0x81, 0xCE, 
+0xE0, 0x24, 0xFD, 0x50, 0x0A, 0x60, 0x1D, 0x14, 0x60, 0x2F, 0x14, 0x60, 0x68, 0xC1, 0x49, 0x90, 
+0xAC, 0xB9, 0x12, 0x27, 0x54, 0x77, 0x77, 0x77, 0x77, 0xD1, 0x4A, 0x12, 0x27, 0x54, 0x77, 0x77, 
+0x77, 0x77, 0xA1, 0x3E, 0x90, 0xAC, 0xB9, 0x12, 0x27, 0x54, 0x54, 0x33, 0x77, 0x70, 0xD1, 0x4A, 
+0x12, 0x27, 0x54, 0x54, 0x33, 0x77, 0x70, 0xA1, 0xB6, 0x90, 0xAC, 0xB9, 0x12, 0x27, 0x54, 0x77, 
+0x77, 0x77, 0x77, 0xD1, 0x4A, 0x12, 0x27, 0x54, 0x77, 0x77, 0x77, 0x77, 0xD1, 0x55, 0x12, 0x27, 
+0x54, 0x3F, 0xF0, 0x00, 0x00, 0x90, 0x92, 0x3F, 0x12, 0x27, 0x54, 0x00, 0x10, 0x00, 0x00, 0x12, 
+0x6F, 0x0E, 0x12, 0x27, 0x54, 0x3F, 0xF0, 0x00, 0x00, 0x90, 0x92, 0x3F, 0x12, 0x27, 0x54, 0x00, 
+0x10, 0x00, 0x00, 0xC1, 0x42, 0x90, 0x92, 0x3B, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0xFF, 0x90, 
+0x92, 0x3F, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0x77, 0xD1, 0x60, 0x90, 0xAC, 0xB9, 0x12, 0x27, 
+0x54, 0x77, 0x77, 0x77, 0x77, 0xD1, 0x55, 0x12, 0x27, 0x54, 0x01, 0x00, 0x00, 0x00, 0x90, 0x92, 
+0x3F, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0x00, 0x12, 0x6F, 0x0E, 0x12, 0x27, 0x54, 0x3F, 0xF0, 
+0x00, 0x00, 0x90, 0x92, 0x3F, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 0x00, 0xC1, 0x42, 0x90, 0x92, 
+0xD2, 0xE0, 0x14, 0x60, 0x56, 0x14, 0x70, 0x02, 0xA1, 0x67, 0x14, 0x70, 0x02, 0xA1, 0xA3, 0x14, 
+0x70, 0x02, 0xA1, 0x67, 0x14, 0x70, 0x02, 0xA1, 0xFB, 0x24, 0x05, 0x60, 0x02, 0xC1, 0x49, 0x90, 
+0xAC, 0xB9, 0x12, 0x27, 0x54, 0x77, 0x33, 0x77, 0x17, 0xD1, 0x4A, 0x12, 0x27, 0x54, 0x77, 0x33, 
+0x77, 0x17, 0xD1, 0x55, 0x12, 0x27, 0x54, 0x3F, 0xF0, 0x00, 0x00, 0x90, 0x92, 0x3F, 0x12, 0x27, 
+0x54, 0x01, 0x00, 0x00, 0x00, 0x12, 0x6F, 0x0E, 0x12, 0x27, 0x54, 0x3F, 0xF0, 0x00, 0x00, 0x90, 
+0x92, 0x3F, 0x12, 0x27, 0x54, 0x01, 0x00, 0x00, 0x00, 0xC1, 0x42, 0x90, 0xAC, 0xB9, 0x12, 0x27, 
+0x54, 0x77, 0x33, 0x77, 0x17, 0xD1, 0x4A, 0x12, 0x27, 0x54, 0x77, 0x33, 0x77, 0x17, 0xD1, 0x55, 
+0x12, 0x27, 0x54, 0x3F, 0xF0, 0x00, 0x00, 0x90, 0x92, 0x3F, 0x12, 0x27, 0x54, 0x00, 0x00, 0x00, 
+0x00, 0x12, 0x6F, 0x0E, 0x12, 0x27, 0x54, 0x3F, 0xF0, 0x00, 0x00, 0x90, 0x92, 0x3F, 0x12, 0x27, 
+0x54, 0x00, 0x00, 0x00, 0x00, 0xC1, 0x42, 0x90, 0xAC, 0xB9, 0x12, 0x27, 0x54, 0x77, 0x33, 0x77, 
+0x77, 0xD1, 0x4A, 0x12, 0x27, 0x54, 0x77, 0x33, 0x77, 0x77, 0xD1, 0x55, 0x12, 0x27, 0x54, 0x3F, 
+0xF0, 0x00, 0x00, 0x90, 0x92, 0x3F, 0x12, 0x27, 0x54, 0x01, 0x00, 0x00, 0x00, 0x12, 0x6F, 0x0E, 
+0x12, 0x27, 0x54, 0x3F, 0xF0, 0x00, 0x00, 0x90, 0x92, 0x3F, 0x12, 0x27, 0x54, 0x01, 0x00, 0x00, 
+0x00, 0xC1, 0x42, 0x90, 0xAC, 0xB9, 0x12, 0x27, 0x54, 0x54, 0x33, 0x77, 0x17, 0xD1, 0x4A, 0x12, 
+0x27, 0x54, 0x54, 0x33, 0x77, 0x17, 0xD1, 0x55, 0x12, 0x27, 0x54, 0x3F, 0xF0, 0x00, 0x00, 0x90, 
+0x92, 0x3F, 0x12, 0x27, 0x54, 0x01, 0x00, 0x00, 0x00, 0x12, 0x6F, 0x0E, 0x12, 0x27, 0x54, 0x3F, 
+0xF0, 0x00, 0x00, 0x90, 0x92, 0x3F, 0x12, 0x27, 0x54, 0x01, 0x00, 0x00, 0x00, 0x7F, 0xB4, 0x7E, 
+0x0E, 0x12, 0x6F, 0x12, 0x12, 0x27, 0x54, 0x00, 0x00, 0x03, 0x03, 0x90, 0x92, 0x3F, 0x12, 0x27, 
+0x54, 0x00, 0x00, 0x00, 0x01, 0x7F, 0x00, 0x7E, 0x09, 0x80, 0x4B, 0x90, 0x92, 0x3B, 0x12, 0x27, 
+0x54, 0x00, 0xFF, 0x00, 0x00, 0x90, 0x92, 0x3F, 0x12, 0x27, 0x54, 0x00, 0x33, 0x00, 0x00, 0xD1, 
+0x60, 0x90, 0xAC, 0xB9, 0x12, 0x27, 0x54, 0x77, 0x33, 0x77, 0x77, 0xD1, 0x55, 0x12, 0x27, 0x54, 
+0x01, 0x00, 0x00, 0x00, 0x90, 0x92, 0x3F, 0x12, 0x27, 0x54, 0x01, 0x00, 0x00, 0x00, 0x12, 0x6F, 
+0x0E, 0x12, 0x27, 0x54, 0x3F, 0xF0, 0x00, 0x00, 0x90, 0x92, 0x3F, 0x12, 0x27, 0x54, 0x01, 0x00, 
+0x00, 0x00, 0x7F, 0xB4, 0x7E, 0x0E, 0x12, 0x6D, 0xD6, 0x22, 0x7F, 0xB0, 0x7E, 0x0C, 0x12, 0x37, 
+0x5D, 0x90, 0xAC, 0xB9, 0x22, 0x7F, 0xB0, 0x7E, 0x0E, 0x12, 0x37, 0x5D, 0x90, 0x92, 0x3B, 0x22, 
+0x7F, 0xB0, 0x7E, 0x0C, 0x02, 0x6D, 0xD6, 0xE4, 0xFE, 0xEF, 0x54, 0xE0, 0xC4, 0x13, 0x54, 0x07, 
+0xFD, 0xEF, 0x54, 0x1F, 0xFF, 0xED, 0x60, 0x2C, 0x14, 0x60, 0x1E, 0x24, 0xFD, 0x60, 0x0F, 0x24, 
+0xFE, 0x70, 0x2A, 0xEF, 0x25, 0xE0, 0xFF, 0xC3, 0x74, 0xDE, 0x9F, 0xFE, 0x80, 0x1F, 0xEF, 0x25, 
+0xE0, 0xFF, 0xC3, 0x74, 0xF2, 0x9F, 0xFE, 0x80, 0x14, 0xEF, 0x25, 0xE0, 0xFF, 0xC3, 0x74, 0x06, 
+0x9F, 0xFE, 0x80, 0x09, 0xEF, 0x25, 0xE0, 0xFF, 0xC3, 0x74, 0x10, 0x9F, 0xFE, 0xAF, 0x06, 0x22, 
+0xD3, 0xEF, 0x64, 0x80, 0x94, 0x1C, 0x40, 0x07, 0xEF, 0x64, 0x80, 0x94, 0x94, 0x40, 0x03, 0x7F, 
+0x00, 0x22, 0xC3, 0xEF, 0x64, 0x80, 0x94, 0x80, 0x40, 0x03, 0x7F, 0x64, 0x22, 0xEF, 0x24, 0x64, 
+0xFF, 0x22, 0x90, 0x90, 0xE4, 0xE0, 0xFF, 0x13, 0x13, 0x54, 0x3F, 0x30, 0xE0, 0x0D, 0x7B, 0x00, 
+0x7A, 0x00, 0x79, 0x00, 0xD1, 0xEE, 0x04, 0xF0, 0x02, 0x5B, 0xE7, 0x02, 0x74, 0xE2, 0x90, 0x92, 
+0x4E, 0x12, 0x47, 0x5F, 0xE4, 0x90, 0x92, 0x51, 0xF0, 0xA3, 0x22, 0x90, 0x90, 0xE4, 0xE0, 0x30, 
+0xE0, 0x36, 0x12, 0x6F, 0x25, 0x64, 0x01, 0x70, 0x2F, 0x90, 0x92, 0xD4, 0xE0, 0x04, 0xF0, 0xE0, 
+0xB4, 0x0A, 0x0B, 0x90, 0x90, 0xE6, 0xE0, 0x04, 0xF0, 0xE4, 0x90, 0x92, 0xD4, 0xF0, 0x90, 0x90, 
+0xE6, 0xE0, 0xFF, 0x90, 0x90, 0xE5, 0xE0, 0xD3, 0x9F, 0x50, 0x0D, 0x90, 0x90, 0xE7, 0xE0, 0x70, 
+0x07, 0xE4, 0x90, 0x90, 0xE6, 0xF0, 0xD1, 0xD2, 0x22, 0x90, 0x90, 0xE4, 0xE0, 0x54, 0xFE, 0xF0, 
+0x54, 0x7F, 0xF0, 0x54, 0xFB, 0xF0, 0xA3, 0x74, 0x0A, 0xF0, 0xE4, 0xA3, 0xF0, 0xA3, 0xF0, 0x22, 
+0x90, 0x02, 0x84, 0xEF, 0xF0, 0xEE, 0xA3, 0xF0, 0xA3, 0xE0, 0x44, 0x01, 0xF0, 0x22, 0x90, 0x02, 
+0x86, 0xE0, 0x20, 0xE2, 0x03, 0x7F, 0x04, 0x22, 0x90, 0x02, 0x86, 0xE0, 0x7F, 0x01, 0x20, 0xE1, 
+0x02, 0x7F, 0x02, 0x22, 0x90, 0x8E, 0xC7, 0xE0, 0xC4, 0x54, 0x0F, 0x20, 0xE0, 0x0A, 0x90, 0x01, 
+0x3F, 0xE0, 0x30, 0xE2, 0x03, 0x12, 0x5F, 0xDA, 0x90, 0x8E, 0xCE, 0xE0, 0x30, 0xE0, 0x0D, 0x90, 
+0x8E, 0xC8, 0xE0, 0xC4, 0x54, 0x0F, 0x20, 0xE0, 0x03, 0x7F, 0x00, 0x22, 0x7F, 0x01, 0x22, 0xEF, 
+0x90, 0x01, 0xC7, 0xB4, 0xA0, 0x05, 0x74, 0x04, 0xF0, 0x80, 0x03, 0x74, 0x08, 0xF0, 0x02, 0x5F, 
+0xDA, 0x90, 0x8E, 0xCE, 0xE0, 0x30, 0xE0, 0x03, 0x7F, 0x01, 0x22, 0x90, 0x06, 0x90, 0xE0, 0x20, 
+0xE5, 0x10, 0x90, 0x01, 0x3F, 0xE0, 0x30, 0xE2, 0x09, 0x90, 0x01, 0xC7, 0x74, 0x25, 0xF0, 0x7F, 
+0x01, 0x22, 0x7F, 0x00, 0x22, 0x90, 0x02, 0x09, 0xE0, 0x90, 0x90, 0xFE, 0xF0, 0x12, 0x26, 0x1E, 
+0x90, 0x90, 0xD2, 0x12, 0x4E, 0xCD, 0x90, 0x90, 0xD3, 0xF0, 0x22, 0x90, 0x02, 0x09, 0xE0, 0xFF, 
+0x12, 0x26, 0x1E, 0xFE, 0xEF, 0x2E, 0x90, 0x90, 0xE2, 0xF0, 0x22, 0x12, 0x98, 0x35, 0x30, 0xE0, 
+0x05, 0x90, 0x01, 0x5B, 0xE4, 0xF0, 0x90, 0x06, 0x92, 0x74, 0x02, 0xF0, 0x90, 0x01, 0x3C, 0x74, 
+0x04, 0xF0, 0xE4, 0x90, 0x92, 0x7E, 0xF0, 0x90, 0x8E, 0xBC, 0xE0, 0xC3, 0x13, 0x54, 0x7F, 0x90, 
+0x92, 0x7F, 0xF0, 0xE4, 0xFB, 0xFD, 0x7F, 0x58, 0x7E, 0x01, 0x12, 0x68, 0x50, 0x90, 0x8E, 0x0E, 
+0xE0, 0x44, 0x08, 0xF0, 0x22, 0x90, 0x8E, 0x0E, 0xE0, 0x13, 0x13, 0x13, 0x54, 0x1F, 0x22, 0x90, 
+0x04, 0x1A, 0xE0, 0xF4, 0x60, 0x03, 0x7F, 0x00, 0x22, 0x90, 0x04, 0x1B, 0xE0, 0x54, 0x07, 0x64, 
+0x07, 0x7F, 0x01, 0x60, 0x02, 0x7F, 0x00, 0x22, 0x11, 0x3F, 0xEF, 0x64, 0x01, 0x70, 0x32, 0x90, 
+0x8E, 0x16, 0xE0, 0xFF, 0x54, 0x03, 0x70, 0x29, 0x90, 0x8E, 0x14, 0xE0, 0xFE, 0xE4, 0xC3, 0x9E, 
+0x40, 0x1F, 0xEF, 0x20, 0xE2, 0x1B, 0x90, 0x8E, 0x16, 0xE0, 0x20, 0xE4, 0x14, 0x90, 0x8E, 0x0F, 
+0xE0, 0x13, 0x13, 0x54, 0x3F, 0x30, 0xE0, 0x09, 0x90, 0x8E, 0xC0, 0xE0, 0x70, 0x03, 0x7F, 0x01, 
+0x22, 0x7F, 0x00, 0x22, 0x90, 0x8E, 0xC1, 0xE0, 0xC3, 0x13, 0x20, 0xE0, 0x30, 0x90, 0x02, 0x87, 
+0xE0, 0x70, 0x33, 0x90, 0x01, 0x00, 0xE0, 0x64, 0x3F, 0x70, 0x2B, 0x90, 0x8E, 0xC5, 0xE0, 0x30, 
+0xE0, 0x06, 0x90, 0x02, 0x82, 0xE0, 0x70, 0x1E, 0x90, 0x8E, 0xCE, 0xE0, 0x20, 0xE0, 0x17, 0x90, 
+0x02, 0x86, 0xE0, 0x30, 0xE1, 0x10, 0x90, 0x02, 0x86, 0xE0, 0x20, 0xE3, 0x09, 0x90, 0x04, 0x1D, 
+0xE0, 0x70, 0x03, 0x7F, 0x01, 0x22, 0x7F, 0x00, 0x22, 0xEF, 0x60, 0x30, 0x12, 0x6F, 0x25, 0x64, 
+0x01, 0x70, 0x29, 0x90, 0x8E, 0x0F, 0xE0, 0x54, 0xFE, 0xF0, 0x7D, 0x2B, 0x7F, 0x0F, 0x12, 0x53, 
+0x74, 0x90, 0x06, 0x04, 0xE0, 0x54, 0xBF, 0xF0, 0x12, 0x74, 0xE2, 0xBF, 0x01, 0x0E, 0x90, 0x8E, 
+0x0E, 0xE0, 0x44, 0x40, 0xF0, 0x7D, 0x06, 0x7F, 0x01, 0x12, 0x51, 0x10, 0x22, 0x7D, 0x2E, 0x7F, 
+0x6F, 0x12, 0x53, 0x74, 0x7D, 0x02, 0x7F, 0x01, 0x02, 0x51, 0x10, 0xE4, 0xFE, 0x74, 0x2F, 0x2E, 
+0x31, 0x44, 0xE4, 0xF0, 0x0E, 0xEE, 0xB4, 0x19, 0xF4, 0xE4, 0x90, 0x8E, 0x28, 0xF0, 0x90, 0x8E, 
+0x2C, 0xF0, 0x90, 0x8E, 0x24, 0xF0, 0xEF, 0xB4, 0x01, 0x09, 0x90, 0x8E, 0x2D, 0x74, 0x19, 0xF0, 
+0xE4, 0xA3, 0xF0, 0x22, 0xF5, 0x82, 0xE4, 0x34, 0x8E, 0xF5, 0x83, 0x22, 0x31, 0x51, 0x02, 0x49, 
+0x38, 0x7E, 0x00, 0x7F, 0x04, 0x7D, 0x00, 0x7B, 0x01, 0x7A, 0x8E, 0x79, 0xC1, 0x22, 0xD3, 0x10, 
+0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x06, 0x31, 0xE0, 0x54, 0xEF, 0x44, 0x08, 0xF0, 0xED, 0x2F, 
+0xFF, 0xE4, 0x3E, 0xFE, 0x7C, 0x00, 0xEF, 0x24, 0x08, 0xFF, 0xEC, 0x3E, 0x90, 0x91, 0x17, 0xF0, 
+0xA3, 0xEF, 0xF0, 0x7E, 0x00, 0x7F, 0x83, 0x7D, 0x00, 0x7B, 0x01, 0x7A, 0x8F, 0x79, 0xE2, 0x12, 
+0x49, 0x38, 0x90, 0x91, 0x18, 0xE0, 0x24, 0x01, 0x12, 0x5F, 0x25, 0x90, 0x8F, 0xE3, 0x51, 0x81, 
+0x24, 0x04, 0x12, 0x5F, 0x25, 0x90, 0x8F, 0xE6, 0x51, 0x81, 0x24, 0x05, 0x12, 0x5F, 0x25, 0x90, 
+0x8F, 0xE7, 0x51, 0x81, 0x24, 0x06, 0x12, 0x5F, 0x25, 0x90, 0x8F, 0xE8, 0x51, 0x81, 0x24, 0x07, 
+0x12, 0x5F, 0x25, 0x90, 0x8F, 0xE9, 0x51, 0x81, 0x24, 0x08, 0x12, 0x5F, 0x25, 0x90, 0x8F, 0xEA, 
+0xEF, 0xF0, 0xE4, 0x90, 0x91, 0x16, 0xF0, 0x90, 0x91, 0x16, 0xE0, 0xFF, 0xC3, 0x94, 0x08, 0x50, 
+0x14, 0x90, 0x91, 0x18, 0xE0, 0x24, 0x09, 0x12, 0x5E, 0x42, 0x90, 0x91, 0x16, 0xE0, 0x51, 0x95, 
+0x51, 0x88, 0xF0, 0x80, 0xE2, 0xE4, 0x90, 0x91, 0x16, 0xF0, 0x90, 0x91, 0x16, 0xE0, 0xFF, 0xC3, 
+0x94, 0x20, 0x50, 0x1B, 0x90, 0x91, 0x18, 0xE0, 0x24, 0x63, 0x12, 0x5E, 0x42, 0x90, 0x91, 0x16, 
+0xE0, 0x24, 0x45, 0xF5, 0x82, 0xE4, 0x34, 0x90, 0xF5, 0x83, 0x51, 0x88, 0xF0, 0x80, 0xDB, 0x90, 
+0x8F, 0xE7, 0x71, 0x72, 0x90, 0x91, 0x14, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x30, 0xE3, 0x0D, 0x7F, 
+0x01, 0x12, 0x63, 0x09, 0x90, 0x01, 0xC7, 0x74, 0x03, 0xF0, 0x80, 0x3E, 0x90, 0x91, 0x14, 0xA3, 
+0xE0, 0xFF, 0x7C, 0x00, 0x54, 0x07, 0xFD, 0x64, 0x01, 0x60, 0x05, 0xED, 0x64, 0x02, 0x70, 0x2A, 
+0xED, 0x64, 0x02, 0x4C, 0x70, 0x24, 0xEF, 0x54, 0x30, 0xFF, 0xE4, 0xC4, 0xF8, 0x54, 0xF0, 0xC8, 
+0xEF, 0xC4, 0x54, 0x0F, 0x48, 0x90, 0x90, 0x7B, 0xF0, 0xAE, 0x04, 0xAF, 0x05, 0xE4, 0xFD, 0x51, 
+0x9F, 0x90, 0x06, 0x31, 0xE0, 0x54, 0xF7, 0x44, 0x10, 0xF0, 0x7F, 0x00, 0xD0, 0xD0, 0x92, 0xAF, 
+0x22, 0xEF, 0xF0, 0x90, 0x91, 0x18, 0xE0, 0x22, 0xEF, 0xF0, 0x90, 0x91, 0x16, 0xE0, 0x04, 0x22, 
+0x90, 0x91, 0x35, 0xE0, 0xFF, 0x24, 0xEB, 0xF5, 0x82, 0xE4, 0x34, 0x8F, 0xF5, 0x83, 0x22, 0x90, 
+0x91, 0x1B, 0xED, 0xF0, 0x90, 0x91, 0x19, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x51, 0xBC, 0x90, 0x91, 
+0x19, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0xA3, 0xE0, 0xFD, 0x02, 0x53, 0x7F, 0xD3, 0x10, 0xAF, 0x01, 
+0xC3, 0xC0, 0xD0, 0x90, 0x90, 0xD3, 0xE0, 0xFD, 0xB4, 0x02, 0x07, 0x71, 0x6A, 0x74, 0x08, 0xF0, 
+0x80, 0x09, 0xED, 0xB4, 0x04, 0x05, 0x71, 0x6A, 0x74, 0x10, 0xF0, 0xEF, 0x64, 0x02, 0x4E, 0x60, 
+0x02, 0x61, 0x65, 0x90, 0x8F, 0xE3, 0xE0, 0xFF, 0x64, 0xFE, 0x60, 0x79, 0xEF, 0x64, 0x02, 0x60, 
+0x05, 0xEF, 0x64, 0x03, 0x70, 0x6F, 0x90, 0x90, 0x43, 0x71, 0x72, 0x90, 0x91, 0x4E, 0xEE, 0xF0, 
+0xA3, 0xEF, 0xF0, 0x7E, 0x00, 0x7F, 0x20, 0x7D, 0x00, 0x7B, 0x01, 0x7A, 0x91, 0x79, 0x2C, 0x12, 
+0x49, 0x38, 0x7B, 0x01, 0x7A, 0x90, 0x79, 0x45, 0x90, 0xAE, 0x73, 0x12, 0x47, 0x5F, 0x7A, 0x91, 
+0x79, 0x2C, 0x90, 0xAE, 0x76, 0x12, 0x47, 0x5F, 0x7A, 0x8F, 0x79, 0xB2, 0x7D, 0x03, 0x12, 0x02, 
+0x00, 0x75, 0x40, 0x01, 0x75, 0x41, 0x91, 0x75, 0x42, 0x34, 0x75, 0x43, 0x10, 0x7B, 0x01, 0x7A, 
+0x91, 0x79, 0x1C, 0x12, 0x34, 0x2C, 0x90, 0x91, 0x32, 0xE0, 0x54, 0x03, 0xFF, 0xC3, 0x94, 0x04, 
+0x90, 0x8F, 0x9E, 0x50, 0x04, 0xEF, 0xF0, 0x80, 0x03, 0x74, 0x05, 0xF0, 0x7B, 0x01, 0x7A, 0x91, 
+0x79, 0x1C, 0x12, 0x4D, 0x38, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0x91, 0x4C, 0x74, 0x80, 0xF0, 
+0xA3, 0x22, 0xE0, 0xFE, 0xA3, 0xE0, 0xFD, 0xED, 0xFF, 0x22, 0x90, 0x91, 0x0E, 0xEE, 0xF0, 0xA3, 
+0xEF, 0xF0, 0x24, 0x16, 0xFF, 0xE4, 0x3E, 0x12, 0x5F, 0x2C, 0x90, 0x90, 0x8C, 0xA3, 0xE0, 0xB5, 
+0x07, 0x1B, 0x90, 0x91, 0x0F, 0xE0, 0x24, 0x16, 0x12, 0x5F, 0x02, 0xFE, 0x7D, 0x01, 0x12, 0x5E, 
+0x54, 0xEF, 0xFD, 0x90, 0x90, 0x8C, 0xE0, 0x6D, 0x70, 0x01, 0xE4, 0x60, 0x03, 0x7F, 0x00, 0x22, 
+0x7F, 0x01, 0x22, 0xE4, 0x90, 0x92, 0x0D, 0xF0, 0x90, 0x91, 0xC3, 0x12, 0x47, 0x56, 0x90, 0x92, 
+0x0B, 0xE0, 0xFE, 0xA3, 0xE0, 0x29, 0xF9, 0xEA, 0x3E, 0xFA, 0xE9, 0x24, 0xC0, 0xF9, 0xEA, 0x34, 
+0xFF, 0xFA, 0x74, 0x88, 0xFD, 0x12, 0x30, 0xA4, 0x90, 0x91, 0xC3, 0x12, 0x47, 0x56, 0x90, 0x92, 
+0x0B, 0xE0, 0xFE, 0xA3, 0xE0, 0x29, 0xF9, 0xEA, 0x3E, 0xFA, 0xE9, 0x24, 0xC4, 0xF9, 0xEA, 0x34, 
+0xFF, 0xFA, 0xA3, 0xE0, 0x44, 0x89, 0xFD, 0x12, 0x30, 0xA4, 0x90, 0x91, 0xC3, 0x12, 0x47, 0x56, 
+0x90, 0x92, 0x0B, 0xE0, 0xFE, 0xA3, 0xE0, 0x29, 0xF9, 0xEA, 0x3E, 0xFA, 0xE9, 0x24, 0xC8, 0xF9, 
+0xEA, 0x34, 0xFF, 0xFA, 0xA3, 0xE0, 0x44, 0x8A, 0xFD, 0x12, 0x30, 0xA4, 0x90, 0x91, 0xC3, 0x12, 
+0x47, 0x56, 0x90, 0x92, 0x0B, 0xE0, 0xFE, 0xA3, 0xE0, 0x29, 0xF9, 0xEA, 0x3E, 0xFA, 0xE9, 0x22, 
+0xA3, 0x74, 0x40, 0xF0, 0x74, 0xCB, 0x2F, 0xF9, 0xE4, 0x34, 0x91, 0xFA, 0x7B, 0x01, 0x74, 0x40, 
+0x44, 0x88, 0xFD, 0x12, 0x30, 0xA4, 0x90, 0x92, 0x0B, 0xA3, 0xE0, 0x24, 0xCF, 0xF9, 0xE4, 0x34, 
+0x91, 0xFA, 0x7B, 0x01, 0xA3, 0xE0, 0x44, 0x89, 0xFD, 0x12, 0x30, 0xA4, 0x90, 0x92, 0x0B, 0xA3, 
+0xE0, 0x24, 0xD3, 0xF9, 0xE4, 0x34, 0x91, 0xFA, 0x7B, 0x01, 0xA3, 0xE0, 0x44, 0x8A, 0xFD, 0x12, 
+0x30, 0xA4, 0x90, 0x92, 0x0B, 0xA3, 0xE0, 0x22, 0x54, 0xFE, 0xFD, 0x7F, 0x02, 0x12, 0x3A, 0x96, 
+0x90, 0x00, 0x02, 0xE0, 0x44, 0x01, 0xFD, 0x7F, 0x02, 0x12, 0x3A, 0x96, 0x90, 0x00, 0x02, 0xE0, 
+0x22, 0x90, 0x90, 0xD7, 0xE0, 0xFF, 0x7B, 0x18, 0x7D, 0x01, 0x12, 0x74, 0x57, 0x90, 0x91, 0x33, 
+0xEF, 0xF0, 0x90, 0x90, 0xD7, 0xE0, 0x90, 0x04, 0x25, 0xF0, 0x22, 0x12, 0x47, 0x3E, 0x90, 0x8E, 
+0x4B, 0x12, 0x47, 0x32, 0x12, 0x46, 0xF9, 0x78, 0x0A, 0x12, 0x27, 0x22, 0x90, 0x8E, 0x2A, 0xE0, 
+0xF4, 0x04, 0x2F, 0x22, 0x90, 0x01, 0x57, 0xE4, 0xF0, 0x90, 0x01, 0x3C, 0x74, 0x02, 0x22, 0x90, 
+0x91, 0xC2, 0xE0, 0xF5, 0x43, 0x7B, 0x01, 0x7A, 0x91, 0x79, 0xCB, 0x12, 0x34, 0x2C, 0xE4, 0x90, 
+0x91, 0xCA, 0xF0, 0x22, 0x74, 0x2F, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x8E, 0xF5, 0x83, 0xE0, 0xFF, 
+0x90, 0x92, 0x15, 0xE0, 0x2F, 0xF0, 0xE0, 0xD3, 0x22, 0x90, 0x8E, 0xBA, 0x74, 0x05, 0xF0, 0xA3, 
+0x74, 0x0F, 0xF0, 0xA3, 0xE0, 0x54, 0x01, 0x44, 0x1E, 0xF0, 0xA3, 0x74, 0x07, 0x22, 0xA3, 0xE0, 
+0x44, 0x8B, 0xFD, 0x12, 0x30, 0xA4, 0x90, 0x92, 0x0D, 0xE0, 0x44, 0x90, 0x90, 0x01, 0x8C, 0xF0, 
+0x22, 0xA3, 0xE0, 0x24, 0x28, 0xF9, 0xE4, 0x34, 0xFC, 0xFA, 0x7B, 0x01, 0x22, 0x90, 0x8E, 0x24, 
+0xE0, 0xFF, 0xA3, 0xE0, 0xFD, 0x90, 0x8E, 0x2B, 0xE0, 0x22, 0x90, 0x8E, 0xC5, 0xE0, 0xC4, 0x13, 
+0x13, 0x54, 0x03, 0x22, 0x7F, 0x00, 0x7E, 0x0C, 0x12, 0x37, 0x5D, 0x7F, 0x00, 0x7E, 0x0E, 0x22, 
+0x90, 0x06, 0x04, 0xE0, 0x44, 0x40, 0xF0, 0xE0, 0x44, 0x80, 0xF0, 0x22, 0xE0, 0x2F, 0x24, 0x42, 
+0xF9, 0xE4, 0x34, 0xFC, 0xFA, 0x22, 0xE0, 0x2F, 0x24, 0x48, 0xF9, 0xE4, 0x34, 0xFC, 0xFA, 0x22, 
+0x75, 0x41, 0x8F, 0x75, 0x42, 0xE9, 0x75, 0x43, 0x02, 0x22, 0xE4, 0x90, 0x92, 0x15, 0xF0, 0x90, 
+0x92, 0x13, 0xF0, 0x22, 0x12, 0x47, 0x14, 0x90, 0x8E, 0x4F, 0x02, 0x27, 0x48, 0xF0, 0xA3, 0xEF, 
+0xF0, 0xE4, 0xFD, 0x02, 0x5E, 0x54, 0x90, 0x92, 0xAB, 0xE0, 0xFF, 0x74, 0x64, 0xD3, 0x9F, 0x22, 
+0x90, 0x92, 0xAB, 0xE0, 0xFF, 0x74, 0x24, 0xD3, 0x9F, 0x22, 0x7E, 0x0E, 0x12, 0x37, 0x5D, 0x90, 
+0x00, 0xFF, 0xE0, 0x22, 0xD2, 0xAF, 0xC2, 0xAF, 0x90, 0x8D, 0x01, 0xE0, 0xFF, 0x22, 0x90, 0x92, 
+0x13, 0xE0, 0xFF, 0xC3, 0x94, 0x19, 0x22, 0x90, 0x90, 0xFA, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x22, 
+0x7F, 0xB4, 0x7E, 0x08, 0x12, 0x36, 0xCE, 0xEF, 0x22, 0x54, 0x08, 0xFE, 0xEF, 0x54, 0xF7, 0x4E, 
+0x22, 0x54, 0x20, 0xFE, 0xEF, 0x54, 0xDF, 0x4E, 0x22, 0x7F, 0xB4, 0x7E, 0x08, 0x02, 0x37, 0x5D, 
+0x90, 0x8D, 0xF9, 0xF0, 0xA3, 0xEF, 0xF0, 0x22, 0xF9, 0xE4, 0x3A, 0xFA, 0x02, 0x26, 0x1E, 0xF0, 
+0x90, 0x91, 0x35, 0xE0, 0x04, 0xF0, 0x22, 0x90, 0x91, 0x38, 0xE4, 0x75, 0xF0, 0x02, 0x22, 0xF0, 
+0xE4, 0x90, 0x91, 0x43, 0xF0, 0xA3, 0x22, 0xF0, 0x90, 0x8E, 0x2D, 0xE0, 0xFF, 0xC3, 0x22, 0x90, 
+0x8E, 0x10, 0xE0, 0xC4, 0x54, 0x0F, 0x22, 0x90, 0x8E, 0x18, 0xE0, 0x90, 0x05, 0x73, 0x22, 0x90, 
+0x8E, 0x16, 0xE0, 0x44, 0x10, 0xF0, 0x22, 0xF0, 0xA3, 0xF0, 0xA3, 0x74, 0x08, 0xF0, 0x22, 0x12, 
+0x3A, 0x96, 0x90, 0x92, 0xCC, 0xE0, 0x22, 0x00, 0xDE, 0x37, 
+};
+u4Byte ArrayLength_MP_8812A_FW_WoWLAN = 24170;
+
+
+void
+ODM_ReadFirmware_MP_8812A_FW_WoWLAN(
+     IN   PDM_ODM_T    pDM_Odm,
+     OUT  u1Byte       *pFirmware,
+     OUT  u4Byte       *pFirmwareSize
+)
+{
+#if (DM_ODM_SUPPORT_TYPE & (ODM_CE))
+	*((SIZE_PTR *)pFirmware) = (SIZE_PTR)Array_MP_8812A_FW_WoWLAN;
+#else
+	ODM_MoveMemory(pDM_Odm, pFirmware, Array_MP_8812A_FW_WoWLAN, ArrayLength_MP_8812A_FW_WoWLAN);
+#endif
+	*pFirmwareSize = ArrayLength_MP_8812A_FW_WoWLAN;
+}
+
+
+
+#endif // end of HWIMG_SUPPORT
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/hal/HalHWImg8821A_FW.c linux-4.9.8821au/drivers/staging/rtl8821au/hal/HalHWImg8821A_FW.c
--- linux-4.9/drivers/staging/rtl8821au/hal/HalHWImg8821A_FW.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/hal/HalHWImg8821A_FW.c	2016-12-11 19:48:25.166978407 -0600
@@ -0,0 +1,6371 @@
+/****************************************************************************** 
+* 
+* Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved. 
+* 
+* This program is free software; you can redistribute it and/or modify it 
+* under the terms of version 2 of the GNU General Public License as 
+* published by the Free Software Foundation. 
+* 
+* This program is distributed in the hope that it will be useful, but WITHOUT 
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for 
+* more details. 
+* 
+* You should have received a copy of the GNU General Public License along with 
+* this program; if not, write to the Free Software Foundation, Inc., 
+* 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA 
+* 
+* 
+******************************************************************************/
+
+#include "Mp_Precomp.h"
+#include "../phydm_precomp.h"
+
+#if (RTL8821A_SUPPORT == 1)
+#if(DM_ODM_SUPPORT_TYPE & (ODM_AP))
+
+
+u1Byte Array_MP_8821A_FW_AP[] = {
+0x01, 0x21, 0x20, 0x00, 0x1C, 0x00, 0x00, 0x00, 0x09, 0x05, 0x15, 0x19, 0x36, 0x3C, 0x00, 0x00, 
+0xD0, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x02, 0x49, 0x01, 0x02, 0x5F, 0xED, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x02, 0x60, 0x52, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x02, 0x68, 0x62, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x02, 0x5F, 0xEE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x67, 0xED, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x02, 0x68, 0x61, 0x15, 0xF0, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x15, 0xF0, 0x0F, 
+0x00, 0x00, 0x00, 0x00, 0x05, 0xF0, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x05, 0xF0, 0x0F, 0x00, 0x00, 
+0x00, 0x00, 0x10, 0xF0, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x10, 0xF0, 0x0F, 0x00, 0x00, 0x00, 0x00, 
+0xF5, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0D, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0xF0, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x10, 0xF0, 0x3F, 0x00, 
+0x00, 0x00, 0x00, 0x15, 0xF0, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x15, 0xF0, 0xCF, 0xFF, 0x00, 0x00, 
+0x00, 0x0A, 0x08, 0x03, 0x03, 0x00, 0x04, 0x09, 0x07, 0x03, 0x03, 0x00, 0x04, 0x08, 0x06, 0x03, 
+0x02, 0x00, 0x04, 0x08, 0x05, 0x03, 0x01, 0x00, 0x04, 0x0D, 0x0A, 0x07, 0x05, 0x00, 0x08, 0x0C, 
+0x0A, 0x07, 0x04, 0x00, 0x08, 0x0B, 0x0A, 0x06, 0x05, 0x00, 0x08, 0x0B, 0x0A, 0x05, 0x03, 0x00, 
+0x08, 0x0B, 0x0A, 0x03, 0x02, 0x00, 0x08, 0x14, 0x12, 0x0C, 0x04, 0x00, 0x10, 0x14, 0x12, 0x09, 
+0x04, 0x00, 0x10, 0x24, 0x22, 0x1C, 0x12, 0x00, 0x20, 0x24, 0x22, 0x18, 0x0C, 0x00, 0x20, 0x24, 
+0x22, 0x14, 0x06, 0x00, 0x20, 0x24, 0x22, 0x0F, 0x04, 0x00, 0x20, 0x24, 0x21, 0x0A, 0x04, 0x00, 
+0x20, 0x23, 0x21, 0x0C, 0x04, 0x00, 0x20, 0x23, 0x1F, 0x0A, 0x04, 0x00, 0x20, 0x22, 0x1F, 0x0F, 
+0x04, 0x00, 0x20, 0x21, 0x1F, 0x16, 0x0C, 0x00, 0x20, 0x31, 0x2F, 0x20, 0x14, 0x00, 0x30, 0x31, 
+0x2F, 0x18, 0x10, 0x00, 0x30, 0x31, 0x2C, 0x18, 0x0C, 0x00, 0x30, 0x31, 0x2A, 0x14, 0x0C, 0x00, 
+0x30, 0x31, 0x28, 0x14, 0x00, 0x00, 0x30, 0x31, 0x24, 0x14, 0x00, 0x00, 0x30, 0x31, 0x1E, 0x14, 
+0x00, 0x00, 0x30, 0x04, 0x04, 0x04, 0x05, 0x04, 0x04, 0x05, 0x07, 0x07, 0x07, 0x08, 0x0A, 0x04, 
+0x07, 0x0A, 0x0E, 0x11, 0x13, 0x14, 0x15, 0x03, 0x04, 0x07, 0x07, 0x08, 0x0B, 0x0D, 0x0F, 0x05, 
+0x05, 0x07, 0x07, 0x08, 0x0B, 0x0D, 0x0F, 0x05, 0x05, 0x07, 0x07, 0x08, 0x0B, 0x0D, 0x0F, 0x07, 
+0x08, 0x08, 0x0A, 0x0A, 0x0C, 0x0E, 0x10, 0x11, 0x11, 0x07, 0x09, 0x09, 0x0B, 0x0B, 0x0D, 0x0F, 
+0x13, 0x13, 0x14, 0x05, 0x05, 0x07, 0x07, 0x08, 0x0B, 0x0D, 0x0F, 0x0F, 0x0F, 0x05, 0x05, 0x07, 
+0x07, 0x08, 0x0B, 0x0D, 0x0F, 0x0F, 0x0F, 0x04, 0x04, 0x04, 0x05, 0x07, 0x07, 0x09, 0x09, 0x0C, 
+0x0E, 0x10, 0x12, 0x05, 0x06, 0x07, 0x0D, 0x10, 0x11, 0x12, 0x12, 0x07, 0x08, 0x09, 0x09, 0x0C, 
+0x0E, 0x11, 0x13, 0x09, 0x09, 0x09, 0x09, 0x0C, 0x0E, 0x11, 0x13, 0x09, 0x09, 0x09, 0x09, 0x0C, 
+0x0E, 0x11, 0x13, 0x05, 0x06, 0x08, 0x09, 0x0C, 0x0E, 0x12, 0x12, 0x13, 0x14, 0x07, 0x08, 0x09, 
+0x0A, 0x0C, 0x0F, 0x12, 0x12, 0x14, 0x16, 0x09, 0x09, 0x09, 0x09, 0x0C, 0x0E, 0x11, 0x13, 0x13, 
+0x13, 0x09, 0x09, 0x09, 0x09, 0x0C, 0x0E, 0x11, 0x13, 0x13, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x24, 0x26, 0x2A, 0x00, 0x00, 0x00, 0x1F, 0x21, 0x25, 0x27, 0x28, 0x00, 
+0x00, 0x00, 0x00, 0x23, 0x26, 0x28, 0x2A, 0x00, 0x00, 0x00, 0x00, 0x23, 0x26, 0x28, 0x2A, 0x00, 
+0x00, 0x00, 0x00, 0x23, 0x26, 0x28, 0x2A, 0x00, 0x00, 0x00, 0x00, 0x20, 0x25, 0x27, 0x29, 0x29, 
+0x2A, 0x00, 0x00, 0x00, 0x00, 0x20, 0x25, 0x27, 0x29, 0x29, 0x2A, 0x00, 0x00, 0x00, 0x00, 0x23, 
+0x26, 0x28, 0x2A, 0x2A, 0x2A, 0x00, 0x00, 0x00, 0x1F, 0x23, 0x26, 0x28, 0x2A, 0x2A, 0x2A, 0x00, 
+0x04, 0x00, 0x04, 0x00, 0x08, 0x00, 0x10, 0x00, 0x18, 0x00, 0x24, 0x00, 0x30, 0x00, 0x48, 0x00, 
+0x60, 0x00, 0x90, 0x00, 0xC0, 0x00, 0xD8, 0x00, 0x3C, 0x00, 0x64, 0x00, 0x78, 0x00, 0xA0, 0x00, 
+0xF0, 0x01, 0x40, 0x01, 0x90, 0x01, 0xE0, 0x00, 0xA0, 0x00, 0xF0, 0x01, 0x40, 0x01, 0x90, 0x02, 
+0x58, 0x03, 0x20, 0x04, 0xB0, 0x06, 0x40, 0x00, 0xC8, 0x01, 0x18, 0x01, 0xE0, 0x02, 0xD0, 0x03, 
+0xE8, 0x04, 0xB0, 0x06, 0x40, 0x07, 0xD0, 0x00, 0xC8, 0x01, 0x18, 0x01, 0xE0, 0x02, 0xD0, 0x03, 
+0xE8, 0x04, 0xB0, 0x06, 0x40, 0x07, 0xD0, 0x00, 0x3C, 0x00, 0x50, 0x00, 0x64, 0x00, 0xA0, 0x00, 
+0xF0, 0x01, 0x40, 0x01, 0x90, 0x01, 0xE0, 0x02, 0x58, 0x03, 0x20, 0x00, 0x78, 0x00, 0xF0, 0x01, 
+0x90, 0x02, 0x58, 0x03, 0xE8, 0x07, 0xD0, 0x09, 0x60, 0x0F, 0xA0, 0x12, 0xC0, 0x15, 0x18, 0x00, 
+0xC8, 0x01, 0x18, 0x01, 0xE0, 0x02, 0xD0, 0x03, 0xE8, 0x04, 0xB0, 0x06, 0x40, 0x07, 0xD0, 0x07, 
+0xD0, 0x07, 0xD0, 0x00, 0xC8, 0x01, 0x18, 0x01, 0xE0, 0x02, 0xD0, 0x03, 0xE8, 0x04, 0xB0, 0x06, 
+0x40, 0x07, 0xD0, 0x07, 0xD0, 0x07, 0xD0, 0x00, 0x02, 0x00, 0x02, 0x00, 0x04, 0x00, 0x08, 0x00, 
+0x0C, 0x00, 0x12, 0x00, 0x18, 0x00, 0x24, 0x00, 0x30, 0x00, 0x48, 0x00, 0x60, 0x00, 0x6C, 0x00, 
+0x14, 0x00, 0x32, 0x00, 0x3C, 0x00, 0x50, 0x00, 0x78, 0x00, 0xA0, 0x00, 0xC8, 0x00, 0xF0, 0x00, 
+0x50, 0x00, 0x78, 0x00, 0xA0, 0x00, 0xC8, 0x01, 0x2C, 0x01, 0x90, 0x02, 0x58, 0x03, 0x20, 0x00, 
+0x64, 0x00, 0x8C, 0x00, 0xF0, 0x01, 0x68, 0x01, 0xF4, 0x02, 0x58, 0x03, 0x20, 0x03, 0xE8, 0x00, 
+0x64, 0x00, 0x8C, 0x00, 0xF0, 0x01, 0x68, 0x01, 0xF4, 0x02, 0x58, 0x03, 0x20, 0x03, 0xE8, 0x00, 
+0x1E, 0x00, 0x28, 0x00, 0x32, 0x00, 0x50, 0x00, 0x78, 0x00, 0xA0, 0x00, 0xC8, 0x00, 0xF0, 0x01, 
+0x2C, 0x01, 0x90, 0x00, 0x3C, 0x00, 0x78, 0x00, 0xC8, 0x01, 0x2C, 0x01, 0xF4, 0x03, 0xE8, 0x04, 
+0xB0, 0x07, 0xD0, 0x09, 0x60, 0x0A, 0xF0, 0x00, 0x64, 0x00, 0x8C, 0x00, 0xF0, 0x01, 0x68, 0x01, 
+0xF4, 0x02, 0x58, 0x03, 0x20, 0x03, 0xE8, 0x03, 0xE8, 0x03, 0xE8, 0x00, 0x64, 0x00, 0x8C, 0x00, 
+0xF0, 0x01, 0x68, 0x01, 0xF4, 0x02, 0x58, 0x03, 0x20, 0x03, 0xE8, 0x03, 0xE8, 0x03, 0xE8, 0x02, 
+0x04, 0x06, 0x08, 0x0A, 0x0C, 0x10, 0x18, 0x20, 0x30, 0x40, 0x50, 0x01, 0x01, 0x01, 0x02, 0x01, 
+0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x02, 0x04, 0x06, 0x07, 0x07, 0x08, 0x08, 0x08, 0x02, 
+0x02, 0x03, 0x03, 0x05, 0x05, 0x06, 0x06, 0x05, 0x06, 0x06, 0x07, 0x07, 0x08, 0x09, 0x0A, 0x05, 
+0x06, 0x06, 0x07, 0x07, 0x08, 0x09, 0x0A, 0x05, 0x06, 0x06, 0x07, 0x07, 0x08, 0x09, 0x0A, 0x0A, 
+0x0B, 0x05, 0x06, 0x06, 0x07, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0B, 0x05, 0x06, 0x06, 0x07, 0x07, 
+0x08, 0x09, 0x0A, 0x0A, 0x0B, 0x05, 0x06, 0x06, 0x07, 0x07, 0x08, 0x09, 0x0A, 0x0A, 0x0B, 0x01, 
+0x01, 0x01, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 
+0x06, 0x07, 0x08, 0x02, 0x04, 0x06, 0x07, 0x08, 0x0A, 0x0B, 0x0C, 0x03, 0x05, 0x06, 0x07, 0x08, 
+0x0A, 0x0B, 0x0C, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x02, 0x04, 0x06, 0x07, 0x08, 
+0x09, 0x0B, 0x0C, 0x0C, 0x0C, 0x03, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0B, 0x0C, 0x0C, 0x0C, 0x05, 
+0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0C, 0x0C, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 
+0x0C, 0x0C, 0x0C, 0x19, 0x06, 0x04, 0x02, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0xC2, 0xAF, 0x80, 0xFE, 0x32, 0x12, 0x45, 0xC4, 0x85, 0xD0, 0x0B, 0x75, 0xD0, 0x08, 0xAA, 0xE0, 
+0xC2, 0x8C, 0xE5, 0x8A, 0x24, 0x67, 0xF5, 0x8A, 0xE5, 0x8C, 0x34, 0x79, 0xF5, 0x8C, 0xD2, 0x8C, 
+0xEC, 0x24, 0x87, 0xF8, 0xE6, 0xBC, 0x02, 0x02, 0x74, 0xFF, 0xC3, 0x95, 0x81, 0xB4, 0x40, 0x00, 
+0x40, 0xCE, 0x79, 0x03, 0x78, 0x80, 0x16, 0xE6, 0x08, 0x70, 0x0B, 0xC2, 0xAF, 0xE6, 0x30, 0xE1, 
+0x03, 0x44, 0x18, 0xF6, 0xD2, 0xAF, 0x08, 0xD9, 0xED, 0xEA, 0x8B, 0xD0, 0x22, 0xE5, 0x0C, 0xFF, 
+0x23, 0x24, 0x81, 0xF8, 0x0F, 0x08, 0x08, 0xBF, 0x03, 0x04, 0x7F, 0x00, 0x78, 0x81, 0xE6, 0x30, 
+0xE4, 0xF2, 0x00, 0xE5, 0x0C, 0xC3, 0x9F, 0x50, 0x20, 0x05, 0x0C, 0x74, 0x86, 0x25, 0x0C, 0xF8, 
+0xE6, 0xFD, 0xA6, 0x81, 0x08, 0xE6, 0xAE, 0x0C, 0xBE, 0x02, 0x02, 0x74, 0xFF, 0xCD, 0xF8, 0xE8, 
+0x6D, 0x60, 0xE0, 0x08, 0xE6, 0xC0, 0xE0, 0x80, 0xF6, 0xE5, 0x0C, 0xD3, 0x9F, 0x40, 0x27, 0xE5, 
+0x0C, 0x24, 0x87, 0xF8, 0xE6, 0xAE, 0x0C, 0xBE, 0x02, 0x02, 0x74, 0xFF, 0xFD, 0x18, 0xE6, 0xCD, 
+0xF8, 0xE5, 0x81, 0x6D, 0x60, 0x06, 0xD0, 0xE0, 0xF6, 0x18, 0x80, 0xF5, 0xE5, 0x0C, 0x24, 0x86, 
+0xC8, 0xF6, 0x15, 0x0C, 0x80, 0xD3, 0xE5, 0x0C, 0x23, 0x24, 0x81, 0xF8, 0x7F, 0x04, 0xC2, 0xAF, 
+0xE6, 0x30, 0xE0, 0x03, 0x10, 0xE2, 0x0C, 0x7F, 0x00, 0x30, 0xE1, 0x07, 0x30, 0xE3, 0x04, 0x7F, 
+0x08, 0x54, 0xF4, 0x54, 0x7C, 0xC6, 0xD2, 0xAF, 0x54, 0x80, 0x42, 0x07, 0x22, 0x78, 0x86, 0xA6, 
+0x81, 0x74, 0x02, 0x60, 0x06, 0xFF, 0x08, 0x76, 0xFF, 0xDF, 0xFB, 0x7F, 0x03, 0xE4, 0x78, 0x80, 
+0xF6, 0x08, 0xF6, 0x08, 0xDF, 0xFA, 0x78, 0x81, 0x76, 0x30, 0x90, 0x49, 0x9F, 0x74, 0x01, 0x93, 
+0xC0, 0xE0, 0xE4, 0x93, 0xC0, 0xE0, 0x43, 0x89, 0x01, 0x75, 0x8A, 0x60, 0x75, 0x8C, 0x79, 0xD2, 
+0x8C, 0xD2, 0xAF, 0x22, 0x02, 0xEF, 0xD3, 0x94, 0x02, 0x40, 0x03, 0x7F, 0xFF, 0x22, 0x74, 0x81, 
+0x2F, 0x2F, 0xF8, 0xE6, 0x20, 0xE5, 0xF4, 0xC2, 0xAF, 0xE6, 0x44, 0x30, 0xF6, 0xD2, 0xAF, 0xAE, 
+0x0C, 0xEE, 0xC3, 0x9F, 0x50, 0x21, 0x0E, 0x74, 0x86, 0x2E, 0xF8, 0xE6, 0xF9, 0x08, 0xE6, 0x18, 
+0xBE, 0x02, 0x02, 0x74, 0xFF, 0xFD, 0xED, 0x69, 0x60, 0x09, 0x09, 0xE7, 0x19, 0x19, 0xF7, 0x09, 
+0x09, 0x80, 0xF3, 0x16, 0x16, 0x80, 0xDA, 0xEE, 0xD3, 0x9F, 0x40, 0x04, 0x05, 0x81, 0x05, 0x81, 
+0xEE, 0xD3, 0x9F, 0x40, 0x22, 0x74, 0x86, 0x2E, 0xF8, 0x08, 0xE6, 0xF9, 0xEE, 0xB5, 0x0C, 0x02, 
+0xA9, 0x81, 0x18, 0x06, 0x06, 0xE6, 0xFD, 0xED, 0x69, 0x60, 0x09, 0x19, 0x19, 0xE7, 0x09, 0x09, 
+0xF7, 0x19, 0x80, 0xF3, 0x1E, 0x80, 0xD9, 0xEF, 0x24, 0x86, 0xF8, 0xE6, 0x04, 0xF8, 0xEF, 0x2F, 
+0x04, 0x90, 0x49, 0x9F, 0x93, 0xF6, 0x08, 0xEF, 0x2F, 0x93, 0xF6, 0x7F, 0x00, 0x22, 0xEF, 0xD3, 
+0x94, 0x02, 0x40, 0x03, 0x7F, 0xFF, 0x22, 0xEF, 0x23, 0x24, 0x81, 0xF8, 0xE6, 0x30, 0xE5, 0xF4, 
+0xC2, 0xAF, 0xE6, 0x54, 0x8C, 0xF6, 0xD2, 0xAF, 0xE5, 0x0C, 0xB5, 0x07, 0x0A, 0x74, 0x86, 0x2F, 
+0xF8, 0xE6, 0xF5, 0x81, 0x02, 0x46, 0x0D, 0x50, 0x2E, 0x74, 0x87, 0x2F, 0xF8, 0xE6, 0xBF, 0x02, 
+0x02, 0x74, 0xFF, 0xFD, 0x18, 0xE6, 0xF9, 0x74, 0x86, 0x2F, 0xF8, 0xFB, 0xE6, 0xFC, 0xE9, 0x6C, 
+0x60, 0x08, 0xA8, 0x05, 0xE7, 0xF6, 0x1D, 0x19, 0x80, 0xF4, 0xA8, 0x03, 0xA6, 0x05, 0x1F, 0xE5, 
+0x0C, 0xB5, 0x07, 0xE3, 0x7F, 0x00, 0x22, 0x74, 0x87, 0x2F, 0xF8, 0xE6, 0xFD, 0x18, 0x86, 0x01, 
+0x0F, 0x74, 0x86, 0x2F, 0xF8, 0xA6, 0x01, 0x08, 0x86, 0x04, 0xE5, 0x0C, 0xB5, 0x07, 0x02, 0xAC, 
+0x81, 0xED, 0x6C, 0x60, 0x08, 0x0D, 0x09, 0xA8, 0x05, 0xE6, 0xF7, 0x80, 0xF4, 0xE5, 0x0C, 0xB5, 
+0x07, 0xDE, 0x89, 0x81, 0x7F, 0x00, 0x22, 0xEF, 0xD3, 0x94, 0x02, 0x40, 0x03, 0x7F, 0xFF, 0x22, 
+0xEF, 0x23, 0x24, 0x81, 0xF8, 0xC2, 0xAF, 0xE6, 0x30, 0xE5, 0x05, 0x30, 0xE0, 0x02, 0xD2, 0xE4, 
+0xD2, 0xE2, 0xC6, 0xD2, 0xAF, 0x7F, 0x00, 0x30, 0xE2, 0x01, 0x0F, 0x02, 0x46, 0x0C, 0x8F, 0xF0, 
+0xE4, 0xFF, 0xFE, 0xE5, 0x0C, 0x23, 0x24, 0x80, 0xF8, 0xC2, 0xA9, 0x30, 0xF7, 0x0D, 0x7F, 0x08, 
+0xE6, 0x60, 0x0B, 0x2D, 0xF6, 0x60, 0x32, 0x50, 0x30, 0x80, 0x07, 0x30, 0xF1, 0x06, 0xED, 0xF6, 
+0x60, 0x27, 0x7E, 0x02, 0x08, 0x30, 0xF0, 0x10, 0xC2, 0xAF, 0xE6, 0x10, 0xE7, 0x25, 0x0E, 0x30, 
+0xE2, 0x0C, 0xD2, 0xAF, 0x7F, 0x04, 0x80, 0x14, 0xC2, 0xAF, 0xE6, 0x10, 0xE7, 0x15, 0x54, 0xEC, 
+0x4E, 0xF6, 0xD2, 0xAF, 0xD2, 0xA9, 0x02, 0x46, 0x0D, 0x7F, 0x08, 0x08, 0xEF, 0x44, 0x83, 0xF4, 
+0xC2, 0xAF, 0x56, 0xC6, 0xD2, 0xAF, 0xD2, 0xA9, 0x54, 0x80, 0x4F, 0xFF, 0x22, 0xEF, 0x2B, 0xFF, 
+0xEE, 0x3A, 0xFE, 0xED, 0x39, 0xFD, 0xEC, 0x38, 0xFC, 0x22, 0xEF, 0x5B, 0xFF, 0xEE, 0x5A, 0xFE, 
+0xED, 0x59, 0xFD, 0xEC, 0x58, 0xFC, 0x22, 0xEF, 0x4B, 0xFF, 0xEE, 0x4A, 0xFE, 0xED, 0x49, 0xFD, 
+0xEC, 0x48, 0xFC, 0x22, 0xEB, 0x9F, 0xF5, 0xF0, 0xEA, 0x9E, 0x42, 0xF0, 0xE9, 0x9D, 0x42, 0xF0, 
+0xE8, 0x9C, 0x45, 0xF0, 0x22, 0xE0, 0xFC, 0xA3, 0xE0, 0xFD, 0xA3, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 
+0x22, 0xE0, 0xF8, 0xA3, 0xE0, 0xF9, 0xA3, 0xE0, 0xFA, 0xA3, 0xE0, 0xFB, 0x22, 0xA4, 0x25, 0x82, 
+0xF5, 0x82, 0xE5, 0xF0, 0x35, 0x83, 0xF5, 0x83, 0x22, 0xE0, 0xFB, 0xA3, 0xE0, 0xFA, 0xA3, 0xE0, 
+0xF9, 0x22, 0xEB, 0xF0, 0xA3, 0xEA, 0xF0, 0xA3, 0xE9, 0xF0, 0x22, 0xD0, 0x83, 0xD0, 0x82, 0xF8, 
+0xE4, 0x93, 0x70, 0x12, 0x74, 0x01, 0x93, 0x70, 0x0D, 0xA3, 0xA3, 0x93, 0xF8, 0x74, 0x01, 0x93, 
+0xF5, 0x82, 0x88, 0x83, 0xE4, 0x73, 0x74, 0x02, 0x93, 0x68, 0x60, 0xEF, 0xA3, 0xA3, 0xA3, 0x80, 
+0xDF, 0x02, 0x49, 0x3F, 0x02, 0x46, 0x9D, 0xE4, 0x93, 0xA3, 0xF8, 0xE4, 0x93, 0xA3, 0x40, 0x03, 
+0xF6, 0x80, 0x01, 0xF2, 0x08, 0xDF, 0xF4, 0x80, 0x29, 0xE4, 0x93, 0xA3, 0xF8, 0x54, 0x07, 0x24, 
+0x0C, 0xC8, 0xC3, 0x33, 0xC4, 0x54, 0x0F, 0x44, 0x20, 0xC8, 0x83, 0x40, 0x04, 0xF4, 0x56, 0x80, 
+0x01, 0x46, 0xF6, 0xDF, 0xE4, 0x80, 0x0B, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x90, 
+0x49, 0x84, 0xE4, 0x7E, 0x01, 0x93, 0x60, 0xBC, 0xA3, 0xFF, 0x54, 0x3F, 0x30, 0xE5, 0x09, 0x54, 
+0x1F, 0xFE, 0xE4, 0x93, 0xA3, 0x60, 0x01, 0x0E, 0xCF, 0x54, 0xC0, 0x25, 0xE0, 0x60, 0xA8, 0x40, 
+0xB8, 0xE4, 0x93, 0xA3, 0xFA, 0xE4, 0x93, 0xA3, 0xF8, 0xE4, 0x93, 0xA3, 0xC8, 0xC5, 0x82, 0xC8, 
+0xCA, 0xC5, 0x83, 0xCA, 0xF0, 0xA3, 0xC8, 0xC5, 0x82, 0xC8, 0xCA, 0xC5, 0x83, 0xCA, 0xDF, 0xE9, 
+0xDE, 0xE7, 0x80, 0xBE, 0x41, 0xA4, 0xED, 0x00, 0x41, 0xA4, 0xEE, 0x00, 0x44, 0xA4, 0xBB, 0x41, 
+0x4E, 0x59, 0x00, 0x44, 0xA4, 0xB7, 0x61, 0x6E, 0x79, 0x00, 0x41, 0xA4, 0xFB, 0x00, 0x00, 0x4B, 
+0xC6, 0x58, 0xA7, 0x58, 0xCE, 0xE4, 0xFD, 0x7F, 0x8D, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 
+0x8F, 0x82, 0x75, 0x83, 0x00, 0xED, 0xF1, 0xFC, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xD3, 0x10, 0xAF, 
+0x01, 0xC3, 0xC0, 0xD0, 0x90, 0xA4, 0xF6, 0xED, 0xF0, 0x90, 0xA4, 0xF5, 0xEF, 0xF0, 0xD3, 0x94, 
+0x07, 0x50, 0x41, 0x7F, 0x47, 0x51, 0x62, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0xF4, 0x5F, 0xFD, 
+0x7F, 0x47, 0x31, 0xA9, 0x7F, 0x46, 0x51, 0x62, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0x4F, 0xFD, 
+0x7F, 0x46, 0xF1, 0xD2, 0x60, 0x0D, 0x7F, 0x45, 0x51, 0x62, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 
+0x4F, 0x80, 0x0C, 0x7F, 0x45, 0x51, 0x62, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0xF4, 0x5F, 0xFD, 
+0x7F, 0x45, 0x80, 0x45, 0x90, 0xA4, 0xF5, 0xE0, 0x24, 0xF8, 0xF0, 0x7F, 0x63, 0x51, 0x62, 0x80, 
+0x02, 0xC3, 0x33, 0xD8, 0xFC, 0xF4, 0x5F, 0xFD, 0x7F, 0x63, 0x31, 0xA9, 0x7F, 0x62, 0x51, 0x62, 
+0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0x4F, 0xFD, 0x7F, 0x62, 0xF1, 0xD2, 0x60, 0x0E, 0x51, 0x60, 
+0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0x4F, 0xFD, 0x7F, 0x61, 0x80, 0x0D, 0x51, 0x60, 0x80, 0x02, 
+0xC3, 0x33, 0xD8, 0xFC, 0xF4, 0x5F, 0xFD, 0x7F, 0x61, 0x31, 0xA9, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 
+0x7F, 0x61, 0x51, 0x6F, 0x90, 0xA4, 0xF5, 0xE0, 0xFE, 0x74, 0x01, 0xA8, 0x06, 0x08, 0x22, 0xD3, 
+0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x8F, 0x82, 0x75, 0x83, 0x00, 0xE0, 0x90, 0xA4, 0xF7, 0xF1, 
+0xFC, 0x90, 0xA4, 0xF7, 0xE0, 0xFF, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 
+0xC0, 0xD0, 0x91, 0x70, 0x20, 0xE6, 0x02, 0x61, 0x44, 0x90, 0x00, 0x8C, 0xE0, 0xF5, 0x26, 0x7F, 
+0x8D, 0x51, 0x6F, 0x90, 0x00, 0x8E, 0xE0, 0xF5, 0x27, 0xEF, 0x24, 0xFC, 0x60, 0x0C, 0x24, 0x03, 
+0x60, 0x02, 0x61, 0x3D, 0xAF, 0x26, 0x91, 0x20, 0x61, 0x3D, 0x74, 0x15, 0x25, 0x26, 0xF1, 0xF2, 
+0xE0, 0xFB, 0xE4, 0xFD, 0x71, 0x7D, 0x91, 0x7C, 0x13, 0x13, 0x71, 0x78, 0x91, 0x7C, 0xF1, 0xDC, 
+0x71, 0x7A, 0x91, 0x7C, 0xC4, 0x71, 0x78, 0x12, 0x75, 0x14, 0xE0, 0xFB, 0xE4, 0xFD, 0x0F, 0x71, 
+0x7E, 0xF1, 0xE8, 0xE0, 0xFB, 0x0D, 0x71, 0x7E, 0xF1, 0x55, 0xC4, 0x13, 0x54, 0x01, 0xFB, 0x0D, 
+0x7F, 0x01, 0x71, 0x7E, 0xF1, 0x55, 0x54, 0x1F, 0x71, 0x70, 0xE5, 0x26, 0x90, 0x89, 0x00, 0x12, 
+0x7C, 0x1A, 0x71, 0x72, 0xE5, 0x26, 0x90, 0x89, 0x01, 0x71, 0x6D, 0xE5, 0x26, 0x90, 0x89, 0x02, 
+0x71, 0x6D, 0xE5, 0x26, 0x90, 0x89, 0x03, 0x71, 0x6D, 0xE5, 0x26, 0x90, 0x89, 0x04, 0x12, 0x7C, 
+0x1A, 0x71, 0x72, 0xE5, 0x26, 0x90, 0x89, 0x05, 0x71, 0x6D, 0xE5, 0x26, 0x90, 0x89, 0x06, 0x71, 
+0x6D, 0xE5, 0x26, 0x90, 0x89, 0x07, 0x11, 0xBD, 0xE0, 0xFB, 0x0D, 0x71, 0x49, 0x91, 0x70, 0x30, 
+0xE0, 0x02, 0x31, 0xA5, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xEF, 0x70, 0x04, 0x74, 0xF0, 0x80, 0x16, 
+0xEF, 0xB4, 0x01, 0x04, 0x74, 0xF4, 0x80, 0x0E, 0xEF, 0xB4, 0x02, 0x04, 0x74, 0xF8, 0x80, 0x06, 
+0xEF, 0xB4, 0x03, 0x08, 0x74, 0xFC, 0x2D, 0x12, 0x6E, 0x34, 0xEB, 0xF0, 0x22, 0x11, 0xBD, 0xE0, 
+0xFB, 0x0D, 0x71, 0x49, 0x75, 0xF0, 0x08, 0x22, 0x54, 0x03, 0xFB, 0x0D, 0xE4, 0xFF, 0x71, 0x49, 
+0x75, 0xF0, 0x04, 0xE5, 0x26, 0x22, 0x7F, 0x54, 0x51, 0x6F, 0xE5, 0x0D, 0x5F, 0xF5, 0x11, 0x7F, 
+0x55, 0x51, 0x6F, 0xE5, 0x0E, 0x5F, 0xF5, 0x12, 0x7F, 0x56, 0x51, 0x6F, 0xE5, 0x0F, 0x5F, 0xF5, 
+0x13, 0x7F, 0x57, 0x51, 0x6F, 0xE5, 0x10, 0x5F, 0xF5, 0x14, 0xAD, 0x11, 0x7F, 0x54, 0x31, 0xA9, 
+0xAD, 0x12, 0x7F, 0x55, 0x31, 0xA9, 0xAD, 0x13, 0x7F, 0x56, 0x31, 0xA9, 0xAD, 0x14, 0x7F, 0x57, 
+0x31, 0xA9, 0x53, 0x91, 0xEF, 0x22, 0x7F, 0x81, 0x51, 0x6F, 0xEF, 0x54, 0xFE, 0xFD, 0x7F, 0x81, 
+0x31, 0xA9, 0x7F, 0x80, 0x12, 0x60, 0x4A, 0x7F, 0x80, 0x31, 0xA9, 0x12, 0x6E, 0x3C, 0x12, 0x3D, 
+0x3B, 0x12, 0x6E, 0x49, 0x12, 0x6E, 0x67, 0x7F, 0x01, 0x12, 0x46, 0xD5, 0x7F, 0x02, 0x12, 0x46, 
+0xD5, 0x12, 0x58, 0x15, 0x12, 0x67, 0xA9, 0x7F, 0x80, 0x51, 0x6F, 0xEF, 0x44, 0x40, 0xFD, 0x7F, 
+0x80, 0x31, 0xA9, 0x75, 0x28, 0xFF, 0x12, 0x58, 0xA0, 0x12, 0x68, 0xD7, 0x7F, 0x81, 0x51, 0x6F, 
+0xEF, 0x44, 0x04, 0xFD, 0x7F, 0x81, 0x31, 0xA9, 0x12, 0x6E, 0x6E, 0xE4, 0xFF, 0x02, 0x47, 0x5E, 
+0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0xA4, 0xF3, 0xEF, 0xF0, 0x91, 0x70, 0x30, 0xE6, 
+0x3A, 0x7F, 0x8D, 0x51, 0x6F, 0xEF, 0x64, 0x01, 0x70, 0x31, 0x90, 0xA4, 0xF4, 0xF0, 0x90, 0xA4, 
+0xF4, 0xE0, 0xFD, 0x90, 0xA4, 0xF3, 0xE0, 0x75, 0xF0, 0x10, 0x12, 0x53, 0xA8, 0xE5, 0x82, 0x2D, 
+0xF1, 0x73, 0xE0, 0xFB, 0xE4, 0xFF, 0x71, 0x49, 0x90, 0xA4, 0xF4, 0xE0, 0x04, 0xF0, 0xE0, 0xC3, 
+0x94, 0x10, 0x40, 0xDA, 0x91, 0x70, 0x30, 0xE0, 0x02, 0x31, 0xA5, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 
+0x7F, 0x8F, 0x51, 0x6F, 0xEF, 0x22, 0xFF, 0x75, 0xF0, 0x04, 0xE5, 0x51, 0x90, 0x96, 0x18, 0x11, 
+0xBD, 0xE0, 0x22, 0x12, 0x06, 0x89, 0x54, 0x7F, 0xF5, 0x51, 0x12, 0x57, 0xA2, 0xFF, 0x54, 0x1F, 
+0xF5, 0x53, 0xF1, 0xD9, 0xF5, 0x52, 0xF1, 0x5D, 0xFF, 0x54, 0x03, 0xF5, 0x54, 0xEF, 0x54, 0x30, 
+0xC4, 0x54, 0x0F, 0xF5, 0x57, 0xF1, 0x5D, 0xFF, 0x54, 0x40, 0xC4, 0x13, 0x13, 0x54, 0x03, 0xF5, 
+0x55, 0xF1, 0xD9, 0xF5, 0x56, 0xF1, 0x5D, 0xFF, 0x54, 0x08, 0x13, 0x13, 0x13, 0x54, 0x1F, 0xF5, 
+0x59, 0xEF, 0x54, 0x04, 0x13, 0x13, 0x54, 0x3F, 0xF5, 0x5A, 0xE5, 0x56, 0x54, 0x01, 0xC4, 0x33, 
+0x33, 0x33, 0x54, 0x80, 0x91, 0x76, 0x54, 0x7F, 0x4F, 0xF0, 0xE5, 0x55, 0x54, 0x01, 0xC4, 0x33, 
+0x33, 0x54, 0xC0, 0x91, 0x76, 0x54, 0xBF, 0x4F, 0xF0, 0xE5, 0x59, 0x60, 0x02, 0xA1, 0x7B, 0xE5, 
+0x53, 0x54, 0x1F, 0xFF, 0x75, 0xF0, 0x04, 0xE5, 0x51, 0xF1, 0x55, 0x54, 0xE0, 0x4F, 0xF0, 0xE5, 
+0x54, 0x54, 0x03, 0x91, 0x76, 0x54, 0xFC, 0x4F, 0xF0, 0xEF, 0x25, 0xE0, 0x25, 0xE0, 0x91, 0x76, 
+0x54, 0xF3, 0x4F, 0xF0, 0xE5, 0x52, 0x54, 0x01, 0xC4, 0x33, 0x54, 0xE0, 0xFF, 0x75, 0xF0, 0x04, 
+0xE5, 0x51, 0xF1, 0x55, 0x54, 0xDF, 0x4F, 0xF0, 0xE5, 0x57, 0x54, 0x03, 0xC4, 0x54, 0xF0, 0x91, 
+0x76, 0x54, 0xCF, 0x4F, 0xF0, 0x74, 0x95, 0x25, 0x51, 0xB1, 0x83, 0xE0, 0x54, 0xFB, 0xF0, 0x74, 
+0x95, 0x25, 0x51, 0xB1, 0x83, 0xE0, 0xFF, 0xE5, 0x5A, 0x25, 0xE0, 0x25, 0xE0, 0xFE, 0xEF, 0x4E, 
+0xF0, 0xE4, 0xF5, 0x58, 0x85, 0x58, 0x82, 0x75, 0x83, 0x00, 0xA3, 0xA3, 0xA3, 0x12, 0x06, 0xA2, 
+0xFF, 0x75, 0xF0, 0x08, 0xE5, 0x51, 0x12, 0x56, 0xFE, 0x25, 0x58, 0xF1, 0x73, 0xEF, 0xF0, 0x05, 
+0x58, 0xE5, 0x58, 0xB4, 0x04, 0xDE, 0xAF, 0x51, 0x12, 0x55, 0x38, 0x22, 0xE4, 0xF5, 0x61, 0x74, 
+0x95, 0x25, 0x5B, 0xF5, 0x82, 0xE4, 0x34, 0x99, 0xF5, 0x83, 0x22, 0x12, 0x57, 0xDE, 0x12, 0x06, 
+0x89, 0xF5, 0x51, 0x24, 0x95, 0xB1, 0x83, 0xE0, 0x54, 0x9C, 0xF0, 0x74, 0x95, 0x25, 0x51, 0xB1, 
+0x83, 0xC0, 0x83, 0xC0, 0x82, 0xE0, 0xFF, 0xF1, 0x4C, 0x12, 0x7C, 0x23, 0xFE, 0xEF, 0x4E, 0xD0, 
+0x82, 0xD0, 0x83, 0xF0, 0x74, 0x95, 0x25, 0x51, 0xB1, 0x83, 0xC0, 0x83, 0xC0, 0x82, 0xE0, 0xFF, 
+0xF1, 0x4C, 0x90, 0x00, 0x03, 0x12, 0x06, 0xA2, 0x54, 0x02, 0xFE, 0xEF, 0x4E, 0xD0, 0x82, 0xD0, 
+0x83, 0xF0, 0x74, 0x95, 0x25, 0x51, 0xB1, 0x83, 0xC0, 0x83, 0xC0, 0x82, 0xE0, 0xFF, 0xF1, 0x4C, 
+0x90, 0x00, 0x03, 0x12, 0x06, 0xA2, 0x54, 0x40, 0xFE, 0xEF, 0x4E, 0xD0, 0x82, 0xD0, 0x83, 0xF0, 
+0x74, 0x95, 0x25, 0x51, 0xB1, 0x83, 0xC0, 0x83, 0xC0, 0x82, 0xE0, 0xFF, 0xF1, 0x4C, 0x90, 0x00, 
+0x03, 0x12, 0x06, 0xA2, 0x54, 0x20, 0xFE, 0xEF, 0x4E, 0xD0, 0x82, 0xD0, 0x83, 0xF0, 0xE5, 0x51, 
+0xC3, 0x94, 0x80, 0x50, 0x06, 0xF1, 0x5D, 0xF1, 0xED, 0xEF, 0xF0, 0x74, 0x95, 0x25, 0x51, 0xB1, 
+0x83, 0xE0, 0x30, 0xE5, 0x10, 0x91, 0x77, 0x13, 0x13, 0x54, 0x03, 0xFB, 0xF1, 0xEE, 0xE0, 0xFD, 
+0xAF, 0x51, 0x12, 0x75, 0x61, 0x22, 0xE4, 0xFF, 0xE4, 0xFE, 0x74, 0x95, 0x2F, 0xB1, 0x83, 0xE0, 
+0x54, 0xFE, 0xF0, 0x75, 0xF0, 0x10, 0xEF, 0x90, 0x81, 0x00, 0xBE, 0x03, 0x0C, 0x11, 0xBD, 0xE5, 
+0x82, 0x2E, 0xF1, 0x73, 0x74, 0x80, 0xF0, 0x80, 0x09, 0x11, 0xBD, 0xE5, 0x82, 0x2E, 0xF1, 0x73, 
+0xE4, 0xF0, 0x75, 0xF0, 0x08, 0xEF, 0x12, 0x56, 0xFE, 0x2E, 0xF1, 0x73, 0xE4, 0xF0, 0x0E, 0xBE, 
+0x10, 0xC8, 0x0F, 0xBF, 0x80, 0xC2, 0xE4, 0x90, 0xAD, 0xE2, 0xF0, 0x90, 0x94, 0x91, 0x12, 0x08, 
+0x79, 0x00, 0x00, 0x00, 0x00, 0xE4, 0xFF, 0xE4, 0xFE, 0x75, 0xF0, 0x0A, 0xEF, 0x12, 0x62, 0xB8, 
+0x75, 0xF0, 0x02, 0xEE, 0x12, 0x64, 0xE0, 0xF0, 0x0E, 0xBE, 0x05, 0xED, 0x74, 0x15, 0x2F, 0x12, 
+0x57, 0xD2, 0xE4, 0x12, 0x63, 0x50, 0x34, 0x92, 0x12, 0x52, 0xDB, 0x12, 0x66, 0x62, 0xE4, 0xF0, 
+0xEF, 0x12, 0x53, 0x78, 0x12, 0x52, 0xDB, 0xEF, 0x12, 0x53, 0x69, 0x12, 0x52, 0xCB, 0xEF, 0x12, 
+0x53, 0x96, 0x12, 0x52, 0xDB, 0x12, 0x75, 0x10, 0x74, 0x3F, 0xF1, 0xE3, 0xE4, 0xF0, 0xF1, 0x51, 
+0x54, 0xE0, 0x44, 0x09, 0xF0, 0x75, 0xF0, 0x04, 0xEF, 0x91, 0x7C, 0x54, 0xF3, 0xF0, 0x75, 0xF0, 
+0x04, 0xEF, 0x91, 0x7C, 0x54, 0xFC, 0xF0, 0xF1, 0x51, 0x44, 0x20, 0xF0, 0x75, 0xF0, 0x04, 0xEF, 
+0x91, 0x7C, 0x54, 0xCF, 0xF0, 0x75, 0xF0, 0x04, 0xEF, 0x91, 0x7C, 0x44, 0x40, 0xF0, 0x75, 0xF0, 
+0x04, 0xEF, 0x91, 0x7C, 0x54, 0x7F, 0xF1, 0xE3, 0xE0, 0xFE, 0x75, 0xF0, 0x10, 0xEF, 0x12, 0x53, 
+0xA8, 0xEE, 0xF0, 0x74, 0x95, 0x2F, 0xB1, 0x83, 0xE4, 0xF0, 0x0F, 0xEF, 0x64, 0x80, 0x60, 0x02, 
+0xC1, 0x87, 0x90, 0x04, 0x49, 0x74, 0xF0, 0xF0, 0xA3, 0xE4, 0xF0, 0xA3, 0x74, 0xFF, 0xF0, 0x90, 
+0x04, 0x33, 0x74, 0x02, 0xF0, 0xA3, 0x74, 0x04, 0xF0, 0xA3, 0x04, 0xF0, 0xA3, 0x04, 0xF0, 0xA3, 
+0x04, 0xF0, 0x74, 0x15, 0x2F, 0x12, 0x76, 0x2E, 0x74, 0xFF, 0xF0, 0x22, 0x90, 0xA3, 0xD1, 0x01, 
+0xC9, 0x75, 0xF0, 0x04, 0xEF, 0x90, 0x96, 0x17, 0x11, 0xBD, 0xE0, 0x22, 0xF0, 0x90, 0x00, 0x02, 
+0x02, 0x06, 0xA2, 0xFF, 0x90, 0xA4, 0xEA, 0xE0, 0x75, 0xF0, 0x08, 0x90, 0x89, 0x00, 0x11, 0xBD, 
+0xE5, 0x82, 0x2F, 0xF5, 0x82, 0xE4, 0x35, 0x83, 0xF5, 0x83, 0x22, 0x90, 0x01, 0x30, 0xE4, 0xF1, 
+0xCA, 0x90, 0x01, 0x38, 0xF1, 0xCA, 0xFD, 0x7F, 0x50, 0x31, 0xA9, 0xE4, 0xFD, 0x7F, 0x51, 0x31, 
+0xA9, 0xE4, 0xFD, 0x7F, 0x52, 0x31, 0xA9, 0xE4, 0xFD, 0x7F, 0x53, 0x21, 0xA9, 0x90, 0x01, 0x34, 
+0x74, 0xFF, 0xF1, 0xCA, 0x90, 0x01, 0x3C, 0xF1, 0xCA, 0xFD, 0x7F, 0x54, 0x31, 0xA9, 0x7D, 0xFF, 
+0x7F, 0x55, 0x31, 0xA9, 0x7D, 0xFF, 0x7F, 0x56, 0x31, 0xA9, 0x7D, 0xFF, 0x7F, 0x57, 0x21, 0xA9, 
+0xE4, 0x90, 0xA3, 0xD9, 0xF0, 0x90, 0xA4, 0x44, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0xA3, 
+0xF0, 0x22, 0x31, 0xA9, 0x90, 0xA4, 0xF6, 0xE0, 0x22, 0xEF, 0x54, 0x80, 0xC4, 0x13, 0x13, 0x13, 
+0x54, 0x01, 0x22, 0xF0, 0x75, 0xF0, 0x04, 0xEF, 0x90, 0x96, 0x16, 0x01, 0xBD, 0xFF, 0x74, 0x15, 
+0x25, 0x51, 0xF5, 0x82, 0xE4, 0x34, 0x9A, 0xF5, 0x83, 0x22, 0x41, 0x8B, 0xF0, 0x7F, 0x10, 0x7E, 
+0x00, 0x02, 0x3D, 0x7A, 0xE0, 0x90, 0xA4, 0xCB, 0xF0, 0xE4, 0xFB, 0xFD, 0x7F, 0x58, 0x7E, 0x01, 
+0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0xA4, 0xC6, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 
+0xA4, 0xCA, 0xE0, 0xF5, 0x3B, 0xA3, 0xE0, 0xF5, 0x3C, 0x12, 0x35, 0x7A, 0x90, 0xA4, 0xC6, 0x12, 
+0x6E, 0x03, 0xA3, 0xA3, 0xA3, 0x74, 0x05, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xAD, 0x07, 0x90, 
+0xA3, 0xC5, 0xE0, 0x75, 0xF0, 0x20, 0xA4, 0xFF, 0x90, 0xA4, 0xD2, 0xE5, 0xF0, 0xF0, 0xA3, 0xEF, 
+0xF0, 0x90, 0xA3, 0xC6, 0xE0, 0x75, 0xF0, 0x08, 0xA4, 0xAE, 0xF0, 0x90, 0xA4, 0xD4, 0xF0, 0xEE, 
+0xA3, 0xF0, 0x11, 0xD5, 0x90, 0xA4, 0xD6, 0xF0, 0xEE, 0xA3, 0xF0, 0xED, 0x64, 0x01, 0x60, 0x64, 
+0x90, 0xA3, 0xC3, 0xE0, 0xFE, 0x12, 0x4F, 0xDC, 0x30, 0xE0, 0x59, 0xEE, 0x11, 0xEA, 0x20, 0xE0, 
+0x02, 0x7D, 0x01, 0x11, 0xDD, 0xFE, 0x54, 0x0F, 0xFF, 0xEE, 0xC4, 0x13, 0x13, 0x54, 0x01, 0xFD, 
+0x11, 0xDD, 0xC4, 0x13, 0x54, 0x07, 0x30, 0xE0, 0x24, 0xA3, 0xE0, 0x30, 0xE0, 0x0F, 0x90, 0xA4, 
+0xD7, 0xE0, 0x90, 0xA4, 0xCA, 0xF0, 0x90, 0xA4, 0xD6, 0x11, 0x04, 0x80, 0x10, 0x11, 0xD5, 0xFF, 
+0x12, 0x3D, 0x7A, 0x11, 0xE5, 0x20, 0xE0, 0x02, 0x7D, 0x01, 0x12, 0x49, 0xBD, 0x90, 0xA3, 0xC3, 
+0xE0, 0xC4, 0x54, 0x0F, 0x30, 0xE0, 0x0D, 0x90, 0xA4, 0xD5, 0xE0, 0x90, 0xA4, 0xCA, 0xF0, 0x90, 
+0xA4, 0xD4, 0x11, 0x04, 0x22, 0x90, 0xA4, 0xD2, 0xE0, 0xFE, 0xA3, 0xE0, 0x22, 0x12, 0x49, 0xBD, 
+0x90, 0xA3, 0xC3, 0xE0, 0x22, 0x90, 0xA3, 0xC3, 0xE0, 0xFE, 0x54, 0x0F, 0xFF, 0xEE, 0xC4, 0x13, 
+0x13, 0x54, 0x03, 0x7D, 0x00, 0x22, 0x90, 0xA3, 0xC3, 0xE0, 0xFF, 0x12, 0x4F, 0xDC, 0x30, 0xE0, 
+0x1A, 0xEF, 0xC4, 0x54, 0x0F, 0x30, 0xE0, 0x02, 0x31, 0x1C, 0x90, 0xA3, 0xC4, 0xE0, 0x30, 0xE0, 
+0x0A, 0x11, 0xE5, 0x20, 0xE0, 0x02, 0x7D, 0x01, 0x12, 0x49, 0xBD, 0x22, 0xE4, 0x90, 0xA4, 0xA2, 
+0xF0, 0x90, 0xA4, 0xA0, 0x74, 0x14, 0xF0, 0x90, 0xA4, 0xAE, 0x74, 0x01, 0xF0, 0xFB, 0x7A, 0xA4, 
+0x79, 0xA0, 0x91, 0x14, 0x7F, 0x04, 0x90, 0xA4, 0xF8, 0xEF, 0xF0, 0x7F, 0x02, 0x12, 0x47, 0xE7, 
+0x90, 0xA2, 0x96, 0xE0, 0xFF, 0x90, 0xA4, 0xF8, 0xE0, 0xFE, 0xEF, 0x4E, 0x90, 0xA2, 0x96, 0xF0, 
+0x22, 0x12, 0x06, 0x89, 0x90, 0xA3, 0xD1, 0xF1, 0xA1, 0x90, 0xA3, 0xD2, 0x12, 0x4F, 0x5C, 0xFD, 
+0xE4, 0xFF, 0x74, 0xD5, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0xA3, 0xF5, 0x83, 0xE4, 0xF0, 0x0F, 0xEF, 
+0xB4, 0x0C, 0xEF, 0xED, 0x30, 0xE0, 0x46, 0x71, 0x82, 0x40, 0x42, 0xA3, 0xE0, 0xD3, 0x94, 0x80, 
+0x40, 0x3B, 0x90, 0xA3, 0xD5, 0x74, 0x01, 0x71, 0x60, 0x90, 0xA3, 0xD6, 0x71, 0x5F, 0x78, 0x08, 
+0x12, 0x08, 0x47, 0x90, 0xA3, 0xD7, 0x71, 0x5F, 0x78, 0x10, 0x12, 0x08, 0x47, 0x90, 0xA3, 0xD8, 
+0x71, 0x5F, 0x78, 0x18, 0x12, 0x08, 0x47, 0x90, 0xA3, 0xD9, 0xEF, 0xF0, 0x71, 0x8A, 0x74, 0x05, 
+0xF0, 0x90, 0x94, 0x91, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 0x00, 0x41, 0x9F, 0xED, 0x30, 0xE1, 
+0x54, 0x90, 0xA3, 0xD5, 0x74, 0x02, 0xF0, 0x71, 0x82, 0x50, 0x17, 0x71, 0x94, 0x51, 0xB9, 0x90, 
+0xA3, 0xD6, 0x51, 0xAB, 0x90, 0xA3, 0xD8, 0xF0, 0xEE, 0xA3, 0xF0, 0x90, 0xA3, 0xD1, 0x51, 0xC0, 
+0x80, 0x06, 0x90, 0xA3, 0xD6, 0x74, 0xEA, 0xF0, 0x90, 0xA3, 0xD2, 0xE0, 0xD3, 0x94, 0x80, 0x50, 
+0x17, 0x71, 0x94, 0x51, 0xB9, 0x90, 0xA3, 0xDA, 0x51, 0xAB, 0x90, 0xA3, 0xDC, 0xF0, 0xEE, 0xA3, 
+0xF0, 0x90, 0xA3, 0xD2, 0x51, 0xC0, 0x80, 0x06, 0x90, 0xA3, 0xDA, 0x74, 0xEA, 0xF0, 0x71, 0x8A, 
+0x74, 0x09, 0xF0, 0x41, 0x9F, 0xED, 0x70, 0x7C, 0x90, 0xA3, 0xD1, 0xE0, 0xFD, 0xD3, 0x94, 0x80, 
+0x50, 0x28, 0xE0, 0x90, 0xA3, 0xD5, 0xF0, 0x71, 0x69, 0x51, 0xB9, 0x90, 0xA3, 0xD6, 0x71, 0x73, 
+0x51, 0xB9, 0x90, 0xA3, 0xD8, 0x71, 0xA0, 0xE0, 0x90, 0xA3, 0xDA, 0xF0, 0x90, 0xA3, 0xD1, 0x71, 
+0x67, 0x51, 0xDB, 0xEF, 0x71, 0x78, 0x51, 0xDB, 0x80, 0x02, 0xF1, 0xF2, 0x90, 0xA3, 0xD2, 0xE0, 
+0xFD, 0xD3, 0x94, 0x80, 0x50, 0x28, 0xE0, 0x90, 0xA3, 0xDB, 0xF0, 0x71, 0x69, 0x51, 0xB9, 0x90, 
+0xA3, 0xDC, 0x71, 0x73, 0x51, 0xB9, 0x90, 0xA3, 0xDE, 0x71, 0xA0, 0xE0, 0x90, 0xA3, 0xE0, 0xF0, 
+0x90, 0xA3, 0xD2, 0x71, 0x67, 0x51, 0xDB, 0xEF, 0x71, 0x78, 0x51, 0xDB, 0x80, 0x08, 0x90, 0xA3, 
+0xD2, 0xE0, 0x90, 0xA3, 0xDB, 0xF0, 0x90, 0xA3, 0xD3, 0x74, 0x04, 0xF0, 0x90, 0xA3, 0xE1, 0x74, 
+0x0C, 0xF0, 0x80, 0x0B, 0x90, 0xA3, 0xD3, 0x74, 0x04, 0xF0, 0xE4, 0x90, 0xA3, 0xE1, 0xF0, 0x7B, 
+0x01, 0x7A, 0xA3, 0x79, 0xD3, 0x91, 0x14, 0x7F, 0x04, 0x21, 0x36, 0xF0, 0xEE, 0xA3, 0xF0, 0xEC, 
+0x25, 0xE0, 0x24, 0x15, 0xF5, 0x82, 0xE4, 0x34, 0x9E, 0xF5, 0x83, 0xE0, 0xFE, 0xA3, 0xE0, 0x22, 
+0xE0, 0xFF, 0x25, 0xE0, 0x24, 0x95, 0xF5, 0x82, 0xE4, 0x34, 0x9F, 0xF5, 0x83, 0xE4, 0xF0, 0xA3, 
+0xF0, 0xEF, 0x25, 0xE0, 0x24, 0x15, 0xF5, 0x82, 0xE4, 0x34, 0x9E, 0xF5, 0x83, 0xE4, 0xF0, 0xA3, 
+0xF0, 0x22, 0x90, 0xA3, 0xCE, 0x12, 0x48, 0xD2, 0x90, 0xA3, 0xCD, 0xEF, 0xF0, 0x12, 0x48, 0xDB, 
+0x53, 0x15, 0x00, 0x53, 0x1A, 0x01, 0x53, 0x1F, 0x08, 0x53, 0x24, 0x09, 0x53, 0x29, 0x0A, 0x53, 
+0x2E, 0x12, 0x53, 0x33, 0x13, 0x53, 0x37, 0x40, 0x53, 0x3C, 0x42, 0x53, 0x41, 0x43, 0x53, 0x45, 
+0x44, 0x00, 0x00, 0x53, 0x49, 0x71, 0x59, 0x02, 0x69, 0xE6, 0x71, 0x59, 0x02, 0x67, 0x3E, 0x71, 
+0x59, 0x02, 0x6A, 0x7E, 0x71, 0x59, 0x02, 0x6A, 0x38, 0x71, 0x59, 0x02, 0x6A, 0x5B, 0x71, 0x59, 
+0x02, 0x6B, 0x45, 0x71, 0x59, 0xE1, 0x2D, 0x71, 0x59, 0x02, 0x4C, 0x83, 0x71, 0x59, 0x02, 0x4D, 
+0x8B, 0x71, 0x59, 0x21, 0x51, 0x71, 0x59, 0x80, 0x65, 0x90, 0x01, 0xC0, 0xE0, 0x44, 0x01, 0xF0, 
+0x90, 0xA3, 0xCD, 0xE0, 0x90, 0x01, 0xC2, 0xF0, 0x22, 0x90, 0xA3, 0xCE, 0x02, 0x48, 0xC9, 0xEF, 
+0xF0, 0x90, 0x94, 0x91, 0x02, 0x48, 0xA5, 0xE0, 0xFF, 0x25, 0xE0, 0x24, 0x95, 0xF5, 0x82, 0xE4, 
+0x34, 0x9C, 0x22, 0xF0, 0xEE, 0xA3, 0xF0, 0xED, 0x25, 0xE0, 0x24, 0x95, 0xF5, 0x82, 0xE4, 0x34, 
+0x9B, 0x22, 0x90, 0xA3, 0xD1, 0xE0, 0xD3, 0x94, 0x80, 0x22, 0x90, 0xA3, 0xD3, 0x74, 0x0D, 0xF0, 
+0x90, 0xA3, 0xE1, 0x22, 0xE0, 0xFC, 0x25, 0xE0, 0x24, 0x95, 0xF5, 0x82, 0xE4, 0x34, 0x9F, 0x22, 
+0xF0, 0xEE, 0xA3, 0xF0, 0x75, 0xF0, 0x10, 0xED, 0x90, 0x81, 0x00, 0x02, 0x48, 0xBD, 0xF1, 0xDE, 
+0xE4, 0x90, 0xA3, 0xD6, 0xF0, 0xFD, 0x12, 0x4F, 0x4C, 0x8D, 0x82, 0xF1, 0x1C, 0xF4, 0x60, 0x32, 
+0x90, 0xA3, 0xD6, 0xE0, 0xFF, 0x12, 0x4F, 0x4C, 0x8D, 0x82, 0xF1, 0x1C, 0xFE, 0x75, 0xF0, 0x10, 
+0xF1, 0x07, 0x12, 0x4F, 0xDC, 0xFC, 0xA8, 0x05, 0x08, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0x4F, 
+0x90, 0xA3, 0xD6, 0xF0, 0x75, 0xF0, 0x10, 0xEE, 0x71, 0xA8, 0xE0, 0xFF, 0xF1, 0x22, 0xEF, 0xF0, 
+0x80, 0x05, 0xF1, 0x22, 0x74, 0xFF, 0xF0, 0x0D, 0xED, 0xB4, 0x07, 0xBA, 0x90, 0xA3, 0xD4, 0x74, 
+0x05, 0xF0, 0x90, 0xA3, 0xE2, 0x74, 0x08, 0xF0, 0x7B, 0x01, 0x7A, 0xA3, 0x79, 0xD4, 0x91, 0x14, 
+0x7F, 0x04, 0x21, 0x36, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0xA3, 0x8B, 0xE0, 0xFF, 
+0x70, 0x06, 0xA3, 0xE0, 0x64, 0x09, 0x60, 0x0A, 0xEF, 0x14, 0xFF, 0x90, 0xA3, 0x8C, 0xE0, 0xB5, 
+0x07, 0x04, 0x7F, 0x01, 0x80, 0x02, 0x7F, 0x00, 0xEF, 0x60, 0x09, 0x90, 0x01, 0xC1, 0xE0, 0x44, 
+0x02, 0xF0, 0x80, 0x29, 0xC0, 0x01, 0x90, 0xA3, 0x8C, 0xE0, 0x12, 0x6E, 0x0C, 0xA8, 0x01, 0xFC, 
+0x7D, 0x01, 0xD0, 0x01, 0x7E, 0x00, 0x7F, 0x0F, 0x12, 0x06, 0x63, 0x90, 0xA3, 0x8C, 0xF1, 0xE4, 
+0xB4, 0x0A, 0x02, 0x7F, 0x01, 0xEF, 0x60, 0x05, 0xE4, 0x90, 0xA3, 0x8C, 0xF0, 0xD0, 0xD0, 0x92, 
+0xAF, 0x22, 0xE4, 0xF5, 0x62, 0x90, 0xA3, 0xC2, 0xE0, 0xFF, 0xE5, 0x62, 0xC3, 0x9F, 0x40, 0x02, 
+0xA1, 0x26, 0xAF, 0x62, 0x12, 0x66, 0x85, 0xEF, 0x70, 0x02, 0xA1, 0x22, 0xE5, 0x62, 0x13, 0x13, 
+0x13, 0x54, 0x1F, 0xFF, 0xE5, 0x62, 0x54, 0x07, 0xFE, 0x74, 0x81, 0x2F, 0x12, 0x64, 0xD8, 0xE0, 
+0xFD, 0xAF, 0x06, 0x12, 0x66, 0x71, 0x80, 0x05, 0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 0xF9, 0xFF, 
+0xEF, 0x5D, 0x60, 0x6E, 0x75, 0xF0, 0x10, 0xE5, 0x62, 0xF1, 0x07, 0x20, 0xE7, 0x02, 0x80, 0x10, 
+0x75, 0xF0, 0x10, 0xE5, 0x62, 0x90, 0x81, 0x02, 0x12, 0x48, 0xBD, 0xE0, 0xFF, 0x20, 0xE7, 0x09, 
+0x90, 0x01, 0xC1, 0xE0, 0x44, 0x20, 0xF0, 0x80, 0x49, 0xEF, 0x30, 0xE6, 0x12, 0x75, 0xF0, 0x10, 
+0xE5, 0x62, 0x71, 0xA8, 0xF1, 0x0F, 0x12, 0x4C, 0x7C, 0xB1, 0x31, 0xE4, 0xFB, 0x80, 0x2E, 0xB1, 
+0x27, 0xF5, 0x83, 0xE0, 0x04, 0xF0, 0xB1, 0x27, 0xF5, 0x83, 0xE0, 0xD3, 0x94, 0x01, 0x40, 0x0D, 
+0xAF, 0x62, 0x12, 0x74, 0xC2, 0xB1, 0x27, 0xF5, 0x83, 0xE4, 0xF0, 0x80, 0x15, 0x75, 0xF0, 0x10, 
+0xE5, 0x62, 0x71, 0xA8, 0xF1, 0x0F, 0x12, 0x4C, 0x7C, 0xB1, 0x31, 0x7B, 0x01, 0xAF, 0x62, 0x12, 
+0x63, 0x63, 0x05, 0x62, 0x81, 0x75, 0x22, 0x74, 0x15, 0x25, 0x62, 0xF5, 0x82, 0xE4, 0x34, 0xA1, 
+0x22, 0x13, 0x13, 0x54, 0x03, 0xF5, 0x69, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 
+0xA4, 0xEA, 0xEF, 0xF0, 0x75, 0xF0, 0x04, 0x12, 0x4F, 0x55, 0x54, 0x1F, 0xFB, 0x60, 0x12, 0x64, 
+0x02, 0x60, 0x0E, 0xEB, 0x64, 0x04, 0x60, 0x09, 0xEB, 0x64, 0x09, 0x60, 0x04, 0xEB, 0xB4, 0x0C, 
+0x07, 0xF1, 0xCC, 0x74, 0x02, 0xF0, 0x80, 0x05, 0xF1, 0xCC, 0x74, 0x01, 0xF0, 0xE4, 0xF5, 0x6A, 
+0x90, 0xA4, 0xEA, 0xE0, 0xFD, 0xD1, 0xFB, 0x25, 0x6A, 0x12, 0x4F, 0x73, 0xE0, 0xFE, 0xEB, 0x75, 
+0xF0, 0x07, 0xA4, 0x24, 0x56, 0xF5, 0x82, 0xE4, 0x34, 0x40, 0xF5, 0x83, 0xE5, 0x82, 0x25, 0x6A, 
+0x12, 0x4F, 0x73, 0xE4, 0x93, 0xFC, 0xEE, 0x5C, 0x90, 0xA4, 0xEC, 0xF0, 0x75, 0xF0, 0x04, 0xED, 
+0x12, 0x4C, 0x7C, 0x54, 0x03, 0xFF, 0xBF, 0x02, 0x0B, 0xE5, 0x6A, 0x70, 0x07, 0x90, 0xA4, 0xEC, 
+0xE0, 0x54, 0xF0, 0xF0, 0x90, 0xA4, 0xEC, 0xE0, 0xFF, 0xD1, 0xF7, 0x25, 0x6A, 0x12, 0x4F, 0x73, 
+0xEF, 0xF0, 0x05, 0x6A, 0xE5, 0x6A, 0x64, 0x07, 0x70, 0xA6, 0x90, 0xA4, 0xEA, 0xE0, 0x75, 0xF0, 
+0x04, 0x12, 0x4C, 0x7C, 0xFF, 0xC4, 0x54, 0x03, 0xF9, 0xE4, 0xFD, 0x75, 0x6B, 0x06, 0xE5, 0x6B, 
+0xB4, 0x06, 0x08, 0x12, 0x4F, 0x63, 0xE0, 0x54, 0x0F, 0x80, 0x08, 0xD1, 0xF7, 0x25, 0x6B, 0x12, 
+0x4F, 0x73, 0xE0, 0x90, 0xA4, 0xEB, 0xF0, 0x90, 0xA4, 0xEB, 0xE0, 0x60, 0x2D, 0x75, 0x6A, 0x07, 
+0xF1, 0xA8, 0x80, 0x05, 0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 0xF9, 0xF1, 0xB9, 0x60, 0x12, 0xF1, 
+0xB0, 0xFD, 0xE9, 0x60, 0x22, 0xED, 0xD3, 0x94, 0x0B, 0x40, 0x1C, 0x74, 0x20, 0x2D, 0xFD, 0x80, 
+0x16, 0x15, 0x6A, 0xE5, 0x6A, 0xC3, 0x94, 0x00, 0x50, 0xD6, 0xE5, 0x6B, 0x60, 0x09, 0x15, 0x6B, 
+0xE5, 0x6B, 0xC3, 0x94, 0x00, 0x50, 0xA7, 0xE4, 0xFC, 0xF5, 0x6B, 0xE5, 0x6B, 0xB4, 0x06, 0x08, 
+0x12, 0x4F, 0x63, 0xE0, 0x54, 0x0F, 0x80, 0x08, 0xD1, 0xF7, 0x25, 0x6B, 0x12, 0x4F, 0x73, 0xE0, 
+0x90, 0xA4, 0xEB, 0xF0, 0x90, 0xA4, 0xEB, 0xE0, 0x60, 0x2B, 0xE4, 0xF5, 0x6A, 0xF1, 0xA8, 0x80, 
+0x05, 0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 0xF9, 0xF1, 0xB9, 0x60, 0x12, 0xF1, 0xB0, 0xFC, 0xE9, 
+0x60, 0x1B, 0xEC, 0xD3, 0x94, 0x0B, 0x40, 0x15, 0x74, 0x20, 0x2C, 0xFC, 0x80, 0x0F, 0x05, 0x6A, 
+0xE5, 0x6A, 0xB4, 0x08, 0xD8, 0x05, 0x6B, 0xE5, 0x6B, 0x64, 0x07, 0x70, 0xAE, 0x90, 0xA4, 0xEA, 
+0xE0, 0xFF, 0x75, 0xF0, 0x04, 0x12, 0x75, 0x14, 0xED, 0x12, 0x4F, 0xE3, 0xEC, 0xF0, 0x75, 0xF0, 
+0x10, 0xEF, 0x71, 0xA8, 0xE0, 0xFF, 0x54, 0x7F, 0xF5, 0x6C, 0xEF, 0x54, 0x80, 0xFF, 0xE5, 0x6C, 
+0xD3, 0x9D, 0x40, 0x03, 0xED, 0x80, 0x07, 0xE5, 0x6C, 0xC3, 0x9C, 0x50, 0x04, 0xEC, 0x4F, 0xF5, 
+0x6C, 0x90, 0xA4, 0xEA, 0xE0, 0xFF, 0x24, 0x95, 0xF5, 0x82, 0xE4, 0x34, 0xA0, 0xF5, 0x83, 0xE5, 
+0x6C, 0xF0, 0x75, 0xF0, 0x04, 0xEF, 0x12, 0x4C, 0x7C, 0xB1, 0x31, 0x90, 0xA4, 0xEA, 0xE0, 0xFF, 
+0xE4, 0xFB, 0xAD, 0x6C, 0x12, 0x63, 0x63, 0x90, 0xA4, 0xEA, 0xE0, 0x75, 0xF0, 0x10, 0xF1, 0xC6, 
+0xE4, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0xA4, 0xEA, 0xE0, 0x75, 0xF0, 0x08, 0x90, 0x89, 
+0x00, 0x12, 0x48, 0xBD, 0xE5, 0x82, 0x22, 0x90, 0x81, 0x01, 0x12, 0x48, 0xBD, 0xE0, 0x22, 0xE0, 
+0xFD, 0x75, 0xF0, 0x04, 0xE5, 0x62, 0x22, 0x12, 0x48, 0xC9, 0x8F, 0x82, 0x75, 0x83, 0x00, 0x02, 
+0x06, 0xA2, 0x74, 0xD7, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 0xA3, 0xF5, 0x83, 0x22, 0x12, 0x06, 0x89, 
+0xFF, 0x54, 0x80, 0xFE, 0x90, 0xA3, 0xC3, 0xE0, 0x54, 0x7F, 0x4E, 0xFE, 0xF0, 0xEF, 0x54, 0x40, 
+0xFF, 0xEE, 0x54, 0xBF, 0x4F, 0xFF, 0xF0, 0x12, 0x06, 0x89, 0xFE, 0x54, 0x20, 0xFD, 0xEF, 0x54, 
+0xDF, 0x4D, 0xFF, 0x90, 0xA3, 0xC3, 0xF0, 0xEE, 0x54, 0x10, 0xFE, 0xEF, 0x54, 0xEF, 0x4E, 0xFF, 
+0xF0, 0x12, 0x06, 0x89, 0x54, 0x0F, 0xFE, 0xEF, 0x54, 0xF0, 0x4E, 0x90, 0xA3, 0xC3, 0xF1, 0xA1, 
+0xFF, 0x54, 0x7F, 0x90, 0xA3, 0xC5, 0xF0, 0x12, 0x4F, 0xD9, 0xFF, 0x90, 0xA3, 0xC4, 0xE0, 0x54, 
+0xFE, 0x4F, 0x12, 0x4F, 0x5C, 0x90, 0xA3, 0xC6, 0xF0, 0x12, 0x7C, 0x23, 0x25, 0xE0, 0xFF, 0x90, 
+0xA3, 0xC4, 0xE0, 0x54, 0xFD, 0x4F, 0xF0, 0x11, 0xE5, 0x20, 0xE0, 0x02, 0x7D, 0x01, 0x02, 0x49, 
+0xBD, 0xF0, 0x90, 0x00, 0x01, 0x02, 0x06, 0xA2, 0x74, 0x01, 0x7E, 0x00, 0xA8, 0x6A, 0x08, 0x22, 
+0xE5, 0x6B, 0x75, 0xF0, 0x08, 0xA4, 0x25, 0x6A, 0x22, 0xFF, 0x90, 0xA4, 0xEB, 0xE0, 0xFB, 0xEF, 
+0x5B, 0x22, 0x75, 0xF0, 0x10, 0xEF, 0x90, 0x81, 0x03, 0x02, 0x48, 0xBD, 0x90, 0xA4, 0xEA, 0xE0, 
+0x24, 0x15, 0xF5, 0x82, 0xE4, 0x34, 0xA2, 0xF5, 0x83, 0x22, 0x81, 0x72, 0x01, 0xF6, 0x90, 0xA3, 
+0xD1, 0x02, 0x48, 0xD2, 0xE0, 0x04, 0xF0, 0xE0, 0x7F, 0x00, 0x22, 0xF1, 0xC2, 0xE0, 0x44, 0x40, 
+0xF0, 0x22, 0x90, 0xA3, 0xD1, 0xE0, 0x90, 0xA3, 0xD5, 0xF0, 0x22, 0x7F, 0xF4, 0x12, 0x4A, 0x6F, 
+0xEF, 0x20, 0xE5, 0x0E, 0x7F, 0xF4, 0x12, 0x4A, 0x6F, 0xEF, 0x7F, 0x01, 0x20, 0xE4, 0x05, 0x7F, 
+0x02, 0x22, 0x7F, 0x03, 0x22, 0x12, 0x57, 0xFB, 0x90, 0xA2, 0x9B, 0xEF, 0xF0, 0x11, 0x2F, 0x90, 
+0x01, 0x64, 0x74, 0x01, 0xF0, 0x90, 0x04, 0x23, 0xE0, 0x44, 0x80, 0xF0, 0x02, 0x36, 0x83, 0x12, 
+0x4F, 0x7B, 0x12, 0x4F, 0x9D, 0x11, 0x62, 0x11, 0x81, 0xE4, 0xF5, 0x0D, 0xF5, 0x0E, 0xF5, 0x0F, 
+0x75, 0x10, 0x80, 0x43, 0x10, 0x02, 0xAD, 0x0D, 0x7F, 0x50, 0x12, 0x49, 0xA9, 0xAD, 0x0E, 0x7F, 
+0x51, 0x12, 0x49, 0xA9, 0xAD, 0x0F, 0x7F, 0x52, 0x12, 0x49, 0xA9, 0xAD, 0x10, 0x7F, 0x53, 0x02, 
+0x49, 0xA9, 0x75, 0x15, 0x12, 0xE4, 0xF5, 0x16, 0x75, 0x17, 0x87, 0x75, 0x18, 0x73, 0x90, 0x01, 
+0x30, 0xE5, 0x15, 0xF0, 0xA3, 0xE5, 0x16, 0xF0, 0xA3, 0xE5, 0x17, 0xF0, 0xA3, 0xE5, 0x18, 0xF0, 
+0x22, 0x75, 0x1D, 0x06, 0x75, 0x1E, 0x01, 0x75, 0x1F, 0x03, 0x75, 0x20, 0x62, 0x90, 0x01, 0x38, 
+0xE5, 0x1D, 0xF0, 0xA3, 0xE5, 0x1E, 0xF0, 0xA3, 0xE5, 0x1F, 0xF0, 0xA3, 0xE5, 0x20, 0xF0, 0x22, 
+0x75, 0xE8, 0x03, 0x75, 0xA8, 0x85, 0x22, 0xE4, 0x90, 0xA3, 0xCB, 0xF0, 0x90, 0xA3, 0xCB, 0xE0, 
+0x64, 0x01, 0xF0, 0x24, 0xA7, 0x90, 0x01, 0xC4, 0xF0, 0x74, 0x58, 0xA3, 0xF0, 0x12, 0x3D, 0x6E, 
+0xBF, 0x01, 0x03, 0x12, 0x31, 0x38, 0x12, 0x4F, 0xFA, 0x12, 0x46, 0x0D, 0x80, 0xDE, 0xE4, 0xFB, 
+0xFA, 0xFD, 0x7F, 0x01, 0x12, 0x48, 0x0E, 0x90, 0xA3, 0xCC, 0xEF, 0xF0, 0x60, 0xF0, 0x90, 0xA2, 
+0x96, 0xE0, 0xFF, 0x70, 0x04, 0xA3, 0xE0, 0x60, 0xE5, 0xC2, 0xAF, 0xEF, 0x30, 0xE0, 0x0F, 0x90, 
+0xA2, 0x96, 0xE0, 0x54, 0xFE, 0xF0, 0xE4, 0xFF, 0x12, 0x61, 0x89, 0x12, 0x76, 0x36, 0xB1, 0xF1, 
+0x30, 0xE1, 0x06, 0x54, 0xFD, 0xF0, 0x12, 0x6C, 0x0A, 0xB1, 0xF1, 0x30, 0xE2, 0x06, 0x54, 0xFB, 
+0xF0, 0x12, 0x6D, 0x23, 0xB1, 0xF1, 0x30, 0xE5, 0x0A, 0x54, 0xDF, 0xF0, 0xF1, 0x65, 0xBF, 0x01, 
+0x02, 0x31, 0x27, 0xD2, 0xAF, 0x80, 0xB7, 0x90, 0xA3, 0xAC, 0xE0, 0x90, 0xA4, 0x30, 0xF0, 0x90, 
+0xA3, 0xAD, 0xE0, 0x90, 0xA4, 0x31, 0xF0, 0x90, 0xA3, 0xAE, 0xE0, 0x90, 0xA4, 0x32, 0xF0, 0x90, 
+0xA3, 0xAF, 0xE0, 0x90, 0xA4, 0x33, 0xF0, 0x90, 0xA3, 0xB0, 0xE0, 0x90, 0xA4, 0x34, 0xF0, 0x90, 
+0xA3, 0x9D, 0xE0, 0x90, 0xA4, 0x35, 0xF0, 0x90, 0xA3, 0x9E, 0xE0, 0x90, 0xA4, 0x36, 0xF0, 0x90, 
+0xA3, 0x9F, 0xE0, 0x90, 0xA4, 0x37, 0xF0, 0x90, 0xA3, 0xA0, 0xE0, 0x90, 0xA4, 0x38, 0xF0, 0x90, 
+0xA3, 0xA1, 0xE0, 0x90, 0xA4, 0x39, 0xF0, 0x90, 0xA3, 0xA2, 0xE0, 0x90, 0xA4, 0x3A, 0xF0, 0x90, 
+0xA3, 0xA3, 0xE0, 0x90, 0xA4, 0x3B, 0xF0, 0x90, 0xA3, 0xA4, 0xE0, 0x90, 0xA4, 0x3C, 0xF0, 0x90, 
+0xA3, 0xA5, 0xE0, 0x90, 0xA4, 0x3D, 0xF0, 0x90, 0xA3, 0xA6, 0xE0, 0x90, 0xA4, 0x3E, 0xF0, 0x12, 
+0x4F, 0xC0, 0x90, 0xA3, 0xD8, 0xF0, 0xB1, 0x8A, 0x50, 0x04, 0xB1, 0x97, 0x80, 0xF8, 0x90, 0x01, 
+0x1F, 0xE0, 0xFE, 0x90, 0x01, 0x1E, 0xF1, 0xE4, 0x90, 0xA3, 0xCD, 0xF0, 0xA3, 0xD1, 0xBA, 0xB1, 
+0x8A, 0x50, 0x4A, 0xB1, 0xFB, 0x90, 0xA3, 0xD8, 0xE0, 0xFE, 0x24, 0x3F, 0xF5, 0x82, 0xE4, 0x34, 
+0xA4, 0xD1, 0x45, 0xE0, 0x24, 0x4D, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0xFF, 0x74, 
+0xDA, 0x2E, 0xF5, 0x82, 0xE4, 0x34, 0xA3, 0xD1, 0x45, 0xE0, 0x24, 0x4E, 0xF9, 0xE4, 0x34, 0xFC, 
+0xFA, 0x7B, 0x01, 0xEE, 0xF1, 0x00, 0x12, 0x48, 0xD2, 0xD1, 0x49, 0xE0, 0x24, 0x38, 0xF9, 0xE4, 
+0x34, 0xFC, 0xFA, 0xEE, 0xD1, 0x37, 0x12, 0x48, 0xD2, 0xB1, 0xA4, 0x80, 0xB2, 0x90, 0x02, 0x87, 
+0xE0, 0x70, 0x02, 0xA1, 0x7C, 0x90, 0xA3, 0x8F, 0xE0, 0x20, 0xE0, 0x02, 0xA1, 0x7C, 0xE4, 0x90, 
+0xA4, 0x49, 0x12, 0x4F, 0xC8, 0x90, 0xA3, 0xCD, 0xE0, 0xFF, 0xA3, 0xE0, 0xA3, 0xCF, 0xF0, 0xA3, 
+0xEF, 0xF0, 0x90, 0xA3, 0xCF, 0xE0, 0xFC, 0xA3, 0xE0, 0xFD, 0xEC, 0x90, 0xFD, 0x11, 0xF0, 0xD1, 
+0xE8, 0xE0, 0xFE, 0xD1, 0x15, 0xE0, 0x7A, 0x00, 0x24, 0x00, 0xFF, 0xEA, 0x3E, 0x54, 0x3F, 0x90, 
+0xA3, 0xD1, 0xF0, 0xA3, 0xF1, 0x0E, 0x54, 0x0F, 0x33, 0x33, 0x33, 0x54, 0xF8, 0x90, 0xA3, 0xD4, 
+0xF0, 0xFC, 0x74, 0x07, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 0xFB, 0xF5, 0x83, 0xE0, 0x54, 0xC0, 0x90, 
+0xA3, 0xD6, 0xF0, 0xEC, 0x24, 0x18, 0x90, 0xA3, 0xD3, 0xF0, 0xFD, 0x90, 0xA3, 0xCF, 0xE0, 0xFE, 
+0xA3, 0xE0, 0xFF, 0xB1, 0xB4, 0xEF, 0x54, 0xFC, 0x90, 0xA3, 0xD5, 0xF0, 0x90, 0xA3, 0xD4, 0xE0, 
+0x24, 0x18, 0xFF, 0xE4, 0x33, 0x90, 0xA3, 0xD1, 0x8F, 0xF0, 0x12, 0x08, 0xD6, 0x90, 0xA3, 0xD1, 
+0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x12, 0x7B, 0x8B, 0x90, 0xA3, 0xCD, 0xF1, 0x9F, 0x90, 0xA3, 0x8D, 
+0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x90, 0xA3, 0xCD, 0xE0, 0xFC, 0xA3, 0xE0, 0xFD, 0xD3, 0x9F, 0xEC, 
+0x9E, 0x40, 0x11, 0x90, 0xA3, 0x8E, 0xD1, 0xF3, 0xED, 0x9F, 0xFF, 0xEC, 0x9E, 0x90, 0xA3, 0xCD, 
+0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0xA3, 0xD5, 0xE0, 0x24, 0xC0, 0x60, 0x02, 0x81, 0xA1, 0xB1, 0x7D, 
+0x24, 0x18, 0xFD, 0xB1, 0xB4, 0xEF, 0x60, 0x02, 0x81, 0x97, 0xB1, 0x7D, 0x24, 0x19, 0xFD, 0xB1, 
+0xB4, 0x90, 0xA3, 0xEE, 0xD1, 0xC2, 0x90, 0xA3, 0xEE, 0xE0, 0xFF, 0x90, 0xA3, 0xD7, 0xE0, 0xFD, 
+0xC3, 0x9F, 0x50, 0x15, 0xB1, 0x7D, 0x24, 0x1A, 0xD1, 0x0F, 0x90, 0xA3, 0xD7, 0xE0, 0x24, 0xEF, 
+0xF5, 0x82, 0xE4, 0x34, 0xA3, 0xD1, 0x20, 0x80, 0xDD, 0x90, 0xA3, 0xEE, 0xE0, 0x70, 0x02, 0x61, 
+0xE9, 0xE4, 0x90, 0xA3, 0xD8, 0xF0, 0xB1, 0x8A, 0x40, 0x02, 0x61, 0xD1, 0xB1, 0xFB, 0x90, 0xA3, 
+0xD8, 0xE0, 0xFF, 0x24, 0xDA, 0xF5, 0x82, 0xE4, 0x34, 0xA3, 0xF5, 0x83, 0xE0, 0xFE, 0x90, 0xA3, 
+0xEE, 0xE0, 0xFD, 0xEE, 0x6D, 0x70, 0x20, 0xEF, 0xF1, 0x00, 0x12, 0x48, 0xC9, 0xC0, 0x03, 0xC0, 
+0x02, 0xC0, 0x01, 0xD1, 0x2B, 0x90, 0xA4, 0x54, 0xED, 0xF0, 0xD0, 0x01, 0xD0, 0x02, 0xD0, 0x03, 
+0xD1, 0x54, 0xEF, 0x60, 0x02, 0x80, 0x4D, 0x90, 0xA3, 0xEE, 0xE0, 0x64, 0x03, 0x70, 0x54, 0xD1, 
+0x2B, 0x90, 0xA4, 0x54, 0x74, 0x03, 0xF0, 0x7A, 0xA4, 0x79, 0xBB, 0xD1, 0x54, 0xEF, 0x70, 0x11, 
+0xD1, 0x2B, 0x90, 0xA4, 0x54, 0x74, 0x03, 0xF0, 0x7A, 0xA4, 0x79, 0xB7, 0xD1, 0x54, 0xEF, 0x60, 
+0x2A, 0x90, 0xA3, 0xD8, 0xE0, 0xFF, 0x24, 0x3A, 0xF5, 0x82, 0xE4, 0x34, 0xA4, 0xF5, 0x83, 0xE0, 
+0x60, 0x02, 0x80, 0x0B, 0x90, 0xA3, 0xD8, 0xE0, 0xFF, 0x24, 0x35, 0xD1, 0xCA, 0x60, 0x05, 0x74, 
+0x49, 0x2F, 0x80, 0x15, 0xB1, 0xE3, 0x74, 0x01, 0xF0, 0x80, 0x12, 0x90, 0xA3, 0xD8, 0xE0, 0x24, 
+0x49, 0x80, 0x06, 0x90, 0xA3, 0xD8, 0xE0, 0x24, 0x49, 0xB1, 0xE9, 0xE4, 0xF0, 0xB1, 0xA4, 0x61, 
+0x26, 0x90, 0xA4, 0x49, 0xE0, 0x70, 0x4D, 0xA3, 0xE0, 0x70, 0x49, 0xA3, 0xE0, 0x70, 0x45, 0xA3, 
+0xE0, 0x70, 0x41, 0xA3, 0xE0, 0x70, 0x3D, 0x81, 0x97, 0xE4, 0x90, 0xA3, 0xD8, 0xF0, 0xB1, 0x8A, 
+0x50, 0x1C, 0x74, 0x35, 0x2E, 0xD1, 0xCA, 0x60, 0x09, 0x74, 0x49, 0x2E, 0xB1, 0xE9, 0xE4, 0xF0, 
+0x80, 0x08, 0x74, 0x49, 0x2E, 0xB1, 0xE9, 0x74, 0x01, 0xF0, 0xB1, 0xA4, 0x80, 0xE0, 0x90, 0xA4, 
+0x49, 0xE0, 0x70, 0x10, 0xA3, 0xE0, 0x70, 0x0C, 0xA3, 0xE0, 0x70, 0x08, 0xA3, 0xE0, 0x70, 0x04, 
+0xA3, 0xE0, 0x60, 0x73, 0xE4, 0x90, 0xA3, 0xD8, 0xF0, 0xB1, 0x8A, 0x50, 0x6A, 0xB1, 0xFB, 0xB1, 
+0xE3, 0xE0, 0x60, 0x5F, 0x7D, 0x43, 0x7F, 0xFF, 0xD1, 0xDD, 0x90, 0x04, 0x1D, 0xE0, 0x70, 0x4E, 
+0x90, 0xA3, 0xD8, 0xE0, 0x24, 0x30, 0xF5, 0x82, 0xE4, 0x34, 0xA4, 0xF5, 0x83, 0xE0, 0xFF, 0x7B, 
+0x08, 0x7D, 0x01, 0x12, 0x6E, 0xE1, 0x90, 0xA3, 0xD1, 0xEE, 0xF0, 0xA3, 0xD1, 0xC2, 0x90, 0xA3, 
+0xD7, 0xE0, 0xFD, 0xC3, 0x94, 0x06, 0x50, 0x1C, 0xB1, 0x7D, 0x24, 0x0A, 0xD1, 0x0F, 0x90, 0xA3, 
+0xD1, 0xA3, 0xE0, 0xFE, 0x90, 0xA3, 0xD7, 0xE0, 0x2E, 0x24, 0x2C, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 
+0xD1, 0x20, 0x80, 0xDA, 0x90, 0x04, 0x1F, 0x74, 0x20, 0xF0, 0x90, 0x06, 0x35, 0xF0, 0xE4, 0xFD, 
+0xFF, 0xD1, 0xDD, 0xB1, 0xA4, 0x80, 0x92, 0xF1, 0x1C, 0x90, 0x06, 0x36, 0x74, 0xDD, 0xF0, 0x41, 
+0x0D, 0x90, 0xA3, 0xD6, 0xE0, 0x60, 0x02, 0xA1, 0x78, 0xB1, 0x7D, 0x24, 0x16, 0xFD, 0xB1, 0xB4, 
+0x90, 0x06, 0x34, 0xEF, 0xF0, 0xB1, 0x7D, 0x24, 0x17, 0xFD, 0xB1, 0xB4, 0x90, 0x06, 0x37, 0xD1, 
+0xBA, 0xB1, 0x8A, 0x50, 0x69, 0xB1, 0xFB, 0xE4, 0x90, 0xA3, 0xD7, 0xF0, 0x90, 0xA3, 0xD7, 0xE0, 
+0xFF, 0xC3, 0x94, 0x06, 0x50, 0x54, 0xEF, 0x60, 0x04, 0x64, 0x01, 0x70, 0x21, 0xB1, 0x7D, 0xB1, 
+0xAB, 0x90, 0xA3, 0xD7, 0xE0, 0xFE, 0x24, 0xA0, 0xD1, 0xD3, 0x90, 0xA3, 0xD8, 0xE0, 0xD1, 0x37, 
+0x12, 0x48, 0xC9, 0x8E, 0x82, 0x12, 0x57, 0x1C, 0xFF, 0x74, 0xA2, 0x2E, 0xD1, 0xD3, 0xB1, 0x7D, 
+0xB1, 0xAB, 0x90, 0xA3, 0xD8, 0xE0, 0xFE, 0xD1, 0x37, 0x12, 0x48, 0xC9, 0x90, 0xA3, 0xD7, 0xE0, 
+0xF5, 0x82, 0x12, 0x57, 0x1C, 0x6F, 0x60, 0x0E, 0x74, 0x44, 0x2E, 0xF5, 0x82, 0xE4, 0x34, 0xA4, 
+0xF5, 0x83, 0xE4, 0xF0, 0x80, 0x04, 0xD1, 0x24, 0x80, 0xA2, 0xB1, 0xA4, 0x80, 0x93, 0x90, 0xA4, 
+0x44, 0xE0, 0x64, 0x01, 0x60, 0x17, 0xA3, 0xE0, 0x64, 0x01, 0x60, 0x11, 0xA3, 0xE0, 0x64, 0x01, 
+0x60, 0x0B, 0xA3, 0xE0, 0x64, 0x01, 0x60, 0x05, 0xA3, 0xE0, 0xB4, 0x01, 0x06, 0x90, 0xA3, 0xD9, 
+0x74, 0x01, 0xF0, 0x90, 0xA3, 0xD9, 0xE0, 0xB4, 0x01, 0x0F, 0xF1, 0x32, 0x90, 0x01, 0xC7, 0x74, 
+0x66, 0xF0, 0xE4, 0xFF, 0x12, 0x7B, 0x5D, 0x41, 0x0D, 0x12, 0x4F, 0xC0, 0x90, 0xA3, 0xD8, 0xF0, 
+0xB1, 0x8A, 0x50, 0x04, 0xB1, 0x97, 0x80, 0xF8, 0xF1, 0x1C, 0x41, 0x0D, 0x22, 0x90, 0xA3, 0xCF, 
+0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x90, 0xA3, 0xD3, 0xE0, 0x22, 0x90, 0xA3, 0x9A, 0xE0, 0xFF, 0x90, 
+0xA3, 0xD8, 0xE0, 0xFE, 0xC3, 0x9F, 0x22, 0x74, 0x44, 0x2E, 0xF5, 0x82, 0xE4, 0x34, 0xA4, 0xF5, 
+0x83, 0x74, 0x01, 0xF0, 0x90, 0xA3, 0xD8, 0xE0, 0x04, 0xF0, 0x22, 0x24, 0x04, 0xFD, 0x90, 0xA3, 
+0xD7, 0xE0, 0x2D, 0xFD, 0xAB, 0x07, 0xAA, 0x06, 0xED, 0x2B, 0xFB, 0xE4, 0x3A, 0xFA, 0xC3, 0x90, 
+0xA3, 0x8E, 0xE0, 0x9B, 0x90, 0xA3, 0x8D, 0xE0, 0x9A, 0x50, 0x09, 0xA3, 0xD1, 0xF3, 0xEB, 0x9F, 
+0xFB, 0xEA, 0x9E, 0xFA, 0xEA, 0x90, 0xFD, 0x11, 0xF0, 0xAF, 0x03, 0x74, 0x00, 0x2F, 0xD1, 0x18, 
+0xE0, 0xFF, 0x22, 0x90, 0xA3, 0xD8, 0xE0, 0x24, 0x49, 0xF5, 0x82, 0xE4, 0x34, 0xA4, 0xF5, 0x83, 
+0x22, 0xD2, 0xAF, 0xC2, 0xAF, 0x90, 0xA2, 0x96, 0xE0, 0xFF, 0x22, 0x74, 0x30, 0x2E, 0xF5, 0x82, 
+0xE4, 0x34, 0xA4, 0xF5, 0x83, 0xE0, 0xFF, 0x90, 0xFD, 0x10, 0xEF, 0xF0, 0x7F, 0x00, 0x22, 0xFC, 
+0xED, 0x2C, 0xFD, 0x80, 0x9F, 0x74, 0x00, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 0xFB, 0xF5, 0x83, 0x22, 
+0xF5, 0x83, 0xEF, 0xF0, 0x90, 0xA3, 0xD7, 0xE0, 0x04, 0xF0, 0x22, 0x7B, 0x01, 0x7A, 0xA3, 0x79, 
+0xEF, 0x90, 0xA4, 0x51, 0x02, 0x48, 0xD2, 0x75, 0xF0, 0x03, 0xA4, 0x24, 0x21, 0xF5, 0x82, 0xE4, 
+0x34, 0xA4, 0xF5, 0x83, 0x22, 0xF5, 0x83, 0xEF, 0xF0, 0x74, 0x3F, 0x2E, 0xF5, 0x82, 0xE4, 0x34, 
+0xA4, 0xF5, 0x83, 0x22, 0x90, 0xA4, 0x4E, 0x12, 0x48, 0xD2, 0xE4, 0xFF, 0x90, 0xA4, 0x54, 0xE0, 
+0xFE, 0xEF, 0xC3, 0x9E, 0x50, 0x16, 0x90, 0xA4, 0x51, 0x12, 0x57, 0x17, 0xFE, 0x90, 0xA4, 0x4E, 
+0x12, 0x57, 0x17, 0x6E, 0x60, 0x03, 0x7F, 0x00, 0x22, 0x0F, 0x80, 0xE0, 0x7F, 0x01, 0x22, 0xE4, 
+0xFC, 0xED, 0x2C, 0x24, 0x00, 0xD1, 0x18, 0xE4, 0xF0, 0x0C, 0xEC, 0xB4, 0x18, 0xF3, 0xD1, 0x15, 
+0xEF, 0xF0, 0xEE, 0x54, 0x3F, 0xFF, 0xD1, 0xE8, 0xF1, 0x0E, 0x54, 0xF0, 0xF0, 0x74, 0x03, 0x2D, 
+0xF5, 0x82, 0xE4, 0x34, 0xFB, 0xF5, 0x83, 0xE0, 0x44, 0x80, 0xF0, 0x74, 0x0B, 0x2D, 0xF5, 0x82, 
+0xE4, 0x34, 0xFB, 0xF5, 0x83, 0xE0, 0x44, 0x10, 0xF0, 0x22, 0xEF, 0xF0, 0xE4, 0x90, 0xA3, 0xD8, 
+0xF0, 0x22, 0xEF, 0xF0, 0xE4, 0x90, 0xA3, 0xD7, 0xF0, 0x22, 0xF5, 0x82, 0xE4, 0x34, 0xA4, 0xF5, 
+0x83, 0xE0, 0x22, 0xF5, 0x82, 0xE4, 0x34, 0x04, 0xF5, 0x83, 0xEF, 0xF0, 0x22, 0x90, 0x05, 0x22, 
+0xEF, 0xF0, 0x90, 0xA2, 0x9A, 0xED, 0xF0, 0x22, 0x74, 0x01, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 0xFB, 
+0xF5, 0x83, 0x22, 0xE0, 0x24, 0x01, 0xFF, 0x90, 0xA3, 0x8D, 0xE0, 0x34, 0x00, 0xFE, 0xC3, 0x22, 
+0x75, 0xF0, 0x03, 0xA4, 0x24, 0xDF, 0xF5, 0x82, 0xE4, 0x34, 0xA3, 0xF5, 0x83, 0x22, 0xEF, 0xF0, 
+0x74, 0x02, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 0xFB, 0xF5, 0x83, 0xE0, 0x22, 0x90, 0xA3, 0xCD, 0xE0, 
+0xFE, 0xA3, 0xE0, 0xFF, 0x90, 0x02, 0x84, 0xEF, 0xF0, 0xEE, 0xA3, 0xF0, 0xA3, 0xE0, 0x44, 0x01, 
+0xF0, 0x22, 0xC2, 0xAF, 0x90, 0xA3, 0x8F, 0xE0, 0x54, 0xFE, 0xF0, 0x7D, 0x08, 0xE4, 0xFF, 0xF1, 
+0x5B, 0x90, 0x02, 0x09, 0xE0, 0x90, 0x04, 0x24, 0xF0, 0x90, 0x02, 0x09, 0xE0, 0x90, 0x04, 0x25, 
+0xF0, 0xE4, 0x90, 0xA3, 0x9B, 0xF0, 0xA3, 0xF0, 0xD2, 0xAF, 0x22, 0x74, 0x15, 0xF1, 0xAD, 0xFE, 
+0xF6, 0x74, 0x30, 0x80, 0x58, 0xE4, 0x90, 0xA3, 0xCD, 0xF0, 0xA3, 0xF0, 0x90, 0x02, 0x86, 0xE0, 
+0x20, 0xE1, 0x27, 0xC3, 0x90, 0xA3, 0xCE, 0xE0, 0x94, 0xD0, 0x90, 0xA3, 0xCD, 0xE0, 0x94, 0x07, 
+0x40, 0x0A, 0x90, 0x01, 0xC1, 0xE0, 0x44, 0x04, 0xF0, 0x7F, 0x00, 0x22, 0x90, 0xA3, 0xCD, 0xE4, 
+0x75, 0xF0, 0x01, 0x12, 0x08, 0xD6, 0xF1, 0xA6, 0x80, 0xD2, 0x7F, 0x01, 0x22, 0xF5, 0x83, 0xEE, 
+0x8F, 0xF0, 0x02, 0x08, 0xD6, 0xF0, 0x7F, 0x0A, 0x7E, 0x00, 0x02, 0x3D, 0x7A, 0x2F, 0xF8, 0xE6, 
+0xFE, 0xED, 0xF4, 0x5E, 0x22, 0x74, 0x1D, 0xF1, 0xAD, 0xFE, 0xF6, 0x74, 0x38, 0x2F, 0xF5, 0x82, 
+0xE4, 0x34, 0x01, 0xF5, 0x83, 0xEE, 0xF0, 0x22, 0x74, 0x1D, 0x2F, 0xF8, 0xE6, 0x4D, 0x80, 0xE9, 
+0x74, 0x15, 0x2F, 0xF8, 0xE6, 0x4D, 0xFE, 0xF6, 0x74, 0x30, 0x80, 0xE1, 0x90, 0x01, 0x17, 0xE0, 
+0xFE, 0x90, 0x01, 0x16, 0xE0, 0x7C, 0x00, 0x24, 0x00, 0xFF, 0xEC, 0x3E, 0x22, 0x32, 0xC0, 0xE0, 
+0xC0, 0xF0, 0xC0, 0x83, 0xC0, 0x82, 0xC0, 0xD0, 0x75, 0xD0, 0x00, 0xC0, 0x00, 0xC0, 0x01, 0xC0, 
+0x02, 0xC0, 0x03, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0x12, 0x4B, 0x86, 0xE5, 0x14, 
+0x30, 0xE7, 0x02, 0x11, 0x30, 0xD0, 0x07, 0xD0, 0x06, 0xD0, 0x05, 0xD0, 0x04, 0xD0, 0x03, 0xD0, 
+0x02, 0xD0, 0x01, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x82, 0xD0, 0x83, 0xD0, 0xF0, 0xD0, 0xE0, 0x32, 
+0x7F, 0x01, 0x7E, 0x00, 0x12, 0x3C, 0xEC, 0x7F, 0xF2, 0x12, 0x4A, 0x6F, 0xEF, 0x20, 0xE6, 0x09, 
+0x7F, 0x05, 0x11, 0x4A, 0x7F, 0x05, 0x12, 0x49, 0xA9, 0x22, 0x12, 0x4A, 0x6F, 0xEF, 0x44, 0x80, 
+0xFD, 0x22, 0xC0, 0xE0, 0xC0, 0xF0, 0xC0, 0x83, 0xC0, 0x82, 0xC0, 0xD0, 0x75, 0xD0, 0x00, 0xC0, 
+0x00, 0xC0, 0x01, 0xC0, 0x02, 0xC0, 0x03, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0x12, 
+0x6E, 0x78, 0xE5, 0x19, 0x30, 0xE1, 0x02, 0x31, 0x06, 0xE5, 0x19, 0x30, 0xE3, 0x02, 0xD1, 0x79, 
+0xE5, 0x19, 0x30, 0xE4, 0x02, 0x91, 0xE7, 0xE5, 0x19, 0x30, 0xE5, 0x03, 0x12, 0x6E, 0xA5, 0xE5, 
+0x1B, 0x30, 0xE0, 0x02, 0xD1, 0x57, 0xE5, 0x1B, 0x30, 0xE1, 0x02, 0x91, 0xFA, 0xE5, 0x1B, 0x30, 
+0xE7, 0x02, 0xD1, 0x37, 0xE5, 0x1C, 0x30, 0xE0, 0x02, 0xD1, 0x47, 0xE5, 0x1C, 0x30, 0xE4, 0x02, 
+0x31, 0x87, 0xE5, 0x1C, 0x30, 0xE5, 0x03, 0x12, 0x57, 0xDA, 0xE5, 0x1C, 0x30, 0xE6, 0x02, 0x11, 
+0xDC, 0xD0, 0x07, 0xD0, 0x06, 0xD0, 0x05, 0xD0, 0x04, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 
+0x00, 0xD0, 0xD0, 0xD0, 0x82, 0xD0, 0x83, 0xD0, 0xF0, 0xD0, 0xE0, 0x32, 0x90, 0x07, 0x1F, 0xE0, 
+0x54, 0x7F, 0xF0, 0x90, 0x07, 0x1C, 0xE0, 0x54, 0x01, 0xFF, 0x90, 0xA4, 0x57, 0xF0, 0x90, 0xA4, 
+0x55, 0x74, 0x02, 0xF0, 0x90, 0xA4, 0x63, 0x14, 0xF0, 0xFB, 0x7A, 0xA4, 0x79, 0x55, 0x12, 0x54, 
+0x14, 0x7F, 0x04, 0x02, 0x51, 0x36, 0xE4, 0xFF, 0x90, 0xA4, 0x55, 0xEF, 0xF0, 0x90, 0x04, 0x7E, 
+0xE0, 0xF5, 0x63, 0xA3, 0xE0, 0xF5, 0x64, 0x65, 0x63, 0x60, 0x6B, 0x90, 0xA4, 0x56, 0x74, 0x03, 
+0xF0, 0x90, 0xA4, 0x64, 0x74, 0x08, 0xF0, 0xE5, 0x64, 0x04, 0x54, 0x0F, 0xF5, 0x65, 0xE4, 0xF5, 
+0x62, 0xE5, 0x65, 0x75, 0xF0, 0x08, 0xA4, 0x24, 0x00, 0xF5, 0x82, 0xE4, 0x34, 0x80, 0xF5, 0x83, 
+0xE5, 0x82, 0x25, 0x62, 0x12, 0x4F, 0x73, 0xE0, 0xFF, 0x74, 0x58, 0x25, 0x62, 0xF5, 0x82, 0xE4, 
+0x34, 0xA4, 0xF5, 0x83, 0xEF, 0xF0, 0x05, 0x62, 0xE5, 0x62, 0xB4, 0x08, 0xD4, 0x7B, 0x01, 0x7A, 
+0xA4, 0x79, 0x56, 0x12, 0x54, 0x14, 0xE5, 0x64, 0x04, 0x54, 0x0F, 0xF5, 0x64, 0xB4, 0x0F, 0x03, 
+0xE4, 0xF5, 0x64, 0x90, 0x04, 0x7F, 0xE5, 0x64, 0xF0, 0x90, 0xA4, 0x55, 0xE0, 0x7F, 0x04, 0x70, 
+0x02, 0x81, 0xEB, 0x12, 0x51, 0x36, 0x22, 0xE4, 0xFF, 0x90, 0xA4, 0x65, 0xEF, 0xF0, 0x7E, 0x00, 
+0x7F, 0x10, 0x7D, 0x00, 0x7B, 0x01, 0x7A, 0xA4, 0x79, 0x67, 0x12, 0x08, 0xAA, 0x90, 0xA3, 0xC2, 
+0xE0, 0x90, 0xA4, 0x79, 0xF0, 0xE4, 0x90, 0xA4, 0x66, 0xF0, 0x90, 0xA4, 0x79, 0xE0, 0xFE, 0x90, 
+0xA4, 0x66, 0xE0, 0xFD, 0xC3, 0x9E, 0x50, 0x43, 0xED, 0x51, 0xD8, 0xED, 0x54, 0x07, 0xA3, 0xF0, 
+0x75, 0xF0, 0x10, 0xED, 0x12, 0x57, 0xC6, 0xE0, 0x30, 0xE7, 0x09, 0x74, 0x81, 0x2D, 0x51, 0xBE, 
+0xE4, 0xF0, 0x80, 0x1F, 0xAF, 0x05, 0x12, 0x57, 0xEB, 0x51, 0xEE, 0xC0, 0x83, 0xC0, 0x82, 0xE0, 
+0xFF, 0x90, 0xA4, 0x78, 0x12, 0x4A, 0x67, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0x4F, 0xD0, 0x82, 
+0xD0, 0x83, 0xF0, 0x90, 0xA4, 0x66, 0xE0, 0x04, 0xF0, 0x80, 0xAF, 0x7F, 0x0C, 0x7E, 0x00, 0x12, 
+0x3D, 0x7A, 0xE4, 0x90, 0xA4, 0x66, 0xF0, 0x90, 0xA4, 0x79, 0xE0, 0xFF, 0x90, 0xA4, 0x66, 0xE0, 
+0xFE, 0xC3, 0x9F, 0x40, 0x02, 0x41, 0xB7, 0xEE, 0x51, 0xD8, 0xEE, 0x54, 0x07, 0xA3, 0xF0, 0xE0, 
+0xD1, 0x70, 0x80, 0x05, 0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 0xF9, 0x4E, 0x7F, 0x00, 0x70, 0x02, 
+0x7F, 0x01, 0x51, 0xEE, 0xE0, 0x5F, 0x70, 0x77, 0x51, 0xC6, 0x90, 0x81, 0x06, 0x51, 0xCF, 0xEF, 
+0x90, 0x81, 0x07, 0x51, 0xE2, 0xFC, 0x71, 0x52, 0x34, 0x92, 0xF5, 0x83, 0xEE, 0xF1, 0xE5, 0xEC, 
+0x90, 0x81, 0x0A, 0x51, 0xCF, 0xEC, 0x90, 0x81, 0x0B, 0x51, 0xE2, 0x75, 0xF0, 0x0A, 0x51, 0xB8, 
+0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x7F, 0x01, 0x90, 0xA4, 0x66, 0xE0, 0xFE, 0x75, 0xF0, 0x10, 0x90, 
+0x81, 0x0B, 0x12, 0x4F, 0x6E, 0xE0, 0xFD, 0x75, 0xF0, 0x0A, 0xEE, 0x51, 0xB8, 0x75, 0xF0, 0x02, 
+0xEF, 0x91, 0xE0, 0xED, 0xF0, 0x0F, 0xEF, 0xB4, 0x05, 0xDD, 0x51, 0xC6, 0x90, 0x81, 0x09, 0x12, 
+0x48, 0xBD, 0xE0, 0xFE, 0xD1, 0x62, 0xEE, 0xF0, 0x90, 0xA4, 0x66, 0xE0, 0xFF, 0x90, 0xA4, 0x65, 
+0xE0, 0xFD, 0x51, 0xFC, 0x90, 0xA4, 0x66, 0xE0, 0x24, 0x81, 0x51, 0xBE, 0x74, 0x01, 0xF0, 0x90, 
+0xA4, 0x66, 0xE0, 0x04, 0xF0, 0x41, 0x07, 0x22, 0x90, 0x8D, 0x01, 0x02, 0x48, 0xBD, 0xF5, 0x82, 
+0xE4, 0x34, 0x93, 0xF5, 0x83, 0x22, 0x90, 0xA4, 0x66, 0xE0, 0xFF, 0x75, 0xF0, 0x10, 0x22, 0x12, 
+0x48, 0xBD, 0xE0, 0xFD, 0x75, 0xF0, 0x10, 0x22, 0x13, 0x13, 0x13, 0x54, 0x1F, 0x90, 0xA4, 0x77, 
+0xF0, 0x22, 0x12, 0x48, 0xBD, 0xE0, 0xFE, 0xED, 0xFF, 0x90, 0xA4, 0x66, 0xE0, 0x22, 0x90, 0xA4, 
+0x77, 0xE0, 0x24, 0x67, 0xF5, 0x82, 0xE4, 0x34, 0xA4, 0xF5, 0x83, 0x22, 0xD3, 0x10, 0xAF, 0x01, 
+0xC3, 0xC0, 0xD0, 0xED, 0x60, 0x2C, 0x75, 0xF0, 0x0A, 0xEF, 0x90, 0x8D, 0x01, 0x71, 0x45, 0xEF, 
+0x90, 0x8D, 0x03, 0x71, 0x45, 0xEF, 0x90, 0x8D, 0x05, 0x71, 0x45, 0xEF, 0x90, 0x8D, 0x07, 0x71, 
+0x45, 0xEF, 0x90, 0x8D, 0x09, 0x91, 0xE0, 0x71, 0x50, 0x34, 0x92, 0x12, 0x52, 0xDB, 0xD1, 0x62, 
+0xE4, 0xF0, 0x12, 0x57, 0xC2, 0xE0, 0x54, 0xBF, 0x44, 0x80, 0xFE, 0x12, 0x57, 0xC2, 0xEE, 0xF0, 
+0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x12, 0x48, 0xBD, 0xE4, 0xF0, 0xA3, 0xF0, 0x75, 0xF0, 0x0A, 0x22, 
+0xF0, 0xEF, 0x25, 0xE0, 0x24, 0x01, 0xF5, 0x82, 0xE4, 0x22, 0x85, 0x5E, 0x69, 0x7B, 0x01, 0xAD, 
+0x5C, 0xAF, 0x5B, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x8F, 0x66, 0x8D, 0x67, 0xE4, 0x90, 
+0xA4, 0xB4, 0xF0, 0xE5, 0x66, 0x13, 0x13, 0x13, 0x54, 0x1F, 0x90, 0xA4, 0xAF, 0xF0, 0xE5, 0x66, 
+0x54, 0x07, 0x90, 0xA4, 0xB1, 0xF0, 0x75, 0xF0, 0x10, 0xEF, 0x12, 0x57, 0x07, 0x90, 0xA4, 0xB2, 
+0xF0, 0x12, 0x75, 0x10, 0xE0, 0x54, 0x7F, 0x90, 0xA4, 0xB5, 0xF0, 0x75, 0xF0, 0x04, 0xE5, 0x66, 
+0x12, 0x4F, 0xE8, 0xE0, 0x90, 0xA4, 0xB6, 0xF0, 0x91, 0xAF, 0xEB, 0x70, 0x25, 0xE0, 0xFF, 0x12, 
+0x75, 0x53, 0xFC, 0x74, 0x01, 0x93, 0xFD, 0xEF, 0x12, 0x73, 0x3B, 0x74, 0x01, 0x93, 0x2D, 0xFF, 
+0xE4, 0x93, 0x3C, 0xC3, 0x13, 0xFE, 0xEF, 0x13, 0xFF, 0xE5, 0x66, 0x91, 0xC6, 0xEE, 0xF0, 0xA3, 
+0xEF, 0xF0, 0x90, 0xA4, 0xB5, 0xE0, 0xFF, 0x90, 0xA4, 0xB0, 0xE0, 0xFE, 0xD3, 0x9F, 0x40, 0x0B, 
+0xE5, 0x67, 0x54, 0x80, 0xFD, 0xEF, 0x4D, 0xF5, 0x67, 0x80, 0x0C, 0x90, 0xA4, 0xB6, 0xE0, 0xFF, 
+0xEE, 0xC3, 0x9F, 0x50, 0x02, 0x8F, 0x67, 0x91, 0xAF, 0xE5, 0x67, 0x54, 0x80, 0x90, 0xA4, 0xB3, 
+0xF0, 0xEB, 0x70, 0x24, 0x91, 0xD2, 0xC0, 0x83, 0xC0, 0x82, 0xE0, 0xFF, 0x90, 0xA4, 0xB1, 0x12, 
+0x4A, 0x67, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0xF4, 0x5F, 0xD0, 0x82, 0xD0, 0x83, 0xF0, 0x90, 
+0xA4, 0xB2, 0xE0, 0x54, 0x7F, 0xF0, 0x80, 0x3F, 0x91, 0xD2, 0xC0, 0x83, 0xC0, 0x82, 0xE0, 0xFF, 
+0x90, 0xA4, 0xB1, 0x12, 0x4A, 0x67, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0x4F, 0xD0, 0x82, 0xD0, 
+0x83, 0xF0, 0x75, 0xF0, 0x10, 0xE5, 0x66, 0x12, 0x57, 0x07, 0x54, 0x07, 0xFF, 0x90, 0xA4, 0xB2, 
+0xF0, 0x90, 0xA4, 0xB0, 0xE0, 0x90, 0x43, 0xAB, 0x93, 0xFE, 0x33, 0x33, 0x33, 0x54, 0xF8, 0x4F, 
+0x90, 0xA4, 0xB2, 0xF0, 0x44, 0x80, 0xF0, 0x75, 0xF0, 0x10, 0xE5, 0x66, 0x12, 0x53, 0xA8, 0xE5, 
+0x67, 0xF0, 0xE5, 0x66, 0x70, 0x06, 0x90, 0x01, 0xC8, 0xE5, 0x67, 0xF0, 0x90, 0xA4, 0xB2, 0xE0, 
+0xFF, 0x75, 0xF0, 0x10, 0xE5, 0x66, 0x90, 0x81, 0x01, 0x12, 0x48, 0xBD, 0xEF, 0xF0, 0x75, 0xF0, 
+0x10, 0xE5, 0x66, 0x91, 0xBE, 0xE0, 0x54, 0xFC, 0xFF, 0xE5, 0x69, 0x12, 0x7C, 0x2C, 0xE5, 0x66, 
+0x91, 0xBE, 0xEF, 0xF0, 0x7D, 0x01, 0xAF, 0x66, 0x51, 0xFC, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xE5, 
+0x67, 0x54, 0x7F, 0x90, 0xA4, 0xB0, 0xF0, 0x22, 0x8F, 0x57, 0x75, 0xF0, 0x10, 0xEF, 0x90, 0x81, 
+0x05, 0x02, 0x48, 0xBD, 0xE5, 0x5B, 0x25, 0xE0, 0x24, 0x95, 0xF5, 0x82, 0xE4, 0x34, 0x94, 0xF5, 
+0x83, 0x22, 0x90, 0xA4, 0xAF, 0xE0, 0x24, 0x81, 0xF5, 0x82, 0xE4, 0x34, 0x94, 0xF5, 0x83, 0x22, 
+0x12, 0x48, 0xBD, 0xE4, 0xF0, 0xA3, 0x22, 0xB1, 0x10, 0x7F, 0x02, 0x8F, 0x6D, 0x7F, 0x02, 0x12, 
+0x47, 0xE7, 0x90, 0xA2, 0x96, 0xE0, 0x45, 0x6D, 0xF0, 0x22, 0xD1, 0x3F, 0xBF, 0x03, 0x0D, 0x90, 
+0x01, 0xB8, 0xE0, 0x04, 0xF0, 0x90, 0x05, 0x21, 0xE0, 0x44, 0x80, 0xF0, 0x7F, 0x01, 0x80, 0xDB, 
+0x90, 0x01, 0xCC, 0xE0, 0x54, 0x0F, 0x90, 0xA4, 0xEF, 0xF0, 0x90, 0xA4, 0xEF, 0xE0, 0xFD, 0x70, 
+0x02, 0xC1, 0x1B, 0x90, 0xA2, 0xF3, 0xE0, 0xFF, 0x70, 0x06, 0xA3, 0xE0, 0x64, 0x09, 0x60, 0x0A, 
+0xEF, 0x14, 0xFF, 0x90, 0xA2, 0xF4, 0xE0, 0xB5, 0x07, 0x04, 0x7F, 0x01, 0x80, 0x02, 0x7F, 0x00, 
+0xEF, 0x60, 0x08, 0x90, 0x01, 0xC1, 0xE0, 0x44, 0x01, 0xF0, 0x22, 0x90, 0xA4, 0xED, 0xE0, 0xD1, 
+0x70, 0x80, 0x05, 0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 0xF9, 0xFF, 0xEF, 0x5D, 0x70, 0x02, 0xA1, 
+0xFE, 0xE4, 0x90, 0xA4, 0xF0, 0xF0, 0x90, 0xA4, 0xF0, 0xE0, 0xF9, 0xC3, 0x94, 0x04, 0x50, 0x42, 
+0xD1, 0x1D, 0xA4, 0xFF, 0xE9, 0xFD, 0x7C, 0x00, 0x2F, 0xFF, 0xEC, 0x35, 0xF0, 0xFE, 0x74, 0xD0, 
+0xD1, 0x25, 0x90, 0xA2, 0xA3, 0x12, 0x48, 0xBD, 0xE5, 0x82, 0x29, 0x12, 0x4F, 0x73, 0xEF, 0xD1, 
+0x1C, 0xA4, 0x2D, 0xFF, 0xEC, 0x35, 0xF0, 0xFE, 0x74, 0xF0, 0xD1, 0x25, 0x90, 0xA2, 0xA7, 0x12, 
+0x48, 0xBD, 0xE5, 0x82, 0x29, 0x12, 0x4F, 0x73, 0xEF, 0xF0, 0x90, 0xA4, 0xF0, 0xE0, 0x04, 0xF0, 
+0x80, 0xB4, 0x90, 0xA4, 0xEF, 0xE0, 0xFF, 0x90, 0xA4, 0xED, 0x12, 0x4A, 0x67, 0x80, 0x02, 0xC3, 
+0x33, 0xD8, 0xFC, 0xF4, 0x5F, 0x90, 0xA4, 0xEF, 0xF0, 0x90, 0xA4, 0xED, 0xE0, 0xFF, 0x74, 0x01, 
+0xA8, 0x07, 0x08, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0x90, 0x01, 0xCC, 0xF0, 0x90, 0xA4, 0xED, 
+0xE0, 0x04, 0xF0, 0xE0, 0x54, 0x03, 0xF0, 0x90, 0xA2, 0xF4, 0x12, 0x57, 0xE4, 0xB4, 0x0A, 0x02, 
+0x7F, 0x01, 0xEF, 0x70, 0x02, 0xA1, 0x1A, 0xE4, 0x90, 0xA2, 0xF4, 0xF0, 0xA1, 0x1A, 0x90, 0x01, 
+0xC0, 0xE0, 0x44, 0x02, 0xF0, 0x90, 0xA4, 0xED, 0xE0, 0x44, 0x80, 0x90, 0x00, 0x8A, 0xD1, 0x1C, 
+0x90, 0x01, 0xD0, 0x12, 0x48, 0xBD, 0xE0, 0x90, 0x01, 0xC3, 0xF0, 0x22, 0xF0, 0x90, 0xA4, 0xED, 
+0xE0, 0x75, 0xF0, 0x04, 0x22, 0x2F, 0xF5, 0x82, 0x74, 0x01, 0x3E, 0xF5, 0x83, 0xE0, 0xFF, 0x90, 
+0xA2, 0xF4, 0xE0, 0x75, 0xF0, 0x08, 0x22, 0xD1, 0x3F, 0xBF, 0x03, 0x02, 0xD1, 0x4F, 0x22, 0x90, 
+0x01, 0x02, 0xE0, 0x54, 0x03, 0xFF, 0x22, 0xD1, 0x3F, 0xBF, 0x03, 0x02, 0xD1, 0x4F, 0x22, 0x90, 
+0x05, 0x21, 0xE0, 0x54, 0x7F, 0xF0, 0x22, 0x90, 0xA3, 0x8F, 0xE0, 0x30, 0xE0, 0x03, 0x12, 0x7B, 
+0xB3, 0x22, 0x74, 0x95, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x98, 0xF5, 0x83, 0x22, 0xED, 0x54, 0x07, 
+0xFF, 0x74, 0x01, 0x7E, 0x00, 0xA8, 0x07, 0x08, 0x22, 0x90, 0xA3, 0x8F, 0xE0, 0x30, 0xE0, 0x04, 
+0x7F, 0x20, 0x91, 0xEB, 0x22, 0xF1, 0x98, 0xD1, 0xA6, 0xE0, 0xFD, 0x7C, 0x00, 0xD1, 0x71, 0x80, 
+0x05, 0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 0xF9, 0xFF, 0xEE, 0x5C, 0xFE, 0xEF, 0x5D, 0x4E, 0x7F, 
+0x00, 0x60, 0x02, 0x7F, 0x01, 0x22, 0x74, 0xB2, 0x2E, 0xF5, 0x82, 0xE4, 0x34, 0xA3, 0xF5, 0x83, 
+0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x7D, 0x10, 0xED, 0x14, 0xF9, 0x24, 0xB2, 0xD1, 
+0xA9, 0xE0, 0x60, 0x36, 0x7C, 0x08, 0xEC, 0x14, 0x90, 0xA4, 0xF9, 0xF0, 0x74, 0xB2, 0x29, 0xD1, 
+0xA9, 0xE0, 0xFB, 0x7A, 0x00, 0x90, 0xA4, 0xF9, 0xE0, 0xD1, 0x70, 0x80, 0x05, 0xC3, 0x33, 0xCE, 
+0x33, 0xCE, 0xD8, 0xF9, 0x12, 0x75, 0x4B, 0x60, 0x0F, 0xE9, 0x75, 0xF0, 0x08, 0xA4, 0xFF, 0x90, 
+0xA4, 0xF9, 0xE0, 0x2F, 0x04, 0xFF, 0x80, 0x06, 0xDC, 0xCC, 0xDD, 0xBE, 0x7F, 0x00, 0xD0, 0xD0, 
+0x92, 0xAF, 0x22, 0xF1, 0x98, 0xED, 0x70, 0x12, 0xD1, 0xA6, 0xC0, 0x83, 0xC0, 0x82, 0xF1, 0x36, 
+0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0xF4, 0x5E, 0x80, 0x0F, 0xD1, 0xA6, 0xC0, 0x83, 0xC0, 0x82, 
+0xF1, 0x36, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0x4E, 0xD0, 0x82, 0xD0, 0x83, 0xF0, 0xD1, 0xB1, 
+0x90, 0xA3, 0xC2, 0xEF, 0xF0, 0x22, 0xE0, 0xFE, 0x74, 0x01, 0xA8, 0x07, 0x08, 0x22, 0x8B, 0x51, 
+0x8A, 0x52, 0x89, 0x53, 0x12, 0x57, 0xA2, 0xFF, 0xF5, 0x55, 0x12, 0x06, 0x89, 0xFE, 0xC3, 0x13, 
+0x30, 0xE0, 0x07, 0x12, 0x4F, 0x5D, 0xF5, 0x56, 0x80, 0x02, 0x8F, 0x56, 0x85, 0x55, 0x54, 0xE5, 
+0x54, 0xD3, 0x95, 0x56, 0x50, 0x23, 0xAB, 0x51, 0xAA, 0x52, 0xA9, 0x53, 0x12, 0x06, 0x89, 0x54, 
+0x01, 0xFD, 0xAF, 0x54, 0xF1, 0x03, 0xAF, 0x54, 0xD1, 0x85, 0xEF, 0xAF, 0x54, 0x70, 0x04, 0xF1, 
+0x91, 0x80, 0x02, 0xF1, 0x8A, 0x05, 0x54, 0x80, 0xD6, 0x22, 0x91, 0xB8, 0xE0, 0x54, 0xFB, 0xF0, 
+0x22, 0x91, 0xB8, 0xE0, 0x44, 0x04, 0xF0, 0x22, 0xEF, 0x13, 0x13, 0x13, 0x54, 0x1F, 0xFE, 0xEF, 
+0x54, 0x07, 0xFF, 0x22, 0xE4, 0xFD, 0xFF, 0xE1, 0x03, 0xF1, 0xA4, 0x12, 0x6C, 0x6C, 0x12, 0x4E, 
+0x36, 0xF1, 0xD0, 0x90, 0xA3, 0xC3, 0xE0, 0x54, 0x7F, 0xF0, 0x54, 0xBF, 0xF0, 0x54, 0xDF, 0xF0, 
+0x54, 0xF0, 0xF0, 0xE4, 0x90, 0xA3, 0xC5, 0xF0, 0x90, 0xA3, 0xC3, 0xE0, 0x54, 0xEF, 0xF0, 0x22, 
+0x90, 0xA3, 0x8F, 0xE0, 0x54, 0xFE, 0xF1, 0xDE, 0x90, 0xA3, 0x96, 0x02, 0x4F, 0xCA, 0xF0, 0xE4, 
+0xA3, 0xF0, 0xA3, 0xF0, 0x22, 0xF0, 0xA3, 0xEF, 0xF0, 0x75, 0xF0, 0x10, 0x22, 0xC0, 0xE0, 0xC0, 
+0xF0, 0xC0, 0x83, 0xC0, 0x82, 0xC0, 0xD0, 0x75, 0xD0, 0x00, 0xC0, 0x00, 0xC0, 0x01, 0xC0, 0x02, 
+0xC0, 0x03, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0x11, 0x31, 0xE5, 0x24, 0x30, 0xE1, 
+0x05, 0x7F, 0x04, 0x12, 0x64, 0xEB, 0xD0, 0x07, 0xD0, 0x06, 0xD0, 0x05, 0xD0, 0x04, 0xD0, 0x03, 
+0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x82, 0xD0, 0x83, 0xD0, 0xF0, 0xD0, 0xE0, 
+0x32, 0x90, 0x01, 0x3C, 0xE0, 0x55, 0x1D, 0xF5, 0x21, 0xA3, 0xE0, 0x55, 0x1E, 0xF5, 0x22, 0xA3, 
+0xE0, 0x55, 0x1F, 0xF5, 0x23, 0xA3, 0xE0, 0x55, 0x20, 0xF5, 0x24, 0x90, 0x01, 0x3C, 0xE5, 0x21, 
+0xF0, 0xA3, 0xE5, 0x22, 0xF0, 0xA3, 0xE5, 0x23, 0xF0, 0xA3, 0xE5, 0x24, 0xF0, 0x53, 0x91, 0xDF, 
+0x22, 0x32, 0x32, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0xA4, 0xBF, 0xEF, 0xF0, 0xA3, 
+0xED, 0xF0, 0x7D, 0x00, 0x7C, 0x00, 0xE4, 0x90, 0xA4, 0xC5, 0xF0, 0x7F, 0xB0, 0x7E, 0x08, 0x12, 
+0x37, 0xBC, 0xE4, 0xFF, 0xEC, 0x90, 0xA4, 0xC1, 0x12, 0x08, 0x6D, 0x90, 0xA4, 0xC1, 0x12, 0x48, 
+0xB1, 0x90, 0xA4, 0xC0, 0xE0, 0xFF, 0xE4, 0xFC, 0xFD, 0xFE, 0x12, 0x48, 0x87, 0xA3, 0x12, 0x08, 
+0x6D, 0x90, 0xA4, 0xC1, 0x31, 0x2C, 0x7F, 0xB0, 0x7E, 0x08, 0x12, 0x38, 0x07, 0x11, 0xD0, 0x90, 
+0xA4, 0xBF, 0xE0, 0x75, 0xF0, 0x08, 0xA4, 0x24, 0xB5, 0xF5, 0x82, 0xE4, 0x34, 0xAD, 0x12, 0x52, 
+0xB9, 0xFF, 0x12, 0x37, 0xBC, 0xED, 0x54, 0x0F, 0xFD, 0xE4, 0xFC, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 
+0x7F, 0x14, 0x7E, 0x00, 0x02, 0x3D, 0x7A, 0xE4, 0x90, 0xA3, 0xC9, 0xF0, 0xA3, 0xF0, 0x31, 0x43, 
+0xEF, 0x64, 0x01, 0x60, 0x40, 0xC3, 0x90, 0xA3, 0xCA, 0xE0, 0x94, 0x88, 0x90, 0xA3, 0xC9, 0xE0, 
+0x94, 0x13, 0x40, 0x0F, 0x90, 0x01, 0xC1, 0xE0, 0x44, 0x10, 0xF0, 0x90, 0x01, 0xC7, 0x74, 0xFD, 
+0xF0, 0x80, 0x22, 0x90, 0xA3, 0xC9, 0xE4, 0x75, 0xF0, 0x01, 0x12, 0x08, 0xD6, 0x11, 0xD0, 0xD3, 
+0x90, 0xA3, 0xCA, 0xE0, 0x94, 0x32, 0x90, 0xA3, 0xC9, 0xE0, 0x94, 0x00, 0x40, 0xC0, 0x90, 0x01, 
+0xC6, 0xE0, 0x30, 0xE3, 0xB9, 0x90, 0x01, 0xC7, 0x74, 0xFE, 0xF0, 0x22, 0x12, 0x48, 0xA5, 0x90, 
+0xAA, 0xB9, 0x02, 0x08, 0x6D, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x11, 0x63, 0xD0, 0xD0, 
+0x92, 0xAF, 0x22, 0x90, 0x01, 0x9A, 0xE0, 0x54, 0xC0, 0x44, 0x0B, 0x12, 0x5F, 0xA5, 0x90, 0x01, 
+0x98, 0xE0, 0x54, 0xC0, 0x7F, 0x00, 0xB4, 0x40, 0x02, 0x7F, 0x01, 0x22, 0xD3, 0x10, 0xAF, 0x01, 
+0xC3, 0xC0, 0xD0, 0x90, 0xA4, 0x8E, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x12, 0x37, 0xBC, 0x90, 0xA4, 
+0x98, 0x12, 0x08, 0x6D, 0x90, 0xA4, 0x90, 0x12, 0x48, 0xA5, 0x12, 0x08, 0x3A, 0x90, 0xA4, 0x98, 
+0x12, 0x48, 0xB1, 0x12, 0x48, 0x7A, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0xA4, 
+0x90, 0x12, 0x48, 0xA5, 0x90, 0xA4, 0x94, 0x12, 0x48, 0xB1, 0x12, 0x48, 0x7A, 0xD0, 0x03, 0xD0, 
+0x02, 0xD0, 0x01, 0xD0, 0x00, 0x12, 0x48, 0x87, 0x90, 0xA4, 0x9C, 0x12, 0x08, 0x6D, 0x90, 0xA4, 
+0x9C, 0x31, 0x2C, 0x90, 0xA4, 0x8E, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x12, 0x38, 0x07, 0xD0, 0xD0, 
+0x92, 0xAF, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0xC0, 0x07, 0xC0, 0x05, 0x90, 0xA4, 
+0xCE, 0x12, 0x48, 0xA5, 0x90, 0xAA, 0x9C, 0x12, 0x08, 0x6D, 0xD0, 0x05, 0xD0, 0x07, 0x12, 0x32, 
+0x34, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0x02, 0x09, 0xE0, 0xF5, 0x51, 0x12, 0x06, 0x89, 0x25, 
+0x51, 0x90, 0xA2, 0x9C, 0x12, 0x57, 0xA1, 0x25, 0x51, 0x90, 0xA2, 0x9D, 0x12, 0x4F, 0x5C, 0x25, 
+0x51, 0x90, 0xA2, 0x9E, 0xF0, 0x90, 0x00, 0x03, 0x12, 0x06, 0xA2, 0x25, 0x51, 0x90, 0xA2, 0x9F, 
+0x51, 0x31, 0x25, 0x51, 0x90, 0xA2, 0xA0, 0xF0, 0x90, 0x00, 0x05, 0x12, 0x06, 0xA2, 0x25, 0x51, 
+0x90, 0xA2, 0xA1, 0xF0, 0x90, 0x00, 0x06, 0x12, 0x06, 0xA2, 0x25, 0x51, 0x90, 0xA2, 0xA2, 0xF0, 
+0x22, 0xF0, 0x90, 0x00, 0x04, 0x02, 0x06, 0xA2, 0x12, 0x06, 0x89, 0x90, 0xA3, 0xA7, 0x12, 0x57, 
+0xA1, 0x90, 0xA3, 0xA8, 0x12, 0x4F, 0x5C, 0x90, 0xA3, 0xA9, 0xF0, 0x90, 0x00, 0x03, 0x12, 0x06, 
+0xA2, 0x90, 0xA3, 0xAA, 0x51, 0x31, 0x90, 0xA3, 0xAB, 0xF0, 0x22, 0x12, 0x06, 0x89, 0x90, 0xA3, 
+0xAC, 0x12, 0x57, 0xA1, 0x90, 0xA3, 0xAD, 0x12, 0x4F, 0x5C, 0x90, 0xA3, 0xAE, 0xF0, 0x90, 0x00, 
+0x03, 0x12, 0x06, 0xA2, 0x90, 0xA3, 0xAF, 0x51, 0x31, 0x90, 0xA3, 0xB0, 0xF0, 0x22, 0x12, 0x57, 
+0xDE, 0x12, 0x06, 0x89, 0x30, 0xE0, 0x12, 0x71, 0x11, 0x90, 0xA2, 0x9B, 0xE0, 0xB4, 0x01, 0x0C, 
+0x90, 0xFE, 0x10, 0xE0, 0x44, 0x04, 0xF0, 0x80, 0x03, 0x12, 0x5F, 0x32, 0x12, 0x4F, 0x4C, 0x12, 
+0x57, 0xA2, 0x90, 0xA3, 0x90, 0x12, 0x4F, 0x5C, 0x90, 0xA3, 0x91, 0xF0, 0x90, 0xA3, 0x90, 0xE0, 
+0x54, 0x01, 0x90, 0xA3, 0x9D, 0xF0, 0x90, 0xA3, 0x90, 0xE0, 0x54, 0x02, 0x90, 0xA3, 0x9E, 0xF0, 
+0x90, 0xA3, 0x90, 0xE0, 0x54, 0x04, 0x90, 0xA3, 0x9F, 0xF0, 0x90, 0xA3, 0x90, 0xE0, 0x54, 0x08, 
+0x90, 0xA3, 0xA0, 0xF0, 0x90, 0xA3, 0x90, 0xE0, 0x54, 0x10, 0x90, 0xA3, 0xA1, 0xF0, 0x90, 0xA3, 
+0x91, 0xE0, 0x54, 0x01, 0x90, 0xA3, 0xA2, 0xF0, 0x90, 0xA3, 0x91, 0xE0, 0x54, 0x02, 0x90, 0xA3, 
+0xA3, 0xF0, 0x90, 0xA3, 0x91, 0xE0, 0x54, 0x04, 0x90, 0xA3, 0xA4, 0xF0, 0x90, 0xA3, 0x91, 0xE0, 
+0x54, 0x08, 0x90, 0xA3, 0xA5, 0xF0, 0x90, 0xA3, 0x91, 0xE0, 0x54, 0x10, 0x90, 0xA3, 0xA6, 0xF0, 
+0x22, 0x12, 0x5F, 0xDC, 0x90, 0xA3, 0x8D, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0x02, 0x86, 0xE0, 0x44, 
+0x04, 0xF0, 0x90, 0xA3, 0x8F, 0xE0, 0x44, 0x01, 0xF0, 0x7D, 0x08, 0xE4, 0xFF, 0x12, 0x5F, 0xD0, 
+0x90, 0x05, 0x52, 0xE0, 0x54, 0x07, 0x04, 0x90, 0xA3, 0x9A, 0x12, 0x67, 0xDE, 0x90, 0x04, 0x22, 
+0xE0, 0x54, 0xEF, 0xF0, 0x22, 0x12, 0x06, 0x89, 0xFF, 0x90, 0xA3, 0xB1, 0xF0, 0xBF, 0x01, 0x07, 
+0x71, 0x58, 0xE4, 0x90, 0xA3, 0xB1, 0xF0, 0x22, 0x91, 0x03, 0x7F, 0xF5, 0x7E, 0x01, 0x12, 0x33, 
+0xFD, 0xBF, 0x01, 0x06, 0x90, 0xA3, 0xD1, 0xE0, 0xA3, 0xF0, 0x91, 0x03, 0x7F, 0xF6, 0x7E, 0x01, 
+0x12, 0x33, 0xFD, 0xBF, 0x01, 0x08, 0x90, 0xA3, 0xD1, 0xE0, 0x90, 0xA3, 0xD3, 0xF0, 0x91, 0x03, 
+0x7F, 0xF4, 0x7E, 0x01, 0x12, 0x33, 0xFD, 0xBF, 0x01, 0x08, 0x90, 0xA3, 0xD1, 0xE0, 0x90, 0xA3, 
+0xD4, 0xF0, 0x91, 0x03, 0x7F, 0xF3, 0x7E, 0x01, 0x12, 0x33, 0xFD, 0xBF, 0x01, 0x03, 0x12, 0x57, 
+0xF2, 0x91, 0x03, 0x7F, 0xF2, 0x7E, 0x01, 0x12, 0x33, 0xFD, 0xBF, 0x01, 0x08, 0x90, 0xA3, 0xD1, 
+0xE0, 0x90, 0xA3, 0xD6, 0xF0, 0x90, 0xA3, 0xD2, 0xE0, 0xFF, 0xA3, 0xE0, 0xFD, 0xA3, 0xE0, 0xFB, 
+0xA3, 0xE0, 0x90, 0xA3, 0xDA, 0xF0, 0x90, 0xA3, 0xD6, 0xE0, 0x90, 0xA3, 0xDB, 0xF0, 0x90, 0xA3, 
+0xDC, 0x74, 0x12, 0xF0, 0x90, 0xA3, 0xEA, 0x74, 0x05, 0xF0, 0x90, 0xA3, 0xDE, 0xEF, 0xF0, 0xA3, 
+0xED, 0xF0, 0xA3, 0xEB, 0xF0, 0x90, 0xA3, 0xDA, 0xE0, 0x90, 0xA3, 0xE1, 0xF0, 0x90, 0xA3, 0xDB, 
+0xE0, 0x90, 0xA3, 0xE2, 0xF0, 0x7B, 0x01, 0x7A, 0xA3, 0x79, 0xDC, 0x12, 0x54, 0x14, 0x7F, 0x04, 
+0x02, 0x51, 0x36, 0x7B, 0x01, 0x7A, 0xA3, 0x79, 0xD1, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 
+0xD0, 0x90, 0xA2, 0xF4, 0xE0, 0xFF, 0x90, 0xA2, 0xF3, 0xE0, 0xB5, 0x07, 0x04, 0x7F, 0x01, 0x80, 
+0x02, 0x7F, 0x00, 0xEF, 0x70, 0x41, 0x90, 0xA2, 0xF3, 0xE0, 0xFE, 0x75, 0xF0, 0x08, 0x90, 0xA2, 
+0xA3, 0x12, 0x48, 0xBD, 0xE0, 0xFD, 0xEE, 0x75, 0xF0, 0x08, 0xA4, 0x24, 0xA4, 0xF9, 0x74, 0xA2, 
+0x35, 0xF0, 0xFA, 0x7B, 0x01, 0xAF, 0x05, 0x12, 0x52, 0xE2, 0x90, 0xA2, 0xF3, 0x12, 0x57, 0xE4, 
+0xB4, 0x0A, 0x02, 0x7F, 0x01, 0xEF, 0x60, 0x05, 0xE4, 0x90, 0xA2, 0xF3, 0xF0, 0x12, 0x65, 0x10, 
+0x90, 0xA2, 0x96, 0xE0, 0x44, 0x02, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xE4, 0x90, 0xA3, 0x8B, 
+0xF0, 0xA3, 0xF0, 0x90, 0xA2, 0xF3, 0xF0, 0xA3, 0xF0, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 
+0xD0, 0x90, 0xA4, 0xD8, 0xEE, 0xF0, 0xA3, 0xEF, 0x12, 0x67, 0xDE, 0x90, 0xA4, 0xD8, 0xD1, 0x03, 
+0xE0, 0x60, 0x29, 0xC3, 0x90, 0xA4, 0xDB, 0xE0, 0x94, 0xE8, 0x90, 0xA4, 0xDA, 0xE0, 0x94, 0x03, 
+0x40, 0x0B, 0x90, 0x01, 0xC0, 0xE0, 0x44, 0x80, 0xF0, 0x7F, 0x00, 0x80, 0x11, 0x90, 0xA4, 0xDA, 
+0xE4, 0x75, 0xF0, 0x01, 0x12, 0x08, 0xD6, 0x12, 0x5F, 0xA6, 0x80, 0xCF, 0x7F, 0x01, 0xD0, 0xD0, 
+0x92, 0xAF, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0xA4, 0xE0, 0x12, 0x48, 0xD2, 
+0x7F, 0x96, 0x7E, 0x02, 0x91, 0x7A, 0xEF, 0x60, 0x45, 0x12, 0x5F, 0xDC, 0xFE, 0xEF, 0x24, 0x01, 
+0xFF, 0xE4, 0x3E, 0xFE, 0x90, 0xA4, 0xE3, 0xEF, 0xF0, 0xEE, 0xFF, 0x90, 0xFD, 0x11, 0xF0, 0x90, 
+0xA4, 0xE3, 0xE0, 0xFD, 0x90, 0x02, 0x94, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0xA4, 0xE0, 0xB1, 0xFA, 
+0x24, 0x02, 0xFF, 0xE4, 0x33, 0xFE, 0x12, 0x5E, 0x7F, 0x90, 0xA4, 0xE3, 0xE0, 0x24, 0x18, 0xFF, 
+0x90, 0xA4, 0xE0, 0x12, 0x48, 0xC9, 0xB1, 0x88, 0x90, 0x02, 0x96, 0x74, 0x01, 0xF0, 0xD0, 0xD0, 
+0x92, 0xAF, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0xE4, 0xFF, 0x90, 0xA3, 0x8C, 0xE0, 
+0xFE, 0x90, 0xA3, 0x8B, 0xE0, 0xFD, 0xB5, 0x06, 0x04, 0x7E, 0x01, 0x80, 0x02, 0x7E, 0x00, 0xEE, 
+0x64, 0x01, 0x60, 0x3F, 0xED, 0xD1, 0x0C, 0xFA, 0x7B, 0x01, 0x91, 0xC3, 0x7F, 0x01, 0xEF, 0x60, 
+0x32, 0x90, 0xA3, 0x8B, 0xE0, 0x04, 0xF0, 0xE0, 0xB4, 0x0A, 0x02, 0x80, 0x02, 0x7F, 0x00, 0xEF, 
+0x60, 0x05, 0xE4, 0x90, 0xA3, 0x8B, 0xF0, 0x90, 0xA3, 0x8C, 0xE0, 0xFF, 0x90, 0xA3, 0x8B, 0xE0, 
+0xB5, 0x07, 0x04, 0x7F, 0x01, 0x80, 0x02, 0x7F, 0x00, 0xEF, 0x70, 0x07, 0x90, 0xA2, 0x96, 0xE0, 
+0x44, 0x04, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0xA4, 0xDC, 0xEF, 0xF0, 0xA3, 0x12, 0x48, 
+0xD2, 0x90, 0xA4, 0xEE, 0xE0, 0xFE, 0x04, 0xF0, 0x90, 0x00, 0x01, 0xEE, 0x12, 0x06, 0xE1, 0x74, 
+0x00, 0x2F, 0xF9, 0xE4, 0x34, 0xFB, 0xFA, 0x7B, 0x01, 0xC0, 0x03, 0xC0, 0x02, 0xC0, 0x01, 0x90, 
+0xA4, 0xDD, 0x12, 0x48, 0xC9, 0x8B, 0x40, 0x8A, 0x41, 0x89, 0x42, 0x75, 0x43, 0x02, 0xD0, 0x01, 
+0xD0, 0x02, 0xD0, 0x03, 0x12, 0x34, 0x62, 0x90, 0xA4, 0xDC, 0xE0, 0x24, 0x02, 0xF9, 0xE4, 0x34, 
+0xFB, 0xFA, 0x7B, 0x01, 0xC0, 0x03, 0xC0, 0x02, 0xC0, 0x01, 0xA3, 0x12, 0x48, 0xC9, 0xE9, 0x24, 
+0x02, 0xF9, 0xE4, 0x3A, 0x8B, 0x40, 0xF5, 0x41, 0x89, 0x42, 0x90, 0xA4, 0xDD, 0xB1, 0xFA, 0xF5, 
+0x43, 0xD0, 0x01, 0xD0, 0x02, 0xD0, 0x03, 0x02, 0x34, 0x62, 0x12, 0x48, 0xC9, 0x90, 0x00, 0x0E, 
+0x02, 0x06, 0xA2, 0xE0, 0xFE, 0xA3, 0xE0, 0xF5, 0x82, 0x8E, 0x83, 0x22, 0x75, 0xF0, 0x0F, 0xA4, 
+0x24, 0xF5, 0xF9, 0x74, 0xA2, 0x35, 0xF0, 0x22, 0x90, 0xA4, 0xE4, 0x12, 0x48, 0xD2, 0xE4, 0xFF, 
+0x90, 0xA4, 0xE4, 0x12, 0x57, 0x17, 0xFE, 0x74, 0xF0, 0x2F, 0xD1, 0x34, 0xEE, 0xF0, 0x0F, 0xEF, 
+0xB4, 0x10, 0xED, 0x22, 0xF5, 0x82, 0xE4, 0x34, 0x02, 0xF5, 0x83, 0x22, 0x90, 0x01, 0x94, 0xE0, 
+0x44, 0x01, 0xF0, 0x90, 0x01, 0xC7, 0xE4, 0xF0, 0x22, 0x90, 0x01, 0x01, 0xE0, 0x44, 0x04, 0xF0, 
+0x90, 0x01, 0x9A, 0xE0, 0x54, 0xC0, 0x12, 0x5F, 0xA5, 0x90, 0x01, 0x99, 0xE0, 0x44, 0xC0, 0xF0, 
+0x90, 0x01, 0x9B, 0x74, 0x80, 0xF0, 0x22, 0xE4, 0x90, 0xA2, 0x96, 0x02, 0x4F, 0xC8, 0x90, 0x01, 
+0xE4, 0x74, 0x1C, 0xF0, 0xA3, 0xE4, 0xF0, 0x22, 0x90, 0x01, 0x34, 0xE0, 0x55, 0x15, 0xF5, 0x19, 
+0xA3, 0xE0, 0x55, 0x16, 0xF5, 0x1A, 0xA3, 0xE0, 0x55, 0x17, 0xF5, 0x1B, 0xA3, 0xE0, 0x55, 0x18, 
+0xF5, 0x1C, 0x90, 0x01, 0x34, 0xE5, 0x19, 0xF0, 0xA3, 0xE5, 0x1A, 0xF0, 0xA3, 0xE5, 0x1B, 0xF0, 
+0xA3, 0xE5, 0x1C, 0xF0, 0x22, 0x90, 0x01, 0xCF, 0xE0, 0x90, 0xA4, 0x55, 0xF0, 0xE0, 0xFF, 0x30, 
+0xE0, 0x07, 0x90, 0x01, 0xCF, 0xE0, 0x54, 0xFE, 0xF0, 0xEF, 0x30, 0xE5, 0x23, 0x90, 0x01, 0xCF, 
+0xE0, 0x54, 0xDF, 0xF0, 0x90, 0x01, 0x34, 0x74, 0x20, 0xF0, 0xE4, 0xF5, 0xA8, 0xF5, 0xE8, 0x12, 
+0x4F, 0x7B, 0x90, 0x00, 0x03, 0xE0, 0x54, 0xFB, 0xFD, 0x7F, 0x03, 0x12, 0x49, 0xA9, 0x80, 0xFE, 
+0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0xA4, 0xE8, 0xED, 0xF0, 0xA3, 0xEB, 0xF0, 
+0x90, 0xA4, 0xE7, 0xEF, 0xF0, 0xE4, 0xFD, 0xFC, 0x12, 0x5E, 0x07, 0x7C, 0x00, 0xAD, 0x07, 0x90, 
+0xA4, 0xE7, 0xE0, 0x90, 0x04, 0x25, 0xF0, 0x90, 0xA4, 0xE8, 0xE0, 0x60, 0x05, 0xF1, 0x70, 0x44, 
+0x80, 0xF0, 0xAF, 0x05, 0x74, 0x20, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x54, 
+0xC0, 0xF0, 0xF1, 0x70, 0x54, 0xC0, 0xF0, 0xAF, 0x05, 0xF1, 0x65, 0xE0, 0x54, 0x01, 0xFE, 0x90, 
+0xA4, 0xE9, 0xE0, 0x25, 0xE0, 0x25, 0xE0, 0xFB, 0xEE, 0x44, 0x02, 0x4B, 0xFE, 0xF1, 0x65, 0xEE, 
+0xF0, 0x74, 0x11, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0x74, 0xFF, 0xF0, 0x74, 0x29, 
+0x2F, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x54, 0xF7, 0xF0, 0xAE, 0x04, 0xAF, 0x05, 
+0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x74, 0x12, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0x22, 
+0x74, 0x21, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x22, 0xE4, 0x90, 0xA4, 0xF1, 
+0xF0, 0xA3, 0xF0, 0x90, 0x05, 0xF8, 0xE0, 0x70, 0x0F, 0xA3, 0xE0, 0x70, 0x0B, 0xA3, 0xE0, 0x70, 
+0x07, 0xA3, 0xE0, 0x70, 0x03, 0x7F, 0x01, 0x22, 0xD3, 0x90, 0xA4, 0xF2, 0xE0, 0x94, 0xE8, 0x90, 
+0xA4, 0xF1, 0xE0, 0x94, 0x03, 0x40, 0x0A, 0x90, 0x01, 0xC0, 0xE0, 0x44, 0x20, 0xF0, 0x7F, 0x00, 
+0x22, 0x7F, 0x32, 0x7E, 0x00, 0x12, 0x3D, 0x7A, 0x90, 0xA4, 0xF1, 0xE4, 0x75, 0xF0, 0x01, 0x12, 
+0x08, 0xD6, 0x80, 0xBF, 0x7E, 0xFF, 0xED, 0xC3, 0x94, 0x33, 0x40, 0x15, 0xED, 0xD3, 0x94, 0x35, 
+0x50, 0x0F, 0x12, 0x4F, 0x51, 0xC4, 0x13, 0x54, 0x07, 0x30, 0xE0, 0x05, 0xED, 0x14, 0x44, 0x80, 
+0xFE, 0xED, 0x14, 0xFD, 0x74, 0x95, 0x2F, 0x12, 0x73, 0x0E, 0xED, 0xF0, 0xAF, 0x06, 0x22, 0xED, 
+0x54, 0x7F, 0xFC, 0xED, 0x54, 0x80, 0x60, 0x03, 0xAF, 0x04, 0x22, 0xEC, 0xC3, 0x94, 0x33, 0x40, 
+0x1A, 0xEC, 0xD3, 0x94, 0x35, 0x50, 0x14, 0x12, 0x4F, 0x51, 0xC4, 0x13, 0x54, 0x07, 0x30, 0xE0, 
+0x06, 0xEC, 0x44, 0x80, 0xFE, 0x80, 0x06, 0x7E, 0xFF, 0x80, 0x02, 0x7E, 0xFF, 0xAF, 0x06, 0x22, 
+0x8F, 0x5B, 0x75, 0xF0, 0x10, 0xEF, 0x12, 0x53, 0xA8, 0xE0, 0xF5, 0x5C, 0xE4, 0xF5, 0x61, 0xE5, 
+0x5C, 0x54, 0x7F, 0xF5, 0x5D, 0xE5, 0x5C, 0x54, 0x80, 0xFF, 0x75, 0xF0, 0x04, 0xE5, 0x5B, 0xB1, 
+0x14, 0xE0, 0xF5, 0x5F, 0x75, 0xF0, 0x04, 0xE5, 0x5B, 0x12, 0x4C, 0x7C, 0xFE, 0xC4, 0x54, 0x03, 
+0xF5, 0x60, 0xE5, 0x5D, 0x71, 0x3B, 0xE4, 0x93, 0xFC, 0x74, 0x01, 0x93, 0xFD, 0x12, 0x64, 0xC4, 
+0xEC, 0xF0, 0xA3, 0xED, 0xF0, 0xE5, 0x5C, 0x4F, 0xFF, 0x74, 0x95, 0x25, 0x5B, 0x71, 0x0E, 0xEF, 
+0xF0, 0x75, 0xF0, 0x04, 0xE5, 0x5B, 0x12, 0x4C, 0x7C, 0x13, 0x13, 0x54, 0x03, 0xF5, 0x5E, 0x74, 
+0x95, 0x25, 0x5B, 0xB1, 0x1A, 0xE5, 0x5E, 0xF0, 0x12, 0x4D, 0x7F, 0xE0, 0x30, 0xE0, 0x22, 0xE5, 
+0x5D, 0x64, 0x3F, 0x70, 0x1C, 0x71, 0x16, 0x12, 0x4F, 0x55, 0xC4, 0x13, 0x54, 0x07, 0x30, 0xE0, 
+0x05, 0x75, 0x5C, 0xBE, 0x80, 0x03, 0x85, 0x5D, 0x5C, 0x85, 0x5E, 0x69, 0xE4, 0xFB, 0x12, 0x63, 
+0x5F, 0xAD, 0x5C, 0xAF, 0x5B, 0x12, 0x6F, 0xEF, 0xEF, 0xF4, 0x60, 0x0B, 0x8F, 0x5C, 0xEF, 0x30, 
+0xE7, 0x02, 0x61, 0x0B, 0x85, 0x5C, 0x5D, 0xE5, 0x5D, 0x64, 0x2C, 0x70, 0x27, 0x75, 0xF0, 0x04, 
+0xE5, 0x5B, 0x12, 0x4C, 0x7C, 0xFF, 0x54, 0x03, 0xFE, 0xE5, 0x5E, 0xC3, 0x9E, 0x50, 0x15, 0x05, 
+0x5E, 0xE5, 0x5E, 0xB1, 0x2D, 0xE5, 0x5B, 0x90, 0x96, 0x18, 0x12, 0x48, 0xBD, 0xEF, 0x54, 0xF3, 
+0x4E, 0xF0, 0x41, 0xC5, 0xE5, 0x5D, 0xC3, 0x95, 0x5F, 0x40, 0x02, 0x41, 0xCA, 0xE5, 0x5D, 0xC3, 
+0x94, 0x0C, 0x40, 0x13, 0xE5, 0x5D, 0x94, 0x13, 0x50, 0x0D, 0x12, 0x4D, 0x7F, 0xE0, 0xFF, 0x20, 
+0xE3, 0x05, 0x75, 0x61, 0x01, 0x80, 0x18, 0xE5, 0x5D, 0xC3, 0x94, 0x2C, 0x40, 0x1A, 0xE5, 0x5D, 
+0x94, 0x35, 0x50, 0x14, 0x12, 0x4D, 0x7F, 0xE0, 0xFF, 0x20, 0xE3, 0x0C, 0x75, 0x61, 0x02, 0x12, 
+0x4D, 0x7F, 0xEF, 0x44, 0x08, 0xF0, 0x80, 0x07, 0x12, 0x4D, 0x7C, 0xE0, 0x54, 0xF7, 0xF0, 0x12, 
+0x4D, 0x7F, 0xE0, 0x20, 0xE6, 0x03, 0x30, 0xE1, 0x07, 0x12, 0x4D, 0x7C, 0xE0, 0x54, 0xF7, 0xF0, 
+0xE5, 0x61, 0x64, 0x01, 0x70, 0x70, 0x71, 0x1F, 0x20, 0xE7, 0x0E, 0x20, 0xE6, 0x0B, 0x20, 0xE5, 
+0x08, 0x20, 0xE4, 0x05, 0x71, 0x2C, 0x30, 0xE0, 0x5D, 0x12, 0x4D, 0x7F, 0xE0, 0x44, 0x04, 0xF0, 
+0xE5, 0x5D, 0xB4, 0x0C, 0x08, 0x75, 0x5D, 0x14, 0x75, 0x5C, 0x14, 0x41, 0x40, 0xE5, 0x5D, 0xB4, 
+0x0D, 0x02, 0x80, 0x05, 0xE5, 0x5D, 0xB4, 0x0E, 0x08, 0x75, 0x5D, 0x15, 0x75, 0x5C, 0x15, 0x41, 
+0x40, 0xE5, 0x5D, 0xB4, 0x0F, 0x08, 0x75, 0x5D, 0x16, 0x75, 0x5C, 0x16, 0x41, 0x40, 0xE5, 0x5D, 
+0xC3, 0x94, 0x10, 0x40, 0x08, 0x75, 0x5D, 0x17, 0x75, 0x5C, 0x17, 0x41, 0x40, 0xE5, 0x5D, 0xC3, 
+0x94, 0x11, 0x50, 0x02, 0x41, 0x40, 0xE5, 0x5D, 0x94, 0x13, 0x40, 0x02, 0x41, 0x40, 0x75, 0x5D, 
+0x18, 0x75, 0x5C, 0x18, 0x80, 0x7A, 0xE5, 0x61, 0x64, 0x02, 0x70, 0x79, 0x71, 0x1F, 0x20, 0xE6, 
+0x0E, 0x20, 0xE7, 0x0B, 0x71, 0x2C, 0x20, 0xE0, 0x06, 0x20, 0xE1, 0x03, 0x30, 0xE2, 0x66, 0xE5, 
+0x5D, 0x64, 0x2C, 0x60, 0x05, 0xE5, 0x5D, 0xB4, 0x2D, 0x08, 0x75, 0x5D, 0x36, 0x75, 0x5C, 0x36, 
+0x80, 0x4E, 0xE5, 0x5D, 0x64, 0x2E, 0x60, 0x05, 0xE5, 0x5D, 0xB4, 0x2F, 0x08, 0x75, 0x5D, 0x37, 
+0x75, 0x5C, 0x37, 0x80, 0x3B, 0xE5, 0x5D, 0xB4, 0x30, 0x08, 0x75, 0x5D, 0x38, 0x75, 0x5C, 0x38, 
+0x80, 0x2E, 0xE5, 0x5D, 0xB4, 0x31, 0x08, 0x75, 0x5D, 0x39, 0x75, 0x5C, 0x39, 0x80, 0x21, 0xE5, 
+0x5D, 0xC3, 0x94, 0x32, 0x40, 0x0F, 0xE5, 0x5D, 0xD3, 0x94, 0x34, 0x50, 0x08, 0x75, 0x5D, 0x3A, 
+0x75, 0x5C, 0x3A, 0x80, 0x0B, 0xE5, 0x5D, 0xB4, 0x35, 0x06, 0x75, 0x5D, 0x3B, 0x75, 0x5C, 0x3B, 
+0x12, 0x63, 0x5A, 0x80, 0x07, 0x12, 0x4D, 0x7F, 0xE0, 0x54, 0xFB, 0xF0, 0xAD, 0x5D, 0xAF, 0x60, 
+0x71, 0x47, 0x8F, 0x5D, 0xAD, 0x5F, 0xAF, 0x60, 0x71, 0x47, 0x8F, 0x5F, 0xE5, 0x5D, 0x04, 0xFD, 
+0xED, 0xD3, 0x95, 0x5F, 0x50, 0x39, 0xB1, 0x22, 0xE5, 0x5B, 0x12, 0x4F, 0x6B, 0xE0, 0xFB, 0x7A, 
+0x00, 0x12, 0x66, 0x6D, 0x80, 0x05, 0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 0xF9, 0xB1, 0x4B, 0x60, 
+0x1B, 0xE5, 0x5D, 0xB4, 0x13, 0x0F, 0x75, 0x5D, 0x18, 0x85, 0x5D, 0x5C, 0x12, 0x4D, 0x7F, 0xE0, 
+0x44, 0x04, 0xF0, 0x80, 0x0A, 0x8D, 0x5D, 0x85, 0x5D, 0x5C, 0x80, 0x03, 0x0D, 0x80, 0xC1, 0xAD, 
+0x5C, 0xAF, 0x60, 0xB1, 0x38, 0x8F, 0x5C, 0x12, 0x4D, 0x7F, 0xE0, 0x30, 0xE0, 0x5D, 0xE5, 0x5D, 
+0x64, 0x3F, 0x70, 0x57, 0x71, 0x16, 0x12, 0x4F, 0x55, 0xC4, 0x13, 0x54, 0x07, 0x30, 0xE0, 0x05, 
+0x75, 0x5C, 0xBE, 0x80, 0x46, 0x85, 0x5D, 0x5C, 0x80, 0x41, 0xE5, 0x5D, 0x65, 0x5F, 0x70, 0x30, 
+0x75, 0xF0, 0x04, 0xE5, 0x5B, 0x12, 0x4F, 0x55, 0xC4, 0x13, 0x54, 0x07, 0x30, 0xE0, 0x0D, 0xE5, 
+0x5C, 0x20, 0xE7, 0x08, 0xE5, 0x5D, 0x44, 0x80, 0xF5, 0x5C, 0x80, 0x1F, 0xE5, 0x5D, 0x71, 0x3B, 
+0xE4, 0x93, 0xFE, 0x74, 0x01, 0x93, 0xFF, 0x12, 0x64, 0xC4, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x22, 
+0x74, 0x95, 0x25, 0x5B, 0x71, 0x0E, 0xE5, 0x5F, 0xF0, 0xF5, 0x5C, 0x02, 0x63, 0x5A, 0xF5, 0x82, 
+0xE4, 0x34, 0xA1, 0xF5, 0x83, 0x22, 0x75, 0x5D, 0x3E, 0x75, 0xF0, 0x04, 0xE5, 0x5B, 0x22, 0x75, 
+0xF0, 0x08, 0xE5, 0x5B, 0x90, 0x89, 0x02, 0x12, 0x48, 0xBD, 0xE0, 0x22, 0x75, 0xF0, 0x08, 0xE5, 
+0x5B, 0x90, 0x89, 0x03, 0x12, 0x48, 0xBD, 0xE0, 0x22, 0xE5, 0x53, 0x25, 0xE0, 0x24, 0x4F, 0xF5, 
+0x82, 0xE4, 0x34, 0x42, 0xF5, 0x83, 0x22, 0xEF, 0x60, 0x0A, 0xED, 0xC3, 0x94, 0x2C, 0x40, 0x04, 
+0x7E, 0x20, 0x80, 0x02, 0xE4, 0xFE, 0xC3, 0xED, 0x9E, 0xFF, 0x22, 0xAA, 0x07, 0xAB, 0x05, 0x75, 
+0xF0, 0x10, 0xEA, 0x12, 0x53, 0xA8, 0xE0, 0xF5, 0x5B, 0x54, 0x7F, 0xF5, 0x5D, 0x75, 0xF0, 0x04, 
+0xEA, 0x12, 0x4F, 0xE8, 0xE0, 0xF9, 0x75, 0xF0, 0x04, 0xEA, 0xB1, 0x14, 0xE0, 0xFC, 0x75, 0xF0, 
+0x04, 0xEA, 0x12, 0x4C, 0x7C, 0x13, 0x13, 0x54, 0x03, 0xF5, 0x5C, 0xE5, 0x5D, 0xB1, 0x53, 0xFE, 
+0x74, 0x01, 0x93, 0xFF, 0xEA, 0x12, 0x64, 0xC6, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x75, 0xF0, 0x04, 
+0xEA, 0x12, 0x4C, 0x7C, 0xC4, 0x54, 0x03, 0x90, 0xA3, 0xDE, 0xF0, 0x74, 0x95, 0x2A, 0x71, 0x0E, 
+0xE5, 0x5D, 0xF0, 0x74, 0x95, 0x2A, 0xB1, 0x1A, 0xE5, 0x5C, 0xF0, 0xE5, 0x5D, 0xD3, 0x9C, 0x40, 
+0x06, 0x8C, 0x5D, 0xAF, 0x04, 0x8F, 0x5B, 0xEB, 0x70, 0x02, 0x81, 0xB6, 0xAF, 0x03, 0x8F, 0x5E, 
+0xE5, 0x5B, 0x30, 0xE7, 0x05, 0x85, 0x5D, 0x5B, 0x15, 0x5E, 0xE5, 0x5E, 0x70, 0x02, 0x81, 0xB6, 
+0xAF, 0x02, 0xAD, 0x5B, 0x12, 0x6F, 0xC4, 0xEF, 0xF4, 0x60, 0x0A, 0x8F, 0x5B, 0x15, 0x5E, 0xE5, 
+0x5E, 0x70, 0x02, 0x81, 0xB6, 0xE5, 0x5D, 0x64, 0x2C, 0x70, 0x26, 0xE5, 0x5C, 0xD3, 0x94, 0x00, 
+0x40, 0x1F, 0xE5, 0x5C, 0xD3, 0x94, 0x02, 0x50, 0x18, 0x15, 0x5C, 0xE5, 0x5C, 0x54, 0x03, 0x25, 
+0xE0, 0x25, 0xE0, 0xFF, 0x75, 0xF0, 0x04, 0xEA, 0x12, 0x4C, 0x7C, 0x54, 0xF3, 0x4F, 0xF0, 0x15, 
+0x5E, 0xE5, 0x5E, 0x70, 0x02, 0x81, 0xB6, 0xE5, 0x5D, 0xD3, 0x99, 0x50, 0x02, 0x81, 0xB2, 0xE4, 
+0x90, 0xA3, 0xDF, 0xF0, 0x90, 0xA3, 0xDE, 0xE0, 0xFF, 0xAD, 0x5D, 0x71, 0x47, 0x8F, 0x5D, 0x85, 
+0x5D, 0x5B, 0xE0, 0xFF, 0xAD, 0x01, 0x71, 0x47, 0xA9, 0x07, 0x90, 0xA3, 0xE0, 0xE5, 0x5B, 0xF0, 
+0xE5, 0x5D, 0x14, 0xFD, 0xED, 0xC3, 0x99, 0x40, 0x46, 0xB1, 0x22, 0xEA, 0x12, 0x4F, 0x6B, 0xE0, 
+0xF5, 0x82, 0x75, 0x83, 0x00, 0x12, 0x66, 0x6D, 0x80, 0x05, 0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 
+0xF9, 0xFF, 0xEE, 0x55, 0x83, 0xFE, 0xEF, 0x55, 0x82, 0x4E, 0x60, 0x20, 0xE5, 0x5D, 0x90, 0xA3, 
+0xE0, 0xB4, 0x14, 0x05, 0x74, 0x0C, 0xF0, 0x80, 0x02, 0xED, 0xF0, 0x90, 0xA3, 0xDF, 0xE0, 0x04, 
+0xF0, 0xE0, 0x65, 0x5E, 0x60, 0x09, 0xA3, 0xE0, 0xD3, 0x99, 0x40, 0x03, 0x1D, 0x80, 0xB5, 0x90, 
+0xA3, 0xE0, 0xE0, 0xF5, 0x5B, 0x90, 0xA3, 0xDE, 0xE0, 0xFF, 0xAD, 0x5B, 0xB1, 0x38, 0x8F, 0x5B, 
+0x80, 0x04, 0xAF, 0x01, 0x8F, 0x5B, 0xAF, 0x02, 0x85, 0x5C, 0x69, 0xE4, 0xFB, 0xAD, 0x5B, 0x02, 
+0x63, 0x63, 0x75, 0xF0, 0x04, 0xEF, 0x12, 0x4C, 0x7C, 0xFE, 0x13, 0x13, 0x54, 0x03, 0xFC, 0xB1, 
+0x10, 0xE0, 0xFB, 0x74, 0x95, 0x2F, 0x71, 0x0E, 0xE0, 0x54, 0x7F, 0xFD, 0x64, 0x2C, 0x70, 0x18, 
+0xEE, 0x54, 0x03, 0xFE, 0xEC, 0xD3, 0x9E, 0x50, 0x0F, 0xEC, 0x60, 0x0C, 0x1C, 0xEC, 0xB1, 0x2D, 
+0xEF, 0x12, 0x4C, 0x7C, 0x54, 0xF3, 0x4E, 0xF0, 0xED, 0xD3, 0x9B, 0x40, 0x02, 0xAD, 0x03, 0x74, 
+0x95, 0x2F, 0x71, 0x0E, 0xE0, 0x54, 0x80, 0x42, 0x05, 0x8C, 0x69, 0xE4, 0xFB, 0x02, 0x63, 0x63, 
+0x75, 0xF0, 0x04, 0xEF, 0x90, 0x96, 0x15, 0x02, 0x48, 0xBD, 0xF5, 0x82, 0xE4, 0x34, 0x9D, 0xF5, 
+0x83, 0x22, 0xED, 0x13, 0x13, 0x13, 0x54, 0x1F, 0xFF, 0x75, 0xF0, 0x08, 0x22, 0x54, 0x03, 0x25, 
+0xE0, 0x25, 0xE0, 0xFE, 0x75, 0xF0, 0x04, 0x22, 0xEF, 0x60, 0x0A, 0xED, 0xD3, 0x94, 0x0B, 0x40, 
+0x04, 0x7E, 0x20, 0x80, 0x02, 0xE4, 0xFE, 0xED, 0x2E, 0xFF, 0x22, 0xFF, 0xEE, 0x5A, 0xFE, 0xEF, 
+0x5B, 0x4E, 0x22, 0x25, 0xE0, 0x24, 0xF7, 0xF5, 0x82, 0xE4, 0x34, 0x42, 0xF5, 0x83, 0xE4, 0x93, 
+0x22, 0x8F, 0x52, 0x8D, 0x53, 0x8B, 0x54, 0x75, 0xF0, 0x04, 0xEF, 0x12, 0x4C, 0x7C, 0xC4, 0x54, 
+0x03, 0x90, 0xA3, 0xD6, 0xF0, 0x90, 0xA3, 0xD4, 0x60, 0x09, 0x74, 0x32, 0xF0, 0xA3, 0x74, 0x2F, 
+0xF0, 0x80, 0x07, 0x74, 0x11, 0xF0, 0xA3, 0x74, 0x0F, 0xF0, 0xE5, 0x53, 0xD3, 0x94, 0x2D, 0x40, 
+0x09, 0x75, 0xF0, 0x04, 0xE5, 0x52, 0xB1, 0x14, 0x80, 0x20, 0xE5, 0x53, 0xD3, 0x94, 0x1E, 0x40, 
+0x05, 0x90, 0xA3, 0xD4, 0x80, 0x14, 0xE5, 0x53, 0xD3, 0x94, 0x14, 0x40, 0x05, 0x90, 0xA3, 0xD5, 
+0x80, 0x08, 0x75, 0xF0, 0x04, 0xE5, 0x52, 0x12, 0x4F, 0xE8, 0xE0, 0xFD, 0x85, 0x54, 0x69, 0xE4, 
+0xFB, 0xAF, 0x52, 0x02, 0x63, 0x63, 0x90, 0xA4, 0x7C, 0xEB, 0xF0, 0x70, 0x5E, 0x90, 0xA4, 0x7C, 
+0xE0, 0xFE, 0xD1, 0x2C, 0xE0, 0xFC, 0x90, 0xA4, 0x7D, 0xE0, 0xFB, 0xEC, 0x6B, 0x60, 0x4C, 0x90, 
+0xA4, 0x81, 0xEB, 0xF0, 0xA3, 0xEE, 0xF0, 0xAE, 0x05, 0xEE, 0x25, 0xE0, 0x4F, 0xFF, 0x90, 0xA2, 
+0x95, 0xE0, 0xFE, 0x25, 0xE0, 0x25, 0xE0, 0x4F, 0x90, 0xA4, 0x83, 0xF0, 0x90, 0xA4, 0x7E, 0xE0, 
+0x90, 0xA4, 0x85, 0xF0, 0x90, 0xA4, 0x7F, 0x74, 0x0C, 0xF0, 0x90, 0xA4, 0x8D, 0x74, 0x04, 0xF0, 
+0x7B, 0x01, 0x7A, 0xA4, 0x79, 0x7F, 0x12, 0x54, 0x14, 0x7F, 0x04, 0x12, 0x51, 0x36, 0x90, 0xA4, 
+0x7D, 0xE0, 0xFF, 0x90, 0xA4, 0x7C, 0xE0, 0xD1, 0x2C, 0xEF, 0xF0, 0x22, 0x24, 0x15, 0xF5, 0x82, 
+0xE4, 0x34, 0x99, 0xF5, 0x83, 0x22, 0xE4, 0xF5, 0x51, 0x90, 0xA3, 0xC2, 0xE0, 0xFF, 0xE5, 0x51, 
+0xC3, 0x9F, 0x40, 0x03, 0x02, 0x7A, 0xF7, 0xAF, 0x51, 0x12, 0x66, 0x85, 0xEF, 0x70, 0x03, 0x02, 
+0x7A, 0xF2, 0x12, 0x4C, 0x77, 0x12, 0x4F, 0xDC, 0x30, 0xE0, 0x03, 0x02, 0x7A, 0xF2, 0x12, 0x7C, 
+0x0E, 0x70, 0x07, 0xE5, 0x51, 0x6E, 0x70, 0x02, 0x80, 0x0A, 0x12, 0x7C, 0x0E, 0x70, 0x33, 0xE5, 
+0x51, 0x6E, 0x70, 0x2E, 0xA3, 0xE0, 0xF5, 0x52, 0xA3, 0xE0, 0x90, 0xA3, 0xDC, 0xF0, 0x75, 0xF0, 
+0x10, 0xE5, 0x51, 0x12, 0x53, 0xA8, 0xE5, 0x52, 0xF0, 0x75, 0xF0, 0x10, 0x12, 0x64, 0xBE, 0xE0, 
+0x54, 0xFC, 0xFF, 0x90, 0xA3, 0xDC, 0xE0, 0x12, 0x7C, 0x2C, 0xE5, 0x51, 0x12, 0x64, 0xBE, 0xEF, 
+0xF0, 0x22, 0xE5, 0x51, 0x12, 0x63, 0x52, 0x34, 0x92, 0x12, 0x52, 0xB9, 0xD3, 0x94, 0x00, 0xEE, 
+0x94, 0x00, 0x50, 0x03, 0x02, 0x7A, 0xF2, 0xE5, 0x51, 0x75, 0xF0, 0x0A, 0xA4, 0x24, 0x01, 0xF9, 
+0x74, 0x8D, 0x35, 0xF0, 0xFA, 0x7B, 0x01, 0x90, 0xA3, 0xD0, 0x12, 0x48, 0xD2, 0xE5, 0x51, 0x12, 
+0x63, 0x52, 0x34, 0x92, 0xF5, 0x83, 0xE0, 0xF5, 0x56, 0xA3, 0xE0, 0xF5, 0x57, 0x74, 0x95, 0x25, 
+0x51, 0x12, 0x66, 0x65, 0xE0, 0xFF, 0x90, 0xA3, 0xD3, 0xE4, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0x00, 
+0x02, 0x12, 0x07, 0xAB, 0xFF, 0xAE, 0xF0, 0x12, 0x07, 0x80, 0x2F, 0xFF, 0xE5, 0xF0, 0x3E, 0xFE, 
+0x90, 0x00, 0x04, 0x12, 0x7C, 0x05, 0xFE, 0x90, 0x00, 0x06, 0x12, 0x7C, 0x05, 0xFE, 0x12, 0x7B, 
+0x29, 0x2F, 0xFF, 0xEE, 0x35, 0xF0, 0x90, 0xA3, 0xD5, 0xF0, 0xA3, 0xEF, 0xF0, 0x12, 0x07, 0x80, 
+0xFF, 0xC3, 0x90, 0xA3, 0xD6, 0xE0, 0x9F, 0xFE, 0x90, 0xA3, 0xD5, 0xE0, 0x95, 0xF0, 0x90, 0xA3, 
+0xD7, 0xF0, 0xA3, 0xCE, 0xF0, 0x90, 0x00, 0x06, 0x12, 0x07, 0xAB, 0xFD, 0xAC, 0xF0, 0x25, 0xE0, 
+0xFF, 0xEC, 0x33, 0xFE, 0xEF, 0x2D, 0xFD, 0xEE, 0x3C, 0xFC, 0x90, 0x00, 0x04, 0x12, 0x07, 0xAB, 
+0x25, 0xE0, 0xFF, 0xE5, 0xF0, 0x33, 0xFE, 0x90, 0x00, 0x02, 0x12, 0x7C, 0x05, 0xCF, 0x2D, 0xFD, 
+0xEF, 0x3C, 0xFC, 0x12, 0x7B, 0x23, 0xAE, 0xF0, 0x78, 0x02, 0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 
+0xF9, 0x2D, 0xFF, 0xEC, 0x3E, 0x90, 0xA3, 0xD9, 0x12, 0x67, 0xE5, 0xE5, 0x51, 0x12, 0x53, 0xA8, 
+0xE0, 0xF5, 0x52, 0x54, 0x7F, 0xF5, 0x53, 0x75, 0xF0, 0x04, 0xE5, 0x51, 0xB1, 0x14, 0xE0, 0x90, 
+0xA3, 0xDB, 0xF0, 0x12, 0x4C, 0x77, 0x13, 0x13, 0x54, 0x03, 0x90, 0xA3, 0xDC, 0xF0, 0x74, 0x15, 
+0x25, 0x51, 0xF5, 0x82, 0xE4, 0x34, 0x9F, 0xF5, 0x83, 0xE0, 0xC3, 0x94, 0x05, 0x40, 0x03, 0x02, 
+0x7A, 0x1D, 0x90, 0xA3, 0xDB, 0xE0, 0xFF, 0xE5, 0x53, 0x9F, 0x40, 0x08, 0x8F, 0x53, 0x53, 0x52, 
+0x80, 0xEF, 0x42, 0x52, 0xE5, 0x53, 0x90, 0x41, 0xFB, 0x93, 0x12, 0x4F, 0xED, 0xE0, 0xC3, 0x9F, 
+0xE5, 0x53, 0x40, 0x05, 0x90, 0x41, 0x53, 0x80, 0x03, 0x90, 0x41, 0xA7, 0x93, 0xF5, 0x58, 0xE5, 
+0x58, 0x75, 0xF0, 0x06, 0xA4, 0x24, 0xB1, 0xF9, 0x74, 0x40, 0x35, 0xF0, 0xFA, 0x7B, 0xFF, 0x90, 
+0xA3, 0xCD, 0x12, 0x48, 0xD2, 0xC3, 0xE5, 0x57, 0x94, 0x0F, 0xE5, 0x56, 0x94, 0x00, 0x50, 0x52, 
+0x71, 0x13, 0x90, 0x00, 0x06, 0x12, 0x07, 0xAB, 0xFF, 0xAE, 0xF0, 0x71, 0x29, 0x2F, 0xFD, 0xE5, 
+0xF0, 0x3E, 0xFC, 0x71, 0x00, 0xFF, 0xD3, 0xED, 0x9F, 0xEC, 0x9E, 0x40, 0x09, 0x7D, 0x01, 0xAF, 
+0x51, 0x12, 0x73, 0x5B, 0x21, 0xFF, 0xE5, 0x57, 0xAE, 0x56, 0x78, 0x02, 0xCE, 0xC3, 0x13, 0xCE, 
+0x13, 0xD8, 0xF9, 0xFD, 0xAC, 0x06, 0x71, 0x00, 0x2D, 0xFF, 0xEE, 0x3C, 0xFE, 0x71, 0x13, 0x12, 
+0x07, 0x80, 0xD3, 0x9F, 0xE5, 0xF0, 0x9E, 0x50, 0x02, 0x21, 0xFF, 0xAF, 0x51, 0x12, 0x70, 0x20, 
+0x21, 0xFF, 0xE5, 0x51, 0x64, 0x01, 0x70, 0x3A, 0x71, 0x23, 0xFD, 0xAC, 0xF0, 0x71, 0x00, 0xFF, 
+0xC3, 0xED, 0x9F, 0xEC, 0x9E, 0x50, 0x08, 0x90, 0xA2, 0x95, 0x74, 0x01, 0xF0, 0x80, 0x23, 0xE5, 
+0x57, 0xAE, 0x56, 0x78, 0x03, 0xCE, 0xC3, 0x13, 0xCE, 0x13, 0xD8, 0xF9, 0xFB, 0xAA, 0x06, 0x71, 
+0x00, 0x2B, 0xFF, 0xEE, 0x3A, 0xFE, 0xD3, 0xED, 0x9F, 0xEC, 0x9E, 0x40, 0x05, 0xE4, 0x90, 0xA2, 
+0x95, 0xF0, 0xD3, 0xE5, 0x57, 0x94, 0xE8, 0xE5, 0x56, 0x94, 0x03, 0x40, 0x05, 0x75, 0x59, 0x05, 
+0x80, 0x13, 0xD3, 0xE5, 0x57, 0x94, 0xC8, 0xE5, 0x56, 0x94, 0x00, 0x40, 0x05, 0x75, 0x59, 0x02, 
+0x80, 0x03, 0xE4, 0xF5, 0x59, 0xE5, 0x51, 0x12, 0x64, 0xC6, 0xE0, 0xF5, 0x54, 0xA3, 0xE0, 0xF5, 
+0x55, 0xE4, 0xF5, 0x5A, 0x71, 0x13, 0x75, 0xF0, 0x02, 0xE5, 0x5A, 0xA4, 0xF5, 0x82, 0x85, 0xF0, 
+0x83, 0x12, 0x07, 0xAB, 0xAE, 0xF0, 0xA8, 0x59, 0x08, 0x80, 0x05, 0xCE, 0xC3, 0x13, 0xCE, 0x13, 
+0xD8, 0xF9, 0xFF, 0x90, 0xA3, 0xCD, 0x12, 0x48, 0xC9, 0x85, 0x5A, 0x82, 0x12, 0x57, 0x1C, 0xFD, 
+0x7C, 0x00, 0x12, 0x07, 0x03, 0xEF, 0x25, 0x55, 0xF5, 0x55, 0xEE, 0x35, 0x54, 0xF5, 0x54, 0x05, 
+0x5A, 0xE5, 0x5A, 0xB4, 0x05, 0xBE, 0x90, 0xA3, 0xCD, 0x12, 0x48, 0xC9, 0x90, 0x00, 0x05, 0x12, 
+0x06, 0xA2, 0xFD, 0x7C, 0x00, 0xE5, 0x57, 0xAE, 0x56, 0xA8, 0x59, 0x08, 0x80, 0x05, 0xCE, 0xC3, 
+0x13, 0xCE, 0x13, 0xD8, 0xF9, 0xFF, 0x12, 0x07, 0x03, 0xD3, 0xE5, 0x55, 0x9F, 0xE5, 0x54, 0x9E, 
+0x40, 0x0C, 0xE5, 0x55, 0x9F, 0xF5, 0x55, 0xE5, 0x54, 0x9E, 0xF5, 0x54, 0x80, 0x05, 0xE4, 0xF5, 
+0x54, 0xF5, 0x55, 0xE5, 0x51, 0x12, 0x64, 0xC6, 0xE5, 0x54, 0xF0, 0xA3, 0xE5, 0x55, 0xF0, 0x12, 
+0x73, 0x39, 0xC3, 0x71, 0x53, 0x50, 0x07, 0xAF, 0x51, 0x12, 0x70, 0x20, 0x80, 0x5D, 0xE5, 0x53, 
+0x25, 0xE0, 0x24, 0xF7, 0xF5, 0x82, 0xE4, 0x34, 0x42, 0xF5, 0x83, 0xD3, 0x71, 0x53, 0x40, 0x53, 
+0x74, 0x95, 0x25, 0x51, 0x12, 0x4D, 0x83, 0xE0, 0x20, 0xE6, 0x03, 0x30, 0xE1, 0x07, 0xE4, 0x90, 
+0xA3, 0xDD, 0xF0, 0x80, 0x06, 0x90, 0xA3, 0xDD, 0x74, 0x01, 0xF0, 0xE5, 0x53, 0xB4, 0x3A, 0x0B, 
+0x90, 0xA3, 0xDD, 0xE0, 0xB4, 0x01, 0x04, 0x7D, 0x08, 0x80, 0x1B, 0xE5, 0x53, 0xB4, 0x18, 0x0B, 
+0x90, 0xA3, 0xDD, 0xE0, 0xB4, 0x01, 0x04, 0x7D, 0x07, 0x80, 0x0B, 0xE5, 0x53, 0xB4, 0x36, 0x04, 
+0x7D, 0x09, 0x80, 0x02, 0x7D, 0x01, 0xAF, 0x51, 0x12, 0x73, 0x5B, 0x71, 0x09, 0xF5, 0x83, 0xE4, 
+0xF0, 0x80, 0x3C, 0x71, 0x09, 0xF5, 0x83, 0xE0, 0x04, 0xF0, 0x71, 0x09, 0xF5, 0x83, 0xE0, 0xC3, 
+0x94, 0x05, 0x40, 0x2B, 0x71, 0x09, 0xF5, 0x83, 0xE4, 0xF0, 0xE5, 0x53, 0x12, 0x75, 0x53, 0xFE, 
+0x74, 0x01, 0x93, 0xFF, 0x12, 0x73, 0x39, 0x74, 0x01, 0x93, 0x2F, 0xFF, 0xE4, 0x93, 0x3E, 0xC3, 
+0x13, 0xFE, 0xEF, 0x13, 0xFF, 0xE5, 0x51, 0x12, 0x64, 0xC6, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0xE5, 
+0x51, 0x12, 0x64, 0xC6, 0xA3, 0xE0, 0x90, 0xA4, 0x7E, 0xF0, 0x90, 0xA4, 0x7D, 0xE5, 0x52, 0xF0, 
+0xAB, 0x51, 0xE4, 0xFD, 0xFF, 0x12, 0x75, 0xC6, 0xE4, 0xF5, 0x54, 0xF5, 0x55, 0x74, 0x81, 0x25, 
+0x51, 0x12, 0x62, 0xBE, 0xE0, 0x64, 0x01, 0x60, 0x02, 0x41, 0xEB, 0x90, 0xA3, 0xD3, 0x71, 0x3C, 
+0xE5, 0x51, 0x12, 0x53, 0x78, 0x71, 0x2F, 0x50, 0x08, 0x12, 0x53, 0x78, 0x12, 0x5F, 0x9D, 0x80, 
+0x05, 0x12, 0x53, 0x78, 0x51, 0xF8, 0x90, 0xA3, 0xD5, 0x71, 0x3C, 0xE5, 0x51, 0x12, 0x53, 0x69, 
+0x71, 0x2F, 0x50, 0x08, 0x12, 0x53, 0x69, 0x12, 0x5F, 0x9D, 0x80, 0x05, 0x12, 0x53, 0x69, 0x51, 
+0xF8, 0x71, 0x4B, 0xFB, 0xC3, 0x74, 0xFF, 0x9B, 0xFF, 0x74, 0xFF, 0x9E, 0xFE, 0x74, 0xFF, 0x94, 
+0x00, 0xFD, 0x74, 0xFF, 0x94, 0x00, 0xFC, 0x90, 0x94, 0x91, 0x12, 0x48, 0xB1, 0xD3, 0x12, 0x48, 
+0x94, 0x90, 0x94, 0x91, 0x50, 0x14, 0x12, 0x48, 0xB1, 0x71, 0x4B, 0xFF, 0xE4, 0xFC, 0xFD, 0x12, 
+0x48, 0x6D, 0x90, 0x94, 0x91, 0x12, 0x08, 0x6D, 0x80, 0x07, 0x12, 0x08, 0x79, 0xFF, 0xFF, 0xFF, 
+0xFF, 0x90, 0xA3, 0xD9, 0x71, 0x3C, 0xE5, 0x51, 0x71, 0x19, 0x71, 0x2F, 0x50, 0x07, 0x71, 0x19, 
+0x12, 0x5F, 0x9D, 0x80, 0x04, 0x71, 0x19, 0x51, 0xF8, 0xC3, 0x74, 0xFF, 0x95, 0x57, 0xFF, 0x74, 
+0xFF, 0x95, 0x56, 0xFE, 0xE5, 0x51, 0x12, 0x53, 0x96, 0xF5, 0x83, 0xE0, 0xFC, 0xA3, 0xE0, 0xD3, 
+0x9F, 0xEC, 0x9E, 0xE5, 0x51, 0x50, 0x0F, 0x12, 0x53, 0x96, 0xF5, 0x83, 0xE5, 0x56, 0x85, 0x57, 
+0xF0, 0x12, 0x08, 0xD6, 0x80, 0x05, 0x12, 0x53, 0x96, 0x51, 0xF8, 0xE4, 0xFD, 0xAF, 0x51, 0x12, 
+0x62, 0xFC, 0x05, 0x51, 0x02, 0x76, 0x39, 0x22, 0xF5, 0x83, 0x74, 0xFF, 0xF0, 0xA3, 0xF0, 0x22, 
+0xE5, 0x56, 0xC3, 0x13, 0xFE, 0xE5, 0x57, 0x13, 0x22, 0x74, 0x15, 0x25, 0x51, 0xF5, 0x82, 0xE4, 
+0x34, 0x98, 0x22, 0x90, 0xA3, 0xD0, 0x02, 0x48, 0xC9, 0x25, 0xE0, 0x24, 0x15, 0xF5, 0x82, 0xE4, 
+0x34, 0x9E, 0x22, 0x90, 0xA3, 0xD0, 0x12, 0x48, 0xC9, 0x90, 0x00, 0x08, 0x02, 0x07, 0xAB, 0xF5, 
+0x83, 0xE0, 0xFA, 0xA3, 0xE0, 0xD3, 0x9D, 0xEA, 0x9C, 0xE5, 0x51, 0x22, 0xE0, 0xFE, 0xA3, 0xE0, 
+0xFF, 0xC3, 0x74, 0xFF, 0x9F, 0xFD, 0x74, 0xFF, 0x9E, 0xFC, 0x22, 0x90, 0xA3, 0xD7, 0xE0, 0xFE, 
+0xA3, 0xE0, 0x22, 0x74, 0x01, 0x93, 0x95, 0x55, 0xE4, 0x93, 0x95, 0x54, 0x22, 0x90, 0xA4, 0xFA, 
+0xEF, 0xF0, 0x90, 0xA2, 0x9B, 0xE0, 0xB4, 0x02, 0x12, 0x90, 0xA4, 0xFA, 0xE0, 0xFF, 0x64, 0x01, 
+0x60, 0x18, 0x90, 0x01, 0x4D, 0xE0, 0x64, 0x80, 0xF0, 0x80, 0x0C, 0x90, 0x06, 0x90, 0xE0, 0x44, 
+0x01, 0xF0, 0x90, 0xA4, 0xFA, 0xE0, 0xFF, 0x12, 0x50, 0x3D, 0x22, 0x7D, 0x07, 0xEF, 0x5D, 0xC3, 
+0x60, 0x0A, 0x71, 0xA0, 0x24, 0x08, 0xFF, 0xE4, 0x3E, 0xFE, 0x80, 0x03, 0x71, 0xA0, 0xFF, 0x22, 
+0x74, 0xFF, 0x9D, 0xFD, 0x74, 0xFF, 0x94, 0x00, 0x5E, 0xFE, 0xED, 0x5F, 0x22, 0x90, 0x04, 0x24, 
+0xEF, 0xF0, 0x22, 0x90, 0xA3, 0x9A, 0xE0, 0xFD, 0x7C, 0x00, 0xA3, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 
+0x12, 0x07, 0x15, 0xED, 0x4C, 0x70, 0x05, 0x90, 0xA3, 0xA7, 0x80, 0x2A, 0xED, 0x64, 0x01, 0x4C, 
+0x70, 0x05, 0x90, 0xA3, 0xA8, 0x80, 0x1F, 0xED, 0x64, 0x02, 0x4C, 0x70, 0x05, 0x90, 0xA3, 0xA9, 
+0x80, 0x14, 0xED, 0x64, 0x03, 0x4C, 0x70, 0x05, 0x90, 0xA3, 0xAA, 0x80, 0x09, 0xED, 0x64, 0x04, 
+0x4C, 0x70, 0x11, 0x90, 0xA3, 0xAB, 0xE0, 0xFF, 0x71, 0xAD, 0x90, 0xA3, 0x9B, 0xE4, 0x75, 0xF0, 
+0x01, 0x12, 0x08, 0xD6, 0x22, 0x12, 0x07, 0xAB, 0x2F, 0xFF, 0xEE, 0x35, 0xF0, 0x22, 0x90, 0x04, 
+0xA0, 0xE0, 0xFF, 0xA3, 0xE0, 0xFE, 0xEF, 0x64, 0x01, 0x22, 0x12, 0x48, 0xBD, 0xE0, 0xFB, 0xE4, 
+0xFD, 0x0F, 0x22, 0x90, 0x00, 0x03, 0x12, 0x06, 0xA2, 0x54, 0x01, 0x22, 0x54, 0x03, 0x4F, 0xFF, 
+0x75, 0xF0, 0x10, 0x22, 0xB7, 0x17, 
+};
+u4Byte ArrayLength_MP_8821A_FW_AP = 15446;
+
+
+void
+ODM_ReadFirmware_MP_8821A_FW_AP(
+     IN   PDM_ODM_T    pDM_Odm,
+     OUT  u1Byte       *pFirmware,
+     OUT  u4Byte       *pFirmwareSize
+)
+{
+     ODM_MoveMemory(pDM_Odm, pFirmware, Array_MP_8821A_FW_AP, ArrayLength_MP_8821A_FW_AP);
+     *pFirmwareSize = ArrayLength_MP_8821A_FW_AP;
+}
+
+
+#else
+
+
+u1Byte Array_MP_8821A_FW_NIC[] = {
+0x01, 0x21, 0x10, 0x00, 0x1C, 0x00, 0x00, 0x00, 0x09, 0x05, 0x15, 0x19, 0xD6, 0x6F, 0x00, 0x00, 
+0xD0, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x02, 0x49, 0xD8, 0x02, 0x67, 0xF4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x02, 0x68, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x02, 0x77, 0xE3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x02, 0x67, 0xF5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x6F, 0xF7, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x02, 0x77, 0xE2, 0x15, 0xF0, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x15, 0xF0, 0x0F, 
+0x00, 0x00, 0x00, 0x00, 0x05, 0xF0, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x05, 0xF0, 0x0F, 0x00, 0x00, 
+0x00, 0x00, 0x10, 0xF0, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x10, 0xF0, 0x0F, 0x00, 0x00, 0x00, 0x00, 
+0xF5, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0D, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0xF0, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x10, 0xF0, 0x3F, 0x00, 
+0x00, 0x00, 0x00, 0x15, 0xF0, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x15, 0xF0, 0xCF, 0xFF, 0x00, 0x00, 
+0x00, 0x0A, 0x08, 0x03, 0x03, 0x00, 0x04, 0x09, 0x07, 0x03, 0x03, 0x00, 0x04, 0x08, 0x06, 0x03, 
+0x02, 0x00, 0x04, 0x08, 0x05, 0x03, 0x01, 0x00, 0x04, 0x0D, 0x0A, 0x07, 0x05, 0x00, 0x08, 0x0C, 
+0x0A, 0x07, 0x04, 0x00, 0x08, 0x0B, 0x0A, 0x06, 0x05, 0x00, 0x08, 0x0B, 0x0A, 0x05, 0x03, 0x00, 
+0x08, 0x0B, 0x0A, 0x03, 0x02, 0x00, 0x08, 0x14, 0x12, 0x0C, 0x04, 0x00, 0x10, 0x14, 0x12, 0x09, 
+0x04, 0x00, 0x10, 0x24, 0x22, 0x1C, 0x12, 0x00, 0x20, 0x24, 0x22, 0x18, 0x0C, 0x00, 0x20, 0x24, 
+0x22, 0x14, 0x06, 0x00, 0x20, 0x24, 0x22, 0x0F, 0x04, 0x00, 0x20, 0x24, 0x21, 0x0A, 0x04, 0x00, 
+0x20, 0x23, 0x21, 0x0C, 0x04, 0x00, 0x20, 0x23, 0x1F, 0x0A, 0x04, 0x00, 0x20, 0x22, 0x1F, 0x0F, 
+0x04, 0x00, 0x20, 0x21, 0x1F, 0x16, 0x0C, 0x00, 0x20, 0x31, 0x2F, 0x20, 0x14, 0x00, 0x30, 0x31, 
+0x2F, 0x18, 0x10, 0x00, 0x30, 0x31, 0x2C, 0x18, 0x0C, 0x00, 0x30, 0x31, 0x2A, 0x14, 0x0C, 0x00, 
+0x30, 0x31, 0x28, 0x14, 0x00, 0x00, 0x30, 0x31, 0x24, 0x14, 0x00, 0x00, 0x30, 0x31, 0x1E, 0x14, 
+0x00, 0x00, 0x30, 0x04, 0x04, 0x04, 0x05, 0x04, 0x04, 0x05, 0x07, 0x07, 0x07, 0x08, 0x0A, 0x04, 
+0x07, 0x0A, 0x0E, 0x11, 0x13, 0x14, 0x15, 0x03, 0x04, 0x07, 0x07, 0x08, 0x0B, 0x0D, 0x0F, 0x05, 
+0x05, 0x07, 0x07, 0x08, 0x0B, 0x0D, 0x0F, 0x05, 0x05, 0x07, 0x07, 0x08, 0x0B, 0x0D, 0x0F, 0x07, 
+0x08, 0x08, 0x0A, 0x0A, 0x0C, 0x0E, 0x10, 0x11, 0x11, 0x07, 0x09, 0x09, 0x0B, 0x0B, 0x0D, 0x0F, 
+0x13, 0x13, 0x14, 0x05, 0x05, 0x07, 0x07, 0x08, 0x0B, 0x0D, 0x0F, 0x0F, 0x0F, 0x05, 0x05, 0x07, 
+0x07, 0x08, 0x0B, 0x0D, 0x0F, 0x0F, 0x0F, 0x04, 0x04, 0x04, 0x05, 0x07, 0x07, 0x09, 0x09, 0x0C, 
+0x0E, 0x10, 0x12, 0x05, 0x06, 0x07, 0x0D, 0x10, 0x11, 0x12, 0x12, 0x07, 0x08, 0x09, 0x09, 0x0C, 
+0x0E, 0x11, 0x13, 0x09, 0x09, 0x09, 0x09, 0x0C, 0x0E, 0x11, 0x13, 0x09, 0x09, 0x09, 0x09, 0x0C, 
+0x0E, 0x11, 0x13, 0x05, 0x06, 0x08, 0x09, 0x0C, 0x0E, 0x12, 0x12, 0x13, 0x14, 0x07, 0x08, 0x09, 
+0x0A, 0x0C, 0x0F, 0x12, 0x12, 0x14, 0x16, 0x09, 0x09, 0x09, 0x09, 0x0C, 0x0E, 0x11, 0x13, 0x13, 
+0x13, 0x09, 0x09, 0x09, 0x09, 0x0C, 0x0E, 0x11, 0x13, 0x13, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x24, 0x26, 0x2A, 0x00, 0x00, 0x00, 0x1F, 0x21, 0x25, 0x27, 0x28, 0x00, 
+0x00, 0x00, 0x00, 0x23, 0x26, 0x28, 0x2A, 0x00, 0x00, 0x00, 0x00, 0x23, 0x26, 0x28, 0x2A, 0x00, 
+0x00, 0x00, 0x00, 0x23, 0x26, 0x28, 0x2A, 0x00, 0x00, 0x00, 0x00, 0x20, 0x25, 0x27, 0x29, 0x29, 
+0x2A, 0x00, 0x00, 0x00, 0x00, 0x20, 0x25, 0x27, 0x29, 0x29, 0x2A, 0x00, 0x00, 0x00, 0x00, 0x23, 
+0x26, 0x28, 0x2A, 0x2A, 0x2A, 0x00, 0x00, 0x00, 0x1F, 0x23, 0x26, 0x28, 0x2A, 0x2A, 0x2A, 0x00, 
+0x04, 0x00, 0x04, 0x00, 0x08, 0x00, 0x10, 0x00, 0x18, 0x00, 0x24, 0x00, 0x30, 0x00, 0x48, 0x00, 
+0x60, 0x00, 0x90, 0x00, 0xC0, 0x00, 0xD8, 0x00, 0x3C, 0x00, 0x64, 0x00, 0x78, 0x00, 0xA0, 0x00, 
+0xF0, 0x01, 0x40, 0x01, 0x90, 0x01, 0xE0, 0x00, 0xA0, 0x00, 0xF0, 0x01, 0x40, 0x01, 0x90, 0x02, 
+0x58, 0x03, 0x20, 0x04, 0xB0, 0x06, 0x40, 0x00, 0xC8, 0x01, 0x18, 0x01, 0xE0, 0x02, 0xD0, 0x03, 
+0xE8, 0x04, 0xB0, 0x06, 0x40, 0x07, 0xD0, 0x00, 0xC8, 0x01, 0x18, 0x01, 0xE0, 0x02, 0xD0, 0x03, 
+0xE8, 0x04, 0xB0, 0x06, 0x40, 0x07, 0xD0, 0x00, 0x3C, 0x00, 0x50, 0x00, 0x64, 0x00, 0xA0, 0x00, 
+0xF0, 0x01, 0x40, 0x01, 0x90, 0x01, 0xE0, 0x02, 0x58, 0x03, 0x20, 0x00, 0x78, 0x00, 0xF0, 0x01, 
+0x90, 0x02, 0x58, 0x03, 0xE8, 0x07, 0xD0, 0x09, 0x60, 0x0F, 0xA0, 0x12, 0xC0, 0x15, 0x18, 0x00, 
+0xC8, 0x01, 0x18, 0x01, 0xE0, 0x02, 0xD0, 0x03, 0xE8, 0x04, 0xB0, 0x06, 0x40, 0x07, 0xD0, 0x07, 
+0xD0, 0x07, 0xD0, 0x00, 0xC8, 0x01, 0x18, 0x01, 0xE0, 0x02, 0xD0, 0x03, 0xE8, 0x04, 0xB0, 0x06, 
+0x40, 0x07, 0xD0, 0x07, 0xD0, 0x07, 0xD0, 0x00, 0x02, 0x00, 0x02, 0x00, 0x04, 0x00, 0x08, 0x00, 
+0x0C, 0x00, 0x12, 0x00, 0x18, 0x00, 0x24, 0x00, 0x30, 0x00, 0x48, 0x00, 0x60, 0x00, 0x6C, 0x00, 
+0x14, 0x00, 0x32, 0x00, 0x3C, 0x00, 0x50, 0x00, 0x78, 0x00, 0xA0, 0x00, 0xC8, 0x00, 0xF0, 0x00, 
+0x50, 0x00, 0x78, 0x00, 0xA0, 0x00, 0xC8, 0x01, 0x2C, 0x01, 0x90, 0x02, 0x58, 0x03, 0x20, 0x00, 
+0x64, 0x00, 0x8C, 0x00, 0xF0, 0x01, 0x68, 0x01, 0xF4, 0x02, 0x58, 0x03, 0x20, 0x03, 0xE8, 0x00, 
+0x64, 0x00, 0x8C, 0x00, 0xF0, 0x01, 0x68, 0x01, 0xF4, 0x02, 0x58, 0x03, 0x20, 0x03, 0xE8, 0x00, 
+0x1E, 0x00, 0x28, 0x00, 0x32, 0x00, 0x50, 0x00, 0x78, 0x00, 0xA0, 0x00, 0xC8, 0x00, 0xF0, 0x01, 
+0x2C, 0x01, 0x90, 0x00, 0x3C, 0x00, 0x78, 0x00, 0xC8, 0x01, 0x2C, 0x01, 0xF4, 0x03, 0xE8, 0x04, 
+0xB0, 0x07, 0xD0, 0x09, 0x60, 0x0A, 0xF0, 0x00, 0x64, 0x00, 0x8C, 0x00, 0xF0, 0x01, 0x68, 0x01, 
+0xF4, 0x02, 0x58, 0x03, 0x20, 0x03, 0xE8, 0x03, 0xE8, 0x03, 0xE8, 0x00, 0x64, 0x00, 0x8C, 0x00, 
+0xF0, 0x01, 0x68, 0x01, 0xF4, 0x02, 0x58, 0x03, 0x20, 0x03, 0xE8, 0x03, 0xE8, 0x03, 0xE8, 0x02, 
+0x04, 0x06, 0x08, 0x0A, 0x0C, 0x10, 0x18, 0x20, 0x30, 0x40, 0x50, 0x01, 0x01, 0x01, 0x02, 0x01, 
+0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x02, 0x04, 0x06, 0x07, 0x07, 0x08, 0x08, 0x08, 0x02, 
+0x02, 0x03, 0x03, 0x05, 0x05, 0x06, 0x06, 0x05, 0x06, 0x06, 0x07, 0x07, 0x08, 0x09, 0x0A, 0x05, 
+0x06, 0x06, 0x07, 0x07, 0x08, 0x09, 0x0A, 0x05, 0x06, 0x06, 0x07, 0x07, 0x08, 0x09, 0x0A, 0x0A, 
+0x0B, 0x05, 0x06, 0x06, 0x07, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0B, 0x05, 0x06, 0x06, 0x07, 0x07, 
+0x08, 0x09, 0x0A, 0x0A, 0x0B, 0x05, 0x06, 0x06, 0x07, 0x07, 0x08, 0x09, 0x0A, 0x0A, 0x0B, 0x01, 
+0x01, 0x01, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 
+0x06, 0x07, 0x08, 0x02, 0x04, 0x06, 0x07, 0x08, 0x0A, 0x0B, 0x0C, 0x03, 0x05, 0x06, 0x07, 0x08, 
+0x0A, 0x0B, 0x0C, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x02, 0x04, 0x06, 0x07, 0x08, 
+0x09, 0x0B, 0x0C, 0x0C, 0x0C, 0x03, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0B, 0x0C, 0x0C, 0x0C, 0x05, 
+0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0C, 0x0C, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 
+0x0C, 0x0C, 0x0C, 0x19, 0x06, 0x04, 0x02, 0x00, 0x18, 0x05, 0x22, 0x05, 0x50, 0x05, 0x51, 0x0B, 
+0x00, 0x08, 0x08, 0x09, 0x0C, 0x0C, 0x00, 0x0E, 0x00, 0x08, 0xC4, 0x08, 0x38, 0x08, 0x2C, 0x0C, 
+0x5C, 0x0C, 0x60, 0x0C, 0x64, 0x0C, 0x68, 0x0C, 0xB8, 0x0C, 0xB0, 0x0C, 0xB4, 0x0E, 0x5C, 0x0E, 
+0x60, 0x0E, 0x64, 0x0E, 0x68, 0x0E, 0xB8, 0x0E, 0xB0, 0x0E, 0xB4, 0x0C, 0x00, 0x0C, 0x94, 0x0C, 
+0x88, 0x0C, 0x8C, 0x0C, 0xE8, 0x0C, 0x10, 0x0D, 0x00, 0x0C, 0x90, 0x0C, 0xC4, 0x0C, 0xC8, 0x0C, 
+0xCC, 0x0C, 0xD4, 0x0C, 0x80, 0x0C, 0x84, 0x0E, 0x00, 0x0E, 0x94, 0x0E, 0x88, 0x0E, 0x8C, 0x0E, 
+0xE8, 0x0E, 0x10, 0x0D, 0x40, 0x0E, 0x90, 0x0E, 0xC4, 0x0E, 0xC8, 0x0E, 0xCC, 0x0E, 0xD4, 0x0E, 
+0x80, 0x0E, 0x84, 0x00, 0x01, 0x04, 0x02, 0x03, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0xC2, 0xAF, 0x80, 0xFE, 0x32, 0x12, 0x45, 0xC4, 0x85, 0xD0, 0x0B, 0x75, 0xD0, 0x08, 0xAA, 0xE0, 
+0xC2, 0x8C, 0xE5, 0x8A, 0x24, 0x67, 0xF5, 0x8A, 0xE5, 0x8C, 0x34, 0x79, 0xF5, 0x8C, 0xD2, 0x8C, 
+0xEC, 0x24, 0x87, 0xF8, 0xE6, 0xBC, 0x02, 0x02, 0x74, 0xFF, 0xC3, 0x95, 0x81, 0xB4, 0x40, 0x00, 
+0x40, 0xCE, 0x79, 0x03, 0x78, 0x80, 0x16, 0xE6, 0x08, 0x70, 0x0B, 0xC2, 0xAF, 0xE6, 0x30, 0xE1, 
+0x03, 0x44, 0x18, 0xF6, 0xD2, 0xAF, 0x08, 0xD9, 0xED, 0xEA, 0x8B, 0xD0, 0x22, 0xE5, 0x0C, 0xFF, 
+0x23, 0x24, 0x81, 0xF8, 0x0F, 0x08, 0x08, 0xBF, 0x03, 0x04, 0x7F, 0x00, 0x78, 0x81, 0xE6, 0x30, 
+0xE4, 0xF2, 0x00, 0xE5, 0x0C, 0xC3, 0x9F, 0x50, 0x20, 0x05, 0x0C, 0x74, 0x86, 0x25, 0x0C, 0xF8, 
+0xE6, 0xFD, 0xA6, 0x81, 0x08, 0xE6, 0xAE, 0x0C, 0xBE, 0x02, 0x02, 0x74, 0xFF, 0xCD, 0xF8, 0xE8, 
+0x6D, 0x60, 0xE0, 0x08, 0xE6, 0xC0, 0xE0, 0x80, 0xF6, 0xE5, 0x0C, 0xD3, 0x9F, 0x40, 0x27, 0xE5, 
+0x0C, 0x24, 0x87, 0xF8, 0xE6, 0xAE, 0x0C, 0xBE, 0x02, 0x02, 0x74, 0xFF, 0xFD, 0x18, 0xE6, 0xCD, 
+0xF8, 0xE5, 0x81, 0x6D, 0x60, 0x06, 0xD0, 0xE0, 0xF6, 0x18, 0x80, 0xF5, 0xE5, 0x0C, 0x24, 0x86, 
+0xC8, 0xF6, 0x15, 0x0C, 0x80, 0xD3, 0xE5, 0x0C, 0x23, 0x24, 0x81, 0xF8, 0x7F, 0x04, 0xC2, 0xAF, 
+0xE6, 0x30, 0xE0, 0x03, 0x10, 0xE2, 0x0C, 0x7F, 0x00, 0x30, 0xE1, 0x07, 0x30, 0xE3, 0x04, 0x7F, 
+0x08, 0x54, 0xF4, 0x54, 0x7C, 0xC6, 0xD2, 0xAF, 0x54, 0x80, 0x42, 0x07, 0x22, 0x78, 0x86, 0xA6, 
+0x81, 0x74, 0x02, 0x60, 0x06, 0xFF, 0x08, 0x76, 0xFF, 0xDF, 0xFB, 0x7F, 0x03, 0xE4, 0x78, 0x80, 
+0xF6, 0x08, 0xF6, 0x08, 0xDF, 0xFA, 0x78, 0x81, 0x76, 0x30, 0x90, 0x4A, 0x92, 0x74, 0x01, 0x93, 
+0xC0, 0xE0, 0xE4, 0x93, 0xC0, 0xE0, 0x43, 0x89, 0x01, 0x75, 0x8A, 0x60, 0x75, 0x8C, 0x79, 0xD2, 
+0x8C, 0xD2, 0xAF, 0x22, 0x02, 0xEF, 0xD3, 0x94, 0x02, 0x40, 0x03, 0x7F, 0xFF, 0x22, 0x74, 0x81, 
+0x2F, 0x2F, 0xF8, 0xE6, 0x20, 0xE5, 0xF4, 0xC2, 0xAF, 0xE6, 0x44, 0x30, 0xF6, 0xD2, 0xAF, 0xAE, 
+0x0C, 0xEE, 0xC3, 0x9F, 0x50, 0x21, 0x0E, 0x74, 0x86, 0x2E, 0xF8, 0xE6, 0xF9, 0x08, 0xE6, 0x18, 
+0xBE, 0x02, 0x02, 0x74, 0xFF, 0xFD, 0xED, 0x69, 0x60, 0x09, 0x09, 0xE7, 0x19, 0x19, 0xF7, 0x09, 
+0x09, 0x80, 0xF3, 0x16, 0x16, 0x80, 0xDA, 0xEE, 0xD3, 0x9F, 0x40, 0x04, 0x05, 0x81, 0x05, 0x81, 
+0xEE, 0xD3, 0x9F, 0x40, 0x22, 0x74, 0x86, 0x2E, 0xF8, 0x08, 0xE6, 0xF9, 0xEE, 0xB5, 0x0C, 0x02, 
+0xA9, 0x81, 0x18, 0x06, 0x06, 0xE6, 0xFD, 0xED, 0x69, 0x60, 0x09, 0x19, 0x19, 0xE7, 0x09, 0x09, 
+0xF7, 0x19, 0x80, 0xF3, 0x1E, 0x80, 0xD9, 0xEF, 0x24, 0x86, 0xF8, 0xE6, 0x04, 0xF8, 0xEF, 0x2F, 
+0x04, 0x90, 0x4A, 0x92, 0x93, 0xF6, 0x08, 0xEF, 0x2F, 0x93, 0xF6, 0x7F, 0x00, 0x22, 0xEF, 0xD3, 
+0x94, 0x02, 0x40, 0x03, 0x7F, 0xFF, 0x22, 0xEF, 0x23, 0x24, 0x81, 0xF8, 0xE6, 0x30, 0xE5, 0xF4, 
+0xC2, 0xAF, 0xE6, 0x54, 0x8C, 0xF6, 0xD2, 0xAF, 0xE5, 0x0C, 0xB5, 0x07, 0x0A, 0x74, 0x86, 0x2F, 
+0xF8, 0xE6, 0xF5, 0x81, 0x02, 0x46, 0x0D, 0x50, 0x2E, 0x74, 0x87, 0x2F, 0xF8, 0xE6, 0xBF, 0x02, 
+0x02, 0x74, 0xFF, 0xFD, 0x18, 0xE6, 0xF9, 0x74, 0x86, 0x2F, 0xF8, 0xFB, 0xE6, 0xFC, 0xE9, 0x6C, 
+0x60, 0x08, 0xA8, 0x05, 0xE7, 0xF6, 0x1D, 0x19, 0x80, 0xF4, 0xA8, 0x03, 0xA6, 0x05, 0x1F, 0xE5, 
+0x0C, 0xB5, 0x07, 0xE3, 0x7F, 0x00, 0x22, 0x74, 0x87, 0x2F, 0xF8, 0xE6, 0xFD, 0x18, 0x86, 0x01, 
+0x0F, 0x74, 0x86, 0x2F, 0xF8, 0xA6, 0x01, 0x08, 0x86, 0x04, 0xE5, 0x0C, 0xB5, 0x07, 0x02, 0xAC, 
+0x81, 0xED, 0x6C, 0x60, 0x08, 0x0D, 0x09, 0xA8, 0x05, 0xE6, 0xF7, 0x80, 0xF4, 0xE5, 0x0C, 0xB5, 
+0x07, 0xDE, 0x89, 0x81, 0x7F, 0x00, 0x22, 0xEF, 0xD3, 0x94, 0x02, 0x40, 0x03, 0x7F, 0xFF, 0x22, 
+0xEF, 0x23, 0x24, 0x81, 0xF8, 0xC2, 0xAF, 0xE6, 0x30, 0xE5, 0x05, 0x30, 0xE0, 0x02, 0xD2, 0xE4, 
+0xD2, 0xE2, 0xC6, 0xD2, 0xAF, 0x7F, 0x00, 0x30, 0xE2, 0x01, 0x0F, 0x02, 0x46, 0x0C, 0x8F, 0xF0, 
+0xE4, 0xFF, 0xFE, 0xE5, 0x0C, 0x23, 0x24, 0x80, 0xF8, 0xC2, 0xA9, 0x30, 0xF7, 0x0D, 0x7F, 0x08, 
+0xE6, 0x60, 0x0B, 0x2D, 0xF6, 0x60, 0x32, 0x50, 0x30, 0x80, 0x07, 0x30, 0xF1, 0x06, 0xED, 0xF6, 
+0x60, 0x27, 0x7E, 0x02, 0x08, 0x30, 0xF0, 0x10, 0xC2, 0xAF, 0xE6, 0x10, 0xE7, 0x25, 0x0E, 0x30, 
+0xE2, 0x0C, 0xD2, 0xAF, 0x7F, 0x04, 0x80, 0x14, 0xC2, 0xAF, 0xE6, 0x10, 0xE7, 0x15, 0x54, 0xEC, 
+0x4E, 0xF6, 0xD2, 0xAF, 0xD2, 0xA9, 0x02, 0x46, 0x0D, 0x7F, 0x08, 0x08, 0xEF, 0x44, 0x83, 0xF4, 
+0xC2, 0xAF, 0x56, 0xC6, 0xD2, 0xAF, 0xD2, 0xA9, 0x54, 0x80, 0x4F, 0xFF, 0x22, 0xEF, 0x5B, 0xFF, 
+0xEE, 0x5A, 0xFE, 0xED, 0x59, 0xFD, 0xEC, 0x58, 0xFC, 0x22, 0xEF, 0x4B, 0xFF, 0xEE, 0x4A, 0xFE, 
+0xED, 0x49, 0xFD, 0xEC, 0x48, 0xFC, 0x22, 0xEB, 0x9F, 0xF5, 0xF0, 0xEA, 0x9E, 0x42, 0xF0, 0xE9, 
+0x9D, 0x42, 0xF0, 0xEC, 0x64, 0x80, 0xC8, 0x64, 0x80, 0x98, 0x45, 0xF0, 0x22, 0xEB, 0x9F, 0xF5, 
+0xF0, 0xEA, 0x9E, 0x42, 0xF0, 0xE9, 0x9D, 0x42, 0xF0, 0xE8, 0x9C, 0x45, 0xF0, 0x22, 0xBB, 0x01, 
+0x07, 0x89, 0x82, 0x8A, 0x83, 0x02, 0x49, 0x3C, 0x50, 0x05, 0xE9, 0xF8, 0x02, 0x49, 0x98, 0xBB, 
+0xFE, 0x05, 0xE9, 0xF8, 0x02, 0x49, 0xA4, 0x89, 0x82, 0x8A, 0x83, 0x02, 0x49, 0xB0, 0xBB, 0x01, 
+0x0D, 0xE5, 0x82, 0x29, 0xF5, 0x82, 0xE5, 0x83, 0x3A, 0xF5, 0x83, 0x02, 0x49, 0x3C, 0x50, 0x07, 
+0xE9, 0x25, 0x82, 0xF8, 0x02, 0x49, 0x98, 0xBB, 0xFE, 0x07, 0xE9, 0x25, 0x82, 0xF8, 0x02, 0x49, 
+0xA4, 0xE5, 0x82, 0x29, 0xF5, 0x82, 0xE5, 0x83, 0x3A, 0xF5, 0x83, 0x02, 0x49, 0xB0, 0xBB, 0x01, 
+0x07, 0x89, 0x82, 0x8A, 0x83, 0x02, 0x08, 0x6D, 0x50, 0x05, 0xE9, 0xF8, 0x02, 0x49, 0xC0, 0xBB, 
+0xFE, 0x05, 0xE9, 0xF8, 0x02, 0x49, 0xCC, 0x22, 0xBB, 0x01, 0x0D, 0xE5, 0x82, 0x29, 0xF5, 0x82, 
+0xE5, 0x83, 0x3A, 0xF5, 0x83, 0x02, 0x08, 0x6D, 0x50, 0x07, 0xE9, 0x25, 0x82, 0xF8, 0x02, 0x49, 
+0xC0, 0xBB, 0xFE, 0x07, 0xE9, 0x25, 0x82, 0xF8, 0x02, 0x49, 0xCC, 0x22, 0xE0, 0xFC, 0xA3, 0xE0, 
+0xFD, 0xA3, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x22, 0xE0, 0xF8, 0xA3, 0xE0, 0xF9, 0xA3, 0xE0, 0xFA, 
+0xA3, 0xE0, 0xFB, 0x22, 0xA4, 0x25, 0x82, 0xF5, 0x82, 0xE5, 0xF0, 0x35, 0x83, 0xF5, 0x83, 0x22, 
+0xE0, 0xFB, 0xA3, 0xE0, 0xFA, 0xA3, 0xE0, 0xF9, 0x22, 0xEB, 0xF0, 0xA3, 0xEA, 0xF0, 0xA3, 0xE9, 
+0xF0, 0x22, 0xD0, 0x83, 0xD0, 0x82, 0xF8, 0xE4, 0x93, 0x70, 0x12, 0x74, 0x01, 0x93, 0x70, 0x0D, 
+0xA3, 0xA3, 0x93, 0xF8, 0x74, 0x01, 0x93, 0xF5, 0x82, 0x88, 0x83, 0xE4, 0x73, 0x74, 0x02, 0x93, 
+0x68, 0x60, 0xEF, 0xA3, 0xA3, 0xA3, 0x80, 0xDF, 0xE6, 0xFC, 0x08, 0xE6, 0xFD, 0x08, 0xE6, 0xFE, 
+0x08, 0xE6, 0xFF, 0x22, 0xE2, 0xFC, 0x08, 0xE2, 0xFD, 0x08, 0xE2, 0xFE, 0x08, 0xE2, 0xFF, 0x22, 
+0xE4, 0x93, 0xFC, 0x74, 0x01, 0x93, 0xFD, 0x74, 0x02, 0x93, 0xFE, 0x74, 0x03, 0x93, 0xFF, 0x22, 
+0xEC, 0xF6, 0x08, 0xED, 0xF6, 0x08, 0xEE, 0xF6, 0x08, 0xEF, 0xF6, 0x22, 0xEC, 0xF2, 0x08, 0xED, 
+0xF2, 0x08, 0xEE, 0xF2, 0x08, 0xEF, 0xF2, 0x22, 0x02, 0x4A, 0x16, 0x02, 0x46, 0x9D, 0xE4, 0x93, 
+0xA3, 0xF8, 0xE4, 0x93, 0xA3, 0x40, 0x03, 0xF6, 0x80, 0x01, 0xF2, 0x08, 0xDF, 0xF4, 0x80, 0x29, 
+0xE4, 0x93, 0xA3, 0xF8, 0x54, 0x07, 0x24, 0x0C, 0xC8, 0xC3, 0x33, 0xC4, 0x54, 0x0F, 0x44, 0x20, 
+0xC8, 0x83, 0x40, 0x04, 0xF4, 0x56, 0x80, 0x01, 0x46, 0xF6, 0xDF, 0xE4, 0x80, 0x0B, 0x01, 0x02, 
+0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x90, 0x4A, 0x5B, 0xE4, 0x7E, 0x01, 0x93, 0x60, 0xBC, 0xA3, 
+0xFF, 0x54, 0x3F, 0x30, 0xE5, 0x09, 0x54, 0x1F, 0xFE, 0xE4, 0x93, 0xA3, 0x60, 0x01, 0x0E, 0xCF, 
+0x54, 0xC0, 0x25, 0xE0, 0x60, 0xA8, 0x40, 0xB8, 0xE4, 0x93, 0xA3, 0xFA, 0xE4, 0x93, 0xA3, 0xF8, 
+0xE4, 0x93, 0xA3, 0xC8, 0xC5, 0x82, 0xC8, 0xCA, 0xC5, 0x83, 0xCA, 0xF0, 0xA3, 0xC8, 0xC5, 0x82, 
+0xC8, 0xCA, 0xC5, 0x83, 0xCA, 0xDF, 0xE9, 0xDE, 0xE7, 0x80, 0xBE, 0x41, 0xA3, 0x1B, 0x00, 0x41, 
+0xA3, 0x1C, 0x00, 0x60, 0x26, 0xA2, 0x4D, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 
+0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x24, 0x28, 0x2C, 0x30, 0x34, 0x38, 0x3C, 0x40, 0x64, 0x68, 0x6C, 
+0x70, 0x74, 0x78, 0x7C, 0x80, 0x84, 0x88, 0x8C, 0x95, 0x99, 0x9D, 0xA1, 0xA5, 0x41, 0xA3, 0x31, 
+0x00, 0x00, 0x4C, 0xD6, 0x58, 0x08, 0x60, 0x2D, 0xE4, 0xFD, 0x7F, 0x8D, 0xD3, 0x10, 0xAF, 0x01, 
+0xC3, 0xC0, 0xD0, 0x8F, 0x82, 0x75, 0x83, 0x00, 0xED, 0x12, 0xAF, 0x50, 0xD0, 0xD0, 0x92, 0xAF, 
+0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x7F, 0x8F, 0x71, 0xFC, 0xEF, 0x20, 0xE6, 0x02, 
+0x61, 0x76, 0x90, 0x00, 0x8C, 0xE0, 0xF5, 0x26, 0x7F, 0x8D, 0x71, 0xFC, 0x90, 0x00, 0x8E, 0xE0, 
+0xF5, 0x27, 0xEF, 0x24, 0xFC, 0x60, 0x0C, 0x24, 0x03, 0x60, 0x02, 0x61, 0x6C, 0xAF, 0x26, 0xB1, 
+0x53, 0x61, 0x6C, 0x74, 0x11, 0x25, 0x26, 0x12, 0x66, 0x3C, 0xE0, 0xFB, 0xE4, 0xFD, 0x71, 0xAD, 
+0xB1, 0xFC, 0x13, 0x13, 0x54, 0x03, 0x71, 0xAA, 0xB1, 0xFC, 0xF1, 0x52, 0x71, 0xAA, 0xB1, 0xFC, 
+0xC4, 0x54, 0x03, 0x71, 0xAA, 0x12, 0x6F, 0xD0, 0xE0, 0xFB, 0xE4, 0xFD, 0x0F, 0x71, 0xAE, 0x12, 
+0x6D, 0x4E, 0xE0, 0xFB, 0x0D, 0x71, 0xAE, 0xF1, 0x61, 0xC4, 0x13, 0x54, 0x01, 0xFB, 0x0D, 0x7F, 
+0x01, 0x71, 0xAE, 0xF1, 0x61, 0x54, 0x1F, 0x71, 0xA2, 0xE5, 0x26, 0x90, 0x89, 0x00, 0x12, 0xAE, 
+0xF6, 0x71, 0xA4, 0xE5, 0x26, 0x90, 0x89, 0x01, 0x71, 0x9F, 0xE5, 0x26, 0x90, 0x89, 0x02, 0x71, 
+0x9F, 0xE5, 0x26, 0x90, 0x89, 0x03, 0x71, 0x9F, 0xE5, 0x26, 0x90, 0x89, 0x04, 0x12, 0xAE, 0xF6, 
+0x71, 0xA4, 0xE5, 0x26, 0x90, 0x89, 0x05, 0x71, 0x9F, 0xE5, 0x26, 0x90, 0x89, 0x06, 0x71, 0x9F, 
+0xE5, 0x26, 0x90, 0x89, 0x07, 0x31, 0x54, 0xE0, 0xFB, 0x0D, 0x71, 0x7B, 0x7F, 0x8F, 0x71, 0xFC, 
+0xEF, 0x30, 0xE0, 0x02, 0x51, 0x98, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xEF, 0x70, 0x04, 0x74, 0xF0, 
+0x80, 0x16, 0xEF, 0xB4, 0x01, 0x04, 0x74, 0xF4, 0x80, 0x0E, 0xEF, 0xB4, 0x02, 0x04, 0x74, 0xF8, 
+0x80, 0x06, 0xEF, 0xB4, 0x03, 0x08, 0x74, 0xFC, 0x2D, 0x12, 0x88, 0x82, 0xEB, 0xF0, 0x22, 0x31, 
+0x54, 0xE0, 0xFB, 0x0D, 0x71, 0x7B, 0x75, 0xF0, 0x08, 0x22, 0xFB, 0x0D, 0xE4, 0xFF, 0x71, 0x7B, 
+0x75, 0xF0, 0x04, 0xE5, 0x26, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x12, 0x52, 0xA5, 
+0x7F, 0x00, 0x7E, 0x0C, 0xB1, 0x3A, 0x12, 0xAD, 0xF8, 0xB1, 0x3A, 0x12, 0xAF, 0x7F, 0x91, 0x2C, 
+0x91, 0x19, 0x91, 0x19, 0x54, 0xFE, 0xFD, 0x7F, 0x02, 0x51, 0x9C, 0x12, 0xAF, 0x47, 0x44, 0x40, 
+0xB1, 0x40, 0x12, 0xAF, 0x78, 0x90, 0x01, 0x00, 0x74, 0x3F, 0xF0, 0xA3, 0xE0, 0x54, 0xFD, 0xF0, 
+0x90, 0x05, 0x53, 0xE0, 0x44, 0x20, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xD3, 0x10, 0xAF, 0x01, 
+0xC3, 0xC0, 0xD0, 0x8F, 0x82, 0x75, 0x83, 0x00, 0xE0, 0x90, 0xA3, 0x27, 0x12, 0xAF, 0x50, 0x90, 
+0xA3, 0x27, 0xE0, 0xFF, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x54, 0xFE, 0xFD, 0x7F, 0x02, 0x51, 0x9C, 
+0x7F, 0x02, 0x71, 0xFC, 0xEF, 0x44, 0x01, 0xFD, 0x7F, 0x02, 0x51, 0x9C, 0x7F, 0x02, 0x71, 0xFC, 
+0xEF, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x7F, 0x10, 0x71, 0xFC, 0xEF, 0x44, 0x0C, 
+0xFD, 0x7F, 0x10, 0x51, 0x9C, 0x7F, 0x72, 0x71, 0xFC, 0xEF, 0x54, 0xF3, 0xFD, 0x7F, 0x72, 0x51, 
+0x9C, 0x90, 0x01, 0x01, 0xE0, 0x44, 0x02, 0xF0, 0x90, 0x01, 0x00, 0x74, 0xFF, 0xF0, 0x90, 0x06, 
+0xB7, 0x74, 0x09, 0xF0, 0x90, 0x06, 0xB4, 0x74, 0x86, 0xF0, 0x12, 0xAF, 0x47, 0x54, 0xBF, 0xF1, 
+0x6E, 0xB1, 0x4B, 0x12, 0xAF, 0x78, 0x91, 0x2C, 0x44, 0x01, 0xFD, 0x7F, 0x02, 0x51, 0x9C, 0x7F, 
+0x00, 0x7E, 0x0C, 0xF1, 0x68, 0xB1, 0x4B, 0x12, 0xAD, 0xF8, 0xF1, 0x68, 0xB1, 0x4B, 0x12, 0xAF, 
+0x7F, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x7F, 0x54, 0x71, 0xFC, 0xE5, 0x0D, 0x5F, 0xF5, 0x11, 0x7F, 
+0x55, 0x71, 0xFC, 0xE5, 0x0E, 0x5F, 0xF5, 0x12, 0x7F, 0x56, 0x71, 0xFC, 0xE5, 0x0F, 0x5F, 0xF5, 
+0x13, 0x7F, 0x57, 0x71, 0xFC, 0xE5, 0x10, 0x5F, 0xF5, 0x14, 0xAD, 0x11, 0x7F, 0x54, 0x51, 0x9C, 
+0xAD, 0x12, 0x7F, 0x55, 0x51, 0x9C, 0xAD, 0x13, 0x7F, 0x56, 0x51, 0x9C, 0xAD, 0x14, 0x7F, 0x57, 
+0x51, 0x9C, 0x53, 0x91, 0xEF, 0x22, 0x7F, 0x81, 0x71, 0xFC, 0xEF, 0x54, 0xFE, 0xFD, 0x7F, 0x81, 
+0x51, 0x9C, 0x7F, 0x80, 0xF1, 0xBC, 0x7F, 0x80, 0x51, 0x9C, 0x12, 0x88, 0xC8, 0x12, 0x3D, 0x3B, 
+0x12, 0x88, 0xD5, 0x12, 0x8A, 0x6A, 0x7F, 0x01, 0x12, 0x46, 0xD5, 0x90, 0xA0, 0x5F, 0x74, 0x02, 
+0xF0, 0xFF, 0x12, 0x46, 0xD5, 0x90, 0xA0, 0x5F, 0xE0, 0x04, 0xF0, 0x12, 0x60, 0x0B, 0x12, 0x85, 
+0x02, 0x7F, 0x80, 0x71, 0xFC, 0xEF, 0x44, 0x40, 0xFD, 0x7F, 0x80, 0x51, 0x9C, 0x75, 0x28, 0xFF, 
+0x12, 0x60, 0x26, 0x12, 0x78, 0xAB, 0x7F, 0x81, 0x71, 0xFC, 0xEF, 0x44, 0x04, 0xFD, 0x7F, 0x81, 
+0x51, 0x9C, 0x12, 0x8A, 0x74, 0xE4, 0xFF, 0x02, 0x47, 0x5E, 0x12, 0x37, 0xBC, 0xEF, 0x54, 0xFC, 
+0xFF, 0xEC, 0x90, 0xA2, 0xF7, 0x12, 0x08, 0x6D, 0x90, 0xA2, 0xF7, 0x31, 0x3C, 0x90, 0xAA, 0xB9, 
+0x02, 0x08, 0x6D, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0xA3, 0x21, 0xEF, 0xF0, 0x7F, 
+0x8F, 0x71, 0xFC, 0xEF, 0x30, 0xE6, 0x3E, 0x7F, 0x8D, 0x71, 0xFC, 0xEF, 0x64, 0x01, 0x70, 0x35, 
+0x90, 0xA3, 0x22, 0xF0, 0x90, 0xA3, 0x22, 0xE0, 0xFD, 0x90, 0xA3, 0x21, 0xE0, 0x75, 0xF0, 0x10, 
+0x12, 0x6D, 0x43, 0xE5, 0x82, 0x2D, 0x12, 0x6C, 0x00, 0xE0, 0xFB, 0xE4, 0xFF, 0x71, 0x7B, 0x90, 
+0xA3, 0x22, 0xE0, 0x04, 0xF0, 0xE0, 0xC3, 0x94, 0x10, 0x40, 0xD9, 0x7F, 0x8F, 0x71, 0xFC, 0xEF, 
+0x30, 0xE0, 0x02, 0x51, 0x98, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0x9F, 0xA4, 0xE0, 0x44, 0x10, 
+0xF0, 0x90, 0x9F, 0xB2, 0xE0, 0xFD, 0x7F, 0x93, 0x51, 0x9C, 0x90, 0x9F, 0xA8, 0xE0, 0x60, 0x12, 
+0x90, 0x01, 0x2F, 0xE0, 0x30, 0xE7, 0x05, 0x74, 0x10, 0xF0, 0x80, 0x06, 0x90, 0x01, 0x2F, 0x74, 
+0x90, 0xF0, 0x7F, 0x08, 0x71, 0xFC, 0xEF, 0x44, 0x10, 0xFD, 0x7F, 0x08, 0x51, 0x9C, 0x7F, 0x01, 
+0x12, 0x78, 0x5F, 0x7F, 0x90, 0x71, 0xFC, 0xEF, 0x44, 0x01, 0xFD, 0x7F, 0x90, 0x51, 0x9C, 0x7F, 
+0x14, 0x7E, 0x00, 0x02, 0x3D, 0x7A, 0xFF, 0x75, 0xF0, 0x04, 0xE5, 0x51, 0x90, 0x96, 0x14, 0x31, 
+0x54, 0xE0, 0x22, 0x12, 0x06, 0x89, 0x54, 0x7F, 0xF5, 0x51, 0x12, 0x74, 0x1C, 0xFF, 0x54, 0x1F, 
+0xF5, 0x53, 0xF1, 0x4F, 0xF5, 0x52, 0xF1, 0x49, 0xFF, 0x54, 0x03, 0xF5, 0x54, 0xEF, 0x54, 0x30, 
+0xC4, 0x54, 0x0F, 0xF5, 0x57, 0xF1, 0x49, 0xFF, 0x54, 0x40, 0xC4, 0x13, 0x13, 0x54, 0x03, 0xF5, 
+0x55, 0xF1, 0x4F, 0xF5, 0x56, 0xF1, 0x49, 0xFF, 0x54, 0x08, 0x13, 0x13, 0x13, 0x54, 0x1F, 0xF5, 
+0x59, 0xEF, 0x54, 0x04, 0x13, 0x13, 0x54, 0x3F, 0xF5, 0x5A, 0xE5, 0x56, 0x12, 0xAF, 0x08, 0xB1, 
+0xF6, 0x54, 0x7F, 0x4F, 0xF0, 0xE5, 0x55, 0x54, 0x01, 0xC4, 0x33, 0x33, 0x54, 0xC0, 0xB1, 0xF6, 
+0x54, 0xBF, 0x4F, 0xF0, 0xE5, 0x59, 0x60, 0x02, 0xC1, 0xF9, 0xE5, 0x53, 0x54, 0x1F, 0xFF, 0x75, 
+0xF0, 0x04, 0xE5, 0x51, 0xF1, 0x61, 0x54, 0xE0, 0x4F, 0xF0, 0xE5, 0x54, 0x54, 0x03, 0xB1, 0xF6, 
+0x54, 0xFC, 0x4F, 0xF0, 0xEF, 0x25, 0xE0, 0x25, 0xE0, 0xB1, 0xF6, 0x54, 0xF3, 0x4F, 0xF0, 0xE5, 
+0x52, 0x54, 0x01, 0xC4, 0x33, 0x54, 0xE0, 0xFF, 0x75, 0xF0, 0x04, 0xE5, 0x51, 0xF1, 0x61, 0x54, 
+0xDF, 0x4F, 0xF0, 0xE5, 0x57, 0x54, 0x03, 0xC4, 0x54, 0xF0, 0xB1, 0xF6, 0x54, 0xCF, 0x4F, 0xF0, 
+0x74, 0x91, 0x25, 0x51, 0x12, 0x66, 0xE5, 0xE0, 0x54, 0xFB, 0xF0, 0x74, 0x91, 0x25, 0x51, 0x12, 
+0x66, 0xE5, 0xE0, 0xFF, 0xE5, 0x5A, 0x25, 0xE0, 0x25, 0xE0, 0xFE, 0xEF, 0x4E, 0xF0, 0xE4, 0xF5, 
+0x58, 0x85, 0x58, 0x82, 0x75, 0x83, 0x00, 0xA3, 0xA3, 0xA3, 0x12, 0x06, 0xA2, 0xFF, 0x75, 0xF0, 
+0x08, 0xE5, 0x51, 0x12, 0x6C, 0x19, 0x25, 0x58, 0x12, 0x6C, 0x00, 0xEF, 0xF0, 0x05, 0x58, 0xE5, 
+0x58, 0xB4, 0x04, 0xDD, 0xAF, 0x51, 0x12, 0x69, 0xB5, 0x22, 0x90, 0x01, 0x30, 0xF1, 0x3E, 0x90, 
+0x01, 0x38, 0xF1, 0x3F, 0xFD, 0x7F, 0x50, 0x51, 0x9C, 0xE4, 0xFD, 0x7F, 0x51, 0x51, 0x9C, 0xE4, 
+0xFD, 0x7F, 0x52, 0x51, 0x9C, 0xE4, 0xFD, 0x7F, 0x53, 0x41, 0x9C, 0x90, 0x01, 0x34, 0x74, 0xFF, 
+0xF1, 0x3F, 0x90, 0x01, 0x3C, 0xF1, 0x3F, 0xFD, 0x7F, 0x54, 0x51, 0x9C, 0x7D, 0xFF, 0x7F, 0x55, 
+0x51, 0x9C, 0x7D, 0xFF, 0x7F, 0x56, 0x51, 0x9C, 0x7D, 0xFF, 0x7F, 0x57, 0x41, 0x9C, 0xE4, 0xF0, 
+0xA3, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0x22, 0x4F, 0xF0, 0x90, 0x00, 0x02, 0x02, 0x06, 0xA2, 0xEF, 
+0x54, 0x80, 0xC4, 0x13, 0x13, 0x13, 0x54, 0x01, 0x22, 0x75, 0x5F, 0x3E, 0x75, 0xF0, 0x04, 0xE5, 
+0x5D, 0x90, 0x96, 0x13, 0x31, 0x54, 0xE0, 0x22, 0x12, 0x37, 0xBC, 0xEF, 0x44, 0x03, 0xFF, 0xEC, 
+0x90, 0xA2, 0xF3, 0x12, 0x08, 0x6D, 0x90, 0xA2, 0xF3, 0x22, 0x12, 0xAF, 0xAE, 0x7F, 0xF2, 0x71, 
+0xFC, 0xEF, 0x20, 0xE6, 0x08, 0x7F, 0x05, 0xF1, 0xBC, 0x7F, 0x05, 0x51, 0x9C, 0x22, 0xE4, 0xF5, 
+0x0D, 0xF5, 0x0E, 0xF5, 0x0F, 0x75, 0x10, 0x80, 0xAD, 0x0D, 0x7F, 0x50, 0x51, 0x9C, 0xAD, 0x0E, 
+0x7F, 0x51, 0x51, 0x9C, 0xAD, 0x0F, 0x7F, 0x52, 0x51, 0x9C, 0xAD, 0x10, 0x7F, 0x53, 0x41, 0x9C, 
+0xD1, 0xFA, 0xF1, 0x1B, 0x12, 0x88, 0x8A, 0x12, 0x88, 0xA9, 0x80, 0xD2, 0x71, 0xFC, 0xEF, 0x44, 
+0x80, 0xFD, 0x22, 0x12, 0x93, 0x5C, 0x7F, 0x08, 0x71, 0xFC, 0xEF, 0x54, 0xEF, 0xFD, 0x7F, 0x08, 
+0x51, 0x9C, 0xE4, 0xFF, 0x12, 0x78, 0x5F, 0x90, 0x9F, 0xA3, 0xE0, 0xFF, 0xC4, 0x54, 0x0F, 0x30, 
+0xE0, 0x03, 0x12, 0x84, 0x50, 0x90, 0x9F, 0xA4, 0xE0, 0x54, 0xEF, 0xF0, 0x22, 0x7D, 0x20, 0x7F, 
+0xFF, 0x12, 0x52, 0x45, 0x71, 0xB6, 0x90, 0x9F, 0xA1, 0x74, 0x02, 0xF0, 0x22, 0x80, 0xF5, 0x90, 
+0xA0, 0x60, 0xE0, 0xC3, 0x13, 0x54, 0x07, 0xFF, 0x75, 0xF0, 0x0E, 0x90, 0xA0, 0x6D, 0x12, 0x49, 
+0x54, 0xE0, 0xFE, 0x75, 0xF0, 0x0E, 0xEF, 0x90, 0xA0, 0x6C, 0x12, 0x49, 0x54, 0xE0, 0x90, 0xA2, 
+0xD5, 0xF0, 0x90, 0xA2, 0xD4, 0xEE, 0xF0, 0xE4, 0xFB, 0xFD, 0x7F, 0x54, 0x7E, 0x01, 0xD3, 0x10, 
+0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0xA2, 0xD0, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0xA2, 0xD4, 
+0xE0, 0xF5, 0x3B, 0xA3, 0xE0, 0xF5, 0x3C, 0x12, 0x35, 0x7A, 0x90, 0xA2, 0xD0, 0x12, 0x7B, 0x10, 
+0xA3, 0xA3, 0xA3, 0x74, 0x05, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0xA0, 0x60, 0xE0, 0x30, 
+0xE0, 0x56, 0x90, 0xA0, 0x62, 0xE0, 0x70, 0x27, 0x7D, 0x16, 0x7F, 0x6F, 0x51, 0x45, 0x51, 0xA5, 
+0x11, 0xB9, 0x75, 0xF0, 0x0E, 0x12, 0xAD, 0xD9, 0x31, 0xE2, 0x11, 0xB9, 0x12, 0x8F, 0x6D, 0xE0, 
+0x44, 0x01, 0xF0, 0x12, 0xAF, 0x11, 0x11, 0x26, 0x90, 0xA0, 0x62, 0x74, 0x01, 0xF0, 0x22, 0x90, 
+0xA0, 0x62, 0xE0, 0x64, 0x01, 0x70, 0x1F, 0x11, 0xB9, 0x12, 0x8F, 0x6C, 0xE0, 0x30, 0xE0, 0x16, 
+0x75, 0xF0, 0x0E, 0xEF, 0x12, 0xAD, 0xD9, 0x31, 0xE2, 0x12, 0xAF, 0x11, 0xF0, 0xE4, 0xFB, 0xFD, 
+0x7F, 0x54, 0x7E, 0x01, 0x01, 0x2E, 0x11, 0xC2, 0x22, 0x90, 0xA0, 0x60, 0xE0, 0xC3, 0x13, 0x54, 
+0x07, 0x22, 0x90, 0xA0, 0x60, 0xE0, 0xFF, 0xC3, 0x13, 0xFE, 0xEF, 0x54, 0xF1, 0xFF, 0xEE, 0x04, 
+0x54, 0x07, 0x25, 0xE0, 0x4F, 0xF0, 0xA3, 0xE0, 0xFF, 0x12, 0xAE, 0x80, 0xB5, 0x07, 0x04, 0xEE, 
+0x54, 0xF1, 0xF0, 0x12, 0x4F, 0xFF, 0xE4, 0x90, 0xA0, 0x62, 0xF0, 0x51, 0xA5, 0x12, 0xAE, 0x80, 
+0xF1, 0xE7, 0xE0, 0xFA, 0x75, 0xF0, 0x0E, 0xED, 0x51, 0x99, 0xFC, 0x54, 0x03, 0xFD, 0xEC, 0x13, 
+0x13, 0x54, 0x07, 0xFB, 0xEE, 0x12, 0xAF, 0x86, 0xAF, 0x02, 0x51, 0xE9, 0x11, 0xB9, 0xFE, 0x75, 
+0xF0, 0x0E, 0x51, 0x99, 0xFD, 0x54, 0x03, 0xFF, 0xED, 0xC4, 0x13, 0x54, 0x07, 0xFD, 0x75, 0xF0, 
+0x0E, 0xEE, 0x51, 0x99, 0xF1, 0x21, 0x11, 0xB9, 0xFF, 0x75, 0xF0, 0x0E, 0x90, 0xA0, 0x6E, 0x12, 
+0x49, 0x54, 0xE0, 0x04, 0xF0, 0x75, 0xF0, 0x0E, 0xEF, 0x51, 0x34, 0x11, 0xB9, 0xFD, 0xE4, 0xFF, 
+0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0xA3, 0x07, 0x12, 0xAF, 0x1A, 0x90, 0xA3, 0x09, 
+0xE0, 0xFF, 0xC3, 0x94, 0x02, 0x40, 0x02, 0x21, 0xDD, 0x90, 0xA3, 0x08, 0xE0, 0xFE, 0x12, 0xAA, 
+0x36, 0x75, 0xF0, 0x03, 0xEF, 0x12, 0xAE, 0x0C, 0xE0, 0x90, 0xA3, 0x0A, 0xF0, 0x90, 0xA3, 0x07, 
+0xE0, 0x60, 0x24, 0x90, 0xA3, 0x0A, 0xE0, 0xFF, 0x75, 0xF0, 0x0E, 0xEE, 0x12, 0xAA, 0x29, 0xC0, 
+0x83, 0xC0, 0x82, 0x90, 0xA3, 0x09, 0xE0, 0xD0, 0x82, 0xD0, 0x83, 0x12, 0x6F, 0xD6, 0x80, 0x02, 
+0xC3, 0x33, 0xD8, 0xFC, 0x4F, 0x80, 0x20, 0x12, 0xAE, 0x8A, 0x75, 0xF0, 0x0E, 0x12, 0xAA, 0x29, 
+0xC0, 0x83, 0xC0, 0x82, 0x90, 0xA3, 0x09, 0xE0, 0xD0, 0x82, 0xD0, 0x83, 0x12, 0x6F, 0xD6, 0x80, 
+0x02, 0xC3, 0x33, 0xD8, 0xFC, 0xF4, 0x5F, 0x90, 0xA3, 0x0A, 0xF0, 0x12, 0xAE, 0x8A, 0x12, 0xAA, 
+0x36, 0xC0, 0x83, 0xC0, 0x82, 0x90, 0xA3, 0x09, 0xE0, 0xD0, 0x82, 0xD0, 0x83, 0x75, 0xF0, 0x03, 
+0x12, 0xAE, 0x0C, 0xEF, 0xF0, 0x90, 0xA3, 0x09, 0xE0, 0x04, 0xF0, 0x21, 0x4D, 0xD0, 0xD0, 0x92, 
+0xAF, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0xA2, 0xDC, 0xEE, 0xF0, 0xA3, 0xEF, 
+0xF0, 0xA3, 0xED, 0xF0, 0x90, 0x04, 0x1D, 0xE0, 0x60, 0x25, 0x90, 0x05, 0x22, 0xE0, 0x90, 0xA2, 
+0xE1, 0xF0, 0x7D, 0x13, 0x51, 0xA1, 0xBF, 0x01, 0x0B, 0x12, 0x90, 0xD5, 0x90, 0xA2, 0xDF, 0xF1, 
+0xD8, 0x12, 0x92, 0x78, 0x90, 0xA2, 0xE1, 0xE0, 0xFF, 0x7D, 0x15, 0x51, 0x45, 0x80, 0x0B, 0x12, 
+0x90, 0xD5, 0x90, 0xA2, 0xDF, 0xF1, 0xD8, 0x12, 0x92, 0x78, 0x12, 0x92, 0x71, 0x7F, 0x01, 0xD0, 
+0xD0, 0x92, 0xAF, 0x22, 0x90, 0xA0, 0x6F, 0x12, 0x49, 0x54, 0xE0, 0xFF, 0x7E, 0x00, 0xE4, 0xFD, 
+0x31, 0xE2, 0xE4, 0xFD, 0xFF, 0x90, 0x05, 0x22, 0xEF, 0xF0, 0x90, 0x9E, 0x96, 0xED, 0xF0, 0x22, 
+0x8F, 0x54, 0x7D, 0x17, 0x51, 0xA1, 0x75, 0xF0, 0x0E, 0xE5, 0x54, 0xF1, 0xEB, 0xE0, 0xFC, 0x51, 
+0x94, 0xFE, 0x54, 0x03, 0xFD, 0xEE, 0x13, 0x13, 0x54, 0x07, 0xFB, 0x90, 0xA0, 0x60, 0xE0, 0xFE, 
+0x12, 0xAF, 0x86, 0xAF, 0x04, 0x51, 0xE9, 0x51, 0x94, 0xFE, 0x54, 0x03, 0xFF, 0xEE, 0xC4, 0x13, 
+0x54, 0x07, 0xFD, 0x51, 0x94, 0xF1, 0x21, 0x75, 0xF0, 0x0E, 0xE5, 0x54, 0x51, 0x34, 0xAD, 0x54, 
+0xE4, 0xFF, 0x21, 0x40, 0x75, 0xF0, 0x0E, 0xE5, 0x54, 0x90, 0xA0, 0x64, 0x12, 0x49, 0x54, 0xE0, 
+0x22, 0x7F, 0xFF, 0x51, 0x45, 0xE4, 0x90, 0xA3, 0x1F, 0xF0, 0xA3, 0xF0, 0x90, 0x05, 0xF8, 0xE0, 
+0x70, 0x0F, 0xA3, 0xE0, 0x70, 0x0B, 0xA3, 0xE0, 0x70, 0x07, 0xA3, 0xE0, 0x70, 0x03, 0x7F, 0x01, 
+0x22, 0xD3, 0x90, 0xA3, 0x20, 0xE0, 0x94, 0xE8, 0x90, 0xA3, 0x1F, 0xE0, 0x94, 0x03, 0x40, 0x0A, 
+0x90, 0x01, 0xC0, 0xE0, 0x44, 0x20, 0xF0, 0x7F, 0x00, 0x22, 0x7F, 0x32, 0x7E, 0x00, 0x12, 0x3D, 
+0x7A, 0x90, 0xA3, 0x1F, 0x12, 0x78, 0xFB, 0x80, 0xC3, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 
+0x90, 0xA3, 0x00, 0xED, 0xF0, 0xA3, 0xEB, 0xF0, 0x90, 0xA2, 0xFF, 0xEF, 0xF0, 0x90, 0xA3, 0x02, 
+0xE0, 0xFD, 0x12, 0x9D, 0x4E, 0x90, 0xA2, 0xFF, 0xE0, 0xC3, 0x94, 0x0E, 0x50, 0x40, 0x90, 0xA2, 
+0xB1, 0x12, 0x08, 0x79, 0x1F, 0xFE, 0x00, 0x00, 0x90, 0xA2, 0xB5, 0x12, 0x08, 0x79, 0x12, 0xD4, 
+0x00, 0x00, 0x12, 0xAF, 0xB5, 0x90, 0xA2, 0x9F, 0x12, 0x08, 0x79, 0x00, 0x07, 0x03, 0x00, 0x90, 
+0xA2, 0xA3, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 0x00, 0xB1, 0xB2, 0x12, 0x08, 0x79, 0x00, 0x07, 
+0x03, 0x00, 0x90, 0xA2, 0xA3, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 0x00, 0x81, 0x6E, 0x12, 0xAE, 
+0xA7, 0x50, 0x1B, 0xEF, 0x94, 0x30, 0x50, 0x16, 0x90, 0xA2, 0xB1, 0x12, 0x08, 0x79, 0x1F, 0xFE, 
+0x00, 0x00, 0x90, 0xA2, 0xB5, 0x12, 0x08, 0x79, 0x09, 0x28, 0x00, 0x00, 0x80, 0x65, 0x90, 0xA2, 
+0xFF, 0xE0, 0xFF, 0x74, 0x32, 0xD3, 0x9F, 0x50, 0x1B, 0xEF, 0x94, 0x40, 0x50, 0x16, 0x90, 0xA2, 
+0xB1, 0x12, 0x08, 0x79, 0x1F, 0xFE, 0x00, 0x00, 0x90, 0xA2, 0xB5, 0x12, 0x08, 0x79, 0x08, 0xA6, 
+0x00, 0x00, 0x80, 0x3F, 0x12, 0xAE, 0x9D, 0x50, 0x1B, 0xEF, 0x94, 0x74, 0x50, 0x16, 0x90, 0xA2, 
+0xB1, 0x12, 0x08, 0x79, 0x1F, 0xFE, 0x00, 0x00, 0x90, 0xA2, 0xB5, 0x12, 0x08, 0x79, 0x08, 0xA4, 
+0x00, 0x00, 0x80, 0x1F, 0x90, 0xA2, 0xFF, 0xE0, 0xFF, 0x74, 0x76, 0xD3, 0x9F, 0x50, 0x17, 0x90, 
+0xA2, 0xB1, 0x12, 0x08, 0x79, 0x1F, 0xFE, 0x00, 0x00, 0x90, 0xA2, 0xB5, 0x12, 0x08, 0x79, 0x08, 
+0x24, 0x00, 0x00, 0x12, 0xAF, 0xB5, 0x12, 0xAE, 0xA7, 0x50, 0x2E, 0xEF, 0x94, 0x40, 0x50, 0x29, 
+0x90, 0xA2, 0x9F, 0x12, 0x08, 0x79, 0x00, 0x07, 0x03, 0x00, 0x90, 0xA2, 0xA3, 0x12, 0x08, 0x79, 
+0x00, 0x01, 0x01, 0x00, 0xB1, 0xB2, 0x12, 0x08, 0x79, 0x00, 0x07, 0x03, 0x00, 0x90, 0xA2, 0xA3, 
+0x12, 0x08, 0x79, 0x00, 0x01, 0x01, 0x00, 0x80, 0x65, 0x12, 0xAE, 0x9D, 0x50, 0x2E, 0xEF, 0x94, 
+0x8C, 0x50, 0x29, 0x90, 0xA2, 0x9F, 0x12, 0x08, 0x79, 0x00, 0x07, 0x03, 0x00, 0x90, 0xA2, 0xA3, 
+0x12, 0x08, 0x79, 0x00, 0x03, 0x01, 0x00, 0xB1, 0xB2, 0x12, 0x08, 0x79, 0x00, 0x07, 0x03, 0x00, 
+0x90, 0xA2, 0xA3, 0x12, 0x08, 0x79, 0x00, 0x03, 0x01, 0x00, 0x80, 0x32, 0x90, 0xA2, 0xFF, 0xE0, 
+0xFF, 0x74, 0x8C, 0xC3, 0x9F, 0x50, 0x2B, 0x90, 0xA2, 0x9F, 0x12, 0x08, 0x79, 0x00, 0x07, 0x03, 
+0x00, 0x90, 0xA2, 0xA3, 0x12, 0x08, 0x79, 0x00, 0x05, 0x01, 0x00, 0xB1, 0xB2, 0x12, 0x08, 0x79, 
+0x00, 0x07, 0x03, 0x00, 0x90, 0xA2, 0xA3, 0x12, 0x08, 0x79, 0x00, 0x05, 0x01, 0x00, 0xF1, 0xE0, 
+0xB1, 0x30, 0x90, 0xA3, 0x00, 0xE0, 0x64, 0x02, 0x70, 0x51, 0x90, 0xA2, 0xFF, 0xE0, 0xFF, 0xD3, 
+0x94, 0x30, 0x50, 0x05, 0x75, 0x70, 0x2A, 0x80, 0x5E, 0xEF, 0xD3, 0x94, 0x40, 0x50, 0x05, 0x75, 
+0x70, 0x3A, 0x80, 0x53, 0xEF, 0xD3, 0x94, 0x70, 0x50, 0x05, 0x75, 0x70, 0x6A, 0x80, 0x48, 0xEF, 
+0xD3, 0x94, 0x80, 0x50, 0x05, 0x75, 0x70, 0x7A, 0x80, 0x3D, 0xEF, 0xD3, 0x94, 0x90, 0x50, 0x05, 
+0x75, 0x70, 0x8A, 0x80, 0x32, 0xEF, 0xD3, 0x94, 0xA1, 0x50, 0x05, 0x75, 0x70, 0x9B, 0x80, 0x27, 
+0xEF, 0xD3, 0x94, 0xB1, 0x50, 0x21, 0x75, 0x70, 0xAB, 0x80, 0x1C, 0x90, 0xA3, 0x00, 0xE0, 0x64, 
+0x01, 0x70, 0x2D, 0xA3, 0xE0, 0x90, 0xA2, 0xFF, 0xB4, 0x01, 0x07, 0xE0, 0x24, 0x02, 0xF5, 0x70, 
+0x80, 0x05, 0xE0, 0x24, 0xFE, 0xF5, 0x70, 0x90, 0xA2, 0x9F, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 
+0xFF, 0xAF, 0x70, 0xB1, 0xA8, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 0xFF, 0xAF, 0x70, 0x80, 0x1D, 
+0x90, 0xA2, 0x9F, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 0xFF, 0x90, 0xA2, 0xFF, 0xE0, 0xFF, 0xB1, 
+0xA8, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 0xFF, 0x90, 0xA2, 0xFF, 0xE0, 0xFF, 0xE4, 0xFC, 0xFD, 
+0xFE, 0x90, 0xA2, 0xA3, 0x12, 0x08, 0x6D, 0xF1, 0xE0, 0xB1, 0x30, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 
+0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0xA2, 0x9D, 0xEC, 0xF0, 0xA3, 0xED, 0xF0, 0x90, 
+0xA2, 0x9C, 0xEF, 0xF0, 0xA3, 0xA3, 0xE0, 0xFD, 0x12, 0x77, 0x23, 0x90, 0xA2, 0xA7, 0x12, 0x08, 
+0x6D, 0x90, 0xA2, 0x9F, 0x12, 0x49, 0x3C, 0x12, 0x08, 0x3A, 0x90, 0xA2, 0xA7, 0x12, 0xAD, 0xE6, 
+0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0xA2, 0x9F, 0x12, 0x49, 0x3C, 0x90, 0xA2, 
+0xA3, 0x12, 0xAD, 0xE6, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0x12, 0x48, 0x7A, 0x90, 
+0xA2, 0xAB, 0x12, 0x08, 0x6D, 0x90, 0xA2, 0x9D, 0xA3, 0xE0, 0xFD, 0xC0, 0x05, 0x90, 0xA2, 0xAB, 
+0x12, 0x49, 0x3C, 0x90, 0xAA, 0x96, 0x12, 0x08, 0x6D, 0x90, 0xA2, 0x9C, 0xE0, 0xFF, 0xD0, 0x05, 
+0x12, 0x3C, 0x33, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xE4, 0xFC, 0xFD, 0xFE, 0x90, 0xA2, 0xA3, 0x12, 
+0x08, 0x6D, 0x7D, 0x18, 0x7C, 0x00, 0xE4, 0xFF, 0xB1, 0x30, 0x90, 0xA2, 0x9F, 0x22, 0xD3, 0x10, 
+0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0xEF, 0x14, 0x60, 0x30, 0x14, 0x60, 0x56, 0x24, 0x02, 0x70, 0x7D, 
+0x90, 0xA2, 0x9F, 0x12, 0x08, 0x79, 0x00, 0x00, 0x0C, 0x00, 0x90, 0xA2, 0xA3, 0x12, 0x08, 0x79, 
+0x00, 0x00, 0x0C, 0x00, 0xB1, 0xB2, 0x12, 0x08, 0x79, 0x00, 0x00, 0x0C, 0x00, 0x90, 0xA2, 0xA3, 
+0x12, 0x08, 0x79, 0x00, 0x00, 0x0C, 0x00, 0x80, 0x50, 0x90, 0xA2, 0x9F, 0x12, 0x08, 0x79, 0x00, 
+0x00, 0x0C, 0x00, 0x90, 0xA2, 0xA3, 0x12, 0x08, 0x79, 0x00, 0x00, 0x04, 0x00, 0xB1, 0xB2, 0x12, 
+0x08, 0x79, 0x00, 0x00, 0x0C, 0x00, 0x90, 0xA2, 0xA3, 0x12, 0x08, 0x79, 0x00, 0x00, 0x04, 0x00, 
+0x80, 0x27, 0x90, 0xA2, 0x9F, 0x12, 0x08, 0x79, 0x00, 0x00, 0x0C, 0x00, 0x90, 0xA2, 0xA3, 0x12, 
+0x08, 0x79, 0x00, 0x00, 0x00, 0x00, 0xB1, 0xB2, 0x12, 0x08, 0x79, 0x00, 0x00, 0x0C, 0x00, 0x90, 
+0xA2, 0xA3, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 0x00, 0xF1, 0xE0, 0xB1, 0x30, 0xD0, 0xD0, 0x92, 
+0xAF, 0x22, 0x12, 0x77, 0xCC, 0x12, 0x06, 0x89, 0xC4, 0x54, 0x0F, 0xFF, 0xBF, 0x0F, 0x15, 0x90, 
+0xA0, 0x60, 0xE0, 0x54, 0xFE, 0xF0, 0x12, 0x71, 0x05, 0x12, 0xAE, 0xE3, 0x54, 0x0F, 0xFF, 0x51, 
+0x50, 0x02, 0x85, 0x11, 0x12, 0x74, 0x16, 0x12, 0xAF, 0xCC, 0xF1, 0xE7, 0xEF, 0x12, 0x4F, 0x48, 
+0x54, 0x03, 0xFF, 0x75, 0xF0, 0x0E, 0xED, 0x51, 0x99, 0x54, 0xFC, 0x12, 0x4F, 0x47, 0x54, 0x1C, 
+0xFF, 0xEE, 0x54, 0x0F, 0xFE, 0x75, 0xF0, 0x0E, 0x51, 0x99, 0x54, 0xE3, 0x12, 0x4F, 0x47, 0x54, 
+0xE0, 0xFF, 0x75, 0xF0, 0x0E, 0xEE, 0x51, 0x99, 0x54, 0x1F, 0x4F, 0xF0, 0x90, 0x00, 0x04, 0x12, 
+0xAE, 0x75, 0xE4, 0xFB, 0x12, 0xAA, 0x2F, 0xA9, 0x53, 0x90, 0x00, 0x05, 0x12, 0xAE, 0x75, 0x7B, 
+0x01, 0x12, 0xAA, 0x2F, 0xA9, 0x53, 0xF1, 0x1B, 0x33, 0x33, 0x33, 0x54, 0xF8, 0x12, 0xAF, 0xCC, 
+0xFD, 0x75, 0xF0, 0x0E, 0x90, 0xA0, 0x6C, 0x12, 0x49, 0x54, 0xEF, 0xF1, 0x1A, 0xC4, 0x13, 0x54, 
+0x07, 0xFF, 0x75, 0xF0, 0x0E, 0xED, 0x90, 0xA0, 0x6D, 0x12, 0x49, 0x54, 0xEF, 0xF0, 0xEE, 0xC4, 
+0x54, 0x0F, 0xFF, 0x14, 0x6D, 0x70, 0x22, 0x90, 0xA0, 0x61, 0xEF, 0x12, 0x67, 0xCE, 0x54, 0x0F, 
+0xC4, 0x54, 0xF0, 0xFF, 0x90, 0xA0, 0x60, 0xE0, 0x54, 0x0F, 0x4F, 0xF0, 0x54, 0xF1, 0xF0, 0x44, 
+0x01, 0xF0, 0x7D, 0x20, 0xE4, 0xFF, 0x12, 0x71, 0x69, 0x22, 0xF0, 0x90, 0x00, 0x03, 0x02, 0x06, 
+0xA2, 0xFE, 0x13, 0x13, 0x54, 0x07, 0xFB, 0x90, 0xA3, 0x03, 0x12, 0x7C, 0xAE, 0xEB, 0xF0, 0xE4, 
+0xFE, 0x7D, 0x18, 0xFF, 0x12, 0x3D, 0x2C, 0x90, 0xA3, 0x06, 0xEF, 0xF0, 0x90, 0xA3, 0x03, 0xE0, 
+0xFF, 0x12, 0x9D, 0x8D, 0x90, 0xA3, 0x03, 0x12, 0xAF, 0x23, 0x12, 0x9D, 0xE4, 0xAE, 0x07, 0x90, 
+0x04, 0x83, 0xEE, 0xF0, 0x90, 0xA3, 0x03, 0xE0, 0xFF, 0xAD, 0x06, 0x12, 0x7C, 0xB5, 0x90, 0xA3, 
+0x03, 0xE0, 0xFF, 0xA1, 0xBE, 0x7D, 0x08, 0xE4, 0xFF, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 
+0x90, 0xA2, 0xE2, 0xEF, 0xF0, 0xA3, 0xED, 0xF0, 0x90, 0x9E, 0x94, 0xE0, 0x04, 0xF0, 0x90, 0x04, 
+0x1D, 0xE0, 0x60, 0x2A, 0x90, 0x05, 0x22, 0xE0, 0x90, 0xA2, 0xE6, 0xF0, 0x7D, 0x26, 0x51, 0xA1, 
+0xEF, 0x64, 0x01, 0x70, 0x0B, 0xF1, 0xC6, 0x12, 0x92, 0x8F, 0x20, 0xE0, 0x03, 0x12, 0x91, 0xF7, 
+0x90, 0xA2, 0xE6, 0xE0, 0xFF, 0x7D, 0x27, 0x51, 0x45, 0x12, 0xAC, 0x43, 0x80, 0x0E, 0x12, 0xAC, 
+0x43, 0xF1, 0xC6, 0x12, 0x92, 0x8F, 0x20, 0xE0, 0x03, 0x12, 0x91, 0xF7, 0x12, 0x92, 0x71, 0x7F, 
+0x01, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0x9E, 0x9A, 0xE0, 0xFF, 0x90, 0xA2, 0xE3, 0xE0, 0xFB, 
+0x7D, 0x01, 0x12, 0x90, 0xDF, 0x90, 0xA2, 0xE4, 0xEE, 0xF0, 0xFC, 0xA3, 0xEF, 0xF0, 0xFD, 0x22, 
+0x7D, 0x18, 0x7C, 0x00, 0x7F, 0x01, 0x22, 0xFD, 0x75, 0xF0, 0x0E, 0x90, 0xA0, 0x63, 0x02, 0x49, 
+0x54, 0x7D, 0x1F, 0x7F, 0x6F, 0x51, 0x45, 0x90, 0x05, 0x27, 0xE0, 0x54, 0xBF, 0xF0, 0x90, 0x9F, 
+0xA1, 0x74, 0x04, 0xF0, 0x22, 0x02, 0x4A, 0xB1, 0xE4, 0x90, 0xA1, 0x3D, 0xF0, 0x90, 0xA1, 0x3D, 
+0xE0, 0x64, 0x01, 0xF0, 0x24, 0x08, 0x90, 0x01, 0xC4, 0xF0, 0x74, 0x58, 0xA3, 0xF0, 0x12, 0x3D, 
+0x6E, 0xBF, 0x01, 0x03, 0x12, 0x31, 0x38, 0x90, 0x9F, 0xA7, 0xE0, 0x60, 0x0E, 0x90, 0x9F, 0xAA, 
+0xE0, 0xFF, 0x90, 0x9F, 0xA9, 0xE0, 0x6F, 0x60, 0x02, 0x11, 0x4F, 0xC2, 0xAF, 0x12, 0x88, 0xF3, 
+0xBF, 0x01, 0x03, 0x12, 0x8A, 0x2B, 0xD2, 0xAF, 0x11, 0x05, 0x12, 0x46, 0x0D, 0x80, 0xBE, 0x90, 
+0x9F, 0x9E, 0xE0, 0x90, 0x9F, 0xA9, 0x30, 0xE0, 0x04, 0xE0, 0xFF, 0xE1, 0x0A, 0xE0, 0xFF, 0x7D, 
+0x01, 0x80, 0x04, 0x7D, 0x01, 0x7F, 0x04, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0xA3, 
+0x2F, 0xED, 0xF0, 0x90, 0x9F, 0xA3, 0xE0, 0xFE, 0xC4, 0x13, 0x13, 0x54, 0x03, 0x30, 0xE0, 0x02, 
+0x21, 0xB3, 0xEE, 0x12, 0x4F, 0x52, 0x30, 0xE0, 0x02, 0x21, 0xB3, 0x90, 0x9F, 0xAA, 0xE0, 0xFE, 
+0x6F, 0x70, 0x02, 0x21, 0xB3, 0xEF, 0x70, 0x02, 0x21, 0x24, 0x24, 0xFE, 0x70, 0x02, 0x21, 0x5E, 
+0x24, 0xFE, 0x60, 0x48, 0x24, 0xFC, 0x70, 0x02, 0x21, 0x99, 0x24, 0xFC, 0x60, 0x02, 0x21, 0xAC, 
+0xEE, 0xB4, 0x0E, 0x02, 0x31, 0xEC, 0x90, 0x9F, 0xAA, 0xE0, 0x70, 0x04, 0x7F, 0x01, 0x51, 0x33, 
+0x90, 0x9F, 0xAA, 0xE0, 0xB4, 0x06, 0x02, 0x51, 0x0D, 0x90, 0x9F, 0xAA, 0xE0, 0xB4, 0x04, 0x0E, 
+0x90, 0xA3, 0x2F, 0xE0, 0xFF, 0x60, 0x05, 0x12, 0x8D, 0x70, 0x80, 0x02, 0xD1, 0x7A, 0x90, 0x9F, 
+0xAA, 0xE0, 0x64, 0x08, 0x60, 0x02, 0x21, 0xAC, 0xF1, 0x43, 0x21, 0xAC, 0x90, 0x9F, 0xAA, 0xE0, 
+0x70, 0x04, 0x7F, 0x01, 0x51, 0x33, 0x90, 0x9F, 0xAA, 0xE0, 0xB4, 0x06, 0x02, 0x51, 0x0D, 0x90, 
+0x9F, 0xAA, 0xE0, 0xB4, 0x0E, 0x07, 0x31, 0xB8, 0xBF, 0x01, 0x02, 0x31, 0xEC, 0x90, 0x9F, 0xAA, 
+0xE0, 0x64, 0x0C, 0x60, 0x02, 0x21, 0xAC, 0x31, 0xB8, 0xEF, 0x64, 0x01, 0x60, 0x02, 0x21, 0xAC, 
+0x51, 0x4C, 0x21, 0xAC, 0x90, 0x9F, 0xAA, 0xE0, 0xB4, 0x0E, 0x07, 0x31, 0xB8, 0xBF, 0x01, 0x02, 
+0x31, 0xEC, 0x90, 0x9F, 0xAA, 0xE0, 0xB4, 0x06, 0x02, 0x51, 0x0D, 0x90, 0x9F, 0xAA, 0xE0, 0xB4, 
+0x0C, 0x07, 0x31, 0xB8, 0xBF, 0x01, 0x02, 0x51, 0x4C, 0x90, 0x9F, 0xAA, 0xE0, 0x64, 0x04, 0x70, 
+0x5B, 0x12, 0x89, 0x32, 0xEF, 0x64, 0x01, 0x70, 0x53, 0x12, 0x84, 0x69, 0x80, 0x4E, 0x90, 0x9F, 
+0xAA, 0xE0, 0xB4, 0x0E, 0x07, 0x31, 0xB8, 0xBF, 0x01, 0x02, 0x31, 0xEC, 0x90, 0x9F, 0xAA, 0xE0, 
+0xB4, 0x06, 0x02, 0x51, 0x0D, 0x90, 0x9F, 0xAA, 0xE0, 0xB4, 0x0C, 0x07, 0x31, 0xB8, 0xBF, 0x01, 
+0x02, 0x51, 0x4C, 0x90, 0x9F, 0xAA, 0xE0, 0x70, 0x04, 0x7F, 0x01, 0x51, 0x33, 0x90, 0x9F, 0xAA, 
+0xE0, 0xB4, 0x04, 0x18, 0x12, 0xAA, 0xE3, 0x80, 0x13, 0x90, 0x9F, 0xAA, 0xE0, 0xB4, 0x0C, 0x0C, 
+0x90, 0x9F, 0xA4, 0x12, 0x8D, 0x69, 0x30, 0xE0, 0x03, 0x12, 0xAC, 0x2B, 0x90, 0x9F, 0xAA, 0x12, 
+0xAD, 0xCC, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xF1, 0x97, 0xEF, 0x64, 0x01, 0x60, 0x05, 0x12, 
+0x89, 0xC9, 0x80, 0x1F, 0x12, 0xAA, 0xAC, 0x30, 0xE0, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x02, 0xF0, 
+0x80, 0x11, 0x90, 0x9F, 0xA9, 0xE0, 0xD3, 0x94, 0x04, 0x40, 0x05, 0x12, 0x89, 0x2B, 0x80, 0x03, 
+0x02, 0x8A, 0x0B, 0x90, 0x01, 0xB9, 0x74, 0x02, 0xF0, 0x7F, 0x00, 0x22, 0x90, 0x9F, 0xA4, 0xE0, 
+0xC3, 0x13, 0x20, 0xE0, 0x04, 0x51, 0x87, 0x80, 0x0E, 0x12, 0xAC, 0xA3, 0xB1, 0x88, 0x90, 0x05, 
+0x27, 0xE0, 0x44, 0x80, 0xF0, 0x51, 0x45, 0xE4, 0xFD, 0xFF, 0x02, 0x52, 0x45, 0x90, 0x9F, 0xA4, 
+0xE0, 0x90, 0x06, 0x04, 0x20, 0xE0, 0x07, 0xE0, 0x44, 0x40, 0xB1, 0x88, 0x80, 0x0F, 0x51, 0x83, 
+0x90, 0x05, 0x27, 0xE0, 0x54, 0x7F, 0xF0, 0x90, 0x9F, 0xA2, 0x74, 0x0C, 0xF0, 0xE4, 0xFD, 0xFF, 
+0x02, 0x52, 0x45, 0x90, 0xA3, 0x2E, 0xEF, 0xF0, 0x12, 0x4C, 0x32, 0x90, 0xA3, 0x2E, 0xE0, 0x60, 
+0x02, 0xD1, 0x74, 0xB1, 0x89, 0x90, 0x9F, 0xA2, 0x74, 0x04, 0xF0, 0x22, 0x12, 0x8C, 0x45, 0x70, 
+0x31, 0x90, 0x9F, 0xA4, 0xE0, 0x54, 0xFD, 0xF0, 0x7D, 0x2C, 0x7F, 0x6F, 0x12, 0x52, 0x45, 0x7D, 
+0x08, 0x7F, 0x01, 0x12, 0x57, 0x69, 0xBF, 0x01, 0x14, 0x90, 0x9F, 0xA3, 0xE0, 0x44, 0x80, 0xF0, 
+0x7D, 0x0E, 0x7F, 0x01, 0x51, 0x8B, 0x90, 0x9F, 0xA2, 0x74, 0x0E, 0xF0, 0x22, 0x12, 0x8E, 0xD7, 
+0x04, 0xF0, 0x22, 0xE0, 0x54, 0x7F, 0xF0, 0x7D, 0x0C, 0x7F, 0x01, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 
+0xC0, 0xD0, 0x90, 0xA3, 0x2D, 0xEF, 0xF0, 0x14, 0x60, 0x15, 0x14, 0x60, 0x19, 0x24, 0x02, 0x70, 
+0x1A, 0xED, 0x54, 0x01, 0xFF, 0x90, 0x9F, 0xA3, 0xE0, 0x54, 0xFE, 0x4F, 0xF0, 0x80, 0x0C, 0x90, 
+0x9F, 0xAA, 0xED, 0xF0, 0x80, 0x05, 0x90, 0x9F, 0xA9, 0xED, 0xF0, 0x7F, 0x8F, 0x12, 0x4B, 0xFC, 
+0xEF, 0x30, 0xE4, 0x2C, 0x90, 0xA3, 0x2D, 0xE0, 0x14, 0x60, 0x07, 0x14, 0x60, 0x18, 0x24, 0x02, 
+0x70, 0x1E, 0x90, 0x9F, 0xA3, 0xE0, 0x12, 0xAF, 0x08, 0xFF, 0x90, 0x9F, 0xAA, 0xE0, 0x54, 0x7F, 
+0x4F, 0xFD, 0x7F, 0x88, 0x80, 0x07, 0x90, 0x9F, 0xA9, 0xE0, 0xFD, 0x7F, 0x89, 0x12, 0x4A, 0x9C, 
+0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x12, 0x77, 0xCC, 0x90, 
+0x05, 0x27, 0xE0, 0xF5, 0x54, 0x12, 0x84, 0x48, 0x90, 0x9F, 0x9E, 0x12, 0xAD, 0xB0, 0xB1, 0x90, 
+0x54, 0x04, 0xFD, 0xEF, 0x54, 0xFB, 0xD1, 0xD1, 0x54, 0x08, 0xFE, 0xEF, 0x54, 0xF7, 0xB1, 0x8F, 
+0x54, 0x10, 0xFD, 0xEF, 0x54, 0xEF, 0xD1, 0xD1, 0x54, 0x20, 0xFE, 0xEF, 0x54, 0xDF, 0xB1, 0x8F, 
+0x54, 0x40, 0xFD, 0xEF, 0x54, 0xBF, 0x4D, 0x90, 0x9F, 0x9E, 0xF0, 0xEE, 0xC3, 0x13, 0x20, 0xE0, 
+0x02, 0x61, 0xCC, 0xE0, 0x30, 0xE0, 0x71, 0x12, 0x71, 0x65, 0x75, 0x54, 0x21, 0xD1, 0xE2, 0x30, 
+0xE0, 0x08, 0x12, 0xAD, 0xEC, 0x43, 0x54, 0x08, 0x80, 0x0D, 0xE4, 0x90, 0x9F, 0x9F, 0xF0, 0xA3, 
+0xF0, 0x7D, 0x40, 0xFF, 0x12, 0x71, 0x7B, 0xD1, 0xD9, 0x54, 0x1F, 0x30, 0xE0, 0x03, 0x43, 0x54, 
+0x12, 0xEF, 0xC4, 0x54, 0x0F, 0x30, 0xE0, 0x03, 0x43, 0x54, 0x14, 0x90, 0x9F, 0x9E, 0xE0, 0xC4, 
+0x13, 0x54, 0x07, 0x30, 0xE0, 0x03, 0x43, 0x54, 0x80, 0x90, 0x9F, 0x9E, 0xF1, 0xEA, 0x20, 0xE0, 
+0x03, 0x43, 0x54, 0x40, 0x91, 0x70, 0x90, 0x9F, 0xA1, 0xE0, 0x70, 0x04, 0x7F, 0x01, 0x91, 0x77, 
+0xD1, 0xF3, 0x30, 0xE0, 0x04, 0x7F, 0x04, 0x80, 0x0B, 0xD1, 0xFE, 0xEF, 0x60, 0x04, 0x7F, 0x01, 
+0x80, 0x02, 0x7F, 0x02, 0x91, 0x77, 0x81, 0x3A, 0x75, 0x54, 0x01, 0x91, 0x70, 0x90, 0x9F, 0xA1, 
+0xE0, 0x64, 0x04, 0x60, 0x02, 0x81, 0x6B, 0xFF, 0x91, 0x77, 0x81, 0x6B, 0x90, 0x9F, 0x9E, 0xE0, 
+0x30, 0xE0, 0x6F, 0x12, 0x71, 0x65, 0x43, 0x54, 0x31, 0xD1, 0xE2, 0x30, 0xE0, 0x08, 0x12, 0xAD, 
+0xEC, 0x43, 0x54, 0x08, 0x80, 0x07, 0x7D, 0x40, 0xE4, 0xFF, 0x12, 0x71, 0x7B, 0xD1, 0xD9, 0x54, 
+0x1F, 0x30, 0xE0, 0x03, 0x43, 0x54, 0x02, 0xEF, 0xC4, 0x54, 0x0F, 0x30, 0xE0, 0x03, 0x43, 0x54, 
+0x04, 0x91, 0x70, 0xD1, 0xF3, 0x30, 0xE0, 0x0A, 0xF1, 0x78, 0x60, 0x2E, 0xE4, 0xFD, 0x7F, 0x02, 
+0x80, 0x1C, 0xD1, 0xC9, 0x90, 0x9F, 0xA2, 0xE0, 0xB4, 0x02, 0x17, 0xB1, 0x97, 0xD1, 0xFE, 0xBF, 
+0x01, 0x09, 0x90, 0x9F, 0xA9, 0xE0, 0xFF, 0x7D, 0x01, 0x80, 0x03, 0xE4, 0xFD, 0xFF, 0x11, 0x67, 
+0x80, 0x08, 0x90, 0x9F, 0xAA, 0xE0, 0x90, 0x9F, 0xA2, 0xF0, 0x90, 0x05, 0x40, 0x74, 0x22, 0xF0, 
+0x80, 0x29, 0x75, 0x54, 0x01, 0x91, 0x70, 0x90, 0x9F, 0xA2, 0xE0, 0xB4, 0x02, 0x06, 0x7D, 0x01, 
+0x7F, 0x04, 0x80, 0x0B, 0x90, 0x9F, 0xA2, 0xE0, 0xB4, 0x08, 0x06, 0x7D, 0x01, 0x7F, 0x0C, 0x11, 
+0x67, 0xD1, 0xEB, 0x90, 0x9F, 0xA9, 0x11, 0x5D, 0x12, 0xAA, 0x3F, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 
+0x90, 0x05, 0x27, 0xE5, 0x54, 0xF0, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x9F, 
+0xA1, 0xE0, 0x90, 0xA3, 0x2C, 0xF0, 0x6F, 0x70, 0x02, 0xA1, 0x83, 0xEF, 0x14, 0x60, 0x42, 0x14, 
+0x60, 0x6C, 0x14, 0x70, 0x02, 0xA1, 0x2C, 0x14, 0x70, 0x02, 0xA1, 0x57, 0x24, 0x04, 0x60, 0x02, 
+0xA1, 0x83, 0x90, 0xA3, 0x2C, 0xE0, 0xB4, 0x04, 0x04, 0xD1, 0xAF, 0xA1, 0x83, 0x90, 0xA3, 0x2C, 
+0xE0, 0xB4, 0x02, 0x04, 0xD1, 0xBA, 0xA1, 0x83, 0x90, 0xA3, 0x2C, 0xE0, 0xB4, 0x03, 0x04, 0xD1, 
+0xC5, 0xA1, 0x83, 0x90, 0xA3, 0x2C, 0xE0, 0x64, 0x01, 0x60, 0x02, 0xA1, 0x83, 0xD1, 0xB1, 0xA1, 
+0x83, 0x90, 0xA3, 0x2C, 0xE0, 0xB4, 0x04, 0x04, 0xD1, 0xA9, 0xA1, 0x83, 0x90, 0xA3, 0x2C, 0xE0, 
+0xB4, 0x02, 0x04, 0xD1, 0xBE, 0xA1, 0x83, 0x90, 0xA3, 0x2C, 0xE0, 0xB4, 0x03, 0x04, 0xD1, 0xA0, 
+0xA1, 0x83, 0x90, 0xA3, 0x2C, 0xE0, 0x60, 0x02, 0xA1, 0x83, 0xF1, 0xCE, 0xA1, 0x83, 0x90, 0xA3, 
+0x2C, 0xE0, 0xB4, 0x04, 0x05, 0x12, 0xAA, 0x5E, 0x80, 0x79, 0x90, 0xA3, 0x2C, 0xE0, 0xB4, 0x01, 
+0x05, 0x12, 0x4F, 0xED, 0x80, 0x6D, 0x90, 0xA3, 0x2C, 0xE0, 0xB4, 0x03, 0x05, 0x12, 0x4F, 0xFD, 
+0x80, 0x61, 0x90, 0xA3, 0x2C, 0xE0, 0x70, 0x5B, 0xF1, 0xD5, 0x80, 0x57, 0x90, 0xA3, 0x2C, 0xE0, 
+0xB4, 0x04, 0x04, 0xF1, 0x25, 0x80, 0x4C, 0x90, 0xA3, 0x2C, 0xE0, 0xB4, 0x01, 0x04, 0xF1, 0xDC, 
+0x80, 0x41, 0x90, 0xA3, 0x2C, 0xE0, 0xB4, 0x02, 0x04, 0xF1, 0xE5, 0x80, 0x36, 0x90, 0xA3, 0x2C, 
+0xE0, 0x70, 0x30, 0xF1, 0xDA, 0x80, 0x2C, 0x90, 0xA3, 0x2C, 0xE0, 0xB4, 0x03, 0x05, 0x12, 0xAA, 
+0x6E, 0x80, 0x20, 0x90, 0xA3, 0x2C, 0xE0, 0xB4, 0x01, 0x05, 0x12, 0x57, 0xF1, 0x80, 0x14, 0x90, 
+0xA3, 0x2C, 0xE0, 0xB4, 0x02, 0x05, 0x12, 0xAA, 0x66, 0x80, 0x08, 0x90, 0xA3, 0x2C, 0xE0, 0x70, 
+0x02, 0xF1, 0xD0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xF0, 0x7D, 0x04, 0x7F, 0x01, 0x41, 0x8B, 0x4E, 
+0xFF, 0xF0, 0x12, 0x06, 0x89, 0xFE, 0x22, 0xD1, 0x74, 0xB1, 0x89, 0xD1, 0xC9, 0x41, 0x45, 0x7E, 
+0x00, 0x7F, 0xA8, 0x7D, 0x00, 0x7B, 0x01, 0x7A, 0x9F, 0x79, 0xA3, 0x12, 0x08, 0xAA, 0x12, 0xAD, 
+0xBF, 0x12, 0x08, 0xAA, 0x90, 0x9F, 0xA6, 0x74, 0x02, 0xF0, 0x90, 0x9F, 0xAD, 0x14, 0xF0, 0xA3, 
+0xF0, 0xA3, 0x74, 0x08, 0xF0, 0x90, 0x9F, 0xB3, 0xE4, 0xF0, 0xA3, 0x74, 0x02, 0xF0, 0xF1, 0x35, 
+0xF0, 0xE4, 0xFD, 0xFF, 0x51, 0x8B, 0x7D, 0x0C, 0x7F, 0x02, 0x51, 0x8B, 0x51, 0x87, 0x90, 0x9E, 
+0x97, 0xE0, 0xB4, 0x01, 0x08, 0x90, 0x9F, 0xB2, 0x74, 0xFF, 0xF0, 0x80, 0x12, 0x90, 0x9E, 0x97, 
+0xE0, 0x90, 0x9F, 0xB2, 0xB4, 0x03, 0x05, 0x74, 0xD4, 0xF0, 0x80, 0x03, 0x74, 0x41, 0xF0, 0x12, 
+0x83, 0xA6, 0xF1, 0x35, 0xF0, 0x90, 0xA0, 0x56, 0xE0, 0x54, 0xFE, 0xF0, 0x90, 0x01, 0x38, 0xE0, 
+0x90, 0xA0, 0x57, 0xF0, 0x90, 0x01, 0x39, 0xE0, 0x90, 0xA0, 0x58, 0xF0, 0x90, 0x01, 0x3A, 0xE0, 
+0x90, 0xA0, 0x59, 0xF0, 0x90, 0x01, 0x3B, 0xE0, 0x90, 0xA0, 0x5A, 0xF0, 0x90, 0x01, 0x30, 0xE0, 
+0x90, 0xA0, 0x5B, 0xF0, 0x90, 0x01, 0x31, 0xE0, 0x90, 0xA0, 0x5C, 0xF0, 0x90, 0x01, 0x32, 0xE0, 
+0x90, 0xA0, 0x5D, 0xF0, 0x90, 0x01, 0x33, 0xE0, 0x90, 0xA0, 0x5E, 0xF0, 0x7F, 0x01, 0x12, 0xAB, 
+0xFD, 0x7E, 0x00, 0x7F, 0x02, 0x7D, 0x00, 0x7B, 0x01, 0x7A, 0xA0, 0x79, 0x4F, 0x12, 0x08, 0xAA, 
+0x12, 0xAF, 0x70, 0x12, 0xAF, 0x58, 0xD1, 0x74, 0xE4, 0x90, 0xA0, 0x51, 0xF0, 0x22, 0xE4, 0xFD, 
+0x7F, 0x0C, 0x11, 0x67, 0xE4, 0xFD, 0xFF, 0x02, 0x52, 0x45, 0x12, 0xAF, 0x70, 0xD1, 0x74, 0x7D, 
+0x0C, 0x7F, 0x01, 0x41, 0x8B, 0x90, 0x9F, 0xA7, 0xE0, 0x64, 0x01, 0x70, 0x12, 0x12, 0x67, 0xD6, 
+0x60, 0x05, 0xD1, 0x6E, 0x02, 0xAA, 0x73, 0x90, 0x9F, 0xAA, 0xE0, 0x70, 0x02, 0x11, 0x63, 0x22, 
+0xD1, 0x74, 0x90, 0x9F, 0xA1, 0x74, 0x01, 0xF0, 0x22, 0xD1, 0x74, 0xD1, 0xC9, 0x80, 0xF3, 0xD1, 
+0xA9, 0x12, 0xAA, 0xFA, 0xE4, 0x90, 0x9F, 0xA1, 0xF0, 0x22, 0xD1, 0xBE, 0x80, 0xF3, 0x12, 0x4C, 
+0x32, 0xD1, 0x74, 0x80, 0xDD, 0xD1, 0xA0, 0x80, 0xE8, 0x90, 0x05, 0x27, 0xE0, 0x44, 0x40, 0xF0, 
+0x22, 0x4D, 0xFF, 0x90, 0x9F, 0x9E, 0xF0, 0xEE, 0x22, 0x90, 0x9F, 0x9E, 0xE0, 0xFF, 0x13, 0x13, 
+0x13, 0x22, 0x90, 0x9F, 0x9E, 0xE0, 0x13, 0x13, 0x54, 0x3F, 0x22, 0xF1, 0x97, 0xEF, 0x70, 0x02, 
+0xD1, 0x85, 0x22, 0x90, 0x9F, 0x9E, 0xE0, 0xFF, 0xC4, 0x13, 0x13, 0x54, 0x03, 0x22, 0x90, 0x05, 
+0x43, 0xE0, 0x7F, 0x00, 0x30, 0xE7, 0x02, 0x7F, 0x01, 0x22, 0xAE, 0x07, 0xD1, 0xFE, 0xBF, 0x01, 
+0x11, 0x90, 0x9F, 0x9E, 0xF1, 0xEA, 0x20, 0xE0, 0x09, 0xAF, 0x06, 0x7D, 0x01, 0x11, 0x67, 0x7F, 
+0x01, 0x22, 0x7F, 0x00, 0x22, 0x7D, 0x22, 0x7F, 0xFF, 0x12, 0x52, 0x45, 0xD1, 0xC9, 0x90, 0x9F, 
+0xA1, 0x74, 0x03, 0xF0, 0x22, 0x90, 0x9F, 0xDD, 0xE0, 0x24, 0x04, 0x90, 0x9F, 0xBF, 0xF0, 0xA3, 
+0x74, 0x08, 0x22, 0x12, 0x4C, 0x32, 0xD1, 0x74, 0x51, 0x87, 0x90, 0x9F, 0xA2, 0x74, 0x0C, 0xF0, 
+0x22, 0x12, 0xAA, 0x73, 0x90, 0x9F, 0xAA, 0xE0, 0x64, 0x0C, 0x60, 0x05, 0xD1, 0x6E, 0x12, 0x57, 
+0x65, 0x22, 0xD1, 0xF3, 0x30, 0xE0, 0x0A, 0xF1, 0x78, 0x60, 0x06, 0x7D, 0x01, 0x7F, 0x02, 0x11, 
+0x67, 0xF1, 0x78, 0x60, 0x02, 0xF1, 0x7F, 0x22, 0x90, 0x9F, 0xA2, 0xE0, 0x64, 0x02, 0x22, 0x90, 
+0x9F, 0xA7, 0xE0, 0x64, 0x02, 0x60, 0x0F, 0x12, 0x67, 0xD6, 0x60, 0x0A, 0xF1, 0x97, 0xEF, 0x70, 
+0x05, 0xFD, 0x7F, 0x0C, 0x11, 0x67, 0x22, 0x90, 0x04, 0x1A, 0xE0, 0xF4, 0x60, 0x03, 0x7F, 0x00, 
+0x22, 0x90, 0x04, 0x1B, 0xE0, 0x54, 0x07, 0x64, 0x07, 0x7F, 0x01, 0x60, 0x02, 0x7F, 0x00, 0x22, 
+0x90, 0x9F, 0xA7, 0xE0, 0x70, 0x07, 0x90, 0x9F, 0x9E, 0xE0, 0x30, 0xE0, 0x10, 0x90, 0x9F, 0x9E, 
+0xE0, 0x30, 0xE0, 0x07, 0xD1, 0xFE, 0xBF, 0x01, 0x04, 0x80, 0xB4, 0xD1, 0x85, 0x22, 0xC1, 0xA2, 
+0xF1, 0xCE, 0x02, 0x57, 0xF1, 0xF1, 0xCE, 0x02, 0x4F, 0xED, 0xF1, 0xCE, 0x7D, 0x21, 0x7F, 0xFF, 
+0x12, 0x52, 0x45, 0xE1, 0x2E, 0x12, 0x4C, 0x32, 0xE1, 0x2E, 0xE0, 0xC4, 0x13, 0x13, 0x54, 0x03, 
+0x22, 0x7F, 0xF4, 0x12, 0x4B, 0xFC, 0xEF, 0x20, 0xE5, 0x0E, 0x7F, 0xF4, 0x12, 0x4B, 0xFC, 0xEF, 
+0x7F, 0x01, 0x20, 0xE4, 0x05, 0x7F, 0x02, 0x22, 0x7F, 0x03, 0x22, 0x12, 0x5F, 0xF1, 0x90, 0x9E, 
+0x97, 0xEF, 0xF0, 0x12, 0x4F, 0xB0, 0x90, 0x01, 0x64, 0x74, 0x01, 0xF0, 0x90, 0x04, 0x23, 0xE0, 
+0x44, 0x80, 0xF0, 0x02, 0x36, 0x83, 0x75, 0xE8, 0x03, 0x75, 0xA8, 0x85, 0x22, 0xE4, 0xFB, 0xFA, 
+0xFD, 0x7F, 0x01, 0x12, 0x48, 0x0E, 0x90, 0xA1, 0x3E, 0xEF, 0xF0, 0x60, 0xF0, 0x90, 0x9E, 0x92, 
+0xE0, 0xFF, 0x70, 0x04, 0xA3, 0xE0, 0x60, 0xE5, 0xC2, 0xAF, 0xEF, 0x30, 0xE0, 0x0E, 0x90, 0x9E, 
+0x92, 0xE0, 0x54, 0xFE, 0xF0, 0xE4, 0xFF, 0x12, 0x85, 0xD5, 0x11, 0x78, 0x12, 0xAE, 0xEC, 0x30, 
+0xE1, 0x06, 0x54, 0xFD, 0xF0, 0x12, 0x84, 0x8A, 0x12, 0xAE, 0xEC, 0x30, 0xE2, 0x06, 0x54, 0xFB, 
+0xF0, 0x12, 0x7A, 0x30, 0xD2, 0xAF, 0x80, 0xC5, 0xE4, 0xF5, 0x51, 0x90, 0x9F, 0x9C, 0xE0, 0xFF, 
+0xE5, 0x51, 0xC3, 0x9F, 0x40, 0x02, 0xA1, 0xFE, 0xAF, 0x51, 0x12, 0x72, 0xA6, 0xEF, 0x70, 0x02, 
+0xA1, 0xFA, 0x12, 0x4D, 0xF7, 0x12, 0x4F, 0x52, 0x30, 0xE0, 0x02, 0xA1, 0xFA, 0x12, 0xAE, 0x48, 
+0x70, 0x07, 0xE5, 0x51, 0x6E, 0x70, 0x02, 0x80, 0x0A, 0x12, 0xAE, 0x48, 0x70, 0x2D, 0xE5, 0x51, 
+0x6E, 0x70, 0x28, 0xA3, 0xE0, 0xF5, 0x52, 0xA3, 0xE0, 0x90, 0xA1, 0x4E, 0x12, 0x6D, 0x3D, 0xE5, 
+0x52, 0xF0, 0x75, 0xF0, 0x10, 0x12, 0xAD, 0x36, 0xE0, 0x54, 0xFC, 0xFF, 0x90, 0xA1, 0x4E, 0xE0, 
+0x12, 0xAF, 0xC4, 0xE5, 0x51, 0x12, 0xAD, 0x36, 0xEF, 0xF0, 0x22, 0x12, 0xAD, 0x92, 0xFE, 0xA3, 
+0xE0, 0xD3, 0x94, 0x00, 0xEE, 0x94, 0x00, 0x50, 0x02, 0xA1, 0xFA, 0xE5, 0x51, 0x75, 0xF0, 0x0A, 
+0xA4, 0x24, 0x01, 0xF9, 0x74, 0x8D, 0x35, 0xF0, 0xFA, 0x7B, 0x01, 0x90, 0xA1, 0x42, 0x12, 0x49, 
+0x69, 0x12, 0xAD, 0x92, 0xF5, 0x56, 0xA3, 0xE0, 0xF5, 0x57, 0x74, 0x91, 0x25, 0x51, 0x12, 0x87, 
+0xC0, 0xE0, 0xFF, 0x90, 0xA1, 0x45, 0xE4, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0x00, 0x02, 0x12, 0x07, 
+0xAB, 0xFF, 0xAE, 0xF0, 0x12, 0x07, 0x80, 0x2F, 0xFF, 0xE5, 0xF0, 0x3E, 0xFE, 0x90, 0x00, 0x04, 
+0xF1, 0xAF, 0x35, 0xF0, 0xFE, 0x90, 0x00, 0x06, 0xF1, 0xAF, 0x35, 0xF0, 0xFE, 0xD1, 0x19, 0x2F, 
+0xFF, 0xEE, 0x35, 0xF0, 0x90, 0xA1, 0x47, 0xF0, 0xA3, 0xEF, 0xF0, 0x12, 0x07, 0x80, 0xFF, 0xC3, 
+0x90, 0xA1, 0x48, 0xE0, 0x9F, 0xFE, 0x90, 0xA1, 0x47, 0xE0, 0x95, 0xF0, 0x90, 0xA1, 0x49, 0xF0, 
+0xA3, 0xCE, 0xF0, 0x90, 0x00, 0x06, 0x12, 0x07, 0xAB, 0xFD, 0xAC, 0xF0, 0x25, 0xE0, 0xFF, 0xEC, 
+0x33, 0xFE, 0xEF, 0x2D, 0xFD, 0xEE, 0x3C, 0xFC, 0x90, 0x00, 0x04, 0x12, 0x07, 0xAB, 0x25, 0xE0, 
+0xFF, 0xE5, 0xF0, 0x33, 0xFE, 0x90, 0x00, 0x02, 0xF1, 0xAF, 0x35, 0xF0, 0xCF, 0x2D, 0xFD, 0xEF, 
+0x3C, 0xFC, 0x90, 0xA1, 0x42, 0x12, 0x49, 0x60, 0xD1, 0x19, 0xAE, 0xF0, 0x78, 0x02, 0xC3, 0x33, 
+0xCE, 0x33, 0xCE, 0xD8, 0xF9, 0x2D, 0xFF, 0xEC, 0x3E, 0x90, 0xA1, 0x4B, 0xF0, 0xA3, 0xEF, 0x12, 
+0x6D, 0x3D, 0xE0, 0xF5, 0x52, 0x54, 0x7F, 0xF5, 0x53, 0x75, 0xF0, 0x04, 0xE5, 0x51, 0x12, 0x6F, 
+0xD0, 0xE0, 0x90, 0xA1, 0x4D, 0xF0, 0x12, 0x4D, 0xF7, 0xFF, 0x13, 0x13, 0x54, 0x03, 0x90, 0xA1, 
+0x4E, 0xF0, 0xD1, 0x01, 0xE0, 0xC3, 0x94, 0x05, 0x40, 0x02, 0x81, 0x22, 0x90, 0xA1, 0x4D, 0xE0, 
+0xFF, 0xE5, 0x53, 0x9F, 0x40, 0x08, 0x8F, 0x53, 0x53, 0x52, 0x80, 0xEF, 0x42, 0x52, 0xE5, 0x53, 
+0x90, 0x41, 0xFB, 0x93, 0xD1, 0x37, 0xE0, 0xC3, 0x9F, 0xE5, 0x53, 0x40, 0x05, 0x90, 0x41, 0x53, 
+0x80, 0x03, 0x90, 0x41, 0xA7, 0x93, 0xF5, 0x58, 0xE5, 0x58, 0x75, 0xF0, 0x06, 0xA4, 0x24, 0xB1, 
+0xF9, 0x74, 0x40, 0x35, 0xF0, 0xFA, 0x7B, 0xFF, 0x90, 0xA1, 0x3F, 0x12, 0x49, 0x69, 0xC3, 0xE5, 
+0x57, 0x94, 0x0F, 0xE5, 0x56, 0x94, 0x00, 0x50, 0x60, 0x90, 0xA1, 0x42, 0x12, 0x49, 0x60, 0x90, 
+0x00, 0x06, 0x12, 0x07, 0xAB, 0xFF, 0xAE, 0xF0, 0xD1, 0x19, 0x2F, 0xFD, 0xE5, 0xF0, 0x3E, 0xFC, 
+0x12, 0xAE, 0xD9, 0xD3, 0xED, 0x9F, 0xEC, 0x9E, 0x40, 0x09, 0x7D, 0x01, 0xAF, 0x51, 0x12, 0x93, 
+0xF2, 0x81, 0x03, 0xE5, 0x57, 0xAE, 0x56, 0x78, 0x02, 0xCE, 0xC3, 0x13, 0xCE, 0x13, 0xD8, 0xF9, 
+0xFD, 0xAC, 0x06, 0xE5, 0x56, 0xC3, 0x13, 0xFE, 0xE5, 0x57, 0x13, 0x2D, 0xFF, 0xEE, 0x3C, 0xFE, 
+0x90, 0xA1, 0x42, 0x12, 0x49, 0x60, 0x12, 0x07, 0x80, 0xD3, 0x9F, 0xE5, 0xF0, 0x9E, 0x50, 0x02, 
+0x81, 0x03, 0xAF, 0x51, 0x12, 0x98, 0xD6, 0x81, 0x03, 0xE5, 0x51, 0x70, 0x46, 0x90, 0xA1, 0x42, 
+0x12, 0x49, 0x60, 0xD1, 0x19, 0xFD, 0xAC, 0xF0, 0x12, 0xAE, 0xD9, 0xC3, 0xED, 0x9F, 0xEC, 0x9E, 
+0x50, 0x08, 0x90, 0x9E, 0x91, 0x74, 0x01, 0xF0, 0x80, 0x29, 0xE5, 0x57, 0xAE, 0x56, 0x78, 0x03, 
+0xCE, 0xC3, 0x13, 0xCE, 0x13, 0xD8, 0xF9, 0xFB, 0xAA, 0x06, 0xE5, 0x56, 0xC3, 0x13, 0xFE, 0xE5, 
+0x57, 0x13, 0x2B, 0xFF, 0xEE, 0x3A, 0xFE, 0xD3, 0xED, 0x9F, 0xEC, 0x9E, 0x40, 0x05, 0xE4, 0x90, 
+0x9E, 0x91, 0xF0, 0x12, 0xAE, 0xBB, 0x40, 0x05, 0x75, 0x59, 0x05, 0x80, 0x13, 0xD3, 0xE5, 0x57, 
+0x94, 0xC8, 0xE5, 0x56, 0x94, 0x00, 0x40, 0x05, 0x75, 0x59, 0x02, 0x80, 0x03, 0xE4, 0xF5, 0x59, 
+0xE5, 0x51, 0xF1, 0xB6, 0xE0, 0xF5, 0x54, 0xA3, 0xE0, 0xF5, 0x55, 0xE4, 0xF5, 0x5C, 0x12, 0xAE, 
+0xB1, 0xE5, 0x5C, 0x12, 0x9C, 0xFA, 0x12, 0xAE, 0xFF, 0x80, 0x05, 0xCE, 0xC3, 0x13, 0xCE, 0x13, 
+0xD8, 0xF9, 0xFF, 0x90, 0xA1, 0x3F, 0x12, 0x49, 0x60, 0x85, 0x5C, 0x82, 0xF1, 0xE5, 0x12, 0xAD, 
+0x81, 0x05, 0x5C, 0xE5, 0x5C, 0xB4, 0x05, 0xD6, 0x90, 0xA1, 0x3F, 0x12, 0x49, 0x60, 0x90, 0x00, 
+0x05, 0x12, 0x06, 0xA2, 0xFD, 0x7C, 0x00, 0xF1, 0xDD, 0x80, 0x05, 0xCE, 0xC3, 0x13, 0xCE, 0x13, 
+0xD8, 0xF9, 0xFF, 0x12, 0x07, 0x03, 0xD3, 0xE5, 0x55, 0x9F, 0xE5, 0x54, 0x9E, 0x40, 0x0C, 0xE5, 
+0x55, 0x9F, 0xF5, 0x55, 0xE5, 0x54, 0x9E, 0xF5, 0x54, 0x80, 0x05, 0xE4, 0xF5, 0x54, 0xF5, 0x55, 
+0xE5, 0x51, 0xF1, 0xB6, 0xE5, 0x54, 0xF0, 0xA3, 0xE5, 0x55, 0xF0, 0x12, 0x9B, 0xED, 0xC3, 0x12, 
+0xAE, 0xCF, 0x50, 0x07, 0xAF, 0x51, 0x12, 0x98, 0xD6, 0x80, 0x55, 0x12, 0x95, 0x9A, 0xF5, 0x83, 
+0xD3, 0x12, 0xAE, 0xCF, 0x40, 0x50, 0x74, 0x91, 0x25, 0x51, 0xD1, 0xE5, 0xE0, 0x20, 0xE6, 0x03, 
+0x30, 0xE1, 0x07, 0xE4, 0x90, 0xA1, 0x4F, 0xF0, 0x80, 0x06, 0x90, 0xA1, 0x4F, 0x74, 0x01, 0xF0, 
+0xE5, 0x53, 0xB4, 0x3A, 0x0B, 0x90, 0xA1, 0x4F, 0xE0, 0xB4, 0x01, 0x04, 0x7D, 0x08, 0x80, 0x1B, 
+0xE5, 0x53, 0xB4, 0x18, 0x0B, 0x90, 0xA1, 0x4F, 0xE0, 0xB4, 0x01, 0x04, 0x7D, 0x07, 0x80, 0x0B, 
+0xE5, 0x53, 0xB4, 0x36, 0x04, 0x7D, 0x09, 0x80, 0x02, 0x7D, 0x01, 0xAF, 0x51, 0x12, 0x93, 0xF2, 
+0xD1, 0x2B, 0xE4, 0xF0, 0x80, 0x2D, 0xD1, 0x2B, 0xE0, 0x04, 0xF0, 0xD1, 0x2B, 0xE0, 0xC3, 0x94, 
+0x05, 0x40, 0x20, 0xD1, 0x2B, 0xE4, 0xF0, 0x12, 0x95, 0x9A, 0x12, 0x96, 0x04, 0x12, 0x9B, 0xED, 
+0x74, 0x01, 0x93, 0x2F, 0xFF, 0xE4, 0x93, 0x3E, 0xC3, 0x13, 0xFE, 0xEF, 0x13, 0xFF, 0xE5, 0x51, 
+0x12, 0x95, 0xA6, 0xE5, 0x51, 0xF1, 0xB6, 0xA3, 0xE0, 0x90, 0xA2, 0x8C, 0xF0, 0x90, 0xA2, 0x8B, 
+0xE5, 0x52, 0xF0, 0xAB, 0x51, 0xE4, 0xFD, 0xFF, 0x12, 0x7B, 0xB3, 0xE4, 0xF5, 0x54, 0xF5, 0x55, 
+0xA1, 0xDE, 0xD1, 0x01, 0xE0, 0xFC, 0x64, 0x05, 0x60, 0x02, 0x81, 0xE6, 0xAD, 0x53, 0xAF, 0x51, 
+0x12, 0x98, 0x08, 0x12, 0xAE, 0x3C, 0xEF, 0xD1, 0x1F, 0xE0, 0x54, 0x07, 0xF5, 0x5B, 0xD1, 0x38, 
+0xE0, 0xFF, 0xC3, 0x94, 0x30, 0x50, 0x06, 0xE4, 0xB1, 0xFF, 0xE4, 0x80, 0x55, 0x12, 0xAE, 0x3C, 
+0xE0, 0x64, 0x01, 0x70, 0x64, 0xF1, 0xC2, 0xE0, 0x64, 0x0A, 0x60, 0x28, 0xEF, 0x24, 0x05, 0xFF, 
+0xE4, 0x33, 0xFE, 0x12, 0xAE, 0x30, 0xE0, 0xFD, 0x12, 0xAE, 0xC5, 0x50, 0x17, 0xED, 0x24, 0x05, 
+0xFF, 0xE4, 0x33, 0xFE, 0xD1, 0x38, 0xE0, 0x12, 0xAE, 0xC5, 0x50, 0x08, 0x12, 0xAD, 0x57, 0xE0, 
+0x65, 0x53, 0x60, 0x2A, 0xE5, 0x5B, 0x70, 0x05, 0x75, 0x5B, 0x01, 0x80, 0x0D, 0xE5, 0x5B, 0xB4, 
+0x01, 0x05, 0x75, 0x5B, 0x03, 0x80, 0x03, 0x75, 0x5B, 0x05, 0xD1, 0x38, 0xE0, 0xFF, 0x12, 0xAE, 
+0x30, 0xEF, 0xF0, 0x74, 0x11, 0x25, 0x51, 0xF5, 0x82, 0xE4, 0x34, 0x9B, 0x80, 0x17, 0xD1, 0x01, 
+0xE4, 0xF0, 0xF1, 0xC2, 0xE0, 0x04, 0xF0, 0x80, 0x10, 0xE4, 0xF5, 0x5B, 0x74, 0x11, 0x25, 0x51, 
+0xF5, 0x82, 0xE4, 0x34, 0x9C, 0xF5, 0x83, 0xE4, 0xF0, 0x12, 0xAD, 0x57, 0xE5, 0x53, 0xF0, 0x12, 
+0x4D, 0xF7, 0xC4, 0x13, 0x13, 0x54, 0x03, 0x20, 0xE0, 0x02, 0xA1, 0xCE, 0xF1, 0xC2, 0xE4, 0xF0, 
+0xB1, 0xFF, 0xE4, 0xF0, 0xA1, 0xCE, 0xEC, 0x64, 0x06, 0x60, 0x02, 0xA1, 0xDE, 0xF5, 0x54, 0xF5, 
+0x55, 0xD1, 0x20, 0xE0, 0x54, 0x07, 0xF5, 0x5B, 0x12, 0xAE, 0xBB, 0x40, 0x05, 0x75, 0x59, 0x05, 
+0x80, 0x13, 0xD3, 0xE5, 0x57, 0x94, 0xFA, 0xE5, 0x56, 0x94, 0x00, 0x40, 0x05, 0x75, 0x59, 0x02, 
+0x80, 0x03, 0xE4, 0xF5, 0x59, 0xF1, 0xDD, 0x80, 0x05, 0xCE, 0xC3, 0x13, 0xCE, 0x13, 0xD8, 0xF9, 
+0xFF, 0x90, 0x44, 0x58, 0xE4, 0x93, 0xFD, 0x7C, 0x00, 0x12, 0x07, 0x03, 0x90, 0xA1, 0x50, 0xEE, 
+0xF0, 0xA3, 0xEF, 0xF0, 0xE4, 0xF5, 0x5A, 0x12, 0xAE, 0xB1, 0xE5, 0x5A, 0x12, 0x9C, 0xFA, 0x12, 
+0xAE, 0xFF, 0x80, 0x05, 0xCE, 0xC3, 0x13, 0xCE, 0x13, 0xD8, 0xF9, 0xFF, 0xE5, 0x5A, 0x90, 0x44, 
+0x53, 0x93, 0x12, 0xAD, 0x81, 0xC3, 0x90, 0xA1, 0x51, 0xE0, 0x95, 0x55, 0x90, 0xA1, 0x50, 0xE0, 
+0x95, 0x54, 0x40, 0x07, 0x05, 0x5A, 0xE5, 0x5A, 0xB4, 0x05, 0xCC, 0xE5, 0x5A, 0xC3, 0x13, 0xF5, 
+0x5A, 0xE5, 0x5B, 0x24, 0x01, 0xFF, 0xE4, 0x33, 0xA2, 0xE7, 0x13, 0xEF, 0x13, 0xFF, 0xD3, 0x95, 
+0x5A, 0x40, 0x06, 0xEF, 0x95, 0x5A, 0xFF, 0x80, 0x02, 0xE4, 0xFF, 0xD1, 0x0D, 0xE0, 0xC3, 0x13, 
+0xFE, 0xEF, 0xC4, 0x33, 0x54, 0xE0, 0x2E, 0x04, 0xFE, 0xD1, 0x0D, 0xEE, 0xF0, 0xD1, 0x0D, 0xE0, 
+0xC3, 0x94, 0xC0, 0x40, 0x05, 0xD1, 0x0D, 0x74, 0xC0, 0xF0, 0xD1, 0x0D, 0x12, 0x5F, 0xEA, 0x25, 
+0xE0, 0xFF, 0x70, 0x04, 0xF5, 0x5B, 0x80, 0x04, 0xEF, 0x14, 0xF5, 0x5B, 0xD3, 0x90, 0xA1, 0x46, 
+0xE0, 0x94, 0x03, 0x90, 0xA1, 0x45, 0xE0, 0x94, 0x00, 0x40, 0x03, 0xE4, 0xF5, 0x5B, 0xD1, 0x20, 
+0xE0, 0x54, 0xF8, 0x90, 0xA1, 0x52, 0xF0, 0x45, 0x5B, 0xFF, 0xD1, 0x1F, 0xEF, 0xF0, 0xD1, 0x01, 
+0xE0, 0xD3, 0x94, 0x05, 0x74, 0x11, 0x50, 0x07, 0xD1, 0x03, 0xE0, 0x04, 0xF0, 0x80, 0x04, 0xD1, 
+0x03, 0xE4, 0xF0, 0xE4, 0xFD, 0xAF, 0x51, 0x12, 0x87, 0x32, 0x05, 0x51, 0x01, 0x7B, 0x22, 0xF5, 
+0x5B, 0x74, 0x11, 0x25, 0x51, 0xF5, 0x82, 0xE4, 0x34, 0x9C, 0xF5, 0x83, 0x22, 0x74, 0x01, 0x25, 
+0x51, 0xF5, 0x82, 0xE4, 0x34, 0x93, 0xF5, 0x83, 0x22, 0x90, 0x00, 0x08, 0x02, 0x07, 0xAB, 0xF0, 
+0x75, 0xF0, 0x10, 0xE5, 0x51, 0x90, 0x81, 0x01, 0x02, 0x49, 0x54, 0x74, 0x11, 0x25, 0x51, 0xF5, 
+0x82, 0xE4, 0x34, 0x98, 0xF5, 0x83, 0x22, 0xFF, 0x74, 0x11, 0x25, 0x51, 0xF5, 0x82, 0xE4, 0x34, 
+0x9A, 0xF5, 0x83, 0x22, 0xF1, 0xEB, 0xF5, 0x51, 0x24, 0x91, 0xD1, 0xE5, 0xE0, 0x54, 0x9C, 0xF0, 
+0x74, 0x91, 0x25, 0x51, 0xD1, 0xE5, 0xC0, 0x83, 0xC0, 0x82, 0xD1, 0xED, 0x12, 0x57, 0x1B, 0x54, 
+0x01, 0xFE, 0xEF, 0x4E, 0xD0, 0x82, 0xD0, 0x83, 0xF0, 0x74, 0x91, 0x25, 0x51, 0xD1, 0xE5, 0xC0, 
+0x83, 0xC0, 0x82, 0xD1, 0xED, 0x12, 0x57, 0x1B, 0x54, 0x02, 0xFE, 0xEF, 0x4E, 0xD0, 0x82, 0xD0, 
+0x83, 0xF0, 0x74, 0x91, 0x25, 0x51, 0xD1, 0xE5, 0xC0, 0x83, 0xC0, 0x82, 0xD1, 0xED, 0x12, 0x57, 
+0x1B, 0x54, 0x40, 0xFE, 0xEF, 0x4E, 0xD0, 0x82, 0xD0, 0x83, 0xF0, 0x74, 0x91, 0x25, 0x51, 0xD1, 
+0xE5, 0xC0, 0x83, 0xC0, 0x82, 0xD1, 0xED, 0x12, 0x57, 0x1B, 0x54, 0x20, 0xFE, 0xEF, 0x4E, 0xD0, 
+0x82, 0xD0, 0x83, 0xF0, 0xE5, 0x51, 0xC3, 0x94, 0x80, 0x50, 0x07, 0x12, 0x4F, 0x49, 0xD1, 0x37, 
+0xEF, 0xF0, 0x74, 0x91, 0x25, 0x51, 0xD1, 0xE5, 0xE0, 0x30, 0xE5, 0x11, 0x12, 0x4D, 0xF7, 0x13, 
+0x13, 0x54, 0x03, 0xFB, 0xD1, 0x38, 0xE0, 0xFD, 0xAF, 0x51, 0x12, 0x98, 0x70, 0x22, 0xE4, 0xF5, 
+0x63, 0x74, 0x91, 0x25, 0x5D, 0xF5, 0x82, 0xE4, 0x34, 0x99, 0xF5, 0x83, 0x22, 0xE0, 0xFF, 0x90, 
+0xA1, 0x43, 0x02, 0x49, 0x60, 0xF1, 0xEB, 0xFF, 0x54, 0x7F, 0x90, 0x9F, 0xA7, 0xF0, 0xEF, 0x12, 
+0x4F, 0x52, 0xA3, 0xF0, 0x12, 0x74, 0x1C, 0xFF, 0x54, 0xF0, 0xC4, 0x54, 0x0F, 0xFE, 0x90, 0x9F, 
+0xA5, 0xE0, 0x54, 0xF0, 0x4E, 0x12, 0x57, 0x1A, 0x54, 0x01, 0x25, 0xE0, 0xFE, 0x90, 0x9F, 0xA3, 
+0xE0, 0x54, 0xFD, 0x4E, 0xF0, 0xEF, 0x54, 0x0F, 0xC4, 0x54, 0xF0, 0xFF, 0xF1, 0xD6, 0x12, 0x4F, 
+0x47, 0x90, 0x9F, 0xA6, 0xF1, 0xCE, 0x30, 0xE0, 0x52, 0xC3, 0x13, 0x54, 0x07, 0xFF, 0xC3, 0x94, 
+0x04, 0x90, 0x9F, 0xBA, 0x50, 0x04, 0xEF, 0xF0, 0x80, 0x2A, 0x74, 0x03, 0xF0, 0xD1, 0xEF, 0xE9, 
+0x24, 0x06, 0xF9, 0xE4, 0x3A, 0xFA, 0x12, 0x06, 0x89, 0xFF, 0x74, 0x03, 0x24, 0xFD, 0xFE, 0xEF, 
+0xC4, 0x54, 0x0F, 0xFD, 0xEF, 0x54, 0x0F, 0xFF, 0xED, 0x2E, 0x54, 0x0F, 0xFE, 0xC4, 0x54, 0xF0, 
+0x4F, 0x12, 0x06, 0xCF, 0xD1, 0xEF, 0xF1, 0xCF, 0xC4, 0x54, 0x0F, 0xFF, 0xC3, 0x94, 0x04, 0x90, 
+0x9F, 0xAF, 0x50, 0x05, 0x74, 0x04, 0xF0, 0x80, 0x02, 0xEF, 0xF0, 0xD1, 0xEF, 0x90, 0x00, 0x04, 
+0x12, 0x06, 0xA2, 0xFD, 0x7F, 0x02, 0x12, 0x5A, 0x8B, 0xD1, 0xEF, 0x12, 0x73, 0xEE, 0x12, 0x8E, 
+0xD7, 0xF0, 0x90, 0x9F, 0xA7, 0x12, 0xAD, 0xCC, 0xF1, 0xD5, 0x90, 0x01, 0xBE, 0xF0, 0x22, 0x12, 
+0x07, 0xAB, 0x2F, 0xFF, 0xEE, 0x22, 0x25, 0xE0, 0x24, 0x91, 0xF5, 0x82, 0xE4, 0x34, 0x94, 0xF5, 
+0x83, 0x22, 0x74, 0x11, 0x25, 0x51, 0xF5, 0x82, 0xE4, 0x34, 0x9B, 0xF5, 0x83, 0x22, 0xF0, 0x90, 
+0x00, 0x06, 0x02, 0x06, 0xA2, 0xF0, 0x90, 0x9F, 0xA5, 0xE0, 0x54, 0x0F, 0x22, 0xE5, 0x57, 0xAE, 
+0x56, 0xA8, 0x59, 0x08, 0x22, 0x75, 0x83, 0x00, 0x02, 0x06, 0xA2, 0x90, 0xA1, 0x43, 0x12, 0x49, 
+0x69, 0x02, 0x06, 0x89, 0x32, 0xC0, 0xE0, 0xC0, 0xF0, 0xC0, 0x83, 0xC0, 0x82, 0xC0, 0xD0, 0x75, 
+0xD0, 0x00, 0xC0, 0x00, 0xC0, 0x01, 0xC0, 0x02, 0xC0, 0x03, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 
+0xC0, 0x07, 0x12, 0x4C, 0x96, 0xE5, 0x14, 0x30, 0xE7, 0x03, 0x12, 0x4F, 0x7A, 0xD0, 0x07, 0xD0, 
+0x06, 0xD0, 0x05, 0xD0, 0x04, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 
+0x82, 0xD0, 0x83, 0xD0, 0xF0, 0xD0, 0xE0, 0x32, 0xC0, 0xE0, 0xC0, 0xF0, 0xC0, 0x83, 0xC0, 0x82, 
+0xC0, 0xD0, 0x75, 0xD0, 0x00, 0xC0, 0x00, 0xC0, 0x01, 0xC0, 0x02, 0xC0, 0x03, 0xC0, 0x04, 0xC0, 
+0x05, 0xC0, 0x06, 0xC0, 0x07, 0x12, 0x8A, 0x7E, 0xE5, 0x19, 0x30, 0xE1, 0x03, 0x12, 0x88, 0x5C, 
+0xE5, 0x19, 0x30, 0xE4, 0x02, 0xF1, 0xE4, 0xE5, 0x19, 0x30, 0xE5, 0x03, 0x12, 0x8A, 0xDB, 0xE5, 
+0x19, 0x30, 0xE6, 0x03, 0x12, 0x8B, 0x17, 0xE5, 0x1B, 0x30, 0xE0, 0x03, 0x12, 0x8B, 0x24, 0xE5, 
+0x1B, 0x30, 0xE1, 0x03, 0x12, 0x72, 0x25, 0xE5, 0x1B, 0x30, 0xE2, 0x03, 0x12, 0x8F, 0x92, 0xE5, 
+0x1B, 0x30, 0xE3, 0x03, 0x12, 0x8C, 0x68, 0xE5, 0x1B, 0x30, 0xE4, 0x03, 0x12, 0x8C, 0x7A, 0xE5, 
+0x1B, 0x30, 0xE5, 0x03, 0x12, 0x8F, 0xBB, 0xE5, 0x1B, 0x30, 0xE6, 0x03, 0x12, 0x8F, 0xD7, 0xE5, 
+0x1C, 0x30, 0xE1, 0x03, 0x12, 0x5F, 0xB0, 0xE5, 0x1C, 0x30, 0xE4, 0x03, 0x12, 0x87, 0xC8, 0xE5, 
+0x1C, 0x30, 0xE5, 0x02, 0x11, 0xE9, 0xE5, 0x1C, 0x30, 0xE6, 0x03, 0x12, 0x92, 0xA3, 0xD0, 0x07, 
+0xD0, 0x06, 0xD0, 0x05, 0xD0, 0x04, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0xD0, 0xD0, 
+0xD0, 0x82, 0xD0, 0x83, 0xD0, 0xF0, 0xD0, 0xE0, 0x32, 0xE4, 0xF5, 0x64, 0x90, 0x9F, 0x9C, 0xE0, 
+0xFF, 0xE5, 0x64, 0xC3, 0x9F, 0x40, 0x02, 0x21, 0xA1, 0xAF, 0x64, 0x12, 0x72, 0xA6, 0xEF, 0x70, 
+0x02, 0x21, 0x9D, 0xE5, 0x64, 0x13, 0x13, 0x13, 0x54, 0x1F, 0xFF, 0xE5, 0x64, 0x54, 0x07, 0xFE, 
+0x74, 0x81, 0x2F, 0xF1, 0xC3, 0xE0, 0xFD, 0xAF, 0x06, 0x12, 0x85, 0xCD, 0x80, 0x05, 0xC3, 0x33, 
+0xCE, 0x33, 0xCE, 0xD8, 0xF9, 0xFF, 0xEF, 0x5D, 0x60, 0x73, 0x75, 0xF0, 0x10, 0xE5, 0x64, 0x12, 
+0x66, 0x25, 0xE0, 0x20, 0xE7, 0x02, 0x80, 0x10, 0x75, 0xF0, 0x10, 0xE5, 0x64, 0x90, 0x81, 0x02, 
+0x12, 0x49, 0x54, 0xE0, 0xFF, 0x20, 0xE7, 0x09, 0x90, 0x01, 0xC1, 0xE0, 0x44, 0x20, 0xF0, 0x80, 
+0x4C, 0xEF, 0x30, 0xE6, 0x17, 0x75, 0xF0, 0x10, 0xE5, 0x64, 0xB1, 0x43, 0xE0, 0xFD, 0x75, 0xF0, 
+0x04, 0xE5, 0x64, 0x12, 0x4D, 0xFC, 0x31, 0xAE, 0xE4, 0xFB, 0x80, 0x2D, 0x31, 0xA2, 0xE0, 0x04, 
+0xF0, 0x31, 0xA2, 0xE0, 0xD3, 0x94, 0x01, 0x40, 0x0B, 0xAF, 0x64, 0x12, 0x93, 0xB1, 0x31, 0xA2, 
+0xE4, 0xF0, 0x80, 0x19, 0x75, 0xF0, 0x10, 0xE5, 0x64, 0xB1, 0x43, 0xE0, 0xFD, 0x75, 0xF0, 0x04, 
+0xE5, 0x64, 0x12, 0x4D, 0xFC, 0x31, 0xAE, 0x7B, 0x01, 0xAF, 0x64, 0xD1, 0x72, 0x05, 0x64, 0x01, 
+0xEC, 0x22, 0x74, 0x11, 0x25, 0x64, 0xF5, 0x82, 0xE4, 0x34, 0x9D, 0xF5, 0x83, 0x22, 0x13, 0x13, 
+0x54, 0x03, 0xF5, 0x6B, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0xA2, 0xFB, 0xEF, 
+0xF0, 0x75, 0xF0, 0x04, 0x12, 0x4F, 0x61, 0x54, 0x1F, 0xFB, 0x60, 0x12, 0x64, 0x02, 0x60, 0x0E, 
+0xEB, 0x64, 0x04, 0x60, 0x09, 0xEB, 0x64, 0x09, 0x60, 0x04, 0xEB, 0xB4, 0x0C, 0x0A, 0x12, 0xAE, 
+0x24, 0xF5, 0x83, 0x74, 0x02, 0xF0, 0x80, 0x08, 0x12, 0xAE, 0x24, 0xF5, 0x83, 0x74, 0x01, 0xF0, 
+0xE4, 0xF5, 0x6C, 0x90, 0xA2, 0xFB, 0xE0, 0xFD, 0x91, 0x16, 0x25, 0x6C, 0x91, 0x00, 0xE0, 0xFE, 
+0xEB, 0x75, 0xF0, 0x07, 0xA4, 0x24, 0x56, 0xF5, 0x82, 0xE4, 0x34, 0x40, 0xF5, 0x83, 0xE5, 0x82, 
+0x25, 0x6C, 0x91, 0x00, 0xE4, 0x93, 0xFC, 0xEE, 0x5C, 0x90, 0xA2, 0xFE, 0xF0, 0x75, 0xF0, 0x04, 
+0xED, 0x12, 0x4D, 0xFC, 0x54, 0x03, 0xFF, 0xBF, 0x02, 0x0B, 0xE5, 0x6C, 0x70, 0x07, 0x90, 0xA2, 
+0xFE, 0xE0, 0x54, 0xF0, 0xF0, 0x90, 0xA2, 0xFE, 0xE0, 0xFF, 0x91, 0x12, 0x25, 0x6C, 0x91, 0x00, 
+0xEF, 0xF0, 0x05, 0x6C, 0xE5, 0x6C, 0x64, 0x07, 0x70, 0xA9, 0x90, 0xA2, 0xFB, 0xE0, 0x75, 0xF0, 
+0x04, 0x12, 0x4D, 0xFC, 0xFF, 0xC4, 0x54, 0x03, 0xFD, 0xE4, 0x90, 0xA2, 0xFC, 0xF0, 0x75, 0x6D, 
+0x06, 0xE5, 0x6D, 0xB4, 0x06, 0x07, 0x71, 0xEF, 0xE0, 0x54, 0x0F, 0x80, 0x07, 0x91, 0x12, 0x25, 
+0x6D, 0x91, 0x00, 0xE0, 0x90, 0xA2, 0xFD, 0xF0, 0x90, 0xA2, 0xFD, 0xE0, 0x60, 0x33, 0x75, 0x6C, 
+0x07, 0x12, 0xAF, 0xBC, 0x80, 0x05, 0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 0xF9, 0x12, 0xAF, 0x35, 
+0x60, 0x16, 0x12, 0xAF, 0x2C, 0x90, 0xA2, 0xFC, 0xF0, 0xED, 0x60, 0x22, 0xE0, 0xD3, 0x94, 0x0B, 
+0x40, 0x1C, 0xE0, 0x24, 0x20, 0xF0, 0x80, 0x16, 0x15, 0x6C, 0xE5, 0x6C, 0xC3, 0x94, 0x00, 0x50, 
+0xD0, 0xE5, 0x6D, 0x60, 0x09, 0x15, 0x6D, 0xE5, 0x6D, 0xC3, 0x94, 0x00, 0x50, 0xA3, 0xE4, 0xFC, 
+0xF5, 0x6D, 0xE5, 0x6D, 0xB4, 0x06, 0x07, 0x71, 0xEF, 0xE0, 0x54, 0x0F, 0x80, 0x07, 0x91, 0x12, 
+0x25, 0x6D, 0x91, 0x00, 0xE0, 0x90, 0xA2, 0xFD, 0xF0, 0x90, 0xA2, 0xFD, 0xE0, 0x60, 0x2E, 0xE4, 
+0xF5, 0x6C, 0x12, 0xAF, 0xBC, 0x80, 0x05, 0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 0xF9, 0x12, 0xAF, 
+0x35, 0x60, 0x13, 0x12, 0xAF, 0x2C, 0xFC, 0xED, 0x60, 0x1B, 0xEC, 0xD3, 0x94, 0x0B, 0x40, 0x15, 
+0x74, 0x20, 0x2C, 0xFC, 0x80, 0x0F, 0x05, 0x6C, 0xE5, 0x6C, 0xB4, 0x08, 0xD5, 0x05, 0x6D, 0xE5, 
+0x6D, 0x64, 0x07, 0x70, 0xAD, 0x90, 0xA2, 0xFC, 0xE0, 0xFF, 0x90, 0xA2, 0xFB, 0xE0, 0xFE, 0x75, 
+0xF0, 0x04, 0xF1, 0xD0, 0xEF, 0xF0, 0x75, 0xF0, 0x04, 0xEE, 0xB1, 0x4E, 0xEC, 0xF0, 0x75, 0xF0, 
+0x10, 0xEE, 0xB1, 0x43, 0xE0, 0xFE, 0x54, 0x7F, 0xF5, 0x6E, 0xEE, 0x54, 0x80, 0xFE, 0xE5, 0x6E, 
+0xD3, 0x9F, 0x40, 0x09, 0x90, 0xA2, 0xFC, 0xE0, 0x4E, 0xF5, 0x6E, 0x80, 0x0C, 0xE5, 0x6E, 0xC3, 
+0x9C, 0x50, 0x06, 0xAF, 0x06, 0xEC, 0x4F, 0xF5, 0x6E, 0x90, 0xA2, 0xFB, 0xE0, 0xFF, 0x24, 0x91, 
+0x12, 0xAD, 0x5B, 0xE5, 0x6E, 0xF0, 0x75, 0xF0, 0x04, 0xEF, 0x12, 0x4D, 0xFC, 0x31, 0xAE, 0x90, 
+0xA2, 0xFB, 0xE0, 0xFF, 0xE4, 0xFB, 0xAD, 0x6E, 0xD1, 0x72, 0x90, 0xA2, 0xFB, 0xE0, 0xFF, 0x75, 
+0xF0, 0x10, 0x12, 0x87, 0x2C, 0xE4, 0xF0, 0x90, 0xA2, 0xFC, 0xE0, 0xFE, 0xC3, 0x94, 0x36, 0x40, 
+0x0A, 0x74, 0x91, 0x2F, 0x91, 0x0A, 0x74, 0x05, 0xF0, 0x80, 0x4F, 0xEE, 0xC3, 0x94, 0x2C, 0x40, 
+0x0B, 0x90, 0xA2, 0xFB, 0xE0, 0x91, 0x08, 0x74, 0x04, 0xF0, 0x80, 0x3E, 0x90, 0xA2, 0xFC, 0xE0, 
+0xFF, 0xC3, 0x94, 0x14, 0x40, 0x0B, 0x90, 0xA2, 0xFB, 0xE0, 0x91, 0x08, 0x74, 0x03, 0xF0, 0x80, 
+0x29, 0xEF, 0xC3, 0x94, 0x0C, 0x40, 0x0B, 0x90, 0xA2, 0xFB, 0xE0, 0x91, 0x08, 0x74, 0x02, 0xF0, 
+0x80, 0x18, 0x90, 0xA2, 0xFC, 0xE0, 0xC3, 0x94, 0x04, 0x90, 0xA2, 0xFB, 0xE0, 0x40, 0x07, 0x91, 
+0x08, 0x74, 0x01, 0xF0, 0x80, 0x04, 0x91, 0x08, 0xE4, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xFF, 
+0x90, 0xA2, 0xFB, 0xE0, 0x75, 0xF0, 0x08, 0x90, 0x89, 0x00, 0x12, 0x49, 0x54, 0xE5, 0x82, 0x2F, 
+0xF5, 0x82, 0xE4, 0x35, 0x83, 0xF5, 0x83, 0x22, 0x24, 0x91, 0xF5, 0x82, 0xE4, 0x34, 0x95, 0xF5, 
+0x83, 0x22, 0x90, 0xA2, 0xFB, 0xE0, 0x75, 0xF0, 0x08, 0x90, 0x89, 0x00, 0x12, 0x49, 0x54, 0xE5, 
+0x82, 0x22, 0xE4, 0xFF, 0xE4, 0xFE, 0x74, 0x91, 0x2F, 0x12, 0x66, 0xE5, 0xE0, 0x54, 0xFE, 0xF0, 
+0x75, 0xF0, 0x10, 0xEF, 0x90, 0x81, 0x00, 0xBE, 0x03, 0x0D, 0x12, 0x49, 0x54, 0xE5, 0x82, 0x2E, 
+0x91, 0x00, 0x74, 0x80, 0xF0, 0x80, 0x0A, 0x12, 0x49, 0x54, 0xE5, 0x82, 0x2E, 0x91, 0x00, 0xE4, 
+0xF0, 0x75, 0xF0, 0x08, 0xEF, 0x91, 0x19, 0x2E, 0x91, 0x00, 0xE4, 0xF0, 0x0E, 0xBE, 0x10, 0xC6, 
+0x0F, 0xBF, 0x80, 0xC0, 0xE4, 0x90, 0xAD, 0xE2, 0xF0, 0xFF, 0xE4, 0xFE, 0x75, 0xF0, 0x0A, 0xEF, 
+0x12, 0x87, 0x08, 0x75, 0xF0, 0x02, 0xEE, 0x12, 0x87, 0x7A, 0xF0, 0x0E, 0xBE, 0x05, 0xED, 0x74, 
+0x91, 0x2F, 0x12, 0xAD, 0x5B, 0x74, 0x3F, 0xF0, 0x74, 0x11, 0x2F, 0x12, 0x67, 0xC6, 0xE4, 0xF0, 
+0x74, 0x01, 0x2F, 0x12, 0x66, 0x11, 0x74, 0xC0, 0xF0, 0x74, 0x11, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 
+0x9E, 0xF5, 0x83, 0xE4, 0x12, 0x87, 0xAC, 0xE4, 0xF1, 0xCB, 0x74, 0x3F, 0xB1, 0x49, 0xE4, 0xF0, 
+0x75, 0xF0, 0x04, 0xEF, 0x12, 0x4F, 0x61, 0x54, 0xE0, 0x44, 0x09, 0xF0, 0x75, 0xF0, 0x04, 0xEF, 
+0x12, 0x4D, 0xFC, 0x54, 0xF3, 0xF0, 0x75, 0xF0, 0x04, 0xEF, 0x12, 0x4D, 0xFC, 0x54, 0xFC, 0xF0, 
+0x75, 0xF0, 0x04, 0xEF, 0x12, 0x4F, 0x61, 0x44, 0x20, 0xF0, 0x75, 0xF0, 0x04, 0xEF, 0x12, 0x4D, 
+0xFC, 0x54, 0xCF, 0xF0, 0x75, 0xF0, 0x04, 0xEF, 0x12, 0x4D, 0xFC, 0x44, 0x40, 0xF0, 0x75, 0xF0, 
+0x04, 0xEF, 0x12, 0x4D, 0xFC, 0x54, 0x7F, 0xB1, 0x49, 0xE0, 0xFE, 0x75, 0xF0, 0x10, 0xEF, 0xB1, 
+0x43, 0xEE, 0xF0, 0x74, 0x91, 0x2F, 0x12, 0x66, 0xE5, 0xE4, 0xF0, 0x0F, 0xEF, 0x64, 0x80, 0x60, 
+0x02, 0x81, 0x6A, 0x90, 0x04, 0x49, 0x74, 0xF0, 0xF0, 0xA3, 0xE4, 0xF0, 0xA3, 0x74, 0xFF, 0xF0, 
+0x90, 0x04, 0x33, 0x74, 0x02, 0xF0, 0xA3, 0x74, 0x04, 0xF0, 0xA3, 0x04, 0xF0, 0xA3, 0x04, 0xF0, 
+0xA3, 0x04, 0xF0, 0x74, 0x11, 0x2F, 0x12, 0x7C, 0x1A, 0x74, 0xFF, 0xF0, 0x22, 0xF0, 0x75, 0xF0, 
+0x10, 0xE5, 0x51, 0x90, 0x81, 0x00, 0x02, 0x49, 0x54, 0xF0, 0x75, 0xF0, 0x04, 0xEF, 0x90, 0x96, 
+0x12, 0x02, 0x49, 0x54, 0x90, 0x01, 0xCC, 0xE0, 0x54, 0x0F, 0x90, 0xA3, 0x1D, 0xF0, 0x90, 0xA3, 
+0x1D, 0xE0, 0xFD, 0x70, 0x02, 0xC1, 0x5F, 0x90, 0x9E, 0xEF, 0xE0, 0xFF, 0x70, 0x06, 0xA3, 0xE0, 
+0x64, 0x09, 0x60, 0x0A, 0xEF, 0x14, 0xFF, 0x90, 0x9E, 0xF0, 0xE0, 0xB5, 0x07, 0x04, 0x7F, 0x01, 
+0x80, 0x02, 0x7F, 0x00, 0xEF, 0x60, 0x08, 0x90, 0x01, 0xC1, 0xE0, 0x44, 0x01, 0xF0, 0x22, 0x90, 
+0xA3, 0x1B, 0xE0, 0x12, 0x85, 0xCC, 0x80, 0x05, 0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 0xF9, 0xFF, 
+0xEF, 0x5D, 0x70, 0x02, 0xC1, 0x42, 0xE4, 0x90, 0xA3, 0x1E, 0xF0, 0x90, 0xA3, 0x1E, 0xE0, 0xF9, 
+0xC3, 0x94, 0x04, 0x50, 0x42, 0xD1, 0x61, 0xA4, 0xFF, 0xE9, 0xFD, 0x7C, 0x00, 0x2F, 0xFF, 0xEC, 
+0x35, 0xF0, 0xFE, 0x74, 0xD0, 0x12, 0xAD, 0xA1, 0x12, 0x84, 0xEB, 0xE5, 0x82, 0x29, 0x91, 0x00, 
+0xEF, 0xD1, 0x60, 0xA4, 0x2D, 0xFF, 0xEC, 0x35, 0xF0, 0xFE, 0x74, 0xF0, 0x12, 0xAD, 0xA1, 0x75, 
+0xF0, 0x08, 0x90, 0x9E, 0xA3, 0x12, 0x49, 0x54, 0xE5, 0x82, 0x29, 0x91, 0x00, 0xEF, 0xF0, 0x90, 
+0xA3, 0x1E, 0xE0, 0x04, 0xF0, 0x80, 0xB4, 0x90, 0xA3, 0x1D, 0xE0, 0xFF, 0x90, 0xA3, 0x1B, 0xF1, 
+0xDC, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0xF4, 0x5F, 0x90, 0xA3, 0x1D, 0xF0, 0x90, 0xA3, 0x1B, 
+0xE0, 0xFF, 0x74, 0x01, 0xA8, 0x07, 0x08, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0x90, 0x01, 0xCC, 
+0xF0, 0x90, 0xA3, 0x1B, 0xE0, 0x04, 0xF0, 0xE0, 0x54, 0x03, 0xF0, 0x90, 0x9E, 0xF0, 0x12, 0x84, 
+0xE4, 0xB4, 0x0A, 0x02, 0x7F, 0x01, 0xEF, 0x70, 0x02, 0xA1, 0x5E, 0xE4, 0x90, 0x9E, 0xF0, 0xF0, 
+0xA1, 0x5E, 0x90, 0x01, 0xC0, 0xE0, 0x44, 0x02, 0xF0, 0x90, 0xA3, 0x1B, 0xE0, 0x44, 0x80, 0x90, 
+0x00, 0x8A, 0xD1, 0x60, 0x90, 0x01, 0xD0, 0x12, 0x49, 0x54, 0xE0, 0x90, 0x01, 0xC3, 0xF0, 0x22, 
+0xF0, 0x90, 0xA3, 0x1B, 0xE0, 0x75, 0xF0, 0x04, 0x22, 0x85, 0x60, 0x6B, 0x7B, 0x01, 0xAD, 0x5E, 
+0xAF, 0x5D, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x8F, 0x68, 0x8D, 0x69, 0xE4, 0x90, 0xA2, 
+0xC6, 0xF0, 0xE5, 0x68, 0x13, 0x13, 0x13, 0x54, 0x1F, 0x90, 0xA2, 0xC1, 0xF0, 0xE5, 0x68, 0x54, 
+0x07, 0x90, 0xA2, 0xC3, 0xF0, 0x75, 0xF0, 0x10, 0xEF, 0x12, 0x66, 0x25, 0xE0, 0x90, 0xA2, 0xC4, 
+0xF1, 0xCB, 0xE0, 0x54, 0x7F, 0x90, 0xA2, 0xC7, 0xF0, 0x75, 0xF0, 0x04, 0xE5, 0x68, 0xB1, 0x4E, 
+0xE0, 0x90, 0xA2, 0xC8, 0xF0, 0x12, 0xAF, 0x3E, 0xEB, 0x70, 0x20, 0xE0, 0xFF, 0x12, 0x95, 0x9C, 
+0x12, 0x9C, 0x04, 0xFD, 0xEF, 0x12, 0x9B, 0xEF, 0x74, 0x01, 0x93, 0x2D, 0xFF, 0xE4, 0x93, 0x3C, 
+0xC3, 0x13, 0xFE, 0xEF, 0x13, 0xFF, 0xE5, 0x68, 0x12, 0x95, 0xA6, 0x90, 0xA2, 0xC7, 0xE0, 0xFF, 
+0x90, 0xA2, 0xC2, 0xE0, 0xFE, 0xD3, 0x9F, 0x40, 0x0B, 0xE5, 0x69, 0x54, 0x80, 0xFD, 0xEF, 0x4D, 
+0xF5, 0x69, 0x80, 0x0C, 0x90, 0xA2, 0xC8, 0xE0, 0xFF, 0xEE, 0xC3, 0x9F, 0x50, 0x02, 0x8F, 0x69, 
+0x12, 0xAF, 0x3E, 0xE5, 0x69, 0x54, 0x80, 0x90, 0xA2, 0xC5, 0xF0, 0xEB, 0x70, 0x29, 0x90, 0xA2, 
+0xC1, 0xE0, 0x24, 0x81, 0xF1, 0xC3, 0xC0, 0x83, 0xC0, 0x82, 0xE0, 0xFF, 0x90, 0xA2, 0xC3, 0xF1, 
+0xDC, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0xF4, 0x5F, 0xD0, 0x82, 0xD0, 0x83, 0xF0, 0x90, 0xA2, 
+0xC4, 0xE0, 0x54, 0x7F, 0xF0, 0x80, 0x45, 0x90, 0xA2, 0xC1, 0xE0, 0x24, 0x81, 0xF1, 0xC3, 0xC0, 
+0x83, 0xC0, 0x82, 0xE0, 0xFF, 0x90, 0xA2, 0xC3, 0xF1, 0xDC, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 
+0x4F, 0xD0, 0x82, 0xD0, 0x83, 0xF0, 0x75, 0xF0, 0x10, 0xE5, 0x68, 0x12, 0x66, 0x25, 0xE0, 0x54, 
+0x07, 0xFF, 0x90, 0xA2, 0xC4, 0xF0, 0x90, 0xA2, 0xC2, 0xE0, 0x90, 0x43, 0xAB, 0x93, 0xFE, 0x33, 
+0x33, 0x33, 0x54, 0xF8, 0x4F, 0x90, 0xA2, 0xC4, 0xF0, 0x44, 0x80, 0xF0, 0x75, 0xF0, 0x10, 0xE5, 
+0x68, 0xB1, 0x43, 0xE5, 0x69, 0xF0, 0xE5, 0x68, 0x70, 0x06, 0x90, 0x01, 0xC8, 0xE5, 0x69, 0xF0, 
+0x90, 0xA2, 0xC4, 0xE0, 0xFF, 0x75, 0xF0, 0x10, 0xE5, 0x68, 0x12, 0x66, 0x25, 0xEF, 0xF0, 0x75, 
+0xF0, 0x10, 0xE5, 0x68, 0x12, 0xAD, 0x36, 0xE0, 0x54, 0xFC, 0xFF, 0xE5, 0x6B, 0x12, 0xAF, 0xC4, 
+0xE5, 0x68, 0x12, 0xAD, 0x36, 0xEF, 0xF0, 0x7D, 0x01, 0xAF, 0x68, 0x12, 0x87, 0x32, 0xD0, 0xD0, 
+0x92, 0xAF, 0x22, 0xF5, 0x82, 0xE4, 0x34, 0x94, 0xF5, 0x83, 0x22, 0xF0, 0x75, 0xF0, 0x04, 0xEF, 
+0x90, 0x96, 0x11, 0x02, 0x49, 0x54, 0x75, 0xF0, 0x03, 0x12, 0x49, 0x54, 0xE0, 0xFE, 0x74, 0x01, 
+0xA8, 0x06, 0x08, 0x22, 0xB1, 0x54, 0x7F, 0x02, 0x8F, 0x6F, 0x7F, 0x02, 0x12, 0x47, 0xE7, 0x90, 
+0x9E, 0x92, 0xE0, 0x45, 0x6F, 0xF0, 0x22, 0xC0, 0xE0, 0xC0, 0xF0, 0xC0, 0x83, 0xC0, 0x82, 0xC0, 
+0xD0, 0x75, 0xD0, 0x00, 0xC0, 0x00, 0xC0, 0x01, 0xC0, 0x02, 0xC0, 0x03, 0xC0, 0x04, 0xC0, 0x05, 
+0xC0, 0x06, 0xC0, 0x07, 0x12, 0x8A, 0xAB, 0xE5, 0x21, 0x30, 0xE1, 0x03, 0x12, 0x8F, 0x76, 0xE5, 
+0x21, 0x30, 0xE2, 0x02, 0x51, 0x90, 0xE5, 0x21, 0x30, 0xE5, 0x02, 0x11, 0x88, 0xE5, 0x22, 0x30, 
+0xE0, 0x03, 0x12, 0x8E, 0x85, 0xE5, 0x23, 0x30, 0xE1, 0x03, 0x12, 0x8D, 0xAD, 0xE5, 0x23, 0x30, 
+0xE0, 0x03, 0x12, 0x92, 0xCD, 0xE5, 0x23, 0x30, 0xE3, 0x02, 0xF1, 0xD3, 0xE5, 0x24, 0x30, 0xE1, 
+0x05, 0x7F, 0x04, 0x12, 0x6F, 0xE8, 0xE5, 0x24, 0x30, 0xE4, 0x02, 0x11, 0x9A, 0xE5, 0x24, 0x30, 
+0xE5, 0x03, 0x12, 0x8E, 0xE1, 0xE5, 0x24, 0x30, 0xE6, 0x03, 0x12, 0x8F, 0x04, 0xD0, 0x07, 0xD0, 
+0x06, 0xD0, 0x05, 0xD0, 0x04, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 
+0x82, 0xD0, 0x83, 0xD0, 0xF0, 0xD0, 0xE0, 0x32, 0x90, 0xA0, 0x60, 0xE0, 0x30, 0xE0, 0x0A, 0x31, 
+0x05, 0xE4, 0x90, 0xA0, 0x62, 0xF0, 0x12, 0x4F, 0xFF, 0x22, 0x12, 0x8B, 0xDE, 0x11, 0xD2, 0x90, 
+0xA0, 0x52, 0xE0, 0x30, 0xE0, 0x24, 0x51, 0x87, 0x90, 0xA0, 0x55, 0xE0, 0x60, 0x05, 0x14, 0xF0, 
+0x02, 0xAC, 0x2B, 0x90, 0xA0, 0x53, 0xE0, 0x14, 0x90, 0xA0, 0x55, 0xF0, 0x90, 0x05, 0x73, 0x74, 
+0x01, 0xF0, 0xE4, 0xFF, 0x31, 0x1C, 0x11, 0xD2, 0x31, 0xF4, 0x22, 0xF0, 0x7D, 0x01, 0x7F, 0x02, 
+0x11, 0xD6, 0x7D, 0x02, 0x7F, 0x02, 0x74, 0x15, 0x2F, 0xF8, 0xE6, 0x4D, 0xFE, 0xF6, 0x74, 0x30, 
+0x80, 0x2F, 0x90, 0x9F, 0xA3, 0xE0, 0x54, 0xFB, 0xF0, 0xE4, 0x90, 0x9F, 0xB0, 0xF0, 0xA3, 0xF0, 
+0x90, 0x9F, 0xAB, 0xF0, 0x90, 0x9F, 0xA4, 0xE0, 0x54, 0xF7, 0xF0, 0x54, 0xBF, 0x11, 0xCB, 0x7D, 
+0x10, 0x7F, 0x03, 0x80, 0x04, 0x7D, 0x20, 0xE4, 0xFF, 0x74, 0x1D, 0xF1, 0xDA, 0xFE, 0xF6, 0x74, 
+0x38, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x01, 0xF5, 0x83, 0xEE, 0xF0, 0x22, 0xD3, 0x10, 0xAF, 0x01, 
+0xC3, 0xC0, 0xD0, 0xAC, 0x07, 0xEF, 0x54, 0x01, 0xFE, 0x90, 0xA0, 0x52, 0xE0, 0x54, 0xFE, 0x4E, 
+0xF0, 0xEF, 0x64, 0x01, 0x70, 0x1F, 0x90, 0x01, 0x53, 0xF0, 0x90, 0xA0, 0x54, 0xE0, 0x60, 0x0A, 
+0x7D, 0x10, 0x7F, 0x03, 0x31, 0x69, 0x51, 0x87, 0x80, 0x16, 0x31, 0xFA, 0x31, 0x09, 0x31, 0x71, 
+0x12, 0xAC, 0x2B, 0x80, 0x0B, 0x31, 0xFA, 0x31, 0x69, 0x11, 0xD2, 0x31, 0xF4, 0x12, 0x5F, 0x43, 
+0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x7D, 0x03, 0x7F, 0x02, 0x74, 0x1D, 0x2F, 0xF8, 0xE6, 0x4D, 0x80, 
+0x9C, 0x7D, 0x02, 0x7F, 0x02, 0x31, 0x7B, 0x7D, 0x01, 0x7F, 0x02, 0x74, 0x15, 0xF1, 0xDA, 0xFE, 
+0xF6, 0x74, 0x30, 0x80, 0x8C, 0xEF, 0x70, 0x32, 0x7D, 0x78, 0x7F, 0x02, 0x31, 0x7B, 0x7D, 0x02, 
+0x7F, 0x03, 0x31, 0x7B, 0x7D, 0xC8, 0x7F, 0x02, 0x31, 0x09, 0x12, 0x8C, 0x94, 0xE4, 0xFF, 0x51, 
+0xA6, 0xEF, 0x70, 0x0A, 0x51, 0x04, 0x54, 0xBF, 0xF0, 0x54, 0x7F, 0xF0, 0x80, 0x07, 0x7D, 0x01, 
+0x7F, 0x0C, 0x12, 0x58, 0x67, 0x51, 0x0A, 0x02, 0xAF, 0x58, 0x90, 0x01, 0x36, 0x74, 0x78, 0xF0, 
+0xA3, 0x74, 0x02, 0xF0, 0x7D, 0x78, 0xFF, 0x11, 0xD6, 0x7D, 0x02, 0x7F, 0x03, 0x11, 0xD6, 0x90, 
+0x06, 0x0A, 0xE0, 0x44, 0x07, 0x12, 0xAE, 0x60, 0xE4, 0xFF, 0x51, 0xA6, 0xBF, 0x01, 0x12, 0x12, 
+0x8C, 0xBF, 0xF0, 0x90, 0x9F, 0xAA, 0xE0, 0x20, 0xE2, 0x09, 0x7D, 0x01, 0x7F, 0x04, 0x02, 0x58, 
+0x67, 0x71, 0xDC, 0x22, 0x7D, 0x01, 0x7F, 0x02, 0x01, 0xD6, 0x90, 0x01, 0x53, 0x74, 0x03, 0xF0, 
+0x7D, 0x10, 0xFF, 0x22, 0x12, 0x4C, 0x32, 0x12, 0x5E, 0x7A, 0x90, 0x9F, 0xA3, 0xE0, 0x54, 0xF7, 
+0xF0, 0x22, 0x90, 0xA0, 0x52, 0xE0, 0x30, 0xE0, 0x0B, 0x90, 0x01, 0x3B, 0xE0, 0x30, 0xE4, 0x04, 
+0x31, 0x71, 0x51, 0x87, 0x22, 0x90, 0x9F, 0x9E, 0xE0, 0x30, 0xE0, 0x06, 0x90, 0x9F, 0xA0, 0x74, 
+0x01, 0xF0, 0x90, 0x9F, 0xA7, 0xE0, 0x60, 0x48, 0x90, 0x9F, 0xA3, 0xE0, 0x30, 0xE0, 0x18, 0x90, 
+0x9F, 0xBE, 0xE0, 0x04, 0x12, 0x8C, 0x59, 0xCE, 0xC3, 0x13, 0xCE, 0x13, 0xD8, 0xF9, 0xFF, 0x90, 
+0x9F, 0xDE, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0x9F, 0xA4, 0x12, 0xAA, 0xAF, 0x30, 0xE0, 0x09, 
+0x90, 0x01, 0x3B, 0xE0, 0x30, 0xE4, 0x02, 0x31, 0x71, 0x90, 0xA3, 0x2A, 0xE0, 0x04, 0xF0, 0xE0, 
+0xC3, 0x94, 0x80, 0x40, 0x0B, 0x90, 0x01, 0x98, 0xE0, 0x54, 0xFE, 0xF0, 0xE0, 0x44, 0x01, 0xF0, 
+0x7F, 0x01, 0x12, 0x6F, 0xE8, 0x80, 0x8B, 0x90, 0xA0, 0x54, 0xE0, 0x90, 0x05, 0x73, 0xF0, 0x22, 
+0x90, 0x9F, 0xA7, 0xE0, 0x60, 0x0F, 0x90, 0x06, 0x92, 0xE0, 0x30, 0xE1, 0x03, 0x02, 0xAA, 0x73, 
+0x51, 0x0A, 0x12, 0x58, 0x4F, 0x22, 0x12, 0xAE, 0x54, 0x12, 0x85, 0x5F, 0xE0, 0xFD, 0x7C, 0x00, 
+0x12, 0x85, 0xCD, 0x80, 0x05, 0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 0xF9, 0xFF, 0xEE, 0x5C, 0xFE, 
+0xEF, 0x5D, 0x4E, 0x7F, 0x00, 0x60, 0x02, 0x7F, 0x01, 0x22, 0xF1, 0xCC, 0x91, 0x1C, 0xFF, 0xF5, 
+0x55, 0x12, 0x06, 0x89, 0xFE, 0xC3, 0x13, 0x30, 0xE0, 0x07, 0x12, 0x4F, 0x49, 0xF5, 0x56, 0x80, 
+0x02, 0x8F, 0x56, 0x85, 0x55, 0x54, 0xE5, 0x54, 0xD3, 0x95, 0x56, 0x50, 0x20, 0x12, 0xAE, 0xE3, 
+0x54, 0x01, 0xFD, 0xAF, 0x54, 0x12, 0x85, 0x23, 0xAF, 0x54, 0x51, 0xA6, 0xEF, 0xAF, 0x54, 0x70, 
+0x05, 0x12, 0x87, 0xD4, 0x80, 0x03, 0x12, 0x87, 0xCC, 0x05, 0x54, 0x80, 0xD9, 0xE5, 0x55, 0x70, 
+0x0E, 0xFF, 0x51, 0xA6, 0xEF, 0x70, 0x08, 0x51, 0x04, 0x54, 0xBF, 0xF0, 0x54, 0x7F, 0xF0, 0x22, 
+0x12, 0x8C, 0x5A, 0xCE, 0xC3, 0x13, 0xCE, 0x13, 0xD8, 0xF9, 0xFF, 0x90, 0xA2, 0x01, 0xEE, 0xF0, 
+0xA3, 0xEF, 0xF0, 0x12, 0x8C, 0x45, 0x60, 0x02, 0x61, 0xD0, 0x90, 0x9F, 0xA7, 0xE0, 0x70, 0x02, 
+0x61, 0xD0, 0x71, 0xE5, 0x64, 0x01, 0x70, 0x22, 0x90, 0x06, 0xAB, 0xE0, 0x90, 0x9F, 0xAE, 0xF0, 
+0x90, 0x06, 0xAA, 0xE0, 0x90, 0x9F, 0xAD, 0xF0, 0xA3, 0xE0, 0xFF, 0x70, 0x08, 0x90, 0x9F, 0xAD, 
+0xE0, 0xFE, 0xFF, 0x80, 0x00, 0x90, 0x9F, 0xAE, 0xEF, 0xF0, 0x12, 0xAB, 0x02, 0x71, 0xDC, 0xE4, 
+0x90, 0x9F, 0xB0, 0x12, 0xAE, 0x60, 0x12, 0x8C, 0x94, 0x12, 0x8D, 0x22, 0x54, 0xEF, 0x71, 0xE4, 
+0x24, 0xFD, 0x50, 0x02, 0x80, 0x0F, 0x90, 0x9F, 0x9E, 0xE0, 0x30, 0xE0, 0x05, 0x12, 0x90, 0x44, 
+0x80, 0x03, 0x12, 0x8F, 0xF7, 0x12, 0x8E, 0xCD, 0x54, 0x1F, 0x30, 0xE0, 0x33, 0xEF, 0xC4, 0x13, 
+0x13, 0x54, 0x03, 0x20, 0xE0, 0x2A, 0x90, 0x9F, 0xAD, 0xE0, 0xFF, 0xA3, 0xE0, 0x6F, 0x70, 0x20, 
+0x90, 0x9F, 0xA4, 0xE0, 0x44, 0x40, 0xF0, 0x12, 0x8E, 0xC5, 0xF0, 0x90, 0x01, 0x3F, 0x74, 0x10, 
+0xF0, 0xFD, 0x7F, 0x03, 0x31, 0x69, 0x31, 0x77, 0xF1, 0xD4, 0x90, 0x9F, 0xAE, 0xE0, 0x14, 0xF0, 
+0x90, 0x9F, 0x9E, 0xE0, 0xC3, 0x13, 0x20, 0xE0, 0x02, 0x71, 0xDC, 0x22, 0x90, 0x9F, 0xA4, 0xE0, 
+0x44, 0x04, 0xF0, 0x22, 0xF0, 0x90, 0x9F, 0xA5, 0xE0, 0xFF, 0xC4, 0x54, 0x0F, 0x22, 0x90, 0xA1, 
+0x46, 0x12, 0x49, 0x69, 0x11, 0xE2, 0x90, 0x9F, 0xA7, 0xE0, 0xFF, 0x31, 0x85, 0x90, 0x9F, 0xA7, 
+0xE0, 0x60, 0x12, 0x90, 0xA1, 0x46, 0x12, 0x49, 0x60, 0x91, 0x1C, 0x54, 0x0F, 0xFF, 0x12, 0x4F, 
+0x49, 0xFD, 0x12, 0xAA, 0xB6, 0x22, 0xAB, 0x51, 0xAA, 0x52, 0xA9, 0x53, 0x90, 0x00, 0x01, 0x02, 
+0x06, 0xA2, 0x12, 0x84, 0x48, 0x90, 0xA0, 0x52, 0x12, 0xAD, 0xB0, 0xF0, 0x91, 0x1C, 0x90, 0xA0, 
+0x53, 0x12, 0x4F, 0x48, 0x90, 0xA0, 0x54, 0xF0, 0x90, 0xA0, 0x53, 0xE0, 0x90, 0xA0, 0x55, 0xF0, 
+0x90, 0xA0, 0x52, 0xE0, 0x54, 0x01, 0xFF, 0x21, 0x1C, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 
+0xF1, 0xCC, 0x12, 0x06, 0x89, 0xFF, 0x90, 0x9F, 0x9D, 0xF0, 0xBF, 0x01, 0x08, 0x91, 0x1C, 0x64, 
+0x01, 0x60, 0x19, 0x80, 0x14, 0x91, 0x16, 0x64, 0x01, 0x60, 0x11, 0x90, 0x9F, 0x9E, 0xE0, 0x20, 
+0xE0, 0x07, 0xE4, 0xFF, 0x12, 0x5C, 0x77, 0x80, 0x03, 0x12, 0x8D, 0xF4, 0xD0, 0xD0, 0x92, 0xAF, 
+0x22, 0x90, 0xA1, 0x40, 0x12, 0x49, 0x69, 0x90, 0xA1, 0x3F, 0xEF, 0xF0, 0x12, 0x49, 0x72, 0x74, 
+0xC6, 0x00, 0x74, 0xCF, 0x01, 0x74, 0xD7, 0x02, 0x74, 0xDF, 0x10, 0x74, 0xE7, 0x11, 0x74, 0xF0, 
+0x12, 0x74, 0xF9, 0x14, 0x75, 0x02, 0x20, 0x75, 0x0B, 0x21, 0x75, 0x14, 0x23, 0x75, 0x1D, 0x24, 
+0x75, 0x26, 0x25, 0x75, 0x2F, 0x27, 0x75, 0x37, 0x28, 0x75, 0x40, 0x40, 0x75, 0x49, 0x42, 0x75, 
+0x52, 0x45, 0x00, 0x00, 0x75, 0x5A, 0x90, 0xA1, 0x40, 0x12, 0x49, 0x60, 0x02, 0x83, 0x11, 0x90, 
+0xA1, 0x40, 0x12, 0x49, 0x60, 0x41, 0xCA, 0x90, 0xA1, 0x40, 0x12, 0x49, 0x60, 0x81, 0x49, 0x90, 
+0xA1, 0x40, 0x12, 0x49, 0x60, 0xE1, 0x31, 0x90, 0xA1, 0x40, 0x12, 0x49, 0x60, 0x02, 0x56, 0x52, 
+0x90, 0xA1, 0x40, 0x12, 0x49, 0x60, 0x02, 0x83, 0x5D, 0x90, 0xA1, 0x40, 0x12, 0x49, 0x60, 0x02, 
+0x83, 0x71, 0x90, 0xA1, 0x40, 0x12, 0x49, 0x60, 0x02, 0x66, 0xF5, 0x90, 0xA1, 0x40, 0x12, 0x49, 
+0x60, 0x02, 0x83, 0x80, 0x90, 0xA1, 0x40, 0x12, 0x49, 0x60, 0x02, 0x83, 0xBC, 0x90, 0xA1, 0x40, 
+0x12, 0x49, 0x60, 0x02, 0x5A, 0xF5, 0x90, 0xA1, 0x40, 0x12, 0x49, 0x60, 0x02, 0x83, 0xC4, 0x90, 
+0xA1, 0x40, 0x12, 0x49, 0x60, 0x81, 0x22, 0x90, 0xA1, 0x40, 0x12, 0x49, 0x60, 0x02, 0x83, 0xCC, 
+0x90, 0xA1, 0x40, 0x12, 0x49, 0x60, 0x02, 0x4E, 0x03, 0x90, 0xA1, 0x40, 0x12, 0x49, 0x60, 0x02, 
+0x66, 0x44, 0x90, 0xA1, 0x40, 0x12, 0x49, 0x60, 0x80, 0x10, 0x90, 0x01, 0xC0, 0xE0, 0x44, 0x01, 
+0xF0, 0x90, 0xA1, 0x3F, 0xE0, 0x90, 0x01, 0xC2, 0xF0, 0x22, 0x91, 0x1C, 0x90, 0xA0, 0x8D, 0x12, 
+0x4F, 0x48, 0x90, 0xA0, 0x8E, 0xF0, 0xB1, 0xB1, 0x7F, 0x01, 0x90, 0xA1, 0x43, 0x74, 0x11, 0xF0, 
+0x90, 0xA1, 0x51, 0x74, 0x01, 0xF0, 0x90, 0xA1, 0x45, 0xEF, 0xF0, 0x7B, 0x01, 0x7A, 0xA1, 0x79, 
+0x43, 0x12, 0x7B, 0x25, 0x7F, 0x04, 0x90, 0xA3, 0x28, 0xEF, 0xF0, 0x7F, 0x02, 0x12, 0x47, 0xE7, 
+0x90, 0x9E, 0x92, 0xE0, 0xFF, 0x90, 0xA3, 0x28, 0xE0, 0xFE, 0xEF, 0x4E, 0x90, 0x9E, 0x92, 0xF0, 
+0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0xD1, 0x0C, 0x7A, 0xA1, 0x79, 0x43, 0x12, 0x9C, 
+0x0D, 0x7B, 0x01, 0x7A, 0xA1, 0x79, 0x82, 0xD1, 0x12, 0x7A, 0xA1, 0x79, 0x66, 0x12, 0x9D, 0x01, 
+0x7B, 0x01, 0x7A, 0xA1, 0x79, 0xAA, 0xD1, 0x12, 0x7A, 0xA1, 0x79, 0x9E, 0xD1, 0xF2, 0x12, 0x9E, 
+0x47, 0xE4, 0xFF, 0x12, 0xA0, 0x64, 0x7B, 0x01, 0x7A, 0xA1, 0x79, 0x9E, 0xE4, 0xFF, 0xF1, 0x4C, 
+0x7B, 0x01, 0x7A, 0xA1, 0x79, 0x82, 0xD1, 0x12, 0x7A, 0xA1, 0x79, 0x66, 0xD1, 0x18, 0xD1, 0x0C, 
+0x7A, 0xA1, 0x79, 0x43, 0x12, 0x9C, 0x82, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x7B, 0x01, 0x7A, 0xA1, 
+0x79, 0x46, 0x90, 0xA1, 0xB9, 0x02, 0x49, 0x69, 0xF1, 0xC2, 0x12, 0x08, 0x79, 0x80, 0x00, 0x00, 
+0x00, 0x90, 0xA2, 0xB5, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 0x00, 0x12, 0x7E, 0x8E, 0xE4, 0x90, 
+0xA1, 0xBC, 0xF0, 0x90, 0xA1, 0xBC, 0xE0, 0xFD, 0x12, 0x9D, 0x38, 0x12, 0x96, 0x04, 0xC0, 0x06, 
+0xC0, 0x07, 0xD1, 0xEC, 0x12, 0x9C, 0xF6, 0x12, 0x48, 0xCE, 0x12, 0x4D, 0x4D, 0xD0, 0x07, 0xD0, 
+0x06, 0x12, 0x38, 0x07, 0x12, 0x9C, 0x7B, 0xE0, 0xC3, 0x94, 0x07, 0x40, 0xD6, 0x90, 0xA2, 0xB1, 
+0x12, 0x08, 0x79, 0x80, 0x00, 0x00, 0x00, 0x90, 0xA2, 0xB5, 0x12, 0x08, 0x79, 0x80, 0x00, 0x00, 
+0x00, 0x12, 0x7E, 0x8E, 0x90, 0xAA, 0xB9, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x80, 
+0xD1, 0xDF, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x84, 0xD1, 0xDF, 0x12, 0x08, 0x79, 
+0x00, 0x00, 0x00, 0x00, 0x7F, 0x88, 0xD1, 0xDF, 0x12, 0x08, 0x79, 0x3C, 0x00, 0x00, 0x00, 0x7F, 
+0x8C, 0xD1, 0xDF, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xB8, 0xD1, 0xDF, 0x12, 0x08, 
+0x79, 0x00, 0x00, 0x00, 0x80, 0x7F, 0x90, 0xD1, 0xDF, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 0x00, 
+0x7F, 0x94, 0xD1, 0xDF, 0x12, 0x08, 0x79, 0x20, 0x04, 0x00, 0x00, 0x7F, 0xC4, 0xD1, 0xDF, 0x12, 
+0x08, 0x79, 0x20, 0x00, 0x00, 0x00, 0x7F, 0xC8, 0x7E, 0x0C, 0x02, 0x38, 0x07, 0x7F, 0xB0, 0x7E, 
+0x0C, 0x12, 0x38, 0x07, 0x90, 0xAA, 0xB9, 0x22, 0xE4, 0xFF, 0xF1, 0x23, 0x90, 0xA1, 0xB6, 0x02, 
+0x49, 0x60, 0xF1, 0xC2, 0x12, 0x08, 0x79, 0x80, 0x00, 0x00, 0x00, 0x90, 0xA2, 0xB5, 0x12, 0x08, 
+0x79, 0x00, 0x00, 0x00, 0x00, 0x12, 0x7E, 0x8E, 0x7D, 0x65, 0xD1, 0xE8, 0x12, 0x48, 0xFE, 0x7D, 
+0x8F, 0xD1, 0xE8, 0x90, 0x00, 0x04, 0x12, 0x49, 0x18, 0xE4, 0xFD, 0xD1, 0xE9, 0x90, 0x00, 0x08, 
+0x02, 0x49, 0x18, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0xF1, 0xE4, 0xD0, 0xD0, 0x92, 0xAF, 
+0x22, 0x90, 0x04, 0x24, 0x12, 0x83, 0x54, 0x90, 0xA0, 0x6F, 0xF0, 0x91, 0x1C, 0x25, 0x51, 0x90, 
+0xA0, 0x7D, 0x12, 0x4F, 0x48, 0x25, 0x51, 0x90, 0xA0, 0x8B, 0xF0, 0x22, 0x90, 0xA1, 0xB6, 0xEF, 
+0xF0, 0xA3, 0xF1, 0xC5, 0x12, 0x08, 0x79, 0x80, 0x00, 0x00, 0x00, 0x90, 0xA2, 0xB5, 0x12, 0x08, 
+0x79, 0x00, 0x00, 0x00, 0x00, 0x12, 0x7E, 0x8E, 0xF1, 0xBC, 0x12, 0x48, 0xAE, 0x12, 0xAD, 0x3F, 
+0x7D, 0x65, 0xF1, 0xBA, 0x90, 0x00, 0x04, 0x12, 0xAD, 0x3C, 0x7D, 0x8F, 0xF1, 0xBA, 0x90, 0x00, 
+0x08, 0x12, 0xAD, 0x3C, 0xE4, 0xFD, 0x12, 0xAC, 0xC1, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 0x00, 
+0x90, 0xA1, 0xB6, 0xE0, 0xFF, 0x7D, 0xEF, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0xC0, 0x07, 
+0xC0, 0x05, 0x90, 0xA1, 0xFA, 0x12, 0x49, 0x3C, 0x90, 0xAA, 0x9C, 0x12, 0x08, 0x6D, 0xD0, 0x05, 
+0xD0, 0x07, 0x12, 0x32, 0x34, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xF1, 0x97, 0x90, 0xA1, 0xB7, 0x02, 
+0x49, 0x60, 0x90, 0xA1, 0xB6, 0x12, 0x49, 0x69, 0x90, 0xA2, 0xB1, 0x22, 0x8B, 0x51, 0x8A, 0x52, 
+0x89, 0x53, 0x22, 0x22, 0x7D, 0x02, 0x7F, 0x02, 0x21, 0x7B, 0x2F, 0xF8, 0xE6, 0xFE, 0xED, 0xF4, 
+0x5E, 0x22, 0x32, 0x32, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0xA2, 0xC9, 0xEF, 0xF0, 
+0xA3, 0xED, 0xF0, 0x7D, 0x00, 0x7C, 0x00, 0xE4, 0x90, 0xA2, 0xCF, 0xF0, 0x7F, 0xB0, 0x7E, 0x08, 
+0x12, 0x37, 0xBC, 0xE4, 0xFF, 0xEC, 0x90, 0xA2, 0xCB, 0x12, 0x08, 0x6D, 0x90, 0xA2, 0xCB, 0x12, 
+0x49, 0x48, 0x90, 0xA2, 0xCA, 0xE0, 0xFF, 0xE4, 0xFC, 0xFD, 0xFE, 0x12, 0x48, 0x7A, 0xA3, 0x12, 
+0x08, 0x6D, 0x90, 0xA2, 0xCB, 0x12, 0x4D, 0x4B, 0x7F, 0xB0, 0x7E, 0x08, 0x12, 0x38, 0x07, 0x11, 
+0x58, 0x90, 0xA2, 0xC9, 0xE0, 0x75, 0xF0, 0x08, 0xA4, 0x24, 0xB5, 0xF5, 0x82, 0xE4, 0x34, 0xAD, 
+0x11, 0x51, 0xFF, 0x12, 0x37, 0xBC, 0xED, 0x54, 0x0F, 0xFD, 0xE4, 0xFC, 0xD0, 0xD0, 0x92, 0xAF, 
+0x22, 0xF5, 0x83, 0xE0, 0xFE, 0xA3, 0xE0, 0x22, 0x7F, 0x14, 0x7E, 0x00, 0x02, 0x3D, 0x7A, 0x90, 
+0xA3, 0x15, 0x31, 0x63, 0x90, 0x01, 0x09, 0xE0, 0x7F, 0x00, 0x30, 0xE7, 0x02, 0x7F, 0x01, 0x90, 
+0xA3, 0x15, 0xE0, 0x6F, 0x60, 0x34, 0xC3, 0x90, 0xA3, 0x17, 0xE0, 0x94, 0x88, 0x90, 0xA3, 0x16, 
+0xE0, 0x94, 0x13, 0x40, 0x08, 0x90, 0x01, 0xC0, 0xE0, 0x44, 0x10, 0xF0, 0x22, 0x90, 0xA3, 0x16, 
+0x11, 0xFB, 0x11, 0x58, 0xD3, 0x90, 0xA3, 0x17, 0xE0, 0x94, 0x32, 0x90, 0xA3, 0x16, 0xE0, 0x94, 
+0x00, 0x40, 0xC1, 0x90, 0x01, 0xC6, 0xE0, 0x30, 0xE0, 0xBA, 0x22, 0xE4, 0x90, 0xA1, 0x3B, 0xF0, 
+0xA3, 0xF0, 0x31, 0x02, 0xEF, 0x64, 0x01, 0x60, 0x3B, 0xC3, 0x90, 0xA1, 0x3C, 0xE0, 0x94, 0x88, 
+0x90, 0xA1, 0x3B, 0xE0, 0x94, 0x13, 0x40, 0x0F, 0x90, 0x01, 0xC1, 0xE0, 0x44, 0x10, 0xF0, 0x90, 
+0x01, 0xC7, 0x74, 0xFD, 0xF0, 0x80, 0x1D, 0x90, 0xA1, 0x3B, 0x11, 0xFB, 0x11, 0x58, 0xD3, 0x90, 
+0xA1, 0x3C, 0xE0, 0x94, 0x32, 0x90, 0xA1, 0x3B, 0xE0, 0x94, 0x00, 0x40, 0xC5, 0x90, 0x01, 0xC6, 
+0xE0, 0x30, 0xE3, 0xBE, 0x90, 0x01, 0xC7, 0x74, 0xFE, 0xF0, 0x22, 0xE4, 0x75, 0xF0, 0x01, 0x02, 
+0x08, 0xD6, 0x90, 0x01, 0x9A, 0xE0, 0x54, 0xC0, 0x44, 0x0B, 0x31, 0x5B, 0x90, 0x01, 0x98, 0xE0, 
+0x54, 0xC0, 0x7F, 0x00, 0xB4, 0x40, 0x02, 0x7F, 0x01, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 
+0xD0, 0x90, 0xA2, 0xE7, 0xEE, 0xF0, 0xA3, 0x31, 0x63, 0x90, 0xA2, 0xE7, 0x71, 0x10, 0xE0, 0x60, 
+0x23, 0xC3, 0x90, 0xA2, 0xEA, 0xE0, 0x94, 0xE8, 0x90, 0xA2, 0xE9, 0xE0, 0x94, 0x03, 0x40, 0x0B, 
+0x90, 0x01, 0xC0, 0xE0, 0x44, 0x80, 0xF0, 0x7F, 0x00, 0x80, 0x0B, 0x90, 0xA2, 0xE9, 0x11, 0xFB, 
+0x31, 0x5C, 0x80, 0xD5, 0x7F, 0x01, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xF0, 0x7F, 0x0A, 0x7E, 0x00, 
+0x02, 0x3D, 0x7A, 0xEF, 0xF0, 0xE4, 0xA3, 0xF0, 0xA3, 0xF0, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 
+0xC0, 0xD0, 0x90, 0xA2, 0xEF, 0x12, 0x49, 0x69, 0x7F, 0x96, 0x7E, 0x02, 0x31, 0x1A, 0xEF, 0x60, 
+0x51, 0x90, 0x01, 0x17, 0xE0, 0xFE, 0x90, 0x01, 0x16, 0xE0, 0x7C, 0x00, 0x24, 0x00, 0xFF, 0xEC, 
+0x3E, 0xFE, 0xEF, 0x24, 0x01, 0xFF, 0xE4, 0x3E, 0xFE, 0x90, 0xA2, 0xF2, 0xEF, 0xF0, 0xEE, 0xFF, 
+0x90, 0xFD, 0x11, 0xF0, 0x90, 0xA2, 0xF2, 0xE0, 0xFD, 0x90, 0x02, 0x94, 0xF0, 0xA3, 0xEF, 0xF0, 
+0x90, 0xA2, 0xEF, 0x71, 0x07, 0x24, 0x02, 0xFF, 0xE4, 0x33, 0xFE, 0x31, 0xD7, 0x90, 0xA2, 0xF2, 
+0xE0, 0x24, 0x18, 0xFF, 0x90, 0xA2, 0xEF, 0x12, 0x49, 0x60, 0x51, 0x95, 0x90, 0x02, 0x96, 0x74, 
+0x01, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xE4, 0xFC, 0xED, 0x2C, 0x24, 0x00, 0x51, 0x28, 0xE4, 
+0xF0, 0x0C, 0xEC, 0xB4, 0x18, 0xF3, 0x74, 0x00, 0x2D, 0x51, 0x28, 0xEF, 0xF0, 0xEE, 0x54, 0x3F, 
+0xFF, 0x74, 0x01, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 0xFB, 0xF5, 0x83, 0xEF, 0xF0, 0x74, 0x02, 0x2D, 
+0xF5, 0x82, 0xE4, 0x34, 0xFB, 0xF5, 0x83, 0xE0, 0x54, 0xF0, 0xF0, 0x74, 0x03, 0x2D, 0xF5, 0x82, 
+0xE4, 0x34, 0xFB, 0xF5, 0x83, 0xE0, 0x44, 0x80, 0xF0, 0x74, 0x0B, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 
+0xFB, 0xF5, 0x83, 0xE0, 0x44, 0x10, 0xF0, 0x22, 0xF5, 0x82, 0xE4, 0x34, 0xFB, 0xF5, 0x83, 0x22, 
+0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0xE4, 0xFF, 0x90, 0x9F, 0x88, 0xE0, 0xFE, 0x90, 0x9F, 
+0x87, 0xE0, 0xFD, 0xB5, 0x06, 0x04, 0x7E, 0x01, 0x80, 0x02, 0x7E, 0x00, 0xEE, 0x64, 0x01, 0x60, 
+0x3F, 0xED, 0x71, 0x19, 0xFA, 0x7B, 0x01, 0x31, 0x6B, 0x7F, 0x01, 0xEF, 0x60, 0x32, 0x90, 0x9F, 
+0x87, 0xE0, 0x04, 0xF0, 0xE0, 0xB4, 0x0A, 0x02, 0x80, 0x02, 0x7F, 0x00, 0xEF, 0x60, 0x05, 0xE4, 
+0x90, 0x9F, 0x87, 0xF0, 0x90, 0x9F, 0x88, 0xE0, 0xFF, 0x90, 0x9F, 0x87, 0xE0, 0xB5, 0x07, 0x04, 
+0x7F, 0x01, 0x80, 0x02, 0x7F, 0x00, 0xEF, 0x70, 0x07, 0x90, 0x9E, 0x92, 0xE0, 0x44, 0x04, 0xF0, 
+0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0xA2, 0xEB, 0xEF, 0xF0, 0xA3, 0x12, 0x49, 0x69, 0x90, 0xA3, 
+0x1C, 0xE0, 0xFE, 0x04, 0xF0, 0x90, 0x00, 0x01, 0xEE, 0x12, 0x06, 0xE1, 0x74, 0x00, 0x2F, 0xF9, 
+0xE4, 0x34, 0xFB, 0xFA, 0x7B, 0x01, 0xC0, 0x03, 0xC0, 0x02, 0xC0, 0x01, 0x90, 0xA2, 0xEC, 0x12, 
+0x49, 0x60, 0x8B, 0x40, 0x8A, 0x41, 0x89, 0x42, 0x75, 0x43, 0x02, 0xD0, 0x01, 0xD0, 0x02, 0xD0, 
+0x03, 0x12, 0x34, 0x62, 0x90, 0xA2, 0xEB, 0xE0, 0x24, 0x02, 0xF9, 0xE4, 0x34, 0xFB, 0xFA, 0x7B, 
+0x01, 0xC0, 0x03, 0xC0, 0x02, 0xC0, 0x01, 0xA3, 0x12, 0x49, 0x60, 0xE9, 0x24, 0x02, 0xF9, 0xE4, 
+0x3A, 0x8B, 0x40, 0xF5, 0x41, 0x89, 0x42, 0x90, 0xA2, 0xEC, 0x71, 0x07, 0xF5, 0x43, 0xD0, 0x01, 
+0xD0, 0x02, 0xD0, 0x03, 0x02, 0x34, 0x62, 0x12, 0x49, 0x60, 0x90, 0x00, 0x0E, 0x02, 0x06, 0xA2, 
+0xE0, 0xFE, 0xA3, 0xE0, 0xF5, 0x82, 0x8E, 0x83, 0x22, 0x75, 0xF0, 0x0F, 0xA4, 0x24, 0xF1, 0xF9, 
+0x74, 0x9E, 0x35, 0xF0, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x9F, 0x87, 0xE0, 
+0xFF, 0x70, 0x06, 0xA3, 0xE0, 0x64, 0x09, 0x60, 0x0A, 0xEF, 0x14, 0xFF, 0x90, 0x9F, 0x88, 0xE0, 
+0xB5, 0x07, 0x04, 0x7F, 0x01, 0x80, 0x02, 0x7F, 0x00, 0xEF, 0x60, 0x09, 0x90, 0x01, 0xC1, 0xE0, 
+0x44, 0x02, 0xF0, 0x80, 0x29, 0xC0, 0x01, 0x90, 0x9F, 0x88, 0xE0, 0x71, 0x19, 0xA8, 0x01, 0xFC, 
+0x7D, 0x01, 0xD0, 0x01, 0x7E, 0x00, 0x7F, 0x0F, 0x12, 0x06, 0x63, 0x90, 0x9F, 0x88, 0x12, 0x84, 
+0xE4, 0xB4, 0x0A, 0x02, 0x7F, 0x01, 0xEF, 0x60, 0x05, 0xE4, 0x90, 0x9F, 0x88, 0xF0, 0xD0, 0xD0, 
+0x92, 0xAF, 0x22, 0x90, 0xA1, 0x4E, 0x74, 0x12, 0xF0, 0x90, 0xA1, 0x5C, 0x74, 0x05, 0xF0, 0x90, 
+0xA1, 0x50, 0x91, 0xAE, 0xEB, 0xF0, 0x90, 0xA1, 0x4C, 0xE0, 0x90, 0xA1, 0x53, 0xF0, 0x90, 0xA1, 
+0x4D, 0xE0, 0x90, 0xA1, 0x54, 0xF0, 0x7B, 0x01, 0x7A, 0xA1, 0x79, 0x4E, 0x71, 0x25, 0x7F, 0x04, 
+0x02, 0x75, 0x96, 0x90, 0xA2, 0x8A, 0xEB, 0xF0, 0x70, 0x5D, 0x90, 0xA2, 0x8A, 0xE0, 0xFE, 0x91, 
+0x18, 0xE0, 0xFC, 0x90, 0xA2, 0x8B, 0xE0, 0xFB, 0xEC, 0x6B, 0x60, 0x4B, 0x90, 0xA2, 0x8F, 0xEB, 
+0xF0, 0xA3, 0xEE, 0xF0, 0xAE, 0x05, 0xEE, 0x25, 0xE0, 0x4F, 0xFF, 0x90, 0x9E, 0x91, 0xE0, 0xFE, 
+0x25, 0xE0, 0x25, 0xE0, 0x4F, 0x90, 0xA2, 0x91, 0xF0, 0x90, 0xA2, 0x8C, 0xE0, 0x90, 0xA2, 0x93, 
+0xF0, 0x90, 0xA2, 0x8D, 0x74, 0x0C, 0xF0, 0x90, 0xA2, 0x9B, 0x74, 0x04, 0xF0, 0x7B, 0x01, 0x7A, 
+0xA2, 0x79, 0x8D, 0x71, 0x25, 0x7F, 0x04, 0x12, 0x75, 0x96, 0x90, 0xA2, 0x8B, 0xE0, 0xFF, 0x90, 
+0xA2, 0x8A, 0xE0, 0x91, 0x18, 0xEF, 0xF0, 0x22, 0x24, 0x11, 0xF5, 0x82, 0xE4, 0x34, 0x99, 0xF5, 
+0x83, 0x22, 0x7B, 0x01, 0x7A, 0xA1, 0x79, 0x43, 0x7F, 0xF5, 0x7E, 0x01, 0x12, 0x33, 0xFD, 0xBF, 
+0x01, 0x06, 0x90, 0xA1, 0x43, 0xE0, 0xA3, 0xF0, 0x7B, 0x01, 0x7A, 0xA1, 0x79, 0x43, 0x7F, 0xF6, 
+0x7E, 0x01, 0x12, 0x33, 0xFD, 0xBF, 0x01, 0x08, 0x90, 0xA1, 0x43, 0xE0, 0x90, 0xA1, 0x45, 0xF0, 
+0x7B, 0x01, 0x7A, 0xA1, 0x79, 0x43, 0x7F, 0xF4, 0x7E, 0x01, 0x12, 0x33, 0xFD, 0xBF, 0x01, 0x08, 
+0x90, 0xA1, 0x43, 0xE0, 0x90, 0xA1, 0x46, 0xF0, 0x7B, 0x01, 0x7A, 0xA1, 0x79, 0x43, 0x7F, 0xF3, 
+0x7E, 0x01, 0x12, 0x33, 0xFD, 0xBF, 0x01, 0x08, 0x90, 0xA1, 0x43, 0xE0, 0x90, 0xA1, 0x47, 0xF0, 
+0x7B, 0x01, 0x7A, 0xA1, 0x79, 0x43, 0x7F, 0xF2, 0x7E, 0x01, 0x12, 0x33, 0xFD, 0xBF, 0x01, 0x08, 
+0x90, 0xA1, 0x43, 0xE0, 0x90, 0xA1, 0x48, 0xF0, 0x90, 0xA1, 0x44, 0x12, 0xAF, 0x23, 0xA3, 0xE0, 
+0x90, 0xA1, 0x4C, 0xF0, 0x90, 0xA1, 0x48, 0xE0, 0x90, 0xA1, 0x4D, 0xF0, 0x61, 0x83, 0xEF, 0xF0, 
+0xA3, 0xED, 0xF0, 0xA3, 0x22, 0x90, 0xA2, 0xD6, 0x91, 0xAE, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 
+0x00, 0x7F, 0x34, 0x7E, 0x08, 0x12, 0x37, 0xBC, 0x90, 0xA2, 0xD8, 0x12, 0x08, 0x6D, 0x90, 0xA2, 
+0xD6, 0xE0, 0x14, 0x60, 0x5E, 0x14, 0x70, 0x02, 0xA1, 0xE9, 0x24, 0x02, 0x60, 0x02, 0xC1, 0x6F, 
+0x90, 0xA2, 0xB1, 0x12, 0x08, 0x79, 0x00, 0x30, 0x03, 0xC3, 0x90, 0xA2, 0xB5, 0x12, 0x08, 0x79, 
+0x00, 0x30, 0x02, 0x00, 0xD1, 0x84, 0x12, 0x08, 0x79, 0x40, 0x00, 0x00, 0x00, 0x90, 0xA2, 0xB5, 
+0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xC4, 0xD1, 0x86, 0x12, 0x08, 0x79, 0x00, 0x1C, 
+0x00, 0x00, 0x90, 0xA2, 0xB5, 0x12, 0x08, 0x79, 0x00, 0x10, 0x00, 0x00, 0x7F, 0x64, 0xD1, 0x86, 
+0x12, 0x08, 0x79, 0x03, 0xC0, 0x00, 0x00, 0x90, 0xA2, 0xB5, 0x12, 0x08, 0x79, 0x02, 0x00, 0x00, 
+0x00, 0xC1, 0x52, 0x90, 0xA2, 0xB1, 0x12, 0x08, 0x79, 0x00, 0x30, 0x03, 0xC3, 0x90, 0xA2, 0xB5, 
+0x12, 0x08, 0x79, 0x00, 0x30, 0x02, 0x01, 0xD1, 0x84, 0x12, 0x08, 0x79, 0x40, 0x00, 0x00, 0x00, 
+0x90, 0xA2, 0xB5, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xC4, 0xD1, 0x86, 0x12, 0x08, 
+0x79, 0x00, 0x00, 0x00, 0x3C, 0xD1, 0x70, 0x12, 0x08, 0x79, 0xF0, 0x00, 0x00, 0x00, 0x12, 0x9F, 
+0x77, 0x7F, 0x38, 0xD1, 0x86, 0x12, 0x08, 0x79, 0x00, 0x1C, 0x00, 0x00, 0x90, 0xA2, 0xB5, 0x12, 
+0x08, 0x79, 0x00, 0x08, 0x00, 0x00, 0x12, 0xAD, 0x17, 0x60, 0x13, 0x12, 0x08, 0x79, 0x03, 0xC0, 
+0x00, 0x00, 0x90, 0xA2, 0xB5, 0x12, 0x08, 0x79, 0x01, 0x80, 0x00, 0x00, 0x80, 0x11, 0x12, 0x08, 
+0x79, 0x03, 0xC0, 0x00, 0x00, 0x90, 0xA2, 0xB5, 0x12, 0x08, 0x79, 0x02, 0x00, 0x00, 0x00, 0x7F, 
+0x48, 0x7E, 0x08, 0xD1, 0x92, 0x90, 0xA2, 0xD7, 0xE0, 0x90, 0xA2, 0xB1, 0xB4, 0x01, 0x13, 0x12, 
+0x08, 0x79, 0x00, 0x00, 0x00, 0x10, 0x90, 0xA2, 0xB5, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 0x10, 
+0x80, 0x11, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 0x10, 0x90, 0xA2, 0xB5, 0x12, 0x08, 0x79, 0x00, 
+0x00, 0x00, 0x00, 0x7F, 0x00, 0x7E, 0x0A, 0xC1, 0x6D, 0x90, 0xA2, 0xB1, 0x12, 0x08, 0x79, 0x00, 
+0x30, 0x03, 0xC3, 0x90, 0xA2, 0xB5, 0x12, 0x08, 0x79, 0x00, 0x30, 0x02, 0x02, 0xD1, 0x84, 0x12, 
+0x08, 0x79, 0x40, 0x00, 0x00, 0x00, 0x90, 0xA2, 0xB5, 0x12, 0x08, 0x79, 0x40, 0x00, 0x00, 0x00, 
+0x7F, 0xC4, 0xD1, 0x86, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 0x3C, 0xD1, 0x70, 0x12, 0x08, 0x79, 
+0xF0, 0x00, 0x00, 0x00, 0x12, 0x9F, 0x77, 0x7F, 0x38, 0xD1, 0x86, 0x12, 0x08, 0x79, 0x00, 0x1C, 
+0x00, 0x00, 0x90, 0xA2, 0xB5, 0x12, 0x08, 0x79, 0x00, 0x08, 0x00, 0x00, 0x12, 0xAD, 0x17, 0x60, 
+0x17, 0x12, 0x08, 0x79, 0x03, 0xC0, 0x00, 0x00, 0x90, 0xA2, 0xB5, 0x12, 0x08, 0x79, 0x01, 0x40, 
+0x00, 0x00, 0x7F, 0x48, 0x7E, 0x08, 0x80, 0x15, 0x12, 0x08, 0x79, 0x03, 0xC0, 0x00, 0x00, 0x90, 
+0xA2, 0xB5, 0x12, 0x08, 0x79, 0x01, 0xC0, 0x00, 0x00, 0x7F, 0x48, 0x7E, 0x08, 0xD1, 0x92, 0x22, 
+0x90, 0xA2, 0xD7, 0xE0, 0xFF, 0xE4, 0xFC, 0xFD, 0xFE, 0x78, 0x02, 0x12, 0x08, 0x5A, 0x90, 0xA2, 
+0xB5, 0x12, 0x08, 0x6D, 0x7F, 0xAC, 0x7E, 0x08, 0xD1, 0x92, 0x90, 0xA2, 0xB1, 0x22, 0x7F, 0x2C, 
+0x7E, 0x08, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0xA2, 0xAF, 0xEE, 0xF0, 0xA3, 0xEF, 
+0xF0, 0x12, 0x37, 0xBC, 0x90, 0xA2, 0xB9, 0x12, 0x08, 0x6D, 0x90, 0xA2, 0xB1, 0x12, 0x49, 0x3C, 
+0x12, 0x08, 0x3A, 0x90, 0xA2, 0xB9, 0x12, 0xAD, 0xE6, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 
+0x07, 0x90, 0xA2, 0xB1, 0x12, 0x49, 0x3C, 0x90, 0xA2, 0xB5, 0x12, 0xAD, 0xE6, 0xD0, 0x03, 0xD0, 
+0x02, 0xD0, 0x01, 0xD0, 0x00, 0x12, 0x48, 0x7A, 0x90, 0xA2, 0xBD, 0x12, 0x08, 0x6D, 0x90, 0xA2, 
+0xBD, 0x12, 0x4D, 0x4B, 0x90, 0xA2, 0xAF, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x12, 0x38, 0x07, 0xD0, 
+0xD0, 0x92, 0xAF, 0x22, 0x90, 0xA3, 0x19, 0xED, 0xF0, 0x90, 0xA3, 0x18, 0xEF, 0xF0, 0x60, 0x02, 
+0xE1, 0xA5, 0x90, 0xA2, 0xB1, 0x12, 0x08, 0x79, 0x30, 0x00, 0x00, 0x00, 0x90, 0xA2, 0xB5, 0x12, 
+0x08, 0x79, 0x00, 0x00, 0x00, 0x00, 0x74, 0x08, 0xFF, 0xFE, 0xD1, 0x88, 0x12, 0x08, 0x79, 0x00, 
+0x00, 0xF0, 0x00, 0x90, 0xA2, 0xB5, 0x12, 0x08, 0x79, 0x00, 0x00, 0x70, 0x00, 0x7F, 0xB0, 0x7E, 
+0x0C, 0xD1, 0x88, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 0xF0, 0x90, 0xA2, 0xB5, 0x12, 0x08, 0x79, 
+0x00, 0x00, 0x00, 0x70, 0x7F, 0xB0, 0x7E, 0x0C, 0xD1, 0x88, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 
+0x0E, 0x90, 0xA2, 0xB5, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 0x08, 0x7F, 0x30, 0xD1, 0x86, 0x12, 
+0x08, 0x79, 0x00, 0x00, 0x00, 0x03, 0x90, 0xA2, 0xB5, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 0x01, 
+0x7F, 0x34, 0xD1, 0x86, 0x12, 0x08, 0x79, 0x00, 0x00, 0x0F, 0x00, 0x90, 0xA2, 0xB5, 0x12, 0x08, 
+0x79, 0x00, 0x00, 0x00, 0x00, 0x12, 0x82, 0xEB, 0x12, 0x08, 0x79, 0x30, 0x00, 0x00, 0x00, 0x90, 
+0xA2, 0xB5, 0x12, 0x08, 0x79, 0x30, 0x00, 0x00, 0x00, 0x12, 0x83, 0x00, 0x90, 0x04, 0x54, 0xE0, 
+0x54, 0x7F, 0x02, 0x83, 0x07, 0x90, 0xA3, 0x18, 0xE0, 0x64, 0x01, 0x60, 0x03, 0x02, 0x80, 0x57, 
+0x90, 0xA2, 0xB1, 0x12, 0x08, 0x79, 0x00, 0x00, 0xF0, 0x00, 0x90, 0xA2, 0xB5, 0x12, 0x08, 0x79, 
+0x00, 0x00, 0x50, 0x00, 0x7F, 0xB0, 0x7E, 0x0C, 0xD1, 0x88, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 
+0xF0, 0x90, 0xA2, 0xB5, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 0x40, 0x7F, 0xB0, 0x7E, 0x0C, 0xD1, 
+0x92, 0x90, 0x04, 0x54, 0xE0, 0x44, 0x80, 0x12, 0x83, 0x07, 0x90, 0xA2, 0xB1, 0x12, 0x08, 0x79, 
+0x30, 0x00, 0x00, 0x00, 0x90, 0xA2, 0xB5, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 0x00, 0x74, 0x08, 
+0xFF, 0xFE, 0x12, 0x7E, 0x88, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 0x0E, 0x90, 0xA2, 0xB5, 0x12, 
+0x08, 0x79, 0x00, 0x00, 0x00, 0x06, 0x7F, 0x30, 0x12, 0x7E, 0x86, 0x12, 0x08, 0x79, 0x00, 0x00, 
+0x00, 0x03, 0x90, 0xA2, 0xB5, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 0x02, 0x7F, 0x34, 0x12, 0x7E, 
+0x86, 0x12, 0x08, 0x79, 0x00, 0x00, 0x0F, 0x00, 0x90, 0xA2, 0xB5, 0x12, 0x08, 0x79, 0x00, 0x00, 
+0x01, 0x00, 0x51, 0xEB, 0x12, 0x08, 0x79, 0x30, 0x00, 0x00, 0x00, 0x90, 0xA2, 0xB5, 0x12, 0x08, 
+0x79, 0x20, 0x00, 0x00, 0x00, 0x71, 0x00, 0x22, 0x90, 0xA3, 0x2B, 0xED, 0xF0, 0xEF, 0x60, 0x02, 
+0x21, 0x30, 0xE0, 0x24, 0xFD, 0x50, 0x0A, 0x60, 0x1E, 0x14, 0x60, 0x31, 0x14, 0x60, 0x73, 0x41, 
+0xD4, 0x90, 0xAA, 0xB9, 0x12, 0x08, 0x79, 0x77, 0x77, 0x77, 0x77, 0x12, 0x76, 0xDD, 0x12, 0x08, 
+0x79, 0x77, 0x77, 0x77, 0x77, 0x21, 0xAA, 0x90, 0xAA, 0xB9, 0x12, 0x08, 0x79, 0x54, 0x33, 0x77, 
+0x70, 0x12, 0x76, 0xDD, 0x12, 0x08, 0x79, 0x54, 0x33, 0x77, 0x70, 0x41, 0x34, 0x90, 0xAA, 0xB9, 
+0x12, 0x08, 0x79, 0x77, 0x77, 0x77, 0x77, 0x12, 0x76, 0xDD, 0x12, 0x08, 0x79, 0x77, 0x77, 0x77, 
+0x77, 0x7F, 0xB0, 0x7E, 0x0E, 0x51, 0xD9, 0x12, 0x08, 0x79, 0x3F, 0xF0, 0x00, 0x00, 0x90, 0xA2, 
+0xB5, 0x12, 0x08, 0x79, 0x00, 0x10, 0x00, 0x00, 0x7F, 0xB4, 0x7E, 0x0C, 0x12, 0x7E, 0x88, 0x12, 
+0x08, 0x79, 0x3F, 0xF0, 0x00, 0x00, 0x90, 0xA2, 0xB5, 0x12, 0x08, 0x79, 0x00, 0x10, 0x00, 0x00, 
+0x41, 0xCD, 0x90, 0xA2, 0xB1, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 0xFF, 0x90, 0xA2, 0xB5, 0x12, 
+0x08, 0x79, 0x00, 0x00, 0x00, 0x77, 0x51, 0xE0, 0x12, 0x08, 0x79, 0x77, 0x77, 0x77, 0x77, 0x7F, 
+0xB0, 0x7E, 0x0E, 0x51, 0xD9, 0x12, 0x08, 0x79, 0x01, 0x00, 0x00, 0x00, 0x90, 0xA2, 0xB5, 0x12, 
+0x08, 0x79, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xB4, 0x7E, 0x0C, 0x12, 0x7E, 0x88, 0x12, 0x08, 0x79, 
+0x3F, 0xF0, 0x00, 0x00, 0x90, 0xA2, 0xB5, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 0x00, 0x41, 0xCD, 
+0x90, 0xA3, 0x2B, 0xE0, 0x14, 0x60, 0x5F, 0x14, 0x70, 0x02, 0x21, 0xDB, 0x14, 0x70, 0x02, 0x41, 
+0x20, 0x14, 0x70, 0x02, 0x21, 0xDB, 0x14, 0x70, 0x02, 0x41, 0x81, 0x24, 0x05, 0x60, 0x02, 0x41, 
+0xD4, 0x90, 0xAA, 0xB9, 0x12, 0x08, 0x79, 0x77, 0x33, 0x77, 0x17, 0x12, 0x76, 0xDD, 0x12, 0x08, 
+0x79, 0x77, 0x33, 0x77, 0x17, 0x7F, 0xB0, 0x7E, 0x0E, 0x51, 0xD9, 0x12, 0x08, 0x79, 0x3F, 0xF0, 
+0x00, 0x00, 0x90, 0xA2, 0xB5, 0x12, 0x08, 0x79, 0x01, 0x00, 0x00, 0x00, 0x7F, 0xB4, 0x7E, 0x0C, 
+0x12, 0x7E, 0x88, 0x12, 0x08, 0x79, 0x3F, 0xF0, 0x00, 0x00, 0x90, 0xA2, 0xB5, 0x12, 0x08, 0x79, 
+0x01, 0x00, 0x00, 0x00, 0x41, 0xCD, 0x90, 0xAA, 0xB9, 0x12, 0x08, 0x79, 0x77, 0x33, 0x77, 0x17, 
+0x12, 0x76, 0xDD, 0x12, 0x08, 0x79, 0x77, 0x33, 0x77, 0x17, 0x7F, 0xB0, 0x7E, 0x0E, 0x51, 0xD9, 
+0x12, 0x08, 0x79, 0x3F, 0xF0, 0x00, 0x00, 0x90, 0xA2, 0xB5, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 
+0x00, 0x7F, 0xB4, 0x7E, 0x0C, 0x12, 0x7E, 0x88, 0x12, 0x08, 0x79, 0x3F, 0xF0, 0x00, 0x00, 0x90, 
+0xA2, 0xB5, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 0x00, 0x41, 0xCD, 0x90, 0xAA, 0xB9, 0x12, 0x08, 
+0x79, 0x77, 0x33, 0x77, 0x77, 0x12, 0x76, 0xDD, 0x12, 0x08, 0x79, 0x77, 0x33, 0x77, 0x77, 0x7F, 
+0xB0, 0x7E, 0x0E, 0x51, 0xD9, 0x12, 0x08, 0x79, 0x3F, 0xF0, 0x00, 0x00, 0x90, 0xA2, 0xB5, 0x12, 
+0x08, 0x79, 0x01, 0x00, 0x00, 0x00, 0x7F, 0xB4, 0x7E, 0x0C, 0x12, 0x7E, 0x88, 0x12, 0x08, 0x79, 
+0x3F, 0xF0, 0x00, 0x00, 0x90, 0xA2, 0xB5, 0x12, 0x08, 0x79, 0x01, 0x00, 0x00, 0x00, 0x41, 0xCD, 
+0x90, 0xAA, 0xB9, 0x12, 0x08, 0x79, 0x54, 0x33, 0x77, 0x17, 0x12, 0x76, 0xDD, 0x12, 0x08, 0x79, 
+0x54, 0x33, 0x77, 0x17, 0x7F, 0xB0, 0x7E, 0x0E, 0x51, 0xD9, 0x12, 0x08, 0x79, 0x3F, 0xF0, 0x00, 
+0x00, 0x90, 0xA2, 0xB5, 0x12, 0x08, 0x79, 0x01, 0x00, 0x00, 0x00, 0x7F, 0xB4, 0x7E, 0x0C, 0x12, 
+0x7E, 0x88, 0x12, 0x08, 0x79, 0x3F, 0xF0, 0x00, 0x00, 0x90, 0xA2, 0xB5, 0x12, 0x08, 0x79, 0x01, 
+0x00, 0x00, 0x00, 0x7F, 0xB4, 0x7E, 0x0E, 0x12, 0x7E, 0x88, 0x12, 0x08, 0x79, 0x00, 0x00, 0x03, 
+0x03, 0x90, 0xA2, 0xB5, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 0x01, 0x7F, 0x00, 0x7E, 0x09, 0x80, 
+0x50, 0x90, 0xA2, 0xB1, 0x12, 0x08, 0x79, 0x00, 0xFF, 0x00, 0x00, 0x90, 0xA2, 0xB5, 0x12, 0x08, 
+0x79, 0x00, 0x33, 0x00, 0x00, 0x51, 0xE0, 0x12, 0x08, 0x79, 0x77, 0x33, 0x77, 0x77, 0x7F, 0xB0, 
+0x7E, 0x0E, 0x51, 0xD9, 0x12, 0x08, 0x79, 0x01, 0x00, 0x00, 0x00, 0x90, 0xA2, 0xB5, 0x12, 0x08, 
+0x79, 0x01, 0x00, 0x00, 0x00, 0x7F, 0xB4, 0x7E, 0x0C, 0x12, 0x7E, 0x88, 0x12, 0x08, 0x79, 0x3F, 
+0xF0, 0x00, 0x00, 0x90, 0xA2, 0xB5, 0x12, 0x08, 0x79, 0x01, 0x00, 0x00, 0x00, 0x7F, 0xB4, 0x7E, 
+0x0E, 0x12, 0x7E, 0x92, 0x22, 0x7F, 0x84, 0x7E, 0x09, 0x12, 0x38, 0x07, 0x90, 0xA2, 0xB1, 0x22, 
+0x7F, 0xB0, 0x7E, 0x0C, 0x12, 0x7E, 0x92, 0x90, 0xAA, 0xB9, 0x22, 0x7F, 0x1C, 0x7E, 0x0C, 0x12, 
+0x7E, 0x92, 0x90, 0xA3, 0x18, 0xE0, 0xFF, 0xA3, 0xE0, 0xFD, 0x11, 0x58, 0x90, 0xA2, 0xB1, 0x22, 
+0x74, 0x08, 0xFF, 0xFE, 0x02, 0x7E, 0x92, 0x90, 0xA3, 0x1A, 0xF0, 0xE0, 0x90, 0x04, 0x54, 0xF0, 
+0x22, 0x90, 0x02, 0x09, 0x71, 0x54, 0x90, 0x9E, 0x98, 0xF0, 0x12, 0x74, 0x1C, 0x25, 0x51, 0x90, 
+0x9E, 0x99, 0x12, 0x4F, 0x48, 0x25, 0x51, 0x90, 0x9E, 0x9A, 0x12, 0x57, 0x1A, 0x25, 0x51, 0x90, 
+0x9E, 0x9B, 0xF0, 0x90, 0x00, 0x04, 0x12, 0x06, 0xA2, 0x25, 0x51, 0x90, 0x9E, 0x9C, 0xF0, 0x90, 
+0x00, 0x05, 0x12, 0x06, 0xA2, 0x25, 0x51, 0x90, 0x9E, 0x9D, 0x12, 0x67, 0xCE, 0x25, 0x51, 0x90, 
+0x9E, 0x9E, 0xF0, 0x22, 0xE0, 0xF5, 0x51, 0x12, 0x06, 0x89, 0x25, 0x51, 0x22, 0x12, 0x06, 0x89, 
+0xFF, 0x90, 0x9F, 0x8B, 0xF0, 0xBF, 0x01, 0x08, 0x12, 0x7C, 0x22, 0xE4, 0x90, 0x9F, 0x8B, 0xF0, 
+0x22, 0x12, 0x06, 0x89, 0x54, 0x01, 0xFF, 0x90, 0xA1, 0x3A, 0xE0, 0x54, 0xFE, 0x4F, 0xF0, 0x22, 
+0x12, 0x4F, 0x49, 0xFF, 0x30, 0xE0, 0x1F, 0x12, 0x06, 0x89, 0x90, 0xA0, 0x4B, 0xF0, 0x12, 0x74, 
+0x1C, 0x90, 0xA0, 0x4C, 0xF0, 0xEF, 0x54, 0xFE, 0xFF, 0xA3, 0xE0, 0x54, 0x01, 0x4F, 0x12, 0x57, 
+0x1A, 0x90, 0xA0, 0x4E, 0xF0, 0x22, 0x90, 0xA0, 0x4B, 0x74, 0x02, 0xF0, 0xA3, 0x74, 0x0A, 0xF0, 
+0xA3, 0xE0, 0x54, 0x01, 0x44, 0x1E, 0xF0, 0xA3, 0x74, 0x05, 0xF0, 0x22, 0x12, 0x06, 0x89, 0x90, 
+0x9F, 0xB2, 0xF0, 0x22, 0x12, 0x06, 0x89, 0x90, 0xA0, 0x51, 0xF0, 0x22, 0x91, 0x48, 0x90, 0xA0, 
+0x56, 0xE0, 0x54, 0xFE, 0x4E, 0xF0, 0xEF, 0x54, 0x02, 0x33, 0x33, 0x33, 0x54, 0xF8, 0xFF, 0x90, 
+0x9F, 0xA3, 0xE0, 0x54, 0xEF, 0x4F, 0xF0, 0x90, 0xA0, 0x56, 0xE0, 0x54, 0x01, 0xFF, 0xEF, 0x64, 
+0x01, 0x70, 0x21, 0x91, 0x69, 0x90, 0x01, 0x38, 0x12, 0x4F, 0x3E, 0x90, 0x01, 0x30, 0x12, 0x4F, 
+0x3F, 0x90, 0x01, 0x30, 0x74, 0x10, 0xF0, 0x90, 0x01, 0x39, 0x74, 0x01, 0xF0, 0x90, 0x00, 0x53, 
+0x74, 0x80, 0xF0, 0x22, 0x91, 0x50, 0x90, 0xA0, 0x5C, 0xE0, 0x90, 0x01, 0x31, 0xF0, 0x90, 0xA0, 
+0x5D, 0xE0, 0x90, 0x01, 0x32, 0xF0, 0x90, 0xA0, 0x5E, 0xE0, 0x90, 0x01, 0x33, 0xF0, 0x90, 0xA0, 
+0x57, 0xE0, 0x90, 0x01, 0x38, 0xF0, 0x90, 0xA0, 0x5A, 0xE0, 0x90, 0x01, 0x3B, 0x12, 0x70, 0xCB, 
+0x7F, 0x01, 0x12, 0x5A, 0x33, 0x02, 0x5D, 0x9F, 0x12, 0x06, 0x89, 0xFF, 0x54, 0x01, 0xFE, 0x22, 
+0x90, 0xA0, 0x5B, 0xE0, 0x90, 0x01, 0x30, 0xF0, 0x90, 0xA0, 0x58, 0xE0, 0x90, 0x01, 0x39, 0xF0, 
+0x90, 0xA0, 0x59, 0xE0, 0x90, 0x01, 0x3A, 0xF0, 0x22, 0x7D, 0x2D, 0x12, 0x52, 0xA1, 0x90, 0x01, 
+0x37, 0x74, 0x02, 0xF0, 0xFD, 0x7F, 0x03, 0x12, 0x70, 0xD6, 0x12, 0x4B, 0xB6, 0xE4, 0xFD, 0x7F, 
+0x01, 0x12, 0x5A, 0x8B, 0xE4, 0x90, 0x9F, 0xA2, 0xF0, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 
+0xD0, 0x90, 0x9E, 0xF0, 0xE0, 0xFF, 0x90, 0x9E, 0xEF, 0xE0, 0xB5, 0x07, 0x04, 0x7F, 0x01, 0x80, 
+0x02, 0x7F, 0x00, 0xEF, 0x70, 0x39, 0x90, 0x9E, 0xEF, 0xE0, 0xFE, 0x91, 0xEB, 0xE0, 0xFD, 0xEE, 
+0x75, 0xF0, 0x08, 0xA4, 0x24, 0xA0, 0xF9, 0x74, 0x9E, 0x35, 0xF0, 0xFA, 0x7B, 0x01, 0xAF, 0x05, 
+0x12, 0x74, 0x81, 0x90, 0x9E, 0xEF, 0x91, 0xE4, 0xB4, 0x0A, 0x02, 0x7F, 0x01, 0xEF, 0x60, 0x05, 
+0xE4, 0x90, 0x9E, 0xEF, 0xF0, 0x12, 0x6D, 0x54, 0x90, 0x9E, 0x92, 0xE0, 0x44, 0x02, 0xF0, 0xD0, 
+0xD0, 0x92, 0xAF, 0x22, 0xE0, 0x04, 0xF0, 0xE0, 0x7F, 0x00, 0x22, 0x75, 0xF0, 0x08, 0x90, 0x9E, 
+0x9F, 0x02, 0x49, 0x54, 0xE4, 0x90, 0x9F, 0x87, 0xF0, 0xA3, 0xF0, 0x90, 0x9E, 0xEF, 0xF0, 0xA3, 
+0xF0, 0x22, 0xB1, 0x20, 0x91, 0xF4, 0x12, 0x6C, 0x22, 0x12, 0xAA, 0x3F, 0x12, 0x5D, 0x9F, 0xB1, 
+0xBB, 0x7E, 0x00, 0x7F, 0x2D, 0x7D, 0x00, 0x7B, 0x01, 0x7A, 0xA0, 0x79, 0x60, 0x02, 0x08, 0xAA, 
+0xE4, 0xFD, 0xFF, 0x12, 0xAE, 0x54, 0xED, 0x70, 0x12, 0xB1, 0x5F, 0xC0, 0x83, 0xC0, 0x82, 0xB1, 
+0x57, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0xF4, 0x5E, 0x80, 0x0F, 0xB1, 0x5F, 0xC0, 0x83, 0xC0, 
+0x82, 0xB1, 0x57, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0x4E, 0xD0, 0x82, 0xD0, 0x83, 0xF0, 0xB1, 
+0x6A, 0x90, 0x9F, 0x9C, 0xEF, 0xF0, 0x22, 0xE0, 0xFE, 0x74, 0x01, 0xA8, 0x07, 0x08, 0x22, 0x74, 
+0x8C, 0x2E, 0xF5, 0x82, 0xE4, 0x34, 0x9F, 0xF5, 0x83, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 
+0xD0, 0x7D, 0x10, 0xED, 0x14, 0xF9, 0x24, 0x8C, 0xB1, 0x62, 0xE0, 0x60, 0x35, 0x7C, 0x08, 0xEC, 
+0x14, 0x90, 0xA3, 0x29, 0xF0, 0x74, 0x8C, 0x29, 0xB1, 0x62, 0xE0, 0xFB, 0x7A, 0x00, 0x90, 0xA3, 
+0x29, 0xE0, 0xB1, 0xCC, 0x80, 0x05, 0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 0xF9, 0xB1, 0xC1, 0x60, 
+0x0F, 0xE9, 0x75, 0xF0, 0x08, 0xA4, 0xFF, 0x90, 0xA3, 0x29, 0xE0, 0x2F, 0x04, 0xFF, 0x80, 0x06, 
+0xDC, 0xCD, 0xDD, 0xBF, 0x7F, 0x00, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x12, 0xAD, 0xBF, 0x02, 0x08, 
+0xAA, 0xFF, 0xEE, 0x5A, 0xFE, 0xEF, 0x5B, 0x4E, 0x22, 0xED, 0x54, 0x07, 0xFF, 0x74, 0x01, 0x7E, 
+0x00, 0xA8, 0x07, 0x08, 0x22, 0x90, 0xA2, 0x73, 0xEF, 0xF0, 0x7E, 0x00, 0x7F, 0x10, 0x7D, 0x00, 
+0x7B, 0x01, 0x7A, 0xA2, 0x79, 0x75, 0x12, 0x08, 0xAA, 0x90, 0x9F, 0x9C, 0xE0, 0x90, 0xA2, 0x87, 
+0xF0, 0xE4, 0x90, 0xA2, 0x74, 0xF0, 0x90, 0xA2, 0x87, 0xE0, 0xFE, 0x90, 0xA2, 0x74, 0xE0, 0xFD, 
+0xC3, 0x9E, 0x50, 0x41, 0xED, 0xF1, 0x88, 0xED, 0x54, 0x07, 0xA3, 0xF0, 0x75, 0xF0, 0x10, 0xED, 
+0xF1, 0x2C, 0xE0, 0x30, 0xE7, 0x09, 0x74, 0x81, 0x2D, 0xF1, 0x0E, 0xE4, 0xF0, 0x80, 0x1E, 0xAF, 
+0x05, 0xF1, 0x81, 0xF1, 0x9E, 0xC0, 0x83, 0xC0, 0x82, 0xE0, 0xFF, 0x90, 0xA2, 0x86, 0x12, 0x6F, 
+0xDC, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0x4F, 0xD0, 0x82, 0xD0, 0x83, 0xF0, 0x90, 0xA2, 0x74, 
+0xE0, 0x04, 0xF0, 0x80, 0xB1, 0x7F, 0x0C, 0x7E, 0x00, 0x12, 0x3D, 0x7A, 0xE4, 0x90, 0xA2, 0x74, 
+0xF0, 0x90, 0xA2, 0x87, 0xE0, 0xFF, 0x90, 0xA2, 0x74, 0xE0, 0xFE, 0xC3, 0x9F, 0x40, 0x02, 0xE1, 
+0x07, 0xEE, 0xF1, 0x88, 0xEE, 0x54, 0x07, 0xA3, 0xF0, 0xE0, 0xB1, 0xCC, 0x80, 0x05, 0xC3, 0x33, 
+0xCE, 0x33, 0xCE, 0xD8, 0xF9, 0x4E, 0x7F, 0x00, 0x70, 0x02, 0x7F, 0x01, 0xF1, 0x9E, 0xE0, 0x5F, 
+0x70, 0x7D, 0xF1, 0x16, 0x90, 0x81, 0x06, 0xF1, 0x1F, 0xEF, 0x90, 0x81, 0x07, 0xF1, 0x92, 0xFC, 
+0x25, 0xE0, 0x24, 0x01, 0xF5, 0x82, 0xE4, 0x34, 0x92, 0x12, 0x95, 0xAF, 0x75, 0xF0, 0x10, 0xEC, 
+0x90, 0x81, 0x0A, 0xF1, 0x1F, 0xEC, 0x90, 0x81, 0x0B, 0xF1, 0x92, 0x75, 0xF0, 0x0A, 0xF1, 0x08, 
+0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x7F, 0x01, 0x90, 0xA2, 0x74, 0xE0, 0xFE, 0x75, 0xF0, 0x10, 0x90, 
+0x81, 0x0B, 0x12, 0x6B, 0xFA, 0xE0, 0xFD, 0x75, 0xF0, 0x0A, 0xEE, 0xF1, 0x08, 0x75, 0xF0, 0x02, 
+0xEF, 0xF1, 0x7A, 0xED, 0xF0, 0x0F, 0xEF, 0xB4, 0x05, 0xDD, 0xF1, 0x16, 0x90, 0x81, 0x09, 0x12, 
+0x49, 0x54, 0xE0, 0xFE, 0xF1, 0xBD, 0xEE, 0xF0, 0x90, 0xA2, 0x74, 0xE0, 0xFF, 0x90, 0xA2, 0x73, 
+0xE0, 0xFD, 0xF1, 0x32, 0x90, 0xA2, 0x74, 0xE0, 0x24, 0x81, 0xF1, 0x0E, 0x74, 0x01, 0xF0, 0x90, 
+0xA2, 0x74, 0xE0, 0x04, 0xF0, 0xC1, 0x51, 0x22, 0x90, 0x8D, 0x01, 0x02, 0x49, 0x54, 0xF5, 0x82, 
+0xE4, 0x34, 0x93, 0xF5, 0x83, 0x22, 0x90, 0xA2, 0x74, 0xE0, 0xFF, 0x75, 0xF0, 0x10, 0x22, 0x12, 
+0x49, 0x54, 0xE0, 0xFD, 0x75, 0xF0, 0x10, 0x22, 0x75, 0xF0, 0x10, 0xEF, 0x90, 0x81, 0x03, 0x02, 
+0x49, 0x54, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0xED, 0x60, 0x21, 0x75, 0xF0, 0x0A, 0xEF, 
+0x90, 0x8D, 0x01, 0xF1, 0x6E, 0x90, 0x8D, 0x03, 0xF1, 0x6E, 0x90, 0x8D, 0x05, 0xF1, 0x6E, 0x90, 
+0x8D, 0x07, 0xF1, 0x6E, 0x90, 0x8D, 0x09, 0xF1, 0x7A, 0xF1, 0xAC, 0xE4, 0xF0, 0xF1, 0x28, 0xE0, 
+0x54, 0xBF, 0x44, 0x80, 0xFE, 0xF1, 0x28, 0xEE, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x12, 0x49, 
+0x54, 0xE4, 0xF0, 0xA3, 0xF0, 0x75, 0xF0, 0x0A, 0xEF, 0x22, 0x12, 0x49, 0x54, 0xE4, 0xF0, 0xA3, 
+0x22, 0xF1, 0x28, 0xE0, 0x44, 0x40, 0xF0, 0x22, 0x13, 0x13, 0x13, 0x54, 0x1F, 0x90, 0xA2, 0x85, 
+0xF0, 0x22, 0x12, 0x49, 0x54, 0xE0, 0xFE, 0xED, 0xFF, 0x90, 0xA2, 0x74, 0xE0, 0x22, 0x90, 0xA2, 
+0x85, 0xE0, 0x24, 0x75, 0xF5, 0x82, 0xE4, 0x34, 0xA2, 0xF5, 0x83, 0x22, 0xF0, 0xEF, 0x25, 0xE0, 
+0x24, 0x01, 0xF5, 0x82, 0xE4, 0x34, 0x92, 0xF5, 0x83, 0xE4, 0xF0, 0xA3, 0xF0, 0x74, 0x91, 0x2F, 
+0xF5, 0x82, 0xE4, 0x34, 0x98, 0xF5, 0x83, 0x22, 0xE4, 0xFF, 0xA1, 0xD5, 0x12, 0xAD, 0x30, 0xE0, 
+0x54, 0xFB, 0xF0, 0x22, 0x12, 0xAD, 0x30, 0xE0, 0x44, 0x04, 0xF0, 0x22, 0x90, 0xA2, 0x01, 0xEF, 
+0xF0, 0x90, 0x04, 0x7E, 0xE0, 0xF5, 0x65, 0xA3, 0xE0, 0xF5, 0x66, 0x65, 0x65, 0x60, 0x6C, 0x90, 
+0xA2, 0x02, 0x74, 0x03, 0xF0, 0x90, 0xA2, 0x10, 0x74, 0x08, 0xF0, 0xE5, 0x66, 0x04, 0x54, 0x0F, 
+0xF5, 0x67, 0xE4, 0xF5, 0x64, 0xE5, 0x67, 0x75, 0xF0, 0x08, 0xA4, 0x24, 0x00, 0xF5, 0x82, 0xE4, 
+0x34, 0x80, 0xF5, 0x83, 0xE5, 0x82, 0x25, 0x64, 0x12, 0x6C, 0x00, 0xE0, 0xFF, 0x74, 0x04, 0x25, 
+0x64, 0xF5, 0x82, 0xE4, 0x34, 0xA2, 0xF5, 0x83, 0xEF, 0xF0, 0x05, 0x64, 0xE5, 0x64, 0xB4, 0x08, 
+0xD4, 0x7B, 0x01, 0x7A, 0xA2, 0x79, 0x02, 0x12, 0x7B, 0x25, 0xE5, 0x66, 0x04, 0x54, 0x0F, 0xF5, 
+0x66, 0xB4, 0x0F, 0x03, 0xE4, 0xF5, 0x66, 0x90, 0x04, 0x7F, 0xE5, 0x66, 0xF0, 0x90, 0xA2, 0x01, 
+0xE0, 0x7F, 0x04, 0x70, 0x03, 0x02, 0x6F, 0xE8, 0x12, 0x75, 0x96, 0x22, 0xE4, 0xFF, 0x02, 0x87, 
+0xDC, 0x90, 0xA3, 0x0F, 0x12, 0x49, 0x69, 0xE4, 0xFF, 0x90, 0xA3, 0x0F, 0x12, 0x49, 0x60, 0x8F, 
+0x82, 0x12, 0x67, 0xE5, 0xFE, 0x74, 0xF0, 0x2F, 0x11, 0x82, 0xEE, 0xF0, 0x0F, 0xEF, 0xB4, 0x10, 
+0xE8, 0x22, 0xF5, 0x82, 0xE4, 0x34, 0x02, 0xF5, 0x83, 0x22, 0x75, 0x15, 0x12, 0xE4, 0xF5, 0x16, 
+0x75, 0x17, 0x07, 0x75, 0x18, 0x72, 0x90, 0x01, 0x30, 0xE5, 0x15, 0xF0, 0xA3, 0xE5, 0x16, 0xF0, 
+0xA3, 0xE5, 0x17, 0xF0, 0xA3, 0xE5, 0x18, 0xF0, 0x22, 0x75, 0x1D, 0x06, 0x75, 0x1E, 0x01, 0x75, 
+0x1F, 0x03, 0x75, 0x20, 0x62, 0x90, 0x01, 0x38, 0xE5, 0x1D, 0xF0, 0xA3, 0xE5, 0x1E, 0xF0, 0xA3, 
+0xE5, 0x1F, 0xF0, 0xA3, 0xE5, 0x20, 0xF0, 0x22, 0x90, 0x01, 0x94, 0xE0, 0x44, 0x01, 0xF0, 0x90, 
+0x01, 0xC7, 0xE4, 0xF0, 0x22, 0x90, 0x01, 0x01, 0xE0, 0x44, 0x04, 0xF0, 0x90, 0x01, 0x9A, 0xE0, 
+0x54, 0xC0, 0x12, 0x79, 0x5B, 0x90, 0x01, 0x99, 0xE0, 0x44, 0xC0, 0xF0, 0x90, 0x01, 0x9B, 0x74, 
+0x80, 0xF0, 0x22, 0x7D, 0x02, 0x90, 0x01, 0xC4, 0x74, 0xF3, 0xF0, 0x74, 0x88, 0xA3, 0xF0, 0x90, 
+0xA0, 0x5F, 0xE0, 0xFF, 0xED, 0xC3, 0x9F, 0x50, 0x14, 0xED, 0x25, 0xE0, 0x24, 0x81, 0xF8, 0xE6, 
+0x30, 0xE4, 0x07, 0x31, 0x2B, 0xA3, 0xF0, 0x7F, 0x00, 0x22, 0x0D, 0x80, 0xE2, 0x74, 0xF3, 0x04, 
+0x90, 0x01, 0xC4, 0xF0, 0x74, 0x88, 0xA3, 0xF0, 0x7F, 0x01, 0x22, 0x90, 0x01, 0xB8, 0x74, 0x08, 
+0xF0, 0x22, 0x12, 0x5F, 0x97, 0xEF, 0x64, 0x01, 0x60, 0x04, 0x31, 0xC9, 0x21, 0xC0, 0x90, 0x9F, 
+0xAB, 0xE0, 0xFF, 0x54, 0x03, 0x60, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x02, 0xF0, 0x80, 0x71, 0x90, 
+0x9F, 0xA9, 0xE0, 0xFE, 0xE4, 0xC3, 0x9E, 0x50, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x04, 0xF0, 0x80, 
+0x5F, 0xEF, 0x30, 0xE2, 0x04, 0x31, 0x2B, 0x80, 0x57, 0x90, 0x9F, 0xAB, 0xE0, 0x30, 0xE4, 0x08, 
+0x90, 0x01, 0xB8, 0x74, 0x10, 0xF0, 0x80, 0x48, 0x90, 0x9F, 0xA4, 0xE0, 0x13, 0x13, 0x54, 0x3F, 
+0x20, 0xE0, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x20, 0xF0, 0x80, 0x35, 0x90, 0xA0, 0x51, 0xE0, 0x60, 
+0x08, 0x90, 0x01, 0xB8, 0x74, 0x80, 0xF0, 0x80, 0x27, 0x90, 0x06, 0x62, 0xE0, 0x30, 0xE1, 0x08, 
+0x90, 0x01, 0xB8, 0x74, 0x11, 0xF0, 0x80, 0x18, 0x90, 0x06, 0x62, 0xE0, 0x30, 0xE0, 0x0F, 0xE0, 
+0x54, 0xFC, 0xFF, 0xBF, 0x80, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x12, 0xF0, 0x80, 0x02, 0x80, 0x4B, 
+0x90, 0x01, 0xB9, 0x74, 0x04, 0xF0, 0x7F, 0x00, 0x22, 0x90, 0x01, 0xB8, 0x74, 0x01, 0xF0, 0x22, 
+0x90, 0xA0, 0x52, 0xE0, 0xC3, 0x13, 0x20, 0xE0, 0x27, 0x90, 0x02, 0x87, 0xE0, 0x60, 0x04, 0x31, 
+0xC9, 0x80, 0x1F, 0x90, 0x02, 0x96, 0xE0, 0x60, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x10, 0xF0, 0x80, 
+0x11, 0x90, 0x02, 0x86, 0xE0, 0x20, 0xE1, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x04, 0xF0, 0x80, 0x02, 
+0x80, 0x09, 0x90, 0x01, 0xB9, 0x74, 0x08, 0xF0, 0x7F, 0x00, 0x22, 0x90, 0x01, 0xB8, 0xE4, 0xF0, 
+0x7F, 0x01, 0x22, 0x90, 0x9F, 0xAA, 0xE0, 0xFF, 0x60, 0x03, 0xB4, 0x08, 0x0D, 0x31, 0xD0, 0xBF, 
+0x01, 0x08, 0x51, 0x58, 0x90, 0x01, 0xE5, 0xE0, 0x04, 0xF0, 0x22, 0x90, 0x9F, 0xA3, 0xE0, 0x30, 
+0xE0, 0x18, 0x90, 0x9F, 0x9E, 0xE0, 0xFF, 0x30, 0xE0, 0x0E, 0xC3, 0x13, 0x30, 0xE0, 0x07, 0x51, 
+0x4B, 0xBF, 0x01, 0x06, 0x80, 0x02, 0x80, 0x00, 0x51, 0x13, 0x22, 0x90, 0x9F, 0xA1, 0xE0, 0x64, 
+0x02, 0x7F, 0x01, 0x60, 0x02, 0x7F, 0x00, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x12, 
+0x4D, 0xAA, 0x12, 0x4F, 0xC3, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xE4, 0x90, 0x9E, 0x92, 0x12, 0x4F, 
+0x3F, 0xA3, 0xF0, 0x22, 0x90, 0x01, 0xE4, 0x74, 0x1C, 0xF0, 0xA3, 0xE4, 0xF0, 0x22, 0x90, 0x01, 
+0x34, 0xE0, 0x55, 0x15, 0xF5, 0x19, 0xA3, 0xE0, 0x55, 0x16, 0xF5, 0x1A, 0xA3, 0xE0, 0x55, 0x17, 
+0xF5, 0x1B, 0xA3, 0xE0, 0x55, 0x18, 0xF5, 0x1C, 0x90, 0x01, 0x34, 0xE5, 0x19, 0xF0, 0xA3, 0xE5, 
+0x1A, 0xF0, 0xA3, 0xE5, 0x1B, 0xF0, 0xA3, 0xE5, 0x1C, 0xF0, 0x22, 0x90, 0x01, 0x3C, 0xE0, 0x55, 
+0x1D, 0xF5, 0x21, 0xA3, 0xE0, 0x55, 0x1E, 0xF5, 0x22, 0xA3, 0xE0, 0x55, 0x1F, 0xF5, 0x23, 0xA3, 
+0xE0, 0x55, 0x20, 0xF5, 0x24, 0x90, 0x01, 0x3C, 0xE5, 0x21, 0xF0, 0xA3, 0xE5, 0x22, 0xF0, 0xA3, 
+0xE5, 0x23, 0xF0, 0xA3, 0xE5, 0x24, 0xF0, 0x53, 0x91, 0xDF, 0x22, 0x90, 0x01, 0xCF, 0xE0, 0x90, 
+0xA2, 0x01, 0xF0, 0xE0, 0xFF, 0x30, 0xE0, 0x07, 0x90, 0x01, 0xCF, 0xE0, 0x54, 0xFE, 0xF0, 0xEF, 
+0x30, 0xE5, 0x23, 0x90, 0x01, 0xCF, 0xE0, 0x54, 0xDF, 0xF0, 0x90, 0x01, 0x34, 0x74, 0x20, 0xF0, 
+0xE4, 0xF5, 0xA8, 0xF5, 0xE8, 0x12, 0x4E, 0xFA, 0x90, 0x00, 0x03, 0xE0, 0x54, 0xFB, 0xFD, 0x7F, 
+0x03, 0x12, 0x4A, 0x9C, 0x80, 0xFE, 0x22, 0x90, 0x9F, 0x9E, 0xE0, 0x30, 0xE0, 0x05, 0xE4, 0xA3, 
+0xF0, 0xA3, 0xF0, 0x22, 0x90, 0x9F, 0x9E, 0xE0, 0x30, 0xE0, 0x10, 0xA3, 0x74, 0x01, 0xF0, 0x90, 
+0x9F, 0x9E, 0xE0, 0xFF, 0xC3, 0x13, 0x30, 0xE0, 0x02, 0xB1, 0xF4, 0xE4, 0xF5, 0x64, 0x90, 0x9F, 
+0xA7, 0xE0, 0x70, 0x02, 0x61, 0xCB, 0x91, 0x45, 0x60, 0x02, 0x61, 0xCB, 0x91, 0x5A, 0xCE, 0xC3, 
+0x13, 0xCE, 0x13, 0xD8, 0xF9, 0x91, 0x4E, 0x12, 0x73, 0xE4, 0x60, 0x22, 0x24, 0xFE, 0x60, 0x03, 
+0x04, 0x70, 0x1E, 0x90, 0x9F, 0xAE, 0xE0, 0x14, 0xF0, 0xE0, 0xFF, 0x60, 0x06, 0x90, 0x9F, 0xB0, 
+0xE0, 0x60, 0x0E, 0xEF, 0x70, 0x08, 0x90, 0x9F, 0xAD, 0xE0, 0xA3, 0xF0, 0x80, 0x00, 0x75, 0x64, 
+0x01, 0x90, 0x9F, 0x9E, 0xE0, 0x30, 0xE0, 0x12, 0x90, 0x9F, 0xA2, 0xE0, 0xB4, 0x02, 0x03, 0xE4, 
+0xF5, 0x64, 0x12, 0x5E, 0xFE, 0xEF, 0x70, 0x02, 0xF5, 0x64, 0xE5, 0x64, 0x60, 0x2D, 0x71, 0xD6, 
+0x90, 0x9F, 0xB0, 0xE0, 0x60, 0x03, 0xB4, 0x01, 0x04, 0x71, 0xCC, 0x80, 0x08, 0x71, 0xCC, 0x75, 
+0xF0, 0x03, 0xA4, 0x24, 0xFE, 0xFF, 0x90, 0x9F, 0xAF, 0xE0, 0x2F, 0x90, 0xA2, 0xD5, 0x12, 0x50, 
+0x26, 0x90, 0x9F, 0xAA, 0xE0, 0x20, 0xE2, 0x03, 0x12, 0x58, 0x63, 0x22, 0xE4, 0x90, 0xA2, 0xD4, 
+0xF0, 0x90, 0x9F, 0xB0, 0xE0, 0x22, 0x90, 0x9F, 0xAB, 0xE0, 0x44, 0x10, 0xF0, 0x22, 0xE4, 0x90, 
+0xA2, 0x11, 0xF0, 0x90, 0x9F, 0xA7, 0xE0, 0x60, 0x5B, 0x91, 0x45, 0x70, 0x57, 0xD1, 0xC5, 0x91, 
+0x59, 0xCE, 0xC3, 0x13, 0xCE, 0x13, 0xD8, 0xF9, 0x91, 0x4E, 0xF0, 0x90, 0xA2, 0x11, 0x74, 0x01, 
+0xF0, 0xE4, 0x90, 0x9F, 0xAE, 0xF0, 0x90, 0x9F, 0x9E, 0xE0, 0x30, 0xE0, 0x16, 0x90, 0x9F, 0xA2, 
+0xE0, 0xB4, 0x02, 0x05, 0xE4, 0x90, 0xA2, 0x11, 0xF0, 0x12, 0x5E, 0xFE, 0xEF, 0x70, 0x04, 0x90, 
+0xA2, 0x11, 0xF0, 0x90, 0xA2, 0x11, 0xE0, 0x60, 0x1B, 0x71, 0xD6, 0xE4, 0x90, 0xA2, 0xD4, 0xF0, 
+0x90, 0x9F, 0xAF, 0xE0, 0x90, 0xA2, 0xD5, 0x12, 0x50, 0x26, 0x90, 0x9F, 0xAA, 0xE0, 0x20, 0xE2, 
+0x03, 0x12, 0x58, 0x63, 0x22, 0xE4, 0xFF, 0x12, 0x72, 0xA6, 0xEF, 0x64, 0x01, 0x22, 0xFF, 0xEE, 
+0x54, 0x3F, 0x90, 0x9F, 0xE2, 0xF0, 0xA3, 0xEF, 0x22, 0xF0, 0x90, 0x05, 0x62, 0xE0, 0xFE, 0x90, 
+0x05, 0x61, 0xE0, 0xFD, 0xED, 0x78, 0x02, 0x22, 0x91, 0x45, 0x70, 0x0D, 0x90, 0x9F, 0xA7, 0xE0, 
+0x60, 0x07, 0x91, 0x94, 0xF1, 0x85, 0x12, 0x50, 0x26, 0x22, 0x91, 0x45, 0x70, 0x15, 0x90, 0x9F, 
+0xA7, 0xE0, 0x60, 0x0F, 0x91, 0x94, 0x90, 0x9F, 0xA3, 0xE0, 0xB1, 0x1F, 0x54, 0x07, 0x70, 0x03, 
+0x12, 0x58, 0x4F, 0x22, 0x90, 0x01, 0x57, 0xE4, 0xF0, 0x90, 0x01, 0x3C, 0x74, 0x02, 0xF0, 0x22, 
+0x90, 0x01, 0x57, 0xE0, 0x60, 0x18, 0x91, 0x97, 0xB1, 0x66, 0x30, 0xE0, 0x02, 0x80, 0x6F, 0xB1, 
+0x4D, 0x40, 0x0B, 0xE4, 0xFF, 0x12, 0x72, 0xA6, 0xBF, 0x01, 0x03, 0x91, 0xBF, 0xF0, 0x22, 0x90, 
+0x9F, 0xA4, 0xE0, 0x54, 0xFB, 0x22, 0xD1, 0xCD, 0x54, 0x1F, 0x30, 0xE0, 0x0C, 0xEF, 0xC4, 0x13, 
+0x13, 0x54, 0x03, 0x30, 0xE0, 0x03, 0x12, 0x77, 0xD4, 0xB1, 0x66, 0x30, 0xE0, 0x08, 0xB1, 0x1E, 
+0x54, 0x07, 0x70, 0x39, 0x80, 0x34, 0xB1, 0x4D, 0x40, 0x30, 0x91, 0x45, 0x70, 0x2F, 0x12, 0x67, 
+0xD6, 0x70, 0x06, 0xB1, 0x2A, 0x91, 0xBF, 0xF0, 0x22, 0xB1, 0x2A, 0x90, 0x9F, 0xB1, 0xE0, 0x04, 
+0xF0, 0xE0, 0xD3, 0x94, 0x02, 0x40, 0x0A, 0x91, 0xBF, 0xF0, 0xE4, 0x90, 0x9F, 0xB1, 0xF0, 0x80, 
+0x03, 0x12, 0x5F, 0x51, 0xE4, 0x90, 0x9F, 0xB0, 0xF0, 0x22, 0x12, 0x58, 0x4F, 0x22, 0xEF, 0x54, 
+0xFB, 0xF0, 0x90, 0x9F, 0xAB, 0xE0, 0x54, 0xFD, 0xF0, 0x22, 0xB1, 0x5A, 0x40, 0x1E, 0x90, 0x9F, 
+0xC1, 0xE0, 0x04, 0xF0, 0xE0, 0xFF, 0x94, 0x04, 0x50, 0x12, 0x90, 0x9F, 0xB9, 0xEF, 0xF0, 0x25, 
+0xE0, 0x24, 0x08, 0x90, 0x9F, 0xC0, 0xF0, 0xFB, 0xD1, 0xBC, 0xD1, 0x1A, 0x22, 0x90, 0x9F, 0xB0, 
+0xE0, 0x04, 0xF0, 0x90, 0x9F, 0xAB, 0xE0, 0x54, 0xEF, 0xF0, 0x90, 0xA0, 0x4B, 0xE0, 0xFF, 0x90, 
+0x9F, 0xB0, 0xE0, 0xD3, 0x9F, 0x22, 0x90, 0x9F, 0xA3, 0xE0, 0xFF, 0x13, 0x13, 0x54, 0x3F, 0x22, 
+0xEF, 0x60, 0x39, 0x91, 0x45, 0x70, 0x35, 0x90, 0x9F, 0xA4, 0xE0, 0x54, 0xFE, 0xF0, 0x7D, 0x2B, 
+0x7F, 0x0F, 0x12, 0x52, 0x45, 0x90, 0x06, 0x04, 0xE0, 0x54, 0xBF, 0xF0, 0x12, 0x57, 0x65, 0xBF, 
+0x01, 0x15, 0x90, 0x9F, 0xA3, 0xE0, 0x44, 0x40, 0xF0, 0x7D, 0x06, 0x7F, 0x01, 0x12, 0x5A, 0x8B, 
+0x90, 0x9F, 0xA2, 0x74, 0x06, 0xF0, 0x22, 0xD1, 0xD7, 0x74, 0x08, 0xF0, 0x22, 0x90, 0x9F, 0x9E, 
+0xE0, 0xFF, 0x30, 0xE0, 0x3E, 0x90, 0x9F, 0xA2, 0xE0, 0x7E, 0x00, 0xB4, 0x02, 0x02, 0x7E, 0x01, 
+0x90, 0x9F, 0xA1, 0xE0, 0x7D, 0x00, 0xB4, 0x04, 0x02, 0x7D, 0x01, 0xED, 0x4E, 0x70, 0x24, 0xEF, 
+0xC3, 0x13, 0x30, 0xE0, 0x02, 0x80, 0x1D, 0x91, 0xA0, 0x90, 0x9F, 0xA2, 0xE0, 0xB4, 0x0C, 0x06, 
+0xE4, 0xFD, 0x7F, 0x08, 0x80, 0x0A, 0x90, 0x9F, 0xA2, 0xE0, 0xB4, 0x04, 0x06, 0xE4, 0xFD, 0xFF, 
+0x12, 0x58, 0x67, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x9F, 0x9D, 0xE0, 0xB4, 
+0x01, 0x04, 0x7F, 0x04, 0x80, 0x0C, 0x12, 0x5E, 0xFE, 0xBF, 0x01, 0x04, 0x7F, 0x01, 0x80, 0x02, 
+0x7F, 0x02, 0x12, 0x5C, 0x77, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xAC, 0x07, 0x90, 0x9F, 0xA3, 0xE0, 
+0x30, 0xE0, 0x16, 0x90, 0x9F, 0xDD, 0xE0, 0x24, 0x04, 0x90, 0x9F, 0xBC, 0xF0, 0x90, 0x9F, 0xDD, 
+0xE0, 0x24, 0x03, 0x90, 0x9F, 0xBB, 0xF0, 0x80, 0x0B, 0x90, 0x9F, 0xBC, 0x74, 0x02, 0xF0, 0x90, 
+0x9F, 0xBB, 0x14, 0xF0, 0x90, 0x9F, 0xBB, 0xE0, 0xFA, 0x90, 0x9F, 0xBA, 0xE0, 0xD3, 0x9A, 0x50, 
+0x09, 0x90, 0x9F, 0xAF, 0xEB, 0xD1, 0x7D, 0x2C, 0x80, 0x0B, 0xAD, 0x02, 0xC3, 0xED, 0x9D, 0x2B, 
+0x90, 0x9F, 0xAF, 0xD1, 0x7D, 0x90, 0x9F, 0xBF, 0xF0, 0x90, 0x9F, 0xBF, 0xE0, 0xFF, 0x7E, 0x00, 
+0x90, 0x9F, 0xB3, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0x05, 0x58, 0xF0, 0x22, 0xF0, 0x90, 0x9F, 
+0xBC, 0xE0, 0xC3, 0x9D, 0x22, 0x12, 0x93, 0x15, 0x90, 0xA2, 0x11, 0xEF, 0xF0, 0x30, 0xE0, 0x05, 
+0x7D, 0x01, 0xE4, 0x80, 0x02, 0xE4, 0xFD, 0xFF, 0x12, 0x5A, 0x8B, 0x90, 0xA2, 0x11, 0xE0, 0x30, 
+0xE6, 0x11, 0x90, 0x01, 0x2F, 0xE0, 0x30, 0xE7, 0x04, 0xE4, 0xF0, 0x80, 0x06, 0x90, 0x01, 0x2F, 
+0x74, 0x80, 0xF0, 0xD1, 0xBC, 0x90, 0x9F, 0xC0, 0xE0, 0xFB, 0xC1, 0x1A, 0x90, 0x9F, 0xB9, 0xE0, 
+0xFF, 0xA3, 0xE0, 0xFD, 0x22, 0x90, 0x9F, 0xAD, 0xE0, 0x90, 0x05, 0x73, 0x22, 0x90, 0x9F, 0xA4, 
+0xE0, 0xFF, 0x13, 0x13, 0x13, 0x22, 0xF0, 0x90, 0x01, 0xB9, 0x74, 0x01, 0xF0, 0x90, 0x01, 0xB8, 
+0x22, 0x90, 0x9F, 0xA3, 0x12, 0x5E, 0xF6, 0x30, 0xE0, 0x19, 0xEF, 0x54, 0xBF, 0xF1, 0x37, 0x30, 
+0xE0, 0x06, 0xE0, 0x44, 0x01, 0xF0, 0x80, 0x08, 0xE0, 0x54, 0xFE, 0xD1, 0xD6, 0x74, 0x04, 0xF0, 
+0x12, 0x58, 0x4F, 0x22, 0x90, 0x9F, 0xA3, 0xE0, 0xFF, 0x12, 0x4F, 0x52, 0x30, 0xE0, 0x1E, 0xEF, 
+0x54, 0x7F, 0xF1, 0x37, 0x30, 0xE1, 0x06, 0xE0, 0x44, 0x02, 0xF0, 0x80, 0x07, 0xE0, 0x54, 0xFD, 
+0xD1, 0xD6, 0x04, 0xF0, 0x90, 0x9F, 0xA7, 0xE0, 0x60, 0x03, 0x12, 0x58, 0x4F, 0x90, 0x04, 0xE0, 
+0xE0, 0x30, 0xE1, 0x02, 0xF1, 0x40, 0x22, 0xF0, 0x90, 0x04, 0xE0, 0xE0, 0x90, 0x9F, 0xA4, 0x22, 
+0x90, 0xA0, 0x60, 0xE0, 0x30, 0xE0, 0x24, 0xC3, 0x13, 0x54, 0x07, 0xF1, 0x6C, 0xE0, 0xFE, 0x30, 
+0xE0, 0x19, 0x75, 0xF0, 0x0E, 0xEF, 0xF1, 0x70, 0xEE, 0x54, 0xFE, 0xF0, 0x90, 0xA0, 0x62, 0x74, 
+0x05, 0xF0, 0x12, 0x50, 0xB9, 0xFD, 0x7F, 0x01, 0x12, 0x51, 0x40, 0x22, 0xFF, 0x75, 0xF0, 0x0E, 
+0x90, 0xA0, 0x6B, 0x02, 0x49, 0x54, 0x90, 0x9F, 0xA7, 0xE0, 0x60, 0x02, 0x91, 0xC6, 0x02, 0x50, 
+0x5B, 0xE0, 0x44, 0x02, 0xF0, 0xE4, 0x90, 0xA2, 0xD4, 0xF0, 0x90, 0xA0, 0x4C, 0xE0, 0x90, 0xA2, 
+0xD5, 0x22, 0x90, 0x9F, 0x9E, 0xE0, 0xFF, 0x30, 0xE0, 0x05, 0x12, 0x5F, 0x78, 0x60, 0x1B, 0x90, 
+0x9F, 0xA7, 0xE0, 0x70, 0x04, 0xEF, 0x30, 0xE0, 0x0B, 0x90, 0x9F, 0xAA, 0xE0, 0x64, 0x02, 0x60, 
+0x09, 0x12, 0x73, 0x20, 0x90, 0x01, 0xE6, 0xE0, 0x04, 0xF0, 0x22, 0xE4, 0xFF, 0x12, 0x72, 0xA6, 
+0xBF, 0x01, 0x13, 0x90, 0x9F, 0xA7, 0xE0, 0x60, 0x0D, 0x12, 0x67, 0xD6, 0x64, 0x02, 0x60, 0x03, 
+0x02, 0x90, 0xB9, 0x12, 0x5F, 0x51, 0x22, 0xE4, 0xFF, 0x12, 0x72, 0xA6, 0xBF, 0x01, 0x0F, 0x90, 
+0x9F, 0xA7, 0xE0, 0x60, 0x09, 0xF1, 0xEF, 0x54, 0x07, 0x70, 0x03, 0x12, 0x58, 0x4F, 0x22, 0x90, 
+0x9F, 0xAB, 0xE0, 0x54, 0xFE, 0xF0, 0x22, 0xE4, 0xF5, 0x64, 0x90, 0x06, 0xA9, 0xE0, 0xF5, 0x64, 
+0x54, 0xC0, 0x70, 0x09, 0x12, 0x8F, 0xEF, 0x54, 0xFD, 0xF0, 0x02, 0x58, 0x4F, 0xE5, 0x64, 0x30, 
+0xE6, 0x1A, 0x90, 0x9F, 0xA7, 0xE0, 0x64, 0x01, 0x70, 0x15, 0x11, 0xB2, 0x12, 0x67, 0xD5, 0x64, 
+0x02, 0x60, 0x04, 0x11, 0xB9, 0x80, 0x08, 0x12, 0x5F, 0x51, 0x80, 0x03, 0x12, 0x8F, 0xEF, 0xE5, 
+0x64, 0x90, 0x9F, 0xAB, 0x30, 0xE7, 0x08, 0x12, 0x8F, 0x81, 0x12, 0x50, 0x26, 0x41, 0x7F, 0xE0, 
+0x54, 0xFD, 0xF0, 0x22, 0x90, 0x06, 0xA9, 0xE0, 0x90, 0xA2, 0x03, 0xF0, 0xE0, 0xFD, 0x54, 0xC0, 
+0x70, 0x05, 0x12, 0x8F, 0xEF, 0x80, 0x57, 0xED, 0x30, 0xE6, 0x3D, 0x90, 0x9F, 0xA7, 0xE0, 0x64, 
+0x02, 0x70, 0x23, 0x90, 0x9F, 0xA3, 0xE0, 0xFF, 0xC3, 0x13, 0x20, 0xE0, 0x05, 0x11, 0xB2, 0xF0, 
+0x80, 0x1D, 0x12, 0x67, 0xD6, 0x64, 0x01, 0x70, 0x22, 0x90, 0x9F, 0xAB, 0xE0, 0x44, 0x04, 0xF0, 
+0x7F, 0x01, 0x31, 0x57, 0x80, 0x15, 0x11, 0xB2, 0x12, 0x67, 0xD5, 0x64, 0x02, 0x60, 0x04, 0x11, 
+0xB9, 0x80, 0x08, 0x12, 0x5F, 0x51, 0x80, 0x03, 0x12, 0x8F, 0xEF, 0x90, 0xA2, 0x03, 0xE0, 0x90, 
+0x9F, 0xAB, 0x30, 0xE7, 0x08, 0x12, 0x8F, 0x81, 0x12, 0x50, 0x26, 0x41, 0x7F, 0xE0, 0x54, 0xFD, 
+0xF0, 0x22, 0x90, 0x9F, 0xAB, 0xE0, 0x44, 0x01, 0x22, 0x90, 0x04, 0x1D, 0xE0, 0x70, 0x15, 0x90, 
+0x9E, 0x99, 0xE0, 0xFF, 0x7B, 0x18, 0xE4, 0xFD, 0x11, 0xDF, 0x90, 0xA3, 0x25, 0xEE, 0xF0, 0xA3, 
+0xEF, 0xF0, 0x51, 0x71, 0x22, 0x90, 0xA2, 0xDC, 0xA3, 0xE0, 0xFF, 0x7B, 0x08, 0x7D, 0x01, 0xD3, 
+0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0xA3, 0x13, 0xED, 0xF0, 0xA3, 0xEB, 0xF0, 0x90, 0xA3, 
+0x12, 0xEF, 0xF0, 0xE4, 0xFD, 0xFC, 0x51, 0x9B, 0x7C, 0x00, 0xAD, 0x07, 0x90, 0xA3, 0x12, 0xE0, 
+0x90, 0x04, 0x25, 0xF0, 0x90, 0xA3, 0x13, 0xE0, 0x60, 0x05, 0x31, 0xEB, 0x44, 0x80, 0xF0, 0xAF, 
+0x05, 0x74, 0x20, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x54, 0xC0, 0xF0, 0x31, 
+0xEB, 0x54, 0xC0, 0xF0, 0xAF, 0x05, 0x31, 0xE0, 0xE0, 0x54, 0x01, 0xFE, 0x90, 0xA3, 0x14, 0xE0, 
+0x25, 0xE0, 0x25, 0xE0, 0xFB, 0xEE, 0x44, 0x02, 0x4B, 0xFE, 0x31, 0xE0, 0xEE, 0xF0, 0x74, 0x11, 
+0x2F, 0x51, 0x87, 0x74, 0xFF, 0xF0, 0x74, 0x29, 0x2F, 0x31, 0xCA, 0x54, 0xF7, 0xF0, 0xAE, 0x04, 
+0xAF, 0x05, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0xA3, 
+0x0B, 0xEF, 0xF0, 0x90, 0x04, 0x1D, 0xE0, 0x60, 0x29, 0x90, 0x05, 0x22, 0xE0, 0x90, 0xA3, 0x0E, 
+0xF0, 0x7D, 0x29, 0x12, 0x52, 0xA1, 0xBF, 0x01, 0x0D, 0x90, 0x9E, 0x9B, 0x11, 0xD9, 0x90, 0xA3, 
+0x0C, 0x12, 0x57, 0xD8, 0x31, 0xA6, 0x90, 0xA3, 0x0E, 0xE0, 0xFF, 0x7D, 0x2A, 0x12, 0x52, 0x45, 
+0x80, 0x0D, 0x90, 0x9E, 0x9B, 0x11, 0xD9, 0x90, 0xA3, 0x0C, 0x12, 0x57, 0xD8, 0x31, 0xA6, 0x51, 
+0x71, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0xA3, 0x0B, 0xE0, 0xFF, 0x31, 0xD4, 0x54, 0x3F, 0xF0, 
+0xEF, 0x60, 0x0A, 0x31, 0xC7, 0x44, 0x10, 0x31, 0xD3, 0x44, 0x80, 0xF0, 0x22, 0x31, 0xC7, 0x54, 
+0xEF, 0x31, 0xD3, 0x44, 0x40, 0xF0, 0x22, 0x74, 0x29, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 
+0x83, 0xE0, 0x22, 0xF0, 0x74, 0x09, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x22, 
+0x74, 0x12, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0x22, 0x74, 0x21, 0x2F, 0xF5, 0x82, 
+0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x22, 0x90, 0xA2, 0xE4, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x90, 
+0x81, 0x00, 0xE0, 0x54, 0x0F, 0xFD, 0xAC, 0x07, 0x51, 0x65, 0x44, 0x01, 0xF0, 0x51, 0x65, 0x54, 
+0xFB, 0xF0, 0xAC, 0x07, 0x74, 0x12, 0x2C, 0x31, 0xE3, 0xE0, 0x44, 0xFA, 0xF0, 0x74, 0x11, 0x2C, 
+0x51, 0x87, 0xE0, 0x44, 0x1F, 0xF0, 0xAC, 0x07, 0x74, 0x06, 0x2C, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 
+0xF5, 0x83, 0xE0, 0x44, 0x0E, 0xF0, 0x90, 0x04, 0xA7, 0xE4, 0xF0, 0x90, 0x04, 0xA6, 0xF0, 0x90, 
+0x04, 0xA5, 0x74, 0xFF, 0xF0, 0x90, 0x04, 0xA4, 0x74, 0xFD, 0xF0, 0x74, 0x14, 0x2C, 0x51, 0x5D, 
+0xE0, 0x54, 0xC0, 0x4D, 0xFD, 0x74, 0x14, 0x2F, 0x51, 0x5D, 0xED, 0xF0, 0x22, 0xF5, 0x82, 0xE4, 
+0x34, 0xFC, 0xF5, 0x83, 0x22, 0x74, 0x0D, 0x2C, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 
+0x22, 0x90, 0x04, 0x1F, 0x74, 0x20, 0xF0, 0x22, 0x90, 0xA2, 0xDE, 0xE0, 0xFF, 0x21, 0xAB, 0x90, 
+0x9F, 0xA3, 0xE0, 0x44, 0x04, 0xF0, 0x22, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0x22, 0x90, 
+0xA2, 0xE2, 0xE0, 0xFF, 0x31, 0xAB, 0x90, 0xA0, 0x60, 0xE0, 0x22, 0x90, 0xFD, 0x10, 0xEF, 0xF0, 
+0x7F, 0x00, 0x22, 0x90, 0x07, 0x1F, 0xE0, 0x54, 0x7F, 0xF0, 0x90, 0x07, 0x1C, 0xE0, 0x54, 0x01, 
+0xFF, 0x90, 0xA2, 0x03, 0xF0, 0x90, 0xA2, 0x01, 0x74, 0x02, 0xF0, 0x90, 0xA2, 0x0F, 0x14, 0xF0, 
+0xFB, 0x7A, 0xA2, 0x79, 0x01, 0x12, 0x7B, 0x25, 0x7F, 0x04, 0x02, 0x75, 0x96, 0x90, 0x9F, 0x9E, 
+0xE0, 0xFF, 0x30, 0xE0, 0x3F, 0x90, 0x9F, 0xA2, 0xE0, 0x7E, 0x00, 0xB4, 0x02, 0x02, 0x7E, 0x01, 
+0x90, 0x9F, 0xA1, 0xE0, 0x7D, 0x00, 0xB4, 0x04, 0x02, 0x7D, 0x01, 0xED, 0x4E, 0x70, 0x25, 0xEF, 
+0xC3, 0x13, 0x30, 0xE0, 0x03, 0x02, 0x8D, 0xF4, 0x12, 0x5F, 0x62, 0x90, 0x9F, 0xA2, 0xE0, 0xB4, 
+0x08, 0x06, 0xE4, 0xFD, 0x7F, 0x0C, 0x80, 0x09, 0x90, 0x9F, 0xA2, 0xE0, 0x70, 0x06, 0xFD, 0x7F, 
+0x04, 0x12, 0x58, 0x67, 0x22, 0xE4, 0x90, 0xA2, 0x12, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0x7F, 0x83, 
+0x12, 0x4B, 0xFC, 0x90, 0xA2, 0x12, 0xEF, 0xF0, 0x7F, 0x83, 0x12, 0x4B, 0xFC, 0xAE, 0x07, 0x90, 
+0xA2, 0x12, 0xE0, 0xFF, 0xB5, 0x06, 0x01, 0x22, 0xC3, 0x90, 0xA2, 0x14, 0xE0, 0x94, 0x64, 0x90, 
+0xA2, 0x13, 0xE0, 0x94, 0x00, 0x40, 0x0D, 0x90, 0x01, 0xC0, 0xE0, 0x44, 0x40, 0xF0, 0x90, 0xA2, 
+0x12, 0xE0, 0xFF, 0x22, 0x90, 0xA2, 0x13, 0x12, 0x78, 0xFB, 0x80, 0xC2, 0x90, 0x01, 0xC4, 0x74, 
+0x5C, 0xF0, 0x74, 0x93, 0xA3, 0xF0, 0x7F, 0x90, 0x12, 0x4B, 0xFC, 0xEF, 0x20, 0xE0, 0xF7, 0x74, 
+0x5C, 0x04, 0x90, 0x01, 0xC4, 0xF0, 0x74, 0x93, 0xA3, 0xF0, 0x22, 0x7E, 0xFF, 0xED, 0xC3, 0x94, 
+0x33, 0x40, 0x19, 0xED, 0xD3, 0x94, 0x35, 0x50, 0x13, 0x75, 0xF0, 0x04, 0xEF, 0x12, 0x4F, 0x61, 
+0xC4, 0x13, 0x54, 0x07, 0x30, 0xE0, 0x05, 0xED, 0x14, 0x44, 0x80, 0xFE, 0xED, 0x14, 0xFD, 0x71, 
+0xA6, 0xED, 0xF0, 0xAF, 0x06, 0x22, 0x74, 0x91, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x9D, 0xF5, 0x83, 
+0x22, 0x75, 0xF0, 0x04, 0xEF, 0x12, 0x4D, 0xFC, 0xF9, 0x12, 0x6F, 0xCC, 0xE0, 0xFC, 0x71, 0xA6, 
+0xE0, 0x54, 0x7F, 0xFD, 0x74, 0x91, 0x2F, 0xB1, 0x87, 0xE0, 0xFE, 0xB1, 0x80, 0xFB, 0x75, 0xF0, 
+0x04, 0xEF, 0x90, 0x96, 0x14, 0x12, 0x49, 0x54, 0xE9, 0x54, 0xF3, 0x4B, 0xF0, 0xED, 0xD3, 0x9C, 
+0x40, 0x02, 0xAD, 0x04, 0x71, 0xA6, 0xE0, 0x54, 0x80, 0x42, 0x05, 0x8E, 0x6B, 0xE4, 0xFB, 0x02, 
+0x6E, 0x72, 0xAA, 0x07, 0xAB, 0x05, 0x75, 0xF0, 0x10, 0xEA, 0x12, 0x6D, 0x43, 0xE0, 0xF5, 0x5D, 
+0x54, 0x7F, 0xF5, 0x5F, 0x75, 0xF0, 0x04, 0xEA, 0x12, 0x6D, 0x4E, 0xE0, 0xF9, 0x75, 0xF0, 0x04, 
+0xEA, 0x12, 0x6F, 0xD0, 0xE0, 0xFC, 0x75, 0xF0, 0x04, 0xEA, 0x12, 0x4D, 0xFC, 0x13, 0x13, 0x54, 
+0x03, 0xF5, 0x5E, 0xE5, 0x5F, 0xB1, 0x9C, 0xD1, 0x04, 0xEA, 0xB1, 0xA6, 0x75, 0xF0, 0x04, 0xEA, 
+0x12, 0x4D, 0xFC, 0xC4, 0x54, 0x03, 0x90, 0xA1, 0x53, 0xF0, 0x74, 0x91, 0x2A, 0x71, 0xA9, 0xE5, 
+0x5F, 0xF0, 0x74, 0x91, 0x2A, 0xB1, 0x87, 0xE5, 0x5E, 0xF0, 0xE5, 0x5F, 0xD3, 0x9C, 0x40, 0x06, 
+0x8C, 0x5F, 0xAF, 0x04, 0x8F, 0x5D, 0xEB, 0x70, 0x02, 0xA1, 0x60, 0xAF, 0x03, 0x8F, 0x60, 0xE5, 
+0x5D, 0x30, 0xE7, 0x05, 0x85, 0x5F, 0x5D, 0x15, 0x60, 0xE5, 0x60, 0x70, 0x02, 0xA1, 0x60, 0xAF, 
+0x02, 0xAD, 0x5D, 0x71, 0x7B, 0xEF, 0xF4, 0x60, 0x0A, 0x8F, 0x5D, 0x15, 0x60, 0xE5, 0x60, 0x70, 
+0x02, 0xA1, 0x60, 0xE5, 0x5D, 0x64, 0x2C, 0x70, 0x2B, 0xE5, 0x5E, 0xD3, 0x94, 0x00, 0x40, 0x24, 
+0xE5, 0x5E, 0xD3, 0x94, 0x02, 0x50, 0x1D, 0x15, 0x5E, 0x75, 0x5D, 0x2D, 0xE5, 0x5E, 0xB1, 0x80, 
+0xFF, 0x75, 0xF0, 0x04, 0xEA, 0x12, 0x4D, 0xFC, 0x54, 0xF3, 0x4F, 0xF0, 0x15, 0x60, 0xE5, 0x60, 
+0x70, 0x02, 0xA1, 0x60, 0xE5, 0x5D, 0xB4, 0x2D, 0x12, 0xE5, 0x5E, 0xD3, 0x94, 0x02, 0x50, 0x0B, 
+0x75, 0x5D, 0x2C, 0x15, 0x60, 0xE5, 0x60, 0x70, 0x02, 0xA1, 0x60, 0xE5, 0x60, 0x70, 0x02, 0xA1, 
+0x60, 0xE5, 0x5F, 0xD3, 0x99, 0x50, 0x02, 0xA1, 0x5C, 0xE4, 0x90, 0xA1, 0x54, 0xF0, 0x90, 0xA1, 
+0x53, 0xE0, 0xFF, 0xAD, 0x5F, 0xB1, 0x6C, 0x8F, 0x5F, 0x85, 0x5F, 0x5D, 0xE0, 0xFF, 0xAD, 0x01, 
+0xB1, 0x6C, 0xA9, 0x07, 0x90, 0xA1, 0x55, 0xE5, 0x5D, 0xF0, 0xE5, 0x5F, 0x14, 0xFD, 0xED, 0xC3, 
+0x99, 0x40, 0x46, 0xB1, 0x8F, 0xEA, 0x12, 0x6B, 0xF7, 0xE0, 0xF5, 0x82, 0x75, 0x83, 0x00, 0x12, 
+0x85, 0xC9, 0x80, 0x05, 0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 0xF9, 0xFF, 0xEE, 0x55, 0x83, 0xFE, 
+0xEF, 0x55, 0x82, 0x4E, 0x60, 0x20, 0xE5, 0x5F, 0x90, 0xA1, 0x55, 0xB4, 0x14, 0x05, 0x74, 0x0C, 
+0xF0, 0x80, 0x02, 0xED, 0xF0, 0x90, 0xA1, 0x54, 0xE0, 0x04, 0xF0, 0xE0, 0x65, 0x60, 0x60, 0x09, 
+0xA3, 0xE0, 0xD3, 0x99, 0x40, 0x03, 0x1D, 0x80, 0xB5, 0x90, 0xA1, 0x55, 0xE0, 0xF5, 0x5D, 0x90, 
+0xA1, 0x53, 0xE0, 0xFF, 0xAD, 0x5D, 0xB1, 0xB7, 0x8F, 0x5D, 0x80, 0x04, 0xAF, 0x01, 0x8F, 0x5D, 
+0xAF, 0x02, 0x85, 0x5E, 0x6B, 0xE4, 0xFB, 0xAD, 0x5D, 0x02, 0x6E, 0x72, 0xEF, 0x60, 0x0A, 0xED, 
+0xC3, 0x94, 0x2C, 0x40, 0x04, 0x7E, 0x20, 0x80, 0x02, 0xE4, 0xFE, 0xC3, 0xED, 0x9E, 0xFF, 0x22, 
+0x54, 0x03, 0x25, 0xE0, 0x25, 0xE0, 0x22, 0xF5, 0x82, 0xE4, 0x34, 0x9B, 0xF5, 0x83, 0x22, 0xED, 
+0x13, 0x13, 0x13, 0x54, 0x1F, 0xFF, 0x75, 0xF0, 0x08, 0x22, 0xE5, 0x53, 0x25, 0xE0, 0x24, 0xF7, 
+0xF5, 0x82, 0xE4, 0x34, 0x42, 0x22, 0x25, 0xE0, 0x24, 0x91, 0xF5, 0x82, 0xE4, 0x34, 0x94, 0xF5, 
+0x83, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x22, 0xEF, 0x60, 0x0A, 0xED, 0xD3, 0x94, 0x0B, 0x40, 0x04, 
+0x7E, 0x20, 0x80, 0x02, 0xE4, 0xFE, 0xED, 0x2E, 0xFF, 0x22, 0x12, 0x38, 0x07, 0x90, 0xA1, 0xF8, 
+0xE0, 0x75, 0xF0, 0x1C, 0xA4, 0x24, 0x97, 0xF5, 0x82, 0xE4, 0x34, 0x44, 0xF5, 0x83, 0xE4, 0x93, 
+0xFE, 0x74, 0x01, 0x93, 0xFF, 0x12, 0x37, 0xBC, 0xE4, 0xFF, 0xFE, 0xEC, 0x54, 0x07, 0xFC, 0x90, 
+0xA2, 0x45, 0x12, 0x08, 0x6D, 0x90, 0xA1, 0xF8, 0xE0, 0x75, 0xF0, 0x0E, 0xA4, 0x24, 0x77, 0xF5, 
+0x82, 0xE4, 0x34, 0x44, 0xF5, 0x83, 0xE4, 0x93, 0xFE, 0x74, 0x01, 0x93, 0xFF, 0x22, 0x90, 0xA1, 
+0xF8, 0x12, 0xAF, 0x1A, 0xB1, 0xF5, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0xAA, 0xB9, 0x12, 0x08, 0x79, 
+0x00, 0x10, 0x00, 0x00, 0xD0, 0x07, 0xD0, 0x06, 0x12, 0x76, 0xE1, 0x12, 0x08, 0x79, 0xFA, 0x00, 
+0x00, 0x00, 0x7F, 0x80, 0x7E, 0x09, 0x12, 0x76, 0xE1, 0x12, 0x08, 0x79, 0xF8, 0x00, 0x00, 0x00, 
+0x7F, 0x80, 0x7E, 0x09, 0x12, 0x38, 0x07, 0x7F, 0x03, 0x7E, 0x00, 0x12, 0x3C, 0xEC, 0xB1, 0xF5, 
+0xC0, 0x06, 0xC0, 0x07, 0x90, 0xAA, 0xB9, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 0x00, 0xD0, 0x07, 
+0xD0, 0x06, 0x12, 0x38, 0x07, 0xE4, 0x90, 0xA1, 0xFB, 0xF0, 0xF1, 0xAC, 0x24, 0x97, 0xF5, 0x82, 
+0xE4, 0x34, 0x44, 0xD1, 0x04, 0xF1, 0xB5, 0x54, 0x04, 0xFE, 0xE4, 0xFD, 0xFC, 0x78, 0x0A, 0x12, 
+0x08, 0x47, 0xEF, 0x70, 0x14, 0x90, 0xA1, 0xFB, 0xE0, 0xD3, 0x94, 0x14, 0x50, 0x0B, 0x12, 0xAF, 
+0xAE, 0x90, 0xA1, 0xFB, 0xE0, 0x04, 0xF0, 0x80, 0xD1, 0x90, 0xA1, 0xFB, 0xE0, 0xC3, 0x94, 0x14, 
+0x40, 0x02, 0xE1, 0x9D, 0x90, 0xA1, 0xF9, 0xE0, 0x70, 0x42, 0xF1, 0xAC, 0x24, 0x97, 0xF5, 0x82, 
+0xE4, 0x34, 0x44, 0xD1, 0x04, 0xF1, 0xB5, 0x54, 0x10, 0x12, 0xAC, 0xFE, 0x70, 0x26, 0xB1, 0xF5, 
+0xC0, 0x06, 0xC0, 0x07, 0x90, 0xAA, 0xB9, 0x12, 0x08, 0x79, 0x02, 0x00, 0x00, 0x00, 0xD0, 0x07, 
+0xD0, 0x06, 0xB1, 0xCA, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0xAA, 0xB9, 0x12, 0x08, 0x79, 0x04, 0x00, 
+0x00, 0x00, 0x80, 0x40, 0xF1, 0xBC, 0x60, 0x02, 0xC1, 0x14, 0xE1, 0xA3, 0xF1, 0xAC, 0x24, 0x97, 
+0xF5, 0x82, 0xE4, 0x34, 0x44, 0xD1, 0x04, 0xF1, 0xB5, 0x54, 0x08, 0x12, 0xAC, 0xFE, 0x70, 0x4E, 
+0xB1, 0xF5, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0xAA, 0xB9, 0x12, 0x08, 0x79, 0x06, 0x00, 0x00, 0x00, 
+0xD0, 0x07, 0xD0, 0x06, 0xB1, 0xCA, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0xAA, 0xB9, 0x12, 0x08, 0x79, 
+0x08, 0x00, 0x00, 0x00, 0xD0, 0x07, 0xD0, 0x06, 0x12, 0x38, 0x07, 0xF1, 0xAC, 0x24, 0x97, 0xF5, 
+0x82, 0xE4, 0x34, 0x44, 0xD1, 0x04, 0x12, 0x37, 0xBC, 0xE4, 0xFF, 0xFE, 0xEC, 0x54, 0x07, 0xFC, 
+0x90, 0xA2, 0x49, 0x12, 0x08, 0x6D, 0x90, 0xA2, 0x00, 0x74, 0x01, 0xF0, 0x80, 0x55, 0xF1, 0xAC, 
+0xF1, 0xCB, 0xD1, 0x04, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0xA2, 0xB1, 0x12, 0x08, 0x79, 0x00, 0x00, 
+0x03, 0xFF, 0x90, 0xA2, 0xB5, 0x12, 0x08, 0x79, 0x00, 0x00, 0x01, 0x00, 0xD0, 0x07, 0xD0, 0x06, 
+0xF1, 0xA9, 0xF1, 0xCB, 0xD1, 0x04, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0xA2, 0xB1, 0x12, 0x08, 0x79, 
+0x03, 0xFF, 0x00, 0x00, 0x90, 0xA2, 0xB5, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 0x00, 0xD0, 0x07, 
+0xD0, 0x06, 0x12, 0x7E, 0x92, 0xF1, 0xBC, 0x60, 0x02, 0xC1, 0x14, 0x80, 0x06, 0xF1, 0xBC, 0x60, 
+0x02, 0xC1, 0x14, 0x90, 0xA2, 0x00, 0xE0, 0xFF, 0x22, 0x12, 0x7E, 0x92, 0x90, 0xA1, 0xF8, 0xE0, 
+0x75, 0xF0, 0x1C, 0xA4, 0x22, 0x12, 0x37, 0xBC, 0xE4, 0xFF, 0xEE, 0x22, 0xE4, 0x90, 0xA2, 0x00, 
+0xF0, 0x90, 0xA1, 0xFA, 0xE0, 0x04, 0xF0, 0xE0, 0x64, 0x0A, 0x22, 0x24, 0x95, 0xF5, 0x82, 0xE4, 
+0x34, 0x44, 0x22, 0xED, 0x54, 0x7F, 0xFC, 0xED, 0x54, 0x80, 0x60, 0x03, 0xAF, 0x04, 0x22, 0xEC, 
+0xC3, 0x94, 0x33, 0x40, 0x1E, 0xEC, 0xD3, 0x94, 0x35, 0x50, 0x18, 0x75, 0xF0, 0x04, 0xEF, 0x12, 
+0x4F, 0x61, 0xC4, 0x13, 0x54, 0x07, 0x30, 0xE0, 0x06, 0xEC, 0x44, 0x80, 0xFE, 0x80, 0x06, 0x7E, 
+0xFF, 0x80, 0x02, 0x7E, 0xFF, 0xAF, 0x06, 0x22, 0xE4, 0xF5, 0x5D, 0x74, 0x91, 0x2F, 0x12, 0x6C, 
+0x0A, 0xE0, 0xFE, 0xB4, 0x05, 0x08, 0xED, 0xC3, 0x94, 0x3B, 0x40, 0x51, 0x80, 0x47, 0xEE, 0xB4, 
+0x04, 0x08, 0xED, 0xC3, 0x94, 0x31, 0x40, 0x45, 0x80, 0x3B, 0x74, 0x91, 0x2F, 0x12, 0x6C, 0x0A, 
+0xE0, 0xFE, 0xB4, 0x03, 0x08, 0xED, 0xC3, 0x94, 0x19, 0x40, 0x32, 0x80, 0x28, 0xEE, 0xB4, 0x02, 
+0x08, 0xED, 0xC3, 0x94, 0x11, 0x40, 0x26, 0x80, 0x1C, 0x74, 0x91, 0x2F, 0x12, 0x6C, 0x0A, 0xE0, 
+0xFE, 0xB4, 0x01, 0x08, 0xED, 0xC3, 0x94, 0x0A, 0x40, 0x13, 0x80, 0x09, 0xEE, 0x70, 0x0B, 0xED, 
+0xC3, 0x94, 0x03, 0x40, 0x08, 0x75, 0x5D, 0x01, 0x80, 0x03, 0xE4, 0xF5, 0x5D, 0xAF, 0x5D, 0x22, 
+0x8F, 0x52, 0x8D, 0x53, 0x8B, 0x54, 0x75, 0xF0, 0x04, 0xEF, 0x12, 0x4D, 0xFC, 0xC4, 0x54, 0x03, 
+0x90, 0xA1, 0x48, 0xF0, 0x90, 0xA1, 0x46, 0x60, 0x09, 0x74, 0x32, 0xF0, 0xA3, 0x74, 0x2F, 0xF0, 
+0x80, 0x07, 0x74, 0x11, 0xF0, 0xA3, 0x74, 0x0F, 0xF0, 0xE5, 0x53, 0xD3, 0x94, 0x2D, 0x40, 0x0A, 
+0x75, 0xF0, 0x04, 0xE5, 0x52, 0x12, 0x6F, 0xD0, 0x80, 0x20, 0xE5, 0x53, 0xD3, 0x94, 0x1E, 0x40, 
+0x05, 0x90, 0xA1, 0x46, 0x80, 0x14, 0xE5, 0x53, 0xD3, 0x94, 0x14, 0x40, 0x05, 0x90, 0xA1, 0x47, 
+0x80, 0x08, 0x75, 0xF0, 0x04, 0xE5, 0x52, 0x12, 0x6D, 0x4E, 0xE0, 0xFD, 0x85, 0x54, 0x6B, 0xE4, 
+0xFB, 0xAF, 0x52, 0x02, 0x6E, 0x72, 0x8F, 0x5D, 0x75, 0xF0, 0x10, 0xEF, 0x12, 0x6D, 0x43, 0xE0, 
+0xF5, 0x5E, 0xE4, 0xF5, 0x63, 0xE5, 0x5E, 0x54, 0x7F, 0xF5, 0x5F, 0xE5, 0x5E, 0x54, 0x80, 0xFF, 
+0x75, 0xF0, 0x04, 0xE5, 0x5D, 0x12, 0x6F, 0xD0, 0xE0, 0xF5, 0x61, 0x75, 0xF0, 0x04, 0xE5, 0x5D, 
+0x12, 0x4D, 0xFC, 0xFE, 0xC4, 0x54, 0x03, 0xF5, 0x62, 0xE5, 0x5F, 0x71, 0xEF, 0x91, 0x06, 0xFD, 
+0xE5, 0x5D, 0x12, 0x67, 0xB6, 0xEC, 0xF0, 0xA3, 0xED, 0xF0, 0xE5, 0x5E, 0x4F, 0xFF, 0x74, 0x91, 
+0x25, 0x5D, 0x12, 0x93, 0xA9, 0xEF, 0xF0, 0x75, 0xF0, 0x04, 0xE5, 0x5D, 0x12, 0x4D, 0xFC, 0x13, 
+0x13, 0x54, 0x03, 0xF5, 0x60, 0x74, 0x91, 0x25, 0x5D, 0x12, 0x95, 0x87, 0xE5, 0x60, 0xF0, 0x12, 
+0x66, 0xE1, 0xE0, 0x30, 0xE0, 0x20, 0xE5, 0x5F, 0x64, 0x3F, 0x70, 0x1A, 0x12, 0x4F, 0x59, 0xC4, 
+0x13, 0x54, 0x07, 0x30, 0xE0, 0x05, 0x75, 0x5E, 0xBE, 0x80, 0x03, 0x85, 0x5F, 0x5E, 0x85, 0x60, 
+0x6B, 0xE4, 0xFB, 0x12, 0x6E, 0x6E, 0xAD, 0x5E, 0xAF, 0x5D, 0x12, 0x97, 0xD3, 0xEF, 0xF4, 0x60, 
+0x0B, 0x8F, 0x5E, 0xEF, 0x30, 0xE7, 0x02, 0x61, 0xD0, 0x85, 0x5E, 0x5F, 0xE5, 0x5F, 0x64, 0x2D, 
+0x70, 0x2F, 0x75, 0xF0, 0x04, 0xE5, 0x5D, 0x12, 0x4D, 0xFC, 0xFF, 0x54, 0x03, 0xFE, 0xE5, 0x60, 
+0xC3, 0x9E, 0x50, 0x1D, 0x75, 0x5E, 0x2C, 0x05, 0x60, 0xE5, 0x60, 0x12, 0x95, 0x80, 0xFE, 0x75, 
+0xF0, 0x04, 0xE5, 0x5D, 0x90, 0x96, 0x14, 0x12, 0x49, 0x54, 0xEF, 0x54, 0xF3, 0x4E, 0xF0, 0x61, 
+0xD0, 0xE5, 0x5F, 0xB4, 0x2C, 0x05, 0x75, 0x5E, 0x2D, 0x61, 0xD0, 0xE5, 0x5F, 0xC3, 0x95, 0x61, 
+0x40, 0x02, 0x61, 0x94, 0xE5, 0x5F, 0xC3, 0x94, 0x0C, 0x40, 0x13, 0xE5, 0x5F, 0x94, 0x13, 0x50, 
+0x0D, 0x12, 0x66, 0xE1, 0xE0, 0xFF, 0x20, 0xE3, 0x05, 0x75, 0x63, 0x01, 0x80, 0x18, 0xE5, 0x5F, 
+0xC3, 0x94, 0x2C, 0x40, 0x1A, 0xE5, 0x5F, 0x94, 0x35, 0x50, 0x14, 0x12, 0x66, 0xE1, 0xE0, 0xFF, 
+0x20, 0xE3, 0x0C, 0x75, 0x63, 0x02, 0x12, 0x66, 0xE1, 0xEF, 0x44, 0x08, 0xF0, 0x80, 0x07, 0x12, 
+0x66, 0xDE, 0xE0, 0x54, 0xF7, 0xF0, 0x12, 0x66, 0xE1, 0xE0, 0x20, 0xE6, 0x03, 0x30, 0xE1, 0x07, 
+0x12, 0x66, 0xDE, 0xE0, 0x54, 0xF7, 0xF0, 0xE5, 0x63, 0x64, 0x01, 0x70, 0x70, 0x71, 0xD3, 0x20, 
+0xE7, 0x0E, 0x20, 0xE6, 0x0B, 0x20, 0xE5, 0x08, 0x20, 0xE4, 0x05, 0x71, 0xE0, 0x30, 0xE0, 0x5D, 
+0x12, 0x66, 0xE1, 0xE0, 0x44, 0x04, 0xF0, 0xE5, 0x5F, 0xB4, 0x0C, 0x08, 0x75, 0x5F, 0x14, 0x75, 
+0x5E, 0x14, 0x61, 0x07, 0xE5, 0x5F, 0xB4, 0x0D, 0x02, 0x80, 0x05, 0xE5, 0x5F, 0xB4, 0x0E, 0x08, 
+0x75, 0x5F, 0x15, 0x75, 0x5E, 0x15, 0x61, 0x07, 0xE5, 0x5F, 0xB4, 0x0F, 0x08, 0x75, 0x5F, 0x16, 
+0x75, 0x5E, 0x16, 0x61, 0x07, 0xE5, 0x5F, 0xC3, 0x94, 0x10, 0x40, 0x08, 0x75, 0x5F, 0x17, 0x75, 
+0x5E, 0x17, 0x61, 0x07, 0xE5, 0x5F, 0xC3, 0x94, 0x11, 0x50, 0x02, 0x61, 0x07, 0xE5, 0x5F, 0x94, 
+0x13, 0x40, 0x02, 0x61, 0x07, 0x75, 0x5F, 0x18, 0x75, 0x5E, 0x18, 0x80, 0x7A, 0xE5, 0x63, 0x64, 
+0x02, 0x70, 0x79, 0x71, 0xD3, 0x20, 0xE6, 0x0E, 0x20, 0xE7, 0x0B, 0x71, 0xE0, 0x20, 0xE0, 0x06, 
+0x20, 0xE1, 0x03, 0x30, 0xE2, 0x66, 0xE5, 0x5F, 0x64, 0x2C, 0x60, 0x05, 0xE5, 0x5F, 0xB4, 0x2D, 
+0x08, 0x75, 0x5F, 0x36, 0x75, 0x5E, 0x36, 0x80, 0x4E, 0xE5, 0x5F, 0x64, 0x2E, 0x60, 0x05, 0xE5, 
+0x5F, 0xB4, 0x2F, 0x08, 0x75, 0x5F, 0x37, 0x75, 0x5E, 0x37, 0x80, 0x3B, 0xE5, 0x5F, 0xB4, 0x30, 
+0x08, 0x75, 0x5F, 0x38, 0x75, 0x5E, 0x38, 0x80, 0x2E, 0xE5, 0x5F, 0xB4, 0x31, 0x08, 0x75, 0x5F, 
+0x39, 0x75, 0x5E, 0x39, 0x80, 0x21, 0xE5, 0x5F, 0xC3, 0x94, 0x32, 0x40, 0x0F, 0xE5, 0x5F, 0xD3, 
+0x94, 0x34, 0x50, 0x08, 0x75, 0x5F, 0x3A, 0x75, 0x5E, 0x3A, 0x80, 0x0B, 0xE5, 0x5F, 0xB4, 0x35, 
+0x06, 0x75, 0x5F, 0x3B, 0x75, 0x5E, 0x3B, 0x12, 0x6E, 0x69, 0x80, 0x07, 0x12, 0x66, 0xE1, 0xE0, 
+0x54, 0xFB, 0xF0, 0xAD, 0x5F, 0xAF, 0x62, 0x12, 0x95, 0x6C, 0x8F, 0x5F, 0xAD, 0x61, 0xAF, 0x62, 
+0x12, 0x95, 0x6C, 0x8F, 0x61, 0xE5, 0x5F, 0x04, 0xFD, 0xED, 0xD3, 0x95, 0x61, 0x50, 0x3B, 0x12, 
+0x95, 0x8F, 0xE5, 0x5D, 0x12, 0x6B, 0xF7, 0xE0, 0xFB, 0x7A, 0x00, 0x12, 0x85, 0xC9, 0x80, 0x05, 
+0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 0xF9, 0x12, 0x85, 0xC1, 0x60, 0x1B, 0xE5, 0x5F, 0xB4, 0x13, 
+0x0F, 0x75, 0x5F, 0x18, 0x85, 0x5F, 0x5E, 0x12, 0x66, 0xE1, 0xE0, 0x44, 0x04, 0xF0, 0x80, 0x0A, 
+0x8D, 0x5F, 0x85, 0x5F, 0x5E, 0x80, 0x03, 0x0D, 0x80, 0xBF, 0xAD, 0x5E, 0xAF, 0x62, 0x12, 0x95, 
+0xB7, 0x8F, 0x5E, 0x12, 0x66, 0xE1, 0xE0, 0x30, 0xE0, 0x56, 0xE5, 0x5F, 0x64, 0x3F, 0x70, 0x50, 
+0x12, 0x4F, 0x59, 0xC4, 0x13, 0x54, 0x07, 0x30, 0xE0, 0x05, 0x75, 0x5E, 0xBE, 0x80, 0x41, 0x85, 
+0x5F, 0x5E, 0x80, 0x3C, 0xE5, 0x5F, 0x65, 0x61, 0x70, 0x2A, 0x12, 0x4F, 0x5C, 0xC4, 0x13, 0x54, 
+0x07, 0x30, 0xE0, 0x0D, 0xE5, 0x5E, 0x20, 0xE7, 0x08, 0xE5, 0x5F, 0x44, 0x80, 0xF5, 0x5E, 0x80, 
+0x1F, 0xE5, 0x5F, 0x25, 0xE0, 0x24, 0x4F, 0xF5, 0x82, 0xE4, 0x34, 0x42, 0x12, 0x96, 0x04, 0xE5, 
+0x5D, 0x02, 0x95, 0xA6, 0x74, 0x91, 0x25, 0x5D, 0x12, 0x93, 0xA9, 0xE5, 0x61, 0xF0, 0xF5, 0x5E, 
+0x02, 0x6E, 0x69, 0x75, 0xF0, 0x08, 0xE5, 0x5D, 0x90, 0x89, 0x02, 0x12, 0x49, 0x54, 0xE0, 0x22, 
+0x75, 0xF0, 0x08, 0xE5, 0x5D, 0x90, 0x89, 0x03, 0x12, 0x49, 0x54, 0xE0, 0x22, 0xE5, 0x53, 0x25, 
+0xE0, 0x24, 0x4F, 0xF5, 0x82, 0xE4, 0x34, 0x42, 0xF5, 0x83, 0x22, 0x25, 0xE0, 0x24, 0x59, 0xF5, 
+0x82, 0xE4, 0x34, 0x44, 0xF5, 0x83, 0xE4, 0x93, 0xFC, 0x74, 0x01, 0x93, 0x22, 0x12, 0x77, 0xC2, 
+0x12, 0x08, 0x79, 0x80, 0x00, 0x00, 0x00, 0x90, 0xA2, 0xB5, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 
+0x00, 0x12, 0x7E, 0x8E, 0xE4, 0x90, 0xA1, 0xBC, 0xF0, 0x90, 0xA1, 0xBC, 0xE0, 0xFF, 0x71, 0xFB, 
+0xF5, 0x82, 0x8C, 0x83, 0xE0, 0xFE, 0x12, 0x76, 0xEC, 0x8F, 0x82, 0x75, 0x83, 0x00, 0xEE, 0x12, 
+0x06, 0xE1, 0x91, 0x7B, 0xE0, 0xB4, 0x03, 0xE1, 0xE4, 0x90, 0xA1, 0xBC, 0xF0, 0x90, 0xA1, 0xBC, 
+0xE0, 0xFF, 0xC3, 0x94, 0x08, 0x50, 0x10, 0xEF, 0x91, 0xEC, 0x12, 0x96, 0x04, 0x12, 0x37, 0xBC, 
+0x90, 0xA1, 0xB9, 0x91, 0x68, 0x80, 0xE6, 0x22, 0x12, 0x49, 0x60, 0x90, 0xA1, 0xBC, 0xE0, 0x75, 
+0xF0, 0x04, 0xA4, 0xF5, 0x82, 0x85, 0xF0, 0x83, 0x12, 0x49, 0x18, 0x90, 0xA1, 0xBC, 0xE0, 0x04, 
+0xF0, 0x22, 0x12, 0x77, 0xC2, 0x12, 0x08, 0x79, 0x80, 0x00, 0x00, 0x00, 0x90, 0xA2, 0xB5, 0x12, 
+0x08, 0x79, 0x00, 0x00, 0x00, 0x00, 0x12, 0x7E, 0x8E, 0xE4, 0x90, 0xA1, 0xBC, 0xF0, 0x12, 0x76, 
+0xEC, 0x90, 0xA1, 0xBC, 0xE0, 0xFF, 0xF5, 0x82, 0x12, 0x67, 0xE5, 0xFE, 0xEF, 0x71, 0xFB, 0xF5, 
+0x82, 0x8C, 0x83, 0xEE, 0xF0, 0x91, 0x7B, 0xE0, 0xB4, 0x03, 0xE3, 0xE4, 0x90, 0xA1, 0xBC, 0xF0, 
+0x90, 0xA1, 0xBC, 0xE0, 0xFD, 0x91, 0xEC, 0x12, 0x96, 0x04, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0xA1, 
+0xB9, 0x12, 0x49, 0x60, 0x91, 0xF6, 0x12, 0x48, 0xCE, 0x12, 0x4D, 0x4D, 0xD0, 0x07, 0xD0, 0x06, 
+0x12, 0x38, 0x07, 0x91, 0x7B, 0xE0, 0xC3, 0x94, 0x08, 0x40, 0xD5, 0x22, 0x25, 0xE0, 0x24, 0x5F, 
+0xF5, 0x82, 0xE4, 0x34, 0x44, 0x22, 0x75, 0xF0, 0x04, 0xED, 0xA4, 0xF5, 0x82, 0x85, 0xF0, 0x83, 
+0x22, 0x12, 0x77, 0xC2, 0x12, 0x08, 0x79, 0x80, 0x00, 0x00, 0x00, 0x90, 0xA2, 0xB5, 0x12, 0x08, 
+0x79, 0x00, 0x00, 0x00, 0x00, 0x12, 0x7E, 0x8E, 0xE4, 0x90, 0xA1, 0xBC, 0xF0, 0x90, 0xA1, 0xBC, 
+0xE0, 0xFF, 0xC3, 0x94, 0x07, 0x50, 0x10, 0xEF, 0xB1, 0x38, 0x12, 0x96, 0x04, 0x12, 0x37, 0xBC, 
+0x90, 0xA1, 0xB6, 0x91, 0x68, 0x80, 0xE6, 0x22, 0x25, 0xE0, 0x24, 0x6F, 0xF5, 0x82, 0xE4, 0x34, 
+0x44, 0x22, 0x90, 0x04, 0x54, 0xE0, 0x7F, 0x00, 0x30, 0xE7, 0x02, 0x7F, 0x01, 0x22, 0x90, 0xA3, 
+0x24, 0xED, 0xF0, 0x90, 0xA3, 0x23, 0xEF, 0xF0, 0xD3, 0x94, 0x0E, 0x50, 0x15, 0xB1, 0x42, 0xEF, 
+0x60, 0x2A, 0xB1, 0x42, 0xEF, 0x64, 0x01, 0x70, 0x23, 0x90, 0xA3, 0x24, 0xE0, 0xFD, 0xE4, 0xFF, 
+0x80, 0x15, 0x90, 0xA3, 0x23, 0xE0, 0xD3, 0x94, 0x0E, 0x40, 0x11, 0xB1, 0x42, 0xEF, 0x70, 0x0A, 
+0x90, 0xA3, 0x24, 0xE0, 0xFD, 0x7F, 0x01, 0x02, 0x7E, 0xF4, 0xB1, 0x42, 0x22, 0xD3, 0x10, 0xAF, 
+0x01, 0xC3, 0xC0, 0xD0, 0xA9, 0x07, 0x90, 0x06, 0x69, 0xE0, 0xFE, 0x90, 0x06, 0x68, 0xE0, 0x7A, 
+0x00, 0x24, 0x00, 0xFF, 0xEA, 0x3E, 0xFE, 0xE9, 0x14, 0x60, 0x0F, 0x14, 0x60, 0x1E, 0x24, 0x02, 
+0x70, 0x25, 0xEE, 0x54, 0xFE, 0xFE, 0xB1, 0xDC, 0x80, 0x1A, 0xEF, 0x44, 0x80, 0xFF, 0xEE, 0x54, 
+0xFE, 0xFC, 0x90, 0x06, 0x68, 0xEF, 0xF0, 0xEC, 0xA3, 0xF0, 0x80, 0x0B, 0xEE, 0x44, 0x01, 0xFC, 
+0xB1, 0xDC, 0xAE, 0x04, 0xEE, 0xA3, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xEF, 0x54, 0x7F, 0x90, 
+0x06, 0x68, 0xF0, 0x22, 0xE4, 0xFE, 0xFC, 0xEF, 0x64, 0x02, 0x70, 0x40, 0xED, 0xB4, 0x01, 0x04, 
+0x7E, 0x0A, 0x80, 0x06, 0xED, 0xB4, 0x02, 0x02, 0x7E, 0x09, 0xEB, 0xB4, 0x01, 0x08, 0xED, 0xB4, 
+0x01, 0x04, 0x7C, 0x04, 0x80, 0x38, 0xEB, 0xB4, 0x02, 0x08, 0xED, 0xB4, 0x01, 0x04, 0x7C, 0x02, 
+0x80, 0x2C, 0xEB, 0xB4, 0x01, 0x08, 0xED, 0xB4, 0x02, 0x04, 0x7C, 0x01, 0x80, 0x20, 0xEB, 0x64, 
+0x02, 0x70, 0x1B, 0xED, 0x64, 0x02, 0x70, 0x16, 0x7C, 0x03, 0x80, 0x12, 0xEF, 0xB4, 0x01, 0x0E, 
+0xEB, 0xB4, 0x02, 0x04, 0x7C, 0x01, 0x80, 0x06, 0xEB, 0xB4, 0x01, 0x02, 0x7C, 0x02, 0xAF, 0x06, 
+0xEF, 0xC4, 0x54, 0xF0, 0x4C, 0xFF, 0x22, 0x90, 0xA2, 0xB1, 0x12, 0x08, 0x79, 0x80, 0x00, 0x00, 
+0x00, 0x90, 0xA2, 0xB5, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 0x00, 0x12, 0x7E, 0x8E, 0x90, 0x05, 
+0x22, 0x74, 0x3F, 0xF0, 0x90, 0x05, 0x50, 0xE0, 0x54, 0xF7, 0xF0, 0xA3, 0xE0, 0x54, 0xF7, 0xF0, 
+0x90, 0xA2, 0xB1, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 0xFF, 0x90, 0xA2, 0xB5, 0x12, 0x08, 0x79, 
+0x00, 0x00, 0x00, 0x00, 0x74, 0x08, 0xFF, 0xFE, 0x12, 0x7E, 0x88, 0x12, 0x08, 0x79, 0x00, 0x00, 
+0x00, 0x0F, 0x90, 0xA2, 0xB5, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 0x0C, 0x7F, 0x38, 0x7E, 0x08, 
+0x02, 0x7E, 0x92, 0xF1, 0x8B, 0x12, 0x08, 0x79, 0x80, 0x00, 0x00, 0x00, 0x90, 0xA2, 0xB5, 0x12, 
+0x08, 0x79, 0x00, 0x00, 0x00, 0x00, 0x12, 0x7E, 0x8E, 0x90, 0xA1, 0xF9, 0xF1, 0x6F, 0xE4, 0x7B, 
+0x12, 0x7A, 0x01, 0xF9, 0xF8, 0xC3, 0x12, 0x48, 0x9D, 0x60, 0x11, 0x90, 0xA1, 0xFD, 0xF1, 0x6F, 
+0xE4, 0x7B, 0xEE, 0x7A, 0x03, 0xF8, 0xC3, 0x12, 0x48, 0x9D, 0x70, 0x48, 0x12, 0x97, 0xAC, 0x12, 
+0x97, 0xCB, 0x12, 0x96, 0x04, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0xA2, 0xB1, 0x12, 0x08, 0x79, 0x00, 
+0x00, 0x03, 0xFF, 0x90, 0xA2, 0xB5, 0x12, 0x08, 0x79, 0x00, 0x00, 0x01, 0x00, 0xD0, 0x07, 0xD0, 
+0x06, 0x12, 0x97, 0xA9, 0x12, 0x97, 0xCB, 0x12, 0x96, 0x04, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0xA2, 
+0xB1, 0x12, 0x08, 0x79, 0x03, 0xFF, 0x00, 0x00, 0x90, 0xA2, 0xB5, 0x12, 0x08, 0x79, 0x00, 0x00, 
+0x00, 0x00, 0x80, 0x44, 0x12, 0x97, 0xAC, 0x12, 0x97, 0xCB, 0x12, 0x96, 0x04, 0xC0, 0x06, 0xC0, 
+0x07, 0x90, 0xA2, 0xB1, 0x12, 0x08, 0x79, 0x00, 0x00, 0x03, 0xFF, 0x90, 0xA1, 0xF9, 0x12, 0x49, 
+0x3C, 0xF1, 0x85, 0xD0, 0x07, 0xD0, 0x06, 0x12, 0x97, 0xA9, 0x12, 0x97, 0xCB, 0x12, 0x96, 0x04, 
+0xC0, 0x06, 0xC0, 0x07, 0x90, 0xA2, 0xB1, 0x12, 0x08, 0x79, 0x03, 0xFF, 0x00, 0x00, 0x90, 0xA1, 
+0xFD, 0x12, 0x49, 0x3C, 0x78, 0x10, 0xF1, 0x82, 0xD0, 0x07, 0xD0, 0x06, 0x02, 0x7E, 0x92, 0x12, 
+0x49, 0x3C, 0x78, 0x01, 0x02, 0x08, 0x47, 0x90, 0xA2, 0xD7, 0xE0, 0xFF, 0xE4, 0xFC, 0xFD, 0xFE, 
+0x78, 0x1C, 0x12, 0x08, 0x5A, 0x90, 0xA2, 0xB5, 0x02, 0x08, 0x6D, 0x90, 0xA1, 0xF8, 0xEF, 0xF0, 
+0x90, 0xA2, 0xB1, 0x22, 0xF1, 0x8B, 0x12, 0x08, 0x79, 0x80, 0x00, 0x00, 0x00, 0x90, 0xA2, 0xB5, 
+0x12, 0x08, 0x79, 0x80, 0x00, 0x00, 0x00, 0x7F, 0x2C, 0x7E, 0x08, 0x12, 0x97, 0xA9, 0x24, 0x99, 
+0xF5, 0x82, 0xE4, 0x34, 0x44, 0x12, 0x96, 0x04, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0xAA, 0xB9, 0x12, 
+0x08, 0x79, 0x00, 0x00, 0x00, 0x80, 0xD0, 0x07, 0xD0, 0x06, 0x12, 0x38, 0x07, 0x12, 0x97, 0xAC, 
+0x24, 0x9B, 0xF5, 0x82, 0xE4, 0x34, 0x44, 0x12, 0x96, 0x04, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0xAA, 
+0xB9, 0x12, 0x08, 0x79, 0x20, 0x04, 0x00, 0x00, 0xD0, 0x07, 0xD0, 0x06, 0x12, 0x38, 0x07, 0x12, 
+0x97, 0xAC, 0x24, 0x9D, 0xF5, 0x82, 0xE4, 0x34, 0x44, 0x12, 0x96, 0x04, 0xC0, 0x06, 0xC0, 0x07, 
+0x90, 0xAA, 0xB9, 0x12, 0x08, 0x79, 0x20, 0x00, 0x00, 0x00, 0xD0, 0x07, 0xD0, 0x06, 0x12, 0x38, 
+0x07, 0x12, 0x97, 0xAC, 0x24, 0x9F, 0xF5, 0x82, 0xE4, 0x34, 0x44, 0x12, 0x96, 0x04, 0xC0, 0x06, 
+0xC0, 0x07, 0x90, 0xA2, 0xB1, 0x12, 0x08, 0x79, 0x00, 0x00, 0x07, 0xFF, 0x90, 0xA1, 0xFD, 0x12, 
+0x49, 0x3C, 0x12, 0x9F, 0x85, 0xD0, 0x07, 0xD0, 0x06, 0x12, 0x97, 0xA9, 0x24, 0xA1, 0xF5, 0x82, 
+0xE4, 0x34, 0x44, 0x12, 0x96, 0x04, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0xA2, 0xB1, 0x12, 0x08, 0x79, 
+0x00, 0x00, 0x07, 0xFF, 0x90, 0xA1, 0xF9, 0x12, 0x49, 0x3C, 0x12, 0x9F, 0x85, 0xD0, 0x07, 0xD0, 
+0x06, 0x02, 0x7E, 0x92, 0x90, 0xA1, 0xB6, 0xEF, 0xF0, 0xE4, 0xA3, 0xF0, 0x90, 0xA1, 0xD3, 0x12, 
+0x4F, 0x3F, 0x78, 0xDA, 0x7C, 0xA1, 0x7D, 0x01, 0x7B, 0xFF, 0x7A, 0x44, 0x79, 0xC3, 0xFE, 0x7F, 
+0x06, 0x12, 0x06, 0x63, 0xE4, 0x90, 0xA1, 0xD7, 0xF0, 0xA3, 0xF0, 0x90, 0xA0, 0x8D, 0xE0, 0x90, 
+0xA1, 0xD9, 0xF0, 0x90, 0xA2, 0xB1, 0x12, 0x08, 0x79, 0x80, 0x00, 0x00, 0x00, 0x90, 0xA2, 0xB5, 
+0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 0x00, 0x12, 0x7E, 0x8E, 0x12, 0xAC, 0xCB, 0x24, 0x71, 0xF5, 
+0x82, 0xE4, 0x34, 0x44, 0x12, 0x96, 0x04, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0xAA, 0xB9, 0x12, 0x08, 
+0x79, 0x77, 0x77, 0x77, 0x77, 0xD0, 0x07, 0xD0, 0x06, 0x12, 0x38, 0x07, 0x12, 0xAC, 0xCB, 0x24, 
+0x73, 0xF5, 0x82, 0xE4, 0x34, 0x44, 0x12, 0x96, 0x04, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0xAA, 0xB9, 
+0x12, 0x08, 0x79, 0x77, 0x77, 0x77, 0x77, 0xD0, 0x07, 0xD0, 0x06, 0x12, 0x38, 0x07, 0x12, 0xAC, 
+0xCB, 0x24, 0x75, 0xF5, 0x82, 0xE4, 0x34, 0x44, 0x12, 0x96, 0x04, 0xC0, 0x06, 0xC0, 0x07, 0x90, 
+0xAA, 0xB9, 0x12, 0x08, 0x79, 0x19, 0x79, 0x19, 0x79, 0xD0, 0x07, 0xD0, 0x06, 0x12, 0xAC, 0xAE, 
+0x24, 0x8B, 0xF5, 0x82, 0xE4, 0x34, 0x44, 0x12, 0x96, 0x04, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0xA2, 
+0xB1, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 0x0F, 0x90, 0xA2, 0xB5, 0x12, 0x08, 0x79, 0x00, 0x00, 
+0x00, 0x04, 0xD0, 0x07, 0xD0, 0x06, 0x12, 0xAC, 0xC8, 0x12, 0x9D, 0x3A, 0x12, 0x96, 0x04, 0xC0, 
+0x06, 0xC0, 0x07, 0x90, 0xA2, 0xB1, 0x12, 0x08, 0x79, 0x07, 0x00, 0x00, 0x00, 0x90, 0xA2, 0xB5, 
+0x12, 0x08, 0x79, 0x07, 0x00, 0x00, 0x00, 0xD0, 0x07, 0xD0, 0x06, 0x12, 0x7E, 0x88, 0x12, 0x08, 
+0x79, 0x40, 0x00, 0x00, 0x00, 0x90, 0xA2, 0xB5, 0x12, 0x08, 0x79, 0x40, 0x00, 0x00, 0x00, 0x7F, 
+0xC4, 0x7E, 0x08, 0x12, 0xAC, 0xC8, 0x24, 0x79, 0xF5, 0x82, 0xE4, 0x34, 0x44, 0x12, 0x96, 0x04, 
+0xC0, 0x06, 0xC0, 0x07, 0x90, 0xA2, 0xB1, 0x12, 0x08, 0x79, 0x00, 0xFF, 0x00, 0x00, 0x90, 0xA2, 
+0xB5, 0x12, 0x08, 0x79, 0x00, 0x77, 0x00, 0x00, 0xD0, 0x07, 0xD0, 0x06, 0x12, 0xAC, 0xC8, 0x24, 
+0x7B, 0xF5, 0x82, 0xE4, 0x34, 0x44, 0x12, 0x96, 0x04, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0xA2, 0xB1, 
+0x12, 0x08, 0x79, 0x03, 0x00, 0x00, 0x00, 0x90, 0xA2, 0xB5, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 
+0x00, 0xD0, 0x07, 0xD0, 0x06, 0x12, 0xAC, 0xC8, 0x24, 0x7D, 0xF5, 0x82, 0xE4, 0x34, 0x44, 0x12, 
+0x96, 0x04, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0xA2, 0xB1, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 0xFF, 
+0x90, 0xA2, 0xB5, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 0x04, 0xD0, 0x07, 0xD0, 0x06, 0x12, 0x7E, 
+0x88, 0x12, 0x08, 0x79, 0x80, 0x00, 0x00, 0x00, 0x90, 0xA2, 0xB5, 0x12, 0x08, 0x79, 0x00, 0x00, 
+0x00, 0x00, 0x12, 0x7E, 0x8E, 0x90, 0xA1, 0xFA, 0x12, 0x08, 0x79, 0x00, 0x08, 0x00, 0x02, 0x90, 
+0xA1, 0xB6, 0xE0, 0xFF, 0x7D, 0xEF, 0x12, 0xAC, 0xC1, 0x12, 0x08, 0x79, 0x00, 0x02, 0x00, 0x00, 
+0x12, 0xAF, 0xA6, 0x12, 0xAC, 0xC1, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 0x3F, 0x12, 0xAF, 0x9E, 
+0x12, 0xAC, 0xC1, 0x12, 0x08, 0x79, 0x00, 0x0F, 0x3F, 0xC3, 0x12, 0xAF, 0x96, 0x12, 0xAC, 0xC1, 
+0x12, 0x08, 0x79, 0x00, 0x09, 0x31, 0xD5, 0x12, 0xAC, 0xBA, 0x12, 0x08, 0x79, 0x00, 0x08, 0xA0, 
+0x01, 0x12, 0xAF, 0x60, 0x12, 0x77, 0x97, 0x90, 0xAA, 0xB9, 0x12, 0x08, 0x79, 0x00, 0x00, 0x80, 
+0x00, 0x7F, 0x0C, 0x7E, 0x09, 0x12, 0x76, 0xE1, 0x12, 0x08, 0x79, 0x03, 0x00, 0x01, 0x00, 0x7F, 
+0x00, 0x7E, 0x0B, 0x12, 0xAC, 0xAE, 0x24, 0x8D, 0xF5, 0x82, 0xE4, 0x34, 0x44, 0x12, 0x96, 0x04, 
+0xC0, 0x06, 0xC0, 0x07, 0x90, 0xA2, 0xB1, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 0x01, 0x90, 0xA2, 
+0xB5, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 0x01, 0xD0, 0x07, 0xD0, 0x06, 0x12, 0x82, 0xE4, 0x12, 
+0x08, 0x79, 0x29, 0x00, 0x20, 0x00, 0x7F, 0x78, 0x7E, 0x09, 0x12, 0x76, 0xE1, 0x12, 0x08, 0x79, 
+0xA9, 0x00, 0x20, 0x00, 0x7F, 0x7C, 0x7E, 0x09, 0x12, 0x76, 0xE1, 0x12, 0x08, 0x79, 0x00, 0x46, 
+0x29, 0x10, 0x12, 0x82, 0xD5, 0x12, 0x08, 0x79, 0x80, 0x00, 0x00, 0x00, 0x90, 0xA2, 0xB5, 0x12, 
+0x08, 0x79, 0x80, 0x00, 0x00, 0x00, 0x12, 0x7E, 0x8E, 0x90, 0xA0, 0x8E, 0xE0, 0x90, 0xA1, 0xB6, 
+0x30, 0xE0, 0x16, 0x12, 0xAD, 0x63, 0x12, 0x96, 0x04, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0xAA, 0xB9, 
+0x12, 0x08, 0x79, 0x82, 0x14, 0x03, 0xF7, 0x80, 0x14, 0x12, 0xAD, 0x63, 0x12, 0x96, 0x04, 0xC0, 
+0x06, 0xC0, 0x07, 0x90, 0xAA, 0xB9, 0x12, 0x08, 0x79, 0x82, 0x14, 0x03, 0xF1, 0xD0, 0x07, 0xD0, 
+0x06, 0x12, 0x38, 0x07, 0x90, 0xA0, 0x8D, 0xE0, 0x30, 0xE5, 0x19, 0x12, 0xAC, 0xB1, 0x12, 0xAE, 
+0x04, 0x12, 0x96, 0x04, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0xAA, 0xB9, 0x12, 0x08, 0x79, 0x40, 0x16, 
+0x3E, 0x96, 0x80, 0x1E, 0x90, 0xA0, 0x8D, 0xE0, 0x30, 0xE4, 0x1E, 0x12, 0xAC, 0xB1, 0x12, 0xAE, 
+0x04, 0x12, 0x96, 0x04, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0xAA, 0xB9, 0x12, 0x08, 0x79, 0x00, 0x16, 
+0x3E, 0x96, 0xD0, 0x07, 0xD0, 0x06, 0x12, 0x38, 0x07, 0x12, 0xAC, 0xB1, 0x24, 0xA3, 0xF5, 0x82, 
+0xE4, 0x34, 0x44, 0x12, 0x96, 0x04, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0xAA, 0xB9, 0x12, 0x08, 0x79, 
+0x18, 0x00, 0x8C, 0x10, 0xD0, 0x07, 0xD0, 0x06, 0x12, 0xAC, 0xAE, 0x24, 0xA5, 0xF5, 0x82, 0xE4, 
+0x34, 0x44, 0x12, 0x96, 0x04, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0xAA, 0xB9, 0x12, 0x08, 0x79, 0x38, 
+0x00, 0x8C, 0x10, 0xD0, 0x07, 0xD0, 0x06, 0x12, 0xAC, 0xAE, 0x24, 0x93, 0xF5, 0x82, 0xE4, 0x34, 
+0x44, 0x12, 0x96, 0x04, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0xAA, 0xB9, 0x12, 0x08, 0x79, 0x00, 0x00, 
+0x00, 0x00, 0xD0, 0x07, 0xD0, 0x06, 0x12, 0x38, 0x07, 0xE4, 0x90, 0xA1, 0xB7, 0xF0, 0x90, 0xA1, 
+0xB6, 0xE0, 0xFF, 0xE4, 0xFD, 0x12, 0x96, 0x0E, 0x90, 0xA1, 0xD7, 0x12, 0xAE, 0x94, 0x90, 0xA1, 
+0xB7, 0xE0, 0xFA, 0x12, 0xAD, 0x4B, 0x12, 0xAD, 0x70, 0x24, 0x21, 0xF5, 0x82, 0xE4, 0x34, 0xA2, 
+0xF5, 0x83, 0x12, 0x08, 0x6D, 0xEB, 0x60, 0x06, 0x90, 0xA1, 0xD3, 0xE0, 0x04, 0xF0, 0x90, 0xA1, 
+0xB7, 0xE0, 0x04, 0xF0, 0xE0, 0xC3, 0x94, 0x03, 0x40, 0xC4, 0x90, 0xA2, 0xB1, 0x12, 0x08, 0x79, 
+0x80, 0x00, 0x00, 0x00, 0x90, 0xA2, 0xB5, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 0x00, 0x12, 0x7E, 
+0x8E, 0x90, 0xA1, 0xB6, 0xE0, 0xFF, 0x7D, 0x08, 0x12, 0x77, 0x23, 0xE4, 0xFF, 0xEE, 0x54, 0xFC, 
+0xFE, 0xED, 0x54, 0x0F, 0xFD, 0xE4, 0xFC, 0x90, 0xA2, 0xA3, 0x12, 0x08, 0x6D, 0x90, 0xA2, 0x9F, 
+0x12, 0x08, 0x79, 0x00, 0x07, 0xFE, 0x00, 0x90, 0xA1, 0xB6, 0xE0, 0xFF, 0x7D, 0x58, 0x7C, 0x00, 
+0x12, 0x55, 0x30, 0x90, 0xA2, 0xB1, 0x12, 0x08, 0x79, 0x80, 0x00, 0x00, 0x00, 0x90, 0xA2, 0xB5, 
+0x12, 0x08, 0x79, 0x80, 0x00, 0x00, 0x00, 0x12, 0x7E, 0x8E, 0x90, 0xA1, 0xD7, 0xE0, 0x70, 0x02, 
+0xC1, 0x60, 0x90, 0xA2, 0xB1, 0x12, 0x08, 0x79, 0x80, 0x00, 0x00, 0x00, 0x90, 0xA2, 0xB5, 0x12, 
+0x08, 0x79, 0x00, 0x00, 0x00, 0x00, 0x12, 0x7E, 0x8E, 0x90, 0xA1, 0xFA, 0x12, 0x08, 0x79, 0x00, 
+0x08, 0x00, 0x00, 0x90, 0xA1, 0xB6, 0xE0, 0xFF, 0x7D, 0xEF, 0x12, 0xAC, 0xC1, 0x12, 0x08, 0x79, 
+0x00, 0x03, 0x00, 0x00, 0x12, 0xAF, 0xA6, 0x12, 0xAC, 0xC1, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 
+0x2F, 0x12, 0xAF, 0x9E, 0x12, 0xAC, 0xC1, 0x12, 0x08, 0x79, 0x00, 0x0F, 0xFF, 0xBB, 0x12, 0xAF, 
+0x96, 0x12, 0xAC, 0xC1, 0x12, 0x08, 0x79, 0x00, 0x08, 0x80, 0x01, 0x12, 0xAF, 0x60, 0x12, 0xAC, 
+0xC1, 0x12, 0x08, 0x79, 0x00, 0x09, 0x31, 0xD8, 0x12, 0xAC, 0xBA, 0x12, 0x08, 0x79, 0x00, 0x00, 
+0x00, 0x00, 0x90, 0xA1, 0xB6, 0xE0, 0xFF, 0x7D, 0xEF, 0x12, 0x77, 0x97, 0x90, 0xA2, 0xB1, 0x12, 
+0x08, 0x79, 0x80, 0x00, 0x00, 0x00, 0x90, 0xA2, 0xB5, 0x12, 0x08, 0x79, 0x80, 0x00, 0x00, 0x00, 
+0x7F, 0x78, 0x7E, 0x09, 0x12, 0x7E, 0x88, 0x12, 0x08, 0x79, 0x80, 0x00, 0x00, 0x00, 0x90, 0xA2, 
+0xB5, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x7C, 0x7E, 0x09, 0x12, 0x82, 0xE4, 0x12, 
+0x08, 0x79, 0x00, 0x00, 0x80, 0x00, 0x7F, 0x0C, 0x7E, 0x09, 0x12, 0x76, 0xE1, 0x12, 0x08, 0x79, 
+0x00, 0x46, 0xA9, 0x11, 0x12, 0x82, 0xD5, 0x12, 0x08, 0x79, 0x80, 0x00, 0x00, 0x00, 0x90, 0xA2, 
+0xB5, 0x12, 0x08, 0x79, 0x80, 0x00, 0x00, 0x00, 0x12, 0x7E, 0x8E, 0x12, 0xAC, 0xB1, 0x24, 0xA3, 
+0xF5, 0x82, 0xE4, 0x34, 0x44, 0x12, 0x96, 0x04, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0xAA, 0xB9, 0x12, 
+0x08, 0x79, 0x38, 0x00, 0x8C, 0x10, 0xD0, 0x07, 0xD0, 0x06, 0x12, 0xAC, 0xAE, 0x24, 0xA5, 0xF5, 
+0x82, 0xE4, 0x34, 0x44, 0x12, 0x96, 0x04, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0xAA, 0xB9, 0x12, 0x08, 
+0x79, 0x18, 0x00, 0x8C, 0x10, 0xD0, 0x07, 0xD0, 0x06, 0x12, 0xAC, 0xAE, 0x12, 0xAD, 0x68, 0x12, 
+0x96, 0x04, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0xAA, 0xB9, 0x12, 0x08, 0x79, 0x02, 0x14, 0x01, 0x19, 
+0xD0, 0x07, 0xD0, 0x06, 0x12, 0xAC, 0xAE, 0x12, 0xAE, 0x04, 0x12, 0x96, 0x04, 0xC0, 0x06, 0xC0, 
+0x07, 0x90, 0xAA, 0xB9, 0x12, 0x08, 0x79, 0x28, 0x16, 0x14, 0x40, 0xD0, 0x07, 0xD0, 0x06, 0x12, 
+0x38, 0x07, 0xE4, 0x90, 0xA1, 0xB9, 0xF0, 0x90, 0xA2, 0xB1, 0x12, 0x08, 0x79, 0x80, 0x00, 0x00, 
+0x00, 0x90, 0xA2, 0xB5, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x2C, 0x12, 0x7E, 0x86, 
+0x12, 0x08, 0x79, 0x03, 0xFF, 0x80, 0x00, 0x90, 0xA1, 0xB9, 0xE0, 0x12, 0xAD, 0x4B, 0xF5, 0x83, 
+0x12, 0x9F, 0x6F, 0xE4, 0xFF, 0xEE, 0x54, 0x80, 0xFE, 0xEC, 0x54, 0x03, 0xFC, 0x12, 0x9F, 0x85, 
+0x7F, 0x78, 0x7E, 0x09, 0x12, 0x7E, 0x88, 0x12, 0x08, 0x79, 0x00, 0x00, 0x07, 0xFF, 0x90, 0xA1, 
+0xB9, 0xE0, 0x12, 0xAC, 0xDF, 0xEE, 0x54, 0x07, 0xFE, 0xE4, 0xFD, 0xFC, 0x12, 0x9F, 0x85, 0x7F, 
+0x78, 0x7E, 0x09, 0x12, 0x7E, 0x88, 0x12, 0x08, 0x79, 0x80, 0x00, 0x00, 0x00, 0x90, 0xA2, 0xB5, 
+0x12, 0x08, 0x79, 0x80, 0x00, 0x00, 0x00, 0x12, 0x7E, 0x8E, 0x90, 0xA1, 0xB6, 0xE0, 0xFF, 0x7D, 
+0x01, 0x12, 0x96, 0x0E, 0x90, 0xA1, 0xD8, 0x12, 0xAE, 0x94, 0x90, 0xA1, 0xB9, 0xE0, 0xFA, 0x12, 
+0xAE, 0x18, 0x12, 0xAD, 0x70, 0x12, 0xAF, 0x68, 0xF5, 0x83, 0x12, 0x08, 0x6D, 0xEB, 0x60, 0x06, 
+0x90, 0xA1, 0xD4, 0xE0, 0x04, 0xF0, 0x12, 0xAF, 0x8E, 0xC3, 0x94, 0x03, 0x50, 0x02, 0xA1, 0xB7, 
+0x90, 0xA1, 0xD3, 0xE0, 0x70, 0x1C, 0x90, 0xA1, 0xF9, 0x12, 0x08, 0x79, 0x00, 0x00, 0x02, 0x00, 
+0x90, 0xA1, 0xFD, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 0x00, 0x90, 0xA1, 0xB6, 0xE0, 0xFF, 0x02, 
+0x9F, 0x94, 0xE4, 0x90, 0xA1, 0xB9, 0xF0, 0x90, 0xA1, 0xB9, 0xE0, 0xFB, 0x12, 0xAD, 0x4B, 0x12, 
+0xAC, 0xEA, 0xEB, 0x12, 0xAC, 0xF4, 0x12, 0x95, 0xAF, 0x90, 0xA1, 0xB9, 0xE0, 0xFB, 0x12, 0xAC, 
+0xDF, 0x12, 0xAC, 0xD4, 0x12, 0x95, 0xAF, 0x90, 0xA1, 0xB9, 0xE0, 0xFB, 0x12, 0xAE, 0x18, 0x12, 
+0xAE, 0x6B, 0xEB, 0x12, 0xA9, 0x1B, 0x34, 0xA1, 0x12, 0x95, 0xAF, 0x90, 0xA1, 0xB9, 0xE0, 0xFB, 
+0x25, 0xE0, 0x25, 0xE0, 0x12, 0xAF, 0x68, 0x12, 0xAE, 0x6B, 0x12, 0xA8, 0x9F, 0x12, 0x95, 0xAF, 
+0x12, 0xAF, 0x8E, 0x64, 0x03, 0x70, 0xB0, 0xE4, 0x90, 0xA1, 0xB8, 0xF0, 0x90, 0xA1, 0xD3, 0x12, 
+0xA8, 0x98, 0xFE, 0xC3, 0x9F, 0x40, 0x02, 0xE1, 0x78, 0xEE, 0x04, 0x90, 0xA1, 0xBA, 0xF0, 0x90, 
+0xA1, 0xD3, 0x12, 0xA9, 0x35, 0x50, 0x71, 0xEE, 0x12, 0xAC, 0xF4, 0x12, 0xA8, 0x93, 0x12, 0xAC, 
+0xF4, 0x12, 0xA8, 0xD3, 0x12, 0xA9, 0x14, 0x50, 0x57, 0x74, 0xFF, 0x7F, 0xFC, 0x12, 0xA8, 0xED, 
+0x12, 0xA8, 0xB4, 0x40, 0x4B, 0x90, 0xA1, 0xBA, 0xE0, 0x12, 0xAC, 0xD5, 0x12, 0xA8, 0x93, 0x12, 
+0xAC, 0xD5, 0x12, 0xA8, 0xF4, 0x50, 0x39, 0x12, 0xA8, 0xAA, 0x40, 0x34, 0x90, 0xA1, 0xBA, 0xE0, 
+0xFB, 0x12, 0xAC, 0xF4, 0x12, 0xA8, 0x93, 0xFA, 0x12, 0xAC, 0xF4, 0x12, 0xA8, 0xBB, 0x90, 0xA1, 
+0xBB, 0x12, 0x08, 0x6D, 0x12, 0xAC, 0xD4, 0x12, 0x78, 0x51, 0xFF, 0xEA, 0x12, 0xAC, 0xD5, 0x12, 
+0xA8, 0xBB, 0x90, 0xA1, 0xBF, 0x12, 0x08, 0x6D, 0x90, 0xA1, 0xD5, 0x74, 0x01, 0xF0, 0x80, 0x08, 
+0x90, 0xA1, 0xBA, 0xE0, 0x04, 0xF0, 0x80, 0x87, 0x90, 0xA1, 0xD5, 0xE0, 0x64, 0x01, 0x60, 0x08, 
+0x90, 0xA1, 0xB8, 0xE0, 0x04, 0xF0, 0xC1, 0xDC, 0x90, 0xA1, 0xD5, 0xE0, 0xB4, 0x01, 0x0E, 0x90, 
+0xA1, 0xBB, 0x12, 0xA9, 0x2C, 0x90, 0xA1, 0xBF, 0x12, 0xA9, 0x23, 0x80, 0x14, 0x90, 0xA1, 0xF9, 
+0x12, 0x08, 0x79, 0x00, 0x00, 0x02, 0x00, 0x90, 0xA1, 0xFD, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 
+0x00, 0x90, 0xA1, 0xB6, 0xE0, 0xFF, 0x12, 0x9F, 0x94, 0x90, 0xA1, 0xD4, 0xE0, 0x70, 0x17, 0x90, 
+0xA1, 0xF9, 0x12, 0x08, 0x79, 0x00, 0x00, 0x01, 0x00, 0x90, 0xA1, 0xFD, 0x12, 0x08, 0x79, 0x00, 
+0x00, 0x00, 0x00, 0x02, 0xA8, 0x82, 0xE4, 0x90, 0xA1, 0xB8, 0xF0, 0x90, 0xA1, 0xD4, 0x12, 0xA8, 
+0x98, 0xFE, 0xC3, 0x9F, 0x40, 0x03, 0x02, 0xA8, 0x5B, 0xEE, 0x04, 0x90, 0xA1, 0xBA, 0xF0, 0x90, 
+0xA1, 0xD4, 0x12, 0xA9, 0x35, 0x50, 0x63, 0xEE, 0x12, 0xA8, 0x8A, 0x12, 0xA9, 0x1B, 0x34, 0xA1, 
+0x12, 0xA8, 0xD3, 0x12, 0xA9, 0x14, 0x50, 0x4A, 0x74, 0xFF, 0x7F, 0xFC, 0x12, 0xA8, 0xED, 0x11, 
+0xB4, 0x40, 0x3F, 0x90, 0xA1, 0xBA, 0xE0, 0x11, 0xA0, 0x11, 0x93, 0x11, 0xA0, 0x11, 0xF4, 0x50, 
+0x31, 0x11, 0xAA, 0x40, 0x2D, 0x90, 0xA1, 0xBA, 0xE0, 0xFB, 0x11, 0x8A, 0xFA, 0x31, 0x1B, 0x34, 
+0xA1, 0x11, 0xBB, 0x90, 0xA1, 0xC3, 0x12, 0x08, 0x6D, 0x11, 0x9F, 0x12, 0x78, 0x51, 0xFF, 0xEA, 
+0x11, 0xA0, 0x11, 0xBB, 0x90, 0xA1, 0xC7, 0x12, 0x08, 0x6D, 0x90, 0xA1, 0xD6, 0x74, 0x01, 0xF0, 
+0x80, 0x08, 0x90, 0xA1, 0xBA, 0xE0, 0x04, 0xF0, 0x80, 0x95, 0x90, 0xA1, 0xD6, 0xE0, 0x64, 0x01, 
+0x60, 0x09, 0x90, 0xA1, 0xB8, 0xE0, 0x04, 0xF0, 0x02, 0xA7, 0xCB, 0x90, 0xA1, 0xD6, 0xE0, 0xB4, 
+0x01, 0x0C, 0x90, 0xA1, 0xC3, 0x31, 0x2C, 0x90, 0xA1, 0xC7, 0x31, 0x23, 0x80, 0x14, 0x90, 0xA1, 
+0xF9, 0x12, 0x08, 0x79, 0x00, 0x00, 0x01, 0x00, 0x90, 0xA1, 0xFD, 0x12, 0x08, 0x79, 0x00, 0x00, 
+0x00, 0x00, 0x90, 0xA1, 0xB6, 0xE0, 0xFF, 0x02, 0x9E, 0xA3, 0x25, 0xE0, 0x24, 0xEC, 0xF5, 0x82, 
+0xE4, 0x34, 0xA1, 0xF5, 0x83, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x90, 0xA1, 0xB8, 0xE0, 0x22, 0xEB, 
+0x25, 0xE0, 0x24, 0xF2, 0xF5, 0x82, 0xE4, 0x34, 0xA1, 0x22, 0x74, 0xFF, 0x7F, 0xFC, 0xFE, 0xFD, 
+0xFC, 0x90, 0xA1, 0xCF, 0x12, 0x49, 0x48, 0xD3, 0x02, 0x48, 0x87, 0xF5, 0x83, 0xE0, 0xFC, 0xA3, 
+0xE0, 0x2F, 0xFF, 0xEC, 0x3E, 0xA2, 0xE7, 0x13, 0xFE, 0xEF, 0x13, 0xFF, 0xEE, 0x33, 0x95, 0xE0, 
+0xFD, 0xFC, 0x22, 0xF5, 0x83, 0xE0, 0xFC, 0xA3, 0xE0, 0xC3, 0x9F, 0xFF, 0xEC, 0x9E, 0xFE, 0x33, 
+0x95, 0xE0, 0xFD, 0xFC, 0x90, 0xA1, 0xCB, 0x12, 0x08, 0x6D, 0xE4, 0x7F, 0x04, 0xFE, 0xFD, 0xFC, 
+0x90, 0xA1, 0xCB, 0x22, 0xF5, 0x83, 0xE0, 0xFC, 0xA3, 0xE0, 0xC3, 0x9F, 0xFF, 0xEC, 0x9E, 0xFE, 
+0x33, 0x95, 0xE0, 0xFD, 0xFC, 0x90, 0xA1, 0xCF, 0x12, 0x08, 0x6D, 0xE4, 0x7F, 0x04, 0xFE, 0xFD, 
+0xFC, 0x90, 0xA1, 0xCF, 0x12, 0x49, 0x48, 0xC3, 0x02, 0x48, 0x87, 0x25, 0xE0, 0x24, 0xEC, 0xF5, 
+0x82, 0xE4, 0x22, 0x12, 0x49, 0x3C, 0x90, 0xA1, 0xFD, 0x02, 0x08, 0x6D, 0x12, 0x49, 0x3C, 0x90, 
+0xA1, 0xF9, 0x02, 0x08, 0x6D, 0xE0, 0xFF, 0x90, 0xA1, 0xBA, 0xE0, 0xFE, 0xC3, 0x9F, 0x22, 0xC3, 
+0xEF, 0x9D, 0xF5, 0x56, 0xC3, 0x94, 0x08, 0x50, 0x1C, 0xE4, 0xF5, 0x57, 0x51, 0x25, 0xC0, 0x83, 
+0xC0, 0x82, 0x90, 0xA1, 0x47, 0xE0, 0xD0, 0x82, 0xD0, 0x83, 0x75, 0xF0, 0x03, 0x12, 0x49, 0x54, 
+0xE5, 0x56, 0xF0, 0x80, 0x3E, 0xE5, 0x56, 0xC3, 0x94, 0x10, 0x50, 0x09, 0x75, 0x57, 0x01, 0xE5, 
+0x56, 0x24, 0xF8, 0x80, 0x17, 0xE5, 0x56, 0xC3, 0x94, 0x18, 0x50, 0x09, 0x75, 0x57, 0x02, 0xE5, 
+0x56, 0x24, 0xF0, 0x80, 0x07, 0x75, 0x57, 0x03, 0xE5, 0x56, 0x24, 0xE8, 0xFF, 0x51, 0x25, 0xC0, 
+0x83, 0xC0, 0x82, 0x90, 0xA1, 0x47, 0xE0, 0xD0, 0x82, 0xD0, 0x83, 0x75, 0xF0, 0x03, 0x12, 0x49, 
+0x54, 0xEF, 0xF0, 0xAF, 0x57, 0x22, 0x8F, 0x54, 0x8D, 0x55, 0xAE, 0x03, 0x74, 0x1F, 0xC3, 0x95, 
+0x54, 0x40, 0x0F, 0x90, 0xA1, 0x47, 0xEE, 0xF0, 0xAB, 0x55, 0xE4, 0xFD, 0x51, 0x1D, 0x24, 0xD4, 
+0x80, 0x40, 0x74, 0x3F, 0xC3, 0x95, 0x54, 0x40, 0x0F, 0x90, 0xA1, 0x47, 0xEE, 0xF0, 0xAB, 0x55, 
+0x7D, 0x20, 0x51, 0x1B, 0x24, 0x88, 0x80, 0x2A, 0x74, 0x5F, 0xC3, 0x95, 0x54, 0x40, 0x0F, 0x90, 
+0xA1, 0x47, 0xEE, 0xF0, 0xAB, 0x55, 0x7D, 0x40, 0x51, 0x1B, 0x24, 0xD0, 0x80, 0x14, 0x74, 0x7F, 
+0xC3, 0x95, 0x54, 0x40, 0x25, 0x90, 0xA1, 0x47, 0xEE, 0xF0, 0xAB, 0x55, 0x7D, 0x60, 0x51, 0x1B, 
+0x24, 0x84, 0xFD, 0xE4, 0x34, 0x04, 0xFC, 0x75, 0xF0, 0x0E, 0xE5, 0x55, 0x51, 0x39, 0x75, 0xF0, 
+0x03, 0xEE, 0x12, 0x49, 0x54, 0xEC, 0xF0, 0xA3, 0xED, 0xF0, 0x22, 0xAF, 0x54, 0x31, 0x3F, 0x90, 
+0xA1, 0x43, 0xEF, 0xF0, 0x22, 0x75, 0xF0, 0x0E, 0xEB, 0x90, 0xA0, 0x67, 0x02, 0x49, 0x54, 0x31, 
+0xA6, 0xAB, 0x51, 0xAA, 0x52, 0x22, 0x75, 0xF0, 0x0E, 0x90, 0xA0, 0x65, 0x02, 0x49, 0x54, 0x7E, 
+0x00, 0x7F, 0x01, 0x7D, 0x00, 0x7B, 0x01, 0x7A, 0x9F, 0x79, 0x9E, 0x12, 0x08, 0xAA, 0x90, 0x9F, 
+0x9E, 0xE0, 0x54, 0xFD, 0xF0, 0xE4, 0x12, 0x4F, 0x40, 0xA3, 0x74, 0x0C, 0xF0, 0x22, 0x12, 0x5E, 
+0xC9, 0x7D, 0x23, 0x02, 0x4F, 0xEF, 0x12, 0x4C, 0x32, 0x7D, 0x24, 0x02, 0x57, 0xF3, 0x7D, 0x25, 
+0x02, 0x57, 0xF3, 0x51, 0xAC, 0x30, 0xE0, 0x05, 0x90, 0x01, 0x5B, 0xE4, 0xF0, 0x90, 0x06, 0x92, 
+0x74, 0x02, 0xF0, 0x90, 0x01, 0x3C, 0x74, 0x04, 0xF0, 0xE4, 0x90, 0xA2, 0xD4, 0xF0, 0x90, 0xA0, 
+0x4D, 0xE0, 0xC3, 0x13, 0x54, 0x7F, 0x90, 0xA2, 0xD5, 0xF0, 0xE4, 0xFB, 0xFD, 0x7F, 0x58, 0x7E, 
+0x01, 0x12, 0x50, 0x2E, 0x90, 0x9F, 0xA3, 0xE0, 0x44, 0x08, 0xF0, 0x22, 0x90, 0x9F, 0xA3, 0xE0, 
+0x13, 0x13, 0x13, 0x54, 0x1F, 0x22, 0xEF, 0x24, 0xFE, 0x60, 0x0B, 0x04, 0x70, 0x24, 0x90, 0x9F, 
+0xAD, 0x74, 0x02, 0xF0, 0x80, 0x13, 0xED, 0x70, 0x06, 0x90, 0xA0, 0x4E, 0xE0, 0x80, 0x02, 0xED, 
+0x14, 0x90, 0x9F, 0xAD, 0xF0, 0x90, 0x9F, 0xAD, 0xE0, 0xA3, 0xF0, 0x90, 0x9F, 0xA4, 0xE0, 0x44, 
+0x08, 0xF0, 0x22, 0x7D, 0x2E, 0x7F, 0x6F, 0x12, 0x52, 0x45, 0x7D, 0x02, 0x7F, 0x01, 0x12, 0x5A, 
+0x8B, 0x51, 0xFA, 0x90, 0x9F, 0xA2, 0x74, 0x02, 0xF0, 0x22, 0x90, 0x05, 0x27, 0xE0, 0x54, 0xBF, 
+0xF0, 0x22, 0xE4, 0xFD, 0xF9, 0xFC, 0x90, 0x05, 0x62, 0xE0, 0xFE, 0x90, 0x05, 0x61, 0xE0, 0xFB, 
+0xEB, 0x78, 0x02, 0xCE, 0xC3, 0x13, 0xCE, 0x13, 0xD8, 0xF9, 0xFF, 0xEE, 0x54, 0x3F, 0x90, 0x9F, 
+0xE0, 0xF0, 0xA3, 0xEF, 0xF0, 0xA3, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x90, 0x9F, 0xE0, 0xE0, 0xFA, 
+0xA3, 0xE0, 0xFB, 0xC3, 0x9F, 0xEA, 0x9E, 0x40, 0x20, 0xEB, 0x9F, 0xFF, 0x90, 0x9F, 0xBF, 0xE0, 
+0xFE, 0xC3, 0x74, 0x0A, 0x9E, 0x2F, 0xF9, 0xC3, 0x94, 0x19, 0x50, 0x0D, 0x74, 0xC4, 0x29, 0x71, 
+0xEC, 0x04, 0xF0, 0x90, 0x9F, 0xBD, 0xE0, 0x04, 0xF0, 0x90, 0x9F, 0xBD, 0xE0, 0xC3, 0x94, 0x64, 
+0x50, 0x02, 0x61, 0xE8, 0xE4, 0xFC, 0xFD, 0x71, 0xE9, 0x2C, 0xFC, 0xD3, 0x94, 0x05, 0x40, 0x07, 
+0x90, 0xA2, 0x03, 0xED, 0xF0, 0x80, 0x05, 0x0D, 0xED, 0xB4, 0x19, 0xEB, 0xE4, 0xFC, 0xFD, 0x71, 
+0xE9, 0x2C, 0xFC, 0xD3, 0x94, 0x5F, 0x40, 0x07, 0x90, 0xA2, 0x04, 0xED, 0xF0, 0x80, 0x05, 0x0D, 
+0xED, 0xB4, 0x19, 0xEB, 0x90, 0xA2, 0x03, 0xE0, 0x90, 0x9F, 0xC2, 0xF0, 0x90, 0xA2, 0x04, 0xE0, 
+0x90, 0x9F, 0xC3, 0x71, 0xF5, 0x94, 0x0B, 0x40, 0x0A, 0xEF, 0x24, 0xF6, 0x90, 0x9F, 0xBA, 0xF0, 
+0xE4, 0x80, 0x09, 0xE4, 0x90, 0x9F, 0xBA, 0x71, 0xF5, 0x74, 0x0A, 0x9F, 0x90, 0x9F, 0xB9, 0xF0, 
+0x90, 0x9F, 0xC2, 0xE0, 0xFF, 0xA3, 0xE0, 0xC3, 0x9F, 0x90, 0x9F, 0xC0, 0xF0, 0xC3, 0x94, 0x08, 
+0x50, 0x03, 0x74, 0x08, 0xF0, 0x90, 0x9F, 0xBA, 0xE0, 0xFD, 0x90, 0x9F, 0xC0, 0xE0, 0xFB, 0xE4, 
+0xFF, 0x12, 0x8E, 0x1A, 0xE4, 0xFF, 0x71, 0xFD, 0x22, 0x74, 0xC4, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 
+0x9F, 0xF5, 0x83, 0xE0, 0x22, 0xF0, 0x90, 0x9F, 0xC2, 0xE0, 0xFF, 0xC3, 0x22, 0xE4, 0xFE, 0x74, 
+0xC4, 0x2E, 0xF5, 0x82, 0xE4, 0x34, 0x9F, 0xF5, 0x83, 0xE4, 0xF0, 0x0E, 0xEE, 0xB4, 0x19, 0xEF, 
+0xE4, 0x90, 0x9F, 0xBD, 0xF0, 0x90, 0x9F, 0xC1, 0xF0, 0x90, 0x9F, 0xB9, 0xF0, 0xEF, 0xB4, 0x01, 
+0x09, 0x90, 0x9F, 0xC2, 0x74, 0x19, 0xF0, 0xE4, 0xA3, 0xF0, 0x22, 0x7D, 0x2F, 0x7F, 0xFF, 0x12, 
+0x52, 0x45, 0x12, 0x4B, 0xB6, 0x7D, 0x08, 0x7F, 0x01, 0x12, 0x5A, 0x8B, 0x90, 0x9F, 0xA2, 0x74, 
+0x08, 0xF0, 0x22, 0x90, 0xA2, 0xE2, 0xE0, 0xFF, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 
+0xA3, 0x30, 0xEF, 0xF0, 0x90, 0x9E, 0x9A, 0xE0, 0xFF, 0x90, 0x04, 0x1C, 0xE0, 0x6F, 0x70, 0x3E, 
+0x90, 0x9F, 0xAA, 0xE0, 0x64, 0x0E, 0x70, 0x15, 0x90, 0xA3, 0x30, 0xE0, 0x70, 0x30, 0x90, 0x9F, 
+0xA3, 0xE0, 0x54, 0x7F, 0xF0, 0x90, 0x06, 0x04, 0x12, 0x5A, 0x83, 0x80, 0x1E, 0x90, 0x9F, 0xAA, 
+0xE0, 0x64, 0x06, 0x70, 0x19, 0x90, 0xA3, 0x30, 0xE0, 0x60, 0x13, 0x90, 0x9F, 0xA3, 0xE0, 0x54, 
+0xBF, 0xF0, 0x91, 0xA3, 0xF0, 0x90, 0x9F, 0xAA, 0x74, 0x04, 0xF0, 0x12, 0x5E, 0x74, 0xD0, 0xD0, 
+0x92, 0xAF, 0x22, 0x90, 0x06, 0x04, 0xE0, 0x44, 0x40, 0xF0, 0xE0, 0x44, 0x80, 0x22, 0x12, 0x38, 
+0x07, 0x90, 0xA1, 0xB6, 0xE0, 0x75, 0xF0, 0x1C, 0xA4, 0x22, 0x90, 0xA1, 0xB6, 0xE0, 0xFF, 0x7D, 
+0x65, 0x12, 0x77, 0x97, 0x90, 0xA1, 0xFA, 0x22, 0x12, 0x7E, 0x92, 0x90, 0xA1, 0xB6, 0xE0, 0x75, 
+0xF0, 0x0E, 0xA4, 0x22, 0xEB, 0x25, 0xE0, 0x24, 0xE6, 0xF5, 0x82, 0xE4, 0x34, 0xA1, 0x22, 0x25, 
+0xE0, 0x25, 0xE0, 0x24, 0x21, 0xF5, 0x82, 0xE4, 0x34, 0xA2, 0xF5, 0x83, 0x12, 0x49, 0x3C, 0x78, 
+0x10, 0x02, 0x08, 0x47, 0x25, 0xE0, 0x24, 0xE0, 0xF5, 0x82, 0xE4, 0x34, 0xA1, 0x22, 0xFE, 0xE4, 
+0xFD, 0xFC, 0x90, 0xA1, 0xFC, 0x12, 0x08, 0x6D, 0xE4, 0xFF, 0xFE, 0xFD, 0xFC, 0x90, 0xA1, 0xFC, 
+0x12, 0x49, 0x48, 0xC3, 0x02, 0x48, 0x9D, 0x7F, 0x64, 0x7E, 0x08, 0x12, 0x7E, 0x92, 0x90, 0xA2, 
+0xD8, 0x12, 0x49, 0x3C, 0xE4, 0xFF, 0xFE, 0xFD, 0xEC, 0x54, 0x04, 0xFC, 0x90, 0xA2, 0xB1, 0x22, 
+0x8F, 0x57, 0x75, 0xF0, 0x10, 0xEF, 0x90, 0x81, 0x05, 0x02, 0x49, 0x54, 0x12, 0x48, 0xCE, 0x90, 
+0xA1, 0xFA, 0x12, 0x08, 0x6D, 0x90, 0xA1, 0xB6, 0xE0, 0xFF, 0x22, 0x25, 0xE0, 0x25, 0xE0, 0x24, 
+0x15, 0xF5, 0x82, 0xE4, 0x34, 0xA2, 0x22, 0x74, 0x91, 0x25, 0x51, 0xF5, 0x82, 0xE4, 0x34, 0x9C, 
+0xF5, 0x83, 0x22, 0xE0, 0x75, 0xF0, 0x1C, 0xA4, 0x24, 0x8F, 0xF5, 0x82, 0xE4, 0x34, 0x44, 0x22, 
+0xF5, 0x83, 0x12, 0x08, 0x6D, 0x90, 0xA2, 0x49, 0x12, 0x49, 0x3C, 0xEA, 0x25, 0xE0, 0x25, 0xE0, 
+0x22, 0xFD, 0x7C, 0x00, 0x12, 0x07, 0x03, 0xEF, 0x25, 0x55, 0xF5, 0x55, 0xEE, 0x35, 0x54, 0xF5, 
+0x54, 0x22, 0xE5, 0x51, 0x25, 0xE0, 0x24, 0x01, 0xF5, 0x82, 0xE4, 0x34, 0x92, 0xF5, 0x83, 0xE0, 
+0x22, 0x2F, 0xF5, 0x82, 0x74, 0x01, 0x3E, 0xF5, 0x83, 0xE0, 0xFF, 0x90, 0x9E, 0xF0, 0xE0, 0x22, 
+0xE0, 0x54, 0xFE, 0x4E, 0xFE, 0xF0, 0xEF, 0x54, 0x02, 0xFF, 0xEE, 0x54, 0xFD, 0x4F, 0x22, 0x7E, 
+0x00, 0x7F, 0x04, 0x7D, 0x00, 0x7B, 0x01, 0x7A, 0xA0, 0x79, 0x52, 0x22, 0xE0, 0x90, 0x01, 0xBA, 
+0xF0, 0x90, 0x9F, 0xA9, 0xE0, 0x90, 0x01, 0xBB, 0x22, 0x90, 0xA0, 0x6F, 0x12, 0x49, 0x54, 0xE0, 
+0xFF, 0x7E, 0x00, 0x7D, 0x01, 0x22, 0x12, 0x49, 0x48, 0x02, 0x48, 0x6D, 0x90, 0x01, 0x34, 0x74, 
+0x40, 0xF0, 0xFD, 0xE4, 0xFF, 0x02, 0x70, 0xD6, 0x7F, 0x00, 0x7E, 0x0C, 0x12, 0x38, 0x07, 0x7F, 
+0x00, 0x7E, 0x0E, 0x22, 0x24, 0x91, 0xF5, 0x82, 0xE4, 0x34, 0x44, 0x22, 0x12, 0x49, 0x54, 0xE0, 
+0xFC, 0xA3, 0xE0, 0xF5, 0x82, 0x8C, 0x83, 0x22, 0x25, 0xE0, 0x25, 0xE0, 0x24, 0x2D, 0xF5, 0x82, 
+0xE4, 0x34, 0xA2, 0x22, 0x90, 0xA2, 0xFB, 0xE0, 0x24, 0x11, 0xF5, 0x82, 0xE4, 0x34, 0x9E, 0x22, 
+0x74, 0x01, 0x25, 0x51, 0xF5, 0x82, 0xE4, 0x34, 0x94, 0xF5, 0x83, 0x22, 0x74, 0x91, 0x25, 0x51, 
+0xF5, 0x82, 0xE4, 0x34, 0x9A, 0xF5, 0x83, 0x22, 0x90, 0x04, 0xA0, 0xE0, 0xFF, 0xA3, 0xE0, 0xFE, 
+0xEF, 0x64, 0x01, 0x22, 0xEF, 0x13, 0x13, 0x13, 0x54, 0x1F, 0xFE, 0xEF, 0x54, 0x07, 0xFF, 0x22, 
+0xF0, 0x90, 0x9F, 0xB3, 0xA3, 0xE0, 0x90, 0x05, 0x58, 0xF0, 0x22, 0xF5, 0x83, 0x12, 0x49, 0x3C, 
+0x78, 0x11, 0x02, 0x08, 0x47, 0x12, 0x06, 0xA2, 0xFF, 0x12, 0x06, 0x89, 0x54, 0x0F, 0xFD, 0x22, 
+0x90, 0xA0, 0x60, 0xE0, 0xFE, 0xC3, 0x13, 0x54, 0x07, 0x22, 0x90, 0xA3, 0x0A, 0xE0, 0xFF, 0x90, 
+0xA3, 0x08, 0xE0, 0x22, 0xEF, 0xF0, 0xFB, 0x90, 0xA2, 0x45, 0x02, 0x49, 0x3C, 0x90, 0xA2, 0xFF, 
+0xE0, 0xFF, 0x74, 0x64, 0xD3, 0x9F, 0x22, 0x90, 0xA2, 0xFF, 0xE0, 0xFF, 0x74, 0x24, 0xD3, 0x9F, 
+0x22, 0x90, 0xA1, 0x42, 0x12, 0x49, 0x60, 0x75, 0xF0, 0x02, 0x22, 0xD3, 0xE5, 0x57, 0x94, 0xE8, 
+0xE5, 0x56, 0x94, 0x03, 0x22, 0xD3, 0x9F, 0xEE, 0x64, 0x80, 0xF8, 0x74, 0x80, 0x98, 0x22, 0x74, 
+0x01, 0x93, 0x95, 0x55, 0xE4, 0x93, 0x95, 0x54, 0x22, 0xE5, 0x56, 0xC3, 0x13, 0xFE, 0xE5, 0x57, 
+0x13, 0xFF, 0x22, 0xAB, 0x51, 0xAA, 0x52, 0xA9, 0x53, 0x02, 0x06, 0x89, 0xD2, 0xAF, 0xC2, 0xAF, 
+0x90, 0x9E, 0x92, 0xE0, 0xFF, 0x22, 0x12, 0x49, 0x54, 0xE0, 0xFB, 0xE4, 0xFD, 0x0F, 0x22, 0x12, 
+0x07, 0xAB, 0xAE, 0xF0, 0xA8, 0x59, 0x08, 0x22, 0x54, 0x01, 0xC4, 0x33, 0x33, 0x33, 0x54, 0x80, 
+0x22, 0xE4, 0x90, 0xA2, 0xD4, 0xF0, 0xA3, 0x74, 0x03, 0x22, 0xEF, 0xF0, 0xA3, 0xED, 0xF0, 0xE4, 
+0xA3, 0xF0, 0x22, 0xE0, 0xFF, 0xA3, 0xE0, 0xFD, 0xA3, 0xE0, 0xFB, 0x22, 0xE5, 0x6D, 0x75, 0xF0, 
+0x08, 0xA4, 0x25, 0x6C, 0x22, 0xFF, 0x90, 0xA2, 0xFD, 0xE0, 0xFB, 0xEF, 0x5B, 0x22, 0xE5, 0x69, 
+0x54, 0x7F, 0x90, 0xA2, 0xC2, 0xF0, 0x22, 0x7F, 0xB4, 0x7E, 0x08, 0x12, 0x37, 0xBC, 0xEF, 0x22, 
+0xF0, 0x7F, 0x10, 0x7E, 0x00, 0x02, 0x3D, 0x7A, 0x90, 0x06, 0x0A, 0xE0, 0x54, 0xF8, 0xF0, 0x22, 
+0x90, 0xA1, 0xB6, 0xE0, 0xFF, 0x7D, 0x8F, 0x22, 0x24, 0x39, 0xF5, 0x82, 0xE4, 0x34, 0xA2, 0x22, 
+0x90, 0x06, 0x04, 0xE0, 0x54, 0x7F, 0xF0, 0x22, 0x7F, 0xB4, 0x7E, 0x08, 0x02, 0x38, 0x07, 0x7F, 
+0x00, 0x7E, 0x0E, 0x02, 0x38, 0x07, 0xC4, 0x54, 0x0F, 0x90, 0xA3, 0x02, 0xF0, 0x22, 0x90, 0xA1, 
+0xB9, 0xE0, 0x04, 0xF0, 0xE0, 0x22, 0x90, 0xA1, 0xB6, 0xE0, 0xFF, 0x7D, 0x32, 0x22, 0x90, 0xA1, 
+0xB6, 0xE0, 0xFF, 0x7D, 0x31, 0x22, 0x90, 0xA1, 0xB6, 0xE0, 0xFF, 0x7D, 0x30, 0x22, 0x7F, 0x01, 
+0x7E, 0x00, 0x02, 0x3C, 0xEC, 0x7F, 0x60, 0x7E, 0x08, 0x02, 0x7E, 0x92, 0x74, 0x01, 0x7E, 0x00, 
+0xA8, 0x6C, 0x08, 0x22, 0x54, 0x03, 0x4F, 0xFF, 0x75, 0xF0, 0x10, 0x22, 0xFF, 0x12, 0x06, 0x89, 
+0xFE, 0x54, 0x0F, 0x22, 0x92, 0x4A, 
+};
+u4Byte ArrayLength_MP_8821A_FW_NIC = 28662;
+
+
+void
+ODM_ReadFirmware_MP_8821A_FW_NIC(
+     IN   PDM_ODM_T    pDM_Odm,
+     OUT  u1Byte       *pFirmware,
+     OUT  u4Byte       *pFirmwareSize
+)
+{
+#if (DM_ODM_SUPPORT_TYPE & (ODM_CE))
+	*((SIZE_PTR *)pFirmware) = (SIZE_PTR)Array_MP_8821A_FW_NIC;
+#else
+	ODM_MoveMemory(pDM_Odm, pFirmware, Array_MP_8821A_FW_NIC, ArrayLength_MP_8821A_FW_NIC);
+#endif
+	*pFirmwareSize = ArrayLength_MP_8821A_FW_NIC;
+}
+
+
+u1Byte Array_MP_8821A_FW_NIC_BT[] = {
+0x01, 0x21, 0x13, 0x00, 0x1C, 0x00, 0x00, 0x00, 0x09, 0x05, 0x15, 0x19, 0x8A, 0x69, 0x00, 0x00, 
+0xD0, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x02, 0x48, 0x6D, 0x02, 0x67, 0xEF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x02, 0x68, 0x54, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x02, 0x78, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x02, 0x67, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x70, 0x0D, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x02, 0x78, 0x06, 0x15, 0xF0, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x15, 0xF0, 0x0F, 
+0x00, 0x00, 0x00, 0x00, 0x05, 0xF0, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x05, 0xF0, 0x0F, 0x00, 0x00, 
+0x00, 0x00, 0x10, 0xF0, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x10, 0xF0, 0x0F, 0x00, 0x00, 0x00, 0x00, 
+0xF5, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0D, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0xF0, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x10, 0xF0, 0x3F, 0x00, 
+0x00, 0x00, 0x00, 0x15, 0xF0, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x15, 0xF0, 0xCF, 0xFF, 0x00, 0x00, 
+0x00, 0x0A, 0x08, 0x03, 0x03, 0x00, 0x04, 0x09, 0x07, 0x03, 0x03, 0x00, 0x04, 0x08, 0x06, 0x03, 
+0x02, 0x00, 0x04, 0x08, 0x05, 0x03, 0x01, 0x00, 0x04, 0x0D, 0x0A, 0x07, 0x05, 0x00, 0x08, 0x0C, 
+0x0A, 0x07, 0x04, 0x00, 0x08, 0x0B, 0x0A, 0x06, 0x05, 0x00, 0x08, 0x0B, 0x0A, 0x05, 0x03, 0x00, 
+0x08, 0x0B, 0x0A, 0x03, 0x02, 0x00, 0x08, 0x14, 0x12, 0x0C, 0x04, 0x00, 0x10, 0x14, 0x12, 0x09, 
+0x04, 0x00, 0x10, 0x24, 0x22, 0x1C, 0x12, 0x00, 0x20, 0x24, 0x22, 0x18, 0x0C, 0x00, 0x20, 0x24, 
+0x22, 0x14, 0x06, 0x00, 0x20, 0x24, 0x22, 0x0F, 0x04, 0x00, 0x20, 0x24, 0x21, 0x0A, 0x04, 0x00, 
+0x20, 0x23, 0x21, 0x0C, 0x04, 0x00, 0x20, 0x23, 0x1F, 0x0A, 0x04, 0x00, 0x20, 0x22, 0x1F, 0x0F, 
+0x04, 0x00, 0x20, 0x21, 0x1F, 0x16, 0x0C, 0x00, 0x20, 0x31, 0x2F, 0x20, 0x14, 0x00, 0x30, 0x31, 
+0x2F, 0x18, 0x10, 0x00, 0x30, 0x31, 0x2C, 0x18, 0x0C, 0x00, 0x30, 0x31, 0x2A, 0x14, 0x0C, 0x00, 
+0x30, 0x31, 0x28, 0x14, 0x00, 0x00, 0x30, 0x31, 0x24, 0x14, 0x00, 0x00, 0x30, 0x31, 0x1E, 0x14, 
+0x00, 0x00, 0x30, 0x04, 0x04, 0x04, 0x05, 0x04, 0x04, 0x05, 0x07, 0x07, 0x07, 0x08, 0x0A, 0x04, 
+0x07, 0x0A, 0x0E, 0x11, 0x13, 0x14, 0x15, 0x03, 0x04, 0x07, 0x07, 0x08, 0x0B, 0x0D, 0x0F, 0x05, 
+0x05, 0x07, 0x07, 0x08, 0x0B, 0x0D, 0x0F, 0x05, 0x05, 0x07, 0x07, 0x08, 0x0B, 0x0D, 0x0F, 0x07, 
+0x08, 0x08, 0x0A, 0x0A, 0x0C, 0x0E, 0x10, 0x11, 0x11, 0x07, 0x09, 0x09, 0x0B, 0x0B, 0x0D, 0x0F, 
+0x13, 0x13, 0x14, 0x05, 0x05, 0x07, 0x07, 0x08, 0x0B, 0x0D, 0x0F, 0x0F, 0x0F, 0x05, 0x05, 0x07, 
+0x07, 0x08, 0x0B, 0x0D, 0x0F, 0x0F, 0x0F, 0x04, 0x04, 0x04, 0x05, 0x07, 0x07, 0x09, 0x09, 0x0C, 
+0x0E, 0x10, 0x12, 0x05, 0x06, 0x07, 0x0D, 0x10, 0x11, 0x12, 0x12, 0x07, 0x08, 0x09, 0x09, 0x0C, 
+0x0E, 0x11, 0x13, 0x09, 0x09, 0x09, 0x09, 0x0C, 0x0E, 0x11, 0x13, 0x09, 0x09, 0x09, 0x09, 0x0C, 
+0x0E, 0x11, 0x13, 0x05, 0x06, 0x08, 0x09, 0x0C, 0x0E, 0x12, 0x12, 0x13, 0x14, 0x07, 0x08, 0x09, 
+0x0A, 0x0C, 0x0F, 0x12, 0x12, 0x14, 0x16, 0x09, 0x09, 0x09, 0x09, 0x0C, 0x0E, 0x11, 0x13, 0x13, 
+0x13, 0x09, 0x09, 0x09, 0x09, 0x0C, 0x0E, 0x11, 0x13, 0x13, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x24, 0x26, 0x2A, 0x00, 0x00, 0x00, 0x1F, 0x21, 0x25, 0x27, 0x28, 0x00, 
+0x00, 0x00, 0x00, 0x23, 0x26, 0x28, 0x2A, 0x00, 0x00, 0x00, 0x00, 0x23, 0x26, 0x28, 0x2A, 0x00, 
+0x00, 0x00, 0x00, 0x23, 0x26, 0x28, 0x2A, 0x00, 0x00, 0x00, 0x00, 0x20, 0x25, 0x27, 0x29, 0x29, 
+0x2A, 0x00, 0x00, 0x00, 0x00, 0x20, 0x25, 0x27, 0x29, 0x29, 0x2A, 0x00, 0x00, 0x00, 0x00, 0x23, 
+0x26, 0x28, 0x2A, 0x2A, 0x2A, 0x00, 0x00, 0x00, 0x1F, 0x23, 0x26, 0x28, 0x2A, 0x2A, 0x2A, 0x00, 
+0x04, 0x00, 0x04, 0x00, 0x08, 0x00, 0x10, 0x00, 0x18, 0x00, 0x24, 0x00, 0x30, 0x00, 0x48, 0x00, 
+0x60, 0x00, 0x90, 0x00, 0xC0, 0x00, 0xD8, 0x00, 0x3C, 0x00, 0x64, 0x00, 0x78, 0x00, 0xA0, 0x00, 
+0xF0, 0x01, 0x40, 0x01, 0x90, 0x01, 0xE0, 0x00, 0xA0, 0x00, 0xF0, 0x01, 0x40, 0x01, 0x90, 0x02, 
+0x58, 0x03, 0x20, 0x04, 0xB0, 0x06, 0x40, 0x00, 0xC8, 0x01, 0x18, 0x01, 0xE0, 0x02, 0xD0, 0x03, 
+0xE8, 0x04, 0xB0, 0x06, 0x40, 0x07, 0xD0, 0x00, 0xC8, 0x01, 0x18, 0x01, 0xE0, 0x02, 0xD0, 0x03, 
+0xE8, 0x04, 0xB0, 0x06, 0x40, 0x07, 0xD0, 0x00, 0x3C, 0x00, 0x50, 0x00, 0x64, 0x00, 0xA0, 0x00, 
+0xF0, 0x01, 0x40, 0x01, 0x90, 0x01, 0xE0, 0x02, 0x58, 0x03, 0x20, 0x00, 0x78, 0x00, 0xF0, 0x01, 
+0x90, 0x02, 0x58, 0x03, 0xE8, 0x07, 0xD0, 0x09, 0x60, 0x0F, 0xA0, 0x12, 0xC0, 0x15, 0x18, 0x00, 
+0xC8, 0x01, 0x18, 0x01, 0xE0, 0x02, 0xD0, 0x03, 0xE8, 0x04, 0xB0, 0x06, 0x40, 0x07, 0xD0, 0x07, 
+0xD0, 0x07, 0xD0, 0x00, 0xC8, 0x01, 0x18, 0x01, 0xE0, 0x02, 0xD0, 0x03, 0xE8, 0x04, 0xB0, 0x06, 
+0x40, 0x07, 0xD0, 0x07, 0xD0, 0x07, 0xD0, 0x00, 0x02, 0x00, 0x02, 0x00, 0x04, 0x00, 0x08, 0x00, 
+0x0C, 0x00, 0x12, 0x00, 0x18, 0x00, 0x24, 0x00, 0x30, 0x00, 0x48, 0x00, 0x60, 0x00, 0x6C, 0x00, 
+0x14, 0x00, 0x32, 0x00, 0x3C, 0x00, 0x50, 0x00, 0x78, 0x00, 0xA0, 0x00, 0xC8, 0x00, 0xF0, 0x00, 
+0x50, 0x00, 0x78, 0x00, 0xA0, 0x00, 0xC8, 0x01, 0x2C, 0x01, 0x90, 0x02, 0x58, 0x03, 0x20, 0x00, 
+0x64, 0x00, 0x8C, 0x00, 0xF0, 0x01, 0x68, 0x01, 0xF4, 0x02, 0x58, 0x03, 0x20, 0x03, 0xE8, 0x00, 
+0x64, 0x00, 0x8C, 0x00, 0xF0, 0x01, 0x68, 0x01, 0xF4, 0x02, 0x58, 0x03, 0x20, 0x03, 0xE8, 0x00, 
+0x1E, 0x00, 0x28, 0x00, 0x32, 0x00, 0x50, 0x00, 0x78, 0x00, 0xA0, 0x00, 0xC8, 0x00, 0xF0, 0x01, 
+0x2C, 0x01, 0x90, 0x00, 0x3C, 0x00, 0x78, 0x00, 0xC8, 0x01, 0x2C, 0x01, 0xF4, 0x03, 0xE8, 0x04, 
+0xB0, 0x07, 0xD0, 0x09, 0x60, 0x0A, 0xF0, 0x00, 0x64, 0x00, 0x8C, 0x00, 0xF0, 0x01, 0x68, 0x01, 
+0xF4, 0x02, 0x58, 0x03, 0x20, 0x03, 0xE8, 0x03, 0xE8, 0x03, 0xE8, 0x00, 0x64, 0x00, 0x8C, 0x00, 
+0xF0, 0x01, 0x68, 0x01, 0xF4, 0x02, 0x58, 0x03, 0x20, 0x03, 0xE8, 0x03, 0xE8, 0x03, 0xE8, 0x02, 
+0x04, 0x06, 0x08, 0x0A, 0x0C, 0x10, 0x18, 0x20, 0x30, 0x40, 0x50, 0x01, 0x01, 0x01, 0x02, 0x01, 
+0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x02, 0x04, 0x06, 0x07, 0x07, 0x08, 0x08, 0x08, 0x02, 
+0x02, 0x03, 0x03, 0x05, 0x05, 0x06, 0x06, 0x05, 0x06, 0x06, 0x07, 0x07, 0x08, 0x09, 0x0A, 0x05, 
+0x06, 0x06, 0x07, 0x07, 0x08, 0x09, 0x0A, 0x05, 0x06, 0x06, 0x07, 0x07, 0x08, 0x09, 0x0A, 0x0A, 
+0x0B, 0x05, 0x06, 0x06, 0x07, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0B, 0x05, 0x06, 0x06, 0x07, 0x07, 
+0x08, 0x09, 0x0A, 0x0A, 0x0B, 0x05, 0x06, 0x06, 0x07, 0x07, 0x08, 0x09, 0x0A, 0x0A, 0x0B, 0x01, 
+0x01, 0x01, 0x01, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 
+0x06, 0x07, 0x08, 0x02, 0x04, 0x06, 0x07, 0x08, 0x0A, 0x0B, 0x0C, 0x03, 0x05, 0x06, 0x07, 0x08, 
+0x0A, 0x0B, 0x0C, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x02, 0x04, 0x06, 0x07, 0x08, 
+0x09, 0x0B, 0x0C, 0x0C, 0x0C, 0x03, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0B, 0x0C, 0x0C, 0x0C, 0x05, 
+0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0C, 0x0C, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 
+0x0C, 0x0C, 0x0C, 0x19, 0x06, 0x04, 0x02, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0xC2, 0xAF, 0x80, 0xFE, 0x32, 0x12, 0x45, 0xC4, 0x85, 0xD0, 0x0B, 0x75, 0xD0, 0x08, 0xAA, 0xE0, 
+0xC2, 0x8C, 0xE5, 0x8A, 0x24, 0x67, 0xF5, 0x8A, 0xE5, 0x8C, 0x34, 0x79, 0xF5, 0x8C, 0xD2, 0x8C, 
+0xEC, 0x24, 0x87, 0xF8, 0xE6, 0xBC, 0x02, 0x02, 0x74, 0xFF, 0xC3, 0x95, 0x81, 0xB4, 0x40, 0x00, 
+0x40, 0xCE, 0x79, 0x03, 0x78, 0x80, 0x16, 0xE6, 0x08, 0x70, 0x0B, 0xC2, 0xAF, 0xE6, 0x30, 0xE1, 
+0x03, 0x44, 0x18, 0xF6, 0xD2, 0xAF, 0x08, 0xD9, 0xED, 0xEA, 0x8B, 0xD0, 0x22, 0xE5, 0x0C, 0xFF, 
+0x23, 0x24, 0x81, 0xF8, 0x0F, 0x08, 0x08, 0xBF, 0x03, 0x04, 0x7F, 0x00, 0x78, 0x81, 0xE6, 0x30, 
+0xE4, 0xF2, 0x00, 0xE5, 0x0C, 0xC3, 0x9F, 0x50, 0x20, 0x05, 0x0C, 0x74, 0x86, 0x25, 0x0C, 0xF8, 
+0xE6, 0xFD, 0xA6, 0x81, 0x08, 0xE6, 0xAE, 0x0C, 0xBE, 0x02, 0x02, 0x74, 0xFF, 0xCD, 0xF8, 0xE8, 
+0x6D, 0x60, 0xE0, 0x08, 0xE6, 0xC0, 0xE0, 0x80, 0xF6, 0xE5, 0x0C, 0xD3, 0x9F, 0x40, 0x27, 0xE5, 
+0x0C, 0x24, 0x87, 0xF8, 0xE6, 0xAE, 0x0C, 0xBE, 0x02, 0x02, 0x74, 0xFF, 0xFD, 0x18, 0xE6, 0xCD, 
+0xF8, 0xE5, 0x81, 0x6D, 0x60, 0x06, 0xD0, 0xE0, 0xF6, 0x18, 0x80, 0xF5, 0xE5, 0x0C, 0x24, 0x86, 
+0xC8, 0xF6, 0x15, 0x0C, 0x80, 0xD3, 0xE5, 0x0C, 0x23, 0x24, 0x81, 0xF8, 0x7F, 0x04, 0xC2, 0xAF, 
+0xE6, 0x30, 0xE0, 0x03, 0x10, 0xE2, 0x0C, 0x7F, 0x00, 0x30, 0xE1, 0x07, 0x30, 0xE3, 0x04, 0x7F, 
+0x08, 0x54, 0xF4, 0x54, 0x7C, 0xC6, 0xD2, 0xAF, 0x54, 0x80, 0x42, 0x07, 0x22, 0x78, 0x86, 0xA6, 
+0x81, 0x74, 0x02, 0x60, 0x06, 0xFF, 0x08, 0x76, 0xFF, 0xDF, 0xFB, 0x7F, 0x03, 0xE4, 0x78, 0x80, 
+0xF6, 0x08, 0xF6, 0x08, 0xDF, 0xFA, 0x78, 0x81, 0x76, 0x30, 0x90, 0x49, 0x86, 0x74, 0x01, 0x93, 
+0xC0, 0xE0, 0xE4, 0x93, 0xC0, 0xE0, 0x43, 0x89, 0x01, 0x75, 0x8A, 0x60, 0x75, 0x8C, 0x79, 0xD2, 
+0x8C, 0xD2, 0xAF, 0x22, 0x02, 0xEF, 0xD3, 0x94, 0x02, 0x40, 0x03, 0x7F, 0xFF, 0x22, 0x74, 0x81, 
+0x2F, 0x2F, 0xF8, 0xE6, 0x20, 0xE5, 0xF4, 0xC2, 0xAF, 0xE6, 0x44, 0x30, 0xF6, 0xD2, 0xAF, 0xAE, 
+0x0C, 0xEE, 0xC3, 0x9F, 0x50, 0x21, 0x0E, 0x74, 0x86, 0x2E, 0xF8, 0xE6, 0xF9, 0x08, 0xE6, 0x18, 
+0xBE, 0x02, 0x02, 0x74, 0xFF, 0xFD, 0xED, 0x69, 0x60, 0x09, 0x09, 0xE7, 0x19, 0x19, 0xF7, 0x09, 
+0x09, 0x80, 0xF3, 0x16, 0x16, 0x80, 0xDA, 0xEE, 0xD3, 0x9F, 0x40, 0x04, 0x05, 0x81, 0x05, 0x81, 
+0xEE, 0xD3, 0x9F, 0x40, 0x22, 0x74, 0x86, 0x2E, 0xF8, 0x08, 0xE6, 0xF9, 0xEE, 0xB5, 0x0C, 0x02, 
+0xA9, 0x81, 0x18, 0x06, 0x06, 0xE6, 0xFD, 0xED, 0x69, 0x60, 0x09, 0x19, 0x19, 0xE7, 0x09, 0x09, 
+0xF7, 0x19, 0x80, 0xF3, 0x1E, 0x80, 0xD9, 0xEF, 0x24, 0x86, 0xF8, 0xE6, 0x04, 0xF8, 0xEF, 0x2F, 
+0x04, 0x90, 0x49, 0x86, 0x93, 0xF6, 0x08, 0xEF, 0x2F, 0x93, 0xF6, 0x7F, 0x00, 0x22, 0xEF, 0xD3, 
+0x94, 0x02, 0x40, 0x03, 0x7F, 0xFF, 0x22, 0xEF, 0x23, 0x24, 0x81, 0xF8, 0xE6, 0x30, 0xE5, 0xF4, 
+0xC2, 0xAF, 0xE6, 0x54, 0x8C, 0xF6, 0xD2, 0xAF, 0xE5, 0x0C, 0xB5, 0x07, 0x0A, 0x74, 0x86, 0x2F, 
+0xF8, 0xE6, 0xF5, 0x81, 0x02, 0x46, 0x0D, 0x50, 0x2E, 0x74, 0x87, 0x2F, 0xF8, 0xE6, 0xBF, 0x02, 
+0x02, 0x74, 0xFF, 0xFD, 0x18, 0xE6, 0xF9, 0x74, 0x86, 0x2F, 0xF8, 0xFB, 0xE6, 0xFC, 0xE9, 0x6C, 
+0x60, 0x08, 0xA8, 0x05, 0xE7, 0xF6, 0x1D, 0x19, 0x80, 0xF4, 0xA8, 0x03, 0xA6, 0x05, 0x1F, 0xE5, 
+0x0C, 0xB5, 0x07, 0xE3, 0x7F, 0x00, 0x22, 0x74, 0x87, 0x2F, 0xF8, 0xE6, 0xFD, 0x18, 0x86, 0x01, 
+0x0F, 0x74, 0x86, 0x2F, 0xF8, 0xA6, 0x01, 0x08, 0x86, 0x04, 0xE5, 0x0C, 0xB5, 0x07, 0x02, 0xAC, 
+0x81, 0xED, 0x6C, 0x60, 0x08, 0x0D, 0x09, 0xA8, 0x05, 0xE6, 0xF7, 0x80, 0xF4, 0xE5, 0x0C, 0xB5, 
+0x07, 0xDE, 0x89, 0x81, 0x7F, 0x00, 0x22, 0xEF, 0xD3, 0x94, 0x02, 0x40, 0x03, 0x7F, 0xFF, 0x22, 
+0xEF, 0x23, 0x24, 0x81, 0xF8, 0xC2, 0xAF, 0xE6, 0x30, 0xE5, 0x05, 0x30, 0xE0, 0x02, 0xD2, 0xE4, 
+0xD2, 0xE2, 0xC6, 0xD2, 0xAF, 0x7F, 0x00, 0x30, 0xE2, 0x01, 0x0F, 0x02, 0x46, 0x0C, 0x8F, 0xF0, 
+0xE4, 0xFF, 0xFE, 0xE5, 0x0C, 0x23, 0x24, 0x80, 0xF8, 0xC2, 0xA9, 0x30, 0xF7, 0x0D, 0x7F, 0x08, 
+0xE6, 0x60, 0x0B, 0x2D, 0xF6, 0x60, 0x32, 0x50, 0x30, 0x80, 0x07, 0x30, 0xF1, 0x06, 0xED, 0xF6, 
+0x60, 0x27, 0x7E, 0x02, 0x08, 0x30, 0xF0, 0x10, 0xC2, 0xAF, 0xE6, 0x10, 0xE7, 0x25, 0x0E, 0x30, 
+0xE2, 0x0C, 0xD2, 0xAF, 0x7F, 0x04, 0x80, 0x14, 0xC2, 0xAF, 0xE6, 0x10, 0xE7, 0x15, 0x54, 0xEC, 
+0x4E, 0xF6, 0xD2, 0xAF, 0xD2, 0xA9, 0x02, 0x46, 0x0D, 0x7F, 0x08, 0x08, 0xEF, 0x44, 0x83, 0xF4, 
+0xC2, 0xAF, 0x56, 0xC6, 0xD2, 0xAF, 0xD2, 0xA9, 0x54, 0x80, 0x4F, 0xFF, 0x22, 0x02, 0x48, 0xAB, 
+0x02, 0x46, 0x9D, 0xE4, 0x93, 0xA3, 0xF8, 0xE4, 0x93, 0xA3, 0x40, 0x03, 0xF6, 0x80, 0x01, 0xF2, 
+0x08, 0xDF, 0xF4, 0x80, 0x29, 0xE4, 0x93, 0xA3, 0xF8, 0x54, 0x07, 0x24, 0x0C, 0xC8, 0xC3, 0x33, 
+0xC4, 0x54, 0x0F, 0x44, 0x20, 0xC8, 0x83, 0x40, 0x04, 0xF4, 0x56, 0x80, 0x01, 0x46, 0xF6, 0xDF, 
+0xE4, 0x80, 0x0B, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x90, 0x49, 0x66, 0xE4, 0x7E, 
+0x01, 0x93, 0x60, 0xBC, 0xA3, 0xFF, 0x54, 0x3F, 0x30, 0xE5, 0x09, 0x54, 0x1F, 0xFE, 0xE4, 0x93, 
+0xA3, 0x60, 0x01, 0x0E, 0xCF, 0x54, 0xC0, 0x25, 0xE0, 0x60, 0xA8, 0x40, 0xB8, 0xE4, 0x93, 0xA3, 
+0xFA, 0xE4, 0x93, 0xA3, 0xF8, 0xE4, 0x93, 0xA3, 0xC8, 0xC5, 0x82, 0xC8, 0xCA, 0xC5, 0x83, 0xCA, 
+0xF0, 0xA3, 0xC8, 0xC5, 0x82, 0xC8, 0xCA, 0xC5, 0x83, 0xCA, 0xDF, 0xE9, 0xDE, 0xE7, 0x80, 0xBE, 
+0xEF, 0x5B, 0xFF, 0xEE, 0x5A, 0xFE, 0xED, 0x59, 0xFD, 0xEC, 0x58, 0xFC, 0x22, 0xEF, 0x4B, 0xFF, 
+0xEE, 0x4A, 0xFE, 0xED, 0x49, 0xFD, 0xEC, 0x48, 0xFC, 0x22, 0xE0, 0xFC, 0xA3, 0xE0, 0xFD, 0xA3, 
+0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x22, 0xE0, 0xF8, 0xA3, 0xE0, 0xF9, 0xA3, 0xE0, 0xFA, 0xA3, 0xE0, 
+0xFB, 0x22, 0xA4, 0x25, 0x82, 0xF5, 0x82, 0xE5, 0xF0, 0x35, 0x83, 0xF5, 0x83, 0x22, 0xE0, 0xFB, 
+0xA3, 0xE0, 0xFA, 0xA3, 0xE0, 0xF9, 0x22, 0xEB, 0xF0, 0xA3, 0xEA, 0xF0, 0xA3, 0xE9, 0xF0, 0x22, 
+0xD0, 0x83, 0xD0, 0x82, 0xF8, 0xE4, 0x93, 0x70, 0x12, 0x74, 0x01, 0x93, 0x70, 0x0D, 0xA3, 0xA3, 
+0x93, 0xF8, 0x74, 0x01, 0x93, 0xF5, 0x82, 0x88, 0x83, 0xE4, 0x73, 0x74, 0x02, 0x93, 0x68, 0x60, 
+0xEF, 0xA3, 0xA3, 0xA3, 0x80, 0xDF, 0x41, 0xA1, 0xCC, 0x00, 0x41, 0xA1, 0xCD, 0x00, 0x41, 0xA1, 
+0xCE, 0x00, 0x41, 0xA1, 0xD2, 0x00, 0x01, 0x72, 0x00, 0x41, 0xA1, 0xD3, 0x00, 0x41, 0xA1, 0xD4, 
+0x00, 0x41, 0xA1, 0xF0, 0x00, 0x00, 0x4B, 0xBC, 0x58, 0x06, 0x60, 0x80, 0xE4, 0xFD, 0x7F, 0x8D, 
+0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x8F, 0x82, 0x75, 0x83, 0x00, 0xED, 0x12, 0xA9, 0x57, 
+0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0xB1, 0xD3, 0x20, 0xE6, 
+0x02, 0x41, 0x60, 0x90, 0x00, 0x8C, 0xE0, 0xF5, 0x70, 0x7F, 0x8D, 0x51, 0xB8, 0x90, 0x00, 0x8E, 
+0xE0, 0xF5, 0x71, 0xEF, 0x24, 0xFC, 0x60, 0x0C, 0x24, 0x03, 0x60, 0x02, 0x41, 0x59, 0xAF, 0x70, 
+0x91, 0x21, 0x41, 0x59, 0x74, 0x11, 0x25, 0x70, 0x12, 0x56, 0xA8, 0xE0, 0xFB, 0xE4, 0xFD, 0x51, 
+0x99, 0xD1, 0x2B, 0x13, 0x13, 0x51, 0x94, 0xD1, 0x2B, 0x12, 0x76, 0xBF, 0x51, 0x96, 0xD1, 0x2B, 
+0xC4, 0x51, 0x94, 0x12, 0x6F, 0x7E, 0xE0, 0xFB, 0xE4, 0xFD, 0x0F, 0x51, 0x9A, 0xF1, 0xEE, 0xE0, 
+0xFB, 0x0D, 0x51, 0x9A, 0xF1, 0xA1, 0xC4, 0x13, 0x54, 0x01, 0xFB, 0x0D, 0x7F, 0x01, 0x51, 0x9A, 
+0xF1, 0xA1, 0x54, 0x1F, 0x51, 0x8C, 0xE5, 0x70, 0x90, 0x89, 0x00, 0x12, 0xA9, 0x3C, 0x51, 0x8E, 
+0xE5, 0x70, 0x90, 0x89, 0x01, 0x51, 0x89, 0xE5, 0x70, 0x90, 0x89, 0x02, 0x51, 0x89, 0xE5, 0x70, 
+0x90, 0x89, 0x03, 0x51, 0x89, 0xE5, 0x70, 0x90, 0x89, 0x04, 0x12, 0xA9, 0x3C, 0x51, 0x8E, 0xE5, 
+0x70, 0x90, 0x89, 0x05, 0x51, 0x89, 0xE5, 0x70, 0x90, 0x89, 0x06, 0x51, 0x89, 0xE5, 0x70, 0x90, 
+0x89, 0x07, 0x31, 0x22, 0xE0, 0xFB, 0x0D, 0x51, 0x65, 0xB1, 0xD3, 0x30, 0xE0, 0x02, 0x31, 0x8C, 
+0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xEF, 0x70, 0x04, 0x74, 0xF0, 0x80, 0x16, 0xEF, 0xB4, 0x01, 0x04, 
+0x74, 0xF4, 0x80, 0x0E, 0xEF, 0xB4, 0x02, 0x04, 0x74, 0xF8, 0x80, 0x06, 0xEF, 0xB4, 0x03, 0x08, 
+0x74, 0xFC, 0x2D, 0x12, 0x94, 0xD4, 0xEB, 0xF0, 0x22, 0x31, 0x22, 0xE0, 0xFB, 0x0D, 0x51, 0x65, 
+0x75, 0xF0, 0x08, 0x22, 0x54, 0x03, 0xFB, 0x0D, 0xE4, 0xFF, 0x51, 0x65, 0x75, 0xF0, 0x04, 0xE5, 
+0x70, 0x22, 0xEF, 0x54, 0xFE, 0xFD, 0x7F, 0x02, 0x31, 0x90, 0x7F, 0x02, 0x51, 0xB8, 0xEF, 0x44, 
+0x01, 0xFD, 0x7F, 0x02, 0x31, 0x90, 0x7F, 0x02, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x8F, 
+0x82, 0x75, 0x83, 0x00, 0xE0, 0x90, 0xA1, 0xE6, 0x12, 0xA9, 0x57, 0x90, 0xA1, 0xE6, 0xE0, 0xFF, 
+0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x7F, 0xFF, 0x12, 0x57, 0x8F, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 
+0xD0, 0x12, 0x77, 0x42, 0x7F, 0x00, 0x7E, 0x0C, 0x12, 0x37, 0xBC, 0xEF, 0x54, 0xFC, 0xB1, 0x20, 
+0x12, 0xA8, 0xE5, 0x12, 0x37, 0xBC, 0xEF, 0x54, 0xFC, 0xB1, 0x20, 0x7F, 0x00, 0x7E, 0x0E, 0xF1, 
+0xE2, 0x51, 0xA2, 0x51, 0xA2, 0xEF, 0x54, 0xFE, 0xFD, 0x7F, 0x02, 0x31, 0x90, 0x12, 0xA9, 0x45, 
+0x44, 0x40, 0xB1, 0x20, 0x7F, 0xB4, 0x7E, 0x08, 0x12, 0x38, 0x07, 0x90, 0x01, 0x00, 0x74, 0x3F, 
+0xF0, 0xA3, 0xE0, 0x54, 0xFD, 0xF0, 0x90, 0x05, 0x53, 0xE0, 0x44, 0x20, 0x12, 0x80, 0xD6, 0x30, 
+0xE0, 0x05, 0x7F, 0x01, 0x12, 0x76, 0xC6, 0x12, 0x8F, 0x7F, 0x30, 0xE0, 0x32, 0x90, 0xA0, 0xA0, 
+0xE0, 0x60, 0x08, 0x90, 0xA1, 0xA0, 0x74, 0x01, 0xF0, 0x80, 0x05, 0xE4, 0x90, 0xA1, 0xA0, 0xF0, 
+0xEF, 0xC4, 0x13, 0x54, 0x07, 0x30, 0xE0, 0x07, 0xE4, 0x90, 0xA1, 0xA1, 0xF0, 0x80, 0x06, 0x90, 
+0xA1, 0xA1, 0x74, 0x02, 0xF0, 0x90, 0xA1, 0xA0, 0xB1, 0x33, 0x7F, 0x01, 0x12, 0x76, 0xC6, 0x90, 
+0xA0, 0x4F, 0xE0, 0x60, 0x02, 0xE4, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x7F, 0x54, 0x51, 0xB8, 
+0xE5, 0x0D, 0x5F, 0xF5, 0x11, 0x7F, 0x55, 0x51, 0xB8, 0xE5, 0x0E, 0x5F, 0xF5, 0x12, 0x7F, 0x56, 
+0x51, 0xB8, 0xE5, 0x0F, 0x5F, 0xF5, 0x13, 0x7F, 0x57, 0x51, 0xB8, 0xE5, 0x10, 0x5F, 0xF5, 0x14, 
+0xAD, 0x11, 0x7F, 0x54, 0x31, 0x90, 0xAD, 0x12, 0x7F, 0x55, 0x31, 0x90, 0xAD, 0x13, 0x7F, 0x56, 
+0x31, 0x90, 0xAD, 0x14, 0x7F, 0x57, 0x31, 0x90, 0x53, 0x91, 0xEF, 0x22, 0x7F, 0x81, 0x51, 0xB8, 
+0xEF, 0x54, 0xFE, 0xFD, 0x7F, 0x81, 0x31, 0x90, 0x7F, 0x80, 0x12, 0x68, 0x4C, 0x7F, 0x80, 0x31, 
+0x90, 0x12, 0x94, 0xDC, 0x12, 0x3D, 0x3B, 0x12, 0x94, 0xE9, 0x12, 0x98, 0x13, 0x7F, 0x01, 0x12, 
+0x46, 0xD5, 0x90, 0xA0, 0xC0, 0x74, 0x02, 0xF0, 0xFF, 0x12, 0x46, 0xD5, 0x90, 0xA0, 0xC0, 0xE0, 
+0x04, 0xF0, 0x12, 0x60, 0x0E, 0x12, 0x89, 0x39, 0x7F, 0x80, 0x51, 0xB8, 0xEF, 0x44, 0x40, 0xFD, 
+0x7F, 0x80, 0x31, 0x90, 0x75, 0x28, 0xFF, 0x12, 0x60, 0x79, 0x12, 0x79, 0x34, 0x7F, 0x81, 0x51, 
+0xB8, 0xEF, 0x44, 0x04, 0xFD, 0x7F, 0x81, 0x31, 0x90, 0x12, 0x98, 0x1D, 0xE4, 0xFF, 0x02, 0x47, 
+0x5E, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0xA1, 0xE2, 0xEF, 0xF0, 0xB1, 0xD3, 0x30, 
+0xE6, 0x3A, 0x7F, 0x8D, 0x51, 0xB8, 0xEF, 0x64, 0x01, 0x70, 0x31, 0x90, 0xA1, 0xE3, 0xF0, 0x90, 
+0xA1, 0xE3, 0xE0, 0xFD, 0x90, 0xA1, 0xE2, 0xE0, 0x75, 0xF0, 0x10, 0x12, 0x57, 0x73, 0xE5, 0x82, 
+0x2D, 0xF1, 0xB8, 0xE0, 0xFB, 0xE4, 0xFF, 0x51, 0x65, 0x90, 0xA1, 0xE3, 0xE0, 0x04, 0xF0, 0xE0, 
+0xC3, 0x94, 0x10, 0x40, 0xDA, 0xB1, 0xD3, 0x30, 0xE0, 0x02, 0x31, 0x8C, 0xD0, 0xD0, 0x92, 0xAF, 
+0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x7F, 0x10, 0x51, 0xB8, 0xEF, 0x44, 0x0C, 0xFD, 
+0x7F, 0x10, 0x31, 0x90, 0x7F, 0x72, 0x51, 0xB8, 0xEF, 0x54, 0xF3, 0xFD, 0x7F, 0x72, 0x31, 0x90, 
+0x90, 0x01, 0x01, 0xE0, 0x44, 0x02, 0xF0, 0x90, 0x01, 0x00, 0x74, 0xFF, 0x12, 0x80, 0xD6, 0x30, 
+0xE0, 0x05, 0x7F, 0x03, 0x12, 0x76, 0xC6, 0x90, 0xA0, 0x7A, 0xE0, 0x20, 0xE0, 0x31, 0x12, 0x8F, 
+0x7F, 0x30, 0xE0, 0x2B, 0x90, 0xA0, 0xA0, 0xE0, 0x60, 0x07, 0xE4, 0x90, 0xA1, 0x9A, 0xF0, 0x80, 
+0x06, 0x90, 0xA1, 0x9A, 0x74, 0x01, 0xF0, 0xEF, 0xC4, 0x13, 0x54, 0x07, 0x90, 0xA1, 0x9B, 0x30, 
+0xE0, 0x05, 0x74, 0x01, 0xF0, 0x80, 0x03, 0x74, 0x02, 0xF0, 0x90, 0xA1, 0x9A, 0xB1, 0x33, 0x90, 
+0x06, 0xB7, 0x74, 0x09, 0xF0, 0x90, 0x06, 0xB4, 0x74, 0x86, 0xF0, 0x12, 0xA9, 0x45, 0x54, 0xBF, 
+0x12, 0xA8, 0x4B, 0xB1, 0x2B, 0x7F, 0xB4, 0x7E, 0x08, 0xF1, 0xE2, 0xEF, 0x44, 0x01, 0xFD, 0x7F, 
+0x02, 0x31, 0x90, 0x7F, 0x00, 0x7E, 0x0C, 0x12, 0xA8, 0x45, 0xB1, 0x2B, 0x12, 0xA8, 0xE5, 0x12, 
+0xA8, 0x45, 0xB1, 0x2B, 0x7F, 0x00, 0x7E, 0x0E, 0x12, 0x38, 0x07, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 
+0xFF, 0xEC, 0x90, 0xA1, 0x9C, 0x12, 0x08, 0x6D, 0x90, 0xA1, 0x9C, 0x31, 0x0A, 0x90, 0xAA, 0xB9, 
+0x02, 0x08, 0x6D, 0xE0, 0xFF, 0xA3, 0xE0, 0xFD, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x8F, 
+0x26, 0x8D, 0x27, 0x90, 0xA0, 0x62, 0x12, 0x74, 0x80, 0x20, 0xE0, 0x73, 0x12, 0x90, 0xA1, 0xB1, 
+0xCD, 0xE5, 0x26, 0x64, 0x02, 0x60, 0x18, 0xB1, 0xC4, 0xE5, 0x26, 0x90, 0xA1, 0xB4, 0xB4, 0x01, 
+0x07, 0x31, 0x0A, 0xEC, 0x44, 0x20, 0x80, 0x05, 0x31, 0x0A, 0xEC, 0x44, 0x10, 0xB1, 0xCC, 0xE5, 
+0x27, 0x64, 0x02, 0x60, 0x37, 0xF1, 0x94, 0xE4, 0xFF, 0xEC, 0xB1, 0xCD, 0xE5, 0x27, 0x70, 0x09, 
+0xF1, 0x94, 0xEF, 0x44, 0x77, 0xFF, 0xEC, 0x80, 0x21, 0xF1, 0x94, 0xEF, 0x44, 0x66, 0xFF, 0xEC, 
+0xB1, 0xCD, 0xB1, 0xC4, 0x90, 0xA0, 0xA0, 0xE0, 0x90, 0xA1, 0xB4, 0x60, 0x07, 0x31, 0x0A, 0xEC, 
+0x44, 0x10, 0x80, 0x05, 0x31, 0x0A, 0xEC, 0x44, 0x20, 0xFC, 0xB1, 0xCD, 0xE5, 0x26, 0xB4, 0x02, 
+0x06, 0xE5, 0x27, 0x64, 0x02, 0x60, 0x08, 0x90, 0xA1, 0xB4, 0xB1, 0x2B, 0x12, 0x90, 0xA8, 0xD0, 
+0xD0, 0x92, 0xAF, 0x22, 0x90, 0xA1, 0xB4, 0x31, 0x0A, 0xEC, 0x54, 0xCF, 0xFC, 0x90, 0xA1, 0xB4, 
+0x02, 0x08, 0x6D, 0x7F, 0x8F, 0x51, 0xB8, 0xEF, 0x22, 0x90, 0x9F, 0xA4, 0xE0, 0x44, 0x10, 0xF0, 
+0x90, 0x9F, 0xB2, 0xE0, 0xFD, 0x7F, 0x93, 0x31, 0x90, 0x90, 0x9F, 0xA8, 0xE0, 0x60, 0x12, 0x90, 
+0x01, 0x2F, 0xE0, 0x30, 0xE7, 0x05, 0x74, 0x10, 0xF0, 0x80, 0x06, 0x90, 0x01, 0x2F, 0x74, 0x90, 
+0xF0, 0x7F, 0x08, 0x51, 0xB8, 0xEF, 0x44, 0x10, 0xFD, 0x7F, 0x08, 0x31, 0x90, 0x7F, 0x01, 0x12, 
+0x78, 0xBD, 0x7F, 0x90, 0x51, 0xB8, 0xEF, 0x44, 0x01, 0xFD, 0x7F, 0x90, 0x31, 0x90, 0x7F, 0x14, 
+0x7E, 0x00, 0x02, 0x3D, 0x7A, 0xFF, 0x75, 0xF0, 0x04, 0xE5, 0x51, 0x90, 0x96, 0x14, 0x31, 0x22, 
+0xE0, 0x22, 0xE4, 0xFF, 0xE4, 0xFE, 0x74, 0x91, 0x2F, 0x12, 0x7E, 0x03, 0xE0, 0x54, 0xFE, 0xF0, 
+0x75, 0xF0, 0x10, 0xEF, 0x90, 0x81, 0x00, 0xBE, 0x03, 0x0C, 0x31, 0x22, 0xE5, 0x82, 0x2E, 0xF1, 
+0xB8, 0x74, 0x80, 0xF0, 0x80, 0x09, 0x31, 0x22, 0xE5, 0x82, 0x2E, 0xF1, 0xB8, 0xE4, 0xF0, 0x75, 
+0xF0, 0x08, 0xEF, 0x12, 0x6C, 0x09, 0x2E, 0xF1, 0xB8, 0xE4, 0xF0, 0x0E, 0xBE, 0x10, 0xC7, 0x0F, 
+0xBF, 0x80, 0xC1, 0xE4, 0x90, 0xAD, 0xE2, 0xF0, 0xFF, 0xE4, 0xFE, 0x75, 0xF0, 0x0A, 0xEF, 0x12, 
+0x6F, 0x88, 0x75, 0xF0, 0x02, 0xEE, 0x12, 0x6F, 0x8E, 0xF0, 0x0E, 0xBE, 0x05, 0xED, 0x74, 0x91, 
+0x2F, 0x12, 0xA8, 0x69, 0x74, 0x3F, 0xF0, 0x74, 0x11, 0x2F, 0x12, 0x57, 0x7D, 0xE4, 0xF0, 0x74, 
+0x01, 0x2F, 0x12, 0x56, 0x8A, 0x74, 0xC0, 0xF0, 0x74, 0x11, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x9E, 
+0xF5, 0x83, 0xE4, 0x12, 0xA8, 0x0E, 0xE4, 0x12, 0x6F, 0x79, 0x74, 0x3F, 0xF1, 0xE9, 0xE4, 0xF0, 
+0x75, 0xF0, 0x04, 0xEF, 0xF1, 0xA1, 0x54, 0xE0, 0x44, 0x09, 0xF0, 0x75, 0xF0, 0x04, 0xEF, 0xD1, 
+0x2B, 0x54, 0xF3, 0xF0, 0x75, 0xF0, 0x04, 0xEF, 0xD1, 0x2B, 0x54, 0xFC, 0xF0, 0x75, 0xF0, 0x04, 
+0xEF, 0xF1, 0xA1, 0x44, 0x20, 0xF0, 0x75, 0xF0, 0x04, 0xEF, 0xD1, 0x2B, 0x54, 0xCF, 0xF0, 0x75, 
+0xF0, 0x04, 0xEF, 0xD1, 0x2B, 0x44, 0x40, 0xF0, 0x75, 0xF0, 0x04, 0xEF, 0xD1, 0x2B, 0x54, 0x7F, 
+0xF1, 0xE9, 0xE0, 0xFE, 0x75, 0xF0, 0x10, 0xEF, 0x12, 0x57, 0x73, 0xEE, 0xF0, 0x74, 0x91, 0x2F, 
+0x12, 0x7E, 0x03, 0xE4, 0xF0, 0x0F, 0xEF, 0x64, 0x80, 0x60, 0x02, 0xC1, 0x79, 0x90, 0x04, 0x49, 
+0x74, 0xF0, 0xF0, 0xA3, 0xE4, 0xF0, 0xA3, 0x74, 0xFF, 0xF0, 0x90, 0x04, 0x33, 0x74, 0x02, 0xF0, 
+0xA3, 0x74, 0x04, 0xF0, 0xA3, 0x04, 0xF0, 0xA3, 0x04, 0xF0, 0xA3, 0x04, 0xF0, 0x74, 0x11, 0x2F, 
+0x12, 0xA0, 0x54, 0x74, 0xFF, 0xF0, 0x22, 0x90, 0x01, 0x30, 0xF1, 0x8B, 0x90, 0x01, 0x38, 0xF1, 
+0x8C, 0xFD, 0x7F, 0x50, 0x31, 0x90, 0xE4, 0xFD, 0x7F, 0x51, 0x31, 0x90, 0xE4, 0xFD, 0x7F, 0x52, 
+0x31, 0x90, 0xE4, 0xFD, 0x7F, 0x53, 0x21, 0x90, 0x90, 0x01, 0x34, 0x74, 0xFF, 0xF1, 0x8C, 0x90, 
+0x01, 0x3C, 0xF1, 0x8C, 0xFD, 0x7F, 0x54, 0x31, 0x90, 0x7D, 0xFF, 0x7F, 0x55, 0x31, 0x90, 0x7D, 
+0xFF, 0x7F, 0x56, 0x31, 0x90, 0x7D, 0xFF, 0x7F, 0x57, 0x21, 0x90, 0xE4, 0xF0, 0xA3, 0xF0, 0xA3, 
+0xF0, 0xA3, 0xF0, 0x22, 0x90, 0xA1, 0xB4, 0x21, 0x0A, 0x75, 0x60, 0x3E, 0x75, 0xF0, 0x04, 0xE5, 
+0x5E, 0x90, 0x96, 0x13, 0x31, 0x22, 0xE0, 0x22, 0xFF, 0x90, 0xA1, 0xC4, 0xE0, 0x75, 0xF0, 0x08, 
+0x90, 0x89, 0x00, 0x31, 0x22, 0xE5, 0x82, 0x2F, 0xF5, 0x82, 0xE4, 0x35, 0x83, 0xF5, 0x83, 0x22, 
+0xE4, 0xF5, 0x0D, 0xF5, 0x0E, 0xF5, 0x0F, 0x75, 0x10, 0x80, 0xAD, 0x0D, 0x7F, 0x50, 0x31, 0x90, 
+0xAD, 0x0E, 0x7F, 0x51, 0x31, 0x90, 0xAD, 0x0F, 0x7F, 0x52, 0x31, 0x90, 0xAD, 0x10, 0x7F, 0x53, 
+0x21, 0x90, 0x12, 0x38, 0x07, 0x7F, 0x02, 0x41, 0xB8, 0xF0, 0x75, 0xF0, 0x04, 0xEF, 0x90, 0x96, 
+0x12, 0x21, 0x22, 0x7D, 0x20, 0x7F, 0xFF, 0x12, 0x57, 0x8F, 0x51, 0xDA, 0x90, 0x9F, 0xA1, 0x74, 
+0x02, 0xF0, 0x22, 0xE0, 0x44, 0x02, 0xF0, 0xE4, 0x90, 0xA1, 0x8E, 0xF0, 0x90, 0xA0, 0x4C, 0xE0, 
+0x90, 0xA1, 0x8F, 0xF0, 0xE4, 0xFB, 0xFD, 0x7F, 0x54, 0x7E, 0x01, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 
+0xC0, 0xD0, 0x90, 0xA1, 0x8A, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0xA1, 0x8E, 0xE0, 0xF5, 0x3B, 
+0xA3, 0xE0, 0xF5, 0x3C, 0x12, 0x35, 0x7A, 0x90, 0xA1, 0x8A, 0x12, 0xA9, 0x4E, 0xA3, 0xA3, 0xA3, 
+0x74, 0x05, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x11, 0x58, 0x70, 0x0B, 0x90, 0x9F, 0xA7, 0xE0, 
+0x60, 0x05, 0x12, 0x9D, 0x21, 0x11, 0x06, 0x22, 0xE4, 0xFF, 0x11, 0x60, 0xEF, 0x64, 0x01, 0x22, 
+0x12, 0x87, 0xB5, 0xFE, 0xEF, 0x54, 0x07, 0xFF, 0x12, 0x89, 0x8F, 0xE0, 0xFD, 0x7C, 0x00, 0x12, 
+0x6F, 0xCF, 0x80, 0x05, 0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 0xF9, 0xFF, 0xEE, 0x5C, 0xFE, 0xEF, 
+0x5D, 0x4E, 0x7F, 0x00, 0x60, 0x02, 0x7F, 0x01, 0x22, 0xE4, 0xF5, 0x51, 0x90, 0x9F, 0x9C, 0xE0, 
+0xFF, 0xE5, 0x51, 0xC3, 0x9F, 0x40, 0x02, 0xC1, 0x73, 0xAF, 0x51, 0x11, 0x60, 0xEF, 0x70, 0x02, 
+0xC1, 0x6F, 0x12, 0x4E, 0x26, 0x12, 0x76, 0xBF, 0x30, 0xE0, 0x02, 0xC1, 0x6F, 0x12, 0xA9, 0x09, 
+0x70, 0x07, 0xE5, 0x51, 0x6E, 0x70, 0x02, 0x80, 0x0A, 0x12, 0xA9, 0x09, 0x70, 0x30, 0xE5, 0x51, 
+0x6E, 0x70, 0x2B, 0xA3, 0xE0, 0xF5, 0x52, 0xA3, 0xE0, 0x90, 0xA0, 0xD5, 0xF1, 0x6D, 0xE5, 0x52, 
+0xF0, 0x75, 0xF0, 0x10, 0x12, 0x6D, 0x95, 0xE0, 0x54, 0xFC, 0xFF, 0x90, 0xA0, 0xD5, 0xE0, 0x54, 
+0x03, 0x4F, 0xFF, 0x75, 0xF0, 0x10, 0xE5, 0x51, 0x12, 0x6D, 0x95, 0xEF, 0xF0, 0x22, 0x12, 0xA8, 
+0x57, 0xE0, 0xFE, 0xA3, 0xE0, 0xD3, 0x94, 0x00, 0xEE, 0x94, 0x00, 0x50, 0x02, 0xC1, 0x6F, 0xE5, 
+0x51, 0x75, 0xF0, 0x0A, 0xA4, 0x24, 0x01, 0xF9, 0x74, 0x8D, 0x35, 0xF0, 0xFA, 0x7B, 0x01, 0x90, 
+0xA0, 0xC9, 0x12, 0x49, 0x37, 0x12, 0xA8, 0x57, 0xE0, 0xF5, 0x56, 0xA3, 0xE0, 0xF5, 0x57, 0x74, 
+0x91, 0x25, 0x51, 0x12, 0xA8, 0x22, 0xE0, 0xFF, 0x90, 0xA0, 0xCC, 0xE4, 0xF0, 0xA3, 0xEF, 0xF0, 
+0x90, 0x00, 0x02, 0x12, 0x07, 0xAB, 0xFF, 0xAE, 0xF0, 0x12, 0x07, 0x80, 0x2F, 0xFF, 0xE5, 0xF0, 
+0x3E, 0xFE, 0x90, 0x00, 0x04, 0xD1, 0x9B, 0xFE, 0x90, 0x00, 0x06, 0xD1, 0x9B, 0xFE, 0x90, 0x00, 
+0x08, 0xD1, 0x9B, 0x90, 0xA0, 0xCE, 0xF0, 0xA3, 0xEF, 0xF0, 0x12, 0x07, 0x80, 0xFF, 0xC3, 0x90, 
+0xA0, 0xCF, 0xE0, 0x9F, 0xFE, 0x90, 0xA0, 0xCE, 0xE0, 0x95, 0xF0, 0x90, 0xA0, 0xD0, 0xF0, 0xA3, 
+0xCE, 0xF0, 0x90, 0x00, 0x06, 0x12, 0x07, 0xAB, 0xFD, 0xAC, 0xF0, 0x25, 0xE0, 0xFF, 0xEC, 0x33, 
+0xFE, 0xEF, 0x2D, 0xFD, 0xEE, 0x3C, 0xFC, 0x90, 0x00, 0x04, 0x12, 0x07, 0xAB, 0x25, 0xE0, 0xFF, 
+0xE5, 0xF0, 0x33, 0xFE, 0x90, 0x00, 0x02, 0xD1, 0x9B, 0xCF, 0x2D, 0xFD, 0xEF, 0x3C, 0xFC, 0xD1, 
+0x80, 0xF1, 0x67, 0xAE, 0xF0, 0x78, 0x02, 0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 0xF9, 0x2D, 0xFF, 
+0xEC, 0x3E, 0x90, 0xA0, 0xD2, 0xF0, 0xA3, 0xEF, 0xF1, 0x6D, 0xE0, 0xF5, 0x52, 0x54, 0x7F, 0xF5, 
+0x53, 0x75, 0xF0, 0x04, 0xE5, 0x51, 0x12, 0x6F, 0x7E, 0xE0, 0x90, 0xA0, 0xD4, 0xF0, 0x12, 0x4E, 
+0x26, 0xFF, 0x13, 0x13, 0x54, 0x03, 0x90, 0xA0, 0xD5, 0xF0, 0xD1, 0x74, 0xE0, 0xC3, 0x94, 0x05, 
+0x40, 0x02, 0x81, 0x93, 0x90, 0xA0, 0xD4, 0xE0, 0xFF, 0xE5, 0x53, 0x9F, 0x40, 0x08, 0x8F, 0x53, 
+0x53, 0x52, 0x80, 0xEF, 0x42, 0x52, 0xE5, 0x53, 0x90, 0x41, 0xFB, 0x93, 0xFF, 0xD1, 0xA4, 0xE0, 
+0xC3, 0x9F, 0xE5, 0x53, 0x40, 0x05, 0x90, 0x41, 0x53, 0x80, 0x03, 0x90, 0x41, 0xA7, 0x93, 0xF5, 
+0x58, 0x90, 0xA0, 0xA2, 0xE0, 0x60, 0x7D, 0xE5, 0x53, 0x64, 0x13, 0x60, 0x05, 0xE5, 0x53, 0xB4, 
+0x0B, 0x05, 0x90, 0xA0, 0xA4, 0x80, 0x23, 0xE5, 0x53, 0x64, 0x12, 0x60, 0x05, 0xE5, 0x53, 0xB4, 
+0x0A, 0x05, 0x90, 0xA0, 0xA5, 0x80, 0x13, 0xE5, 0x53, 0x64, 0x11, 0x60, 0x05, 0xE5, 0x53, 0xB4, 
+0x09, 0x05, 0x90, 0xA0, 0xA6, 0x80, 0x03, 0x90, 0xA0, 0xA3, 0xE0, 0xF5, 0x5C, 0xE5, 0x5C, 0xC3, 
+0x94, 0x80, 0x50, 0x28, 0xE5, 0x5C, 0x94, 0x1B, 0x40, 0x02, 0x80, 0x13, 0xE5, 0x58, 0x25, 0x5C, 
+0xFF, 0xE4, 0x33, 0xFE, 0xD3, 0xEF, 0x94, 0x1B, 0xEE, 0x64, 0x80, 0x94, 0x80, 0x40, 0x05, 0x75, 
+0x58, 0x1B, 0x80, 0x20, 0xE5, 0x5C, 0x25, 0x58, 0xF5, 0x58, 0x80, 0x18, 0xC3, 0xE4, 0x95, 0x5C, 
+0xF5, 0x5C, 0xE5, 0x58, 0xD3, 0x95, 0x5C, 0x40, 0x08, 0xE5, 0x58, 0x95, 0x5C, 0xF5, 0x58, 0x80, 
+0x03, 0xE4, 0xF5, 0x58, 0xE5, 0x58, 0x75, 0xF0, 0x06, 0xA4, 0x24, 0xB1, 0xF9, 0x74, 0x40, 0x35, 
+0xF0, 0xFA, 0x7B, 0xFF, 0x90, 0xA0, 0xC6, 0x12, 0x49, 0x37, 0xC3, 0xE5, 0x57, 0x94, 0x0F, 0xE5, 
+0x56, 0x94, 0x00, 0x50, 0x52, 0xD1, 0x80, 0x90, 0x00, 0x06, 0x12, 0x07, 0xAB, 0xFF, 0xAE, 0xF0, 
+0xF1, 0x67, 0x2F, 0xFD, 0xE5, 0xF0, 0x3E, 0xFC, 0xD1, 0x92, 0xFF, 0xD3, 0xED, 0x9F, 0xEC, 0x9E, 
+0x40, 0x09, 0x7D, 0x01, 0xAF, 0x51, 0x12, 0xA3, 0x88, 0x81, 0x74, 0xE5, 0x57, 0xAE, 0x56, 0x78, 
+0x02, 0xCE, 0xC3, 0x13, 0xCE, 0x13, 0xD8, 0xF9, 0xFD, 0xAC, 0x06, 0xD1, 0x92, 0x2D, 0xFF, 0xEE, 
+0x3C, 0xFE, 0xD1, 0x80, 0x12, 0x07, 0x80, 0xD3, 0x9F, 0xE5, 0xF0, 0x9E, 0x50, 0x02, 0x81, 0x74, 
+0xAF, 0x51, 0x12, 0xA0, 0x70, 0x81, 0x74, 0xE5, 0x51, 0x70, 0x3C, 0xD1, 0x80, 0xF1, 0x67, 0xFD, 
+0xAC, 0xF0, 0xD1, 0x92, 0xFF, 0xC3, 0xED, 0x9F, 0xEC, 0x9E, 0x50, 0x08, 0x90, 0x9E, 0x91, 0x74, 
+0x01, 0xF0, 0x80, 0x23, 0xE5, 0x57, 0xAE, 0x56, 0x78, 0x03, 0xCE, 0xC3, 0x13, 0xCE, 0x13, 0xD8, 
+0xF9, 0xFB, 0xAA, 0x06, 0xD1, 0x92, 0x2B, 0xFF, 0xEE, 0x3A, 0xFE, 0xD3, 0xED, 0x9F, 0xEC, 0x9E, 
+0x40, 0x05, 0xE4, 0x90, 0x9E, 0x91, 0xF0, 0x12, 0xA9, 0x28, 0x40, 0x05, 0x75, 0x59, 0x05, 0x80, 
+0x13, 0xD3, 0xE5, 0x57, 0x94, 0xC8, 0xE5, 0x56, 0x94, 0x00, 0x40, 0x05, 0x75, 0x59, 0x02, 0x80, 
+0x03, 0xE4, 0xF5, 0x59, 0xE5, 0x51, 0xD1, 0xCA, 0xE0, 0xF5, 0x54, 0xA3, 0xE0, 0xF5, 0x55, 0xE4, 
+0xF5, 0x5D, 0xD1, 0x80, 0x75, 0xF0, 0x02, 0xE5, 0x5D, 0x12, 0xA8, 0x9B, 0x80, 0x05, 0xCE, 0xC3, 
+0x13, 0xCE, 0x13, 0xD8, 0xF9, 0xFF, 0x90, 0xA0, 0xC6, 0x12, 0x49, 0x2E, 0x85, 0x5D, 0x82, 0x12, 
+0x64, 0x72, 0x12, 0xA8, 0x71, 0x05, 0x5D, 0xE5, 0x5D, 0xB4, 0x05, 0xD6, 0x90, 0xA0, 0xC6, 0x12, 
+0x49, 0x2E, 0x12, 0x66, 0xDF, 0xFD, 0x7C, 0x00, 0x12, 0xA9, 0x77, 0x80, 0x05, 0xCE, 0xC3, 0x13, 
+0xCE, 0x13, 0xD8, 0xF9, 0xFF, 0x12, 0x07, 0x03, 0xD3, 0xE5, 0x55, 0x9F, 0xE5, 0x54, 0x9E, 0x40, 
+0x0C, 0xE5, 0x55, 0x9F, 0xF5, 0x55, 0xE5, 0x54, 0x9E, 0xF5, 0x54, 0x80, 0x05, 0xE4, 0xF5, 0x54, 
+0xF5, 0x55, 0xE5, 0x51, 0xD1, 0xCA, 0x12, 0xA9, 0x7F, 0x12, 0xA3, 0x7A, 0xC3, 0x12, 0xA9, 0x32, 
+0x50, 0x07, 0xAF, 0x51, 0x12, 0xA0, 0x70, 0x80, 0x54, 0x12, 0xA5, 0x47, 0xD3, 0x12, 0xA9, 0x32, 
+0x40, 0x51, 0x74, 0x91, 0x25, 0x51, 0x12, 0x7E, 0x03, 0xE0, 0x20, 0xE6, 0x03, 0x30, 0xE1, 0x07, 
+0xE4, 0x90, 0xA0, 0xD6, 0xF0, 0x80, 0x06, 0x90, 0xA0, 0xD6, 0x74, 0x01, 0xF0, 0xE5, 0x53, 0xB4, 
+0x3A, 0x0B, 0x90, 0xA0, 0xD6, 0xE0, 0xB4, 0x01, 0x04, 0x7D, 0x08, 0x80, 0x1B, 0xE5, 0x53, 0xB4, 
+0x18, 0x0B, 0x90, 0xA0, 0xD6, 0xE0, 0xB4, 0x01, 0x04, 0x7D, 0x07, 0x80, 0x0B, 0xE5, 0x53, 0xB4, 
+0x36, 0x04, 0x7D, 0x09, 0x80, 0x02, 0x7D, 0x01, 0xAF, 0x51, 0x12, 0xA3, 0x88, 0xD1, 0xBC, 0xE4, 
+0xF0, 0x80, 0x31, 0xD1, 0xBC, 0xE0, 0x04, 0xF0, 0xD1, 0xBC, 0xE0, 0xC3, 0x94, 0x05, 0x40, 0x24, 
+0xD1, 0xBC, 0xE4, 0xF0, 0x12, 0xA5, 0x47, 0x12, 0xA5, 0x11, 0x12, 0xA3, 0x7A, 0x74, 0x01, 0x93, 
+0x2F, 0xFF, 0xE4, 0x93, 0x3E, 0xC3, 0x13, 0xFE, 0xEF, 0x13, 0xFF, 0xE5, 0x51, 0xD1, 0xCA, 0xEE, 
+0xF0, 0xA3, 0xEF, 0xF0, 0xE5, 0x51, 0xD1, 0xCA, 0xA3, 0xE0, 0x90, 0xA1, 0x2C, 0xF0, 0x90, 0xA1, 
+0x2B, 0xE5, 0x52, 0xF0, 0xAB, 0x51, 0xE4, 0xFD, 0xFF, 0x12, 0x9F, 0xEB, 0xE4, 0xF5, 0x54, 0xF5, 
+0x55, 0xC1, 0x53, 0xD1, 0x74, 0xE0, 0xFC, 0x64, 0x05, 0x60, 0x02, 0xA1, 0x5B, 0xAD, 0x53, 0xAF, 
+0x51, 0x12, 0xA5, 0x55, 0x12, 0xA8, 0xFD, 0xEF, 0xD1, 0xB0, 0xE0, 0x54, 0x07, 0xF5, 0x5B, 0xD1, 
+0xA4, 0xE0, 0xFF, 0xC3, 0x94, 0x30, 0x50, 0x08, 0xE4, 0xF5, 0x5B, 0xD1, 0x74, 0xE4, 0x80, 0x55, 
+0x12, 0xA8, 0xFD, 0xE0, 0x64, 0x01, 0x70, 0x64, 0xF1, 0x79, 0xE0, 0x64, 0x0A, 0x60, 0x28, 0xEF, 
+0x24, 0x05, 0xFF, 0xE4, 0x33, 0xFE, 0x12, 0xA8, 0xF1, 0xE0, 0xFD, 0x12, 0xA8, 0xDB, 0x50, 0x17, 
+0xED, 0x24, 0x05, 0xFF, 0xE4, 0x33, 0xFE, 0xD1, 0xA4, 0xE0, 0x12, 0xA8, 0xDB, 0x50, 0x08, 0x12, 
+0xA8, 0x65, 0xE0, 0x65, 0x53, 0x60, 0x2A, 0xE5, 0x5B, 0x70, 0x05, 0x75, 0x5B, 0x01, 0x80, 0x0D, 
+0xE5, 0x5B, 0xB4, 0x01, 0x05, 0x75, 0x5B, 0x03, 0x80, 0x03, 0x75, 0x5B, 0x05, 0xD1, 0xA4, 0xE0, 
+0xFF, 0x12, 0xA8, 0xF1, 0xEF, 0xF0, 0x74, 0x11, 0x25, 0x51, 0xF5, 0x82, 0xE4, 0x34, 0x9B, 0x80, 
+0x17, 0xD1, 0x74, 0xE4, 0xF0, 0xF1, 0x79, 0xE0, 0x04, 0xF0, 0x80, 0x10, 0xE4, 0xF5, 0x5B, 0x74, 
+0x11, 0x25, 0x51, 0xF5, 0x82, 0xE4, 0x34, 0x9C, 0xF5, 0x83, 0xE4, 0xF0, 0x12, 0xA8, 0x65, 0xE5, 
+0x53, 0xF0, 0x12, 0x4E, 0x26, 0xC4, 0x13, 0x13, 0x54, 0x03, 0x20, 0xE0, 0x02, 0xC1, 0x43, 0xF1, 
+0x79, 0xE4, 0xF0, 0xF5, 0x5B, 0xD1, 0x74, 0xE4, 0xF0, 0xC1, 0x43, 0xEC, 0x64, 0x06, 0x60, 0x02, 
+0xC1, 0x53, 0xF5, 0x54, 0xF5, 0x55, 0xD1, 0xB1, 0xE0, 0x54, 0x07, 0xF5, 0x5B, 0x12, 0xA9, 0x28, 
+0x40, 0x05, 0x75, 0x59, 0x05, 0x80, 0x13, 0xD3, 0xE5, 0x57, 0x94, 0xFA, 0xE5, 0x56, 0x94, 0x00, 
+0x40, 0x05, 0x75, 0x59, 0x02, 0x80, 0x03, 0xE4, 0xF5, 0x59, 0x12, 0xA9, 0x77, 0x80, 0x05, 0xCE, 
+0xC3, 0x13, 0xCE, 0x13, 0xD8, 0xF9, 0xFF, 0x90, 0x44, 0x58, 0xE4, 0x93, 0xFD, 0x7C, 0x00, 0x12, 
+0x07, 0x03, 0x90, 0xA0, 0xD7, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0xE4, 0xF5, 0x5A, 0xD1, 0x80, 0x75, 
+0xF0, 0x02, 0xE5, 0x5A, 0x12, 0xA8, 0x9B, 0x80, 0x05, 0xCE, 0xC3, 0x13, 0xCE, 0x13, 0xD8, 0xF9, 
+0xFF, 0xE5, 0x5A, 0x90, 0x44, 0x53, 0x93, 0x12, 0xA8, 0x71, 0xC3, 0x90, 0xA0, 0xD8, 0xE0, 0x95, 
+0x55, 0x90, 0xA0, 0xD7, 0xE0, 0x95, 0x54, 0x40, 0x07, 0x05, 0x5A, 0xE5, 0x5A, 0xB4, 0x05, 0xCD, 
+0xE5, 0x5A, 0xC3, 0x13, 0xF5, 0x5A, 0xE5, 0x5B, 0x24, 0x01, 0xFF, 0xE4, 0x33, 0xA2, 0xE7, 0x13, 
+0xEF, 0x13, 0xFF, 0xD3, 0x95, 0x5A, 0x40, 0x06, 0xEF, 0x95, 0x5A, 0xFF, 0x80, 0x02, 0xE4, 0xFF, 
+0xD1, 0x86, 0xE0, 0xC3, 0x13, 0xFE, 0xEF, 0xC4, 0x33, 0x54, 0xE0, 0x2E, 0x04, 0xFE, 0xD1, 0x86, 
+0xEE, 0xF0, 0xD1, 0x86, 0xE0, 0xC3, 0x94, 0xC0, 0x40, 0x05, 0xD1, 0x86, 0x74, 0xC0, 0xF0, 0xD1, 
+0x86, 0x12, 0x74, 0x80, 0x25, 0xE0, 0xFF, 0x70, 0x04, 0xF5, 0x5B, 0x80, 0x04, 0xEF, 0x14, 0xF5, 
+0x5B, 0xD3, 0x90, 0xA0, 0xCD, 0xE0, 0x94, 0x03, 0x90, 0xA0, 0xCC, 0xE0, 0x94, 0x00, 0x40, 0x03, 
+0xE4, 0xF5, 0x5B, 0xD1, 0xB1, 0xE0, 0x54, 0xF8, 0x90, 0xA0, 0xD9, 0xF0, 0x45, 0x5B, 0xFF, 0xD1, 
+0xB0, 0xEF, 0xF0, 0xD1, 0x74, 0xE0, 0xD3, 0x94, 0x05, 0x74, 0x11, 0x50, 0x07, 0xD1, 0x76, 0xE0, 
+0x04, 0xF0, 0x80, 0x04, 0xD1, 0x76, 0xE4, 0xF0, 0xE4, 0xFD, 0xAF, 0x51, 0x12, 0x6D, 0xB4, 0x05, 
+0x51, 0x01, 0x8C, 0x22, 0x74, 0x11, 0x25, 0x51, 0xF5, 0x82, 0xE4, 0x34, 0x9C, 0xF5, 0x83, 0x22, 
+0x90, 0xA0, 0xC9, 0x02, 0x49, 0x2E, 0x74, 0x01, 0x25, 0x51, 0xF5, 0x82, 0xE4, 0x34, 0x93, 0xF5, 
+0x83, 0x22, 0xE5, 0x56, 0xC3, 0x13, 0xFE, 0xE5, 0x57, 0x13, 0x22, 0x12, 0x07, 0xAB, 0x2F, 0xFF, 
+0xEE, 0x35, 0xF0, 0x22, 0x74, 0x11, 0x25, 0x51, 0xF5, 0x82, 0xE4, 0x34, 0x9A, 0xF5, 0x83, 0x22, 
+0xF0, 0x75, 0xF0, 0x10, 0xE5, 0x51, 0x90, 0x81, 0x01, 0x02, 0x49, 0x22, 0x74, 0x11, 0x25, 0x51, 
+0xF5, 0x82, 0xE4, 0x34, 0x98, 0xF5, 0x83, 0x22, 0xE5, 0x5E, 0x25, 0xE0, 0x24, 0x91, 0xF5, 0x82, 
+0xE4, 0x34, 0x94, 0xF5, 0x83, 0x22, 0x11, 0x58, 0x70, 0x26, 0x90, 0x9F, 0xA4, 0xE0, 0x54, 0xFD, 
+0xF0, 0x7D, 0x2C, 0x7F, 0x6F, 0xF1, 0x8F, 0x12, 0x74, 0x87, 0xBF, 0x01, 0x0F, 0x90, 0x9F, 0xA3, 
+0xE0, 0x44, 0x80, 0xF0, 0x7D, 0x0E, 0xF1, 0xD0, 0x74, 0x0E, 0xF0, 0x22, 0xF1, 0xF9, 0x04, 0xF0, 
+0x22, 0xE4, 0x90, 0xA0, 0xF4, 0xF0, 0x90, 0x9F, 0xA7, 0xE0, 0x60, 0x5A, 0x11, 0x58, 0x70, 0x56, 
+0x12, 0x9D, 0x11, 0x12, 0x9B, 0x48, 0xCE, 0xC3, 0x13, 0xCE, 0x13, 0xD8, 0xF9, 0x12, 0x9D, 0xE2, 
+0xF0, 0x12, 0x82, 0x36, 0xE4, 0x90, 0x9F, 0xAE, 0xF0, 0x90, 0x9F, 0x9E, 0xE0, 0x30, 0xE0, 0x16, 
+0x90, 0x9F, 0xA2, 0xE0, 0xB4, 0x02, 0x05, 0xE4, 0x90, 0xA0, 0xF4, 0xF0, 0x12, 0x5E, 0xD3, 0xEF, 
+0x70, 0x04, 0x90, 0xA0, 0xF4, 0xF0, 0x90, 0xA0, 0xF4, 0xE0, 0x60, 0x1A, 0x12, 0x9D, 0x19, 0xE4, 
+0x90, 0xA1, 0x8E, 0xF0, 0x90, 0x9F, 0xAF, 0x11, 0x0F, 0x90, 0x9F, 0xAA, 0xE0, 0x20, 0xE2, 0x03, 
+0x12, 0x58, 0x61, 0x12, 0x8F, 0xB2, 0x22, 0x90, 0x00, 0x08, 0x02, 0x07, 0xAB, 0xF0, 0x75, 0xF0, 
+0x10, 0xE5, 0x51, 0x90, 0x81, 0x00, 0x02, 0x49, 0x22, 0x74, 0x11, 0x25, 0x51, 0xF5, 0x82, 0xE4, 
+0x34, 0x9B, 0xF5, 0x83, 0x22, 0xE4, 0xFD, 0x7F, 0x0C, 0x12, 0x58, 0x65, 0xE4, 0xFD, 0xFF, 0x90, 
+0x05, 0x22, 0xEF, 0xF0, 0x90, 0x9E, 0x96, 0xED, 0xF0, 0x22, 0xEF, 0x60, 0x32, 0x11, 0x58, 0x70, 
+0x2E, 0x90, 0x9F, 0xA4, 0xE0, 0x54, 0xFE, 0xF0, 0x7D, 0x2B, 0x7F, 0x0F, 0xF1, 0x8F, 0x90, 0x06, 
+0x04, 0xE0, 0x54, 0xBF, 0xF0, 0x12, 0x97, 0xC3, 0xBF, 0x01, 0x0F, 0x90, 0x9F, 0xA3, 0xE0, 0x44, 
+0x40, 0xF0, 0x7D, 0x06, 0xF1, 0xD0, 0x74, 0x06, 0xF0, 0x22, 0xF1, 0xF9, 0x74, 0x08, 0xF0, 0x22, 
+0x7F, 0x01, 0x12, 0x5A, 0x74, 0x90, 0x9F, 0xA2, 0x22, 0x7D, 0x1F, 0x7F, 0x6F, 0xF1, 0x8F, 0x90, 
+0x05, 0x27, 0xE0, 0x54, 0xBF, 0xF0, 0x90, 0x9F, 0xA1, 0x74, 0x04, 0xF0, 0x22, 0x7D, 0x25, 0x80, 
+0xEA, 0x12, 0x4C, 0x71, 0x7D, 0x24, 0x80, 0xE3, 0xF0, 0x90, 0x01, 0xB9, 0x74, 0x01, 0xF0, 0x90, 
+0x01, 0xB8, 0x22, 0x02, 0x49, 0xA5, 0xE4, 0x90, 0xA0, 0xC4, 0xF0, 0x90, 0xA0, 0xC4, 0xE0, 0x64, 
+0x01, 0xF0, 0x24, 0x06, 0x90, 0x01, 0xC4, 0xF0, 0x74, 0x58, 0xA3, 0xF0, 0x12, 0x3D, 0x6E, 0xBF, 
+0x01, 0x03, 0x12, 0x31, 0x38, 0x90, 0x9F, 0xA7, 0xE0, 0x60, 0x0E, 0x90, 0x9F, 0xAA, 0xE0, 0xFF, 
+0x90, 0x9F, 0xA9, 0xE0, 0x6F, 0x60, 0x02, 0x11, 0x4D, 0xC2, 0xAF, 0x12, 0x95, 0x07, 0xBF, 0x01, 
+0x03, 0x12, 0x96, 0x67, 0xD2, 0xAF, 0x11, 0x03, 0x12, 0x46, 0x0D, 0x80, 0xBE, 0x90, 0x9F, 0x9E, 
+0xE0, 0x90, 0x9F, 0xA9, 0x30, 0xE0, 0x04, 0xE0, 0xFF, 0xC1, 0xDF, 0xE0, 0xFF, 0x7D, 0x01, 0x80, 
+0x04, 0x7D, 0x01, 0x7F, 0x04, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0xA1, 0xEE, 0xED, 
+0xF0, 0x90, 0x9F, 0xA3, 0xE0, 0xFE, 0xC4, 0x13, 0x13, 0x54, 0x03, 0x30, 0xE0, 0x02, 0x21, 0xB4, 
+0xEE, 0x12, 0x76, 0xBF, 0x30, 0xE0, 0x02, 0x21, 0xB4, 0x90, 0x9F, 0xAA, 0xE0, 0xFE, 0x6F, 0x70, 
+0x02, 0x21, 0xB4, 0xEF, 0x70, 0x02, 0x21, 0x23, 0x24, 0xFE, 0x70, 0x02, 0x21, 0x5E, 0x24, 0xFE, 
+0x60, 0x48, 0x24, 0xFC, 0x70, 0x02, 0x21, 0x9A, 0x24, 0xFC, 0x60, 0x02, 0x21, 0xAD, 0xEE, 0xB4, 
+0x0E, 0x02, 0x51, 0x08, 0x90, 0x9F, 0xAA, 0xE0, 0x70, 0x04, 0x7F, 0x01, 0x51, 0x53, 0x90, 0x9F, 
+0xAA, 0xE0, 0xB4, 0x06, 0x02, 0x51, 0x2D, 0x90, 0x9F, 0xAA, 0xE0, 0xB4, 0x04, 0x0E, 0x90, 0xA1, 
+0xEE, 0xE0, 0xFF, 0x60, 0x05, 0x12, 0x57, 0x9A, 0x80, 0x02, 0xD1, 0x3C, 0x90, 0x9F, 0xAA, 0xE0, 
+0x64, 0x08, 0x60, 0x02, 0x21, 0xAD, 0xF1, 0xC4, 0x21, 0xAD, 0x90, 0x9F, 0xAA, 0xE0, 0x70, 0x04, 
+0x7F, 0x01, 0x51, 0x53, 0x90, 0x9F, 0xAA, 0xE0, 0xB4, 0x06, 0x02, 0x51, 0x2D, 0x90, 0x9F, 0xAA, 
+0xE0, 0xB4, 0x0E, 0x07, 0x31, 0xB9, 0xBF, 0x01, 0x02, 0x51, 0x08, 0x90, 0x9F, 0xAA, 0xE0, 0x64, 
+0x0C, 0x60, 0x02, 0x21, 0xAD, 0x31, 0xB9, 0xEF, 0x64, 0x01, 0x60, 0x02, 0x21, 0xAD, 0x12, 0x56, 
+0xD6, 0x21, 0xAD, 0x90, 0x9F, 0xAA, 0xE0, 0xB4, 0x0E, 0x07, 0x31, 0xB9, 0xBF, 0x01, 0x02, 0x51, 
+0x08, 0x90, 0x9F, 0xAA, 0xE0, 0xB4, 0x06, 0x02, 0x51, 0x2D, 0x90, 0x9F, 0xAA, 0xE0, 0xB4, 0x0C, 
+0x08, 0x31, 0xB9, 0xBF, 0x01, 0x03, 0x12, 0x56, 0xD6, 0x90, 0x9F, 0xAA, 0xE0, 0x64, 0x04, 0x70, 
+0x5C, 0x12, 0x95, 0x46, 0xEF, 0x64, 0x01, 0x70, 0x54, 0x12, 0xA7, 0x49, 0x80, 0x4F, 0x90, 0x9F, 
+0xAA, 0xE0, 0xB4, 0x0E, 0x07, 0x31, 0xB9, 0xBF, 0x01, 0x02, 0x51, 0x08, 0x90, 0x9F, 0xAA, 0xE0, 
+0xB4, 0x06, 0x02, 0x51, 0x2D, 0x90, 0x9F, 0xAA, 0xE0, 0xB4, 0x0C, 0x08, 0x31, 0xB9, 0xBF, 0x01, 
+0x03, 0x12, 0x56, 0xD6, 0x90, 0x9F, 0xAA, 0xE0, 0x70, 0x04, 0x7F, 0x01, 0x51, 0x53, 0x90, 0x9F, 
+0xAA, 0xE0, 0xB4, 0x04, 0x18, 0x12, 0xA7, 0x6A, 0x80, 0x13, 0x90, 0x9F, 0xAA, 0xE0, 0xB4, 0x0C, 
+0x0C, 0x90, 0x9F, 0xA4, 0x12, 0x75, 0x00, 0x30, 0xE0, 0x03, 0x12, 0x80, 0x29, 0x90, 0x9F, 0xAA, 
+0x12, 0xA8, 0xCE, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0xA0, 0x5F, 0xE0, 0x30, 0xE0, 0x10, 
+0x90, 0xA0, 0x65, 0xE0, 0xC4, 0x13, 0x54, 0x07, 0x30, 0xE0, 0x12, 0x12, 0x96, 0x02, 0x80, 0x2F, 
+0x12, 0x96, 0xA6, 0xEF, 0x64, 0x01, 0x60, 0x05, 0x12, 0x96, 0x40, 0x80, 0x22, 0x90, 0x9F, 0xA3, 
+0x12, 0x80, 0xDA, 0x30, 0xE0, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x02, 0xF0, 0x80, 0x11, 0x90, 0x9F, 
+0xA9, 0xE0, 0xD3, 0x94, 0x04, 0x40, 0x05, 0x12, 0x95, 0x3F, 0x80, 0x03, 0x02, 0x96, 0x47, 0x90, 
+0x01, 0xB9, 0x74, 0x02, 0xF0, 0x7F, 0x00, 0x22, 0x90, 0x9F, 0xA4, 0xE0, 0xC3, 0x13, 0x20, 0xE0, 
+0x04, 0x51, 0x70, 0x80, 0x12, 0x12, 0xA8, 0x03, 0xD1, 0x2C, 0x90, 0x05, 0x27, 0xE0, 0x44, 0x80, 
+0xF0, 0x90, 0x9F, 0xA2, 0x74, 0x04, 0xF0, 0xE4, 0xFD, 0xFF, 0x02, 0x57, 0x8F, 0x90, 0x9F, 0xA4, 
+0xE0, 0x90, 0x06, 0x04, 0x20, 0xE0, 0x07, 0xE0, 0x44, 0x40, 0xD1, 0x2C, 0x80, 0x0F, 0x51, 0x6C, 
+0x90, 0x05, 0x27, 0xE0, 0x54, 0x7F, 0xF0, 0x90, 0x9F, 0xA2, 0x74, 0x0C, 0xF0, 0xE4, 0xFD, 0xFF, 
+0x02, 0x57, 0x8F, 0x90, 0xA1, 0xED, 0xEF, 0xF0, 0x12, 0x4C, 0x71, 0x90, 0xA1, 0xED, 0xE0, 0x60, 
+0x02, 0xD1, 0x36, 0x7D, 0x04, 0x12, 0x57, 0xD0, 0x74, 0x04, 0xF0, 0x22, 0xE0, 0x54, 0x7F, 0xF0, 
+0x7D, 0x0C, 0x7F, 0x01, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0xA1, 0xEC, 0xEF, 0xF0, 
+0x14, 0x60, 0x15, 0x14, 0x60, 0x19, 0x24, 0x02, 0x70, 0x1A, 0xED, 0x54, 0x01, 0xFF, 0x90, 0x9F, 
+0xA3, 0xE0, 0x54, 0xFE, 0x4F, 0xF0, 0x80, 0x0C, 0x90, 0x9F, 0xAA, 0xED, 0xF0, 0x80, 0x05, 0x90, 
+0x9F, 0xA9, 0xED, 0xF0, 0x12, 0x4D, 0xD3, 0x30, 0xE4, 0x2C, 0x90, 0xA1, 0xEC, 0xE0, 0x14, 0x60, 
+0x07, 0x14, 0x60, 0x18, 0x24, 0x02, 0x70, 0x1E, 0x90, 0x9F, 0xA3, 0xE0, 0x12, 0x8F, 0xA0, 0xFF, 
+0x90, 0x9F, 0xAA, 0xE0, 0x54, 0x7F, 0x4F, 0xFD, 0x7F, 0x88, 0x80, 0x07, 0x90, 0x9F, 0xA9, 0xE0, 
+0xFD, 0x7F, 0x89, 0x12, 0x49, 0x90, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 
+0xC0, 0xD0, 0x12, 0x8E, 0x56, 0x90, 0x05, 0x27, 0xE0, 0xF5, 0x54, 0x12, 0x7F, 0x8B, 0x90, 0x9F, 
+0x9E, 0x12, 0x7E, 0x4B, 0x12, 0x7E, 0x22, 0x90, 0x9F, 0x9E, 0x12, 0xA8, 0xB8, 0x12, 0x7E, 0x1C, 
+0x12, 0xA8, 0x82, 0x90, 0x9F, 0x9E, 0x12, 0xA9, 0x15, 0x12, 0x7E, 0x1C, 0xFE, 0x54, 0x40, 0xFD, 
+0xEF, 0x54, 0xBF, 0x4D, 0x90, 0x9F, 0x9E, 0xF0, 0xEE, 0xC3, 0x13, 0x20, 0xE0, 0x02, 0x61, 0xA2, 
+0xE0, 0x30, 0xE0, 0x6D, 0xD1, 0xFB, 0x75, 0x54, 0x21, 0xD1, 0x82, 0x30, 0xE0, 0x04, 0xF1, 0xCF, 
+0x80, 0x0C, 0xE4, 0x90, 0x9F, 0x9F, 0xF0, 0xA3, 0xF0, 0x7D, 0x40, 0xFF, 0xF1, 0x1E, 0x90, 0x9F, 
+0x9E, 0xD1, 0xCB, 0x30, 0xE0, 0x03, 0x43, 0x54, 0x12, 0xEF, 0xC4, 0x54, 0x0F, 0x30, 0xE0, 0x03, 
+0x43, 0x54, 0x14, 0x90, 0x9F, 0x9E, 0xE0, 0xC4, 0x13, 0x54, 0x07, 0x30, 0xE0, 0x03, 0x43, 0x54, 
+0x80, 0x90, 0x9F, 0x9E, 0x12, 0x74, 0x80, 0x20, 0xE0, 0x03, 0x43, 0x54, 0x40, 0x91, 0x43, 0x90, 
+0x9F, 0xA1, 0xE0, 0x70, 0x04, 0x7F, 0x01, 0x91, 0x4A, 0xD1, 0x8B, 0x30, 0xE0, 0x04, 0x7F, 0x04, 
+0x80, 0x0B, 0xD1, 0xD3, 0xEF, 0x60, 0x04, 0x7F, 0x01, 0x80, 0x02, 0x7F, 0x02, 0x91, 0x4A, 0x80, 
+0x7B, 0x91, 0x40, 0x90, 0x9F, 0xA1, 0xE0, 0x64, 0x04, 0x60, 0x02, 0x81, 0x3B, 0xFF, 0x91, 0x4A, 
+0x81, 0x3B, 0x90, 0x9F, 0x9E, 0xE0, 0x30, 0xE0, 0x6B, 0xD1, 0xFB, 0x43, 0x54, 0x31, 0xD1, 0x82, 
+0x30, 0xE0, 0x04, 0xF1, 0xCF, 0x80, 0x06, 0x7D, 0x40, 0xE4, 0xFF, 0xF1, 0x1E, 0x90, 0x9F, 0x9E, 
+0xD1, 0xCB, 0x30, 0xE0, 0x03, 0x43, 0x54, 0x02, 0xEF, 0xC4, 0x54, 0x0F, 0x30, 0xE0, 0x03, 0x43, 
+0x54, 0x04, 0x91, 0x43, 0xD1, 0x8B, 0x30, 0xE0, 0x0B, 0x12, 0x97, 0x2A, 0x60, 0x2E, 0xE4, 0xFD, 
+0x7F, 0x02, 0x80, 0x1C, 0xD1, 0x7A, 0x90, 0x9F, 0xA2, 0xE0, 0xB4, 0x02, 0x17, 0xD1, 0x47, 0xD1, 
+0xD3, 0xBF, 0x01, 0x09, 0x90, 0x9F, 0xA9, 0xE0, 0xFF, 0x7D, 0x01, 0x80, 0x03, 0xE4, 0xFD, 0xFF, 
+0x11, 0x65, 0x80, 0x08, 0x90, 0x9F, 0xAA, 0xE0, 0x90, 0x9F, 0xA2, 0xF0, 0x90, 0x05, 0x40, 0x74, 
+0x22, 0xF0, 0x80, 0x27, 0x91, 0x40, 0x90, 0x9F, 0xA2, 0xE0, 0xB4, 0x02, 0x06, 0x7D, 0x01, 0x7F, 
+0x04, 0x80, 0x0B, 0x90, 0x9F, 0xA2, 0xE0, 0xB4, 0x08, 0x06, 0x7D, 0x01, 0x7F, 0x0C, 0x11, 0x65, 
+0x12, 0x96, 0xBF, 0x90, 0x9F, 0xA9, 0x11, 0x5B, 0x12, 0xA6, 0x8B, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 
+0x75, 0x54, 0x01, 0x90, 0x05, 0x27, 0xE5, 0x54, 0xF0, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 
+0xD0, 0x90, 0x9F, 0xA1, 0xE0, 0x90, 0xA1, 0xEB, 0xF0, 0x6F, 0x70, 0x02, 0xA1, 0x58, 0xEF, 0x14, 
+0x60, 0x42, 0x14, 0x60, 0x6C, 0x14, 0x70, 0x02, 0x81, 0xFD, 0x14, 0x70, 0x02, 0xA1, 0x2C, 0x24, 
+0x04, 0x60, 0x02, 0xA1, 0x58, 0x90, 0xA1, 0xEB, 0xE0, 0xB4, 0x04, 0x04, 0xD1, 0x63, 0xA1, 0x58, 
+0x90, 0xA1, 0xEB, 0xE0, 0xB4, 0x02, 0x04, 0xD1, 0x6E, 0xA1, 0x58, 0x90, 0xA1, 0xEB, 0xE0, 0xB4, 
+0x03, 0x04, 0xD1, 0x76, 0xA1, 0x58, 0x90, 0xA1, 0xEB, 0xE0, 0x64, 0x01, 0x60, 0x02, 0xA1, 0x58, 
+0xD1, 0x65, 0xA1, 0x58, 0x90, 0xA1, 0xEB, 0xE0, 0xB4, 0x04, 0x04, 0xD1, 0x5D, 0xA1, 0x58, 0x90, 
+0xA1, 0xEB, 0xE0, 0xB4, 0x02, 0x04, 0xD1, 0x54, 0xA1, 0x58, 0x90, 0xA1, 0xEB, 0xE0, 0xB4, 0x03, 
+0x04, 0xD1, 0x72, 0xA1, 0x58, 0x90, 0xA1, 0xEB, 0xE0, 0x60, 0x02, 0xA1, 0x58, 0xF1, 0xDE, 0xA1, 
+0x58, 0x90, 0xA1, 0xEB, 0xE0, 0xB4, 0x04, 0x04, 0xF1, 0xED, 0x80, 0x7C, 0x90, 0xA1, 0xEB, 0xE0, 
+0xB4, 0x01, 0x05, 0x12, 0x4F, 0xF3, 0x80, 0x70, 0x90, 0xA1, 0xEB, 0xE0, 0xB4, 0x03, 0x04, 0xF1, 
+0xEA, 0x80, 0x65, 0x90, 0xA1, 0xEB, 0xE0, 0x70, 0x5F, 0xF1, 0xE5, 0x80, 0x5B, 0x90, 0xA1, 0xEB, 
+0xE0, 0xB4, 0x04, 0x05, 0x12, 0xA6, 0xC2, 0x80, 0x4F, 0x90, 0xA1, 0xEB, 0xE0, 0xB4, 0x01, 0x05, 
+0x12, 0xA6, 0xAA, 0x80, 0x43, 0x90, 0xA1, 0xEB, 0xE0, 0xB4, 0x02, 0x05, 0x12, 0xA6, 0xBD, 0x80, 
+0x37, 0x90, 0xA1, 0xEB, 0xE0, 0x70, 0x31, 0x12, 0xA6, 0xB8, 0x80, 0x2C, 0x90, 0xA1, 0xEB, 0xE0, 
+0xB4, 0x03, 0x05, 0x12, 0x57, 0xED, 0x80, 0x20, 0x90, 0xA1, 0xEB, 0xE0, 0xB4, 0x01, 0x05, 0x12, 
+0x57, 0xD9, 0x80, 0x14, 0x90, 0xA1, 0xEB, 0xE0, 0xB4, 0x02, 0x05, 0x12, 0x57, 0xF1, 0x80, 0x08, 
+0x90, 0xA1, 0xEB, 0xE0, 0x70, 0x02, 0xF1, 0xE0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x7E, 0x00, 0x7F, 
+0xA8, 0x7D, 0x00, 0x7B, 0x01, 0x7A, 0x9F, 0x79, 0xA3, 0x12, 0x08, 0xAA, 0x12, 0xA8, 0xC1, 0x12, 
+0x08, 0xAA, 0x90, 0x9F, 0xA6, 0x74, 0x02, 0xF0, 0x90, 0x9F, 0xAD, 0x14, 0xF0, 0xA3, 0xF0, 0xA3, 
+0x74, 0x08, 0xF0, 0x90, 0x9F, 0xB3, 0xE4, 0xF0, 0xA3, 0x74, 0x02, 0xF0, 0x12, 0xA8, 0x8C, 0xE4, 
+0xFD, 0xFF, 0x51, 0x74, 0x7D, 0x0C, 0x7F, 0x02, 0x51, 0x74, 0x51, 0x70, 0x90, 0x9E, 0x97, 0xE0, 
+0xB4, 0x01, 0x08, 0x90, 0x9F, 0xB2, 0x74, 0xFF, 0xF0, 0x80, 0x12, 0x90, 0x9E, 0x97, 0xE0, 0x90, 
+0x9F, 0xB2, 0xB4, 0x03, 0x05, 0x74, 0xD4, 0xF0, 0x80, 0x03, 0x74, 0x41, 0xF0, 0x12, 0x8D, 0xA3, 
+0x12, 0xA8, 0x8C, 0x90, 0xA0, 0x56, 0xE0, 0x54, 0xFE, 0xF0, 0x90, 0x01, 0x38, 0xE0, 0x90, 0xA0, 
+0x57, 0xF0, 0x90, 0x01, 0x39, 0xE0, 0x90, 0xA0, 0x58, 0xF0, 0x90, 0x01, 0x3A, 0xE0, 0x90, 0xA0, 
+0x59, 0xF0, 0x90, 0x01, 0x3B, 0xE0, 0x90, 0xA0, 0x5A, 0xF0, 0x90, 0x01, 0x30, 0xE0, 0x90, 0xA0, 
+0x5B, 0xF0, 0x90, 0x01, 0x31, 0xE0, 0x90, 0xA0, 0x5C, 0xF0, 0x90, 0x01, 0x32, 0xE0, 0x90, 0xA0, 
+0x5D, 0xF0, 0x90, 0x01, 0x33, 0xE0, 0x90, 0xA0, 0x5E, 0xF0, 0x7F, 0x01, 0x12, 0x9B, 0x57, 0x7E, 
+0x00, 0x7F, 0x02, 0x7D, 0x00, 0x7B, 0x01, 0x7A, 0xA0, 0x79, 0x4F, 0x12, 0x08, 0xAA, 0x12, 0xA9, 
+0x67, 0x12, 0xA9, 0x5F, 0xD1, 0x36, 0xE4, 0x90, 0xA0, 0x51, 0xF0, 0x22, 0xF0, 0x7D, 0x04, 0x7F, 
+0x01, 0x41, 0x74, 0x12, 0x4C, 0x71, 0xE4, 0xFD, 0xFF, 0x02, 0x57, 0x8F, 0x12, 0xA9, 0x67, 0xD1, 
+0x36, 0x7D, 0x0C, 0x7F, 0x01, 0x41, 0x74, 0xD1, 0x36, 0xD1, 0x2D, 0xD1, 0x7A, 0x90, 0x9F, 0xA2, 
+0x74, 0x04, 0xF0, 0x22, 0xD1, 0x33, 0x90, 0x9F, 0xA1, 0x74, 0x01, 0xF0, 0x22, 0xD1, 0x36, 0xD1, 
+0x7A, 0x80, 0xF3, 0xD1, 0x5D, 0x12, 0xA7, 0x81, 0xE4, 0x90, 0x9F, 0xA1, 0xF0, 0x22, 0xD1, 0x54, 
+0x80, 0xF3, 0xD1, 0x36, 0x80, 0xE0, 0xD1, 0x72, 0x80, 0xEB, 0x90, 0x05, 0x27, 0xE0, 0x44, 0x40, 
+0xF0, 0x22, 0x90, 0x9F, 0x9E, 0xE0, 0x13, 0x13, 0x54, 0x3F, 0x22, 0x90, 0x9F, 0x9E, 0xE0, 0xFF, 
+0xC4, 0x13, 0x13, 0x54, 0x03, 0x22, 0x90, 0x9F, 0xA3, 0xD1, 0x8E, 0x30, 0xE0, 0x29, 0xEF, 0x54, 
+0xBF, 0x12, 0x9F, 0x62, 0x30, 0xE0, 0x06, 0xE0, 0x44, 0x01, 0xF0, 0x80, 0x09, 0xE0, 0x54, 0xFE, 
+0x12, 0x57, 0xF8, 0x74, 0x04, 0xF0, 0x90, 0xA0, 0x65, 0x12, 0x83, 0x3F, 0x30, 0xE0, 0x06, 0x7D, 
+0x01, 0x7F, 0x0C, 0x01, 0x65, 0x11, 0x4D, 0x22, 0x90, 0x9F, 0xA4, 0xE0, 0xFF, 0x13, 0x13, 0x13, 
+0x54, 0x1F, 0x22, 0x90, 0x05, 0x43, 0xE0, 0x7F, 0x00, 0x30, 0xE7, 0x02, 0x7F, 0x01, 0x22, 0xAE, 
+0x07, 0xD1, 0xD3, 0xBF, 0x01, 0x12, 0x90, 0x9F, 0x9E, 0x12, 0x74, 0x80, 0x20, 0xE0, 0x09, 0xAF, 
+0x06, 0x7D, 0x01, 0x11, 0x65, 0x7F, 0x01, 0x22, 0x7F, 0x00, 0x22, 0x7D, 0x03, 0x7F, 0x02, 0x74, 
+0x1D, 0x2F, 0xF8, 0xE6, 0x4D, 0xFE, 0xF6, 0x74, 0x38, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x01, 0xF5, 
+0x83, 0xEE, 0xF0, 0x22, 0x7D, 0x02, 0x7F, 0x02, 0xF1, 0x1E, 0x7D, 0x01, 0x7F, 0x02, 0x74, 0x15, 
+0x12, 0xA9, 0x6F, 0xFE, 0xF6, 0x74, 0x30, 0x80, 0xE0, 0xEF, 0x70, 0x33, 0x7D, 0x78, 0x7F, 0x02, 
+0xF1, 0x1E, 0x7D, 0x02, 0x7F, 0x03, 0xF1, 0x1E, 0x7D, 0xC8, 0x7F, 0x02, 0xF1, 0xBD, 0x12, 0x9D, 
+0x21, 0xF0, 0xE4, 0xFF, 0x12, 0x50, 0x60, 0xEF, 0x70, 0x0A, 0xF1, 0xB0, 0x54, 0xBF, 0xF0, 0x54, 
+0x7F, 0xF0, 0x80, 0x06, 0x7D, 0x01, 0x7F, 0x0C, 0x11, 0x65, 0xF1, 0xB5, 0x02, 0xA9, 0x5F, 0x90, 
+0x01, 0x36, 0x74, 0x78, 0xF0, 0xA3, 0x74, 0x02, 0xF0, 0x7D, 0x78, 0xFF, 0xF1, 0xA4, 0x7D, 0x02, 
+0x7F, 0x03, 0xF1, 0xA4, 0x90, 0x06, 0x0A, 0xE0, 0x44, 0x07, 0x12, 0x9D, 0xD7, 0xE4, 0xFF, 0x12, 
+0x50, 0x60, 0xBF, 0x01, 0x10, 0x12, 0x97, 0xB4, 0x90, 0x9F, 0xAA, 0xE0, 0x20, 0xE2, 0x09, 0x7D, 
+0x01, 0x7F, 0x04, 0x01, 0x65, 0x12, 0x9A, 0x44, 0x22, 0xF0, 0x7D, 0x01, 0x7F, 0x02, 0xF1, 0xA4, 
+0x7D, 0x02, 0x7F, 0x02, 0x74, 0x15, 0x2F, 0xF8, 0xE6, 0x4D, 0xFE, 0xF6, 0x74, 0x30, 0xE1, 0x09, 
+0x12, 0x4C, 0x71, 0xD1, 0x3C, 0x90, 0x9F, 0xA3, 0xE0, 0x54, 0xF7, 0xF0, 0x22, 0x74, 0x1D, 0x12, 
+0xA9, 0x6F, 0xE1, 0x05, 0xD1, 0x33, 0x51, 0x70, 0x90, 0x9F, 0xA2, 0x74, 0x0C, 0xF0, 0x22, 0x90, 
+0x01, 0x34, 0x74, 0x40, 0xF0, 0xFD, 0xE4, 0xFF, 0xF1, 0xA4, 0x43, 0x54, 0x08, 0x22, 0xC1, 0x56, 
+0xF1, 0xDE, 0x02, 0x57, 0xD9, 0xF1, 0xDE, 0x02, 0x4F, 0xF3, 0x02, 0x4F, 0xFA, 0xD1, 0x7A, 0x7D, 
+0x23, 0x02, 0x4F, 0xF5, 0x7F, 0xF4, 0x12, 0x4A, 0xB8, 0xEF, 0x20, 0xE5, 0x0E, 0x7F, 0xF4, 0x12, 
+0x4A, 0xB8, 0xEF, 0x7F, 0x01, 0x20, 0xE4, 0x05, 0x7F, 0x02, 0x22, 0x7F, 0x03, 0x22, 0x12, 0x5F, 
+0xF4, 0x90, 0x9E, 0x97, 0xEF, 0xF0, 0x11, 0x28, 0x90, 0x01, 0x64, 0x74, 0x01, 0xF0, 0x90, 0x04, 
+0x23, 0xE0, 0x44, 0x80, 0xF0, 0x02, 0x36, 0x83, 0x12, 0x4F, 0x47, 0x12, 0x4F, 0x68, 0x11, 0x35, 
+0x11, 0x54, 0x02, 0x4F, 0xC0, 0x75, 0x15, 0x12, 0xE4, 0xF5, 0x16, 0x75, 0x17, 0x07, 0x75, 0x18, 
+0x72, 0x90, 0x01, 0x30, 0xE5, 0x15, 0xF0, 0xA3, 0xE5, 0x16, 0xF0, 0xA3, 0xE5, 0x17, 0xF0, 0xA3, 
+0xE5, 0x18, 0xF0, 0x22, 0x75, 0x1D, 0x06, 0x75, 0x1E, 0x01, 0x75, 0x1F, 0x03, 0x75, 0x20, 0x62, 
+0x43, 0x20, 0x80, 0x43, 0x1F, 0x04, 0x90, 0x01, 0x38, 0xE5, 0x1D, 0xF0, 0xA3, 0xE5, 0x1E, 0xF0, 
+0xA3, 0xE5, 0x1F, 0xF0, 0xA3, 0xE5, 0x20, 0xF0, 0x22, 0x75, 0xE8, 0x07, 0x75, 0xA8, 0x85, 0x22, 
+0xE4, 0xFB, 0xFA, 0xFD, 0x7F, 0x01, 0x12, 0x48, 0x0E, 0x90, 0xA0, 0xC5, 0xEF, 0xF0, 0x60, 0xF0, 
+0x90, 0x9E, 0x92, 0xE0, 0xFF, 0x70, 0x04, 0xA3, 0xE0, 0x60, 0xE5, 0xC2, 0xAF, 0xEF, 0x30, 0xE0, 
+0x0F, 0x90, 0x9E, 0x92, 0xE0, 0x54, 0xFE, 0xF0, 0xE4, 0xFF, 0x12, 0x6E, 0x07, 0x12, 0x50, 0x89, 
+0x11, 0xD4, 0x30, 0xE1, 0x06, 0x54, 0xFD, 0xF0, 0x12, 0x8F, 0x10, 0x11, 0xD4, 0x30, 0xE2, 0x06, 
+0x54, 0xFB, 0xF0, 0x12, 0x93, 0xAB, 0x11, 0xD4, 0x30, 0xE6, 0x05, 0x54, 0xBF, 0xF0, 0x11, 0xDE, 
+0xD2, 0xAF, 0x80, 0xBC, 0xD2, 0xAF, 0xC2, 0xAF, 0x90, 0x9E, 0x92, 0xE0, 0xFF, 0x22, 0xE4, 0x7B, 
+0x01, 0x7A, 0xA0, 0x79, 0xAA, 0xF1, 0xDD, 0xB4, 0x02, 0x18, 0x90, 0xA1, 0xCC, 0xE0, 0x64, 0x04, 
+0x60, 0x0B, 0x7F, 0x40, 0xB1, 0x78, 0x90, 0xA1, 0xCC, 0xE0, 0x04, 0xF0, 0x22, 0xE4, 0x90, 0xA1, 
+0xCC, 0xF0, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0xA1, 0xA2, 0xEF, 0xF0, 0xA3, 
+0xED, 0xF0, 0xA3, 0x12, 0x49, 0x37, 0x12, 0xA8, 0x2A, 0x70, 0x21, 0x90, 0xFD, 0x58, 0xE0, 0x20, 
+0xE0, 0x12, 0x90, 0xA1, 0xA2, 0xE0, 0xFF, 0xA3, 0xE0, 0xFD, 0xA3, 0x12, 0x49, 0x2E, 0x91, 0x16, 
+0x7F, 0x01, 0x80, 0x0E, 0x7F, 0x01, 0x31, 0x47, 0x7F, 0x02, 0x80, 0x06, 0x7F, 0x02, 0x31, 0x47, 
+0x7F, 0x03, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x51, 0xDE, 0x7F, 0x04, 0x8F, 0x73, 0x7F, 0x02, 0x12, 
+0x47, 0xE7, 0x90, 0x9E, 0x92, 0xE0, 0x45, 0x73, 0xF0, 0x22, 0x90, 0xFD, 0x68, 0xE0, 0xFF, 0x90, 
+0xFD, 0x60, 0xE0, 0x90, 0xA1, 0x03, 0xF0, 0xEF, 0x20, 0xE0, 0x02, 0x41, 0xD7, 0x90, 0xA1, 0xCE, 
+0xE0, 0x70, 0x1A, 0x7F, 0x2E, 0x12, 0x4A, 0xB8, 0x90, 0xA0, 0x9C, 0xEF, 0xF0, 0x7F, 0x2D, 0x12, 
+0x4A, 0xB8, 0x90, 0xA0, 0x9D, 0xEF, 0xF0, 0x90, 0xA1, 0xCE, 0x74, 0x01, 0xF0, 0x90, 0xA1, 0x03, 
+0xE0, 0x64, 0x15, 0x70, 0x58, 0x90, 0xFD, 0x62, 0xE0, 0xFF, 0x30, 0xE6, 0x11, 0xF4, 0x54, 0x3F, 
+0x04, 0xFE, 0x71, 0xF0, 0xC3, 0x9E, 0x71, 0xE8, 0x40, 0x12, 0xE4, 0xF0, 0x80, 0x0E, 0x71, 0xF0, 
+0xFE, 0xEF, 0x54, 0x3F, 0x2E, 0x71, 0xE8, 0x40, 0x03, 0x74, 0x3F, 0xF0, 0x90, 0xA1, 0x02, 0xE0, 
+0xFF, 0x54, 0x30, 0xC4, 0x54, 0x0F, 0xFE, 0xEF, 0x25, 0xE0, 0x25, 0xE0, 0x4E, 0x90, 0xA1, 0x00, 
+0xF0, 0xE0, 0xFD, 0x7F, 0x2E, 0x12, 0x49, 0x90, 0x90, 0xA1, 0x02, 0xE0, 0xC4, 0x54, 0xF0, 0xFF, 
+0x90, 0xA0, 0x9D, 0xE0, 0x54, 0x0F, 0x4F, 0xFD, 0x7F, 0x2D, 0x12, 0x49, 0x90, 0x90, 0xA1, 0x03, 
+0xE0, 0xB4, 0x21, 0x0C, 0x90, 0xFD, 0x62, 0xE0, 0xFF, 0x12, 0x8F, 0xD6, 0x7F, 0x04, 0x31, 0x4B, 
+0x90, 0xA1, 0x03, 0xE0, 0xB4, 0x23, 0x04, 0x7F, 0x01, 0x51, 0xD8, 0x90, 0xA1, 0x03, 0xE0, 0xB4, 
+0x27, 0x04, 0x7F, 0x02, 0x51, 0xD8, 0x90, 0xA1, 0x03, 0xE0, 0xB4, 0x30, 0x0C, 0xE4, 0xFB, 0xFD, 
+0x7F, 0x01, 0x12, 0x8F, 0xF0, 0x7F, 0x04, 0x31, 0x4B, 0x90, 0xA1, 0x03, 0xE0, 0x64, 0x34, 0x70, 
+0x46, 0x90, 0xFD, 0x62, 0xE0, 0x30, 0xE0, 0x32, 0x90, 0xA0, 0x84, 0xE0, 0xFF, 0xC3, 0x13, 0x20, 
+0xE0, 0x35, 0x90, 0xA1, 0x00, 0x74, 0x01, 0xF0, 0xFB, 0x7A, 0xA1, 0x79, 0x00, 0xFD, 0x7F, 0x34, 
+0x31, 0x03, 0x90, 0xA1, 0x00, 0x74, 0x03, 0xF0, 0xE0, 0xFF, 0x91, 0x78, 0x90, 0x04, 0x9D, 0xE4, 
+0xF0, 0xE0, 0x44, 0x01, 0xF0, 0x12, 0x8E, 0xA2, 0x80, 0x0D, 0x12, 0x90, 0x61, 0x90, 0x04, 0x9D, 
+0xE0, 0x54, 0xFE, 0xF0, 0x12, 0x8F, 0x8F, 0x90, 0xA1, 0x03, 0xE0, 0xFD, 0xB4, 0x35, 0x07, 0x90, 
+0xA0, 0x66, 0xE0, 0x44, 0x01, 0xF0, 0xED, 0xB4, 0x36, 0x22, 0x90, 0xFD, 0x61, 0xE0, 0x90, 0xA1, 
+0x00, 0xF0, 0x90, 0xFD, 0x62, 0xE0, 0x90, 0xA1, 0x01, 0xF0, 0x90, 0xA1, 0x03, 0xE0, 0xFF, 0x90, 
+0xA1, 0x00, 0xE0, 0xFD, 0x7B, 0x01, 0x7A, 0xA1, 0x79, 0x01, 0x31, 0x03, 0x90, 0xA1, 0x03, 0xE0, 
+0xB4, 0x37, 0x02, 0x91, 0xD4, 0x90, 0xA1, 0x03, 0xE0, 0xB4, 0x40, 0x14, 0x90, 0xFD, 0x62, 0xE0, 
+0x30, 0xE0, 0x08, 0x90, 0xA0, 0x82, 0x74, 0x01, 0xF0, 0x80, 0x05, 0xE4, 0x90, 0xA0, 0x82, 0xF0, 
+0x90, 0xFD, 0x68, 0xE0, 0x44, 0x01, 0xF0, 0x22, 0x71, 0x03, 0x7F, 0x04, 0x21, 0x4B, 0xD3, 0x10, 
+0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0xA1, 0x6C, 0x74, 0x15, 0xF0, 0x90, 0xA1, 0x7A, 0x74, 0x01, 
+0xF0, 0x90, 0xA1, 0x6E, 0xEF, 0xF0, 0x7B, 0x01, 0x7A, 0xA1, 0x79, 0x6C, 0x71, 0x89, 0xD0, 0xD0, 
+0x92, 0xAF, 0x22, 0x90, 0xA1, 0x4E, 0x74, 0x09, 0xF0, 0x90, 0xA1, 0x5C, 0x74, 0x07, 0xF0, 0x90, 
+0xA1, 0x50, 0xEF, 0xF0, 0x70, 0x31, 0x90, 0xA0, 0x78, 0xE0, 0x60, 0x1A, 0xA3, 0xE0, 0x60, 0x02, 
+0x80, 0x0C, 0x90, 0x07, 0x70, 0xE0, 0x70, 0x06, 0x90, 0x07, 0x74, 0xE0, 0x60, 0x08, 0x90, 0xA1, 
+0x51, 0x74, 0x01, 0xF0, 0x80, 0x05, 0xE4, 0x90, 0xA1, 0x51, 0xF0, 0xE4, 0x90, 0xA1, 0x52, 0xF0, 
+0xA3, 0xF0, 0xA3, 0xF0, 0xA3, 0x80, 0x39, 0x90, 0xFD, 0x62, 0xE0, 0x90, 0xA1, 0x51, 0xF0, 0x90, 
+0xFD, 0x63, 0xE0, 0x90, 0xA1, 0x52, 0xF0, 0x90, 0xFD, 0x64, 0xE0, 0x90, 0xA1, 0x53, 0xF0, 0x90, 
+0xFD, 0x65, 0xE0, 0x90, 0xA1, 0x54, 0xF0, 0x90, 0xFD, 0x66, 0xE0, 0x90, 0xA1, 0x55, 0xF0, 0x90, 
+0xFD, 0x67, 0xE0, 0x90, 0xA1, 0x56, 0xF0, 0x90, 0xA1, 0x51, 0xE0, 0x54, 0x01, 0x90, 0xA0, 0x78, 
+0xF0, 0xA3, 0xF0, 0x7B, 0x01, 0x7A, 0xA1, 0x79, 0x4E, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 
+0x90, 0x9F, 0x87, 0xE0, 0xFF, 0x70, 0x06, 0xA3, 0xE0, 0x64, 0x09, 0x60, 0x0A, 0xEF, 0x14, 0xFF, 
+0x90, 0x9F, 0x88, 0xE0, 0xB5, 0x07, 0x04, 0x7F, 0x01, 0x80, 0x02, 0x7F, 0x00, 0xEF, 0x60, 0x09, 
+0x90, 0x01, 0xC1, 0xE0, 0x44, 0x02, 0xF0, 0x80, 0x2A, 0xC0, 0x01, 0x90, 0x9F, 0x88, 0xE0, 0x12, 
+0x94, 0x8B, 0xA8, 0x01, 0xFC, 0x7D, 0x01, 0xD0, 0x01, 0x7E, 0x00, 0x7F, 0x0F, 0x12, 0x06, 0x63, 
+0x90, 0x9F, 0x88, 0x12, 0x8F, 0x70, 0xB4, 0x0A, 0x02, 0x7F, 0x01, 0xEF, 0x60, 0x05, 0xE4, 0x90, 
+0x9F, 0x88, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0xA1, 0x02, 0xF0, 0xD3, 0x94, 0x3F, 0x22, 
+0x90, 0xA0, 0x9C, 0xE0, 0x13, 0x13, 0x54, 0x3F, 0x22, 0x90, 0xA0, 0x87, 0xE0, 0x44, 0x04, 0xF0, 
+0x7D, 0x01, 0x7F, 0x23, 0x31, 0x03, 0x8F, 0x51, 0xE5, 0x51, 0xB4, 0x03, 0x08, 0xE4, 0xFF, 0x71, 
+0x03, 0x7F, 0x04, 0xB1, 0x78, 0x22, 0x90, 0xA1, 0xCF, 0x12, 0x49, 0x37, 0xE4, 0xFE, 0x90, 0xFD, 
+0x50, 0xEF, 0xF0, 0x64, 0x30, 0x60, 0x1F, 0xA3, 0xED, 0xF0, 0xEE, 0xC3, 0x9D, 0x50, 0x0A, 0x91, 
+0x6A, 0xFF, 0x91, 0x5F, 0xEF, 0xF0, 0x0E, 0x80, 0xF1, 0xEE, 0xC3, 0x94, 0x06, 0x50, 0x19, 0x91, 
+0x5F, 0xE4, 0xF0, 0x0E, 0x80, 0xF3, 0xEE, 0xC3, 0x94, 0x07, 0x50, 0x0C, 0x91, 0x6A, 0xFF, 0x74, 
+0x51, 0x91, 0x61, 0xEF, 0xF0, 0x0E, 0x80, 0xEE, 0x90, 0xFD, 0x58, 0x74, 0x01, 0xF0, 0x22, 0x74, 
+0x52, 0x2E, 0xF5, 0x82, 0xE4, 0x34, 0xFD, 0xF5, 0x83, 0x22, 0x90, 0xA1, 0xCF, 0x12, 0x49, 0x2E, 
+0x8E, 0x82, 0x75, 0x83, 0x00, 0x02, 0x06, 0xA2, 0x90, 0xA1, 0x05, 0xEF, 0xF0, 0x12, 0x90, 0xA1, 
+0xE4, 0xFE, 0xFD, 0xEC, 0x90, 0xA0, 0x7B, 0x12, 0x08, 0x6D, 0x90, 0xA0, 0x7A, 0xE0, 0x44, 0x01, 
+0xF0, 0x7D, 0x11, 0x12, 0x4A, 0xD5, 0x90, 0x07, 0x78, 0xE0, 0x90, 0xA0, 0x7F, 0xF0, 0x12, 0x87, 
+0xCC, 0x12, 0x4D, 0x38, 0x90, 0xA1, 0x05, 0xE0, 0xFD, 0x70, 0x02, 0x80, 0x1C, 0xED, 0xB4, 0x01, 
+0x06, 0x91, 0xCD, 0x44, 0x20, 0xF0, 0x22, 0x90, 0xA1, 0x05, 0xE0, 0xFD, 0xB4, 0x02, 0x06, 0x91, 
+0xCD, 0x44, 0x60, 0xF0, 0x22, 0xED, 0xB4, 0x03, 0x03, 0x91, 0xCD, 0xF0, 0x22, 0x90, 0xA0, 0x7A, 
+0xE0, 0x54, 0x1F, 0x22, 0x90, 0xA0, 0x62, 0x12, 0x74, 0x80, 0x20, 0xE0, 0x1D, 0x90, 0xFD, 0x62, 
+0xE0, 0x30, 0xE0, 0x16, 0xE0, 0x90, 0xA1, 0x04, 0x30, 0xE1, 0x05, 0x74, 0x01, 0xF0, 0x80, 0x03, 
+0x74, 0x02, 0xF0, 0x90, 0xA1, 0x04, 0xE0, 0xFF, 0x91, 0x78, 0x22, 0x90, 0xA0, 0xE4, 0xEF, 0xF0, 
+0x90, 0x04, 0x7E, 0xE0, 0xF5, 0x66, 0xA3, 0xE0, 0xF5, 0x67, 0x65, 0x66, 0x60, 0x69, 0x90, 0xA0, 
+0xE5, 0x74, 0x03, 0xF0, 0x90, 0xA0, 0xF3, 0x74, 0x08, 0xF0, 0xE5, 0x67, 0x04, 0x54, 0x0F, 0xF5, 
+0x68, 0xE4, 0xF5, 0x65, 0xE5, 0x68, 0x75, 0xF0, 0x08, 0xA4, 0x24, 0x00, 0xF5, 0x82, 0xE4, 0x34, 
+0x80, 0xF5, 0x83, 0xE5, 0x82, 0x25, 0x65, 0x12, 0x4F, 0xB8, 0xE0, 0xFF, 0x74, 0xE7, 0x25, 0x65, 
+0xF5, 0x82, 0xE4, 0x34, 0xA0, 0xF5, 0x83, 0xEF, 0xF0, 0x05, 0x65, 0xE5, 0x65, 0xB4, 0x08, 0xD4, 
+0x7B, 0x01, 0x7A, 0xA0, 0x79, 0xE5, 0x71, 0x89, 0xE5, 0x67, 0x04, 0x54, 0x0F, 0xF5, 0x67, 0xB4, 
+0x0F, 0x03, 0xE4, 0xF5, 0x67, 0x90, 0x04, 0x7F, 0xE5, 0x67, 0xF0, 0x90, 0xA0, 0xE4, 0xE0, 0x7F, 
+0x04, 0x70, 0x02, 0x21, 0x4B, 0xB1, 0x78, 0x22, 0x90, 0xA1, 0xE7, 0xEF, 0xF0, 0x7F, 0x02, 0x12, 
+0x47, 0xE7, 0x90, 0x9E, 0x92, 0xE0, 0xFF, 0x90, 0xA1, 0xE7, 0xE0, 0xFE, 0xEF, 0x4E, 0x90, 0x9E, 
+0x92, 0xF0, 0x22, 0xB1, 0xB9, 0x12, 0x06, 0x89, 0x90, 0xA0, 0xAA, 0xD1, 0xFB, 0x90, 0xA0, 0xAB, 
+0xF1, 0x35, 0x90, 0xA0, 0xAC, 0xF0, 0x90, 0xA0, 0x87, 0xE0, 0x44, 0x01, 0xF0, 0xB1, 0xBF, 0xF1, 
+0xDD, 0xB4, 0x02, 0x04, 0x7F, 0x40, 0xB1, 0x78, 0x22, 0x90, 0xA0, 0xCA, 0x12, 0x49, 0x37, 0x90, 
+0xA0, 0xCA, 0x02, 0x49, 0x2E, 0xF1, 0xE9, 0x12, 0x06, 0x89, 0xFF, 0x54, 0x7F, 0x90, 0x9F, 0xA7, 
+0xF0, 0xEF, 0x12, 0x76, 0xBF, 0xA3, 0xD1, 0xFB, 0xFF, 0x54, 0xF0, 0xC4, 0x54, 0x0F, 0xFE, 0x90, 
+0x9F, 0xA5, 0xE0, 0x54, 0xF0, 0x4E, 0xF0, 0x12, 0x7A, 0xD3, 0x54, 0x01, 0x25, 0xE0, 0xFE, 0x90, 
+0x9F, 0xA3, 0xE0, 0x54, 0xFD, 0x4E, 0xF0, 0xEF, 0x54, 0x0F, 0xC4, 0x54, 0xF0, 0xFF, 0x12, 0x96, 
+0xE6, 0x4F, 0xF1, 0x35, 0x90, 0x9F, 0xA6, 0xF1, 0xCD, 0x30, 0xE0, 0x52, 0xC3, 0x13, 0x54, 0x07, 
+0xFF, 0xC3, 0x94, 0x04, 0x90, 0x9F, 0xBA, 0x50, 0x04, 0xEF, 0xF0, 0x80, 0x2A, 0x74, 0x03, 0xF0, 
+0xB1, 0xBF, 0xE9, 0x24, 0x06, 0xF9, 0xE4, 0x3A, 0xFA, 0x12, 0x06, 0x89, 0xFF, 0x74, 0x03, 0x24, 
+0xFD, 0xFE, 0xEF, 0xC4, 0x54, 0x0F, 0xFD, 0xEF, 0x54, 0x0F, 0xFF, 0xED, 0x2E, 0x54, 0x0F, 0xFE, 
+0xC4, 0x54, 0xF0, 0x4F, 0x12, 0x06, 0xCF, 0xB1, 0xBF, 0xF1, 0xCE, 0xC4, 0x54, 0x0F, 0xFF, 0xC3, 
+0x94, 0x04, 0x90, 0x9F, 0xAF, 0x50, 0x05, 0x74, 0x04, 0xF0, 0x80, 0x02, 0xEF, 0xF0, 0xB1, 0xBF, 
+0xF1, 0xD7, 0xFD, 0x7F, 0x02, 0x12, 0x5A, 0x74, 0xB1, 0xBF, 0xD1, 0xDF, 0xFF, 0x54, 0x01, 0xFE, 
+0x90, 0xA0, 0x50, 0x12, 0x7E, 0x4B, 0xD1, 0xDD, 0x12, 0x7E, 0x27, 0x90, 0xA0, 0x50, 0x12, 0xA8, 
+0xB8, 0xD1, 0xDC, 0x12, 0xA8, 0x82, 0x90, 0xA0, 0x50, 0x12, 0xA9, 0x15, 0xD1, 0xDC, 0x12, 0x7E, 
+0x0D, 0x4E, 0x90, 0xA0, 0x50, 0xF0, 0x12, 0x5E, 0x8E, 0x20, 0xE0, 0x29, 0xEF, 0xC3, 0x13, 0x20, 
+0xE0, 0x0B, 0x75, 0x52, 0x01, 0x90, 0xA0, 0xA0, 0xE0, 0x60, 0x0B, 0x80, 0x0E, 0xE4, 0xF5, 0x52, 
+0x90, 0xA0, 0xA0, 0xE0, 0x60, 0x05, 0xE4, 0xF5, 0x51, 0x80, 0x03, 0x75, 0x51, 0x01, 0xAD, 0x52, 
+0xAF, 0x51, 0x12, 0x4D, 0x38, 0xB1, 0xBF, 0x12, 0xA6, 0xF3, 0x12, 0x57, 0xF9, 0xF0, 0x90, 0x9F, 
+0xA7, 0x12, 0xA8, 0xCE, 0x12, 0x96, 0xE5, 0x90, 0x01, 0xBE, 0xF0, 0x22, 0x4E, 0xFF, 0xF0, 0x90, 
+0x00, 0x05, 0x02, 0x06, 0xA2, 0xB1, 0xB9, 0x12, 0x06, 0x89, 0x90, 0xA0, 0xBD, 0xD1, 0xFB, 0x90, 
+0xA0, 0xBE, 0xF0, 0xB1, 0xBF, 0x7D, 0x02, 0x7F, 0x38, 0x21, 0x03, 0xF0, 0x90, 0x00, 0x01, 0x02, 
+0x06, 0xA2, 0x90, 0xA0, 0xCA, 0x74, 0x0A, 0xF0, 0x90, 0xA0, 0xD8, 0x74, 0x06, 0xF0, 0x12, 0x06, 
+0x89, 0x90, 0xA0, 0xCC, 0xD1, 0xFB, 0x90, 0xA0, 0xCD, 0xF1, 0x35, 0x90, 0xA0, 0xCE, 0xF0, 0x12, 
+0x7A, 0xD3, 0x90, 0xA0, 0xCF, 0xF1, 0xD6, 0x90, 0xA0, 0xD0, 0xD1, 0xDE, 0x90, 0xA0, 0xD1, 0xF0, 
+0x12, 0x7E, 0xD8, 0x61, 0x89, 0xF0, 0x90, 0x00, 0x02, 0x02, 0x06, 0xA2, 0x12, 0x06, 0x89, 0xF5, 
+0x51, 0xD1, 0xFC, 0xF5, 0x54, 0xF1, 0x36, 0xF5, 0x55, 0x12, 0x7A, 0xD3, 0xF5, 0x56, 0xF1, 0xD7, 
+0xF5, 0x57, 0xD1, 0xDF, 0xF5, 0x58, 0xF1, 0xCE, 0xF5, 0x59, 0xE5, 0x51, 0x12, 0x49, 0x40, 0x67, 
+0x78, 0x00, 0x67, 0x80, 0x01, 0x67, 0x88, 0x02, 0x67, 0x90, 0x03, 0x67, 0x98, 0x04, 0x67, 0xA0, 
+0x05, 0x67, 0xA8, 0x06, 0x00, 0x00, 0x67, 0xBB, 0x75, 0x52, 0x02, 0x75, 0x53, 0x29, 0x80, 0x41, 
+0x75, 0x52, 0x06, 0x75, 0x53, 0x2A, 0x80, 0x39, 0x75, 0x52, 0x01, 0x75, 0x53, 0x31, 0x80, 0x31, 
+0x75, 0x52, 0x01, 0x75, 0x53, 0x32, 0x80, 0x29, 0x75, 0x52, 0x06, 0x75, 0x53, 0x33, 0x80, 0x21, 
+0x7B, 0x00, 0x7A, 0x00, 0x79, 0x54, 0xE1, 0x02, 0x90, 0xA0, 0xA2, 0x12, 0xA9, 0x7F, 0xA3, 0xE5, 
+0x56, 0xF0, 0xA3, 0xE5, 0x57, 0xF0, 0xA3, 0xE5, 0x58, 0xF0, 0x22, 0x75, 0x52, 0x01, 0x75, 0x53, 
+0xFF, 0x7B, 0x00, 0x7A, 0x00, 0x79, 0x54, 0xAD, 0x52, 0xAF, 0x53, 0x21, 0x03, 0xF0, 0x90, 0x00, 
+0x06, 0x02, 0x06, 0xA2, 0x4E, 0xFF, 0xF0, 0x90, 0x00, 0x04, 0x02, 0x06, 0xA2, 0x7D, 0x03, 0x7F, 
+0x11, 0x31, 0x03, 0xEF, 0x22, 0xE4, 0xFF, 0x81, 0xFB, 0x90, 0xA0, 0xCA, 0x02, 0x49, 0x37, 0x32, 
+0xC0, 0xE0, 0xC0, 0xF0, 0xC0, 0x83, 0xC0, 0x82, 0xC0, 0xD0, 0x75, 0xD0, 0x00, 0xC0, 0x00, 0xC0, 
+0x01, 0xC0, 0x02, 0xC0, 0x03, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0x12, 0x4B, 0x7C, 
+0xE5, 0x14, 0x30, 0xE7, 0x02, 0x11, 0x32, 0xD0, 0x07, 0xD0, 0x06, 0xD0, 0x05, 0xD0, 0x04, 0xD0, 
+0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x82, 0xD0, 0x83, 0xD0, 0xF0, 0xD0, 
+0xE0, 0x32, 0x7F, 0x01, 0x7E, 0x00, 0x12, 0x3C, 0xEC, 0x7F, 0xF2, 0x12, 0x4A, 0xB8, 0xEF, 0x20, 
+0xE6, 0x09, 0x7F, 0x05, 0x11, 0x4C, 0x7F, 0x05, 0x12, 0x49, 0x90, 0x22, 0x12, 0x4A, 0xB8, 0xEF, 
+0x44, 0x80, 0xFD, 0x22, 0xC0, 0xE0, 0xC0, 0xF0, 0xC0, 0x83, 0xC0, 0x82, 0xC0, 0xD0, 0x75, 0xD0, 
+0x00, 0xC0, 0x00, 0xC0, 0x01, 0xC0, 0x02, 0xC0, 0x03, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 
+0x07, 0x12, 0x98, 0x27, 0xE5, 0x19, 0x30, 0xE1, 0x03, 0x12, 0x67, 0xE5, 0xE5, 0x19, 0x30, 0xE4, 
+0x03, 0x12, 0x92, 0xD0, 0xE5, 0x19, 0x30, 0xE5, 0x03, 0x12, 0x98, 0x84, 0xE5, 0x19, 0x30, 0xE6, 
+0x03, 0x12, 0x98, 0xC0, 0xE5, 0x1B, 0x30, 0xE0, 0x03, 0x12, 0x98, 0xCD, 0xE5, 0x1B, 0x30, 0xE1, 
+0x03, 0x12, 0x80, 0x4B, 0xE5, 0x1B, 0x30, 0xE2, 0x03, 0x12, 0x9E, 0x22, 0xE5, 0x1B, 0x30, 0xE3, 
+0x03, 0x12, 0x50, 0x48, 0xE5, 0x1B, 0x30, 0xE4, 0x03, 0x12, 0x9E, 0x05, 0xE5, 0x1B, 0x30, 0xE5, 
+0x03, 0x12, 0x97, 0x31, 0xE5, 0x1B, 0x30, 0xE6, 0x03, 0x12, 0x9D, 0xED, 0xE5, 0x1C, 0x30, 0xE1, 
+0x03, 0x12, 0x9E, 0xD8, 0xE5, 0x1C, 0x30, 0xE4, 0x02, 0xF1, 0x84, 0xE5, 0x1C, 0x30, 0xE5, 0x02, 
+0x31, 0x04, 0xE5, 0x1C, 0x30, 0xE6, 0x02, 0xF1, 0xE3, 0xD0, 0x07, 0xD0, 0x06, 0xD0, 0x05, 0xD0, 
+0x04, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x82, 0xD0, 0x83, 0xD0, 
+0xF0, 0xD0, 0xE0, 0x32, 0xE4, 0xF5, 0x65, 0x90, 0x9F, 0x9C, 0xE0, 0xFF, 0xE5, 0x65, 0xC3, 0x9F, 
+0x40, 0x02, 0x21, 0xB2, 0xAF, 0x65, 0x12, 0x50, 0x60, 0xEF, 0x70, 0x02, 0x21, 0xAE, 0xE5, 0x65, 
+0x13, 0x13, 0x13, 0x54, 0x1F, 0xFF, 0xE5, 0x65, 0x54, 0x07, 0xFE, 0x74, 0x81, 0x2F, 0xB1, 0x5D, 
+0xE0, 0xFD, 0xAF, 0x06, 0xF1, 0xCF, 0x80, 0x05, 0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 0xF9, 0xFF, 
+0xEF, 0x5D, 0x60, 0x6A, 0x75, 0xF0, 0x10, 0xE5, 0x65, 0x12, 0x56, 0xB6, 0xE0, 0x20, 0xE7, 0x02, 
+0x80, 0x10, 0x75, 0xF0, 0x10, 0xE5, 0x65, 0x90, 0x81, 0x02, 0x12, 0x49, 0x22, 0xE0, 0xFF, 0x20, 
+0xE7, 0x09, 0x90, 0x01, 0xC1, 0xE0, 0x44, 0x20, 0xF0, 0x80, 0x43, 0xEF, 0x30, 0xE6, 0x13, 0x75, 
+0xF0, 0x10, 0xE5, 0x65, 0x12, 0x57, 0x73, 0xB1, 0x65, 0x12, 0x4E, 0x2B, 0x31, 0xBF, 0xE4, 0xFB, 
+0x80, 0x28, 0x31, 0xB3, 0xE0, 0x04, 0xF0, 0x31, 0xB3, 0xE0, 0xD3, 0x94, 0x01, 0x40, 0x0A, 0xAF, 
+0x65, 0xF1, 0x38, 0x31, 0xB3, 0xE4, 0xF0, 0x80, 0x15, 0x75, 0xF0, 0x10, 0xE5, 0x65, 0x12, 0x57, 
+0x73, 0xB1, 0x65, 0x12, 0x4E, 0x2B, 0x31, 0xBF, 0x7B, 0x01, 0xAF, 0x65, 0x91, 0x1B, 0x05, 0x65, 
+0x21, 0x07, 0x22, 0x74, 0x11, 0x25, 0x65, 0xF5, 0x82, 0xE4, 0x34, 0x9D, 0xF5, 0x83, 0x22, 0x13, 
+0x13, 0x54, 0x03, 0xF5, 0x6C, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0xA1, 0xC4, 
+0xEF, 0xF0, 0x75, 0xF0, 0x04, 0x12, 0x4F, 0xA1, 0x54, 0x1F, 0xFB, 0x60, 0x12, 0x64, 0x02, 0x60, 
+0x0E, 0xEB, 0x64, 0x04, 0x60, 0x09, 0xEB, 0x64, 0x09, 0x60, 0x04, 0xEB, 0xB4, 0x0C, 0x09, 0xB1, 
+0x9B, 0xF5, 0x83, 0x74, 0x02, 0xF0, 0x80, 0x07, 0xB1, 0x9B, 0xF5, 0x83, 0x74, 0x01, 0xF0, 0xE4, 
+0xF5, 0x6D, 0x90, 0xA1, 0xC4, 0xE0, 0xFD, 0x91, 0x06, 0x25, 0x6D, 0x12, 0x4F, 0xB8, 0xE0, 0xFE, 
+0xEB, 0x75, 0xF0, 0x07, 0xA4, 0x24, 0x56, 0xF5, 0x82, 0xE4, 0x34, 0x40, 0xF5, 0x83, 0xE5, 0x82, 
+0x25, 0x6D, 0x12, 0x4F, 0xB8, 0xE4, 0x93, 0xFC, 0xEE, 0x5C, 0x90, 0xA1, 0xC7, 0xF0, 0x75, 0xF0, 
+0x04, 0xED, 0x12, 0x4E, 0x2B, 0x54, 0x03, 0xFF, 0xBF, 0x02, 0x0B, 0xE5, 0x6D, 0x70, 0x07, 0x90, 
+0xA1, 0xC7, 0xE0, 0x54, 0xF0, 0xF0, 0x90, 0xA1, 0xC7, 0xE0, 0xFF, 0x91, 0x02, 0x25, 0x6D, 0x12, 
+0x4F, 0xB8, 0xEF, 0xF0, 0x05, 0x6D, 0xE5, 0x6D, 0x64, 0x07, 0x70, 0xA6, 0x90, 0xA1, 0xC4, 0xE0, 
+0x75, 0xF0, 0x04, 0x12, 0x4E, 0x2B, 0xFF, 0xC4, 0x54, 0x03, 0xFD, 0xE4, 0x90, 0xA1, 0xC5, 0xF0, 
+0x75, 0x6E, 0x06, 0xE5, 0x6E, 0xB4, 0x06, 0x08, 0x12, 0x4F, 0xA8, 0xE0, 0x54, 0x0F, 0x80, 0x08, 
+0x91, 0x02, 0x25, 0x6E, 0x12, 0x4F, 0xB8, 0xE0, 0x90, 0xA1, 0xC6, 0xF0, 0x90, 0xA1, 0xC6, 0xE0, 
+0x60, 0x30, 0x75, 0x6D, 0x07, 0xB1, 0x6D, 0x80, 0x05, 0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 0xF9, 
+0xB1, 0x7E, 0x60, 0x15, 0xB1, 0x75, 0x90, 0xA1, 0xC5, 0xF0, 0xED, 0x60, 0x22, 0xE0, 0xD3, 0x94, 
+0x0B, 0x40, 0x1C, 0xE0, 0x24, 0x20, 0xF0, 0x80, 0x16, 0x15, 0x6D, 0xE5, 0x6D, 0xC3, 0x94, 0x00, 
+0x50, 0xD3, 0xE5, 0x6E, 0x60, 0x09, 0x15, 0x6E, 0xE5, 0x6E, 0xC3, 0x94, 0x00, 0x50, 0xA4, 0xE4, 
+0xFC, 0xF5, 0x6E, 0xE5, 0x6E, 0xB4, 0x06, 0x08, 0x12, 0x4F, 0xA8, 0xE0, 0x54, 0x0F, 0x80, 0x08, 
+0x91, 0x02, 0x25, 0x6E, 0x12, 0x4F, 0xB8, 0xE0, 0x90, 0xA1, 0xC6, 0xF0, 0x90, 0xA1, 0xC6, 0xE0, 
+0x60, 0x2B, 0xE4, 0xF5, 0x6D, 0xB1, 0x6D, 0x80, 0x05, 0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 0xF9, 
+0xB1, 0x7E, 0x60, 0x12, 0xB1, 0x75, 0xFC, 0xED, 0x60, 0x1B, 0xEC, 0xD3, 0x94, 0x0B, 0x40, 0x15, 
+0x74, 0x20, 0x2C, 0xFC, 0x80, 0x0F, 0x05, 0x6D, 0xE5, 0x6D, 0xB4, 0x08, 0xD8, 0x05, 0x6E, 0xE5, 
+0x6E, 0x64, 0x07, 0x70, 0xAE, 0x90, 0xA1, 0xC5, 0xE0, 0xFF, 0x90, 0xA1, 0xC4, 0xE0, 0xFE, 0x75, 
+0xF0, 0x04, 0xF1, 0x7E, 0xEF, 0xF0, 0x75, 0xF0, 0x04, 0xEE, 0x12, 0x4F, 0xEE, 0xEC, 0xF0, 0x75, 
+0xF0, 0x10, 0xEE, 0x12, 0x57, 0x73, 0xE0, 0xFE, 0x54, 0x7F, 0xF5, 0x6F, 0xEE, 0x54, 0x80, 0xFE, 
+0xE5, 0x6F, 0xD3, 0x9F, 0x40, 0x09, 0x90, 0xA1, 0xC5, 0xE0, 0x4E, 0xF5, 0x6F, 0x80, 0x0C, 0xE5, 
+0x6F, 0xC3, 0x9C, 0x50, 0x06, 0xAF, 0x06, 0xEC, 0x4F, 0xF5, 0x6F, 0x90, 0xA1, 0xC4, 0xE0, 0xFF, 
+0x24, 0x91, 0x12, 0xA8, 0x69, 0xE5, 0x6F, 0xF0, 0x75, 0xF0, 0x04, 0xEF, 0x12, 0x4E, 0x2B, 0x31, 
+0xBF, 0x90, 0xA1, 0xC4, 0xE0, 0xFF, 0xE4, 0xFB, 0xAD, 0x6F, 0x91, 0x1B, 0x90, 0xA1, 0xC4, 0xE0, 
+0xFF, 0x75, 0xF0, 0x10, 0xD1, 0x01, 0xE4, 0xF0, 0x90, 0xA1, 0xC5, 0xE0, 0xFE, 0xC3, 0x94, 0x36, 
+0x40, 0x0A, 0x74, 0x91, 0x2F, 0x71, 0xFA, 0x74, 0x05, 0xF0, 0x80, 0x43, 0xEE, 0xC3, 0x94, 0x2C, 
+0x40, 0x07, 0x71, 0xF4, 0x74, 0x04, 0xF0, 0x80, 0x36, 0x90, 0xA1, 0xC5, 0xE0, 0xFF, 0xC3, 0x94, 
+0x14, 0x40, 0x07, 0x71, 0xF4, 0x74, 0x03, 0xF0, 0x80, 0x25, 0xEF, 0xC3, 0x94, 0x0C, 0x40, 0x07, 
+0x71, 0xF4, 0x74, 0x02, 0xF0, 0x80, 0x18, 0x90, 0xA1, 0xC5, 0xE0, 0xC3, 0x94, 0x04, 0x90, 0xA1, 
+0xC4, 0xE0, 0x40, 0x07, 0x71, 0xF8, 0x74, 0x01, 0xF0, 0x80, 0x04, 0x71, 0xF8, 0xE4, 0xF0, 0xD0, 
+0xD0, 0x92, 0xAF, 0x22, 0x90, 0xA1, 0xC4, 0xE0, 0x24, 0x91, 0xF5, 0x82, 0xE4, 0x34, 0x95, 0xF5, 
+0x83, 0x22, 0x90, 0xA1, 0xC4, 0xE0, 0x75, 0xF0, 0x08, 0x90, 0x89, 0x00, 0x12, 0x49, 0x22, 0xE5, 
+0x82, 0x22, 0x85, 0x61, 0x6C, 0x7B, 0x01, 0xAD, 0x5F, 0xAF, 0x5E, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 
+0xC0, 0xD0, 0x8F, 0x69, 0x8D, 0x6A, 0xE4, 0x90, 0xA1, 0x80, 0xF0, 0xE5, 0x69, 0x13, 0x13, 0x13, 
+0x54, 0x1F, 0x90, 0xA1, 0x7B, 0xF0, 0xE5, 0x69, 0x54, 0x07, 0x90, 0xA1, 0x7D, 0xF0, 0x75, 0xF0, 
+0x10, 0xEF, 0x12, 0x56, 0xB6, 0xE0, 0x90, 0xA1, 0x7E, 0xF1, 0x79, 0xE0, 0x54, 0x7F, 0x90, 0xA1, 
+0x81, 0xF0, 0x75, 0xF0, 0x04, 0xE5, 0x69, 0x12, 0x4F, 0xEE, 0xE0, 0x90, 0xA1, 0x82, 0xF0, 0xB1, 
+0x87, 0xEB, 0x70, 0x24, 0xE0, 0xFF, 0x12, 0xA5, 0x49, 0x12, 0xA5, 0x3F, 0xEF, 0x12, 0xA3, 0x7C, 
+0x74, 0x01, 0x93, 0x2D, 0xFF, 0xE4, 0x93, 0x3C, 0xC3, 0x13, 0xFE, 0xEF, 0x13, 0xFF, 0xE5, 0x69, 
+0x12, 0x56, 0xCA, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0xA1, 0x81, 0xE0, 0xFF, 0x90, 0xA1, 0x7C, 
+0xE0, 0xFE, 0xD3, 0x9F, 0x40, 0x0B, 0xE5, 0x6A, 0x54, 0x80, 0xFD, 0xEF, 0x4D, 0xF5, 0x6A, 0x80, 
+0x0C, 0x90, 0xA1, 0x82, 0xE0, 0xFF, 0xEE, 0xC3, 0x9F, 0x50, 0x02, 0x8F, 0x6A, 0xB1, 0x87, 0xE5, 
+0x6A, 0x54, 0x80, 0x90, 0xA1, 0x7F, 0xF0, 0xEB, 0x70, 0x24, 0x90, 0xA1, 0x7B, 0xE0, 0x24, 0x81, 
+0xB1, 0x5D, 0xC0, 0x83, 0xC0, 0x82, 0xB1, 0xA7, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0xF4, 0x5F, 
+0xD0, 0x82, 0xD0, 0x83, 0xF0, 0x90, 0xA1, 0x7E, 0xE0, 0x54, 0x7F, 0xF0, 0x80, 0x40, 0x90, 0xA1, 
+0x7B, 0xE0, 0x24, 0x81, 0xB1, 0x5D, 0xC0, 0x83, 0xC0, 0x82, 0xB1, 0xA7, 0x80, 0x02, 0xC3, 0x33, 
+0xD8, 0xFC, 0x4F, 0xD0, 0x82, 0xD0, 0x83, 0xF0, 0x75, 0xF0, 0x10, 0xE5, 0x69, 0x12, 0x56, 0xB6, 
+0xE0, 0x54, 0x07, 0xFF, 0x90, 0xA1, 0x7E, 0xF0, 0x90, 0xA1, 0x7C, 0xE0, 0x90, 0x43, 0xAB, 0x93, 
+0xFE, 0x33, 0x33, 0x33, 0x54, 0xF8, 0x4F, 0x90, 0xA1, 0x7E, 0xF0, 0x44, 0x80, 0xF0, 0x75, 0xF0, 
+0x10, 0xE5, 0x69, 0x12, 0x57, 0x73, 0xE5, 0x6A, 0xF0, 0xE5, 0x69, 0x70, 0x06, 0x90, 0x01, 0xC8, 
+0xE5, 0x6A, 0xF0, 0x90, 0xA1, 0x7E, 0xE0, 0xFF, 0x75, 0xF0, 0x10, 0xE5, 0x69, 0x12, 0x56, 0xB6, 
+0xEF, 0xF0, 0xB1, 0x90, 0xE0, 0x54, 0xFC, 0xFF, 0xE5, 0x6C, 0x54, 0x03, 0x4F, 0xFF, 0xB1, 0x90, 
+0xEF, 0xF0, 0x7D, 0x01, 0xAF, 0x69, 0xB1, 0xB4, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xF5, 0x82, 0xE4, 
+0x34, 0x94, 0xF5, 0x83, 0x22, 0xE0, 0xFD, 0x75, 0xF0, 0x04, 0xE5, 0x65, 0x22, 0x74, 0x01, 0x7E, 
+0x00, 0xA8, 0x6D, 0x08, 0x22, 0xE5, 0x6E, 0x75, 0xF0, 0x08, 0xA4, 0x25, 0x6D, 0x22, 0xFF, 0x90, 
+0xA1, 0xC6, 0xE0, 0xFB, 0xEF, 0x5B, 0x22, 0xE5, 0x6A, 0x54, 0x7F, 0x90, 0xA1, 0x7C, 0xF0, 0x22, 
+0x75, 0xF0, 0x10, 0xE5, 0x69, 0x90, 0x81, 0x05, 0x02, 0x49, 0x22, 0x90, 0xA1, 0xC4, 0xE0, 0x24, 
+0x11, 0xF5, 0x82, 0xE4, 0x34, 0x9E, 0x22, 0xE0, 0xFF, 0x90, 0xA1, 0x7D, 0xE0, 0xFE, 0x74, 0x01, 
+0xA8, 0x06, 0x08, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0xED, 0x60, 0x22, 0x75, 0xF0, 
+0x0A, 0xEF, 0x90, 0x8D, 0x01, 0xB1, 0xF1, 0x90, 0x8D, 0x03, 0xB1, 0xF1, 0x90, 0x8D, 0x05, 0xB1, 
+0xF1, 0x90, 0x8D, 0x07, 0xB1, 0xF1, 0x90, 0x8D, 0x09, 0xF1, 0x8E, 0x12, 0xA8, 0x0E, 0xE4, 0xF0, 
+0xB1, 0xFD, 0xE0, 0x54, 0xBF, 0x44, 0x80, 0xFE, 0xB1, 0xFD, 0xEE, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 
+0x22, 0x12, 0x49, 0x22, 0xE4, 0xF0, 0xA3, 0xF0, 0x75, 0xF0, 0x0A, 0xEF, 0x22, 0x75, 0xF0, 0x10, 
+0xEF, 0x90, 0x81, 0x03, 0x02, 0x49, 0x22, 0x90, 0xA1, 0x13, 0xEF, 0xF0, 0x7E, 0x00, 0x7F, 0x10, 
+0x7D, 0x00, 0x7B, 0x01, 0x7A, 0xA1, 0x79, 0x15, 0x12, 0x08, 0xAA, 0x90, 0x9F, 0x9C, 0xE0, 0x90, 
+0xA1, 0x27, 0xF0, 0xE4, 0x90, 0xA1, 0x14, 0xF0, 0x90, 0xA1, 0x27, 0xE0, 0xFE, 0x90, 0xA1, 0x14, 
+0xE0, 0xFD, 0xC3, 0x9E, 0x50, 0x41, 0xED, 0xF1, 0xB6, 0xED, 0x54, 0x07, 0xA3, 0xF0, 0x75, 0xF0, 
+0x10, 0xED, 0xD1, 0x01, 0xE0, 0x30, 0xE7, 0x09, 0x74, 0x81, 0x2D, 0xF1, 0x9C, 0xE4, 0xF0, 0x80, 
+0x1E, 0xAF, 0x05, 0xF1, 0x95, 0x12, 0xA8, 0xAA, 0xC0, 0x83, 0xC0, 0x82, 0xE0, 0xFF, 0x90, 0xA1, 
+0x26, 0xB1, 0xAC, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0x4F, 0xD0, 0x82, 0xD0, 0x83, 0xF0, 0x90, 
+0xA1, 0x14, 0xE0, 0x04, 0xF0, 0x80, 0xB1, 0x7F, 0x0C, 0x7E, 0x00, 0x12, 0x3D, 0x7A, 0xE4, 0x90, 
+0xA1, 0x14, 0xF0, 0x90, 0xA1, 0x27, 0xE0, 0xFF, 0x90, 0xA1, 0x14, 0xE0, 0xFE, 0xC3, 0x9F, 0x40, 
+0x02, 0xE1, 0x37, 0xEE, 0xF1, 0xB6, 0xEE, 0x54, 0x07, 0xA3, 0xF0, 0xE0, 0xF1, 0xCE, 0x80, 0x05, 
+0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 0xF9, 0x4E, 0x7F, 0x00, 0x70, 0x02, 0x7F, 0x01, 0x12, 0xA8, 
+0xAA, 0xE0, 0x5F, 0x70, 0x7A, 0xF1, 0xA4, 0x90, 0x81, 0x06, 0xF1, 0xAD, 0xEF, 0x90, 0x81, 0x07, 
+0xF1, 0xD7, 0xFC, 0x12, 0xA8, 0x59, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x75, 0xF0, 0x10, 0xEC, 0x90, 
+0x81, 0x0A, 0xF1, 0xAD, 0xEC, 0x90, 0x81, 0x0B, 0xF1, 0xD7, 0x75, 0xF0, 0x0A, 0xF1, 0x88, 0xEE, 
+0xF0, 0xA3, 0xEF, 0xF0, 0x7F, 0x01, 0x90, 0xA1, 0x14, 0xE0, 0xFE, 0x75, 0xF0, 0x10, 0x90, 0x81, 
+0x0B, 0x12, 0x4F, 0xB3, 0xE0, 0xFD, 0x75, 0xF0, 0x0A, 0xEE, 0xF1, 0x88, 0x75, 0xF0, 0x02, 0xEF, 
+0xF1, 0x8E, 0xED, 0xF0, 0x0F, 0xEF, 0xB4, 0x05, 0xDD, 0xF1, 0xA4, 0x90, 0x81, 0x09, 0x12, 0x49, 
+0x22, 0xE0, 0xFE, 0x12, 0xA8, 0x1F, 0xEE, 0xF0, 0x90, 0xA1, 0x14, 0xE0, 0xFF, 0x90, 0xA1, 0x13, 
+0xE0, 0xFD, 0xB1, 0xB4, 0x90, 0xA1, 0x14, 0xE0, 0x24, 0x81, 0xF1, 0x9C, 0x74, 0x01, 0xF0, 0x90, 
+0xA1, 0x14, 0xE0, 0x04, 0xF0, 0xC1, 0x83, 0x22, 0x75, 0xF0, 0x04, 0xEF, 0x12, 0x4E, 0x2B, 0xF9, 
+0xF1, 0x7A, 0xE0, 0xFC, 0xF1, 0xC0, 0xE0, 0x54, 0x7F, 0xFD, 0x74, 0x91, 0x2F, 0x12, 0xA5, 0x19, 
+0xE0, 0xFE, 0x12, 0xA5, 0x0A, 0xFB, 0x75, 0xF0, 0x04, 0xEF, 0x90, 0x96, 0x14, 0x12, 0x49, 0x22, 
+0xE9, 0x54, 0xF3, 0x4B, 0xF0, 0xED, 0xD3, 0x9C, 0x40, 0x02, 0xAD, 0x04, 0xF1, 0xC0, 0xE0, 0x54, 
+0x80, 0x42, 0x05, 0x8E, 0x6C, 0xE4, 0xFB, 0x81, 0x1B, 0xF0, 0x75, 0xF0, 0x04, 0xEF, 0x90, 0x96, 
+0x11, 0x02, 0x49, 0x22, 0xE4, 0xFF, 0xC1, 0x07, 0x90, 0x8D, 0x01, 0x02, 0x49, 0x22, 0x12, 0x49, 
+0x22, 0xE4, 0xF0, 0xA3, 0x22, 0xB1, 0xFD, 0xE0, 0x44, 0x40, 0xF0, 0x22, 0xF5, 0x82, 0xE4, 0x34, 
+0x93, 0xF5, 0x83, 0x22, 0x90, 0xA1, 0x14, 0xE0, 0xFF, 0x75, 0xF0, 0x10, 0x22, 0x12, 0x49, 0x22, 
+0xE0, 0xFD, 0x75, 0xF0, 0x10, 0x22, 0x13, 0x13, 0x13, 0x54, 0x1F, 0x90, 0xA1, 0x25, 0xF0, 0x22, 
+0x74, 0x91, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x9D, 0xF5, 0x83, 0x22, 0xED, 0x54, 0x07, 0xFF, 0x74, 
+0x01, 0x7E, 0x00, 0xA8, 0x07, 0x08, 0x22, 0x12, 0x49, 0x22, 0xE0, 0xFE, 0xED, 0xFF, 0x90, 0xA1, 
+0x14, 0xE0, 0x22, 0x90, 0x07, 0x1F, 0xE0, 0x54, 0x7F, 0xF0, 0x90, 0x07, 0x1C, 0xE0, 0x54, 0x01, 
+0xFF, 0x90, 0xA0, 0xE6, 0xF0, 0x90, 0xA0, 0xE4, 0x74, 0x02, 0xF0, 0x90, 0xA0, 0xF2, 0x14, 0xF0, 
+0xFB, 0x7A, 0xA0, 0x79, 0xE4, 0x12, 0x63, 0x89, 0x7F, 0x04, 0x02, 0x65, 0x78, 0xC0, 0xE0, 0xC0, 
+0xF0, 0xC0, 0x83, 0xC0, 0x82, 0xC0, 0xD0, 0x75, 0xD0, 0x00, 0xC0, 0x00, 0xC0, 0x01, 0xC0, 0x02, 
+0xC0, 0x03, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0x12, 0x98, 0x54, 0xE5, 0x21, 0x30, 
+0xE1, 0x02, 0x11, 0xAE, 0xE5, 0x21, 0x30, 0xE2, 0x03, 0x12, 0x9E, 0xF9, 0xE5, 0x22, 0x30, 0xE0, 
+0x03, 0x12, 0x9C, 0xD2, 0xE5, 0x23, 0x30, 0xE1, 0x03, 0x12, 0x9D, 0x6A, 0xE5, 0x23, 0x30, 0xE0, 
+0x03, 0x12, 0x9E, 0x91, 0xE5, 0x23, 0x30, 0xE2, 0x0A, 0x12, 0x82, 0xD3, 0x90, 0x07, 0x8F, 0xE0, 
+0x44, 0x10, 0xF0, 0xE5, 0x23, 0x30, 0xE3, 0x02, 0xF1, 0xE4, 0xE5, 0x24, 0x30, 0xE1, 0x05, 0x7F, 
+0x04, 0x12, 0x61, 0x4B, 0xE5, 0x24, 0x30, 0xE4, 0x02, 0x11, 0xB8, 0xE5, 0x24, 0x30, 0xE5, 0x03, 
+0x12, 0x5E, 0x96, 0xE5, 0x24, 0x30, 0xE6, 0x03, 0x12, 0x9F, 0x10, 0xE5, 0x24, 0x30, 0xE7, 0x03, 
+0x12, 0x82, 0x7F, 0xD0, 0x07, 0xD0, 0x06, 0xD0, 0x05, 0xD0, 0x04, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 
+0x01, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x82, 0xD0, 0x83, 0xD0, 0xF0, 0xD0, 0xE0, 0x32, 0x90, 0x9F, 
+0xA7, 0xE0, 0x60, 0x03, 0x12, 0x97, 0x5B, 0x22, 0x12, 0x57, 0x01, 0x12, 0x5F, 0xA0, 0x11, 0xF0, 
+0x90, 0xA0, 0x52, 0xE0, 0x30, 0xE0, 0x28, 0x12, 0x80, 0x20, 0x90, 0xA0, 0x55, 0xE0, 0x60, 0x05, 
+0x14, 0xF0, 0x02, 0x80, 0x29, 0x90, 0xA0, 0x53, 0xE0, 0x14, 0x90, 0xA0, 0x55, 0xF0, 0x90, 0x05, 
+0x73, 0x74, 0x01, 0xF0, 0xE4, 0xFF, 0x12, 0x7F, 0xBE, 0x12, 0x5F, 0xA0, 0x12, 0x80, 0x19, 0x22, 
+0x90, 0xA0, 0x5F, 0xE0, 0x30, 0xE0, 0x04, 0xE4, 0xFF, 0x11, 0xFC, 0x22, 0xD3, 0x10, 0xAF, 0x01, 
+0xC3, 0xC0, 0xD0, 0x90, 0xA1, 0xAC, 0xEF, 0xF0, 0xA3, 0x74, 0x02, 0xF0, 0xE4, 0xFF, 0x91, 0xFB, 
+0x30, 0xE0, 0x03, 0x12, 0x4C, 0x71, 0x90, 0xA0, 0x63, 0xE0, 0x30, 0xE0, 0x04, 0x7F, 0x01, 0x80, 
+0x36, 0x90, 0xA0, 0x5F, 0x91, 0x80, 0x30, 0xE0, 0x04, 0x7F, 0x0D, 0x80, 0x2A, 0x90, 0xA0, 0x62, 
+0xE0, 0xFF, 0xC4, 0x54, 0x0F, 0x30, 0xE0, 0x10, 0xEF, 0x13, 0x13, 0x54, 0x3F, 0x30, 0xE0, 0x04, 
+0x7F, 0x09, 0x80, 0x13, 0x7F, 0x03, 0x80, 0x0F, 0x90, 0xA0, 0x62, 0xE0, 0xC3, 0x13, 0x30, 0xE0, 
+0x04, 0x7F, 0x03, 0x80, 0x02, 0x7F, 0x09, 0xD1, 0xC6, 0x90, 0xA1, 0xAC, 0xE0, 0x64, 0x03, 0x70, 
+0x69, 0x91, 0x7D, 0x30, 0xE0, 0x5F, 0x90, 0xA0, 0x69, 0xE0, 0xFF, 0x90, 0xA0, 0x74, 0xE0, 0xFE, 
+0xD3, 0x9F, 0x40, 0x37, 0xEE, 0x75, 0xF0, 0x03, 0xA4, 0xFF, 0x90, 0xA0, 0x6B, 0xE0, 0xFE, 0xC3, 
+0xEF, 0x9E, 0xFF, 0x24, 0x03, 0xFD, 0xE4, 0x33, 0xFC, 0x90, 0xA0, 0x61, 0xE0, 0xFE, 0xD3, 0x9D, 
+0xEC, 0x12, 0xA8, 0xDE, 0x40, 0x08, 0xEE, 0x9F, 0x90, 0xA1, 0xAF, 0xF0, 0x80, 0x06, 0x90, 0xA1, 
+0xAF, 0x74, 0x03, 0xF0, 0x90, 0xA1, 0xAF, 0x51, 0xC9, 0x80, 0x13, 0x90, 0xA0, 0x6C, 0xE0, 0xFF, 
+0x51, 0xB7, 0x90, 0xA0, 0x67, 0x74, 0x04, 0xF0, 0xE4, 0x90, 0xA0, 0x72, 0x91, 0x67, 0xE4, 0x90, 
+0xA0, 0x74, 0xF0, 0x80, 0x05, 0x90, 0xA0, 0x61, 0x51, 0xC9, 0x90, 0xA0, 0x5F, 0xD1, 0xBE, 0x30, 
+0xE0, 0x07, 0xE4, 0x90, 0xA1, 0xAE, 0xF0, 0x80, 0x06, 0x90, 0xA1, 0xAE, 0x74, 0x01, 0xF0, 0xF1, 
+0xD2, 0x20, 0xE0, 0x13, 0x90, 0xA0, 0xA0, 0xE0, 0x60, 0x07, 0xE4, 0x90, 0xA1, 0xAD, 0xF0, 0x80, 
+0x06, 0x90, 0xA1, 0xAD, 0x74, 0x01, 0xF0, 0x90, 0xA1, 0xAD, 0x12, 0x4D, 0x33, 0x90, 0xA0, 0x71, 
+0x74, 0x01, 0xF0, 0xF1, 0xC0, 0x30, 0xE0, 0x0D, 0x90, 0xA1, 0xAC, 0xE0, 0x70, 0x3A, 0xFD, 0xFF, 
+0x12, 0x57, 0x8F, 0x80, 0x33, 0xF1, 0xA8, 0x30, 0xE0, 0x1A, 0x90, 0xA0, 0x65, 0xE0, 0x44, 0x20, 
+0xF0, 0x90, 0xA0, 0x51, 0xE0, 0x60, 0x04, 0x7D, 0x01, 0x80, 0x18, 0x12, 0x5E, 0x36, 0x7D, 0x01, 
+0x7F, 0x0C, 0x80, 0x11, 0x90, 0xA1, 0xAC, 0xE0, 0xB4, 0x03, 0x0D, 0x90, 0x9F, 0xA7, 0xE0, 0x60, 
+0x07, 0xE4, 0xFD, 0x7F, 0x04, 0x12, 0x58, 0x65, 0x90, 0xA0, 0x51, 0xE0, 0x60, 0x18, 0x90, 0xA1, 
+0xAC, 0xE0, 0x70, 0x04, 0x7D, 0x04, 0x80, 0x0A, 0x90, 0xA1, 0xAC, 0xE0, 0x64, 0x03, 0x70, 0x2E, 
+0x7D, 0x0B, 0x7F, 0x6F, 0x80, 0x25, 0x90, 0xA1, 0xAC, 0xE0, 0x70, 0x04, 0xFD, 0xFF, 0x80, 0x1B, 
+0x90, 0xA1, 0xAC, 0xE0, 0xB4, 0x03, 0x17, 0x12, 0x83, 0x3C, 0x20, 0xE0, 0x0B, 0xEF, 0x13, 0x13, 
+0x54, 0x3F, 0x30, 0xE0, 0x03, 0x12, 0x87, 0x74, 0xE4, 0xFD, 0xFF, 0x12, 0x57, 0x8F, 0xD1, 0xBB, 
+0x30, 0xE0, 0x04, 0x7F, 0x01, 0xF1, 0xE5, 0x90, 0xA0, 0x63, 0xE0, 0xC3, 0x13, 0x30, 0xE0, 0x0E, 
+0x90, 0x06, 0xCD, 0xE0, 0x44, 0x10, 0xF0, 0x90, 0x06, 0xCF, 0xE0, 0x44, 0x10, 0xF0, 0xD0, 0xD0, 
+0x92, 0xAF, 0x22, 0xE0, 0xC3, 0x9F, 0xFF, 0xE4, 0x90, 0xA1, 0x8E, 0xF0, 0xA3, 0xEF, 0xF0, 0xE4, 
+0xFB, 0xFD, 0x7F, 0x6C, 0x7E, 0x01, 0x02, 0x50, 0x1B, 0xE0, 0xFF, 0x51, 0xB7, 0x90, 0xA0, 0x72, 
+0xE0, 0x04, 0xF0, 0x22, 0x91, 0x7D, 0x20, 0xE0, 0x02, 0x81, 0x61, 0x90, 0xA0, 0x67, 0xE0, 0x64, 
+0x01, 0x70, 0x2A, 0x90, 0x06, 0x92, 0xE0, 0x20, 0xE2, 0x06, 0x90, 0x04, 0xE3, 0xE0, 0x60, 0x18, 
+0x91, 0x68, 0x91, 0x76, 0x90, 0xA0, 0x6B, 0xE0, 0x75, 0xF0, 0x03, 0x84, 0xFF, 0x90, 0xA0, 0x74, 
+0xE0, 0xB5, 0x07, 0x02, 0x80, 0x02, 0x81, 0x4C, 0xF1, 0xDB, 0x04, 0xF0, 0x22, 0x90, 0xA0, 0x67, 
+0xE0, 0x64, 0x04, 0x70, 0x27, 0x90, 0x06, 0x92, 0xE0, 0x20, 0xE2, 0x06, 0x90, 0x04, 0xE3, 0xE0, 
+0x60, 0x14, 0x91, 0x68, 0x91, 0x76, 0x90, 0xA0, 0x6A, 0xE0, 0xFF, 0x90, 0xA0, 0x74, 0xE0, 0xB5, 
+0x07, 0x02, 0x80, 0x02, 0x81, 0x4C, 0xF1, 0xDB, 0x74, 0x04, 0xF0, 0x22, 0x90, 0xA0, 0x67, 0xE0, 
+0x64, 0x06, 0x60, 0x02, 0x61, 0xDA, 0xB1, 0x07, 0x50, 0x08, 0x90, 0xA0, 0x75, 0xE0, 0x94, 0x03, 
+0x40, 0x1A, 0xF1, 0xA0, 0x90, 0xA0, 0x72, 0x30, 0xE0, 0x05, 0x74, 0x05, 0xF0, 0x80, 0x03, 0x74, 
+0x02, 0xF0, 0xE4, 0x90, 0xA0, 0x67, 0xF0, 0x90, 0xA0, 0x75, 0xF0, 0x22, 0x90, 0xA0, 0x66, 0xB1, 
+0x00, 0x30, 0xE0, 0x35, 0xF1, 0xB8, 0xF1, 0xA0, 0x30, 0xE0, 0x0B, 0x90, 0xA0, 0x84, 0xE0, 0x20, 
+0xE0, 0x02, 0x81, 0x05, 0x80, 0x78, 0xB1, 0x07, 0x40, 0x0B, 0x90, 0xA0, 0x84, 0xE0, 0x30, 0xE0, 
+0x02, 0x80, 0x6B, 0x80, 0x70, 0x90, 0xA0, 0x84, 0xE0, 0x30, 0xE0, 0x06, 0x91, 0x62, 0xF1, 0xC9, 
+0x80, 0x6C, 0x90, 0xA0, 0x72, 0x74, 0x02, 0xF0, 0x22, 0x91, 0x87, 0x90, 0xA0, 0x75, 0xE0, 0x04, 
+0xF0, 0x7F, 0x03, 0x51, 0xB7, 0xB1, 0x07, 0x50, 0x0A, 0x90, 0xA0, 0x75, 0xE0, 0x94, 0x03, 0x50, 
+0x02, 0x81, 0x61, 0x7F, 0x03, 0xD1, 0xC6, 0x90, 0x05, 0x22, 0xE0, 0x44, 0x10, 0xFF, 0x7D, 0x03, 
+0x12, 0x57, 0x8F, 0x90, 0x04, 0x9C, 0xE0, 0x04, 0xF0, 0x22, 0x90, 0xA0, 0x67, 0xE0, 0x64, 0x07, 
+0x70, 0x2F, 0x90, 0xA0, 0x75, 0xE0, 0xB4, 0x04, 0x04, 0x91, 0x6F, 0x80, 0x59, 0x90, 0xA0, 0x66, 
+0xB1, 0x00, 0x30, 0xE0, 0x12, 0xF1, 0xB8, 0x90, 0xA0, 0x84, 0xE0, 0x30, 0xE0, 0x07, 0x91, 0x62, 
+0xF1, 0xC9, 0x04, 0x80, 0x09, 0x80, 0x68, 0x91, 0x87, 0x90, 0xA0, 0x75, 0xE0, 0x04, 0xF0, 0x80, 
+0x3B, 0x90, 0xA0, 0x67, 0xE0, 0x64, 0x09, 0x70, 0x48, 0x90, 0xA0, 0x66, 0xE0, 0x30, 0xE0, 0x0A, 
+0x91, 0x6F, 0x90, 0xA0, 0x66, 0xE0, 0x54, 0xFE, 0xF0, 0x22, 0x90, 0x06, 0x92, 0xE0, 0x30, 0xE2, 
+0x1F, 0x74, 0x04, 0xF0, 0x91, 0x76, 0xE0, 0xB4, 0x02, 0x12, 0xF1, 0xB0, 0x60, 0x05, 0x74, 0x05, 
+0xF0, 0x80, 0x03, 0x74, 0x02, 0xF0, 0xE4, 0x90, 0xA0, 0x67, 0xF0, 0x22, 0x7F, 0x03, 0x41, 0xB7, 
+0xF1, 0xB0, 0x60, 0x05, 0x74, 0x05, 0xF0, 0x80, 0x03, 0x74, 0x02, 0xF0, 0xE4, 0x90, 0xA0, 0x67, 
+0xF0, 0x22, 0x90, 0xA0, 0x67, 0x74, 0x09, 0xF0, 0x90, 0x06, 0x92, 0x74, 0x04, 0xF0, 0x22, 0x90, 
+0xA0, 0x72, 0x74, 0x05, 0xF0, 0x22, 0x90, 0xA0, 0x74, 0xE0, 0x04, 0xF0, 0x22, 0x90, 0xA0, 0x63, 
+0xE0, 0xC4, 0x13, 0x13, 0x54, 0x03, 0x22, 0x90, 0xA0, 0x66, 0xE0, 0x44, 0x02, 0xF0, 0x7D, 0x08, 
+0x7F, 0x01, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0xA1, 0xA7, 0xEF, 0xF0, 0xA3, 0xED, 
+0xF0, 0x90, 0x9E, 0x94, 0xE0, 0x04, 0xF0, 0x90, 0x04, 0x1D, 0xE0, 0x60, 0x2A, 0x90, 0x05, 0x22, 
+0xE0, 0x90, 0xA1, 0xAB, 0xF0, 0x7D, 0x26, 0xF1, 0x3D, 0xEF, 0x64, 0x01, 0x70, 0x02, 0x80, 0x05, 
+0x91, 0x7D, 0x30, 0xE0, 0x03, 0x12, 0x86, 0x66, 0x90, 0xA1, 0xAB, 0xE0, 0xFF, 0x7D, 0x27, 0x12, 
+0x57, 0x8F, 0x12, 0xA7, 0xA2, 0x80, 0x06, 0x12, 0xA7, 0xA2, 0x12, 0x86, 0x66, 0x90, 0xA0, 0x5F, 
+0xE0, 0x30, 0xE0, 0x0D, 0x91, 0x7D, 0x30, 0xE0, 0x08, 0x12, 0x87, 0xC4, 0x7D, 0x28, 0x12, 0x57, 
+0x8F, 0x12, 0x85, 0x4B, 0x7F, 0x01, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xB1, 0x2F, 0x90, 0xA0, 0x63, 
+0xE0, 0xFF, 0x13, 0x13, 0x54, 0x3F, 0x22, 0x90, 0xA0, 0x75, 0xE0, 0xFF, 0x90, 0xA0, 0x74, 0xE0, 
+0x2F, 0xFF, 0xE4, 0x33, 0xFE, 0x7C, 0x00, 0x7D, 0x03, 0x12, 0x07, 0x03, 0x90, 0xA0, 0x6B, 0xE0, 
+0x2F, 0xFF, 0xEC, 0x3E, 0xFE, 0xC3, 0xEF, 0x94, 0x41, 0xEE, 0x64, 0x80, 0x94, 0x80, 0x22, 0xD3, 
+0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0xEF, 0xB4, 0x03, 0x0F, 0x90, 0xA0, 0x62, 0x91, 0x80, 0x90, 
+0x06, 0xCC, 0x30, 0xE0, 0x35, 0xE4, 0xF0, 0x80, 0x34, 0x90, 0xA0, 0x63, 0xE0, 0xC4, 0x54, 0x0F, 
+0x30, 0xE0, 0x0C, 0xEF, 0x90, 0x06, 0xCC, 0x70, 0x03, 0xF0, 0x80, 0x03, 0x74, 0x03, 0xF0, 0x90, 
+0xA0, 0xAD, 0xE0, 0x30, 0xE0, 0x17, 0xC4, 0x54, 0x0F, 0x30, 0xE0, 0x0B, 0xEF, 0x90, 0x06, 0xCC, 
+0x70, 0x03, 0xF0, 0x80, 0x08, 0x80, 0x03, 0x90, 0x06, 0xCC, 0x74, 0x03, 0xF0, 0xD0, 0xD0, 0x92, 
+0xAF, 0x22, 0x90, 0xA0, 0xF4, 0xEF, 0xF0, 0x90, 0xA0, 0xF6, 0x74, 0x02, 0xF0, 0x7F, 0x01, 0x91, 
+0xFB, 0x30, 0xE0, 0x21, 0x90, 0xA0, 0xF4, 0xE0, 0xB4, 0x02, 0x04, 0x7D, 0x07, 0x80, 0x09, 0x90, 
+0xA0, 0xF4, 0xE0, 0xB4, 0x05, 0x07, 0x7D, 0x0D, 0x7F, 0xFF, 0x12, 0x57, 0x8F, 0xF1, 0x42, 0xBF, 
+0x01, 0x03, 0x12, 0x4A, 0xDA, 0x90, 0xA0, 0x63, 0xD1, 0xBE, 0x30, 0xE0, 0x04, 0x7F, 0x03, 0x80, 
+0x02, 0x7F, 0x01, 0xD1, 0xC6, 0x90, 0xA0, 0xF4, 0xE0, 0xB4, 0x02, 0x0C, 0x90, 0xA0, 0x60, 0xE0, 
+0x24, 0x03, 0xFF, 0x90, 0xA0, 0x6F, 0x51, 0xB3, 0x90, 0xA0, 0x5F, 0xE0, 0xC3, 0x13, 0x30, 0xE0, 
+0x07, 0xE4, 0x90, 0xA0, 0xF5, 0xF0, 0x80, 0x06, 0x90, 0xA0, 0xF5, 0x74, 0x01, 0xF0, 0xF1, 0xD2, 
+0x20, 0xE0, 0x13, 0x90, 0xA0, 0xA0, 0xE0, 0x60, 0x08, 0x90, 0xA0, 0xF6, 0x74, 0x01, 0xF0, 0x80, 
+0x05, 0xE4, 0x90, 0xA0, 0xF6, 0xF0, 0x90, 0xA0, 0xF6, 0xE0, 0xFF, 0x90, 0xA0, 0xF5, 0xE0, 0xFD, 
+0x12, 0x4D, 0x38, 0xE4, 0x90, 0xA0, 0x71, 0xF0, 0x90, 0xA0, 0xF4, 0xE0, 0xFF, 0xB4, 0x02, 0x04, 
+0x51, 0xCD, 0x80, 0x09, 0xEF, 0xB4, 0x05, 0x05, 0xE4, 0x90, 0xA0, 0x72, 0xF0, 0xF1, 0xC0, 0x30, 
+0xE0, 0x17, 0x90, 0xA0, 0xF4, 0xE0, 0xB4, 0x02, 0x04, 0x7D, 0x08, 0x80, 0x4E, 0x90, 0xA0, 0xF4, 
+0xE0, 0x64, 0x05, 0x70, 0x4B, 0x7D, 0x0E, 0x80, 0x42, 0xF1, 0xA8, 0x30, 0xE0, 0x20, 0x12, 0x87, 
+0xA2, 0x20, 0xE0, 0x03, 0x12, 0xA9, 0x1E, 0x90, 0xA0, 0xF4, 0xE0, 0xB4, 0x02, 0x04, 0x7D, 0x09, 
+0x80, 0x29, 0x90, 0xA0, 0xF4, 0xE0, 0x64, 0x05, 0x70, 0x26, 0x7D, 0x0F, 0x80, 0x1D, 0x90, 0x9F, 
+0xA7, 0xE0, 0x60, 0x1C, 0x12, 0xA9, 0x1E, 0x90, 0xA0, 0xF4, 0xE0, 0xB4, 0x02, 0x04, 0x7D, 0x0A, 
+0x80, 0x09, 0x90, 0xA0, 0xF4, 0xE0, 0xB4, 0x05, 0x07, 0x7D, 0x10, 0x7F, 0x6F, 0x12, 0x57, 0x8F, 
+0x90, 0xA0, 0x62, 0xE0, 0x30, 0xE0, 0x03, 0x12, 0x5E, 0x36, 0xD1, 0xBB, 0x30, 0xE0, 0x04, 0xE4, 
+0xFF, 0xF1, 0xE5, 0x90, 0xA0, 0x63, 0xE0, 0xC3, 0x13, 0x30, 0xE0, 0x0E, 0x90, 0x06, 0xCD, 0xE0, 
+0x54, 0xEF, 0xF0, 0x90, 0x06, 0xCF, 0xE0, 0x54, 0xEF, 0xF0, 0x22, 0x90, 0xA0, 0x62, 0xE0, 0xC4, 
+0x13, 0x13, 0x13, 0x54, 0x01, 0x22, 0x90, 0xA0, 0x84, 0x12, 0x80, 0xDA, 0x30, 0xE0, 0x07, 0x90, 
+0x07, 0x78, 0x74, 0x09, 0xF0, 0x22, 0x90, 0xA0, 0xBF, 0xE0, 0x30, 0xE0, 0x1D, 0xEF, 0x24, 0xFD, 
+0x60, 0x0E, 0x24, 0xFA, 0x60, 0x0E, 0x24, 0xFC, 0x60, 0x0E, 0x24, 0x0C, 0x7F, 0x02, 0x80, 0x0A, 
+0x7F, 0x03, 0x80, 0x06, 0x7F, 0x0B, 0x80, 0x02, 0x7F, 0x0E, 0x90, 0x07, 0x78, 0xEF, 0xF0, 0x22, 
+0x90, 0xA0, 0x5F, 0xE0, 0x30, 0xE0, 0x35, 0x51, 0xD4, 0x90, 0xA0, 0x72, 0xE0, 0xFF, 0xB4, 0x01, 
+0x02, 0x80, 0x1C, 0x90, 0xA0, 0x72, 0xE0, 0xFF, 0xB4, 0x02, 0x02, 0x80, 0x1D, 0x90, 0xA0, 0x72, 
+0xE0, 0xFF, 0xB4, 0x03, 0x02, 0x01, 0xFC, 0x90, 0xA0, 0x72, 0xE0, 0xFF, 0xB4, 0x04, 0x03, 0x02, 
+0x83, 0x46, 0x90, 0xA0, 0x72, 0xE0, 0xFF, 0xB4, 0x05, 0x02, 0xB1, 0x82, 0x22, 0x7F, 0xFF, 0x12, 
+0x57, 0x8F, 0xE4, 0x90, 0xA1, 0xE0, 0xF0, 0xA3, 0xF0, 0x90, 0x05, 0xF8, 0xE0, 0x70, 0x0F, 0xA3, 
+0xE0, 0x70, 0x0B, 0xA3, 0xE0, 0x70, 0x07, 0xA3, 0xE0, 0x70, 0x03, 0x7F, 0x01, 0x22, 0x91, 0x7D, 
+0x30, 0xE0, 0x15, 0xD3, 0x90, 0xA1, 0xE1, 0xE0, 0x94, 0x03, 0x90, 0xA1, 0xE0, 0xE0, 0x94, 0x00, 
+0x40, 0x02, 0x80, 0x13, 0x7F, 0x01, 0x80, 0x1B, 0xD3, 0x90, 0xA1, 0xE1, 0xE0, 0x94, 0xE8, 0x90, 
+0xA1, 0xE0, 0xE0, 0x94, 0x03, 0x40, 0x0A, 0x90, 0x01, 0xC0, 0xE0, 0x44, 0x20, 0xF0, 0x7F, 0x00, 
+0x22, 0x7F, 0x32, 0x7E, 0x00, 0x12, 0x3D, 0x7A, 0x90, 0xA1, 0xE0, 0x12, 0x79, 0x84, 0x80, 0xA9, 
+0x90, 0xA0, 0x62, 0xE0, 0xC4, 0x54, 0x0F, 0x22, 0x90, 0xA0, 0x5F, 0xE0, 0xC4, 0x54, 0x0F, 0x22, 
+0x90, 0xA1, 0xCD, 0xE0, 0x90, 0xA0, 0x72, 0x22, 0xEF, 0x54, 0xFB, 0xF0, 0xE4, 0xA3, 0xF0, 0x22, 
+0x90, 0xA0, 0x5F, 0xE0, 0xC4, 0x13, 0x54, 0x07, 0x22, 0xE4, 0x90, 0xA0, 0x74, 0xF0, 0x90, 0xA1, 
+0xCD, 0x22, 0x90, 0xA0, 0x62, 0xE0, 0xC4, 0x13, 0x54, 0x07, 0x22, 0xE4, 0x90, 0xA0, 0x67, 0xF0, 
+0x90, 0xA0, 0x72, 0x22, 0x22, 0x90, 0xA0, 0x91, 0xE0, 0xFE, 0xC3, 0x13, 0x30, 0xE0, 0x16, 0xEF, 
+0xB4, 0x01, 0x05, 0x90, 0xA0, 0x98, 0x80, 0x03, 0x90, 0xA0, 0x94, 0x12, 0x4D, 0x2B, 0x7F, 0x58, 
+0x7E, 0x0C, 0x12, 0x38, 0x07, 0x22, 0xC0, 0xE0, 0xC0, 0xF0, 0xC0, 0x83, 0xC0, 0x82, 0xC0, 0xD0, 
+0x75, 0xD0, 0x00, 0xC0, 0x00, 0xC0, 0x01, 0xC0, 0x02, 0xC0, 0x03, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 
+0x06, 0xC0, 0x07, 0x12, 0x61, 0x5A, 0x53, 0x91, 0xBF, 0xD0, 0x07, 0xD0, 0x06, 0xD0, 0x05, 0xD0, 
+0x04, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x82, 0xD0, 0x83, 0xD0, 
+0xF0, 0xD0, 0xE0, 0x32, 0x32, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0xA1, 0x83, 0xEF, 
+0xF0, 0xA3, 0xED, 0xF0, 0x7D, 0x00, 0x7C, 0x00, 0xE4, 0x90, 0xA1, 0x89, 0xF0, 0x7F, 0xB0, 0x7E, 
+0x08, 0x12, 0x37, 0xBC, 0xE4, 0xFF, 0xEC, 0x90, 0xA1, 0x85, 0x12, 0x08, 0x6D, 0x90, 0xA1, 0x85, 
+0x12, 0x49, 0x16, 0x90, 0xA1, 0x84, 0xE0, 0xFF, 0xE4, 0xFC, 0xFD, 0xFE, 0x12, 0x48, 0xFD, 0xA3, 
+0x12, 0x08, 0x6D, 0x90, 0xA1, 0x85, 0x12, 0x4D, 0x2B, 0x7F, 0xB0, 0x7E, 0x08, 0x12, 0x38, 0x07, 
+0x11, 0xB6, 0x90, 0xA1, 0x83, 0xE0, 0x75, 0xF0, 0x08, 0xA4, 0x24, 0xB5, 0xF5, 0x82, 0xE4, 0x34, 
+0xAD, 0xF5, 0x83, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x12, 0x37, 0xBC, 0xED, 0x54, 0x0F, 0xFD, 0xE4, 
+0xFC, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x7F, 0x14, 0x7E, 0x00, 0x02, 0x3D, 0x7A, 0x90, 0xA1, 0xDB, 
+0x31, 0xE5, 0x90, 0x01, 0x09, 0xE0, 0x7F, 0x00, 0x30, 0xE7, 0x02, 0x7F, 0x01, 0x90, 0xA1, 0xDB, 
+0xE0, 0x6F, 0x60, 0x34, 0xC3, 0x90, 0xA1, 0xDD, 0xE0, 0x94, 0x88, 0x90, 0xA1, 0xDC, 0xE0, 0x94, 
+0x13, 0x40, 0x08, 0x90, 0x01, 0xC0, 0xE0, 0x44, 0x10, 0xF0, 0x22, 0x90, 0xA1, 0xDC, 0x31, 0x84, 
+0x11, 0xB6, 0xD3, 0x90, 0xA1, 0xDD, 0xE0, 0x94, 0x32, 0x90, 0xA1, 0xDC, 0xE0, 0x94, 0x00, 0x40, 
+0xC1, 0x90, 0x01, 0xC6, 0xE0, 0x30, 0xE0, 0xBA, 0x22, 0x12, 0x9F, 0x6B, 0x7F, 0x08, 0x12, 0x4A, 
+0xB8, 0xEF, 0x54, 0xEF, 0xFD, 0x7F, 0x08, 0x12, 0x49, 0x90, 0xE4, 0xFF, 0x11, 0xBD, 0x90, 0x9F, 
+0xA3, 0xE0, 0xFF, 0xC4, 0x54, 0x0F, 0x30, 0xE0, 0x03, 0x12, 0xA7, 0x89, 0x90, 0x9F, 0xA4, 0xE0, 
+0x54, 0xEF, 0xF0, 0x22, 0xE4, 0x90, 0xA0, 0xC2, 0xF0, 0xA3, 0xF0, 0x31, 0x8B, 0xEF, 0x64, 0x01, 
+0x60, 0x3B, 0xC3, 0x90, 0xA0, 0xC3, 0xE0, 0x94, 0x88, 0x90, 0xA0, 0xC2, 0xE0, 0x94, 0x13, 0x40, 
+0x0F, 0x90, 0x01, 0xC1, 0xE0, 0x44, 0x10, 0xF0, 0x90, 0x01, 0xC7, 0x74, 0xFD, 0xF0, 0x80, 0x1D, 
+0x90, 0xA0, 0xC2, 0x31, 0x84, 0x11, 0xB6, 0xD3, 0x90, 0xA0, 0xC3, 0xE0, 0x94, 0x32, 0x90, 0xA0, 
+0xC2, 0xE0, 0x94, 0x00, 0x40, 0xC5, 0x90, 0x01, 0xC6, 0xE0, 0x30, 0xE3, 0xBE, 0x90, 0x01, 0xC7, 
+0x74, 0xFE, 0xF0, 0x22, 0xE4, 0x75, 0xF0, 0x01, 0x02, 0x08, 0xD6, 0x90, 0x01, 0x9A, 0xE0, 0x54, 
+0xC0, 0x44, 0x0B, 0xF1, 0x93, 0x90, 0x01, 0x98, 0xE0, 0x54, 0xC0, 0x7F, 0x00, 0xB4, 0x40, 0x02, 
+0x7F, 0x01, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0xA1, 0xB8, 0xEE, 0xF0, 0xA3, 
+0x31, 0xE5, 0x90, 0xA1, 0xB8, 0x12, 0xA9, 0x4E, 0xE0, 0x60, 0x23, 0xC3, 0x90, 0xA1, 0xBB, 0xE0, 
+0x94, 0xE8, 0x90, 0xA1, 0xBA, 0xE0, 0x94, 0x03, 0x40, 0x0B, 0x90, 0x01, 0xC0, 0xE0, 0x44, 0x80, 
+0xF0, 0x7F, 0x00, 0x80, 0x0B, 0x90, 0xA1, 0xBA, 0x31, 0x84, 0xF1, 0x94, 0x80, 0xD4, 0x7F, 0x01, 
+0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xEF, 0xF0, 0xE4, 0xA3, 0xF0, 0xA3, 0xF0, 0x22, 0xF1, 0x8B, 0x90, 
+0xA0, 0xAD, 0xE0, 0x54, 0xFE, 0x4E, 0xFE, 0xF0, 0xEF, 0x54, 0x06, 0xFF, 0xEE, 0x54, 0xF9, 0x4F, 
+0xFF, 0xF0, 0x12, 0x06, 0x89, 0xFE, 0x54, 0x08, 0xFD, 0xEF, 0x54, 0xF7, 0x4D, 0xFF, 0x90, 0xA0, 
+0xAD, 0xD1, 0x14, 0x12, 0xA9, 0x17, 0x4E, 0x90, 0xA0, 0xAD, 0x12, 0x66, 0xFB, 0xFF, 0x54, 0x03, 
+0xFE, 0x90, 0xA0, 0xAE, 0xE0, 0x54, 0xFC, 0x4E, 0xFE, 0xF0, 0xEF, 0x54, 0x04, 0xFF, 0xEE, 0x54, 
+0xFB, 0x4F, 0xFF, 0x12, 0x66, 0xFB, 0xFE, 0x54, 0x30, 0xFD, 0xEF, 0x54, 0xCF, 0x4D, 0xFF, 0x90, 
+0xA0, 0xAE, 0xD1, 0x0B, 0x4E, 0x12, 0x67, 0x35, 0x90, 0xA0, 0xAF, 0xF0, 0x51, 0xD3, 0x90, 0xA0, 
+0xB0, 0x12, 0x67, 0xD6, 0x90, 0xA0, 0xB1, 0xF0, 0x90, 0xA0, 0xAF, 0x51, 0xC0, 0xEF, 0x78, 0x05, 
+0xCE, 0xC3, 0x13, 0xCE, 0x13, 0xD8, 0xF9, 0xFF, 0x90, 0xA0, 0xB7, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 
+0x90, 0xA0, 0xB0, 0x51, 0xC0, 0xEF, 0x78, 0x05, 0xCE, 0xC3, 0x13, 0xCE, 0x13, 0xD8, 0xF9, 0xFF, 
+0x90, 0xA0, 0xB9, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0xA0, 0xB1, 0x51, 0xC0, 0x90, 0xA0, 0xBB, 
+0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0xA0, 0xAD, 0xE0, 0x30, 0xE0, 0x13, 0x90, 0xA0, 0xB2, 0x74, 
+0x01, 0xF0, 0xA3, 0xF0, 0xA3, 0x31, 0xE6, 0x90, 0x07, 0x83, 0xE0, 0x44, 0x20, 0xF0, 0x22, 0xE4, 
+0x90, 0xA0, 0xB2, 0x12, 0x4F, 0x8C, 0xA3, 0xF0, 0x90, 0x07, 0x83, 0xE0, 0x54, 0xDF, 0xF0, 0x22, 
+0xE0, 0xFF, 0x7E, 0x00, 0x7C, 0x01, 0x7D, 0x40, 0x02, 0x07, 0x03, 0xE0, 0xFF, 0x90, 0xA0, 0xCA, 
+0x12, 0x49, 0x2E, 0x90, 0x00, 0x03, 0x02, 0x06, 0xA2, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 
+0x12, 0x67, 0xE9, 0xF1, 0x8B, 0x90, 0xA0, 0x5F, 0xD1, 0x4B, 0xD1, 0x22, 0x90, 0xA0, 0x5F, 0xD1, 
+0x14, 0xD1, 0x41, 0x90, 0xA0, 0x5F, 0xD1, 0x0B, 0xD1, 0x1C, 0xD1, 0x39, 0x90, 0xA0, 0x5F, 0xF0, 
+0x51, 0xD3, 0xFF, 0x54, 0x01, 0xFE, 0x90, 0xA0, 0x62, 0xD1, 0x4B, 0xFF, 0xF0, 0x51, 0xD3, 0xD1, 
+0x27, 0x90, 0xA0, 0x62, 0xF0, 0xEE, 0x54, 0x10, 0xFE, 0xEF, 0x54, 0xEF, 0x4E, 0xFF, 0xF0, 0x51, 
+0xD3, 0xD1, 0x41, 0x90, 0xA0, 0x62, 0xD1, 0x0B, 0x4E, 0xFF, 0xF0, 0x51, 0xD3, 0xD1, 0x39, 0x90, 
+0xA0, 0x62, 0x12, 0x67, 0xD6, 0xFF, 0x54, 0x20, 0xFE, 0x90, 0xA0, 0x63, 0xE0, 0x54, 0xDF, 0x4E, 
+0xFE, 0xF0, 0xEF, 0x54, 0x40, 0xFF, 0xEE, 0x54, 0xBF, 0x4F, 0x12, 0x67, 0xD5, 0xFE, 0x54, 0x80, 
+0xFD, 0xEF, 0x54, 0x7F, 0x4D, 0xFF, 0x90, 0xA0, 0x63, 0xF0, 0xEE, 0x54, 0x01, 0xFE, 0xEF, 0x54, 
+0xFE, 0x12, 0x67, 0xD4, 0xD1, 0x27, 0x90, 0xA0, 0x63, 0xF0, 0xEE, 0x54, 0x02, 0xFE, 0xEF, 0x54, 
+0xFD, 0x12, 0x67, 0xD4, 0x12, 0xA8, 0x82, 0x90, 0xA0, 0x63, 0x12, 0xA8, 0xB8, 0x4E, 0xF0, 0x12, 
+0x75, 0x00, 0x20, 0xE0, 0x03, 0x12, 0x5E, 0x33, 0x12, 0x65, 0xBF, 0x12, 0x06, 0x89, 0x20, 0xE0, 
+0x02, 0x81, 0xD8, 0x90, 0x05, 0x54, 0xE0, 0x90, 0xA0, 0x70, 0xF0, 0xE0, 0xC3, 0x13, 0x90, 0xA0, 
+0x6F, 0xF0, 0x12, 0x77, 0xA0, 0x30, 0xE0, 0x0F, 0x12, 0x66, 0xFC, 0x90, 0xA0, 0x60, 0x12, 0x67, 
+0x35, 0x90, 0xA0, 0x61, 0xF0, 0x80, 0x42, 0x12, 0x66, 0xFC, 0xFF, 0xC3, 0x94, 0x2A, 0x50, 0x12, 
+0xEF, 0xC3, 0x94, 0x03, 0x90, 0xA0, 0x60, 0x50, 0x05, 0x74, 0x03, 0xF0, 0x80, 0x0A, 0xEF, 0xF0, 
+0x80, 0x06, 0x90, 0xA0, 0x60, 0x74, 0x2A, 0xF0, 0x12, 0x67, 0x36, 0xFF, 0xC3, 0x94, 0x2A, 0x50, 
+0x12, 0xEF, 0xC3, 0x94, 0x03, 0x90, 0xA0, 0x61, 0x50, 0x05, 0x74, 0x03, 0xF0, 0x80, 0x0A, 0xEF, 
+0xF0, 0x80, 0x06, 0x90, 0xA0, 0x61, 0x74, 0x2A, 0xF0, 0x12, 0x74, 0x7D, 0x30, 0xE0, 0x3D, 0x90, 
+0xA0, 0x60, 0xE0, 0x75, 0xF0, 0x03, 0x84, 0x90, 0xA0, 0x68, 0xF0, 0xE0, 0xC3, 0x13, 0xA3, 0xF0, 
+0x90, 0xA0, 0x61, 0xE0, 0x75, 0xF0, 0x03, 0x84, 0x90, 0xA0, 0x6A, 0xF0, 0x90, 0xA0, 0x60, 0xE0, 
+0xC3, 0x13, 0x90, 0xA0, 0x6B, 0xF0, 0x90, 0xA0, 0x61, 0xE0, 0xC3, 0x13, 0x90, 0xA0, 0x6C, 0xF0, 
+0x90, 0x01, 0x3E, 0x74, 0x08, 0xF0, 0xFD, 0x7F, 0x02, 0x12, 0x5E, 0xFF, 0xE4, 0x90, 0xA0, 0x9E, 
+0xF0, 0x51, 0xCD, 0xC4, 0x13, 0x13, 0x54, 0x03, 0x20, 0xE0, 0x39, 0x90, 0xA0, 0x5F, 0xE0, 0xFF, 
+0xC3, 0x13, 0x20, 0xE0, 0x07, 0xEF, 0x12, 0x76, 0xBF, 0x30, 0xE0, 0x28, 0x12, 0x06, 0x89, 0x13, 
+0x13, 0x13, 0x54, 0x1F, 0x30, 0xE0, 0x08, 0x90, 0xA0, 0xA0, 0xE0, 0x60, 0x08, 0x80, 0x0B, 0x90, 
+0xA0, 0xA0, 0xE0, 0x60, 0x05, 0x75, 0x51, 0x01, 0x80, 0x03, 0xE4, 0xF5, 0x51, 0x7D, 0x02, 0xAF, 
+0x51, 0x12, 0x4D, 0x38, 0x12, 0x77, 0xA8, 0x30, 0xE0, 0x12, 0x12, 0x87, 0xA2, 0x30, 0xE0, 0x07, 
+0x7D, 0x04, 0x7F, 0x02, 0x12, 0x5A, 0x74, 0xD1, 0x31, 0x74, 0x11, 0xF0, 0x90, 0x05, 0x58, 0x74, 
+0x02, 0xF0, 0x90, 0xA0, 0x67, 0xE0, 0xFF, 0xB4, 0x01, 0x08, 0x90, 0xA0, 0x72, 0x74, 0x01, 0xF0, 
+0x80, 0x1F, 0xEF, 0xB4, 0x04, 0x08, 0x90, 0xA0, 0x72, 0x74, 0x04, 0xF0, 0x80, 0x13, 0xEF, 0xB4, 
+0x06, 0x08, 0x90, 0xA0, 0x72, 0x74, 0x02, 0xF0, 0x80, 0x07, 0xEF, 0xB4, 0x07, 0x03, 0x12, 0x74, 
+0x6F, 0xE4, 0x90, 0xA0, 0x67, 0xF0, 0x80, 0x55, 0x51, 0xCD, 0x12, 0x5E, 0x8F, 0x30, 0xE0, 0x05, 
+0x75, 0x52, 0x02, 0x80, 0x11, 0x12, 0x06, 0x89, 0x12, 0x5E, 0xCC, 0x30, 0xE0, 0x05, 0x75, 0x52, 
+0x01, 0x80, 0x03, 0xE4, 0xF5, 0x52, 0x12, 0x90, 0x4B, 0x90, 0xA0, 0xBF, 0xE0, 0x30, 0xE0, 0x04, 
+0x7D, 0xA0, 0x80, 0x02, 0x7D, 0x20, 0x7F, 0x40, 0x12, 0x49, 0x90, 0x51, 0xCD, 0x13, 0x13, 0x13, 
+0x54, 0x1F, 0x30, 0xE0, 0x04, 0x7F, 0x03, 0x80, 0x02, 0x7F, 0x01, 0x12, 0x76, 0xC6, 0xAD, 0x52, 
+0x7F, 0x02, 0x12, 0x4D, 0x38, 0x12, 0x5E, 0x36, 0xD1, 0x31, 0x74, 0x43, 0xF0, 0x12, 0x87, 0xD4, 
+0x90, 0xA0, 0x71, 0xF0, 0x12, 0x76, 0xBB, 0x30, 0xE0, 0x09, 0x90, 0xA0, 0x91, 0xE0, 0x44, 0x02, 
+0xF0, 0x80, 0x0C, 0x7F, 0x01, 0x12, 0x77, 0xE5, 0x90, 0xA0, 0x91, 0xE0, 0x54, 0xFD, 0xF0, 0x7F, 
+0x03, 0x12, 0x75, 0x2F, 0x90, 0xA0, 0x5F, 0xE0, 0x20, 0xE0, 0x07, 0x90, 0xA0, 0x63, 0xE0, 0x54, 
+0xBF, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x12, 0x67, 0xE9, 0x12, 0x06, 0x89, 0xF5, 0x51, 0x24, 
+0x91, 0xD1, 0x03, 0xE0, 0x54, 0x9C, 0xF0, 0x74, 0x91, 0x25, 0x51, 0xD1, 0x03, 0xC0, 0x83, 0xC0, 
+0x82, 0x51, 0xCB, 0x54, 0x01, 0xFE, 0xEF, 0x4E, 0xD0, 0x82, 0xD0, 0x83, 0xF0, 0x74, 0x91, 0x25, 
+0x51, 0xD1, 0x03, 0xC0, 0x83, 0xC0, 0x82, 0x51, 0xCB, 0x54, 0x02, 0xFE, 0xEF, 0x4E, 0xD0, 0x82, 
+0xD0, 0x83, 0xF0, 0x74, 0x91, 0x25, 0x51, 0xD1, 0x03, 0xC0, 0x83, 0xC0, 0x82, 0x51, 0xCB, 0x54, 
+0x40, 0xFE, 0xEF, 0x4E, 0xD0, 0x82, 0xD0, 0x83, 0xF0, 0x74, 0x91, 0x25, 0x51, 0xD1, 0x03, 0xC0, 
+0x83, 0xC0, 0x82, 0x51, 0xCB, 0x54, 0x20, 0xFE, 0xEF, 0x4E, 0xD0, 0x82, 0xD0, 0x83, 0xF0, 0xE5, 
+0x51, 0xC3, 0x94, 0x80, 0x50, 0x09, 0x12, 0x67, 0x36, 0xFF, 0x12, 0x56, 0xA4, 0xEF, 0xF0, 0x74, 
+0x91, 0x25, 0x51, 0xD1, 0x03, 0xE0, 0x30, 0xE5, 0x12, 0x12, 0x4E, 0x26, 0x13, 0x13, 0x54, 0x03, 
+0xFB, 0x12, 0x56, 0xA4, 0xE0, 0xFD, 0xAF, 0x51, 0x12, 0xA5, 0xBD, 0x22, 0xE4, 0xF5, 0x64, 0x74, 
+0x91, 0x25, 0x5E, 0xF5, 0x82, 0xE4, 0x34, 0x99, 0xF5, 0x83, 0x22, 0xF0, 0xEE, 0x54, 0x40, 0xFE, 
+0xEF, 0x54, 0xBF, 0x22, 0xF0, 0xEE, 0x54, 0x10, 0xFE, 0xEF, 0x54, 0xEF, 0x4E, 0xFF, 0xF0, 0x02, 
+0x06, 0x89, 0xFF, 0xF0, 0x12, 0x06, 0x89, 0xFE, 0x54, 0x04, 0xFD, 0xEF, 0x54, 0xFB, 0x4D, 0xFF, 
+0x22, 0x90, 0x05, 0x00, 0x74, 0x1C, 0xF0, 0xA3, 0x22, 0x54, 0x80, 0xFE, 0xEF, 0x54, 0x7F, 0x4E, 
+0x22, 0xFE, 0x54, 0x20, 0xFD, 0xEF, 0x54, 0xDF, 0x4D, 0xFF, 0x22, 0xE0, 0x54, 0xFE, 0x4E, 0xFE, 
+0xF0, 0xEF, 0x54, 0x02, 0xFF, 0xEE, 0x54, 0xFD, 0x4F, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 
+0xD0, 0x12, 0x06, 0x89, 0x90, 0xA0, 0xCA, 0x12, 0x66, 0xFB, 0x90, 0xA0, 0xCB, 0x12, 0x67, 0x35, 
+0x90, 0xA0, 0xCC, 0xF0, 0x51, 0xD3, 0x90, 0xA0, 0xCD, 0x12, 0x67, 0xD6, 0x90, 0xA0, 0xCE, 0x31, 
+0xE6, 0x90, 0xA0, 0x87, 0xE0, 0x44, 0x40, 0xF0, 0x90, 0xA0, 0xCB, 0xE0, 0xB4, 0x0C, 0x06, 0xE5, 
+0x72, 0x70, 0x0D, 0x80, 0x00, 0xD1, 0xD8, 0x7D, 0x07, 0x7F, 0x30, 0x12, 0x61, 0x03, 0x8F, 0x51, 
+0x90, 0xA0, 0xCB, 0xE0, 0xB4, 0x0D, 0x0E, 0xE5, 0x51, 0x64, 0x01, 0x60, 0x05, 0x75, 0x72, 0x01, 
+0x80, 0x03, 0xE4, 0xF5, 0x72, 0xE5, 0x51, 0xB4, 0x01, 0x05, 0x75, 0x52, 0x01, 0x80, 0x03, 0xE4, 
+0xF5, 0x52, 0x90, 0xA0, 0xCA, 0xE0, 0xFB, 0xAD, 0x52, 0xE4, 0xFF, 0x12, 0x8F, 0xF0, 0x7F, 0x04, 
+0x12, 0x65, 0x78, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x7B, 0x01, 0x7A, 0xA0, 0x79, 0xCA, 0x22, 0xD1, 
+0xD8, 0x7F, 0xF5, 0x7E, 0x01, 0x12, 0x33, 0xFD, 0xBF, 0x01, 0x06, 0x90, 0xA0, 0xCA, 0xE0, 0xA3, 
+0xF0, 0xD1, 0xD8, 0x7F, 0xF6, 0x7E, 0x01, 0x12, 0x33, 0xFD, 0xBF, 0x01, 0x08, 0x90, 0xA0, 0xCA, 
+0xE0, 0x90, 0xA0, 0xCC, 0xF0, 0xD1, 0xD8, 0x7F, 0xF4, 0x7E, 0x01, 0x12, 0x33, 0xFD, 0xBF, 0x01, 
+0x08, 0x90, 0xA0, 0xCA, 0xE0, 0x90, 0xA0, 0xCD, 0xF0, 0xD1, 0xD8, 0x7F, 0xF3, 0x7E, 0x01, 0x12, 
+0x33, 0xFD, 0xBF, 0x01, 0x08, 0x90, 0xA0, 0xCA, 0xE0, 0x90, 0xA0, 0xCE, 0xF0, 0xD1, 0xD8, 0x7F, 
+0xF2, 0x7E, 0x01, 0x12, 0x33, 0xFD, 0xBF, 0x01, 0x08, 0x90, 0xA0, 0xCA, 0xE0, 0x90, 0xA0, 0xCF, 
+0xF0, 0x90, 0xA0, 0xCB, 0xE0, 0xFF, 0xA3, 0xE0, 0xFD, 0xA3, 0xE0, 0xFB, 0xA3, 0xE0, 0x90, 0xA0, 
+0xD3, 0xF0, 0x90, 0xA0, 0xCF, 0xE0, 0x90, 0xA0, 0xD4, 0xF0, 0x90, 0xA0, 0xD5, 0x74, 0x12, 0xF0, 
+0x90, 0xA0, 0xE3, 0x74, 0x05, 0xF0, 0x90, 0xA0, 0xD7, 0xEF, 0x12, 0x87, 0x58, 0x90, 0xA0, 0xD3, 
+0xE0, 0x90, 0xA0, 0xDA, 0xF0, 0x90, 0xA0, 0xD4, 0xE0, 0x90, 0xA0, 0xDB, 0xF0, 0x7B, 0x01, 0x7A, 
+0xA0, 0x79, 0xD5, 0x12, 0x63, 0x89, 0x7F, 0x04, 0x02, 0x65, 0x78, 0x12, 0x06, 0x89, 0xFF, 0x54, 
+0x01, 0xFE, 0x22, 0xF0, 0x7F, 0x0A, 0x7E, 0x00, 0x02, 0x3D, 0x7A, 0xF1, 0x8B, 0x90, 0xA0, 0x52, 
+0xD1, 0x4B, 0x12, 0x66, 0xFB, 0x90, 0xA0, 0x53, 0x12, 0x67, 0x35, 0x90, 0xA0, 0x54, 0xF0, 0x90, 
+0xA0, 0x53, 0xE0, 0x90, 0xA0, 0x55, 0xF0, 0x90, 0xA0, 0x52, 0xE0, 0x54, 0x01, 0xFF, 0xD3, 0x10, 
+0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0xAC, 0x07, 0xEF, 0x54, 0x01, 0xFE, 0x90, 0xA0, 0x52, 0xE0, 0x54, 
+0xFE, 0x4E, 0xF0, 0xEF, 0x64, 0x01, 0x70, 0x24, 0x90, 0x01, 0x53, 0xF0, 0x90, 0xA0, 0x54, 0xE0, 
+0x60, 0x0C, 0x7D, 0x10, 0x7F, 0x03, 0x12, 0x5E, 0xFF, 0x12, 0x80, 0x20, 0x80, 0x1C, 0x12, 0x80, 
+0x0F, 0x12, 0x5F, 0xBD, 0x12, 0x5F, 0x14, 0x12, 0x80, 0x29, 0x80, 0x0E, 0x12, 0x80, 0x0F, 0x12, 
+0x5E, 0xFF, 0x12, 0x5F, 0xA0, 0x11, 0x19, 0x12, 0x5F, 0xC4, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 
+0x01, 0x53, 0x74, 0x03, 0xF0, 0x7D, 0x10, 0xFF, 0x22, 0x7D, 0x01, 0x7F, 0x02, 0x02, 0x5F, 0xA4, 
+0x90, 0xA0, 0x54, 0xE0, 0x90, 0x05, 0x73, 0xF0, 0x22, 0x7D, 0x2F, 0x12, 0x4A, 0xD5, 0x7D, 0x08, 
+0x12, 0x57, 0xD0, 0x74, 0x08, 0xF0, 0x22, 0x90, 0xA0, 0x52, 0xE0, 0x30, 0xE0, 0x0C, 0x90, 0x01, 
+0x3B, 0xE0, 0x30, 0xE4, 0x05, 0x12, 0x5F, 0x14, 0x11, 0x20, 0x22, 0x90, 0xA0, 0x7A, 0xE0, 0x30, 
+0xE0, 0x04, 0x51, 0xA8, 0x80, 0x02, 0x71, 0x05, 0x90, 0xA0, 0x63, 0x12, 0x5E, 0x8E, 0x30, 0xE0, 
+0x13, 0x90, 0xA0, 0xA9, 0xE0, 0x04, 0xF0, 0xE0, 0xB4, 0x14, 0x09, 0x90, 0x04, 0x9C, 0xE4, 0xF0, 
+0x90, 0xA0, 0xA9, 0xF0, 0x90, 0x9F, 0x9E, 0xE0, 0x30, 0xE0, 0x06, 0x90, 0x9F, 0xA0, 0x74, 0x01, 
+0xF0, 0x90, 0x9F, 0xA7, 0xE0, 0x60, 0x48, 0x90, 0x9F, 0xA3, 0xE0, 0x30, 0xE0, 0x18, 0x90, 0x9F, 
+0xBE, 0xE0, 0x04, 0x12, 0x9B, 0x48, 0xCE, 0xC3, 0x13, 0xCE, 0x13, 0xD8, 0xF9, 0xFF, 0x90, 0x9F, 
+0xDE, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0x9F, 0xA4, 0x11, 0xDA, 0x30, 0xE0, 0x0A, 0x90, 0x01, 
+0x3B, 0xE0, 0x30, 0xE4, 0x03, 0x12, 0x5F, 0x14, 0x90, 0xA1, 0xEA, 0xE0, 0x04, 0xF0, 0xE0, 0xC3, 
+0x94, 0x80, 0x40, 0x0B, 0x90, 0x01, 0x98, 0xE0, 0x54, 0xFE, 0xF0, 0xE0, 0x44, 0x01, 0xF0, 0x7F, 
+0x01, 0x12, 0x61, 0x4B, 0x01, 0x37, 0xF0, 0x90, 0xA0, 0x50, 0xE0, 0x13, 0x13, 0x13, 0x54, 0x1F, 
+0x22, 0x90, 0xA0, 0xF4, 0xEF, 0xF1, 0x58, 0x90, 0xA0, 0xAD, 0x11, 0xDA, 0x20, 0xE0, 0x0E, 0x90, 
+0xA0, 0xF5, 0xE0, 0xB4, 0x01, 0x07, 0x7D, 0x36, 0x7F, 0x6F, 0x12, 0x57, 0x8F, 0x90, 0xA0, 0xF4, 
+0xE0, 0x70, 0x0C, 0x90, 0xA0, 0xF6, 0xE0, 0xFF, 0x7D, 0x05, 0x12, 0x74, 0x92, 0x80, 0x26, 0x90, 
+0xA0, 0xF4, 0xE0, 0xB4, 0x01, 0x09, 0x90, 0xA0, 0xF6, 0xE0, 0xFF, 0xB1, 0x52, 0x80, 0x16, 0x90, 
+0xA0, 0xF4, 0xE0, 0xB4, 0x02, 0x0F, 0xA3, 0xE0, 0xB4, 0x01, 0x0A, 0x90, 0xA0, 0xBB, 0xE0, 0xFE, 
+0xA3, 0xE0, 0xFF, 0x91, 0x62, 0x90, 0xA0, 0xAD, 0x11, 0xDA, 0x20, 0xE0, 0x0B, 0x90, 0xA0, 0xF5, 
+0xE0, 0x70, 0x05, 0xFD, 0xFF, 0x12, 0x57, 0x8F, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 
+0x90, 0xA0, 0xB4, 0xE0, 0xB4, 0x01, 0x02, 0x80, 0x42, 0x90, 0xA0, 0xB4, 0xE0, 0xB4, 0x02, 0x11, 
+0x51, 0x58, 0x7F, 0x01, 0x12, 0x75, 0x2F, 0x31, 0xB2, 0x90, 0xA0, 0xB4, 0x74, 0x03, 0xF0, 0x80, 
+0x3C, 0x90, 0xA0, 0xB4, 0xE0, 0x64, 0x03, 0x70, 0x1B, 0x90, 0xA0, 0xB7, 0x51, 0x5B, 0xE4, 0xFF, 
+0x12, 0x75, 0x2F, 0x31, 0xB2, 0x51, 0x4E, 0xE4, 0xFB, 0xFD, 0x11, 0xE1, 0x90, 0xA0, 0xB4, 0x74, 
+0x04, 0xF0, 0x80, 0x19, 0x90, 0xA0, 0xB4, 0xE0, 0xB4, 0x04, 0x12, 0x51, 0x4E, 0x7B, 0x01, 0x7D, 
+0x01, 0x11, 0xE1, 0x90, 0xA0, 0xB4, 0x74, 0x02, 0xF0, 0x90, 0xA0, 0xB2, 0xF0, 0xD0, 0xD0, 0x92, 
+0xAF, 0x22, 0xAD, 0x07, 0xED, 0x70, 0x19, 0x51, 0x3D, 0x70, 0x02, 0x80, 0x17, 0xBC, 0x01, 0x02, 
+0x80, 0x19, 0x51, 0x3D, 0xBC, 0x02, 0x02, 0x80, 0x1B, 0xEC, 0x64, 0x03, 0x70, 0x22, 0x80, 0x1B, 
+0x51, 0x45, 0x70, 0x04, 0x7F, 0x01, 0x80, 0x15, 0xBC, 0x01, 0x04, 0x7F, 0x03, 0x80, 0x0E, 0x51, 
+0x45, 0xBC, 0x02, 0x04, 0x7F, 0x09, 0x80, 0x05, 0xBC, 0x03, 0x05, 0x7F, 0x0D, 0x12, 0x76, 0xC6, 
+0x90, 0xA0, 0xAD, 0xE0, 0xC4, 0x13, 0x54, 0x07, 0x30, 0xE0, 0x3A, 0xED, 0x70, 0x1B, 0xA3, 0xE0, 
+0x13, 0x13, 0x54, 0x3F, 0x30, 0xE0, 0x07, 0xE4, 0x90, 0xA0, 0xF4, 0xF0, 0x80, 0x02, 0x51, 0x36, 
+0x90, 0xA0, 0xF4, 0xE0, 0xFD, 0xE4, 0xFF, 0x80, 0x19, 0x90, 0xA0, 0xAE, 0x12, 0x74, 0x80, 0x30, 
+0xE0, 0x07, 0xE4, 0x90, 0xA0, 0xF4, 0xF0, 0x80, 0x02, 0x51, 0x36, 0x90, 0xA0, 0xF4, 0xE0, 0xFD, 
+0x7F, 0x01, 0x12, 0x4D, 0x38, 0x22, 0x90, 0xA0, 0xF4, 0x74, 0x01, 0xF0, 0x22, 0x90, 0xA0, 0xAE, 
+0xE0, 0x54, 0x03, 0xFC, 0x22, 0x90, 0xA0, 0xAE, 0xE0, 0xC4, 0x54, 0x03, 0xFC, 0x22, 0x90, 0xA0, 
+0xAD, 0xE0, 0xC3, 0x13, 0x54, 0x03, 0xFF, 0x22, 0x90, 0xA0, 0xB9, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 
+0xAD, 0x07, 0xEE, 0xFF, 0x90, 0x01, 0x6F, 0xE4, 0xF0, 0x8F, 0x35, 0xAF, 0x05, 0x8F, 0x36, 0xFB, 
+0xFD, 0x7F, 0x6C, 0x7E, 0x01, 0x12, 0x3B, 0xDB, 0x90, 0x01, 0x6F, 0x74, 0x05, 0xF0, 0x22, 0x90, 
+0xA0, 0x7A, 0xE0, 0x30, 0xE0, 0x04, 0x51, 0x97, 0x80, 0x03, 0x12, 0x77, 0x00, 0x90, 0xA0, 0xAD, 
+0xE0, 0x30, 0xE0, 0x02, 0x31, 0x49, 0x22, 0x7D, 0x12, 0x7F, 0xFF, 0x12, 0x57, 0x8F, 0x7F, 0x01, 
+0x12, 0x76, 0xC6, 0xF1, 0xCC, 0x02, 0x4D, 0x38, 0x51, 0x97, 0x90, 0xA0, 0x7A, 0x71, 0x3F, 0xFE, 
+0xEF, 0xC3, 0x13, 0x54, 0x0F, 0xC3, 0x9E, 0x40, 0x03, 0x02, 0x90, 0x61, 0x90, 0xA0, 0x7A, 0xE0, 
+0xFF, 0xC3, 0x13, 0x54, 0x0F, 0xFE, 0xEF, 0x54, 0xE1, 0xFF, 0xEE, 0x04, 0x54, 0x0F, 0x25, 0xE0, 
+0x4F, 0xF0, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0xA0, 0xAD, 0xE0, 0x30, 0xE0, 
+0x1F, 0x90, 0xA0, 0xB2, 0xE0, 0xB4, 0x01, 0x0C, 0xA3, 0xE0, 0xB4, 0x01, 0x13, 0x74, 0x02, 0xF0, 
+0x51, 0x58, 0x80, 0x0C, 0x90, 0xA0, 0xB2, 0xE0, 0xB4, 0x02, 0x05, 0x74, 0x03, 0xF0, 0x31, 0x49, 
+0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xE4, 0xFF, 0x90, 0xA0, 0x5F, 0xE0, 0x30, 0xE0, 0x2D, 0xA3, 0x12, 
+0x72, 0xB3, 0x90, 0xA0, 0x72, 0x74, 0x01, 0xF0, 0x90, 0xA0, 0x71, 0xF0, 0x90, 0xA0, 0x51, 0xE0, 
+0x60, 0x07, 0x7D, 0x05, 0x7F, 0x6F, 0x02, 0x57, 0x8F, 0x12, 0x5E, 0x36, 0x71, 0x3C, 0x20, 0xE0, 
+0x0A, 0xEF, 0x13, 0x13, 0x54, 0x3F, 0x30, 0xE0, 0x02, 0xF1, 0x74, 0x22, 0x90, 0xA0, 0x5F, 0xE0, 
+0xFF, 0xC4, 0x13, 0x54, 0x07, 0x22, 0x90, 0xA0, 0xF4, 0xEF, 0xF0, 0x7F, 0x03, 0x12, 0x72, 0xB7, 
+0x12, 0x77, 0xA0, 0x90, 0xA0, 0x72, 0x30, 0xE0, 0x05, 0x74, 0x05, 0xF0, 0x80, 0x03, 0xE0, 0x04, 
+0xF0, 0x90, 0xA0, 0x63, 0x71, 0x3F, 0x20, 0xE0, 0x05, 0xF1, 0xB5, 0x30, 0xE0, 0x38, 0x12, 0x77, 
+0xA0, 0x30, 0xE0, 0x0A, 0x90, 0xA0, 0x60, 0xE0, 0xFF, 0x90, 0xA0, 0x70, 0x80, 0x21, 0x90, 0xA0, 
+0xF4, 0xE0, 0xFC, 0xB4, 0x01, 0x0D, 0x90, 0xA0, 0x60, 0xE0, 0xFE, 0x90, 0xA0, 0x6F, 0xE0, 0xC3, 
+0x9E, 0x80, 0x0F, 0xEC, 0xB4, 0x04, 0x0F, 0x90, 0xA0, 0x61, 0xE0, 0xFF, 0x90, 0xA0, 0x6F, 0xE0, 
+0xC3, 0x9F, 0x90, 0xA0, 0x76, 0xF0, 0x12, 0x77, 0xC0, 0x30, 0xE0, 0x1F, 0xF1, 0xA2, 0x20, 0xE0, 
+0x02, 0x81, 0x32, 0x91, 0x59, 0x50, 0x0A, 0xEF, 0x25, 0xE0, 0x25, 0xE0, 0xFB, 0xE4, 0xFD, 0x80, 
+0x05, 0x7B, 0x7F, 0x7D, 0xFF, 0xE4, 0xFF, 0xB1, 0x1D, 0x80, 0x67, 0x12, 0x77, 0xA8, 0x30, 0xE0, 
+0x48, 0xF1, 0xD4, 0xFD, 0x7F, 0x04, 0x12, 0x58, 0x65, 0x12, 0x74, 0x7D, 0x30, 0xE0, 0x3A, 0x90, 
+0xA0, 0x66, 0xE0, 0x44, 0x02, 0xF0, 0x54, 0xFB, 0xF0, 0xE4, 0x90, 0xA0, 0x75, 0xF0, 0x90, 0xA0, 
+0x72, 0xF0, 0x90, 0xA0, 0xF4, 0xE0, 0xFF, 0xB4, 0x01, 0x08, 0x90, 0xA0, 0x67, 0x74, 0x06, 0xF0, 
+0x80, 0x0A, 0xEF, 0xB4, 0x04, 0x06, 0x90, 0xA0, 0x67, 0x74, 0x07, 0xF0, 0x90, 0xA0, 0x51, 0xE0, 
+0x60, 0x07, 0x90, 0xA0, 0x66, 0xE0, 0x44, 0x04, 0xF0, 0x90, 0xA0, 0xF4, 0xE0, 0xB4, 0x01, 0x04, 
+0x7D, 0x06, 0x80, 0x09, 0x90, 0xA0, 0xF4, 0xE0, 0xB4, 0x04, 0x07, 0x7D, 0x0C, 0x7F, 0x6F, 0x12, 
+0x57, 0x8F, 0x90, 0xA0, 0x63, 0x11, 0xDA, 0x30, 0xE0, 0x14, 0x91, 0x59, 0x50, 0x0A, 0xEF, 0x7F, 
+0x00, 0x25, 0xE0, 0x25, 0xE0, 0xFE, 0x80, 0x04, 0x7F, 0xFF, 0x7E, 0x7F, 0x91, 0x62, 0x90, 0xA0, 
+0x62, 0xE0, 0x30, 0xE0, 0x03, 0x12, 0x5E, 0x36, 0x22, 0x90, 0xA0, 0x76, 0xE0, 0xFF, 0xC3, 0x94, 
+0x20, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0xA0, 0xF7, 0xEE, 0xF0, 0xA3, 0xEF, 
+0xF0, 0x90, 0x04, 0x1D, 0xE0, 0x60, 0x1E, 0x90, 0x05, 0x22, 0xE0, 0x90, 0xA0, 0xFB, 0xF0, 0x7D, 
+0x36, 0x12, 0x77, 0x3D, 0xBF, 0x01, 0x02, 0xF1, 0x02, 0x90, 0xA0, 0xFB, 0xE0, 0xFF, 0x7D, 0x37, 
+0x12, 0x57, 0x8F, 0x80, 0x02, 0xF1, 0x02, 0xF1, 0xC4, 0x7D, 0x38, 0x12, 0x57, 0x8F, 0xB1, 0x4B, 
+0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0xA1, 0xD9, 0xED, 
+0xF0, 0xA3, 0xEB, 0xF0, 0x90, 0xA1, 0xD8, 0xEF, 0xF0, 0xE4, 0xFD, 0xFC, 0xF1, 0xBC, 0x7C, 0x00, 
+0xAD, 0x07, 0x90, 0xA1, 0xD8, 0xE0, 0x90, 0x04, 0x25, 0xF0, 0x90, 0xA1, 0xD9, 0xE0, 0x60, 0x05, 
+0xF1, 0x68, 0x44, 0x80, 0xF0, 0xAF, 0x05, 0x74, 0x20, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 
+0x83, 0xE0, 0x54, 0xC0, 0xF0, 0xF1, 0x68, 0x54, 0xC0, 0xF0, 0xAF, 0x05, 0xD1, 0x5B, 0xE0, 0x54, 
+0x01, 0xFE, 0x90, 0xA1, 0xDA, 0xE0, 0x25, 0xE0, 0x25, 0xE0, 0xFB, 0xEE, 0x44, 0x02, 0x4B, 0xFE, 
+0xD1, 0x5B, 0xEE, 0xF0, 0x74, 0x11, 0x2F, 0xF1, 0x9A, 0x74, 0xFF, 0xF0, 0x74, 0x29, 0x2F, 0xF1, 
+0x42, 0x54, 0xF7, 0xF0, 0xAE, 0x04, 0xAF, 0x05, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0xA0, 0xF5, 
+0xEF, 0xF1, 0x58, 0x90, 0x04, 0x1D, 0xE0, 0x60, 0x20, 0x90, 0x05, 0x22, 0xE0, 0x90, 0xA0, 0xFA, 
+0xF0, 0x7D, 0x01, 0x12, 0x77, 0x3D, 0xEF, 0x64, 0x01, 0x70, 0x02, 0xB1, 0xE0, 0x90, 0xA0, 0xFA, 
+0xE0, 0xFF, 0x7D, 0x02, 0x12, 0x57, 0x8F, 0x80, 0x02, 0xB1, 0xE0, 0x90, 0x04, 0x1F, 0x74, 0x20, 
+0xF0, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0xA1, 0xC8, 0xEF, 0xF0, 0x90, 0x04, 
+0x1D, 0xE0, 0x60, 0x1E, 0x90, 0x05, 0x22, 0xE0, 0x90, 0xA1, 0xCB, 0xF0, 0x7D, 0x29, 0x12, 0x77, 
+0x3D, 0xBF, 0x01, 0x02, 0xB1, 0x8B, 0x90, 0xA1, 0xCB, 0xE0, 0xFF, 0x7D, 0x2A, 0x12, 0x57, 0x8F, 
+0x80, 0x02, 0xB1, 0x8B, 0xB1, 0x4B, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0x9E, 0x9B, 0xE0, 0xFF, 
+0x7B, 0x08, 0x7D, 0x01, 0x91, 0xA5, 0x90, 0xA1, 0xC9, 0xEE, 0xF0, 0xFC, 0xA3, 0xEF, 0xF0, 0xFD, 
+0x90, 0xA1, 0xC8, 0xE0, 0xFF, 0xF1, 0x4C, 0x54, 0x3F, 0xF0, 0xEF, 0x60, 0x29, 0xF1, 0x3F, 0x44, 
+0x10, 0xF1, 0x4B, 0x44, 0x80, 0xF0, 0xF1, 0xA2, 0x30, 0xE0, 0x24, 0x91, 0x59, 0x50, 0x0E, 0xEF, 
+0x25, 0xE0, 0x25, 0xE0, 0xFF, 0x74, 0x2B, 0x2D, 0xD1, 0xFA, 0xEF, 0xF0, 0x22, 0x74, 0x2B, 0x2D, 
+0xD1, 0xFA, 0x74, 0x7F, 0xF0, 0x22, 0xF1, 0x3F, 0x54, 0xEF, 0xF1, 0x4B, 0x44, 0x40, 0xF0, 0x22, 
+0x90, 0x9E, 0x9C, 0xE0, 0xFF, 0x7B, 0x08, 0x7D, 0x01, 0x91, 0xA5, 0x90, 0xA0, 0xF8, 0xEE, 0xF0, 
+0xFC, 0xA3, 0xEF, 0xF0, 0xFD, 0x90, 0xA0, 0xF5, 0xE0, 0xFF, 0xA3, 0xE0, 0xFB, 0xA3, 0xE0, 0x90, 
+0xA0, 0xFF, 0xF0, 0x90, 0xA0, 0xFC, 0xEC, 0xF1, 0x58, 0x90, 0xA0, 0xFC, 0xE0, 0xFC, 0xA3, 0xE0, 
+0xFD, 0xB1, 0xA5, 0x90, 0xA0, 0xFC, 0xA3, 0xE0, 0xFF, 0xFD, 0x24, 0x0D, 0xD1, 0xEE, 0x44, 0x80, 
+0xF0, 0x74, 0x0D, 0x2D, 0xD1, 0xEE, 0x54, 0xEF, 0xD1, 0x5A, 0xE0, 0x44, 0x02, 0xD1, 0x5A, 0xE0, 
+0x54, 0x03, 0xF0, 0x90, 0xA0, 0xFE, 0xE0, 0xFF, 0x90, 0xA0, 0xFC, 0xA3, 0xE0, 0xFE, 0x24, 0x2A, 
+0xF1, 0xAB, 0x90, 0xA0, 0xFF, 0xE0, 0xFF, 0xD1, 0xF7, 0xEF, 0xF0, 0x74, 0x2C, 0x2E, 0xF5, 0x82, 
+0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x24, 0x02, 0xF0, 0x22, 0xF0, 0x74, 0x12, 0x2F, 0xF5, 0x82, 
+0xE4, 0x34, 0xFC, 0xF5, 0x83, 0x22, 0x90, 0x9E, 0x9A, 0xE0, 0xFF, 0x90, 0xA1, 0xA8, 0xE0, 0xFB, 
+0x7D, 0x01, 0x91, 0xA5, 0x90, 0xA1, 0xA9, 0xEE, 0xF0, 0xFC, 0xA3, 0xEF, 0xF0, 0xFD, 0x90, 0xA1, 
+0xA7, 0xE0, 0xFF, 0xB1, 0xA5, 0x90, 0xA1, 0xA9, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x90, 0x81, 0x00, 
+0xE0, 0x54, 0x0F, 0xFD, 0xAC, 0x07, 0xD1, 0xEB, 0x44, 0x01, 0xF0, 0xD1, 0xEB, 0x54, 0xFB, 0xF0, 
+0xAC, 0x07, 0x74, 0x12, 0x2C, 0xD1, 0x5E, 0xE0, 0x44, 0xFA, 0xF0, 0x74, 0x11, 0x2C, 0xF1, 0x9A, 
+0xE0, 0x44, 0x1F, 0xF0, 0xAC, 0x07, 0x74, 0x06, 0x2C, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 
+0xE0, 0x44, 0x0E, 0xF0, 0x90, 0x04, 0xA7, 0xE4, 0xF0, 0x90, 0x04, 0xA6, 0xF0, 0x90, 0x04, 0xA5, 
+0x74, 0xFF, 0xF0, 0x90, 0x04, 0xA4, 0x74, 0xFD, 0xF0, 0x74, 0x14, 0x2C, 0xF1, 0x60, 0xE0, 0x54, 
+0xC0, 0x4D, 0xFD, 0x74, 0x14, 0x2F, 0xF1, 0x60, 0xED, 0xF0, 0x22, 0x74, 0x0D, 0x2C, 0xF5, 0x82, 
+0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x22, 0x74, 0x2B, 0x2E, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 
+0x83, 0x22, 0x90, 0x9E, 0x9D, 0xE0, 0xFF, 0xE4, 0xFB, 0x7D, 0x01, 0x91, 0xA5, 0x90, 0xA0, 0xF9, 
+0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0xA0, 0xF7, 0xE0, 0xFC, 0xA3, 0xE0, 0xFD, 0xD3, 0x10, 0xAF, 
+0x01, 0xC3, 0xC0, 0xD0, 0xAB, 0x07, 0x90, 0xA0, 0xFC, 0xED, 0xF0, 0xEC, 0xF9, 0xE0, 0xFF, 0xAE, 
+0x03, 0x74, 0x2A, 0x2E, 0xF1, 0xAB, 0xD1, 0xF7, 0xE9, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x74, 
+0x29, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x22, 0xF0, 0x74, 0x09, 0x2D, 0xF5, 
+0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x22, 0xF0, 0xA3, 0xED, 0xF0, 0xA3, 0xEB, 0xF0, 0x22, 
+0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0x22, 0x74, 0x21, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 
+0xF5, 0x83, 0xE0, 0x22, 0x90, 0xA0, 0x50, 0xE0, 0xC4, 0x54, 0x0F, 0x20, 0xE0, 0x1B, 0x90, 0x04, 
+0x1D, 0xE0, 0x70, 0x15, 0x90, 0x9E, 0x99, 0xE0, 0xFF, 0x7B, 0x18, 0xE4, 0xFD, 0x91, 0xA5, 0x90, 
+0xA1, 0xE4, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0xB1, 0x4B, 0x22, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 
+0x83, 0x22, 0x90, 0xA0, 0x63, 0xE0, 0xC4, 0x13, 0x54, 0x07, 0x22, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 
+0xF5, 0x83, 0xEF, 0xF0, 0x22, 0xEF, 0x13, 0x13, 0x13, 0x54, 0x1F, 0x22, 0x90, 0xFD, 0x10, 0xEF, 
+0xF0, 0x7F, 0x00, 0x22, 0x90, 0x05, 0x22, 0xE0, 0x54, 0x6F, 0xFF, 0x22, 0x90, 0xA0, 0xA0, 0xE0, 
+0xFF, 0xE4, 0xFD, 0x22, 0x90, 0xA0, 0x65, 0xE0, 0x54, 0xDF, 0xF0, 0xE4, 0x22, 0xD3, 0x10, 0xAF, 
+0x01, 0xC3, 0xC0, 0xD0, 0x12, 0x78, 0x45, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xD3, 0x10, 0xAF, 0x01, 
+0xC3, 0xC0, 0xD0, 0xC0, 0x07, 0xC0, 0x05, 0x90, 0xA1, 0x92, 0x12, 0x49, 0x0A, 0x90, 0xAA, 0x9C, 
+0x12, 0x08, 0x6D, 0xD0, 0x05, 0xD0, 0x07, 0x12, 0x32, 0x34, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x7E, 
+0x00, 0x7F, 0x19, 0x7D, 0x00, 0x7B, 0x01, 0x7A, 0xA0, 0x79, 0x91, 0x12, 0x08, 0xAA, 0xF1, 0x03, 
+0x90, 0xA0, 0x98, 0x12, 0x49, 0x0A, 0x90, 0xA0, 0x94, 0x12, 0x08, 0x6D, 0x90, 0x9E, 0x97, 0xE0, 
+0xFF, 0x64, 0x02, 0x70, 0x22, 0x31, 0x2A, 0x30, 0xE0, 0x02, 0x7E, 0x01, 0x90, 0xA0, 0xA0, 0xEE, 
+0xF0, 0x31, 0x2A, 0x30, 0xE1, 0x02, 0x7E, 0x01, 0x90, 0xA0, 0xA1, 0xEE, 0xF0, 0x90, 0xFD, 0x80, 
+0xE0, 0x90, 0x02, 0xFB, 0xF0, 0x80, 0x3A, 0xEF, 0x64, 0x01, 0x70, 0x15, 0x11, 0xC3, 0x30, 0xE0, 
+0x02, 0x7F, 0x01, 0x90, 0xA0, 0xA0, 0xEF, 0xF0, 0x11, 0xC3, 0x30, 0xE1, 0x02, 0x7F, 0x01, 0x80, 
+0x1B, 0x90, 0x9E, 0x97, 0xE0, 0x64, 0x03, 0x70, 0x18, 0x11, 0xBC, 0x30, 0xE0, 0x02, 0x7F, 0x01, 
+0x90, 0xA0, 0xA0, 0xEF, 0xF0, 0x11, 0xBC, 0x30, 0xE1, 0x02, 0x7F, 0x01, 0x90, 0xA0, 0xA1, 0xEF, 
+0xF0, 0x90, 0xFD, 0x68, 0xE0, 0x44, 0x02, 0xF0, 0x7F, 0x01, 0x12, 0x76, 0xC6, 0x11, 0xCA, 0x12, 
+0x90, 0x4B, 0x90, 0xA0, 0x78, 0x74, 0x01, 0xF0, 0x90, 0xA0, 0xAD, 0xE0, 0x54, 0xFE, 0xF0, 0x90, 
+0x04, 0x8F, 0xE4, 0xF0, 0x90, 0xA0, 0xBF, 0xE0, 0x54, 0xFE, 0xF0, 0x22, 0x90, 0xFD, 0x78, 0xE0, 
+0x7F, 0x00, 0x22, 0x90, 0xFD, 0x70, 0xE0, 0x7F, 0x00, 0x22, 0x7E, 0x00, 0x7F, 0x32, 0x7D, 0x00, 
+0x7B, 0x01, 0x7A, 0xA0, 0x79, 0x5F, 0x12, 0x08, 0xAA, 0x90, 0xA0, 0x60, 0x74, 0x0B, 0xF0, 0xA3, 
+0x74, 0x08, 0xF0, 0x90, 0x9E, 0x97, 0xE0, 0xFC, 0x64, 0x02, 0x70, 0x14, 0x31, 0x2A, 0x30, 0xE2, 
+0x02, 0x7E, 0x01, 0xEE, 0x31, 0x31, 0xFE, 0x90, 0xA0, 0x62, 0xE0, 0x54, 0xBF, 0x4E, 0xF0, 0x22, 
+0xEC, 0x64, 0x01, 0x70, 0x09, 0x11, 0xC3, 0x30, 0xE2, 0x02, 0x7F, 0x01, 0x80, 0x0F, 0x90, 0x9E, 
+0x97, 0xE0, 0x64, 0x03, 0x70, 0x13, 0x11, 0xBC, 0x30, 0xE2, 0x02, 0x7F, 0x01, 0xEF, 0x31, 0x31, 
+0xFF, 0x90, 0xA0, 0x62, 0xE0, 0x54, 0xBF, 0x4F, 0xF0, 0x22, 0x90, 0xFD, 0x80, 0xE0, 0x7E, 0x00, 
+0x22, 0x54, 0x01, 0xC4, 0x33, 0x33, 0x54, 0xC0, 0x22, 0x31, 0x4B, 0x12, 0x92, 0xD7, 0x12, 0x4E, 
+0x32, 0x12, 0xA6, 0x8B, 0x12, 0x5D, 0x5D, 0x31, 0xEC, 0x01, 0x0F, 0xE4, 0xFD, 0xFF, 0x12, 0x87, 
+0xB5, 0xFE, 0xEF, 0x54, 0x07, 0xFF, 0xED, 0x70, 0x12, 0x31, 0x8F, 0xC0, 0x83, 0xC0, 0x82, 0x31, 
+0x87, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0xF4, 0x5E, 0x80, 0x0F, 0x31, 0x8F, 0xC0, 0x83, 0xC0, 
+0x82, 0x31, 0x87, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0x4E, 0xD0, 0x82, 0xD0, 0x83, 0xF0, 0x31, 
+0x9A, 0x90, 0x9F, 0x9C, 0xEF, 0xF0, 0x22, 0xE0, 0xFE, 0x74, 0x01, 0xA8, 0x07, 0x08, 0x22, 0x74, 
+0x8C, 0x2E, 0xF5, 0x82, 0xE4, 0x34, 0x9F, 0xF5, 0x83, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 
+0xD0, 0x7D, 0x10, 0xED, 0x14, 0xF9, 0x24, 0x8C, 0x31, 0x92, 0xE0, 0x60, 0x36, 0x7C, 0x08, 0xEC, 
+0x14, 0x90, 0xA1, 0xE8, 0xF0, 0x74, 0x8C, 0x29, 0x31, 0x92, 0xE0, 0xFB, 0x7A, 0x00, 0x90, 0xA1, 
+0xE8, 0xE0, 0x12, 0x6F, 0xCE, 0x80, 0x05, 0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 0xF9, 0xF1, 0x87, 
+0x60, 0x0F, 0xE9, 0x75, 0xF0, 0x08, 0xA4, 0xFF, 0x90, 0xA1, 0xE8, 0xE0, 0x2F, 0x04, 0xFF, 0x80, 
+0x06, 0xDC, 0xCC, 0xDD, 0xBE, 0x7F, 0x00, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x12, 0xA8, 0xC1, 0x02, 
+0x08, 0xAA, 0xD1, 0x56, 0x12, 0x66, 0xFC, 0xFF, 0xF5, 0x55, 0x12, 0x06, 0x89, 0xFE, 0xC3, 0x13, 
+0x30, 0xE0, 0x07, 0x12, 0x67, 0x36, 0xF5, 0x56, 0x80, 0x02, 0x8F, 0x56, 0x85, 0x55, 0x54, 0xE5, 
+0x54, 0xD3, 0x95, 0x56, 0x50, 0x26, 0xAB, 0x51, 0xAA, 0x52, 0xA9, 0x53, 0x12, 0x06, 0x89, 0x54, 
+0x01, 0xFD, 0xAF, 0x54, 0x31, 0x4E, 0xAF, 0x54, 0x12, 0x50, 0x60, 0xEF, 0xAF, 0x54, 0x70, 0x05, 
+0x12, 0x94, 0xA5, 0x80, 0x03, 0x12, 0x94, 0x97, 0x05, 0x54, 0x80, 0xD3, 0xE5, 0x55, 0x70, 0x10, 
+0xFF, 0x12, 0x50, 0x60, 0xEF, 0x70, 0x09, 0x12, 0x5F, 0xB0, 0x54, 0xBF, 0xF0, 0x54, 0x7F, 0xF0, 
+0x22, 0x12, 0x06, 0x89, 0x54, 0x7F, 0xF5, 0x51, 0x12, 0x66, 0xFC, 0xFF, 0x54, 0x1F, 0xF5, 0x53, 
+0xEF, 0x54, 0x80, 0x12, 0x76, 0xBF, 0xF5, 0x52, 0x12, 0x67, 0x36, 0xFF, 0x54, 0x03, 0xF5, 0x54, 
+0xEF, 0x54, 0x30, 0xC4, 0x54, 0x0F, 0xF5, 0x57, 0x12, 0x67, 0x36, 0xFF, 0x54, 0x40, 0xC4, 0x13, 
+0x13, 0x54, 0x03, 0xF5, 0x55, 0xEF, 0x54, 0x80, 0x12, 0x76, 0xBF, 0xF5, 0x56, 0x12, 0x67, 0x36, 
+0xFF, 0x54, 0x08, 0x13, 0x13, 0x13, 0x54, 0x1F, 0xF5, 0x59, 0xEF, 0x54, 0x04, 0x13, 0x13, 0x54, 
+0x3F, 0xF5, 0x5A, 0xE5, 0x56, 0xF1, 0xA0, 0x12, 0x4E, 0x25, 0x54, 0x7F, 0x4F, 0xF0, 0xE5, 0x55, 
+0x31, 0x31, 0x12, 0x4E, 0x25, 0x54, 0xBF, 0x4F, 0xF0, 0xE5, 0x59, 0x60, 0x02, 0x61, 0x53, 0xE5, 
+0x53, 0x54, 0x1F, 0xFF, 0x75, 0xF0, 0x04, 0xE5, 0x51, 0x12, 0x4F, 0xA1, 0x54, 0xE0, 0x4F, 0xF0, 
+0xE5, 0x54, 0x54, 0x03, 0x12, 0x4E, 0x25, 0x54, 0xFC, 0x4F, 0xF0, 0xEF, 0x25, 0xE0, 0x25, 0xE0, 
+0x12, 0x4E, 0x25, 0x54, 0xF3, 0x4F, 0xF0, 0xE5, 0x52, 0x54, 0x01, 0xC4, 0x33, 0x54, 0xE0, 0xFF, 
+0x75, 0xF0, 0x04, 0xE5, 0x51, 0x12, 0x4F, 0xA1, 0x54, 0xDF, 0x4F, 0xF0, 0xE5, 0x57, 0x54, 0x03, 
+0xC4, 0x54, 0xF0, 0x12, 0x4E, 0x25, 0x54, 0xCF, 0x4F, 0xF0, 0x74, 0x91, 0x25, 0x51, 0x12, 0x7E, 
+0x03, 0xE0, 0x54, 0xFB, 0xF0, 0x74, 0x91, 0x25, 0x51, 0x12, 0x7E, 0x03, 0xE0, 0xFF, 0xE5, 0x5A, 
+0x25, 0xE0, 0x25, 0xE0, 0xFE, 0xEF, 0x4E, 0xF0, 0xE4, 0xF5, 0x58, 0x85, 0x58, 0x82, 0x75, 0x83, 
+0x00, 0xA3, 0xA3, 0xA3, 0x12, 0x06, 0xA2, 0xFF, 0x75, 0xF0, 0x08, 0xE5, 0x51, 0x12, 0x6C, 0x09, 
+0x25, 0x58, 0x12, 0x4F, 0xB8, 0xEF, 0xF0, 0x05, 0x58, 0xE5, 0x58, 0xB4, 0x04, 0xDD, 0xAF, 0x51, 
+0x12, 0x69, 0xC6, 0x22, 0x90, 0xA0, 0xC7, 0x12, 0x49, 0x37, 0x90, 0xA0, 0xC6, 0xEF, 0xF0, 0x12, 
+0x49, 0x40, 0x8B, 0xC0, 0x00, 0x8B, 0xC9, 0x01, 0x8B, 0xD1, 0x02, 0x8B, 0xD9, 0x12, 0x8B, 0xE2, 
+0x14, 0x8B, 0xEB, 0x20, 0x8B, 0xF4, 0x21, 0x8B, 0xFC, 0x23, 0x8C, 0x04, 0x24, 0x8C, 0x0D, 0x25, 
+0x8C, 0x15, 0x27, 0x8C, 0x1E, 0x28, 0x8C, 0x26, 0x40, 0x8C, 0x2E, 0x42, 0x8C, 0x37, 0x60, 0x8C, 
+0x40, 0x61, 0x8C, 0x49, 0x62, 0x8C, 0x51, 0x63, 0x8C, 0x59, 0x64, 0x8C, 0x61, 0x65, 0x8C, 0x6A, 
+0x66, 0x8C, 0x73, 0x67, 0x8C, 0x7C, 0x68, 0x8C, 0x84, 0x69, 0x8C, 0x8D, 0x6B, 0x8C, 0x96, 0x6C, 
+0x8C, 0x9F, 0x6D, 0x8C, 0xA7, 0x6E, 0x8C, 0xAF, 0x6F, 0x8C, 0xB8, 0x70, 0x00, 0x00, 0x8C, 0xC1, 
+0x90, 0xA0, 0xC7, 0x12, 0x49, 0x2E, 0x02, 0x90, 0xAF, 0x90, 0xA0, 0xC7, 0x12, 0x49, 0x2E, 0x21, 
+0xF2, 0x90, 0xA0, 0xC7, 0x12, 0x49, 0x2E, 0xC1, 0x16, 0x90, 0xA0, 0xC7, 0x12, 0x49, 0x2E, 0x02, 
+0x90, 0xF0, 0x90, 0xA0, 0xC7, 0x12, 0x49, 0x2E, 0x02, 0x91, 0x04, 0x90, 0xA0, 0xC7, 0x12, 0x49, 
+0x2E, 0x02, 0x65, 0xC5, 0x90, 0xA0, 0xC7, 0x12, 0x49, 0x2E, 0xA1, 0x7D, 0x90, 0xA0, 0xC7, 0x12, 
+0x49, 0x2E, 0xE1, 0x77, 0x90, 0xA0, 0xC7, 0x12, 0x49, 0x2E, 0x02, 0x5A, 0xDB, 0x90, 0xA0, 0xC7, 
+0x12, 0x49, 0x2E, 0xA1, 0xE5, 0x90, 0xA0, 0xC7, 0x12, 0x49, 0x2E, 0x02, 0x7F, 0x9B, 0x90, 0xA0, 
+0xC7, 0x12, 0x49, 0x2E, 0x81, 0xFE, 0x90, 0xA0, 0xC7, 0x12, 0x49, 0x2E, 0x41, 0x51, 0x90, 0xA0, 
+0xC7, 0x12, 0x49, 0x2E, 0x02, 0x7D, 0x67, 0x90, 0xA0, 0xC7, 0x12, 0x49, 0x2E, 0x02, 0x7A, 0xD9, 
+0x90, 0xA0, 0xC7, 0x12, 0x49, 0x2E, 0x02, 0x63, 0xF9, 0x90, 0xA0, 0xC7, 0x12, 0x49, 0x2E, 0xE1, 
+0x69, 0x90, 0xA0, 0xC7, 0x12, 0x49, 0x2E, 0x80, 0x78, 0x90, 0xA0, 0xC7, 0x12, 0x49, 0x2E, 0xC1, 
+0xB2, 0x90, 0xA0, 0xC7, 0x12, 0x49, 0x2E, 0x02, 0x91, 0x13, 0x90, 0xA0, 0xC7, 0x12, 0x49, 0x2E, 
+0x02, 0x65, 0x93, 0x90, 0xA0, 0xC7, 0x12, 0x49, 0x2E, 0x02, 0x7E, 0x5A, 0x90, 0xA0, 0xC7, 0x12, 
+0x49, 0x2E, 0x80, 0x61, 0x90, 0xA0, 0xC7, 0x12, 0x49, 0x2E, 0x02, 0x67, 0x3C, 0x90, 0xA0, 0xC7, 
+0x12, 0x49, 0x2E, 0x02, 0x79, 0xED, 0x90, 0xA0, 0xC7, 0x12, 0x49, 0x2E, 0x02, 0x66, 0xE5, 0x90, 
+0xA0, 0xC7, 0x12, 0x49, 0x2E, 0xC1, 0x5D, 0x90, 0xA0, 0xC7, 0x12, 0x49, 0x2E, 0xA1, 0xB9, 0x90, 
+0xA0, 0xC7, 0x12, 0x49, 0x2E, 0x02, 0x91, 0x21, 0x90, 0xA0, 0xC7, 0x12, 0x49, 0x2E, 0x02, 0x91, 
+0x44, 0x90, 0x01, 0xC0, 0xE0, 0x44, 0x01, 0xF0, 0x90, 0xA0, 0xC6, 0xE0, 0x90, 0x01, 0xC2, 0xF0, 
+0x22, 0x90, 0xA0, 0x87, 0xE0, 0x44, 0x10, 0xF0, 0x7D, 0x01, 0x7F, 0x1B, 0x12, 0x61, 0x03, 0x90, 
+0xA0, 0xCA, 0xEF, 0xF0, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0xA0, 0x88, 0xE0, 
+0x44, 0x01, 0xF0, 0x7D, 0x01, 0x7F, 0x28, 0x91, 0xDC, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x12, 0x7F, 
+0x8B, 0x90, 0xA0, 0x56, 0xE0, 0x54, 0xFE, 0x4E, 0xF0, 0xEF, 0x54, 0x02, 0x33, 0x33, 0x33, 0x54, 
+0xF8, 0xFF, 0x90, 0x9F, 0xA3, 0xE0, 0x54, 0xEF, 0x4F, 0xF0, 0x90, 0xA0, 0x56, 0xE0, 0x54, 0x01, 
+0xFF, 0xEF, 0x64, 0x01, 0x70, 0x22, 0x12, 0xA7, 0x49, 0x90, 0x01, 0x38, 0x12, 0x4F, 0x8B, 0x90, 
+0x01, 0x30, 0x12, 0x4F, 0x8C, 0x90, 0x01, 0x30, 0x74, 0x10, 0xF0, 0x90, 0x01, 0x39, 0x74, 0x01, 
+0xF0, 0x90, 0x00, 0x53, 0x74, 0x80, 0xF0, 0x22, 0x12, 0xA7, 0x89, 0x90, 0xA0, 0x5C, 0xE0, 0x90, 
+0x01, 0x31, 0xF0, 0x90, 0xA0, 0x5D, 0xE0, 0x90, 0x01, 0x32, 0xF0, 0x90, 0xA0, 0x5E, 0xE0, 0x90, 
+0x01, 0x33, 0xF0, 0x90, 0xA0, 0x57, 0xE0, 0x90, 0x01, 0x38, 0xF0, 0x90, 0xA0, 0x5A, 0xE0, 0x90, 
+0x01, 0x3B, 0x12, 0x5F, 0x99, 0x7F, 0x01, 0x12, 0x5A, 0x53, 0x02, 0x5D, 0x5D, 0x12, 0x67, 0x36, 
+0xFF, 0x30, 0xE0, 0x1F, 0x12, 0x06, 0x89, 0x90, 0xA0, 0x4B, 0x12, 0x66, 0xFB, 0x90, 0xA0, 0x4C, 
+0xF0, 0xEF, 0x54, 0xFE, 0xFF, 0xA3, 0xE0, 0x54, 0x01, 0x4F, 0xF0, 0x12, 0x7A, 0xD3, 0x90, 0xA0, 
+0x4E, 0xF0, 0x22, 0x90, 0xA0, 0x4B, 0x74, 0x02, 0xF0, 0xA3, 0x74, 0x0A, 0xF0, 0xA3, 0xE0, 0x54, 
+0x01, 0x44, 0x1E, 0xF0, 0xA3, 0x74, 0x05, 0xF0, 0x22, 0x12, 0x06, 0x89, 0x54, 0x01, 0x25, 0xE0, 
+0xD1, 0xAA, 0x54, 0xFB, 0x4F, 0xF0, 0xE0, 0x13, 0x13, 0x54, 0x3F, 0x30, 0xE0, 0x08, 0x90, 0x07, 
+0x65, 0xE0, 0x44, 0x18, 0xF0, 0x22, 0x90, 0xA0, 0xA7, 0xE0, 0x20, 0xE0, 0x07, 0x90, 0x07, 0x65, 
+0xE0, 0x54, 0xE7, 0xF0, 0x22, 0x12, 0x06, 0x89, 0x90, 0xA0, 0x51, 0xF0, 0x60, 0x27, 0x90, 0xA0, 
+0x5F, 0xE0, 0x20, 0xE0, 0x20, 0xE4, 0xFD, 0x7F, 0x04, 0x12, 0x58, 0x65, 0xF1, 0x7F, 0x30, 0xE0, 
+0x14, 0x12, 0x87, 0xB5, 0x20, 0xE0, 0x0E, 0xF1, 0xA9, 0x30, 0xE0, 0x04, 0x7F, 0x0D, 0x80, 0x02, 
+0x7F, 0x09, 0x12, 0x76, 0xC6, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0xD1, 0x56, 0x12, 
+0x06, 0x89, 0xFF, 0x90, 0x9F, 0x9D, 0xF0, 0xBF, 0x01, 0x09, 0x12, 0x66, 0xFC, 0x64, 0x01, 0x60, 
+0x20, 0x80, 0x1B, 0xAB, 0x51, 0xAA, 0x52, 0xA9, 0x53, 0x12, 0x66, 0xFC, 0x64, 0x01, 0x60, 0x11, 
+0x90, 0x9F, 0x9E, 0xE0, 0x20, 0xE0, 0x07, 0xE4, 0xFF, 0x12, 0x5C, 0x4A, 0x80, 0x03, 0x12, 0x9D, 
+0xB1, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x8B, 0x51, 0x8A, 0x52, 0x89, 0x53, 0x22, 0x12, 0x06, 0x89, 
+0x54, 0x01, 0xD1, 0xAA, 0x54, 0xFD, 0x4F, 0xF0, 0xE0, 0xC3, 0x13, 0xFF, 0x54, 0x01, 0x90, 0x01, 
+0xE6, 0xF0, 0xA3, 0xE0, 0x54, 0xFE, 0xF0, 0xEF, 0x30, 0xE0, 0x27, 0x12, 0xA8, 0x2A, 0x70, 0x20, 
+0x90, 0xA0, 0xA7, 0xE0, 0x30, 0xE0, 0x02, 0x80, 0x19, 0x90, 0xFD, 0x62, 0xE0, 0xB4, 0xAD, 0x0E, 
+0xA3, 0xE0, 0xB4, 0x35, 0x09, 0xD1, 0xA2, 0x90, 0x01, 0xE5, 0x74, 0xDF, 0xF0, 0x22, 0x80, 0x00, 
+0xE1, 0x8F, 0x90, 0x01, 0xE7, 0xE0, 0x54, 0xFE, 0xF0, 0x22, 0x25, 0xE0, 0xFF, 0x90, 0xA0, 0x84, 
+0xE0, 0x22, 0x12, 0x67, 0xE9, 0x90, 0xA1, 0xD2, 0xE0, 0x70, 0x08, 0xF1, 0x03, 0x90, 0xA1, 0xD2, 
+0x74, 0x01, 0xF0, 0x12, 0x65, 0xBF, 0x12, 0x06, 0x89, 0xFF, 0xE4, 0x8F, 0x54, 0xF5, 0x53, 0xF5, 
+0x52, 0xF5, 0x51, 0x90, 0xA0, 0x98, 0x12, 0x49, 0x0A, 0xEC, 0x54, 0xC1, 0xFC, 0xC0, 0x04, 0xC0, 
+0x05, 0xC0, 0x06, 0xC0, 0x07, 0xAF, 0x54, 0xAE, 0x53, 0xAD, 0x52, 0xAC, 0x51, 0x78, 0x19, 0x12, 
+0x08, 0x5A, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0x12, 0x48, 0xFD, 0x90, 0xA0, 0x94, 
+0x02, 0x08, 0x6D, 0x7F, 0x58, 0x7E, 0x0C, 0x12, 0x37, 0xBC, 0x90, 0xA0, 0x98, 0x02, 0x08, 0x6D, 
+0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x9E, 0xF0, 0xE0, 0xFF, 0x90, 0x9E, 0xEF, 0xE0, 
+0xB5, 0x07, 0x04, 0x7F, 0x01, 0x80, 0x02, 0x7F, 0x00, 0xEF, 0x70, 0x38, 0x90, 0x9E, 0xEF, 0xE0, 
+0xFE, 0xF1, 0x97, 0xE0, 0xFD, 0xEE, 0x75, 0xF0, 0x08, 0xA4, 0x24, 0xA0, 0xF9, 0x74, 0x9E, 0x35, 
+0xF0, 0xFA, 0x7B, 0x01, 0xAF, 0x05, 0x71, 0x54, 0x90, 0x9E, 0xEF, 0xF1, 0x70, 0xB4, 0x0A, 0x02, 
+0x7F, 0x01, 0xEF, 0x60, 0x05, 0xE4, 0x90, 0x9E, 0xEF, 0xF0, 0x12, 0x91, 0xAB, 0x90, 0x9E, 0x92, 
+0xE0, 0x44, 0x02, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x7D, 0x01, 0x7F, 0x17, 0x02, 0x61, 0x03, 
+0xE0, 0x04, 0xF0, 0xE0, 0x7F, 0x00, 0x22, 0x12, 0x06, 0x89, 0x90, 0x9F, 0xB2, 0xF0, 0x22, 0x90, 
+0xA0, 0x50, 0xE0, 0xFF, 0xC3, 0x13, 0x22, 0xFF, 0xEE, 0x5A, 0xFE, 0xEF, 0x5B, 0x4E, 0x22, 0x90, 
+0x01, 0xE7, 0xE0, 0x44, 0x01, 0xF0, 0x22, 0x75, 0xF0, 0x08, 0x90, 0x9E, 0x9F, 0x02, 0x49, 0x22, 
+0x54, 0x01, 0xC4, 0x33, 0x33, 0x33, 0x54, 0x80, 0x22, 0x90, 0xA0, 0x50, 0xE0, 0x13, 0x13, 0x54, 
+0x3F, 0x22, 0xF1, 0x7F, 0x30, 0xE0, 0x1E, 0x12, 0x87, 0xB5, 0x20, 0xE0, 0x18, 0x12, 0x77, 0xA0, 
+0x30, 0xE0, 0x04, 0x7F, 0x03, 0x80, 0x0B, 0xF1, 0xA9, 0x30, 0xE0, 0x04, 0x7F, 0x0D, 0x80, 0x02, 
+0x7F, 0x09, 0x12, 0x76, 0xC6, 0x22, 0x90, 0xA1, 0x04, 0x74, 0x08, 0xF0, 0x90, 0xA1, 0x12, 0x74, 
+0x01, 0xF0, 0x90, 0xA1, 0x06, 0xEF, 0xF0, 0x7B, 0x01, 0x7A, 0xA1, 0x79, 0x04, 0x02, 0x63, 0x89, 
+0x90, 0xA1, 0x5D, 0x74, 0x0B, 0xF0, 0x90, 0xA1, 0x6B, 0x74, 0x07, 0xF0, 0x90, 0xA1, 0x5F, 0xEF, 
+0xF0, 0x60, 0x32, 0x90, 0xFD, 0x63, 0xE0, 0x90, 0xA1, 0x60, 0xF0, 0x90, 0xFD, 0x61, 0xE0, 0x90, 
+0xA1, 0x61, 0xF0, 0x90, 0xFD, 0x64, 0xE0, 0x90, 0xA1, 0x62, 0xF0, 0x90, 0xFD, 0x65, 0xE0, 0x90, 
+0xA1, 0x63, 0xF0, 0x90, 0xFD, 0x66, 0xE0, 0x90, 0xA1, 0x64, 0xF0, 0x90, 0xFD, 0x67, 0xE0, 0x90, 
+0xA1, 0x65, 0xF0, 0x80, 0x0D, 0x90, 0xA1, 0x60, 0xED, 0xF0, 0xA3, 0xEB, 0xF0, 0xE4, 0xA3, 0x12, 
+0x4F, 0x8C, 0x7B, 0x01, 0x7A, 0xA1, 0x79, 0x5D, 0x02, 0x63, 0x89, 0x7E, 0x00, 0x7F, 0x0A, 0x7D, 
+0x00, 0x7B, 0x01, 0x7A, 0xA0, 0x79, 0x87, 0x12, 0x08, 0xAA, 0x90, 0xA0, 0x73, 0x74, 0x02, 0xF0, 
+0x22, 0x90, 0xA0, 0x7A, 0xE0, 0x54, 0xFE, 0xF0, 0x54, 0xE1, 0xF0, 0x90, 0xA0, 0x7F, 0xE0, 0xFF, 
+0x12, 0x76, 0xC6, 0x11, 0xA1, 0xE4, 0xFF, 0xE4, 0xFC, 0x11, 0x97, 0x12, 0x49, 0x0A, 0x90, 0xA0, 
+0x7B, 0x12, 0x49, 0x16, 0x12, 0x48, 0xFD, 0x11, 0x97, 0x12, 0x4D, 0x2B, 0x11, 0xA8, 0x12, 0x4C, 
+0x71, 0xE4, 0xFD, 0xFF, 0x02, 0x57, 0x8F, 0x90, 0xA1, 0xB0, 0x12, 0x08, 0x6D, 0x90, 0xA1, 0xB0, 
+0x22, 0x7F, 0xB4, 0x7E, 0x0C, 0x02, 0x37, 0xBC, 0x7F, 0xB4, 0x7E, 0x0C, 0x02, 0x38, 0x07, 0x90, 
+0x02, 0x09, 0xE0, 0xF5, 0x51, 0x12, 0x06, 0x89, 0x25, 0x51, 0x90, 0x9E, 0x98, 0x12, 0x66, 0xFB, 
+0x25, 0x51, 0x90, 0x9E, 0x99, 0x12, 0x67, 0x35, 0x25, 0x51, 0x90, 0x9E, 0x9A, 0xF0, 0x12, 0x7A, 
+0xD3, 0x25, 0x51, 0x90, 0x9E, 0x9B, 0x12, 0x67, 0xD6, 0x25, 0x51, 0x90, 0x9E, 0x9C, 0x12, 0x66, 
+0xDE, 0x25, 0x51, 0x90, 0x9E, 0x9D, 0x12, 0x67, 0xCD, 0x25, 0x51, 0x90, 0x9E, 0x9E, 0xF0, 0x22, 
+0x12, 0x06, 0x89, 0xFF, 0x90, 0x9F, 0x8B, 0xF0, 0xBF, 0x01, 0x08, 0x12, 0x7E, 0xDF, 0xE4, 0x90, 
+0x9F, 0x8B, 0xF0, 0x22, 0x12, 0x06, 0x89, 0x54, 0x01, 0xFF, 0x90, 0xA0, 0xC1, 0xE0, 0x54, 0xFE, 
+0x4F, 0xF0, 0x22, 0x12, 0x06, 0x89, 0x90, 0xA0, 0xA0, 0x12, 0x66, 0xFB, 0x90, 0xA0, 0xA1, 0xF0, 
+0x22, 0x12, 0x06, 0x89, 0x54, 0x01, 0x33, 0x33, 0x33, 0x54, 0xF8, 0xFF, 0x90, 0xA0, 0x84, 0xE0, 
+0x54, 0xF7, 0x4F, 0xF0, 0x12, 0x80, 0xDA, 0x90, 0x07, 0x65, 0x30, 0xE0, 0x04, 0x74, 0x18, 0xF0, 
+0x22, 0xE4, 0xF0, 0x22, 0x12, 0x06, 0x89, 0x54, 0x01, 0xFF, 0x90, 0xA0, 0xBF, 0xE0, 0x54, 0xFE, 
+0x4F, 0xF0, 0x30, 0xE0, 0x55, 0x90, 0x00, 0x40, 0xE0, 0x54, 0xBF, 0x44, 0xA0, 0xFD, 0x7F, 0x40, 
+0x12, 0x49, 0x90, 0x90, 0x00, 0x41, 0xE0, 0x44, 0x04, 0xFD, 0x7F, 0x41, 0x12, 0x49, 0x90, 0x90, 
+0x00, 0x6A, 0xE0, 0x54, 0xFB, 0xFD, 0x7F, 0x6A, 0x12, 0x49, 0x90, 0x90, 0x07, 0x6E, 0x74, 0x55, 
+0xF0, 0xA3, 0x74, 0x12, 0xF0, 0x90, 0x07, 0x78, 0xE0, 0x54, 0xF2, 0x44, 0x02, 0xF0, 0x90, 0x06, 
+0xCC, 0xE0, 0x44, 0x03, 0xF0, 0x90, 0x07, 0x65, 0xE0, 0x54, 0xF5, 0xF0, 0x90, 0x05, 0x23, 0xE0, 
+0x54, 0x7F, 0xF0, 0xE4, 0xFD, 0x7F, 0x66, 0x12, 0x49, 0x90, 0x22, 0x90, 0x01, 0xCC, 0xE0, 0x54, 
+0x0F, 0x90, 0xA1, 0xDE, 0xF0, 0x90, 0xA1, 0xDE, 0xE0, 0xFD, 0x70, 0x02, 0x41, 0xB7, 0x90, 0x9E, 
+0xEF, 0xE0, 0xFF, 0x70, 0x06, 0xA3, 0xE0, 0x64, 0x09, 0x60, 0x0A, 0xEF, 0x14, 0xFF, 0x90, 0x9E, 
+0xF0, 0xE0, 0xB5, 0x07, 0x04, 0x7F, 0x01, 0x80, 0x02, 0x7F, 0x00, 0xEF, 0x60, 0x08, 0x90, 0x01, 
+0xC1, 0xE0, 0x44, 0x01, 0xF0, 0x22, 0x90, 0xA1, 0xD3, 0xE0, 0x12, 0x6F, 0xCE, 0x80, 0x05, 0xC3, 
+0x33, 0xCE, 0x33, 0xCE, 0xD8, 0xF9, 0xFF, 0xEF, 0x5D, 0x70, 0x02, 0x41, 0x9A, 0xE4, 0x90, 0xA1, 
+0xDF, 0xF0, 0x90, 0xA1, 0xDF, 0xE0, 0xF9, 0xC3, 0x94, 0x04, 0x50, 0x42, 0x51, 0xB9, 0xA4, 0xFF, 
+0xE9, 0xFD, 0x7C, 0x00, 0x2F, 0xFF, 0xEC, 0x35, 0xF0, 0xFE, 0x74, 0xD0, 0x51, 0xC1, 0x12, 0x8F, 
+0x97, 0xE5, 0x82, 0x29, 0x12, 0x4F, 0xB8, 0xEF, 0x51, 0xB8, 0xA4, 0x2D, 0xFF, 0xEC, 0x35, 0xF0, 
+0xFE, 0x74, 0xF0, 0x51, 0xC1, 0x75, 0xF0, 0x08, 0x90, 0x9E, 0xA3, 0x12, 0x49, 0x22, 0xE5, 0x82, 
+0x29, 0x12, 0x4F, 0xB8, 0xEF, 0xF0, 0x90, 0xA1, 0xDF, 0xE0, 0x04, 0xF0, 0x80, 0xB4, 0x90, 0xA1, 
+0xDE, 0xE0, 0xFF, 0x90, 0xA1, 0xD3, 0x12, 0x6D, 0xAC, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0xF4, 
+0x5F, 0x90, 0xA1, 0xDE, 0xF0, 0x90, 0xA1, 0xD3, 0xE0, 0xFF, 0x74, 0x01, 0xA8, 0x07, 0x08, 0x80, 
+0x02, 0xC3, 0x33, 0xD8, 0xFC, 0x90, 0x01, 0xCC, 0xF0, 0x90, 0xA1, 0xD3, 0xE0, 0x04, 0xF0, 0xE0, 
+0x54, 0x03, 0xF0, 0x90, 0x9E, 0xF0, 0x12, 0x8F, 0x70, 0xB4, 0x0A, 0x02, 0x7F, 0x01, 0xEF, 0x70, 
+0x02, 0x21, 0xB5, 0xE4, 0x90, 0x9E, 0xF0, 0xF0, 0x21, 0xB5, 0x90, 0x01, 0xC0, 0xE0, 0x44, 0x02, 
+0xF0, 0x90, 0xA1, 0xD3, 0xE0, 0x44, 0x80, 0x90, 0x00, 0x8A, 0x51, 0xB8, 0x90, 0x01, 0xD0, 0x12, 
+0x49, 0x22, 0xE0, 0x90, 0x01, 0xC3, 0xF0, 0x22, 0xF0, 0x90, 0xA1, 0xD3, 0xE0, 0x75, 0xF0, 0x04, 
+0x22, 0x2F, 0xF5, 0x82, 0x74, 0x01, 0x3E, 0xF5, 0x83, 0xE0, 0xFF, 0x90, 0x9E, 0xF0, 0xE0, 0x22, 
+0x31, 0xAB, 0x7F, 0x02, 0x02, 0x61, 0x4B, 0xE4, 0x90, 0x9F, 0x87, 0xF0, 0xA3, 0xF0, 0x90, 0x9E, 
+0xEF, 0xF0, 0xA3, 0xF0, 0x22, 0xE4, 0xFC, 0xED, 0x2C, 0x24, 0x00, 0x71, 0x36, 0xE4, 0xF0, 0x0C, 
+0xEC, 0xB4, 0x18, 0xF3, 0x74, 0x00, 0x2D, 0x71, 0x36, 0xEF, 0xF0, 0xEE, 0x54, 0x3F, 0xFF, 0x74, 
+0x01, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 0xFB, 0xF5, 0x83, 0xEF, 0xF0, 0x74, 0x02, 0x2D, 0xF5, 0x82, 
+0xE4, 0x34, 0xFB, 0xF5, 0x83, 0xE0, 0x54, 0xF0, 0xF0, 0x74, 0x03, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 
+0xFB, 0xF5, 0x83, 0xE0, 0x44, 0x80, 0xF0, 0x74, 0x0B, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 0xFB, 0xF5, 
+0x83, 0xE0, 0x44, 0x10, 0xF0, 0x22, 0xF5, 0x82, 0xE4, 0x34, 0xFB, 0xF5, 0x83, 0x22, 0xD3, 0x10, 
+0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0xA1, 0xC0, 0x12, 0x49, 0x37, 0x7F, 0x96, 0x7E, 0x02, 0x12, 
+0x79, 0xA3, 0xEF, 0x60, 0x51, 0x90, 0x01, 0x17, 0xE0, 0xFE, 0x90, 0x01, 0x16, 0xE0, 0x7C, 0x00, 
+0x24, 0x00, 0xFF, 0xEC, 0x3E, 0xFE, 0xEF, 0x24, 0x01, 0xFF, 0xE4, 0x3E, 0xFE, 0x90, 0xA1, 0xC3, 
+0xEF, 0xF0, 0xEE, 0xFF, 0x90, 0xFD, 0x11, 0xF0, 0x90, 0xA1, 0xC3, 0xE0, 0xFD, 0x90, 0x02, 0x94, 
+0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0xA1, 0xC0, 0x91, 0x82, 0x24, 0x02, 0xFF, 0xE4, 0x33, 0xFE, 0x51, 
+0xE5, 0x90, 0xA1, 0xC3, 0xE0, 0x24, 0x18, 0xFF, 0x90, 0xA1, 0xC0, 0x12, 0x49, 0x2E, 0x91, 0x10, 
+0x90, 0x02, 0x96, 0x74, 0x01, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 
+0xC0, 0xD0, 0xE4, 0xFF, 0x90, 0x9F, 0x88, 0xE0, 0xFE, 0x90, 0x9F, 0x87, 0xE0, 0xFD, 0xB5, 0x06, 
+0x04, 0x7E, 0x01, 0x80, 0x02, 0x7E, 0x00, 0xEE, 0x64, 0x01, 0x60, 0x3F, 0xED, 0x91, 0x8B, 0xFA, 
+0x7B, 0x01, 0x71, 0x3E, 0x7F, 0x01, 0xEF, 0x60, 0x32, 0x90, 0x9F, 0x87, 0xE0, 0x04, 0xF0, 0xE0, 
+0xB4, 0x0A, 0x02, 0x80, 0x02, 0x7F, 0x00, 0xEF, 0x60, 0x05, 0xE4, 0x90, 0x9F, 0x87, 0xF0, 0x90, 
+0x9F, 0x88, 0xE0, 0xFF, 0x90, 0x9F, 0x87, 0xE0, 0xB5, 0x07, 0x04, 0x7F, 0x01, 0x80, 0x02, 0x7F, 
+0x00, 0xEF, 0x70, 0x07, 0x90, 0x9E, 0x92, 0xE0, 0x44, 0x04, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 
+0x90, 0xA1, 0xBC, 0xEF, 0xF0, 0xA3, 0x12, 0x49, 0x37, 0x90, 0xA1, 0xD4, 0xE0, 0xFE, 0x04, 0xF0, 
+0x90, 0x00, 0x01, 0xEE, 0x12, 0x06, 0xE1, 0x74, 0x00, 0x2F, 0xF9, 0xE4, 0x34, 0xFB, 0xFA, 0x7B, 
+0x01, 0xC0, 0x03, 0xC0, 0x02, 0xC0, 0x01, 0x90, 0xA1, 0xBD, 0x12, 0x49, 0x2E, 0x8B, 0x40, 0x8A, 
+0x41, 0x89, 0x42, 0x75, 0x43, 0x02, 0xD0, 0x01, 0xD0, 0x02, 0xD0, 0x03, 0x12, 0x34, 0x62, 0x90, 
+0xA1, 0xBC, 0xE0, 0x24, 0x02, 0xF9, 0xE4, 0x34, 0xFB, 0xFA, 0x7B, 0x01, 0xC0, 0x03, 0xC0, 0x02, 
+0xC0, 0x01, 0xA3, 0x12, 0x49, 0x2E, 0xE9, 0x24, 0x02, 0xF9, 0xE4, 0x3A, 0x8B, 0x40, 0xF5, 0x41, 
+0x89, 0x42, 0x90, 0xA1, 0xBD, 0x91, 0x82, 0xF5, 0x43, 0xD0, 0x01, 0xD0, 0x02, 0xD0, 0x03, 0x02, 
+0x34, 0x62, 0x12, 0x49, 0x2E, 0x90, 0x00, 0x0E, 0x02, 0x06, 0xA2, 0x75, 0xF0, 0x0F, 0xA4, 0x24, 
+0xF1, 0xF9, 0x74, 0x9E, 0x35, 0xF0, 0x22, 0x8F, 0x57, 0x75, 0xF0, 0x10, 0xEF, 0x12, 0x6D, 0x95, 
+0xE0, 0x54, 0xFB, 0xF0, 0x22, 0x8F, 0x57, 0x75, 0xF0, 0x10, 0xEF, 0x12, 0x6D, 0x95, 0xE0, 0x44, 
+0x04, 0xF0, 0x22, 0x90, 0xA1, 0xD5, 0x12, 0x49, 0x37, 0xE4, 0xFF, 0x90, 0xA1, 0xD5, 0x12, 0x49, 
+0x2E, 0x8F, 0x82, 0x12, 0x64, 0x72, 0xFE, 0x74, 0xF0, 0x2F, 0x91, 0xD4, 0xEE, 0xF0, 0x0F, 0xEF, 
+0xB4, 0x10, 0xE8, 0x22, 0xF5, 0x82, 0xE4, 0x34, 0x02, 0xF5, 0x83, 0x22, 0x90, 0x01, 0x94, 0xE0, 
+0x44, 0x01, 0xF0, 0x90, 0x01, 0xC7, 0xE4, 0xF0, 0x22, 0x90, 0x01, 0x01, 0xE0, 0x44, 0x04, 0xF0, 
+0x90, 0x01, 0x9A, 0xE0, 0x54, 0xC0, 0x12, 0x7F, 0x93, 0x90, 0x01, 0x99, 0xE0, 0x44, 0xC0, 0xF0, 
+0x90, 0x01, 0x9B, 0x74, 0x80, 0xF0, 0x22, 0x7D, 0x02, 0x90, 0x01, 0xC4, 0x74, 0x07, 0xF0, 0x74, 
+0x95, 0xA3, 0xF0, 0x90, 0xA0, 0xC0, 0xE0, 0xFF, 0xED, 0xC3, 0x9F, 0x50, 0x14, 0xED, 0x25, 0xE0, 
+0x24, 0x81, 0xF8, 0xE6, 0x30, 0xE4, 0x07, 0xB1, 0x3F, 0xA3, 0xF0, 0x7F, 0x00, 0x22, 0x0D, 0x80, 
+0xE2, 0x74, 0x07, 0x04, 0x90, 0x01, 0xC4, 0xF0, 0x74, 0x95, 0xA3, 0xF0, 0x7F, 0x01, 0x22, 0x90, 
+0x01, 0xB8, 0x74, 0x08, 0xF0, 0x22, 0x90, 0xA0, 0x5F, 0xE0, 0x30, 0xE0, 0x23, 0x90, 0xA0, 0x71, 
+0xE0, 0x60, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x40, 0xF0, 0xA1, 0xF9, 0x90, 0x9F, 0xA9, 0xE0, 0xD3, 
+0x94, 0x00, 0x40, 0x02, 0x80, 0x30, 0x90, 0xA0, 0x51, 0xE0, 0x70, 0x02, 0xA1, 0xF7, 0x80, 0x5A, 
+0xD1, 0xA6, 0xEF, 0x64, 0x01, 0x60, 0x04, 0xD1, 0x40, 0x80, 0x7E, 0x90, 0x9F, 0xAB, 0xE0, 0xFF, 
+0x54, 0x03, 0x60, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x02, 0xF0, 0x80, 0x6D, 0x90, 0x9F, 0xA9, 0xE0, 
+0xFE, 0xE4, 0xC3, 0x9E, 0x50, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x04, 0xF0, 0x80, 0x5B, 0xEF, 0x30, 
+0xE2, 0x04, 0xB1, 0x3F, 0x80, 0x53, 0x90, 0x9F, 0xAB, 0xE0, 0x30, 0xE4, 0x04, 0xD1, 0x02, 0x80, 
+0x48, 0x90, 0x9F, 0xA4, 0xE0, 0x13, 0x13, 0x54, 0x3F, 0x20, 0xE0, 0x08, 0x90, 0x01, 0xB8, 0x74, 
+0x20, 0xF0, 0x80, 0x35, 0x90, 0xA0, 0x51, 0xE0, 0x60, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x80, 0xF0, 
+0x80, 0x27, 0x90, 0x06, 0x62, 0xE0, 0x30, 0xE1, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x11, 0xF0, 0x80, 
+0x18, 0x90, 0x06, 0x62, 0xE0, 0x30, 0xE0, 0x0F, 0xE0, 0x54, 0xFC, 0xFF, 0xBF, 0x80, 0x08, 0x90, 
+0x01, 0xB8, 0x74, 0x12, 0xF0, 0x80, 0x02, 0x80, 0x4E, 0x90, 0x01, 0xB9, 0x74, 0x04, 0xF0, 0x7F, 
+0x00, 0x22, 0x90, 0x01, 0xB8, 0x74, 0x10, 0xF0, 0x22, 0x90, 0xA0, 0x52, 0xE0, 0xC3, 0x13, 0x20, 
+0xE0, 0x23, 0x90, 0x02, 0x87, 0xE0, 0x60, 0x04, 0xD1, 0x40, 0x80, 0x1B, 0x90, 0x02, 0x96, 0xE0, 
+0x60, 0x04, 0xD1, 0x02, 0x80, 0x11, 0x90, 0x02, 0x86, 0xE0, 0x20, 0xE1, 0x08, 0x90, 0x01, 0xB8, 
+0x74, 0x04, 0xF0, 0x80, 0x02, 0x80, 0x10, 0x90, 0x01, 0xB9, 0x74, 0x08, 0xF0, 0x7F, 0x00, 0x22, 
+0x90, 0x01, 0xB8, 0x74, 0x01, 0xF0, 0x22, 0x90, 0x01, 0xB8, 0xE4, 0xF0, 0x7F, 0x01, 0x22, 0x90, 
+0x9F, 0xAA, 0xE0, 0xFF, 0x60, 0x03, 0xB4, 0x08, 0x0D, 0xD1, 0x09, 0xBF, 0x01, 0x08, 0xD1, 0x94, 
+0x90, 0x01, 0xE5, 0xE0, 0x04, 0xF0, 0x22, 0x90, 0x9F, 0xA3, 0xE0, 0x30, 0xE0, 0x18, 0x90, 0x9F, 
+0x9E, 0xE0, 0xFF, 0x30, 0xE0, 0x0E, 0xC3, 0x13, 0x30, 0xE0, 0x07, 0xD1, 0x87, 0xBF, 0x01, 0x06, 
+0x80, 0x02, 0x80, 0x00, 0xD1, 0x4F, 0x22, 0x90, 0x9F, 0xA1, 0xE0, 0x64, 0x02, 0x7F, 0x01, 0x60, 
+0x02, 0x7F, 0x00, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x12, 0x4D, 0xD9, 0x12, 0x79, 
+0x09, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0x04, 0x1A, 0xE0, 0xF4, 0x60, 0x03, 0x7F, 0x00, 0x22, 
+0x90, 0x04, 0x1B, 0xE0, 0x54, 0x07, 0x64, 0x07, 0x7F, 0x01, 0x60, 0x02, 0x7F, 0x00, 0x22, 0xD1, 
+0xA6, 0xEF, 0x70, 0x02, 0xD1, 0xED, 0x22, 0x90, 0x9F, 0xA7, 0xE0, 0x64, 0x02, 0x60, 0x0F, 0xD1, 
+0xE6, 0x60, 0x0B, 0xD1, 0xA6, 0xEF, 0x70, 0x06, 0xFD, 0x7F, 0x0C, 0x12, 0x58, 0x65, 0x22, 0x90, 
+0x9F, 0xAB, 0xE0, 0x44, 0x01, 0xF0, 0x90, 0x9F, 0xA5, 0xE0, 0x54, 0x0F, 0x22, 0x90, 0xA0, 0x5F, 
+0xE0, 0x20, 0xE0, 0x1D, 0x90, 0x9F, 0xA7, 0xE0, 0x64, 0x01, 0x70, 0x15, 0x12, 0x8F, 0xB2, 0xD1, 
+0xE6, 0x60, 0x05, 0x12, 0x57, 0x85, 0xE1, 0xD6, 0x90, 0x9F, 0xAA, 0xE0, 0x70, 0x03, 0x12, 0x58, 
+0x61, 0x22, 0x12, 0x5E, 0x8B, 0x30, 0xE0, 0x0B, 0xF1, 0x2A, 0x60, 0x07, 0x7D, 0x01, 0x7F, 0x02, 
+0x12, 0x58, 0x65, 0xF1, 0x2A, 0x60, 0x02, 0xD1, 0xC7, 0x22, 0x90, 0x9F, 0xA2, 0xE0, 0x64, 0x02, 
+0x22, 0xE4, 0xFF, 0x12, 0x50, 0x60, 0xBF, 0x01, 0x11, 0x90, 0x9F, 0xA7, 0xE0, 0x60, 0x0B, 0xD1, 
+0xE6, 0x64, 0x02, 0x60, 0x03, 0x02, 0x87, 0x74, 0xF1, 0x4B, 0x22, 0xF1, 0xD6, 0x90, 0x9F, 0xAA, 
+0xE0, 0x64, 0x0C, 0x60, 0x05, 0x12, 0x57, 0x85, 0xF1, 0xC3, 0x22, 0x12, 0x5E, 0xC8, 0x30, 0xE0, 
+0x0B, 0xEF, 0xC4, 0x13, 0x13, 0x54, 0x03, 0x30, 0xE0, 0x02, 0xF1, 0xBC, 0x90, 0x9F, 0xA3, 0x12, 
+0x75, 0x00, 0x30, 0xE0, 0x08, 0xF1, 0xCA, 0x54, 0x07, 0x70, 0x38, 0x80, 0x33, 0x12, 0x9D, 0x51, 
+0x40, 0x2E, 0x12, 0x50, 0x58, 0x70, 0x2C, 0xD1, 0xE6, 0x70, 0x05, 0x12, 0x9C, 0xAF, 0x80, 0x24, 
+0x12, 0x9C, 0xAF, 0x90, 0x9F, 0xB1, 0xE0, 0x04, 0xF0, 0xE0, 0xD3, 0x94, 0x02, 0x40, 0x09, 0xF1, 
+0xB4, 0xE4, 0x90, 0x9F, 0xB1, 0xF0, 0x80, 0x02, 0xF1, 0x4B, 0xE4, 0x90, 0x9F, 0xB0, 0xF0, 0x22, 
+0x12, 0x58, 0x4D, 0x22, 0x90, 0x9F, 0xA4, 0xE0, 0x54, 0xFB, 0xF0, 0x22, 0x7D, 0x02, 0x7F, 0x02, 
+0x02, 0x5F, 0x1E, 0x7D, 0x08, 0xE4, 0xFF, 0x02, 0x74, 0x92, 0xEF, 0x54, 0xFB, 0xF0, 0x90, 0x9F, 
+0xAB, 0xE0, 0x54, 0xFD, 0xF0, 0x22, 0x90, 0x9F, 0xA3, 0x12, 0x80, 0xDA, 0x30, 0xE0, 0x05, 0x90, 
+0x01, 0x5B, 0xE4, 0xF0, 0x90, 0x06, 0x92, 0x74, 0x02, 0xF0, 0x90, 0x01, 0x3C, 0x74, 0x04, 0xF0, 
+0xE4, 0x90, 0xA1, 0x8E, 0xF0, 0x90, 0xA0, 0x4D, 0xE0, 0xC3, 0x13, 0x54, 0x7F, 0x90, 0xA1, 0x8F, 
+0xF0, 0xE4, 0xFB, 0xFD, 0x7F, 0x58, 0x7E, 0x01, 0x12, 0x50, 0x1B, 0x90, 0x9F, 0xA3, 0xE0, 0x44, 
+0x08, 0xF0, 0x22, 0xE4, 0x90, 0x9E, 0x92, 0x12, 0x4F, 0x8C, 0xA3, 0xF0, 0x22, 0x90, 0x01, 0xE4, 
+0x74, 0x1C, 0xF0, 0xA3, 0xE4, 0xF0, 0x22, 0x90, 0x01, 0x34, 0xE0, 0x55, 0x15, 0xF5, 0x19, 0xA3, 
+0xE0, 0x55, 0x16, 0xF5, 0x1A, 0xA3, 0xE0, 0x55, 0x17, 0xF5, 0x1B, 0xA3, 0xE0, 0x55, 0x18, 0xF5, 
+0x1C, 0x90, 0x01, 0x34, 0xE5, 0x19, 0xF0, 0xA3, 0xE5, 0x1A, 0xF0, 0xA3, 0xE5, 0x1B, 0xF0, 0xA3, 
+0xE5, 0x1C, 0xF0, 0x22, 0x90, 0x01, 0x3C, 0xE0, 0x55, 0x1D, 0xF5, 0x21, 0xA3, 0xE0, 0x55, 0x1E, 
+0xF5, 0x22, 0xA3, 0xE0, 0x55, 0x1F, 0xF5, 0x23, 0xA3, 0xE0, 0x55, 0x20, 0xF5, 0x24, 0x90, 0x01, 
+0x3C, 0xE5, 0x21, 0xF0, 0xA3, 0xE5, 0x22, 0xF0, 0xA3, 0xE5, 0x23, 0xF0, 0xA3, 0xE5, 0x24, 0xF0, 
+0x53, 0x91, 0xDF, 0x22, 0x90, 0x01, 0xCF, 0xE0, 0x90, 0xA0, 0xE4, 0xF0, 0xE0, 0xFF, 0x30, 0xE0, 
+0x07, 0x90, 0x01, 0xCF, 0xE0, 0x54, 0xFE, 0xF0, 0xEF, 0x30, 0xE5, 0x23, 0x90, 0x01, 0xCF, 0xE0, 
+0x54, 0xDF, 0xF0, 0x90, 0x01, 0x34, 0x74, 0x20, 0xF0, 0xE4, 0xF5, 0xA8, 0xF5, 0xE8, 0x12, 0x4F, 
+0x47, 0x90, 0x00, 0x03, 0xE0, 0x54, 0xFB, 0xFD, 0x7F, 0x03, 0x12, 0x49, 0x90, 0x80, 0xFE, 0x22, 
+0x90, 0x9F, 0x9E, 0xE0, 0x30, 0xE0, 0x05, 0xE4, 0xA3, 0xF0, 0xA3, 0xF0, 0x22, 0x90, 0x9F, 0x9E, 
+0xE0, 0x30, 0xE0, 0x10, 0xA3, 0x74, 0x01, 0xF0, 0x90, 0x9F, 0x9E, 0xE0, 0xFF, 0xC3, 0x13, 0x30, 
+0xE0, 0x02, 0xB1, 0xB1, 0x11, 0xE9, 0x02, 0x70, 0xF0, 0xE4, 0xF5, 0x65, 0x90, 0x9F, 0xA7, 0xE0, 
+0x70, 0x02, 0x21, 0x79, 0x12, 0x50, 0x58, 0x60, 0x02, 0x21, 0x79, 0x71, 0x49, 0xCE, 0xC3, 0x13, 
+0xCE, 0x13, 0xD8, 0xF9, 0xB1, 0xE2, 0x31, 0x84, 0x60, 0x22, 0x24, 0xFE, 0x60, 0x03, 0x04, 0x70, 
+0x1E, 0x90, 0x9F, 0xAE, 0xE0, 0x14, 0xF0, 0xE0, 0xFF, 0x60, 0x06, 0x90, 0x9F, 0xB0, 0xE0, 0x60, 
+0x0E, 0xEF, 0x70, 0x08, 0x90, 0x9F, 0xAD, 0xE0, 0xA3, 0xF0, 0x80, 0x00, 0x75, 0x65, 0x01, 0x90, 
+0x9F, 0x9E, 0xE0, 0x30, 0xE0, 0x12, 0x90, 0x9F, 0xA2, 0xE0, 0xB4, 0x02, 0x03, 0xE4, 0xF5, 0x65, 
+0x12, 0x5E, 0xD3, 0xEF, 0x70, 0x02, 0xF5, 0x65, 0xE5, 0x65, 0x60, 0x2D, 0xB1, 0x19, 0x90, 0x9F, 
+0xB0, 0xE0, 0x60, 0x03, 0xB4, 0x01, 0x04, 0x31, 0x7A, 0x80, 0x08, 0x31, 0x7A, 0x75, 0xF0, 0x03, 
+0xA4, 0x24, 0xFE, 0xFF, 0x90, 0x9F, 0xAF, 0xE0, 0x2F, 0x12, 0x50, 0x10, 0x90, 0x9F, 0xAA, 0xE0, 
+0x20, 0xE2, 0x03, 0x12, 0x58, 0x61, 0x12, 0x8F, 0xB2, 0x22, 0xE4, 0x90, 0xA1, 0x8E, 0xF0, 0x90, 
+0x9F, 0xB0, 0xE0, 0x22, 0xF0, 0x90, 0x9F, 0xA5, 0xE0, 0xFF, 0xC4, 0x54, 0x0F, 0x22, 0x71, 0x49, 
+0xCE, 0xC3, 0x13, 0xCE, 0x13, 0xD8, 0xF9, 0xFF, 0x90, 0xA0, 0xE4, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 
+0x12, 0x50, 0x58, 0x60, 0x02, 0x41, 0x38, 0x90, 0x9F, 0xA7, 0xE0, 0x70, 0x02, 0x41, 0x38, 0x31, 
+0x85, 0x64, 0x01, 0x70, 0x22, 0x90, 0x06, 0xAB, 0xE0, 0x90, 0x9F, 0xAE, 0xF0, 0x90, 0x06, 0xAA, 
+0xE0, 0x90, 0x9F, 0xAD, 0xF0, 0xA3, 0xE0, 0xFF, 0x70, 0x08, 0x90, 0x9F, 0xAD, 0xE0, 0xFE, 0xFF, 
+0x80, 0x00, 0x90, 0x9F, 0xAE, 0xEF, 0xF0, 0x51, 0x4C, 0x51, 0x44, 0xE4, 0x90, 0x9F, 0xB0, 0xB1, 
+0xD7, 0xB1, 0x21, 0x12, 0x97, 0xCD, 0x54, 0xEF, 0x31, 0x84, 0x24, 0xFD, 0x50, 0x02, 0x80, 0x0D, 
+0x90, 0x9F, 0x9E, 0xE0, 0x30, 0xE0, 0x04, 0x71, 0xCF, 0x80, 0x02, 0x71, 0x80, 0x12, 0x5E, 0xC8, 
+0x30, 0xE0, 0x35, 0xEF, 0xC4, 0x13, 0x13, 0x54, 0x03, 0x20, 0xE0, 0x2C, 0x90, 0x9F, 0xAD, 0xE0, 
+0xFF, 0xA3, 0xE0, 0x6F, 0x70, 0x22, 0x90, 0x9F, 0xA4, 0xE0, 0x44, 0x40, 0xF0, 0xB1, 0x11, 0xF0, 
+0x90, 0x01, 0x3F, 0x74, 0x10, 0xF0, 0xFD, 0x7F, 0x03, 0x12, 0x5E, 0xFF, 0x12, 0x5F, 0x1A, 0x12, 
+0x97, 0xBC, 0x90, 0x9F, 0xAE, 0xE0, 0x14, 0xF0, 0x90, 0x9F, 0x9E, 0xE0, 0xC3, 0x13, 0x20, 0xE0, 
+0x02, 0x51, 0x44, 0x22, 0x90, 0x9F, 0xA4, 0xE0, 0x44, 0x04, 0xF0, 0x22, 0xE4, 0xFD, 0xF9, 0xFC, 
+0x90, 0x05, 0x62, 0xE0, 0xFE, 0x90, 0x05, 0x61, 0xE0, 0xFB, 0xEB, 0x78, 0x02, 0xCE, 0xC3, 0x13, 
+0xCE, 0x13, 0xD8, 0xF9, 0xFF, 0xEE, 0x54, 0x3F, 0x90, 0x9F, 0xE0, 0xF0, 0xA3, 0xEF, 0xF0, 0xA3, 
+0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x90, 0x9F, 0xE0, 0xE0, 0xFA, 0xA3, 0xE0, 0xFB, 0xC3, 0x9F, 0xEA, 
+0x9E, 0x40, 0x21, 0xEB, 0x9F, 0xFF, 0x90, 0x9F, 0xBF, 0xE0, 0xFE, 0xC3, 0x74, 0x0A, 0x9E, 0x2F, 
+0xF9, 0xC3, 0x94, 0x19, 0x50, 0x0E, 0x74, 0xC4, 0x29, 0x71, 0x38, 0xE0, 0x04, 0xF0, 0x90, 0x9F, 
+0xBD, 0xE0, 0x04, 0xF0, 0x90, 0x9F, 0xBD, 0xE0, 0xC3, 0x94, 0x64, 0x50, 0x02, 0x61, 0x34, 0xE4, 
+0xFC, 0xFD, 0x71, 0x35, 0xE0, 0x2C, 0xFC, 0xD3, 0x94, 0x05, 0x40, 0x07, 0x90, 0xA0, 0xE6, 0xED, 
+0xF0, 0x80, 0x05, 0x0D, 0xED, 0xB4, 0x19, 0xEA, 0xE4, 0xFC, 0xFD, 0x71, 0x35, 0xE0, 0x2C, 0xFC, 
+0xD3, 0x94, 0x5F, 0x40, 0x07, 0x90, 0xA0, 0xE7, 0xED, 0xF0, 0x80, 0x05, 0x0D, 0xED, 0xB4, 0x19, 
+0xEA, 0x90, 0xA0, 0xE6, 0xE0, 0x90, 0x9F, 0xC2, 0xF0, 0x90, 0xA0, 0xE7, 0xE0, 0x90, 0x9F, 0xC3, 
+0x71, 0x40, 0x94, 0x0B, 0x40, 0x0A, 0xEF, 0x24, 0xF6, 0x90, 0x9F, 0xBA, 0xF0, 0xE4, 0x80, 0x09, 
+0xE4, 0x90, 0x9F, 0xBA, 0x71, 0x40, 0x74, 0x0A, 0x9F, 0x90, 0x9F, 0xB9, 0xF0, 0x90, 0x9F, 0xC2, 
+0xE0, 0xFF, 0xA3, 0xE0, 0xC3, 0x9F, 0x90, 0x9F, 0xC0, 0xF0, 0xC3, 0x94, 0x08, 0x50, 0x03, 0x74, 
+0x08, 0xF0, 0x90, 0x9F, 0xBA, 0xE0, 0xFD, 0x90, 0x9F, 0xC0, 0xE0, 0xFB, 0xE4, 0xFF, 0x91, 0x44, 
+0xE4, 0xFF, 0x71, 0x57, 0x22, 0x74, 0xC4, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 0x9F, 0xF5, 0x83, 0x22, 
+0xF0, 0x90, 0x9F, 0xC2, 0xE0, 0xFF, 0xC3, 0x22, 0xF0, 0x90, 0x05, 0x62, 0xE0, 0xFE, 0x90, 0x05, 
+0x61, 0xE0, 0xFD, 0xED, 0x78, 0x02, 0x22, 0xE4, 0xFE, 0x74, 0xC4, 0x2E, 0x71, 0x38, 0xE4, 0xF0, 
+0x0E, 0xEE, 0xB4, 0x19, 0xF4, 0xE4, 0x90, 0x9F, 0xBD, 0xF0, 0x90, 0x9F, 0xC1, 0xF0, 0x90, 0x9F, 
+0xB9, 0xF0, 0xEF, 0xB4, 0x01, 0x09, 0x90, 0x9F, 0xC2, 0x74, 0x19, 0xF0, 0xE4, 0xA3, 0xF0, 0x22, 
+0xE4, 0xF5, 0x65, 0x90, 0x06, 0xA9, 0xE0, 0xF5, 0x65, 0x54, 0xC0, 0x70, 0x08, 0x71, 0xC7, 0x54, 
+0xFD, 0xF0, 0x02, 0x58, 0x4D, 0xE5, 0x65, 0x30, 0xE6, 0x19, 0x90, 0x9F, 0xA7, 0xE0, 0x64, 0x01, 
+0x70, 0x13, 0x12, 0x96, 0xDF, 0x64, 0x02, 0x60, 0x05, 0x12, 0x87, 0x74, 0x80, 0x07, 0x12, 0x97, 
+0x4B, 0x80, 0x02, 0x71, 0xC7, 0xE5, 0x65, 0x90, 0x9F, 0xAB, 0x30, 0xE7, 0x05, 0x12, 0x50, 0x03, 
+0x80, 0x7A, 0xE0, 0x54, 0xFD, 0xF0, 0x22, 0x90, 0x9F, 0xAB, 0xE0, 0x54, 0xFE, 0xF0, 0x22, 0x90, 
+0x06, 0xA9, 0xE0, 0x90, 0xA0, 0xE6, 0xF0, 0xE0, 0xFD, 0x54, 0xC0, 0x70, 0x04, 0x71, 0xC7, 0x80, 
+0x57, 0xED, 0x30, 0xE6, 0x41, 0x90, 0x9F, 0xA7, 0xE0, 0x64, 0x02, 0x70, 0x28, 0x90, 0x9F, 0xA3, 
+0xE0, 0xFF, 0xC3, 0x13, 0x20, 0xE0, 0x09, 0x90, 0x9F, 0xAB, 0xE0, 0x44, 0x01, 0xF0, 0x80, 0x1C, 
+0x12, 0x96, 0xE6, 0x64, 0x01, 0x70, 0x21, 0x90, 0x9F, 0xAB, 0xE0, 0x44, 0x04, 0xF0, 0x7F, 0x01, 
+0x12, 0x85, 0x52, 0x80, 0x13, 0x12, 0x96, 0xDF, 0x64, 0x02, 0x60, 0x05, 0x12, 0x87, 0x74, 0x80, 
+0x07, 0x12, 0x97, 0x4B, 0x80, 0x02, 0x71, 0xC7, 0x90, 0xA0, 0xE6, 0xE0, 0x90, 0x9F, 0xAB, 0x30, 
+0xE7, 0x05, 0x12, 0x50, 0x03, 0x80, 0x05, 0xE0, 0x54, 0xFD, 0xF0, 0x22, 0x90, 0x9F, 0xA3, 0xE0, 
+0x44, 0x04, 0xF0, 0x22, 0xAC, 0x07, 0x90, 0x9F, 0xA3, 0xE0, 0x30, 0xE0, 0x16, 0x90, 0x9F, 0xDD, 
+0xE0, 0x24, 0x04, 0x90, 0x9F, 0xBC, 0xF0, 0x90, 0x9F, 0xDD, 0xE0, 0x24, 0x03, 0x90, 0x9F, 0xBB, 
+0xF0, 0x80, 0x0B, 0x90, 0x9F, 0xBC, 0x74, 0x02, 0xF0, 0x90, 0x9F, 0xBB, 0x14, 0xF0, 0x90, 0x9F, 
+0xBB, 0xE0, 0xFA, 0x90, 0x9F, 0xBA, 0xE0, 0xD3, 0x9A, 0x50, 0x09, 0x90, 0x9F, 0xAF, 0xEB, 0x91, 
+0xA7, 0x2C, 0x80, 0x0B, 0xAD, 0x02, 0xC3, 0xED, 0x9D, 0x2B, 0x90, 0x9F, 0xAF, 0x91, 0xA7, 0x90, 
+0x9F, 0xBF, 0xF0, 0x90, 0x9F, 0xBF, 0xE0, 0xFF, 0x7E, 0x00, 0x90, 0x9F, 0xB3, 0xEE, 0xF0, 0xA3, 
+0xEF, 0xF0, 0x90, 0x05, 0x58, 0xF0, 0x22, 0xF0, 0x90, 0x9F, 0xBC, 0xE0, 0xC3, 0x9D, 0x22, 0xB1, 
+0x5E, 0x40, 0x1E, 0x90, 0x9F, 0xC1, 0xE0, 0x04, 0xF0, 0xE0, 0xFF, 0x94, 0x04, 0x50, 0x12, 0x90, 
+0x9F, 0xB9, 0xEF, 0xF0, 0x25, 0xE0, 0x24, 0x08, 0x90, 0x9F, 0xC0, 0xF0, 0xFB, 0xB1, 0x08, 0x91, 
+0x44, 0x22, 0xD1, 0x4A, 0x90, 0xA0, 0xF4, 0xEF, 0xF0, 0x30, 0xE0, 0x05, 0x7D, 0x01, 0xE4, 0x80, 
+0x02, 0xE4, 0xFD, 0xFF, 0x12, 0x5A, 0x74, 0x90, 0xA0, 0xF4, 0xE0, 0x30, 0xE6, 0x11, 0x90, 0x01, 
+0x2F, 0xE0, 0x30, 0xE7, 0x04, 0xE4, 0xF0, 0x80, 0x06, 0x90, 0x01, 0x2F, 0x74, 0x80, 0xF0, 0xB1, 
+0x08, 0x90, 0x9F, 0xC0, 0xE0, 0xFB, 0x81, 0x44, 0x90, 0x9F, 0xB9, 0xE0, 0xFF, 0xA3, 0xE0, 0xFD, 
+0x22, 0x90, 0x9F, 0xAD, 0xE0, 0x90, 0x05, 0x73, 0x22, 0x90, 0x9F, 0xAB, 0xE0, 0x44, 0x10, 0xF0, 
+0x22, 0x90, 0x01, 0x57, 0xE4, 0xF0, 0x90, 0x01, 0x3C, 0x74, 0x02, 0x22, 0x90, 0x01, 0x57, 0xE0, 
+0x60, 0x1E, 0xB1, 0x24, 0xF0, 0x90, 0x9F, 0xA3, 0x12, 0x75, 0x00, 0x30, 0xE0, 0x03, 0x02, 0x97, 
+0xCA, 0xB1, 0x51, 0x40, 0x0B, 0xE4, 0xFF, 0x12, 0x50, 0x60, 0xBF, 0x01, 0x03, 0x12, 0x97, 0xB4, 
+0x22, 0x90, 0x9F, 0xB0, 0xE0, 0x04, 0xF0, 0x90, 0x9F, 0xAB, 0xE0, 0x54, 0xEF, 0xF0, 0x90, 0xA0, 
+0x4B, 0xE0, 0xFF, 0x90, 0x9F, 0xB0, 0xE0, 0xD3, 0x9F, 0x22, 0x90, 0x9F, 0x9E, 0xE0, 0xFF, 0x30, 
+0xE0, 0x3E, 0x90, 0x9F, 0xA2, 0xE0, 0x7E, 0x00, 0xB4, 0x02, 0x02, 0x7E, 0x01, 0x90, 0x9F, 0xA1, 
+0xE0, 0x7D, 0x00, 0xB4, 0x04, 0x02, 0x7D, 0x01, 0xED, 0x4E, 0x70, 0x24, 0xEF, 0xC3, 0x13, 0x30, 
+0xE0, 0x02, 0x80, 0x1D, 0xB1, 0x2C, 0x90, 0x9F, 0xA2, 0xE0, 0xB4, 0x0C, 0x06, 0xE4, 0xFD, 0x7F, 
+0x08, 0x80, 0x0A, 0x90, 0x9F, 0xA2, 0xE0, 0xB4, 0x04, 0x06, 0xE4, 0xFD, 0xFF, 0x12, 0x58, 0x65, 
+0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x9F, 0x9D, 0xE0, 0xB4, 0x01, 0x04, 0x7F, 
+0x04, 0x80, 0x0C, 0x12, 0x5E, 0xD3, 0xBF, 0x01, 0x04, 0x7F, 0x01, 0x80, 0x02, 0x7F, 0x02, 0x12, 
+0x5C, 0x4A, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xF0, 0x90, 0x9F, 0xB3, 0xA3, 0xE0, 0x90, 0x05, 0x58, 
+0xF0, 0x22, 0xFF, 0xEE, 0x54, 0x3F, 0x90, 0x9F, 0xE2, 0xF0, 0xA3, 0xEF, 0x22, 0xE4, 0xFF, 0x12, 
+0x50, 0x60, 0xBF, 0x01, 0x0F, 0x90, 0x9F, 0xA7, 0xE0, 0x60, 0x09, 0x71, 0xC7, 0x54, 0x07, 0x70, 
+0x03, 0x12, 0x58, 0x4D, 0x22, 0x12, 0x50, 0x58, 0x70, 0x17, 0x90, 0x9F, 0xA7, 0xE0, 0x60, 0x11, 
+0xB1, 0x21, 0xF0, 0x90, 0x9F, 0xA3, 0xE0, 0x12, 0x97, 0xCB, 0x54, 0x07, 0x70, 0x03, 0x12, 0x58, 
+0x4D, 0x22, 0x90, 0x9F, 0x9E, 0xE0, 0xFF, 0x30, 0xE0, 0x05, 0x12, 0x97, 0x2A, 0x60, 0x1A, 0x90, 
+0x9F, 0xA7, 0xE0, 0x70, 0x04, 0xEF, 0x30, 0xE0, 0x0A, 0x90, 0x9F, 0xAA, 0xE0, 0x64, 0x02, 0x60, 
+0x08, 0x31, 0x8E, 0x90, 0x01, 0xE6, 0xE0, 0x04, 0xF0, 0x22, 0xE4, 0x90, 0xA0, 0xF5, 0xF0, 0xA3, 
+0xF0, 0xA3, 0xF0, 0x7F, 0x83, 0x12, 0x4A, 0xB8, 0x90, 0xA0, 0xF5, 0xEF, 0xF0, 0x7F, 0x83, 0x12, 
+0x4A, 0xB8, 0xAE, 0x07, 0x90, 0xA0, 0xF5, 0xE0, 0xFF, 0xB5, 0x06, 0x01, 0x22, 0xC3, 0x90, 0xA0, 
+0xF7, 0xE0, 0x94, 0x64, 0x90, 0xA0, 0xF6, 0xE0, 0x94, 0x00, 0x40, 0x0D, 0x90, 0x01, 0xC0, 0xE0, 
+0x44, 0x40, 0xF0, 0x90, 0xA0, 0xF5, 0xE0, 0xFF, 0x22, 0x90, 0xA0, 0xF6, 0x12, 0x79, 0x84, 0x80, 
+0xC2, 0x90, 0x9F, 0x9E, 0xE0, 0xFF, 0x30, 0xE0, 0x3E, 0x90, 0x9F, 0xA2, 0xE0, 0x7E, 0x00, 0xB4, 
+0x02, 0x02, 0x7E, 0x01, 0x90, 0x9F, 0xA1, 0xE0, 0x7D, 0x00, 0xB4, 0x04, 0x02, 0x7D, 0x01, 0xED, 
+0x4E, 0x70, 0x24, 0xEF, 0xC3, 0x13, 0x30, 0xE0, 0x02, 0xA1, 0xB1, 0x12, 0x97, 0x12, 0x90, 0x9F, 
+0xA2, 0xE0, 0xB4, 0x08, 0x06, 0xE4, 0xFD, 0x7F, 0x0C, 0x80, 0x09, 0x90, 0x9F, 0xA2, 0xE0, 0x70, 
+0x06, 0xFD, 0x7F, 0x04, 0x12, 0x58, 0x65, 0x22, 0x90, 0x9F, 0xA7, 0xE0, 0x70, 0x07, 0x90, 0x9F, 
+0x9E, 0xE0, 0x30, 0xE0, 0x13, 0x90, 0x9F, 0x9E, 0xE0, 0x30, 0xE0, 0x09, 0x12, 0x5E, 0xD3, 0xBF, 
+0x01, 0x06, 0x02, 0x96, 0xC7, 0x12, 0x96, 0xED, 0x22, 0x90, 0x9F, 0xA7, 0xE0, 0x60, 0x10, 0x90, 
+0x06, 0x92, 0xE0, 0x30, 0xE1, 0x03, 0x02, 0x97, 0xD6, 0x12, 0x5F, 0xB5, 0x12, 0x58, 0x4D, 0x22, 
+0x90, 0x9F, 0xA3, 0xE0, 0xFF, 0x12, 0x76, 0xBF, 0x30, 0xE0, 0x1F, 0xEF, 0x54, 0x7F, 0xF1, 0x62, 
+0x30, 0xE1, 0x06, 0xE0, 0x44, 0x02, 0xF0, 0x80, 0x08, 0xE0, 0x54, 0xFD, 0x12, 0x57, 0xF8, 0x04, 
+0xF0, 0x90, 0x9F, 0xA7, 0xE0, 0x60, 0x03, 0x12, 0x58, 0x4D, 0x12, 0x74, 0x7D, 0x30, 0xE0, 0x21, 
+0x90, 0xA0, 0x66, 0xE0, 0xFF, 0xC3, 0x13, 0x30, 0xE0, 0x17, 0xEF, 0x54, 0xFD, 0xF0, 0x90, 0x04, 
+0xE0, 0xE0, 0x90, 0xA0, 0x66, 0x30, 0xE1, 0x05, 0xE0, 0x44, 0x04, 0xF0, 0x22, 0xE0, 0x54, 0xFB, 
+0xF0, 0x22, 0xF0, 0x90, 0x04, 0xE0, 0xE0, 0x90, 0x9F, 0xA4, 0x22, 0x90, 0x01, 0xC4, 0x74, 0x6B, 
+0xF0, 0x74, 0x9F, 0xA3, 0xF0, 0x7F, 0x90, 0x12, 0x4A, 0xB8, 0xEF, 0x20, 0xE0, 0xF7, 0x74, 0x6B, 
+0x04, 0x90, 0x01, 0xC4, 0xF0, 0x74, 0x9F, 0xA3, 0xF0, 0x22, 0x7E, 0xFF, 0xED, 0xC3, 0x94, 0x33, 
+0x40, 0x19, 0xED, 0xD3, 0x94, 0x35, 0x50, 0x13, 0x75, 0xF0, 0x04, 0xEF, 0x12, 0x4F, 0xA1, 0xC4, 
+0x13, 0x54, 0x07, 0x30, 0xE0, 0x05, 0xED, 0x14, 0x44, 0x80, 0xFE, 0xED, 0x14, 0xFD, 0x12, 0x6F, 
+0xC0, 0xED, 0xF0, 0xAF, 0x06, 0x22, 0xED, 0x54, 0x7F, 0xFC, 0xED, 0x54, 0x80, 0x60, 0x03, 0xAF, 
+0x04, 0x22, 0xEC, 0xC3, 0x94, 0x33, 0x40, 0x1E, 0xEC, 0xD3, 0x94, 0x35, 0x50, 0x18, 0x75, 0xF0, 
+0x04, 0xEF, 0x12, 0x4F, 0xA1, 0xC4, 0x13, 0x54, 0x07, 0x30, 0xE0, 0x06, 0xEC, 0x44, 0x80, 0xFE, 
+0x80, 0x06, 0x7E, 0xFF, 0x80, 0x02, 0x7E, 0xFF, 0xAF, 0x06, 0x22, 0x90, 0xA1, 0x2A, 0xEB, 0xF0, 
+0x70, 0x5F, 0x90, 0xA1, 0x2A, 0xE0, 0xFE, 0x12, 0xA0, 0x52, 0xE0, 0xFC, 0x90, 0xA1, 0x2B, 0xE0, 
+0xFB, 0xEC, 0x6B, 0x60, 0x4C, 0x90, 0xA1, 0x2F, 0xEB, 0xF0, 0xA3, 0xEE, 0xF0, 0xAE, 0x05, 0xEE, 
+0x25, 0xE0, 0x4F, 0xFF, 0x90, 0x9E, 0x91, 0xE0, 0xFE, 0x25, 0xE0, 0x25, 0xE0, 0x4F, 0x90, 0xA1, 
+0x31, 0xF0, 0x90, 0xA1, 0x2C, 0xE0, 0x90, 0xA1, 0x33, 0xF0, 0x90, 0xA1, 0x2D, 0x74, 0x0C, 0xF0, 
+0x90, 0xA1, 0x3B, 0x74, 0x04, 0xF0, 0x7B, 0x01, 0x7A, 0xA1, 0x79, 0x2D, 0x12, 0x63, 0x89, 0x7F, 
+0x04, 0x12, 0x65, 0x78, 0x90, 0xA1, 0x2B, 0xE0, 0xFF, 0x90, 0xA1, 0x2A, 0xE0, 0x11, 0x52, 0xEF, 
+0xF0, 0x22, 0x24, 0x11, 0xF5, 0x82, 0xE4, 0x34, 0x99, 0xF5, 0x83, 0x22, 0xEF, 0x60, 0x0A, 0xED, 
+0xC3, 0x94, 0x2C, 0x40, 0x04, 0x7E, 0x20, 0x80, 0x02, 0xE4, 0xFE, 0xC3, 0xED, 0x9E, 0xFF, 0x22, 
+0x8F, 0x5E, 0x75, 0xF0, 0x10, 0xEF, 0x12, 0x57, 0x73, 0xE0, 0xF5, 0x5F, 0xE4, 0xF5, 0x64, 0xE5, 
+0x5F, 0x54, 0x7F, 0xF5, 0x60, 0xE5, 0x5F, 0x54, 0x80, 0xFF, 0x75, 0xF0, 0x04, 0xE5, 0x5E, 0x12, 
+0x6F, 0x7E, 0xE0, 0xF5, 0x62, 0x75, 0xF0, 0x04, 0xE5, 0x5E, 0x12, 0x4E, 0x2B, 0xFE, 0xC4, 0x54, 
+0x03, 0xF5, 0x63, 0xE5, 0x60, 0x71, 0x7C, 0xB1, 0x3F, 0x12, 0x56, 0xC8, 0xEC, 0xF0, 0xA3, 0xED, 
+0xF0, 0xE5, 0x5F, 0x4F, 0xFF, 0x74, 0x91, 0x25, 0x5E, 0x12, 0x6F, 0xC3, 0xEF, 0xF0, 0x75, 0xF0, 
+0x04, 0xE5, 0x5E, 0x12, 0x4E, 0x2B, 0x13, 0x13, 0x54, 0x03, 0xF5, 0x61, 0x74, 0x91, 0x25, 0x5E, 
+0xB1, 0x19, 0xE5, 0x61, 0xF0, 0x12, 0x7D, 0xFF, 0xE0, 0x30, 0xE0, 0x20, 0xE5, 0x60, 0x64, 0x3F, 
+0x70, 0x1A, 0x12, 0x4F, 0x99, 0xC4, 0x13, 0x54, 0x07, 0x30, 0xE0, 0x05, 0x75, 0x5F, 0xBE, 0x80, 
+0x03, 0x85, 0x60, 0x5F, 0x85, 0x61, 0x6C, 0xE4, 0xFB, 0x12, 0x6C, 0x17, 0xAD, 0x5F, 0xAF, 0x5E, 
+0x12, 0x9F, 0xB6, 0xEF, 0xF4, 0x60, 0x0B, 0x8F, 0x5F, 0xEF, 0x30, 0xE7, 0x02, 0x61, 0x5D, 0x85, 
+0x5F, 0x60, 0xE5, 0x60, 0x64, 0x2D, 0x70, 0x2E, 0x75, 0xF0, 0x04, 0xE5, 0x5E, 0x12, 0x4E, 0x2B, 
+0xFF, 0x54, 0x03, 0xFE, 0xE5, 0x61, 0xC3, 0x9E, 0x50, 0x1C, 0x75, 0x5F, 0x2C, 0x05, 0x61, 0xE5, 
+0x61, 0xB1, 0x0A, 0xFE, 0x75, 0xF0, 0x04, 0xE5, 0x5E, 0x90, 0x96, 0x14, 0x12, 0x49, 0x22, 0xEF, 
+0x54, 0xF3, 0x4E, 0xF0, 0x61, 0x5D, 0xE5, 0x60, 0xB4, 0x2C, 0x05, 0x75, 0x5F, 0x2D, 0x61, 0x5D, 
+0xE5, 0x60, 0xC3, 0x95, 0x62, 0x40, 0x02, 0x61, 0x25, 0xE5, 0x60, 0xC3, 0x94, 0x0C, 0x40, 0x13, 
+0xE5, 0x60, 0x94, 0x13, 0x50, 0x0D, 0x12, 0x7D, 0xFF, 0xE0, 0xFF, 0x20, 0xE3, 0x05, 0x75, 0x64, 
+0x01, 0x80, 0x18, 0xE5, 0x60, 0xC3, 0x94, 0x2C, 0x40, 0x1A, 0xE5, 0x60, 0x94, 0x35, 0x50, 0x14, 
+0x12, 0x7D, 0xFF, 0xE0, 0xFF, 0x20, 0xE3, 0x0C, 0x75, 0x64, 0x02, 0x12, 0x7D, 0xFF, 0xEF, 0x44, 
+0x08, 0xF0, 0x80, 0x07, 0x12, 0x7D, 0xFC, 0xE0, 0x54, 0xF7, 0xF0, 0x12, 0x7D, 0xFF, 0xE0, 0x20, 
+0xE6, 0x03, 0x30, 0xE1, 0x07, 0x12, 0x7D, 0xFC, 0xE0, 0x54, 0xF7, 0xF0, 0xE5, 0x64, 0x64, 0x01, 
+0x70, 0x70, 0x71, 0x60, 0x20, 0xE7, 0x0E, 0x20, 0xE6, 0x0B, 0x20, 0xE5, 0x08, 0x20, 0xE4, 0x05, 
+0x71, 0x6D, 0x30, 0xE0, 0x5D, 0x12, 0x7D, 0xFF, 0xE0, 0x44, 0x04, 0xF0, 0xE5, 0x60, 0xB4, 0x0C, 
+0x08, 0x75, 0x60, 0x14, 0x75, 0x5F, 0x14, 0x41, 0x9C, 0xE5, 0x60, 0xB4, 0x0D, 0x02, 0x80, 0x05, 
+0xE5, 0x60, 0xB4, 0x0E, 0x08, 0x75, 0x60, 0x15, 0x75, 0x5F, 0x15, 0x41, 0x9C, 0xE5, 0x60, 0xB4, 
+0x0F, 0x08, 0x75, 0x60, 0x16, 0x75, 0x5F, 0x16, 0x41, 0x9C, 0xE5, 0x60, 0xC3, 0x94, 0x10, 0x40, 
+0x08, 0x75, 0x60, 0x17, 0x75, 0x5F, 0x17, 0x41, 0x9C, 0xE5, 0x60, 0xC3, 0x94, 0x11, 0x50, 0x02, 
+0x41, 0x9C, 0xE5, 0x60, 0x94, 0x13, 0x40, 0x02, 0x41, 0x9C, 0x75, 0x60, 0x18, 0x75, 0x5F, 0x18, 
+0x80, 0x7A, 0xE5, 0x64, 0x64, 0x02, 0x70, 0x79, 0x71, 0x60, 0x20, 0xE6, 0x0E, 0x20, 0xE7, 0x0B, 
+0x71, 0x6D, 0x20, 0xE0, 0x06, 0x20, 0xE1, 0x03, 0x30, 0xE2, 0x66, 0xE5, 0x60, 0x64, 0x2C, 0x60, 
+0x05, 0xE5, 0x60, 0xB4, 0x2D, 0x08, 0x75, 0x60, 0x36, 0x75, 0x5F, 0x36, 0x80, 0x4E, 0xE5, 0x60, 
+0x64, 0x2E, 0x60, 0x05, 0xE5, 0x60, 0xB4, 0x2F, 0x08, 0x75, 0x60, 0x37, 0x75, 0x5F, 0x37, 0x80, 
+0x3B, 0xE5, 0x60, 0xB4, 0x30, 0x08, 0x75, 0x60, 0x38, 0x75, 0x5F, 0x38, 0x80, 0x2E, 0xE5, 0x60, 
+0xB4, 0x31, 0x08, 0x75, 0x60, 0x39, 0x75, 0x5F, 0x39, 0x80, 0x21, 0xE5, 0x60, 0xC3, 0x94, 0x32, 
+0x40, 0x0F, 0xE5, 0x60, 0xD3, 0x94, 0x34, 0x50, 0x08, 0x75, 0x60, 0x3A, 0x75, 0x5F, 0x3A, 0x80, 
+0x0B, 0xE5, 0x60, 0xB4, 0x35, 0x06, 0x75, 0x60, 0x3B, 0x75, 0x5F, 0x3B, 0x12, 0x6C, 0x12, 0x80, 
+0x07, 0x12, 0x7D, 0xFF, 0xE0, 0x54, 0xFB, 0xF0, 0xAD, 0x60, 0xAF, 0x63, 0x11, 0x5C, 0x8F, 0x60, 
+0xAD, 0x62, 0xAF, 0x63, 0x11, 0x5C, 0x8F, 0x62, 0xE5, 0x60, 0x04, 0xFD, 0xED, 0xD3, 0x95, 0x62, 
+0x50, 0x3A, 0xB1, 0x21, 0xE5, 0x5E, 0x12, 0x4F, 0xB0, 0xE0, 0xFB, 0x7A, 0x00, 0x12, 0x6F, 0xCB, 
+0x80, 0x05, 0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 0xF9, 0x12, 0x8F, 0x87, 0x60, 0x1B, 0xE5, 0x60, 
+0xB4, 0x13, 0x0F, 0x75, 0x60, 0x18, 0x85, 0x60, 0x5F, 0x12, 0x7D, 0xFF, 0xE0, 0x44, 0x04, 0xF0, 
+0x80, 0x0A, 0x8D, 0x60, 0x85, 0x60, 0x5F, 0x80, 0x03, 0x0D, 0x80, 0xC0, 0xAD, 0x5F, 0xAF, 0x63, 
+0xB1, 0x2C, 0x8F, 0x5F, 0x12, 0x7D, 0xFF, 0xE0, 0x30, 0xE0, 0x52, 0xE5, 0x60, 0x64, 0x3F, 0x70, 
+0x4C, 0x12, 0x4F, 0x99, 0xC4, 0x13, 0x54, 0x07, 0x30, 0xE0, 0x05, 0x75, 0x5F, 0xBE, 0x80, 0x3D, 
+0x85, 0x60, 0x5F, 0x80, 0x38, 0xE5, 0x60, 0x65, 0x62, 0x70, 0x26, 0x12, 0x4F, 0x9C, 0xC4, 0x13, 
+0x54, 0x07, 0x30, 0xE0, 0x0D, 0xE5, 0x5F, 0x20, 0xE7, 0x08, 0xE5, 0x60, 0x44, 0x80, 0xF5, 0x5F, 
+0x80, 0x1B, 0xE5, 0x60, 0x71, 0x7C, 0xB1, 0x11, 0x12, 0x56, 0xC8, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 
+0x22, 0x74, 0x91, 0x25, 0x5E, 0x12, 0x6F, 0xC3, 0xE5, 0x62, 0xF0, 0xF5, 0x5F, 0x02, 0x6C, 0x12, 
+0x75, 0xF0, 0x08, 0xE5, 0x5E, 0x90, 0x89, 0x02, 0x12, 0x49, 0x22, 0xE0, 0x22, 0x75, 0xF0, 0x08, 
+0xE5, 0x5E, 0x90, 0x89, 0x03, 0x12, 0x49, 0x22, 0xE0, 0x22, 0xE5, 0x53, 0x25, 0xE0, 0x24, 0x4F, 
+0xF5, 0x82, 0xE4, 0x34, 0x42, 0xF5, 0x83, 0x22, 0xAA, 0x07, 0xAB, 0x05, 0x75, 0xF0, 0x10, 0xEA, 
+0x12, 0x57, 0x73, 0xE0, 0xF5, 0x5E, 0x54, 0x7F, 0xF5, 0x60, 0x75, 0xF0, 0x04, 0xEA, 0x12, 0x4F, 
+0xEE, 0xE0, 0xF9, 0x75, 0xF0, 0x04, 0xEA, 0x12, 0x6F, 0x7E, 0xE0, 0xFC, 0x75, 0xF0, 0x04, 0xEA, 
+0x12, 0x4E, 0x2B, 0x13, 0x13, 0x54, 0x03, 0xF5, 0x5F, 0xE5, 0x60, 0xB1, 0x49, 0xB1, 0x11, 0xEA, 
+0x12, 0x56, 0xCA, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x75, 0xF0, 0x04, 0xEA, 0x12, 0x4E, 0x2B, 0xC4, 
+0x54, 0x03, 0x90, 0xA0, 0xDA, 0xF0, 0x74, 0x91, 0x2A, 0x12, 0x6F, 0xC3, 0xE5, 0x60, 0xF0, 0x74, 
+0x91, 0x2A, 0xB1, 0x19, 0xE5, 0x5F, 0xF0, 0xE5, 0x60, 0xD3, 0x9C, 0x40, 0x06, 0x8C, 0x60, 0xAF, 
+0x04, 0x8F, 0x5E, 0xEB, 0x70, 0x02, 0x81, 0xFE, 0xAF, 0x03, 0x8F, 0x61, 0xE5, 0x5E, 0x30, 0xE7, 
+0x05, 0x85, 0x60, 0x5E, 0x15, 0x61, 0xE5, 0x61, 0x70, 0x02, 0x81, 0xFE, 0xAF, 0x02, 0xAD, 0x5E, 
+0x12, 0x9F, 0x8A, 0xEF, 0xF4, 0x60, 0x0A, 0x8F, 0x5E, 0x15, 0x61, 0xE5, 0x61, 0x70, 0x02, 0x81, 
+0xFE, 0xE5, 0x5E, 0x64, 0x2C, 0x70, 0x2B, 0xE5, 0x5F, 0xD3, 0x94, 0x00, 0x40, 0x24, 0xE5, 0x5F, 
+0xD3, 0x94, 0x02, 0x50, 0x1D, 0x15, 0x5F, 0x75, 0x5E, 0x2D, 0xE5, 0x5F, 0xB1, 0x0A, 0xFF, 0x75, 
+0xF0, 0x04, 0xEA, 0x12, 0x4E, 0x2B, 0x54, 0xF3, 0x4F, 0xF0, 0x15, 0x61, 0xE5, 0x61, 0x70, 0x02, 
+0x81, 0xFE, 0xE5, 0x5E, 0xB4, 0x2D, 0x12, 0xE5, 0x5F, 0xD3, 0x94, 0x02, 0x50, 0x0B, 0x75, 0x5E, 
+0x2C, 0x15, 0x61, 0xE5, 0x61, 0x70, 0x02, 0x81, 0xFE, 0xE5, 0x61, 0x70, 0x02, 0x81, 0xFE, 0xE5, 
+0x60, 0xD3, 0x99, 0x50, 0x02, 0x81, 0xFA, 0xE4, 0x90, 0xA0, 0xDB, 0xF0, 0x90, 0xA0, 0xDA, 0xE0, 
+0xFF, 0xAD, 0x60, 0x11, 0x5C, 0x8F, 0x60, 0x85, 0x60, 0x5E, 0xE0, 0xFF, 0xAD, 0x01, 0x11, 0x5C, 
+0xA9, 0x07, 0x90, 0xA0, 0xDC, 0xE5, 0x5E, 0xF0, 0xE5, 0x60, 0x14, 0xFD, 0xED, 0xC3, 0x99, 0x40, 
+0x46, 0xB1, 0x21, 0xEA, 0x12, 0x4F, 0xB0, 0xE0, 0xF5, 0x82, 0x75, 0x83, 0x00, 0x12, 0x6F, 0xCB, 
+0x80, 0x05, 0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 0xF9, 0xFF, 0xEE, 0x55, 0x83, 0xFE, 0xEF, 0x55, 
+0x82, 0x4E, 0x60, 0x20, 0xE5, 0x60, 0x90, 0xA0, 0xDC, 0xB4, 0x14, 0x05, 0x74, 0x0C, 0xF0, 0x80, 
+0x02, 0xED, 0xF0, 0x90, 0xA0, 0xDB, 0xE0, 0x04, 0xF0, 0xE0, 0x65, 0x61, 0x60, 0x09, 0xA3, 0xE0, 
+0xD3, 0x99, 0x40, 0x03, 0x1D, 0x80, 0xB5, 0x90, 0xA0, 0xDC, 0xE0, 0xF5, 0x5E, 0x90, 0xA0, 0xDA, 
+0xE0, 0xFF, 0xAD, 0x5E, 0xB1, 0x2C, 0x8F, 0x5E, 0x80, 0x04, 0xAF, 0x01, 0x8F, 0x5E, 0xAF, 0x02, 
+0x85, 0x5F, 0x6C, 0xE4, 0xFB, 0xAD, 0x5E, 0x02, 0x6C, 0x1B, 0x54, 0x03, 0x25, 0xE0, 0x25, 0xE0, 
+0x22, 0xE4, 0x93, 0xFE, 0x74, 0x01, 0x93, 0xFF, 0x22, 0xF5, 0x82, 0xE4, 0x34, 0x9B, 0xF5, 0x83, 
+0x22, 0xED, 0x13, 0x13, 0x13, 0x54, 0x1F, 0xFF, 0x75, 0xF0, 0x08, 0x22, 0xEF, 0x60, 0x0A, 0xED, 
+0xD3, 0x94, 0x0B, 0x40, 0x04, 0x7E, 0x20, 0x80, 0x02, 0xE4, 0xFE, 0xED, 0x2E, 0xFF, 0x22, 0xE4, 
+0x93, 0xFC, 0x74, 0x01, 0x93, 0xFD, 0x22, 0xE5, 0x53, 0x25, 0xE0, 0x24, 0xF7, 0xF5, 0x82, 0xE4, 
+0x34, 0x42, 0xF5, 0x83, 0x22, 0xE4, 0xF5, 0x5E, 0x74, 0x91, 0x2F, 0x12, 0x6B, 0xFA, 0xE0, 0xFE, 
+0xB4, 0x05, 0x08, 0xED, 0xC3, 0x94, 0x3B, 0x40, 0x51, 0x80, 0x47, 0xEE, 0xB4, 0x04, 0x08, 0xED, 
+0xC3, 0x94, 0x31, 0x40, 0x45, 0x80, 0x3B, 0x74, 0x91, 0x2F, 0x12, 0x6B, 0xFA, 0xE0, 0xFE, 0xB4, 
+0x03, 0x08, 0xED, 0xC3, 0x94, 0x19, 0x40, 0x32, 0x80, 0x28, 0xEE, 0xB4, 0x02, 0x08, 0xED, 0xC3, 
+0x94, 0x11, 0x40, 0x26, 0x80, 0x1C, 0x74, 0x91, 0x2F, 0x12, 0x6B, 0xFA, 0xE0, 0xFE, 0xB4, 0x01, 
+0x08, 0xED, 0xC3, 0x94, 0x0A, 0x40, 0x13, 0x80, 0x09, 0xEE, 0x70, 0x0B, 0xED, 0xC3, 0x94, 0x03, 
+0x40, 0x08, 0x75, 0x5E, 0x01, 0x80, 0x03, 0xE4, 0xF5, 0x5E, 0xAF, 0x5E, 0x22, 0x8F, 0x52, 0x8D, 
+0x53, 0x8B, 0x54, 0x75, 0xF0, 0x04, 0xEF, 0x12, 0x4E, 0x2B, 0xC4, 0x54, 0x03, 0x90, 0xA0, 0xCF, 
+0xF0, 0x90, 0xA0, 0xCD, 0x60, 0x09, 0x74, 0x32, 0xF0, 0xA3, 0x74, 0x2F, 0xF0, 0x80, 0x07, 0x74, 
+0x11, 0xF0, 0xA3, 0x74, 0x0F, 0xF0, 0xE5, 0x53, 0xD3, 0x94, 0x2D, 0x40, 0x0A, 0x75, 0xF0, 0x04, 
+0xE5, 0x52, 0x12, 0x6F, 0x7E, 0x80, 0x20, 0xE5, 0x53, 0xD3, 0x94, 0x1E, 0x40, 0x05, 0x90, 0xA0, 
+0xCD, 0x80, 0x14, 0xE5, 0x53, 0xD3, 0x94, 0x14, 0x40, 0x05, 0x90, 0xA0, 0xCE, 0x80, 0x08, 0x75, 
+0xF0, 0x04, 0xE5, 0x52, 0x12, 0x4F, 0xEE, 0xE0, 0xFD, 0x85, 0x54, 0x6C, 0xE4, 0xFB, 0xAF, 0x52, 
+0x02, 0x6C, 0x1B, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0xA1, 0x3C, 0xEE, 0xF0, 0xA3, 
+0xEF, 0xF0, 0x12, 0x37, 0xBC, 0x90, 0xA1, 0x46, 0x12, 0x08, 0x6D, 0x90, 0xA1, 0x3E, 0x12, 0x49, 
+0x0A, 0x12, 0x08, 0x3A, 0x90, 0xA1, 0x46, 0x12, 0x49, 0x16, 0x12, 0x48, 0xF0, 0xC0, 0x04, 0xC0, 
+0x05, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0xA1, 0x3E, 0x12, 0x49, 0x0A, 0x90, 0xA1, 0x42, 0x12, 0x49, 
+0x16, 0x12, 0x48, 0xF0, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0x12, 0x48, 0xFD, 0x90, 
+0xA1, 0x4A, 0x12, 0x08, 0x6D, 0x90, 0xA1, 0x4A, 0x12, 0x4D, 0x2B, 0x90, 0xA1, 0x3C, 0xE0, 0xFE, 
+0xA3, 0xE0, 0xFF, 0x12, 0x38, 0x07, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x7E, 0x00, 0x7F, 0x01, 0x7D, 
+0x00, 0x7B, 0x01, 0x7A, 0x9F, 0x79, 0x9E, 0x12, 0x08, 0xAA, 0x90, 0x9F, 0x9E, 0xE0, 0x54, 0xFD, 
+0xF0, 0xE4, 0x12, 0x4F, 0x8D, 0xA3, 0x74, 0x0C, 0xF0, 0x22, 0x7D, 0x21, 0x7F, 0xFF, 0x12, 0x57, 
+0x8F, 0x90, 0x9F, 0xA1, 0x74, 0x03, 0xF0, 0x22, 0x12, 0x5F, 0xDE, 0x80, 0xED, 0x12, 0x4C, 0x71, 
+0x80, 0xEF, 0x7D, 0x22, 0x7F, 0xFF, 0x12, 0x57, 0x8F, 0x12, 0x5E, 0x7A, 0x80, 0xE3, 0x90, 0x9F, 
+0xA3, 0xE0, 0x54, 0xFB, 0xF0, 0xE4, 0x90, 0x9F, 0xB0, 0xF0, 0xA3, 0xF0, 0x90, 0x9F, 0xAB, 0xF0, 
+0x90, 0x9F, 0xA4, 0xE0, 0x54, 0xF7, 0xF0, 0x54, 0xBF, 0x12, 0x5F, 0x99, 0x7D, 0x10, 0x7F, 0x03, 
+0x02, 0x5F, 0xBD, 0x90, 0xA0, 0xCD, 0x12, 0x49, 0x37, 0xD1, 0xCE, 0x90, 0x9F, 0xA7, 0xE0, 0xFF, 
+0x12, 0x5F, 0x29, 0x90, 0x9F, 0xA7, 0xE0, 0x60, 0x12, 0x90, 0xA0, 0xCD, 0x12, 0x49, 0x2E, 0x12, 
+0x66, 0xFC, 0x54, 0x0F, 0xFF, 0x12, 0x67, 0x36, 0xFD, 0xF1, 0x1C, 0x22, 0xEF, 0x24, 0xFE, 0x60, 
+0x0B, 0x04, 0x70, 0x24, 0x90, 0x9F, 0xAD, 0x74, 0x02, 0xF0, 0x80, 0x13, 0xED, 0x70, 0x06, 0x90, 
+0xA0, 0x4E, 0xE0, 0x80, 0x02, 0xED, 0x14, 0x90, 0x9F, 0xAD, 0xF0, 0x90, 0x9F, 0xAD, 0xE0, 0xA3, 
+0xF0, 0x90, 0x9F, 0xA4, 0xE0, 0x44, 0x08, 0xF0, 0x22, 0x7D, 0x2D, 0x12, 0x77, 0x3D, 0x90, 0x01, 
+0x37, 0x74, 0x02, 0xF0, 0xFD, 0x7F, 0x03, 0x12, 0x5F, 0xA4, 0x12, 0x4A, 0xDA, 0xE4, 0xFD, 0x7F, 
+0x01, 0x12, 0x5A, 0x74, 0xE4, 0x90, 0x9F, 0xA2, 0xF0, 0x22, 0x7D, 0x2E, 0x7F, 0x6F, 0x12, 0x57, 
+0x8F, 0x7D, 0x02, 0x7F, 0x01, 0x12, 0x5A, 0x74, 0xF1, 0x81, 0x90, 0x9F, 0xA2, 0x74, 0x02, 0xF0, 
+0x22, 0x90, 0x05, 0x27, 0xE0, 0x54, 0xBF, 0xF0, 0x22, 0x90, 0xA0, 0x5B, 0xE0, 0x90, 0x01, 0x30, 
+0xF0, 0x90, 0xA0, 0x58, 0xE0, 0x90, 0x01, 0x39, 0xF0, 0x90, 0xA0, 0x59, 0xE0, 0x90, 0x01, 0x3A, 
+0xF0, 0x22, 0x90, 0xA1, 0xA7, 0xE0, 0xFF, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0xA1, 
+0xEF, 0xEF, 0xF0, 0x90, 0x9E, 0x9A, 0xE0, 0xFF, 0x90, 0x04, 0x1C, 0xE0, 0x6F, 0x70, 0x3F, 0x90, 
+0x9F, 0xAA, 0xE0, 0x64, 0x0E, 0x70, 0x15, 0x90, 0xA1, 0xEF, 0xE0, 0x70, 0x31, 0x90, 0x9F, 0xA3, 
+0xE0, 0x54, 0x7F, 0xF0, 0x90, 0x06, 0x04, 0x12, 0x5A, 0x6C, 0x80, 0x1F, 0x90, 0x9F, 0xAA, 0xE0, 
+0x64, 0x06, 0x70, 0x1A, 0x90, 0xA1, 0xEF, 0xE0, 0x60, 0x14, 0x90, 0x9F, 0xA3, 0xE0, 0x54, 0xBF, 
+0xF0, 0x12, 0xA8, 0x03, 0xF0, 0x90, 0x9F, 0xAA, 0x74, 0x04, 0xF0, 0x12, 0x5E, 0x36, 0xD0, 0xD0, 
+0x92, 0xAF, 0x22, 0x90, 0x06, 0x04, 0xE0, 0x44, 0x40, 0xF0, 0xE0, 0x44, 0x80, 0x22, 0xF0, 0xEF, 
+0x25, 0xE0, 0x24, 0x01, 0xF5, 0x82, 0xE4, 0x34, 0x92, 0xF5, 0x83, 0xE4, 0xF0, 0xA3, 0xF0, 0x74, 
+0x91, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x98, 0xF5, 0x83, 0x22, 0x7F, 0xA3, 0x12, 0x4A, 0xB8, 0xEF, 
+0x54, 0xF8, 0x44, 0x05, 0xFD, 0x7F, 0xA3, 0x12, 0x49, 0x90, 0x7F, 0xA0, 0x12, 0x4A, 0xB8, 0xEF, 
+0x54, 0x0F, 0x64, 0x04, 0x22, 0x12, 0x37, 0xBC, 0xEF, 0x44, 0x03, 0xFF, 0xEC, 0x90, 0xA1, 0x96, 
+0x12, 0x08, 0x6D, 0x90, 0xA1, 0x96, 0x22, 0xE5, 0x51, 0x25, 0xE0, 0x24, 0x01, 0xF5, 0x82, 0xE4, 
+0x34, 0x92, 0xF5, 0x83, 0x22, 0x74, 0x91, 0x25, 0x51, 0xF5, 0x82, 0xE4, 0x34, 0x9C, 0xF5, 0x83, 
+0x22, 0xFD, 0x7C, 0x00, 0x12, 0x07, 0x03, 0xEF, 0x25, 0x55, 0xF5, 0x55, 0xEE, 0x35, 0x54, 0xF5, 
+0x54, 0x22, 0xFE, 0x54, 0x10, 0xFD, 0xEF, 0x54, 0xEF, 0x4D, 0xFF, 0x22, 0x90, 0x9F, 0xDD, 0xE0, 
+0x24, 0x04, 0x90, 0x9F, 0xBF, 0xF0, 0xA3, 0x74, 0x08, 0xF0, 0x22, 0xA4, 0xF5, 0x82, 0x85, 0xF0, 
+0x83, 0x12, 0x07, 0xAB, 0xAE, 0xF0, 0xA8, 0x59, 0x08, 0x22, 0x90, 0xA1, 0x25, 0xE0, 0x24, 0x15, 
+0xF5, 0x82, 0xE4, 0x34, 0xA1, 0xF5, 0x83, 0x22, 0xF0, 0xEE, 0x54, 0x08, 0xFE, 0xEF, 0x54, 0xF7, 
+0x22, 0x7E, 0x00, 0x7F, 0x04, 0x7D, 0x00, 0x7B, 0x01, 0x7A, 0xA0, 0x79, 0x52, 0x22, 0xE0, 0x90, 
+0x01, 0xBA, 0xF0, 0x90, 0x9F, 0xA9, 0xE0, 0x90, 0x01, 0xBB, 0x22, 0xD3, 0x9F, 0xEE, 0x64, 0x80, 
+0xF8, 0x74, 0x80, 0x98, 0x22, 0x7F, 0x00, 0x7E, 0x0C, 0x12, 0x38, 0x07, 0x7F, 0x00, 0x7E, 0x0E, 
+0x22, 0x74, 0x01, 0x25, 0x51, 0xF5, 0x82, 0xE4, 0x34, 0x94, 0xF5, 0x83, 0x22, 0x74, 0x91, 0x25, 
+0x51, 0xF5, 0x82, 0xE4, 0x34, 0x9A, 0xF5, 0x83, 0x22, 0x90, 0x04, 0xA0, 0xE0, 0xFF, 0xA3, 0xE0, 
+0xFE, 0xEF, 0x64, 0x01, 0x22, 0xF0, 0xEE, 0x54, 0x20, 0xFE, 0xEF, 0x54, 0xDF, 0x22, 0x90, 0x9F, 
+0xA9, 0xE0, 0xFF, 0xE4, 0xFD, 0x02, 0x58, 0x65, 0xD3, 0xE5, 0x57, 0x94, 0xE8, 0xE5, 0x56, 0x94, 
+0x03, 0x22, 0x74, 0x01, 0x93, 0x95, 0x55, 0xE4, 0x93, 0x95, 0x54, 0x22, 0x12, 0x49, 0x22, 0xE0, 
+0xFB, 0xE4, 0xFD, 0x0F, 0x22, 0x7F, 0xB4, 0x7E, 0x08, 0x12, 0x37, 0xBC, 0xEF, 0x22, 0xE0, 0xFE, 
+0xA3, 0xE0, 0xF5, 0x82, 0x8E, 0x83, 0x22, 0xF0, 0x7F, 0x10, 0x7E, 0x00, 0x02, 0x3D, 0x7A, 0x90, 
+0x06, 0x0A, 0xE0, 0x54, 0xF8, 0xF0, 0x22, 0x90, 0x06, 0x04, 0xE0, 0x54, 0x7F, 0xF0, 0x22, 0x2F, 
+0xF8, 0xE6, 0xFE, 0xED, 0xF4, 0x5E, 0x22, 0xE5, 0x57, 0xAE, 0x56, 0xA8, 0x59, 0x08, 0x22, 0xE5, 
+0x54, 0xF0, 0xA3, 0xE5, 0x55, 0xF0, 0x22, 0x00, 0x1D, 0x83, 
+};
+u4Byte ArrayLength_MP_8821A_FW_NIC_BT = 27050;
+
+
+void
+ODM_ReadFirmware_MP_8821A_FW_NIC_BT(
+     IN   PDM_ODM_T    pDM_Odm,
+     OUT  u1Byte       *pFirmware,
+     OUT  u4Byte       *pFirmwareSize
+)
+{
+#if (DM_ODM_SUPPORT_TYPE & (ODM_CE))
+     *((SIZE_PTR *)pFirmware) = (SIZE_PTR)Array_MP_8821A_FW_NIC_BT;
+#else
+     ODM_MoveMemory(pDM_Odm, pFirmware, Array_MP_8821A_FW_NIC_BT, ArrayLength_MP_8821A_FW_NIC_BT);
+#endif
+     *pFirmwareSize = ArrayLength_MP_8821A_FW_NIC_BT;
+}
+
+
+u1Byte Array_MP_8821A_FW_WoWLAN[] = {
+0x01, 0x21, 0x30, 0x00, 0x1C, 0x00, 0x00, 0x00, 0x09, 0x05, 0x15, 0x19, 0x6A, 0x6A, 0x00, 0x00, 
+0xD0, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x02, 0x4A, 0xFA, 0x02, 0x6F, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x02, 0x70, 0x42, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x02, 0x7F, 0xEE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x02, 0x6F, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x77, 0xF8, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x02, 0x7F, 0xED, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+0xC2, 0xAF, 0x80, 0xFE, 0x32, 0x12, 0x45, 0xC4, 0x85, 0xD0, 0x0B, 0x75, 0xD0, 0x08, 0xAA, 0xE0, 
+0xC2, 0x8C, 0xE5, 0x8A, 0x24, 0x67, 0xF5, 0x8A, 0xE5, 0x8C, 0x34, 0x79, 0xF5, 0x8C, 0xD2, 0x8C, 
+0xEC, 0x24, 0x87, 0xF8, 0xE6, 0xBC, 0x02, 0x02, 0x74, 0xFF, 0xC3, 0x95, 0x81, 0xB4, 0x40, 0x00, 
+0x40, 0xCE, 0x79, 0x03, 0x78, 0x80, 0x16, 0xE6, 0x08, 0x70, 0x0B, 0xC2, 0xAF, 0xE6, 0x30, 0xE1, 
+0x03, 0x44, 0x18, 0xF6, 0xD2, 0xAF, 0x08, 0xD9, 0xED, 0xEA, 0x8B, 0xD0, 0x22, 0xE5, 0x0C, 0xFF, 
+0x23, 0x24, 0x81, 0xF8, 0x0F, 0x08, 0x08, 0xBF, 0x03, 0x04, 0x7F, 0x00, 0x78, 0x81, 0xE6, 0x30, 
+0xE4, 0xF2, 0x00, 0xE5, 0x0C, 0xC3, 0x9F, 0x50, 0x20, 0x05, 0x0C, 0x74, 0x86, 0x25, 0x0C, 0xF8, 
+0xE6, 0xFD, 0xA6, 0x81, 0x08, 0xE6, 0xAE, 0x0C, 0xBE, 0x02, 0x02, 0x74, 0xFF, 0xCD, 0xF8, 0xE8, 
+0x6D, 0x60, 0xE0, 0x08, 0xE6, 0xC0, 0xE0, 0x80, 0xF6, 0xE5, 0x0C, 0xD3, 0x9F, 0x40, 0x27, 0xE5, 
+0x0C, 0x24, 0x87, 0xF8, 0xE6, 0xAE, 0x0C, 0xBE, 0x02, 0x02, 0x74, 0xFF, 0xFD, 0x18, 0xE6, 0xCD, 
+0xF8, 0xE5, 0x81, 0x6D, 0x60, 0x06, 0xD0, 0xE0, 0xF6, 0x18, 0x80, 0xF5, 0xE5, 0x0C, 0x24, 0x86, 
+0xC8, 0xF6, 0x15, 0x0C, 0x80, 0xD3, 0xE5, 0x0C, 0x23, 0x24, 0x81, 0xF8, 0x7F, 0x04, 0xC2, 0xAF, 
+0xE6, 0x30, 0xE0, 0x03, 0x10, 0xE2, 0x0C, 0x7F, 0x00, 0x30, 0xE1, 0x07, 0x30, 0xE3, 0x04, 0x7F, 
+0x08, 0x54, 0xF4, 0x54, 0x7C, 0xC6, 0xD2, 0xAF, 0x54, 0x80, 0x42, 0x07, 0x22, 0x78, 0x86, 0xA6, 
+0x81, 0x74, 0x02, 0x60, 0x06, 0xFF, 0x08, 0x76, 0xFF, 0xDF, 0xFB, 0x7F, 0x03, 0xE4, 0x78, 0x80, 
+0xF6, 0x08, 0xF6, 0x08, 0xDF, 0xFA, 0x78, 0x81, 0x76, 0x30, 0x90, 0x4B, 0x99, 0x74, 0x01, 0x93, 
+0xC0, 0xE0, 0xE4, 0x93, 0xC0, 0xE0, 0x43, 0x89, 0x01, 0x75, 0x8A, 0x60, 0x75, 0x8C, 0x79, 0xD2, 
+0x8C, 0xD2, 0xAF, 0x22, 0x02, 0xEF, 0xD3, 0x94, 0x02, 0x40, 0x03, 0x7F, 0xFF, 0x22, 0x74, 0x81, 
+0x2F, 0x2F, 0xF8, 0xE6, 0x20, 0xE5, 0xF4, 0xC2, 0xAF, 0xE6, 0x44, 0x30, 0xF6, 0xD2, 0xAF, 0xAE, 
+0x0C, 0xEE, 0xC3, 0x9F, 0x50, 0x21, 0x0E, 0x74, 0x86, 0x2E, 0xF8, 0xE6, 0xF9, 0x08, 0xE6, 0x18, 
+0xBE, 0x02, 0x02, 0x74, 0xFF, 0xFD, 0xED, 0x69, 0x60, 0x09, 0x09, 0xE7, 0x19, 0x19, 0xF7, 0x09, 
+0x09, 0x80, 0xF3, 0x16, 0x16, 0x80, 0xDA, 0xEE, 0xD3, 0x9F, 0x40, 0x04, 0x05, 0x81, 0x05, 0x81, 
+0xEE, 0xD3, 0x9F, 0x40, 0x22, 0x74, 0x86, 0x2E, 0xF8, 0x08, 0xE6, 0xF9, 0xEE, 0xB5, 0x0C, 0x02, 
+0xA9, 0x81, 0x18, 0x06, 0x06, 0xE6, 0xFD, 0xED, 0x69, 0x60, 0x09, 0x19, 0x19, 0xE7, 0x09, 0x09, 
+0xF7, 0x19, 0x80, 0xF3, 0x1E, 0x80, 0xD9, 0xEF, 0x24, 0x86, 0xF8, 0xE6, 0x04, 0xF8, 0xEF, 0x2F, 
+0x04, 0x90, 0x4B, 0x99, 0x93, 0xF6, 0x08, 0xEF, 0x2F, 0x93, 0xF6, 0x7F, 0x00, 0x22, 0xEF, 0xD3, 
+0x94, 0x02, 0x40, 0x03, 0x7F, 0xFF, 0x22, 0xEF, 0x23, 0x24, 0x81, 0xF8, 0xE6, 0x30, 0xE5, 0xF4, 
+0xC2, 0xAF, 0xE6, 0x54, 0x8C, 0xF6, 0xD2, 0xAF, 0xE5, 0x0C, 0xB5, 0x07, 0x0A, 0x74, 0x86, 0x2F, 
+0xF8, 0xE6, 0xF5, 0x81, 0x02, 0x46, 0x0D, 0x50, 0x2E, 0x74, 0x87, 0x2F, 0xF8, 0xE6, 0xBF, 0x02, 
+0x02, 0x74, 0xFF, 0xFD, 0x18, 0xE6, 0xF9, 0x74, 0x86, 0x2F, 0xF8, 0xFB, 0xE6, 0xFC, 0xE9, 0x6C, 
+0x60, 0x08, 0xA8, 0x05, 0xE7, 0xF6, 0x1D, 0x19, 0x80, 0xF4, 0xA8, 0x03, 0xA6, 0x05, 0x1F, 0xE5, 
+0x0C, 0xB5, 0x07, 0xE3, 0x7F, 0x00, 0x22, 0x74, 0x87, 0x2F, 0xF8, 0xE6, 0xFD, 0x18, 0x86, 0x01, 
+0x0F, 0x74, 0x86, 0x2F, 0xF8, 0xA6, 0x01, 0x08, 0x86, 0x04, 0xE5, 0x0C, 0xB5, 0x07, 0x02, 0xAC, 
+0x81, 0xED, 0x6C, 0x60, 0x08, 0x0D, 0x09, 0xA8, 0x05, 0xE6, 0xF7, 0x80, 0xF4, 0xE5, 0x0C, 0xB5, 
+0x07, 0xDE, 0x89, 0x81, 0x7F, 0x00, 0x22, 0xEF, 0xD3, 0x94, 0x02, 0x40, 0x03, 0x7F, 0xFF, 0x22, 
+0xEF, 0x23, 0x24, 0x81, 0xF8, 0xC2, 0xAF, 0xE6, 0x30, 0xE5, 0x05, 0x30, 0xE0, 0x02, 0xD2, 0xE4, 
+0xD2, 0xE2, 0xC6, 0xD2, 0xAF, 0x7F, 0x00, 0x30, 0xE2, 0x01, 0x0F, 0x02, 0x46, 0x0C, 0x8F, 0xF0, 
+0xE4, 0xFF, 0xFE, 0xE5, 0x0C, 0x23, 0x24, 0x80, 0xF8, 0xC2, 0xA9, 0x30, 0xF7, 0x0D, 0x7F, 0x08, 
+0xE6, 0x60, 0x0B, 0x2D, 0xF6, 0x60, 0x32, 0x50, 0x30, 0x80, 0x07, 0x30, 0xF1, 0x06, 0xED, 0xF6, 
+0x60, 0x27, 0x7E, 0x02, 0x08, 0x30, 0xF0, 0x10, 0xC2, 0xAF, 0xE6, 0x10, 0xE7, 0x25, 0x0E, 0x30, 
+0xE2, 0x0C, 0xD2, 0xAF, 0x7F, 0x04, 0x80, 0x14, 0xC2, 0xAF, 0xE6, 0x10, 0xE7, 0x15, 0x54, 0xEC, 
+0x4E, 0xF6, 0xD2, 0xAF, 0xD2, 0xA9, 0x02, 0x46, 0x0D, 0x7F, 0x08, 0x08, 0xEF, 0x44, 0x83, 0xF4, 
+0xC2, 0xAF, 0x56, 0xC6, 0xD2, 0xAF, 0xD2, 0xA9, 0x54, 0x80, 0x4F, 0xFF, 0x22, 0xEF, 0x2B, 0xFF, 
+0xEE, 0x3A, 0xFE, 0xED, 0x39, 0xFD, 0xEC, 0x38, 0xFC, 0x22, 0xE8, 0x8F, 0xF0, 0xA4, 0xCC, 0x8B, 
+0xF0, 0xA4, 0x2C, 0xFC, 0xE9, 0x8E, 0xF0, 0xA4, 0x2C, 0xFC, 0x8A, 0xF0, 0xED, 0xA4, 0x2C, 0xFC, 
+0xEA, 0x8E, 0xF0, 0xA4, 0xCD, 0xA8, 0xF0, 0x8B, 0xF0, 0xA4, 0x2D, 0xCC, 0x38, 0x25, 0xF0, 0xFD, 
+0xE9, 0x8F, 0xF0, 0xA4, 0x2C, 0xCD, 0x35, 0xF0, 0xFC, 0xEB, 0x8E, 0xF0, 0xA4, 0xFE, 0xA9, 0xF0, 
+0xEB, 0x8F, 0xF0, 0xA4, 0xCF, 0xC5, 0xF0, 0x2E, 0xCD, 0x39, 0xFE, 0xE4, 0x3C, 0xFC, 0xEA, 0xA4, 
+0x2D, 0xCE, 0x35, 0xF0, 0xFD, 0xE4, 0x3C, 0xFC, 0x22, 0xEF, 0x5B, 0xFF, 0xEE, 0x5A, 0xFE, 0xED, 
+0x59, 0xFD, 0xEC, 0x58, 0xFC, 0x22, 0xEF, 0x4B, 0xFF, 0xEE, 0x4A, 0xFE, 0xED, 0x49, 0xFD, 0xEC, 
+0x48, 0xFC, 0x22, 0xEB, 0x9F, 0xF5, 0xF0, 0xEA, 0x9E, 0x42, 0xF0, 0xE9, 0x9D, 0x42, 0xF0, 0xE8, 
+0x9C, 0x45, 0xF0, 0x22, 0xE0, 0xFC, 0xA3, 0xE0, 0xFD, 0xA3, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x22, 
+0xE0, 0xF8, 0xA3, 0xE0, 0xF9, 0xA3, 0xE0, 0xFA, 0xA3, 0xE0, 0xFB, 0x22, 0xA4, 0x25, 0x82, 0xF5, 
+0x82, 0xE5, 0xF0, 0x35, 0x83, 0xF5, 0x83, 0x22, 0xE0, 0xFB, 0xA3, 0xE0, 0xFA, 0xA3, 0xE0, 0xF9, 
+0x22, 0xEB, 0xF0, 0xA3, 0xEA, 0xF0, 0xA3, 0xE9, 0xF0, 0x22, 0xD0, 0x83, 0xD0, 0x82, 0xF8, 0xE4, 
+0x93, 0x70, 0x12, 0x74, 0x01, 0x93, 0x70, 0x0D, 0xA3, 0xA3, 0x93, 0xF8, 0x74, 0x01, 0x93, 0xF5, 
+0x82, 0x88, 0x83, 0xE4, 0x73, 0x74, 0x02, 0x93, 0x68, 0x60, 0xEF, 0xA3, 0xA3, 0xA3, 0x80, 0xDF, 
+0xE3, 0xF5, 0xF0, 0x09, 0xE2, 0x08, 0xB5, 0xF0, 0x6B, 0xDF, 0xF5, 0x80, 0x67, 0xE3, 0xF5, 0xF0, 
+0x09, 0xE6, 0x08, 0xB5, 0xF0, 0x5E, 0xDF, 0xF5, 0x80, 0x5A, 0x87, 0xF0, 0x09, 0xE6, 0x08, 0xB5, 
+0xF0, 0x52, 0xDF, 0xF6, 0x80, 0x4E, 0x87, 0xF0, 0x09, 0xE2, 0x08, 0xB5, 0xF0, 0x46, 0xDF, 0xF6, 
+0x80, 0x42, 0x88, 0x82, 0x8C, 0x83, 0x87, 0xF0, 0x09, 0xE0, 0xA3, 0xB5, 0xF0, 0x36, 0xDF, 0xF6, 
+0x80, 0x32, 0x88, 0x82, 0x8C, 0x83, 0x87, 0xF0, 0x09, 0xE4, 0x93, 0xA3, 0xB5, 0xF0, 0x25, 0xDF, 
+0xF5, 0x80, 0x21, 0x88, 0x82, 0x8C, 0x83, 0xE3, 0xF5, 0xF0, 0x09, 0xE0, 0xA3, 0xB5, 0xF0, 0x14, 
+0xDF, 0xF5, 0x80, 0x10, 0x88, 0x82, 0x8C, 0x83, 0xE3, 0xF5, 0xF0, 0x09, 0xE4, 0x93, 0xA3, 0xB5, 
+0xF0, 0x02, 0xDF, 0xF4, 0x02, 0x4A, 0x7F, 0x80, 0x87, 0x80, 0xE9, 0x80, 0x90, 0x80, 0xD4, 0x80, 
+0x3E, 0x80, 0x15, 0x80, 0x6E, 0x80, 0x7E, 0x80, 0x9D, 0x80, 0xB7, 0x80, 0x8D, 0x80, 0xA3, 0x80, 
+0x51, 0x80, 0x74, 0x80, 0x3C, 0x02, 0x4A, 0x8B, 0x89, 0x82, 0x8A, 0x83, 0xEC, 0xFA, 0xE4, 0x93, 
+0xF5, 0xF0, 0xA3, 0xC8, 0xC5, 0x82, 0xC8, 0xCC, 0xC5, 0x83, 0xCC, 0xE4, 0x93, 0xA3, 0xC8, 0xC5, 
+0x82, 0xC8, 0xCC, 0xC5, 0x83, 0xCC, 0xB5, 0xF0, 0x76, 0xDF, 0xE3, 0xDE, 0xE1, 0x80, 0x70, 0x89, 
+0x82, 0x8A, 0x83, 0xE4, 0x93, 0xF5, 0xF0, 0xA3, 0xE2, 0x08, 0xB5, 0xF0, 0x62, 0xDF, 0xF4, 0x80, 
+0x5E, 0x89, 0x82, 0x8A, 0x83, 0xE0, 0xF5, 0xF0, 0xA3, 0xE6, 0x08, 0xB5, 0xF0, 0x51, 0xDF, 0xF5, 
+0x80, 0x4D, 0x89, 0x82, 0x8A, 0x83, 0xE0, 0xF5, 0xF0, 0xA3, 0xE2, 0x08, 0xB5, 0xF0, 0x40, 0xDF, 
+0xF5, 0x80, 0x3C, 0x89, 0x82, 0x8A, 0x83, 0xE4, 0x93, 0xF5, 0xF0, 0xA3, 0xE6, 0x08, 0xB5, 0xF0, 
+0x2E, 0xDF, 0xF4, 0x80, 0x2A, 0x80, 0x02, 0x80, 0x57, 0x89, 0x82, 0x8A, 0x83, 0xEC, 0xFA, 0xE4, 
+0x93, 0xF5, 0xF0, 0xA3, 0xC8, 0xC5, 0x82, 0xC8, 0xCC, 0xC5, 0x83, 0xCC, 0xE0, 0xA3, 0xC8, 0xC5, 
+0x82, 0xC8, 0xCC, 0xC5, 0x83, 0xCC, 0xB5, 0xF0, 0x06, 0xDF, 0xE4, 0xDE, 0xE2, 0x80, 0x00, 0x7F, 
+0xFF, 0xB5, 0xF0, 0x02, 0x0F, 0x22, 0x40, 0x02, 0x7F, 0x01, 0x22, 0x89, 0x82, 0x8A, 0x83, 0xEC, 
+0xFA, 0xE0, 0xF5, 0xF0, 0xA3, 0xC8, 0xC5, 0x82, 0xC8, 0xCC, 0xC5, 0x83, 0xCC, 0xE0, 0xA3, 0xC8, 
+0xC5, 0x82, 0xC8, 0xCC, 0xC5, 0x83, 0xCC, 0xB5, 0xF0, 0xD5, 0xDF, 0xE5, 0xDE, 0xE3, 0x80, 0xCF, 
+0x89, 0x82, 0x8A, 0x83, 0xEC, 0xFA, 0xE0, 0xF5, 0xF0, 0xA3, 0xC8, 0xC5, 0x82, 0xC8, 0xCC, 0xC5, 
+0x83, 0xCC, 0xE4, 0x93, 0xA3, 0xC8, 0xC5, 0x82, 0xC8, 0xCC, 0xC5, 0x83, 0xCC, 0xB5, 0xF0, 0xAF, 
+0xDF, 0xE4, 0xDE, 0xE2, 0x80, 0xA9, 0x88, 0xF0, 0xEF, 0x60, 0x01, 0x0E, 0x4E, 0x60, 0xAB, 0xED, 
+0x24, 0x02, 0xB4, 0x04, 0x00, 0x50, 0x98, 0xF5, 0x82, 0xEB, 0x24, 0x02, 0xB4, 0x04, 0x00, 0x50, 
+0x8E, 0x23, 0x23, 0x45, 0x82, 0x23, 0x90, 0x49, 0xC7, 0x73, 0x02, 0x4B, 0x38, 0x02, 0x46, 0x9D, 
+0xE4, 0x93, 0xA3, 0xF8, 0xE4, 0x93, 0xA3, 0x40, 0x03, 0xF6, 0x80, 0x01, 0xF2, 0x08, 0xDF, 0xF4, 
+0x80, 0x29, 0xE4, 0x93, 0xA3, 0xF8, 0x54, 0x07, 0x24, 0x0C, 0xC8, 0xC3, 0x33, 0xC4, 0x54, 0x0F, 
+0x44, 0x20, 0xC8, 0x83, 0x40, 0x04, 0xF4, 0x56, 0x80, 0x01, 0x46, 0xF6, 0xDF, 0xE4, 0x80, 0x0B, 
+0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x90, 0x4B, 0x7D, 0xE4, 0x7E, 0x01, 0x93, 0x60, 
+0xBC, 0xA3, 0xFF, 0x54, 0x3F, 0x30, 0xE5, 0x09, 0x54, 0x1F, 0xFE, 0xE4, 0x93, 0xA3, 0x60, 0x01, 
+0x0E, 0xCF, 0x54, 0xC0, 0x25, 0xE0, 0x60, 0xA8, 0x40, 0xB8, 0xE4, 0x93, 0xA3, 0xFA, 0xE4, 0x93, 
+0xA3, 0xF8, 0xE4, 0x93, 0xA3, 0xC8, 0xC5, 0x82, 0xC8, 0xCA, 0xC5, 0x83, 0xCA, 0xF0, 0xA3, 0xC8, 
+0xC5, 0x82, 0xC8, 0xCA, 0xC5, 0x83, 0xCA, 0xDF, 0xE9, 0xDE, 0xE7, 0x80, 0xBE, 0x41, 0x95, 0x36, 
+0x00, 0x41, 0x95, 0x37, 0x00, 0x41, 0x95, 0x48, 0x00, 0x41, 0x94, 0x65, 0x00, 0x41, 0x94, 0x47, 
+0x00, 0x44, 0x95, 0x26, 0x00, 0x50, 0xF2, 0x01, 0x00, 0x4D, 0xB2, 0x58, 0x8A, 0x67, 0xFE, 0xD3, 
+0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x8F, 0x82, 0x75, 0x83, 0x00, 0xED, 0xF1, 0xFC, 0xD0, 0xD0, 
+0x92, 0xAF, 0x22, 0x13, 0x54, 0x01, 0xFD, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x95, 
+0x3D, 0xED, 0xF0, 0x90, 0x95, 0x3C, 0xEF, 0xF0, 0xD3, 0x94, 0x07, 0x50, 0x41, 0x7F, 0x47, 0x91, 
+0x5C, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0xF4, 0x5F, 0xFD, 0x7F, 0x47, 0x71, 0x9F, 0x7F, 0x46, 
+0x91, 0x5C, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0x4F, 0xFD, 0x7F, 0x46, 0xF1, 0xE5, 0x60, 0x0D, 
+0x7F, 0x45, 0x91, 0x5C, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0x4F, 0x80, 0x0C, 0x7F, 0x45, 0x91, 
+0x5C, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0xF4, 0x5F, 0xFD, 0x7F, 0x45, 0x80, 0x45, 0x90, 0x95, 
+0x3C, 0xE0, 0x24, 0xF8, 0xF0, 0x7F, 0x63, 0x91, 0x5C, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0xF4, 
+0x5F, 0xFD, 0x7F, 0x63, 0x71, 0x9F, 0x7F, 0x62, 0x91, 0x5C, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 
+0x4F, 0xFD, 0x7F, 0x62, 0xF1, 0xE5, 0x60, 0x0E, 0x91, 0x5A, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 
+0x4F, 0xFD, 0x7F, 0x61, 0x80, 0x0D, 0x91, 0x5A, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0xF4, 0x5F, 
+0xFD, 0x7F, 0x61, 0x71, 0x9F, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x7F, 0x61, 0x91, 0x69, 0x90, 0x95, 
+0x3C, 0xE0, 0xFE, 0x74, 0x01, 0xA8, 0x06, 0x08, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 
+0x8F, 0x82, 0x75, 0x83, 0x00, 0xE0, 0x90, 0x95, 0x42, 0xF1, 0xFC, 0x90, 0x95, 0x42, 0xE0, 0xFF, 
+0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x7F, 0xFF, 0x12, 0x54, 0x6C, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 
+0xD0, 0x12, 0x57, 0x77, 0x7F, 0x00, 0x7E, 0x0C, 0xD1, 0xC1, 0x12, 0xA9, 0xC1, 0xD1, 0xC1, 0x7F, 
+0x00, 0x7E, 0x0E, 0x12, 0x38, 0x07, 0x91, 0xEB, 0x91, 0xD8, 0x91, 0xD8, 0x54, 0xFE, 0xFD, 0x7F, 
+0x02, 0x71, 0x9F, 0x12, 0xAA, 0x39, 0x44, 0x40, 0xD1, 0xC7, 0x7F, 0xB4, 0x7E, 0x08, 0x12, 0x38, 
+0x07, 0x90, 0x01, 0x00, 0x74, 0x3F, 0xF0, 0xA3, 0xE0, 0x54, 0xFD, 0xF0, 0x90, 0x05, 0x53, 0xE0, 
+0x44, 0x20, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x54, 0xFE, 0xFD, 0x7F, 0x02, 0x71, 0x9F, 0x7F, 
+0x02, 0x91, 0x69, 0xEF, 0x44, 0x01, 0xFD, 0x7F, 0x02, 0x71, 0x9F, 0x7F, 0x02, 0x91, 0x69, 0xEF, 
+0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x7F, 0x10, 0x91, 0x69, 0xEF, 0x44, 0x0C, 0xFD, 
+0x7F, 0x10, 0x71, 0x9F, 0x7F, 0x72, 0x91, 0x69, 0xEF, 0x54, 0xF3, 0xFD, 0x7F, 0x72, 0x71, 0x9F, 
+0x90, 0x01, 0x01, 0xE0, 0x44, 0x02, 0xF0, 0x90, 0x01, 0x00, 0x74, 0xFF, 0xF0, 0x90, 0x06, 0xB7, 
+0x74, 0x09, 0xF0, 0x90, 0x06, 0xB4, 0x74, 0x86, 0xF0, 0x12, 0xAA, 0x39, 0x54, 0xBF, 0xF1, 0xA7, 
+0x90, 0x95, 0x12, 0xD1, 0xD2, 0x7F, 0xB4, 0x7E, 0x08, 0x12, 0x38, 0x07, 0x91, 0xEB, 0x44, 0x01, 
+0xFD, 0x7F, 0x02, 0x71, 0x9F, 0x7F, 0x00, 0x7E, 0x0C, 0x12, 0x37, 0xBC, 0xEF, 0x44, 0x03, 0xF1, 
+0xA7, 0x90, 0x95, 0x12, 0xD1, 0xD2, 0x12, 0xA9, 0xC1, 0x12, 0x37, 0xBC, 0xEF, 0x44, 0x03, 0xF1, 
+0xA7, 0x90, 0x95, 0x12, 0xD1, 0xD2, 0x7F, 0x00, 0x7E, 0x0E, 0x12, 0x38, 0x07, 0xD0, 0xD0, 0x92, 
+0xAF, 0x22, 0x7F, 0x54, 0x91, 0x69, 0xE5, 0x0D, 0x5F, 0xF5, 0x11, 0x7F, 0x55, 0x91, 0x69, 0xE5, 
+0x0E, 0x5F, 0xF5, 0x12, 0x7F, 0x56, 0x91, 0x69, 0xE5, 0x0F, 0x5F, 0xF5, 0x13, 0x7F, 0x57, 0x91, 
+0x69, 0xE5, 0x10, 0x5F, 0xF5, 0x14, 0xAD, 0x11, 0x7F, 0x54, 0x71, 0x9F, 0xAD, 0x12, 0x7F, 0x55, 
+0x71, 0x9F, 0xAD, 0x13, 0x7F, 0x56, 0x71, 0x9F, 0xAD, 0x14, 0x7F, 0x57, 0x71, 0x9F, 0x53, 0x91, 
+0xEF, 0x22, 0x7F, 0x81, 0x91, 0x69, 0xEF, 0x54, 0xFE, 0xFD, 0x7F, 0x81, 0x71, 0x9F, 0x7F, 0x80, 
+0xF1, 0xEC, 0x7F, 0x80, 0x71, 0x9F, 0x12, 0x9A, 0x2B, 0x12, 0x3D, 0x3B, 0xF1, 0xF9, 0xF1, 0xF3, 
+0x7F, 0x01, 0x12, 0x46, 0xD5, 0x90, 0x93, 0x23, 0x74, 0x02, 0xF0, 0xFF, 0x12, 0x46, 0xD5, 0x90, 
+0x93, 0x23, 0xE0, 0x04, 0xF0, 0x12, 0x58, 0x1F, 0x12, 0x95, 0xA1, 0x7F, 0x80, 0x91, 0x69, 0xEF, 
+0x44, 0x40, 0xFD, 0x7F, 0x80, 0x71, 0x9F, 0x75, 0x28, 0xFF, 0x12, 0x58, 0x83, 0x12, 0x9A, 0x52, 
+0x12, 0x88, 0x16, 0x7F, 0x81, 0x91, 0x69, 0xEF, 0x44, 0x04, 0xFD, 0x7F, 0x81, 0x71, 0x9F, 0x12, 
+0x9A, 0x59, 0xE4, 0xFF, 0x02, 0x47, 0x5E, 0xAD, 0x07, 0x90, 0x8E, 0xC5, 0xE0, 0x75, 0xF0, 0x40, 
+0xA4, 0xFF, 0x90, 0x95, 0x1A, 0xE5, 0xF0, 0xF0, 0xA3, 0xEF, 0xF0, 0xE4, 0xA3, 0xF0, 0x90, 0x8E, 
+0xC6, 0xE0, 0xC3, 0x13, 0x54, 0x7F, 0x90, 0x95, 0x1D, 0xF0, 0xED, 0x64, 0x01, 0x70, 0x68, 0x90, 
+0x95, 0x1A, 0xE0, 0x70, 0x02, 0xA3, 0xE0, 0x60, 0x0B, 0x90, 0x95, 0x1A, 0x74, 0xFF, 0x75, 0xF0, 
+0xD0, 0x12, 0x08, 0xD6, 0xD1, 0xB3, 0x13, 0x54, 0x07, 0x7D, 0x00, 0x20, 0xE0, 0x02, 0x7D, 0x01, 
+0x71, 0xB7, 0xD1, 0xB3, 0x71, 0xB3, 0x90, 0x8E, 0xC6, 0xE0, 0x30, 0xE0, 0x3A, 0xD1, 0xA8, 0x13, 
+0x54, 0x07, 0x7D, 0x00, 0x20, 0xE0, 0x02, 0x7D, 0x01, 0x71, 0xB7, 0xE4, 0x90, 0x95, 0x1C, 0xF0, 
+0x90, 0x95, 0x1D, 0xE0, 0xFF, 0x90, 0x95, 0x1C, 0xE0, 0xC3, 0x9F, 0x50, 0x1A, 0xD1, 0xA8, 0x71, 
+0xB3, 0xD1, 0xA8, 0x13, 0x54, 0x07, 0x7D, 0x00, 0x20, 0xE0, 0x02, 0x7D, 0x01, 0x71, 0xB7, 0x90, 
+0x95, 0x1C, 0xE0, 0x04, 0xF0, 0x80, 0xD9, 0x22, 0x90, 0x95, 0x1A, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 
+0x12, 0x3D, 0x7A, 0x90, 0x8E, 0xC4, 0xE0, 0x54, 0x7F, 0xFF, 0x90, 0x8E, 0xC3, 0xE0, 0xFE, 0xC4, 
+0x22, 0x12, 0x37, 0xBC, 0xEF, 0x54, 0xFC, 0xFF, 0xEC, 0x90, 0x95, 0x16, 0x12, 0x08, 0x6D, 0x90, 
+0x95, 0x16, 0x11, 0xF4, 0x90, 0xAA, 0xB9, 0x02, 0x08, 0x6D, 0x90, 0x8E, 0x12, 0xE0, 0x44, 0x10, 
+0xF0, 0x90, 0x8E, 0x20, 0xE0, 0xFD, 0x7F, 0x93, 0x71, 0x9F, 0x90, 0x8E, 0x16, 0xE0, 0x60, 0x12, 
+0x90, 0x01, 0x2F, 0xE0, 0x30, 0xE7, 0x05, 0x74, 0x10, 0xF0, 0x80, 0x06, 0x90, 0x01, 0x2F, 0x74, 
+0x90, 0xF0, 0x7F, 0x08, 0x91, 0x69, 0xEF, 0x44, 0x10, 0xFD, 0x7F, 0x08, 0x71, 0x9F, 0x7F, 0x01, 
+0x12, 0x59, 0x59, 0x7F, 0x90, 0x91, 0x69, 0xEF, 0x44, 0x01, 0xFD, 0x7F, 0x90, 0x71, 0x9F, 0x7F, 
+0x14, 0x7E, 0x00, 0x02, 0x3D, 0x7A, 0x90, 0x01, 0x30, 0xE4, 0xF1, 0x6D, 0x90, 0x01, 0x38, 0xF1, 
+0x6D, 0xFD, 0x7F, 0x50, 0x71, 0x9F, 0xE4, 0xFD, 0x7F, 0x51, 0x71, 0x9F, 0xE4, 0xFD, 0x7F, 0x52, 
+0x71, 0x9F, 0xE4, 0xFD, 0x7F, 0x53, 0x61, 0x9F, 0x90, 0x01, 0x34, 0x74, 0xFF, 0xF1, 0x6D, 0x90, 
+0x01, 0x3C, 0xF1, 0x6D, 0xFD, 0x7F, 0x54, 0x71, 0x9F, 0x7D, 0xFF, 0x7F, 0x55, 0x71, 0x9F, 0x7D, 
+0xFF, 0x7F, 0x56, 0x71, 0x9F, 0x7D, 0xFF, 0x7F, 0x57, 0x61, 0x9F, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 
+0xA3, 0xF0, 0xA3, 0xF0, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0xF1, 0xA1, 0x30, 0xE6, 
+0x1B, 0x90, 0x00, 0x8C, 0xE0, 0xF5, 0x26, 0x7F, 0x8D, 0x91, 0x69, 0x90, 0x00, 0x8E, 0xE0, 0xF5, 
+0x27, 0xF1, 0xA1, 0x30, 0xE0, 0x06, 0xE4, 0xFD, 0x7F, 0x8D, 0x71, 0x9F, 0xD0, 0xD0, 0x92, 0xAF, 
+0x22, 0x7F, 0x8F, 0x91, 0x69, 0xEF, 0x22, 0xFF, 0xEC, 0x90, 0x95, 0x12, 0x02, 0x08, 0x6D, 0x12, 
+0xAA, 0x51, 0x7F, 0xF2, 0x91, 0x69, 0xEF, 0x20, 0xE6, 0x08, 0x7F, 0x05, 0xF1, 0xEC, 0x7F, 0x05, 
+0x71, 0x9F, 0x22, 0xE4, 0xF5, 0x0D, 0xF5, 0x0E, 0xF5, 0x0F, 0x75, 0x10, 0x80, 0xAD, 0x0D, 0x7F, 
+0x50, 0x71, 0x9F, 0xAD, 0x0E, 0x7F, 0x51, 0x71, 0x9F, 0xAD, 0x0F, 0x7F, 0x52, 0x71, 0x9F, 0xAD, 
+0x10, 0x7F, 0x53, 0x61, 0x9F, 0x71, 0x9F, 0x90, 0x95, 0x3D, 0xE0, 0x22, 0x91, 0x69, 0xEF, 0x44, 
+0x80, 0xFD, 0x22, 0xE4, 0x90, 0x8D, 0x01, 0xE1, 0x6B, 0x22, 0xE1, 0x75, 0xF0, 0x7F, 0x10, 0x7E, 
+0x00, 0x02, 0x3D, 0x7A, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x94, 0xE3, 0xEE, 0xF0, 
+0xA3, 0xEF, 0xF0, 0x90, 0x94, 0xE7, 0xE0, 0xF5, 0x3B, 0xA3, 0xE0, 0xF5, 0x3C, 0x12, 0x35, 0x7A, 
+0x90, 0x94, 0xE3, 0x12, 0x95, 0x7A, 0xA3, 0xA3, 0xA3, 0x74, 0x05, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 
+0x22, 0xE4, 0x90, 0x93, 0x4F, 0xF0, 0x7F, 0x03, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 
+0x93, 0x4A, 0xEF, 0xF0, 0x12, 0x88, 0x2F, 0x90, 0x93, 0x4A, 0xE0, 0xFF, 0x31, 0x47, 0x74, 0x01, 
+0xF0, 0x90, 0x93, 0x4F, 0xE0, 0xFE, 0xEF, 0x31, 0x55, 0xEE, 0xF0, 0x90, 0x93, 0x4A, 0xE0, 0x11, 
+0x9C, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 0x01, 0x11, 0x91, 0x78, 0x10, 0x12, 0x08, 0x47, 0xAB, 
+0x07, 0x11, 0x91, 0x78, 0x08, 0x12, 0x08, 0x47, 0x90, 0x94, 0xE7, 0xEF, 0xF0, 0x11, 0x91, 0x90, 
+0x94, 0xE8, 0xEF, 0xF0, 0x7D, 0x01, 0x7F, 0x50, 0x7E, 0x01, 0x11, 0x04, 0xD0, 0xD0, 0x92, 0xAF, 
+0x22, 0x90, 0x93, 0x4B, 0x02, 0x48, 0xF4, 0x90, 0x93, 0x38, 0xE0, 0xFB, 0x75, 0xF0, 0x0A, 0xA4, 
+0x24, 0xF7, 0xF5, 0x82, 0xE4, 0x34, 0x93, 0xF5, 0x83, 0x22, 0xE4, 0x90, 0x93, 0x38, 0xF0, 0x90, 
+0x93, 0x38, 0xE0, 0xFF, 0xC3, 0x94, 0x08, 0x40, 0x02, 0x21, 0x3F, 0xEF, 0x31, 0x47, 0xE0, 0x64, 
+0x01, 0x70, 0x74, 0x90, 0x93, 0x38, 0xE0, 0x11, 0x9C, 0x12, 0x48, 0xF4, 0xE4, 0x7B, 0x01, 0x31, 
+0x40, 0x70, 0x3A, 0x90, 0x93, 0x38, 0xE0, 0xFB, 0x31, 0x55, 0xE0, 0x60, 0x21, 0x14, 0x70, 0x57, 
+0xEB, 0x75, 0xF0, 0x0A, 0xA4, 0x24, 0xFB, 0xF5, 0x82, 0xE4, 0x34, 0x93, 0xF5, 0x83, 0x12, 0x48, 
+0xF4, 0xEB, 0x11, 0x9C, 0x12, 0x08, 0x6D, 0x90, 0x93, 0x38, 0xE0, 0xFF, 0x80, 0x0B, 0x11, 0x97, 
+0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 0x00, 0xAF, 0x03, 0x31, 0x63, 0x80, 0x2A, 0x90, 0x93, 0x38, 
+0xE0, 0x11, 0x9C, 0x12, 0x48, 0xF4, 0xE4, 0xFB, 0x31, 0x40, 0x50, 0x1B, 0x11, 0x97, 0x12, 0x48, 
+0xF4, 0xEF, 0x24, 0xFF, 0xFF, 0xEE, 0x34, 0xFF, 0xFE, 0xED, 0x34, 0xFF, 0xFD, 0xEC, 0x34, 0xFF, 
+0xFC, 0xEB, 0x11, 0x9C, 0x12, 0x08, 0x6D, 0x90, 0x93, 0x38, 0xE0, 0x04, 0xF0, 0x01, 0xAF, 0x22, 
+0xFA, 0xF9, 0xF8, 0xC3, 0x02, 0x48, 0xE3, 0x75, 0xF0, 0x0A, 0xA4, 0x24, 0x00, 0xF5, 0x82, 0xE4, 
+0x34, 0x94, 0xF5, 0x83, 0x22, 0x75, 0xF0, 0x0A, 0xA4, 0x24, 0xFF, 0xF5, 0x82, 0xE4, 0x34, 0x93, 
+0xF5, 0x83, 0x22, 0xEF, 0x24, 0xFC, 0x60, 0x05, 0x04, 0x70, 0x05, 0x80, 0x04, 0x12, 0x80, 0xEF, 
+0x22, 0xE4, 0x90, 0x93, 0x39, 0xF0, 0x90, 0x94, 0x65, 0x04, 0xF0, 0x90, 0x06, 0x32, 0xE0, 0x44, 
+0x04, 0xF0, 0x90, 0x93, 0x0E, 0x12, 0x48, 0xF4, 0x12, 0x95, 0x6A, 0xE4, 0x3D, 0xFD, 0xE4, 0x3C, 
+0xFC, 0x90, 0x93, 0x0E, 0x12, 0x08, 0x6D, 0x12, 0xA7, 0xD8, 0xE4, 0x90, 0x94, 0x49, 0xF0, 0xFF, 
+0x12, 0x83, 0xB6, 0x12, 0x72, 0xD5, 0x70, 0x27, 0x31, 0xDE, 0x7F, 0x05, 0x7E, 0x00, 0x12, 0x3C, 
+0xEC, 0x71, 0xEB, 0x90, 0x8E, 0x18, 0xE0, 0x64, 0x02, 0x60, 0x14, 0x90, 0x93, 0x39, 0xE0, 0x04, 
+0xF0, 0x12, 0xAA, 0x51, 0x31, 0xDE, 0x90, 0x93, 0x39, 0xE0, 0xD3, 0x94, 0x0A, 0x40, 0xE4, 0x90, 
+0x93, 0x4B, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 0x0A, 0x12, 0x87, 0xB1, 0x01, 0x38, 0x7D, 0x01, 
+0x7F, 0x02, 0x80, 0x04, 0x7D, 0x01, 0x7F, 0x04, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 
+0x95, 0x4B, 0xED, 0xF0, 0x90, 0x8E, 0x11, 0xE0, 0xFE, 0xC4, 0x13, 0x13, 0x54, 0x03, 0x30, 0xE0, 
+0x02, 0x61, 0x33, 0xEE, 0x12, 0x6F, 0xF0, 0x30, 0xE0, 0x02, 0x61, 0x33, 0x90, 0x8E, 0x18, 0xE0, 
+0xFE, 0x6F, 0x70, 0x02, 0x61, 0x33, 0xEF, 0x70, 0x02, 0x41, 0xA7, 0x24, 0xFE, 0x70, 0x02, 0x41, 
+0xE0, 0x24, 0xFE, 0x60, 0x4A, 0x24, 0xFC, 0x70, 0x02, 0x61, 0x1B, 0x24, 0xFC, 0x60, 0x02, 0x61, 
+0x2D, 0xEE, 0xB4, 0x0E, 0x02, 0x71, 0x6A, 0x90, 0x8E, 0x18, 0xE0, 0x70, 0x04, 0x7F, 0x01, 0x71, 
+0xA6, 0x90, 0x8E, 0x18, 0xE0, 0xB4, 0x06, 0x02, 0x71, 0x85, 0x90, 0x8E, 0x18, 0xE0, 0xB4, 0x04, 
+0x0F, 0x90, 0x95, 0x4B, 0xE0, 0xFF, 0x60, 0x05, 0x12, 0x73, 0x6A, 0x80, 0x03, 0x12, 0x79, 0x4E, 
+0x90, 0x8E, 0x18, 0xE0, 0x64, 0x08, 0x60, 0x02, 0x61, 0x2D, 0x12, 0xA7, 0x8A, 0x61, 0x2D, 0x90, 
+0x8E, 0x18, 0xE0, 0x70, 0x04, 0x7F, 0x01, 0x71, 0xA6, 0x90, 0x8E, 0x18, 0xE0, 0xB4, 0x06, 0x02, 
+0x71, 0x85, 0x90, 0x8E, 0x18, 0xE0, 0xB4, 0x0E, 0x07, 0x71, 0x38, 0xBF, 0x01, 0x02, 0x71, 0x6A, 
+0x90, 0x8E, 0x18, 0xE0, 0x64, 0x0C, 0x60, 0x02, 0x61, 0x2D, 0x71, 0x38, 0xEF, 0x64, 0x01, 0x60, 
+0x02, 0x61, 0x2D, 0x71, 0xBD, 0x61, 0x2D, 0x90, 0x8E, 0x18, 0xE0, 0xB4, 0x0E, 0x07, 0x71, 0x38, 
+0xBF, 0x01, 0x02, 0x71, 0x6A, 0x90, 0x8E, 0x18, 0xE0, 0xB4, 0x06, 0x02, 0x71, 0x85, 0x90, 0x8E, 
+0x18, 0xE0, 0xB4, 0x0C, 0x07, 0x71, 0x38, 0xBF, 0x01, 0x02, 0x71, 0xBD, 0x90, 0x8E, 0x18, 0xE0, 
+0x64, 0x04, 0x70, 0x59, 0x12, 0x59, 0xFD, 0xEF, 0x64, 0x01, 0x70, 0x51, 0xF1, 0xCB, 0x80, 0x4D, 
+0x90, 0x8E, 0x18, 0xE0, 0xB4, 0x0E, 0x07, 0x71, 0x38, 0xBF, 0x01, 0x02, 0x71, 0x6A, 0x90, 0x8E, 
+0x18, 0xE0, 0xB4, 0x06, 0x02, 0x71, 0x85, 0x90, 0x8E, 0x18, 0xE0, 0xB4, 0x0C, 0x07, 0x71, 0x38, 
+0xBF, 0x01, 0x02, 0x71, 0xBD, 0x90, 0x8E, 0x18, 0xE0, 0x70, 0x04, 0x7F, 0x01, 0x71, 0xA6, 0x90, 
+0x8E, 0x18, 0xE0, 0xB4, 0x04, 0x17, 0x12, 0xA7, 0x7C, 0x80, 0x12, 0x90, 0x8E, 0x18, 0xE0, 0xB4, 
+0x0C, 0x0B, 0x90, 0x8E, 0x12, 0x12, 0x87, 0x6B, 0x30, 0xE0, 0x02, 0xF1, 0xEE, 0x90, 0x8E, 0x18, 
+0x12, 0xA9, 0x99, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x12, 0xA7, 0x36, 0xEF, 0x64, 0x01, 0x60, 0x05, 
+0x12, 0x5A, 0x97, 0x80, 0x1C, 0x12, 0x9E, 0x34, 0x30, 0xE0, 0x05, 0x12, 0x5A, 0x90, 0x80, 0x11, 
+0x90, 0x8E, 0x17, 0xE0, 0xD3, 0x94, 0x04, 0x40, 0x05, 0x12, 0x59, 0xF6, 0x80, 0x03, 0x02, 0x5A, 
+0x9E, 0x90, 0x01, 0xB9, 0x74, 0x02, 0xF0, 0x7F, 0x00, 0x22, 0x90, 0x8E, 0x12, 0xE0, 0xC3, 0x13, 
+0x20, 0xE0, 0x04, 0x7D, 0x0C, 0x80, 0x05, 0x12, 0x97, 0xB8, 0x7D, 0x04, 0x7F, 0x01, 0x71, 0xF7, 
+0xE4, 0xFD, 0xFF, 0x81, 0x6C, 0x90, 0x8E, 0x12, 0xE0, 0x90, 0x06, 0x04, 0x20, 0xE0, 0x08, 0xE0, 
+0x44, 0x40, 0xF0, 0x7D, 0x04, 0x80, 0x06, 0xE0, 0x54, 0x7F, 0xF0, 0x7D, 0x0C, 0x7F, 0x01, 0x71, 
+0xF7, 0xE4, 0xFD, 0xFF, 0x81, 0x6C, 0x90, 0x95, 0x4A, 0xEF, 0xF0, 0x12, 0x4C, 0xF1, 0x90, 0x95, 
+0x4A, 0xE0, 0x60, 0x03, 0x12, 0x87, 0xCC, 0x7D, 0x04, 0x7F, 0x01, 0x80, 0x3A, 0x12, 0x72, 0xD5, 
+0x70, 0x28, 0x90, 0x8E, 0x12, 0xE0, 0x54, 0xFD, 0xF0, 0x7D, 0x2C, 0x7F, 0x6F, 0x91, 0x6C, 0x7D, 
+0x08, 0x7F, 0x01, 0xF1, 0x27, 0xBF, 0x01, 0x0D, 0x90, 0x8E, 0x11, 0xE0, 0x44, 0x80, 0xF0, 0x7D, 
+0x0E, 0x7F, 0x01, 0x80, 0x12, 0x12, 0x77, 0xEE, 0x04, 0xF0, 0x22, 0x90, 0x8E, 0x17, 0xE0, 0x90, 
+0x94, 0x61, 0xF0, 0x7D, 0x02, 0x7F, 0x02, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x95, 
+0x49, 0xEF, 0xF0, 0x14, 0x60, 0x15, 0x14, 0x60, 0x19, 0x24, 0x02, 0x70, 0x1A, 0xED, 0x54, 0x01, 
+0xFF, 0x90, 0x8E, 0x11, 0xE0, 0x54, 0xFE, 0x4F, 0xF0, 0x80, 0x0C, 0x90, 0x8E, 0x18, 0xED, 0xF0, 
+0x80, 0x05, 0x90, 0x8E, 0x17, 0xED, 0xF0, 0x12, 0x4F, 0xA1, 0x30, 0xE4, 0x31, 0x90, 0x95, 0x49, 
+0xE0, 0x14, 0x60, 0x07, 0x14, 0x60, 0x1D, 0x24, 0x02, 0x70, 0x23, 0x90, 0x8E, 0x11, 0xE0, 0x54, 
+0x01, 0xC4, 0x33, 0x33, 0x33, 0x54, 0x80, 0xFF, 0x90, 0x8E, 0x18, 0xE0, 0x54, 0x7F, 0x4F, 0xFD, 
+0x7F, 0x88, 0x80, 0x07, 0x90, 0x8E, 0x17, 0xE0, 0xFD, 0x7F, 0x89, 0x12, 0x4B, 0x9F, 0xD0, 0xD0, 
+0x92, 0xAF, 0x22, 0xE4, 0xFD, 0x7F, 0x0C, 0x31, 0xE8, 0xE4, 0xFD, 0xFF, 0x90, 0x05, 0x22, 0xEF, 
+0xF0, 0x90, 0x8D, 0x05, 0xED, 0xF0, 0x22, 0x90, 0x93, 0x65, 0x12, 0x49, 0x21, 0x90, 0x05, 0x22, 
+0xE0, 0x90, 0x93, 0x76, 0xF0, 0x90, 0x04, 0x1D, 0xE0, 0x60, 0x09, 0x7D, 0x39, 0xF1, 0x73, 0xBF, 
+0x01, 0x10, 0x80, 0x00, 0x90, 0x93, 0x16, 0x12, 0x82, 0x17, 0x90, 0x93, 0x73, 0xEE, 0xF0, 0xA3, 
+0xEF, 0xF0, 0x90, 0x93, 0x73, 0x12, 0xA8, 0xD4, 0x12, 0x84, 0x71, 0x90, 0x93, 0x75, 0xEF, 0xF0, 
+0x90, 0x93, 0x73, 0xF1, 0xF9, 0x90, 0x93, 0x71, 0xE0, 0xFD, 0x12, 0x91, 0x03, 0x90, 0x93, 0x72, 
+0xE0, 0x60, 0x02, 0xA1, 0x46, 0xF1, 0x16, 0xC0, 0x03, 0xC0, 0x02, 0xC0, 0x01, 0x90, 0x93, 0x68, 
+0xF1, 0x05, 0x75, 0x43, 0x06, 0xD0, 0x01, 0xD0, 0x02, 0xD0, 0x03, 0xB1, 0xE6, 0xF1, 0xE4, 0xC0, 
+0x03, 0xC0, 0x02, 0xC0, 0x01, 0x90, 0x93, 0x65, 0xF1, 0x05, 0x75, 0x43, 0x10, 0xD0, 0x01, 0xD0, 
+0x02, 0xD0, 0x03, 0xB1, 0xE6, 0xF1, 0x19, 0xC0, 0x03, 0xC0, 0x02, 0xC0, 0x01, 0xF1, 0x02, 0x75, 
+0x43, 0x10, 0xD0, 0x01, 0xD0, 0x02, 0xD0, 0x03, 0xB1, 0xE6, 0x24, 0x60, 0xF9, 0xE4, 0x34, 0xFC, 
+0xFA, 0x7B, 0x01, 0xC0, 0x03, 0xC0, 0x02, 0xC0, 0x01, 0xF1, 0x02, 0x75, 0x43, 0x10, 0xD0, 0x01, 
+0xD0, 0x02, 0xD0, 0x03, 0xB1, 0xE6, 0x24, 0x72, 0xF9, 0xE4, 0x34, 0xFC, 0xFA, 0x7B, 0x01, 0xC0, 
+0x03, 0xC0, 0x02, 0xC0, 0x01, 0x90, 0x93, 0x6E, 0xF1, 0x05, 0x75, 0x43, 0x06, 0xD0, 0x01, 0xD0, 
+0x02, 0xD0, 0x03, 0x12, 0x34, 0x62, 0x90, 0x93, 0x6B, 0x12, 0x49, 0x18, 0x90, 0x93, 0xA2, 0x12, 
+0x49, 0x21, 0x90, 0x93, 0xA5, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 0x20, 0x90, 0x93, 0xA9, 0x74, 
+0x3A, 0xF0, 0x90, 0x93, 0x65, 0x12, 0x49, 0x18, 0x12, 0xA6, 0x4D, 0xB1, 0xE9, 0x24, 0x30, 0xF9, 
+0xE4, 0x34, 0xFC, 0x12, 0x83, 0xF4, 0x75, 0x43, 0x28, 0x7B, 0x01, 0x7A, 0x93, 0x79, 0x77, 0xB1, 
+0xE6, 0x12, 0xA9, 0xD9, 0xC0, 0x03, 0x8B, 0x40, 0x75, 0x41, 0x8F, 0x75, 0x42, 0x64, 0x75, 0x43, 
+0x28, 0xD0, 0x03, 0x12, 0x34, 0x62, 0x90, 0x93, 0x75, 0xE0, 0xFF, 0x90, 0x93, 0x74, 0xE0, 0x2F, 
+0xFF, 0x90, 0x93, 0x73, 0xE0, 0x34, 0x00, 0xCF, 0x24, 0x30, 0xFD, 0xE4, 0x3F, 0xFC, 0x90, 0x93, 
+0x16, 0xE0, 0xFB, 0x7F, 0x3A, 0x12, 0x5D, 0x99, 0xB1, 0xE9, 0x12, 0xA9, 0xD9, 0xC0, 0x03, 0x8B, 
+0x40, 0x75, 0x41, 0x93, 0x75, 0x42, 0x77, 0x75, 0x43, 0x28, 0xD0, 0x03, 0x12, 0x34, 0x62, 0x90, 
+0x06, 0x33, 0xE0, 0x44, 0x02, 0xF0, 0x90, 0x93, 0x76, 0xE0, 0xFF, 0x7D, 0x3A, 0x91, 0x6C, 0x90, 
+0x04, 0x1F, 0x74, 0x20, 0xF0, 0x22, 0x12, 0x34, 0x62, 0x90, 0x93, 0x73, 0xA3, 0xE0, 0xFF, 0xA3, 
+0xE0, 0x2F, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x94, 0x9F, 0x12, 0x49, 0x21, 
+0x78, 0xAB, 0x7C, 0x94, 0x7D, 0x01, 0x7B, 0xFF, 0x7A, 0x40, 0x79, 0x64, 0x12, 0x6F, 0xF7, 0x90, 
+0x05, 0x22, 0xE0, 0x90, 0x94, 0xAA, 0xF0, 0x90, 0x04, 0x1D, 0xE0, 0x60, 0x09, 0x7D, 0x33, 0xF1, 
+0x73, 0xBF, 0x01, 0x10, 0x80, 0x00, 0x90, 0x93, 0x15, 0x12, 0x82, 0x17, 0x90, 0x94, 0xA7, 0xEE, 
+0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0x94, 0xA7, 0x12, 0xA8, 0xD4, 0x12, 0x84, 0x71, 0x90, 0x94, 0xA9, 
+0xEF, 0xF0, 0x90, 0x94, 0xA7, 0xF1, 0xF9, 0x90, 0x94, 0xA5, 0xE0, 0xFD, 0x12, 0x91, 0x03, 0x90, 
+0x94, 0xA6, 0xE0, 0x70, 0x4E, 0xF1, 0x16, 0xC0, 0x03, 0xC0, 0x02, 0xC0, 0x01, 0x90, 0x94, 0xA2, 
+0xF1, 0x05, 0x75, 0x43, 0x06, 0xD0, 0x01, 0xD0, 0x02, 0xD0, 0x03, 0xF1, 0x0F, 0xB1, 0xEC, 0x12, 
+0x84, 0x6A, 0xFA, 0x7B, 0x01, 0xC0, 0x03, 0xC0, 0x02, 0xC0, 0x01, 0x90, 0x94, 0xA2, 0xF1, 0x05, 
+0x75, 0x43, 0x06, 0xD0, 0x01, 0xD0, 0x02, 0xD0, 0x03, 0xF1, 0x0F, 0xB1, 0xEC, 0xF1, 0xE4, 0xC0, 
+0x03, 0xC0, 0x02, 0xC0, 0x01, 0x90, 0x94, 0x9F, 0xF1, 0x05, 0x75, 0x43, 0x04, 0xD0, 0x01, 0xD0, 
+0x02, 0x80, 0x45, 0x90, 0x94, 0xA6, 0xE0, 0x64, 0x01, 0x70, 0x42, 0xF1, 0x16, 0xC0, 0x03, 0x8B, 
+0x40, 0x75, 0x41, 0x8E, 0x75, 0x42, 0xE0, 0x75, 0x43, 0x06, 0xD0, 0x03, 0xF1, 0x0F, 0xB1, 0xEC, 
+0x12, 0x84, 0x6A, 0xFA, 0x7B, 0x01, 0xC0, 0x03, 0x8B, 0x40, 0x75, 0x41, 0x8E, 0x75, 0x42, 0xEA, 
+0x75, 0x43, 0x06, 0xD0, 0x03, 0xF1, 0x0F, 0xB1, 0xEC, 0xF1, 0xE4, 0xC0, 0x03, 0x8B, 0x40, 0x75, 
+0x41, 0x8E, 0x75, 0x42, 0xF0, 0x75, 0x43, 0x04, 0xD0, 0x03, 0x12, 0x34, 0x62, 0x90, 0x06, 0x30, 
+0xE0, 0x44, 0x10, 0xF0, 0x90, 0x94, 0xAA, 0xE0, 0xFF, 0x7D, 0x34, 0xB1, 0xDD, 0xD0, 0xD0, 0x92, 
+0xAF, 0x22, 0x90, 0x93, 0x6B, 0x12, 0x49, 0x18, 0x8B, 0x40, 0x8A, 0x41, 0x89, 0x42, 0x22, 0x12, 
+0x34, 0x62, 0x90, 0x94, 0xA7, 0x22, 0xA3, 0xA3, 0xE0, 0x24, 0x38, 0xF9, 0xE4, 0x34, 0xFC, 0xFA, 
+0x7B, 0x01, 0x22, 0x7D, 0x08, 0xE4, 0xFF, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x95, 
+0x01, 0xEF, 0xF0, 0xA3, 0xED, 0xF0, 0x90, 0x8D, 0x03, 0xE0, 0x04, 0xF0, 0x90, 0x04, 0x1D, 0xE0, 
+0x60, 0x22, 0x90, 0x05, 0x22, 0xE0, 0x90, 0x95, 0x05, 0xF0, 0x7D, 0x26, 0xF1, 0x73, 0xEF, 0x64, 
+0x01, 0x70, 0x03, 0x12, 0x82, 0xBB, 0x90, 0x95, 0x05, 0xE0, 0xFF, 0x7D, 0x27, 0x91, 0x6C, 0x12, 
+0x97, 0x43, 0x80, 0x06, 0x12, 0x97, 0x43, 0x12, 0x82, 0xBB, 0xB1, 0xDF, 0x7F, 0x01, 0xD0, 0xD0, 
+0x92, 0xAF, 0x22, 0x7F, 0xFF, 0x91, 0x6C, 0xE4, 0x90, 0x95, 0x3A, 0xF0, 0xA3, 0xF0, 0x90, 0x05, 
+0xF8, 0xE0, 0x70, 0x0F, 0xA3, 0xE0, 0x70, 0x0B, 0xA3, 0xE0, 0x70, 0x07, 0xA3, 0xE0, 0x70, 0x03, 
+0x7F, 0x01, 0x22, 0xD3, 0x90, 0x95, 0x3B, 0xE0, 0x94, 0xE8, 0x90, 0x95, 0x3A, 0xE0, 0x94, 0x03, 
+0x40, 0x0A, 0x90, 0x01, 0xC0, 0xE0, 0x44, 0x20, 0xF0, 0x7F, 0x00, 0x22, 0x7F, 0x32, 0x7E, 0x00, 
+0x12, 0x3D, 0x7A, 0x90, 0x95, 0x3A, 0x12, 0x5A, 0xA6, 0x80, 0xC3, 0x12, 0x9E, 0x02, 0x90, 0x8E, 
+0x18, 0xE0, 0x64, 0x0C, 0x60, 0x04, 0x91, 0x63, 0xF1, 0x23, 0x22, 0x7D, 0x2D, 0xF1, 0x73, 0x90, 
+0x01, 0x37, 0x74, 0x02, 0xF0, 0xFD, 0x7F, 0x03, 0x12, 0x78, 0x7A, 0x12, 0x4C, 0x8A, 0xE4, 0xFD, 
+0x7F, 0x01, 0x61, 0xF7, 0x24, 0x48, 0xF9, 0xE4, 0x34, 0xFC, 0xFA, 0x7B, 0x01, 0x22, 0x7D, 0x2F, 
+0x12, 0x4C, 0x85, 0x7D, 0x08, 0x7F, 0x01, 0x61, 0xF7, 0xA3, 0xE0, 0x24, 0x28, 0xF9, 0xE4, 0x34, 
+0xFC, 0xFA, 0x7B, 0x01, 0x22, 0x7F, 0xF4, 0x12, 0x4C, 0x69, 0xEF, 0x20, 0xE5, 0x0E, 0x7F, 0xF4, 
+0x12, 0x4C, 0x69, 0xEF, 0x7F, 0x01, 0x20, 0xE4, 0x05, 0x7F, 0x02, 0x22, 0x7F, 0x03, 0x22, 0x11, 
+0x05, 0x90, 0x8D, 0x06, 0xEF, 0xF0, 0x11, 0x38, 0x90, 0x01, 0x64, 0x74, 0x01, 0xF0, 0x90, 0x04, 
+0x23, 0xE0, 0x44, 0x80, 0xF0, 0x02, 0x36, 0x83, 0x12, 0x4F, 0x26, 0x12, 0x4F, 0x48, 0x11, 0x45, 
+0x11, 0x64, 0x02, 0x4F, 0xC3, 0x75, 0x15, 0x10, 0xE4, 0xF5, 0x16, 0x75, 0x17, 0x07, 0x75, 0x18, 
+0x42, 0x90, 0x01, 0x30, 0xE5, 0x15, 0xF0, 0xA3, 0xE5, 0x16, 0xF0, 0xA3, 0xE5, 0x17, 0xF0, 0xA3, 
+0xE5, 0x18, 0xF0, 0x22, 0x75, 0x1D, 0x07, 0x75, 0x1E, 0x01, 0x75, 0x1F, 0x03, 0x75, 0x20, 0x62, 
+0x90, 0x01, 0x38, 0xE5, 0x1D, 0xF0, 0xA3, 0xE5, 0x1E, 0xF0, 0xA3, 0xE5, 0x1F, 0xF0, 0xA3, 0xE5, 
+0x20, 0xF0, 0x22, 0x75, 0xE8, 0x03, 0x75, 0xA8, 0x85, 0x22, 0xE4, 0x90, 0x93, 0x36, 0xF0, 0x90, 
+0x93, 0x36, 0xE0, 0x64, 0x01, 0xF0, 0x24, 0x8A, 0x90, 0x01, 0xC4, 0xF0, 0x74, 0x58, 0xA3, 0xF0, 
+0x12, 0x3D, 0x6E, 0xBF, 0x01, 0x03, 0x12, 0x31, 0x38, 0x90, 0x8E, 0x15, 0xE0, 0x60, 0x0F, 0x90, 
+0x8E, 0x18, 0xE0, 0xFF, 0x90, 0x8E, 0x17, 0xE0, 0x6F, 0x60, 0x03, 0x12, 0x77, 0xC1, 0xC2, 0xAF, 
+0x31, 0x21, 0xBF, 0x01, 0x02, 0x11, 0xD1, 0xD2, 0xAF, 0x12, 0x4F, 0xFA, 0x12, 0x46, 0x0D, 0x80, 
+0xBE, 0x90, 0x8E, 0x11, 0xE0, 0x30, 0xE0, 0x02, 0x11, 0xDB, 0x22, 0x90, 0x8E, 0x18, 0xE0, 0xFF, 
+0x60, 0x03, 0xB4, 0x08, 0x0D, 0x31, 0xA8, 0xBF, 0x01, 0x08, 0x11, 0xF3, 0x90, 0x01, 0xE5, 0xE0, 
+0x04, 0xF0, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x12, 0x4E, 0xDA, 0x31, 0x04, 0xD0, 
+0xD0, 0x92, 0xAF, 0x22, 0x12, 0x9F, 0x74, 0x7F, 0x08, 0x12, 0x4C, 0x69, 0xEF, 0x54, 0xEF, 0xFD, 
+0x7F, 0x08, 0x12, 0x4B, 0x9F, 0xE4, 0xFF, 0x31, 0x59, 0x90, 0x8E, 0x12, 0xE0, 0x54, 0xEF, 0xF0, 
+0x22, 0x7D, 0x02, 0x90, 0x01, 0xC4, 0x74, 0x21, 0xF0, 0x74, 0x59, 0xA3, 0xF0, 0x90, 0x93, 0x23, 
+0xE0, 0xFF, 0xED, 0xC3, 0x9F, 0x50, 0x14, 0xED, 0x25, 0xE0, 0x24, 0x81, 0xF8, 0xE6, 0x30, 0xE4, 
+0x07, 0x31, 0xF6, 0xA3, 0xF0, 0x7F, 0x00, 0x22, 0x0D, 0x80, 0xE2, 0x74, 0x21, 0x04, 0x90, 0x01, 
+0xC4, 0xF0, 0x74, 0x59, 0xA3, 0xF0, 0x7F, 0x01, 0x22, 0x90, 0x95, 0x30, 0xEF, 0x12, 0x94, 0x6D, 
+0x90, 0x01, 0x09, 0xE0, 0x7F, 0x00, 0x30, 0xE7, 0x02, 0x7F, 0x01, 0x90, 0x95, 0x30, 0xE0, 0x6F, 
+0x60, 0x35, 0xC3, 0x90, 0x95, 0x32, 0xE0, 0x94, 0x88, 0x90, 0x95, 0x31, 0xE0, 0x94, 0x13, 0x40, 
+0x08, 0x90, 0x01, 0xC0, 0xE0, 0x44, 0x10, 0xF0, 0x22, 0x90, 0x95, 0x31, 0x51, 0xA6, 0x12, 0x87, 
+0x92, 0xD3, 0x90, 0x95, 0x32, 0xE0, 0x94, 0x32, 0x90, 0x95, 0x31, 0xE0, 0x94, 0x00, 0x40, 0xC0, 
+0x90, 0x01, 0xC6, 0xE0, 0x30, 0xE0, 0xB9, 0x22, 0x90, 0x02, 0x87, 0xE0, 0x60, 0x04, 0x51, 0x97, 
+0x80, 0x3B, 0x90, 0x8E, 0xC0, 0xE0, 0x30, 0xE0, 0x0A, 0x90, 0x02, 0x82, 0xE0, 0x60, 0x04, 0x51, 
+0x90, 0x80, 0x2A, 0x90, 0x8E, 0xC9, 0xE0, 0x30, 0xE0, 0x04, 0x31, 0xF6, 0x80, 0x1F, 0x90, 0x02, 
+0x86, 0xE0, 0x20, 0xE1, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x04, 0xF0, 0x80, 0x10, 0x90, 0x04, 0x1D, 
+0xE0, 0x60, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x40, 0xF0, 0x80, 0x02, 0x41, 0x9E, 0x90, 0x01, 0xB9, 
+0x74, 0x08, 0xF0, 0x7F, 0x00, 0x22, 0x90, 0x01, 0xB8, 0x74, 0x08, 0xF0, 0x22, 0x12, 0xA7, 0x36, 
+0xEF, 0x64, 0x01, 0x60, 0x04, 0x51, 0x97, 0x80, 0x7E, 0x90, 0x8E, 0x19, 0xE0, 0xFF, 0x54, 0x03, 
+0x60, 0x04, 0x51, 0x90, 0x80, 0x71, 0x90, 0x8E, 0x17, 0xE0, 0xFE, 0xE4, 0xC3, 0x9E, 0x50, 0x08, 
+0x90, 0x01, 0xB8, 0x74, 0x04, 0xF0, 0x80, 0x5F, 0xEF, 0x30, 0xE2, 0x04, 0x31, 0xF6, 0x80, 0x57, 
+0x90, 0x8E, 0x19, 0xE0, 0x30, 0xE4, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x10, 0xF0, 0x80, 0x48, 0x90, 
+0x8E, 0x12, 0xE0, 0x13, 0x13, 0x54, 0x3F, 0x20, 0xE0, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x20, 0xF0, 
+0x80, 0x35, 0x90, 0x8E, 0xBF, 0xE0, 0x60, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x80, 0xF0, 0x80, 0x27, 
+0x90, 0x06, 0x62, 0xE0, 0x30, 0xE1, 0x08, 0x90, 0x01, 0xB8, 0x74, 0x11, 0xF0, 0x80, 0x18, 0x90, 
+0x06, 0x62, 0xE0, 0x30, 0xE0, 0x0F, 0xE0, 0x54, 0xFC, 0xFF, 0xBF, 0x80, 0x08, 0x90, 0x01, 0xB8, 
+0x74, 0x12, 0xF0, 0x80, 0x02, 0x80, 0x17, 0x90, 0x01, 0xB9, 0x74, 0x04, 0xF0, 0x7F, 0x00, 0x22, 
+0x90, 0x01, 0xB8, 0x74, 0x02, 0xF0, 0x22, 0x90, 0x01, 0xB8, 0x74, 0x01, 0xF0, 0x22, 0x90, 0x01, 
+0xB8, 0xE4, 0xF0, 0x7F, 0x01, 0x22, 0xE4, 0x75, 0xF0, 0x01, 0x02, 0x08, 0xD6, 0xD3, 0x10, 0xAF, 
+0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x93, 0x40, 0x12, 0x8C, 0xBA, 0x90, 0x93, 0x58, 0x74, 0x18, 0xF0, 
+0x7E, 0x00, 0x7F, 0x80, 0x7D, 0x00, 0x7B, 0x01, 0x7A, 0x93, 0x79, 0x60, 0x12, 0x08, 0xAA, 0x90, 
+0x01, 0xC4, 0x74, 0xAD, 0xF0, 0x74, 0x5A, 0xA3, 0xF0, 0x90, 0x93, 0x17, 0xE0, 0xFF, 0x12, 0x7F, 
+0xD6, 0x90, 0x93, 0x57, 0xEF, 0xF0, 0xF9, 0xE0, 0xFE, 0x24, 0x29, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 
+0xF5, 0x83, 0x74, 0x41, 0xF0, 0xEE, 0x24, 0x28, 0xFD, 0xE4, 0x33, 0xFC, 0x90, 0x93, 0x58, 0xE0, 
+0x7A, 0x00, 0x2D, 0xFE, 0xEA, 0x3C, 0x90, 0x93, 0x5C, 0xF0, 0xA3, 0xCE, 0xF0, 0x74, 0x28, 0x29, 
+0x12, 0x57, 0xFD, 0x90, 0x93, 0x42, 0xE0, 0xFD, 0x12, 0x91, 0x03, 0xF1, 0x89, 0x90, 0x93, 0x5C, 
+0xE0, 0xFF, 0xA3, 0xE0, 0x90, 0x93, 0x5A, 0xCF, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0x93, 0x60, 0x74, 
+0x01, 0xF0, 0xA3, 0x74, 0x03, 0xF0, 0xE4, 0xA3, 0xF0, 0xA3, 0x74, 0x5F, 0xF0, 0x90, 0x93, 0x5C, 
+0x12, 0x8A, 0xE7, 0x90, 0x8F, 0xDA, 0xE0, 0xFF, 0x7E, 0x02, 0xB4, 0xFE, 0x02, 0x7E, 0xFE, 0x90, 
+0x93, 0x5C, 0xA3, 0xE0, 0xFD, 0xB1, 0x8F, 0xEE, 0xF0, 0x74, 0x00, 0x2D, 0xB1, 0x91, 0xE0, 0x90, 
+0x93, 0x64, 0xF0, 0x90, 0x93, 0x5C, 0x51, 0xA6, 0x90, 0x90, 0x6F, 0xE0, 0x90, 0x93, 0x40, 0xB4, 
+0x01, 0x0B, 0xE0, 0x44, 0x03, 0xFC, 0xA3, 0xE0, 0x44, 0x10, 0xFD, 0x80, 0x09, 0xE0, 0x44, 0x03, 
+0xFC, 0xA3, 0xE0, 0x44, 0x20, 0xFD, 0x90, 0x93, 0x5E, 0xEC, 0xF0, 0xA3, 0xED, 0xF0, 0x90, 0x93, 
+0x65, 0x74, 0x03, 0xF0, 0xA3, 0x74, 0x12, 0xF0, 0xF1, 0xD0, 0xEF, 0x64, 0xFE, 0x70, 0x24, 0x90, 
+0x93, 0x5C, 0xA3, 0xE0, 0x24, 0x00, 0xF1, 0xE7, 0xC0, 0x03, 0x8B, 0x40, 0xF1, 0xDA, 0xD0, 0x03, 
+0x12, 0x34, 0x62, 0x75, 0x40, 0x01, 0xF1, 0xDA, 0x7B, 0x01, 0x7A, 0x93, 0x79, 0x67, 0x12, 0x34, 
+0x62, 0x80, 0x56, 0x90, 0x93, 0x12, 0xE0, 0xFF, 0xB4, 0x02, 0x26, 0x90, 0x93, 0x5C, 0xE0, 0xFC, 
+0xA3, 0xE0, 0xFD, 0x24, 0x00, 0xF5, 0x82, 0x74, 0xFC, 0x3C, 0xF5, 0x83, 0xE4, 0xF0, 0x74, 0x01, 
+0x2D, 0xF5, 0x82, 0x74, 0xFC, 0x3C, 0xF5, 0x83, 0x74, 0x20, 0xF1, 0xA5, 0x74, 0x20, 0xF0, 0x80, 
+0x28, 0xEF, 0xB4, 0x04, 0x24, 0x90, 0x93, 0x5C, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x24, 0x00, 0xF5, 
+0x82, 0x74, 0xFC, 0x3E, 0xF5, 0x83, 0xE4, 0xF0, 0x74, 0x01, 0x2F, 0xF5, 0x82, 0x74, 0xFC, 0x3E, 
+0xF5, 0x83, 0x74, 0x10, 0xF1, 0xA5, 0x74, 0x10, 0xF0, 0xF1, 0xD0, 0xE4, 0x90, 0x93, 0x59, 0xF0, 
+0x12, 0xA9, 0x3A, 0xE0, 0xFE, 0x90, 0x93, 0x5C, 0xA3, 0xE0, 0xFD, 0xEF, 0x2D, 0xB1, 0x8F, 0xEE, 
+0xF0, 0x12, 0xA9, 0x3A, 0xE0, 0xFE, 0x74, 0x69, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x93, 0xF5, 0x83, 
+0xEE, 0xF1, 0x78, 0xE0, 0xB4, 0x08, 0xD9, 0xF1, 0x93, 0x90, 0x93, 0x5C, 0x12, 0xAA, 0x4A, 0x90, 
+0x93, 0x5C, 0xE4, 0x75, 0xF0, 0x10, 0x12, 0x08, 0xD6, 0xF1, 0x89, 0xE4, 0x90, 0x93, 0xE3, 0xF0, 
+0xE4, 0x90, 0x93, 0x59, 0xF0, 0xF1, 0xBE, 0x50, 0x0A, 0x12, 0x9F, 0x53, 0xB1, 0x8E, 0xE4, 0xF1, 
+0x78, 0x80, 0xF2, 0x7F, 0x64, 0x7E, 0x00, 0x12, 0x3D, 0x7A, 0x90, 0x06, 0x31, 0xE0, 0x54, 0xFB, 
+0xF0, 0x90, 0x93, 0x18, 0xE0, 0xFD, 0xFF, 0x90, 0x93, 0x17, 0xE0, 0xC3, 0x9F, 0xFF, 0xEF, 0xFE, 
+0x90, 0x93, 0x58, 0x12, 0x60, 0x10, 0xCF, 0x24, 0x38, 0xCF, 0x34, 0x00, 0xFE, 0xC0, 0x06, 0xC0, 
+0x07, 0x90, 0xAC, 0x7A, 0x74, 0x10, 0xF0, 0xED, 0xFE, 0xE4, 0x78, 0x03, 0xCE, 0xC3, 0x13, 0xCE, 
+0x13, 0xD8, 0xF9, 0xFF, 0x90, 0xAC, 0x7B, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0xD0, 0x07, 0xD0, 0x06, 
+0x7B, 0x63, 0xE4, 0xFD, 0xFC, 0x12, 0x38, 0xC6, 0x7B, 0x01, 0x7A, 0x93, 0x79, 0x60, 0x90, 0xAC, 
+0xA0, 0x12, 0x49, 0x21, 0x7A, 0x93, 0x79, 0x43, 0x90, 0xAC, 0xA3, 0x12, 0x49, 0x21, 0x90, 0xAC, 
+0xA6, 0x74, 0x10, 0xF0, 0x7A, 0x8F, 0x79, 0x96, 0x12, 0x34, 0xC2, 0x90, 0x93, 0xE3, 0xE0, 0x04, 
+0xF0, 0x90, 0x06, 0x31, 0xE0, 0x30, 0xE2, 0x06, 0xF1, 0x9D, 0x50, 0x02, 0x81, 0x60, 0xF1, 0x9D, 
+0x40, 0x0A, 0x90, 0x06, 0x35, 0xE0, 0x44, 0x20, 0x90, 0x06, 0x34, 0xF0, 0xE4, 0x90, 0x93, 0x59, 
+0xF0, 0xF1, 0xBE, 0x50, 0x1C, 0x12, 0x9F, 0x53, 0x90, 0x93, 0x59, 0xE0, 0x24, 0x43, 0xF5, 0x82, 
+0xE4, 0x34, 0x93, 0xF5, 0x83, 0xE0, 0xFF, 0x90, 0x93, 0x57, 0xB1, 0x8E, 0xEF, 0xF1, 0x78, 0x80, 
+0xE0, 0x90, 0x04, 0x1D, 0xE0, 0x60, 0x23, 0x90, 0x05, 0x22, 0xE0, 0x90, 0x93, 0xE2, 0xF0, 0x7D, 
+0x1D, 0x12, 0x57, 0x73, 0xBF, 0x01, 0x07, 0x12, 0x82, 0x14, 0x12, 0xA9, 0xA7, 0xF0, 0x90, 0x93, 
+0xE2, 0xE0, 0xFF, 0x7D, 0x1E, 0x12, 0x54, 0x6C, 0x80, 0x07, 0x12, 0x82, 0x14, 0x12, 0xA9, 0xA7, 
+0xF0, 0x12, 0x55, 0xDF, 0x90, 0x8E, 0x18, 0xE0, 0x70, 0x05, 0x7F, 0x01, 0x12, 0x53, 0xA6, 0x74, 
+0xAD, 0x04, 0x90, 0x01, 0xC4, 0xF0, 0x74, 0x5A, 0xA3, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x12, 
+0x48, 0x6D, 0xA8, 0x04, 0xA9, 0x05, 0xAA, 0x06, 0xAB, 0x07, 0x90, 0x93, 0x3C, 0xA3, 0xE0, 0x24, 
+0x00, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 
+0x90, 0x94, 0xBF, 0xEC, 0xF0, 0xA3, 0xED, 0xF0, 0xAA, 0x07, 0x90, 0x94, 0xC5, 0x12, 0x08, 0x79, 
+0x00, 0x00, 0x00, 0x00, 0x90, 0xFD, 0x10, 0xEB, 0xF0, 0xEA, 0x24, 0xEF, 0x60, 0x43, 0x24, 0xD7, 
+0x70, 0x02, 0xC1, 0x82, 0x24, 0x3A, 0x60, 0x02, 0xC1, 0xB8, 0xD1, 0xE9, 0x24, 0x0A, 0xD1, 0xF0, 
+0xED, 0xF0, 0xFE, 0xB1, 0x8F, 0xD1, 0xDC, 0xE4, 0xF0, 0xFE, 0x74, 0x00, 0x2F, 0xF1, 0xAD, 0x7D, 
+0x14, 0x7C, 0x00, 0xF1, 0xB5, 0x7B, 0x00, 0x7A, 0x00, 0x79, 0x00, 0x90, 0xAC, 0x67, 0x12, 0x49, 
+0x21, 0xD1, 0xD6, 0x90, 0xAC, 0x6A, 0x12, 0x08, 0x6D, 0x7D, 0x14, 0x7C, 0x00, 0xE4, 0xFF, 0x80, 
+0x7C, 0x90, 0x94, 0xBF, 0xE4, 0x75, 0xF0, 0x14, 0x12, 0x08, 0xD6, 0x90, 0x94, 0xBF, 0xA3, 0xE0, 
+0xFB, 0xFF, 0x24, 0x06, 0xFC, 0xD1, 0xF1, 0xCC, 0xF0, 0x90, 0x94, 0xC9, 0xA3, 0xE0, 0xFE, 0xB1, 
+0x8F, 0xD1, 0xDC, 0xE4, 0x12, 0x86, 0xC7, 0xE0, 0xFE, 0xAD, 0x03, 0x12, 0xAA, 0x27, 0x12, 0x60, 
+0x0E, 0x90, 0x94, 0xC3, 0xF0, 0xA3, 0xEF, 0xF0, 0xED, 0x7E, 0x00, 0x24, 0x00, 0xF1, 0xAD, 0xF1, 
+0xC7, 0xF1, 0xB5, 0x90, 0x94, 0xBF, 0x74, 0xFF, 0x75, 0xF0, 0xEC, 0x12, 0x08, 0xD6, 0xD1, 0xE9, 
+0x7E, 0x00, 0x24, 0x0C, 0xF9, 0xEE, 0x34, 0xFC, 0xFA, 0x7B, 0x01, 0xC0, 0x02, 0xC0, 0x01, 0x74, 
+0x10, 0x2F, 0xF9, 0xEE, 0x34, 0xFC, 0xFA, 0x90, 0xAC, 0x67, 0x12, 0x49, 0x21, 0xD1, 0xD6, 0x90, 
+0xAC, 0x6A, 0x12, 0x08, 0x6D, 0xF1, 0xC7, 0xD0, 0x01, 0xD0, 0x02, 0x7F, 0x11, 0x12, 0x1B, 0x9A, 
+0x80, 0x2E, 0xD1, 0xE9, 0x24, 0x2A, 0xD1, 0xF0, 0xED, 0xF0, 0xFE, 0xB1, 0x8F, 0xD1, 0xDC, 0xE4, 
+0xF0, 0xF1, 0xE4, 0x7D, 0x48, 0x7C, 0x00, 0x12, 0x24, 0xE6, 0xD1, 0xD0, 0xF1, 0xEF, 0x12, 0x48, 
+0x6D, 0xE4, 0xFD, 0xFC, 0xD1, 0xD0, 0xF1, 0xEF, 0x12, 0x48, 0x6D, 0xD1, 0xD0, 0x12, 0x08, 0x3A, 
+0x90, 0x94, 0xC1, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0x94, 0xC1, 0x12, 0xAA, 0x60, 0x90, 0x94, 
+0xC9, 0xA3, 0xE0, 0xFE, 0xB1, 0x8F, 0xEF, 0xD1, 0xDD, 0xED, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 
+0x90, 0x94, 0xC5, 0x12, 0x08, 0x6D, 0x90, 0x94, 0xC5, 0x02, 0x48, 0xF4, 0xE4, 0xF0, 0x74, 0x01, 
+0x2E, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0x22, 0x90, 0x94, 0xBF, 0xA3, 0xE0, 0xFF, 0x22, 
+0xFD, 0xE4, 0x33, 0x90, 0x94, 0xC9, 0xF0, 0xA3, 0x22, 0xE4, 0x90, 0x93, 0xE7, 0xF0, 0xA3, 0xF0, 
+0x90, 0x06, 0x32, 0xE0, 0x44, 0x20, 0xF0, 0x12, 0x9F, 0x14, 0xEF, 0x64, 0x01, 0x70, 0x68, 0x90, 
+0x93, 0x1F, 0xE0, 0xFF, 0x7B, 0x08, 0x7D, 0x01, 0x12, 0x82, 0x1D, 0x12, 0x9D, 0xEF, 0x90, 0x93, 
+0xE4, 0x12, 0xA8, 0xD4, 0x12, 0x84, 0x71, 0x90, 0x93, 0xE6, 0xEF, 0xF0, 0x90, 0x93, 0xE4, 0x12, 
+0x57, 0xF9, 0xE4, 0xFD, 0x12, 0x91, 0x03, 0x90, 0x93, 0xE6, 0xE0, 0xFF, 0x90, 0x93, 0xE5, 0xE0, 
+0x2F, 0xFF, 0x90, 0x93, 0xE4, 0xE0, 0x34, 0x00, 0xCF, 0x24, 0x30, 0xCF, 0x34, 0x00, 0xFE, 0x90, 
+0x93, 0xE7, 0xF0, 0xA3, 0xEF, 0xF0, 0x12, 0xA7, 0xAE, 0xF1, 0x80, 0x90, 0x93, 0x1F, 0xE0, 0xFB, 
+0xE4, 0xFF, 0xB1, 0x99, 0xF1, 0x80, 0x90, 0x93, 0x1B, 0xE0, 0xFB, 0x7F, 0x11, 0xB1, 0x99, 0x12, 
+0x55, 0xDF, 0x90, 0x90, 0x82, 0x51, 0xA6, 0x22, 0xF0, 0x90, 0x93, 0x59, 0xE0, 0x04, 0xF0, 0x22, 
+0x90, 0x93, 0xE7, 0xE0, 0xFC, 0xA3, 0xE0, 0xFD, 0x22, 0x90, 0x93, 0x5C, 0xE4, 0x75, 0xF0, 0x08, 
+0x12, 0x08, 0xD6, 0x90, 0x93, 0x5C, 0xE4, 0x75, 0xF0, 0x08, 0x02, 0x08, 0xD6, 0x90, 0x93, 0xE3, 
+0xE0, 0xC3, 0x94, 0x0A, 0x22, 0xF0, 0xE4, 0x90, 0x93, 0x67, 0xF0, 0xA3, 0x22, 0xF9, 0xEE, 0x34, 
+0xFC, 0xFA, 0x7B, 0x01, 0x22, 0x12, 0x24, 0xE6, 0x90, 0x94, 0xC5, 0x02, 0x08, 0x6D, 0x90, 0x93, 
+0x59, 0xE0, 0xFF, 0xC3, 0x94, 0x10, 0x22, 0x90, 0x94, 0xC3, 0xE0, 0xFC, 0xA3, 0xE0, 0xFD, 0x22, 
+0x90, 0x93, 0x5C, 0xE4, 0x75, 0xF0, 0x02, 0x02, 0x08, 0xD6, 0x75, 0x41, 0x8F, 0x75, 0x42, 0xDD, 
+0x75, 0x43, 0x02, 0x22, 0x74, 0x00, 0x2F, 0xF9, 0xE4, 0x34, 0xFC, 0xFA, 0x7B, 0x01, 0x22, 0x78, 
+0x10, 0x12, 0x08, 0x47, 0x90, 0x94, 0xC5, 0x02, 0x49, 0x00, 0x74, 0x01, 0x2D, 0xF5, 0x82, 0xE4, 
+0x34, 0xFB, 0xF5, 0x83, 0xE0, 0xFE, 0x74, 0x00, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 0xFB, 0xF5, 0x83, 
+0xE0, 0x7A, 0x00, 0x24, 0x00, 0xFF, 0xEA, 0x3E, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 
+0xA9, 0x07, 0x90, 0x06, 0x69, 0xE0, 0xFE, 0x90, 0x06, 0x68, 0x11, 0x10, 0xFE, 0xE9, 0x14, 0x60, 
+0x0F, 0x14, 0x60, 0x1E, 0x24, 0x02, 0x70, 0x25, 0xEE, 0x54, 0xFE, 0xFE, 0x11, 0x62, 0x80, 0x1A, 
+0xEF, 0x44, 0x80, 0xFF, 0xEE, 0x54, 0xFE, 0xFC, 0x90, 0x06, 0x68, 0xEF, 0xF0, 0xEC, 0xA3, 0xF0, 
+0x80, 0x0B, 0xEE, 0x44, 0x01, 0xFC, 0x11, 0x62, 0xAE, 0x04, 0xEE, 0xA3, 0xF0, 0xD0, 0xD0, 0x92, 
+0xAF, 0x22, 0xEF, 0x54, 0x7F, 0x90, 0x06, 0x68, 0xF0, 0x22, 0x90, 0x95, 0x22, 0xF1, 0xF7, 0xEB, 
+0xF0, 0xE4, 0xFE, 0x7D, 0x18, 0xFF, 0x12, 0x3D, 0x2C, 0x90, 0x95, 0x25, 0xEF, 0xF0, 0x90, 0x95, 
+0x22, 0xE0, 0xFF, 0x11, 0x19, 0x90, 0x95, 0x22, 0x12, 0x98, 0xD0, 0x12, 0x9F, 0xF7, 0xAE, 0x07, 
+0x90, 0x04, 0x83, 0xEE, 0xF0, 0x90, 0x95, 0x22, 0xE0, 0xFF, 0xAD, 0x06, 0x91, 0x09, 0x90, 0x95, 
+0x22, 0xE0, 0xFF, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0xEF, 0x14, 0x60, 0x30, 0x14, 0x60, 
+0x56, 0x24, 0x02, 0x70, 0x7B, 0x90, 0x94, 0x7D, 0x12, 0x08, 0x79, 0x00, 0x00, 0x0C, 0x00, 0x90, 
+0x94, 0x81, 0x12, 0x08, 0x79, 0x00, 0x00, 0x0C, 0x00, 0x71, 0xFD, 0x12, 0x08, 0x79, 0x00, 0x00, 
+0x0C, 0x00, 0x90, 0x94, 0x81, 0x12, 0x08, 0x79, 0x00, 0x00, 0x0C, 0x00, 0x80, 0x50, 0x90, 0x94, 
+0x7D, 0x12, 0x08, 0x79, 0x00, 0x00, 0x0C, 0x00, 0x90, 0x94, 0x81, 0x12, 0x08, 0x79, 0x00, 0x00, 
+0x04, 0x00, 0x71, 0xFD, 0x12, 0x08, 0x79, 0x00, 0x00, 0x0C, 0x00, 0x90, 0x94, 0x81, 0x12, 0x08, 
+0x79, 0x00, 0x00, 0x04, 0x00, 0x80, 0x27, 0x90, 0x94, 0x7D, 0x12, 0x08, 0x79, 0x00, 0x00, 0x0C, 
+0x00, 0x90, 0x94, 0x81, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 0x00, 0x71, 0xFD, 0x12, 0x08, 0x79, 
+0x00, 0x00, 0x0C, 0x00, 0x90, 0x94, 0x81, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 0x00, 0x31, 0x35, 
+0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x7D, 0x18, 0x7C, 0x00, 0x7F, 0x01, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 
+0xC0, 0xD0, 0x90, 0x94, 0x7B, 0xEC, 0xF0, 0xA3, 0xED, 0xF0, 0x90, 0x94, 0x7A, 0xEF, 0xF0, 0xA3, 
+0xA3, 0xE0, 0xFD, 0x12, 0x87, 0xE4, 0x90, 0x94, 0x85, 0x12, 0x08, 0x6D, 0x90, 0x94, 0x7D, 0x12, 
+0x48, 0xF4, 0x12, 0x08, 0x3A, 0x90, 0x94, 0x85, 0xF1, 0xB2, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 
+0xC0, 0x07, 0x90, 0x94, 0x7D, 0x12, 0x48, 0xF4, 0x90, 0x94, 0x81, 0xF1, 0xB2, 0xD0, 0x03, 0xD0, 
+0x02, 0xD0, 0x01, 0xD0, 0x00, 0x12, 0x48, 0xD6, 0x90, 0x94, 0x89, 0x12, 0x08, 0x6D, 0x90, 0x94, 
+0x7B, 0xA3, 0xE0, 0xFD, 0xC0, 0x05, 0x90, 0x94, 0x89, 0x12, 0x48, 0xF4, 0x90, 0xAA, 0x96, 0x12, 
+0x08, 0x6D, 0x90, 0x94, 0x7A, 0xE0, 0xFF, 0xD0, 0x05, 0x12, 0x3C, 0x33, 0xD0, 0xD0, 0x92, 0xAF, 
+0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x95, 0x1F, 0xED, 0xF0, 0xA3, 0xEB, 0xF0, 
+0x90, 0x95, 0x1E, 0xEF, 0xF0, 0x90, 0x95, 0x21, 0xE0, 0xFD, 0x12, 0x9F, 0x9F, 0x90, 0x95, 0x1E, 
+0xE0, 0xC3, 0x94, 0x0E, 0x50, 0x3F, 0x90, 0x94, 0x8F, 0x12, 0x08, 0x79, 0x1F, 0xFE, 0x00, 0x00, 
+0x90, 0x94, 0x93, 0x12, 0x08, 0x79, 0x12, 0xD4, 0x00, 0x00, 0xF1, 0xBE, 0x90, 0x94, 0x7D, 0x12, 
+0x08, 0x79, 0x00, 0x07, 0x03, 0x00, 0x90, 0x94, 0x81, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 0x00, 
+0x71, 0xFD, 0x12, 0x08, 0x79, 0x00, 0x07, 0x03, 0x00, 0x90, 0x94, 0x81, 0x12, 0x08, 0x79, 0x00, 
+0x00, 0x00, 0x00, 0x61, 0x34, 0x12, 0xAA, 0x01, 0x50, 0x1B, 0xEF, 0x94, 0x30, 0x50, 0x16, 0x90, 
+0x94, 0x8F, 0x12, 0x08, 0x79, 0x1F, 0xFE, 0x00, 0x00, 0x90, 0x94, 0x93, 0x12, 0x08, 0x79, 0x09, 
+0x28, 0x00, 0x00, 0x80, 0x65, 0x90, 0x95, 0x1E, 0xE0, 0xFF, 0x74, 0x32, 0xD3, 0x9F, 0x50, 0x1B, 
+0xEF, 0x94, 0x40, 0x50, 0x16, 0x90, 0x94, 0x8F, 0x12, 0x08, 0x79, 0x1F, 0xFE, 0x00, 0x00, 0x90, 
+0x94, 0x93, 0x12, 0x08, 0x79, 0x08, 0xA6, 0x00, 0x00, 0x80, 0x3F, 0x12, 0xA9, 0xF7, 0x50, 0x1B, 
+0xEF, 0x94, 0x74, 0x50, 0x16, 0x90, 0x94, 0x8F, 0x12, 0x08, 0x79, 0x1F, 0xFE, 0x00, 0x00, 0x90, 
+0x94, 0x93, 0x12, 0x08, 0x79, 0x08, 0xA4, 0x00, 0x00, 0x80, 0x1F, 0x90, 0x95, 0x1E, 0xE0, 0xFF, 
+0x74, 0x76, 0xD3, 0x9F, 0x50, 0x16, 0x90, 0x94, 0x8F, 0x12, 0x08, 0x79, 0x1F, 0xFE, 0x00, 0x00, 
+0x90, 0x94, 0x93, 0x12, 0x08, 0x79, 0x08, 0x24, 0x00, 0x00, 0xF1, 0xBE, 0x12, 0xAA, 0x01, 0x50, 
+0x2E, 0xEF, 0x94, 0x40, 0x50, 0x29, 0x90, 0x94, 0x7D, 0x12, 0x08, 0x79, 0x00, 0x07, 0x03, 0x00, 
+0x90, 0x94, 0x81, 0x12, 0x08, 0x79, 0x00, 0x01, 0x01, 0x00, 0x71, 0xFD, 0x12, 0x08, 0x79, 0x00, 
+0x07, 0x03, 0x00, 0x90, 0x94, 0x81, 0x12, 0x08, 0x79, 0x00, 0x01, 0x01, 0x00, 0x80, 0x65, 0x12, 
+0xA9, 0xF7, 0x50, 0x2E, 0xEF, 0x94, 0x8C, 0x50, 0x29, 0x90, 0x94, 0x7D, 0x12, 0x08, 0x79, 0x00, 
+0x07, 0x03, 0x00, 0x90, 0x94, 0x81, 0x12, 0x08, 0x79, 0x00, 0x03, 0x01, 0x00, 0x71, 0xFD, 0x12, 
+0x08, 0x79, 0x00, 0x07, 0x03, 0x00, 0x90, 0x94, 0x81, 0x12, 0x08, 0x79, 0x00, 0x03, 0x01, 0x00, 
+0x80, 0x32, 0x90, 0x95, 0x1E, 0xE0, 0xFF, 0x74, 0x8C, 0xC3, 0x9F, 0x50, 0x29, 0x90, 0x94, 0x7D, 
+0x12, 0x08, 0x79, 0x00, 0x07, 0x03, 0x00, 0x90, 0x94, 0x81, 0x12, 0x08, 0x79, 0x00, 0x05, 0x01, 
+0x00, 0x71, 0xFD, 0x12, 0x08, 0x79, 0x00, 0x07, 0x03, 0x00, 0x90, 0x94, 0x81, 0x12, 0x08, 0x79, 
+0x00, 0x05, 0x01, 0x00, 0x31, 0x35, 0x90, 0x95, 0x1F, 0xE0, 0x64, 0x02, 0x70, 0x51, 0x90, 0x95, 
+0x1E, 0xE0, 0xFF, 0xD3, 0x94, 0x30, 0x50, 0x05, 0x75, 0x5A, 0x2A, 0x80, 0x5E, 0xEF, 0xD3, 0x94, 
+0x40, 0x50, 0x05, 0x75, 0x5A, 0x3A, 0x80, 0x53, 0xEF, 0xD3, 0x94, 0x70, 0x50, 0x05, 0x75, 0x5A, 
+0x6A, 0x80, 0x48, 0xEF, 0xD3, 0x94, 0x80, 0x50, 0x05, 0x75, 0x5A, 0x7A, 0x80, 0x3D, 0xEF, 0xD3, 
+0x94, 0x90, 0x50, 0x05, 0x75, 0x5A, 0x8A, 0x80, 0x32, 0xEF, 0xD3, 0x94, 0xA1, 0x50, 0x05, 0x75, 
+0x5A, 0x9B, 0x80, 0x27, 0xEF, 0xD3, 0x94, 0xB1, 0x50, 0x21, 0x75, 0x5A, 0xAB, 0x80, 0x1C, 0x90, 
+0x95, 0x1F, 0xE0, 0x64, 0x01, 0x70, 0x31, 0xA3, 0xE0, 0x90, 0x95, 0x1E, 0xB4, 0x01, 0x07, 0xE0, 
+0x24, 0x02, 0xF5, 0x5A, 0x80, 0x05, 0xE0, 0x24, 0xFE, 0xF5, 0x5A, 0x90, 0x94, 0x7D, 0x12, 0x08, 
+0x79, 0x00, 0x00, 0x00, 0xFF, 0xAF, 0x5A, 0xE4, 0xFC, 0xFD, 0xFE, 0x71, 0xF7, 0x12, 0x08, 0x79, 
+0x00, 0x00, 0x00, 0xFF, 0xAF, 0x5A, 0x80, 0x1E, 0x90, 0x94, 0x7D, 0x12, 0x08, 0x79, 0x00, 0x00, 
+0x00, 0xFF, 0x90, 0x95, 0x1E, 0x12, 0x80, 0x77, 0x71, 0xF7, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 
+0xFF, 0x90, 0x95, 0x1E, 0xE0, 0xFF, 0xE4, 0xFC, 0xFD, 0xFE, 0x90, 0x94, 0x81, 0x12, 0x08, 0x6D, 
+0x31, 0x35, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0x94, 0x81, 0x12, 0x08, 0x6D, 0x7D, 0x18, 0x7C, 
+0x00, 0xE4, 0xFF, 0x31, 0x3B, 0x90, 0x94, 0x7D, 0x22, 0x90, 0x94, 0xEF, 0xF1, 0xF7, 0x12, 0x08, 
+0x79, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x34, 0x7E, 0x08, 0x12, 0x37, 0xBC, 0x90, 0x94, 0xF1, 0x12, 
+0x08, 0x6D, 0x90, 0x94, 0xEF, 0xE0, 0x14, 0x60, 0x5E, 0x14, 0x70, 0x02, 0xA1, 0x46, 0x24, 0x02, 
+0x60, 0x02, 0xA1, 0xD5, 0x90, 0x94, 0x8F, 0x12, 0x08, 0x79, 0x00, 0x30, 0x03, 0xC3, 0x90, 0x94, 
+0x93, 0x12, 0x08, 0x79, 0x00, 0x30, 0x02, 0x00, 0xD1, 0x4E, 0x12, 0x08, 0x79, 0x40, 0x00, 0x00, 
+0x00, 0x90, 0x94, 0x93, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xC4, 0xD1, 0x50, 0x12, 
+0x08, 0x79, 0x00, 0x1C, 0x00, 0x00, 0x90, 0x94, 0x93, 0x12, 0x08, 0x79, 0x00, 0x10, 0x00, 0x00, 
+0x7F, 0x64, 0xD1, 0x50, 0x12, 0x08, 0x79, 0x03, 0xC0, 0x00, 0x00, 0x90, 0x94, 0x93, 0x12, 0x08, 
+0x79, 0x02, 0x00, 0x00, 0x00, 0xA1, 0xB8, 0x90, 0x94, 0x8F, 0x12, 0x08, 0x79, 0x00, 0x30, 0x03, 
+0xC3, 0x90, 0x94, 0x93, 0x12, 0x08, 0x79, 0x00, 0x30, 0x02, 0x01, 0xD1, 0x4E, 0x12, 0x08, 0x79, 
+0x40, 0x00, 0x00, 0x00, 0x90, 0x94, 0x93, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xC4, 
+0xD1, 0x50, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 0x3C, 0xD1, 0x3A, 0x12, 0x08, 0x79, 0xF0, 0x00, 
+0x00, 0x00, 0x90, 0x94, 0xF0, 0x12, 0x80, 0x77, 0x78, 0x1C, 0x12, 0x08, 0x5A, 0xF1, 0xF1, 0x7F, 
+0x38, 0xD1, 0x50, 0x12, 0x08, 0x79, 0x00, 0x1C, 0x00, 0x00, 0x90, 0x94, 0x93, 0x12, 0x08, 0x79, 
+0x00, 0x08, 0x00, 0x00, 0xF1, 0xD9, 0x60, 0x13, 0x12, 0x08, 0x79, 0x03, 0xC0, 0x00, 0x00, 0x90, 
+0x94, 0x93, 0x12, 0x08, 0x79, 0x01, 0x80, 0x00, 0x00, 0x80, 0x11, 0x12, 0x08, 0x79, 0x03, 0xC0, 
+0x00, 0x00, 0x90, 0x94, 0x93, 0x12, 0x08, 0x79, 0x02, 0x00, 0x00, 0x00, 0x7F, 0x48, 0x7E, 0x08, 
+0xB1, 0xDA, 0x90, 0x94, 0xF0, 0xE0, 0x90, 0x94, 0x8F, 0xB4, 0x01, 0x13, 0x12, 0x08, 0x79, 0x00, 
+0x00, 0x00, 0x10, 0x90, 0x94, 0x93, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 0x10, 0x80, 0x11, 0x12, 
+0x08, 0x79, 0x00, 0x00, 0x00, 0x10, 0x90, 0x94, 0x93, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 0x00, 
+0x7F, 0x00, 0x7E, 0x0A, 0xA1, 0xD3, 0x90, 0x94, 0x8F, 0x12, 0x08, 0x79, 0x00, 0x30, 0x03, 0xC3, 
+0x90, 0x94, 0x93, 0x12, 0x08, 0x79, 0x00, 0x30, 0x02, 0x02, 0xD1, 0x4E, 0x12, 0x08, 0x79, 0x40, 
+0x00, 0x00, 0x00, 0x90, 0x94, 0x93, 0x12, 0x08, 0x79, 0x40, 0x00, 0x00, 0x00, 0x7F, 0xC4, 0xD1, 
+0x50, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 0x3C, 0xD1, 0x3A, 0x12, 0x08, 0x79, 0xF0, 0x00, 0x00, 
+0x00, 0x90, 0x94, 0xF0, 0x12, 0x80, 0x77, 0x78, 0x1C, 0x12, 0x08, 0x5A, 0xF1, 0xF1, 0x7F, 0x38, 
+0xD1, 0x50, 0x12, 0x08, 0x79, 0x00, 0x1C, 0x00, 0x00, 0x90, 0x94, 0x93, 0x12, 0x08, 0x79, 0x00, 
+0x08, 0x00, 0x00, 0xF1, 0xD9, 0x60, 0x17, 0x12, 0x08, 0x79, 0x03, 0xC0, 0x00, 0x00, 0x90, 0x94, 
+0x93, 0x12, 0x08, 0x79, 0x01, 0x40, 0x00, 0x00, 0x7F, 0x48, 0x7E, 0x08, 0x80, 0x15, 0x12, 0x08, 
+0x79, 0x03, 0xC0, 0x00, 0x00, 0x90, 0x94, 0x93, 0x12, 0x08, 0x79, 0x01, 0xC0, 0x00, 0x00, 0x7F, 
+0x48, 0x7E, 0x08, 0xB1, 0xDA, 0x22, 0x7F, 0xB0, 0x7E, 0x0C, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 
+0xD0, 0x90, 0x94, 0x8D, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x12, 0x37, 0xBC, 0x90, 0x94, 0x97, 0x12, 
+0x08, 0x6D, 0x90, 0x94, 0x8F, 0x12, 0x48, 0xF4, 0x12, 0x08, 0x3A, 0x90, 0x94, 0x97, 0xF1, 0xB2, 
+0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0x94, 0x8F, 0x12, 0x48, 0xF4, 0x90, 0x94, 
+0x93, 0xF1, 0xB2, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0x12, 0x48, 0xD6, 0x90, 0x94, 
+0x9B, 0x12, 0x08, 0x6D, 0x90, 0x94, 0x9B, 0x12, 0x4E, 0xD2, 0x90, 0x94, 0x8D, 0xE0, 0xFE, 0xA3, 
+0xE0, 0xFF, 0x12, 0x38, 0x07, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0x94, 0xF0, 0xE0, 0xFF, 0xE4, 
+0xFC, 0xFD, 0xFE, 0x78, 0x02, 0x12, 0x08, 0x5A, 0x90, 0x94, 0x93, 0x12, 0x08, 0x6D, 0x7F, 0xAC, 
+0x7E, 0x08, 0xB1, 0xDA, 0x90, 0x94, 0x8F, 0x22, 0x90, 0x95, 0x34, 0xED, 0xF0, 0x90, 0x95, 0x33, 
+0xEF, 0xF0, 0x60, 0x02, 0xE1, 0x07, 0x90, 0x94, 0x8F, 0x12, 0x08, 0x79, 0x30, 0x00, 0x00, 0x00, 
+0x90, 0x94, 0x93, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 0x00, 0x74, 0x08, 0xFF, 0xFE, 0xD1, 0x52, 
+0x12, 0x08, 0x79, 0x00, 0x00, 0xF0, 0x00, 0x90, 0x94, 0x93, 0x12, 0x08, 0x79, 0x00, 0x00, 0x70, 
+0x00, 0x7F, 0xB0, 0x7E, 0x0C, 0xD1, 0x52, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 0xF0, 0x90, 0x94, 
+0x93, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 0x70, 0x7F, 0xB0, 0x7E, 0x0C, 0xD1, 0x52, 0x12, 0x08, 
+0x79, 0x00, 0x00, 0x00, 0x0E, 0x90, 0x94, 0x93, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 0x08, 0x7F, 
+0x30, 0xD1, 0x50, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 0x03, 0x90, 0x94, 0x93, 0x12, 0x08, 0x79, 
+0x00, 0x00, 0x00, 0x01, 0x7F, 0x34, 0xD1, 0x50, 0x12, 0x08, 0x79, 0x00, 0x00, 0x0F, 0x00, 0x90, 
+0x94, 0x93, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 0x00, 0xF1, 0xC4, 0x12, 0x08, 0x79, 0x30, 0x00, 
+0x00, 0x00, 0x90, 0x94, 0x93, 0x12, 0x08, 0x79, 0x30, 0x00, 0x00, 0x00, 0xF1, 0xB8, 0x90, 0x04, 
+0x54, 0xE0, 0x54, 0x7F, 0x02, 0xA9, 0xED, 0x90, 0x95, 0x33, 0xE0, 0x64, 0x01, 0x60, 0x02, 0xE1, 
+0xB1, 0x90, 0x94, 0x8F, 0x12, 0x08, 0x79, 0x00, 0x00, 0xF0, 0x00, 0x90, 0x94, 0x93, 0x12, 0x08, 
+0x79, 0x00, 0x00, 0x50, 0x00, 0x7F, 0xB0, 0x7E, 0x0C, 0xD1, 0x52, 0x12, 0x08, 0x79, 0x00, 0x00, 
+0x00, 0xF0, 0x90, 0x94, 0x93, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 0x40, 0xB1, 0xD6, 0x90, 0x04, 
+0x54, 0xE0, 0x44, 0x80, 0x12, 0xA9, 0xED, 0x90, 0x94, 0x8F, 0x12, 0x08, 0x79, 0x30, 0x00, 0x00, 
+0x00, 0x90, 0x94, 0x93, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 0x00, 0x74, 0x08, 0xFF, 0xFE, 0xD1, 
+0x52, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 0x0E, 0x90, 0x94, 0x93, 0x12, 0x08, 0x79, 0x00, 0x00, 
+0x00, 0x06, 0x7F, 0x30, 0xD1, 0x50, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 0x03, 0x90, 0x94, 0x93, 
+0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 0x02, 0x7F, 0x34, 0xD1, 0x50, 0x12, 0x08, 0x79, 0x00, 0x00, 
+0x0F, 0x00, 0x90, 0x94, 0x93, 0x12, 0x08, 0x79, 0x00, 0x00, 0x01, 0x00, 0xF1, 0xC4, 0x12, 0x08, 
+0x79, 0x30, 0x00, 0x00, 0x00, 0x90, 0x94, 0x93, 0x12, 0x08, 0x79, 0x20, 0x00, 0x00, 0x00, 0xF1, 
+0xB8, 0x22, 0x12, 0x49, 0x00, 0x02, 0x48, 0xC9, 0x74, 0x08, 0xFF, 0xFE, 0xA1, 0xDA, 0x7F, 0x60, 
+0x7E, 0x08, 0xA1, 0xDA, 0x7F, 0x1C, 0x7E, 0x0C, 0xB1, 0xDA, 0x90, 0x95, 0x33, 0xE0, 0xFF, 0xA3, 
+0xE0, 0xFD, 0x12, 0xA0, 0x5A, 0x90, 0x94, 0x8F, 0x22, 0x7F, 0x64, 0x7E, 0x08, 0xB1, 0xDA, 0x90, 
+0x94, 0xF1, 0x12, 0x48, 0xF4, 0xE4, 0xFF, 0xFE, 0xFD, 0xEC, 0x54, 0x04, 0xFC, 0x90, 0x94, 0x8F, 
+0x22, 0x90, 0x94, 0x93, 0x02, 0x08, 0x6D, 0xEF, 0xF0, 0xA3, 0xED, 0xF0, 0xA3, 0x22, 0xE4, 0xFB, 
+0xFA, 0xFD, 0x7F, 0x01, 0x12, 0x48, 0x0E, 0x90, 0x93, 0x37, 0xEF, 0xF0, 0x60, 0xF0, 0x90, 0x8D, 
+0x01, 0xE0, 0xFF, 0x70, 0x04, 0xA3, 0xE0, 0x60, 0xE5, 0xC2, 0xAF, 0xEF, 0x30, 0xE1, 0x0A, 0x90, 
+0x8D, 0x01, 0xE0, 0x54, 0xFD, 0xF0, 0x12, 0x75, 0x4F, 0xF1, 0xA6, 0x30, 0xE2, 0x06, 0x54, 0xFB, 
+0xF0, 0x12, 0x94, 0x08, 0xF1, 0xA6, 0x30, 0xE4, 0x0B, 0x54, 0xEF, 0xF0, 0x12, 0xA3, 0x0B, 0xBF, 
+0x01, 0x02, 0x11, 0x53, 0xF1, 0xA6, 0x30, 0xE7, 0x06, 0x54, 0x7F, 0xF0, 0x12, 0x50, 0xAA, 0xD2, 
+0xAF, 0x80, 0xBB, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0xE4, 0x90, 0x94, 0x6F, 0x12, 0x97, 
+0xB0, 0xA3, 0x12, 0x94, 0x6D, 0x90, 0x94, 0x77, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0x90, 0x01, 0xC4, 
+0x74, 0x53, 0xF0, 0x74, 0x68, 0xA3, 0xF0, 0x12, 0x8F, 0x97, 0x12, 0x7C, 0x9B, 0x90, 0x94, 0x66, 
+0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0x02, 0x82, 0xE0, 0x90, 0x94, 0x6E, 0xF0, 0x90, 0x8E, 0xC0, 0xE0, 
+0x20, 0xE0, 0x02, 0x61, 0x43, 0xE4, 0x90, 0x94, 0x6D, 0xF0, 0x90, 0x94, 0x6E, 0xE0, 0xFF, 0x90, 
+0x94, 0x6D, 0xE0, 0xC3, 0x9F, 0x40, 0x02, 0x61, 0x43, 0x90, 0x94, 0x66, 0x12, 0xAA, 0x60, 0x90, 
+0xFD, 0x11, 0xF0, 0x90, 0x94, 0x77, 0xEF, 0xF0, 0x12, 0x5F, 0xFA, 0x54, 0x3F, 0xFE, 0x90, 0x94, 
+0x68, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0x94, 0x73, 0xEE, 0x12, 0xA8, 0xFB, 0xE0, 0x54, 0x03, 0xFE, 
+0xEF, 0x24, 0x18, 0x2E, 0xFF, 0x90, 0x94, 0x78, 0xF0, 0x90, 0x94, 0x67, 0xE0, 0x2F, 0xFF, 0x90, 
+0x94, 0x66, 0xE0, 0x34, 0x00, 0xFE, 0x90, 0x94, 0x6A, 0xF1, 0xE8, 0xC0, 0x07, 0x71, 0x54, 0x7D, 
+0x01, 0x71, 0x7F, 0xC0, 0x07, 0x71, 0x54, 0x7D, 0x04, 0x71, 0x7F, 0xAB, 0x07, 0xD0, 0x05, 0xD0, 
+0x07, 0x12, 0x84, 0x71, 0x90, 0x94, 0x6F, 0xEF, 0x71, 0x53, 0xE4, 0xFD, 0x71, 0x7F, 0xEF, 0x54, 
+0xFC, 0x90, 0x94, 0x6C, 0xF0, 0x90, 0x94, 0x78, 0xE0, 0xFF, 0x90, 0x94, 0x68, 0xE4, 0x8F, 0xF0, 
+0x12, 0x08, 0xD6, 0x90, 0x94, 0x68, 0x12, 0x8F, 0x49, 0x90, 0x94, 0x68, 0xEE, 0xF0, 0xA3, 0xEF, 
+0xF0, 0x90, 0x94, 0x66, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x7D, 0x0F, 0x71, 0x7F, 0x90, 0x94, 0x68, 
+0xE0, 0xFC, 0xA3, 0xE0, 0xFD, 0x90, 0x94, 0x66, 0xEC, 0x8D, 0xF0, 0x12, 0x8F, 0x86, 0xFC, 0xA3, 
+0xE0, 0xFD, 0xD3, 0x90, 0x94, 0x67, 0xE0, 0x9D, 0x90, 0x94, 0x66, 0xE0, 0x9C, 0x40, 0x18, 0x90, 
+0x8D, 0xF9, 0xE0, 0x24, 0x01, 0xFD, 0x12, 0x8F, 0xC3, 0xFC, 0xC3, 0x90, 0x94, 0x67, 0xE0, 0x9D, 
+0xF0, 0x90, 0x94, 0x66, 0xE0, 0x9C, 0xF0, 0xEF, 0x30, 0xE6, 0x06, 0x90, 0x01, 0xC7, 0x74, 0x22, 
+0xF0, 0xEF, 0x30, 0xE7, 0x06, 0x90, 0x01, 0xC7, 0x74, 0x21, 0xF0, 0xEF, 0x30, 0xE5, 0x06, 0x90, 
+0x01, 0xC7, 0x74, 0x23, 0xF0, 0x90, 0x94, 0x65, 0xE0, 0x60, 0x3B, 0x90, 0x94, 0x6C, 0xE0, 0x24, 
+0xB0, 0x60, 0x16, 0x24, 0xD0, 0x60, 0x02, 0x41, 0xDF, 0x12, 0xAA, 0x58, 0x20, 0xE0, 0x18, 0x12, 
+0x96, 0x1C, 0x20, 0xE0, 0x02, 0x41, 0xDF, 0x80, 0x0E, 0x12, 0xAA, 0x58, 0x20, 0xE0, 0x08, 0x12, 
+0x96, 0x1C, 0x20, 0xE0, 0x02, 0x41, 0xDF, 0x71, 0x54, 0x90, 0x94, 0x73, 0xE0, 0xFC, 0xA3, 0xE0, 
+0xFD, 0x12, 0x8A, 0xFD, 0x41, 0xDF, 0x90, 0x94, 0x6C, 0xE0, 0x24, 0x40, 0x60, 0x04, 0x24, 0x20, 
+0x70, 0x2B, 0x90, 0x8E, 0xC3, 0xE0, 0xFF, 0xF1, 0xF0, 0x20, 0xE0, 0x02, 0x41, 0xDF, 0x90, 0x8E, 
+0xD6, 0xE0, 0x04, 0x71, 0x53, 0x12, 0xA3, 0x8E, 0xEF, 0x70, 0x02, 0x41, 0xDF, 0x90, 0x94, 0x6C, 
+0xE0, 0xFF, 0x12, 0xA3, 0x7C, 0x90, 0x8E, 0xD7, 0xE0, 0x04, 0xF0, 0x41, 0xDF, 0x12, 0x8F, 0xAA, 
+0x30, 0xE0, 0x5F, 0x90, 0x94, 0x6F, 0xE0, 0xFF, 0x90, 0x94, 0x6B, 0xE0, 0x2F, 0xFF, 0x90, 0x94, 
+0x6A, 0xE0, 0x34, 0x00, 0xCF, 0x24, 0x08, 0xCF, 0x34, 0x00, 0xFE, 0x90, 0x94, 0x75, 0xF1, 0xE8, 
+0xEF, 0x64, 0x45, 0x70, 0x3D, 0x12, 0xA9, 0x90, 0x12, 0x84, 0x92, 0xEF, 0x64, 0x01, 0x70, 0x32, 
+0x12, 0xA9, 0x90, 0xF1, 0xB0, 0xEF, 0x64, 0x01, 0x70, 0x28, 0x90, 0x94, 0x79, 0x04, 0xF0, 0x90, 
+0x94, 0x75, 0xF1, 0x85, 0xFD, 0x12, 0x8C, 0xC3, 0xEF, 0x70, 0x0F, 0x90, 0x94, 0x77, 0xE0, 0xFD, 
+0x90, 0xFD, 0x11, 0xF0, 0x12, 0xA9, 0x90, 0x12, 0x8C, 0x74, 0x90, 0x94, 0x77, 0xE0, 0x90, 0xFD, 
+0x11, 0xF0, 0x71, 0x54, 0x12, 0xA3, 0x8E, 0xEF, 0x60, 0x1F, 0x71, 0x54, 0x90, 0x94, 0x6F, 0xE0, 
+0xFD, 0x90, 0x94, 0x72, 0xE0, 0xFB, 0x90, 0x94, 0x77, 0xE0, 0x90, 0x94, 0xFF, 0xF0, 0x71, 0xB2, 
+0xEF, 0x60, 0x06, 0x90, 0x94, 0x79, 0x74, 0x01, 0xF0, 0x90, 0x8E, 0xC0, 0xE0, 0xC3, 0x13, 0x30, 
+0xE0, 0x12, 0x71, 0x54, 0x90, 0x94, 0x6F, 0xE0, 0xFD, 0x91, 0x28, 0xEF, 0x60, 0x06, 0x90, 0x94, 
+0x79, 0x74, 0x01, 0xF0, 0x12, 0x7C, 0x8B, 0x54, 0x3F, 0x30, 0xE0, 0x0A, 0x71, 0x54, 0x90, 0x94, 
+0x6F, 0xE0, 0xFD, 0x12, 0xA4, 0x50, 0x90, 0x8E, 0xC0, 0xE0, 0xFF, 0xF1, 0xF0, 0x30, 0xE0, 0x0F, 
+0x90, 0x94, 0x79, 0xE0, 0x70, 0x09, 0x71, 0x54, 0x90, 0x94, 0x6F, 0xE0, 0xFD, 0xD1, 0xDF, 0x12, 
+0xA6, 0x8C, 0xEF, 0x64, 0x01, 0x60, 0x07, 0x90, 0x01, 0x3F, 0xE0, 0x30, 0xE2, 0x05, 0x7F, 0x01, 
+0x12, 0x8B, 0x36, 0x12, 0xA3, 0x56, 0xEF, 0x64, 0x01, 0x70, 0x37, 0x90, 0x8E, 0xD8, 0xE0, 0x04, 
+0xF0, 0x12, 0xA3, 0x40, 0xAD, 0x07, 0xEF, 0x64, 0x01, 0x60, 0x1F, 0xF1, 0x95, 0xED, 0xB4, 0x02, 
+0x08, 0x90, 0x01, 0xC7, 0x74, 0x42, 0xF0, 0x80, 0x0A, 0xED, 0xB4, 0x04, 0x06, 0x90, 0x01, 0xC7, 
+0x74, 0x43, 0xF0, 0x7F, 0x01, 0x12, 0x8B, 0x36, 0x80, 0x19, 0x90, 0x94, 0x66, 0x12, 0xA2, 0xF8, 
+0x80, 0x09, 0x90, 0x8E, 0xC0, 0xE0, 0x54, 0xFE, 0xF0, 0x80, 0x08, 0x90, 0x94, 0x6D, 0xE0, 0x04, 
+0xF0, 0x01, 0x9A, 0x74, 0x53, 0x04, 0x90, 0x01, 0xC4, 0xF0, 0x74, 0x68, 0xA3, 0xF0, 0xD0, 0xD0, 
+0x92, 0xAF, 0x22, 0xF0, 0x90, 0x94, 0x6A, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x22, 0x90, 0x93, 0x3A, 
+0xE0, 0xFD, 0x90, 0x93, 0x39, 0xE0, 0x2D, 0xFD, 0x90, 0x93, 0x38, 0xE0, 0x34, 0x00, 0xCD, 0x24, 
+0x10, 0xCD, 0x34, 0x00, 0xFC, 0x7E, 0x00, 0xED, 0x2F, 0xFF, 0xEE, 0x3C, 0xFE, 0xE4, 0xFD, 0xAB, 
+0x07, 0xAA, 0x06, 0xED, 0x2B, 0xFB, 0xE4, 0x3A, 0xFA, 0xC3, 0x90, 0x8D, 0xF9, 0xE0, 0x9B, 0x90, 
+0x8D, 0xF8, 0xE0, 0x9A, 0x50, 0x0C, 0xA3, 0x12, 0x8F, 0xBF, 0xFE, 0xC3, 0xEB, 0x9F, 0xFB, 0xEA, 
+0x9E, 0xFA, 0x12, 0x8F, 0x7E, 0x74, 0x00, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0xFB, 0xF5, 0x83, 0xE0, 
+0xFF, 0x22, 0x90, 0x94, 0xFD, 0xED, 0xF0, 0xA3, 0xEB, 0xF0, 0x90, 0x94, 0xFB, 0x12, 0x8F, 0x70, 
+0x90, 0x95, 0x00, 0xF0, 0xFD, 0x71, 0x7F, 0xEF, 0x54, 0x0C, 0x64, 0x08, 0x70, 0x54, 0xF1, 0x82, 
+0xF1, 0x8D, 0x64, 0x88, 0x70, 0x4C, 0xF1, 0x82, 0x24, 0x07, 0xFD, 0x71, 0x7F, 0xEF, 0x64, 0x8E, 
+0x70, 0x40, 0x90, 0x95, 0x00, 0x04, 0xF0, 0x12, 0xA9, 0x49, 0x04, 0xFD, 0x71, 0x7F, 0xEF, 0x64, 
+0x03, 0x70, 0x2F, 0x12, 0xA9, 0x49, 0xF1, 0x8D, 0x30, 0xE3, 0x07, 0x90, 0x01, 0xC7, 0x74, 0x01, 
+0x80, 0x1E, 0x90, 0x8E, 0xC0, 0x12, 0x9E, 0x37, 0x30, 0xE0, 0x07, 0xF1, 0x82, 0xFD, 0xB1, 0x6B, 
+0x80, 0x10, 0x90, 0x8E, 0xC3, 0x12, 0x8F, 0xAD, 0x30, 0xE0, 0x07, 0x90, 0x01, 0xC7, 0x74, 0x02, 
+0xF1, 0x94, 0x90, 0x95, 0x00, 0xE0, 0xFF, 0x22, 0x12, 0x8C, 0xB7, 0x12, 0xA6, 0x44, 0x7A, 0x40, 
+0x79, 0x56, 0xF1, 0xF7, 0x78, 0x47, 0x7C, 0x93, 0x7D, 0x01, 0x7B, 0xFF, 0x7A, 0x40, 0x79, 0x5C, 
+0xF1, 0xE1, 0x78, 0x4B, 0x7C, 0x93, 0x7D, 0x01, 0x7B, 0xFF, 0x7A, 0x40, 0x79, 0x60, 0xF1, 0xE1, 
+0xE4, 0x90, 0x93, 0x50, 0xF0, 0xD1, 0x95, 0xCF, 0x24, 0x06, 0xCF, 0xB1, 0x64, 0xEF, 0x64, 0x08, 
+0x60, 0x02, 0xA1, 0x47, 0xD1, 0x95, 0xCF, 0x24, 0x07, 0xCF, 0xB1, 0x64, 0xEF, 0x64, 0x06, 0x60, 
+0x02, 0xA1, 0x47, 0x90, 0x93, 0x50, 0x04, 0xF0, 0xE4, 0x90, 0x93, 0x4F, 0xF0, 0xB1, 0x4D, 0x94, 
+0x06, 0x50, 0x17, 0x90, 0x93, 0x39, 0xE0, 0x24, 0x0A, 0xFD, 0x90, 0x93, 0x38, 0xE0, 0x71, 0x72, 
+0x90, 0x93, 0x4F, 0x12, 0xA6, 0x3B, 0xB1, 0x54, 0x80, 0xE3, 0x12, 0xA6, 0x2B, 0x7B, 0x01, 0x7A, 
+0x8E, 0x79, 0xD0, 0x12, 0xA3, 0xDF, 0x60, 0x02, 0xA1, 0x47, 0x90, 0x93, 0x4F, 0xF0, 0xB1, 0x4D, 
+0x94, 0x04, 0x50, 0x19, 0x12, 0xA6, 0x1F, 0xD1, 0xA0, 0xCD, 0x24, 0x20, 0x71, 0x71, 0x90, 0x93, 
+0x4F, 0xE0, 0x24, 0x4B, 0xF5, 0x82, 0xE4, 0x34, 0x93, 0xB1, 0x54, 0x80, 0xE1, 0x78, 0x4B, 0x7C, 
+0x93, 0x12, 0xA9, 0x72, 0xEF, 0x70, 0x67, 0x90, 0x06, 0x30, 0xE0, 0x44, 0x01, 0x54, 0xDF, 0xF0, 
+0x90, 0x8E, 0xC2, 0xE0, 0x30, 0xE0, 0x09, 0x90, 0x01, 0xC7, 0x74, 0x09, 0xF1, 0x94, 0x80, 0x57, 
+0xE4, 0x90, 0x93, 0x4F, 0xF0, 0xB1, 0x4D, 0x94, 0x06, 0x50, 0x0C, 0x71, 0x5D, 0x90, 0x93, 0x4F, 
+0x12, 0xA6, 0x32, 0xB1, 0x54, 0x80, 0xEE, 0xE4, 0x90, 0x93, 0x4F, 0xF0, 0xB1, 0x4D, 0x94, 0x04, 
+0x50, 0x19, 0x12, 0xA6, 0x1F, 0xD1, 0xA0, 0xCD, 0x24, 0x16, 0x71, 0x71, 0x90, 0x93, 0x4F, 0xE0, 
+0x24, 0x47, 0xF5, 0x82, 0xE4, 0x34, 0x93, 0xB1, 0x54, 0x80, 0xE1, 0x7B, 0x01, 0x7A, 0x93, 0x79, 
+0x41, 0x12, 0xA9, 0xB4, 0xF0, 0x7A, 0x93, 0x79, 0x47, 0x12, 0x55, 0xF3, 0x80, 0x09, 0x90, 0x06, 
+0x30, 0xE0, 0x44, 0x21, 0x54, 0xEF, 0xF0, 0x90, 0x93, 0x50, 0xE0, 0xFF, 0x22, 0x90, 0x93, 0x4F, 
+0xE0, 0xFF, 0xC3, 0x22, 0xF5, 0x83, 0xEF, 0xF0, 0x90, 0x93, 0x4F, 0xE0, 0x04, 0xF0, 0x22, 0xFF, 
+0x90, 0x93, 0x3B, 0xE0, 0x34, 0x00, 0xFE, 0xE4, 0xFD, 0x61, 0x7F, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 
+0xC0, 0xD0, 0x90, 0x06, 0x31, 0xE0, 0x54, 0xEF, 0x44, 0x08, 0xF0, 0xED, 0x2F, 0xFF, 0xE4, 0x3E, 
+0xFE, 0x7C, 0x00, 0xEF, 0x24, 0x08, 0xFF, 0xEC, 0x3E, 0x90, 0x93, 0x3B, 0xF0, 0xA3, 0xEF, 0xF0, 
+0x7E, 0x00, 0x7F, 0x83, 0x7D, 0x00, 0x7B, 0x01, 0x7A, 0x8F, 0x79, 0xD6, 0x12, 0x08, 0xAA, 0x90, 
+0x93, 0x3C, 0xE0, 0x24, 0x01, 0xB1, 0x5F, 0x90, 0x8F, 0xD7, 0xD1, 0x8E, 0x24, 0x04, 0xB1, 0x5F, 
+0x90, 0x8F, 0xDA, 0xD1, 0x8E, 0x24, 0x05, 0xB1, 0x5F, 0x90, 0x8F, 0xDB, 0xD1, 0x8E, 0x24, 0x06, 
+0xB1, 0x5F, 0x90, 0x8F, 0xDC, 0xD1, 0x8E, 0x24, 0x07, 0xB1, 0x5F, 0x90, 0x8F, 0xDD, 0xD1, 0x8E, 
+0x24, 0x08, 0xB1, 0x5F, 0x90, 0x8F, 0xDE, 0xEF, 0xF0, 0xE4, 0x90, 0x93, 0x3A, 0xF0, 0x90, 0x93, 
+0x3A, 0xE0, 0xFF, 0xC3, 0x94, 0x08, 0x50, 0x19, 0x90, 0x93, 0x3C, 0xE0, 0x24, 0x09, 0xFD, 0x90, 
+0x93, 0x3B, 0xE0, 0x71, 0x72, 0x90, 0x93, 0x3A, 0xE0, 0x12, 0xA9, 0x3F, 0x12, 0x83, 0x9B, 0x80, 
+0xDD, 0xE4, 0x90, 0x93, 0x3A, 0xF0, 0x90, 0x93, 0x3A, 0xE0, 0xFF, 0xC3, 0x94, 0x20, 0x50, 0x1F, 
+0x90, 0x93, 0x3C, 0xE0, 0x24, 0x63, 0xFD, 0x90, 0x93, 0x3B, 0xE0, 0x71, 0x72, 0x90, 0x93, 0x3A, 
+0xE0, 0x24, 0x39, 0xF5, 0x82, 0xE4, 0x34, 0x90, 0xF5, 0x83, 0x12, 0x83, 0x9B, 0x80, 0xD7, 0x90, 
+0x8F, 0xDB, 0x12, 0x95, 0x72, 0x12, 0x87, 0xD2, 0x30, 0xE3, 0x0D, 0x7F, 0x01, 0x12, 0x8B, 0x36, 
+0x90, 0x01, 0xC7, 0x74, 0x03, 0xF0, 0x80, 0x3F, 0x90, 0x93, 0x38, 0xA3, 0xE0, 0xFF, 0x7C, 0x00, 
+0x54, 0x07, 0xFD, 0x64, 0x01, 0x60, 0x05, 0xED, 0x64, 0x02, 0x70, 0x2B, 0xED, 0x64, 0x02, 0x4C, 
+0x70, 0x25, 0xEF, 0x54, 0x30, 0xFF, 0xE4, 0xC4, 0xF8, 0x54, 0xF0, 0xC8, 0xEF, 0xC4, 0x54, 0x0F, 
+0x48, 0x90, 0x90, 0x6F, 0xF0, 0xAE, 0x04, 0xAF, 0x05, 0xE4, 0xFD, 0x12, 0xA7, 0x94, 0x90, 0x06, 
+0x31, 0xE0, 0x54, 0xF7, 0x44, 0x10, 0xF0, 0x7F, 0x00, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xEF, 0xF0, 
+0x90, 0x93, 0x3C, 0xE0, 0x22, 0x90, 0x93, 0x3A, 0xE0, 0xFF, 0x90, 0x93, 0x39, 0xE0, 0x2F, 0xFF, 
+0x90, 0x93, 0x38, 0xE0, 0x34, 0x00, 0x22, 0x90, 0x93, 0x48, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x7D, 
+0x09, 0x71, 0x7F, 0xEF, 0x64, 0x06, 0x70, 0x24, 0xF1, 0x9D, 0x7D, 0x14, 0x71, 0x7F, 0xEF, 0x70, 
+0x1B, 0xF1, 0x9D, 0x7D, 0x15, 0x71, 0x7F, 0xEF, 0x64, 0x50, 0x70, 0x10, 0xF1, 0x9D, 0x7D, 0x21, 
+0x71, 0x7F, 0xEF, 0x20, 0xE0, 0x03, 0x30, 0xE2, 0x03, 0x7F, 0x01, 0x22, 0x7F, 0x00, 0x22, 0x12, 
+0x8C, 0xB7, 0x12, 0xA6, 0x2B, 0x7B, 0xFF, 0x7A, 0x40, 0x79, 0x90, 0xF1, 0xF7, 0x78, 0x42, 0x7C, 
+0x93, 0x7D, 0x01, 0x7B, 0xFF, 0x7A, 0x40, 0x79, 0x96, 0xF1, 0xE1, 0x12, 0x8C, 0xAE, 0x12, 0xA3, 
+0x8E, 0xEF, 0x60, 0x7D, 0xD1, 0x95, 0xFE, 0x90, 0x93, 0x46, 0xF0, 0xA3, 0xEF, 0xF0, 0x24, 0x06, 
+0xFF, 0xE4, 0x3E, 0xB1, 0x66, 0xEF, 0x64, 0x08, 0x70, 0x67, 0x90, 0x93, 0x47, 0xE0, 0x24, 0x07, 
+0xFF, 0x90, 0x93, 0x46, 0xB1, 0x63, 0xEF, 0x70, 0x58, 0x90, 0x93, 0x41, 0xF0, 0x90, 0x93, 0x41, 
+0xE0, 0xFF, 0xC3, 0x94, 0x04, 0x50, 0x24, 0x90, 0x93, 0x47, 0xE0, 0x24, 0x18, 0xFD, 0x90, 0x93, 
+0x46, 0xE0, 0x71, 0x72, 0x90, 0x93, 0x41, 0xE0, 0x24, 0x42, 0xF5, 0x82, 0xE4, 0x34, 0x93, 0xF5, 
+0x83, 0xEF, 0xF0, 0x90, 0x93, 0x41, 0xE0, 0x04, 0xF0, 0x80, 0xD2, 0x78, 0x42, 0x7C, 0x93, 0x12, 
+0xA9, 0x72, 0xEF, 0x70, 0x1C, 0x90, 0x93, 0x47, 0xE0, 0x24, 0x08, 0xFF, 0x90, 0x93, 0x46, 0xE0, 
+0x34, 0x00, 0xFE, 0xD1, 0xA7, 0xEF, 0x64, 0x01, 0x60, 0x07, 0x90, 0x01, 0xC7, 0x74, 0x22, 0xF1, 
+0x94, 0x22, 0x90, 0x94, 0xFB, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0xA3, 0xE0, 0x22, 0x24, 0x06, 0xFD, 
+0x71, 0x7F, 0xEF, 0x22, 0xF0, 0x90, 0x8E, 0xC9, 0xE0, 0x44, 0x01, 0xF0, 0x22, 0x90, 0x93, 0x48, 
+0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x22, 0xD2, 0xAF, 0xC2, 0xAF, 0x90, 0x8D, 0x01, 0xE0, 0xFF, 0x22, 
+0x12, 0x87, 0xD2, 0x24, 0x16, 0xFF, 0xE4, 0x3E, 0xB1, 0x66, 0x90, 0x90, 0x80, 0xA3, 0xE0, 0xB5, 
+0x07, 0x19, 0x90, 0x93, 0x39, 0xE0, 0x24, 0x16, 0xD1, 0x9F, 0xFE, 0x7D, 0x01, 0x71, 0x7F, 0xEF, 
+0xFD, 0x90, 0x90, 0x80, 0xE0, 0x6D, 0x70, 0x01, 0xE4, 0x60, 0x03, 0x7F, 0x00, 0x22, 0x7F, 0x01, 
+0x22, 0x7E, 0x00, 0x7F, 0x04, 0x02, 0x06, 0x63, 0xF0, 0xA3, 0xEF, 0xF0, 0xE4, 0xFD, 0x61, 0x7F, 
+0xC4, 0x13, 0x13, 0x13, 0x54, 0x01, 0x22, 0x7E, 0x00, 0x7F, 0x06, 0x02, 0x06, 0x63, 0x32, 0xC0, 
+0xE0, 0xC0, 0xF0, 0xC0, 0x83, 0xC0, 0x82, 0xC0, 0xD0, 0x75, 0xD0, 0x00, 0xC0, 0x00, 0xC0, 0x01, 
+0xC0, 0x02, 0xC0, 0x03, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0x12, 0x4D, 0x72, 0xE5, 
+0x14, 0x30, 0xE7, 0x03, 0x12, 0x4F, 0xAF, 0xD0, 0x07, 0xD0, 0x06, 0xD0, 0x05, 0xD0, 0x04, 0xD0, 
+0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x82, 0xD0, 0x83, 0xD0, 0xF0, 0xD0, 
+0xE0, 0x32, 0xC0, 0xE0, 0xC0, 0xF0, 0xC0, 0x83, 0xC0, 0x82, 0xC0, 0xD0, 0x75, 0xD0, 0x00, 0xC0, 
+0x00, 0xC0, 0x01, 0xC0, 0x02, 0xC0, 0x03, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0x12, 
+0x9A, 0x63, 0xE5, 0x19, 0x30, 0xE3, 0x03, 0x12, 0x9A, 0xC0, 0xE5, 0x19, 0x30, 0xE4, 0x02, 0x31, 
+0x9D, 0xE5, 0x19, 0x30, 0xE5, 0x03, 0x12, 0x9A, 0xCD, 0xE5, 0x1B, 0x30, 0xE0, 0x02, 0x11, 0xD6, 
+0xE5, 0x1B, 0x30, 0xE1, 0x03, 0x12, 0x8E, 0x13, 0xE5, 0x1B, 0x30, 0xE2, 0x03, 0x12, 0x9B, 0x09, 
+0xE5, 0x1B, 0x30, 0xE3, 0x02, 0x51, 0xDD, 0xE5, 0x1B, 0x30, 0xE4, 0x02, 0x71, 0x1D, 0xE5, 0x1B, 
+0x30, 0xE5, 0x02, 0x71, 0x50, 0xE5, 0x1B, 0x30, 0xE6, 0x02, 0x71, 0x39, 0xE5, 0x1C, 0x30, 0xE1, 
+0x03, 0x12, 0x9E, 0x9C, 0xE5, 0x1C, 0x30, 0xE6, 0x02, 0x31, 0x5B, 0xD0, 0x07, 0xD0, 0x06, 0xD0, 
+0x05, 0xD0, 0x04, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x82, 0xD0, 
+0x83, 0xD0, 0xF0, 0xD0, 0xE0, 0x32, 0xE4, 0xF5, 0x58, 0x90, 0x8E, 0x15, 0xE0, 0x60, 0x71, 0x51, 
+0xD5, 0x70, 0x6D, 0x12, 0x8F, 0xD8, 0xCE, 0xC3, 0x13, 0xCE, 0x13, 0xD8, 0xF9, 0x12, 0xA9, 0xCD, 
+0x90, 0x8E, 0x13, 0xE0, 0xC4, 0x54, 0x0F, 0x60, 0x22, 0x24, 0xFE, 0x60, 0x03, 0x04, 0x70, 0x1E, 
+0x90, 0x8E, 0x1C, 0xE0, 0x14, 0xF0, 0xE0, 0xFF, 0x60, 0x06, 0x90, 0x8E, 0x1E, 0xE0, 0x60, 0x0E, 
+0xEF, 0x70, 0x08, 0x90, 0x8E, 0x1B, 0xE0, 0xA3, 0xF0, 0x80, 0x00, 0x75, 0x58, 0x01, 0xE5, 0x58, 
+0x60, 0x2E, 0xF1, 0xE2, 0x90, 0x8E, 0x1E, 0xE0, 0x60, 0x03, 0xB4, 0x01, 0x04, 0x31, 0x51, 0x80, 
+0x08, 0x31, 0x51, 0x75, 0xF0, 0x03, 0xA4, 0x24, 0xFE, 0xFF, 0x90, 0x8E, 0x1D, 0xE0, 0x2F, 0x91, 
+0x2F, 0x7E, 0x01, 0x12, 0x50, 0x04, 0x90, 0x8E, 0x18, 0xE0, 0x20, 0xE2, 0x03, 0x12, 0x51, 0xE4, 
+0x22, 0xE4, 0x90, 0x94, 0xE7, 0xF0, 0x90, 0x8E, 0x1E, 0xE0, 0x22, 0x90, 0x07, 0x1F, 0xE0, 0x54, 
+0x7F, 0xF0, 0x90, 0x07, 0x1C, 0xE0, 0x54, 0x01, 0xFF, 0x90, 0x93, 0xE6, 0xF0, 0x90, 0x93, 0xE4, 
+0x74, 0x02, 0xF0, 0x90, 0x93, 0xF2, 0x14, 0xF0, 0xFB, 0x7A, 0x93, 0x79, 0xE4, 0x12, 0x85, 0x0E, 
+0x7F, 0x04, 0x90, 0x95, 0x43, 0xEF, 0xF0, 0x7F, 0x02, 0x12, 0x47, 0xE7, 0x90, 0x8D, 0x01, 0xE0, 
+0xFF, 0x90, 0x95, 0x43, 0xE0, 0xFE, 0xEF, 0x4E, 0x90, 0x8D, 0x01, 0xF0, 0x22, 0x31, 0xB0, 0x7F, 
+0x02, 0x8F, 0x59, 0x7F, 0x02, 0x12, 0x47, 0xE7, 0x90, 0x8D, 0x01, 0xE0, 0x45, 0x59, 0xF0, 0x22, 
+0x90, 0x01, 0xCC, 0xE0, 0x54, 0x0F, 0x90, 0x95, 0x38, 0xF0, 0x90, 0x95, 0x38, 0xE0, 0xFD, 0x70, 
+0x02, 0x41, 0xAA, 0x90, 0x8D, 0x5E, 0xE0, 0xFF, 0x70, 0x06, 0xA3, 0xE0, 0x64, 0x09, 0x60, 0x0A, 
+0xEF, 0x14, 0xFF, 0x90, 0x8D, 0x5F, 0xE0, 0xB5, 0x07, 0x04, 0x7F, 0x01, 0x80, 0x02, 0x7F, 0x00, 
+0xEF, 0x60, 0x08, 0x90, 0x01, 0xC1, 0xE0, 0x44, 0x01, 0xF0, 0x22, 0x90, 0x95, 0x36, 0x12, 0x8F, 
+0xA0, 0x80, 0x05, 0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 0xF9, 0xFF, 0xEF, 0x5D, 0x70, 0x02, 0x41, 
+0x8C, 0xE4, 0x90, 0x95, 0x39, 0xF0, 0x90, 0x95, 0x39, 0xE0, 0xF9, 0xC3, 0x94, 0x04, 0x50, 0x31, 
+0x51, 0xAB, 0xA4, 0xFF, 0xE9, 0xFD, 0x7C, 0x00, 0x2F, 0xFF, 0xEC, 0x35, 0xF0, 0xFE, 0x74, 0xD0, 
+0x51, 0xC3, 0x90, 0x8D, 0x0E, 0x51, 0xB3, 0x51, 0xAB, 0xA4, 0x2D, 0xFF, 0xEC, 0x35, 0xF0, 0xFE, 
+0x74, 0xF0, 0x51, 0xC3, 0x90, 0x8D, 0x12, 0x51, 0xB3, 0x90, 0x95, 0x39, 0xE0, 0x04, 0xF0, 0x80, 
+0xC5, 0x90, 0x95, 0x38, 0xE0, 0xFF, 0x90, 0x95, 0x36, 0x12, 0x4C, 0x61, 0x80, 0x02, 0xC3, 0x33, 
+0xD8, 0xFC, 0xF4, 0x5F, 0x90, 0x95, 0x38, 0xF0, 0x90, 0x95, 0x36, 0xE0, 0xFF, 0x74, 0x01, 0xA8, 
+0x07, 0x08, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0x90, 0x01, 0xCC, 0xF0, 0x90, 0x95, 0x36, 0xE0, 
+0x04, 0xF0, 0xE0, 0x54, 0x03, 0xF0, 0x90, 0x8D, 0x5F, 0xF1, 0xCB, 0xB4, 0x0A, 0x02, 0x7F, 0x01, 
+0xEF, 0x70, 0x02, 0x21, 0xBA, 0xE4, 0x90, 0x8D, 0x5F, 0xF0, 0x21, 0xBA, 0x90, 0x01, 0xC0, 0xE0, 
+0x44, 0x02, 0xF0, 0x90, 0x95, 0x36, 0xE0, 0x44, 0x80, 0x90, 0x00, 0x8A, 0xF0, 0x51, 0xAB, 0x90, 
+0x01, 0xD0, 0x12, 0x49, 0x0C, 0xE0, 0x90, 0x01, 0xC3, 0xF0, 0x22, 0x90, 0x95, 0x36, 0xE0, 0x75, 
+0xF0, 0x04, 0x22, 0x12, 0x49, 0x0C, 0xE5, 0x82, 0x29, 0xF5, 0x82, 0xE4, 0x35, 0x83, 0xF5, 0x83, 
+0xEF, 0xF0, 0x22, 0x2F, 0xF5, 0x82, 0x74, 0x01, 0x3E, 0xF5, 0x83, 0xE0, 0xFF, 0x90, 0x8D, 0x5F, 
+0xE0, 0x75, 0xF0, 0x08, 0x22, 0xE4, 0xFF, 0x51, 0xF2, 0xEF, 0x64, 0x01, 0x22, 0x51, 0xD5, 0x70, 
+0x10, 0x90, 0x8E, 0x15, 0xE0, 0x60, 0x0A, 0x12, 0x9E, 0x3E, 0x91, 0x25, 0x7E, 0x01, 0x12, 0x50, 
+0x04, 0x22, 0x12, 0x96, 0x1C, 0xFE, 0xEF, 0x54, 0x07, 0xFF, 0x74, 0xFF, 0x2E, 0x12, 0x96, 0x77, 
+0xFD, 0x7C, 0x00, 0x12, 0x8F, 0xA2, 0x80, 0x05, 0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 0xF9, 0xFF, 
+0xEE, 0x5C, 0xFE, 0xEF, 0x5D, 0x4E, 0x7F, 0x00, 0x60, 0x02, 0x7F, 0x01, 0x22, 0x51, 0xD5, 0x70, 
+0x17, 0x90, 0x8E, 0x15, 0xE0, 0x60, 0x11, 0x12, 0x9E, 0x3E, 0xF0, 0x90, 0x8E, 0x11, 0xE0, 0x12, 
+0x9E, 0x49, 0x54, 0x07, 0x70, 0x02, 0xF1, 0xC1, 0x22, 0xE4, 0xFF, 0x51, 0xF2, 0xBF, 0x01, 0x0F, 
+0x90, 0x8E, 0x15, 0xE0, 0x60, 0x09, 0x12, 0x9C, 0x15, 0x54, 0x07, 0x70, 0x02, 0xF1, 0xC1, 0x22, 
+0xE4, 0xFF, 0x51, 0xF2, 0xBF, 0x01, 0x12, 0x90, 0x8E, 0x15, 0xE0, 0x60, 0x0C, 0xD1, 0x16, 0x64, 
+0x02, 0x60, 0x03, 0x02, 0x9E, 0xA5, 0x12, 0x57, 0xBB, 0x22, 0xEF, 0x60, 0x32, 0x51, 0xD5, 0x70, 
+0x2E, 0x90, 0x8E, 0x12, 0xE0, 0x54, 0xFE, 0xF0, 0x7D, 0x2B, 0x7F, 0x0F, 0x12, 0x54, 0x6C, 0x90, 
+0x06, 0x04, 0xE0, 0x54, 0xBF, 0xF0, 0x12, 0x57, 0x23, 0xBF, 0x01, 0x0E, 0x90, 0x8E, 0x11, 0xE0, 
+0x44, 0x40, 0xF0, 0x7D, 0x06, 0x7F, 0x01, 0x02, 0x53, 0xF7, 0xF1, 0xEE, 0x74, 0x08, 0xF0, 0x22, 
+0x90, 0x93, 0x24, 0xE0, 0x30, 0xE0, 0x34, 0x51, 0xD5, 0x70, 0x30, 0x90, 0x95, 0x48, 0xE0, 0x04, 
+0xF0, 0xE0, 0xB4, 0x0A, 0x0B, 0x90, 0x93, 0x26, 0xE0, 0x04, 0xF0, 0xE4, 0x90, 0x95, 0x48, 0xF0, 
+0x90, 0x93, 0x26, 0xE0, 0xFF, 0x90, 0x93, 0x25, 0xE0, 0xD3, 0x9F, 0x50, 0x0E, 0x90, 0x93, 0x27, 
+0xE0, 0x70, 0x08, 0xE4, 0x90, 0x93, 0x26, 0xF0, 0x12, 0x87, 0x72, 0x22, 0xE4, 0x90, 0x93, 0xF3, 
+0xF0, 0x90, 0x8E, 0x15, 0xE0, 0x60, 0x3D, 0x51, 0xD5, 0x70, 0x39, 0x12, 0x9D, 0xDF, 0x12, 0x8F, 
+0xD7, 0xCE, 0xC3, 0x13, 0xCE, 0x13, 0xD8, 0xF9, 0x12, 0xA9, 0xCD, 0x90, 0x93, 0xF3, 0x74, 0x01, 
+0xF0, 0xE4, 0x90, 0x8E, 0x1C, 0xF0, 0x04, 0x60, 0x1B, 0xF1, 0xE2, 0xE4, 0x90, 0x94, 0xE7, 0xF0, 
+0x90, 0x8E, 0x1D, 0x91, 0x2E, 0x7E, 0x01, 0x12, 0x50, 0x04, 0x90, 0x8E, 0x18, 0xE0, 0x20, 0xE2, 
+0x03, 0x12, 0x51, 0xE4, 0x22, 0xF0, 0xE4, 0x90, 0x94, 0xE7, 0xF0, 0x90, 0x8E, 0xBA, 0xE0, 0x90, 
+0x94, 0xE8, 0xF0, 0xE4, 0xFB, 0xFD, 0x7F, 0x54, 0x22, 0x8B, 0x51, 0x8A, 0x52, 0x89, 0x53, 0xD1, 
+0xE7, 0xFF, 0xF5, 0x55, 0x12, 0x06, 0x89, 0xFE, 0xC3, 0x13, 0x30, 0xE0, 0x06, 0xF1, 0xBB, 0xF5, 
+0x56, 0x80, 0x02, 0x8F, 0x56, 0x85, 0x55, 0x54, 0xE5, 0x54, 0xD3, 0x95, 0x56, 0x50, 0x26, 0xAB, 
+0x51, 0xAA, 0x52, 0xA9, 0x53, 0x12, 0x06, 0x89, 0x54, 0x01, 0xFD, 0xAF, 0x54, 0x12, 0x95, 0xCF, 
+0xAF, 0x54, 0x51, 0xF2, 0xEF, 0xAF, 0x54, 0x70, 0x05, 0x12, 0x99, 0x46, 0x80, 0x03, 0x12, 0x99, 
+0x32, 0x05, 0x54, 0x80, 0xD3, 0xE5, 0x55, 0x70, 0x0F, 0xFF, 0x51, 0xF2, 0xEF, 0x70, 0x09, 0x12, 
+0x79, 0x41, 0x54, 0xBF, 0xF0, 0x54, 0x7F, 0xF0, 0x22, 0x90, 0x93, 0x39, 0x12, 0x49, 0x21, 0x90, 
+0x93, 0x38, 0xEF, 0xF0, 0x12, 0x49, 0x2A, 0x74, 0xE1, 0x00, 0x74, 0xE6, 0x01, 0x74, 0xEA, 0x02, 
+0x74, 0xEF, 0x03, 0x74, 0xF4, 0x04, 0x74, 0xF9, 0x12, 0x74, 0xFE, 0x14, 0x75, 0x03, 0x20, 0x75, 
+0x07, 0x21, 0x75, 0x0C, 0x23, 0x75, 0x11, 0x25, 0x75, 0x1B, 0x80, 0x75, 0x16, 0x81, 0x75, 0x20, 
+0x82, 0x75, 0x25, 0x83, 0x75, 0x2A, 0x84, 0x75, 0x34, 0x86, 0x75, 0x2F, 0x88, 0x00, 0x00, 0x75, 
+0x39, 0xB1, 0x49, 0x02, 0x8F, 0xE6, 0xB1, 0x49, 0x81, 0x39, 0xB1, 0x49, 0x02, 0x97, 0xD2, 0xB1, 
+0x49, 0x02, 0xA2, 0xD2, 0xB1, 0x49, 0x02, 0x8C, 0x3C, 0xB1, 0x49, 0x02, 0x98, 0x0F, 0xB1, 0x49, 
+0x02, 0x98, 0xD9, 0xB1, 0x49, 0xC1, 0x1D, 0xB1, 0x49, 0x02, 0x98, 0xE8, 0xB1, 0x49, 0x02, 0x99, 
+0x22, 0xB1, 0x49, 0x02, 0x99, 0x2A, 0xB1, 0x49, 0x02, 0x7A, 0xE7, 0xB1, 0x49, 0x02, 0x7B, 0x8E, 
+0xB1, 0x49, 0x02, 0xA6, 0xB0, 0xB1, 0x49, 0x02, 0x92, 0x0F, 0xB1, 0x49, 0x02, 0x92, 0x4D, 0xB1, 
+0x49, 0x02, 0xA6, 0xC6, 0xB1, 0x49, 0x02, 0x86, 0xD3, 0x90, 0x01, 0xC0, 0xE0, 0x44, 0x01, 0xF0, 
+0x90, 0x93, 0x38, 0xE0, 0x90, 0x01, 0xC2, 0xF0, 0x22, 0x90, 0x93, 0x39, 0x02, 0x49, 0x18, 0xD3, 
+0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x8D, 0x5F, 0xE0, 0xFF, 0x90, 0x8D, 0x5E, 0xE0, 0xB5, 
+0x07, 0x04, 0x7F, 0x01, 0x80, 0x02, 0x7F, 0x00, 0xEF, 0x70, 0x3E, 0x90, 0x8D, 0x5E, 0xE0, 0xFE, 
+0x75, 0xF0, 0x08, 0x90, 0x8D, 0x0E, 0x12, 0x49, 0x0C, 0xE0, 0xFD, 0xEE, 0x75, 0xF0, 0x08, 0xA4, 
+0x24, 0x0F, 0xF9, 0x74, 0x8D, 0x35, 0xF0, 0xFA, 0x7B, 0x01, 0xAF, 0x05, 0x91, 0x99, 0x90, 0x8D, 
+0x5E, 0xF1, 0xCB, 0xB4, 0x0A, 0x02, 0x7F, 0x01, 0xEF, 0x60, 0x05, 0xE4, 0x90, 0x8D, 0x5E, 0xF0, 
+0x31, 0xB0, 0x90, 0x8D, 0x01, 0xE0, 0x44, 0x02, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x12, 0x8F, 
+0xB4, 0x30, 0xE0, 0x0C, 0xEF, 0xC4, 0x13, 0x13, 0x54, 0x03, 0x30, 0xE0, 0x03, 0x12, 0x79, 0x5B, 
+0x90, 0x8E, 0x11, 0x12, 0x87, 0x6B, 0x30, 0xE0, 0x0A, 0xEF, 0x12, 0x9E, 0x49, 0x54, 0x07, 0x70, 
+0x44, 0x80, 0x40, 0x90, 0x8E, 0x1E, 0xE0, 0x04, 0xF0, 0x90, 0x8E, 0x19, 0xE0, 0x54, 0xEF, 0xF0, 
+0x12, 0x9E, 0x5F, 0x40, 0x2E, 0x51, 0xD5, 0x70, 0x2C, 0xD1, 0x16, 0x70, 0x05, 0x12, 0x9D, 0x7D, 
+0xE1, 0xDA, 0x12, 0x9D, 0x7D, 0x90, 0x8E, 0x1F, 0xE0, 0x04, 0xF0, 0xE0, 0xD3, 0x94, 0x02, 0x40, 
+0x09, 0xF1, 0xDA, 0xE4, 0x90, 0x8E, 0x1F, 0xF0, 0x80, 0x03, 0x12, 0x57, 0xBB, 0xE4, 0x90, 0x8E, 
+0x1E, 0xF0, 0x22, 0xF1, 0xC1, 0x22, 0x90, 0x8E, 0x13, 0xE0, 0x54, 0x0F, 0x22, 0x12, 0x87, 0x65, 
+0x12, 0x06, 0x89, 0xFF, 0x54, 0x7F, 0x90, 0x8E, 0x15, 0xF0, 0xEF, 0x12, 0x6F, 0xF0, 0xA3, 0xD1, 
+0xE6, 0xFF, 0x54, 0xF0, 0xC4, 0x54, 0x0F, 0xFE, 0x90, 0x8E, 0x13, 0xE0, 0x54, 0xF0, 0x4E, 0xF1, 
+0xD3, 0x54, 0x01, 0x25, 0xE0, 0xFE, 0x90, 0x8E, 0x11, 0xE0, 0x54, 0xFD, 0x4E, 0xF0, 0xEF, 0x54, 
+0x0F, 0xC4, 0x54, 0xF0, 0xFF, 0xD1, 0x16, 0xF1, 0xB9, 0x90, 0x8E, 0x14, 0xF0, 0xD1, 0xDF, 0x30, 
+0xE0, 0x4E, 0xC3, 0x13, 0x54, 0x07, 0xFF, 0xC3, 0x94, 0x04, 0x90, 0x8E, 0x28, 0x50, 0x04, 0xEF, 
+0xF0, 0x80, 0x26, 0x74, 0x03, 0xF0, 0xD1, 0xD9, 0xE9, 0x24, 0x06, 0x12, 0x92, 0x99, 0xFF, 0x74, 
+0x03, 0x24, 0xFD, 0xFE, 0xEF, 0xC4, 0x54, 0x0F, 0xFD, 0xEF, 0x54, 0x0F, 0xFF, 0xED, 0x2E, 0x54, 
+0x0F, 0xFE, 0xC4, 0x54, 0xF0, 0x4F, 0x12, 0x06, 0xCF, 0xD1, 0xD9, 0xD1, 0xDF, 0xC4, 0x54, 0x0F, 
+0xFF, 0xC3, 0x94, 0x04, 0x90, 0x8E, 0x1D, 0x50, 0x05, 0x74, 0x04, 0xF0, 0x80, 0x02, 0xEF, 0xF0, 
+0xD1, 0xD9, 0x12, 0x90, 0x26, 0xFD, 0x7F, 0x02, 0x12, 0x53, 0xF7, 0x90, 0x94, 0x65, 0xE0, 0x60, 
+0x03, 0x12, 0x53, 0xEB, 0xD1, 0xD9, 0x12, 0x79, 0x87, 0xF1, 0xEE, 0xF0, 0x90, 0x8E, 0x15, 0x12, 
+0xA9, 0x99, 0xD1, 0x16, 0x90, 0x01, 0xBE, 0xF0, 0x22, 0x90, 0x93, 0x3C, 0x02, 0x49, 0x18, 0x90, 
+0x00, 0x06, 0x02, 0x06, 0xA2, 0x4E, 0xF0, 0x90, 0x00, 0x01, 0x02, 0x06, 0xA2, 0x12, 0x06, 0x89, 
+0x90, 0x06, 0x74, 0xD1, 0xE6, 0x90, 0x06, 0x75, 0xF1, 0xBA, 0x90, 0x06, 0x76, 0xF1, 0xD3, 0x90, 
+0x06, 0x77, 0xF0, 0x90, 0x06, 0x70, 0xEF, 0xF0, 0xA3, 0xE4, 0xF0, 0xA3, 0x04, 0xF0, 0xA3, 0x74, 
+0x80, 0xF0, 0x7F, 0x01, 0x7E, 0x00, 0x02, 0x3D, 0x7A, 0x90, 0x93, 0x94, 0xEF, 0xF0, 0xA3, 0x12, 
+0x49, 0x21, 0x90, 0x93, 0x95, 0x12, 0x57, 0x05, 0xF1, 0xA4, 0x24, 0x02, 0xF1, 0x8A, 0x24, 0x04, 
+0xF1, 0x9B, 0x24, 0x03, 0xF1, 0x8A, 0x24, 0x08, 0xF1, 0x9B, 0x24, 0x04, 0xF1, 0x8A, 0x24, 0x0C, 
+0xF1, 0x9B, 0x24, 0x05, 0xFF, 0x7B, 0x01, 0x7A, 0x93, 0x79, 0x98, 0xD1, 0xED, 0x90, 0x93, 0x94, 
+0xE0, 0xFE, 0x44, 0x10, 0x90, 0x93, 0x98, 0xF0, 0xA3, 0x74, 0x80, 0xF0, 0xA3, 0x74, 0xFF, 0xF0, 
+0xA3, 0xF0, 0xEE, 0x75, 0xF0, 0x08, 0xA4, 0xFF, 0x7B, 0x01, 0x7A, 0x93, 0x79, 0x98, 0xD1, 0xED, 
+0x90, 0x93, 0x98, 0x74, 0xFF, 0x12, 0x4F, 0x6D, 0xF1, 0xB0, 0x04, 0xFF, 0x7B, 0x01, 0x7A, 0x93, 
+0x79, 0x98, 0xD1, 0xED, 0x90, 0x06, 0x72, 0xE4, 0xF0, 0x22, 0xFF, 0x7B, 0x01, 0x7A, 0x93, 0x79, 
+0x98, 0xD1, 0xED, 0x90, 0x93, 0x95, 0x12, 0x49, 0x18, 0xE9, 0x22, 0xF9, 0xE4, 0x3A, 0x8B, 0x40, 
+0xF5, 0x41, 0x89, 0x42, 0x75, 0x43, 0x04, 0x7B, 0x01, 0x7A, 0x93, 0x79, 0x98, 0x12, 0x34, 0x62, 
+0x90, 0x93, 0x94, 0xE0, 0x75, 0xF0, 0x08, 0xA4, 0x22, 0x4F, 0xF0, 0x90, 0x00, 0x02, 0x02, 0x06, 
+0xA2, 0x90, 0x8E, 0x17, 0xE0, 0xFF, 0x7D, 0x01, 0x02, 0x51, 0xE8, 0xE0, 0x04, 0xF0, 0xE0, 0x7F, 
+0x00, 0x22, 0x4F, 0xF0, 0x90, 0x00, 0x03, 0x02, 0x06, 0xA2, 0x90, 0x8E, 0x12, 0xE0, 0x54, 0xFB, 
+0xF0, 0x22, 0x90, 0x8E, 0x19, 0xE0, 0x44, 0x10, 0xF0, 0x22, 0x7F, 0x80, 0x21, 0xA1, 0x90, 0x01, 
+0xB9, 0x74, 0x01, 0xF0, 0x90, 0x01, 0xB8, 0x22, 0xC0, 0xE0, 0xC0, 0xF0, 0xC0, 0x83, 0xC0, 0x82, 
+0xC0, 0xD0, 0x75, 0xD0, 0x00, 0xC0, 0x00, 0xC0, 0x01, 0xC0, 0x02, 0xC0, 0x03, 0xC0, 0x04, 0xC0, 
+0x05, 0xC0, 0x06, 0xC0, 0x07, 0x12, 0x9A, 0x90, 0xE5, 0x21, 0x30, 0xE0, 0x03, 0x12, 0x77, 0xEA, 
+0xE5, 0x21, 0x30, 0xE1, 0x03, 0x12, 0x9F, 0x0A, 0xE5, 0x21, 0x30, 0xE2, 0x02, 0x31, 0x71, 0xE5, 
+0x22, 0x30, 0xE0, 0x03, 0x12, 0x9D, 0xA0, 0xE5, 0x24, 0x30, 0xE1, 0x05, 0x7F, 0x04, 0x12, 0x71, 
+0xA1, 0xE5, 0x24, 0x30, 0xE4, 0x02, 0x11, 0x73, 0xE5, 0x24, 0x30, 0xE5, 0x03, 0x12, 0x8B, 0xD5, 
+0xE5, 0x24, 0x30, 0xE6, 0x03, 0x12, 0x8C, 0x04, 0xD0, 0x07, 0xD0, 0x06, 0xD0, 0x05, 0xD0, 0x04, 
+0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0xD0, 0xD0, 0xD0, 0x82, 0xD0, 0x83, 0xD0, 0xF0, 
+0xD0, 0xE0, 0x32, 0x12, 0x73, 0xDC, 0x7D, 0x02, 0x7F, 0x02, 0x74, 0x15, 0x2F, 0xF8, 0xE6, 0x4D, 
+0xFE, 0xF6, 0x74, 0x30, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x01, 0xF5, 0x83, 0xEE, 0xF0, 0x22, 0x90, 
+0x8E, 0x11, 0xE0, 0x54, 0xFB, 0xF0, 0xE4, 0x90, 0x8E, 0x1E, 0xF0, 0xA3, 0xF0, 0x90, 0x8E, 0x19, 
+0xF0, 0x90, 0x8E, 0x12, 0xE0, 0x54, 0xF7, 0xF0, 0x54, 0xBF, 0xF0, 0x7D, 0x01, 0x7F, 0x02, 0x11, 
+0x7A, 0x7D, 0x02, 0x7F, 0x02, 0x11, 0x7A, 0x7D, 0x10, 0x7F, 0x03, 0x74, 0x1D, 0x12, 0xAA, 0x0B, 
+0x74, 0x38, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x01, 0xF5, 0x83, 0xEE, 0xF0, 0x22, 0x90, 0x01, 0x36, 
+0x74, 0x78, 0xF0, 0xA3, 0x74, 0x02, 0xF0, 0x7D, 0x78, 0xFF, 0x11, 0x7A, 0x7D, 0x02, 0x7F, 0x03, 
+0x11, 0x7A, 0x90, 0x06, 0x0A, 0xE0, 0x44, 0x07, 0x12, 0x9E, 0x54, 0xE4, 0xFF, 0x12, 0x72, 0xF2, 
+0xBF, 0x01, 0x11, 0x12, 0x77, 0xDA, 0x90, 0x8E, 0x18, 0xE0, 0x20, 0xE2, 0x0A, 0x7D, 0x01, 0x7F, 
+0x04, 0x02, 0x51, 0xE8, 0x12, 0x9D, 0xE7, 0x22, 0xEF, 0x70, 0x34, 0x7D, 0x78, 0x7F, 0x02, 0x31, 
+0x5F, 0x7D, 0x02, 0x7F, 0x03, 0x31, 0x5F, 0x7D, 0xC8, 0x7F, 0x02, 0x11, 0xBB, 0x12, 0x9E, 0x3E, 
+0xF0, 0xE4, 0xFF, 0x12, 0x72, 0xF2, 0xEF, 0x70, 0x0A, 0x31, 0x41, 0x54, 0xBF, 0xF0, 0x54, 0x7F, 
+0xF0, 0x80, 0x07, 0x7D, 0x01, 0x7F, 0x0C, 0x12, 0x51, 0xE8, 0x31, 0x46, 0x02, 0x97, 0xA8, 0x80, 
+0x8C, 0x12, 0x4C, 0xF1, 0x31, 0x4E, 0x90, 0x8E, 0x11, 0xE0, 0x54, 0xF7, 0xF0, 0x22, 0x12, 0x97, 
+0xA0, 0x12, 0x87, 0xCC, 0x7D, 0x0C, 0x7F, 0x01, 0x02, 0x53, 0xF7, 0x7D, 0x02, 0x7F, 0x02, 0x74, 
+0x15, 0x12, 0xAA, 0x0B, 0x74, 0x30, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x01, 0xF5, 0x83, 0xEE, 0xF0, 
+0x22, 0x90, 0x8E, 0x15, 0xE0, 0x60, 0x0F, 0x90, 0x06, 0x92, 0xE0, 0x30, 0xE1, 0x03, 0x02, 0x9E, 
+0x02, 0x31, 0x46, 0x12, 0x77, 0xC1, 0x22, 0x90, 0x93, 0x3F, 0x12, 0x49, 0x21, 0x11, 0x8F, 0x90, 
+0x8E, 0x15, 0xE0, 0xFF, 0x31, 0x08, 0x90, 0x8E, 0x15, 0xE0, 0x60, 0x13, 0x90, 0x93, 0x3F, 0x12, 
+0x49, 0x18, 0x12, 0x76, 0xE7, 0x54, 0x0F, 0xFF, 0x12, 0x77, 0xBB, 0xFD, 0x12, 0xA7, 0x4F, 0x22, 
+0xEF, 0x60, 0x38, 0x90, 0x93, 0x14, 0xE0, 0xFF, 0x60, 0x03, 0x12, 0xA4, 0x27, 0x90, 0x01, 0xC7, 
+0xE4, 0x91, 0x92, 0xF1, 0xE5, 0x90, 0x06, 0x09, 0xE0, 0x54, 0xFE, 0xF0, 0x7D, 0x35, 0x12, 0x4C, 
+0x85, 0x12, 0x87, 0xB9, 0x12, 0x8D, 0x54, 0x12, 0xA6, 0xFA, 0x12, 0x87, 0xC9, 0x12, 0x99, 0xA0, 
+0x90, 0x01, 0x34, 0x74, 0x08, 0xF0, 0xFD, 0xE4, 0xFF, 0x01, 0x7A, 0x7D, 0x08, 0xE4, 0xFF, 0x31, 
+0x5F, 0x90, 0x06, 0x90, 0xE0, 0x54, 0xF0, 0xF0, 0x12, 0x87, 0x99, 0x12, 0x99, 0xF3, 0x12, 0x8A, 
+0xEE, 0x12, 0x95, 0x5A, 0x7A, 0x8E, 0x79, 0xC0, 0x12, 0x08, 0xAA, 0x90, 0x06, 0x90, 0xE0, 0x44, 
+0x20, 0xF0, 0x12, 0x9A, 0x18, 0x12, 0x8B, 0x16, 0x90, 0x8D, 0x06, 0xE0, 0xFF, 0x64, 0x02, 0x70, 
+0x2A, 0x51, 0xE0, 0x30, 0xE0, 0x02, 0x7E, 0x01, 0x90, 0x8E, 0xDF, 0x51, 0xDE, 0x30, 0xE1, 0x02, 
+0x7E, 0x01, 0x90, 0x8E, 0xDD, 0x51, 0xDE, 0x30, 0xE2, 0x02, 0x7E, 0x01, 0x90, 0x8E, 0xDE, 0xEE, 
+0xF0, 0x90, 0xFD, 0x80, 0xE0, 0x90, 0x02, 0xFB, 0xF0, 0x80, 0x4A, 0xEF, 0x64, 0x01, 0x70, 0x1D, 
+0x51, 0xD7, 0x30, 0xE0, 0x02, 0x7F, 0x01, 0x90, 0x8E, 0xDF, 0x51, 0xD5, 0x30, 0xE1, 0x02, 0x7F, 
+0x01, 0x90, 0x8E, 0xDD, 0x51, 0xD5, 0x30, 0xE2, 0x02, 0x7F, 0x01, 0x80, 0x23, 0x90, 0x8D, 0x06, 
+0xE0, 0x64, 0x03, 0x70, 0x20, 0x51, 0xCE, 0x30, 0xE0, 0x02, 0x7F, 0x01, 0x90, 0x8E, 0xDF, 0x51, 
+0xCC, 0x30, 0xE1, 0x02, 0x7F, 0x01, 0x90, 0x8E, 0xDD, 0x51, 0xCC, 0x30, 0xE2, 0x02, 0x7F, 0x01, 
+0x90, 0x8E, 0xDE, 0xEF, 0xF0, 0x90, 0x8E, 0xC0, 0xE0, 0x54, 0xEF, 0xF0, 0xE4, 0x90, 0x90, 0xC6, 
+0xF0, 0xA3, 0xF0, 0x90, 0x90, 0xCE, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 0x00, 0x90, 0x90, 0xD2, 
+0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 0x00, 0x90, 0x90, 0xCA, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 
+0x00, 0x90, 0x93, 0x0E, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 0x00, 0x22, 0xEF, 0xF0, 0x90, 0xFD, 
+0x78, 0xE0, 0x7F, 0x00, 0x22, 0xEF, 0xF0, 0x90, 0xFD, 0x70, 0xE0, 0x7F, 0x00, 0x22, 0xEE, 0xF0, 
+0x90, 0xFD, 0x80, 0xE0, 0x7E, 0x00, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0xF1, 0xDE, 
+0xFE, 0x90, 0x8E, 0xC0, 0x71, 0x79, 0x12, 0xAA, 0x42, 0xFF, 0x90, 0x8E, 0xC0, 0x12, 0x87, 0xDB, 
+0x4E, 0x71, 0x87, 0x12, 0xAA, 0x15, 0x90, 0x8E, 0xC0, 0x12, 0xA9, 0xE3, 0x71, 0x87, 0x12, 0xAA, 
+0x1E, 0x90, 0x8E, 0xC0, 0x12, 0xAA, 0x30, 0x4E, 0x12, 0x77, 0xBA, 0x54, 0x01, 0xFF, 0x90, 0x8E, 
+0xC2, 0xE0, 0x54, 0xFE, 0x4F, 0x12, 0x76, 0xE6, 0x54, 0x01, 0xFF, 0x90, 0x8E, 0xC1, 0xE0, 0x54, 
+0xFE, 0x4F, 0x91, 0x92, 0xF1, 0xE5, 0x90, 0x8E, 0xC0, 0xE0, 0xC3, 0x13, 0x54, 0x01, 0xFF, 0x12, 
+0xA6, 0xD6, 0x91, 0x8B, 0x54, 0x01, 0xFF, 0x12, 0xA4, 0x45, 0x91, 0x8B, 0x13, 0x54, 0x01, 0xFF, 
+0x12, 0x86, 0x00, 0x90, 0x8E, 0xC0, 0xE0, 0xC4, 0x54, 0x01, 0xFF, 0x12, 0xA6, 0xE2, 0x90, 0x8E, 
+0xC0, 0xE0, 0xC4, 0x13, 0x13, 0x54, 0x01, 0xFF, 0x12, 0xA6, 0xF0, 0x90, 0x8E, 0xC0, 0xE0, 0x54, 
+0x01, 0xFF, 0x31, 0xB0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xE0, 0x54, 0xFE, 0x4E, 0xFE, 0xF0, 0xEF, 
+0x54, 0x02, 0xFF, 0xEE, 0x54, 0xFD, 0x4F, 0xFF, 0xF0, 0x12, 0x06, 0x89, 0xFE, 0x22, 0xD3, 0x10, 
+0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x12, 0x87, 0x65, 0x12, 0x06, 0x89, 0x20, 0xE0, 0x05, 0x12, 0x99, 
+0xF3, 0x81, 0x86, 0x90, 0x8F, 0x94, 0x74, 0x05, 0xF0, 0x12, 0x76, 0xD9, 0xF1, 0xDE, 0xFE, 0x90, 
+0x8E, 0xC3, 0x71, 0x79, 0x12, 0xAA, 0x42, 0xFF, 0x90, 0x8E, 0xC3, 0x12, 0x87, 0xDB, 0x4E, 0x71, 
+0x87, 0x12, 0xAA, 0x15, 0x90, 0x8E, 0xC3, 0x12, 0xA9, 0xE3, 0x71, 0x87, 0x12, 0xAA, 0x1E, 0x90, 
+0x8E, 0xC3, 0x12, 0xAA, 0x30, 0x12, 0x76, 0xE5, 0x54, 0x80, 0xFF, 0x90, 0x8E, 0xC4, 0xE0, 0x54, 
+0x7F, 0x4F, 0xF0, 0x12, 0x06, 0x89, 0x13, 0x13, 0x54, 0x3F, 0x30, 0xE0, 0x07, 0x90, 0x06, 0x90, 
+0xE0, 0x44, 0x04, 0xF0, 0x12, 0x76, 0xD9, 0x12, 0x06, 0x89, 0x13, 0x13, 0x13, 0x54, 0x1F, 0x30, 
+0xE0, 0x07, 0x90, 0x06, 0x90, 0xE0, 0x44, 0x08, 0xF0, 0x90, 0x8D, 0x06, 0xE0, 0xB4, 0x02, 0x0A, 
+0x90, 0x8E, 0xC4, 0xE0, 0x12, 0x6F, 0xF0, 0x20, 0xE0, 0x5E, 0x12, 0x76, 0xE7, 0x54, 0x7F, 0xFF, 
+0x90, 0x8E, 0xC4, 0xE0, 0x54, 0x80, 0x12, 0x77, 0xB9, 0x90, 0x8E, 0xC5, 0x12, 0x77, 0xD3, 0xFF, 
+0x54, 0x01, 0xFE, 0x90, 0x8E, 0xC6, 0xE0, 0x54, 0xFE, 0x4E, 0xFE, 0xF0, 0xEF, 0x54, 0xFE, 0xFF, 
+0xEE, 0x54, 0x01, 0x4F, 0xF0, 0x12, 0x4E, 0xB3, 0x13, 0x54, 0x07, 0x7D, 0x00, 0x20, 0xE0, 0x02, 
+0x7D, 0x01, 0x12, 0x4B, 0xB7, 0x90, 0x8D, 0x06, 0xE0, 0xB4, 0x01, 0x1C, 0x7F, 0x4E, 0x12, 0x4C, 
+0x69, 0xEF, 0x54, 0xBF, 0xFD, 0x7F, 0x4E, 0x12, 0x4B, 0x9F, 0x7F, 0x4A, 0x12, 0x4C, 0x69, 0xEF, 
+0x54, 0xFB, 0xFD, 0x7F, 0x4A, 0x12, 0x4B, 0x9F, 0x90, 0x8D, 0x06, 0xE0, 0xB4, 0x01, 0x07, 0x90, 
+0xFE, 0x10, 0xE0, 0x44, 0x04, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0x8E, 0xC0, 0xE0, 0x13, 
+0x13, 0x22, 0xF0, 0x90, 0x01, 0x17, 0xE0, 0xFE, 0x90, 0x01, 0x16, 0xE0, 0x7C, 0x00, 0x24, 0x00, 
+0xFF, 0xEC, 0x3E, 0x22, 0x90, 0x93, 0x1F, 0xB1, 0x65, 0xEF, 0xF0, 0xE0, 0xFE, 0x24, 0x28, 0xF5, 
+0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0xFF, 0x74, 0x29, 0x2E, 0x12, 0x83, 0x7E, 0xFD, 0x90, 
+0x93, 0x3C, 0xE0, 0x24, 0x2C, 0x12, 0xA8, 0xF1, 0x12, 0x84, 0x71, 0x90, 0x93, 0x3C, 0xE0, 0x2F, 
+0x24, 0x30, 0xA3, 0xF0, 0xE0, 0xFD, 0x24, 0x04, 0x12, 0x86, 0xCB, 0xE0, 0xFE, 0x12, 0xAA, 0x27, 
+0xF5, 0x83, 0x91, 0x9B, 0x90, 0x90, 0x7A, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0x93, 0x3D, 0xE0, 0x24, 
+0x0C, 0xF9, 0xE4, 0x34, 0xFC, 0x12, 0x83, 0xF4, 0x75, 0x43, 0x04, 0x7B, 0x01, 0x7A, 0x90, 0x79, 
+0x7C, 0x12, 0x34, 0x62, 0x90, 0x93, 0x3D, 0xE0, 0x24, 0x14, 0xF0, 0xE0, 0xFD, 0x24, 0x01, 0x12, 
+0x5E, 0xE1, 0xE0, 0xFE, 0x74, 0x00, 0x2D, 0x12, 0x5D, 0x91, 0x91, 0x9B, 0x90, 0x90, 0x80, 0xF0, 
+0xA3, 0xEF, 0xF0, 0x90, 0x93, 0x20, 0xB1, 0x65, 0xEF, 0xF0, 0x90, 0x90, 0x76, 0xE0, 0xFE, 0xA3, 
+0xE0, 0xFF, 0x4E, 0x60, 0x14, 0x90, 0x93, 0x3C, 0xE0, 0x24, 0x00, 0x12, 0x83, 0xF0, 0x8F, 0x43, 
+0x7B, 0x01, 0x7A, 0x90, 0x79, 0x84, 0x12, 0x34, 0x62, 0x90, 0x93, 0x21, 0xB1, 0x65, 0xEF, 0xF0, 
+0x24, 0x00, 0x12, 0x83, 0xF0, 0x90, 0x90, 0x78, 0xA3, 0xE0, 0xF5, 0x43, 0x7B, 0x01, 0x7A, 0x90, 
+0x79, 0xA4, 0x02, 0x34, 0x62, 0xE0, 0xFF, 0xF1, 0xD6, 0x90, 0x93, 0x3C, 0x22, 0xD3, 0x10, 0xAF, 
+0x01, 0xC3, 0xC0, 0xD0, 0xE4, 0x90, 0x93, 0x3C, 0xF0, 0xA3, 0xF0, 0x90, 0x02, 0x09, 0xE0, 0x90, 
+0x93, 0x41, 0xF0, 0x90, 0x93, 0x22, 0xE0, 0xFF, 0xF1, 0xD6, 0x7E, 0x00, 0x90, 0x93, 0x3C, 0xEE, 
+0xF0, 0xA3, 0xEF, 0xF0, 0x12, 0x5D, 0x8F, 0xE0, 0x90, 0x90, 0xC6, 0xF0, 0x74, 0x01, 0x2F, 0x12, 
+0x5E, 0xE1, 0xE0, 0x90, 0x90, 0xC7, 0xF0, 0x90, 0x01, 0xA0, 0xF0, 0x90, 0x93, 0x3C, 0x12, 0x8A, 
+0xE7, 0x90, 0x93, 0x3C, 0xA3, 0xE0, 0x24, 0x02, 0x12, 0x86, 0x9A, 0xFF, 0xE4, 0xFC, 0xFD, 0x78, 
+0x10, 0x12, 0x08, 0x5A, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0x12, 0xA9, 0x2D, 0x12, 
+0x80, 0x75, 0x78, 0x18, 0x12, 0x08, 0x5A, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0x12, 
+0x48, 0x6D, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0x12, 0xA9, 0x67, 0x34, 0xFC, 0x12, 
+0x80, 0x75, 0x78, 0x08, 0x12, 0x08, 0x5A, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0x12, 
+0x5D, 0x7F, 0x12, 0x80, 0x77, 0x12, 0x48, 0x6D, 0x90, 0x90, 0xCA, 0x12, 0x80, 0x5C, 0x78, 0x10, 
+0x12, 0x08, 0x5A, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0x12, 0xA9, 0x2D, 0x12, 0x80, 
+0x75, 0x78, 0x18, 0x12, 0x08, 0x5A, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0x12, 0x48, 
+0x6D, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0x12, 0xA9, 0x67, 0x34, 0xFC, 0x12, 0x80, 
+0x75, 0x78, 0x08, 0x12, 0x08, 0x5A, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0x12, 0x5D, 
+0x7F, 0x12, 0x80, 0x77, 0x12, 0x48, 0x6D, 0x90, 0x90, 0xCE, 0x12, 0x80, 0x5C, 0x78, 0x10, 0x12, 
+0x08, 0x5A, 0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0x12, 0xA9, 0x2D, 0x12, 0x80, 0x75, 
+0x78, 0x18, 0x12, 0x08, 0x5A, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0x12, 0x48, 0x6D, 
+0xC0, 0x04, 0xC0, 0x05, 0xC0, 0x06, 0xC0, 0x07, 0x12, 0xA9, 0x67, 0x34, 0xFC, 0x12, 0x80, 0x75, 
+0x78, 0x08, 0x12, 0x08, 0x5A, 0xD0, 0x03, 0xD0, 0x02, 0xD0, 0x01, 0xD0, 0x00, 0x12, 0x5D, 0x7F, 
+0x12, 0x80, 0x77, 0x12, 0x48, 0x6D, 0x90, 0x90, 0xD2, 0x12, 0x08, 0x6D, 0x90, 0x93, 0x3C, 0xE4, 
+0x75, 0xF0, 0x04, 0x12, 0xA9, 0x24, 0x12, 0xA9, 0x5C, 0x12, 0x5D, 0x8F, 0xE0, 0xFF, 0x12, 0x8F, 
+0x8E, 0xF1, 0xC6, 0xE0, 0xB4, 0x10, 0xEF, 0x12, 0xA9, 0x1D, 0x12, 0xA9, 0x5C, 0x12, 0x5D, 0x8F, 
+0xE0, 0xFF, 0x74, 0xE6, 0x2E, 0xF5, 0x82, 0xE4, 0x34, 0x90, 0xF1, 0xC6, 0xE0, 0xB4, 0x10, 0xEA, 
+0x12, 0xA9, 0x1D, 0x12, 0xA9, 0x5C, 0x12, 0x5D, 0x8F, 0xE0, 0xFF, 0x74, 0xF6, 0x2E, 0xF5, 0x82, 
+0xE4, 0x34, 0x90, 0xF1, 0xC6, 0xE0, 0xB4, 0x10, 0xEA, 0x12, 0xA9, 0x1D, 0x90, 0x93, 0x3E, 0xE0, 
+0xFF, 0xC3, 0x94, 0x08, 0x50, 0x20, 0x90, 0x93, 0x3C, 0xA3, 0xE0, 0xFE, 0xEF, 0x2E, 0x12, 0x5D, 
+0x8F, 0xE0, 0xFE, 0x90, 0x93, 0x41, 0xE0, 0xFD, 0xEE, 0x2D, 0xFE, 0x74, 0x06, 0x2F, 0x12, 0x87, 
+0xA9, 0xEE, 0xF1, 0xC9, 0x80, 0xD6, 0x90, 0x91, 0x06, 0xE0, 0x90, 0x01, 0xA1, 0xF0, 0x90, 0x91, 
+0x07, 0xE0, 0x90, 0x01, 0xA2, 0xF0, 0x90, 0x91, 0x08, 0xE0, 0x90, 0x01, 0xA3, 0xF0, 0x90, 0x91, 
+0x09, 0xE0, 0x90, 0x01, 0xA4, 0xF0, 0x90, 0x91, 0x0A, 0xE0, 0x90, 0x01, 0xA5, 0xF0, 0x90, 0x93, 
+0x22, 0xE0, 0x90, 0x93, 0x40, 0xF0, 0x90, 0x93, 0x3C, 0xE4, 0xF0, 0xA3, 0x74, 0x80, 0xF0, 0xE4, 
+0xA3, 0xF0, 0x90, 0x93, 0x3E, 0xE0, 0xFF, 0xC3, 0x94, 0x10, 0x50, 0x43, 0xEF, 0x12, 0xA9, 0x81, 
+0xC0, 0x03, 0xC0, 0x01, 0x90, 0x93, 0x3C, 0xA3, 0xE0, 0x24, 0x00, 0xF9, 0xE4, 0x34, 0xFC, 0x8B, 
+0x40, 0xF5, 0x41, 0x89, 0x42, 0x75, 0x43, 0x20, 0xD0, 0x01, 0xD0, 0x03, 0x12, 0x84, 0x63, 0x12, 
+0xAA, 0x4A, 0x90, 0x93, 0x3C, 0xE0, 0xB4, 0x01, 0x12, 0xA3, 0xE0, 0xB4, 0x00, 0x0D, 0x90, 0x93, 
+0x40, 0xE0, 0x04, 0xF0, 0xB1, 0x65, 0xE4, 0xF0, 0xA3, 0xEF, 0xF0, 0xF1, 0xCA, 0x80, 0xB3, 0xE4, 
+0x90, 0x93, 0x3E, 0xF0, 0xE4, 0xFF, 0x0F, 0xEF, 0xB4, 0x20, 0xFB, 0xF1, 0xCA, 0xE0, 0xB4, 0x10, 
+0xF3, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xF5, 0x83, 0xEF, 0xF0, 0x90, 0x93, 0x3E, 0xE0, 0x04, 0xF0, 
+0x22, 0x90, 0x8D, 0xFD, 0xE0, 0xFF, 0x90, 0xFD, 0x10, 0xEF, 0xF0, 0x7F, 0x00, 0x22, 0x12, 0x06, 
+0x89, 0xFF, 0x54, 0x01, 0x22, 0x90, 0x8D, 0xF8, 0xF0, 0xA3, 0xEF, 0xF0, 0x22, 0x32, 0x32, 0xD3, 
+0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x94, 0xDC, 0xEF, 0xF0, 0xA3, 0xED, 0xF0, 0x7D, 0x00, 
+0x7C, 0x00, 0xE4, 0x90, 0x94, 0xE2, 0xF0, 0x7F, 0xB0, 0x7E, 0x08, 0x12, 0x37, 0xBC, 0xE4, 0xFF, 
+0xEC, 0x90, 0x94, 0xDE, 0x12, 0x08, 0x6D, 0x90, 0x94, 0xDE, 0x12, 0x49, 0x00, 0x90, 0x94, 0xDD, 
+0x11, 0x77, 0x12, 0x48, 0xD6, 0xA3, 0x12, 0x08, 0x6D, 0x90, 0x94, 0xDE, 0x12, 0x4E, 0xD2, 0x7F, 
+0xB0, 0x7E, 0x08, 0x12, 0x38, 0x07, 0xF1, 0x92, 0x90, 0x94, 0xDC, 0xE0, 0x75, 0xF0, 0x08, 0xA4, 
+0x24, 0xB5, 0xF5, 0x82, 0xE4, 0x34, 0xAD, 0xF5, 0x83, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x12, 0x37, 
+0xBC, 0xED, 0x54, 0x0F, 0xFD, 0xE4, 0xFC, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x12, 0x08, 0x6D, 0x90, 
+0x93, 0x3C, 0xE4, 0x75, 0xF0, 0x04, 0x12, 0x08, 0xD6, 0x90, 0x93, 0x3C, 0xA3, 0xE0, 0x24, 0x02, 
+0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0xFF, 0xE4, 0xFC, 0xFD, 0xFE, 0x22, 0x90, 0x8D, 
+0xFB, 0xF1, 0x6B, 0x30, 0xE0, 0x07, 0xF1, 0x99, 0xE4, 0x90, 0x94, 0x64, 0xF0, 0x90, 0x94, 0x8F, 
+0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 0x7F, 0x90, 0x94, 0x4A, 0x11, 0x77, 0x12, 0x67, 0xF1, 0x7F, 
+0x50, 0x7E, 0x0C, 0x12, 0x66, 0x52, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 0x7F, 0x90, 0x94, 0x4B, 
+0x11, 0x77, 0x12, 0x67, 0xF1, 0xF1, 0x8B, 0x90, 0x94, 0x60, 0xE0, 0x90, 0x06, 0x08, 0xF0, 0x90, 
+0x94, 0x62, 0xA3, 0xE0, 0x90, 0x06, 0xA0, 0xF0, 0xA3, 0xE4, 0xF0, 0x90, 0x94, 0x4E, 0xE0, 0xFF, 
+0x60, 0x0D, 0x90, 0x94, 0x50, 0xE0, 0xFD, 0x90, 0x94, 0x4F, 0xE0, 0xFB, 0x12, 0x60, 0x6A, 0x90, 
+0x94, 0x4D, 0xE0, 0xFF, 0x60, 0x08, 0x12, 0x98, 0xD2, 0x71, 0xA4, 0x12, 0x61, 0xB1, 0x22, 0xD3, 
+0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x94, 0x5C, 0xE0, 0xFF, 0x12, 0xA8, 0x54, 0xEF, 0x70, 
+0x02, 0x21, 0xA2, 0x90, 0x94, 0x5D, 0xE0, 0xFB, 0xD3, 0x94, 0x00, 0x40, 0x1A, 0x90, 0x94, 0x8F, 
+0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 0x0F, 0xAF, 0x03, 0xE4, 0xFC, 0xFD, 0xFE, 0x12, 0x67, 0xF1, 
+0x7F, 0x20, 0x7E, 0x0C, 0x12, 0x65, 0xDA, 0x90, 0x94, 0x5C, 0xE0, 0xFF, 0x90, 0x06, 0x33, 0xF0, 
+0x71, 0xA4, 0xE4, 0xFB, 0xFD, 0x12, 0x61, 0xB1, 0x90, 0x94, 0x5F, 0xE0, 0x60, 0x07, 0x90, 0x8D, 
+0xFC, 0xE0, 0xFF, 0x31, 0xE6, 0xF1, 0xA1, 0x30, 0xE0, 0x34, 0x90, 0x90, 0xC7, 0xE0, 0x60, 0x2E, 
+0xE4, 0x90, 0x93, 0x3A, 0xF0, 0x90, 0x90, 0xC7, 0xE0, 0xFF, 0x90, 0x93, 0x3A, 0xE0, 0xC3, 0x9F, 
+0x50, 0x1C, 0x7F, 0x03, 0x7E, 0x00, 0x12, 0x3C, 0xEC, 0x90, 0x93, 0x3A, 0xE0, 0x24, 0x06, 0xF1, 
+0xA9, 0xE0, 0xFF, 0x31, 0xE6, 0x90, 0x01, 0xA6, 0xE0, 0x04, 0x71, 0x9C, 0x80, 0xD7, 0x90, 0x94, 
+0x5E, 0xE0, 0x90, 0x93, 0x39, 0xF0, 0x90, 0x94, 0x49, 0xE0, 0x04, 0xF0, 0xE0, 0xFF, 0x71, 0xB6, 
+0x90, 0x93, 0x39, 0x11, 0x77, 0x90, 0x93, 0x4B, 0x12, 0x08, 0x6D, 0xF1, 0xB1, 0x12, 0x50, 0x38, 
+0x80, 0x3F, 0xE4, 0x90, 0x94, 0x49, 0xF0, 0x90, 0x94, 0x65, 0xF0, 0x90, 0x06, 0x32, 0xE0, 0x54, 
+0xFB, 0xF0, 0x11, 0x7E, 0xE4, 0xFF, 0x12, 0x72, 0xF2, 0xBF, 0x01, 0x0C, 0x90, 0x94, 0x61, 0xE0, 
+0xFD, 0x7F, 0x02, 0x12, 0x53, 0xF7, 0x71, 0xAD, 0x90, 0x93, 0x3B, 0x74, 0x07, 0xF0, 0x90, 0x93, 
+0x49, 0xF0, 0x7B, 0x01, 0x7A, 0x93, 0x79, 0x3B, 0xB1, 0x0E, 0x7F, 0x04, 0x12, 0x71, 0x82, 0x91, 
+0xC9, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x93, 0x4A, 
+0xEF, 0xF0, 0x12, 0x9F, 0x14, 0xBF, 0x01, 0x17, 0x90, 0x06, 0x32, 0xE0, 0x44, 0x08, 0xF0, 0x90, 
+0x93, 0x4A, 0x51, 0x17, 0x90, 0x93, 0x4B, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x12, 0x55, 0xDF, 0xD0, 
+0xD0, 0x92, 0xAF, 0x22, 0x90, 0x93, 0x17, 0xE0, 0xFF, 0x7B, 0x18, 0x7D, 0x01, 0xD3, 0x10, 0xAF, 
+0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x95, 0x2E, 0xED, 0xF0, 0xA3, 0xEB, 0xF0, 0x90, 0x95, 0x2D, 0xEF, 
+0xF0, 0xE4, 0xFD, 0xFC, 0xB1, 0xF8, 0x90, 0x95, 0x2D, 0xE0, 0x90, 0x04, 0x25, 0xF0, 0x90, 0x95, 
+0x2E, 0xE0, 0x60, 0x05, 0x71, 0x4E, 0x44, 0x80, 0xF0, 0xAF, 0x05, 0x74, 0x20, 0x2F, 0xF5, 0x82, 
+0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x54, 0xC0, 0xF0, 0x71, 0x4E, 0x54, 0xC0, 0xF0, 0x90, 0x00, 
+0x8B, 0xE0, 0xD3, 0x94, 0x03, 0x74, 0x10, 0x40, 0x07, 0x51, 0xA7, 0x74, 0x04, 0xF0, 0x80, 0x04, 
+0x51, 0xA7, 0xE4, 0xF0, 0xAF, 0x05, 0x51, 0xB0, 0xE0, 0x54, 0x01, 0xFE, 0x90, 0x95, 0x2F, 0xE0, 
+0x25, 0xE0, 0x25, 0xE0, 0xFB, 0xEE, 0x44, 0x02, 0x4B, 0xFE, 0x51, 0xB0, 0xEE, 0xF0, 0x74, 0x11, 
+0x2F, 0x71, 0x93, 0x74, 0xFF, 0xF0, 0x74, 0x29, 0x2F, 0x71, 0x7E, 0x54, 0xF7, 0xF0, 0xAE, 0x04, 
+0xAF, 0x05, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0x22, 
+0x74, 0x12, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0x22, 0x90, 0x8D, 0x09, 0xE0, 0xFF, 
+0x90, 0x95, 0x02, 0xE0, 0xFB, 0x7D, 0x01, 0x51, 0x1D, 0x90, 0x95, 0x03, 0xEE, 0xF0, 0xFC, 0xA3, 
+0xEF, 0xF0, 0xFD, 0x90, 0x95, 0x01, 0xE0, 0xFF, 0x71, 0x5A, 0x90, 0x95, 0x03, 0xE0, 0xFE, 0xA3, 
+0xE0, 0xFF, 0x90, 0x81, 0x00, 0xE0, 0x54, 0x0F, 0xFD, 0xAC, 0x07, 0x71, 0x42, 0x44, 0x01, 0xF0, 
+0x71, 0x42, 0x54, 0xFB, 0xF0, 0xAC, 0x07, 0x74, 0x12, 0x2C, 0x51, 0xB3, 0xE0, 0x44, 0xFA, 0xF0, 
+0x74, 0x11, 0x2C, 0x71, 0x93, 0xE0, 0x44, 0x1F, 0xF0, 0xAC, 0x07, 0x74, 0x06, 0x2C, 0xB1, 0xED, 
+0x44, 0x0E, 0xF0, 0x90, 0x04, 0xA7, 0xE4, 0xF0, 0x90, 0x04, 0xA6, 0xF0, 0x90, 0x04, 0xA5, 0x74, 
+0xFF, 0xF0, 0x90, 0x04, 0xA4, 0x74, 0xFD, 0xF0, 0x74, 0x14, 0x2C, 0x71, 0x3A, 0xE0, 0x54, 0xC0, 
+0x4D, 0xFD, 0x74, 0x14, 0x2F, 0x71, 0x3A, 0xED, 0xF0, 0x22, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 
+0x83, 0x22, 0x74, 0x0D, 0x2C, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x22, 0x74, 0x21, 
+0x2F, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x22, 0x71, 0x87, 0x54, 0x3F, 0xF0, 0xEF, 
+0x60, 0x0E, 0x74, 0x29, 0x2D, 0x71, 0x7E, 0x44, 0x10, 0xF0, 0x71, 0x87, 0x44, 0x80, 0xF0, 0x22, 
+0x74, 0x29, 0x2D, 0x71, 0x7E, 0x54, 0xEF, 0xF0, 0x71, 0x87, 0x44, 0x40, 0xF0, 0x22, 0xF5, 0x82, 
+0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x22, 0x74, 0x09, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 
+0x83, 0xE0, 0x22, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0x22, 0xEF, 0xF0, 0x90, 0x93, 0x3A, 
+0xE0, 0x04, 0xF0, 0x22, 0x90, 0x94, 0x54, 0xE0, 0x90, 0x95, 0x21, 0xF0, 0x22, 0xF1, 0xCC, 0x7D, 
+0x04, 0x7F, 0x01, 0x02, 0x53, 0xF7, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x93, 0x4A, 
+0xEF, 0xF0, 0x12, 0x7F, 0xD1, 0x74, 0x10, 0x2F, 0xFF, 0x90, 0x93, 0x4A, 0xE0, 0x25, 0xE0, 0x25, 
+0xE0, 0x2F, 0xFF, 0x24, 0x00, 0x71, 0xF0, 0x75, 0x43, 0x04, 0x7B, 0x01, 0x7A, 0x94, 0x79, 0x5C, 
+0x12, 0x34, 0x62, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x12, 0x7F, 0xD6, 0x7E, 0x00, 0x74, 0x00, 0x2F, 
+0xF9, 0xE4, 0x34, 0xFC, 0x75, 0x40, 0x01, 0xF5, 0x41, 0x89, 0x42, 0x22, 0x12, 0x7D, 0x67, 0xE4, 
+0xF1, 0xC1, 0x12, 0xA8, 0xD4, 0x91, 0x71, 0x90, 0x93, 0x3E, 0xEF, 0xF0, 0x90, 0x93, 0x3C, 0xA3, 
+0xE0, 0x24, 0x38, 0xF9, 0xE4, 0x34, 0xFC, 0x71, 0xF4, 0x75, 0x43, 0x06, 0x7B, 0x01, 0x7A, 0x8E, 
+0x79, 0xE0, 0x91, 0x63, 0x12, 0x55, 0xEC, 0x24, 0x3E, 0xF9, 0xE4, 0x34, 0xFC, 0x71, 0xF4, 0x75, 
+0x43, 0x04, 0x7B, 0x01, 0x7A, 0x8E, 0x79, 0xE6, 0x91, 0x63, 0x12, 0x55, 0xEC, 0x91, 0x6A, 0x71, 
+0xF4, 0x75, 0x43, 0x06, 0x7B, 0x01, 0x7A, 0x8E, 0x79, 0xEA, 0x91, 0x63, 0x12, 0x55, 0xEC, 0x24, 
+0x48, 0xF9, 0xE4, 0x34, 0xFC, 0x71, 0xF4, 0x75, 0x43, 0x04, 0x7B, 0x01, 0x7A, 0x8E, 0x79, 0xF0, 
+0x02, 0x34, 0x62, 0x12, 0x34, 0x62, 0x90, 0x93, 0x3C, 0x22, 0x24, 0x42, 0xF9, 0xE4, 0x34, 0xFC, 
+0x22, 0xE4, 0xFE, 0xEF, 0x30, 0xE7, 0x04, 0x7C, 0x02, 0x80, 0x02, 0xE4, 0xFC, 0xED, 0x30, 0xE6, 
+0x09, 0xAF, 0x03, 0x12, 0xA3, 0xE8, 0xAE, 0x07, 0x80, 0x02, 0xE4, 0xFE, 0xEC, 0x24, 0x18, 0x2E, 
+0xFF, 0x22, 0xF1, 0xD2, 0xE4, 0xA3, 0xF0, 0x90, 0x93, 0x3A, 0xE0, 0xFD, 0xC3, 0x94, 0x04, 0x50, 
+0x25, 0x90, 0x93, 0x39, 0xE0, 0x24, 0x10, 0x12, 0x6E, 0x9F, 0xFE, 0x12, 0x6B, 0x7F, 0x90, 0x93, 
+0x3A, 0xE0, 0x24, 0x7C, 0xF5, 0x82, 0xE4, 0x34, 0x90, 0xF5, 0x83, 0xE0, 0x6F, 0x60, 0x03, 0x7F, 
+0x00, 0x22, 0x71, 0x9D, 0x80, 0xD1, 0x7F, 0x01, 0x22, 0x90, 0x8D, 0xFB, 0x12, 0x8F, 0xB7, 0x30, 
+0xE0, 0x33, 0x90, 0x90, 0xCE, 0x12, 0x48, 0xF4, 0xEC, 0x4D, 0x4E, 0x4F, 0x60, 0x13, 0x90, 0x93, 
+0x0E, 0x12, 0x49, 0x00, 0xD3, 0x12, 0x48, 0xE3, 0x40, 0x07, 0xB1, 0x06, 0x90, 0x90, 0xD2, 0x80, 
+0x05, 0xB1, 0x06, 0x90, 0x90, 0xCA, 0x12, 0x49, 0x00, 0x12, 0x48, 0x7A, 0x90, 0x93, 0x4B, 0x12, 
+0x08, 0x6D, 0x12, 0x50, 0x31, 0x22, 0xE4, 0x7F, 0xE8, 0x7E, 0x03, 0xFD, 0xFC, 0x22, 0xD3, 0x10, 
+0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x8D, 0xF6, 0xE0, 0xFF, 0x70, 0x06, 0xA3, 0xE0, 0x64, 0x09, 
+0x60, 0x0A, 0xEF, 0x14, 0xFF, 0x90, 0x8D, 0xF7, 0xE0, 0xB5, 0x07, 0x04, 0x7F, 0x01, 0x80, 0x02, 
+0x7F, 0x00, 0xEF, 0x60, 0x09, 0x90, 0x01, 0xC1, 0xE0, 0x44, 0x02, 0xF0, 0x80, 0x2A, 0xC0, 0x01, 
+0x90, 0x8D, 0xF7, 0xE0, 0x12, 0x95, 0x83, 0xA8, 0x01, 0xFC, 0x7D, 0x01, 0xD0, 0x01, 0x7E, 0x00, 
+0x7F, 0x0F, 0x12, 0x06, 0x63, 0x90, 0x8D, 0xF7, 0x12, 0x77, 0xCB, 0xB4, 0x0A, 0x02, 0x7F, 0x01, 
+0xEF, 0x60, 0x05, 0xE4, 0x90, 0x8D, 0xF7, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xE4, 0xFD, 0xFC, 
+0x90, 0x93, 0x1E, 0xB1, 0xF6, 0xAB, 0x05, 0x74, 0x01, 0x2B, 0x12, 0x5E, 0xE1, 0xE0, 0xFE, 0x74, 
+0x00, 0x2B, 0x12, 0x5D, 0x91, 0x12, 0x60, 0x10, 0x90, 0x90, 0x70, 0xF0, 0xA3, 0xEF, 0xF0, 0x74, 
+0x03, 0x2B, 0xD1, 0xAC, 0xFE, 0x74, 0x02, 0x2B, 0xD1, 0x9A, 0x24, 0x00, 0xFF, 0xEA, 0x3E, 0x90, 
+0x90, 0x72, 0xF0, 0xA3, 0xEF, 0xF0, 0x74, 0x05, 0x2B, 0xD1, 0xA3, 0xFE, 0x74, 0x04, 0x2B, 0xD1, 
+0xCB, 0xE0, 0x24, 0x00, 0xFF, 0xEA, 0x3E, 0x90, 0x90, 0x74, 0xF0, 0xA3, 0xEF, 0xF0, 0x74, 0x07, 
+0x2B, 0xD1, 0xBE, 0xFE, 0x74, 0x06, 0x2B, 0xB1, 0xED, 0x24, 0x00, 0xFF, 0xEA, 0x3E, 0x90, 0x90, 
+0x76, 0xF0, 0xA3, 0xEF, 0xF0, 0x74, 0x09, 0x2B, 0x71, 0x8A, 0xFE, 0x74, 0x08, 0x2B, 0xD1, 0xB5, 
+0x24, 0x00, 0xFF, 0xEC, 0x3E, 0x90, 0x90, 0x78, 0xF0, 0xA3, 0xEF, 0xF0, 0x22, 0xF5, 0x82, 0xE4, 
+0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x22, 0xE0, 0xFF, 0x12, 0x7F, 0xD6, 0x7C, 0x00, 0xAD, 0x07, 0x22, 
+0xE4, 0xFD, 0xFC, 0xEF, 0x60, 0x3D, 0x90, 0x93, 0x18, 0xB1, 0xF6, 0x12, 0x5F, 0xE4, 0xF1, 0x65, 
+0x90, 0x93, 0x3C, 0x12, 0x57, 0x05, 0x75, 0x43, 0x40, 0x7B, 0x01, 0x7A, 0x8F, 0x79, 0x96, 0x12, 
+0x34, 0x62, 0xE4, 0xFD, 0x7F, 0x03, 0x12, 0x30, 0x0A, 0x90, 0x93, 0x19, 0xE0, 0xFE, 0xE4, 0x78, 
+0x03, 0xCE, 0xC3, 0x13, 0xCE, 0x13, 0xD8, 0xF9, 0xFF, 0x12, 0x39, 0x00, 0x7D, 0x01, 0x7F, 0x03, 
+0x12, 0x30, 0x0A, 0x22, 0x12, 0x7F, 0xD1, 0x74, 0x00, 0x2F, 0x12, 0x5D, 0x91, 0xE0, 0x90, 0x94, 
+0x4C, 0xF0, 0x74, 0x01, 0x2F, 0x12, 0x5E, 0xE1, 0xE0, 0x90, 0x94, 0x4D, 0xF0, 0x74, 0x02, 0x2F, 
+0xD1, 0x9A, 0x90, 0x94, 0x4E, 0xF0, 0x74, 0x03, 0x2F, 0xD1, 0xAC, 0x90, 0x94, 0x4F, 0xD1, 0xC7, 
+0xE0, 0x90, 0x94, 0x50, 0xF0, 0x74, 0x05, 0x2F, 0xD1, 0xA3, 0x90, 0x94, 0x51, 0xF0, 0x74, 0x06, 
+0x2F, 0xB1, 0xED, 0x90, 0x94, 0x52, 0xF0, 0x74, 0x07, 0x2F, 0xD1, 0xBE, 0x90, 0x94, 0x53, 0xF0, 
+0x74, 0x08, 0x2F, 0xD1, 0xB5, 0x90, 0x94, 0x54, 0xF0, 0x22, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 
+0x83, 0xE0, 0x22, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x22, 0xF5, 0x82, 0xE4, 0x34, 
+0xFC, 0xF5, 0x83, 0xE0, 0x22, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x22, 0xF5, 0x82, 
+0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0x22, 0xF0, 0x74, 0x04, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 
+0xF5, 0x83, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x02, 0x09, 0xE0, 0xFD, 0x12, 
+0x7F, 0xDE, 0xFE, 0x90, 0x8D, 0xFB, 0x12, 0x7B, 0x79, 0x54, 0x04, 0xFC, 0xEF, 0x54, 0xFB, 0x4C, 
+0xFF, 0x90, 0x8D, 0xFB, 0xF1, 0xDB, 0x12, 0x76, 0xE5, 0xFF, 0xED, 0x2F, 0x90, 0x8D, 0xFC, 0x12, 
+0x77, 0xBA, 0xFF, 0xAE, 0x05, 0xED, 0x2F, 0x90, 0x8D, 0xFD, 0xF0, 0x90, 0x8D, 0xFB, 0xE0, 0xFF, 
+0x20, 0xE0, 0x08, 0x13, 0x13, 0x13, 0x54, 0x1F, 0x30, 0xE0, 0x09, 0x90, 0x06, 0x31, 0xE0, 0x44, 
+0x40, 0xF0, 0xD1, 0x44, 0x90, 0x8D, 0xFB, 0xE0, 0xFF, 0x30, 0xE0, 0x34, 0x90, 0x06, 0x32, 0xE0, 
+0x44, 0x01, 0xF0, 0x90, 0x06, 0x09, 0xE0, 0x54, 0xFE, 0x12, 0xA8, 0x4B, 0xEF, 0x13, 0x13, 0x54, 
+0x3F, 0x30, 0xE0, 0x08, 0xF1, 0xB9, 0x90, 0x94, 0x64, 0x74, 0x01, 0xF0, 0x7D, 0x08, 0xE4, 0xFF, 
+0x12, 0x78, 0x7A, 0x90, 0x93, 0x4B, 0x12, 0x08, 0x79, 0x00, 0x00, 0x27, 0x10, 0x12, 0x50, 0x31, 
+0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0x93, 0x3C, 0x02, 0x49, 0x21, 0xE0, 0xFF, 0x13, 0x13, 0x54, 
+0x3F, 0x22, 0x90, 0x93, 0x24, 0xF1, 0x6B, 0x30, 0xE0, 0x0E, 0x7B, 0x00, 0x7A, 0x00, 0x79, 0x00, 
+0x12, 0xA9, 0xB4, 0x04, 0xF0, 0x02, 0x55, 0xF3, 0x02, 0x57, 0x23, 0x7F, 0x58, 0x7E, 0x0C, 0x02, 
+0x65, 0xDA, 0x7F, 0x14, 0x7E, 0x00, 0x02, 0x3D, 0x7A, 0x90, 0x02, 0x86, 0xE0, 0x54, 0xFB, 0xF0, 
+0x22, 0x90, 0x8E, 0xC0, 0xE0, 0xC4, 0x54, 0x0F, 0x22, 0xF5, 0x82, 0xE4, 0x34, 0x91, 0xF5, 0x83, 
+0x22, 0xE4, 0x90, 0x93, 0x4F, 0xF0, 0x7F, 0x04, 0x22, 0x90, 0x02, 0x86, 0xE0, 0x44, 0x04, 0xF0, 
+0x22, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0x93, 0x3C, 0x22, 0x12, 0x4C, 0xF1, 0xE4, 0xFD, 0xFF, 0x02, 
+0x54, 0x6C, 0x90, 0x93, 0x38, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x22, 0xF0, 0xEE, 0x54, 0x08, 0xFE, 
+0xEF, 0x54, 0xF7, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x12, 0x7F, 0xEF, 0xD0, 0xD0, 
+0x92, 0xAF, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0xC0, 0x07, 0xC0, 0x05, 0x90, 0x94, 
+0xEB, 0x12, 0x48, 0xF4, 0x90, 0xAA, 0x9C, 0x12, 0x08, 0x6D, 0xD0, 0x05, 0xD0, 0x07, 0x12, 0x32, 
+0x34, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0xE4, 0xFF, 0xEF, 
+0x12, 0x51, 0x47, 0xE4, 0xF0, 0x0F, 0xEF, 0xB4, 0x08, 0xF5, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 
+0x01, 0x53, 0xE4, 0xF0, 0xFF, 0xEF, 0x12, 0x51, 0x47, 0xE4, 0xF0, 0x0F, 0xEF, 0xB4, 0x08, 0xF5, 
+0x22, 0x90, 0x8E, 0xC0, 0xE0, 0xFF, 0xC4, 0x54, 0x0F, 0x30, 0xE0, 0x05, 0x11, 0x2F, 0x12, 0x7A, 
+0x95, 0x22, 0x90, 0x93, 0x3C, 0xEC, 0xF0, 0xA3, 0xED, 0xF0, 0x90, 0x93, 0x3A, 0xF1, 0x70, 0x90, 
+0x93, 0x60, 0xF0, 0xEF, 0x24, 0x24, 0xFF, 0xE4, 0x3E, 0xFE, 0xC0, 0x06, 0x51, 0xC6, 0xD0, 0x06, 
+0xE4, 0xFB, 0xFA, 0x51, 0x96, 0x4E, 0x60, 0x3E, 0xE0, 0x24, 0x01, 0xFF, 0x90, 0x93, 0x61, 0x12, 
+0x6D, 0x63, 0x90, 0x93, 0x3F, 0x51, 0xAF, 0x90, 0x93, 0x3F, 0x51, 0xA5, 0xFE, 0xC3, 0x9F, 0x50, 
+0x25, 0x90, 0x93, 0x62, 0xE0, 0x24, 0x02, 0xFD, 0x90, 0x93, 0x61, 0xE0, 0x34, 0x00, 0xFC, 0xEE, 
+0x7E, 0x00, 0x2D, 0x12, 0x6B, 0x79, 0x90, 0x93, 0x3E, 0xE0, 0x24, 0x40, 0xF5, 0x82, 0xE4, 0x34, 
+0x93, 0x12, 0x7F, 0xC6, 0x80, 0xD1, 0x51, 0xB7, 0xC0, 0x06, 0x51, 0xC6, 0xD0, 0x06, 0x7B, 0x03, 
+0x51, 0x93, 0x90, 0x93, 0x3B, 0xE0, 0x24, 0x22, 0x51, 0xBD, 0x90, 0x93, 0x61, 0x12, 0x6F, 0xE8, 
+0xEF, 0x20, 0xE4, 0x02, 0x21, 0x88, 0x90, 0x93, 0x60, 0xE0, 0x04, 0xF0, 0x51, 0xB7, 0xC0, 0x06, 
+0x51, 0xC6, 0xD0, 0x06, 0x7B, 0x30, 0x51, 0x93, 0x4E, 0x60, 0x45, 0xE0, 0x24, 0x08, 0xFF, 0x90, 
+0x93, 0x61, 0x12, 0x6D, 0x63, 0x51, 0xAC, 0x51, 0xA2, 0xC3, 0x9F, 0x50, 0x33, 0x90, 0x93, 0x62, 
+0xE0, 0x24, 0x0D, 0xFF, 0x90, 0x93, 0x61, 0x12, 0x6D, 0x63, 0x90, 0x93, 0x63, 0xEF, 0xF0, 0xBF, 
+0x02, 0x09, 0x90, 0x93, 0x60, 0xE0, 0x24, 0x20, 0xF0, 0x80, 0x0E, 0x90, 0x93, 0x63, 0xE0, 0xB4, 
+0x04, 0x07, 0x90, 0x93, 0x60, 0xE0, 0x24, 0x40, 0xF0, 0x51, 0xE4, 0x12, 0x7F, 0xCA, 0x80, 0xC7, 
+0x51, 0xB7, 0xC0, 0x06, 0x51, 0xC6, 0xD0, 0x06, 0x7B, 0xDD, 0x7A, 0x00, 0x7D, 0x01, 0x51, 0x97, 
+0x4E, 0x60, 0x4A, 0xE0, 0x24, 0x0C, 0xFF, 0x90, 0x93, 0x61, 0x12, 0x6D, 0x63, 0x51, 0xAC, 0x51, 
+0xA2, 0xC3, 0x9F, 0x50, 0x38, 0x90, 0x93, 0x62, 0xE0, 0x24, 0x11, 0xFF, 0x90, 0x93, 0x61, 0x12, 
+0x6D, 0x63, 0x90, 0x93, 0x63, 0xEF, 0xF0, 0xBF, 0x02, 0x09, 0x90, 0x93, 0x60, 0xE0, 0x24, 0x02, 
+0xF0, 0x80, 0x0E, 0x90, 0x93, 0x63, 0xE0, 0xB4, 0x04, 0x07, 0x90, 0x93, 0x60, 0xE0, 0x24, 0x04, 
+0xF0, 0x51, 0xE4, 0x12, 0x7F, 0xCA, 0x80, 0xC7, 0xE4, 0x90, 0x93, 0x60, 0xF0, 0x90, 0x90, 0xC6, 
+0xE0, 0x90, 0x04, 0xFD, 0x51, 0xB0, 0x90, 0x90, 0xC6, 0x51, 0xA5, 0xFE, 0xC3, 0x9F, 0x50, 0x5F, 
+0xF1, 0x8E, 0xF5, 0x83, 0xE0, 0xFF, 0x90, 0x93, 0x3F, 0xE0, 0xFE, 0x6F, 0x70, 0x4C, 0x90, 0x04, 
+0xFC, 0xE0, 0x04, 0xF0, 0x90, 0x93, 0x3E, 0xE0, 0x24, 0xE6, 0xF5, 0x82, 0xE4, 0x34, 0x90, 0xF5, 
+0x83, 0xE0, 0xFF, 0x90, 0x93, 0x60, 0xE0, 0xFD, 0x4F, 0x60, 0x04, 0xED, 0x5F, 0x60, 0x2B, 0xEE, 
+0xFF, 0x7E, 0x00, 0xC0, 0x06, 0xC0, 0x07, 0x90, 0x93, 0x3E, 0xE0, 0x12, 0xA9, 0x81, 0x78, 0x40, 
+0x7C, 0x93, 0x7D, 0x01, 0xD0, 0x07, 0xD0, 0x06, 0x12, 0x4A, 0xD6, 0xEF, 0x70, 0x0C, 0x90, 0x01, 
+0xC7, 0x74, 0x55, 0xF0, 0x7F, 0x01, 0x71, 0x36, 0x11, 0x41, 0x12, 0x7F, 0xCA, 0x80, 0x97, 0x22, 
+0x90, 0x93, 0x65, 0x91, 0xBA, 0xA3, 0xEA, 0xF0, 0xA3, 0xEB, 0xF0, 0xC3, 0x90, 0x93, 0x6B, 0xE0, 
+0x94, 0x01, 0x90, 0x93, 0x6A, 0xE0, 0x94, 0x00, 0x50, 0x02, 0x80, 0x73, 0xE4, 0x90, 0x93, 0x6E, 
+0xF0, 0xA3, 0xF0, 0x51, 0xDB, 0xE4, 0xFD, 0x12, 0x6B, 0x7F, 0x90, 0x93, 0x68, 0xE0, 0x70, 0x03, 
+0xA3, 0xE0, 0x6F, 0x70, 0x17, 0x90, 0x93, 0x66, 0xE0, 0x24, 0x02, 0xB1, 0x4C, 0xFE, 0x90, 0x93, 
+0x67, 0xE0, 0xFD, 0xF1, 0xCA, 0xBF, 0x01, 0x02, 0x41, 0xDB, 0x80, 0x00, 0x90, 0x93, 0x66, 0xE0, 
+0x24, 0x01, 0xFF, 0x90, 0x93, 0x65, 0x12, 0x6D, 0x63, 0x7E, 0x00, 0x90, 0x93, 0x6C, 0xEE, 0xF0, 
+0xA3, 0xEF, 0xF0, 0x24, 0x02, 0xFF, 0xEE, 0x33, 0xFE, 0x90, 0x93, 0x65, 0x8F, 0xF0, 0x12, 0x08, 
+0xD6, 0x90, 0x93, 0x6E, 0xEE, 0x8F, 0xF0, 0x12, 0x08, 0xD6, 0x90, 0x93, 0x6A, 0xE0, 0xFE, 0xA3, 
+0xE0, 0xFF, 0xC3, 0x90, 0x93, 0x6F, 0xE0, 0x9F, 0x90, 0x93, 0x6E, 0xE0, 0x9E, 0x40, 0x94, 0xE4, 
+0xFE, 0xFF, 0x22, 0x7A, 0x00, 0xE4, 0xFD, 0x51, 0x00, 0x90, 0x93, 0x61, 0xEE, 0xF0, 0xA3, 0xEF, 
+0xF0, 0x22, 0x90, 0x93, 0x64, 0xE0, 0xFF, 0x90, 0x93, 0x3E, 0xE0, 0x22, 0x90, 0x93, 0x64, 0xEF, 
+0xF0, 0xE4, 0x90, 0x93, 0x3E, 0xF0, 0x22, 0x90, 0x93, 0x3B, 0xE0, 0x24, 0x24, 0xFF, 0x90, 0x93, 
+0x3A, 0xE0, 0x34, 0x00, 0xFE, 0x22, 0x90, 0x93, 0x3D, 0xE0, 0x24, 0xDC, 0xFE, 0x90, 0x93, 0x3C, 
+0xE0, 0x34, 0xFF, 0x90, 0x93, 0x6A, 0xF0, 0xA3, 0xCE, 0xF0, 0x22, 0x90, 0x93, 0x65, 0xE0, 0xFE, 
+0xA3, 0xE0, 0xFF, 0x22, 0x90, 0x93, 0x61, 0xE4, 0x75, 0xF0, 0x04, 0x02, 0x08, 0xD6, 0x51, 0xF2, 
+0x01, 0x41, 0x90, 0x8E, 0xC0, 0x71, 0xFC, 0x30, 0xE0, 0x02, 0x71, 0x16, 0x22, 0x12, 0x87, 0xD2, 
+0x90, 0x94, 0x47, 0xE0, 0x64, 0x01, 0xF0, 0xE0, 0x24, 0xFD, 0x90, 0x01, 0xC4, 0xF0, 0x74, 0x8A, 
+0xA3, 0xF0, 0x91, 0xAE, 0x01, 0x52, 0x71, 0x78, 0xE4, 0x90, 0x93, 0x1E, 0x12, 0x4F, 0x6D, 0x90, 
+0x90, 0x70, 0x12, 0x4F, 0x6B, 0xA3, 0x12, 0x4F, 0x6B, 0x90, 0x90, 0x82, 0xF0, 0xA3, 0xF0, 0x90, 
+0x90, 0xC4, 0xF0, 0xA3, 0xF0, 0x22, 0x90, 0x95, 0x47, 0xEF, 0xF0, 0x90, 0x8D, 0x06, 0xE0, 0x64, 
+0x02, 0x70, 0x23, 0x90, 0x95, 0x47, 0xE0, 0xFD, 0x64, 0x01, 0x70, 0x29, 0x12, 0x6F, 0x95, 0x90, 
+0x8E, 0xC4, 0xE0, 0x12, 0x6F, 0xF0, 0x30, 0xE0, 0x09, 0x90, 0x01, 0x4D, 0xE0, 0x64, 0x80, 0xF0, 
+0x80, 0x13, 0xAF, 0x05, 0x80, 0x0C, 0x90, 0x06, 0x90, 0xE0, 0x44, 0x01, 0xF0, 0x90, 0x95, 0x47, 
+0xE0, 0xFF, 0x12, 0x4E, 0x17, 0x71, 0x8A, 0xF0, 0x90, 0x8E, 0xC0, 0xE0, 0x54, 0xBF, 0xF0, 0x22, 
+0x90, 0x01, 0xC7, 0x74, 0x10, 0xF0, 0x7F, 0x01, 0x71, 0x36, 0x90, 0x93, 0x28, 0xE0, 0x54, 0xFE, 
+0x22, 0x90, 0x93, 0x28, 0xE0, 0x30, 0xE0, 0x3C, 0x90, 0x93, 0x2D, 0xE0, 0xFD, 0x60, 0x35, 0xF1, 
+0xA2, 0x80, 0x05, 0xC3, 0x33, 0xCE, 0x33, 0xCE, 0xD8, 0xF9, 0xFF, 0x90, 0x04, 0xE0, 0xE0, 0xFB, 
+0xEF, 0x5B, 0x60, 0x0B, 0xE4, 0x90, 0x93, 0x2D, 0xF0, 0x90, 0x93, 0x2F, 0x04, 0xF0, 0x22, 0x90, 
+0x93, 0x2A, 0xE0, 0xD3, 0x9D, 0x50, 0x04, 0x71, 0x80, 0xF0, 0x22, 0x12, 0x57, 0x23, 0x90, 0x93, 
+0x2D, 0xE0, 0x04, 0xF0, 0x22, 0x90, 0x8E, 0x11, 0x71, 0xFC, 0x30, 0xE0, 0x1B, 0xEF, 0x54, 0xBF, 
+0x91, 0x33, 0x30, 0xE0, 0x06, 0xE0, 0x44, 0x01, 0xF0, 0x80, 0x0A, 0xE0, 0x54, 0xFE, 0xF0, 0x12, 
+0x77, 0xEE, 0x74, 0x04, 0xF0, 0x12, 0x77, 0xC1, 0xE4, 0xFF, 0x80, 0x95, 0xE0, 0xFF, 0xC4, 0x13, 
+0x13, 0x54, 0x03, 0x22, 0x90, 0x8E, 0x11, 0xE0, 0xFF, 0x12, 0x6F, 0xF0, 0x30, 0xE0, 0x20, 0xEF, 
+0x54, 0x7F, 0x91, 0x33, 0x30, 0xE1, 0x06, 0xE0, 0x44, 0x02, 0xF0, 0x80, 0x09, 0xE0, 0x54, 0xFD, 
+0xF0, 0x12, 0x77, 0xEE, 0x04, 0xF0, 0x90, 0x8E, 0x15, 0xE0, 0x60, 0x03, 0x12, 0x77, 0xC1, 0x7F, 
+0x01, 0x61, 0x91, 0xF0, 0x90, 0x04, 0xE0, 0xE0, 0x90, 0x8E, 0x12, 0x22, 0x12, 0x87, 0x65, 0x12, 
+0xA7, 0x1C, 0x12, 0x76, 0xD9, 0x12, 0x7F, 0xDE, 0xFE, 0x71, 0x8A, 0x4E, 0xF0, 0xEF, 0xC3, 0x13, 
+0x30, 0xE0, 0x20, 0x12, 0x76, 0xE7, 0x90, 0x93, 0x29, 0x12, 0x77, 0xBA, 0x90, 0x93, 0x2A, 0xF0, 
+0x12, 0x06, 0x89, 0x54, 0x04, 0xFF, 0x90, 0x93, 0x28, 0xE0, 0x54, 0xFB, 0x12, 0x77, 0xD2, 0x90, 
+0x93, 0x2B, 0xF0, 0x22, 0x91, 0xB7, 0xE4, 0xA3, 0xF0, 0xB1, 0x09, 0x50, 0x1A, 0x91, 0xAE, 0xB1, 
+0x12, 0xE0, 0x24, 0xA4, 0xF5, 0x82, 0xE4, 0x34, 0x90, 0xF5, 0x83, 0xE0, 0xB5, 0x07, 0x1C, 0x90, 
+0x93, 0x3B, 0xE0, 0x04, 0xF0, 0x80, 0xE2, 0x90, 0x06, 0x32, 0xE0, 0x44, 0x80, 0xF0, 0x90, 0x01, 
+0xC7, 0x74, 0x30, 0xF0, 0x7F, 0x01, 0x71, 0x36, 0x7F, 0x01, 0x22, 0x7F, 0x00, 0x22, 0x90, 0x93, 
+0x38, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x22, 0x90, 0x93, 0x38, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0xA3, 
+0xED, 0xF0, 0x22, 0x91, 0xB7, 0x90, 0x90, 0x76, 0xE0, 0x70, 0x02, 0xA3, 0xE0, 0x60, 0x26, 0xE4, 
+0x90, 0x93, 0x3B, 0xF0, 0xB1, 0x09, 0x50, 0x20, 0x91, 0xAE, 0xB1, 0x12, 0xE0, 0x24, 0x84, 0xF5, 
+0x82, 0xE4, 0x34, 0x90, 0xF5, 0x83, 0xE0, 0x6F, 0x60, 0x03, 0x7F, 0x00, 0x22, 0x90, 0x93, 0x3B, 
+0xE0, 0x04, 0xF0, 0x80, 0xDF, 0x7F, 0x00, 0x22, 0x90, 0x06, 0x32, 0xE0, 0x44, 0x40, 0xF0, 0xE4, 
+0x90, 0x90, 0x82, 0xF0, 0xA3, 0xF0, 0x7F, 0x01, 0x22, 0x90, 0x93, 0x3B, 0xE0, 0xFD, 0xC3, 0x94, 
+0x02, 0x22, 0xED, 0x24, 0x1C, 0xFD, 0x12, 0x6B, 0x7F, 0x90, 0x93, 0x3B, 0x22, 0x90, 0x93, 0x65, 
+0x91, 0xBA, 0x2F, 0xFF, 0xE4, 0x3E, 0xCF, 0x24, 0x06, 0xCF, 0x12, 0x6D, 0x64, 0xBF, 0x86, 0x19, 
+0x90, 0x93, 0x67, 0xE0, 0xFF, 0x90, 0x93, 0x66, 0xE0, 0x2F, 0xB1, 0x4C, 0xCF, 0x24, 0x07, 0xCF, 
+0x12, 0x6D, 0x64, 0xBF, 0xDD, 0x03, 0x7F, 0x01, 0x22, 0x7F, 0x00, 0x22, 0xFF, 0x90, 0x93, 0x65, 
+0xE0, 0x34, 0x00, 0x22, 0x12, 0xA3, 0x40, 0xAD, 0x07, 0x90, 0x01, 0xC4, 0x74, 0x54, 0xF0, 0x74, 
+0x8D, 0xA3, 0xF0, 0xED, 0x64, 0x01, 0x60, 0x1D, 0x12, 0x6F, 0x95, 0xED, 0xB4, 0x02, 0x08, 0x90, 
+0x01, 0xC7, 0x74, 0x40, 0xF0, 0x80, 0x0A, 0xED, 0xB4, 0x04, 0x06, 0x90, 0x01, 0xC7, 0x74, 0x41, 
+0xF0, 0x7F, 0x01, 0x61, 0x36, 0xD1, 0xC0, 0x90, 0x02, 0x87, 0xE0, 0x70, 0xF8, 0x90, 0x06, 0x90, 
+0xE0, 0x44, 0x02, 0xF0, 0x74, 0x54, 0x04, 0x90, 0x01, 0xC4, 0xF0, 0x74, 0x8D, 0xA3, 0xF0, 0x22, 
+0x90, 0x93, 0x28, 0xE0, 0x30, 0xE0, 0x6B, 0x90, 0x93, 0x2C, 0xE0, 0x04, 0xF0, 0x90, 0x93, 0x2F, 
+0xE0, 0x64, 0x01, 0x70, 0x20, 0x90, 0x93, 0x28, 0xE0, 0x13, 0x13, 0x54, 0x3F, 0x30, 0xE0, 0x15, 
+0x90, 0x93, 0x2E, 0xE0, 0x70, 0x0F, 0x90, 0x93, 0x2B, 0xE0, 0xFF, 0xA3, 0xE0, 0xC3, 0x9F, 0x40, 
+0x04, 0x71, 0x80, 0xF0, 0x22, 0x90, 0x93, 0x2C, 0xE0, 0xFF, 0x90, 0x93, 0x29, 0xE0, 0xD3, 0x9F, 
+0x50, 0x30, 0x90, 0x06, 0x92, 0xE0, 0x20, 0xE2, 0x1A, 0x90, 0x93, 0x2E, 0xE0, 0x70, 0x14, 0x7D, 
+0x08, 0xFF, 0x12, 0x57, 0x27, 0x90, 0x93, 0x2D, 0xE0, 0x04, 0xF0, 0x90, 0x93, 0x27, 0xE0, 0x04, 
+0xF0, 0x80, 0x06, 0x90, 0x06, 0x92, 0x74, 0x04, 0xF0, 0xE4, 0x90, 0x93, 0x2C, 0xF0, 0x90, 0x93, 
+0x2E, 0xF0, 0x22, 0x90, 0x8E, 0x15, 0xE0, 0x60, 0x46, 0x90, 0x8E, 0x11, 0xE0, 0x30, 0xE0, 0x17, 
+0x90, 0x8E, 0x2C, 0xE0, 0x04, 0xF1, 0xD7, 0xCE, 0xC3, 0x13, 0xCE, 0x13, 0xD8, 0xF9, 0xFF, 0x90, 
+0x8E, 0x4C, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0xF1, 0xB4, 0x30, 0xE0, 0x0C, 0x90, 0x01, 0x3B, 0xE0, 
+0x30, 0xE4, 0x05, 0x12, 0x79, 0x5B, 0xF1, 0x77, 0x90, 0x95, 0x45, 0xE0, 0x04, 0xF0, 0xE0, 0xC3, 
+0x94, 0x80, 0x40, 0x0B, 0x90, 0x01, 0x98, 0xE0, 0x54, 0xFE, 0xF0, 0xE0, 0x44, 0x01, 0xF0, 0xB1, 
+0xA0, 0x12, 0x73, 0xA0, 0xE4, 0x90, 0x93, 0x27, 0xF0, 0xF1, 0xAA, 0x30, 0xE0, 0x51, 0x90, 0x90, 
+0x70, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x7C, 0x00, 0x7D, 0x64, 0x12, 0x07, 0x15, 0x90, 0x90, 0xC4, 
+0xE0, 0x6E, 0x70, 0x03, 0xA3, 0xE0, 0x6F, 0x60, 0x0A, 0x90, 0x90, 0xC4, 0xE4, 0x75, 0xF0, 0x01, 
+0x02, 0x08, 0xD6, 0x90, 0x90, 0x74, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x90, 0x90, 0x82, 0xE0, 0xB5, 
+0x06, 0x13, 0xA3, 0xE0, 0xB5, 0x07, 0x0E, 0xEF, 0x4E, 0x60, 0x0A, 0x90, 0x01, 0xC7, 0x74, 0x31, 
+0xF0, 0x7F, 0x01, 0x61, 0x36, 0x12, 0x5E, 0xF9, 0xE4, 0x90, 0x90, 0xC4, 0xF0, 0xA3, 0xF0, 0x22, 
+0xF1, 0x97, 0x12, 0x7C, 0x9B, 0x90, 0x93, 0x3C, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0x02, 0x87, 0xE0, 
+0xF9, 0x90, 0x8E, 0xC0, 0xE0, 0x30, 0xE0, 0x70, 0xEC, 0xC3, 0x99, 0x50, 0x6B, 0x90, 0x93, 0x3C, 
+0xE0, 0xFA, 0xA3, 0xE0, 0xFB, 0xF1, 0x7E, 0xAD, 0x07, 0x12, 0x5F, 0xFA, 0x54, 0x3F, 0x90, 0x93, 
+0x3E, 0x12, 0xA8, 0xFB, 0xE0, 0x54, 0x03, 0xFB, 0xEF, 0x24, 0x18, 0xFF, 0xE4, 0x33, 0xCF, 0x2B, 
+0xCF, 0x3A, 0x90, 0x93, 0x3E, 0x8F, 0xF0, 0x12, 0x08, 0xD6, 0x90, 0x93, 0x3E, 0xF1, 0x49, 0x90, 
+0x93, 0x3E, 0xEE, 0x12, 0x87, 0xC1, 0xEE, 0x8F, 0xF0, 0xF1, 0x86, 0xFE, 0xA3, 0xE0, 0xFF, 0xD3, 
+0x90, 0x93, 0x3D, 0xE0, 0x9F, 0x90, 0x93, 0x3C, 0xE0, 0x9E, 0x40, 0x13, 0x90, 0x8D, 0xF9, 0xF1, 
+0xBF, 0xFE, 0xC3, 0x90, 0x93, 0x3D, 0xE0, 0x9F, 0xF0, 0x90, 0x93, 0x3C, 0xE0, 0x9E, 0xF0, 0x90, 
+0x93, 0x3C, 0x12, 0xA2, 0xF8, 0x0C, 0x80, 0x90, 0x22, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x7D, 0x07, 
+0xEF, 0x5D, 0xC3, 0x60, 0x0A, 0xF1, 0x63, 0x24, 0x08, 0xFF, 0xE4, 0x3E, 0xFE, 0x80, 0x03, 0xF1, 
+0x63, 0xFF, 0x22, 0x74, 0xFF, 0x9D, 0xFD, 0x74, 0xFF, 0x94, 0x00, 0x5E, 0xFE, 0xED, 0x5F, 0x22, 
+0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0xE4, 0x22, 0x7D, 0x01, 0x7F, 0x02, 0x02, 0x79, 0x5F, 0xEA, 0x90, 
+0xFD, 0x11, 0xF0, 0xAF, 0x03, 0x22, 0x12, 0x08, 0xD6, 0x90, 0x8D, 0xF8, 0xE0, 0x22, 0x74, 0xD6, 
+0x2E, 0xF5, 0x82, 0xE4, 0x34, 0x90, 0x22, 0x90, 0x01, 0x1F, 0xE0, 0xFE, 0x90, 0x01, 0x1E, 0x22, 
+0xE0, 0xFF, 0x74, 0x01, 0x7E, 0x00, 0xA8, 0x07, 0x08, 0x22, 0x90, 0x8E, 0xC0, 0xE0, 0xC4, 0x13, 
+0x13, 0x54, 0x03, 0x22, 0x90, 0x8E, 0x12, 0xE0, 0xFF, 0x13, 0x13, 0x13, 0x54, 0x1F, 0x22, 0xE0, 
+0x24, 0x01, 0xFF, 0x90, 0x8D, 0xF8, 0xE0, 0x34, 0x00, 0x22, 0xED, 0x14, 0x60, 0x06, 0x04, 0x70, 
+0x03, 0x7F, 0x01, 0x22, 0x7F, 0x01, 0x22, 0xF0, 0x90, 0x05, 0x62, 0xE0, 0xFE, 0x90, 0x05, 0x61, 
+0xE0, 0xFD, 0xED, 0x78, 0x02, 0x22, 0x90, 0x02, 0x09, 0xE0, 0xF5, 0x51, 0x12, 0x06, 0x89, 0x25, 
+0x51, 0x90, 0x8D, 0x07, 0x12, 0x76, 0xE6, 0x25, 0x51, 0x90, 0x8D, 0x08, 0x12, 0x77, 0xBA, 0x25, 
+0x51, 0x90, 0x8D, 0x09, 0x12, 0x77, 0xD3, 0x25, 0x51, 0x90, 0x8D, 0x0A, 0x11, 0x25, 0x25, 0x51, 
+0x90, 0x8D, 0x0B, 0x51, 0x08, 0x25, 0x51, 0x90, 0x8D, 0x0C, 0xF0, 0x12, 0x76, 0xDF, 0x25, 0x51, 
+0x90, 0x8D, 0x0D, 0xF0, 0x22, 0xF0, 0x90, 0x00, 0x04, 0x02, 0x06, 0xA2, 0x90, 0x94, 0xB1, 0x12, 
+0x49, 0x21, 0x12, 0x06, 0x89, 0x90, 0x94, 0xB6, 0x12, 0x76, 0xE6, 0x90, 0x94, 0xB7, 0x11, 0x25, 
+0x90, 0x94, 0xB8, 0x51, 0x08, 0x90, 0x94, 0xB9, 0xF0, 0x12, 0x76, 0xDF, 0x90, 0x94, 0xBA, 0xF0, 
+0x90, 0x00, 0x07, 0x12, 0x06, 0xA2, 0x90, 0x94, 0xBB, 0x12, 0x77, 0xD3, 0x90, 0x94, 0xBE, 0xF0, 
+0xED, 0x70, 0x19, 0xFF, 0x11, 0xF8, 0xE0, 0xB4, 0xFF, 0x06, 0x11, 0xF8, 0xE4, 0xF0, 0x80, 0x07, 
+0x11, 0xF8, 0xE0, 0x04, 0xF0, 0x80, 0x05, 0x0F, 0xEF, 0xB4, 0x06, 0xE8, 0x90, 0x94, 0xB5, 0xE0, 
+0xFF, 0xB4, 0x04, 0x13, 0xA3, 0xE0, 0xFE, 0x11, 0xF2, 0xEE, 0x31, 0x90, 0xFE, 0x11, 0xF2, 0x51, 
+0xA0, 0x90, 0x00, 0x02, 0xE4, 0x80, 0x20, 0xEF, 0xB4, 0x02, 0x1F, 0x90, 0x94, 0xB7, 0x11, 0xF0, 
+0xEF, 0x31, 0x90, 0x44, 0x20, 0x54, 0x7F, 0x11, 0xF1, 0x90, 0x00, 0x01, 0xEF, 0x12, 0x06, 0xE1, 
+0x90, 0x94, 0xB6, 0xE0, 0x90, 0x00, 0x02, 0x12, 0x06, 0xE1, 0x11, 0xF2, 0xE9, 0x24, 0x03, 0x51, 
+0x99, 0x44, 0x20, 0x12, 0x06, 0xCF, 0x90, 0x94, 0xB8, 0x11, 0xF0, 0x90, 0x00, 0x04, 0xEF, 0x12, 
+0x06, 0xE1, 0x90, 0x94, 0xB9, 0xE0, 0x90, 0x00, 0x05, 0x12, 0x06, 0xE1, 0x90, 0x94, 0xBA, 0xE0, 
+0x90, 0x00, 0x06, 0x12, 0x06, 0xE1, 0x90, 0x94, 0xBB, 0xE0, 0x90, 0x00, 0x07, 0x02, 0x06, 0xE1, 
+0xE0, 0xFF, 0x90, 0x94, 0xB1, 0x02, 0x49, 0x18, 0x74, 0xB6, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x94, 
+0xF5, 0x83, 0x22, 0x90, 0x94, 0xF8, 0xED, 0xF0, 0x90, 0x94, 0xF5, 0x12, 0x49, 0x21, 0xE4, 0x90, 
+0x94, 0xF9, 0xF0, 0xA3, 0xF0, 0x12, 0x06, 0x89, 0xFF, 0x12, 0x76, 0xE7, 0xFD, 0x11, 0x26, 0xFB, 
+0x12, 0x84, 0x71, 0x90, 0x94, 0xF9, 0xEF, 0xF0, 0x90, 0x94, 0xF5, 0x12, 0x49, 0x18, 0x11, 0x26, 
+0xFF, 0x12, 0xA3, 0xE8, 0x90, 0x94, 0xFA, 0xEF, 0xF0, 0x90, 0x8F, 0x95, 0xE0, 0x24, 0xFE, 0x60, 
+0x14, 0x24, 0xFE, 0x60, 0x10, 0x14, 0x60, 0x07, 0x14, 0x60, 0x04, 0x24, 0x05, 0x70, 0x40, 0x31, 
+0x98, 0x31, 0xA4, 0x80, 0x0C, 0x31, 0x98, 0x90, 0x8F, 0x95, 0xE0, 0x90, 0x94, 0xB5, 0xF0, 0x11, 
+0x2C, 0x90, 0x94, 0xFA, 0xE0, 0xFF, 0x90, 0x94, 0xF5, 0x12, 0x49, 0x18, 0x90, 0x94, 0xF9, 0xE0, 
+0x7C, 0x00, 0x29, 0xF9, 0xEC, 0x3A, 0xFA, 0xC3, 0xE9, 0x9F, 0xF9, 0xEA, 0x94, 0x00, 0xFA, 0x75, 
+0x40, 0x01, 0x75, 0x41, 0x8F, 0x75, 0x42, 0x8C, 0xA3, 0xE0, 0xF5, 0x43, 0x12, 0x34, 0x62, 0x22, 
+0x12, 0x06, 0xCF, 0x90, 0x94, 0xB7, 0xE0, 0x22, 0x7B, 0x01, 0x7A, 0x8F, 0x79, 0x8C, 0x90, 0x94, 
+0xF8, 0xE0, 0xFD, 0x22, 0x90, 0x94, 0xD7, 0xED, 0xF0, 0x90, 0x94, 0xD4, 0x12, 0x49, 0x21, 0x12, 
+0x77, 0xD4, 0x90, 0x94, 0xDB, 0xF0, 0x90, 0x94, 0xD4, 0x12, 0x57, 0x05, 0x75, 0x43, 0x03, 0x7B, 
+0x01, 0x7A, 0x94, 0x79, 0xD8, 0x12, 0x34, 0x62, 0x90, 0x94, 0xD7, 0xE0, 0x70, 0x2E, 0xFF, 0x31, 
+0xFD, 0xE0, 0xB4, 0xFF, 0x06, 0x31, 0xFD, 0xE4, 0xF0, 0x80, 0x07, 0x31, 0xFD, 0xE0, 0x04, 0xF0, 
+0x80, 0x05, 0x0F, 0xEF, 0xB4, 0x03, 0xE8, 0x75, 0x40, 0x01, 0x75, 0x41, 0x94, 0x75, 0x42, 0xD8, 
+0x75, 0x43, 0x03, 0x90, 0x94, 0xD4, 0x12, 0x49, 0x18, 0x12, 0x34, 0x62, 0x22, 0x74, 0xD8, 0x2F, 
+0xF5, 0x82, 0xE4, 0x34, 0x94, 0xF5, 0x83, 0x22, 0xF0, 0x90, 0x00, 0x05, 0x02, 0x06, 0xA2, 0x51, 
+0x8B, 0x90, 0x93, 0x14, 0x12, 0x76, 0xE6, 0xFF, 0xED, 0x2F, 0x90, 0x93, 0x15, 0x12, 0x77, 0xBA, 
+0xFF, 0xED, 0x2F, 0x90, 0x93, 0x16, 0x12, 0x77, 0xD3, 0xFF, 0xED, 0x2F, 0x90, 0x93, 0x17, 0x11, 
+0x25, 0xFF, 0xED, 0x2F, 0x90, 0x93, 0x18, 0x51, 0x08, 0xFF, 0xED, 0x2F, 0x90, 0x93, 0x19, 0xF0, 
+0x12, 0x76, 0xDF, 0xFF, 0xAE, 0x05, 0xED, 0x2F, 0x90, 0x93, 0x1A, 0xF0, 0x22, 0x51, 0x8B, 0x90, 
+0x93, 0x1B, 0x12, 0x76, 0xE6, 0xFF, 0xED, 0x2F, 0x90, 0x93, 0x1C, 0x12, 0x77, 0xBA, 0xFF, 0xED, 
+0x2F, 0x90, 0x93, 0x1D, 0x12, 0x77, 0xD3, 0xFF, 0xED, 0x2F, 0x90, 0x93, 0x1E, 0x11, 0x25, 0xFF, 
+0xED, 0x2F, 0x90, 0x93, 0x1F, 0x51, 0x08, 0xFF, 0xED, 0x2F, 0x90, 0x93, 0x20, 0xF0, 0x12, 0x76, 
+0xDF, 0xFF, 0xAE, 0x05, 0xED, 0x2F, 0x90, 0x93, 0x21, 0xF0, 0x22, 0x90, 0x02, 0x09, 0xE0, 0xFD, 
+0x12, 0x06, 0x89, 0xFE, 0xAF, 0x05, 0xED, 0x2E, 0x22, 0xF9, 0xE4, 0x3A, 0xFA, 0x02, 0x06, 0x89, 
+0x90, 0x00, 0x01, 0xEE, 0x02, 0x06, 0xE1, 0x90, 0x95, 0x0A, 0xEF, 0xF0, 0xA3, 0x12, 0x49, 0x21, 
+0x90, 0x95, 0x37, 0xE0, 0xFE, 0x04, 0xF0, 0x51, 0xA0, 0x74, 0x00, 0x2F, 0xF9, 0xE4, 0x34, 0xFB, 
+0xFA, 0x7B, 0x01, 0xC0, 0x03, 0xC0, 0x02, 0xC0, 0x01, 0x90, 0x95, 0x0B, 0x12, 0x57, 0x05, 0x75, 
+0x43, 0x02, 0xD0, 0x01, 0xD0, 0x02, 0xD0, 0x03, 0x12, 0x34, 0x62, 0x90, 0x95, 0x0A, 0xE0, 0x24, 
+0x02, 0xF9, 0xE4, 0x34, 0xFB, 0xFA, 0x7B, 0x01, 0xC0, 0x03, 0xC0, 0x02, 0xC0, 0x01, 0xA3, 0x12, 
+0x49, 0x18, 0xE9, 0x24, 0x02, 0xF9, 0xE4, 0x3A, 0x8B, 0x40, 0xF5, 0x41, 0x89, 0x42, 0x90, 0x95, 
+0x0B, 0x71, 0x68, 0xF5, 0x43, 0xD0, 0x01, 0xD0, 0x02, 0xD0, 0x03, 0x02, 0x34, 0x62, 0xD3, 0x10, 
+0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x95, 0x0E, 0x12, 0x49, 0x21, 0x7F, 0x96, 0x7E, 0x02, 0x71, 
+0x71, 0xEF, 0x60, 0x3F, 0x12, 0x7C, 0x93, 0xFE, 0xB1, 0x6A, 0x90, 0x95, 0x11, 0xEF, 0xF0, 0xEE, 
+0xFF, 0x90, 0xFD, 0x11, 0xF0, 0x90, 0x95, 0x11, 0xE0, 0xFD, 0x90, 0x02, 0x94, 0xF0, 0xA3, 0xEF, 
+0xF0, 0x90, 0x95, 0x0E, 0x71, 0x68, 0x24, 0x02, 0xFF, 0xE4, 0x33, 0xFE, 0x71, 0xB4, 0x90, 0x95, 
+0x11, 0xE0, 0x24, 0x18, 0xFF, 0x90, 0x95, 0x0E, 0x12, 0x49, 0x18, 0x51, 0xA7, 0x90, 0x02, 0x96, 
+0x74, 0x01, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x12, 0x49, 0x18, 0x90, 0x00, 0x0E, 0x02, 0x06, 
+0xA2, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x95, 0x06, 0xEE, 0xF0, 0xA3, 0xEF, 0x91, 
+0x6D, 0x90, 0x95, 0x06, 0xB1, 0x7A, 0xE0, 0x60, 0x24, 0xC3, 0x90, 0x95, 0x09, 0xE0, 0x94, 0xE8, 
+0x90, 0x95, 0x08, 0xE0, 0x94, 0x03, 0x40, 0x0B, 0x90, 0x01, 0xC0, 0xE0, 0x44, 0x80, 0xF0, 0x7F, 
+0x00, 0x80, 0x0C, 0x90, 0x95, 0x08, 0x12, 0x5A, 0xA6, 0xB1, 0x63, 0x80, 0xD4, 0x7F, 0x01, 0xD0, 
+0xD0, 0x92, 0xAF, 0x22, 0xE4, 0xFC, 0xED, 0x2C, 0x24, 0x00, 0xF5, 0x82, 0xE4, 0x34, 0xFB, 0xF5, 
+0x83, 0xE4, 0xF0, 0x0C, 0xEC, 0xB4, 0x18, 0xEE, 0x74, 0x00, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 0xFB, 
+0xF5, 0x83, 0xEF, 0xF0, 0xEE, 0x54, 0x3F, 0xFF, 0x74, 0x01, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 0xFB, 
+0xF5, 0x83, 0xEF, 0xF0, 0x74, 0x02, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 0xFB, 0xF5, 0x83, 0xE0, 0x54, 
+0xF0, 0xF0, 0x12, 0xA9, 0x12, 0xE0, 0x44, 0x80, 0xF0, 0x74, 0x0B, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 
+0xFB, 0xF5, 0x83, 0xE0, 0x44, 0x10, 0xF0, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0xE4, 
+0xFF, 0x90, 0x8D, 0xF7, 0xE0, 0xFE, 0x90, 0x8D, 0xF6, 0xE0, 0xFD, 0xB5, 0x06, 0x04, 0x7E, 0x01, 
+0x80, 0x02, 0x7E, 0x00, 0xEE, 0x64, 0x01, 0x60, 0x3F, 0xED, 0xB1, 0x83, 0xFA, 0x7B, 0x01, 0x71, 
+0x0E, 0x7F, 0x01, 0xEF, 0x60, 0x32, 0x90, 0x8D, 0xF6, 0xE0, 0x04, 0xF0, 0xE0, 0xB4, 0x0A, 0x02, 
+0x80, 0x02, 0x7F, 0x00, 0xEF, 0x60, 0x05, 0xE4, 0x90, 0x8D, 0xF6, 0xF0, 0x90, 0x8D, 0xF7, 0xE0, 
+0xFF, 0x90, 0x8D, 0xF6, 0xE0, 0xB5, 0x07, 0x04, 0x7F, 0x01, 0x80, 0x02, 0x7F, 0x00, 0xEF, 0x70, 
+0x07, 0x90, 0x8D, 0x01, 0xE0, 0x44, 0x04, 0xF0, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xF0, 0xE4, 0xA3, 
+0xF0, 0xA3, 0xF0, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x93, 0x13, 0xE0, 0xFD, 
+0xB4, 0x02, 0x07, 0xB1, 0x52, 0x74, 0x08, 0xF0, 0x80, 0x09, 0xED, 0xB4, 0x04, 0x05, 0xB1, 0x52, 
+0x74, 0x10, 0xF0, 0xEF, 0x64, 0x02, 0x4E, 0x60, 0x02, 0xA1, 0x4D, 0x90, 0x8F, 0xD7, 0xE0, 0xFF, 
+0x64, 0xFE, 0x70, 0x02, 0xA1, 0x4D, 0xEF, 0x64, 0x02, 0x60, 0x07, 0xEF, 0x64, 0x03, 0x60, 0x02, 
+0xA1, 0x4D, 0x90, 0x90, 0x37, 0xB1, 0x72, 0x90, 0x93, 0x92, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0xB1, 
+0x5A, 0x7A, 0x93, 0x79, 0x50, 0x12, 0x08, 0xAA, 0xB1, 0x5A, 0x7A, 0x93, 0x79, 0x70, 0x12, 0x08, 
+0xAA, 0x90, 0xAC, 0x7A, 0x74, 0x10, 0x91, 0x6D, 0x7B, 0x20, 0xFD, 0xFC, 0xFF, 0xFE, 0x12, 0x38, 
+0xC6, 0x7B, 0x01, 0x7A, 0x90, 0x79, 0x39, 0x90, 0xAC, 0x89, 0x12, 0x49, 0x21, 0x7A, 0x93, 0x79, 
+0x70, 0x90, 0xAC, 0x8C, 0x12, 0x49, 0x21, 0x90, 0xAC, 0x8F, 0x74, 0x20, 0xF0, 0x7A, 0x8F, 0x79, 
+0xA6, 0x12, 0x33, 0x97, 0x75, 0x40, 0x01, 0x75, 0x41, 0x93, 0x75, 0x42, 0x78, 0x75, 0x43, 0x18, 
+0x7B, 0x01, 0x7A, 0x93, 0x79, 0x50, 0x12, 0x34, 0x62, 0x75, 0x40, 0x01, 0x75, 0x41, 0x93, 0x75, 
+0x42, 0x58, 0x75, 0x43, 0x10, 0x7B, 0x01, 0x7A, 0x93, 0x79, 0x40, 0x12, 0x34, 0x62, 0x90, 0x93, 
+0x56, 0xE0, 0x54, 0x03, 0xFF, 0xC3, 0x94, 0x04, 0x90, 0x8F, 0x94, 0x50, 0x04, 0xEF, 0xF0, 0x80, 
+0x03, 0x74, 0x05, 0xF0, 0x7B, 0x01, 0x7A, 0x93, 0x79, 0x40, 0x12, 0x77, 0x19, 0xD0, 0xD0, 0x92, 
+0xAF, 0x22, 0x90, 0x93, 0x90, 0x74, 0x80, 0xF0, 0xA3, 0x22, 0x7E, 0x00, 0x7F, 0x20, 0x7D, 0x00, 
+0x7B, 0x01, 0x22, 0x7F, 0x0A, 0x7E, 0x00, 0x02, 0x3D, 0x7A, 0xEF, 0x24, 0x01, 0xFF, 0xE4, 0x3E, 
+0xFE, 0x22, 0xE0, 0xFE, 0xA3, 0xE0, 0xFD, 0xED, 0xFF, 0x22, 0xE0, 0xFE, 0xA3, 0xE0, 0xF5, 0x82, 
+0x8E, 0x83, 0x22, 0x75, 0xF0, 0x0F, 0xA4, 0x24, 0x60, 0xF9, 0x74, 0x8D, 0x35, 0xF0, 0x22, 0x90, 
+0x93, 0x24, 0xE0, 0x54, 0xFE, 0xF0, 0x54, 0x7F, 0xF0, 0x54, 0xFB, 0xF0, 0xA3, 0x74, 0x0A, 0x81, 
+0x6D, 0xB1, 0xCC, 0xF1, 0xC4, 0xD1, 0x80, 0x12, 0x7A, 0x01, 0xB1, 0x8F, 0x12, 0xA7, 0x1C, 0x90, 
+0x93, 0x30, 0xE0, 0x54, 0x7F, 0xF0, 0x54, 0xBF, 0xF0, 0x54, 0xDF, 0xF0, 0x54, 0xF0, 0xF0, 0xE4, 
+0x90, 0x93, 0x32, 0xF0, 0x90, 0x93, 0x30, 0xE0, 0x54, 0xEF, 0xF0, 0x22, 0xE4, 0xFD, 0xFF, 0xD1, 
+0x1C, 0xFE, 0xEF, 0x54, 0x07, 0xFF, 0xED, 0x70, 0x14, 0xD1, 0x13, 0xF5, 0x83, 0xC0, 0x83, 0xC0, 
+0x82, 0xD1, 0x0B, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0xF4, 0x5E, 0x80, 0x11, 0xD1, 0x13, 0xF5, 
+0x83, 0xC0, 0x83, 0xC0, 0x82, 0xD1, 0x0B, 0x80, 0x02, 0xC3, 0x33, 0xD8, 0xFC, 0x4E, 0xD0, 0x82, 
+0xD0, 0x83, 0xF0, 0xD1, 0x23, 0x90, 0x8E, 0x0F, 0xEF, 0xF0, 0x22, 0xE0, 0xFE, 0x74, 0x01, 0xA8, 
+0x07, 0x08, 0x22, 0x74, 0xFF, 0x2E, 0xF5, 0x82, 0xE4, 0x34, 0x8D, 0x22, 0xEF, 0x13, 0x13, 0x13, 
+0x54, 0x1F, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x7D, 0x10, 0xED, 0x14, 0xF9, 0x24, 
+0xFF, 0xD1, 0x77, 0x60, 0x39, 0x7C, 0x08, 0xEC, 0x14, 0x90, 0x95, 0x44, 0xF0, 0x74, 0xFF, 0x29, 
+0xD1, 0x77, 0xFB, 0x7A, 0x00, 0x90, 0x95, 0x44, 0x12, 0x8F, 0xA0, 0x80, 0x05, 0xC3, 0x33, 0xCE, 
+0x33, 0xCE, 0xD8, 0xF9, 0xFF, 0xEE, 0x5A, 0xFE, 0xEF, 0x5B, 0x4E, 0x60, 0x0F, 0xE9, 0x75, 0xF0, 
+0x08, 0xA4, 0xFF, 0x90, 0x95, 0x44, 0xE0, 0x2F, 0x04, 0xFF, 0x80, 0x06, 0xDC, 0xC9, 0xDD, 0xBC, 
+0x7F, 0x00, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xF5, 0x82, 0xE4, 0x34, 0x8D, 0xF5, 0x83, 0xE0, 0x22, 
+0x7E, 0x00, 0x7F, 0xA8, 0x7D, 0x00, 0x7B, 0x01, 0x7A, 0x8E, 0x79, 0x11, 0x12, 0x08, 0xAA, 0x90, 
+0x8E, 0x14, 0x74, 0x02, 0xF0, 0x90, 0x8E, 0x1B, 0x14, 0xF1, 0xB0, 0x90, 0x8E, 0x21, 0xE4, 0xF0, 
+0xA3, 0x74, 0x02, 0xF0, 0xD1, 0xF9, 0xE4, 0xFD, 0xFF, 0x12, 0x53, 0xF7, 0x7D, 0x0C, 0x7F, 0x02, 
+0x12, 0x53, 0xF7, 0xF1, 0x3C, 0x90, 0x8D, 0x06, 0xE0, 0xFF, 0xB4, 0x01, 0x08, 0x90, 0x8E, 0x20, 
+0x74, 0xFF, 0xF0, 0x80, 0x0F, 0xEF, 0x90, 0x8E, 0x20, 0xB4, 0x03, 0x05, 0x74, 0xD4, 0xF0, 0x80, 
+0x03, 0x74, 0x41, 0xF0, 0x12, 0x99, 0x0C, 0xD1, 0xF9, 0x7F, 0x01, 0xF1, 0x08, 0x7E, 0x00, 0x7F, 
+0x02, 0x7D, 0x00, 0x7B, 0x01, 0x7A, 0x8E, 0x79, 0xBD, 0x12, 0x08, 0xAA, 0xF1, 0xA0, 0xF1, 0xA8, 
+0x12, 0x87, 0xCC, 0xE4, 0x90, 0x8E, 0xBF, 0xF0, 0x22, 0x90, 0x8E, 0x4B, 0xE0, 0x24, 0x04, 0x90, 
+0x8E, 0x2D, 0xF0, 0xA3, 0x74, 0x08, 0xF0, 0x22, 0xE4, 0xFE, 0x74, 0x32, 0x2E, 0xF1, 0x34, 0xE4, 
+0xF0, 0x0E, 0xEE, 0xB4, 0x19, 0xF4, 0xE4, 0x90, 0x8E, 0x2B, 0xF0, 0x90, 0x8E, 0x2F, 0xF0, 0x90, 
+0x8E, 0x27, 0xF0, 0xEF, 0xB4, 0x01, 0x09, 0x90, 0x8E, 0x30, 0x74, 0x19, 0xF0, 0xE4, 0xA3, 0xF0, 
+0x22, 0x74, 0x32, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 0x8E, 0xF5, 0x83, 0x22, 0x7D, 0x0C, 0x7F, 0x01, 
+0x02, 0x53, 0xF7, 0x90, 0x95, 0x01, 0xE0, 0xFF, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 
+0x95, 0x4C, 0xEF, 0xF0, 0x90, 0x8D, 0x09, 0xE0, 0xFF, 0x90, 0x04, 0x1C, 0xE0, 0x6F, 0x70, 0x3B, 
+0x90, 0x8E, 0x18, 0xE0, 0x64, 0x0E, 0x70, 0x13, 0x90, 0x95, 0x4C, 0xE0, 0x70, 0x2D, 0x90, 0x8E, 
+0x11, 0xE0, 0x54, 0x7F, 0xF0, 0xF1, 0xA0, 0xF1, 0x3C, 0x80, 0x1D, 0x90, 0x8E, 0x18, 0xE0, 0x64, 
+0x06, 0x70, 0x18, 0x90, 0x95, 0x4C, 0xE0, 0x60, 0x12, 0x90, 0x8E, 0x11, 0xE0, 0x54, 0xBF, 0xF0, 
+0xF1, 0xB8, 0x90, 0x8E, 0x18, 0x74, 0x04, 0xF0, 0x12, 0x87, 0xCC, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 
+0x90, 0x06, 0x04, 0xE0, 0x54, 0x7F, 0xF0, 0x22, 0x90, 0x06, 0x0A, 0xE0, 0x54, 0xF8, 0xF0, 0x22, 
+0xF0, 0xA3, 0xF0, 0xA3, 0x74, 0x08, 0xF0, 0x22, 0x90, 0x06, 0x04, 0xE0, 0x44, 0x40, 0xF0, 0xE0, 
+0x44, 0x80, 0xF0, 0x22, 0xE4, 0x90, 0x8D, 0xF6, 0xF0, 0xA3, 0xF0, 0x90, 0x8D, 0x5E, 0xF0, 0xA3, 
+0xF0, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x8B, 0x51, 0x8A, 0x52, 0x89, 0x53, 0x12, 
+0x06, 0x89, 0xFF, 0x90, 0x8E, 0x10, 0xF0, 0xBF, 0x01, 0x0D, 0x12, 0x76, 0xE7, 0x64, 0x01, 0x60, 
+0x19, 0x7D, 0x13, 0x7F, 0x6F, 0x80, 0x10, 0xAB, 0x51, 0xAA, 0x52, 0xA9, 0x53, 0x12, 0x76, 0xE7, 
+0x64, 0x01, 0x60, 0x06, 0xE4, 0xFD, 0xFF, 0x12, 0x54, 0x6C, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x12, 
+0x06, 0x89, 0xFF, 0x90, 0x8D, 0xFA, 0xF0, 0xBF, 0x01, 0x07, 0x11, 0x22, 0xE4, 0x90, 0x8D, 0xFA, 
+0xF0, 0x22, 0x11, 0xC9, 0x7F, 0xF5, 0x7E, 0x01, 0x12, 0x33, 0xFD, 0xBF, 0x01, 0x06, 0x90, 0x93, 
+0x3C, 0xE0, 0xA3, 0xF0, 0x11, 0xC9, 0x7F, 0xF6, 0x7E, 0x01, 0x12, 0x33, 0xFD, 0xBF, 0x01, 0x08, 
+0x90, 0x93, 0x3C, 0xE0, 0x90, 0x93, 0x3E, 0xF0, 0x11, 0xC9, 0x7F, 0xF4, 0x7E, 0x01, 0x12, 0x33, 
+0xFD, 0xBF, 0x01, 0x08, 0x90, 0x93, 0x3C, 0xE0, 0x90, 0x93, 0x3F, 0xF0, 0x11, 0xC9, 0x7F, 0xF3, 
+0x7E, 0x01, 0x12, 0x33, 0xFD, 0xBF, 0x01, 0x08, 0x90, 0x93, 0x3C, 0xE0, 0x90, 0x93, 0x40, 0xF0, 
+0x11, 0xC9, 0x7F, 0xF2, 0x7E, 0x01, 0x12, 0x33, 0xFD, 0xBF, 0x01, 0x08, 0x90, 0x93, 0x3C, 0xE0, 
+0x90, 0x93, 0x41, 0xF0, 0x90, 0x93, 0x3D, 0x11, 0xD0, 0xA3, 0xE0, 0x90, 0x93, 0x45, 0xF0, 0x90, 
+0x93, 0x41, 0xE0, 0x90, 0x93, 0x46, 0xF0, 0x90, 0x93, 0x47, 0x74, 0x12, 0xF0, 0x90, 0x93, 0x55, 
+0x74, 0x05, 0xF0, 0x90, 0x93, 0x49, 0x12, 0x67, 0xF7, 0xEB, 0xF0, 0x90, 0x93, 0x45, 0xE0, 0x90, 
+0x93, 0x4C, 0xF0, 0x90, 0x93, 0x46, 0xE0, 0x90, 0x93, 0x4D, 0xF0, 0x7B, 0x01, 0x7A, 0x93, 0x79, 
+0x47, 0x12, 0x85, 0x0E, 0x7F, 0x04, 0x02, 0x71, 0x82, 0x7B, 0x01, 0x7A, 0x93, 0x79, 0x3C, 0x22, 
+0xE0, 0xFF, 0xA3, 0xE0, 0xFD, 0xA3, 0xE0, 0xFB, 0x22, 0x12, 0x06, 0x89, 0x54, 0x01, 0xFF, 0x90, 
+0x93, 0x35, 0xE0, 0x54, 0xFE, 0x4F, 0xF0, 0x22, 0x12, 0x77, 0xBB, 0xFF, 0x30, 0xE0, 0x1D, 0x12, 
+0x06, 0x89, 0x90, 0x8E, 0xB9, 0x12, 0x76, 0xE6, 0x90, 0x8E, 0xBA, 0xF0, 0xEF, 0x54, 0xFE, 0xFF, 
+0xA3, 0xE0, 0x54, 0x01, 0x12, 0x77, 0xD2, 0x90, 0x8E, 0xBC, 0xF0, 0x22, 0x90, 0x8E, 0xB9, 0x74, 
+0x05, 0xF0, 0xA3, 0x74, 0x0A, 0xF0, 0xA3, 0xE0, 0x54, 0x01, 0x44, 0x1E, 0xF0, 0xA3, 0x74, 0x05, 
+0xF0, 0x22, 0x12, 0x06, 0x89, 0x90, 0x8E, 0x20, 0xF0, 0x22, 0x12, 0x06, 0x89, 0x90, 0x8E, 0xBF, 
+0xF0, 0x22, 0x31, 0x38, 0x54, 0xFB, 0xF0, 0x22, 0x8F, 0x57, 0x75, 0xF0, 0x10, 0xEF, 0x90, 0x81, 
+0x05, 0x12, 0x49, 0x0C, 0xE0, 0x22, 0x31, 0x38, 0x44, 0x04, 0xF0, 0x22, 0xEF, 0x70, 0x04, 0x74, 
+0xF0, 0x80, 0x16, 0xEF, 0xB4, 0x01, 0x04, 0x74, 0xF4, 0x80, 0x0E, 0xEF, 0xB4, 0x02, 0x04, 0x74, 
+0xF8, 0x80, 0x06, 0xEF, 0xB4, 0x03, 0x0C, 0x74, 0xFC, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 0x02, 0xF5, 
+0x83, 0xEB, 0xF0, 0x22, 0x90, 0x95, 0x2A, 0x12, 0x49, 0x21, 0xE4, 0xFF, 0x90, 0x95, 0x2A, 0x12, 
+0x49, 0x18, 0x8F, 0x82, 0x75, 0x83, 0x00, 0x12, 0x06, 0xA2, 0xFE, 0x74, 0xF0, 0x2F, 0xF5, 0x82, 
+0xE4, 0x34, 0x02, 0x31, 0x99, 0xB4, 0x10, 0xE4, 0x22, 0xF5, 0x83, 0xEE, 0xF0, 0x0F, 0xEF, 0x22, 
+0xE4, 0xFF, 0x74, 0x18, 0x31, 0xC4, 0x74, 0xD0, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x8E, 0xF5, 0x83, 
+0xEE, 0xF0, 0x74, 0x10, 0x31, 0xC4, 0x74, 0xCA, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x8E, 0x31, 0x99, 
+0xB4, 0x06, 0xDF, 0x22, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x06, 0xF5, 0x83, 0xE0, 0xFE, 0x22, 0xE4, 
+0xFF, 0x74, 0x8C, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x8F, 0xF5, 0x83, 0xE0, 0xFE, 0x74, 0x84, 0x2F, 
+0xF5, 0x82, 0xE4, 0x34, 0x04, 0x31, 0x99, 0xB4, 0x08, 0xE7, 0x90, 0x8F, 0x94, 0xE0, 0x90, 0x04, 
+0x8C, 0xF0, 0x22, 0x51, 0x18, 0x31, 0xCF, 0x90, 0x01, 0x3F, 0x74, 0x04, 0xF0, 0x90, 0x8D, 0x06, 
+0xE0, 0xFF, 0xB4, 0x01, 0x07, 0x90, 0xFD, 0x00, 0xE0, 0x54, 0xEF, 0xF0, 0xEF, 0xB4, 0x01, 0x07, 
+0x90, 0xFE, 0x10, 0xE0, 0x54, 0xFB, 0xF0, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0xE4, 
+0xFD, 0x7F, 0x8F, 0x12, 0x4B, 0x9F, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x90, 0x01, 0x94, 0xE0, 0x44, 
+0x01, 0xF0, 0x90, 0x01, 0xC7, 0xE4, 0xF0, 0x22, 0x90, 0x01, 0x9A, 0xE0, 0x54, 0xC0, 0x44, 0x0B, 
+0xF0, 0x12, 0x95, 0x63, 0x90, 0x01, 0x98, 0xE0, 0x54, 0xC0, 0x7F, 0x00, 0xB4, 0x40, 0x02, 0x7F, 
+0x01, 0x22, 0x90, 0x01, 0xC7, 0x74, 0xFE, 0xF0, 0x22, 0x90, 0x01, 0xE4, 0x74, 0x1C, 0xF0, 0xA3, 
+0xE4, 0xF0, 0x22, 0x90, 0x01, 0x34, 0xE0, 0x55, 0x15, 0xF5, 0x19, 0xA3, 0xE0, 0x55, 0x16, 0xF5, 
+0x1A, 0xA3, 0xE0, 0x55, 0x17, 0xF5, 0x1B, 0xA3, 0xE0, 0x55, 0x18, 0xF5, 0x1C, 0x90, 0x01, 0x34, 
+0xE5, 0x19, 0xF0, 0xA3, 0xE5, 0x1A, 0xF0, 0xA3, 0xE5, 0x1B, 0xF0, 0xA3, 0xE5, 0x1C, 0xF0, 0x22, 
+0x90, 0x01, 0x3C, 0xE0, 0x55, 0x1D, 0xF5, 0x21, 0xA3, 0xE0, 0x55, 0x1E, 0xF5, 0x22, 0xA3, 0xE0, 
+0x55, 0x1F, 0xF5, 0x23, 0xA3, 0xE0, 0x55, 0x20, 0xF5, 0x24, 0x90, 0x01, 0x3C, 0xE5, 0x21, 0xF0, 
+0xA3, 0xE5, 0x22, 0xF0, 0xA3, 0xE5, 0x23, 0xF0, 0xA3, 0xE5, 0x24, 0xF0, 0x53, 0x91, 0xDF, 0x22, 
+0x90, 0x8E, 0xC0, 0xE0, 0x30, 0xE0, 0x05, 0x7F, 0x10, 0x12, 0x71, 0xA1, 0x22, 0x90, 0x01, 0xCF, 
+0xE0, 0x90, 0x93, 0xE4, 0xF0, 0xE0, 0xFF, 0x30, 0xE0, 0x07, 0x90, 0x01, 0xCF, 0xE0, 0x54, 0xFE, 
+0xF0, 0xEF, 0x30, 0xE5, 0x23, 0x90, 0x01, 0xCF, 0xE0, 0x54, 0xDF, 0xF0, 0x90, 0x01, 0x34, 0x74, 
+0x20, 0xF0, 0xE4, 0xF5, 0xA8, 0xF5, 0xE8, 0x12, 0x4F, 0x26, 0x90, 0x00, 0x03, 0xE0, 0x54, 0xFB, 
+0xFD, 0x7F, 0x03, 0x12, 0x4B, 0x9F, 0x80, 0xFE, 0x22, 0x90, 0x93, 0x2E, 0xE0, 0x04, 0xF0, 0x90, 
+0x8E, 0x18, 0xE0, 0x64, 0x02, 0x60, 0x08, 0x71, 0x20, 0x90, 0x01, 0xE6, 0xE0, 0x04, 0xF0, 0x22, 
+0x12, 0x8F, 0xD8, 0xCE, 0xC3, 0x13, 0xCE, 0x13, 0xD8, 0xF9, 0xFF, 0xB1, 0xEF, 0x12, 0x72, 0xD5, 
+0x60, 0x02, 0x61, 0xB7, 0x90, 0x8E, 0x15, 0xE0, 0x60, 0x7D, 0x71, 0xB8, 0x64, 0x01, 0x70, 0x22, 
+0x90, 0x06, 0xAB, 0xE0, 0x90, 0x8E, 0x1C, 0xF0, 0x90, 0x06, 0xAA, 0xE0, 0x90, 0x8E, 0x1B, 0xF0, 
+0xA3, 0xE0, 0xFF, 0x70, 0x08, 0x90, 0x8E, 0x1B, 0xE0, 0xFE, 0xFF, 0x80, 0x00, 0x90, 0x8E, 0x1C, 
+0xEF, 0xF0, 0x91, 0x1D, 0xB1, 0xE7, 0xE4, 0x90, 0x8E, 0x1E, 0xD1, 0x54, 0xD1, 0x3E, 0xD1, 0x4B, 
+0x54, 0xEF, 0xF0, 0x71, 0xB8, 0x24, 0xFD, 0x50, 0x02, 0x80, 0x02, 0x71, 0xC1, 0x12, 0x8F, 0xB4, 
+0x30, 0xE0, 0x34, 0xEF, 0xC4, 0x13, 0x13, 0x54, 0x03, 0x20, 0xE0, 0x2B, 0x90, 0x8E, 0x1B, 0xE0, 
+0xFF, 0xA3, 0xE0, 0x6F, 0x70, 0x21, 0x90, 0x8E, 0x12, 0xE0, 0x44, 0x40, 0xF0, 0xB1, 0xDF, 0xF0, 
+0x90, 0x01, 0x3F, 0x74, 0x10, 0xF0, 0xFD, 0x7F, 0x03, 0xD1, 0x6B, 0x12, 0x8F, 0x77, 0x12, 0x79, 
+0x5B, 0x90, 0x8E, 0x1C, 0xE0, 0x14, 0xF0, 0x22, 0x90, 0x8E, 0x13, 0xE0, 0xFF, 0xC4, 0x54, 0x0F, 
+0x22, 0xE4, 0xF5, 0x58, 0x90, 0x06, 0xA9, 0xE0, 0xF5, 0x58, 0x54, 0xC0, 0x70, 0x08, 0x91, 0x15, 
+0x54, 0xFD, 0xF0, 0x02, 0x77, 0xC1, 0xE5, 0x58, 0x30, 0xE6, 0x1F, 0x90, 0x8E, 0x15, 0xE0, 0x64, 
+0x01, 0x70, 0x19, 0x90, 0x8E, 0x19, 0xE0, 0x44, 0x01, 0xF0, 0x12, 0x76, 0x16, 0x64, 0x02, 0x60, 
+0x04, 0xD1, 0xA5, 0x80, 0x07, 0x12, 0x57, 0xBB, 0x80, 0x02, 0x91, 0x15, 0xE5, 0x58, 0x90, 0x8E, 
+0x19, 0x30, 0xE7, 0x0C, 0xE0, 0x44, 0x02, 0x12, 0x74, 0x25, 0xB1, 0xF8, 0x44, 0x04, 0xF0, 0x22, 
+0xE0, 0x54, 0xFD, 0xF0, 0x22, 0x90, 0x8E, 0x19, 0xE0, 0x54, 0xFE, 0xF0, 0x22, 0xE4, 0xFD, 0xF9, 
+0xFC, 0x90, 0x05, 0x62, 0xE0, 0xFE, 0x90, 0x05, 0x61, 0xE0, 0xFB, 0xEB, 0x78, 0x02, 0xCE, 0xC3, 
+0x13, 0xCE, 0x13, 0xD8, 0xF9, 0xFF, 0xEE, 0x54, 0x3F, 0x90, 0x8E, 0x4E, 0xF0, 0xA3, 0xEF, 0xF0, 
+0xA3, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x90, 0x8E, 0x4E, 0xE0, 0xFA, 0xA3, 0xE0, 0xFB, 0xC3, 0x9F, 
+0xEA, 0x9E, 0x40, 0x22, 0xEB, 0x9F, 0xFF, 0x90, 0x8E, 0x2D, 0xE0, 0xFE, 0xC3, 0x74, 0x0A, 0x9E, 
+0x2F, 0xF9, 0xC3, 0x94, 0x19, 0x50, 0x0F, 0x74, 0x32, 0x29, 0x12, 0x97, 0x34, 0xE0, 0x04, 0xF0, 
+0x90, 0x8E, 0x2B, 0xE0, 0x04, 0xF0, 0x90, 0x8E, 0x2B, 0xE0, 0xC3, 0x94, 0x64, 0x50, 0x02, 0xA1, 
+0x09, 0xE4, 0xFC, 0xFD, 0x12, 0x97, 0x31, 0xE0, 0x2C, 0xFC, 0xD3, 0x94, 0x05, 0x40, 0x07, 0x90, 
+0x93, 0xE6, 0xED, 0xF0, 0x80, 0x05, 0x0D, 0xED, 0xB4, 0x19, 0xE9, 0xE4, 0xFC, 0xFD, 0x12, 0x97, 
+0x31, 0xE0, 0x2C, 0xFC, 0xD3, 0x94, 0x5F, 0x40, 0x07, 0x90, 0x93, 0xE7, 0xED, 0xF0, 0x80, 0x05, 
+0x0D, 0xED, 0xB4, 0x19, 0xE9, 0x90, 0x93, 0xE6, 0xE0, 0x90, 0x8E, 0x30, 0xF0, 0x90, 0x93, 0xE7, 
+0xE0, 0x90, 0x8E, 0x31, 0xB1, 0x0A, 0x94, 0x0B, 0x40, 0x0A, 0xEF, 0x24, 0xF6, 0x90, 0x8E, 0x28, 
+0xF0, 0xE4, 0x80, 0x09, 0xE4, 0x90, 0x8E, 0x28, 0xB1, 0x0A, 0x74, 0x0A, 0x9F, 0x90, 0x8E, 0x27, 
+0xF0, 0x90, 0x8E, 0x30, 0xE0, 0xFF, 0xA3, 0xE0, 0xC3, 0x9F, 0x90, 0x8E, 0x2E, 0xF0, 0xC3, 0x94, 
+0x08, 0x50, 0x03, 0x74, 0x08, 0xF0, 0x90, 0x8E, 0x28, 0xE0, 0xFD, 0x90, 0x8E, 0x2E, 0xE0, 0xFB, 
+0xE4, 0xFF, 0xB1, 0x12, 0xE4, 0xFF, 0x12, 0x97, 0x08, 0x22, 0xF0, 0x90, 0x8E, 0x30, 0xE0, 0xFF, 
+0xC3, 0x22, 0xAC, 0x07, 0x90, 0x8E, 0x11, 0xE0, 0x30, 0xE0, 0x16, 0x90, 0x8E, 0x4B, 0xE0, 0x24, 
+0x04, 0x90, 0x8E, 0x2A, 0xF0, 0x90, 0x8E, 0x4B, 0xE0, 0x24, 0x03, 0x90, 0x8E, 0x29, 0xF0, 0x80, 
+0x0B, 0x90, 0x8E, 0x2A, 0x74, 0x02, 0xF0, 0x90, 0x8E, 0x29, 0x14, 0xF0, 0x90, 0x8E, 0x29, 0xE0, 
+0xFA, 0x90, 0x8E, 0x28, 0xE0, 0xD3, 0x9A, 0x50, 0x09, 0x90, 0x8E, 0x1D, 0xEB, 0xB1, 0x75, 0x2C, 
+0x80, 0x0B, 0xAD, 0x02, 0xC3, 0xED, 0x9D, 0x2B, 0x90, 0x8E, 0x1D, 0xB1, 0x75, 0x90, 0x8E, 0x2D, 
+0xF0, 0x90, 0x8E, 0x2D, 0xE0, 0xFF, 0x7E, 0x00, 0x90, 0x8E, 0x21, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 
+0x90, 0x05, 0x58, 0xF0, 0x22, 0xF0, 0x90, 0x8E, 0x2A, 0xE0, 0xC3, 0x9D, 0x22, 0xD1, 0x5F, 0x40, 
+0x1E, 0x90, 0x8E, 0x2F, 0xE0, 0x04, 0xF0, 0xE0, 0xFF, 0x94, 0x04, 0x50, 0x12, 0x90, 0x8E, 0x27, 
+0xEF, 0xF0, 0x25, 0xE0, 0x24, 0x08, 0x90, 0x8E, 0x2E, 0xF0, 0xFB, 0xB1, 0xD6, 0xB1, 0x12, 0x22, 
+0xD1, 0xC3, 0x90, 0x93, 0xF3, 0xEF, 0xF0, 0x30, 0xE0, 0x05, 0x7D, 0x01, 0xE4, 0x80, 0x02, 0xE4, 
+0xFD, 0xFF, 0x12, 0x53, 0xF7, 0x90, 0x93, 0xF3, 0xE0, 0x30, 0xE6, 0x11, 0x90, 0x01, 0x2F, 0xE0, 
+0x30, 0xE7, 0x04, 0xE4, 0xF0, 0x80, 0x06, 0x90, 0x01, 0x2F, 0x74, 0x80, 0xF0, 0xB1, 0xD6, 0x90, 
+0x8E, 0x2E, 0xE0, 0xFB, 0xA1, 0x12, 0x90, 0x8E, 0x27, 0xE0, 0xFF, 0xA3, 0xE0, 0xFD, 0x22, 0x90, 
+0x8E, 0x1B, 0xE0, 0x90, 0x05, 0x73, 0x22, 0x90, 0x8E, 0x12, 0xE0, 0x44, 0x04, 0xF0, 0x22, 0x90, 
+0x93, 0xE4, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x22, 0x7E, 0x01, 0x12, 0x50, 0x04, 0x90, 0x8E, 0x11, 
+0xE0, 0x22, 0xD1, 0x34, 0x30, 0xE0, 0x05, 0x90, 0x01, 0x5B, 0xE4, 0xF0, 0x90, 0x06, 0x92, 0x74, 
+0x02, 0xF0, 0x90, 0x01, 0x3C, 0x74, 0x04, 0xF0, 0xE4, 0x90, 0x94, 0xE7, 0xF0, 0x90, 0x8E, 0xBB, 
+0xE0, 0xC3, 0x13, 0x54, 0x7F, 0x90, 0x94, 0xE8, 0xF0, 0xE4, 0xFB, 0xFD, 0x7F, 0x58, 0xB1, 0xF8, 
+0x44, 0x08, 0xF0, 0x22, 0x90, 0x8E, 0x11, 0xE0, 0x13, 0x13, 0x13, 0x54, 0x1F, 0x22, 0x90, 0x01, 
+0x57, 0xE4, 0xF0, 0x90, 0x01, 0x3C, 0x74, 0x02, 0x22, 0x54, 0xFB, 0xF0, 0x90, 0x8E, 0x19, 0xE0, 
+0x54, 0xFD, 0xF0, 0x22, 0xF0, 0x90, 0x8E, 0x21, 0xA3, 0xE0, 0x90, 0x05, 0x58, 0xF0, 0x22, 0x90, 
+0x8E, 0xB9, 0xE0, 0xFF, 0x90, 0x8E, 0x1E, 0xE0, 0xD3, 0x9F, 0x22, 0x74, 0x1D, 0x2F, 0xF8, 0xE6, 
+0x4D, 0xFE, 0xF6, 0x74, 0x38, 0x2F, 0xF5, 0x82, 0xE4, 0x34, 0x01, 0xF5, 0x83, 0xEE, 0xF0, 0x22, 
+0x90, 0x8E, 0x15, 0xE0, 0x64, 0x01, 0x70, 0x13, 0x12, 0x76, 0x16, 0x60, 0x05, 0x12, 0x54, 0x63, 
+0xC1, 0x02, 0x90, 0x8E, 0x18, 0xE0, 0x70, 0x03, 0x12, 0x51, 0xE4, 0x22, 0x90, 0x8E, 0x15, 0xE0, 
+0x60, 0x02, 0xD1, 0x80, 0x22, 0x90, 0x04, 0x1D, 0xE0, 0x70, 0x17, 0x90, 0x8D, 0x08, 0xE0, 0xFF, 
+0x7B, 0x18, 0xE4, 0xFD, 0x12, 0x82, 0x1D, 0x90, 0x95, 0x40, 0xEE, 0xF0, 0xA3, 0xEF, 0xF0, 0x12, 
+0x55, 0xDF, 0x22, 0xE4, 0x90, 0x93, 0xF4, 0xF0, 0xA3, 0xF0, 0xA3, 0xF0, 0x7F, 0x83, 0x12, 0x4C, 
+0x69, 0x90, 0x93, 0xF4, 0xEF, 0xF0, 0x7F, 0x83, 0x12, 0x4C, 0x69, 0xAE, 0x07, 0x90, 0x93, 0xF4, 
+0xE0, 0xFF, 0xB5, 0x06, 0x01, 0x22, 0xC3, 0x90, 0x93, 0xF6, 0xE0, 0x94, 0x64, 0x90, 0x93, 0xF5, 
+0xE0, 0x94, 0x00, 0x40, 0x0D, 0x90, 0x01, 0xC0, 0xE0, 0x44, 0x40, 0xF0, 0x90, 0x93, 0xF4, 0xE0, 
+0xFF, 0x22, 0x90, 0x93, 0xF5, 0x12, 0x5A, 0xA6, 0x80, 0xC2, 0x90, 0x8E, 0x15, 0xE0, 0x60, 0x03, 
+0x12, 0x75, 0xAE, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x04, 0x1D, 0xE0, 0x60, 
+0x1A, 0x90, 0x05, 0x22, 0xE0, 0x54, 0x90, 0x60, 0x07, 0x90, 0x01, 0xC0, 0xE0, 0x44, 0x08, 0xF0, 
+0x90, 0x01, 0xC6, 0xE0, 0x30, 0xE1, 0xE4, 0x7F, 0x00, 0x80, 0x02, 0x7F, 0x01, 0xD0, 0xD0, 0x92, 
+0xAF, 0x22, 0xC3, 0xEE, 0x94, 0x01, 0x40, 0x0A, 0x0D, 0xED, 0x13, 0x90, 0xFD, 0x10, 0xF0, 0xE4, 
+0x2F, 0xFF, 0x22, 0x90, 0x93, 0x5D, 0xE0, 0x2F, 0xFF, 0x90, 0x93, 0x5C, 0xE0, 0x34, 0x00, 0xFE, 
+0x90, 0x93, 0xE0, 0xF0, 0xA3, 0xEF, 0xF0, 0x90, 0x93, 0x17, 0xE0, 0xFD, 0xF1, 0x42, 0x90, 0x93, 
+0x57, 0xEF, 0xF0, 0x22, 0x90, 0x01, 0xC4, 0x74, 0x74, 0xF0, 0x74, 0x9F, 0xA3, 0xF0, 0x7F, 0x90, 
+0x12, 0x4C, 0x69, 0xEF, 0x20, 0xE0, 0xF7, 0x74, 0x74, 0x04, 0x90, 0x01, 0xC4, 0xF0, 0x74, 0x9F, 
+0xA3, 0xF0, 0x22, 0x90, 0x04, 0x54, 0xE0, 0x7F, 0x00, 0x30, 0xE7, 0x02, 0x7F, 0x01, 0x22, 0x90, 
+0x95, 0x3F, 0xED, 0xF0, 0x90, 0x95, 0x3E, 0xEF, 0xF0, 0xD3, 0x94, 0x0E, 0x50, 0x16, 0xF1, 0x93, 
+0xEF, 0x60, 0x43, 0xF1, 0x93, 0xEF, 0x64, 0x01, 0x70, 0x3C, 0x90, 0x95, 0x3F, 0xE0, 0xFD, 0xE4, 
+0xFF, 0x02, 0x66, 0x58, 0x90, 0x95, 0x3E, 0xE0, 0xD3, 0x94, 0x0E, 0x40, 0x29, 0xF1, 0x93, 0xEF, 
+0x70, 0x22, 0x90, 0x8D, 0xFB, 0xE0, 0x30, 0xE0, 0x03, 0x12, 0xA8, 0x77, 0x90, 0x95, 0x3F, 0xE0, 
+0xFD, 0x7F, 0x01, 0x12, 0x66, 0x58, 0x90, 0x8D, 0xFB, 0xE0, 0x13, 0x13, 0x54, 0x3F, 0x30, 0xE0, 
+0x05, 0x02, 0x87, 0x99, 0xF1, 0x93, 0x22, 0xE4, 0xFE, 0xFC, 0xEF, 0x64, 0x02, 0x70, 0x40, 0xED, 
+0xB4, 0x01, 0x04, 0x7E, 0x0A, 0x80, 0x06, 0xED, 0xB4, 0x02, 0x02, 0x7E, 0x09, 0xEB, 0xB4, 0x01, 
+0x08, 0xED, 0xB4, 0x01, 0x04, 0x7C, 0x04, 0x80, 0x38, 0xEB, 0xB4, 0x02, 0x08, 0xED, 0xB4, 0x01, 
+0x04, 0x7C, 0x02, 0x80, 0x2C, 0xEB, 0xB4, 0x01, 0x08, 0xED, 0xB4, 0x02, 0x04, 0x7C, 0x01, 0x80, 
+0x20, 0xEB, 0x64, 0x02, 0x70, 0x1B, 0xED, 0x64, 0x02, 0x70, 0x16, 0x7C, 0x03, 0x80, 0x12, 0xEF, 
+0xB4, 0x01, 0x0E, 0xEB, 0xB4, 0x02, 0x04, 0x7C, 0x01, 0x80, 0x06, 0xEB, 0xB4, 0x01, 0x02, 0x7C, 
+0x02, 0xAF, 0x06, 0xEF, 0xC4, 0x54, 0xF0, 0x4C, 0xFF, 0x22, 0x90, 0x95, 0x46, 0xED, 0xF0, 0xEF, 
+0x60, 0x02, 0x21, 0x2B, 0xE0, 0x24, 0xFD, 0x50, 0x0A, 0x60, 0x1D, 0x14, 0x60, 0x2F, 0x14, 0x60, 
+0x6C, 0x41, 0xBB, 0x90, 0xAA, 0xB9, 0x12, 0x08, 0x79, 0x77, 0x77, 0x77, 0x77, 0x51, 0xC7, 0x12, 
+0x08, 0x79, 0x77, 0x77, 0x77, 0x77, 0x21, 0x9F, 0x90, 0xAA, 0xB9, 0x12, 0x08, 0x79, 0x54, 0x33, 
+0x77, 0x70, 0x51, 0xC7, 0x12, 0x08, 0x79, 0x54, 0x33, 0x77, 0x70, 0x41, 0x1F, 0x90, 0xAA, 0xB9, 
+0x12, 0x08, 0x79, 0x77, 0x77, 0x77, 0x77, 0x51, 0xC7, 0x12, 0x08, 0x79, 0x77, 0x77, 0x77, 0x77, 
+0x51, 0xBC, 0x12, 0x08, 0x79, 0x3F, 0xF0, 0x00, 0x00, 0x90, 0x94, 0x93, 0x12, 0x08, 0x79, 0x00, 
+0x10, 0x00, 0x00, 0x7F, 0xB4, 0x7E, 0x0C, 0x12, 0x66, 0x52, 0x12, 0x08, 0x79, 0x3F, 0xF0, 0x00, 
+0x00, 0x90, 0x94, 0x93, 0x12, 0x08, 0x79, 0x00, 0x10, 0x00, 0x00, 0x41, 0xB4, 0x90, 0x94, 0x8F, 
+0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 0xFF, 0x90, 0x94, 0x93, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 
+0x77, 0x12, 0x65, 0xD6, 0x90, 0xAA, 0xB9, 0x12, 0x08, 0x79, 0x77, 0x77, 0x77, 0x77, 0x51, 0xBC, 
+0x12, 0x08, 0x79, 0x01, 0x00, 0x00, 0x00, 0x90, 0x94, 0x93, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 
+0x00, 0x7F, 0xB4, 0x7E, 0x0C, 0x12, 0x66, 0x52, 0x12, 0x08, 0x79, 0x3F, 0xF0, 0x00, 0x00, 0x90, 
+0x94, 0x93, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 0x00, 0x41, 0xB4, 0x90, 0x95, 0x46, 0xE0, 0x14, 
+0x60, 0x5A, 0x14, 0x70, 0x02, 0x21, 0xCC, 0x14, 0x70, 0x02, 0x41, 0x0C, 0x14, 0x70, 0x02, 0x21, 
+0xCC, 0x14, 0x70, 0x02, 0x41, 0x68, 0x24, 0x05, 0x60, 0x02, 0x41, 0xBB, 0x90, 0xAA, 0xB9, 0x12, 
+0x08, 0x79, 0x77, 0x33, 0x77, 0x17, 0x51, 0xC7, 0x12, 0x08, 0x79, 0x77, 0x33, 0x77, 0x17, 0x51, 
+0xBC, 0x12, 0x08, 0x79, 0x3F, 0xF0, 0x00, 0x00, 0x90, 0x94, 0x93, 0x12, 0x08, 0x79, 0x01, 0x00, 
+0x00, 0x00, 0x7F, 0xB4, 0x7E, 0x0C, 0x12, 0x66, 0x52, 0x12, 0x08, 0x79, 0x3F, 0xF0, 0x00, 0x00, 
+0x90, 0x94, 0x93, 0x12, 0x08, 0x79, 0x01, 0x00, 0x00, 0x00, 0x41, 0xB4, 0x90, 0xAA, 0xB9, 0x12, 
+0x08, 0x79, 0x77, 0x33, 0x77, 0x17, 0x51, 0xC7, 0x12, 0x08, 0x79, 0x77, 0x33, 0x77, 0x17, 0x51, 
+0xBC, 0x12, 0x08, 0x79, 0x3F, 0xF0, 0x00, 0x00, 0x90, 0x94, 0x93, 0x12, 0x08, 0x79, 0x00, 0x00, 
+0x00, 0x00, 0x7F, 0xB4, 0x7E, 0x0C, 0x12, 0x66, 0x52, 0x12, 0x08, 0x79, 0x3F, 0xF0, 0x00, 0x00, 
+0x90, 0x94, 0x93, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 0x00, 0x41, 0xB4, 0x90, 0xAA, 0xB9, 0x12, 
+0x08, 0x79, 0x77, 0x33, 0x77, 0x77, 0x51, 0xC7, 0x12, 0x08, 0x79, 0x77, 0x33, 0x77, 0x77, 0x51, 
+0xBC, 0x12, 0x08, 0x79, 0x3F, 0xF0, 0x00, 0x00, 0x90, 0x94, 0x93, 0x12, 0x08, 0x79, 0x01, 0x00, 
+0x00, 0x00, 0x7F, 0xB4, 0x7E, 0x0C, 0x12, 0x66, 0x52, 0x12, 0x08, 0x79, 0x3F, 0xF0, 0x00, 0x00, 
+0x90, 0x94, 0x93, 0x12, 0x08, 0x79, 0x01, 0x00, 0x00, 0x00, 0x41, 0xB4, 0x90, 0xAA, 0xB9, 0x12, 
+0x08, 0x79, 0x54, 0x33, 0x77, 0x17, 0x51, 0xC7, 0x12, 0x08, 0x79, 0x54, 0x33, 0x77, 0x17, 0x51, 
+0xBC, 0x12, 0x08, 0x79, 0x3F, 0xF0, 0x00, 0x00, 0x90, 0x94, 0x93, 0x12, 0x08, 0x79, 0x01, 0x00, 
+0x00, 0x00, 0x7F, 0xB4, 0x7E, 0x0C, 0x12, 0x66, 0x52, 0x12, 0x08, 0x79, 0x3F, 0xF0, 0x00, 0x00, 
+0x90, 0x94, 0x93, 0x12, 0x08, 0x79, 0x01, 0x00, 0x00, 0x00, 0x7F, 0xB4, 0x7E, 0x0E, 0x12, 0x66, 
+0x52, 0x12, 0x08, 0x79, 0x00, 0x00, 0x03, 0x03, 0x90, 0x94, 0x93, 0x12, 0x08, 0x79, 0x00, 0x00, 
+0x00, 0x01, 0x7F, 0x00, 0x7E, 0x09, 0x80, 0x50, 0x90, 0x94, 0x8F, 0x12, 0x08, 0x79, 0x00, 0xFF, 
+0x00, 0x00, 0x90, 0x94, 0x93, 0x12, 0x08, 0x79, 0x00, 0x33, 0x00, 0x00, 0x12, 0x65, 0xD6, 0x90, 
+0xAA, 0xB9, 0x12, 0x08, 0x79, 0x77, 0x33, 0x77, 0x77, 0x51, 0xBC, 0x12, 0x08, 0x79, 0x01, 0x00, 
+0x00, 0x00, 0x90, 0x94, 0x93, 0x12, 0x08, 0x79, 0x01, 0x00, 0x00, 0x00, 0x7F, 0xB4, 0x7E, 0x0C, 
+0x12, 0x66, 0x52, 0x12, 0x08, 0x79, 0x3F, 0xF0, 0x00, 0x00, 0x90, 0x94, 0x93, 0x12, 0x08, 0x79, 
+0x01, 0x00, 0x00, 0x00, 0x7F, 0xB4, 0x7E, 0x0E, 0x12, 0x65, 0xDA, 0x22, 0x7F, 0xB0, 0x7E, 0x0E, 
+0x12, 0x38, 0x07, 0x90, 0x94, 0x8F, 0x22, 0x7F, 0xB0, 0x7E, 0x0C, 0x12, 0x38, 0x07, 0x90, 0xAA, 
+0xB9, 0x22, 0x12, 0x7F, 0xDE, 0xFE, 0x90, 0x93, 0x24, 0xE0, 0x54, 0xFE, 0x4E, 0xFE, 0xF0, 0xEF, 
+0x54, 0x04, 0xFF, 0xEE, 0x54, 0xFB, 0x4F, 0xF0, 0x12, 0x06, 0x89, 0xC3, 0x13, 0x30, 0xE0, 0x07, 
+0x12, 0x76, 0xE7, 0x90, 0x93, 0x25, 0xF0, 0x22, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x90, 0x02, 0x84, 
+0xEF, 0xF0, 0xEE, 0xA3, 0xF0, 0xA3, 0xE0, 0x44, 0x01, 0xF0, 0x22, 0xE4, 0x90, 0x93, 0x38, 0xF0, 
+0xA3, 0xF0, 0x90, 0x02, 0x86, 0xE0, 0x20, 0xE1, 0x24, 0xC3, 0x90, 0x93, 0x39, 0xE0, 0x94, 0xD0, 
+0x90, 0x93, 0x38, 0xE0, 0x94, 0x07, 0x40, 0x0A, 0x90, 0x01, 0xC1, 0xE0, 0x44, 0x04, 0xF0, 0x7F, 
+0x00, 0x22, 0x90, 0x93, 0x38, 0x12, 0x5A, 0xA6, 0x12, 0x95, 0x63, 0x80, 0xD5, 0x7F, 0x01, 0x22, 
+0x90, 0x02, 0x86, 0xE0, 0x20, 0xE2, 0x03, 0x7F, 0x04, 0x22, 0x90, 0x02, 0x86, 0xE0, 0x7F, 0x01, 
+0x20, 0xE1, 0x02, 0x7F, 0x02, 0x22, 0x90, 0x8E, 0xC9, 0xE0, 0xFF, 0x20, 0xE0, 0x07, 0x90, 0x01, 
+0x3F, 0xE0, 0x30, 0xE2, 0x14, 0xEF, 0x44, 0x01, 0x90, 0x8E, 0xC9, 0xF0, 0x90, 0x8E, 0xC3, 0xE0, 
+0xC4, 0x54, 0x0F, 0x20, 0xE0, 0x03, 0x7F, 0x00, 0x22, 0x7F, 0x01, 0x22, 0xEF, 0x90, 0x01, 0xC7, 
+0xB4, 0xA0, 0x05, 0x74, 0x04, 0xF0, 0x80, 0x03, 0x74, 0x08, 0xF0, 0x02, 0x6F, 0x95, 0x90, 0x94, 
+0xCB, 0x12, 0x8F, 0x70, 0x90, 0x94, 0xD3, 0xF0, 0x90, 0x94, 0xD3, 0xE0, 0xFD, 0xC3, 0x94, 0x06, 
+0x50, 0x28, 0x90, 0x94, 0xCC, 0xE0, 0x24, 0x04, 0xFF, 0x90, 0x94, 0xCB, 0xE0, 0x34, 0x00, 0xFE, 
+0x12, 0x6B, 0x7F, 0x90, 0x94, 0xD3, 0xE0, 0x24, 0xCD, 0xF5, 0x82, 0xE4, 0x34, 0x94, 0xF5, 0x83, 
+0xEF, 0xF0, 0x90, 0x94, 0xD3, 0xE0, 0x04, 0xF0, 0x80, 0xCE, 0x78, 0xCA, 0x7C, 0x8E, 0x7D, 0x01, 
+0x7B, 0x01, 0x7A, 0x94, 0x79, 0xCD, 0x71, 0xDF, 0x7F, 0x00, 0x70, 0x02, 0x7F, 0x01, 0x22, 0x7E, 
+0x00, 0x7F, 0x06, 0x12, 0x4A, 0xD6, 0xEF, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0xEF, 
+0x20, 0xE0, 0x05, 0x90, 0x93, 0x12, 0x80, 0x03, 0x90, 0x93, 0x13, 0xE0, 0x90, 0x8F, 0x95, 0xF0, 
+0x90, 0x8F, 0x95, 0xE0, 0x14, 0x60, 0x13, 0x14, 0x60, 0x14, 0x24, 0xFE, 0x60, 0x10, 0x14, 0x60, 
+0x09, 0x14, 0x60, 0x06, 0x24, 0x06, 0xE4, 0xFE, 0x80, 0x06, 0x7E, 0x04, 0x80, 0x02, 0x7E, 0x08, 
+0xAF, 0x06, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0x12, 0x83, 0xE8, 0x75, 0x43, 0x08, 0x7B, 0x01, 0x7A, 
+0x8F, 0x79, 0x8C, 0x02, 0x34, 0x62, 0x12, 0x83, 0xE8, 0x75, 0x43, 0x70, 0x7B, 0x01, 0x7A, 0x8E, 
+0x79, 0xF4, 0x02, 0x34, 0x62, 0xEF, 0x60, 0x07, 0x90, 0x93, 0x1A, 0xE0, 0xFF, 0x91, 0x36, 0x22, 
+0x12, 0x8C, 0xB7, 0xD1, 0x2B, 0x7B, 0xFF, 0x7A, 0x40, 0x79, 0x6A, 0x12, 0x6F, 0xF7, 0xD1, 0x44, 
+0x7A, 0x40, 0x79, 0x70, 0xB1, 0xFC, 0x78, 0x51, 0x7C, 0x93, 0x7D, 0x01, 0x7B, 0xFF, 0x7A, 0x40, 
+0x79, 0x80, 0xB1, 0xFC, 0xE4, 0x90, 0x93, 0x64, 0xF0, 0x90, 0x93, 0x38, 0x12, 0x6F, 0x85, 0xFD, 
+0x12, 0x8D, 0x1D, 0xEF, 0x64, 0x01, 0x60, 0x02, 0xA1, 0xE4, 0x12, 0x6E, 0x95, 0xCF, 0x24, 0x0E, 
+0xCF, 0x12, 0x6D, 0x64, 0xEF, 0x64, 0x3A, 0x60, 0x02, 0xA1, 0xE4, 0x12, 0x6E, 0x95, 0xCF, 0x24, 
+0x30, 0xCF, 0x12, 0x6D, 0x64, 0xEF, 0x64, 0x87, 0x60, 0x02, 0xA1, 0xE4, 0x90, 0x93, 0x64, 0x04, 
+0xF0, 0xE4, 0x90, 0x93, 0x61, 0xF0, 0xB1, 0xEA, 0x94, 0x10, 0x50, 0x1A, 0xD1, 0x1F, 0x12, 0x6E, 
+0xA0, 0xCD, 0x24, 0x38, 0x12, 0x6B, 0x71, 0x90, 0x93, 0x61, 0xE0, 0x24, 0x51, 0xF5, 0x82, 0xE4, 
+0x34, 0x93, 0xB1, 0xF1, 0x80, 0xE0, 0xE4, 0x90, 0x93, 0x62, 0xF0, 0x90, 0x93, 0x62, 0xE0, 0xFF, 
+0xC3, 0x94, 0x02, 0x40, 0x02, 0xA1, 0xE4, 0x75, 0xF0, 0x38, 0xEF, 0xD1, 0x03, 0x20, 0xE0, 0x02, 
+0xA1, 0xE4, 0xE4, 0x90, 0x93, 0x63, 0xF0, 0xD1, 0x0B, 0x90, 0x8E, 0xF5, 0x12, 0x49, 0x0C, 0xE0, 
+0xFE, 0x90, 0x93, 0x63, 0xE0, 0xC3, 0x9E, 0x40, 0x02, 0xA1, 0xDC, 0xEF, 0x75, 0xF0, 0x38, 0xA4, 
+0x24, 0x0C, 0xF9, 0x74, 0x8F, 0x35, 0xF0, 0xFA, 0x7B, 0x01, 0xE0, 0x75, 0xF0, 0x10, 0xA4, 0x29, 
+0xF9, 0xEA, 0x35, 0xF0, 0xFA, 0x78, 0x51, 0x7C, 0x93, 0xD1, 0x14, 0x60, 0x02, 0xA1, 0xCD, 0x90, 
+0x06, 0x33, 0xE0, 0x44, 0x01, 0x54, 0xFB, 0xF0, 0xE4, 0x90, 0x93, 0x61, 0xF0, 0xB1, 0xEA, 0x94, 
+0x06, 0x50, 0x14, 0xD1, 0x1F, 0x12, 0x6E, 0xA0, 0xCD, 0x24, 0x4A, 0x12, 0x6B, 0x71, 0x90, 0x93, 
+0x61, 0xD1, 0x3B, 0xB1, 0xF1, 0x80, 0xE6, 0xE4, 0x90, 0x93, 0x61, 0xF0, 0xB1, 0xEA, 0x94, 0x10, 
+0x50, 0x0C, 0x12, 0x6B, 0x5D, 0x90, 0x93, 0x61, 0xD1, 0x32, 0xB1, 0xF1, 0x80, 0xEE, 0xD1, 0x0B, 
+0xD1, 0x03, 0xFE, 0xC3, 0x13, 0x30, 0xE0, 0x19, 0xEF, 0x75, 0xF0, 0x38, 0xA4, 0x24, 0xFC, 0xF9, 
+0x74, 0x8E, 0x35, 0xF0, 0xFA, 0x7B, 0x01, 0x78, 0x41, 0x7C, 0x93, 0xD1, 0x14, 0x70, 0x45, 0x80, 
+0x00, 0x7B, 0x01, 0x7A, 0x93, 0x79, 0x3B, 0x90, 0x93, 0x68, 0x12, 0x49, 0x21, 0x7A, 0x93, 0x79, 
+0x51, 0x90, 0x93, 0x6B, 0x12, 0x49, 0x21, 0x90, 0x93, 0x62, 0xE0, 0x75, 0xF0, 0x38, 0xA4, 0x24, 
+0xF6, 0xF9, 0x74, 0x8E, 0x35, 0xF0, 0xFA, 0x90, 0x93, 0x6E, 0x12, 0x49, 0x21, 0xE4, 0x90, 0x93, 
+0x71, 0xF0, 0xA3, 0xF0, 0x7A, 0x93, 0x79, 0x41, 0x12, 0x54, 0x77, 0x80, 0x07, 0x90, 0x06, 0x33, 
+0xE0, 0x44, 0x05, 0xF0, 0x90, 0x93, 0x63, 0xE0, 0x04, 0xF0, 0x81, 0xF7, 0x90, 0x93, 0x62, 0xE0, 
+0x04, 0xF0, 0x81, 0xDB, 0x90, 0x93, 0x64, 0xE0, 0xFF, 0x22, 0x90, 0x93, 0x61, 0xE0, 0xFF, 0xC3, 
+0x22, 0xF5, 0x83, 0xEF, 0xF0, 0x90, 0x93, 0x61, 0xE0, 0x04, 0xF0, 0x22, 0x7E, 0x00, 0x7F, 0x10, 
+0x02, 0x06, 0x63, 0x90, 0x8E, 0xF4, 0x12, 0x49, 0x0C, 0xE0, 0x22, 0x90, 0x93, 0x62, 0xE0, 0xFF, 
+0x75, 0xF0, 0x38, 0x22, 0x7D, 0x01, 0x7E, 0x00, 0x7F, 0x10, 0x12, 0x4A, 0xD6, 0xEF, 0x22, 0x90, 
+0x93, 0x3A, 0xE0, 0xFD, 0x90, 0x93, 0x39, 0xE0, 0x2D, 0xFD, 0x22, 0x78, 0x3B, 0x7C, 0x93, 0x7D, 
+0x01, 0x22, 0xE0, 0x24, 0x41, 0xF5, 0x82, 0xE4, 0x34, 0x93, 0x22, 0xE0, 0x24, 0x3B, 0xF5, 0x82, 
+0xE4, 0x34, 0x93, 0x22, 0x78, 0x41, 0x7C, 0x93, 0x7D, 0x01, 0x7B, 0xFF, 0x22, 0x90, 0x93, 0x9F, 
+0x12, 0x49, 0x21, 0x90, 0x93, 0xA2, 0x12, 0x57, 0x05, 0x75, 0x43, 0x10, 0x7B, 0x01, 0x7A, 0x8F, 
+0x79, 0x64, 0x12, 0x34, 0x62, 0x90, 0x93, 0x9F, 0x12, 0x57, 0x05, 0x75, 0x43, 0x10, 0x7B, 0x01, 
+0x7A, 0x8F, 0x79, 0x74, 0x12, 0x34, 0x62, 0x90, 0x93, 0xA5, 0x12, 0x48, 0xF4, 0x90, 0x8F, 0x84, 
+0x12, 0x08, 0x6D, 0x90, 0x93, 0xA9, 0xE0, 0x90, 0x8F, 0x8B, 0xF0, 0x22, 0x90, 0x8E, 0xC9, 0xE0, 
+0x30, 0xE0, 0x03, 0x7F, 0x01, 0x22, 0x90, 0x06, 0x90, 0xE0, 0x20, 0xE5, 0x10, 0x90, 0x01, 0x3F, 
+0xE0, 0x30, 0xE2, 0x09, 0x90, 0x01, 0xC7, 0x74, 0x25, 0xF0, 0x7F, 0x01, 0x22, 0x7F, 0x00, 0x22, 
+0x90, 0x02, 0x09, 0xE0, 0x90, 0x93, 0x3C, 0xF0, 0x12, 0x06, 0x89, 0x90, 0x93, 0x12, 0x12, 0x76, 
+0xE6, 0x90, 0x93, 0x13, 0xF0, 0x22, 0x90, 0x02, 0x09, 0xE0, 0xFF, 0x12, 0x06, 0x89, 0xFE, 0xEF, 
+0x2E, 0x90, 0x93, 0x22, 0xF0, 0x22, 0xEF, 0x60, 0x08, 0x90, 0x93, 0x15, 0xE0, 0xFF, 0x12, 0x83, 
+0xFC, 0x22, 0xEF, 0x60, 0x0A, 0x90, 0x06, 0x31, 0xE0, 0x44, 0x80, 0xF0, 0x12, 0x7D, 0x6D, 0x22, 
+0xEF, 0x60, 0x06, 0x12, 0x85, 0x6D, 0x12, 0x7C, 0xA4, 0x22, 0xF1, 0x1B, 0x12, 0x87, 0xA1, 0x30, 
+0xE0, 0x18, 0x90, 0x8D, 0xFB, 0xE0, 0xFF, 0xC4, 0x54, 0x0F, 0x20, 0xE0, 0x0D, 0x90, 0x93, 0x4B, 
+0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 0x14, 0x12, 0x50, 0x31, 0x22, 0x22, 0x7E, 0x00, 0x7F, 0x08, 
+0x7D, 0x00, 0x7B, 0x01, 0x7A, 0x93, 0x79, 0x28, 0x12, 0x08, 0xAA, 0x90, 0x93, 0x29, 0x74, 0x08, 
+0xF0, 0xA3, 0x74, 0x03, 0xF0, 0x22, 0x90, 0x04, 0x1A, 0xE0, 0xF4, 0x60, 0x03, 0x7F, 0x00, 0x22, 
+0x90, 0x04, 0x1B, 0xE0, 0x54, 0x07, 0x64, 0x07, 0x7F, 0x01, 0x60, 0x02, 0x7F, 0x00, 0x22, 0xEF, 
+0x24, 0xFE, 0x60, 0x0B, 0x04, 0x70, 0x24, 0x90, 0x8E, 0x1B, 0x74, 0x02, 0xF0, 0x80, 0x13, 0xED, 
+0x70, 0x06, 0x90, 0x8E, 0xBC, 0xE0, 0x80, 0x02, 0xED, 0x14, 0x90, 0x8E, 0x1B, 0xF0, 0x90, 0x8E, 
+0x1B, 0xE0, 0xA3, 0xF0, 0x90, 0x8E, 0x12, 0xE0, 0x44, 0x08, 0xF0, 0x22, 0x7D, 0x2E, 0x7F, 0x6F, 
+0x12, 0x54, 0x6C, 0x7D, 0x02, 0x7F, 0x01, 0x02, 0x53, 0xF7, 0x12, 0x87, 0xC9, 0x7D, 0x0C, 0x7F, 
+0x01, 0x02, 0x53, 0xF7, 0x90, 0x93, 0x3F, 0xED, 0xF0, 0x90, 0x93, 0x3D, 0xEE, 0xF0, 0xA3, 0xEF, 
+0xF0, 0x12, 0x94, 0x74, 0x90, 0x93, 0x3D, 0x12, 0x6F, 0x85, 0xFD, 0x02, 0x5A, 0xAD, 0xAD, 0x07, 
+0x90, 0x90, 0x7A, 0x12, 0x5A, 0xA6, 0x90, 0x90, 0x7A, 0xE0, 0xFF, 0xAE, 0x05, 0x74, 0x04, 0x2E, 
+0x12, 0x86, 0xCB, 0xEF, 0xF0, 0x90, 0x90, 0x7A, 0xA3, 0xE0, 0xFF, 0x74, 0x05, 0x2E, 0xF5, 0x82, 
+0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xEF, 0xF0, 0x22, 0x7F, 0x50, 0x7E, 0x0C, 0x12, 0x37, 0xBC, 0x90, 
+0x94, 0x4A, 0xEF, 0xF0, 0x7F, 0x58, 0x7E, 0x0C, 0x12, 0x37, 0xBC, 0x90, 0x94, 0x4B, 0xEF, 0xF0, 
+0x90, 0x94, 0x8F, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 0x7F, 0x90, 0x94, 0x93, 0x12, 0x08, 0x79, 
+0x00, 0x00, 0x00, 0x17, 0x7F, 0x50, 0x7E, 0x0C, 0x12, 0x66, 0x52, 0x12, 0x08, 0x79, 0x00, 0x00, 
+0x00, 0x7F, 0x90, 0x94, 0x93, 0x12, 0x08, 0x79, 0x00, 0x00, 0x00, 0x17, 0x12, 0x87, 0x8B, 0x90, 
+0x06, 0x08, 0xE0, 0x90, 0x94, 0x60, 0xF0, 0x90, 0x06, 0xA1, 0xE0, 0xFE, 0x90, 0x06, 0xA0, 0x12, 
+0x7C, 0x9B, 0x90, 0x94, 0x62, 0xF0, 0xA3, 0xEF, 0x11, 0x4B, 0x90, 0x06, 0xA0, 0x74, 0x20, 0xF0, 
+0xA3, 0x74, 0x01, 0xF0, 0xE4, 0xFB, 0xFD, 0xFF, 0x02, 0x60, 0x6A, 0xF0, 0x90, 0x06, 0x08, 0xE0, 
+0x54, 0x7F, 0xF0, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x94, 0x4C, 0xE0, 0xFE, 
+0x90, 0x94, 0x49, 0xE0, 0xC3, 0x9E, 0x40, 0x04, 0x7F, 0x00, 0x80, 0x06, 0xEF, 0x7F, 0x01, 0x70, 
+0x01, 0xFF, 0xD0, 0xD0, 0x92, 0xAF, 0x22, 0xD3, 0x10, 0xAF, 0x01, 0xC3, 0xC0, 0xD0, 0x90, 0x05, 
+0x22, 0xE0, 0x90, 0x93, 0x4B, 0xF0, 0x7D, 0x1B, 0x7F, 0xFF, 0x12, 0x54, 0x6C, 0x90, 0x8D, 0xFC, 
+0xE0, 0xFF, 0x12, 0x7F, 0xD6, 0x90, 0x93, 0x4A, 0xEF, 0xF0, 0xE0, 0x24, 0x10, 0xF0, 0xE0, 0xFF, 
+0x12, 0x5D, 0x8F, 0xE0, 0x54, 0x80, 0x44, 0x04, 0xFE, 0x74, 0x00, 0x2F, 0x12, 0x5D, 0x91, 0xEE, 
+0xF0, 0x90, 0x93, 0x4B, 0xE0, 0xFF, 0x7D, 0x1C, 0x12, 0x54, 0x6C, 0x90, 0x93, 0x4A, 0xE0, 0x24, 
+0xF0, 0xF0, 0xE4, 0xA3, 0xF0, 0x90, 0x93, 0x4B, 0xE0, 0x04, 0xF0, 0xE0, 0xB4, 0x1E, 0xF6, 0xD0, 
+0xD0, 0x92, 0xAF, 0x22, 0xA3, 0xE0, 0xFE, 0x24, 0x28, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 
+0xE0, 0xFF, 0x74, 0x29, 0x2E, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0xFD, 0x74, 0x2C, 
+0x2E, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0xF5, 0x83, 0xE0, 0xFB, 0x22, 0xF0, 0xA3, 0xEF, 0xF0, 0x74, 
+0x02, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 0xFB, 0xF5, 0x83, 0xE0, 0x54, 0x0F, 0x33, 0x33, 0x33, 0x54, 
+0xF8, 0xFF, 0x74, 0x03, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 0xFB, 0xF5, 0x83, 0x22, 0x90, 0x93, 0x3C, 
+0xE4, 0x75, 0xF0, 0x10, 0x12, 0x08, 0xD6, 0xE4, 0x90, 0x93, 0x3E, 0xF0, 0x22, 0x90, 0x93, 0x3C, 
+0xA3, 0xE0, 0x24, 0x03, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0x22, 0x90, 0x93, 0x59, 0xE0, 0xFF, 0x24, 
+0xDF, 0xF5, 0x82, 0xE4, 0x34, 0x8F, 0xF5, 0x83, 0x22, 0x90, 0x94, 0xFB, 0xE0, 0xFE, 0xA3, 0xE0, 
+0xFF, 0x90, 0x94, 0xFE, 0xE0, 0xFD, 0x90, 0x94, 0xFD, 0xE0, 0x2D, 0x22, 0x90, 0x93, 0x3C, 0xA3, 
+0xE0, 0xFF, 0xA3, 0xE0, 0xFE, 0x2F, 0x22, 0x90, 0x93, 0x3C, 0xA3, 0xE0, 0x24, 0x01, 0xF5, 0x82, 
+0xE4, 0x22, 0x7D, 0x01, 0x7B, 0x01, 0x7A, 0x8E, 0x79, 0xE6, 0x7E, 0x00, 0x7F, 0x04, 0x02, 0x4A, 
+0xD6, 0x75, 0xF0, 0x20, 0xA4, 0x24, 0x0E, 0xF9, 0x74, 0x91, 0x35, 0xF0, 0xFA, 0x7B, 0x01, 0x22, 
+0x90, 0x94, 0x75, 0xE0, 0xFE, 0xA3, 0xE0, 0xFF, 0x22, 0xE0, 0x90, 0x01, 0xBA, 0xF0, 0x90, 0x8E, 
+0x17, 0xE0, 0x90, 0x01, 0xBB, 0xF0, 0x22, 0x90, 0x93, 0x57, 0xEF, 0xF0, 0x90, 0x93, 0x17, 0xE0, 
+0x90, 0x04, 0x25, 0x22, 0x90, 0x94, 0xA2, 0x12, 0x49, 0x21, 0xE4, 0x90, 0x94, 0xA5, 0xF0, 0xA3, 
+0x22, 0x7F, 0x00, 0x7E, 0x0C, 0x12, 0x38, 0x07, 0x7F, 0x00, 0x7E, 0x0E, 0x22, 0xFF, 0xEE, 0x54, 
+0x3F, 0x90, 0x8E, 0x50, 0xF0, 0xA3, 0xEF, 0xF0, 0x22, 0x24, 0x30, 0xF9, 0xE4, 0x34, 0xFC, 0xFA, 
+0x7B, 0x01, 0x22, 0xF0, 0xEE, 0x54, 0x20, 0xFE, 0xEF, 0x54, 0xDF, 0x4E, 0x22, 0x90, 0x95, 0x35, 
+0xF0, 0xE0, 0x90, 0x04, 0x54, 0xF0, 0x22, 0x90, 0x95, 0x1E, 0xE0, 0xFF, 0x74, 0x64, 0xD3, 0x9F, 
+0x22, 0x90, 0x95, 0x1E, 0xE0, 0xFF, 0x74, 0x24, 0xD3, 0x9F, 0x22, 0x2F, 0xF8, 0xE6, 0xFE, 0xED, 
+0xF4, 0x5E, 0xFE, 0xF6, 0x22, 0x54, 0x10, 0xFD, 0xEF, 0x54, 0xEF, 0x4D, 0xFF, 0x22, 0x54, 0x40, 
+0xFD, 0xEF, 0x54, 0xBF, 0x4D, 0xFF, 0x22, 0x74, 0x05, 0x2D, 0xF5, 0x82, 0xE4, 0x34, 0xFC, 0x22, 
+0xF0, 0xEE, 0x54, 0x80, 0xFE, 0xEF, 0x54, 0x7F, 0x22, 0x7F, 0xB4, 0x7E, 0x08, 0x12, 0x37, 0xBC, 
+0xEF, 0x22, 0x54, 0x04, 0xFD, 0xEF, 0x54, 0xFB, 0x4D, 0x22, 0xE4, 0x75, 0xF0, 0x20, 0x02, 0x08, 
+0xD6, 0x7F, 0x01, 0x7E, 0x00, 0x02, 0x3C, 0xEC, 0x90, 0x8D, 0xFB, 0xE0, 0xFF, 0xC3, 0x13, 0x22, 
+0xE0, 0xFC, 0xA3, 0xE0, 0xFD, 0xEC, 0xFF, 0x22, 0xE3, 0x90, 
+};
+u4Byte ArrayLength_MP_8821A_FW_WoWLAN = 27274;
+
+
+void
+ODM_ReadFirmware_MP_8821A_FW_WoWLAN(
+     IN   PDM_ODM_T    pDM_Odm,
+     OUT  u1Byte       *pFirmware,
+     OUT  u4Byte       *pFirmwareSize
+)
+{
+#if (DM_ODM_SUPPORT_TYPE & (ODM_CE))		
+	*((SIZE_PTR *)pFirmware) = (SIZE_PTR)Array_MP_8821A_FW_WoWLAN;
+#else
+	ODM_MoveMemory(pDM_Odm, pFirmware, Array_MP_8821A_FW_WoWLAN, ArrayLength_MP_8821A_FW_WoWLAN);
+#endif
+	*pFirmwareSize = ArrayLength_MP_8821A_FW_WoWLAN;
+}
+
+#ifdef CONFIG_MP_INCLUDED
+u8 Rtl8821A_BT_MP_Patch_FW [Rtl8812BFwBTImgArrayLength] = {
+0x52, 0x65, 0x61, 0x6c, 0x74, 0x65, 0x63, 0x68, 0x8e, 0x50, 0x2f, 0x80, 0x02, 0x00, 0x01, 0x00, 0x02, 0x00, 0x1c, 0x3e, 0x98, 0x3e, 0x30, 0x00, 0x00, 0x00, 0xc0, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfb, 0x63, 0x09, 0x62, 0x08, 0xd1, 0x07, 0xd0, 0x00, 0x6a, 0x5f, 0xb3, 0x40, 0xdb, 0x5f, 0xb4, 0x5f, 0xb3, 0xa0, 0x9c, 0x40, 0xc3, 0x5f, 0xb2, 0xac, 0xea, 0x5f, 0xb5, 0xae, 0xea, 0x03, 0x2a, 0x40, 0xdc, 0x01, 0x6a, 0x40, 0xc3, 0x5d, 0xb2, 0x40, 0x9a, 0x5d, 0xb3, 0x5d, 0xb0, 0x42, 0x34, 0x82, 0x34, 0x80, 0xcb, 0x5c, 0xb3, 0x40, 0xcb, 0x5c, 0xb3, 0x5d, 0xb2, 0x80, 0x18, 0x90, 0x2d, 0x60, 0xda, 0x5c, 0xb3, 0x5c, 0xb2, 0x60, 0xda, 0x5c, 0xb3, 0x5d, 0xb2, 0x60, 0xda, 0x5d, 0xb3, 0x5d, 0xb2, 0x60, 0xda, 0x5d, 0xb3, 0x5e, 0xb2, 0x60, 0xda, 0x5e, 0xb3, 0x5e, 0xb2, 0x60, 0xda, 0x5e, 0xb3, 0x5f, 0xb2, 0x60, 0xda, 0x5f, 0xb3, 0x5f, 0xb2, 0x60, 0xda, 0x45, 0xf1, 0x09, 0x6a, 0x00, 0xf1, 0x50, 0xc8, 0x5d, 0xb2, 0x00, 0xf4, 0x00, 0x6b, 0x02, 0x69, 0x43, 0xd8, 0x5c, 0xb2, 0xa0, 0xf0, 0x76, 0xc8, 0x2b, 0xe9, 0x44, 0xd8, 0x00, 0x6a, 0x45, 0xd8, 0x46, 0xd8, 0x47, 0xd8, 0x48, 0xd8, 0x49, 0xd8, 0x02, 0x6a, 0x80, 0xf1, 0x42, 0xc0, 0x00, 0xf2, 0x00, 0x6a, 0xa0, 0xf0, 0x52, 0xc8, 0x90, 0x6a, 0xa0, 0xf0, 0x54, 0xc8, 0xa0, 0xf0, 0x58, 0xc8, 0xe0, 0xf1, 0x42, 0xa0, 0x0f, 0x6b, 0x6b, 0xeb, 0x2c, 0xea, 0x6c, 0xea, 0x10, 0x6b, 0x6d, 0xea, 0x7d, 0x67, 0x50, 0xc3, 0xe0, 0xf1, 0x42, 0xc0, 0x4b, 0xb3, 0x4c, 0xb2, 0x60, 0xda, 0x4c, 0xb3, 0x4c, 0xb2, 0x60, 0xda, 0x4c, 0xb3, 0x4d, 0xb2, 0x60, 0xda, 0x4d, 0xb3, 0x4d, 0xb2, 0x60, 0xda, 0x4d, 0xb3, 0x4e, 0xb2, 0x60, 0xda, 0x4e, 0xb3, 0x4e, 0xb2, 0x60, 0xda, 0x4e, 0xb3, 0x4f, 0xb2, 0x60, 0xda, 0x4f, 0xb3, 0x4f, 0xb2, 0x60, 0xda, 0x4f, 0xb3, 0x50, 0xb2, 0x60, 0xda, 0x50, 0xb3, 0x50, 0xb2, 0x60, 0xda, 0x50, 0xb3, 0x51, 0xb2, 0x60, 0xda, 0x51, 0xb3, 0x51, 0xb2, 0x60, 0xda, 0x51, 0xb3, 0x52, 0xb2, 0x80, 0x18, 0x2e, 0x32, 0x60, 0xda, 0x51, 0xb3, 0x83, 0xa3, 0x80, 0x6b, 0x6b
+, 0xeb, 0x8c, 0xeb, 0xff, 0x6c, 0x8c, 0xeb, 0x4e, 0xb2, 0x1f, 0x23, 0xe0, 0xf1, 0x63, 0xa0, 0xff, 0x73, 0x4d, 0xb3, 0x0d, 0x61, 0x80, 0xa3, 0x08, 0x6b, 0x8c, 0xeb, 0x05, 0x23, 0x80, 0xa2, 0x01, 0x6b, 0x8d, 0xeb, 0x60, 0xc2, 0x1a, 0x10, 0x60, 0xa2, 0x6c, 0xe9, 0x20, 0xc2, 0x16, 0x10, 0x40, 0xa2, 0xa0, 0xa3, 0x01, 0x6c, 0x4c, 0xec, 0x0f, 0x6a, 0xac, 0xea, 0x8c, 0x34, 0x4d, 0xec, 0x10, 0x6a, 0x4b, 0xea, 0xac, 0xea, 0x8d, 0xea, 0x08, 0x10, 0x60, 0xa2, 0x6c, 0xe9, 0x20, 0xc2, 0x3d, 0xb3, 0x80, 0xa3, 0x09, 0x6a, 0x4b, 0xea, 0x8c, 0xea, 0x40, 0xc3, 0x09, 0x97, 0x08, 0x91, 0x07, 0x90, 0x00, 0xef, 0x05, 0x63, 0x00, 0x65, 0x4c, 0x8b, 0x10, 0x80, 0x54, 0x8b, 0x10, 0x80, 0x08, 0x94, 0x10, 0x80, 0xff, 0xff, 0xff, 0x00, 0xee, 0xff, 0xc0, 0x00, 0x18, 0xde, 0x10, 0x80, 0x42, 0x00, 0x11, 0x80, 0x48, 0x00, 0x11, 0x80, 0x40, 0x00, 0x11, 0x80, 0xb5, 0xc4, 0x10, 0x80, 0xc0, 0x07, 0x11, 0x80, 0x39, 0xcd, 0x10, 0x80, 0xfc, 0x06, 0x11, 0x80, 0x71, 0xc1, 0x10, 0x80, 0xf4, 0x18, 0x11, 0x80, 0xe9, 0xc0, 0x10, 0x80, 0x50, 0x19, 0x11, 0x80, 0x59, 0xcc, 0x10, 0x80, 0x8c, 0x07, 0x11, 0x80, 0x59, 0xb8, 0x10, 0x80, 0xe0, 0x06, 0x11, 0x80, 0x89, 0xb8, 0x10, 0x80, 0xc0, 0x06, 0x11, 0x80, 0x19, 0xb9, 0x10, 0x80, 0x04, 0x08, 0x11, 0x80, 0x14, 0xc0, 0x52, 0x02, 0x58, 0xd5, 0xc8, 0x19, 0x0d, 0xb6, 0x10, 0x80, 0x38, 0x1b, 0x11, 0x80, 0xb9, 0xd5, 0x10, 0x80, 0xc8, 0x1a, 0x11, 0x80, 0x99, 0xcd, 0x10, 0x80, 0x6c, 0x07, 0x11, 0x80, 0x6d, 0xce, 0x10, 0x80, 0x18, 0x19, 0x11, 0x80, 0xb1, 0xb8, 0x10, 0x80, 0x90, 0x07, 0x11, 0x80, 0xe5, 0xb8, 0x10, 0x80, 0x24, 0x08, 0x11, 0x80, 0xbd, 0xc6, 0x10, 0x80, 0x5c, 0x07, 0x11, 0x80, 0x45, 0xd6, 0x10, 0x80, 0xd0, 0x1a, 0x11, 0x80, 0x69, 0xca, 0x10, 0x80, 0xec, 0x18, 0x11, 0x80, 0xe9, 0xb8, 0x10, 0x80, 0xf0, 0x18, 0x11, 0x80, 0x3d, 0xc9, 0x10, 0x80, 0x5c, 0x1b, 0x11, 0x80, 0x21, 0xb9, 0x10, 0x80, 0xe8, 0x19, 0x11, 0x80, 0xa1, 0xcb, 0x10, 0x80, 0xd0, 0x06, 0x11, 0x80, 0x2c, 0x3a, 0x11, 0x80, 0x2b, 0x02, 0x11, 0x80, 0xe8, 0x3a, 0x11, 0x80, 0xfd, 0x63, 0x05, 0x62, 0x04, 0xd0, 0x0a, 0xb0, 0x90, 0x67, 0x00, 0x6d, 
+0x00, 0x18, 0x29, 0x34, 0x38, 0x6e, 0x01, 0x6a, 0x4b, 0xea, 0x47, 0xd8, 0x70, 0x6a, 0x43, 0xc0, 0x0a, 0x6a, 0x4c, 0xc0, 0x08, 0x6a, 0x4d, 0xc0, 0x05, 0x97, 0x04, 0x90, 0x00, 0xef, 0x03, 0x63, 0xe8, 0x93, 0x11, 0x80, 0xd6, 0x63, 0x53, 0x62, 0x52, 0xd1, 0x51, 0xd0, 0x00, 0xf4, 0x05, 0x6a, 0x7d, 0x67, 0x52, 0xcb, 0x0d, 0x6a, 0x20, 0xf0, 0x46, 0xc3, 0x20, 0xf0, 0x07, 0x04, 0x71, 0xb5, 0x00, 0x18, 0xf6, 0x33, 0x06, 0x6e, 0x9d, 0x67, 0x01, 0x6a, 0x00, 0x6b, 0x20, 0xf0, 0x4f, 0xc4, 0x20, 0xf0, 0x53, 0xc4, 0x6c, 0xb2, 0x20, 0xf0, 0x6d, 0xc4, 0x20, 0xf0, 0x6e, 0xc4, 0x20, 0xf0, 0x70, 0xc4, 0x20, 0xf0, 0x71, 0xc4, 0x20, 0xf0, 0x72, 0xc4, 0xc0, 0xf1, 0x6a, 0xc2, 0xc0, 0xf1, 0x7e, 0xc2, 0x03, 0x6b, 0x02, 0x6c, 0xc0, 0xf1, 0x7c, 0xc2, 0x64, 0xb3, 0xc0, 0xf1, 0x89, 0xc2, 0xc0, 0xf1, 0x88, 0xc2, 0xc0, 0xf1, 0x9d, 0xc2, 0x80, 0xc3, 0x61, 0xb3, 0x00, 0x6c, 0x80, 0xdb, 0x81, 0xdb, 0x60, 0xf1, 0x70, 0xa2, 0x44, 0x67, 0x02, 0x73, 0x07, 0x60, 0x03, 0x73, 0xa0, 0xf0, 0x07, 0x60, 0x01, 0x73, 0xa0, 0xf0, 0x04, 0x60, 0x0f, 0x10, 0xc0, 0xf2, 0x0c, 0x6b, 0x78, 0xea, 0x58, 0xb4, 0x12, 0xeb, 0x6d, 0xe4, 0xc0, 0xf0, 0x68, 0xa3, 0x80, 0xf0, 0x19, 0x2b, 0x01, 0x4a, 0xff, 0x6b, 0x6c, 0xea, 0x0a, 0x5a, 0xf1, 0x61, 0x00, 0x18, 0xbd, 0x5e, 0x09, 0x04, 0x4a, 0xd2, 0x80, 0xf0, 0x10, 0x2a, 0x7d, 0x67, 0x20, 0xf0, 0x6d, 0xa3, 0x5d, 0x67, 0x9d, 0x67, 0x20, 0xf0, 0x4e, 0xa2, 0x20, 0xf0, 0x8f, 0xa4, 0x4e, 0xd3, 0x7d, 0x67, 0x4f, 0xd2, 0x4d, 0xd4, 0x5d, 0x67, 0x20, 0xf0, 0x93, 0xa3, 0x20, 0xf0, 0x50, 0xa2, 0x20, 0xf0, 0x02, 0x05, 0x4b, 0xd4, 0x4c, 0xd2, 0x20, 0xf0, 0x12, 0xa3, 0x20, 0xf0, 0x31, 0xa3, 0x00, 0x18, 0xcb, 0xe1, 0x08, 0x04, 0x02, 0x22, 0x4a, 0xd2, 0x70, 0x10, 0x5d, 0x67, 0x00, 0x30, 0x2d, 0xe8, 0x31, 0xaa, 0xc0, 0xf2, 0x0c, 0x6a, 0x38, 0xb5, 0x58, 0xe9, 0x3b, 0xb2, 0x12, 0xe9, 0x45, 0xe1, 0xe0, 0xf0, 0x88, 0x41, 0x00, 0x18, 0xf6, 0x33, 0x06, 0x6e, 0x4f, 0x93, 0x4e, 0x94, 0x60, 0x32, 0x8d, 0xea, 0x60, 0xf2, 0x58, 0xc9, 0x5d, 0x67, 0x30, 0xf1, 0x64, 0x42, 0x40, 0xa3, 0x7d, 0x67, 0x30, 0xf1, 0x80, 0x43, 0xe0, 0xf0, 0x55, 0xc1, 0x60, 0xa4
+, 0x9d, 0x67, 0x20, 0xf1, 0x4c, 0x44, 0xe0, 0xf0, 0x77, 0xc1, 0x80, 0xa2, 0x7d, 0x67, 0xe0, 0xf0, 0x98, 0xc1, 0x20, 0xf0, 0x40, 0xa3, 0xe0, 0xf0, 0x4e, 0xc1, 0x01, 0x6a, 0x60, 0xf2, 0x5a, 0xc1, 0x00, 0x18, 0x3a, 0x9d, 0x91, 0xab, 0x9d, 0x67, 0x20, 0xf1, 0x48, 0x44, 0x80, 0xa2, 0x02, 0x32, 0x5e, 0x32, 0x00, 0xf1, 0x8c, 0xc1, 0x13, 0x22, 0xef, 0xf7, 0x1f, 0x6a, 0x0c, 0xea, 0x01, 0x6b, 0x80, 0xf0, 0x44, 0xc9, 0x06, 0x6c, 0x04, 0xd3, 0xfc, 0x6d, 0x1e, 0xb3, 0x20, 0xf5, 0x06, 0x6e, 0x20, 0xf5, 0x17, 0x6f, 0x05, 0xd3, 0x20, 0x18, 0xc5, 0x30, 0x06, 0xd2, 0x06, 0x10, 0x5d, 0x67, 0x20, 0xf1, 0x68, 0x42, 0x40, 0xab, 0x80, 0xf0, 0x44, 0xc9, 0x00, 0x18, 0xe6, 0xa0, 0x09, 0x04, 0x02, 0x67, 0x0e, 0x22, 0x7d, 0x67, 0x20, 0xf0, 0x80, 0xa3, 0xe0, 0xf0, 0xa3, 0xa1, 0x00, 0x18, 0xa8, 0xe1, 0x00, 0x65, 0x0a, 0xb4, 0x00, 0x18, 0xa4, 0xe1, 0x00, 0x65, 0x4a, 0xd0, 0x08, 0x10, 0x5d, 0x67, 0x91, 0xaa, 0x20, 0x18, 0x21, 0x26, 0x01, 0x6d, 0x02, 0x10, 0x0c, 0x6b, 0x4a, 0xd3, 0x4a, 0x92, 0x53, 0x97, 0x52, 0x91, 0x51, 0x90, 0x00, 0xef, 0x2a, 0x63, 0xfc, 0x93, 0x11, 0x80, 0x80, 0x50, 0x11, 0x80, 0x09, 0x50, 0x11, 0x80, 0xb0, 0x51, 0x11, 0x80, 0x74, 0x54, 0x11, 0x80, 0xb0, 0xe7, 0x04, 0x80, 0xfd, 0x63, 0x05, 0x62, 0x10, 0xb3, 0x00, 0x6d, 0xc0, 0xf1, 0xaa, 0xc3, 0xc0, 0xf1, 0xbe, 0xc3, 0xff, 0x6a, 0x03, 0x6d, 0x8c, 0xea, 0xc0, 0xf1, 0xbc, 0xc3, 0x02, 0x6c, 0x0b, 0xb5, 0xc0, 0xf1, 0x89, 0xc3, 0xc0, 0xf1, 0x88, 0xc3, 0xc0, 0xf1, 0x9d, 0xc3, 0x60, 0xf1, 0x40, 0xc3, 0x80, 0xc5, 0x00, 0x18, 0x82, 0xa9, 0x82, 0x67, 0x06, 0xb2, 0x00, 0x6b, 0x60, 0xda, 0x61, 0xda, 0x05, 0x97, 0x00, 0xef, 0x03, 0x63, 0x80, 0x50, 0x11, 0x80, 0x09, 0x50, 0x11, 0x80, 0xb0, 0x51, 0x11, 0x80, 0xdc, 0x63, 0x47, 0x62, 0x00, 0xf4, 0x06, 0x6a, 0x7d, 0x67, 0x4a, 0xcb, 0x03, 0x6a, 0x56, 0xc3, 0x13, 0x6a, 0x59, 0xc3, 0x1d, 0xb2, 0x6d, 0xa2, 0x08, 0x73, 0x1a, 0x60, 0xff, 0x6c, 0x09, 0x4c, 0x98, 0xeb, 0x1b, 0xb2, 0x01, 0x6d, 0x12, 0xec, 0x91, 0xe2, 0x20, 0xf1, 0xcf, 0xa4, 0xac, 0xee, 0x0f, 0x26, 0x00, 0xf1, 0x52, 0xaa, 0x47, 0xeb, 0xac, 0xea, 0x0a, 0x22, 0x20, 0xf1, 0x4c, 
+0xac, 0x7d, 0x67, 0x05, 0x04, 0x57, 0xc3, 0x42, 0x32, 0x58, 0xc3, 0x00, 0x18, 0x47, 0x4f, 0x04, 0x05, 0x0e, 0xb2, 0x4c, 0xa2, 0x0a, 0x72, 0x14, 0x60, 0xc0, 0xf2, 0x0c, 0x6b, 0x78, 0xea, 0x0d, 0xb3, 0x12, 0xea, 0x49, 0xe3, 0xe0, 0xf0, 0x66, 0xa2, 0x01, 0x73, 0x0a, 0x61, 0x60, 0xf2, 0x56, 0xaa, 0x7d, 0x67, 0x05, 0x04, 0x57, 0xc3, 0x42, 0x32, 0x58, 0xc3, 0x00, 0x18, 0x47, 0x4f, 0x04, 0x05, 0x47, 0x97, 0x00, 0xef, 0x24, 0x63, 0x00, 0x65, 0xe8, 0x93, 0x11, 0x80, 0x00, 0x3b, 0x11, 0x80, 0x74, 0x54, 0x11, 0x80, 0xdc, 0x63, 0x47, 0x62, 0x46, 0xd0, 0x00, 0x6a, 0x18, 0xb3, 0x9d, 0x67, 0x40, 0xdb, 0x41, 0xdb, 0x04, 0xf0, 0x06, 0x6b, 0x68, 0xcc, 0x54, 0xc4, 0x56, 0xc4, 0x57, 0xc4, 0x58, 0xc4, 0x59, 0xc4, 0x5a, 0xc4, 0x5b, 0xc4, 0x5c, 0xc4, 0x5d, 0xc4, 0x5e, 0xc4, 0x5f, 0xc4, 0x0f, 0x6b, 0x07, 0x6a, 0x04, 0x00, 0x72, 0xc4, 0x20, 0xf0, 0x40, 0xc4, 0x20, 0x6b, 0x03, 0x6a, 0x73, 0xc4, 0x75, 0xc4, 0x20, 0xf0, 0x41, 0xc4, 0x00, 0x18, 0xb5, 0xc9, 0x90, 0x67, 0x7d, 0x67, 0x04, 0xf0, 0x0a, 0x6a, 0x48, 0xcb, 0x01, 0x6a, 0x90, 0x67, 0x52, 0xc3, 0x00, 0x18, 0x2d, 0xca, 0x53, 0xc3, 0x47, 0x97, 0x46, 0x90, 0x00, 0xef, 0x24, 0x63, 0x00, 0x65, 0xb0, 0x51, 0x11, 0x80, 0xdc, 0x63, 0x47, 0x62, 0x00, 0x6a, 0x21, 0xb3, 0x9d, 0x67, 0x40, 0xdb, 0x41, 0xdb, 0x04, 0xf0, 0x0d, 0x6b, 0x68, 0xcc, 0x19, 0x6b, 0x72, 0xc4, 0x60, 0x6b, 0x6b, 0xeb, 0x73, 0xc4, 0x75, 0xc4, 0x1b, 0xb3, 0x54, 0xc4, 0x56, 0xc4, 0x57, 0xc4, 0x58, 0xc4, 0x94, 0xa3, 0xbd, 0x67, 0x5f, 0xc5, 0x99, 0xc5, 0x95, 0xa3, 0x20, 0xf0, 0x40, 0xc5, 0x20, 0xf0, 0x42, 0xc5, 0x9a, 0xc5, 0x96, 0xa3, 0x20, 0xf0, 0x44, 0xc5, 0x20, 0xf0, 0x45, 0xc5, 0x9b, 0xc5, 0x97, 0xa3, 0x20, 0xf0, 0x47, 0xc5, 0x20, 0xf0, 0x49, 0xc5, 0x9c, 0xc5, 0x98, 0xa3, 0x79, 0xa3, 0x9d, 0xc5, 0x7e, 0xc5, 0x02, 0x6b, 0x20, 0xf0, 0x61, 0xc5, 0x20, 0xf0, 0x63, 0xc5, 0x1e, 0x6b, 0x20, 0xf0, 0x66, 0xc5, 0x12, 0x6b, 0x20, 0xf0, 0x68, 0xc5, 0x20, 0xf0, 0x6a, 0xc5, 0x20, 0xf0, 0x4b, 0xc5, 0x00, 0x18, 0xee, 0xc7, 0x04, 0x04, 0x47, 0x97, 0x00, 0xef, 0x24, 0x63, 0xb0, 0x51, 0x11, 0x80, 0xe8, 0x93, 0x11, 0x80, 0xdc, 0x63, 0x47
+, 0x62, 0x0c, 0xb2, 0x00, 0x6b, 0x60, 0xda, 0x61, 0xda, 0x7d, 0x67, 0x04, 0xf0, 0x1d, 0x6a, 0x48, 0xcb, 0x01, 0x6a, 0x52, 0xc3, 0x08, 0xb2, 0x41, 0xaa, 0x7f, 0x6b, 0x04, 0x04, 0x4a, 0x32, 0x6c, 0xea, 0x7d, 0x67, 0x00, 0x18, 0x51, 0xc5, 0x53, 0xc3, 0x47, 0x97, 0x00, 0xef, 0x24, 0x63, 0x00, 0x65, 0xb0, 0x51, 0x11, 0x80, 0xe8, 0x93, 0x11, 0x80, 0xdb, 0x63, 0x49, 0x62, 0x48, 0xd1, 0x47, 0xd0, 0x00, 0x69, 0x0e, 0xb2, 0x7d, 0x67, 0x20, 0xda, 0x21, 0xda, 0x04, 0xf0, 0x1f, 0x6a, 0x48, 0xcb, 0x0b, 0xb2, 0x81, 0xf1, 0x48, 0xaa, 0x0b, 0xb0, 0x32, 0xc3, 0x04, 0x04, 0x00, 0x18, 0xcb, 0xc4, 0x4b, 0xd8, 0x64, 0xa0, 0x41, 0x6a, 0x4b, 0xea, 0x6c, 0xea, 0x29, 0xc0, 0x44, 0xc0, 0x49, 0x97, 0x48, 0x91, 0x47, 0x90, 0x00, 0xef, 0x25, 0x63, 0xb0, 0x51, 0x11, 0x80, 0x00, 0x3b, 0x11, 0x80, 0xe8, 0x93, 0x11, 0x80, 0xdc, 0x63, 0x47, 0x62, 0x46, 0xd0, 0x00, 0x68, 0x0b, 0xb2, 0x7d, 0x67, 0x00, 0xda, 0x01, 0xda, 0x04, 0xf0, 0x1f, 0x6a, 0x12, 0xc3, 0x04, 0x04, 0x00, 0x18, 0xcb, 0xc4, 0x48, 0xcb, 0x07, 0xb2, 0x84, 0xa2, 0x41, 0x6b, 0x6b, 0xeb, 0x8c, 0xeb, 0x64, 0xc2, 0x09, 0xc2, 0x47, 0x97, 0x46, 0x90, 0x00, 0xef, 0x24, 0x63, 0xb0, 0x51, 0x11, 0x80, 0xe8, 0x93, 0x11, 0x80, 0xdc, 0x63, 0x47, 0x62, 0x1c, 0xb2, 0x00, 0x6b, 0x60, 0xda, 0x61, 0xda, 0x1b, 0xb2, 0x64, 0xa2, 0x07, 0x6d, 0x6e, 0x34, 0xac, 0xec, 0x05, 0x54, 0x06, 0x61, 0x39, 0x6c, 0x8b, 0xec, 0x6c, 0xec, 0x20, 0x6b, 0x6d, 0xec, 0x84, 0xc2, 0x15, 0xb2, 0x64, 0xa2, 0x07, 0x6c, 0x14, 0xb5, 0x6e, 0x33, 0x8c, 0xeb, 0x6d, 0xe5, 0x60, 0xa3, 0xc3, 0xa2, 0x6c, 0xec, 0x0f, 0x6b, 0x6b, 0xeb, 0x84, 0x35, 0xcc, 0xeb, 0xad, 0xeb, 0x63, 0xc2, 0xbd, 0x67, 0x04, 0xf0, 0x1e, 0x6b, 0x68, 0xcd, 0x03, 0x6b, 0x72, 0xc5, 0x61, 0xaa, 0x7f, 0x6d, 0x6a, 0x33, 0xac, 0xeb, 0xbd, 0x67, 0x73, 0xc5, 0x40, 0x9a, 0x95, 0xc5, 0x04, 0x04, 0x42, 0x32, 0x00, 0x18, 0x07, 0xc5, 0x54, 0xc5, 0x47, 0x97, 0x00, 0xef, 0x24, 0x63, 0x00, 0x65, 0xb0, 0x51, 0x11, 0x80, 0xe8, 0x93, 0x11, 0x80, 0x04, 0xdc, 0x10, 0x80, 0xfd, 0x63, 0x05, 0x62, 0x57, 0x6c, 0x00, 0x18, 0xa1, 0xa5, 0x01, 0x6d, 0xff, 0xf7, 0x1f, 0x6b, 0x02, 0xf1, 
+0x01, 0x6e, 0x4c, 0xeb, 0xcb, 0xee, 0x6c, 0xee, 0x57, 0x6c, 0x00, 0x18, 0x01, 0xa6, 0x01, 0x6d, 0x00, 0x6c, 0xa4, 0x67, 0x00, 0x18, 0x01, 0xa6, 0xc4, 0x67, 0x06, 0xb2, 0x84, 0xa2, 0x41, 0x6b, 0x6b, 0xeb, 0x8c, 0xeb, 0x64, 0xc2, 0x00, 0x6b, 0x69, 0xc2, 0x05, 0x97, 0x00, 0xef, 0x03, 0x63, 0x00, 0x65, 0xe8, 0x93, 0x11, 0x80, 0xfc, 0x63, 0x07, 0x62, 0x06, 0xd1, 0x05, 0xd0, 0x7c, 0x6c, 0x00, 0x18, 0xa1, 0xa5, 0x01, 0x6d, 0x79, 0x6c, 0x01, 0x6d, 0x00, 0x18, 0xa1, 0xa5, 0x22, 0x67, 0x1e, 0xb3, 0xff, 0xf7, 0x1f, 0x68, 0x80, 0x9b, 0x0c, 0xe9, 0x4c, 0xe8, 0x4b, 0x9b, 0x96, 0x34, 0xe3, 0xf7, 0x1f, 0x6d, 0x49, 0xe0, 0xac, 0xec, 0x98, 0xea, 0x4b, 0xdb, 0x4d, 0x9b, 0x49, 0xe1, 0x4d, 0xdb, 0x12, 0xec, 0x8c, 0xdb, 0x7d, 0xf2, 0x01, 0x6b, 0x63, 0xe8, 0x02, 0x60, 0x63, 0xe9, 0x1d, 0x61, 0x57, 0x6c, 0x00, 0x18, 0xa1, 0xa5, 0x01, 0x6d, 0xff, 0xf7, 0x1f, 0x68, 0x0c, 0xea, 0x01, 0xf6, 0x01, 0x6b, 0x6b, 0xeb, 0xc2, 0x67, 0x6c, 0xee, 0x57, 0x6c, 0x00, 0x18, 0x01, 0xa6, 0x01, 0x6d, 0x57, 0x6c, 0x00, 0x18, 0xa1, 0xa5, 0x01, 0x6d, 0x0c, 0xea, 0x01, 0xf6, 0x00, 0x6b, 0xc2, 0x67, 0x57, 0x6c, 0x01, 0x6d, 0x00, 0x18, 0x01, 0xa6, 0x6d, 0xee, 0x07, 0x97, 0x06, 0x91, 0x05, 0x90, 0x00, 0xef, 0x04, 0x63, 0xe8, 0x93, 0x11, 0x80, 0xfb, 0x63, 0x09, 0x62, 0x08, 0xd1, 0x07, 0xd0, 0x11, 0xb2, 0x47, 0x9a, 0xff, 0x68, 0x8c, 0xe8, 0x01, 0x4a, 0x04, 0x22, 0x0f, 0xb4, 0x00, 0x18, 0x4d, 0x1d, 0x00, 0x65, 0x11, 0x20, 0x00, 0x69, 0x0b, 0xb0, 0x01, 0x6c, 0x0b, 0xb5, 0x0c, 0xb6, 0xf1, 0x67, 0x00, 0x18, 0x5b, 0x1d, 0x04, 0xd1, 0x87, 0x98, 0x00, 0x18, 0x40, 0x1d, 0x14, 0x6d, 0x00, 0x6a, 0x30, 0xc8, 0x20, 0xf0, 0x49, 0xc0, 0x09, 0x97, 0x08, 0x91, 0x07, 0x90, 0x00, 0xef, 0x05, 0x63, 0x00, 0x65, 0xe8, 0x93, 0x11, 0x80, 0x04, 0x94, 0x11, 0x80, 0x59, 0xa9, 0x10, 0x80, 0xfd, 0x63, 0x05, 0x62, 0x04, 0xd0, 0x57, 0x6c, 0x00, 0x18, 0xa1, 0xa5, 0x01, 0x6d, 0xff, 0xf7, 0x1f, 0x68, 0xff, 0x6b, 0x0c, 0xea, 0x02, 0x4b, 0x6b, 0xeb, 0xc2, 0x67, 0x6c, 0xee, 0x57, 0x6c, 0x00, 0x18, 0x01, 0xa6, 0x01, 0x6d, 0x59, 0x6c, 0x00, 0x18, 0xa1, 0xa5, 0x01, 0x6d, 0x0c, 0xea, 0x00, 0xf2
+, 0x01, 0x6b, 0x6b, 0xeb, 0xc2, 0x67, 0x6c, 0xee, 0x59, 0x6c, 0x00, 0x18, 0x01, 0xa6, 0x01, 0x6d, 0x00, 0x6c, 0x0c, 0xb0, 0xa4, 0x67, 0x00, 0x18, 0x01, 0xa6, 0xc4, 0x67, 0xd1, 0xa8, 0x01, 0x6d, 0x00, 0x18, 0x01, 0xa6, 0x42, 0x6c, 0x80, 0x18, 0x22, 0x2a, 0x00, 0x6c, 0x64, 0xa0, 0x41, 0x6a, 0x4b, 0xea, 0x6c, 0xea, 0x44, 0xc0, 0x00, 0x6a, 0x49, 0xc0, 0x05, 0x97, 0x04, 0x90, 0x00, 0xef, 0x03, 0x63, 0xe8, 0x93, 0x11, 0x80, 0xfc, 0x63, 0x07, 0x62, 0x06, 0xd1, 0x05, 0xd0, 0x20, 0xb2, 0x47, 0x9a, 0x08, 0xd4, 0x8e, 0xea, 0x05, 0x22, 0x01, 0x4c, 0x03, 0x24, 0x00, 0x18, 0x4d, 0x1d, 0x08, 0x04, 0x1b, 0xb0, 0x64, 0xa0, 0x40, 0x6a, 0x6c, 0xea, 0x08, 0x2a, 0x47, 0x98, 0x01, 0x4a, 0x29, 0x22, 0x18, 0xb4, 0x00, 0x18, 0x4d, 0x1d, 0x00, 0x65, 0x24, 0x10, 0x02, 0x69, 0x6c, 0xe9, 0xff, 0x6a, 0x4c, 0xe9, 0x07, 0x21, 0x80, 0x18, 0xfd, 0x29, 0x00, 0x65, 0x50, 0xa8, 0x01, 0x4a, 0x50, 0xc8, 0x18, 0x10, 0x7d, 0x6c, 0x00, 0x18, 0xa1, 0xa5, 0x01, 0x6d, 0x04, 0x6b, 0x4c, 0xeb, 0x06, 0x23, 0x50, 0xa8, 0x20, 0xf0, 0x29, 0xc0, 0x01, 0x4a, 0x50, 0xc8, 0x0b, 0x10, 0x20, 0xf0, 0x49, 0xa0, 0x19, 0x5a, 0x04, 0x60, 0x01, 0x4a, 0x20, 0xf0, 0x49, 0xc0, 0x03, 0x10, 0x80, 0x18, 0x38, 0x2a, 0x00, 0x65, 0x07, 0x97, 0x06, 0x91, 0x05, 0x90, 0x00, 0xef, 0x04, 0x63, 0xe8, 0x93, 0x11, 0x80, 0x04, 0x94, 0x11, 0x80, 0xfc, 0x63, 0x07, 0x62, 0x06, 0xd1, 0x05, 0xd0, 0x00, 0x6c, 0x02, 0xf0, 0x00, 0x6e, 0x00, 0x18, 0x01, 0xa6, 0xa4, 0x67, 0x2b, 0xb2, 0xc1, 0xaa, 0x7f, 0x6a, 0x3c, 0x6c, 0xca, 0x36, 0x4c, 0xee, 0x29, 0xb2, 0x00, 0xf6, 0xc0, 0x36, 0x00, 0x6d, 0x00, 0x18, 0x01, 0xa6, 0x4d, 0xee, 0x57, 0x6c, 0x00, 0x18, 0xa1, 0xa5, 0x01, 0x6d, 0xff, 0xf7, 0x1f, 0x68, 0x0c, 0xea, 0x01, 0xf6, 0x01, 0x6b, 0x6b, 0xeb, 0xc2, 0x67, 0x6c, 0xee, 0x57, 0x6c, 0x00, 0x18, 0x01, 0xa6, 0x01, 0x6d, 0x57, 0x6c, 0x00, 0x18, 0xa1, 0xa5, 0x01, 0x6d, 0x0c, 0xea, 0x01, 0xf6, 0x00, 0x6b, 0xc2, 0x67, 0x6d, 0xee, 0x57, 0x6c, 0x00, 0x18, 0x01, 0xa6, 0x01, 0x6d, 0x57, 0x6c, 0x00, 0x18, 0xa1, 0xa5, 0x01, 0x6d, 0x0c, 0xea, 0x03, 0x69, 0x2b, 0xe9, 0xc2, 0x67, 0x2c, 0xee, 0x57, 0x6c, 0x00, 
+0x18, 0x01, 0xa6, 0x01, 0x6d, 0x57, 0x6c, 0x00, 0x18, 0xa1, 0xa5, 0x01, 0x6d, 0x0c, 0xea, 0x02, 0x6b, 0xc2, 0x67, 0x6d, 0xee, 0x57, 0x6c, 0x00, 0x18, 0x01, 0xa6, 0x01, 0x6d, 0x57, 0x6c, 0x00, 0x18, 0xa1, 0xa5, 0x01, 0x6d, 0x0c, 0xea, 0xc2, 0x67, 0x2c, 0xee, 0x01, 0x6d, 0x00, 0x18, 0x01, 0xa6, 0x57, 0x6c, 0x80, 0x18, 0x22, 0x2a, 0x01, 0x6c, 0x07, 0x97, 0x06, 0x91, 0x05, 0x90, 0x00, 0xef, 0x04, 0x63, 0xe8, 0x93, 0x11, 0x80, 0x00, 0x00, 0x00, 0x80, 0xfd, 0x63, 0x05, 0x62, 0x04, 0xd0, 0x00, 0x6c, 0xc4, 0x67, 0x00, 0x18, 0x01, 0xa6, 0xa4, 0x67, 0x57, 0x6c, 0x00, 0x18, 0xa1, 0xa5, 0x01, 0x6d, 0xff, 0x6e, 0xff, 0xf7, 0x1f, 0x6b, 0x04, 0x4e, 0x4c, 0xeb, 0xcb, 0xee, 0x6c, 0xee, 0x01, 0x6d, 0x0b, 0xb0, 0x00, 0x18, 0x01, 0xa6, 0x57, 0x6c, 0x64, 0xa0, 0x41, 0x6a, 0x4b, 0xea, 0x6c, 0xea, 0x00, 0x6c, 0x80, 0x18, 0x22, 0x2a, 0x44, 0xc0, 0x80, 0x18, 0xfd, 0x29, 0x00, 0x65, 0x00, 0x6a, 0x49, 0xc0, 0x05, 0x97, 0x04, 0x90, 0x00, 0xef, 0x03, 0x63, 0x00, 0x65, 0xe8, 0x93, 0x11, 0x80, 0xfb, 0x63, 0x09, 0x62, 0x08, 0xd0, 0x38, 0xb0, 0x90, 0xa0, 0x4f, 0xa0, 0x04, 0x05, 0x80, 0x34, 0x4d, 0xec, 0x4e, 0xa0, 0x80, 0x34, 0x00, 0x18, 0x15, 0xbc, 0x4d, 0xec, 0x7d, 0x67, 0x48, 0xab, 0x8f, 0xa0, 0xdd, 0x67, 0x4c, 0xcb, 0x49, 0xab, 0xaa, 0xae, 0x4d, 0xcb, 0x4e, 0xa0, 0x80, 0x33, 0x68, 0x33, 0x48, 0x32, 0x6d, 0xea, 0x03, 0x6b, 0xac, 0xeb, 0x6d, 0xea, 0x70, 0xa0, 0x4e, 0xce, 0x9a, 0x34, 0x68, 0x32, 0x7e, 0x33, 0x8d, 0xea, 0x05, 0x23, 0x09, 0xf4, 0x00, 0x6b, 0x4d, 0xeb, 0x6f, 0xce, 0x06, 0x10, 0x0a, 0xf0, 0x00, 0x6b, 0x6b, 0xeb, 0x4d, 0xeb, 0x5d, 0x67, 0x6f, 0xca, 0x00, 0x6a, 0x21, 0x10, 0xdd, 0x67, 0x44, 0x35, 0xb5, 0xe6, 0xac, 0xad, 0x01, 0x6e, 0xa7, 0xeb, 0xcc, 0xed, 0x0c, 0x25, 0x0f, 0x6d, 0x77, 0xe5, 0xc4, 0xed, 0xa6, 0x67, 0x8d, 0xed, 0xa0, 0x34, 0x80, 0x34, 0x83, 0x34, 0x83, 0x34, 0xff, 0xf7, 0x1f, 0x6d, 0xac, 0xec, 0x01, 0x4b, 0xff, 0x6d, 0xac, 0xeb, 0x10, 0x5b, 0xe7, 0x61, 0x44, 0x33, 0x01, 0x4a, 0xdd, 0x67, 0xac, 0xea, 0x6d, 0xe6, 0x04, 0x5a, 0x8c, 0xcb, 0x03, 0x60, 0x00, 0x6c, 0x64, 0x67, 0xdc, 0x17, 0x5d, 0x67, 0xcc, 0xaa, 0x51
+, 0x6c, 0x00, 0x18, 0x01, 0xa6, 0x01, 0x6d, 0x7d, 0x67, 0xcd, 0xab, 0x50, 0x6c, 0x00, 0x18, 0x01, 0xa6, 0x01, 0x6d, 0x5d, 0x67, 0xce, 0xaa, 0x4f, 0x6c, 0x00, 0x18, 0x01, 0xa6, 0x01, 0x6d, 0x7d, 0x67, 0xcf, 0xab, 0x4e, 0x6c, 0x00, 0x18, 0x01, 0xa6, 0x01, 0x6d, 0x09, 0x97, 0x08, 0x90, 0x00, 0xef, 0x05, 0x63, 0xe8, 0x93, 0x11, 0x80, 0xfb, 0x63, 0x09, 0x62, 0x08, 0xd1, 0x07, 0xd0, 0x5e, 0x6c, 0x00, 0x18, 0xa1, 0xa5, 0x01, 0x6d, 0xff, 0xf7, 0x1f, 0x68, 0x0c, 0xea, 0x02, 0xf0, 0x01, 0x6b, 0x6b, 0xeb, 0xc2, 0x67, 0x6c, 0xee, 0x5e, 0x6c, 0x00, 0x18, 0x01, 0xa6, 0x01, 0x6d, 0x57, 0x6c, 0x00, 0x18, 0xa1, 0xa5, 0x01, 0x6d, 0x0c, 0xea, 0xff, 0x6b, 0x01, 0x4b, 0xc2, 0x67, 0x53, 0xb1, 0x6d, 0xee, 0x57, 0x6c, 0x00, 0x18, 0x01, 0xa6, 0x01, 0x6d, 0x44, 0xa1, 0x07, 0x6b, 0xa3, 0xa1, 0x4e, 0x32, 0x6c, 0xea, 0x44, 0x34, 0x0f, 0x6a, 0x4b, 0xea, 0xac, 0xea, 0x8d, 0xea, 0x43, 0xc1, 0x57, 0x6c, 0x01, 0x6d, 0x00, 0x18, 0xa1, 0xa5, 0x04, 0xd3, 0xc3, 0xa1, 0x04, 0x93, 0x71, 0x6c, 0xc6, 0x36, 0x6c, 0xee, 0x0c, 0xea, 0x8b, 0xec, 0x8c, 0xea, 0xd0, 0x36, 0x4d, 0xee, 0x57, 0x6c, 0x00, 0x18, 0x01, 0xa6, 0x01, 0x6d, 0x60, 0xa1, 0x01, 0x6a, 0x01, 0x68, 0x6c, 0xea, 0x0b, 0x22, 0x44, 0xa1, 0x80, 0x48, 0xff, 0x48, 0x4c, 0xe8, 0xff, 0x6a, 0x4c, 0xe8, 0x0b, 0xe8, 0xc0, 0xf7, 0x02, 0x30, 0x03, 0x6a, 0x03, 0xe2, 0x39, 0xb1, 0x56, 0x6c, 0x00, 0x18, 0xa1, 0xa5, 0x01, 0x6d, 0x80, 0x99, 0x00, 0x33, 0xe3, 0xf7, 0x1f, 0x6d, 0x96, 0x34, 0xac, 0xec, 0x78, 0x33, 0x8d, 0xeb, 0xfb, 0xf7, 0x1f, 0x6c, 0x8c, 0xeb, 0xff, 0xf7, 0x1f, 0x68, 0x1c, 0xf0, 0x00, 0x6c, 0x8b, 0xec, 0x0c, 0xea, 0xc3, 0x67, 0x8c, 0xea, 0x4d, 0xee, 0x56, 0x6c, 0x00, 0x18, 0x01, 0xa6, 0x01, 0x6d, 0xc7, 0xa1, 0x46, 0xa1, 0x58, 0x6c, 0xc0, 0x36, 0x4d, 0xee, 0x00, 0x18, 0x01, 0xa6, 0x01, 0x6d, 0x59, 0x6c, 0x00, 0x18, 0xa1, 0xa5, 0x01, 0x6d, 0x04, 0x6b, 0x6b, 0xeb, 0x0c, 0xea, 0x6c, 0xea, 0x68, 0xa1, 0x03, 0x6c, 0xc2, 0x67, 0x8c, 0xeb, 0x6d, 0xee, 0x59, 0x6c, 0x00, 0x18, 0x01, 0xa6, 0x01, 0x6d, 0x80, 0x18, 0xc2, 0x2a, 0x00, 0x65, 0x63, 0xa1, 0x80, 0x6a, 0x4b, 0xea, 0x6c, 0xea, 0xff, 0x6b, 
+0x6c, 0xea, 0x1e, 0x22, 0x57, 0x6c, 0x00, 0x18, 0xa1, 0xa5, 0x01, 0x6d, 0x0c, 0xea, 0x80, 0x6b, 0xc2, 0x67, 0x6d, 0xee, 0x57, 0x6c, 0x00, 0x18, 0x01, 0xa6, 0x01, 0x6d, 0x59, 0x6c, 0x00, 0x18, 0xa1, 0xa5, 0x01, 0x6d, 0xc5, 0xa1, 0xe0, 0xf1, 0x1d, 0x6b, 0x6b, 0xeb, 0x0c, 0xea, 0x6c, 0xea, 0xc8, 0x36, 0xe0, 0xf3, 0x19, 0x4b, 0x6c, 0xee, 0x59, 0x6c, 0x01, 0x6d, 0x4d, 0xee, 0x0b, 0x10, 0x57, 0x6c, 0x00, 0x18, 0xa1, 0xa5, 0x01, 0x6d, 0x0c, 0xea, 0x81, 0x6b, 0x6b, 0xeb, 0xc2, 0x67, 0x57, 0x6c, 0x01, 0x6d, 0x6c, 0xee, 0x00, 0x18, 0x01, 0xa6, 0x00, 0x65, 0x09, 0x97, 0x08, 0x91, 0x07, 0x90, 0x00, 0xef, 0x05, 0x63, 0x00, 0x65, 0xe8, 0x93, 0x11, 0x80, 0xfb, 0x63, 0x09, 0x62, 0x08, 0xd1, 0x07, 0xd0, 0x80, 0x18, 0xfc, 0x2a, 0x00, 0x65, 0x57, 0x6c, 0x00, 0x18, 0xa1, 0xa5, 0x01, 0x6d, 0xff, 0xf7, 0x1f, 0x68, 0x0c, 0xea, 0x02, 0xf0, 0x01, 0x6b, 0x6b, 0xeb, 0xc2, 0x67, 0x6c, 0xee, 0x57, 0x6c, 0x00, 0x18, 0x01, 0xa6, 0x01, 0x6d, 0x59, 0x6c, 0x00, 0x18, 0xa1, 0xa5, 0x01, 0x6d, 0x0c, 0xea, 0x00, 0xf2, 0x00, 0x6b, 0xc2, 0x67, 0x6d, 0xee, 0x59, 0x6c, 0x00, 0x18, 0x01, 0xa6, 0x01, 0x6d, 0x42, 0x6c, 0x00, 0x18, 0xa1, 0xa5, 0x01, 0x6d, 0x32, 0xb3, 0xd2, 0xab, 0x51, 0xcb, 0x53, 0xab, 0xc0, 0x36, 0xc0, 0x36, 0x4d, 0xee, 0x02, 0xf0, 0x00, 0x5e, 0x02, 0x61, 0xe1, 0xf7, 0x1f, 0x6e, 0x2c, 0xb0, 0x20, 0xf0, 0x48, 0xa0, 0x0f, 0x6b, 0xd0, 0x36, 0x6c, 0xea, 0x4d, 0xee, 0x42, 0x6c, 0x00, 0x18, 0x01, 0xa6, 0x01, 0x6d, 0x00, 0x6c, 0x02, 0xf0, 0x00, 0x6e, 0x00, 0x18, 0x01, 0xa6, 0xa4, 0x67, 0x63, 0xa0, 0x07, 0x6a, 0x02, 0x6c, 0x72, 0x33, 0x4c, 0xeb, 0x05, 0x4b, 0x00, 0x6d, 0xff, 0xf7, 0x1f, 0x69, 0x00, 0x18, 0xa1, 0xa5, 0x04, 0xd3, 0x04, 0x93, 0x1f, 0xf7, 0x01, 0x6c, 0x2c, 0xea, 0x8b, 0xec, 0x8c, 0xea, 0x1c, 0xb4, 0x6d, 0xe4, 0x20, 0xf1, 0xda, 0xa3, 0x02, 0x6c, 0x00, 0x6d, 0xc0, 0x36, 0x00, 0x18, 0x01, 0xa6, 0x4d, 0xee, 0xc1, 0xa8, 0x7f, 0x6a, 0x3c, 0x6c, 0xca, 0x36, 0x4c, 0xee, 0x00, 0xf6, 0xc0, 0x36, 0x00, 0x18, 0x01, 0xa6, 0x00, 0x6d, 0x57, 0x6c, 0x00, 0x18, 0xa1, 0xa5, 0x01, 0x6d, 0x2c, 0xea, 0x01, 0x6d, 0xc2, 0x67, 0xad, 0xee, 0x00, 0x18
+, 0x01, 0xa6, 0x57, 0x6c, 0x57, 0x6c, 0x00, 0x18, 0xa1, 0xa5, 0x01, 0x6d, 0x2c, 0xea, 0x02, 0x6b, 0x6b, 0xeb, 0xc2, 0x67, 0x01, 0x6d, 0x6c, 0xee, 0x00, 0x18, 0x01, 0xa6, 0x57, 0x6c, 0x80, 0x18, 0x22, 0x2a, 0x01, 0x6c, 0x09, 0x97, 0x08, 0x91, 0x07, 0x90, 0x00, 0xef, 0x05, 0x63, 0x00, 0x65, 0xe8, 0x93, 0x11, 0x80, 0x48, 0x00, 0x11, 0x80, 0xfb, 0x63, 0x09, 0x62, 0x08, 0xd1, 0x07, 0xd0, 0x80, 0x18, 0xfc, 0x2a, 0x00, 0x65, 0x57, 0x6c, 0x00, 0x18, 0xa1, 0xa5, 0x01, 0x6d, 0xff, 0xf7, 0x1f, 0x68, 0x0c, 0xea, 0x02, 0xf0, 0x00, 0x69, 0xc2, 0x67, 0x2d, 0xee, 0x57, 0x6c, 0x00, 0x18, 0x01, 0xa6, 0x01, 0x6d, 0x59, 0x6c, 0x00, 0x18, 0xa1, 0xa5, 0x01, 0x6d, 0x0c, 0xea, 0x00, 0xf2, 0x01, 0x6b, 0x6b, 0xeb, 0xc2, 0x67, 0x6c, 0xee, 0x59, 0x6c, 0x00, 0x18, 0x01, 0xa6, 0x01, 0x6d, 0x00, 0x6c, 0xd1, 0x67, 0x23, 0xb1, 0x00, 0x18, 0x01, 0xa6, 0xa4, 0x67, 0x63, 0xa1, 0x07, 0x6a, 0x02, 0x6c, 0x72, 0x33, 0x4c, 0xeb, 0x05, 0x4b, 0x00, 0x6d, 0x00, 0x18, 0xa1, 0xa5, 0x04, 0xd3, 0x04, 0x93, 0x1f, 0xf7, 0x01, 0x6c, 0x0c, 0xea, 0x8b, 0xec, 0x8c, 0xea, 0x1a, 0xb4, 0x6d, 0xe4, 0x20, 0xf1, 0xda, 0xa3, 0x02, 0x6c, 0x00, 0x6d, 0xc0, 0x36, 0x00, 0x18, 0x01, 0xa6, 0x4d, 0xee, 0xc1, 0xa9, 0x7f, 0x6a, 0x3c, 0x6c, 0xca, 0x36, 0x4c, 0xee, 0x00, 0xf6, 0xc0, 0x36, 0x00, 0x18, 0x01, 0xa6, 0x00, 0x6d, 0x57, 0x6c, 0x00, 0x18, 0xa1, 0xa5, 0x01, 0x6d, 0x0c, 0xea, 0x01, 0x6d, 0xc2, 0x67, 0xad, 0xee, 0x00, 0x18, 0x01, 0xa6, 0x57, 0x6c, 0x57, 0x6c, 0x00, 0x18, 0xa1, 0xa5, 0x01, 0x6d, 0x0c, 0xea, 0x02, 0x6b, 0x6b, 0xeb, 0xc2, 0x67, 0x57, 0x6c, 0x01, 0x6d, 0x00, 0x18, 0x01, 0xa6, 0x6c, 0xee, 0x09, 0x97, 0x08, 0x91, 0x07, 0x90, 0x00, 0xef, 0x05, 0x63, 0x00, 0x65, 0xe8, 0x93, 0x11, 0x80, 0x48, 0x00, 0x11, 0x80, 0xfd, 0x63, 0x05, 0x62, 0x80, 0x18, 0xfc, 0x2a, 0x00, 0x65, 0x00, 0x6b, 0x0c, 0xb2, 0x6d, 0xda, 0x6b, 0xda, 0x59, 0x6c, 0x00, 0x18, 0xa1, 0xa5, 0x01, 0x6d, 0xff, 0xf7, 0x1f, 0x6b, 0x00, 0xf2, 0x01, 0x6e, 0x4c, 0xeb, 0xcb, 0xee, 0x59, 0x6c, 0x01, 0x6d, 0x00, 0x18, 0x01, 0xa6, 0x6c, 0xee, 0x80, 0x18, 0x7a, 0x2a, 0x00, 0x65, 0x05, 0x97, 0x00, 0xef, 0x03, 
+0x63, 0xe8, 0x93, 0x11, 0x80, 0xfa, 0x63, 0x0b, 0x62, 0x0a, 0xd1, 0x09, 0xd0, 0x42, 0xa4, 0x04, 0x67, 0x23, 0xa4, 0x1e, 0x5a, 0xe0, 0xf2, 0x0f, 0x60, 0x04, 0x0b, 0x44, 0x32, 0x49, 0xe3, 0x40, 0x8a, 0x4d, 0xe3, 0x00, 0xeb, 0x00, 0x65, 0x00, 0x65, 0x3d, 0x00, 0x45, 0x00, 0x99, 0x00, 0x25, 0x02, 0xb3, 0x02, 0xed, 0x02, 0x63, 0x03, 0x8b, 0x03, 0x9d, 0x03, 0xab, 0x03, 0xc1, 0x03, 0xcf, 0x03, 0xcf, 0x05, 0xcf, 0x05, 0xdd, 0x03, 0xd5, 0x04, 0xed, 0x04, 0xcf, 0x05, 0x05, 0x05, 0x13, 0x05, 0x21, 0x05, 0x51, 0x05, 0x5f, 0x05, 0x71, 0x05, 0x7f, 0x05, 0x91, 0x05, 0x95, 0x05, 0x99, 0x05, 0xa5, 0x05, 0xb7, 0x05, 0xc0, 0xf5, 0x10, 0xb2, 0x40, 0xaa, 0xc2, 0x12, 0x57, 0x6c, 0x00, 0x18, 0xa1, 0xa5, 0x01, 0x6d, 0xff, 0xf7, 0x1f, 0x6b, 0x02, 0xf1, 0x03, 0x6e, 0x4c, 0xeb, 0xcb, 0xee, 0x6c, 0xee, 0x57, 0x6c, 0x00, 0x18, 0x01, 0xa6, 0x01, 0x6d, 0x00, 0x6c, 0xa4, 0x67, 0x00, 0x18, 0x01, 0xa6, 0xc4, 0x67, 0x80, 0x18, 0x22, 0x2a, 0x00, 0x6c, 0x00, 0x18, 0xaf, 0x58, 0x00, 0x65, 0x00, 0x6d, 0x01, 0xf4, 0x03, 0x6c, 0x00, 0x18, 0xea, 0x53, 0xc5, 0x67, 0x80, 0xf5, 0x0c, 0xb2, 0x0a, 0x6b, 0x6c, 0xc2, 0x08, 0x6b, 0x6d, 0xc2, 0x00, 0x6b, 0x69, 0xc2, 0x6a, 0xc2, 0xa3, 0x12, 0x0b, 0x59, 0x80, 0xf2, 0x1c, 0x60, 0x60, 0xf5, 0x14, 0xb2, 0x06, 0x21, 0x64, 0xa2, 0x40, 0x6a, 0x6c, 0xea, 0x80, 0xf2, 0x14, 0x2a, 0x06, 0x10, 0x84, 0xa2, 0x40, 0x6b, 0x8c, 0xeb, 0x02, 0x2b, 0x29, 0xc2, 0x91, 0x12, 0x40, 0xf5, 0x14, 0xb2, 0x69, 0xa2, 0x0b, 0x59, 0x29, 0xc2, 0x04, 0xd3, 0xa0, 0xf0, 0x01, 0x60, 0x04, 0x0a, 0x24, 0x31, 0x25, 0xe2, 0x60, 0x89, 0x69, 0xe2, 0x00, 0xea, 0x00, 0x65, 0x00, 0x65, 0x17, 0x00, 0x9f, 0x00, 0xb5, 0x00, 0xe9, 0x00, 0x09, 0x01, 0x0d, 0x01, 0x17, 0x01, 0x33, 0x01, 0x1b, 0x01, 0x23, 0x01, 0x2b, 0x01, 0x20, 0xf5, 0x00, 0xb2, 0x44, 0xa2, 0x01, 0x6b, 0x4c, 0xeb, 0x12, 0x23, 0x02, 0x6b, 0x4c, 0xeb, 0x04, 0x23, 0x80, 0x18, 0xac, 0x2a, 0x00, 0x65, 0x18, 0x10, 0x04, 0x92, 0x02, 0x72, 0x04, 0x61, 0x80, 0x18, 0x38, 0x2a, 0x00, 0x65, 0x11, 0x10, 0x80, 0x18, 0xeb, 0x29, 0x00, 0x65, 0x0d, 0x10, 0x04, 0x6b, 0x4c, 0xeb, 0x0a, 0x23, 0x02, 0x6b, 0x4c
+, 0xeb, 0x04, 0x23, 0x80, 0x18, 0xa9, 0x29, 0x00, 0x65, 0x03, 0x10, 0x80, 0x18, 0xbc, 0x29, 0x00, 0x65, 0xc0, 0xf4, 0x14, 0xb1, 0x6b, 0x99, 0xec, 0x99, 0x4d, 0x99, 0x07, 0xd3, 0x06, 0xd7, 0x00, 0x18, 0xaf, 0x58, 0x05, 0xd2, 0x00, 0x6d, 0x01, 0xf4, 0x03, 0x6c, 0x00, 0x18, 0xea, 0x53, 0xc5, 0x67, 0x0a, 0x6a, 0x4c, 0xc1, 0x08, 0x6a, 0x4d, 0xc1, 0x04, 0x92, 0x07, 0x93, 0x06, 0x97, 0x02, 0x5a, 0x20, 0xf2, 0x17, 0x60, 0x6b, 0xd9, 0x05, 0x93, 0xec, 0xd9, 0x6d, 0xd9, 0x32, 0x12, 0x80, 0xf4, 0x18, 0xb1, 0x64, 0xa1, 0x02, 0x6a, 0x6d, 0xea, 0x01, 0x6b, 0x6d, 0xea, 0x80, 0x18, 0xde, 0x2b, 0x44, 0xc1, 0x25, 0x10, 0x80, 0xf4, 0x00, 0xb3, 0x84, 0xa3, 0x03, 0x6a, 0x4b, 0xea, 0x8c, 0xea, 0x04, 0x6c, 0x4c, 0xec, 0x07, 0x24, 0x02, 0x6c, 0x8b, 0xec, 0x4c, 0xec, 0x80, 0x18, 0xcb, 0x29, 0x84, 0xc3, 0x05, 0x10, 0x01, 0x6c, 0x4d, 0xec, 0x80, 0x18, 0x5e, 0x2b, 0x84, 0xc3, 0x40, 0xf4, 0x18, 0xb3, 0x84, 0xa3, 0x40, 0x6a, 0xe0, 0x10, 0x40, 0xf4, 0x0c, 0xb1, 0x64, 0xa1, 0x03, 0x6a, 0x4b, 0xea, 0x6c, 0xea, 0x01, 0x6b, 0x6d, 0xea, 0x80, 0x18, 0xa6, 0x2b, 0x44, 0xc1, 0x64, 0xa1, 0x40, 0x6a, 0x6d, 0xea, 0x44, 0xc1, 0xfd, 0x11, 0x01, 0x6c, 0x01, 0x10, 0x02, 0x6c, 0x80, 0x18, 0x22, 0x29, 0x00, 0x65, 0xf6, 0x11, 0x03, 0x6c, 0xfa, 0x17, 0x80, 0x18, 0x76, 0x29, 0x00, 0x65, 0xf0, 0x11, 0x80, 0x18, 0x5b, 0x29, 0x00, 0x65, 0xec, 0x11, 0x80, 0x18, 0x36, 0x29, 0x00, 0x65, 0xe8, 0x11, 0x80, 0x18, 0xa5, 0x28, 0x00, 0x65, 0xe0, 0xf1, 0x03, 0x22, 0x12, 0x72, 0xc0, 0xf1, 0x1c, 0x60, 0x00, 0x6c, 0x04, 0x6b, 0xdb, 0x11, 0x04, 0x59, 0xc0, 0xf1, 0x16, 0x60, 0x80, 0x18, 0x22, 0x2a, 0x00, 0x6c, 0x57, 0x6c, 0x00, 0x18, 0xa1, 0xa5, 0x01, 0x6d, 0xff, 0xf7, 0x1f, 0x6b, 0x02, 0xf1, 0x03, 0x6e, 0x4c, 0xeb, 0xcb, 0xee, 0x6c, 0xee, 0x57, 0x6c, 0x00, 0x18, 0x01, 0xa6, 0x01, 0x6d, 0x00, 0x6c, 0xa4, 0x67, 0x00, 0x18, 0x01, 0xa6, 0xc4, 0x67, 0x00, 0x18, 0xaf, 0x58, 0x00, 0x65, 0x00, 0x6d, 0x01, 0xf4, 0x03, 0x6c, 0x00, 0x18, 0xea, 0x53, 0xc5, 0x67, 0xea, 0xb3, 0x0a, 0x6a, 0x4c, 0xc3, 0x08, 0x6a, 0x2a, 0xc3, 0x4d, 0xc3, 0x00, 0x1c, 0xf6, 0x1b, 0x07, 0xd3, 0x07, 0x93, 
+0xa2, 0x67, 0x05, 0x6a, 0x84, 0xa3, 0x4b, 0xea, 0x01, 0x71, 0x8c, 0xea, 0x44, 0xc3, 0x09, 0x61, 0x03, 0x6c, 0x80, 0x18, 0x22, 0x29, 0x06, 0xd5, 0x00, 0x18, 0x4a, 0x56, 0x00, 0x6c, 0x06, 0x95, 0x05, 0x10, 0x02, 0x71, 0x03, 0x61, 0x04, 0x6c, 0x4d, 0xec, 0x84, 0xc3, 0x00, 0x1c, 0xfd, 0x1b, 0x85, 0x67, 0x96, 0x11, 0x4f, 0x59, 0x80, 0xf1, 0x0f, 0x60, 0x44, 0xa4, 0x08, 0x5a, 0x80, 0xf1, 0x0b, 0x60, 0xd4, 0xb3, 0x7f, 0x6a, 0xa1, 0xab, 0x2c, 0xea, 0x48, 0x34, 0xe0, 0xf1, 0x1d, 0x6a, 0x4b, 0xea, 0xac, 0xea, 0x8d, 0xea, 0x41, 0xcb, 0x84, 0xa0, 0x07, 0x6a, 0xa3, 0xa3, 0x8c, 0xea, 0x50, 0x34, 0x71, 0x6a, 0x4b, 0xea, 0xac, 0xea, 0x8d, 0xea, 0x43, 0xc3, 0x79, 0x11, 0x0a, 0x59, 0x44, 0xa4, 0x65, 0xa4, 0x60, 0xf1, 0x10, 0x60, 0x60, 0x33, 0x4d, 0xeb, 0xe3, 0xf7, 0x1f, 0x6c, 0xc5, 0xb2, 0x6c, 0xec, 0x94, 0x35, 0xc4, 0xb6, 0x80, 0x9a, 0xcc, 0xec, 0xad, 0xec, 0x80, 0xda, 0xc3, 0xb5, 0x24, 0x34, 0x91, 0xe5, 0x80, 0xac, 0x8c, 0x34, 0x62, 0xec, 0x40, 0xf1, 0x1c, 0x61, 0x03, 0x59, 0x06, 0x60, 0x80, 0xa2, 0x02, 0x6b, 0x6b, 0xeb, 0x8c, 0xeb, 0x60, 0xc2, 0x0c, 0x10, 0x80, 0xa2, 0xa4, 0xa2, 0x01, 0x6b, 0x8d, 0xeb, 0x06, 0x59, 0x60, 0xc2, 0x98, 0x67, 0x7f, 0x6b, 0x9c, 0x34, 0xac, 0xeb, 0x8d, 0xeb, 0x64, 0xc2, 0xb6, 0xb2, 0x25, 0xe2, 0x80, 0xa1, 0xb1, 0xb3, 0x0f, 0x6a, 0x8c, 0xea, 0xa0, 0xa3, 0x44, 0x34, 0x1f, 0x6a, 0x4b, 0xea, 0xac, 0xea, 0x8d, 0xea, 0x40, 0xc3, 0x3e, 0x11, 0x45, 0xa4, 0x08, 0x5a, 0x20, 0xf1, 0x16, 0x60, 0x44, 0xa4, 0xa9, 0xb3, 0xa4, 0xa3, 0x40, 0x32, 0x2d, 0xea, 0x53, 0xcb, 0x85, 0xa4, 0x07, 0x6a, 0x8c, 0xea, 0x4c, 0x34, 0x39, 0x6a, 0x4b, 0xea, 0xac, 0xea, 0x8d, 0xea, 0x44, 0xc3, 0x2a, 0x11, 0x44, 0xa4, 0xa1, 0xb3, 0x40, 0x32, 0x2d, 0xea, 0x52, 0xcb, 0x45, 0xa4, 0x20, 0xf0, 0x48, 0xc3, 0x21, 0x11, 0x9d, 0xb2, 0x26, 0xc2, 0x64, 0xa4, 0x67, 0xc2, 0x65, 0xa4, 0x68, 0xc2, 0x1a, 0x11, 0x9a, 0xb2, 0x63, 0xa2, 0x3e, 0x35, 0x7f, 0x6c, 0xbc, 0x35, 0x8c, 0xeb, 0xad, 0xeb, 0x8c, 0xe9, 0x63, 0xc2, 0x25, 0xc2, 0x0f, 0x11, 0x94, 0xb2, 0x2e, 0xc2, 0x64, 0xa4, 0x6f, 0xc2, 0x65, 0xa4, 0x70, 0xc2, 0x08, 0x11, 0x91, 0xb2, 0x31, 0xc2
+, 0x64, 0xa4, 0x72, 0xc2, 0x65, 0xa4, 0x73, 0xc2, 0x01, 0x11, 0x8d, 0xb3, 0x49, 0xa3, 0x0a, 0x72, 0x2c, 0x61, 0x8c, 0xa3, 0x00, 0x6a, 0x0a, 0x74, 0x0e, 0x60, 0xc0, 0xf2, 0x0c, 0x4a, 0x58, 0xec, 0x8c, 0xb2, 0x12, 0xec, 0x91, 0xe2, 0xc0, 0xf0, 0x48, 0xa4, 0x04, 0x72, 0x05, 0x6a, 0x03, 0x60, 0x0a, 0x6a, 0x4c, 0xc3, 0x00, 0x6a, 0x82, 0xb3, 0x8d, 0xa3, 0x08, 0x74, 0x5d, 0x60, 0xff, 0x6a, 0x09, 0x4a, 0x58, 0xec, 0x84, 0xb3, 0x12, 0xea, 0x49, 0xe3, 0x20, 0xf1, 0xaf, 0xa2, 0x01, 0x6a, 0x4c, 0xed, 0x06, 0x25, 0x00, 0xf1, 0x72, 0xab, 0x67, 0xec, 0x4c, 0xeb, 0x05, 0x6a, 0x4c, 0x2b, 0x78, 0xb2, 0x08, 0x6b, 0x6d, 0xc2, 0x00, 0x6a, 0x47, 0x10, 0x8b, 0x42, 0xff, 0x6b, 0x6c, 0xec, 0x03, 0x5c, 0x1a, 0x60, 0x00, 0x6a, 0xc0, 0xf2, 0x0c, 0x6c, 0x98, 0xea, 0x75, 0xb3, 0x12, 0xec, 0x91, 0xe3, 0xc0, 0xf0, 0x68, 0xa4, 0x04, 0x73, 0x09, 0x61, 0xe0, 0xf0, 0xa8, 0x9c, 0x6c, 0xb3, 0xa5, 0xdb, 0xe0, 0xf0, 0x8c, 0xac, 0x4c, 0xc3, 0x8c, 0xcb, 0x26, 0x10, 0x01, 0x4a, 0xff, 0x6b, 0x6c, 0xea, 0x0a, 0x5a, 0xe8, 0x61, 0x27, 0x10, 0x88, 0x42, 0x6c, 0xec, 0x02, 0x5c, 0x24, 0x60, 0x00, 0x6a, 0xff, 0x6c, 0x09, 0x4c, 0x98, 0xea, 0x67, 0xb3, 0x01, 0x6d, 0x12, 0xec, 0x91, 0xe3, 0x20, 0xf1, 0xcf, 0xa4, 0xac, 0xee, 0x12, 0x26, 0x00, 0xf1, 0x72, 0xab, 0x67, 0xea, 0xac, 0xeb, 0x0d, 0x23, 0x60, 0xf1, 0xbe, 0xac, 0x5a, 0xb3, 0xaa, 0xcb, 0x80, 0xf1, 0xa0, 0xac, 0xab, 0xcb, 0x80, 0xf1, 0x82, 0xac, 0x4d, 0xc3, 0x8c, 0xcb, 0x05, 0x6a, 0x06, 0x10, 0x01, 0x4a, 0xff, 0x6b, 0x6c, 0xea, 0x08, 0x5a, 0xde, 0x61, 0x04, 0x6a, 0x52, 0xb3, 0x6a, 0xa3, 0x40, 0x32, 0x6d, 0xea, 0x66, 0x10, 0x55, 0xb3, 0x20, 0xf0, 0x9e, 0xa3, 0x20, 0xf0, 0x5d, 0xa3, 0x20, 0xf0, 0x7c, 0xa3, 0x80, 0x34, 0x40, 0x32, 0x80, 0x34, 0x8d, 0xea, 0x6d, 0x10, 0x4f, 0xb3, 0x40, 0xf0, 0x81, 0xa3, 0x40, 0xf0, 0x40, 0xa3, 0x20, 0xf0, 0x7f, 0xa3, 0x80, 0x34, 0x40, 0x32, 0x80, 0x34, 0x8d, 0xea, 0x61, 0x10, 0x43, 0xb2, 0x34, 0xc2, 0x64, 0xa4, 0x75, 0xc2, 0x65, 0xa4, 0x76, 0xc2, 0x66, 0x10, 0x40, 0xb2, 0x37, 0xc2, 0x64, 0xa4, 0x78, 0xc2, 0x65, 0xa4, 0x79, 0xc2, 0x5f, 0x10, 0x4f, 0x41, 0xff, 0x6b, 0x6c, 
+0xea, 0x09, 0x5a, 0x56, 0x60, 0x5c, 0x6c, 0x00, 0x18, 0xa1, 0xa5, 0x01, 0x6d, 0xff, 0xf7, 0x1f, 0x6b, 0x4c, 0xeb, 0x79, 0x6a, 0x4b, 0xea, 0x4c, 0xeb, 0x2c, 0x36, 0x78, 0x6a, 0x4c, 0xee, 0x5c, 0x6c, 0x01, 0x6d, 0x00, 0x18, 0x01, 0xa6, 0x6d, 0xee, 0x47, 0x10, 0x30, 0xb3, 0x8b, 0x9b, 0x36, 0xb5, 0x56, 0xab, 0xac, 0xec, 0x8b, 0xdb, 0x21, 0x10, 0x2d, 0xb4, 0xab, 0x9c, 0xff, 0xf7, 0x1f, 0x6b, 0xa2, 0x32, 0xac, 0xeb, 0x42, 0x32, 0x6b, 0xdc, 0x18, 0x10, 0x28, 0xb3, 0x8d, 0x9b, 0x2e, 0xb5, 0x5a, 0xab, 0xac, 0xec, 0x8d, 0xdb, 0x11, 0x10, 0x25, 0xb4, 0xad, 0x9c, 0xff, 0xf7, 0x1f, 0x6b, 0xa2, 0x32, 0xac, 0xeb, 0x42, 0x32, 0x6d, 0xdc, 0x08, 0x10, 0x78, 0x6c, 0x03, 0x10, 0x76, 0x6c, 0x01, 0x10, 0x77, 0x6c, 0x00, 0x18, 0xa1, 0xa5, 0x01, 0x6d, 0x02, 0x6c, 0x13, 0x10, 0x1b, 0xb3, 0x96, 0xa3, 0x55, 0xa3, 0x74, 0xa3, 0x80, 0x34, 0x40, 0x32, 0x80, 0x34, 0x8d, 0xea, 0x08, 0x10, 0x17, 0xb3, 0x99, 0xa3, 0x58, 0xa3, 0x77, 0xa3, 0x80, 0x34, 0x40, 0x32, 0x80, 0x34, 0x8d, 0xea, 0x6d, 0xea, 0x03, 0x6c, 0x00, 0x6b, 0x0b, 0x10, 0x00, 0x18, 0x00, 0x30, 0x90, 0x67, 0x14, 0x10, 0x00, 0x6c, 0x03, 0x6b, 0x44, 0x67, 0x03, 0x10, 0x00, 0x6c, 0x64, 0x67, 0x44, 0x67, 0x90, 0x34, 0x6d, 0xec, 0x83, 0xc0, 0x81, 0xa0, 0x10, 0x6b, 0x6b, 0xeb, 0x8c, 0xeb, 0x61, 0xc0, 0xa0, 0x98, 0x02, 0x6c, 0x00, 0x18, 0x55, 0x2f, 0xc2, 0x67, 0x0b, 0x97, 0x0a, 0x91, 0x09, 0x90, 0x01, 0x6a, 0x00, 0xef, 0x06, 0x63, 0x00, 0x65, 0x40, 0x00, 0x11, 0x80, 0xe8, 0x93, 0x11, 0x80, 0x1f, 0x00, 0xfc, 0xff, 0xf0, 0xdb, 0x10, 0x80, 0xe4, 0xdb, 0x10, 0x80, 0x74, 0x54, 0x11, 0x80, 0x00, 0x3b, 0x11, 0x80, 0x48, 0x00, 0x11, 0x80, 0x00, 0x00, 0xff, 0xff, 0x0b, 0xb3, 0x7c, 0x4b, 0x77, 0x9b, 0x0c, 0x6e, 0x0a, 0xb2, 0x40, 0xf7, 0x62, 0x33, 0xd8, 0xeb, 0xe0, 0xf0, 0x86, 0xaa, 0xe0, 0xf0, 0xa8, 0xaa, 0xb7, 0xe4, 0x12, 0xeb, 0x63, 0xed, 0x03, 0x60, 0x6d, 0xe4, 0xe0, 0xf0, 0x66, 0xca, 0x20, 0xe8, 0x00, 0x65, 0x00, 0x65, 0x48, 0x00, 0x11, 0x80, 0x00, 0x3b, 0x11, 0x80, 0x00, 0x6a, 0x71, 0xb5, 0x55, 0xe5, 0xa0, 0xa5, 0x70, 0xb3, 0x51, 0xe3, 0x20, 0xf1, 0xba, 0xc4, 0x01, 0x4a, 0xff, 0x6c, 0x8c
+, 0xea, 0x10, 0x5a, 0xf4, 0x61, 0x60, 0xf1, 0xa1, 0xa3, 0x0d, 0x75, 0x05, 0x61, 0x15, 0x6a, 0x60, 0xf1, 0x41, 0xc3, 0x00, 0x6c, 0x0f, 0x10, 0x0f, 0x6a, 0xac, 0xea, 0xaf, 0x42, 0x8c, 0xed, 0x05, 0x5d, 0x05, 0x60, 0x10, 0x6c, 0x4d, 0xec, 0x60, 0xf1, 0x81, 0xc3, 0x03, 0x10, 0x15, 0x6a, 0x60, 0xf1, 0x41, 0xc3, 0x01, 0x6c, 0x60, 0xb2, 0x0b, 0x6b, 0x40, 0xf1, 0x7b, 0xc2, 0x40, 0xf1, 0x7c, 0xc2, 0x40, 0xf1, 0x7d, 0xc2, 0x40, 0xf1, 0x7e, 0xc2, 0x00, 0x6b, 0x80, 0xf0, 0x7d, 0xc2, 0x24, 0xf0, 0x13, 0x6b, 0x60, 0xf1, 0x62, 0xca, 0x06, 0xf4, 0x1f, 0x6b, 0x60, 0xf1, 0x64, 0xca, 0x0a, 0xf4, 0x17, 0x6b, 0x60, 0xf1, 0x66, 0xca, 0x0e, 0xf2, 0x0d, 0x6b, 0x60, 0xf1, 0x68, 0xca, 0x04, 0xf5, 0x00, 0x6b, 0x6b, 0xeb, 0x60, 0xf1, 0x6a, 0xca, 0x00, 0x6b, 0xc0, 0xf1, 0x68, 0xca, 0xc0, 0xf1, 0x6a, 0xca, 0xc0, 0xf1, 0x6c, 0xca, 0xc0, 0xf1, 0x6e, 0xca, 0x40, 0xf1, 0x7f, 0xa2, 0xff, 0x73, 0x03, 0x61, 0x01, 0x6b, 0x40, 0xf1, 0x7f, 0xc2, 0x47, 0xb2, 0x60, 0xf1, 0x60, 0xa2, 0xff, 0x73, 0x03, 0x61, 0x0a, 0x6b, 0x60, 0xf1, 0x60, 0xc2, 0x43, 0xb2, 0x80, 0xf1, 0x62, 0xa2, 0xff, 0x73, 0x03, 0x61, 0x05, 0x6b, 0x80, 0xf1, 0x62, 0xc2, 0x3f, 0xb2, 0x01, 0x6b, 0x80, 0xf1, 0x60, 0xc2, 0x80, 0xf1, 0x71, 0xc2, 0x07, 0x2c, 0x80, 0xf1, 0x61, 0xa2, 0x1c, 0x73, 0x03, 0x61, 0x10, 0x6b, 0x80, 0xf1, 0x61, 0xc2, 0x38, 0xb2, 0x02, 0x6b, 0x80, 0xf1, 0x63, 0xc2, 0x80, 0xf1, 0x72, 0xc2, 0x00, 0x6a, 0x35, 0xb4, 0x51, 0xe4, 0x80, 0xa4, 0x33, 0xb3, 0x4d, 0xe3, 0x80, 0xf1, 0x84, 0xc3, 0x01, 0x4a, 0xff, 0x6b, 0x6c, 0xea, 0x0d, 0x5a, 0xf4, 0x61, 0x00, 0x6a, 0x30, 0xb3, 0x4d, 0xe3, 0x60, 0xa3, 0xff, 0x6c, 0xe0, 0x4b, 0x8c, 0xeb, 0x00, 0xf6, 0x60, 0x34, 0x00, 0xf6, 0x83, 0x34, 0x00, 0x54, 0x05, 0x60, 0x80, 0x4b, 0x00, 0xf6, 0x60, 0x34, 0x00, 0xf6, 0x83, 0x34, 0x25, 0xb3, 0x4d, 0xe3, 0x80, 0xf1, 0x93, 0xc3, 0x01, 0x4a, 0xff, 0x6b, 0x6c, 0xea, 0x0d, 0x5a, 0xe6, 0x61, 0x00, 0x6a, 0x23, 0xb4, 0x51, 0xe4, 0x80, 0xa4, 0x1f, 0xb3, 0x4d, 0xe3, 0xc0, 0xf1, 0x80, 0xc3, 0x21, 0xb4, 0x51, 0xe4, 0x80, 0xa4, 0xc0, 0xf1, 0x82, 0xc3, 0x1f, 0xb3, 0x4d, 0xe3, 0x60, 0xa3, 0xff, 0x6c, 
+0xe0, 0x4b, 0x8c, 0xeb, 0x00, 0xf6, 0x60, 0x34, 0x00, 0xf6, 0x83, 0x34, 0x00, 0x54, 0x05, 0x60, 0x80, 0x4b, 0x00, 0xf6, 0x60, 0x34, 0x00, 0xf6, 0x83, 0x34, 0x12, 0xb3, 0x4d, 0xe3, 0xc0, 0xf1, 0x84, 0xc3, 0x16, 0xb3, 0x4d, 0xe3, 0x60, 0xa3, 0xff, 0x6c, 0xe0, 0x4b, 0x8c, 0xeb, 0x00, 0xf6, 0x60, 0x34, 0x00, 0xf6, 0x83, 0x34, 0x00, 0x54, 0x05, 0x60, 0x80, 0x4b, 0x00, 0xf6, 0x60, 0x34, 0x00, 0xf6, 0x83, 0x34, 0x07, 0xb3, 0x4d, 0xe3, 0xc0, 0xf1, 0x86, 0xc3, 0x01, 0x4a, 0xff, 0x6b, 0x6c, 0xea, 0x02, 0x5a, 0xc5, 0x61, 0x20, 0xe8, 0x00, 0x65, 0x00, 0x65, 0x18, 0xdd, 0x10, 0x80, 0x48, 0x00, 0x11, 0x80, 0x28, 0xdd, 0x10, 0x80, 0x40, 0xdd, 0x10, 0x80, 0x38, 0xdd, 0x10, 0x80, 0x3c, 0xdd, 0x10, 0x80, 0x50, 0xdd, 0x10, 0x80, 0x54, 0xdd, 0x10, 0x80, 0xff, 0x6a, 0x4c, 0xee, 0x4c, 0xec, 0x4c, 0xed, 0xec, 0xea, 0x57, 0xe5, 0x00, 0xf6, 0xa0, 0x35, 0x00, 0xf6, 0xa3, 0x35, 0xb8, 0xed, 0xd3, 0xe4, 0x00, 0xf6, 0x80, 0x34, 0x00, 0xf6, 0x83, 0x34, 0xff, 0xf7, 0x1f, 0x6b, 0x12, 0xed, 0x98, 0xec, 0x12, 0xec, 0x89, 0xe5, 0x20, 0xe8, 0x6c, 0xea, 0x20, 0xe8, 0x00, 0x65, 0x0b, 0xb2, 0x20, 0xf0, 0x70, 0xa2, 0x16, 0x6a, 0x6c, 0xea, 0x12, 0x72, 0x04, 0x61, 0x40, 0xa4, 0x01, 0x5a, 0x58, 0x67, 0x40, 0xc4, 0x06, 0xb2, 0xc0, 0xf1, 0x7f, 0xa2, 0x07, 0x6a, 0x6c, 0xea, 0x04, 0x52, 0x58, 0x67, 0x01, 0x6b, 0x20, 0xe8, 0x6e, 0xea, 0x00, 0x65, 0x48, 0x00, 0x11, 0x80, 0x08, 0xb2, 0x60, 0xa2, 0x1e, 0x6a, 0x80, 0x9c, 0x6c, 0xea, 0x06, 0x6b, 0x4e, 0xeb, 0x05, 0x2b, 0x47, 0x6a, 0x8c, 0xea, 0x02, 0x22, 0x04, 0xb2, 0x60, 0xc2, 0x20, 0xe8, 0x00, 0x6a, 0x00, 0x65, 0xc0, 0x1e, 0x11, 0x80, 0xb2, 0x06, 0x11, 0x80, 0x62, 0xa4, 0x80, 0x6a, 0x4b, 0xea, 0x6c, 0xea, 0xff, 0x6d, 0xac, 0xea, 0x0b, 0x22, 0x09, 0xb2, 0xa1, 0xa2, 0x0c, 0x6a, 0xac, 0xea, 0x0c, 0x72, 0x09, 0x60, 0x7f, 0x6a, 0x6c, 0xea, 0x21, 0x6b, 0x6b, 0xeb, 0x02, 0x10, 0x21, 0x6a, 0x4b, 0xea, 0x6c, 0xea, 0x42, 0xc4, 0x20, 0xe8, 0x00, 0x6a, 0xc0, 0x1e, 0x11, 0x80, 0x20, 0xe8, 0x01, 0x6a, 0x64, 0xa4, 0x43, 0xa4, 0xc0, 0xa5, 0x60, 0x33, 0x4d, 0xe3, 0xff, 0xf7, 0x1f, 0x6a, 0x4c, 0xeb, 0x7f, 0xf4, 0x0f, 0x73
+, 0x00, 0x6a, 0x09, 0x61, 0xc9, 0xe4, 0x02, 0x6b, 0x62, 0xc2, 0x41, 0x46, 0xff, 0x6b, 0x6c, 0xea, 0x41, 0xc4, 0x40, 0xc5, 0x01, 0x6a, 0x20, 0xe8, 0x00, 0x65, 0x00, 0x65, 0x20, 0xe8, 0x00, 0x6a, 0x20, 0xe8, 0x00, 0x65, 0x0b, 0xb2, 0x60, 0xf1, 0x50, 0xa2, 0xff, 0x6b, 0xfd, 0x4a, 0x6c, 0xea, 0x02, 0x5a, 0x0b, 0x60, 0x08, 0xb2, 0x40, 0xa2, 0x08, 0x2a, 0x63, 0xa4, 0x02, 0x6a, 0x6c, 0xea, 0x04, 0x22, 0x03, 0x6a, 0x4b, 0xea, 0x6c, 0xea, 0x43, 0xc4, 0x20, 0xe8, 0x00, 0x6a, 0x00, 0x65, 0x80, 0x50, 0x11, 0x80, 0x7d, 0x04, 0x11, 0x80, 0x07, 0xb2, 0x40, 0x9a, 0x61, 0x42, 0x07, 0x23, 0x24, 0x6b, 0x78, 0xea, 0x05, 0xb3, 0x12, 0xea, 0x49, 0xe3, 0x05, 0xb3, 0x63, 0xda, 0x20, 0xe8, 0x00, 0x65, 0x00, 0x65, 0x80, 0x04, 0x11, 0x80, 0x0c, 0x8a, 0x11, 0x80, 0x45, 0xd0, 0x10, 0x80, 0xf9, 0x63, 0x0d, 0x62, 0x0c, 0xd1, 0x0b, 0xd0, 0x01, 0x6b, 0x6b, 0xeb, 0x20, 0xb2, 0x60, 0xda, 0x00, 0x68, 0x0e, 0x10, 0x0c, 0x6b, 0x78, 0xe8, 0x12, 0xeb, 0x49, 0xe3, 0x62, 0x9a, 0x07, 0x23, 0x20, 0x18, 0xc1, 0x32, 0x81, 0x9a, 0x03, 0x22, 0x19, 0xb2, 0x00, 0xda, 0x06, 0x10, 0x01, 0x48, 0x18, 0xb2, 0x80, 0xf0, 0x64, 0xa2, 0x02, 0xeb, 0xed, 0x60, 0x17, 0xb2, 0x17, 0xb3, 0x60, 0xda, 0x17, 0xb2, 0x40, 0xa2, 0xff, 0x72, 0x07, 0x61, 0x16, 0xb2, 0x40, 0xaa, 0x04, 0x2a, 0x00, 0x18, 0xba, 0x39, 0x00, 0x65, 0x01, 0x10, 0x00, 0x6a, 0x0d, 0xb3, 0x60, 0x9b, 0x81, 0x43, 0x07, 0x2c, 0x11, 0xb3, 0x60, 0x9b, 0xd1, 0x23, 0xd0, 0x2a, 0x40, 0xeb, 0x00, 0x65, 0xcd, 0x17, 0x0c, 0x68, 0x18, 0xeb, 0x08, 0xb2, 0x04, 0x01, 0xb1, 0x67, 0x12, 0xe8, 0x41, 0xe0, 0x20, 0x18, 0xc8, 0x32, 0x81, 0x98, 0xc2, 0x2a, 0x40, 0x98, 0x40, 0xea, 0x91, 0x67, 0xbe, 0x17, 0x80, 0x88, 0x11, 0x80, 0x84, 0x88, 0x11, 0x80, 0x78, 0xa0, 0x00, 0xb0, 0x20, 0x4e, 0xa5, 0x01, 0x62, 0x04, 0x11, 0x80, 0xde, 0x18, 0x11, 0x80, 0xf0, 0x84, 0x11, 0x80, 0xf6, 0x63, 0x13, 0x62, 0x12, 0xd1, 0x11, 0xd0, 0x09, 0x6a, 0x04, 0xd2, 0x2f, 0xb2, 0x05, 0xd2, 0x2f, 0xb2, 0x40, 0xaa, 0x01, 0x6c, 0xfa, 0x6d, 0x06, 0xd2, 0x2e, 0xb2, 0x40, 0xaa, 0x44, 0xf3, 0x14, 0x6e, 0xa1, 0xf3, 0x16, 0x6f, 0x07, 0xd2, 0x2b, 0xb2, 0x40, 
+0x9a, 0x08, 0xd2, 0x2b, 0xb2, 0x40, 0xf0, 0x61, 0xa2, 0x09, 0xd3, 0x40, 0xf0, 0x60, 0xa2, 0x0a, 0xd3, 0x20, 0xf0, 0x7f, 0xa2, 0x0b, 0xd3, 0x20, 0xf0, 0x7e, 0xa2, 0x0c, 0xd3, 0x20, 0xf0, 0x7d, 0xa2, 0x0d, 0xd3, 0x20, 0xf0, 0x5c, 0xa2, 0x20, 0x18, 0xc5, 0x30, 0x0e, 0xd2, 0x04, 0xf7, 0x10, 0x6d, 0x00, 0x18, 0x7e, 0x32, 0x01, 0x6c, 0x1f, 0xb2, 0x00, 0x9a, 0x1f, 0xb2, 0x4e, 0xe8, 0x0d, 0x28, 0x1e, 0xb1, 0x40, 0xa1, 0x0a, 0x22, 0x1e, 0xb2, 0x63, 0xa2, 0x1e, 0xb2, 0x3f, 0xf4, 0x00, 0x6c, 0x60, 0xc2, 0x00, 0x18, 0x57, 0x90, 0x00, 0x6d, 0x00, 0xc1, 0x1b, 0xb2, 0x80, 0x9a, 0x1b, 0xb3, 0x8e, 0xeb, 0x01, 0x2b, 0x60, 0xda, 0x1a, 0xb2, 0x80, 0x9a, 0x1a, 0xb3, 0x8e, 0xeb, 0x01, 0x2b, 0x60, 0xda, 0x11, 0xb3, 0x0f, 0xb2, 0x60, 0xda, 0x17, 0xb2, 0x00, 0x6b, 0x60, 0xda, 0x61, 0xda, 0x62, 0xda, 0x63, 0xda, 0x00, 0x1c, 0xc6, 0x1b, 0x64, 0xda, 0x80, 0x18, 0x5f, 0x2e, 0x00, 0x65, 0x13, 0x97, 0x12, 0x91, 0x11, 0x90, 0x00, 0xef, 0x0a, 0x63, 0x00, 0x65, 0xb0, 0xe7, 0x04, 0x80, 0x40, 0x00, 0x11, 0x80, 0x42, 0x00, 0x11, 0x80, 0xe8, 0x1f, 0x11, 0x80, 0x48, 0x00, 0x11, 0x80, 0x50, 0x8b, 0x10, 0x80, 0xef, 0xbe, 0x23, 0x87, 0x08, 0x94, 0x10, 0x80, 0x54, 0x8b, 0x10, 0x80, 0x60, 0x07, 0x11, 0x80, 0x58, 0x8b, 0x10, 0x80, 0x32, 0x97, 0x79, 0x23, 0x60, 0x8b, 0x10, 0x80, 0x58, 0x3b, 0x7a, 0x93, 0x24, 0x73, 0x11, 0x80, 0xf2, 0x63, 0x1b, 0x62, 0x1a, 0xd1, 0x19, 0xd0, 0x20, 0xf5, 0x1c, 0xb2, 0x7d, 0x67, 0x40, 0xaa, 0x51, 0xcb, 0x20, 0xf0, 0x82, 0xa3, 0x20, 0xf5, 0x14, 0xb2, 0x92, 0x35, 0xa0, 0xc2, 0x13, 0xd5, 0x20, 0xf0, 0x63, 0xa3, 0x01, 0x6a, 0x86, 0x34, 0x6e, 0x31, 0x4c, 0xe9, 0x66, 0x33, 0x4c, 0xeb, 0x24, 0x31, 0x6d, 0xe9, 0x07, 0x6b, 0x6c, 0xec, 0x10, 0xd4, 0x7c, 0x6c, 0x98, 0xe9, 0x00, 0xf5, 0x10, 0xb3, 0xb1, 0x67, 0x12, 0xec, 0x6d, 0xe4, 0x12, 0xd3, 0x60, 0xa3, 0x10, 0x94, 0x6c, 0xea, 0x00, 0x18, 0xf5, 0xbc, 0x14, 0xd2, 0x11, 0xd2, 0x11, 0x93, 0x0a, 0x6a, 0x58, 0xeb, 0xe0, 0xf4, 0x14, 0xb3, 0x12, 0xea, 0x49, 0xe3, 0x61, 0xaa, 0xe0, 0xf4, 0x0c, 0xb2, 0x60, 0xc2, 0xe0, 0xf4, 0x0c, 0xb2, 0x40, 0x9a, 0x04, 0x22, 0x20, 0xf0, 0x02, 0x04, 0x40
+, 0xea, 0x00, 0x65, 0x13, 0x94, 0x09, 0x74, 0x07, 0x61, 0x10, 0x95, 0x00, 0x6c, 0x01, 0x25, 0x82, 0x41, 0x00, 0x18, 0x31, 0x83, 0x00, 0x65, 0x7d, 0x67, 0x20, 0xf0, 0x43, 0xa3, 0x01, 0x68, 0x0c, 0xea, 0x2d, 0x22, 0xc0, 0xf4, 0x00, 0xb2, 0x40, 0xa2, 0x03, 0x6b, 0x6c, 0xea, 0x14, 0x22, 0xa0, 0xf4, 0x18, 0xb3, 0x46, 0xab, 0x9d, 0x67, 0x50, 0xcc, 0xc0, 0xf2, 0x0c, 0x6c, 0x98, 0xea, 0xa0, 0xf4, 0x0c, 0xb4, 0x12, 0xea, 0x49, 0xe4, 0x00, 0x6c, 0x20, 0xf2, 0x9d, 0xc2, 0xe0, 0xf0, 0xa3, 0xa2, 0x00, 0x18, 0x79, 0x3d, 0x8e, 0xa3, 0x80, 0xf4, 0x18, 0xb2, 0x60, 0xf1, 0x4b, 0xa2, 0x20, 0xf2, 0x0d, 0x22, 0x00, 0x6a, 0x80, 0xf4, 0x0c, 0xb3, 0x04, 0xd2, 0x05, 0xd3, 0x06, 0xd2, 0x06, 0x6c, 0xfa, 0x6d, 0xe4, 0xf0, 0x04, 0x6e, 0xc0, 0xf5, 0x19, 0x6f, 0x32, 0x10, 0x10, 0x94, 0xb1, 0x67, 0x20, 0x18, 0xd9, 0x0e, 0x09, 0x06, 0x0d, 0x2a, 0x10, 0x93, 0x60, 0xf4, 0x0c, 0xb2, 0x69, 0xe2, 0x40, 0xa2, 0x01, 0x72, 0x00, 0xf2, 0x12, 0x61, 0x60, 0xf4, 0x00, 0xb2, 0x69, 0xe2, 0x00, 0xc2, 0x0d, 0x12, 0x13, 0x94, 0x02, 0x74, 0x20, 0x61, 0x20, 0xf4, 0x18, 0xb2, 0x40, 0xa2, 0x00, 0xf2, 0x05, 0x2a, 0x20, 0xf4, 0x1c, 0xb2, 0x44, 0x9a, 0x02, 0x72, 0xe0, 0xf1, 0x1f, 0x60, 0x00, 0x18, 0x6f, 0xa9, 0x00, 0x65, 0x00, 0x18, 0xe8, 0x3a, 0x00, 0x65, 0x20, 0xf4, 0x08, 0xb3, 0x04, 0xd0, 0x05, 0xd3, 0x06, 0xd2, 0x06, 0x6c, 0xfa, 0x6d, 0x04, 0xf1, 0x09, 0x6e, 0xc0, 0xf5, 0x1a, 0x6f, 0x20, 0x18, 0xc5, 0x30, 0x00, 0x65, 0xea, 0x11, 0x10, 0x94, 0xb1, 0x67, 0x00, 0x18, 0x8e, 0xdf, 0x08, 0x06, 0xff, 0x72, 0xe0, 0xf1, 0x02, 0x60, 0x00, 0xf4, 0x04, 0xb2, 0x40, 0x9a, 0xbd, 0x67, 0x10, 0xad, 0x0d, 0x22, 0x14, 0x93, 0x3c, 0x6c, 0x12, 0x95, 0x98, 0xeb, 0x7d, 0x67, 0xd1, 0xab, 0x12, 0xec, 0x91, 0xe5, 0x04, 0x4c, 0x40, 0xea, 0xb0, 0x67, 0xc0, 0xf1, 0x0f, 0x2a, 0xc0, 0xf2, 0x0c, 0x6a, 0x58, 0xe8, 0x13, 0x93, 0xf1, 0xb2, 0x12, 0x94, 0x12, 0xe8, 0x41, 0xe0, 0x01, 0x6a, 0x44, 0xeb, 0x14, 0x93, 0x15, 0xd2, 0x3c, 0x6a, 0x58, 0xeb, 0x12, 0xea, 0x49, 0xe4, 0x20, 0xf0, 0x72, 0xa2, 0x02, 0x73, 0xe0, 0xf0, 0x00, 0x61, 0x20, 0xf0, 0x70, 0xa2, 0xff, 0x73, 0xc0, 0xf0, 0x1b, 0x60, 
+0x20, 0xf0, 0x74, 0xa2, 0x10, 0x95, 0xae, 0xeb, 0xc0, 0xf0, 0x15, 0x2b, 0x13, 0x95, 0x96, 0xaa, 0xa0, 0x33, 0x70, 0x33, 0x8e, 0xeb, 0xc0, 0xf0, 0x0e, 0x2b, 0x20, 0xf0, 0x76, 0xa2, 0x01, 0x4b, 0x20, 0xf0, 0x76, 0xc2, 0xc0, 0xf0, 0x4d, 0xa0, 0x02, 0x72, 0x15, 0x61, 0x15, 0x93, 0x08, 0xf4, 0x10, 0x6a, 0x6c, 0xea, 0x06, 0x22, 0xa0, 0xf0, 0x5c, 0xa8, 0x01, 0x4a, 0xa0, 0xf0, 0x5c, 0xc8, 0x0a, 0x10, 0x15, 0x94, 0x11, 0xf1, 0x00, 0x6a, 0x8c, 0xea, 0x05, 0x22, 0xc0, 0xf0, 0x42, 0xa8, 0x01, 0x4a, 0xc0, 0xf0, 0x42, 0xc8, 0x14, 0x93, 0x3c, 0x6a, 0x12, 0x94, 0x58, 0xeb, 0xbd, 0x67, 0x70, 0xad, 0x12, 0xea, 0x49, 0xe4, 0x20, 0xf0, 0x50, 0xa2, 0x6a, 0xea, 0x0e, 0x60, 0x02, 0x6c, 0x04, 0xd4, 0xcb, 0xb4, 0x05, 0xd4, 0xfa, 0x6d, 0x02, 0x6c, 0x44, 0xf1, 0x10, 0x6e, 0x61, 0xf4, 0x17, 0x6f, 0x06, 0xd3, 0x20, 0x18, 0xc5, 0x30, 0x07, 0xd2, 0x14, 0x93, 0x3c, 0x6a, 0x12, 0x94, 0x58, 0xeb, 0x12, 0xea, 0x49, 0xe4, 0x20, 0xf0, 0x56, 0xa2, 0x04, 0x5a, 0x15, 0x61, 0xbf, 0xb2, 0x60, 0xf1, 0x45, 0xa2, 0x11, 0x22, 0x20, 0x18, 0x29, 0x26, 0x00, 0x65, 0x2e, 0xea, 0x0c, 0x22, 0xc0, 0xf0, 0x58, 0xa0, 0x09, 0x2a, 0x00, 0x18, 0x24, 0x3c, 0x01, 0x6c, 0xbd, 0xb3, 0x80, 0xa3, 0x01, 0x6a, 0x44, 0xe9, 0x8d, 0xea, 0x40, 0xc3, 0x14, 0x93, 0x3c, 0x6a, 0x12, 0x94, 0x58, 0xeb, 0xb9, 0xb3, 0x12, 0xea, 0x49, 0xe4, 0x20, 0xf0, 0xb6, 0xa2, 0xc0, 0xf0, 0x4a, 0xab, 0x03, 0x6c, 0x42, 0x32, 0x4a, 0x32, 0x8c, 0xea, 0x44, 0x32, 0x42, 0xed, 0x2f, 0x61, 0xac, 0xb2, 0x60, 0xf1, 0x47, 0xa2, 0x2b, 0x22, 0x17, 0xd3, 0x20, 0x18, 0x29, 0x26, 0x16, 0xd4, 0x2e, 0xea, 0x17, 0x93, 0x16, 0x94, 0x23, 0x22, 0xc0, 0xf0, 0x59, 0xa0, 0x20, 0x2a, 0xab, 0xb2, 0xa0, 0xaa, 0x02, 0x6a, 0xac, 0xea, 0x1b, 0x2a, 0xc0, 0xf0, 0x6a, 0xab, 0xa9, 0xb5, 0x40, 0xa5, 0x62, 0x33, 0x72, 0x33, 0x8c, 0xeb, 0x01, 0x4a, 0xff, 0x6e, 0x64, 0x33, 0xcc, 0xea, 0x01, 0x4b, 0x7a, 0xea, 0x01, 0x2b, 0xe5, 0xe8, 0x40, 0xc5, 0x10, 0xea, 0x09, 0x2a, 0x00, 0x18, 0x0f, 0x3c, 0x01, 0x6c, 0x9c, 0xb3, 0x80, 0xa3, 0x01, 0x6a, 0x44, 0xe9, 0x8d, 0xea, 0x40, 0xc3, 0x9a, 0xb2, 0x7c, 0x4a, 0x58, 0x9a, 0x10, 0x6b, 0x6c, 0xea
+, 0x30, 0x22, 0x14, 0x93, 0x3c, 0x6a, 0x12, 0x94, 0x58, 0xeb, 0x12, 0xea, 0x49, 0xe4, 0x20, 0xf0, 0x56, 0xa2, 0x04, 0x5a, 0x04, 0x61, 0x95, 0xb2, 0x00, 0xf1, 0x54, 0xa2, 0x06, 0x2a, 0xe0, 0xf0, 0x47, 0xa0, 0x1f, 0x2a, 0x93, 0xb2, 0x40, 0xa2, 0x1c, 0x2a, 0x92, 0xb3, 0x40, 0xa3, 0xff, 0x6c, 0x01, 0x4a, 0x8c, 0xea, 0x40, 0xc3, 0x8a, 0xb3, 0x7c, 0x4b, 0x78, 0x9b, 0x07, 0x6c, 0x7a, 0x33, 0x8c, 0xeb, 0x64, 0x33, 0x01, 0x4b, 0x7b, 0xea, 0x01, 0x2b, 0xe5, 0xe8, 0x10, 0xea, 0x09, 0x2a, 0x00, 0x18, 0x13, 0xd0, 0x01, 0x6c, 0x88, 0xb3, 0x80, 0xa3, 0x01, 0x6a, 0x44, 0xe9, 0x8d, 0xea, 0x40, 0xc3, 0xe0, 0xf0, 0x67, 0xa0, 0x15, 0x94, 0xff, 0x6a, 0x01, 0x5b, 0x78, 0x67, 0x6b, 0xeb, 0x6c, 0xea, 0x19, 0xf5, 0x18, 0x6b, 0x8c, 0xeb, 0x04, 0x23, 0x10, 0x95, 0x02, 0x25, 0x01, 0x6a, 0x02, 0x10, 0xff, 0x72, 0x03, 0x60, 0x7d, 0xb4, 0x31, 0xe4, 0x40, 0xc4, 0x6f, 0xb2, 0x60, 0xf1, 0x50, 0xa2, 0xff, 0x6c, 0xfd, 0x4a, 0x8c, 0xea, 0x02, 0x5a, 0x10, 0x60, 0x80, 0xf2, 0x5c, 0xa0, 0x03, 0x72, 0x0c, 0x61, 0x11, 0x94, 0x0a, 0x6a, 0xbd, 0x67, 0x58, 0xec, 0x91, 0xad, 0x60, 0xb5, 0x17, 0xd3, 0x12, 0xea, 0x00, 0x18, 0xa5, 0x07, 0x55, 0xe5, 0x17, 0x93, 0x06, 0x23, 0x5d, 0x67, 0x90, 0xaa, 0x00, 0x18, 0xc1, 0xa3, 0x17, 0xd3, 0x17, 0x93, 0x5f, 0xb2, 0x60, 0xf1, 0x50, 0xa2, 0xff, 0x6c, 0xfd, 0x4a, 0x8c, 0xea, 0x02, 0x5a, 0x04, 0x60, 0x80, 0xf2, 0x5c, 0xa0, 0x03, 0x72, 0x0c, 0x60, 0x59, 0xb2, 0x29, 0xe2, 0x80, 0xf1, 0x40, 0xa2, 0x07, 0x22, 0x91, 0x67, 0x00, 0x18, 0xe9, 0x06, 0x17, 0xd3, 0x10, 0xd2, 0x17, 0x93, 0x02, 0x10, 0x00, 0x6c, 0x10, 0xd4, 0x11, 0x95, 0x2a, 0x25, 0x5f, 0xb2, 0x29, 0xe2, 0x44, 0xa2, 0x01, 0x6c, 0x46, 0x32, 0x8c, 0xea, 0x23, 0x22, 0x22, 0x2b, 0x5c, 0xb2, 0xa9, 0xe2, 0x60, 0xa2, 0x6a, 0x33, 0x60, 0xc2, 0xe0, 0xf0, 0x47, 0xa0, 0x01, 0x72, 0x19, 0x61, 0x59, 0xb2, 0xa9, 0xe2, 0x40, 0xa2, 0x15, 0x2a, 0x60, 0xf0, 0x56, 0xa8, 0x7d, 0x67, 0x01, 0x4a, 0x60, 0xf0, 0x56, 0xc8, 0x20, 0xf3, 0x0b, 0x6a, 0x58, 0xcb, 0x53, 0xb2, 0x80, 0x9a, 0x0d, 0x92, 0xb0, 0xab, 0x0b, 0x96, 0x04, 0xd2, 0x0c, 0x97, 0x0e, 0x92, 0x0a, 0xd5, 0x00, 0x18, 0x10, 
+0x1d, 0x05, 0xd2, 0x4e, 0xb2, 0x40, 0x9a, 0x06, 0x22, 0x7d, 0x67, 0xb1, 0xab, 0x10, 0x96, 0x40, 0xea, 0x08, 0x04, 0x57, 0x2a, 0x44, 0xb2, 0x40, 0xa2, 0x19, 0x2a, 0x40, 0xb2, 0x40, 0xa2, 0x16, 0x2a, 0xc0, 0xf0, 0x6d, 0xa0, 0x02, 0x6c, 0x46, 0xb2, 0x8e, 0xeb, 0x0a, 0x23, 0x01, 0x6b, 0x60, 0xc2, 0x37, 0xb2, 0x7c, 0x4a, 0x58, 0x9a, 0x03, 0x6c, 0x42, 0x32, 0x46, 0x32, 0x4c, 0xec, 0x03, 0x10, 0x60, 0xc2, 0x40, 0xb2, 0x80, 0xa2, 0x00, 0x18, 0x13, 0xd0, 0x00, 0x65, 0x10, 0x95, 0x02, 0x2d, 0x13, 0x92, 0x08, 0x22, 0x13, 0x93, 0x01, 0x73, 0x27, 0x61, 0x10, 0x94, 0x25, 0x2c, 0x25, 0xb2, 0x44, 0x9a, 0x22, 0x22, 0xe0, 0xf0, 0x47, 0xa0, 0x01, 0x6d, 0xae, 0xea, 0x1d, 0x2a, 0x36, 0xb3, 0x02, 0x49, 0x28, 0x31, 0x27, 0xe3, 0x60, 0x99, 0x00, 0x53, 0x16, 0x61, 0x11, 0x93, 0x14, 0x23, 0x11, 0x94, 0x0a, 0x6b, 0x18, 0xf0, 0x00, 0x6d, 0x78, 0xec, 0x14, 0xb4, 0x12, 0xeb, 0x6d, 0xe4, 0x83, 0xab, 0x00, 0x18, 0xc3, 0x3b, 0x16, 0xd2, 0x11, 0x95, 0x16, 0x92, 0x26, 0xb3, 0xad, 0xe3, 0x40, 0xc3, 0x23, 0xb3, 0xad, 0xe3, 0x40, 0xc3, 0x13, 0xb2, 0x60, 0xf1, 0x49, 0xa2, 0x01, 0x72, 0x08, 0x61, 0x00, 0xf2, 0x52, 0xa0, 0x05, 0x22, 0xa0, 0xf0, 0x44, 0xa8, 0x01, 0x4a, 0xa0, 0xf0, 0x44, 0xc8, 0x1b, 0x97, 0x1a, 0x91, 0x19, 0x90, 0x00, 0xef, 0x0e, 0x63, 0x00, 0x65, 0x08, 0x00, 0x00, 0xb6, 0x7d, 0x04, 0x11, 0x80, 0x54, 0x36, 0x11, 0x80, 0x9c, 0x39, 0x11, 0x80, 0xa8, 0x1a, 0x11, 0x80, 0xac, 0x1a, 0x11, 0x80, 0x60, 0x50, 0x11, 0x80, 0x6c, 0x50, 0x11, 0x80, 0x74, 0x54, 0x11, 0x80, 0x80, 0x50, 0x11, 0x80, 0xb0, 0xe7, 0x04, 0x80, 0xa4, 0x19, 0x11, 0x80, 0xac, 0x19, 0x11, 0x80, 0xf4, 0x19, 0x11, 0x80, 0x02, 0x1a, 0x11, 0x80, 0x48, 0x00, 0x11, 0x80, 0x20, 0x01, 0x00, 0xb6, 0x03, 0x1a, 0x11, 0x80, 0x00, 0x3b, 0x11, 0x80, 0x4a, 0x1b, 0x11, 0x80, 0x01, 0x1a, 0x11, 0x80, 0x00, 0x1a, 0x11, 0x80, 0x98, 0x19, 0x11, 0x80, 0x30, 0x3a, 0x11, 0x80, 0x60, 0x19, 0x11, 0x80, 0x54, 0x19, 0x11, 0x80, 0x40, 0x36, 0x11, 0x80, 0xf0, 0x19, 0x11, 0x80, 0xc9, 0x19, 0x11, 0x80, 0x45, 0x00, 0x11, 0x80, 0x0c, 0xa3, 0x00, 0xb0, 0xfc, 0x63, 0x07, 0x62, 0x0f, 0xb3, 0x60, 0xf1, 0x64
+, 0x9b, 0x0f, 0xb2, 0x6c, 0xea, 0x0f, 0xb3, 0x6e, 0xea, 0x13, 0x2a, 0x0e, 0xb2, 0xff, 0xf7, 0x1f, 0x6b, 0xff, 0x6c, 0x40, 0xaa, 0x1f, 0x4c, 0x4c, 0xeb, 0x5d, 0x67, 0x68, 0xca, 0x08, 0x6a, 0x4b, 0xea, 0x6c, 0xea, 0x01, 0x6b, 0x6d, 0xea, 0x7d, 0x67, 0x50, 0xc3, 0x00, 0x18, 0xc3, 0x3b, 0xa8, 0xab, 0x07, 0x97, 0x00, 0xef, 0x04, 0x63, 0x80, 0x50, 0x11, 0x80, 0xff, 0x00, 0x00, 0xff, 0x01, 0x00, 0x00, 0x01, 0x1e, 0x01, 0x00, 0xb6, 0xfd, 0x63, 0x05, 0x62, 0x00, 0x1c, 0xf6, 0x1b, 0x00, 0x65, 0x09, 0xb3, 0x60, 0x9b, 0x81, 0x43, 0x07, 0x24, 0x24, 0x6c, 0x98, 0xeb, 0x07, 0xb4, 0x12, 0xeb, 0x6d, 0xe4, 0x06, 0xb4, 0x83, 0xdb, 0x00, 0x1c, 0xfd, 0x1b, 0x82, 0x67, 0x05, 0x97, 0x00, 0xef, 0x03, 0x63, 0xfc, 0x05, 0x11, 0x80, 0x0c, 0x8a, 0x11, 0x80, 0x6d, 0xd6, 0x10, 0x80, 0xf0, 0x63, 0x1f, 0x62, 0x1e, 0xd1, 0x1d, 0xd0, 0x80, 0xac, 0xc0, 0xf2, 0x0c, 0x68, 0xc1, 0xb2, 0x18, 0xec, 0x19, 0xd4, 0xa0, 0xa5, 0x12, 0xd5, 0x12, 0xe8, 0x41, 0xe0, 0xe0, 0xf0, 0x47, 0xa0, 0x13, 0xd2, 0xa0, 0xf0, 0x60, 0xa8, 0x18, 0xd3, 0xa0, 0xf0, 0x82, 0xa8, 0x80, 0xf0, 0x7e, 0xa8, 0x17, 0xd4, 0xa0, 0xf0, 0xa6, 0xa8, 0x16, 0xd5, 0xe0, 0xf0, 0x4e, 0xa0, 0x11, 0xd2, 0x00, 0x6a, 0xc0, 0xf2, 0x44, 0xc0, 0xc0, 0xf2, 0x45, 0xc0, 0xe0, 0xf0, 0x23, 0xa0, 0x11, 0x94, 0x1b, 0xd3, 0x00, 0x18, 0xf5, 0xbc, 0xb1, 0x67, 0x0a, 0x6c, 0x98, 0xea, 0x14, 0xd2, 0xae, 0xb2, 0x12, 0xec, 0x49, 0xe4, 0x15, 0xd2, 0xe0, 0xf0, 0xa3, 0xa0, 0x00, 0x18, 0xbc, 0x3d, 0x11, 0x94, 0x12, 0x92, 0x1b, 0x93, 0x0c, 0x22, 0x13, 0x94, 0x01, 0x74, 0x09, 0x61, 0x15, 0x92, 0x03, 0xf4, 0x00, 0x6c, 0x18, 0xf0, 0x00, 0x6d, 0x00, 0x18, 0x0b, 0x98, 0xc3, 0xaa, 0x1b, 0x93, 0x00, 0x1c, 0xf6, 0x1b, 0x1b, 0xd3, 0x0a, 0x04, 0xb1, 0x67, 0x00, 0x18, 0xa9, 0x97, 0x1a, 0xd2, 0x0a, 0x92, 0x9f, 0xb4, 0x1b, 0x93, 0x46, 0x32, 0x01, 0x4a, 0x8c, 0xea, 0x0a, 0xd2, 0xa0, 0xf2, 0x9e, 0xa8, 0x10, 0xd4, 0x07, 0x2c, 0x12, 0x95, 0x01, 0x75, 0x04, 0x61, 0x00, 0x1c, 0xfd, 0x1b, 0x1a, 0x94, 0x21, 0x11, 0x06, 0x22, 0x05, 0x23, 0x7b, 0xea, 0x01, 0x2b, 0xe5, 0xe8, 0x10, 0xe9, 0x01, 0x10, 0x00, 0x69, 0xff, 0xf7, 0x1f, 0x6c, 
+0x27, 0xe3, 0x8c, 0xe9, 0x18, 0x94, 0x85, 0xe1, 0x23, 0xeb, 0x01, 0x60, 0x67, 0xe1, 0x12, 0x95, 0x01, 0x75, 0x02, 0x60, 0x10, 0xd3, 0x16, 0x10, 0x8b, 0xb3, 0xa0, 0xf2, 0x8c, 0x98, 0x8c, 0xeb, 0x43, 0xeb, 0x67, 0xe2, 0x03, 0x61, 0x89, 0xb1, 0x67, 0xe1, 0x45, 0xe1, 0x10, 0x95, 0x4b, 0xe3, 0xba, 0xe9, 0x01, 0x2d, 0xe5, 0xe8, 0x12, 0xe9, 0x01, 0x49, 0xb8, 0xe9, 0x12, 0xe9, 0x25, 0xe2, 0x81, 0xb2, 0x4c, 0xe9, 0x11, 0x93, 0xe0, 0xf0, 0xa3, 0xa0, 0x02, 0x6c, 0x74, 0x32, 0xa0, 0x35, 0xff, 0x6b, 0x6c, 0xea, 0xac, 0x35, 0x4d, 0xed, 0xff, 0xf7, 0x1f, 0x6a, 0x00, 0x18, 0xc3, 0x3b, 0x4c, 0xed, 0x0a, 0x93, 0x71, 0xe1, 0x11, 0xd4, 0x05, 0x10, 0x11, 0x95, 0x10, 0x92, 0x55, 0xe5, 0x11, 0xd5, 0x45, 0xe1, 0x08, 0x59, 0xf9, 0x61, 0x00, 0x18, 0xe8, 0x3a, 0x1b, 0xd3, 0x11, 0x94, 0x1b, 0x93, 0x6f, 0xe4, 0x64, 0x33, 0x6d, 0xe2, 0x70, 0xd8, 0x10, 0x95, 0x00, 0x18, 0xc3, 0x3b, 0x4e, 0x6c, 0x11, 0x95, 0xff, 0xf7, 0x1f, 0x6a, 0x48, 0x6c, 0x4c, 0xed, 0x18, 0xd5, 0x00, 0x18, 0xc3, 0x3b, 0x1b, 0xd2, 0x13, 0x93, 0x12, 0x2b, 0x16, 0x95, 0x00, 0x18, 0xc3, 0x3b, 0x4c, 0x6c, 0x17, 0x95, 0x00, 0x18, 0xc3, 0x3b, 0x4a, 0x6c, 0x65, 0xb3, 0x1b, 0x92, 0x00, 0xf2, 0x1c, 0x6c, 0xa0, 0xab, 0x40, 0x6b, 0x4c, 0xed, 0x6d, 0xed, 0x4c, 0xed, 0x16, 0x10, 0x61, 0xb3, 0x7c, 0x4b, 0x78, 0x9b, 0x10, 0xf0, 0x00, 0x6a, 0x6c, 0xea, 0x08, 0x22, 0x16, 0x94, 0x03, 0x24, 0x4c, 0x6c, 0x01, 0x6d, 0x05, 0x10, 0x4c, 0x6c, 0x00, 0x6d, 0x02, 0x10, 0x16, 0x95, 0x4c, 0x6c, 0x00, 0x18, 0xc3, 0x3b, 0x00, 0x65, 0x17, 0x95, 0x4a, 0x6c, 0x00, 0x18, 0xc3, 0x3b, 0x00, 0x65, 0x07, 0x6d, 0x00, 0x18, 0xc3, 0x3b, 0x00, 0x6c, 0x12, 0x95, 0x0e, 0x2d, 0x13, 0x92, 0x01, 0x72, 0x0b, 0x61, 0x14, 0x93, 0x51, 0xb2, 0x69, 0xe2, 0xa0, 0xc2, 0x50, 0xb2, 0x69, 0xe2, 0x7d, 0x67, 0x87, 0x43, 0x41, 0x4c, 0x60, 0xa4, 0x60, 0xc2, 0x1a, 0x94, 0x00, 0x1c, 0xfd, 0x1b, 0x02, 0x49, 0x00, 0x18, 0x3a, 0x04, 0x00, 0x65, 0x01, 0xf0, 0x00, 0x6d, 0x00, 0x18, 0x3d, 0xbe, 0x5e, 0x6c, 0x11, 0x95, 0x18, 0x94, 0x03, 0x6a, 0x04, 0xd2, 0x46, 0xb2, 0x05, 0xd2, 0x06, 0xd4, 0xa4, 0x32, 0x07, 0xd5, 0x00, 0x6c, 0xfa, 0x6d
+, 0xa3, 0xf6, 0x16, 0x6e, 0x40, 0x6f, 0x20, 0x18, 0xc5, 0x30, 0x08, 0xd2, 0x12, 0x92, 0x1f, 0x2a, 0x13, 0x93, 0x01, 0x73, 0x0c, 0x61, 0x15, 0x92, 0x18, 0xf0, 0x00, 0x6c, 0x03, 0xf4, 0x00, 0x6d, 0x00, 0x18, 0x0b, 0x98, 0xc3, 0xaa, 0x20, 0x6a, 0x00, 0xf2, 0x50, 0xc0, 0x24, 0x10, 0x51, 0x59, 0x06, 0x61, 0x19, 0x95, 0xff, 0xf7, 0x1f, 0x6c, 0x00, 0x18, 0x1c, 0x9d, 0x2c, 0xec, 0x15, 0x93, 0x18, 0xf0, 0x00, 0x6c, 0x01, 0xf4, 0x00, 0x6d, 0x00, 0x18, 0x0b, 0x98, 0xc3, 0xab, 0x13, 0x94, 0x12, 0x2c, 0x12, 0x95, 0x10, 0x25, 0x51, 0x59, 0x0e, 0x61, 0x19, 0x95, 0xff, 0xf7, 0x1f, 0x6c, 0x00, 0x18, 0x1c, 0x9d, 0x2c, 0xec, 0x15, 0x92, 0x01, 0xf4, 0x00, 0x6c, 0x18, 0xf0, 0x00, 0x6d, 0x00, 0x18, 0x0b, 0x98, 0xc3, 0xaa, 0x10, 0x94, 0x7d, 0x67, 0x60, 0xf2, 0x0b, 0x6a, 0x5a, 0xcb, 0x23, 0xb2, 0x0b, 0xd4, 0x80, 0x9a, 0x0e, 0x92, 0x10, 0x95, 0x0c, 0x96, 0x04, 0xd2, 0x0d, 0x97, 0x0f, 0x92, 0x00, 0x18, 0x10, 0x1d, 0x05, 0xd2, 0x03, 0x6a, 0x10, 0x95, 0x04, 0xd2, 0x1b, 0xb2, 0x05, 0xd2, 0x16, 0x93, 0x17, 0x92, 0x06, 0xd5, 0x05, 0x6c, 0xfa, 0x6d, 0x03, 0xf7, 0x0c, 0x6e, 0x82, 0xf7, 0x1e, 0x6f, 0x07, 0xd2, 0x20, 0x18, 0xc5, 0x30, 0x08, 0xd3, 0x14, 0x94, 0x0d, 0x24, 0x64, 0x67, 0xff, 0x4b, 0x68, 0x33, 0x13, 0xb4, 0x71, 0xe4, 0x00, 0x6a, 0x40, 0xdc, 0x12, 0xb4, 0x71, 0xe4, 0x40, 0xdc, 0x11, 0xb4, 0x6d, 0xe4, 0x40, 0xdb, 0x1f, 0x97, 0x1e, 0x91, 0x1d, 0x90, 0x01, 0x6a, 0x00, 0xef, 0x10, 0x63, 0x00, 0x65, 0x74, 0x54, 0x11, 0x80, 0x9c, 0x39, 0x11, 0x80, 0xff, 0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x08, 0x1c, 0x02, 0x00, 0xb6, 0x48, 0x00, 0x11, 0x80, 0x54, 0x19, 0x11, 0x80, 0x60, 0x19, 0x11, 0x80, 0xb0, 0xe7, 0x04, 0x80, 0xfc, 0x46, 0x11, 0x80, 0x14, 0x1a, 0x11, 0x80, 0x44, 0x1a, 0x11, 0x80, 0x74, 0x1a, 0x11, 0x80, 0xfb, 0x63, 0x09, 0x62, 0x08, 0xd1, 0x07, 0xd0, 0x59, 0xb2, 0xff, 0xf7, 0x1f, 0x6b, 0x01, 0x6c, 0x40, 0xaa, 0x4c, 0xeb, 0x57, 0xb2, 0x40, 0xaa, 0x04, 0xd2, 0x57, 0xb2, 0x40, 0xa2, 0x8e, 0xea, 0x06, 0x2a, 0x56, 0xb4, 0x40, 0xc4, 0x56, 0xb4, 0x40, 0xc4, 0x56, 0xb4, 0x40, 0xc4, 0x00, 0x69, 0x92, 0x10, 0x55, 0xb2, 0x40, 0x9a, 0x05, 
+0x22, 0x08, 0xf0, 0x00, 0x6a, 0x6c, 0xea, 0x80, 0xf0, 0x0f, 0x22, 0x04, 0x92, 0x08, 0xf0, 0x00, 0x6c, 0x6c, 0xec, 0x4f, 0xe8, 0x6c, 0xe8, 0x00, 0x32, 0x40, 0x32, 0x43, 0x32, 0x43, 0x32, 0x04, 0x24, 0x00, 0x18, 0x5b, 0x9c, 0x05, 0xd2, 0x05, 0x92, 0x4a, 0xb3, 0x7c, 0x4b, 0x75, 0x9b, 0x02, 0x6c, 0x8c, 0xeb, 0x0f, 0x23, 0x00, 0x52, 0x0d, 0x60, 0x00, 0x18, 0x61, 0x1b, 0x00, 0x65, 0x46, 0xb2, 0x40, 0xf0, 0x63, 0xa2, 0x06, 0x23, 0xff, 0xf7, 0x1e, 0x6b, 0x6c, 0xe8, 0x00, 0x6b, 0x40, 0xf0, 0x63, 0xc2, 0x08, 0x6a, 0x0c, 0xea, 0x03, 0x22, 0x00, 0x18, 0x36, 0x0a, 0x00, 0x65, 0x02, 0x6a, 0x0c, 0xea, 0x03, 0x22, 0x80, 0x18, 0xca, 0x2e, 0x00, 0x65, 0x01, 0x6a, 0x0c, 0xea, 0x03, 0x22, 0x00, 0x18, 0xe6, 0x13, 0x00, 0x6c, 0x20, 0x6a, 0x0c, 0xea, 0x03, 0x22, 0x00, 0x18, 0x0f, 0x06, 0x00, 0x65, 0x04, 0x6a, 0x0c, 0xea, 0x03, 0x22, 0x00, 0x18, 0xed, 0x11, 0x00, 0x65, 0x02, 0xf0, 0x00, 0x6a, 0x0c, 0xea, 0x09, 0x22, 0x00, 0x18, 0x06, 0x12, 0x00, 0x65, 0x2f, 0xb2, 0x40, 0xa2, 0x03, 0x22, 0x00, 0x18, 0x26, 0xa4, 0x00, 0x65, 0x00, 0xf6, 0x00, 0x6a, 0x0c, 0xea, 0x05, 0x22, 0x2b, 0xb2, 0xff, 0xf7, 0x1f, 0x69, 0x40, 0xaa, 0x4c, 0xe9, 0x00, 0xf2, 0x00, 0x6a, 0x0c, 0xea, 0x03, 0x22, 0x00, 0x18, 0x9a, 0x13, 0x91, 0x67, 0x00, 0xf4, 0x00, 0x6a, 0x0c, 0xea, 0x0f, 0x22, 0x00, 0x18, 0xd3, 0x13, 0x91, 0x67, 0xfe, 0xf7, 0x1f, 0x6d, 0x00, 0x18, 0x58, 0xbe, 0x5e, 0x6c, 0x1c, 0xb2, 0xe0, 0xf0, 0x54, 0xa2, 0x03, 0x22, 0x00, 0x18, 0x0d, 0xab, 0x00, 0x65, 0x01, 0xf0, 0x00, 0x6d, 0x50, 0x67, 0xac, 0xea, 0x07, 0x22, 0x00, 0x18, 0xbb, 0x13, 0x05, 0xd5, 0x05, 0x95, 0x00, 0x18, 0x3d, 0xbe, 0x5e, 0x6c, 0xff, 0x6a, 0x01, 0x4a, 0x0c, 0xea, 0x03, 0x22, 0x00, 0x18, 0x61, 0x05, 0x00, 0x65, 0x08, 0xb2, 0xff, 0xf7, 0x1f, 0x6b, 0x40, 0xaa, 0x4c, 0xeb, 0x04, 0x94, 0x8f, 0xea, 0x6c, 0xea, 0x7f, 0xf7, 0x09, 0x2a, 0x09, 0x97, 0x08, 0x91, 0x07, 0x90, 0x00, 0xef, 0x05, 0x63, 0x00, 0x65, 0xbe, 0x00, 0x00, 0xb6, 0x72, 0x04, 0x11, 0x80, 0x28, 0x3a, 0x11, 0x80, 0x08, 0x1a, 0x11, 0x80, 0x09, 0x1a, 0x11, 0x80, 0x68, 0x39, 0x11, 0x80, 0x44, 0x3a, 0x11, 0x80, 0x48, 0x00, 0x11
+, 0x80, 0xac, 0x44, 0x11, 0x80, 0xc0, 0x1a, 0x11, 0x80, 0x5c, 0x00, 0x00, 0xb6, 0xfd, 0x63, 0x05, 0x62, 0x04, 0xd0, 0x00, 0x68, 0x18, 0xb4, 0x04, 0x32, 0x49, 0xe4, 0x60, 0xaa, 0xff, 0xf7, 0x1f, 0x73, 0x0e, 0x60, 0x41, 0x40, 0x44, 0x32, 0x49, 0xe4, 0xc0, 0xaa, 0x3f, 0x6c, 0x6c, 0xec, 0x00, 0x18, 0x01, 0xa6, 0x00, 0x6d, 0x02, 0x48, 0xff, 0x6a, 0x4c, 0xe8, 0x10, 0x58, 0xeb, 0x61, 0x00, 0x68, 0x0e, 0xb4, 0x04, 0x32, 0x49, 0xe4, 0x60, 0xaa, 0xff, 0xf7, 0x1f, 0x73, 0x0e, 0x60, 0x41, 0x40, 0x44, 0x32, 0x49, 0xe4, 0xc0, 0xaa, 0x3f, 0x6c, 0x6c, 0xec, 0x00, 0x18, 0x01, 0xa6, 0x00, 0x6d, 0x02, 0x48, 0xff, 0x6a, 0x4c, 0xe8, 0x1a, 0x58, 0xeb, 0x61, 0x05, 0x97, 0x04, 0x90, 0x00, 0xef, 0x03, 0x63, 0x00, 0x65, 0xc4, 0xdc, 0x10, 0x80, 0xe4, 0xdc, 0x10, 0x80, 0xfb, 0x63, 0x09, 0x62, 0x08, 0xd0, 0x44, 0x67, 0x80, 0x9c, 0x3f, 0x6b, 0xff, 0x6e, 0x8c, 0xeb, 0x30, 0x73, 0x7d, 0x61, 0x62, 0xa2, 0x83, 0xa2, 0xa4, 0xa2, 0x06, 0x23, 0xe8, 0x43, 0xea, 0x4f, 0x02, 0x6e, 0xe3, 0xee, 0x62, 0x61, 0x04, 0x10, 0x66, 0xb3, 0xc0, 0xab, 0x03, 0x6b, 0x63, 0x10, 0x05, 0x5d, 0x5f, 0x60, 0x04, 0x0e, 0xa4, 0x35, 0xb5, 0xe6, 0xa0, 0x8d, 0xb9, 0xe6, 0x00, 0xee, 0x00, 0x65, 0x00, 0x65, 0x0f, 0x00, 0x79, 0x01, 0x0b, 0x00, 0x4f, 0x00, 0x5b, 0x00, 0x5e, 0xb4, 0x29, 0x10, 0x1e, 0x73, 0x18, 0x61, 0x00, 0x6b, 0xc0, 0xf2, 0x0c, 0x6d, 0xb8, 0xeb, 0x5b, 0xb6, 0x12, 0xed, 0xd5, 0xe5, 0xe0, 0xf0, 0xe3, 0xa5, 0x59, 0xb6, 0x8e, 0xef, 0x04, 0x2f, 0x40, 0xf2, 0x88, 0x45, 0xa0, 0xde, 0x16, 0x10, 0x00, 0x6d, 0xa0, 0xde, 0x01, 0x4b, 0xff, 0x6d, 0xac, 0xeb, 0x0a, 0x5b, 0xea, 0x61, 0x36, 0x10, 0x52, 0xb3, 0x80, 0x9b, 0x33, 0x24, 0x40, 0xf2, 0x08, 0x4c, 0x08, 0x10, 0x0a, 0x6b, 0x78, 0xec, 0x4f, 0xb3, 0x12, 0xec, 0x71, 0xe4, 0x02, 0x10, 0x4e, 0xb4, 0x01, 0x10, 0x27, 0x24, 0x62, 0xa2, 0x1e, 0x73, 0x0a, 0x61, 0x62, 0xa4, 0xc1, 0xa4, 0x60, 0x33, 0x60, 0x33, 0xc0, 0x36, 0x6d, 0xee, 0x60, 0xa4, 0x6d, 0xee, 0x63, 0xa4, 0x0b, 0x10, 0x1f, 0x73, 0x0e, 0x61, 0x66, 0xa4, 0xc5, 0xa4, 0x60, 0x33, 0x60, 0x33, 0xc0, 0x36, 0x6d, 0xee, 0x64, 0xa4, 0x6d, 0xee, 0x67, 0xa4, 0x00, 0xf6, 
+0x60, 0x33, 0x6d, 0xee, 0x04, 0x6b, 0x0c, 0x10, 0xc9, 0xa4, 0x68, 0xa4, 0xc0, 0x36, 0x6d, 0xee, 0x02, 0x6b, 0x06, 0x10, 0x80, 0x18, 0xee, 0x2b, 0x82, 0x67, 0x60, 0x10, 0x00, 0x6b, 0xc3, 0x67, 0x81, 0xa2, 0x70, 0x33, 0x63, 0xc2, 0x10, 0x6b, 0x6b, 0xeb, 0x8c, 0xeb, 0x61, 0xc2, 0xa0, 0x9a, 0x00, 0x18, 0x55, 0x2f, 0x02, 0x6c, 0x52, 0x10, 0x23, 0x73, 0x50, 0x60, 0x11, 0x73, 0x30, 0x61, 0xa1, 0x9a, 0x82, 0x32, 0x42, 0x32, 0xcc, 0xea, 0x1c, 0x22, 0xa2, 0x32, 0xcc, 0xea, 0x34, 0x5a, 0x07, 0x61, 0x1f, 0xf7, 0x01, 0x6a, 0x4b, 0xea, 0x4c, 0xed, 0x06, 0xf2, 0x00, 0x6a, 0x4d, 0xed, 0xa2, 0x32, 0xff, 0x6b, 0x6c, 0xea, 0x14, 0x5a, 0x07, 0x60, 0x1f, 0xf7, 0x01, 0x6a, 0x4b, 0xea, 0x4c, 0xed, 0x02, 0xf4, 0x00, 0x6a, 0x4d, 0xed, 0x00, 0xf6, 0x82, 0x33, 0x22, 0xb2, 0x60, 0xc2, 0x02, 0x10, 0x20, 0xb3, 0x40, 0xc3, 0x1f, 0xb2, 0x40, 0xa2, 0xff, 0x6b, 0xff, 0x4a, 0x6c, 0xea, 0x0e, 0x5a, 0x24, 0x60, 0x01, 0x6b, 0x1c, 0xb2, 0x00, 0x18, 0x99, 0xf4, 0x60, 0xc2, 0x1e, 0x10, 0x1b, 0x73, 0x00, 0x6a, 0x1c, 0x61, 0x82, 0x34, 0x82, 0x34, 0xcc, 0xec, 0x03, 0x2c, 0x00, 0xf2, 0x00, 0x68, 0x02, 0x10, 0x20, 0xf2, 0x00, 0x68, 0xa0, 0xf1, 0x06, 0x6c, 0x00, 0x18, 0xc3, 0x3b, 0xb0, 0x67, 0x01, 0x6a, 0x04, 0xd2, 0x04, 0x6c, 0x11, 0xb2, 0xfa, 0x6d, 0xe3, 0xf0, 0x17, 0x6e, 0xa1, 0xf1, 0x14, 0x6f, 0x05, 0xd2, 0x20, 0x18, 0xc5, 0x30, 0x06, 0xd0, 0x01, 0x6a, 0x09, 0x97, 0x08, 0x90, 0x00, 0xef, 0x05, 0x63, 0x0a, 0xb4, 0x72, 0x17, 0x40, 0x00, 0x11, 0x80, 0x7c, 0x4f, 0x11, 0x80, 0x74, 0x54, 0x11, 0x80, 0x54, 0x07, 0x11, 0x80, 0xcc, 0x4f, 0x11, 0x80, 0xb0, 0x4b, 0x11, 0x80, 0x4e, 0x07, 0x11, 0x80, 0xb8, 0x94, 0x11, 0x80, 0xb0, 0xe7, 0x04, 0x80, 0xd0, 0x4b, 0x11, 0x80, 0xfd, 0x63, 0x05, 0x62, 0xff, 0x6d, 0x00, 0x18, 0x26, 0x8d, 0xcc, 0xed, 0x05, 0x97, 0x00, 0xef, 0x03, 0x63, 0x00, 0x65, 0xfb, 0x63, 0x09, 0x62, 0x08, 0xd1, 0x07, 0xd0, 0x18, 0xb2, 0x19, 0xb3, 0x63, 0xea, 0x26, 0x61, 0x18, 0xb2, 0x80, 0x9a, 0x18, 0xb3, 0x8e, 0xeb, 0x21, 0x2b, 0x02, 0xaa, 0x17, 0xb5, 0x1d, 0x10, 0x17, 0xb4, 0x42, 0x45, 0x43, 0xec, 0x1a, 0x61, 0xc0, 0xa2, 0xff, 0xf7, 0x1f, 0x6f
+, 0x43, 0x46, 0x43, 0xe8, 0x14, 0x61, 0x45, 0xe5, 0x23, 0xec, 0x11, 0x61, 0x81, 0xa5, 0x60, 0xa5, 0x80, 0x34, 0x6d, 0xec, 0xec, 0xec, 0xe0, 0xf3, 0x14, 0x5c, 0x09, 0x60, 0x43, 0xe0, 0x0d, 0xb2, 0x03, 0x4d, 0x91, 0xe2, 0x00, 0x18, 0xf6, 0x33, 0xec, 0xe8, 0xb1, 0x67, 0xe2, 0x28, 0x09, 0x97, 0x08, 0x91, 0x07, 0x90, 0x00, 0xef, 0x05, 0x63, 0x00, 0x65, 0xf0, 0xff, 0x10, 0x80, 0x18, 0xde, 0x10, 0x80, 0x1c, 0xde, 0x10, 0x80, 0x55, 0xab, 0x23, 0x87, 0x22, 0xde, 0x10, 0x80, 0xff, 0xff, 0x10, 0x80, 0x48, 0x00, 0x11, 0x80, 0xfc, 0x63, 0x07, 0x62, 0x0b, 0xb2, 0x42, 0xaa, 0x60, 0xac, 0x9d, 0x67, 0x4f, 0xea, 0x6c, 0xea, 0xff, 0xf7, 0x1f, 0x6b, 0x4c, 0xeb, 0x48, 0xcc, 0x62, 0x33, 0x20, 0x6a, 0x6c, 0xea, 0x03, 0x22, 0x00, 0x18, 0x0c, 0xd6, 0x00, 0x65, 0x07, 0x97, 0x00, 0x6a, 0x00, 0xef, 0x04, 0x63, 0x00, 0x65, 0x00, 0x3b, 0x11, 0x80, 0xfa, 0x63, 0x0b, 0x62, 0x0a, 0xd1, 0x09, 0xd0, 0xff, 0x69, 0x36, 0xb0, 0x8c, 0xe9, 0x61, 0xf3, 0x06, 0x6d, 0x00, 0x18, 0xc3, 0x3b, 0x22, 0x6c, 0x20, 0xf0, 0xbf, 0xa0, 0xf3, 0x6a, 0x24, 0x6c, 0xa0, 0x35, 0x00, 0x18, 0xc3, 0x3b, 0x4d, 0xed, 0x40, 0xf0, 0xa1, 0xa0, 0x40, 0xf0, 0x40, 0xa0, 0x26, 0x6c, 0xa0, 0x35, 0x00, 0x18, 0xc3, 0x3b, 0x4d, 0xed, 0xeb, 0xf0, 0x12, 0x6d, 0x00, 0x18, 0xc3, 0x3b, 0x28, 0x6c, 0x93, 0xf7, 0x1a, 0x6d, 0x00, 0x18, 0xc3, 0x3b, 0x2a, 0x6c, 0x00, 0x18, 0xa1, 0x3a, 0x01, 0x6c, 0x02, 0x6c, 0x00, 0x18, 0xc3, 0x3b, 0x20, 0x6d, 0x22, 0xb2, 0x03, 0xf4, 0x00, 0x6d, 0x00, 0x18, 0xc3, 0x3b, 0x81, 0xa2, 0x20, 0xb2, 0x20, 0x6d, 0x5e, 0x6c, 0x60, 0xaa, 0x9f, 0xf7, 0x1f, 0x6a, 0x6c, 0xea, 0x00, 0x18, 0xc3, 0x3b, 0x4d, 0xed, 0xff, 0x6c, 0x09, 0x4c, 0x00, 0x18, 0xc3, 0x3b, 0x03, 0x6d, 0x1a, 0xb2, 0x81, 0xa2, 0x1a, 0xb2, 0x49, 0xe4, 0x60, 0xaa, 0xee, 0xf1, 0x09, 0x6a, 0x6c, 0xea, 0xff, 0x6b, 0x21, 0x4b, 0x6d, 0xea, 0x16, 0xb3, 0xa0, 0xa3, 0x07, 0x6b, 0x6c, 0xed, 0xa0, 0x35, 0xa4, 0x35, 0x00, 0x18, 0xc3, 0x3b, 0x4d, 0xed, 0x02, 0x6c, 0x00, 0x18, 0xc3, 0x3b, 0x20, 0x6d, 0x00, 0x6c, 0x00, 0x18, 0xc3, 0x3b, 0x0d, 0x6d, 0x0b, 0x21, 0x04, 0x00, 0x90, 0x67, 0x55, 0x6d, 0x00, 0x18, 0x29, 
+0x34, 0x0a, 0x6e, 0x01, 0x6c, 0x00, 0x6d, 0x00, 0x18, 0x8f, 0x3d, 0xd0, 0x67, 0x0b, 0x97, 0x0a, 0x91, 0x09, 0x90, 0x00, 0xef, 0x06, 0x63, 0x48, 0x00, 0x11, 0x80, 0x1c, 0xf2, 0x04, 0x80, 0x5e, 0x00, 0x00, 0xb6, 0x24, 0xf2, 0x04, 0x80, 0x00, 0x00, 0x00, 0xb6, 0x18, 0x05, 0x11, 0x80, 0xf9, 0x63, 0x0d, 0x62, 0x0c, 0xd1, 0x0b, 0xd0, 0x0f, 0xd5, 0x10, 0xd6, 0x40, 0xa5, 0x04, 0x67, 0x09, 0xd2, 0x60, 0xa6, 0x08, 0xd3, 0x40, 0xac, 0x7f, 0xf4, 0x10, 0x72, 0x1c, 0x60, 0x7f, 0xf4, 0x11, 0x6b, 0x63, 0xea, 0x07, 0x60, 0x1f, 0xf4, 0x16, 0x72, 0x0b, 0x60, 0x7f, 0xf4, 0x0f, 0x72, 0x4d, 0x60, 0x62, 0x10, 0x5f, 0xf5, 0x04, 0x72, 0x16, 0x60, 0x5f, 0xf5, 0x05, 0x72, 0x0b, 0x60, 0x5b, 0x10, 0x33, 0xb2, 0xc0, 0xf1, 0x7f, 0xa2, 0x07, 0x6a, 0x6c, 0xea, 0x55, 0x22, 0x00, 0x18, 0x04, 0x25, 0x00, 0x6c, 0x51, 0x10, 0x43, 0xa0, 0x00, 0x6c, 0x01, 0x22, 0x01, 0x6c, 0x80, 0x18, 0x5c, 0x32, 0x00, 0x65, 0x4f, 0x10, 0x24, 0xa4, 0x63, 0xa4, 0x1f, 0x6a, 0x4c, 0xe9, 0x29, 0xb2, 0x01, 0x23, 0x01, 0x6b, 0x20, 0xf0, 0x6a, 0xc2, 0x02, 0x6a, 0x04, 0xd2, 0x26, 0xb2, 0x05, 0xd2, 0x24, 0xb3, 0x20, 0xf0, 0x4a, 0xa3, 0x05, 0x6c, 0xfa, 0x6d, 0x82, 0xf1, 0x0b, 0x6e, 0x41, 0xf5, 0x10, 0x6f, 0x06, 0xd2, 0x20, 0x18, 0xc5, 0x30, 0x07, 0xd1, 0x0c, 0x21, 0x04, 0x6c, 0x00, 0x18, 0xa1, 0xa5, 0x00, 0x6d, 0x1f, 0x6b, 0x4c, 0xeb, 0x05, 0x23, 0x2e, 0xeb, 0x03, 0x2b, 0x19, 0xb2, 0x20, 0xf0, 0x2b, 0xc2, 0x85, 0xa0, 0x17, 0xb3, 0x07, 0x6a, 0x8c, 0xea, 0xa3, 0xa3, 0x50, 0x34, 0x71, 0x6a, 0x4b, 0xea, 0xac, 0xea, 0x8d, 0xea, 0x43, 0xc3, 0x1c, 0x10, 0x00, 0x6b, 0x01, 0x6a, 0x08, 0xd3, 0x09, 0xd2, 0x80, 0xa8, 0x00, 0x18, 0x57, 0x90, 0x08, 0x95, 0x7d, 0x67, 0x47, 0x43, 0x1d, 0x4a, 0x40, 0xa2, 0x0f, 0x93, 0x40, 0xc3, 0x7d, 0x67, 0x47, 0x43, 0x19, 0x4a, 0x40, 0xa2, 0x10, 0x93, 0x40, 0xc3, 0x01, 0x6a, 0x01, 0x10, 0x00, 0x6a, 0x0d, 0x97, 0x0c, 0x91, 0x0b, 0x90, 0x00, 0xef, 0x07, 0x63, 0x09, 0x93, 0x01, 0x73, 0xe9, 0x61, 0xe4, 0x17, 0x48, 0x00, 0x11, 0x80, 0xe8, 0x93, 0x11, 0x80, 0xb0, 0xe7, 0x04, 0x80, 0xfd, 0x63, 0x05, 0x62, 0x06, 0xb2, 0xc0, 0xf1, 0x7f, 0xa2, 0x07, 0x6a, 0x6c
+, 0xea, 0x03, 0x22, 0x00, 0x18, 0x04, 0x25, 0x00, 0x6c, 0x05, 0x97, 0x00, 0xef, 0x03, 0x63, 0x48, 0x00, 0x11, 0x80, 0xf8, 0x63, 0x0f, 0x62, 0x0e, 0xd0, 0x68, 0xa4, 0x01, 0x6a, 0x04, 0x67, 0x6c, 0xea, 0x04, 0x22, 0x00, 0x18, 0x19, 0x02, 0x00, 0x65, 0x31, 0x2a, 0x68, 0xa0, 0x04, 0x6a, 0x6c, 0xea, 0x04, 0x22, 0x00, 0x18, 0xb0, 0x01, 0x90, 0x67, 0x29, 0x2a, 0x68, 0xa0, 0x08, 0x6a, 0x6c, 0xea, 0x04, 0x22, 0x00, 0x18, 0x8b, 0x01, 0x90, 0x67, 0x21, 0x2a, 0x1e, 0xb2, 0x80, 0xf0, 0x7c, 0xa2, 0x5d, 0x67, 0x20, 0xf0, 0x70, 0xc2, 0x04, 0x6a, 0x6c, 0xea, 0x07, 0x22, 0x66, 0xa0, 0x7f, 0x6a, 0x6c, 0xea, 0x21, 0x6b, 0x6b, 0xeb, 0x6c, 0xea, 0x46, 0xc0, 0x16, 0xb2, 0x20, 0xf0, 0x7b, 0xa2, 0x5d, 0x67, 0x20, 0xf0, 0x74, 0xc2, 0x40, 0x6a, 0x6c, 0xea, 0x05, 0x22, 0x66, 0xa0, 0x21, 0x6a, 0x4b, 0xea, 0x6c, 0xea, 0x46, 0xc0, 0x00, 0x18, 0xb8, 0x37, 0x84, 0x40, 0x05, 0x6a, 0x04, 0xd2, 0x0e, 0xb2, 0x05, 0xd2, 0x40, 0x98, 0x04, 0x6c, 0xfa, 0x6d, 0x06, 0xd2, 0x43, 0x98, 0x21, 0xf7, 0x01, 0x6e, 0xa1, 0xf1, 0x1a, 0x6f, 0x07, 0xd2, 0x42, 0x98, 0x08, 0xd2, 0x41, 0x98, 0x09, 0xd2, 0x44, 0x98, 0x20, 0x18, 0xc5, 0x30, 0x0a, 0xd2, 0x0f, 0x97, 0x0e, 0x90, 0x01, 0x6a, 0x00, 0xef, 0x08, 0x63, 0x48, 0x00, 0x11, 0x80, 0xb0, 0xe7, 0x04, 0x80, 0xfb, 0x63, 0x09, 0x62, 0x08, 0xd0, 0x17, 0xb2, 0xc0, 0xf1, 0x1f, 0xa2, 0x07, 0x6a, 0x0c, 0xea, 0x22, 0x22, 0x00, 0x18, 0x04, 0x25, 0x01, 0x6c, 0xff, 0x6a, 0x4c, 0xe8, 0x16, 0x30, 0x03, 0x6a, 0x4c, 0xe8, 0x14, 0x6c, 0x00, 0x18, 0xad, 0x25, 0x84, 0xe8, 0x0f, 0xb2, 0x60, 0x9a, 0x24, 0x6a, 0x05, 0x6c, 0x58, 0xeb, 0x0d, 0xb3, 0xfa, 0x6d, 0x41, 0xf6, 0x03, 0x6e, 0x01, 0xf0, 0x0c, 0x6f, 0x12, 0xea, 0x49, 0xe3, 0x0a, 0xb3, 0x63, 0xda, 0x00, 0x6a, 0x0a, 0xb3, 0x04, 0xd2, 0x05, 0xd3, 0x20, 0x18, 0xc5, 0x30, 0x06, 0xd2, 0x09, 0x97, 0x08, 0x90, 0x00, 0xef, 0x05, 0x63, 0x00, 0x65, 0x48, 0x00, 0x11, 0x80, 0x30, 0x00, 0x11, 0x80, 0x0c, 0x8a, 0x11, 0x80, 0x81, 0xcb, 0x10, 0x80, 0xb0, 0xe7, 0x04, 0x80, 0xfb, 0x63, 0x09, 0x62, 0x08, 0xd1, 0x07, 0xd0, 0x16, 0xb2, 0xc0, 0xf1, 0x7f, 0xa2, 0x07, 0x6a, 0xff, 0xf7, 0x1f, 0x68, 
+0x6c, 0xea, 0x0a, 0xd4, 0x0b, 0xd5, 0x0d, 0xd7, 0xcc, 0xe8, 0x15, 0x22, 0x11, 0xb1, 0x00, 0x1c, 0xf6, 0x1b, 0x00, 0x65, 0x60, 0xa1, 0x0c, 0x23, 0x00, 0x18, 0x08, 0x36, 0x04, 0xd2, 0x0e, 0xb3, 0x80, 0xa3, 0x1e, 0x6b, 0x04, 0x92, 0x8c, 0xeb, 0x06, 0x6c, 0x8e, 0xeb, 0x01, 0x2b, 0x60, 0xc1, 0x00, 0x1c, 0xfd, 0x1b, 0x82, 0x67, 0x0d, 0x97, 0x0a, 0x94, 0x0b, 0x95, 0x00, 0x18, 0x8e, 0x20, 0xd0, 0x67, 0x09, 0x97, 0x08, 0x91, 0x07, 0x90, 0x00, 0xef, 0x05, 0x63, 0x48, 0x00, 0x11, 0x80, 0xb2, 0x06, 0x11, 0x80, 0xc0, 0x1e, 0x11, 0x80, 0xfd, 0x63, 0x05, 0x62, 0x04, 0xd0, 0x00, 0x1c, 0xf6, 0x1b, 0x00, 0x65, 0x02, 0x67, 0x11, 0xb2, 0x60, 0x9a, 0x11, 0xb2, 0x00, 0x6c, 0x6e, 0xea, 0x02, 0x2a, 0x10, 0xb2, 0x80, 0x9a, 0x00, 0x6b, 0x0e, 0xb2, 0x60, 0xda, 0x0e, 0xb3, 0x82, 0x34, 0x82, 0x34, 0x40, 0x9b, 0xff, 0xf7, 0x1f, 0x6d, 0x80, 0x34, 0xac, 0xea, 0x80, 0x34, 0x8d, 0xea, 0x40, 0xdb, 0x00, 0x18, 0xb5, 0x26, 0x00, 0x6c, 0x00, 0x1c, 0xfd, 0x1b, 0x90, 0x67, 0x05, 0x97, 0x04, 0x90, 0x00, 0xef, 0x03, 0x63, 0x00, 0x65, 0x58, 0x8b, 0x10, 0x80, 0x32, 0x97, 0x79, 0x23, 0x5c, 0x8b, 0x10, 0x80, 0x30, 0x00, 0x00, 0xb5, 0xfd, 0x63, 0x05, 0x62, 0x1e, 0xb2, 0x1f, 0xb3, 0x63, 0xa3, 0x1f, 0xb4, 0x40, 0x9a, 0x7e, 0x33, 0x60, 0x33, 0x60, 0x33, 0x8c, 0xea, 0x6d, 0xea, 0x1c, 0xb3, 0xe0, 0xf1, 0x63, 0xa3, 0x01, 0x6c, 0x8c, 0xeb, 0x05, 0x23, 0x1a, 0xb3, 0x6c, 0xea, 0x1a, 0xb3, 0x6d, 0xea, 0x04, 0x10, 0x1a, 0xb3, 0x6d, 0xea, 0x1a, 0xb3, 0x6c, 0xea, 0x12, 0xb3, 0x40, 0xdb, 0x19, 0xb2, 0x19, 0xb3, 0x72, 0xda, 0x19, 0xb3, 0x75, 0xda, 0x19, 0xb3, 0x69, 0xda, 0x19, 0xb3, 0x6c, 0xda, 0x19, 0xb3, 0x6f, 0xda, 0x19, 0xb3, 0x66, 0xda, 0x19, 0xb3, 0x7b, 0xda, 0x19, 0xb3, 0x60, 0xda, 0x19, 0xb3, 0x80, 0x18, 0x99, 0x28, 0x78, 0xda, 0x18, 0xb3, 0x19, 0xb2, 0x60, 0xda, 0x19, 0xb3, 0x19, 0xb2, 0x80, 0x18, 0x89, 0x2e, 0x60, 0xda, 0x05, 0x97, 0x00, 0xef, 0x03, 0x63, 0x00, 0x65, 0x74, 0xa0, 0x00, 0xb0, 0x2c, 0x3a, 0x11, 0x80, 0xff, 0xff, 0xfe, 0xff, 0x48, 0x00, 0x11, 0x80, 0xff, 0xff, 0xfb, 0xff, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x04, 0x00, 0xff, 0xff, 0xef, 0xff
+, 0x84, 0x88, 0x11, 0x80, 0x21, 0xd9, 0x10, 0x80, 0x11, 0xd9, 0x10, 0x80, 0x01, 0xd9, 0x10, 0x80, 0xf1, 0xd8, 0x10, 0x80, 0x1d, 0xd8, 0x10, 0x80, 0x0d, 0xd8, 0x10, 0x80, 0x39, 0xd7, 0x10, 0x80, 0x01, 0xd7, 0x10, 0x80, 0xe1, 0xd6, 0x10, 0x80, 0xcd, 0xcc, 0x10, 0x80, 0xc0, 0x2d, 0x11, 0x80, 0xa5, 0xc8, 0x10, 0x80, 0x94, 0x1d, 0x11, 0x80, 0xfd, 0x63, 0x05, 0x62, 0x04, 0xd0, 0x00, 0x6b, 0x27, 0xb2, 0x80, 0x18, 0x99, 0x28, 0x60, 0xc2, 0x26, 0xb2, 0xc0, 0xf1, 0x1f, 0xa2, 0xff, 0x6c, 0x78, 0xaa, 0xd0, 0x67, 0x8c, 0xee, 0x01, 0x6d, 0xce, 0x32, 0xac, 0xea, 0x50, 0x37, 0x11, 0x6a, 0x4b, 0xea, 0x6c, 0xea, 0xd2, 0x33, 0xac, 0xeb, 0xed, 0xea, 0x60, 0x33, 0xff, 0xf5, 0x1e, 0x4d, 0x64, 0x33, 0xac, 0xea, 0x6d, 0xea, 0x07, 0x6b, 0x0c, 0xeb, 0x8c, 0xeb, 0x04, 0x53, 0x04, 0x61, 0x07, 0x6b, 0x6b, 0xeb, 0x4c, 0xeb, 0x07, 0x10, 0x03, 0x6c, 0x6c, 0xec, 0x84, 0x33, 0x07, 0x6c, 0x8b, 0xec, 0x4c, 0xec, 0x8d, 0xeb, 0x13, 0xb2, 0x78, 0xca, 0xff, 0x6b, 0x6c, 0xe8, 0x07, 0x6a, 0x0c, 0xea, 0x6c, 0xea, 0x03, 0x22, 0x00, 0x18, 0x04, 0x25, 0x00, 0x6c, 0x1e, 0x30, 0x12, 0x20, 0x00, 0x68, 0x00, 0x18, 0xc6, 0x1c, 0x01, 0x6c, 0x00, 0x18, 0x04, 0x25, 0x01, 0x6c, 0x00, 0x18, 0xc6, 0x1c, 0x01, 0x6c, 0x00, 0x18, 0x04, 0x25, 0x00, 0x6c, 0x01, 0x48, 0xff, 0x6a, 0x4c, 0xe8, 0x04, 0x58, 0xef, 0x61, 0x05, 0x97, 0x04, 0x90, 0x00, 0xef, 0x03, 0x63, 0x24, 0x94, 0x11, 0x80, 0x48, 0x00, 0x11, 0x80, 0xfa, 0x63, 0x0b, 0x62, 0x0a, 0xd1, 0x09, 0xd0, 0xff, 0xf7, 0x1f, 0x6a, 0x4c, 0xee, 0x4c, 0xed, 0xff, 0x6a, 0x0c, 0xd4, 0x06, 0xd6, 0x04, 0xd5, 0x05, 0xd2, 0x5c, 0x10, 0x04, 0x93, 0x0c, 0x94, 0x64, 0x32, 0x49, 0xe4, 0x40, 0xaa, 0xff, 0xf7, 0x1f, 0x72, 0x58, 0x60, 0xe0, 0xf3, 0x1f, 0x68, 0x01, 0x4b, 0x4c, 0xe8, 0x64, 0x33, 0x42, 0x32, 0x6d, 0xe4, 0x56, 0x32, 0x20, 0xab, 0x44, 0x32, 0x03, 0x0b, 0x49, 0xe3, 0x40, 0x8a, 0x4d, 0xe3, 0x00, 0xeb, 0x00, 0x65, 0x11, 0x00, 0x19, 0x00, 0x6f, 0x00, 0x45, 0x00, 0x4d, 0x00, 0x6f, 0x00, 0x57, 0x00, 0x61, 0x00, 0x3f, 0x6c, 0x0c, 0xec, 0x00, 0x6d, 0x12, 0x10, 0x05, 0x93, 0x02, 0x32, 0x4a, 0xeb, 0x08, 0x60, 0xc2, 0x67, 0x40, 
+0x6c, 0x01, 0x6d, 0x00, 0x18, 0x01, 0xa6, 0x07, 0xd2, 0x07, 0x92, 0x05, 0xd2, 0x7f, 0x6c, 0x0c, 0xec, 0x87, 0x34, 0x40, 0x6a, 0x4d, 0xec, 0x01, 0x6d, 0x00, 0x18, 0x01, 0xa6, 0xd1, 0x67, 0x1c, 0x10, 0x00, 0x18, 0xc6, 0x1c, 0x91, 0x67, 0x18, 0x10, 0x01, 0x6a, 0x0c, 0xea, 0x15, 0x2a, 0x13, 0xb2, 0x09, 0x10, 0x01, 0x6a, 0x0c, 0xea, 0x10, 0x2a, 0x11, 0xb2, 0x04, 0x10, 0x01, 0x6a, 0x0c, 0xea, 0x0b, 0x2a, 0x10, 0xb2, 0x41, 0xe0, 0x20, 0xc8, 0x07, 0x10, 0x01, 0x6a, 0x0c, 0xea, 0x04, 0x2a, 0x90, 0x67, 0x00, 0x18, 0xc3, 0x3b, 0xb1, 0x67, 0x04, 0x94, 0xff, 0xf7, 0x1f, 0x6a, 0x02, 0x4c, 0x4c, 0xec, 0x04, 0xd4, 0x04, 0x92, 0x06, 0x93, 0x63, 0xea, 0xa0, 0x61, 0x0b, 0x97, 0x0a, 0x91, 0x09, 0x90, 0x00, 0xef, 0x06, 0x63, 0x00, 0x65, 0x00, 0xa0, 0x00, 0xb0, 0x00, 0x00, 0x00, 0xb5, 0x00, 0x10, 0x00, 0xb6, 0xfd, 0x63, 0x05, 0x62, 0x04, 0x6c, 0x00, 0x18, 0xa1, 0xa5, 0x00, 0x6d, 0x20, 0x6b, 0x4d, 0xeb, 0xff, 0xf7, 0x1f, 0x6e, 0x6c, 0xee, 0x00, 0x6d, 0x00, 0x18, 0x01, 0xa6, 0x04, 0x6c, 0x00, 0x18, 0xc1, 0x1c, 0x50, 0x6c, 0x04, 0x6c, 0x00, 0x18, 0xa1, 0xa5, 0x00, 0x6d, 0x05, 0x97, 0x1f, 0x6b, 0x6c, 0xea, 0x00, 0xef, 0x03, 0x63, 0x00, 0x65, 0xfc, 0x63, 0x07, 0x62, 0x06, 0xd1, 0x05, 0xd0, 0x4e, 0xb2, 0x20, 0xf0, 0x6a, 0xa2, 0x03, 0x23, 0x20, 0xf0, 0x4b, 0xa2, 0x26, 0x10, 0x64, 0xa2, 0x41, 0x6a, 0x6c, 0xea, 0x41, 0x72, 0x0f, 0x61, 0x00, 0x6c, 0x00, 0x18, 0xa1, 0xa5, 0xa4, 0x67, 0xff, 0xf7, 0x1f, 0x6b, 0x4c, 0xeb, 0x62, 0x33, 0x72, 0x33, 0x00, 0x6a, 0x16, 0x23, 0x80, 0x18, 0x03, 0x34, 0x00, 0x65, 0x12, 0x10, 0xa0, 0xf1, 0x1a, 0x6c, 0x10, 0xf0, 0x0f, 0x6d, 0x00, 0x18, 0xc3, 0x3b, 0x00, 0x65, 0x3e, 0xb2, 0x60, 0xaa, 0xff, 0xf7, 0x1f, 0x6a, 0x6c, 0xea, 0x42, 0x32, 0x3f, 0x6b, 0x6c, 0xea, 0x46, 0x32, 0xff, 0x6b, 0x6c, 0xea, 0x3a, 0xb3, 0x80, 0xf1, 0x81, 0xa3, 0x66, 0x22, 0x39, 0xb5, 0x60, 0xf1, 0xb2, 0xa5, 0x62, 0x2d, 0x80, 0xf1, 0xa0, 0xa3, 0x5f, 0x25, 0x80, 0xf1, 0xa3, 0xa3, 0x03, 0x2d, 0x01, 0x6d, 0x80, 0xf1, 0xa3, 0xc3, 0x33, 0xb3, 0x00, 0x83, 0x30, 0xb3, 0x80, 0xf1, 0x63, 0xa3, 0x8b, 0xe2, 0x00, 0xf6, 0x40, 0x32, 0x00, 0xf6, 0x43
+, 0x32, 0x7a, 0xea, 0x01, 0x2b, 0xe5, 0xe8, 0x00, 0x18, 0x12, 0xa6, 0x12, 0xec, 0x27, 0xb2, 0x20, 0xf0, 0x6a, 0xa2, 0x05, 0x2b, 0x64, 0xa2, 0x41, 0x6a, 0x6c, 0xea, 0x41, 0x72, 0x40, 0x61, 0x27, 0xb2, 0x40, 0x82, 0x4e, 0xe8, 0x3c, 0x20, 0x26, 0xb2, 0x60, 0xa2, 0x07, 0x5b, 0x02, 0x61, 0x06, 0x6b, 0x60, 0xc2, 0x23, 0xb2, 0xa0, 0xa2, 0x1d, 0xb2, 0x63, 0xa2, 0x07, 0x6c, 0x72, 0x36, 0x8c, 0xee, 0xc2, 0xed, 0x06, 0x60, 0x8c, 0xed, 0x88, 0x4c, 0xb0, 0x35, 0x6c, 0xec, 0xad, 0xec, 0x83, 0xc2, 0x16, 0xb2, 0x43, 0xa2, 0x07, 0x6b, 0x02, 0x6c, 0x52, 0x32, 0x6c, 0xea, 0x61, 0x42, 0x8b, 0xec, 0x8c, 0xeb, 0x18, 0xb4, 0x20, 0xf1, 0x16, 0x4b, 0xff, 0xf7, 0x1f, 0x68, 0x8d, 0xe3, 0x20, 0xab, 0x01, 0x6b, 0x4c, 0xeb, 0x6c, 0x33, 0x02, 0x6c, 0x00, 0x6d, 0x0c, 0xe9, 0x00, 0x18, 0xa1, 0xa5, 0x27, 0xeb, 0x1f, 0xf7, 0x01, 0x6b, 0x0c, 0xea, 0x6b, 0xeb, 0x0c, 0xe9, 0x6c, 0xea, 0x20, 0x31, 0x0c, 0xe9, 0xc2, 0x67, 0x02, 0x6c, 0x00, 0x6d, 0x00, 0x18, 0x01, 0xa6, 0x2d, 0xee, 0x07, 0x97, 0x06, 0x91, 0x05, 0x90, 0x00, 0xef, 0x04, 0x63, 0xe8, 0x93, 0x11, 0x80, 0xba, 0x01, 0x00, 0xb6, 0x48, 0x00, 0x11, 0x80, 0x80, 0x50, 0x11, 0x80, 0xe4, 0x1a, 0x11, 0x80, 0x6c, 0x04, 0x11, 0x80, 0x00, 0x00, 0x00, 0xb6, 0xfc, 0x63, 0x07, 0x62, 0x06, 0xd1, 0x05, 0xd0, 0x00, 0x68, 0x24, 0x67, 0x04, 0x32, 0x49, 0xe1, 0x60, 0xaa, 0xff, 0xf7, 0x1f, 0x73, 0x29, 0x60, 0x1e, 0xf0, 0x00, 0x6a, 0x6c, 0xea, 0x0c, 0xf0, 0x00, 0x72, 0x07, 0x61, 0x41, 0x40, 0x44, 0x32, 0x49, 0xe1, 0x00, 0x18, 0xc1, 0x1c, 0x80, 0xaa, 0x18, 0x10, 0x04, 0xf0, 0x00, 0x72, 0x0b, 0x61, 0xff, 0x6c, 0x8c, 0xeb, 0x40, 0x6a, 0x67, 0x33, 0x4d, 0xeb, 0x41, 0x40, 0x44, 0x32, 0x49, 0xe1, 0x6c, 0xec, 0x01, 0x6d, 0x07, 0x10, 0x0d, 0x2a, 0x41, 0x40, 0x44, 0x32, 0xff, 0x6c, 0x49, 0xe1, 0x6c, 0xec, 0x00, 0x6d, 0x00, 0x18, 0x01, 0xa6, 0xc0, 0xaa, 0x02, 0x48, 0xff, 0x6a, 0x4c, 0xe8, 0xd1, 0x17, 0x07, 0x97, 0x06, 0x91, 0x05, 0x90, 0x00, 0xef, 0x04, 0x63, 0xf9, 0x63, 0x0d, 0x62, 0x0c, 0xd1, 0x0b, 0xd0, 0xff, 0x68, 0x00, 0x6e, 0x8c, 0xe8, 0x01, 0x6d, 0x00, 0x18, 0x01, 0xa6, 0x40, 0x6c, 0x5a, 0x6c, 0x00, 0x18, 
+0xa1, 0xa5, 0x01, 0x6d, 0x5c, 0x6c, 0x01, 0x6d, 0x00, 0x18, 0xa1, 0xa5, 0x22, 0x67, 0xff, 0xf7, 0x1f, 0x6b, 0x6c, 0xe9, 0xff, 0xf7, 0x1e, 0x6e, 0x6c, 0xea, 0x5a, 0x6c, 0x01, 0x6d, 0x2c, 0xee, 0x08, 0xd2, 0x00, 0x18, 0x01, 0xa6, 0x09, 0xd3, 0x08, 0x92, 0x09, 0x93, 0x03, 0x6e, 0x4d, 0xee, 0x5c, 0x6c, 0x01, 0x6d, 0x00, 0x18, 0x01, 0xa6, 0x6c, 0xee, 0x42, 0xb4, 0x80, 0x18, 0x68, 0x34, 0x00, 0x65, 0x06, 0x20, 0x90, 0x67, 0x00, 0x18, 0xc6, 0x1c, 0x00, 0x68, 0x70, 0x67, 0x24, 0x10, 0x01, 0x6d, 0xc5, 0x67, 0x00, 0x18, 0x01, 0xa6, 0x40, 0x6c, 0x41, 0x6c, 0x38, 0xf0, 0x03, 0x6e, 0x00, 0x18, 0x01, 0xa6, 0x01, 0x6d, 0x00, 0x18, 0xc1, 0x1c, 0x0a, 0x6c, 0x00, 0x68, 0x7e, 0x6c, 0x00, 0x18, 0xa1, 0xa5, 0x01, 0x6d, 0x00, 0xf2, 0x00, 0x6b, 0x4c, 0xeb, 0x02, 0x23, 0x00, 0x6b, 0x0b, 0x10, 0x00, 0x18, 0xc6, 0x1c, 0x0a, 0x6c, 0x01, 0x48, 0xff, 0xf7, 0x1f, 0x6a, 0x4c, 0xe8, 0xe0, 0xf3, 0x08, 0x58, 0xec, 0x61, 0x01, 0x6b, 0x2c, 0xb4, 0x80, 0x18, 0x68, 0x34, 0x09, 0xd3, 0x5a, 0x6c, 0x01, 0x6d, 0x00, 0x18, 0x01, 0xa6, 0xd1, 0x67, 0x08, 0x96, 0x5c, 0x6c, 0x00, 0x18, 0x01, 0xa6, 0x01, 0x6d, 0x01, 0x6d, 0xc5, 0x67, 0x00, 0x18, 0x01, 0xa6, 0x40, 0x6c, 0x7e, 0x6c, 0x00, 0x18, 0xa1, 0xa5, 0x01, 0x6d, 0x40, 0x6c, 0x01, 0x6d, 0x00, 0x6e, 0x00, 0x18, 0x01, 0xa6, 0x08, 0xd2, 0x09, 0x93, 0x09, 0x23, 0x21, 0x6c, 0x08, 0xf2, 0x00, 0x6e, 0x00, 0x18, 0x01, 0xa6, 0x00, 0x6d, 0xff, 0xf7, 0x1f, 0x69, 0x07, 0x10, 0x21, 0x6c, 0x00, 0x18, 0xa1, 0xa5, 0x00, 0x6d, 0xff, 0xf7, 0x1f, 0x69, 0x4c, 0xe9, 0x15, 0xb3, 0x01, 0x6a, 0x04, 0x6c, 0xfa, 0x6d, 0x61, 0xf3, 0x12, 0x6e, 0xc4, 0xf3, 0x15, 0x6f, 0x05, 0xd3, 0x06, 0xd0, 0x09, 0xd3, 0x20, 0x18, 0xc5, 0x30, 0x04, 0xd2, 0x09, 0x93, 0x02, 0x6a, 0x04, 0xd2, 0x05, 0xd3, 0x08, 0x93, 0xff, 0xf7, 0x1f, 0x6a, 0x05, 0x6c, 0x6c, 0xea, 0xfa, 0x6d, 0x61, 0xf3, 0x13, 0x6e, 0x44, 0xf5, 0x18, 0x6f, 0x06, 0xd1, 0x20, 0x18, 0xc5, 0x30, 0x07, 0xd2, 0x51, 0x67, 0x0d, 0x97, 0x0c, 0x91, 0x0b, 0x90, 0x00, 0xef, 0x07, 0x63, 0x58, 0xdd, 0x10, 0x80, 0xec, 0xdd, 0x10, 0x80, 0xb0, 0xe7, 0x04, 0x80, 0xf5, 0x63, 0x15, 0x62, 0x14, 0xd1
+, 0x13, 0xd0, 0x02, 0x6c, 0x00, 0x18, 0xa1, 0xa5, 0x00, 0x6d, 0x3f, 0x6c, 0x00, 0x6d, 0x00, 0x18, 0xa1, 0xa5, 0x11, 0xd2, 0x11, 0x93, 0xff, 0x69, 0x2c, 0xea, 0xff, 0xf7, 0x1f, 0x68, 0x0c, 0xd2, 0x0c, 0xeb, 0x0c, 0x95, 0x62, 0x33, 0x2c, 0xeb, 0x01, 0x6a, 0xc3, 0x67, 0x82, 0x67, 0xe2, 0x67, 0x11, 0xd3, 0x80, 0x18, 0x85, 0x34, 0x04, 0xd2, 0x11, 0x93, 0x0c, 0x95, 0x03, 0x6a, 0xc3, 0x67, 0x00, 0x6c, 0x0f, 0x6f, 0x80, 0x18, 0x85, 0x34, 0x04, 0xd2, 0x42, 0x34, 0x1f, 0x6d, 0x11, 0x93, 0x8a, 0x34, 0x56, 0x32, 0xac, 0xec, 0xac, 0xea, 0x0c, 0x95, 0x03, 0x6e, 0x0b, 0xd4, 0x04, 0xd6, 0x00, 0x6c, 0xc3, 0x67, 0x0f, 0x6f, 0x80, 0x18, 0x85, 0x34, 0x0a, 0xd2, 0x42, 0x37, 0x1f, 0x6c, 0xea, 0x37, 0x8c, 0xef, 0x09, 0xd7, 0x56, 0x35, 0x8c, 0xed, 0x0b, 0x96, 0x09, 0x94, 0x08, 0xd5, 0x2c, 0xed, 0x2c, 0xee, 0x2c, 0xec, 0x0d, 0xd5, 0x0a, 0x97, 0x97, 0xe6, 0x10, 0xd6, 0x0d, 0x96, 0x2c, 0xef, 0x0e, 0xd4, 0xd3, 0xe7, 0x00, 0xf6, 0x80, 0x34, 0x00, 0xf6, 0x83, 0x34, 0x98, 0xec, 0x00, 0xf6, 0xa0, 0x35, 0x00, 0xf6, 0xa3, 0x35, 0x0f, 0xd7, 0x11, 0x93, 0x12, 0xec, 0xb8, 0xed, 0x12, 0xed, 0xb1, 0xe4, 0x0c, 0xec, 0x11, 0x5c, 0x09, 0x60, 0x09, 0x94, 0x0b, 0x95, 0x08, 0x96, 0x0a, 0x97, 0xad, 0xe4, 0x67, 0x33, 0x0c, 0xeb, 0xf1, 0xe6, 0x56, 0x10, 0x0c, 0x95, 0xc3, 0x67, 0x03, 0x6a, 0x00, 0x6c, 0x0f, 0x6f, 0x80, 0x18, 0x85, 0x34, 0x04, 0xd2, 0x42, 0x33, 0x1f, 0x6c, 0x6a, 0x33, 0x8c, 0xeb, 0x10, 0x96, 0xe3, 0x67, 0x2c, 0xef, 0x1f, 0x6d, 0x56, 0x34, 0xac, 0xec, 0xf7, 0xe6, 0x00, 0xf6, 0xa0, 0x35, 0x00, 0xf6, 0xa3, 0x35, 0x0d, 0x65, 0x0f, 0x95, 0x8c, 0xe9, 0x3b, 0xe5, 0x00, 0xf6, 0xc0, 0x36, 0x00, 0xf6, 0xc3, 0x36, 0xd8, 0xee, 0xa8, 0x67, 0x12, 0xee, 0xb8, 0xed, 0x12, 0xed, 0xb9, 0xe6, 0x0e, 0x95, 0x0c, 0xee, 0x11, 0x5e, 0xff, 0xe5, 0x0d, 0x95, 0x00, 0xf6, 0xe0, 0x37, 0x00, 0xf6, 0xe3, 0x37, 0x27, 0xe5, 0x00, 0xf6, 0x20, 0x35, 0x00, 0xf6, 0xa3, 0x35, 0xb8, 0xed, 0x12, 0xed, 0xf8, 0xef, 0x12, 0xef, 0xf5, 0xe5, 0x0c, 0xed, 0x10, 0x60, 0xc3, 0xed, 0x07, 0x60, 0x09, 0x95, 0x08, 0x96, 0xad, 0xe3, 0x67, 0x33, 0x0c, 0xeb, 0xd1, 0xe4, 0x13, 0x10, 0x0b, 
+0x97, 0x0a, 0x95, 0xed, 0xe3, 0x67, 0x33, 0x0c, 0xeb, 0xb1, 0xe4, 0x0c, 0x10, 0x11, 0x5d, 0x04, 0x61, 0x00, 0x6c, 0x11, 0x69, 0x10, 0x6b, 0x1b, 0x10, 0x09, 0x96, 0x08, 0x97, 0xcd, 0xe3, 0x67, 0x33, 0x0c, 0xeb, 0xf1, 0xe4, 0xa4, 0x43, 0x87, 0x34, 0x20, 0x5d, 0x0c, 0xec, 0x65, 0x67, 0x01, 0x61, 0x1f, 0x6b, 0xff, 0xf7, 0x1f, 0x6e, 0x04, 0x4c, 0xcc, 0xec, 0xa4, 0x67, 0xcc, 0xec, 0x20, 0x5c, 0xcc, 0xeb, 0x01, 0x61, 0x1f, 0x6d, 0xff, 0xf7, 0x1f, 0x69, 0xac, 0xe9, 0x01, 0x6c, 0x1f, 0x68, 0x4c, 0xe8, 0x08, 0x24, 0x10, 0xf0, 0x00, 0x6a, 0x4b, 0xea, 0x4d, 0xe8, 0xff, 0xf7, 0x1f, 0x6a, 0x4c, 0xe8, 0x11, 0x10, 0x01, 0x6d, 0xc5, 0x67, 0x00, 0x6c, 0x00, 0x18, 0x01, 0xa6, 0x11, 0xd3, 0x46, 0x6c, 0x01, 0x6d, 0x00, 0x18, 0x01, 0xa6, 0x00, 0x6e, 0x00, 0x6c, 0x01, 0x6d, 0x00, 0x18, 0x01, 0xa6, 0xc4, 0x67, 0x11, 0x93, 0x60, 0x33, 0x68, 0x33, 0x34, 0x31, 0x6d, 0xe9, 0x0d, 0xe9, 0x20, 0x36, 0xc0, 0x36, 0xc3, 0x36, 0xff, 0xf7, 0x1f, 0x6a, 0xc3, 0x36, 0x4c, 0xee, 0x21, 0x6c, 0x00, 0x18, 0x01, 0xa6, 0x00, 0x6d, 0x0e, 0x6c, 0x00, 0x18, 0xa1, 0xa5, 0x00, 0x6d, 0x21, 0x6c, 0x00, 0x6d, 0x00, 0x18, 0xa1, 0xa5, 0x02, 0x67, 0x02, 0x6b, 0x04, 0xd3, 0x01, 0x6c, 0x08, 0xb3, 0xfa, 0x6d, 0xc1, 0xf3, 0x1f, 0x6e, 0xa4, 0xf3, 0x0d, 0x6f, 0x06, 0xd0, 0x05, 0xd3, 0x20, 0x18, 0xc5, 0x30, 0x07, 0xd2, 0x15, 0x97, 0x14, 0x91, 0x13, 0x90, 0x00, 0xef, 0x0b, 0x63, 0xb0, 0xe7, 0x04, 0x80, 0xfd, 0x63, 0x05, 0x62, 0x1d, 0xb4, 0x00, 0x6d, 0x80, 0x18, 0xc6, 0x33, 0x5c, 0x6e, 0x1c, 0xb4, 0x00, 0x6d, 0x80, 0x18, 0xc6, 0x33, 0x5c, 0x6e, 0x80, 0x18, 0x93, 0x31, 0x00, 0x65, 0x00, 0x18, 0x62, 0xa6, 0x00, 0x65, 0x00, 0x18, 0x47, 0xa6, 0x00, 0x65, 0x00, 0x18, 0x87, 0xa4, 0x00, 0x65, 0x00, 0x18, 0x91, 0xa4, 0x00, 0x65, 0x13, 0xb2, 0x40, 0x9a, 0x61, 0x42, 0x07, 0x23, 0x24, 0x6b, 0x78, 0xea, 0x11, 0xb3, 0x12, 0xea, 0x49, 0xe3, 0x10, 0xb3, 0x63, 0xda, 0x80, 0x18, 0xdf, 0x34, 0x00, 0x65, 0x00, 0x6c, 0x01, 0x6d, 0x00, 0x18, 0x01, 0xa6, 0x02, 0x6e, 0x57, 0x6c, 0x01, 0x6d, 0x00, 0x18, 0x01, 0xa6, 0x10, 0x6e, 0x00, 0x6c, 0x01, 0x6d, 0x00, 0x18, 0x01, 0xa6, 0xc4, 0x67, 0x05
+, 0x97, 0x00, 0xef, 0x03, 0x63, 0x00, 0x65, 0x3c, 0x02, 0x11, 0x80, 0x0c, 0xdc, 0x10, 0x80, 0x80, 0x04, 0x11, 0x80, 0x0c, 0x8a, 0x11, 0x80, 0x45, 0xd0, 0x10, 0x80, 0xfd, 0x63, 0x05, 0x62, 0xff, 0x6a, 0x4c, 0xee, 0x85, 0x67, 0x01, 0x76, 0x4c, 0xec, 0x05, 0x61, 0x40, 0x6b, 0x8d, 0xeb, 0x83, 0x67, 0x4c, 0xec, 0x01, 0x10, 0x03, 0x2e, 0x00, 0x18, 0xbc, 0xa5, 0xa7, 0x67, 0x05, 0x97, 0x00, 0xef, 0x03, 0x63, 0xfb, 0x63, 0x09, 0x62, 0x08, 0xd1, 0x07, 0xd0, 0x04, 0x67, 0x00, 0x1c, 0xf6, 0x1b, 0x04, 0xd5, 0x14, 0xb4, 0x22, 0x67, 0x40, 0x9c, 0x04, 0x95, 0x01, 0x4a, 0x19, 0x22, 0xff, 0x6a, 0xac, 0xea, 0x01, 0x72, 0x04, 0x60, 0x20, 0x18, 0x64, 0x2f, 0x90, 0x67, 0x11, 0x10, 0x00, 0x18, 0x4d, 0x1d, 0x00, 0x65, 0x01, 0x6b, 0x6b, 0xeb, 0x0c, 0xb2, 0x60, 0xc2, 0x0c, 0xb2, 0x01, 0x6b, 0x40, 0x9a, 0x6c, 0xea, 0x05, 0x2a, 0x0a, 0xb3, 0x0b, 0xb4, 0x40, 0x9b, 0x8d, 0xea, 0x40, 0xdb, 0x00, 0x1c, 0xfd, 0x1b, 0x91, 0x67, 0x09, 0x97, 0x08, 0x91, 0x07, 0x90, 0x00, 0xef, 0x05, 0x63, 0x00, 0x65, 0xfc, 0x05, 0x11, 0x80, 0x00, 0x06, 0x11, 0x80, 0x50, 0x60, 0x00, 0xb0, 0x40, 0xa0, 0x00, 0xb0, 0x00, 0x00, 0x80, 0x00, 0xfd, 0x63, 0x05, 0x62, 0x44, 0xac, 0xe0, 0xf3, 0x0a, 0x72, 0x04, 0x61, 0x00, 0x18, 0xa7, 0xee, 0x00, 0x65, 0x03, 0x10, 0x00, 0x18, 0x6d, 0xf5, 0x00, 0x65, 0x05, 0x97, 0x00, 0xef, 0x03, 0x63, 0xfd, 0x63, 0x05, 0x62, 0x00, 0x18, 0x5b, 0x3a, 0x00, 0x65, 0x09, 0xb2, 0x40, 0x9a, 0x61, 0x42, 0x07, 0x23, 0x24, 0x6b, 0x78, 0xea, 0x07, 0xb3, 0x12, 0xea, 0x49, 0xe3, 0x06, 0xb3, 0x63, 0xda, 0x80, 0x18, 0x4e, 0x30, 0x00, 0x65, 0x05, 0x97, 0x00, 0xef, 0x03, 0x63, 0x80, 0x04, 0x11, 0x80, 0x0c, 0x8a, 0x11, 0x80, 0x45, 0xd0, 0x10, 0x80, 0xfa, 0x63, 0x0b, 0x62, 0x0a, 0xd1, 0x09, 0xd0, 0x44, 0xac, 0x04, 0x67, 0x60, 0x9c, 0x01, 0x72, 0x2a, 0x61, 0x3f, 0x69, 0x6c, 0xe9, 0x20, 0x71, 0x0b, 0x61, 0x25, 0xb2, 0x6c, 0xea, 0x08, 0x2a, 0x24, 0xb3, 0x40, 0xdb, 0x24, 0xb3, 0x40, 0xdb, 0x40, 0x9c, 0x24, 0xb3, 0x6d, 0xea, 0x40, 0xdc, 0x02, 0x6a, 0x04, 0xd2, 0x22, 0xb2, 0x05, 0xd2, 0x40, 0x98, 0x04, 0x6c, 0xfa, 0x6d, 0x06, 0xd2, 0x41, 0x98, 0x80, 0xf6, 
+0x17, 0x6e, 0x41, 0xf5, 0x0d, 0x6f, 0x20, 0x18, 0xc5, 0x30, 0x07, 0xd2, 0x30, 0x71, 0x24, 0x61, 0x42, 0xa0, 0x22, 0x2a, 0x17, 0xb3, 0x40, 0xdb, 0x19, 0xb3, 0x40, 0xdb, 0x19, 0xb3, 0x40, 0xdb, 0x1b, 0x10, 0x19, 0xb2, 0x20, 0xa2, 0x18, 0x29, 0x02, 0x6a, 0x04, 0xd2, 0x13, 0xb2, 0x05, 0xd2, 0x06, 0xd3, 0x41, 0x9c, 0xfa, 0x6d, 0x05, 0x6c, 0xc0, 0xf6, 0x02, 0x6e, 0x41, 0xf5, 0x0e, 0x6f, 0x20, 0x18, 0xc5, 0x30, 0x07, 0xd2, 0x11, 0xb2, 0x40, 0xa2, 0x06, 0x22, 0x40, 0xa0, 0x30, 0x72, 0x03, 0x60, 0x0f, 0xb2, 0x20, 0xda, 0x03, 0x10, 0x00, 0x18, 0xce, 0x31, 0x90, 0x67, 0x0b, 0x97, 0x0a, 0x91, 0x09, 0x90, 0x00, 0xef, 0x06, 0x63, 0x00, 0x00, 0xff, 0x00, 0x1c, 0xde, 0x10, 0x80, 0x4c, 0x8b, 0x10, 0x80, 0x00, 0x00, 0x01, 0x00, 0xb0, 0xe7, 0x04, 0x80, 0x54, 0x8b, 0x10, 0x80, 0x60, 0x8b, 0x10, 0x80, 0x4f, 0x07, 0x11, 0x80, 0x20, 0x94, 0x11, 0x80, 0x50, 0x07, 0x11, 0x80, 0xfd, 0x63, 0x05, 0x62, 0x00, 0x18, 0xa8, 0xba, 0x00, 0x65, 0x05, 0x97, 0x00, 0xef, 0x03, 0x63, 0xf7, 0x63, 0x11, 0x62, 0x10, 0xd0, 0x00, 0x18, 0x25, 0xbb, 0x04, 0x67, 0x44, 0xa8, 0x20, 0xf3, 0x01, 0x72, 0x4b, 0x61, 0x28, 0xb2, 0x60, 0xf1, 0x50, 0xa2, 0x03, 0x72, 0x46, 0x61, 0x27, 0xb2, 0x40, 0xaa, 0x01, 0x72, 0x13, 0x61, 0x26, 0xb2, 0x40, 0xa2, 0x01, 0x72, 0x0f, 0x61, 0x25, 0xb2, 0x60, 0xaa, 0xff, 0xf7, 0x1f, 0x6a, 0x6c, 0xea, 0xff, 0x6b, 0x01, 0x4b, 0x4c, 0xeb, 0x06, 0x23, 0xff, 0xf6, 0x1f, 0x6d, 0xac, 0x6c, 0x00, 0x18, 0xc3, 0x3b, 0x4c, 0xed, 0x1e, 0xb2, 0x40, 0xa2, 0x01, 0x72, 0x2b, 0x61, 0x1d, 0xb2, 0x40, 0xa2, 0x28, 0x2a, 0x09, 0x6a, 0x04, 0xd2, 0x1c, 0xb2, 0x05, 0xd2, 0x1c, 0xb2, 0x80, 0xf2, 0x7e, 0xa2, 0x01, 0x6c, 0xfa, 0x6d, 0x06, 0xd3, 0x80, 0xf2, 0x7f, 0xa2, 0x40, 0xf6, 0x03, 0x6e, 0xc1, 0xf3, 0x19, 0x6f, 0x07, 0xd3, 0xa0, 0xf2, 0x60, 0xa2, 0x08, 0xd3, 0xa0, 0xf2, 0x61, 0xa2, 0x09, 0xd3, 0xa0, 0xf2, 0x62, 0xa2, 0x0a, 0xd3, 0xa0, 0xf2, 0x63, 0xa2, 0x0b, 0xd3, 0xa0, 0xf2, 0x68, 0xa2, 0x0c, 0xd3, 0xa0, 0xf2, 0x66, 0xaa, 0x0d, 0xd3, 0xa0, 0xf2, 0x44, 0xaa, 0x20, 0x18, 0xc5, 0x30, 0x0e, 0xd2, 0x11, 0x97, 0x10, 0x90, 0x00, 0xef, 0x09, 0x63, 0x00, 0x65
+, 0x80, 0x50, 0x11, 0x80, 0x10, 0x1a, 0x11, 0x80, 0x08, 0x1a, 0x11, 0x80, 0xac, 0x00, 0x00, 0xb6, 0x44, 0x38, 0x11, 0x80, 0x28, 0x3a, 0x11, 0x80, 0xb0, 0xe7, 0x04, 0x80, 0x74, 0x54, 0x11, 0x80, 0xfd, 0x63, 0x05, 0x62, 0x00, 0x18, 0xc7, 0x5c, 0x00, 0x65, 0x05, 0x97, 0x00, 0xef, 0x03, 0x63, 0xfd, 0x63, 0x05, 0x62, 0x00, 0x18, 0x8c, 0x8e, 0x00, 0x65, 0x05, 0x97, 0x00, 0xef, 0x03, 0x63, 0xfd, 0x63, 0x05, 0x62, 0x00, 0x18, 0x50, 0x5d, 0x00, 0x65, 0x05, 0x97, 0x00, 0xef, 0x03, 0x63, 0xef, 0x63, 0x21, 0x62, 0x20, 0xd1, 0x1f, 0xd0, 0x44, 0xac, 0x24, 0x67, 0x60, 0xf2, 0x04, 0x72, 0x18, 0x61, 0xa3, 0xb2, 0x60, 0xf1, 0x52, 0xa2, 0xa0, 0xf0, 0x0b, 0x22, 0x00, 0x1c, 0xf6, 0x1b, 0x00, 0x65, 0x00, 0x18, 0xaf, 0x58, 0x02, 0x67, 0x80, 0x18, 0x22, 0x29, 0x03, 0x6c, 0x00, 0x18, 0x4a, 0x56, 0x00, 0x6c, 0x20, 0x18, 0x18, 0x26, 0x00, 0x65, 0x00, 0x1c, 0xfd, 0x1b, 0x90, 0x67, 0x28, 0x11, 0x60, 0xf4, 0x1f, 0x72, 0x80, 0xf0, 0x14, 0x61, 0x95, 0xb2, 0x41, 0x9a, 0xfe, 0x4a, 0x02, 0x5a, 0x80, 0xf0, 0x0e, 0x60, 0x40, 0x9c, 0x17, 0x05, 0x84, 0x42, 0x20, 0x18, 0x03, 0x25, 0x1c, 0xd2, 0x90, 0xb3, 0x80, 0xa3, 0x1c, 0x92, 0x8f, 0xb3, 0x07, 0x2c, 0x60, 0xa3, 0x02, 0x2b, 0x8e, 0xb4, 0x60, 0xc4, 0x01, 0x4b, 0x8c, 0xb4, 0x03, 0x10, 0x60, 0xa3, 0x02, 0x2b, 0x8b, 0xb4, 0x60, 0xc4, 0x00, 0x6c, 0x3f, 0x10, 0x8a, 0xb3, 0x84, 0x35, 0xb5, 0xe3, 0xfd, 0x67, 0xc0, 0xad, 0x40, 0xf0, 0xbc, 0xaf, 0xce, 0xed, 0x33, 0x2d, 0xa7, 0x44, 0x11, 0x4d, 0xa4, 0x35, 0xb5, 0xe3, 0xc0, 0xad, 0x40, 0xf0, 0xbe, 0xaf, 0xce, 0xed, 0x2a, 0x2d, 0xa7, 0x44, 0x29, 0x4d, 0xa4, 0x35, 0xad, 0xe3, 0xa0, 0xab, 0x60, 0xf0, 0x60, 0xaf, 0xae, 0xeb, 0x21, 0x2b, 0x7d, 0xb4, 0x80, 0x9c, 0xa2, 0x67, 0x00, 0x18, 0x6a, 0x1d, 0x1c, 0xd3, 0x05, 0x6a, 0x04, 0xd2, 0x7a, 0xb2, 0x05, 0xd2, 0x40, 0xa0, 0x1c, 0x93, 0x02, 0x6c, 0x06, 0xd2, 0x07, 0xd3, 0x7d, 0x67, 0x60, 0xf0, 0x40, 0xab, 0xfa, 0x6d, 0x60, 0xf4, 0x09, 0x6e, 0x08, 0xd2, 0x40, 0xf0, 0x5e, 0xab, 0x61, 0xf6, 0x1e, 0x6f, 0x09, 0xd2, 0x40, 0xf0, 0x5c, 0xab, 0x20, 0x18, 0xc5, 0x30, 0x0a, 0xd2, 0xca, 0x10, 0x01, 0x4c, 0xff, 0x6b, 0x6c, 
+0xec, 0x69, 0xb0, 0x60, 0xa0, 0x63, 0xec, 0xbd, 0x61, 0x18, 0x5c, 0x16, 0x60, 0xfd, 0x67, 0x40, 0xf0, 0xdc, 0xaf, 0x66, 0xb2, 0x84, 0x35, 0xb5, 0xe2, 0xc0, 0xcd, 0xa7, 0x44, 0x11, 0x4d, 0x30, 0x4c, 0x84, 0x34, 0xa4, 0x35, 0xb5, 0xe2, 0x40, 0xf0, 0xde, 0xaf, 0x89, 0xe2, 0x60, 0xf0, 0x80, 0xaf, 0x01, 0x4b, 0xc0, 0xcd, 0x60, 0xc0, 0x80, 0xca, 0x05, 0x6a, 0x04, 0xd2, 0x5d, 0xb2, 0x05, 0xd2, 0x59, 0xb2, 0x40, 0xa2, 0x7d, 0x67, 0x01, 0x6c, 0x06, 0xd2, 0x01, 0x6a, 0x07, 0xd2, 0x60, 0xf0, 0x40, 0xab, 0xfa, 0x6d, 0x60, 0xf4, 0x1a, 0x6e, 0x08, 0xd2, 0x40, 0xf0, 0x5e, 0xab, 0x61, 0xf6, 0x1e, 0x6f, 0x09, 0xd2, 0x40, 0xf0, 0x5c, 0xab, 0x20, 0x18, 0xc5, 0x30, 0x0a, 0xd2, 0x44, 0xa9, 0x80, 0xf4, 0x00, 0x72, 0x80, 0xf0, 0x08, 0x61, 0x00, 0x99, 0x64, 0xa0, 0x8b, 0xa8, 0x66, 0x32, 0x13, 0x72, 0x1a, 0xd4, 0x02, 0x60, 0x18, 0x72, 0x7f, 0x61, 0x66, 0x33, 0x41, 0x99, 0x1b, 0xd3, 0xa4, 0xa1, 0x16, 0x04, 0xba, 0xc0, 0x00, 0x18, 0xa9, 0x97, 0x1c, 0xd2, 0x1b, 0x95, 0x1c, 0x92, 0x7f, 0x75, 0x04, 0x60, 0x00, 0x6c, 0xe1, 0xf4, 0x16, 0x6f, 0x03, 0x10, 0x85, 0xa0, 0x01, 0xf4, 0x16, 0x6f, 0x10, 0x6d, 0x64, 0xa0, 0x04, 0xd5, 0x3e, 0xb5, 0x05, 0xd5, 0x1b, 0x96, 0x16, 0x95, 0x08, 0xd4, 0x07, 0xd6, 0x06, 0xd5, 0x99, 0xa0, 0xa3, 0x67, 0x0a, 0xd2, 0x09, 0xd4, 0x01, 0x6c, 0x8c, 0xed, 0x0b, 0xd5, 0xab, 0xa8, 0xc0, 0xf4, 0x09, 0x6e, 0x0c, 0xd5, 0x36, 0xb5, 0x49, 0xe5, 0x44, 0xa2, 0x0e, 0xd3, 0xfa, 0x6d, 0x4c, 0xec, 0x0d, 0xd4, 0x45, 0xa0, 0x04, 0x6c, 0x0f, 0xd2, 0x46, 0xa0, 0x10, 0xd2, 0x47, 0xa0, 0x11, 0xd2, 0x48, 0xa0, 0x12, 0xd2, 0x49, 0xa0, 0x13, 0xd2, 0x4a, 0xa0, 0x14, 0xd2, 0x4b, 0xa0, 0x20, 0x18, 0xc5, 0x30, 0x15, 0xd2, 0x1a, 0x97, 0xff, 0x77, 0x35, 0x60, 0xc0, 0xf2, 0x0c, 0x69, 0x38, 0xef, 0x28, 0xb2, 0x12, 0xe9, 0x25, 0xe2, 0xe0, 0xf0, 0x46, 0xa1, 0x01, 0x72, 0x2b, 0x61, 0xc0, 0xf0, 0x48, 0xa1, 0x0b, 0x72, 0x11, 0x61, 0x24, 0xb2, 0x80, 0x9a, 0x00, 0x18, 0x6a, 0x1d, 0xb0, 0x67, 0x00, 0xf2, 0x0f, 0xa1, 0x01, 0x6a, 0x4e, 0xe8, 0x26, 0x28, 0x8b, 0x99, 0x00, 0x18, 0x3a, 0x1d, 0x00, 0x6d, 0x00, 0xf2, 0x0f, 0xc1, 0x1f, 0x10, 0x1a, 0x94, 0x00
+, 0x18, 0xfb, 0xe1, 0xb0, 0x67, 0x1b, 0x93, 0x13, 0x73, 0x05, 0x61, 0x1a, 0x95, 0x20, 0x18, 0x1e, 0x04, 0x90, 0x67, 0x0a, 0x10, 0x1b, 0x94, 0x18, 0x74, 0x07, 0x61, 0x12, 0x6a, 0xc0, 0xf0, 0x48, 0xc1, 0x1a, 0x95, 0x20, 0x18, 0x71, 0x01, 0x90, 0x67, 0x10, 0xb2, 0x80, 0x9a, 0x00, 0x18, 0x6a, 0x1d, 0xb0, 0x67, 0x03, 0x10, 0x20, 0x18, 0x6a, 0x24, 0x91, 0x67, 0x21, 0x97, 0x20, 0x91, 0x1f, 0x90, 0x00, 0xef, 0x11, 0x63, 0x80, 0x50, 0x11, 0x80, 0x18, 0x73, 0x11, 0x80, 0x19, 0x73, 0x11, 0x80, 0x24, 0x94, 0x11, 0x80, 0x28, 0x94, 0x11, 0x80, 0x00, 0x47, 0x11, 0x80, 0xb0, 0xe7, 0x04, 0x80, 0x30, 0x3a, 0x11, 0x80, 0x74, 0x54, 0x11, 0x80, 0xf8, 0x46, 0x11, 0x80, 0x04, 0x0b, 0x0f, 0x04, 0x0a, 0x0e, 0x08, 0x0b, 0x0f, 0x00, 0x00, 0x00, 0x1b, 0x00, 0xb7, 0x00, 0x53, 0x01, 0x36, 0x00, 0x6f, 0x01, 0xa7, 0x02, 0x53, 0x00, 0x28, 0x02, 0xfd, 0x03, 0x25, 0x00, 0x07, 0x04, 0x05, 0x01, 0x00, 0x00, 0x00, 0x00, 0x74, 0x41, 0x01, 0x10, 0xac, 0x80, 0x02, 0xf0, 0x78, 0x41, 0x07, 0x20, 0x7a, 0x41, 0xb1, 0x01, 0x7c, 0x41, 0x07, 0x00, 0x7e, 0x41, 0xb1, 0x01, 0x0a, 0x22, 0x62, 0x02, 0x4e, 0x22, 0x9a, 0x06, 0x50, 0x22, 0x9a, 0x06, 0x18, 0x20, 0x0f, 0x69, 0x34, 0x20, 0x55, 0x22, 0x38, 0x20, 0xa8, 0xc0, 0x00, 0x00, 0x06, 0x10, 0x0e, 0x00, 0x22, 0x10, 0x16, 0x00, 0x00, 0x24, 0x16, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x20, 0x81, 0x25, 0x00, 0x93, 0x23, 0x2b, 0x00, 0x80, 0x48, 0x21, 0x00, 0x00, 0x42, 0x24, 0x00, 0x00, 0xfe, 0x26, 0x00, 0x2a, 0x08, 0x26, 0x00, 0x2a, 0x08, 0x27, 0x00, 0x60, 0x04, 0x28, 0x00, 0x42, 0xc0, 0x29, 0x00, 0x18, 0xc4, 0x2a, 0x00, 0xc0, 0x40, 0x2d, 0x00, 0x08, 0x00, 0x37, 0x00, 0x04, 0xc0, 0x0e, 0x00, 0x22, 0x90, 0x31, 0x00, 0x01, 0x50, 0x32, 0x00, 0x71, 0x00, 0x33, 0x00, 0x70, 0x6f, 0x0e, 0x00, 0xa2, 0x11, 0x2a, 0x00, 0xc0, 0x46, 0x24, 0x00, 0x01, 0xfe, 0x00, 0x60, 0x00, 0x01, 0x2a, 0x00, 0xd0, 0x40, 0x1c, 0x00, 0x21, 0x81, 0x00, 0x60, 0x01, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x60, 0x01, 0x00, 0x3f, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x20, 0xff, 0xff, 0xff, 0xff, 0x13, 0x00, 0x9b, 0x7d, 0x13, 0x00, 
+0x0e, 0x60, 0x13, 0x00, 0x9e, 0x5c, 0x13, 0x00, 0x0a, 0x30, 0x13, 0x00, 0xf8, 0x2f, 0x13, 0x00, 0xc5, 0x1f, 0x13, 0x00, 0x90, 0x00, 0xff, 0xff, 0xff, 0xff, 0x1f, 0x00, 0xcb, 0x70, 0x20, 0x00, 0xc4, 0xff, 0x22, 0x00, 0x00, 0x00, 0x23, 0x00, 0x15, 0xe0, 0x15, 0x00, 0x40, 0x00, 0x15, 0x00, 0xc0, 0x20, 0x15, 0x00, 0xc0, 0x48, 0x15, 0x00, 0xc0, 0x69, 0x15, 0x00, 0xc0, 0x90, 0x15, 0x00, 0xc0, 0xb1, 0x15, 0x00, 0xc0, 0xd8, 0x15, 0x00, 0xc0, 0xf9, 0xff, 0xff, 0xff, 0xff, 0x08, 0x08, 0x08, 0x08, 0x08, 0x0b, 0x28, 0x2b, 0x48, 0x4b, 0xc8, 0xcc, 0xe9, 0xec, 0xee, 0xff, 0xf7, 0xf7, 0xf8, 0xf9, 0x07, 0x08, 0x0a, 0x0c, 0x0e, 0x1c, 0x1e, 0x1f, 0x1f, 0x00, 0x00, 0x00, 0xf7, 0xf7, 0x00, 0x00, 0x1f, 0x1f, 0x00, 0x00, 0x3f, 0x3f, 0x3f, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21, 0x00, 0x00, 0xc2, 0x00, 0x00, 0x00, 0x50, 0x01, 0x00, 0x00, 0x17, 0x02, 0x00, 0x00, 0xcc, 0x3f, 0x00, 0x01, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x60, 0xf4, 0x01, 0x00, 0x20, 0x01, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x40, 0x20, 0x00, 0x48, 0x42, 0x20, 0x00, 0x01, 0x44, 0x20, 0x00, 0x48, 0x46, 0x20, 0x00, 0x81, 0x48, 0x20, 0x00, 0x00, 0x4a, 0x20, 0x00, 0xf8, 0x4c, 0x20, 0x00, 0x00, 0x4e, 0x20, 0xd0, 0x00, 0x50, 0x20, 0x30, 0xcc, 0x52, 0x20, 0x00, 0x18, 0x54, 0x20, 0x10, 0x8c, 0x56, 0x20, 0x00, 0xe0, 0x58, 0x20, 0x00, 0x50, 0x5a, 0x20, 0x00, 0x80, 0x5c, 0x20, 0x00, 0x20, 0x5e, 0x20, 0x00, 0x00, 0x00, 0x20, 0x01, 0x00, 0x08, 0x20, 0x14, 0x14, 0x0e, 0x20, 0x01, 0x00, 0x02, 0x20, 0x60, 0xc0, 0x00, 0x60, 0x0a, 0x00, 0x02, 0x20, 0x20, 0xc0, 0x00, 0x60, 0x0a, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x20, 0x01, 0x00, 0x02, 0x20, 0x20, 0x00, 0x0c, 0x20, 0x10, 0x00, 0x0e, 0x20, 0x00, 0x80, 0x00, 0x20, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x50, 0x50, 0x6a, 0x6a, 0x94, 0x2a, 0x00, 0x00, 0xd3, 0x4d, 0x2f, 0x80, 0x00, 0x00
+, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfd, 0x63, 0x05, 0x62, 0x00, 0x6a, 0x42, 0xb3, 0x40, 0xdb, 0x42, 0xb4, 0x42, 0xb3, 0xa0, 0x9c, 0x40, 0xc3, 0x42, 0xb2, 0xac, 0xea, 0x42, 0xb5, 0xae, 0xea, 0x03, 0x2a, 0x40, 0xdc, 0x01, 0x6a, 0x40, 0xc3, 0x40, 0xb2, 0x40, 0x9a, 0x40, 0xb3, 0x42, 0x34, 0x82, 0x34, 0x80, 0xcb, 0x3f, 0xb3, 0x40, 0xcb, 0x3f, 0xb3, 0x3f, 0xb2, 0x80, 0x18, 0x65, 0x2d, 0x60, 0xda, 0x3e, 0xb3, 0x3f, 0xb2, 0x60, 0xda, 0x3f, 0xb3, 0x3f, 0xb2, 0x60, 0xda, 0x3f, 0xb3, 0x40, 0xb2, 0x60, 0xda, 0x40, 0xb3, 0x40, 0xb2, 0x60, 0xda, 0x40, 0xb3, 0x41, 0xb2, 0x60, 0xda, 0x41, 0xb3, 0x41, 0xb2, 0x60, 0xda, 0x41, 0xb3, 0x42, 0xb2, 0x60, 0xda, 0x42, 0xb3, 0x42, 0xb2, 0x60, 0xda, 0x42, 0xb2, 0x45, 0xf1, 0x09, 0x6b, 0x00, 0xf1, 0x70, 0xca, 0x41, 0xb3, 0x00, 0xf4, 0x00, 0x6c, 0xa0, 0xf0, 0x96, 0xca, 0x63, 0xda, 0x3f, 0xb3, 0x64, 0xda, 0x00, 0x6b, 0x65, 0xda, 0x66, 0xda, 0x67, 0xda, 0x68, 0xda, 0x69, 0xda, 0x02, 0x6b, 0x80, 0xf1, 0x62, 0xc2, 0x00, 0xf2, 0x00, 0x6b, 0xa0, 0xf0, 0x72, 0xca, 0x90, 0x6b, 0xa0, 0xf0, 0x74, 0xca, 0xa0, 0xf0, 0x78, 0xca, 0x36, 0xb3, 0x36, 0xb2, 0x60, 0xda, 0x36, 0xb3, 0x37, 0xb2, 0x60, 0xda, 0x37, 0xb3, 0x37, 0xb2, 0x60, 0xda, 0x37, 0xb3, 0x38, 0xb2, 0x60, 0xda, 0x38, 0xb3, 0x38, 0xb2, 0x60, 0xda, 0x38, 0xb3, 0x39, 0xb2, 0x60, 0xda, 0x39, 0xb3, 0x39, 0xb2, 0x60, 0xda, 0x39, 0xb3, 0x3a, 0xb2, 0x60, 0xda, 0x3a, 0xb3, 0x3a, 0xb2, 0x60, 0xda, 0x3a, 
+0xb3, 0x3b, 0xb2, 0x80, 0x18, 0x19, 0x34, 0x60, 0xda, 0x3a, 0xb2, 0x63, 0xa2, 0x80, 0x6a, 0x4b, 0xea, 0x6c, 0xea, 0xff, 0x6b, 0x6c, 0xea, 0x05, 0x2a, 0x37, 0xb3, 0x80, 0xa3, 0xfe, 0x4a, 0x8c, 0xea, 0x40, 0xc3, 0x05, 0x97, 0x00, 0xef, 0x03, 0x63, 0x00, 0x65, 0x4c, 0x8b, 0x10, 0x80, 0x54, 0x8b, 0x10, 0x80, 0x08, 0x94, 0x10, 0x80, 0xff, 0xff, 0xff, 0x00, 0xee, 0xff, 0xc0, 0x00, 0x94, 0xde, 0x10, 0x80, 0x52, 0x00, 0x11, 0x80, 0x50, 0x00, 0x11, 0x80, 0xcd, 0xc5, 0x10, 0x80, 0xd4, 0x07, 0x11, 0x80, 0xc9, 0xb7, 0x10, 0x80, 0x20, 0x08, 0x11, 0x80, 0x7d, 0xd6, 0x10, 0x80, 0xe0, 0x1a, 0x11, 0x80, 0x0d, 0xd0, 0x10, 0x80, 0x04, 0x07, 0x11, 0x80, 0x29, 0xb8, 0x10, 0x80, 0xd0, 0x06, 0x11, 0x80, 0x2d, 0xcf, 0x10, 0x80, 0xa0, 0x07, 0x11, 0x80, 0x95, 0xb7, 0x10, 0x80, 0xe8, 0x06, 0x11, 0x80, 0x79, 0xce, 0x10, 0x80, 0x30, 0x19, 0x11, 0x80, 0x9d, 0xcd, 0x10, 0x80, 0x80, 0x07, 0x11, 0x80, 0x58, 0x00, 0x11, 0x80, 0x14, 0xc0, 0x52, 0x02, 0x58, 0xd5, 0xc8, 0x19, 0x39, 0xaf, 0x10, 0x80, 0x6c, 0x07, 0x11, 0x80, 0xd1, 0xb8, 0x10, 0x80, 0x04, 0x1a, 0x11, 0x80, 0x85, 0xc6, 0x10, 0x80, 0xd8, 0x06, 0x11, 0x80, 0xc5, 0xb7, 0x10, 0x80, 0x44, 0x08, 0x11, 0x80, 0xe1, 0xc8, 0x10, 0x80, 0x04, 0x19, 0x11, 0x80, 0xd1, 0xb7, 0x10, 0x80, 0x08, 0x19, 0x11, 0x80, 0x85, 0xb8, 0x10, 0x80, 0xc8, 0x07, 0x11, 0x80, 0xf9, 0xc0, 0x10, 0x80, 0x0c, 0x19, 0x11, 0x80, 0x71, 0xc0, 0x10, 0x80, 0x68, 0x19, 0x11, 0x80, 0xb1, 0xcb, 0x10, 0x80, 0x64, 0x07, 0x11, 0x80, 0x6c, 0x3a, 0x11, 0x80, 0x3b, 0x02, 0x11, 0x80, 0xfd, 0x63, 0x05, 0x62, 0x04, 0xd0, 0x0c, 0xb0, 0x90, 0x67, 0x00, 0x6d, 0x00, 0x18, 0x5a, 0x33, 0x38, 0x6e, 0x01, 0x6a, 0x4b, 0xea, 0x47, 0xd8, 0x70, 0x6a, 0x43, 0xc0, 0x0a, 0x6a, 0x4c, 0xc0, 0x08, 0x6a, 0x4d, 0xc0, 0x00, 0x6b, 0x05, 0xb2, 0x60, 0xc2, 0x05, 0x97, 0x04, 0x90, 0x00, 0xef, 0x03, 0x63, 0x00, 0x65, 0x28, 0x94, 0x11, 0x80, 0x60, 0x94, 0x11, 0x80, 0xd6, 0x63, 0x53, 0x62, 0x52, 0xd1, 0x51, 0xd0, 0x00, 0xf4, 0x05, 0x6a, 0x7d, 0x67, 0x52, 0xcb, 0x0d, 0x6a, 0x20, 0xf0, 0x46, 0xc3, 0x20, 0xf0, 0x07, 0x04, 0x71, 0xb5, 0x00, 0x18, 0x27, 0x33, 0x06
+, 0x6e, 0x9d, 0x67, 0x01, 0x6a, 0x00, 0x6b, 0x20, 0xf0, 0x4f, 0xc4, 0x20, 0xf0, 0x53, 0xc4, 0x6c, 0xb2, 0x20, 0xf0, 0x6d, 0xc4, 0x20, 0xf0, 0x6e, 0xc4, 0x20, 0xf0, 0x70, 0xc4, 0x20, 0xf0, 0x71, 0xc4, 0x20, 0xf0, 0x72, 0xc4, 0xc0, 0xf1, 0x6a, 0xc2, 0xc0, 0xf1, 0x7e, 0xc2, 0x03, 0x6b, 0x02, 0x6c, 0xc0, 0xf1, 0x7c, 0xc2, 0x64, 0xb3, 0xc0, 0xf1, 0x89, 0xc2, 0xc0, 0xf1, 0x88, 0xc2, 0xc0, 0xf1, 0x9d, 0xc2, 0x80, 0xc3, 0x61, 0xb3, 0x00, 0x6c, 0x80, 0xdb, 0x81, 0xdb, 0x60, 0xf1, 0x70, 0xa2, 0x44, 0x67, 0x02, 0x73, 0x07, 0x60, 0x03, 0x73, 0xa0, 0xf0, 0x07, 0x60, 0x01, 0x73, 0xa0, 0xf0, 0x04, 0x60, 0x0f, 0x10, 0xc0, 0xf2, 0x0c, 0x6b, 0x78, 0xea, 0x58, 0xb4, 0x12, 0xeb, 0x6d, 0xe4, 0xc0, 0xf0, 0x68, 0xa3, 0x80, 0xf0, 0x19, 0x2b, 0x01, 0x4a, 0xff, 0x6b, 0x6c, 0xea, 0x0a, 0x5a, 0xf1, 0x61, 0x00, 0x18, 0x58, 0x5e, 0x09, 0x04, 0x4a, 0xd2, 0x80, 0xf0, 0x10, 0x2a, 0x7d, 0x67, 0x20, 0xf0, 0x6d, 0xa3, 0x5d, 0x67, 0x9d, 0x67, 0x20, 0xf0, 0x4e, 0xa2, 0x20, 0xf0, 0x8f, 0xa4, 0x4e, 0xd3, 0x7d, 0x67, 0x4f, 0xd2, 0x4d, 0xd4, 0x5d, 0x67, 0x20, 0xf0, 0x93, 0xa3, 0x20, 0xf0, 0x50, 0xa2, 0x20, 0xf0, 0x02, 0x05, 0x4b, 0xd4, 0x4c, 0xd2, 0x20, 0xf0, 0x12, 0xa3, 0x20, 0xf0, 0x31, 0xa3, 0x00, 0x18, 0x71, 0xdf, 0x08, 0x04, 0x02, 0x22, 0x4a, 0xd2, 0x70, 0x10, 0x5d, 0x67, 0x00, 0x30, 0x2d, 0xe8, 0x31, 0xaa, 0xc0, 0xf2, 0x0c, 0x6a, 0x38, 0xb5, 0x58, 0xe9, 0x3b, 0xb2, 0x12, 0xe9, 0x45, 0xe1, 0xe0, 0xf0, 0x88, 0x41, 0x00, 0x18, 0x27, 0x33, 0x06, 0x6e, 0x4f, 0x93, 0x4e, 0x94, 0x60, 0x32, 0x8d, 0xea, 0x60, 0xf2, 0x58, 0xc9, 0x5d, 0x67, 0x30, 0xf1, 0x64, 0x42, 0x40, 0xa3, 0x7d, 0x67, 0x30, 0xf1, 0x80, 0x43, 0xe0, 0xf0, 0x55, 0xc1, 0x60, 0xa4, 0x9d, 0x67, 0x20, 0xf1, 0x4c, 0x44, 0xe0, 0xf0, 0x77, 0xc1, 0x80, 0xa2, 0x7d, 0x67, 0xe0, 0xf0, 0x98, 0xc1, 0x20, 0xf0, 0x40, 0xa3, 0xe0, 0xf0, 0x4e, 0xc1, 0x01, 0x6a, 0x60, 0xf2, 0x5a, 0xc1, 0x00, 0x18, 0xfd, 0x9b, 0x91, 0xab, 0x9d, 0x67, 0x20, 0xf1, 0x48, 0x44, 0x80, 0xa2, 0x02, 0x32, 0x5e, 0x32, 0x00, 0xf1, 0x8c, 0xc1, 0x13, 0x22, 0xef, 0xf7, 0x1f, 0x6a, 0x0c, 0xea, 0x01, 0x6b, 0x80, 0xf0, 0x44, 0xc9, 
+0x06, 0x6c, 0x04, 0xd3, 0xfc, 0x6d, 0x1e, 0xb3, 0x20, 0xf5, 0x06, 0x6e, 0x20, 0xf5, 0x17, 0x6f, 0x05, 0xd3, 0x20, 0x18, 0x00, 0x2d, 0x06, 0xd2, 0x06, 0x10, 0x5d, 0x67, 0x20, 0xf1, 0x68, 0x42, 0x40, 0xab, 0x80, 0xf0, 0x44, 0xc9, 0x00, 0x18, 0xaa, 0x9f, 0x09, 0x04, 0x02, 0x67, 0x0e, 0x22, 0x7d, 0x67, 0x20, 0xf0, 0x80, 0xa3, 0xe0, 0xf0, 0xa3, 0xa1, 0x00, 0x18, 0x4b, 0xdf, 0x00, 0x65, 0x0a, 0xb4, 0x00, 0x18, 0x47, 0xdf, 0x00, 0x65, 0x4a, 0xd0, 0x08, 0x10, 0x5d, 0x67, 0x91, 0xaa, 0x20, 0x18, 0x66, 0x22, 0x01, 0x6d, 0x02, 0x10, 0x0c, 0x6b, 0x4a, 0xd3, 0x4a, 0x92, 0x53, 0x97, 0x52, 0x91, 0x51, 0x90, 0x00, 0xef, 0x2a, 0x63, 0x3c, 0x94, 0x11, 0x80, 0xc0, 0x50, 0x11, 0x80, 0x49, 0x50, 0x11, 0x80, 0xf0, 0x51, 0x11, 0x80, 0xb4, 0x54, 0x11, 0x80, 0x00, 0xd9, 0x04, 0x80, 0xfd, 0x63, 0x05, 0x62, 0x10, 0xb3, 0x00, 0x6d, 0xc0, 0xf1, 0xaa, 0xc3, 0xc0, 0xf1, 0xbe, 0xc3, 0xff, 0x6a, 0x03, 0x6d, 0x8c, 0xea, 0xc0, 0xf1, 0xbc, 0xc3, 0x02, 0x6c, 0x0b, 0xb5, 0xc0, 0xf1, 0x89, 0xc3, 0xc0, 0xf1, 0x88, 0xc3, 0xc0, 0xf1, 0x9d, 0xc3, 0x60, 0xf1, 0x40, 0xc3, 0x80, 0xc5, 0x00, 0x18, 0x76, 0xa7, 0x82, 0x67, 0x06, 0xb2, 0x00, 0x6b, 0x60, 0xda, 0x61, 0xda, 0x05, 0x97, 0x00, 0xef, 0x03, 0x63, 0xc0, 0x50, 0x11, 0x80, 0x49, 0x50, 0x11, 0x80, 0xf0, 0x51, 0x11, 0x80, 0xdc, 0x63, 0x47, 0x62, 0x00, 0xf4, 0x06, 0x6a, 0x7d, 0x67, 0x4a, 0xcb, 0x03, 0x6a, 0x56, 0xc3, 0x13, 0x6a, 0x59, 0xc3, 0x1d, 0xb2, 0x6d, 0xa2, 0x08, 0x73, 0x1a, 0x60, 0xff, 0x6c, 0x09, 0x4c, 0x98, 0xeb, 0x1b, 0xb2, 0x01, 0x6d, 0x12, 0xec, 0x91, 0xe2, 0x20, 0xf1, 0xcf, 0xa4, 0xac, 0xee, 0x0f, 0x26, 0x00, 0xf1, 0x52, 0xaa, 0x47, 0xeb, 0xac, 0xea, 0x0a, 0x22, 0x20, 0xf1, 0x4c, 0xac, 0x7d, 0x67, 0x05, 0x04, 0x57, 0xc3, 0x42, 0x32, 0x58, 0xc3, 0x00, 0x18, 0x18, 0x4f, 0x04, 0x05, 0x0e, 0xb2, 0x4c, 0xa2, 0x0a, 0x72, 0x14, 0x60, 0xc0, 0xf2, 0x0c, 0x6b, 0x78, 0xea, 0x0d, 0xb3, 0x12, 0xea, 0x49, 0xe3, 0xe0, 0xf0, 0x66, 0xa2, 0x01, 0x73, 0x0a, 0x61, 0x60, 0xf2, 0x56, 0xaa, 0x7d, 0x67, 0x05, 0x04, 0x57, 0xc3, 0x42, 0x32, 0x58, 0xc3, 0x00, 0x18, 0x18, 0x4f, 0x04, 0x05, 0x47, 0x97, 0x00, 0xef
+, 0x24, 0x63, 0x00, 0x65, 0x28, 0x94, 0x11, 0x80, 0x40, 0x3b, 0x11, 0x80, 0xb4, 0x54, 0x11, 0x80, 0xdc, 0x63, 0x47, 0x62, 0x46, 0xd0, 0x00, 0x6a, 0x18, 0xb3, 0x9d, 0x67, 0x40, 0xdb, 0x41, 0xdb, 0x04, 0xf0, 0x06, 0x6b, 0x68, 0xcc, 0x54, 0xc4, 0x56, 0xc4, 0x57, 0xc4, 0x58, 0xc4, 0x59, 0xc4, 0x5a, 0xc4, 0x5b, 0xc4, 0x5c, 0xc4, 0x5d, 0xc4, 0x5e, 0xc4, 0x5f, 0xc4, 0x0f, 0x6b, 0x07, 0x6a, 0x04, 0x00, 0x72, 0xc4, 0x20, 0xf0, 0x40, 0xc4, 0x20, 0x6b, 0x03, 0x6a, 0x73, 0xc4, 0x75, 0xc4, 0x20, 0xf0, 0x41, 0xc4, 0x00, 0x18, 0x5c, 0xc7, 0x90, 0x67, 0x7d, 0x67, 0x04, 0xf0, 0x0a, 0x6a, 0x48, 0xcb, 0x01, 0x6a, 0x90, 0x67, 0x52, 0xc3, 0x00, 0x18, 0xd4, 0xc7, 0x53, 0xc3, 0x47, 0x97, 0x46, 0x90, 0x00, 0xef, 0x24, 0x63, 0x00, 0x65, 0xf0, 0x51, 0x11, 0x80, 0xdc, 0x63, 0x47, 0x62, 0x00, 0x6a, 0x21, 0xb3, 0x9d, 0x67, 0x40, 0xdb, 0x41, 0xdb, 0x04, 0xf0, 0x0d, 0x6b, 0x68, 0xcc, 0x19, 0x6b, 0x72, 0xc4, 0x60, 0x6b, 0x6b, 0xeb, 0x73, 0xc4, 0x75, 0xc4, 0x1b, 0xb3, 0x54, 0xc4, 0x56, 0xc4, 0x57, 0xc4, 0x58, 0xc4, 0x94, 0xa3, 0xbd, 0x67, 0x5f, 0xc5, 0x99, 0xc5, 0x95, 0xa3, 0x20, 0xf0, 0x40, 0xc5, 0x20, 0xf0, 0x42, 0xc5, 0x9a, 0xc5, 0x96, 0xa3, 0x20, 0xf0, 0x44, 0xc5, 0x20, 0xf0, 0x45, 0xc5, 0x9b, 0xc5, 0x97, 0xa3, 0x20, 0xf0, 0x47, 0xc5, 0x20, 0xf0, 0x49, 0xc5, 0x9c, 0xc5, 0x98, 0xa3, 0x79, 0xa3, 0x9d, 0xc5, 0x7e, 0xc5, 0x02, 0x6b, 0x20, 0xf0, 0x61, 0xc5, 0x20, 0xf0, 0x63, 0xc5, 0x1e, 0x6b, 0x20, 0xf0, 0x66, 0xc5, 0x12, 0x6b, 0x20, 0xf0, 0x68, 0xc5, 0x20, 0xf0, 0x6a, 0xc5, 0x20, 0xf0, 0x4b, 0xc5, 0x00, 0x18, 0x8a, 0xc5, 0x04, 0x04, 0x47, 0x97, 0x00, 0xef, 0x24, 0x63, 0xf0, 0x51, 0x11, 0x80, 0x28, 0x94, 0x11, 0x80, 0xdc, 0x63, 0x47, 0x62, 0x0c, 0xb2, 0x00, 0x6b, 0x60, 0xda, 0x61, 0xda, 0x7d, 0x67, 0x04, 0xf0, 0x1d, 0x6a, 0x48, 0xcb, 0x01, 0x6a, 0x52, 0xc3, 0x08, 0xb2, 0x41, 0xaa, 0x7f, 0x6b, 0x04, 0x04, 0x4a, 0x32, 0x6c, 0xea, 0x7d, 0x67, 0x00, 0x18, 0xeb, 0xc2, 0x53, 0xc3, 0x47, 0x97, 0x00, 0xef, 0x24, 0x63, 0x00, 0x65, 0xf0, 0x51, 0x11, 0x80, 0x28, 0x94, 0x11, 0x80, 0xdb, 0x63, 0x49, 0x62, 0x48, 0xd1, 0x47, 0xd0, 0x00, 0x69, 0x0e, 
+0xb2, 0x7d, 0x67, 0x20, 0xda, 0x21, 0xda, 0x04, 0xf0, 0x1f, 0x6a, 0x48, 0xcb, 0x0b, 0xb2, 0x81, 0xf1, 0x48, 0xaa, 0x0b, 0xb0, 0x32, 0xc3, 0x04, 0x04, 0x00, 0x18, 0x65, 0xc2, 0x4b, 0xd8, 0x64, 0xa0, 0x41, 0x6a, 0x4b, 0xea, 0x6c, 0xea, 0x29, 0xc0, 0x44, 0xc0, 0x49, 0x97, 0x48, 0x91, 0x47, 0x90, 0x00, 0xef, 0x25, 0x63, 0xf0, 0x51, 0x11, 0x80, 0x40, 0x3b, 0x11, 0x80, 0x28, 0x94, 0x11, 0x80, 0xdc, 0x63, 0x47, 0x62, 0x46, 0xd0, 0x00, 0x68, 0x0b, 0xb2, 0x7d, 0x67, 0x00, 0xda, 0x01, 0xda, 0x04, 0xf0, 0x1f, 0x6a, 0x12, 0xc3, 0x04, 0x04, 0x00, 0x18, 0x65, 0xc2, 0x48, 0xcb, 0x07, 0xb2, 0x84, 0xa2, 0x41, 0x6b, 0x6b, 0xeb, 0x8c, 0xeb, 0x64, 0xc2, 0x09, 0xc2, 0x47, 0x97, 0x46, 0x90, 0x00, 0xef, 0x24, 0x63, 0xf0, 0x51, 0x11, 0x80, 0x28, 0x94, 0x11, 0x80, 0xdc, 0x63, 0x47, 0x62, 0x1c, 0xb2, 0x00, 0x6b, 0x60, 0xda, 0x61, 0xda, 0x1b, 0xb2, 0x64, 0xa2, 0x07, 0x6d, 0x6e, 0x34, 0xac, 0xec, 0x05, 0x54, 0x06, 0x61, 0x39, 0x6c, 0x8b, 0xec, 0x6c, 0xec, 0x20, 0x6b, 0x6d, 0xec, 0x84, 0xc2, 0x15, 0xb2, 0x64, 0xa2, 0x07, 0x6c, 0x14, 0xb5, 0x6e, 0x33, 0x8c, 0xeb, 0x6d, 0xe5, 0x60, 0xa3, 0xc3, 0xa2, 0x6c, 0xec, 0x0f, 0x6b, 0x6b, 0xeb, 0x84, 0x35, 0xcc, 0xeb, 0xad, 0xeb, 0x63, 0xc2, 0xbd, 0x67, 0x04, 0xf0, 0x1e, 0x6b, 0x68, 0xcd, 0x03, 0x6b, 0x72, 0xc5, 0x61, 0xaa, 0x7f, 0x6d, 0x6a, 0x33, 0xac, 0xeb, 0xbd, 0x67, 0x73, 0xc5, 0x40, 0x9a, 0x95, 0xc5, 0x04, 0x04, 0x42, 0x32, 0x00, 0x18, 0xa1, 0xc2, 0x54, 0xc5, 0x47, 0x97, 0x00, 0xef, 0x24, 0x63, 0x00, 0x65, 0xf0, 0x51, 0x11, 0x80, 0x28, 0x94, 0x11, 0x80, 0x80, 0xdc, 0x10, 0x80, 0xfd, 0x63, 0x05, 0x62, 0x57, 0x6c, 0x00, 0x18, 0x46, 0xa4, 0x01, 0x6d, 0xff, 0xf7, 0x1f, 0x6b, 0x02, 0xf1, 0x01, 0x6e, 0x4c, 0xeb, 0xcb, 0xee, 0x6c, 0xee, 0x57, 0x6c, 0x00, 0x18, 0xa4, 0xa4, 0x01, 0x6d, 0x00, 0x6c, 0xa4, 0x67, 0x00, 0x18, 0xa4, 0xa4, 0xc4, 0x67, 0x06, 0xb2, 0x84, 0xa2, 0x41, 0x6b, 0x6b, 0xeb, 0x8c, 0xeb, 0x64, 0xc2, 0x00, 0x6b, 0x69, 0xc2, 0x05, 0x97, 0x00, 0xef, 0x03, 0x63, 0x00, 0x65, 0x28, 0x94, 0x11, 0x80, 0xfc, 0x63, 0x07, 0x62, 0x06, 0xd1, 0x05, 0xd0, 0x7c, 0x6c, 0x00, 0x18, 0x46, 0xa4, 0x01
+, 0x6d, 0x79, 0x6c, 0x01, 0x6d, 0x00, 0x18, 0x46, 0xa4, 0x22, 0x67, 0x1e, 0xb3, 0xff, 0xf7, 0x1f, 0x68, 0x80, 0x9b, 0x0c, 0xe9, 0x4c, 0xe8, 0x4b, 0x9b, 0x96, 0x34, 0xe3, 0xf7, 0x1f, 0x6d, 0x49, 0xe0, 0xac, 0xec, 0x98, 0xea, 0x4b, 0xdb, 0x4d, 0x9b, 0x49, 0xe1, 0x4d, 0xdb, 0x12, 0xec, 0x8c, 0xdb, 0x7d, 0xf2, 0x01, 0x6b, 0x63, 0xe8, 0x02, 0x60, 0x63, 0xe9, 0x1d, 0x61, 0x57, 0x6c, 0x00, 0x18, 0x46, 0xa4, 0x01, 0x6d, 0xff, 0xf7, 0x1f, 0x68, 0x0c, 0xea, 0x01, 0xf6, 0x01, 0x6b, 0x6b, 0xeb, 0xc2, 0x67, 0x6c, 0xee, 0x57, 0x6c, 0x00, 0x18, 0xa4, 0xa4, 0x01, 0x6d, 0x57, 0x6c, 0x00, 0x18, 0x46, 0xa4, 0x01, 0x6d, 0x0c, 0xea, 0x01, 0xf6, 0x00, 0x6b, 0xc2, 0x67, 0x57, 0x6c, 0x01, 0x6d, 0x00, 0x18, 0xa4, 0xa4, 0x6d, 0xee, 0x07, 0x97, 0x06, 0x91, 0x05, 0x90, 0x00, 0xef, 0x04, 0x63, 0x28, 0x94, 0x11, 0x80, 0xfb, 0x63, 0x09, 0x62, 0x08, 0xd1, 0x07, 0xd0, 0x11, 0xb2, 0x47, 0x9a, 0xff, 0x68, 0x8c, 0xe8, 0x01, 0x4a, 0x04, 0x22, 0x0f, 0xb4, 0x00, 0x18, 0xb6, 0x1c, 0x00, 0x65, 0x11, 0x20, 0x00, 0x69, 0x0b, 0xb0, 0x01, 0x6c, 0x0b, 0xb5, 0x0c, 0xb6, 0xf1, 0x67, 0x00, 0x18, 0xc4, 0x1c, 0x04, 0xd1, 0x87, 0x98, 0x00, 0x18, 0xa9, 0x1c, 0x14, 0x6d, 0x00, 0x6a, 0x30, 0xc8, 0x20, 0xf0, 0x49, 0xc0, 0x09, 0x97, 0x08, 0x91, 0x07, 0x90, 0x00, 0xef, 0x05, 0x63, 0x00, 0x65, 0x28, 0x94, 0x11, 0x80, 0x44, 0x94, 0x11, 0x80, 0xd9, 0xa8, 0x10, 0x80, 0xfd, 0x63, 0x05, 0x62, 0x04, 0xd0, 0x57, 0x6c, 0x00, 0x18, 0x46, 0xa4, 0x01, 0x6d, 0xff, 0xf7, 0x1f, 0x68, 0xff, 0x6b, 0x0c, 0xea, 0x02, 0x4b, 0x6b, 0xeb, 0xc2, 0x67, 0x6c, 0xee, 0x57, 0x6c, 0x00, 0x18, 0xa4, 0xa4, 0x01, 0x6d, 0x59, 0x6c, 0x00, 0x18, 0x46, 0xa4, 0x01, 0x6d, 0x0c, 0xea, 0x00, 0xf2, 0x01, 0x6b, 0x6b, 0xeb, 0xc2, 0x67, 0x6c, 0xee, 0x59, 0x6c, 0x00, 0x18, 0xa4, 0xa4, 0x01, 0x6d, 0x00, 0x6c, 0x0c, 0xb0, 0xa4, 0x67, 0x00, 0x18, 0xa4, 0xa4, 0xc4, 0x67, 0xd1, 0xa8, 0x01, 0x6d, 0x00, 0x18, 0xa4, 0xa4, 0x42, 0x6c, 0x80, 0x18, 0x02, 0x2a, 0x00, 0x6c, 0x64, 0xa0, 0x41, 0x6a, 0x4b, 0xea, 0x6c, 0xea, 0x44, 0xc0, 0x00, 0x6a, 0x49, 0xc0, 0x05, 0x97, 0x04, 0x90, 0x00, 0xef, 0x03, 0x63, 0x28, 0x94, 
+0x11, 0x80, 0xfc, 0x63, 0x07, 0x62, 0x06, 0xd1, 0x05, 0xd0, 0x20, 0xb2, 0x47, 0x9a, 0x08, 0xd4, 0x8e, 0xea, 0x05, 0x22, 0x01, 0x4c, 0x03, 0x24, 0x00, 0x18, 0xb6, 0x1c, 0x08, 0x04, 0x1b, 0xb0, 0x64, 0xa0, 0x40, 0x6a, 0x6c, 0xea, 0x08, 0x2a, 0x47, 0x98, 0x01, 0x4a, 0x29, 0x22, 0x18, 0xb4, 0x00, 0x18, 0xb6, 0x1c, 0x00, 0x65, 0x24, 0x10, 0x02, 0x69, 0x6c, 0xe9, 0xff, 0x6a, 0x4c, 0xe9, 0x07, 0x21, 0x80, 0x18, 0xdd, 0x29, 0x00, 0x65, 0x50, 0xa8, 0x01, 0x4a, 0x50, 0xc8, 0x18, 0x10, 0x7d, 0x6c, 0x00, 0x18, 0x46, 0xa4, 0x01, 0x6d, 0x04, 0x6b, 0x4c, 0xeb, 0x06, 0x23, 0x50, 0xa8, 0x20, 0xf0, 0x29, 0xc0, 0x01, 0x4a, 0x50, 0xc8, 0x0b, 0x10, 0x20, 0xf0, 0x49, 0xa0, 0x19, 0x5a, 0x04, 0x60, 0x01, 0x4a, 0x20, 0xf0, 0x49, 0xc0, 0x03, 0x10, 0x80, 0x18, 0x18, 0x2a, 0x00, 0x65, 0x07, 0x97, 0x06, 0x91, 0x05, 0x90, 0x00, 0xef, 0x04, 0x63, 0x28, 0x94, 0x11, 0x80, 0x44, 0x94, 0x11, 0x80, 0xfc, 0x63, 0x07, 0x62, 0x06, 0xd1, 0x05, 0xd0, 0x00, 0x6c, 0x02, 0xf0, 0x00, 0x6e, 0x00, 0x18, 0xa4, 0xa4, 0xa4, 0x67, 0x2b, 0xb2, 0xc1, 0xaa, 0x7f, 0x6a, 0x3c, 0x6c, 0xca, 0x36, 0x4c, 0xee, 0x29, 0xb2, 0x00, 0xf6, 0xc0, 0x36, 0x00, 0x6d, 0x00, 0x18, 0xa4, 0xa4, 0x4d, 0xee, 0x57, 0x6c, 0x00, 0x18, 0x46, 0xa4, 0x01, 0x6d, 0xff, 0xf7, 0x1f, 0x68, 0x0c, 0xea, 0x01, 0xf6, 0x01, 0x6b, 0x6b, 0xeb, 0xc2, 0x67, 0x6c, 0xee, 0x57, 0x6c, 0x00, 0x18, 0xa4, 0xa4, 0x01, 0x6d, 0x57, 0x6c, 0x00, 0x18, 0x46, 0xa4, 0x01, 0x6d, 0x0c, 0xea, 0x01, 0xf6, 0x00, 0x6b, 0xc2, 0x67, 0x6d, 0xee, 0x57, 0x6c, 0x00, 0x18, 0xa4, 0xa4, 0x01, 0x6d, 0x57, 0x6c, 0x00, 0x18, 0x46, 0xa4, 0x01, 0x6d, 0x0c, 0xea, 0x03, 0x69, 0x2b, 0xe9, 0xc2, 0x67, 0x2c, 0xee, 0x57, 0x6c, 0x00, 0x18, 0xa4, 0xa4, 0x01, 0x6d, 0x57, 0x6c, 0x00, 0x18, 0x46, 0xa4, 0x01, 0x6d, 0x0c, 0xea, 0x02, 0x6b, 0xc2, 0x67, 0x6d, 0xee, 0x57, 0x6c, 0x00, 0x18, 0xa4, 0xa4, 0x01, 0x6d, 0x57, 0x6c, 0x00, 0x18, 0x46, 0xa4, 0x01, 0x6d, 0x0c, 0xea, 0xc2, 0x67, 0x2c, 0xee, 0x01, 0x6d, 0x00, 0x18, 0xa4, 0xa4, 0x57, 0x6c, 0x80, 0x18, 0x02, 0x2a, 0x01, 0x6c, 0x07, 0x97, 0x06, 0x91, 0x05, 0x90, 0x00, 0xef, 0x04, 0x63, 0x28, 0x94
+, 0x11, 0x80, 0x00, 0x00, 0x00, 0x80, 0xfd, 0x63, 0x05, 0x62, 0x04, 0xd0, 0x00, 0x6c, 0xc4, 0x67, 0x00, 0x18, 0xa4, 0xa4, 0xa4, 0x67, 0x57, 0x6c, 0x00, 0x18, 0x46, 0xa4, 0x01, 0x6d, 0xff, 0x6e, 0xff, 0xf7, 0x1f, 0x6b, 0x04, 0x4e, 0x4c, 0xeb, 0xcb, 0xee, 0x6c, 0xee, 0x01, 0x6d, 0x0b, 0xb0, 0x00, 0x18, 0xa4, 0xa4, 0x57, 0x6c, 0x64, 0xa0, 0x41, 0x6a, 0x4b, 0xea, 0x6c, 0xea, 0x00, 0x6c, 0x80, 0x18, 0x02, 0x2a, 0x44, 0xc0, 0x80, 0x18, 0xdd, 0x29, 0x00, 0x65, 0x00, 0x6a, 0x49, 0xc0, 0x05, 0x97, 0x04, 0x90, 0x00, 0xef, 0x03, 0x63, 0x00, 0x65, 0x28, 0x94, 0x11, 0x80, 0xfb, 0x63, 0x09, 0x62, 0x08, 0xd0, 0x38, 0xb0, 0x90, 0xa0, 0x4f, 0xa0, 0x04, 0x05, 0x80, 0x34, 0x4d, 0xec, 0x4e, 0xa0, 0x80, 0x34, 0x00, 0x18, 0xb1, 0xb9, 0x4d, 0xec, 0x7d, 0x67, 0x48, 0xab, 0x8f, 0xa0, 0xdd, 0x67, 0x4c, 0xcb, 0x49, 0xab, 0xaa, 0xae, 0x4d, 0xcb, 0x4e, 0xa0, 0x80, 0x33, 0x68, 0x33, 0x48, 0x32, 0x6d, 0xea, 0x03, 0x6b, 0xac, 0xeb, 0x6d, 0xea, 0x70, 0xa0, 0x4e, 0xce, 0x9a, 0x34, 0x68, 0x32, 0x7e, 0x33, 0x8d, 0xea, 0x05, 0x23, 0x09, 0xf4, 0x00, 0x6b, 0x4d, 0xeb, 0x6f, 0xce, 0x06, 0x10, 0x0a, 0xf0, 0x00, 0x6b, 0x6b, 0xeb, 0x4d, 0xeb, 0x5d, 0x67, 0x6f, 0xca, 0x00, 0x6a, 0x21, 0x10, 0xdd, 0x67, 0x44, 0x35, 0xb5, 0xe6, 0xac, 0xad, 0x01, 0x6e, 0xa7, 0xeb, 0xcc, 0xed, 0x0c, 0x25, 0x0f, 0x6d, 0x77, 0xe5, 0xc4, 0xed, 0xa6, 0x67, 0x8d, 0xed, 0xa0, 0x34, 0x80, 0x34, 0x83, 0x34, 0x83, 0x34, 0xff, 0xf7, 0x1f, 0x6d, 0xac, 0xec, 0x01, 0x4b, 0xff, 0x6d, 0xac, 0xeb, 0x10, 0x5b, 0xe7, 0x61, 0x44, 0x33, 0x01, 0x4a, 0xdd, 0x67, 0xac, 0xea, 0x6d, 0xe6, 0x04, 0x5a, 0x8c, 0xcb, 0x03, 0x60, 0x00, 0x6c, 0x64, 0x67, 0xdc, 0x17, 0x5d, 0x67, 0xcc, 0xaa, 0x51, 0x6c, 0x00, 0x18, 0xa4, 0xa4, 0x01, 0x6d, 0x7d, 0x67, 0xcd, 0xab, 0x50, 0x6c, 0x00, 0x18, 0xa4, 0xa4, 0x01, 0x6d, 0x5d, 0x67, 0xce, 0xaa, 0x4f, 0x6c, 0x00, 0x18, 0xa4, 0xa4, 0x01, 0x6d, 0x7d, 0x67, 0xcf, 0xab, 0x4e, 0x6c, 0x00, 0x18, 0xa4, 0xa4, 0x01, 0x6d, 0x09, 0x97, 0x08, 0x90, 0x00, 0xef, 0x05, 0x63, 0x28, 0x94, 0x11, 0x80, 0xfb, 0x63, 0x09, 0x62, 0x08, 0xd1, 0x07, 0xd0, 0x5e, 0x6c, 0x00, 0x18, 0x46, 
+0xa4, 0x01, 0x6d, 0xff, 0xf7, 0x1f, 0x68, 0x0c, 0xea, 0x02, 0xf0, 0x01, 0x6b, 0x6b, 0xeb, 0xc2, 0x67, 0x6c, 0xee, 0x5e, 0x6c, 0x00, 0x18, 0xa4, 0xa4, 0x01, 0x6d, 0x57, 0x6c, 0x00, 0x18, 0x46, 0xa4, 0x01, 0x6d, 0x0c, 0xea, 0xff, 0x6b, 0x01, 0x4b, 0xc2, 0x67, 0x53, 0xb1, 0x6d, 0xee, 0x57, 0x6c, 0x00, 0x18, 0xa4, 0xa4, 0x01, 0x6d, 0x44, 0xa1, 0x07, 0x6b, 0xa3, 0xa1, 0x4e, 0x32, 0x6c, 0xea, 0x44, 0x34, 0x0f, 0x6a, 0x4b, 0xea, 0xac, 0xea, 0x8d, 0xea, 0x43, 0xc1, 0x57, 0x6c, 0x01, 0x6d, 0x00, 0x18, 0x46, 0xa4, 0x04, 0xd3, 0xc3, 0xa1, 0x04, 0x93, 0x71, 0x6c, 0xc6, 0x36, 0x6c, 0xee, 0x0c, 0xea, 0x8b, 0xec, 0x8c, 0xea, 0xd0, 0x36, 0x4d, 0xee, 0x57, 0x6c, 0x00, 0x18, 0xa4, 0xa4, 0x01, 0x6d, 0x60, 0xa1, 0x01, 0x6a, 0x01, 0x68, 0x6c, 0xea, 0x0b, 0x22, 0x44, 0xa1, 0x80, 0x48, 0xff, 0x48, 0x4c, 0xe8, 0xff, 0x6a, 0x4c, 0xe8, 0x0b, 0xe8, 0xc0, 0xf7, 0x02, 0x30, 0x03, 0x6a, 0x03, 0xe2, 0x39, 0xb1, 0x56, 0x6c, 0x00, 0x18, 0x46, 0xa4, 0x01, 0x6d, 0x80, 0x99, 0x00, 0x33, 0xe3, 0xf7, 0x1f, 0x6d, 0x96, 0x34, 0xac, 0xec, 0x78, 0x33, 0x8d, 0xeb, 0xfb, 0xf7, 0x1f, 0x6c, 0x8c, 0xeb, 0xff, 0xf7, 0x1f, 0x68, 0x1c, 0xf0, 0x00, 0x6c, 0x8b, 0xec, 0x0c, 0xea, 0xc3, 0x67, 0x8c, 0xea, 0x4d, 0xee, 0x56, 0x6c, 0x00, 0x18, 0xa4, 0xa4, 0x01, 0x6d, 0xc7, 0xa1, 0x46, 0xa1, 0x58, 0x6c, 0xc0, 0x36, 0x4d, 0xee, 0x00, 0x18, 0xa4, 0xa4, 0x01, 0x6d, 0x59, 0x6c, 0x00, 0x18, 0x46, 0xa4, 0x01, 0x6d, 0x04, 0x6b, 0x6b, 0xeb, 0x0c, 0xea, 0x6c, 0xea, 0x68, 0xa1, 0x03, 0x6c, 0xc2, 0x67, 0x8c, 0xeb, 0x6d, 0xee, 0x59, 0x6c, 0x00, 0x18, 0xa4, 0xa4, 0x01, 0x6d, 0x80, 0x18, 0xa2, 0x2a, 0x00, 0x65, 0x63, 0xa1, 0x80, 0x6a, 0x4b, 0xea, 0x6c, 0xea, 0xff, 0x6b, 0x6c, 0xea, 0x1e, 0x22, 0x57, 0x6c, 0x00, 0x18, 0x46, 0xa4, 0x01, 0x6d, 0x0c, 0xea, 0x80, 0x6b, 0xc2, 0x67, 0x6d, 0xee, 0x57, 0x6c, 0x00, 0x18, 0xa4, 0xa4, 0x01, 0x6d, 0x59, 0x6c, 0x00, 0x18, 0x46, 0xa4, 0x01, 0x6d, 0xc5, 0xa1, 0xe0, 0xf1, 0x1d, 0x6b, 0x6b, 0xeb, 0x0c, 0xea, 0x6c, 0xea, 0xc8, 0x36, 0xe0, 0xf3, 0x19, 0x4b, 0x6c, 0xee, 0x59, 0x6c, 0x01, 0x6d, 0x4d, 0xee, 0x0b, 0x10, 0x57, 0x6c, 0x00, 0x18, 0x46
+, 0xa4, 0x01, 0x6d, 0x0c, 0xea, 0x81, 0x6b, 0x6b, 0xeb, 0xc2, 0x67, 0x57, 0x6c, 0x01, 0x6d, 0x6c, 0xee, 0x00, 0x18, 0xa4, 0xa4, 0x00, 0x65, 0x09, 0x97, 0x08, 0x91, 0x07, 0x90, 0x00, 0xef, 0x05, 0x63, 0x00, 0x65, 0x28, 0x94, 0x11, 0x80, 0xfb, 0x63, 0x09, 0x62, 0x08, 0xd1, 0x07, 0xd0, 0x80, 0x18, 0xdc, 0x2a, 0x00, 0x65, 0x57, 0x6c, 0x00, 0x18, 0x46, 0xa4, 0x01, 0x6d, 0xff, 0xf7, 0x1f, 0x68, 0x0c, 0xea, 0x02, 0xf0, 0x01, 0x6b, 0x6b, 0xeb, 0xc2, 0x67, 0x6c, 0xee, 0x57, 0x6c, 0x00, 0x18, 0xa4, 0xa4, 0x01, 0x6d, 0x59, 0x6c, 0x00, 0x18, 0x46, 0xa4, 0x01, 0x6d, 0x0c, 0xea, 0x00, 0xf2, 0x00, 0x6b, 0xc2, 0x67, 0x6d, 0xee, 0x59, 0x6c, 0x00, 0x18, 0xa4, 0xa4, 0x01, 0x6d, 0x42, 0x6c, 0x00, 0x18, 0x46, 0xa4, 0x01, 0x6d, 0x32, 0xb3, 0xd2, 0xab, 0x51, 0xcb, 0x53, 0xab, 0xc0, 0x36, 0xc0, 0x36, 0x4d, 0xee, 0x02, 0xf0, 0x00, 0x5e, 0x02, 0x61, 0xe1, 0xf7, 0x1f, 0x6e, 0x2c, 0xb0, 0x20, 0xf0, 0x48, 0xa0, 0x0f, 0x6b, 0xd0, 0x36, 0x6c, 0xea, 0x4d, 0xee, 0x42, 0x6c, 0x00, 0x18, 0xa4, 0xa4, 0x01, 0x6d, 0x00, 0x6c, 0x02, 0xf0, 0x00, 0x6e, 0x00, 0x18, 0xa4, 0xa4, 0xa4, 0x67, 0x63, 0xa0, 0x07, 0x6a, 0x02, 0x6c, 0x72, 0x33, 0x4c, 0xeb, 0x05, 0x4b, 0x00, 0x6d, 0xff, 0xf7, 0x1f, 0x69, 0x00, 0x18, 0x46, 0xa4, 0x04, 0xd3, 0x04, 0x93, 0x1f, 0xf7, 0x01, 0x6c, 0x2c, 0xea, 0x8b, 0xec, 0x8c, 0xea, 0x1c, 0xb4, 0x6d, 0xe4, 0x20, 0xf1, 0xda, 0xa3, 0x02, 0x6c, 0x00, 0x6d, 0xc0, 0x36, 0x00, 0x18, 0xa4, 0xa4, 0x4d, 0xee, 0xc1, 0xa8, 0x7f, 0x6a, 0x3c, 0x6c, 0xca, 0x36, 0x4c, 0xee, 0x00, 0xf6, 0xc0, 0x36, 0x00, 0x18, 0xa4, 0xa4, 0x00, 0x6d, 0x57, 0x6c, 0x00, 0x18, 0x46, 0xa4, 0x01, 0x6d, 0x2c, 0xea, 0x01, 0x6d, 0xc2, 0x67, 0xad, 0xee, 0x00, 0x18, 0xa4, 0xa4, 0x57, 0x6c, 0x57, 0x6c, 0x00, 0x18, 0x46, 0xa4, 0x01, 0x6d, 0x2c, 0xea, 0x02, 0x6b, 0x6b, 0xeb, 0xc2, 0x67, 0x01, 0x6d, 0x6c, 0xee, 0x00, 0x18, 0xa4, 0xa4, 0x57, 0x6c, 0x80, 0x18, 0x02, 0x2a, 0x01, 0x6c, 0x09, 0x97, 0x08, 0x91, 0x07, 0x90, 0x00, 0xef, 0x05, 0x63, 0x00, 0x65, 0x28, 0x94, 0x11, 0x80, 0x58, 0x00, 0x11, 0x80, 0xfb, 0x63, 0x09, 0x62, 0x08, 0xd1, 0x07, 0xd0, 0x80, 0x18, 0xdc, 0x2a, 
+0x00, 0x65, 0x57, 0x6c, 0x00, 0x18, 0x46, 0xa4, 0x01, 0x6d, 0xff, 0xf7, 0x1f, 0x68, 0x0c, 0xea, 0x02, 0xf0, 0x00, 0x69, 0xc2, 0x67, 0x2d, 0xee, 0x57, 0x6c, 0x00, 0x18, 0xa4, 0xa4, 0x01, 0x6d, 0x59, 0x6c, 0x00, 0x18, 0x46, 0xa4, 0x01, 0x6d, 0x0c, 0xea, 0x00, 0xf2, 0x01, 0x6b, 0x6b, 0xeb, 0xc2, 0x67, 0x6c, 0xee, 0x59, 0x6c, 0x00, 0x18, 0xa4, 0xa4, 0x01, 0x6d, 0x00, 0x6c, 0xd1, 0x67, 0x23, 0xb1, 0x00, 0x18, 0xa4, 0xa4, 0xa4, 0x67, 0x63, 0xa1, 0x07, 0x6a, 0x02, 0x6c, 0x72, 0x33, 0x4c, 0xeb, 0x05, 0x4b, 0x00, 0x6d, 0x00, 0x18, 0x46, 0xa4, 0x04, 0xd3, 0x04, 0x93, 0x1f, 0xf7, 0x01, 0x6c, 0x0c, 0xea, 0x8b, 0xec, 0x8c, 0xea, 0x1a, 0xb4, 0x6d, 0xe4, 0x20, 0xf1, 0xda, 0xa3, 0x02, 0x6c, 0x00, 0x6d, 0xc0, 0x36, 0x00, 0x18, 0xa4, 0xa4, 0x4d, 0xee, 0xc1, 0xa9, 0x7f, 0x6a, 0x3c, 0x6c, 0xca, 0x36, 0x4c, 0xee, 0x00, 0xf6, 0xc0, 0x36, 0x00, 0x18, 0xa4, 0xa4, 0x00, 0x6d, 0x57, 0x6c, 0x00, 0x18, 0x46, 0xa4, 0x01, 0x6d, 0x0c, 0xea, 0x01, 0x6d, 0xc2, 0x67, 0xad, 0xee, 0x00, 0x18, 0xa4, 0xa4, 0x57, 0x6c, 0x57, 0x6c, 0x00, 0x18, 0x46, 0xa4, 0x01, 0x6d, 0x0c, 0xea, 0x02, 0x6b, 0x6b, 0xeb, 0xc2, 0x67, 0x57, 0x6c, 0x01, 0x6d, 0x00, 0x18, 0xa4, 0xa4, 0x6c, 0xee, 0x09, 0x97, 0x08, 0x91, 0x07, 0x90, 0x00, 0xef, 0x05, 0x63, 0x00, 0x65, 0x28, 0x94, 0x11, 0x80, 0x58, 0x00, 0x11, 0x80, 0xfd, 0x63, 0x05, 0x62, 0x80, 0x18, 0xdc, 0x2a, 0x00, 0x65, 0x00, 0x6b, 0x0c, 0xb2, 0x6d, 0xda, 0x6b, 0xda, 0x59, 0x6c, 0x00, 0x18, 0x46, 0xa4, 0x01, 0x6d, 0xff, 0xf7, 0x1f, 0x6b, 0x00, 0xf2, 0x01, 0x6e, 0x4c, 0xeb, 0xcb, 0xee, 0x59, 0x6c, 0x01, 0x6d, 0x00, 0x18, 0xa4, 0xa4, 0x6c, 0xee, 0x80, 0x18, 0x5a, 0x2a, 0x00, 0x65, 0x05, 0x97, 0x00, 0xef, 0x03, 0x63, 0x28, 0x94, 0x11, 0x80, 0xfa, 0x63, 0x0b, 0x62, 0x0a, 0xd1, 0x09, 0xd0, 0x42, 0xa4, 0xff, 0x6b, 0x04, 0x67, 0xff, 0x4a, 0x6c, 0xea, 0x22, 0x5a, 0x23, 0xa4, 0x2a, 0x60, 0x04, 0x0b, 0x44, 0x32, 0x49, 0xe3, 0x40, 0x8a, 0x4d, 0xe3, 0x00, 0xeb, 0x00, 0x65, 0x00, 0x65, 0x49, 0x00, 0x9d, 0x00, 0x29, 0x02, 0xb7, 0x02, 0xf1, 0x02, 0x65, 0x03, 0x8d, 0x03, 0x9f, 0x03, 0xad, 0x03, 0xc3, 0x03, 0xd1, 0x03, 0x45, 0x00
+, 0x45, 0x00, 0xdf, 0x03, 0xd7, 0x04, 0xef, 0x04, 0x45, 0x00, 0x07, 0x05, 0x15, 0x05, 0x23, 0x05, 0x53, 0x05, 0x61, 0x05, 0x73, 0x05, 0x81, 0x05, 0x93, 0x05, 0x97, 0x05, 0x9b, 0x05, 0xa7, 0x05, 0xb9, 0x05, 0x45, 0x00, 0x45, 0x00, 0x45, 0x00, 0x45, 0x00, 0xd1, 0x05, 0x00, 0x6a, 0xde, 0x12, 0x57, 0x6c, 0x00, 0x18, 0x46, 0xa4, 0x01, 0x6d, 0xff, 0xf7, 0x1f, 0x6b, 0x02, 0xf1, 0x03, 0x6e, 0x4c, 0xeb, 0xcb, 0xee, 0x6c, 0xee, 0x57, 0x6c, 0x00, 0x18, 0xa4, 0xa4, 0x01, 0x6d, 0x00, 0x6c, 0xa4, 0x67, 0x00, 0x18, 0xa4, 0xa4, 0xc4, 0x67, 0x80, 0x18, 0x02, 0x2a, 0x00, 0x6c, 0x00, 0x18, 0x78, 0x58, 0x00, 0x65, 0x00, 0x6d, 0x01, 0xf4, 0x03, 0x6c, 0x00, 0x18, 0xbb, 0x53, 0xc5, 0x67, 0x80, 0xf5, 0x08, 0xb2, 0x0a, 0x6b, 0x6c, 0xc2, 0x08, 0x6b, 0x6d, 0xc2, 0x00, 0x6b, 0x69, 0xc2, 0x6a, 0xc2, 0xa3, 0x12, 0x0b, 0x59, 0x80, 0xf2, 0x1c, 0x60, 0x60, 0xf5, 0x10, 0xb2, 0x06, 0x21, 0x64, 0xa2, 0x40, 0x6a, 0x6c, 0xea, 0x80, 0xf2, 0x14, 0x2a, 0x06, 0x10, 0x84, 0xa2, 0x40, 0x6b, 0x8c, 0xeb, 0x02, 0x2b, 0x29, 0xc2, 0x91, 0x12, 0x40, 0xf5, 0x10, 0xb2, 0x69, 0xa2, 0x0b, 0x59, 0x29, 0xc2, 0x04, 0xd3, 0xa0, 0xf0, 0x01, 0x60, 0x04, 0x0a, 0x24, 0x31, 0x25, 0xe2, 0x60, 0x89, 0x69, 0xe2, 0x00, 0xea, 0x00, 0x65, 0x00, 0x65, 0x17, 0x00, 0x9f, 0x00, 0xb5, 0x00, 0xe9, 0x00, 0x09, 0x01, 0x0d, 0x01, 0x17, 0x01, 0x33, 0x01, 0x1b, 0x01, 0x23, 0x01, 0x2b, 0x01, 0x00, 0xf5, 0x1c, 0xb2, 0x44, 0xa2, 0x01, 0x6b, 0x4c, 0xeb, 0x12, 0x23, 0x02, 0x6b, 0x4c, 0xeb, 0x04, 0x23, 0x80, 0x18, 0x8c, 0x2a, 0x00, 0x65, 0x18, 0x10, 0x04, 0x92, 0x02, 0x72, 0x04, 0x61, 0x80, 0x18, 0x18, 0x2a, 0x00, 0x65, 0x11, 0x10, 0x80, 0x18, 0xcb, 0x29, 0x00, 0x65, 0x0d, 0x10, 0x04, 0x6b, 0x4c, 0xeb, 0x0a, 0x23, 0x02, 0x6b, 0x4c, 0xeb, 0x04, 0x23, 0x80, 0x18, 0x89, 0x29, 0x00, 0x65, 0x03, 0x10, 0x80, 0x18, 0x9c, 0x29, 0x00, 0x65, 0xc0, 0xf4, 0x10, 0xb1, 0x6b, 0x99, 0xec, 0x99, 0x4d, 0x99, 0x07, 0xd3, 0x06, 0xd7, 0x00, 0x18, 0x78, 0x58, 0x05, 0xd2, 0x00, 0x6d, 0x01, 0xf4, 0x03, 0x6c, 0x00, 0x18, 0xbb, 0x53, 0xc5, 0x67, 0x0a, 0x6a, 0x4c, 0xc1, 0x08, 0x6a, 0x4d, 0xc1, 0x04, 0x92, 0x07, 
+0x93, 0x06, 0x97, 0x02, 0x5a, 0x20, 0xf2, 0x17, 0x60, 0x6b, 0xd9, 0x05, 0x93, 0xec, 0xd9, 0x6d, 0xd9, 0x32, 0x12, 0x80, 0xf4, 0x14, 0xb1, 0x64, 0xa1, 0x02, 0x6a, 0x6d, 0xea, 0x01, 0x6b, 0x6d, 0xea, 0x80, 0x18, 0xbe, 0x2b, 0x44, 0xc1, 0x25, 0x10, 0x60, 0xf4, 0x1c, 0xb3, 0x84, 0xa3, 0x03, 0x6a, 0x4b, 0xea, 0x8c, 0xea, 0x04, 0x6c, 0x4c, 0xec, 0x07, 0x24, 0x02, 0x6c, 0x8b, 0xec, 0x4c, 0xec, 0x80, 0x18, 0xab, 0x29, 0x84, 0xc3, 0x05, 0x10, 0x01, 0x6c, 0x4d, 0xec, 0x80, 0x18, 0x3e, 0x2b, 0x84, 0xc3, 0x40, 0xf4, 0x14, 0xb3, 0x84, 0xa3, 0x40, 0x6a, 0xdf, 0x10, 0x40, 0xf4, 0x08, 0xb1, 0x64, 0xa1, 0x03, 0x6a, 0x4b, 0xea, 0x6c, 0xea, 0x01, 0x6b, 0x6d, 0xea, 0x80, 0x18, 0x86, 0x2b, 0x44, 0xc1, 0x64, 0xa1, 0x40, 0x6a, 0x6d, 0xea, 0x44, 0xc1, 0xfd, 0x11, 0x01, 0x6c, 0x01, 0x10, 0x02, 0x6c, 0x80, 0x18, 0x02, 0x29, 0x00, 0x65, 0xf6, 0x11, 0x03, 0x6c, 0xfa, 0x17, 0x80, 0x18, 0x56, 0x29, 0x00, 0x65, 0xf0, 0x11, 0x80, 0x18, 0x3b, 0x29, 0x00, 0x65, 0xec, 0x11, 0x80, 0x18, 0x16, 0x29, 0x00, 0x65, 0xe8, 0x11, 0x80, 0x18, 0x85, 0x28, 0x00, 0x65, 0xe0, 0xf1, 0x03, 0x22, 0x12, 0x72, 0xc0, 0xf1, 0x1c, 0x60, 0x00, 0x6c, 0x04, 0x6b, 0xdb, 0x11, 0x04, 0x59, 0xc0, 0xf1, 0x16, 0x60, 0x80, 0x18, 0x02, 0x2a, 0x00, 0x6c, 0x57, 0x6c, 0x00, 0x18, 0x46, 0xa4, 0x01, 0x6d, 0xff, 0xf7, 0x1f, 0x6b, 0x02, 0xf1, 0x03, 0x6e, 0x4c, 0xeb, 0xcb, 0xee, 0x6c, 0xee, 0x57, 0x6c, 0x00, 0x18, 0xa4, 0xa4, 0x01, 0x6d, 0x00, 0x6c, 0xa4, 0x67, 0x00, 0x18, 0xa4, 0xa4, 0xc4, 0x67, 0x00, 0x18, 0x78, 0x58, 0x00, 0x65, 0x00, 0x6d, 0x01, 0xf4, 0x03, 0x6c, 0x00, 0x18, 0xbb, 0x53, 0xc5, 0x67, 0xe9, 0xb3, 0x0a, 0x6a, 0x4c, 0xc3, 0x08, 0x6a, 0x2a, 0xc3, 0x4d, 0xc3, 0x00, 0x1c, 0x5e, 0x1b, 0x07, 0xd3, 0x07, 0x93, 0xa2, 0x67, 0x05, 0x6a, 0x84, 0xa3, 0x4b, 0xea, 0x01, 0x71, 0x8c, 0xea, 0x44, 0xc3, 0x09, 0x61, 0x03, 0x6c, 0x80, 0x18, 0x02, 0x29, 0x06, 0xd5, 0x00, 0x18, 0x11, 0x56, 0x00, 0x6c, 0x06, 0x95, 0x05, 0x10, 0x02, 0x71, 0x03, 0x61, 0x04, 0x6c, 0x4d, 0xec, 0x84, 0xc3, 0x00, 0x1c, 0x65, 0x1b, 0x85, 0x67, 0x96, 0x11, 0x4f, 0x59, 0x80, 0xf1, 0x0f, 0x60, 0x44, 0xa4, 0x08
+, 0x5a, 0x80, 0xf1, 0x0b, 0x60, 0xd3, 0xb3, 0x7f, 0x6a, 0xa1, 0xab, 0x2c, 0xea, 0x48, 0x34, 0xe0, 0xf1, 0x1d, 0x6a, 0x4b, 0xea, 0xac, 0xea, 0x8d, 0xea, 0x41, 0xcb, 0x84, 0xa0, 0x07, 0x6a, 0xa3, 0xa3, 0x8c, 0xea, 0x50, 0x34, 0x71, 0x6a, 0x4b, 0xea, 0xac, 0xea, 0x8d, 0xea, 0x43, 0xc3, 0x79, 0x11, 0x0a, 0x59, 0x44, 0xa4, 0x65, 0xa4, 0x60, 0xf1, 0x10, 0x60, 0x60, 0x33, 0x4d, 0xeb, 0xe3, 0xf7, 0x1f, 0x6c, 0xc4, 0xb2, 0x6c, 0xec, 0x94, 0x35, 0xc3, 0xb6, 0x80, 0x9a, 0xcc, 0xec, 0xad, 0xec, 0x80, 0xda, 0xc2, 0xb5, 0x24, 0x34, 0x91, 0xe5, 0x80, 0xac, 0x8c, 0x34, 0x62, 0xec, 0x40, 0xf1, 0x1c, 0x61, 0x03, 0x59, 0x06, 0x60, 0x80, 0xa2, 0x02, 0x6b, 0x6b, 0xeb, 0x8c, 0xeb, 0x60, 0xc2, 0x0c, 0x10, 0x80, 0xa2, 0xa4, 0xa2, 0x01, 0x6b, 0x8d, 0xeb, 0x06, 0x59, 0x60, 0xc2, 0x98, 0x67, 0x7f, 0x6b, 0x9c, 0x34, 0xac, 0xeb, 0x8d, 0xeb, 0x64, 0xc2, 0xb5, 0xb2, 0x25, 0xe2, 0x80, 0xa1, 0xb0, 0xb3, 0x0f, 0x6a, 0x8c, 0xea, 0xa0, 0xa3, 0x44, 0x34, 0x1f, 0x6a, 0x4b, 0xea, 0xac, 0xea, 0x8d, 0xea, 0x39, 0x11, 0x45, 0xa4, 0x08, 0x5a, 0x20, 0xf1, 0x17, 0x60, 0x44, 0xa4, 0xa9, 0xb3, 0xa4, 0xa3, 0x40, 0x32, 0x2d, 0xea, 0x53, 0xcb, 0x85, 0xa4, 0x07, 0x6a, 0x8c, 0xea, 0x4c, 0x34, 0x39, 0x6a, 0x4b, 0xea, 0xac, 0xea, 0x8d, 0xea, 0x44, 0xc3, 0x2b, 0x11, 0x44, 0xa4, 0xa1, 0xb3, 0x40, 0x32, 0x2d, 0xea, 0x52, 0xcb, 0x45, 0xa4, 0x20, 0xf0, 0x48, 0xc3, 0x22, 0x11, 0x9d, 0xb2, 0x26, 0xc2, 0x64, 0xa4, 0x67, 0xc2, 0x65, 0xa4, 0x68, 0xc2, 0x1b, 0x11, 0x99, 0xb2, 0x63, 0xa2, 0x3e, 0x35, 0x7f, 0x6c, 0xbc, 0x35, 0x8c, 0xeb, 0xad, 0xeb, 0x8c, 0xe9, 0x63, 0xc2, 0x25, 0xc2, 0x10, 0x11, 0x94, 0xb2, 0x2e, 0xc2, 0x64, 0xa4, 0x6f, 0xc2, 0x65, 0xa4, 0x70, 0xc2, 0x09, 0x11, 0x90, 0xb2, 0x31, 0xc2, 0x64, 0xa4, 0x72, 0xc2, 0x65, 0xa4, 0x73, 0xc2, 0x02, 0x11, 0x8d, 0xb3, 0x49, 0xa3, 0x0a, 0x72, 0x2c, 0x61, 0x8c, 0xa3, 0x00, 0x6a, 0x0a, 0x74, 0x0e, 0x60, 0xc0, 0xf2, 0x0c, 0x4a, 0x58, 0xec, 0x8b, 0xb2, 0x12, 0xec, 0x91, 0xe2, 0xc0, 0xf0, 0x48, 0xa4, 0x04, 0x72, 0x05, 0x6a, 0x03, 0x60, 0x0a, 0x6a, 0x4c, 0xc3, 0x00, 0x6a, 0x82, 0xb3, 0x8d, 0xa3, 0x08, 0x74, 0x5d, 0x60, 
+0xff, 0x6a, 0x09, 0x4a, 0x58, 0xec, 0x83, 0xb3, 0x12, 0xea, 0x49, 0xe3, 0x20, 0xf1, 0xaf, 0xa2, 0x01, 0x6a, 0x4c, 0xed, 0x06, 0x25, 0x00, 0xf1, 0x72, 0xab, 0x67, 0xec, 0x4c, 0xeb, 0x05, 0x6a, 0x4c, 0x2b, 0x77, 0xb2, 0x08, 0x6b, 0x6d, 0xc2, 0x00, 0x6a, 0x47, 0x10, 0x8b, 0x42, 0xff, 0x6b, 0x6c, 0xec, 0x03, 0x5c, 0x1a, 0x60, 0x00, 0x6a, 0xc0, 0xf2, 0x0c, 0x6c, 0x98, 0xea, 0x74, 0xb3, 0x12, 0xec, 0x91, 0xe3, 0xc0, 0xf0, 0x68, 0xa4, 0x04, 0x73, 0x09, 0x61, 0xe0, 0xf0, 0xa8, 0x9c, 0x6c, 0xb3, 0xa5, 0xdb, 0xe0, 0xf0, 0x8c, 0xac, 0x4c, 0xc3, 0x8c, 0xcb, 0x26, 0x10, 0x01, 0x4a, 0xff, 0x6b, 0x6c, 0xea, 0x0a, 0x5a, 0xe8, 0x61, 0x27, 0x10, 0x88, 0x42, 0x6c, 0xec, 0x02, 0x5c, 0x24, 0x60, 0x00, 0x6a, 0xff, 0x6c, 0x09, 0x4c, 0x98, 0xea, 0x66, 0xb3, 0x01, 0x6d, 0x12, 0xec, 0x91, 0xe3, 0x20, 0xf1, 0xcf, 0xa4, 0xac, 0xee, 0x12, 0x26, 0x00, 0xf1, 0x72, 0xab, 0x67, 0xea, 0xac, 0xeb, 0x0d, 0x23, 0x60, 0xf1, 0xbe, 0xac, 0x5a, 0xb3, 0xaa, 0xcb, 0x80, 0xf1, 0xa0, 0xac, 0xab, 0xcb, 0x80, 0xf1, 0x82, 0xac, 0x4d, 0xc3, 0x8c, 0xcb, 0x05, 0x6a, 0x06, 0x10, 0x01, 0x4a, 0xff, 0x6b, 0x6c, 0xea, 0x08, 0x5a, 0xde, 0x61, 0x04, 0x6a, 0x51, 0xb3, 0x6a, 0xa3, 0x40, 0x32, 0x6d, 0xea, 0x66, 0x10, 0x55, 0xb3, 0x20, 0xf0, 0x9e, 0xa3, 0x20, 0xf0, 0x5d, 0xa3, 0x20, 0xf0, 0x7c, 0xa3, 0x80, 0x34, 0x40, 0x32, 0x80, 0x34, 0x8d, 0xea, 0x6d, 0x10, 0x4f, 0xb3, 0x40, 0xf0, 0x81, 0xa3, 0x40, 0xf0, 0x40, 0xa3, 0x20, 0xf0, 0x7f, 0xa3, 0x80, 0x34, 0x40, 0x32, 0x80, 0x34, 0x8d, 0xea, 0x61, 0x10, 0x43, 0xb2, 0x34, 0xc2, 0x64, 0xa4, 0x75, 0xc2, 0x65, 0xa4, 0x76, 0xc2, 0x67, 0x10, 0x3f, 0xb2, 0x37, 0xc2, 0x64, 0xa4, 0x78, 0xc2, 0x65, 0xa4, 0x79, 0xc2, 0x60, 0x10, 0x4f, 0x41, 0xff, 0x6b, 0x6c, 0xea, 0x09, 0x5a, 0x57, 0x60, 0x5c, 0x6c, 0x00, 0x18, 0x46, 0xa4, 0x01, 0x6d, 0xff, 0xf7, 0x1f, 0x6b, 0x4c, 0xeb, 0x79, 0x6a, 0x4b, 0xea, 0x4c, 0xeb, 0x2c, 0x36, 0x78, 0x6a, 0x4c, 0xee, 0x5c, 0x6c, 0x01, 0x6d, 0x00, 0x18, 0xa4, 0xa4, 0x6d, 0xee, 0x48, 0x10, 0x30, 0xb3, 0x8b, 0x9b, 0x36, 0xb5, 0x56, 0xab, 0xac, 0xec, 0x8b, 0xdb, 0x21, 0x10, 0x2c, 0xb4, 0xab, 0x9c, 0xff, 0xf7
+, 0x1f, 0x6b, 0xa2, 0x32, 0xac, 0xeb, 0x42, 0x32, 0x6b, 0xdc, 0x18, 0x10, 0x28, 0xb3, 0x8d, 0x9b, 0x2e, 0xb5, 0x5a, 0xab, 0xac, 0xec, 0x8d, 0xdb, 0x11, 0x10, 0x24, 0xb4, 0xad, 0x9c, 0xff, 0xf7, 0x1f, 0x6b, 0xa2, 0x32, 0xac, 0xeb, 0x42, 0x32, 0x6d, 0xdc, 0x08, 0x10, 0x78, 0x6c, 0x03, 0x10, 0x76, 0x6c, 0x01, 0x10, 0x77, 0x6c, 0x00, 0x18, 0x46, 0xa4, 0x01, 0x6d, 0x02, 0x6c, 0x13, 0x10, 0x1b, 0xb3, 0x96, 0xa3, 0x55, 0xa3, 0x74, 0xa3, 0x80, 0x34, 0x40, 0x32, 0x80, 0x34, 0x8d, 0xea, 0x08, 0x10, 0x16, 0xb3, 0x99, 0xa3, 0x58, 0xa3, 0x77, 0xa3, 0x80, 0x34, 0x40, 0x32, 0x80, 0x34, 0x8d, 0xea, 0x6d, 0xea, 0x03, 0x6c, 0x00, 0x6b, 0x0c, 0x10, 0x01, 0x6a, 0x2c, 0xea, 0x17, 0xb3, 0x40, 0xc3, 0x04, 0x10, 0x00, 0x6c, 0x03, 0x6b, 0x44, 0x67, 0x03, 0x10, 0x00, 0x6c, 0x64, 0x67, 0x44, 0x67, 0x90, 0x34, 0x6d, 0xec, 0x83, 0xc0, 0x81, 0xa0, 0x10, 0x6b, 0x6b, 0xeb, 0x8c, 0xeb, 0x61, 0xc0, 0xa0, 0x98, 0x02, 0x6c, 0x00, 0x18, 0xca, 0x2e, 0xc2, 0x67, 0x01, 0x6a, 0x0b, 0x97, 0x0a, 0x91, 0x09, 0x90, 0x00, 0xef, 0x06, 0x63, 0x00, 0x65, 0x28, 0x94, 0x11, 0x80, 0x1f, 0x00, 0xfc, 0xff, 0x6c, 0xdc, 0x10, 0x80, 0x60, 0xdc, 0x10, 0x80, 0xb4, 0x54, 0x11, 0x80, 0x40, 0x3b, 0x11, 0x80, 0x58, 0x00, 0x11, 0x80, 0x00, 0x00, 0xff, 0xff, 0x60, 0x94, 0x11, 0x80, 0x00, 0x6a, 0x6f, 0xb5, 0x55, 0xe5, 0xa0, 0xa5, 0x6e, 0xb3, 0x51, 0xe3, 0x20, 0xf1, 0xba, 0xc4, 0x01, 0x4a, 0xff, 0x6c, 0x8c, 0xea, 0x10, 0x5a, 0xf4, 0x61, 0x60, 0xf1, 0xa1, 0xa3, 0xfe, 0x75, 0x0b, 0x60, 0x0f, 0x6a, 0xac, 0xea, 0xaf, 0x42, 0x8c, 0xed, 0x05, 0x5d, 0x05, 0x60, 0x10, 0x6c, 0x4d, 0xec, 0x60, 0xf1, 0x81, 0xc3, 0x03, 0x10, 0x15, 0x6a, 0x60, 0xf1, 0x41, 0xc3, 0x61, 0xb2, 0x0b, 0x6b, 0x40, 0xf1, 0x7b, 0xc2, 0x40, 0xf1, 0x7c, 0xc2, 0x40, 0xf1, 0x7d, 0xc2, 0x40, 0xf1, 0x7e, 0xc2, 0x00, 0x6b, 0x80, 0xf0, 0x7d, 0xc2, 0x24, 0xf0, 0x13, 0x6b, 0x60, 0xf1, 0x62, 0xca, 0x06, 0xf4, 0x1f, 0x6b, 0x60, 0xf1, 0x64, 0xca, 0x0a, 0xf4, 0x17, 0x6b, 0x60, 0xf1, 0x66, 0xca, 0x0e, 0xf2, 0x0d, 0x6b, 0x60, 0xf1, 0x68, 0xca, 0x04, 0xf5, 0x00, 0x6b, 0x6b, 0xeb, 0x60, 0xf1, 0x6a, 0xca, 0x00, 0x6b, 0xc0, 
+0xf1, 0x68, 0xca, 0xc0, 0xf1, 0x6a, 0xca, 0xc0, 0xf1, 0x6c, 0xca, 0xc0, 0xf1, 0x6e, 0xca, 0x40, 0xf1, 0x7f, 0xa2, 0xff, 0x73, 0x03, 0x61, 0x01, 0x6b, 0x40, 0xf1, 0x7f, 0xc2, 0x48, 0xb2, 0x60, 0xf1, 0x60, 0xa2, 0xff, 0x6c, 0x02, 0x4b, 0x8c, 0xeb, 0x02, 0x5b, 0x03, 0x60, 0x0a, 0x6b, 0x60, 0xf1, 0x60, 0xc2, 0x42, 0xb2, 0x80, 0xf1, 0x62, 0xa2, 0xff, 0x73, 0x03, 0x61, 0x05, 0x6b, 0x80, 0xf1, 0x62, 0xc2, 0x3e, 0xb2, 0x01, 0x6b, 0x80, 0xf1, 0x60, 0xc2, 0x80, 0xf1, 0x71, 0xc2, 0x80, 0xf1, 0x61, 0xa2, 0xfe, 0x73, 0x03, 0x61, 0x10, 0x6b, 0x80, 0xf1, 0x61, 0xc2, 0x38, 0xb2, 0x02, 0x6b, 0x80, 0xf1, 0x63, 0xc2, 0x80, 0xf1, 0x72, 0xc2, 0x00, 0x6a, 0x35, 0xb4, 0x51, 0xe4, 0x80, 0xa4, 0x33, 0xb3, 0x4d, 0xe3, 0x80, 0xf1, 0x84, 0xc3, 0x01, 0x4a, 0xff, 0x6b, 0x6c, 0xea, 0x0d, 0x5a, 0xf4, 0x61, 0x00, 0x6a, 0x30, 0xb3, 0x4d, 0xe3, 0x60, 0xa3, 0xff, 0x6c, 0xe0, 0x4b, 0x8c, 0xeb, 0x00, 0xf6, 0x60, 0x34, 0x00, 0xf6, 0x83, 0x34, 0x00, 0x54, 0x05, 0x60, 0x80, 0x4b, 0x00, 0xf6, 0x60, 0x34, 0x00, 0xf6, 0x83, 0x34, 0x25, 0xb3, 0x4d, 0xe3, 0x80, 0xf1, 0x93, 0xc3, 0x01, 0x4a, 0xff, 0x6b, 0x6c, 0xea, 0x0d, 0x5a, 0xe6, 0x61, 0x00, 0x6a, 0x23, 0xb4, 0x51, 0xe4, 0x80, 0xa4, 0x1f, 0xb3, 0x4d, 0xe3, 0xc0, 0xf1, 0x80, 0xc3, 0x21, 0xb4, 0x51, 0xe4, 0x80, 0xa4, 0xc0, 0xf1, 0x82, 0xc3, 0x1f, 0xb3, 0x4d, 0xe3, 0x60, 0xa3, 0xff, 0x6c, 0xe0, 0x4b, 0x8c, 0xeb, 0x00, 0xf6, 0x60, 0x34, 0x00, 0xf6, 0x83, 0x34, 0x00, 0x54, 0x05, 0x60, 0x80, 0x4b, 0x00, 0xf6, 0x60, 0x34, 0x00, 0xf6, 0x83, 0x34, 0x12, 0xb3, 0x4d, 0xe3, 0xc0, 0xf1, 0x84, 0xc3, 0x16, 0xb3, 0x4d, 0xe3, 0x60, 0xa3, 0xff, 0x6c, 0xe0, 0x4b, 0x8c, 0xeb, 0x00, 0xf6, 0x60, 0x34, 0x00, 0xf6, 0x83, 0x34, 0x00, 0x54, 0x05, 0x60, 0x80, 0x4b, 0x00, 0xf6, 0x60, 0x34, 0x00, 0xf6, 0x83, 0x34, 0x07, 0xb3, 0x4d, 0xe3, 0xc0, 0xf1, 0x86, 0xc3, 0x01, 0x4a, 0xff, 0x6b, 0x6c, 0xea, 0x02, 0x5a, 0xc5, 0x61, 0x20, 0xe8, 0x00, 0x65, 0x00, 0x65, 0x94, 0xdd, 0x10, 0x80, 0x58, 0x00, 0x11, 0x80, 0xa4, 0xdd, 0x10, 0x80, 0xbc, 0xdd, 0x10, 0x80, 0xb4, 0xdd, 0x10, 0x80, 0xb8, 0xdd, 0x10, 0x80, 0xcc, 0xdd, 0x10, 0x80, 0xd0
+, 0xdd, 0x10, 0x80, 0xff, 0x6b, 0x6c, 0xee, 0x6c, 0xec, 0x6c, 0xed, 0xec, 0xeb, 0x77, 0xe5, 0xb8, 0xed, 0xd3, 0xe4, 0xff, 0xf7, 0x1f, 0x6f, 0x12, 0xed, 0x98, 0xec, 0x12, 0xec, 0x89, 0xe5, 0x20, 0xe8, 0xec, 0xea, 0x20, 0xe8, 0x00, 0x65, 0x0b, 0xb2, 0x20, 0xf0, 0x70, 0xa2, 0x16, 0x6a, 0x6c, 0xea, 0x12, 0x72, 0x04, 0x61, 0x40, 0xa4, 0x01, 0x5a, 0x58, 0x67, 0x40, 0xc4, 0x06, 0xb2, 0xc0, 0xf1, 0x7f, 0xa2, 0x07, 0x6a, 0x6c, 0xea, 0x04, 0x52, 0x58, 0x67, 0x01, 0x6b, 0x20, 0xe8, 0x6e, 0xea, 0x00, 0x65, 0x58, 0x00, 0x11, 0x80, 0x20, 0xe8, 0x00, 0x6a, 0x20, 0xe8, 0x00, 0x6a, 0x20, 0xe8, 0x00, 0x65, 0x64, 0xa4, 0x43, 0xa4, 0xc0, 0xa5, 0x60, 0x33, 0x4d, 0xe3, 0xff, 0xf7, 0x1f, 0x6a, 0x4c, 0xeb, 0x7f, 0xf4, 0x0f, 0x73, 0x00, 0x6a, 0x09, 0x61, 0xc9, 0xe4, 0x02, 0x6b, 0x62, 0xc2, 0x41, 0x46, 0xff, 0x6b, 0x6c, 0xea, 0x41, 0xc4, 0x40, 0xc5, 0x01, 0x6a, 0x20, 0xe8, 0x00, 0x65, 0x00, 0x65, 0x07, 0xb2, 0x40, 0x9a, 0x61, 0x42, 0x07, 0x23, 0x24, 0x6b, 0x78, 0xea, 0x05, 0xb3, 0x12, 0xea, 0x49, 0xe3, 0x05, 0xb3, 0x63, 0xda, 0x20, 0xe8, 0x00, 0x65, 0x00, 0x65, 0x90, 0x04, 0x11, 0x80, 0x4c, 0x8a, 0x11, 0x80, 0x21, 0xd1, 0x10, 0x80, 0x08, 0xb2, 0x60, 0xa2, 0x1e, 0x6a, 0x80, 0x9c, 0x6c, 0xea, 0x06, 0x6b, 0x4e, 0xeb, 0x05, 0x2b, 0x47, 0x6a, 0x8c, 0xea, 0x02, 0x22, 0x04, 0xb2, 0x60, 0xc2, 0x20, 0xe8, 0x00, 0x6a, 0x00, 0x65, 0xe0, 0x1e, 0x11, 0x80, 0xc2, 0x06, 0x11, 0x80, 0x62, 0xa4, 0x80, 0x6a, 0x4b, 0xea, 0x6c, 0xea, 0xff, 0x6d, 0xac, 0xea, 0x0b, 0x22, 0x09, 0xb2, 0xa1, 0xa2, 0x0c, 0x6a, 0xac, 0xea, 0x0c, 0x72, 0x09, 0x60, 0x7f, 0x6a, 0x6c, 0xea, 0x21, 0x6b, 0x6b, 0xeb, 0x02, 0x10, 0x21, 0x6a, 0x4b, 0xea, 0x6c, 0xea, 0x42, 0xc4, 0x20, 0xe8, 0x00, 0x6a, 0xe0, 0x1e, 0x11, 0x80, 0x0f, 0xb2, 0x10, 0xb3, 0x10, 0xb5, 0x40, 0x9a, 0x10, 0xb2, 0x03, 0x6e, 0x40, 0x9a, 0x60, 0x9b, 0xa0, 0x9d, 0x80, 0xf5, 0xa2, 0x35, 0xcc, 0xed, 0x0e, 0x25, 0x03, 0x75, 0x0c, 0x60, 0x62, 0x33, 0x42, 0x32, 0x62, 0x33, 0x42, 0x32, 0xa6, 0x43, 0x42, 0xed, 0x04, 0x61, 0xfa, 0x4b, 0x62, 0xea, 0x01, 0x6d, 0x01, 0x60, 0x02, 0x6d, 0x20, 0xe8, 0xa0, 0xc4, 0x00, 0x65, 
+0xa0, 0xa0, 0x00, 0xb0, 0x54, 0xa0, 0x00, 0xb0, 0x5c, 0xa0, 0x00, 0xb0, 0xa4, 0xa0, 0x00, 0xb0, 0x0b, 0xb2, 0x60, 0xf1, 0x50, 0xa2, 0xff, 0x6b, 0xfd, 0x4a, 0x6c, 0xea, 0x02, 0x5a, 0x0b, 0x60, 0x08, 0xb2, 0x40, 0xa2, 0x08, 0x2a, 0x63, 0xa4, 0x02, 0x6a, 0x6c, 0xea, 0x04, 0x22, 0x03, 0x6a, 0x4b, 0xea, 0x6c, 0xea, 0x43, 0xc4, 0x20, 0xe8, 0x00, 0x6a, 0x00, 0x65, 0xc0, 0x50, 0x11, 0x80, 0x8d, 0x04, 0x11, 0x80, 0xf9, 0x63, 0x0d, 0x62, 0x0c, 0xd1, 0x0b, 0xd0, 0x01, 0x6b, 0x6b, 0xeb, 0x20, 0xb2, 0x60, 0xda, 0x00, 0x68, 0x0e, 0x10, 0x0c, 0x6b, 0x78, 0xe8, 0x12, 0xeb, 0x49, 0xe3, 0x62, 0x9a, 0x07, 0x23, 0x20, 0x18, 0xf1, 0x2e, 0x81, 0x9a, 0x03, 0x22, 0x19, 0xb2, 0x00, 0xda, 0x06, 0x10, 0x01, 0x48, 0x18, 0xb2, 0x80, 0xf0, 0x64, 0xa2, 0x02, 0xeb, 0xed, 0x60, 0x17, 0xb2, 0x17, 0xb3, 0x60, 0xda, 0x17, 0xb2, 0x40, 0xa2, 0xff, 0x72, 0x07, 0x61, 0x16, 0xb2, 0x40, 0xaa, 0x04, 0x2a, 0x00, 0x18, 0x04, 0x39, 0x00, 0x65, 0x01, 0x10, 0x00, 0x6a, 0x0d, 0xb3, 0x60, 0x9b, 0x81, 0x43, 0x07, 0x2c, 0x11, 0xb3, 0x60, 0x9b, 0xd1, 0x23, 0xd0, 0x2a, 0x40, 0xeb, 0x00, 0x65, 0xcd, 0x17, 0x0c, 0x68, 0x18, 0xeb, 0x08, 0xb2, 0x04, 0x01, 0xb1, 0x67, 0x12, 0xe8, 0x41, 0xe0, 0x20, 0x18, 0xf8, 0x2e, 0x81, 0x98, 0xc2, 0x2a, 0x40, 0x98, 0x40, 0xea, 0x91, 0x67, 0xbe, 0x17, 0xc0, 0x88, 0x11, 0x80, 0xc4, 0x88, 0x11, 0x80, 0x78, 0xa0, 0x00, 0xb0, 0x20, 0x4e, 0xa5, 0x01, 0x72, 0x04, 0x11, 0x80, 0xf6, 0x18, 0x11, 0x80, 0x30, 0x85, 0x11, 0x80, 0xf6, 0x63, 0x13, 0x62, 0x12, 0xd1, 0x11, 0xd0, 0x09, 0x6a, 0x04, 0xd2, 0x2f, 0xb2, 0x05, 0xd2, 0x2f, 0xb2, 0x40, 0xaa, 0x01, 0x6c, 0xfa, 0x6d, 0x06, 0xd2, 0x2e, 0xb2, 0x40, 0xaa, 0x24, 0xf0, 0x08, 0x6e, 0xa1, 0xf3, 0x16, 0x6f, 0x07, 0xd2, 0x2b, 0xb2, 0x40, 0x9a, 0x08, 0xd2, 0x2b, 0xb2, 0x40, 0xf0, 0x61, 0xa2, 0x09, 0xd3, 0x40, 0xf0, 0x60, 0xa2, 0x0a, 0xd3, 0x20, 0xf0, 0x7f, 0xa2, 0x0b, 0xd3, 0x20, 0xf0, 0x7e, 0xa2, 0x0c, 0xd3, 0x20, 0xf0, 0x7d, 0xa2, 0x0d, 0xd3, 0x20, 0xf0, 0x5c, 0xa2, 0x20, 0x18, 0x00, 0x2d, 0x0e, 0xd2, 0x04, 0xf7, 0x10, 0x6d, 0x00, 0x18, 0xe5, 0x31, 0x01, 0x6c, 0x1f, 0xb2, 0x00, 0x9a, 0x1f, 0xb2
+, 0x4e, 0xe8, 0x0d, 0x28, 0x1e, 0xb1, 0x40, 0xa1, 0x0a, 0x22, 0x1e, 0xb2, 0x63, 0xa2, 0x1e, 0xb2, 0x3f, 0xf4, 0x00, 0x6c, 0x60, 0xc2, 0x00, 0x18, 0xe7, 0x8e, 0x00, 0x6d, 0x00, 0xc1, 0x1b, 0xb2, 0x80, 0x9a, 0x1b, 0xb3, 0x8e, 0xeb, 0x01, 0x2b, 0x60, 0xda, 0x1a, 0xb2, 0x80, 0x9a, 0x1a, 0xb3, 0x8e, 0xeb, 0x01, 0x2b, 0x60, 0xda, 0x11, 0xb3, 0x0f, 0xb2, 0x60, 0xda, 0x17, 0xb2, 0x00, 0x6b, 0x60, 0xda, 0x61, 0xda, 0x62, 0xda, 0x63, 0xda, 0x00, 0x1c, 0x2e, 0x1b, 0x64, 0xda, 0x80, 0x18, 0x41, 0x2e, 0x00, 0x65, 0x13, 0x97, 0x12, 0x91, 0x11, 0x90, 0x00, 0xef, 0x0a, 0x63, 0x00, 0x65, 0x00, 0xd9, 0x04, 0x80, 0x50, 0x00, 0x11, 0x80, 0x52, 0x00, 0x11, 0x80, 0x04, 0x20, 0x11, 0x80, 0x58, 0x00, 0x11, 0x80, 0x50, 0x8b, 0x10, 0x80, 0xef, 0xbe, 0x23, 0x87, 0x08, 0x94, 0x10, 0x80, 0x54, 0x8b, 0x10, 0x80, 0x70, 0x07, 0x11, 0x80, 0x58, 0x8b, 0x10, 0x80, 0x32, 0x97, 0x79, 0x23, 0x60, 0x8b, 0x10, 0x80, 0x58, 0x3b, 0x7a, 0x93, 0x64, 0x73, 0x11, 0x80, 0xf2, 0x63, 0x1b, 0x62, 0x1a, 0xd1, 0x19, 0xd0, 0x20, 0xf5, 0x1c, 0xb2, 0x7d, 0x67, 0x40, 0xaa, 0x51, 0xcb, 0x20, 0xf0, 0x82, 0xa3, 0x20, 0xf5, 0x14, 0xb2, 0x92, 0x35, 0xa0, 0xc2, 0x13, 0xd5, 0x20, 0xf0, 0x63, 0xa3, 0x01, 0x6a, 0x86, 0x34, 0x6e, 0x31, 0x4c, 0xe9, 0x66, 0x33, 0x4c, 0xeb, 0x24, 0x31, 0x6d, 0xe9, 0x07, 0x6b, 0x6c, 0xec, 0x10, 0xd4, 0x7c, 0x6c, 0x98, 0xe9, 0x00, 0xf5, 0x10, 0xb3, 0xb1, 0x67, 0x12, 0xec, 0x6d, 0xe4, 0x12, 0xd3, 0x60, 0xa3, 0x10, 0x94, 0x6c, 0xea, 0x00, 0x18, 0x91, 0xba, 0x14, 0xd2, 0x11, 0xd2, 0x11, 0x93, 0x0a, 0x6a, 0x58, 0xeb, 0xe0, 0xf4, 0x14, 0xb3, 0x12, 0xea, 0x49, 0xe3, 0x61, 0xaa, 0xe0, 0xf4, 0x0c, 0xb2, 0x60, 0xc2, 0xe0, 0xf4, 0x0c, 0xb2, 0x40, 0x9a, 0x04, 0x22, 0x20, 0xf0, 0x02, 0x04, 0x40, 0xea, 0x00, 0x65, 0x13, 0x94, 0x09, 0x74, 0x07, 0x61, 0x10, 0x95, 0x00, 0x6c, 0x01, 0x25, 0x82, 0x41, 0x00, 0x18, 0x48, 0x82, 0x00, 0x65, 0x7d, 0x67, 0x20, 0xf0, 0x43, 0xa3, 0x01, 0x68, 0x0c, 0xea, 0x2d, 0x22, 0xc0, 0xf4, 0x00, 0xb2, 0x40, 0xa2, 0x03, 0x6b, 0x6c, 0xea, 0x14, 0x22, 0xa0, 0xf4, 0x18, 0xb3, 0x46, 0xab, 0x9d, 0x67, 0x50, 0xcc, 0xc0, 0xf2, 0x0c, 
+0x6c, 0x98, 0xea, 0xa0, 0xf4, 0x0c, 0xb4, 0x12, 0xea, 0x49, 0xe4, 0x00, 0x6c, 0x20, 0xf2, 0x9d, 0xc2, 0xe0, 0xf0, 0xa3, 0xa2, 0x00, 0x18, 0xa3, 0x3c, 0x8e, 0xa3, 0x80, 0xf4, 0x18, 0xb2, 0x60, 0xf1, 0x4b, 0xa2, 0x20, 0xf2, 0x0d, 0x22, 0x00, 0x6a, 0x80, 0xf4, 0x0c, 0xb3, 0x04, 0xd2, 0x05, 0xd3, 0x06, 0xd2, 0x06, 0x6c, 0xfa, 0x6d, 0xa3, 0xf5, 0x05, 0x6e, 0xc0, 0xf5, 0x19, 0x6f, 0x32, 0x10, 0x10, 0x94, 0xb1, 0x67, 0x20, 0x18, 0x2c, 0x0b, 0x09, 0x06, 0x0d, 0x2a, 0x10, 0x93, 0x60, 0xf4, 0x0c, 0xb2, 0x69, 0xe2, 0x40, 0xa2, 0x01, 0x72, 0x00, 0xf2, 0x12, 0x61, 0x60, 0xf4, 0x00, 0xb2, 0x69, 0xe2, 0x00, 0xc2, 0x0d, 0x12, 0x13, 0x94, 0x02, 0x74, 0x20, 0x61, 0x20, 0xf4, 0x18, 0xb2, 0x40, 0xa2, 0x00, 0xf2, 0x05, 0x2a, 0x20, 0xf4, 0x1c, 0xb2, 0x44, 0x9a, 0x02, 0x72, 0xe0, 0xf1, 0x1f, 0x60, 0x00, 0x18, 0x63, 0xa7, 0x00, 0x65, 0x00, 0x18, 0x35, 0x3a, 0x00, 0x65, 0x20, 0xf4, 0x08, 0xb3, 0x04, 0xd0, 0x05, 0xd3, 0x06, 0xd2, 0x06, 0x6c, 0xfa, 0x6d, 0xc3, 0xf5, 0x0a, 0x6e, 0xc0, 0xf5, 0x1a, 0x6f, 0x20, 0x18, 0x00, 0x2d, 0x00, 0x65, 0xea, 0x11, 0x10, 0x94, 0xb1, 0x67, 0x00, 0x18, 0x31, 0xdd, 0x08, 0x06, 0xff, 0x72, 0xe0, 0xf1, 0x02, 0x60, 0x00, 0xf4, 0x04, 0xb2, 0x40, 0x9a, 0xbd, 0x67, 0x10, 0xad, 0x0d, 0x22, 0x14, 0x93, 0x3c, 0x6c, 0x12, 0x95, 0x98, 0xeb, 0x7d, 0x67, 0xd1, 0xab, 0x12, 0xec, 0x91, 0xe5, 0x04, 0x4c, 0x40, 0xea, 0xb0, 0x67, 0xc0, 0xf1, 0x0f, 0x2a, 0xc0, 0xf2, 0x0c, 0x6a, 0x58, 0xe8, 0x13, 0x93, 0xf1, 0xb2, 0x12, 0x94, 0x12, 0xe8, 0x41, 0xe0, 0x01, 0x6a, 0x44, 0xeb, 0x14, 0x93, 0x15, 0xd2, 0x3c, 0x6a, 0x58, 0xeb, 0x12, 0xea, 0x49, 0xe4, 0x20, 0xf0, 0x72, 0xa2, 0x02, 0x73, 0xe0, 0xf0, 0x00, 0x61, 0x20, 0xf0, 0x70, 0xa2, 0xff, 0x73, 0xc0, 0xf0, 0x1b, 0x60, 0x20, 0xf0, 0x74, 0xa2, 0x10, 0x95, 0xae, 0xeb, 0xc0, 0xf0, 0x15, 0x2b, 0x13, 0x95, 0x96, 0xaa, 0xa0, 0x33, 0x70, 0x33, 0x8e, 0xeb, 0xc0, 0xf0, 0x0e, 0x2b, 0x20, 0xf0, 0x76, 0xa2, 0x01, 0x4b, 0x20, 0xf0, 0x76, 0xc2, 0xc0, 0xf0, 0x4d, 0xa0, 0x02, 0x72, 0x15, 0x61, 0x15, 0x93, 0x08, 0xf4, 0x10, 0x6a, 0x6c, 0xea, 0x06, 0x22, 0xa0, 0xf0, 0x5c, 0xa8, 0x01, 0x4a, 0xa0
+, 0xf0, 0x5c, 0xc8, 0x0a, 0x10, 0x15, 0x94, 0x11, 0xf1, 0x00, 0x6a, 0x8c, 0xea, 0x05, 0x22, 0xc0, 0xf0, 0x42, 0xa8, 0x01, 0x4a, 0xc0, 0xf0, 0x42, 0xc8, 0x14, 0x93, 0x3c, 0x6a, 0x12, 0x94, 0x58, 0xeb, 0xbd, 0x67, 0x70, 0xad, 0x12, 0xea, 0x49, 0xe4, 0x20, 0xf0, 0x50, 0xa2, 0x6a, 0xea, 0x0e, 0x60, 0x02, 0x6c, 0x04, 0xd4, 0xcb, 0xb4, 0x05, 0xd4, 0xfa, 0x6d, 0x02, 0x6c, 0x03, 0xf6, 0x11, 0x6e, 0x61, 0xf4, 0x17, 0x6f, 0x06, 0xd3, 0x20, 0x18, 0x00, 0x2d, 0x07, 0xd2, 0x14, 0x93, 0x3c, 0x6a, 0x12, 0x94, 0x58, 0xeb, 0x12, 0xea, 0x49, 0xe4, 0x20, 0xf0, 0x56, 0xa2, 0x04, 0x5a, 0x15, 0x61, 0xbf, 0xb2, 0x60, 0xf1, 0x45, 0xa2, 0x11, 0x22, 0x20, 0x18, 0x6e, 0x22, 0x00, 0x65, 0x2e, 0xea, 0x0c, 0x22, 0xc0, 0xf0, 0x58, 0xa0, 0x09, 0x2a, 0x00, 0x18, 0x3c, 0x3b, 0x01, 0x6c, 0xbd, 0xb3, 0x80, 0xa3, 0x01, 0x6a, 0x44, 0xe9, 0x8d, 0xea, 0x40, 0xc3, 0x14, 0x93, 0x3c, 0x6a, 0x12, 0x94, 0x58, 0xeb, 0xb9, 0xb3, 0x12, 0xea, 0x49, 0xe4, 0x20, 0xf0, 0xb6, 0xa2, 0xc0, 0xf0, 0x4a, 0xab, 0x03, 0x6c, 0x42, 0x32, 0x4a, 0x32, 0x8c, 0xea, 0x44, 0x32, 0x42, 0xed, 0x2f, 0x61, 0xac, 0xb2, 0x60, 0xf1, 0x47, 0xa2, 0x2b, 0x22, 0x17, 0xd3, 0x20, 0x18, 0x6e, 0x22, 0x16, 0xd4, 0x2e, 0xea, 0x17, 0x93, 0x16, 0x94, 0x23, 0x22, 0xc0, 0xf0, 0x59, 0xa0, 0x20, 0x2a, 0xab, 0xb2, 0xa0, 0xaa, 0x02, 0x6a, 0xac, 0xea, 0x1b, 0x2a, 0xc0, 0xf0, 0x6a, 0xab, 0xa9, 0xb5, 0x40, 0xa5, 0x62, 0x33, 0x72, 0x33, 0x8c, 0xeb, 0x01, 0x4a, 0xff, 0x6e, 0x64, 0x33, 0xcc, 0xea, 0x01, 0x4b, 0x7a, 0xea, 0x01, 0x2b, 0xe5, 0xe8, 0x40, 0xc5, 0x10, 0xea, 0x09, 0x2a, 0x00, 0x18, 0x27, 0x3b, 0x01, 0x6c, 0x9c, 0xb3, 0x80, 0xa3, 0x01, 0x6a, 0x44, 0xe9, 0x8d, 0xea, 0x40, 0xc3, 0x9a, 0xb2, 0x7c, 0x4a, 0x58, 0x9a, 0x10, 0x6b, 0x6c, 0xea, 0x30, 0x22, 0x14, 0x93, 0x3c, 0x6a, 0x12, 0x94, 0x58, 0xeb, 0x12, 0xea, 0x49, 0xe4, 0x20, 0xf0, 0x56, 0xa2, 0x04, 0x5a, 0x04, 0x61, 0x95, 0xb2, 0x00, 0xf1, 0x54, 0xa2, 0x06, 0x2a, 0xe0, 0xf0, 0x47, 0xa0, 0x1f, 0x2a, 0x93, 0xb2, 0x40, 0xa2, 0x1c, 0x2a, 0x92, 0xb3, 0x40, 0xa3, 0xff, 0x6c, 0x01, 0x4a, 0x8c, 0xea, 0x40, 0xc3, 0x8a, 0xb3, 0x7c, 0x4b, 0x78, 0x9b, 
+0x07, 0x6c, 0x7a, 0x33, 0x8c, 0xeb, 0x64, 0x33, 0x01, 0x4b, 0x7b, 0xea, 0x01, 0x2b, 0xe5, 0xe8, 0x10, 0xea, 0x09, 0x2a, 0x00, 0x18, 0xb5, 0xcd, 0x01, 0x6c, 0x88, 0xb3, 0x80, 0xa3, 0x01, 0x6a, 0x44, 0xe9, 0x8d, 0xea, 0x40, 0xc3, 0xe0, 0xf0, 0x67, 0xa0, 0x15, 0x94, 0xff, 0x6a, 0x01, 0x5b, 0x78, 0x67, 0x6b, 0xeb, 0x6c, 0xea, 0x19, 0xf5, 0x18, 0x6b, 0x8c, 0xeb, 0x04, 0x23, 0x10, 0x95, 0x02, 0x25, 0x01, 0x6a, 0x02, 0x10, 0xff, 0x72, 0x03, 0x60, 0x7d, 0xb4, 0x31, 0xe4, 0x40, 0xc4, 0x6f, 0xb2, 0x60, 0xf1, 0x50, 0xa2, 0xff, 0x6c, 0xfd, 0x4a, 0x8c, 0xea, 0x02, 0x5a, 0x10, 0x60, 0x80, 0xf2, 0x5c, 0xa0, 0x03, 0x72, 0x0c, 0x61, 0x11, 0x94, 0x0a, 0x6a, 0xbd, 0x67, 0x58, 0xec, 0x91, 0xad, 0x60, 0xb5, 0x17, 0xd3, 0x12, 0xea, 0x00, 0x18, 0x86, 0x07, 0x55, 0xe5, 0x17, 0x93, 0x06, 0x23, 0x5d, 0x67, 0x90, 0xaa, 0x00, 0x18, 0x61, 0xa2, 0x17, 0xd3, 0x17, 0x93, 0x5f, 0xb2, 0x60, 0xf1, 0x50, 0xa2, 0xff, 0x6c, 0xfd, 0x4a, 0x8c, 0xea, 0x02, 0x5a, 0x04, 0x60, 0x80, 0xf2, 0x5c, 0xa0, 0x03, 0x72, 0x0c, 0x60, 0x59, 0xb2, 0x29, 0xe2, 0x80, 0xf1, 0x40, 0xa2, 0x07, 0x22, 0x91, 0x67, 0x00, 0x18, 0xce, 0x06, 0x17, 0xd3, 0x10, 0xd2, 0x17, 0x93, 0x02, 0x10, 0x00, 0x6c, 0x10, 0xd4, 0x11, 0x95, 0x2a, 0x25, 0x5f, 0xb2, 0x29, 0xe2, 0x44, 0xa2, 0x01, 0x6c, 0x46, 0x32, 0x8c, 0xea, 0x23, 0x22, 0x22, 0x2b, 0x5c, 0xb2, 0xa9, 0xe2, 0x60, 0xa2, 0x6a, 0x33, 0x60, 0xc2, 0xe0, 0xf0, 0x47, 0xa0, 0x01, 0x72, 0x19, 0x61, 0x59, 0xb2, 0xa9, 0xe2, 0x40, 0xa2, 0x15, 0x2a, 0x60, 0xf0, 0x56, 0xa8, 0x7d, 0x67, 0x01, 0x4a, 0x60, 0xf0, 0x56, 0xc8, 0x20, 0xf3, 0x0b, 0x6a, 0x58, 0xcb, 0x53, 0xb2, 0x80, 0x9a, 0x0d, 0x92, 0xb0, 0xab, 0x0b, 0x96, 0x04, 0xd2, 0x0c, 0x97, 0x0e, 0x92, 0x0a, 0xd5, 0x00, 0x18, 0x79, 0x1c, 0x05, 0xd2, 0x4e, 0xb2, 0x40, 0x9a, 0x06, 0x22, 0x7d, 0x67, 0xb1, 0xab, 0x10, 0x96, 0x40, 0xea, 0x08, 0x04, 0x57, 0x2a, 0x44, 0xb2, 0x40, 0xa2, 0x19, 0x2a, 0x40, 0xb2, 0x40, 0xa2, 0x16, 0x2a, 0xc0, 0xf0, 0x6d, 0xa0, 0x02, 0x6c, 0x46, 0xb2, 0x8e, 0xeb, 0x0a, 0x23, 0x01, 0x6b, 0x60, 0xc2, 0x37, 0xb2, 0x7c, 0x4a, 0x58, 0x9a, 0x03, 0x6c, 0x42, 0x32, 0x46, 0x32
+, 0x4c, 0xec, 0x03, 0x10, 0x60, 0xc2, 0x40, 0xb2, 0x80, 0xa2, 0x00, 0x18, 0xb5, 0xcd, 0x00, 0x65, 0x10, 0x95, 0x02, 0x2d, 0x13, 0x92, 0x08, 0x22, 0x13, 0x93, 0x01, 0x73, 0x27, 0x61, 0x10, 0x94, 0x25, 0x2c, 0x25, 0xb2, 0x44, 0x9a, 0x22, 0x22, 0xe0, 0xf0, 0x47, 0xa0, 0x01, 0x6d, 0xae, 0xea, 0x1d, 0x2a, 0x36, 0xb3, 0x02, 0x49, 0x28, 0x31, 0x27, 0xe3, 0x60, 0x99, 0x00, 0x53, 0x16, 0x61, 0x11, 0x93, 0x14, 0x23, 0x11, 0x94, 0x0a, 0x6b, 0x18, 0xf0, 0x00, 0x6d, 0x78, 0xec, 0x14, 0xb4, 0x12, 0xeb, 0x6d, 0xe4, 0x83, 0xab, 0x00, 0x18, 0xec, 0x3a, 0x16, 0xd2, 0x11, 0x95, 0x16, 0x92, 0x26, 0xb3, 0xad, 0xe3, 0x40, 0xc3, 0x23, 0xb3, 0xad, 0xe3, 0x40, 0xc3, 0x13, 0xb2, 0x60, 0xf1, 0x49, 0xa2, 0x01, 0x72, 0x08, 0x61, 0x00, 0xf2, 0x52, 0xa0, 0x05, 0x22, 0xa0, 0xf0, 0x44, 0xa8, 0x01, 0x4a, 0xa0, 0xf0, 0x44, 0xc8, 0x1b, 0x97, 0x1a, 0x91, 0x19, 0x90, 0x00, 0xef, 0x0e, 0x63, 0x00, 0x65, 0x08, 0x00, 0x00, 0xb6, 0x8d, 0x04, 0x11, 0x80, 0x94, 0x36, 0x11, 0x80, 0xdc, 0x39, 0x11, 0x80, 0xc0, 0x1a, 0x11, 0x80, 0xc4, 0x1a, 0x11, 0x80, 0xa0, 0x50, 0x11, 0x80, 0xac, 0x50, 0x11, 0x80, 0xb4, 0x54, 0x11, 0x80, 0xc0, 0x50, 0x11, 0x80, 0x00, 0xd9, 0x04, 0x80, 0xbc, 0x19, 0x11, 0x80, 0xc4, 0x19, 0x11, 0x80, 0x10, 0x1a, 0x11, 0x80, 0x1f, 0x1a, 0x11, 0x80, 0x58, 0x00, 0x11, 0x80, 0x20, 0x01, 0x00, 0xb6, 0x20, 0x1a, 0x11, 0x80, 0x40, 0x3b, 0x11, 0x80, 0x66, 0x1b, 0x11, 0x80, 0x1e, 0x1a, 0x11, 0x80, 0x1c, 0x1a, 0x11, 0x80, 0xb0, 0x19, 0x11, 0x80, 0x70, 0x3a, 0x11, 0x80, 0x78, 0x19, 0x11, 0x80, 0x6c, 0x19, 0x11, 0x80, 0x80, 0x36, 0x11, 0x80, 0x0c, 0x1a, 0x11, 0x80, 0xe1, 0x19, 0x11, 0x80, 0x55, 0x00, 0x11, 0x80, 0x0c, 0xa3, 0x00, 0xb0, 0xfc, 0x63, 0x07, 0x62, 0x0f, 0xb3, 0x60, 0xf1, 0x64, 0x9b, 0x0f, 0xb2, 0x6c, 0xea, 0x0f, 0xb3, 0x6e, 0xea, 0x13, 0x2a, 0x0e, 0xb2, 0xff, 0xf7, 0x1f, 0x6b, 0xff, 0x6c, 0x40, 0xaa, 0x1f, 0x4c, 0x4c, 0xeb, 0x5d, 0x67, 0x68, 0xca, 0x08, 0x6a, 0x4b, 0xea, 0x6c, 0xea, 0x01, 0x6b, 0x6d, 0xea, 0x7d, 0x67, 0x50, 0xc3, 0x00, 0x18, 0xec, 0x3a, 0xa8, 0xab, 0x07, 0x97, 0x00, 0xef, 0x04, 0x63, 0xc0, 0x50, 0x11, 0x80, 0xff, 
+0x00, 0x00, 0xff, 0x01, 0x00, 0x00, 0x01, 0x1e, 0x01, 0x00, 0xb6, 0xfd, 0x63, 0x05, 0x62, 0x00, 0x1c, 0x5e, 0x1b, 0x00, 0x65, 0x09, 0xb3, 0x60, 0x9b, 0x81, 0x43, 0x07, 0x24, 0x24, 0x6c, 0x98, 0xeb, 0x07, 0xb4, 0x12, 0xeb, 0x6d, 0xe4, 0x06, 0xb4, 0x83, 0xdb, 0x00, 0x1c, 0x65, 0x1b, 0x82, 0x67, 0x05, 0x97, 0x00, 0xef, 0x03, 0x63, 0x0c, 0x06, 0x11, 0x80, 0x4c, 0x8a, 0x11, 0x80, 0x09, 0xd7, 0x10, 0x80, 0xf0, 0x63, 0x1f, 0x62, 0x1e, 0xd1, 0x1d, 0xd0, 0x80, 0xac, 0xc0, 0xf2, 0x0c, 0x68, 0xc1, 0xb2, 0x18, 0xec, 0x19, 0xd4, 0xa0, 0xa5, 0x12, 0xd5, 0x12, 0xe8, 0x41, 0xe0, 0xe0, 0xf0, 0x47, 0xa0, 0x13, 0xd2, 0xa0, 0xf0, 0x60, 0xa8, 0x18, 0xd3, 0xa0, 0xf0, 0x82, 0xa8, 0x80, 0xf0, 0x7e, 0xa8, 0x17, 0xd4, 0xa0, 0xf0, 0xa6, 0xa8, 0x16, 0xd5, 0xe0, 0xf0, 0x4e, 0xa0, 0x11, 0xd2, 0x00, 0x6a, 0xc0, 0xf2, 0x44, 0xc0, 0xc0, 0xf2, 0x45, 0xc0, 0xe0, 0xf0, 0x23, 0xa0, 0x11, 0x94, 0x1b, 0xd3, 0x00, 0x18, 0x91, 0xba, 0xb1, 0x67, 0x0a, 0x6c, 0x98, 0xea, 0x14, 0xd2, 0xae, 0xb2, 0x12, 0xec, 0x49, 0xe4, 0x15, 0xd2, 0xe0, 0xf0, 0xa3, 0xa0, 0x00, 0x18, 0xe6, 0x3c, 0x11, 0x94, 0x12, 0x92, 0x1b, 0x93, 0x0c, 0x22, 0x13, 0x94, 0x01, 0x74, 0x09, 0x61, 0x15, 0x92, 0x03, 0xf4, 0x00, 0x6c, 0x18, 0xf0, 0x00, 0x6d, 0x00, 0x18, 0xc8, 0x96, 0xc3, 0xaa, 0x1b, 0x93, 0x00, 0x1c, 0x5e, 0x1b, 0x1b, 0xd3, 0x0a, 0x04, 0xb1, 0x67, 0x00, 0x18, 0x66, 0x96, 0x1a, 0xd2, 0x0a, 0x92, 0x9f, 0xb4, 0x1b, 0x93, 0x46, 0x32, 0x01, 0x4a, 0x8c, 0xea, 0x0a, 0xd2, 0xa0, 0xf2, 0x9e, 0xa8, 0x10, 0xd4, 0x07, 0x2c, 0x12, 0x95, 0x01, 0x75, 0x04, 0x61, 0x00, 0x1c, 0x65, 0x1b, 0x1a, 0x94, 0x21, 0x11, 0x06, 0x22, 0x05, 0x23, 0x7b, 0xea, 0x01, 0x2b, 0xe5, 0xe8, 0x10, 0xe9, 0x01, 0x10, 0x00, 0x69, 0xff, 0xf7, 0x1f, 0x6c, 0x27, 0xe3, 0x8c, 0xe9, 0x18, 0x94, 0x85, 0xe1, 0x23, 0xeb, 0x01, 0x60, 0x67, 0xe1, 0x12, 0x95, 0x01, 0x75, 0x02, 0x60, 0x10, 0xd3, 0x16, 0x10, 0x8b, 0xb3, 0xa0, 0xf2, 0x8c, 0x98, 0x8c, 0xeb, 0x43, 0xeb, 0x67, 0xe2, 0x03, 0x61, 0x89, 0xb1, 0x67, 0xe1, 0x45, 0xe1, 0x10, 0x95, 0x4b, 0xe3, 0xba, 0xe9, 0x01, 0x2d, 0xe5, 0xe8, 0x12, 0xe9, 0x01, 0x49, 0xb8, 0xe9, 0x12
+, 0xe9, 0x25, 0xe2, 0x81, 0xb2, 0x4c, 0xe9, 0x11, 0x93, 0xe0, 0xf0, 0xa3, 0xa0, 0x02, 0x6c, 0x74, 0x32, 0xa0, 0x35, 0xff, 0x6b, 0x6c, 0xea, 0xac, 0x35, 0x4d, 0xed, 0xff, 0xf7, 0x1f, 0x6a, 0x00, 0x18, 0xec, 0x3a, 0x4c, 0xed, 0x0a, 0x93, 0x71, 0xe1, 0x11, 0xd4, 0x05, 0x10, 0x11, 0x95, 0x10, 0x92, 0x55, 0xe5, 0x11, 0xd5, 0x45, 0xe1, 0x08, 0x59, 0xf9, 0x61, 0x00, 0x18, 0x35, 0x3a, 0x1b, 0xd3, 0x11, 0x94, 0x1b, 0x93, 0x6f, 0xe4, 0x64, 0x33, 0x6d, 0xe2, 0x70, 0xd8, 0x10, 0x95, 0x00, 0x18, 0xec, 0x3a, 0x4e, 0x6c, 0x11, 0x95, 0xff, 0xf7, 0x1f, 0x6a, 0x48, 0x6c, 0x4c, 0xed, 0x18, 0xd5, 0x00, 0x18, 0xec, 0x3a, 0x1b, 0xd2, 0x13, 0x93, 0x12, 0x2b, 0x16, 0x95, 0x00, 0x18, 0xec, 0x3a, 0x4c, 0x6c, 0x17, 0x95, 0x00, 0x18, 0xec, 0x3a, 0x4a, 0x6c, 0x65, 0xb3, 0x1b, 0x92, 0x00, 0xf2, 0x1c, 0x6c, 0xa0, 0xab, 0x40, 0x6b, 0x4c, 0xed, 0x6d, 0xed, 0x4c, 0xed, 0x16, 0x10, 0x61, 0xb3, 0x7c, 0x4b, 0x78, 0x9b, 0x10, 0xf0, 0x00, 0x6a, 0x6c, 0xea, 0x08, 0x22, 0x16, 0x94, 0x03, 0x24, 0x4c, 0x6c, 0x01, 0x6d, 0x05, 0x10, 0x4c, 0x6c, 0x00, 0x6d, 0x02, 0x10, 0x16, 0x95, 0x4c, 0x6c, 0x00, 0x18, 0xec, 0x3a, 0x00, 0x65, 0x17, 0x95, 0x4a, 0x6c, 0x00, 0x18, 0xec, 0x3a, 0x00, 0x65, 0x07, 0x6d, 0x00, 0x18, 0xec, 0x3a, 0x00, 0x6c, 0x12, 0x95, 0x0e, 0x2d, 0x13, 0x92, 0x01, 0x72, 0x0b, 0x61, 0x14, 0x93, 0x51, 0xb2, 0x69, 0xe2, 0xa0, 0xc2, 0x50, 0xb2, 0x69, 0xe2, 0x7d, 0x67, 0x87, 0x43, 0x41, 0x4c, 0x60, 0xa4, 0x60, 0xc2, 0x1a, 0x94, 0x00, 0x1c, 0x65, 0x1b, 0x02, 0x49, 0x00, 0x18, 0x1c, 0x04, 0x00, 0x65, 0x01, 0xf0, 0x00, 0x6d, 0x00, 0x18, 0xd9, 0xbb, 0x5e, 0x6c, 0x11, 0x95, 0x18, 0x94, 0x03, 0x6a, 0x04, 0xd2, 0x46, 0xb2, 0x05, 0xd2, 0x06, 0xd4, 0xa4, 0x32, 0x07, 0xd5, 0x00, 0x6c, 0xfa, 0x6d, 0x63, 0xf3, 0x17, 0x6e, 0x40, 0x6f, 0x20, 0x18, 0x00, 0x2d, 0x08, 0xd2, 0x12, 0x92, 0x1f, 0x2a, 0x13, 0x93, 0x01, 0x73, 0x0c, 0x61, 0x15, 0x92, 0x18, 0xf0, 0x00, 0x6c, 0x03, 0xf4, 0x00, 0x6d, 0x00, 0x18, 0xc8, 0x96, 0xc3, 0xaa, 0x20, 0x6a, 0x00, 0xf2, 0x50, 0xc0, 0x24, 0x10, 0x51, 0x59, 0x06, 0x61, 0x19, 0x95, 0xff, 0xf7, 0x1f, 0x6c, 0x00, 0x18, 0xdf, 0x9b, 
+0x2c, 0xec, 0x15, 0x93, 0x18, 0xf0, 0x00, 0x6c, 0x01, 0xf4, 0x00, 0x6d, 0x00, 0x18, 0xc8, 0x96, 0xc3, 0xab, 0x13, 0x94, 0x12, 0x2c, 0x12, 0x95, 0x10, 0x25, 0x51, 0x59, 0x0e, 0x61, 0x19, 0x95, 0xff, 0xf7, 0x1f, 0x6c, 0x00, 0x18, 0xdf, 0x9b, 0x2c, 0xec, 0x15, 0x92, 0x01, 0xf4, 0x00, 0x6c, 0x18, 0xf0, 0x00, 0x6d, 0x00, 0x18, 0xc8, 0x96, 0xc3, 0xaa, 0x10, 0x94, 0x7d, 0x67, 0x60, 0xf2, 0x0b, 0x6a, 0x5a, 0xcb, 0x23, 0xb2, 0x0b, 0xd4, 0x80, 0x9a, 0x0e, 0x92, 0x10, 0x95, 0x0c, 0x96, 0x04, 0xd2, 0x0d, 0x97, 0x0f, 0x92, 0x00, 0x18, 0x79, 0x1c, 0x05, 0xd2, 0x03, 0x6a, 0x10, 0x95, 0x04, 0xd2, 0x1b, 0xb2, 0x05, 0xd2, 0x16, 0x93, 0x17, 0x92, 0x06, 0xd5, 0x05, 0x6c, 0xfa, 0x6d, 0xc3, 0xf3, 0x0d, 0x6e, 0x82, 0xf7, 0x1e, 0x6f, 0x07, 0xd2, 0x20, 0x18, 0x00, 0x2d, 0x08, 0xd3, 0x14, 0x94, 0x0d, 0x24, 0x64, 0x67, 0xff, 0x4b, 0x68, 0x33, 0x13, 0xb4, 0x71, 0xe4, 0x00, 0x6a, 0x40, 0xdc, 0x12, 0xb4, 0x71, 0xe4, 0x40, 0xdc, 0x11, 0xb4, 0x6d, 0xe4, 0x40, 0xdb, 0x1f, 0x97, 0x1e, 0x91, 0x1d, 0x90, 0x01, 0x6a, 0x00, 0xef, 0x10, 0x63, 0x00, 0x65, 0xb4, 0x54, 0x11, 0x80, 0xdc, 0x39, 0x11, 0x80, 0xff, 0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x08, 0x1c, 0x02, 0x00, 0xb6, 0x58, 0x00, 0x11, 0x80, 0x6c, 0x19, 0x11, 0x80, 0x78, 0x19, 0x11, 0x80, 0x00, 0xd9, 0x04, 0x80, 0x3c, 0x47, 0x11, 0x80, 0x2c, 0x1a, 0x11, 0x80, 0x5c, 0x1a, 0x11, 0x80, 0x8c, 0x1a, 0x11, 0x80, 0xfb, 0x63, 0x09, 0x62, 0x08, 0xd1, 0x07, 0xd0, 0x58, 0xb2, 0xff, 0xf7, 0x1f, 0x6b, 0x01, 0x6c, 0x40, 0xaa, 0x4c, 0xeb, 0x56, 0xb2, 0x40, 0xaa, 0x04, 0xd2, 0x56, 0xb2, 0x40, 0xa2, 0x8e, 0xea, 0x04, 0x2a, 0x55, 0xb4, 0x40, 0xc4, 0x55, 0xb4, 0x40, 0xc4, 0x00, 0x69, 0x92, 0x10, 0x54, 0xb2, 0x40, 0x9a, 0x05, 0x22, 0x08, 0xf0, 0x00, 0x6a, 0x6c, 0xea, 0x80, 0xf0, 0x0f, 0x22, 0x04, 0x92, 0x08, 0xf0, 0x00, 0x6c, 0x6c, 0xec, 0x4f, 0xe8, 0x6c, 0xe8, 0x00, 0x32, 0x40, 0x32, 0x43, 0x32, 0x43, 0x32, 0x04, 0x24, 0x00, 0x18, 0x1e, 0x9b, 0x05, 0xd2, 0x05, 0x92, 0x49, 0xb3, 0x7c, 0x4b, 0x75, 0x9b, 0x02, 0x6c, 0x8c, 0xeb, 0x0f, 0x23, 0x00, 0x52, 0x0d, 0x60, 0x00, 0x18, 0xc9, 0x1a, 0x00, 0x65, 0x45, 0xb2
+, 0x40, 0xf0, 0x63, 0xa2, 0x06, 0x23, 0xff, 0xf7, 0x1e, 0x6b, 0x6c, 0xe8, 0x00, 0x6b, 0x40, 0xf0, 0x63, 0xc2, 0x08, 0x6a, 0x0c, 0xea, 0x03, 0x22, 0x00, 0x18, 0xcd, 0x09, 0x00, 0x65, 0x02, 0x6a, 0x0c, 0xea, 0x03, 0x22, 0x80, 0x18, 0xac, 0x2e, 0x00, 0x65, 0x01, 0x6a, 0x0c, 0xea, 0x03, 0x22, 0x00, 0x18, 0x3c, 0x13, 0x00, 0x6c, 0x20, 0x6a, 0x0c, 0xea, 0x03, 0x22, 0x00, 0x18, 0xf4, 0x05, 0x00, 0x65, 0x04, 0x6a, 0x0c, 0xea, 0x03, 0x22, 0x00, 0x18, 0x43, 0x11, 0x00, 0x65, 0x02, 0xf0, 0x00, 0x6a, 0x0c, 0xea, 0x09, 0x22, 0x00, 0x18, 0x5c, 0x11, 0x00, 0x65, 0x2e, 0xb2, 0x40, 0xa2, 0x03, 0x22, 0x00, 0x18, 0xc6, 0xa2, 0x00, 0x65, 0x00, 0xf6, 0x00, 0x6a, 0x0c, 0xea, 0x05, 0x22, 0x2a, 0xb2, 0xff, 0xf7, 0x1f, 0x69, 0x40, 0xaa, 0x4c, 0xe9, 0x00, 0xf2, 0x00, 0x6a, 0x0c, 0xea, 0x03, 0x22, 0x00, 0x18, 0xf0, 0x12, 0x91, 0x67, 0x00, 0xf4, 0x00, 0x6a, 0x0c, 0xea, 0x0f, 0x22, 0x00, 0x18, 0x29, 0x13, 0x91, 0x67, 0xfe, 0xf7, 0x1f, 0x6d, 0x00, 0x18, 0xf4, 0xbb, 0x5e, 0x6c, 0x1b, 0xb2, 0xe0, 0xf0, 0x54, 0xa2, 0x03, 0x22, 0x00, 0x18, 0x01, 0xa9, 0x00, 0x65, 0x01, 0xf0, 0x00, 0x6d, 0x50, 0x67, 0xac, 0xea, 0x07, 0x22, 0x00, 0x18, 0x11, 0x13, 0x05, 0xd5, 0x05, 0x95, 0x00, 0x18, 0xd9, 0xbb, 0x5e, 0x6c, 0xff, 0x6a, 0x01, 0x4a, 0x0c, 0xea, 0x03, 0x22, 0x00, 0x18, 0x46, 0x05, 0x00, 0x65, 0x08, 0xb2, 0xff, 0xf7, 0x1f, 0x6b, 0x40, 0xaa, 0x4c, 0xeb, 0x04, 0x94, 0x8f, 0xea, 0x6c, 0xea, 0x7f, 0xf7, 0x09, 0x2a, 0x09, 0x97, 0x08, 0x91, 0x07, 0x90, 0x00, 0xef, 0x05, 0x63, 0x00, 0x65, 0xbe, 0x00, 0x00, 0xb6, 0x82, 0x04, 0x11, 0x80, 0x68, 0x3a, 0x11, 0x80, 0x23, 0x1a, 0x11, 0x80, 0xa8, 0x39, 0x11, 0x80, 0x84, 0x3a, 0x11, 0x80, 0x58, 0x00, 0x11, 0x80, 0xec, 0x44, 0x11, 0x80, 0xd8, 0x1a, 0x11, 0x80, 0x5c, 0x00, 0x00, 0xb6, 0xfd, 0x63, 0x05, 0x62, 0x04, 0xd0, 0x2a, 0xb2, 0x40, 0x9a, 0x1e, 0xf4, 0x01, 0x6b, 0x6b, 0xeb, 0x4d, 0xeb, 0x40, 0x9c, 0x04, 0x67, 0x6c, 0xea, 0x7c, 0x6b, 0x4c, 0xeb, 0x40, 0xdc, 0x03, 0x23, 0x00, 0x18, 0x75, 0x39, 0x00, 0x65, 0x61, 0xa0, 0x40, 0x6a, 0x6c, 0xea, 0x03, 0x22, 0x00, 0x18, 0x99, 0x02, 0x00, 0x65, 0x61, 0xa0, 0x04, 
+0x6a, 0x6c, 0xea, 0x03, 0x22, 0x80, 0x18, 0x0f, 0x31, 0x00, 0x65, 0x61, 0xa0, 0x10, 0x6a, 0x6c, 0xea, 0x03, 0x22, 0x00, 0x18, 0xe0, 0x03, 0x00, 0x65, 0x61, 0xa0, 0x08, 0x6a, 0x4c, 0xeb, 0x0a, 0x23, 0x15, 0xb3, 0x61, 0xa3, 0x6c, 0xea, 0x03, 0x22, 0x00, 0x18, 0xc0, 0x00, 0x00, 0x65, 0x00, 0x18, 0x76, 0x37, 0x00, 0x65, 0x61, 0xa0, 0x80, 0x6a, 0x4b, 0xea, 0x6c, 0xea, 0xff, 0x6b, 0x6c, 0xea, 0x03, 0x22, 0x00, 0x18, 0xad, 0x02, 0x00, 0x65, 0x61, 0xa0, 0x20, 0x6a, 0x6c, 0xea, 0x03, 0x22, 0x00, 0x18, 0x2d, 0x02, 0x00, 0x65, 0x09, 0xb2, 0x60, 0xa2, 0x04, 0x23, 0x00, 0x6b, 0x00, 0x18, 0x74, 0x33, 0x60, 0xc2, 0x00, 0x6b, 0x06, 0xb2, 0x60, 0xc2, 0x05, 0x97, 0x04, 0x90, 0x01, 0x6a, 0x00, 0xef, 0x03, 0x63, 0x90, 0x20, 0x11, 0x80, 0x88, 0x07, 0x11, 0x80, 0xd0, 0x07, 0x11, 0x80, 0xf8, 0x63, 0x0f, 0x62, 0x0e, 0xd0, 0x68, 0xa4, 0x01, 0x6a, 0x04, 0x67, 0x6c, 0xea, 0x04, 0x22, 0x00, 0x18, 0x0a, 0x02, 0x00, 0x65, 0x4f, 0x2a, 0x68, 0xa0, 0x04, 0x6a, 0x6c, 0xea, 0x04, 0x22, 0x00, 0x18, 0x97, 0x01, 0x90, 0x67, 0x47, 0x2a, 0x68, 0xa0, 0x08, 0x6a, 0x6c, 0xea, 0x04, 0x22, 0x00, 0x18, 0x72, 0x01, 0x90, 0x67, 0x3f, 0x2a, 0x2d, 0xb2, 0x7c, 0x4a, 0x58, 0x9a, 0x02, 0x6b, 0x6c, 0xea, 0x18, 0x22, 0x68, 0xa0, 0x80, 0x6a, 0x4b, 0xea, 0x6c, 0xea, 0xff, 0x6b, 0x6c, 0xea, 0x04, 0x22, 0x00, 0x18, 0xf0, 0x01, 0x90, 0x67, 0x2e, 0x2a, 0x68, 0xa0, 0x40, 0x6a, 0x6c, 0xea, 0x04, 0x22, 0x00, 0x18, 0xdc, 0x01, 0x90, 0x67, 0x26, 0x2a, 0x62, 0x98, 0xc1, 0x6a, 0x4b, 0xea, 0x6c, 0xea, 0x37, 0x22, 0x1e, 0xb2, 0x80, 0xf0, 0x7c, 0xa2, 0x5d, 0x67, 0x20, 0xf0, 0x70, 0xc2, 0x04, 0x6a, 0x6c, 0xea, 0x07, 0x22, 0x66, 0xa0, 0x7f, 0x6a, 0x6c, 0xea, 0x21, 0x6b, 0x6b, 0xeb, 0x6c, 0xea, 0x46, 0xc0, 0x16, 0xb2, 0x20, 0xf0, 0x7b, 0xa2, 0x5d, 0x67, 0x20, 0xf0, 0x74, 0xc2, 0x40, 0x6a, 0x6c, 0xea, 0x05, 0x22, 0x66, 0xa0, 0x21, 0x6a, 0x4b, 0xea, 0x6c, 0xea, 0x46, 0xc0, 0x00, 0x18, 0xf9, 0x36, 0x84, 0x40, 0x05, 0x6a, 0x04, 0xd2, 0x0e, 0xb2, 0x05, 0xd2, 0x40, 0x98, 0x04, 0x6c, 0xfa, 0x6d, 0x06, 0xd2, 0x43, 0x98, 0x82, 0xf6, 0x0b, 0x6e, 0xa1, 0xf1, 0x1a, 0x6f, 0x07, 0xd2, 0x42
+, 0x98, 0x08, 0xd2, 0x41, 0x98, 0x09, 0xd2, 0x44, 0x98, 0x20, 0x18, 0x00, 0x2d, 0x0a, 0xd2, 0x0f, 0x97, 0x0e, 0x90, 0x01, 0x6a, 0x00, 0xef, 0x08, 0x63, 0x58, 0x00, 0x11, 0x80, 0x00, 0xd9, 0x04, 0x80, 0xfd, 0x63, 0x05, 0x62, 0x04, 0xd0, 0x00, 0x68, 0x18, 0xb4, 0x04, 0x32, 0x49, 0xe4, 0x60, 0xaa, 0xff, 0xf7, 0x1f, 0x73, 0x0e, 0x60, 0x41, 0x40, 0x44, 0x32, 0x49, 0xe4, 0xc0, 0xaa, 0x3f, 0x6c, 0x6c, 0xec, 0x00, 0x18, 0xa4, 0xa4, 0x00, 0x6d, 0x02, 0x48, 0xff, 0x6a, 0x4c, 0xe8, 0x10, 0x58, 0xeb, 0x61, 0x00, 0x68, 0x0e, 0xb4, 0x04, 0x32, 0x49, 0xe4, 0x60, 0xaa, 0xff, 0xf7, 0x1f, 0x73, 0x0e, 0x60, 0x41, 0x40, 0x44, 0x32, 0x49, 0xe4, 0xc0, 0xaa, 0x3f, 0x6c, 0x6c, 0xec, 0x00, 0x18, 0xa4, 0xa4, 0x00, 0x6d, 0x02, 0x48, 0xff, 0x6a, 0x4c, 0xe8, 0x1a, 0x58, 0xeb, 0x61, 0x05, 0x97, 0x04, 0x90, 0x00, 0xef, 0x03, 0x63, 0x00, 0x65, 0x40, 0xdd, 0x10, 0x80, 0x60, 0xdd, 0x10, 0x80, 0xfa, 0x63, 0x0b, 0x62, 0x0a, 0xd1, 0x09, 0xd0, 0xff, 0x69, 0x36, 0xb0, 0x8c, 0xe9, 0x61, 0xf3, 0x06, 0x6d, 0x00, 0x18, 0xec, 0x3a, 0x22, 0x6c, 0x20, 0xf0, 0xbf, 0xa0, 0xf3, 0x6a, 0x24, 0x6c, 0xa0, 0x35, 0x00, 0x18, 0xec, 0x3a, 0x4d, 0xed, 0x40, 0xf0, 0xa1, 0xa0, 0x40, 0xf0, 0x40, 0xa0, 0x26, 0x6c, 0xa0, 0x35, 0x00, 0x18, 0xec, 0x3a, 0x4d, 0xed, 0xeb, 0xf0, 0x12, 0x6d, 0x00, 0x18, 0xec, 0x3a, 0x28, 0x6c, 0x93, 0xf7, 0x1a, 0x6d, 0x00, 0x18, 0xec, 0x3a, 0x2a, 0x6c, 0x00, 0x18, 0xee, 0x39, 0x01, 0x6c, 0x02, 0x6c, 0x00, 0x18, 0xec, 0x3a, 0x20, 0x6d, 0x22, 0xb2, 0x03, 0xf4, 0x00, 0x6d, 0x00, 0x18, 0xec, 0x3a, 0x81, 0xa2, 0x20, 0xb2, 0x20, 0x6d, 0x5e, 0x6c, 0x60, 0xaa, 0x9f, 0xf7, 0x1f, 0x6a, 0x6c, 0xea, 0x00, 0x18, 0xec, 0x3a, 0x4d, 0xed, 0xff, 0x6c, 0x09, 0x4c, 0x00, 0x18, 0xec, 0x3a, 0x03, 0x6d, 0x1a, 0xb2, 0x81, 0xa2, 0x1a, 0xb2, 0x49, 0xe4, 0x60, 0xaa, 0xee, 0xf1, 0x09, 0x6a, 0x6c, 0xea, 0xff, 0x6b, 0x21, 0x4b, 0x6d, 0xea, 0x16, 0xb3, 0xa0, 0xa3, 0x07, 0x6b, 0x6c, 0xed, 0xa0, 0x35, 0xa4, 0x35, 0x00, 0x18, 0xec, 0x3a, 0x4d, 0xed, 0x02, 0x6c, 0x00, 0x18, 0xec, 0x3a, 0x20, 0x6d, 0x00, 0x6c, 0x00, 0x18, 0xec, 0x3a, 0x0d, 0x6d, 0x0b, 0x21, 0x04, 0x00, 
+0x90, 0x67, 0x55, 0x6d, 0x00, 0x18, 0x5a, 0x33, 0x0a, 0x6e, 0x01, 0x6c, 0x00, 0x6d, 0x00, 0x18, 0xb9, 0x3c, 0xd0, 0x67, 0x0b, 0x97, 0x0a, 0x91, 0x09, 0x90, 0x00, 0xef, 0x06, 0x63, 0x58, 0x00, 0x11, 0x80, 0x6c, 0xe3, 0x04, 0x80, 0x5e, 0x00, 0x00, 0xb6, 0x74, 0xe3, 0x04, 0x80, 0x00, 0x00, 0x00, 0xb6, 0x28, 0x05, 0x11, 0x80, 0xf9, 0x63, 0x0d, 0x62, 0x0c, 0xd1, 0x0b, 0xd0, 0x0f, 0xd5, 0x10, 0xd6, 0x40, 0xa5, 0x04, 0x67, 0x09, 0xd2, 0x60, 0xa6, 0x08, 0xd3, 0x40, 0xac, 0x7f, 0xf4, 0x10, 0x72, 0x1c, 0x60, 0x7f, 0xf4, 0x11, 0x6b, 0x63, 0xea, 0x07, 0x60, 0x1f, 0xf4, 0x16, 0x72, 0x0b, 0x60, 0x7f, 0xf4, 0x0f, 0x72, 0x4d, 0x60, 0x62, 0x10, 0x5f, 0xf5, 0x04, 0x72, 0x16, 0x60, 0x5f, 0xf5, 0x05, 0x72, 0x0b, 0x60, 0x5b, 0x10, 0x33, 0xb2, 0xc0, 0xf1, 0x7f, 0xa2, 0x07, 0x6a, 0x6c, 0xea, 0x55, 0x22, 0x00, 0x18, 0x79, 0x24, 0x00, 0x6c, 0x51, 0x10, 0x43, 0xa0, 0x00, 0x6c, 0x01, 0x22, 0x01, 0x6c, 0x80, 0x18, 0xfa, 0x31, 0x00, 0x65, 0x4f, 0x10, 0x24, 0xa4, 0x63, 0xa4, 0x1f, 0x6a, 0x4c, 0xe9, 0x29, 0xb2, 0x01, 0x23, 0x01, 0x6b, 0x20, 0xf0, 0x6a, 0xc2, 0x02, 0x6a, 0x04, 0xd2, 0x26, 0xb2, 0x05, 0xd2, 0x24, 0xb3, 0x20, 0xf0, 0x4a, 0xa3, 0x05, 0x6c, 0xfa, 0x6d, 0x62, 0xf4, 0x1c, 0x6e, 0x41, 0xf5, 0x11, 0x6f, 0x06, 0xd2, 0x20, 0x18, 0x00, 0x2d, 0x07, 0xd1, 0x0c, 0x21, 0x04, 0x6c, 0x00, 0x18, 0x46, 0xa4, 0x00, 0x6d, 0x1f, 0x6b, 0x4c, 0xeb, 0x05, 0x23, 0x2e, 0xeb, 0x03, 0x2b, 0x19, 0xb2, 0x20, 0xf0, 0x2b, 0xc2, 0x85, 0xa0, 0x17, 0xb3, 0x07, 0x6a, 0x8c, 0xea, 0xa3, 0xa3, 0x50, 0x34, 0x71, 0x6a, 0x4b, 0xea, 0xac, 0xea, 0x8d, 0xea, 0x43, 0xc3, 0x1c, 0x10, 0x00, 0x6b, 0x01, 0x6a, 0x08, 0xd3, 0x09, 0xd2, 0x80, 0xa8, 0x00, 0x18, 0xe7, 0x8e, 0x08, 0x95, 0x7d, 0x67, 0x47, 0x43, 0x1d, 0x4a, 0x40, 0xa2, 0x0f, 0x93, 0x40, 0xc3, 0x7d, 0x67, 0x47, 0x43, 0x19, 0x4a, 0x40, 0xa2, 0x10, 0x93, 0x40, 0xc3, 0x01, 0x6a, 0x01, 0x10, 0x00, 0x6a, 0x0d, 0x97, 0x0c, 0x91, 0x0b, 0x90, 0x00, 0xef, 0x07, 0x63, 0x09, 0x93, 0x01, 0x73, 0xe9, 0x61, 0xe4, 0x17, 0x58, 0x00, 0x11, 0x80, 0x28, 0x94, 0x11, 0x80, 0x00, 0xd9, 0x04, 0x80, 0xfd, 0x63, 0x05, 0x62, 0x06, 0xb2
+, 0xc0, 0xf1, 0x7f, 0xa2, 0x07, 0x6a, 0x6c, 0xea, 0x03, 0x22, 0x00, 0x18, 0x79, 0x24, 0x00, 0x6c, 0x05, 0x97, 0x00, 0xef, 0x03, 0x63, 0x58, 0x00, 0x11, 0x80, 0xf1, 0x63, 0x1d, 0x62, 0x1c, 0xd1, 0x1b, 0xd0, 0xff, 0xf7, 0x1f, 0x6a, 0x8c, 0xea, 0x57, 0xb3, 0x16, 0xd2, 0x48, 0x32, 0x49, 0xe3, 0x00, 0x6b, 0x00, 0x9a, 0x15, 0xd3, 0x17, 0xd3, 0x9d, 0x10, 0x43, 0xa8, 0x43, 0x2a, 0x15, 0x93, 0x01, 0x4b, 0x15, 0xd3, 0x15, 0x94, 0xff, 0x6b, 0x6c, 0xec, 0x0b, 0x5c, 0x15, 0xd4, 0x02, 0x61, 0x46, 0xd8, 0x92, 0x10, 0x00, 0x1c, 0x5e, 0x1b, 0x00, 0x65, 0x82, 0x67, 0x47, 0x98, 0x02, 0x72, 0x2b, 0x61, 0x17, 0x92, 0x0e, 0x2a, 0x16, 0x93, 0x68, 0x32, 0x46, 0xb3, 0x49, 0xe3, 0x60, 0x9a, 0x04, 0x2b, 0x00, 0x1c, 0x65, 0x1b, 0x00, 0x65, 0x7f, 0x10, 0x66, 0x98, 0x14, 0xd3, 0x60, 0xda, 0x05, 0x10, 0x46, 0x98, 0x17, 0x93, 0x46, 0xdb, 0x46, 0x98, 0x14, 0xd2, 0x01, 0x6a, 0x47, 0xd8, 0x00, 0x6a, 0x00, 0x1c, 0x65, 0x1b, 0x46, 0xd8, 0x43, 0x98, 0x03, 0x22, 0x80, 0x98, 0x40, 0xea, 0xa5, 0x98, 0x44, 0x98, 0x01, 0x72, 0x65, 0x61, 0x47, 0x98, 0x01, 0x72, 0x62, 0x61, 0x80, 0x98, 0x20, 0x18, 0xc7, 0x30, 0xa2, 0x98, 0x5d, 0x10, 0x00, 0x1c, 0x65, 0x1b, 0x00, 0x65, 0x06, 0x98, 0x14, 0xd0, 0x57, 0x10, 0x00, 0x1c, 0x5e, 0x1b, 0x00, 0x65, 0x82, 0x67, 0x47, 0x98, 0x02, 0x72, 0x09, 0x61, 0x43, 0xa8, 0x66, 0x98, 0xff, 0x4a, 0x43, 0xc8, 0x00, 0x1c, 0x65, 0x1b, 0x14, 0xd3, 0x17, 0xd0, 0x04, 0x10, 0x00, 0x1c, 0x65, 0x1b, 0x00, 0x65, 0x14, 0xd0, 0x47, 0x98, 0x02, 0x72, 0x40, 0x61, 0x63, 0x98, 0x25, 0xb2, 0x4b, 0xe3, 0x3c, 0x2a, 0xc0, 0xf2, 0x0c, 0x69, 0x38, 0xea, 0x23, 0xb3, 0x12, 0xe9, 0x65, 0xe1, 0x8b, 0x99, 0x60, 0x98, 0x8e, 0xeb, 0x2d, 0x2b, 0xe0, 0xf0, 0xa3, 0xa1, 0x12, 0x04, 0x00, 0x18, 0x66, 0x96, 0x18, 0xd2, 0x0b, 0x6b, 0x04, 0xd3, 0x1c, 0xb3, 0x05, 0xd3, 0x18, 0x92, 0x12, 0x93, 0x02, 0x6c, 0x07, 0xd2, 0x06, 0xd3, 0xe0, 0xf0, 0x43, 0xa1, 0xfa, 0x6d, 0x82, 0xf3, 0x1f, 0x6e, 0x08, 0xd2, 0xe0, 0xf0, 0x4e, 0xa1, 0x64, 0xf4, 0x14, 0x6f, 0x09, 0xd2, 0x4d, 0x99, 0x0a, 0xd2, 0x60, 0xf2, 0x52, 0xa1, 0x0b, 0xd2, 0x60, 0xf2, 0x53, 0xa1, 0x0c, 0xd2, 0x4c, 
+0x99, 0x0d, 0xd2, 0x40, 0x98, 0x0e, 0xd2, 0x43, 0xa8, 0x0f, 0xd2, 0x48, 0x98, 0x20, 0x18, 0x00, 0x2d, 0x10, 0xd2, 0x05, 0x10, 0x01, 0x4a, 0xff, 0x6b, 0x6c, 0xea, 0x0a, 0x5a, 0xc4, 0x61, 0x14, 0x90, 0x7f, 0xf7, 0x01, 0x28, 0x1d, 0x97, 0x1c, 0x91, 0x1b, 0x90, 0x00, 0xef, 0x0f, 0x63, 0x4c, 0x89, 0x11, 0x80, 0x59, 0xab, 0x04, 0x80, 0xb4, 0x54, 0x11, 0x80, 0x00, 0xd9, 0x04, 0x80, 0xfd, 0x63, 0x05, 0x62, 0x44, 0xac, 0xc8, 0x72, 0x04, 0x61, 0x80, 0x18, 0x86, 0x32, 0x80, 0xac, 0x03, 0x10, 0x20, 0x18, 0xd6, 0x31, 0x00, 0x65, 0x05, 0x97, 0x00, 0xef, 0x03, 0x63, 0x00, 0x65, 0xfb, 0x63, 0x09, 0x62, 0x08, 0xd0, 0x44, 0x67, 0x80, 0x9c, 0x3f, 0x6b, 0xff, 0x6e, 0x8c, 0xeb, 0x30, 0x73, 0x77, 0x61, 0x62, 0xa2, 0x02, 0x6e, 0x83, 0xa2, 0xe8, 0x43, 0xea, 0x4f, 0xe3, 0xee, 0xa4, 0xa2, 0x5d, 0x61, 0x05, 0x5d, 0x5f, 0x60, 0x04, 0x0e, 0xa4, 0x35, 0xb5, 0xe6, 0xa0, 0x8d, 0xb9, 0xe6, 0x00, 0xee, 0x00, 0x65, 0x00, 0x65, 0x0f, 0x00, 0x79, 0x01, 0x0b, 0x00, 0x4f, 0x00, 0x5b, 0x00, 0x5d, 0xb4, 0x29, 0x10, 0x1e, 0x73, 0x18, 0x61, 0x00, 0x6b, 0xc0, 0xf2, 0x0c, 0x6d, 0xb8, 0xeb, 0x5a, 0xb6, 0x12, 0xed, 0xd5, 0xe5, 0xe0, 0xf0, 0xe3, 0xa5, 0x58, 0xb6, 0x8e, 0xef, 0x04, 0x2f, 0x40, 0xf2, 0x88, 0x45, 0xa0, 0xde, 0x16, 0x10, 0x00, 0x6d, 0xa0, 0xde, 0x01, 0x4b, 0xff, 0x6d, 0xac, 0xeb, 0x0a, 0x5b, 0xea, 0x61, 0x36, 0x10, 0x51, 0xb3, 0x80, 0x9b, 0x33, 0x24, 0x40, 0xf2, 0x08, 0x4c, 0x08, 0x10, 0x0a, 0x6b, 0x78, 0xec, 0x4e, 0xb3, 0x12, 0xec, 0x71, 0xe4, 0x02, 0x10, 0x4d, 0xb4, 0x01, 0x10, 0x27, 0x24, 0x62, 0xa2, 0x1e, 0x73, 0x0a, 0x61, 0x62, 0xa4, 0xc1, 0xa4, 0x60, 0x33, 0x60, 0x33, 0xc0, 0x36, 0x6d, 0xee, 0x60, 0xa4, 0x6d, 0xee, 0x63, 0xa4, 0x0b, 0x10, 0x1f, 0x73, 0x0e, 0x61, 0x66, 0xa4, 0xc5, 0xa4, 0x60, 0x33, 0x60, 0x33, 0xc0, 0x36, 0x6d, 0xee, 0x64, 0xa4, 0x6d, 0xee, 0x67, 0xa4, 0x00, 0xf6, 0x60, 0x33, 0x6d, 0xee, 0x04, 0x6b, 0x0c, 0x10, 0xc9, 0xa4, 0x68, 0xa4, 0xc0, 0x36, 0x6d, 0xee, 0x02, 0x6b, 0x06, 0x10, 0x00, 0x18, 0x67, 0x2f, 0x82, 0x67, 0x60, 0x10, 0x00, 0x6b, 0xc3, 0x67, 0x81, 0xa2, 0x70, 0x33, 0x63, 0xc2, 0x10, 0x6b, 0x6b, 0xeb, 0x8c
+, 0xeb, 0x61, 0xc2, 0xa0, 0x9a, 0x00, 0x18, 0xca, 0x2e, 0x02, 0x6c, 0x52, 0x10, 0x23, 0x73, 0x50, 0x60, 0x11, 0x73, 0x30, 0x61, 0xa1, 0x9a, 0x82, 0x32, 0x42, 0x32, 0xcc, 0xea, 0x1c, 0x22, 0xa2, 0x32, 0xcc, 0xea, 0x34, 0x5a, 0x07, 0x61, 0x1f, 0xf7, 0x01, 0x6a, 0x4b, 0xea, 0x4c, 0xed, 0x06, 0xf2, 0x00, 0x6a, 0x4d, 0xed, 0xa2, 0x32, 0xff, 0x6b, 0x6c, 0xea, 0x14, 0x5a, 0x07, 0x60, 0x1f, 0xf7, 0x01, 0x6a, 0x4b, 0xea, 0x4c, 0xed, 0x02, 0xf4, 0x00, 0x6a, 0x4d, 0xed, 0x00, 0xf6, 0x82, 0x33, 0x21, 0xb2, 0x60, 0xc2, 0x02, 0x10, 0x1f, 0xb3, 0x40, 0xc3, 0x1e, 0xb2, 0x40, 0xa2, 0xff, 0x6b, 0xff, 0x4a, 0x6c, 0xea, 0x0e, 0x5a, 0x24, 0x60, 0x01, 0x6b, 0x1b, 0xb2, 0x00, 0x18, 0xed, 0xf0, 0x60, 0xc2, 0x1e, 0x10, 0x1b, 0x73, 0x00, 0x6a, 0x1c, 0x61, 0x82, 0x34, 0x82, 0x34, 0xcc, 0xec, 0x03, 0x2c, 0x00, 0xf2, 0x00, 0x68, 0x02, 0x10, 0x20, 0xf2, 0x00, 0x68, 0xa0, 0xf1, 0x06, 0x6c, 0x00, 0x18, 0xec, 0x3a, 0xb0, 0x67, 0x01, 0x6a, 0x04, 0xd2, 0x04, 0x6c, 0x10, 0xb2, 0xfa, 0x6d, 0x02, 0xf3, 0x08, 0x6e, 0xa1, 0xf1, 0x14, 0x6f, 0x05, 0xd2, 0x20, 0x18, 0x00, 0x2d, 0x06, 0xd0, 0x01, 0x6a, 0x09, 0x97, 0x08, 0x90, 0x00, 0xef, 0x05, 0x63, 0x09, 0xb4, 0x72, 0x17, 0xbc, 0x4f, 0x11, 0x80, 0xb4, 0x54, 0x11, 0x80, 0x5c, 0x07, 0x11, 0x80, 0x0c, 0x50, 0x11, 0x80, 0xf0, 0x4b, 0x11, 0x80, 0x56, 0x07, 0x11, 0x80, 0xf8, 0x94, 0x11, 0x80, 0x00, 0xd9, 0x04, 0x80, 0x10, 0x4c, 0x11, 0x80, 0xfd, 0x63, 0x05, 0x62, 0xff, 0x6d, 0x00, 0x18, 0x23, 0x8c, 0xcc, 0xed, 0x05, 0x97, 0x00, 0xef, 0x03, 0x63, 0x00, 0x65, 0xfd, 0x63, 0x05, 0x62, 0x1f, 0xb2, 0x20, 0xb3, 0x63, 0xa3, 0x20, 0xb4, 0x40, 0x9a, 0x7e, 0x33, 0x60, 0x33, 0x60, 0x33, 0x8c, 0xea, 0x6d, 0xea, 0x1d, 0xb3, 0xe0, 0xf1, 0x63, 0xa3, 0x01, 0x6c, 0x8c, 0xeb, 0x05, 0x23, 0x1b, 0xb3, 0x6c, 0xea, 0x1b, 0xb3, 0x6d, 0xea, 0x04, 0x10, 0x1b, 0xb3, 0x6d, 0xea, 0x1b, 0xb3, 0x6c, 0xea, 0x13, 0xb3, 0x40, 0xdb, 0x1a, 0xb2, 0x1a, 0xb3, 0x63, 0xda, 0x1a, 0xb3, 0x72, 0xda, 0x1a, 0xb3, 0x75, 0xda, 0x1a, 0xb3, 0x69, 0xda, 0x1a, 0xb3, 0x6c, 0xda, 0x1a, 0xb3, 0x6f, 0xda, 0x1a, 0xb3, 0x66, 0xda, 0x1a, 0xb3, 0x7b, 0xda, 
+0x1a, 0xb3, 0x60, 0xda, 0x1a, 0xb3, 0x80, 0x18, 0x76, 0x28, 0x78, 0xda, 0x19, 0xb3, 0x1a, 0xb2, 0x60, 0xda, 0x1a, 0xb3, 0x1a, 0xb2, 0x80, 0x18, 0x6b, 0x2e, 0x60, 0xda, 0x05, 0x97, 0x00, 0xef, 0x03, 0x63, 0x00, 0x65, 0x74, 0xa0, 0x00, 0xb0, 0x6c, 0x3a, 0x11, 0x80, 0xff, 0xff, 0xfe, 0xff, 0x58, 0x00, 0x11, 0x80, 0xff, 0xff, 0xfb, 0xff, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x04, 0x00, 0xff, 0xff, 0xef, 0xff, 0xc4, 0x88, 0x11, 0x80, 0x91, 0xcb, 0x10, 0x80, 0x9d, 0xd9, 0x10, 0x80, 0x8d, 0xd9, 0x10, 0x80, 0x7d, 0xd9, 0x10, 0x80, 0x6d, 0xd9, 0x10, 0x80, 0x99, 0xd8, 0x10, 0x80, 0x89, 0xd8, 0x10, 0x80, 0xd5, 0xd7, 0x10, 0x80, 0x9d, 0xd7, 0x10, 0x80, 0x7d, 0xd7, 0x10, 0x80, 0xa1, 0xcf, 0x10, 0x80, 0x00, 0x2e, 0x11, 0x80, 0x89, 0xcd, 0x10, 0x80, 0xb4, 0x1d, 0x11, 0x80, 0xfd, 0x63, 0x05, 0x62, 0x04, 0xd0, 0x00, 0x6b, 0x29, 0xb2, 0x80, 0x18, 0x76, 0x28, 0x60, 0xc2, 0x28, 0xb2, 0xc0, 0xf1, 0x1f, 0xa2, 0xff, 0x6c, 0x12, 0x6b, 0xd0, 0x67, 0x8c, 0xee, 0x01, 0x6d, 0xe0, 0xf0, 0x62, 0xc2, 0x78, 0xaa, 0xce, 0x32, 0xac, 0xea, 0x50, 0x37, 0x11, 0x6a, 0x4b, 0xea, 0x6c, 0xea, 0xd2, 0x33, 0xac, 0xeb, 0xed, 0xea, 0x60, 0x33, 0xff, 0xf5, 0x1e, 0x4d, 0x64, 0x33, 0xac, 0xea, 0x6d, 0xea, 0x07, 0x6b, 0x0c, 0xeb, 0x8c, 0xeb, 0x04, 0x53, 0x04, 0x61, 0x07, 0x6b, 0x6b, 0xeb, 0x4c, 0xeb, 0x07, 0x10, 0x03, 0x6c, 0x6c, 0xec, 0x84, 0x33, 0x07, 0x6c, 0x8b, 0xec, 0x4c, 0xec, 0x8d, 0xeb, 0x13, 0xb2, 0x78, 0xca, 0xff, 0x6b, 0x6c, 0xe8, 0x07, 0x6a, 0x0c, 0xea, 0x6c, 0xea, 0x03, 0x22, 0x00, 0x18, 0x79, 0x24, 0x00, 0x6c, 0x1e, 0x30, 0x12, 0x20, 0x00, 0x68, 0x00, 0x18, 0x2f, 0x1c, 0x01, 0x6c, 0x00, 0x18, 0x79, 0x24, 0x01, 0x6c, 0x00, 0x18, 0x2f, 0x1c, 0x01, 0x6c, 0x00, 0x18, 0x79, 0x24, 0x00, 0x6c, 0x01, 0x48, 0xff, 0x6a, 0x4c, 0xe8, 0x04, 0x58, 0xef, 0x61, 0x05, 0x97, 0x04, 0x90, 0x00, 0xef, 0x03, 0x63, 0x00, 0x65, 0x64, 0x94, 0x11, 0x80, 0x58, 0x00, 0x11, 0x80, 0xfb, 0x63, 0x09, 0x62, 0x08, 0xd0, 0x17, 0xb2, 0xc0, 0xf1, 0x1f, 0xa2, 0x07, 0x6a, 0x0c, 0xea, 0x22, 0x22, 0x00, 0x18, 0x79, 0x24, 0x01, 0x6c, 0xff, 0x6a, 0x4c, 0xe8, 0x16, 0x30, 0x03, 0x6a
+, 0x4c, 0xe8, 0x14, 0x6c, 0x00, 0x18, 0x20, 0x25, 0x84, 0xe8, 0x0f, 0xb2, 0x60, 0x9a, 0x24, 0x6a, 0x05, 0x6c, 0x58, 0xeb, 0x0d, 0xb3, 0xfa, 0x6d, 0xa1, 0xf3, 0x16, 0x6e, 0x01, 0xf0, 0x0c, 0x6f, 0x12, 0xea, 0x49, 0xe3, 0x0a, 0xb3, 0x63, 0xda, 0x00, 0x6a, 0x0a, 0xb3, 0x04, 0xd2, 0x05, 0xd3, 0x20, 0x18, 0x00, 0x2d, 0x06, 0xd2, 0x09, 0x97, 0x08, 0x90, 0x00, 0xef, 0x05, 0x63, 0x00, 0x65, 0x58, 0x00, 0x11, 0x80, 0x34, 0x00, 0x11, 0x80, 0x4c, 0x8a, 0x11, 0x80, 0xf9, 0xc9, 0x10, 0x80, 0x00, 0xd9, 0x04, 0x80, 0xfb, 0x63, 0x09, 0x62, 0x08, 0xd1, 0x07, 0xd0, 0x16, 0xb2, 0xc0, 0xf1, 0x7f, 0xa2, 0x07, 0x6a, 0xff, 0xf7, 0x1f, 0x68, 0x6c, 0xea, 0x0a, 0xd4, 0x0b, 0xd5, 0x0d, 0xd7, 0xcc, 0xe8, 0x15, 0x22, 0x11, 0xb1, 0x00, 0x1c, 0x5e, 0x1b, 0x00, 0x65, 0x60, 0xa1, 0x0c, 0x23, 0x00, 0x18, 0x43, 0x35, 0x04, 0xd2, 0x0e, 0xb3, 0x80, 0xa3, 0x1e, 0x6b, 0x04, 0x92, 0x8c, 0xeb, 0x06, 0x6c, 0x8e, 0xeb, 0x01, 0x2b, 0x60, 0xc1, 0x00, 0x1c, 0x65, 0x1b, 0x82, 0x67, 0x0d, 0x97, 0x0a, 0x94, 0x0b, 0x95, 0x00, 0x18, 0x42, 0x20, 0xd0, 0x67, 0x09, 0x97, 0x08, 0x91, 0x07, 0x90, 0x00, 0xef, 0x05, 0x63, 0x58, 0x00, 0x11, 0x80, 0xc2, 0x06, 0x11, 0x80, 0xe0, 0x1e, 0x11, 0x80, 0xfd, 0x63, 0x05, 0x62, 0x04, 0xd0, 0x00, 0x1c, 0x5e, 0x1b, 0x00, 0x65, 0x02, 0x67, 0x0f, 0xb2, 0x60, 0x9a, 0x0f, 0xb2, 0x00, 0x6c, 0x6e, 0xea, 0x02, 0x2a, 0x0e, 0xb2, 0x80, 0x9a, 0x0e, 0xb3, 0x82, 0x34, 0x82, 0x34, 0x40, 0x9b, 0xff, 0xf7, 0x1f, 0x6d, 0x80, 0x34, 0xac, 0xea, 0x80, 0x34, 0x8d, 0xea, 0x40, 0xdb, 0x00, 0x18, 0x2c, 0x26, 0x00, 0x6c, 0x00, 0x1c, 0x65, 0x1b, 0x90, 0x67, 0x05, 0x97, 0x04, 0x90, 0x00, 0xef, 0x03, 0x63, 0x58, 0x8b, 0x10, 0x80, 0x32, 0x97, 0x79, 0x23, 0x5c, 0x8b, 0x10, 0x80, 0x30, 0x00, 0x00, 0xb5, 0xfb, 0x63, 0x09, 0x62, 0x08, 0xd1, 0x07, 0xd0, 0x18, 0xb2, 0x19, 0xb3, 0x63, 0xea, 0x26, 0x61, 0x18, 0xb2, 0x80, 0x9a, 0x18, 0xb3, 0x8e, 0xeb, 0x21, 0x2b, 0x02, 0xaa, 0x17, 0xb5, 0x1d, 0x10, 0x17, 0xb4, 0x42, 0x45, 0x43, 0xec, 0x1a, 0x61, 0xc0, 0xa2, 0xff, 0xf7, 0x1f, 0x6f, 0x43, 0x46, 0x43, 0xe8, 0x14, 0x61, 0x45, 0xe5, 0x23, 0xec, 0x11, 0x61, 0x81, 
+0xa5, 0x60, 0xa5, 0x80, 0x34, 0x6d, 0xec, 0xec, 0xec, 0xe0, 0xf3, 0x14, 0x5c, 0x09, 0x60, 0x43, 0xe0, 0x0d, 0xb2, 0x03, 0x4d, 0x91, 0xe2, 0x00, 0x18, 0x27, 0x33, 0xec, 0xe8, 0xb1, 0x67, 0xe2, 0x28, 0x09, 0x97, 0x08, 0x91, 0x07, 0x90, 0x00, 0xef, 0x05, 0x63, 0x00, 0x65, 0xf0, 0xff, 0x10, 0x80, 0x94, 0xde, 0x10, 0x80, 0x98, 0xde, 0x10, 0x80, 0x55, 0xab, 0x23, 0x87, 0x9e, 0xde, 0x10, 0x80, 0xff, 0xff, 0x10, 0x80, 0x58, 0x00, 0x11, 0x80, 0xfd, 0x63, 0x05, 0x62, 0x04, 0x6c, 0x00, 0x18, 0x46, 0xa4, 0x00, 0x6d, 0x20, 0x6b, 0x4d, 0xeb, 0xff, 0xf7, 0x1f, 0x6e, 0x6c, 0xee, 0x00, 0x6d, 0x00, 0x18, 0xa4, 0xa4, 0x04, 0x6c, 0x00, 0x18, 0x2a, 0x1c, 0x50, 0x6c, 0x04, 0x6c, 0x00, 0x18, 0x46, 0xa4, 0x00, 0x6d, 0x05, 0x97, 0x1f, 0x6b, 0x6c, 0xea, 0x00, 0xef, 0x03, 0x63, 0x00, 0x65, 0xfc, 0x63, 0x07, 0x62, 0x06, 0xd1, 0x05, 0xd0, 0x4e, 0xb2, 0x20, 0xf0, 0x6a, 0xa2, 0x03, 0x23, 0x20, 0xf0, 0x4b, 0xa2, 0x26, 0x10, 0x64, 0xa2, 0x41, 0x6a, 0x6c, 0xea, 0x41, 0x72, 0x0f, 0x61, 0x00, 0x6c, 0x00, 0x18, 0x46, 0xa4, 0xa4, 0x67, 0xff, 0xf7, 0x1f, 0x6b, 0x4c, 0xeb, 0x62, 0x33, 0x72, 0x33, 0x00, 0x6a, 0x16, 0x23, 0x80, 0x18, 0x3a, 0x34, 0x00, 0x65, 0x12, 0x10, 0xa0, 0xf1, 0x1a, 0x6c, 0x10, 0xf0, 0x0f, 0x6d, 0x00, 0x18, 0xec, 0x3a, 0x00, 0x65, 0x3e, 0xb2, 0x60, 0xaa, 0xff, 0xf7, 0x1f, 0x6a, 0x6c, 0xea, 0x42, 0x32, 0x3f, 0x6b, 0x6c, 0xea, 0x46, 0x32, 0xff, 0x6b, 0x6c, 0xea, 0x3a, 0xb3, 0x80, 0xf1, 0x81, 0xa3, 0x66, 0x22, 0x39, 0xb5, 0x60, 0xf1, 0xb2, 0xa5, 0x62, 0x2d, 0x80, 0xf1, 0xa0, 0xa3, 0x5f, 0x25, 0x80, 0xf1, 0xa3, 0xa3, 0x03, 0x2d, 0x01, 0x6d, 0x80, 0xf1, 0xa3, 0xc3, 0x33, 0xb3, 0x00, 0x83, 0x30, 0xb3, 0x80, 0xf1, 0x63, 0xa3, 0x8b, 0xe2, 0x00, 0xf6, 0x40, 0x32, 0x00, 0xf6, 0x43, 0x32, 0x7a, 0xea, 0x01, 0x2b, 0xe5, 0xe8, 0x00, 0x18, 0xb8, 0xa4, 0x12, 0xec, 0x27, 0xb2, 0x20, 0xf0, 0x6a, 0xa2, 0x05, 0x2b, 0x64, 0xa2, 0x41, 0x6a, 0x6c, 0xea, 0x41, 0x72, 0x40, 0x61, 0x27, 0xb2, 0x40, 0x82, 0x4e, 0xe8, 0x3c, 0x20, 0x26, 0xb2, 0x60, 0xa2, 0x07, 0x5b, 0x02, 0x61, 0x06, 0x6b, 0x60, 0xc2, 0x23, 0xb2, 0xa0, 0xa2, 0x1d, 0xb2, 0x63, 0xa2, 0x07
+, 0x6c, 0x72, 0x36, 0x8c, 0xee, 0xc2, 0xed, 0x06, 0x60, 0x8c, 0xed, 0x88, 0x4c, 0xb0, 0x35, 0x6c, 0xec, 0xad, 0xec, 0x83, 0xc2, 0x16, 0xb2, 0x43, 0xa2, 0x07, 0x6b, 0x02, 0x6c, 0x52, 0x32, 0x6c, 0xea, 0x61, 0x42, 0x8b, 0xec, 0x8c, 0xeb, 0x18, 0xb4, 0x20, 0xf1, 0x16, 0x4b, 0xff, 0xf7, 0x1f, 0x68, 0x8d, 0xe3, 0x20, 0xab, 0x01, 0x6b, 0x4c, 0xeb, 0x6c, 0x33, 0x02, 0x6c, 0x00, 0x6d, 0x0c, 0xe9, 0x00, 0x18, 0x46, 0xa4, 0x27, 0xeb, 0x1f, 0xf7, 0x01, 0x6b, 0x0c, 0xea, 0x6b, 0xeb, 0x0c, 0xe9, 0x6c, 0xea, 0x20, 0x31, 0x0c, 0xe9, 0xc2, 0x67, 0x02, 0x6c, 0x00, 0x6d, 0x00, 0x18, 0xa4, 0xa4, 0x2d, 0xee, 0x07, 0x97, 0x06, 0x91, 0x05, 0x90, 0x00, 0xef, 0x04, 0x63, 0x28, 0x94, 0x11, 0x80, 0xba, 0x01, 0x00, 0xb6, 0x58, 0x00, 0x11, 0x80, 0xc0, 0x50, 0x11, 0x80, 0x00, 0x1b, 0x11, 0x80, 0x7c, 0x04, 0x11, 0x80, 0x00, 0x00, 0x00, 0xb6, 0xfc, 0x63, 0x07, 0x62, 0x06, 0xd1, 0x05, 0xd0, 0x00, 0x68, 0x24, 0x67, 0x04, 0x32, 0x49, 0xe1, 0x60, 0xaa, 0xff, 0xf7, 0x1f, 0x73, 0x29, 0x60, 0x1e, 0xf0, 0x00, 0x6a, 0x6c, 0xea, 0x0c, 0xf0, 0x00, 0x72, 0x07, 0x61, 0x41, 0x40, 0x44, 0x32, 0x49, 0xe1, 0x00, 0x18, 0x2a, 0x1c, 0x80, 0xaa, 0x18, 0x10, 0x04, 0xf0, 0x00, 0x72, 0x0b, 0x61, 0xff, 0x6c, 0x8c, 0xeb, 0x40, 0x6a, 0x67, 0x33, 0x4d, 0xeb, 0x41, 0x40, 0x44, 0x32, 0x49, 0xe1, 0x6c, 0xec, 0x01, 0x6d, 0x07, 0x10, 0x0d, 0x2a, 0x41, 0x40, 0x44, 0x32, 0xff, 0x6c, 0x49, 0xe1, 0x6c, 0xec, 0x00, 0x6d, 0x00, 0x18, 0xa4, 0xa4, 0xc0, 0xaa, 0x02, 0x48, 0xff, 0x6a, 0x4c, 0xe8, 0xd1, 0x17, 0x07, 0x97, 0x06, 0x91, 0x05, 0x90, 0x00, 0xef, 0x04, 0x63, 0xf9, 0x63, 0x0d, 0x62, 0x0c, 0xd1, 0x0b, 0xd0, 0xff, 0x68, 0x00, 0x6e, 0x8c, 0xe8, 0x01, 0x6d, 0x00, 0x18, 0xa4, 0xa4, 0x40, 0x6c, 0x5a, 0x6c, 0x00, 0x18, 0x46, 0xa4, 0x01, 0x6d, 0x5c, 0x6c, 0x01, 0x6d, 0x00, 0x18, 0x46, 0xa4, 0x22, 0x67, 0xff, 0xf7, 0x1f, 0x6b, 0x6c, 0xe9, 0xff, 0xf7, 0x1e, 0x6e, 0x6c, 0xea, 0x5a, 0x6c, 0x01, 0x6d, 0x2c, 0xee, 0x08, 0xd2, 0x00, 0x18, 0xa4, 0xa4, 0x09, 0xd3, 0x08, 0x92, 0x09, 0x93, 0x03, 0x6e, 0x4d, 0xee, 0x5c, 0x6c, 0x01, 0x6d, 0x00, 0x18, 0xa4, 0xa4, 0x6c, 0xee, 0x42, 0xb4, 
+0x80, 0x18, 0x9f, 0x34, 0x00, 0x65, 0x06, 0x20, 0x90, 0x67, 0x00, 0x18, 0x2f, 0x1c, 0x00, 0x68, 0x70, 0x67, 0x24, 0x10, 0x01, 0x6d, 0xc5, 0x67, 0x00, 0x18, 0xa4, 0xa4, 0x40, 0x6c, 0x41, 0x6c, 0x38, 0xf0, 0x03, 0x6e, 0x00, 0x18, 0xa4, 0xa4, 0x01, 0x6d, 0x00, 0x18, 0x2a, 0x1c, 0x0a, 0x6c, 0x00, 0x68, 0x7e, 0x6c, 0x00, 0x18, 0x46, 0xa4, 0x01, 0x6d, 0x00, 0xf2, 0x00, 0x6b, 0x4c, 0xeb, 0x02, 0x23, 0x00, 0x6b, 0x0b, 0x10, 0x00, 0x18, 0x2f, 0x1c, 0x0a, 0x6c, 0x01, 0x48, 0xff, 0xf7, 0x1f, 0x6a, 0x4c, 0xe8, 0xe0, 0xf3, 0x08, 0x58, 0xec, 0x61, 0x01, 0x6b, 0x2c, 0xb4, 0x80, 0x18, 0x9f, 0x34, 0x09, 0xd3, 0x5a, 0x6c, 0x01, 0x6d, 0x00, 0x18, 0xa4, 0xa4, 0xd1, 0x67, 0x08, 0x96, 0x5c, 0x6c, 0x00, 0x18, 0xa4, 0xa4, 0x01, 0x6d, 0x01, 0x6d, 0xc5, 0x67, 0x00, 0x18, 0xa4, 0xa4, 0x40, 0x6c, 0x7e, 0x6c, 0x00, 0x18, 0x46, 0xa4, 0x01, 0x6d, 0x40, 0x6c, 0x01, 0x6d, 0x00, 0x6e, 0x00, 0x18, 0xa4, 0xa4, 0x08, 0xd2, 0x09, 0x93, 0x09, 0x23, 0x21, 0x6c, 0x08, 0xf2, 0x00, 0x6e, 0x00, 0x18, 0xa4, 0xa4, 0x00, 0x6d, 0xff, 0xf7, 0x1f, 0x69, 0x07, 0x10, 0x21, 0x6c, 0x00, 0x18, 0x46, 0xa4, 0x00, 0x6d, 0xff, 0xf7, 0x1f, 0x69, 0x4c, 0xe9, 0x15, 0xb3, 0x01, 0x6a, 0x04, 0x6c, 0xfa, 0x6d, 0xa1, 0xf1, 0x16, 0x6e, 0xc4, 0xf3, 0x15, 0x6f, 0x05, 0xd3, 0x06, 0xd0, 0x09, 0xd3, 0x20, 0x18, 0x00, 0x2d, 0x04, 0xd2, 0x09, 0x93, 0x02, 0x6a, 0x04, 0xd2, 0x05, 0xd3, 0x08, 0x93, 0xff, 0xf7, 0x1f, 0x6a, 0x05, 0x6c, 0x6c, 0xea, 0xfa, 0x6d, 0xa1, 0xf1, 0x17, 0x6e, 0x44, 0xf5, 0x18, 0x6f, 0x06, 0xd1, 0x20, 0x18, 0x00, 0x2d, 0x07, 0xd2, 0x51, 0x67, 0x0d, 0x97, 0x0c, 0x91, 0x0b, 0x90, 0x00, 0xef, 0x07, 0x63, 0xd4, 0xdd, 0x10, 0x80, 0x68, 0xde, 0x10, 0x80, 0x00, 0xd9, 0x04, 0x80, 0xf5, 0x63, 0x15, 0x62, 0x14, 0xd1, 0x13, 0xd0, 0x02, 0x6c, 0x00, 0x18, 0x46, 0xa4, 0x00, 0x6d, 0x3f, 0x6c, 0x00, 0x6d, 0x00, 0x18, 0x46, 0xa4, 0x11, 0xd2, 0x11, 0x93, 0xff, 0x69, 0x2c, 0xea, 0xff, 0xf7, 0x1f, 0x68, 0x0c, 0xd2, 0x0c, 0xeb, 0x0c, 0x95, 0x62, 0x33, 0x2c, 0xeb, 0x01, 0x6a, 0xc3, 0x67, 0x82, 0x67, 0xe2, 0x67, 0x11, 0xd3, 0x80, 0x18, 0xbc, 0x34, 0x04, 0xd2, 0x11, 0x93, 0x0c, 0x95
+, 0x03, 0x6a, 0xc3, 0x67, 0x00, 0x6c, 0x0f, 0x6f, 0x80, 0x18, 0xbc, 0x34, 0x04, 0xd2, 0x42, 0x34, 0x1f, 0x6d, 0x11, 0x93, 0x8a, 0x34, 0x56, 0x32, 0xac, 0xec, 0xac, 0xea, 0x0c, 0x95, 0x03, 0x6e, 0x0b, 0xd4, 0x04, 0xd6, 0x00, 0x6c, 0xc3, 0x67, 0x0f, 0x6f, 0x80, 0x18, 0xbc, 0x34, 0x0a, 0xd2, 0x42, 0x37, 0x0b, 0x96, 0x1f, 0x6c, 0xea, 0x37, 0x56, 0x35, 0x8c, 0xef, 0x8c, 0xed, 0x08, 0xd5, 0x2c, 0xee, 0x09, 0xd7, 0x2c, 0xef, 0xf7, 0xe6, 0x0e, 0xd7, 0x08, 0x94, 0x0a, 0x97, 0xa0, 0x35, 0x2c, 0xec, 0x2c, 0xef, 0x10, 0xd4, 0x93, 0xe7, 0x80, 0x34, 0x80, 0x34, 0x83, 0x34, 0x83, 0x34, 0x98, 0xec, 0xa0, 0x35, 0xa3, 0x35, 0xa3, 0x35, 0x0d, 0xd6, 0x0f, 0xd7, 0x11, 0x93, 0x12, 0xec, 0xb8, 0xed, 0x12, 0xed, 0xb1, 0xe4, 0x0c, 0xec, 0x11, 0x5c, 0x0a, 0x60, 0x0b, 0x95, 0x09, 0x93, 0x08, 0x96, 0x0a, 0x97, 0xb1, 0xe3, 0x87, 0x34, 0xf5, 0xe6, 0x0c, 0xec, 0xa7, 0x35, 0x57, 0x10, 0x0c, 0x95, 0xc3, 0x67, 0x03, 0x6a, 0x00, 0x6c, 0x0f, 0x6f, 0x80, 0x18, 0xbc, 0x34, 0x04, 0xd2, 0x42, 0x34, 0x1f, 0x6b, 0x8a, 0x34, 0x6c, 0xec, 0x0d, 0x96, 0xe4, 0x67, 0x2c, 0xef, 0x1f, 0x6d, 0x56, 0x33, 0xac, 0xeb, 0xf7, 0xe6, 0xa0, 0x35, 0xa0, 0x35, 0xa3, 0x35, 0xa3, 0x35, 0x0d, 0x65, 0x0f, 0x95, 0x6c, 0xe9, 0x3b, 0xe5, 0xc0, 0x36, 0xc0, 0x36, 0xc3, 0x36, 0xc3, 0x36, 0xd8, 0xee, 0xa8, 0x67, 0x12, 0xee, 0xb8, 0xed, 0x12, 0xed, 0xb9, 0xe6, 0x0e, 0x95, 0x0c, 0xee, 0x11, 0x5e, 0xff, 0xe5, 0x10, 0x95, 0xe0, 0x37, 0xe0, 0x37, 0x27, 0xe5, 0x20, 0x35, 0xa0, 0x35, 0xa3, 0x35, 0xa3, 0x35, 0xb8, 0xed, 0xe3, 0x37, 0xe3, 0x37, 0x12, 0xed, 0xf8, 0xef, 0x12, 0xef, 0xf5, 0xe5, 0x0c, 0xed, 0x10, 0x60, 0xc3, 0xed, 0x07, 0x60, 0x09, 0x95, 0x08, 0x96, 0xb1, 0xe4, 0x87, 0x34, 0x0c, 0xec, 0xcd, 0xe3, 0x13, 0x10, 0x0b, 0x97, 0x0a, 0x95, 0xf1, 0xe4, 0x87, 0x34, 0x0c, 0xec, 0xad, 0xe3, 0x0c, 0x10, 0x11, 0x5d, 0x04, 0x61, 0x00, 0x6c, 0x11, 0x69, 0x10, 0x6b, 0x0f, 0x10, 0x09, 0x96, 0x08, 0x97, 0xd1, 0xe4, 0x87, 0x34, 0x0c, 0xec, 0xed, 0xe3, 0x67, 0x35, 0x0c, 0xed, 0xff, 0xf7, 0x1f, 0x6b, 0xff, 0xf7, 0x1f, 0x69, 0x8c, 0xeb, 0xac, 0xe9, 0x01, 0x6c, 0x1f, 0x68, 0x4c, 0xe8, 0x08, 
+0x24, 0x10, 0xf0, 0x00, 0x6a, 0x4b, 0xea, 0x4d, 0xe8, 0xff, 0xf7, 0x1f, 0x6a, 0x4c, 0xe8, 0x11, 0x10, 0x01, 0x6d, 0xc5, 0x67, 0x00, 0x6c, 0x00, 0x18, 0xa4, 0xa4, 0x11, 0xd3, 0x46, 0x6c, 0x01, 0x6d, 0x00, 0x18, 0xa4, 0xa4, 0x00, 0x6e, 0x00, 0x6c, 0x01, 0x6d, 0x00, 0x18, 0xa4, 0xa4, 0xc4, 0x67, 0x11, 0x93, 0x60, 0x33, 0x68, 0x33, 0x34, 0x31, 0x6d, 0xe9, 0x0d, 0xe9, 0x20, 0x36, 0xc0, 0x36, 0xc3, 0x36, 0xff, 0xf7, 0x1f, 0x6a, 0xc3, 0x36, 0x4c, 0xee, 0x21, 0x6c, 0x00, 0x18, 0xa4, 0xa4, 0x00, 0x6d, 0x0e, 0x6c, 0x00, 0x18, 0x46, 0xa4, 0x00, 0x6d, 0x21, 0x6c, 0x00, 0x6d, 0x00, 0x18, 0x46, 0xa4, 0x02, 0x67, 0x02, 0x6b, 0x04, 0xd3, 0x01, 0x6c, 0x08, 0xb3, 0xfa, 0x6d, 0x01, 0xf2, 0x16, 0x6e, 0xa4, 0xf3, 0x0d, 0x6f, 0x06, 0xd0, 0x05, 0xd3, 0x20, 0x18, 0x00, 0x2d, 0x07, 0xd2, 0x15, 0x97, 0x14, 0x91, 0x13, 0x90, 0x00, 0xef, 0x0b, 0x63, 0x00, 0xd9, 0x04, 0x80, 0xfd, 0x63, 0x05, 0x62, 0x1d, 0xb4, 0x00, 0x6d, 0x00, 0x18, 0x37, 0xa6, 0x5e, 0x6e, 0x1c, 0xb4, 0x00, 0x6d, 0x00, 0x18, 0x37, 0xa6, 0x5c, 0x6e, 0x80, 0x18, 0xde, 0x31, 0x00, 0x65, 0x00, 0x18, 0x0c, 0xa5, 0x00, 0x65, 0x00, 0x18, 0xed, 0xa4, 0x00, 0x65, 0x00, 0x18, 0x27, 0xa3, 0x00, 0x65, 0x00, 0x18, 0x31, 0xa3, 0x00, 0x65, 0x13, 0xb2, 0x40, 0x9a, 0x61, 0x42, 0x07, 0x23, 0x24, 0x6b, 0x78, 0xea, 0x11, 0xb3, 0x12, 0xea, 0x49, 0xe3, 0x10, 0xb3, 0x63, 0xda, 0x80, 0x18, 0x16, 0x35, 0x00, 0x65, 0x00, 0x6c, 0x01, 0x6d, 0x00, 0x18, 0xa4, 0xa4, 0x02, 0x6e, 0x57, 0x6c, 0x01, 0x6d, 0x00, 0x18, 0xa4, 0xa4, 0x10, 0x6e, 0x00, 0x6c, 0x01, 0x6d, 0x00, 0x18, 0xa4, 0xa4, 0xc4, 0x67, 0x05, 0x97, 0x00, 0xef, 0x03, 0x63, 0x00, 0x65, 0x4c, 0x02, 0x11, 0x80, 0x88, 0xdc, 0x10, 0x80, 0x90, 0x04, 0x11, 0x80, 0x4c, 0x8a, 0x11, 0x80, 0x21, 0xd1, 0x10, 0x80, 0xfb, 0x63, 0x09, 0x62, 0x08, 0xd1, 0x07, 0xd0, 0x04, 0x67, 0x00, 0x1c, 0x5e, 0x1b, 0x04, 0xd5, 0x14, 0xb4, 0x22, 0x67, 0x40, 0x9c, 0x04, 0x95, 0x01, 0x4a, 0x19, 0x22, 0xff, 0x6a, 0xac, 0xea, 0x01, 0x72, 0x04, 0x60, 0x20, 0x18, 0x9f, 0x2b, 0x90, 0x67, 0x11, 0x10, 0x00, 0x18, 0xb6, 0x1c, 0x00, 0x65, 0x01, 0x6b, 0x6b, 0xeb, 0x0c, 0xb2, 0x60
+, 0xc2, 0x0c, 0xb2, 0x01, 0x6b, 0x40, 0x9a, 0x6c, 0xea, 0x05, 0x2a, 0x0a, 0xb3, 0x0b, 0xb4, 0x40, 0x9b, 0x8d, 0xea, 0x40, 0xdb, 0x00, 0x1c, 0x65, 0x1b, 0x91, 0x67, 0x09, 0x97, 0x08, 0x91, 0x07, 0x90, 0x00, 0xef, 0x05, 0x63, 0x00, 0x65, 0x0c, 0x06, 0x11, 0x80, 0x10, 0x06, 0x11, 0x80, 0x50, 0x60, 0x00, 0xb0, 0x40, 0xa0, 0x00, 0xb0, 0x00, 0x00, 0x80, 0x00, 0xfd, 0x63, 0x05, 0x62, 0x44, 0xac, 0xe0, 0xf3, 0x0a, 0x72, 0x04, 0x61, 0x00, 0x18, 0x31, 0xeb, 0x00, 0x65, 0x03, 0x10, 0x00, 0x18, 0xc4, 0xf1, 0x00, 0x65, 0x05, 0x97, 0x00, 0xef, 0x03, 0x63, 0xfd, 0x63, 0x05, 0x62, 0x00, 0x18, 0xa5, 0x39, 0x00, 0x65, 0x09, 0xb2, 0x40, 0x9a, 0x61, 0x42, 0x07, 0x23, 0x24, 0x6b, 0x78, 0xea, 0x07, 0xb3, 0x12, 0xea, 0x49, 0xe3, 0x06, 0xb3, 0x63, 0xda, 0x80, 0x18, 0x30, 0x30, 0x00, 0x65, 0x05, 0x97, 0x00, 0xef, 0x03, 0x63, 0x90, 0x04, 0x11, 0x80, 0x4c, 0x8a, 0x11, 0x80, 0x21, 0xd1, 0x10, 0x80, 0xf9, 0x63, 0x0d, 0x62, 0x0c, 0xd1, 0x0b, 0xd0, 0x44, 0xac, 0x04, 0x67, 0x20, 0x9c, 0x01, 0x72, 0x1e, 0x61, 0x02, 0x6a, 0x04, 0xd2, 0x21, 0xb2, 0x05, 0xd2, 0x06, 0xd1, 0x41, 0x9c, 0xfa, 0x6d, 0x04, 0x6c, 0xc0, 0xf5, 0x03, 0x6e, 0x41, 0xf5, 0x0e, 0x6f, 0x20, 0x18, 0x00, 0x2d, 0x07, 0xd2, 0x3f, 0x6a, 0x2c, 0xea, 0x30, 0x72, 0x28, 0x61, 0x41, 0xa8, 0xff, 0x6b, 0x6c, 0xea, 0x24, 0x2a, 0x17, 0xb3, 0x40, 0xdb, 0x17, 0xb3, 0x40, 0xdb, 0x17, 0xb3, 0x40, 0xdb, 0x1d, 0x10, 0x17, 0xb2, 0x60, 0xa2, 0x1a, 0x2b, 0x02, 0x6a, 0x04, 0xd2, 0x10, 0xb2, 0x05, 0xd2, 0x06, 0xd1, 0x41, 0x9c, 0xfa, 0x6d, 0x05, 0x6c, 0xe0, 0xf5, 0x0d, 0x6e, 0x41, 0xf5, 0x0f, 0x6f, 0x08, 0xd3, 0x20, 0x18, 0x00, 0x2d, 0x07, 0xd2, 0x0e, 0xb2, 0x40, 0xa2, 0x08, 0x93, 0x06, 0x22, 0x40, 0xa0, 0x30, 0x72, 0x03, 0x60, 0x0c, 0xb2, 0x60, 0xda, 0x03, 0x10, 0x00, 0x18, 0x2f, 0x31, 0x90, 0x67, 0x0d, 0x97, 0x0c, 0x91, 0x0b, 0x90, 0x00, 0xef, 0x07, 0x63, 0x00, 0xd9, 0x04, 0x80, 0x4c, 0x8b, 0x10, 0x80, 0x54, 0x8b, 0x10, 0x80, 0x60, 0x8b, 0x10, 0x80, 0x57, 0x07, 0x11, 0x80, 0x60, 0x94, 0x11, 0x80, 0x58, 0x07, 0x11, 0x80, 0xfd, 0x63, 0x05, 0x62, 0x00, 0x18, 0x44, 0xb8, 0x00, 0x65, 0x05, 0x97, 
+0x00, 0xef, 0x03, 0x63, 0xf7, 0x63, 0x11, 0x62, 0x10, 0xd0, 0x00, 0x18, 0xc1, 0xb8, 0x04, 0x67, 0x44, 0xa8, 0x20, 0xf3, 0x01, 0x72, 0x4b, 0x61, 0x28, 0xb2, 0x60, 0xf1, 0x50, 0xa2, 0x03, 0x72, 0x46, 0x61, 0x27, 0xb2, 0x40, 0xaa, 0x01, 0x72, 0x13, 0x61, 0x26, 0xb2, 0x40, 0xa2, 0x01, 0x72, 0x0f, 0x61, 0x25, 0xb2, 0x60, 0xaa, 0xff, 0xf7, 0x1f, 0x6a, 0x6c, 0xea, 0xff, 0x6b, 0x01, 0x4b, 0x4c, 0xeb, 0x06, 0x23, 0xff, 0xf6, 0x1f, 0x6d, 0xac, 0x6c, 0x00, 0x18, 0xec, 0x3a, 0x4c, 0xed, 0x1e, 0xb2, 0x40, 0xa2, 0x01, 0x72, 0x2b, 0x61, 0x1d, 0xb2, 0x40, 0xa2, 0x28, 0x2a, 0x09, 0x6a, 0x04, 0xd2, 0x1c, 0xb2, 0x05, 0xd2, 0x1c, 0xb2, 0x80, 0xf2, 0x7e, 0xa2, 0x01, 0x6c, 0xfa, 0x6d, 0x06, 0xd3, 0x80, 0xf2, 0x7f, 0xa2, 0xa0, 0xf5, 0x08, 0x6e, 0xc1, 0xf3, 0x19, 0x6f, 0x07, 0xd3, 0xa0, 0xf2, 0x60, 0xa2, 0x08, 0xd3, 0xa0, 0xf2, 0x61, 0xa2, 0x09, 0xd3, 0xa0, 0xf2, 0x62, 0xa2, 0x0a, 0xd3, 0xa0, 0xf2, 0x63, 0xa2, 0x0b, 0xd3, 0xa0, 0xf2, 0x68, 0xa2, 0x0c, 0xd3, 0xa0, 0xf2, 0x66, 0xaa, 0x0d, 0xd3, 0xa0, 0xf2, 0x44, 0xaa, 0x20, 0x18, 0x00, 0x2d, 0x0e, 0xd2, 0x11, 0x97, 0x10, 0x90, 0x00, 0xef, 0x09, 0x63, 0x00, 0x65, 0xc0, 0x50, 0x11, 0x80, 0x28, 0x1a, 0x11, 0x80, 0x23, 0x1a, 0x11, 0x80, 0xac, 0x00, 0x00, 0xb6, 0x84, 0x38, 0x11, 0x80, 0x68, 0x3a, 0x11, 0x80, 0x00, 0xd9, 0x04, 0x80, 0xb4, 0x54, 0x11, 0x80, 0xfd, 0x63, 0x05, 0x62, 0x00, 0x18, 0x6e, 0x5c, 0x00, 0x65, 0x05, 0x97, 0x00, 0xef, 0x03, 0x63, 0xfd, 0x63, 0x05, 0x62, 0x00, 0x18, 0x7b, 0x8d, 0x00, 0x65, 0x05, 0x97, 0x00, 0xef, 0x03, 0x63, 0xfd, 0x63, 0x05, 0x62, 0x00, 0x18, 0xef, 0x5c, 0x00, 0x65, 0x05, 0x97, 0x00, 0xef, 0x03, 0x63, 0xef, 0x63, 0x21, 0x62, 0x20, 0xd1, 0x1f, 0xd0, 0x44, 0xac, 0x24, 0x67, 0x60, 0xf2, 0x04, 0x72, 0x18, 0x61, 0xa3, 0xb2, 0x60, 0xf1, 0x52, 0xa2, 0xa0, 0xf0, 0x0b, 0x22, 0x00, 0x1c, 0x5e, 0x1b, 0x00, 0x65, 0x00, 0x18, 0x78, 0x58, 0x02, 0x67, 0x80, 0x18, 0x02, 0x29, 0x03, 0x6c, 0x00, 0x18, 0x11, 0x56, 0x00, 0x6c, 0x20, 0x18, 0x5d, 0x22, 0x00, 0x65, 0x00, 0x1c, 0x65, 0x1b, 0x90, 0x67, 0x28, 0x11, 0x60, 0xf4, 0x1f, 0x72, 0x80, 0xf0, 0x14, 0x61, 0x95, 0xb2
+, 0x41, 0x9a, 0xfe, 0x4a, 0x02, 0x5a, 0x80, 0xf0, 0x0e, 0x60, 0x40, 0x9c, 0x17, 0x05, 0x84, 0x42, 0x20, 0x18, 0x48, 0x21, 0x1c, 0xd2, 0x90, 0xb3, 0x80, 0xa3, 0x1c, 0x92, 0x8f, 0xb3, 0x07, 0x2c, 0x60, 0xa3, 0x02, 0x2b, 0x8e, 0xb4, 0x60, 0xc4, 0x01, 0x4b, 0x8c, 0xb4, 0x03, 0x10, 0x60, 0xa3, 0x02, 0x2b, 0x8b, 0xb4, 0x60, 0xc4, 0x00, 0x6c, 0x3f, 0x10, 0x8a, 0xb3, 0x84, 0x35, 0xb5, 0xe3, 0xfd, 0x67, 0xc0, 0xad, 0x40, 0xf0, 0xbc, 0xaf, 0xce, 0xed, 0x33, 0x2d, 0xa7, 0x44, 0x11, 0x4d, 0xa4, 0x35, 0xb5, 0xe3, 0xc0, 0xad, 0x40, 0xf0, 0xbe, 0xaf, 0xce, 0xed, 0x2a, 0x2d, 0xa7, 0x44, 0x29, 0x4d, 0xa4, 0x35, 0xad, 0xe3, 0xa0, 0xab, 0x60, 0xf0, 0x60, 0xaf, 0xae, 0xeb, 0x21, 0x2b, 0x7d, 0xb4, 0x80, 0x9c, 0xa2, 0x67, 0x00, 0x18, 0xd3, 0x1c, 0x1c, 0xd3, 0x05, 0x6a, 0x04, 0xd2, 0x7a, 0xb2, 0x05, 0xd2, 0x40, 0xa0, 0x1c, 0x93, 0x02, 0x6c, 0x06, 0xd2, 0x07, 0xd3, 0x7d, 0x67, 0x60, 0xf0, 0x40, 0xab, 0xfa, 0x6d, 0xc0, 0xf3, 0x0e, 0x6e, 0x08, 0xd2, 0x40, 0xf0, 0x5e, 0xab, 0x61, 0xf6, 0x1e, 0x6f, 0x09, 0xd2, 0x40, 0xf0, 0x5c, 0xab, 0x20, 0x18, 0x00, 0x2d, 0x0a, 0xd2, 0xca, 0x10, 0x01, 0x4c, 0xff, 0x6b, 0x6c, 0xec, 0x69, 0xb0, 0x60, 0xa0, 0x63, 0xec, 0xbd, 0x61, 0x18, 0x5c, 0x16, 0x60, 0xfd, 0x67, 0x40, 0xf0, 0xdc, 0xaf, 0x66, 0xb2, 0x84, 0x35, 0xb5, 0xe2, 0xc0, 0xcd, 0xa7, 0x44, 0x11, 0x4d, 0x30, 0x4c, 0x84, 0x34, 0xa4, 0x35, 0xb5, 0xe2, 0x40, 0xf0, 0xde, 0xaf, 0x89, 0xe2, 0x60, 0xf0, 0x80, 0xaf, 0x01, 0x4b, 0xc0, 0xcd, 0x60, 0xc0, 0x80, 0xca, 0x05, 0x6a, 0x04, 0xd2, 0x5d, 0xb2, 0x05, 0xd2, 0x59, 0xb2, 0x40, 0xa2, 0x7d, 0x67, 0x01, 0x6c, 0x06, 0xd2, 0x01, 0x6a, 0x07, 0xd2, 0x60, 0xf0, 0x40, 0xab, 0xfa, 0x6d, 0xc0, 0xf3, 0x1f, 0x6e, 0x08, 0xd2, 0x40, 0xf0, 0x5e, 0xab, 0x61, 0xf6, 0x1e, 0x6f, 0x09, 0xd2, 0x40, 0xf0, 0x5c, 0xab, 0x20, 0x18, 0x00, 0x2d, 0x0a, 0xd2, 0x44, 0xa9, 0x80, 0xf4, 0x00, 0x72, 0x80, 0xf0, 0x08, 0x61, 0x00, 0x99, 0x64, 0xa0, 0x8b, 0xa8, 0x66, 0x32, 0x13, 0x72, 0x1a, 0xd4, 0x02, 0x60, 0x18, 0x72, 0x7f, 0x61, 0x66, 0x33, 0x41, 0x99, 0x1b, 0xd3, 0xa4, 0xa1, 0x16, 0x04, 0xba, 0xc0, 0x00, 0x18, 0x66, 0x96, 0x1c, 
+0xd2, 0x1b, 0x95, 0x1c, 0x92, 0x7f, 0x75, 0x04, 0x60, 0x00, 0x6c, 0xe1, 0xf4, 0x16, 0x6f, 0x03, 0x10, 0x85, 0xa0, 0x01, 0xf4, 0x16, 0x6f, 0x10, 0x6d, 0x64, 0xa0, 0x04, 0xd5, 0x3e, 0xb5, 0x05, 0xd5, 0x1b, 0x96, 0x16, 0x95, 0x08, 0xd4, 0x07, 0xd6, 0x06, 0xd5, 0x99, 0xa0, 0xa3, 0x67, 0x0a, 0xd2, 0x09, 0xd4, 0x01, 0x6c, 0x8c, 0xed, 0x0b, 0xd5, 0xab, 0xa8, 0x20, 0xf4, 0x0d, 0x6e, 0x0c, 0xd5, 0x36, 0xb5, 0x49, 0xe5, 0x44, 0xa2, 0x0e, 0xd3, 0xfa, 0x6d, 0x4c, 0xec, 0x0d, 0xd4, 0x45, 0xa0, 0x04, 0x6c, 0x0f, 0xd2, 0x46, 0xa0, 0x10, 0xd2, 0x47, 0xa0, 0x11, 0xd2, 0x48, 0xa0, 0x12, 0xd2, 0x49, 0xa0, 0x13, 0xd2, 0x4a, 0xa0, 0x14, 0xd2, 0x4b, 0xa0, 0x20, 0x18, 0x00, 0x2d, 0x15, 0xd2, 0x1a, 0x97, 0xff, 0x77, 0x35, 0x60, 0xc0, 0xf2, 0x0c, 0x69, 0x38, 0xef, 0x28, 0xb2, 0x12, 0xe9, 0x25, 0xe2, 0xe0, 0xf0, 0x46, 0xa1, 0x01, 0x72, 0x2b, 0x61, 0xc0, 0xf0, 0x48, 0xa1, 0x0b, 0x72, 0x11, 0x61, 0x24, 0xb2, 0x80, 0x9a, 0x00, 0x18, 0xd3, 0x1c, 0xb0, 0x67, 0x00, 0xf2, 0x0f, 0xa1, 0x01, 0x6a, 0x4e, 0xe8, 0x26, 0x28, 0x8b, 0x99, 0x00, 0x18, 0xa3, 0x1c, 0x00, 0x6d, 0x00, 0xf2, 0x0f, 0xc1, 0x1f, 0x10, 0x1a, 0x94, 0x00, 0x18, 0xa1, 0xdf, 0xb0, 0x67, 0x1b, 0x93, 0x13, 0x73, 0x05, 0x61, 0x1a, 0x95, 0x20, 0x18, 0x71, 0x00, 0x90, 0x67, 0x0a, 0x10, 0x1b, 0x94, 0x18, 0x74, 0x07, 0x61, 0x12, 0x6a, 0xc0, 0xf0, 0x48, 0xc1, 0x1a, 0x95, 0x00, 0x18, 0xc4, 0xfd, 0x90, 0x67, 0x10, 0xb2, 0x80, 0x9a, 0x00, 0x18, 0xd3, 0x1c, 0xb0, 0x67, 0x03, 0x10, 0x20, 0x18, 0xaf, 0x20, 0x91, 0x67, 0x21, 0x97, 0x20, 0x91, 0x1f, 0x90, 0x00, 0xef, 0x11, 0x63, 0xc0, 0x50, 0x11, 0x80, 0x58, 0x73, 0x11, 0x80, 0x59, 0x73, 0x11, 0x80, 0x64, 0x94, 0x11, 0x80, 0x68, 0x94, 0x11, 0x80, 0x40, 0x47, 0x11, 0x80, 0x00, 0xd9, 0x04, 0x80, 0x70, 0x3a, 0x11, 0x80, 0xb4, 0x54, 0x11, 0x80, 0x38, 0x47, 0x11, 0x80, 0x04, 0x0b, 0x0f, 0x04, 0x0a, 0x0e, 0x08, 0x0b, 0x0f, 0x00, 0x00, 0x00, 0x1b, 0x00, 0xb7, 0x00, 0x53, 0x01, 0x36, 0x00, 0x6f, 0x01, 0xa7, 0x02, 0x53, 0x00, 0x28, 0x02, 0xfd, 0x03, 0x25, 0x00, 0x07, 0x04, 0x05, 0x01, 0x00, 0x00, 0x00, 0x00, 0x74, 0x41, 0x01, 0x10, 0xac, 0x80, 0x02
+, 0xf0, 0x78, 0x41, 0x07, 0x20, 0x7a, 0x41, 0xb1, 0x01, 0x7c, 0x41, 0x07, 0x00, 0x7e, 0x41, 0xb1, 0x01, 0x0a, 0x22, 0x62, 0x02, 0x4e, 0x22, 0x9a, 0x06, 0x50, 0x22, 0x9a, 0x06, 0x18, 0x20, 0x0f, 0x69, 0x34, 0x20, 0x55, 0x22, 0x38, 0x20, 0xa8, 0xc0, 0x00, 0x00, 0x06, 0x10, 0x0e, 0x00, 0x22, 0x10, 0x16, 0x00, 0x00, 0x24, 0x16, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x20, 0x81, 0x25, 0x00, 0x93, 0x23, 0x2b, 0x00, 0x80, 0x48, 0x21, 0x00, 0x00, 0x42, 0x24, 0x00, 0x00, 0xfe, 0x26, 0x00, 0x2a, 0x08, 0x26, 0x00, 0x2a, 0x08, 0x27, 0x00, 0x60, 0x04, 0x28, 0x00, 0x42, 0xc0, 0x29, 0x00, 0x18, 0xc4, 0x2a, 0x00, 0xc0, 0x40, 0x2d, 0x00, 0x08, 0x00, 0x37, 0x00, 0x04, 0xc0, 0x0e, 0x00, 0x22, 0x90, 0x31, 0x00, 0x01, 0x50, 0x32, 0x00, 0x71, 0x00, 0x33, 0x00, 0x70, 0x6f, 0x0e, 0x00, 0xa2, 0x11, 0x2a, 0x00, 0xc0, 0x46, 0x24, 0x00, 0x01, 0xfe, 0x00, 0x60, 0x00, 0x01, 0x2a, 0x00, 0xd0, 0x40, 0x1c, 0x00, 0x21, 0x81, 0x00, 0x60, 0x01, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x60, 0x01, 0x00, 0x3f, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x20, 0xff, 0xff, 0xff, 0xff, 0x13, 0x00, 0x9b, 0x7d, 0x13, 0x00, 0x0e, 0x60, 0x13, 0x00, 0x9e, 0x5c, 0x13, 0x00, 0x0a, 0x30, 0x13, 0x00, 0xf8, 0x2f, 0x13, 0x00, 0xc5, 0x1f, 0x13, 0x00, 0x90, 0x00, 0xff, 0xff, 0xff, 0xff, 0x1f, 0x00, 0xcb, 0x70, 0x20, 0x00, 0xc4, 0xff, 0x22, 0x00, 0x00, 0x00, 0x23, 0x00, 0x15, 0xe0, 0x15, 0x00, 0x40, 0x00, 0x15, 0x00, 0xc0, 0x20, 0x15, 0x00, 0xc0, 0x48, 0x15, 0x00, 0xc0, 0x69, 0x15, 0x00, 0xc0, 0x90, 0x15, 0x00, 0xc0, 0xb1, 0x15, 0x00, 0xc0, 0xd8, 0x15, 0x00, 0xc0, 0xf9, 0xff, 0xff, 0xff, 0xff, 0x08, 0x08, 0x08, 0x08, 0x08, 0x0b, 0x28, 0x2b, 0x48, 0x4b, 0xc8, 0xcc, 0xe9, 0xec, 0xee, 0xff, 0xf7, 0xf7, 0xf8, 0xf9, 0x07, 0x08, 0x0a, 0x0c, 0x0e, 0x1c, 0x1e, 0x1f, 0x1f, 0x00, 0x00, 0x00, 0xf7, 0xf7, 0x00, 0x00, 0x1f, 0x1f, 0x00, 0x00, 0x3f, 0x3f, 0x3f, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21, 0x00, 0x00, 0xc2, 0x00, 0x00, 0x00, 0x50, 0x01, 0x00, 0x00, 0x17, 0x02, 0x00, 
+0x00, 0xe9, 0x3f, 0x00, 0x01, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x60, 0xf4, 0x01, 0x00, 0x20, 0x01, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x40, 0x20, 0x00, 0x48, 0x42, 0x20, 0x00, 0x01, 0x44, 0x20, 0x00, 0x48, 0x46, 0x20, 0x00, 0x81, 0x48, 0x20, 0x00, 0x00, 0x4a, 0x20, 0x00, 0xf8, 0x4c, 0x20, 0x00, 0x00, 0x4e, 0x20, 0xe8, 0x00, 0x50, 0x20, 0x50, 0xcc, 0x52, 0x20, 0x00, 0xc8, 0x54, 0x20, 0x10, 0x8c, 0x56, 0x20, 0x00, 0xe0, 0x58, 0x20, 0x00, 0x50, 0x5a, 0x20, 0x00, 0x80, 0x5c, 0x20, 0x00, 0x20, 0x5e, 0x20, 0x00, 0x28, 0x00, 0x20, 0x01, 0x00, 0x08, 0x20, 0x00, 0x14, 0x0e, 0x20, 0x01, 0x00, 0x02, 0x20, 0x60, 0xc0, 0x00, 0x60, 0x0a, 0x00, 0x02, 0x20, 0x20, 0xc0, 0x00, 0x60, 0x0a, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x20, 0x01, 0x00, 0x02, 0x20, 0x20, 0x00, 0x0c, 0x20, 0x10, 0x00, 0x0e, 0x20, 0x00, 0x80, 0x00, 0x20, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x50, 0x50, 0x6a, 0x6a, 0x92, 0x2a, 0x00, 0x00, 0xd1, 0x4d, 0x2f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x02, 0x01, 0x00, 0x51, 0x04, 0xfd, 0x77
+};
+
+u32 CheckSum = 0xb228;
+#endif //#ifdef CONFIG_MP_INCLUDED
+
+
+#endif // end of DM_ODM_SUPPORT_TYPE & (ODM_AP)
+
+
+#endif // end of HWIMG_SUPPORT
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/hal/hal_intf.c linux-4.9.8821au/drivers/staging/rtl8821au/hal/hal_intf.c
--- linux-4.9/drivers/staging/rtl8821au/hal/hal_intf.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/hal/hal_intf.c	2016-12-11 19:48:25.166978407 -0600
@@ -0,0 +1,87 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+#define _HAL_INTF_C_
+
+#include <drv_types.h>
+#include <rtw_ap.h>
+#include <rtl8812a_hal.h>
+
+uint rtw_hal_init(struct rtl_priv *rtlpriv)
+{
+	uint status = _SUCCESS;
+
+	rtlpriv->hw_init_completed = false;
+
+	status = rtlpriv->cfg->ops->hw_init(rtlpriv);
+
+	if (status == _SUCCESS) {
+		rtlpriv->hw_init_completed = true;
+	} else {
+		rtlpriv->hw_init_completed = false;
+		RT_TRACE(rtlpriv, COMP_ERR, DBG_LOUD, "rtw_hal_init: hal__init fail\n");
+	}
+
+	return status;
+
+}
+
+uint rtw_hal_deinit(struct rtl_priv *rtlpriv)
+{
+	uint	status = _SUCCESS;
+
+	status = rtlpriv->cfg->ops->hal_deinit(rtlpriv);
+
+	if (status == _SUCCESS) {
+		rtlpriv->hw_init_completed = false;
+	} else {
+		RT_TRACE(rtlpriv, COMP_ERR, DBG_LOUD, "\n rtw_hal_deinit: hal_init fail\n");
+	}
+
+	return status;
+}
+
+int32_t	rtw_hal_mgnt_xmit(struct rtl_priv *rtlpriv, struct xmit_frame *pmgntframe)
+{
+	int32_t ret = _FAIL;
+
+	update_mgntframe_attrib_addr(rtlpriv, pmgntframe);
+
+	if (rtlpriv->cfg->ops->mgnt_xmit)
+		ret = rtlpriv->cfg->ops->mgnt_xmit(rtlpriv, pmgntframe);
+	return ret;
+}
+
+void rtw_hal_update_ra_mask(struct rtl_priv *rtlpriv, struct sta_info *psta, 
+			    uint8_t rssi_level)
+{
+	struct mlme_priv *pmlmepriv;
+
+	if (!psta)
+		return;
+
+	pmlmepriv = &(rtlpriv->mlmepriv);
+
+	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true) {
+		add_RATid(rtlpriv, psta, rssi_level);
+	} else {
+		UpdateHalRAMask8812A(rtlpriv, psta->mac_id, rssi_level);
+	}
+}
diff -Naur linux-4.9/drivers/staging/rtl8821au/hal/HalPwrSeqCmd.c linux-4.9.8821au/drivers/staging/rtl8821au/hal/HalPwrSeqCmd.c
--- linux-4.9/drivers/staging/rtl8821au/hal/HalPwrSeqCmd.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/hal/HalPwrSeqCmd.c	2016-12-11 19:48:25.166978407 -0600
@@ -0,0 +1,133 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+/*++
+Copyright (c) Realtek Semiconductor Corp. All rights reserved.
+
+Module Name:
+	HalPwrSeqCmd.c
+
+Abstract:
+	Implement HW Power sequence configuration CMD handling routine for Realtek devices.
+
+Major Change History:
+	When       Who               What
+	---------- ---------------   -------------------------------
+	2011-10-26 Lucas            Modify to be compatible with SD4-CE driver.
+	2011-07-07 Roger            Create.
+
+--*/
+#include <HalPwrSeqCmd.h>
+
+//
+//	Description:
+//		This routine deal with the Power Configuration CMDs parsing for RTL8723/RTL8188E Series IC.
+//
+//	Assumption:
+//		We should follow specific format which was released from HW SD.
+//
+//	2011.07.07, added by Roger.
+//
+
+/* ULLI : rtlwifi core.c
+ * real name is rtl_hal_pwrseqcmdparsing ()
+ */
+
+bool rtw_hal_pwrseqcmdparsing(struct rtl_priv *rtlpriv, u8 cut_version,
+				 u8 fabversion, u8 interface_type,
+				 struct wlan_pwr_cfg pwrcfgcmd[])
+{
+	struct wlan_pwr_cfg cfg_cmd = {0};
+	uint8_t	bPollingBit = false;
+	uint32_t AryIdx = 0;
+	uint8_t value = 0;
+	uint32_t offset = 0;
+	uint32_t pollingCount = 0; 	/* polling autoload done. */
+	uint32_t maxPollingCnt = 5000;
+
+	do {
+		cfg_cmd = pwrcfgcmd[AryIdx];
+
+		/* 2 Only Handle the command whose FAB, CUT, and Interface are matched */
+		if ((GET_PWR_CFG_FAB_MASK(cfg_cmd) & fabversion)
+		   && (GET_PWR_CFG_CUT_MASK(cfg_cmd) & cut_version)
+		   && (GET_PWR_CFG_INTF_MASK(cfg_cmd) & interface_type)) {
+			switch (GET_PWR_CFG_CMD(cfg_cmd)) {
+			case PWR_CMD_READ:
+				break;
+
+			case PWR_CMD_WRITE:
+				offset = GET_PWR_CFG_OFFSET(cfg_cmd);
+
+				{
+					/* Read the value from system register */
+					value = rtl_read_byte(rtlpriv, offset);
+
+					value=value&(~(GET_PWR_CFG_MASK(cfg_cmd)));
+					value=value|(GET_PWR_CFG_VALUE(cfg_cmd)&GET_PWR_CFG_MASK(cfg_cmd));
+
+					/* Write the value back to sytem register */
+					rtl_write_byte(rtlpriv, offset, value);
+				}
+				break;
+
+			case PWR_CMD_POLLING:
+				bPollingBit = false;
+				offset = GET_PWR_CFG_OFFSET(cfg_cmd);
+				do {
+						value = rtl_read_byte(rtlpriv, offset);
+
+					value=value&GET_PWR_CFG_MASK(cfg_cmd);
+					if (value == (GET_PWR_CFG_VALUE(cfg_cmd) & GET_PWR_CFG_MASK(cfg_cmd)))
+						bPollingBit = true;
+					else
+						udelay(10);
+
+					if (pollingCount++ > maxPollingCnt) {
+						RT_TRACE(rtlpriv, COMP_ERR, DBG_LOUD, "Fail to polling Offset[%#x]\n", offset);
+						return false;
+					}
+				} while (!bPollingBit);
+
+				break;
+
+			case PWR_CMD_DELAY:
+				if (GET_PWR_CFG_VALUE(cfg_cmd) == PWRSEQ_DELAY_US)
+					udelay(GET_PWR_CFG_OFFSET(cfg_cmd));
+				else
+					udelay(GET_PWR_CFG_OFFSET(cfg_cmd)*1000);
+				break;
+
+			case PWR_CMD_END:
+				/* When this command is parsed, end the process */
+				return true;
+				break;
+
+			default:
+				break;
+			}
+		}
+
+		AryIdx++;		/* Add Array Index */
+	} while(1);
+
+	return true;
+}
+
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/hal/odm.c linux-4.9.8821au/drivers/staging/rtl8821au/hal/odm.c
--- linux-4.9/drivers/staging/rtl8821au/hal/odm.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/hal/odm.c	2016-12-11 19:48:25.166978407 -0600
@@ -0,0 +1,511 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+/*
+ * ============================================================
+ * include files
+ * ============================================================
+ */
+
+#include <drv_types.h>
+#include "odm_precomp.h"
+#include <../rtl8821au/reg.h>
+#include <../rtl8821au/dm.h>
+#include <../wifi.h>
+#include <rtl8812a_cmd.h>
+
+#define ODM_RT_ASSERT(x, ...)	do { } while (0);
+
+const u16 dB_Invert_Table[8][12] = {
+	{	1,		1,		1,		2,		2,		2,		2,		3,		3,		3,		4,		4},
+	{	4,		5,		6,		6,		7,		8,		9,		10,		11,		13,		14,		16},
+	{	18,		20,		22,		25,		28,		32,		35,		40,		45,		50,		56,		63},
+	{	71,		79,		89,		100,	112,	126,	141,	158,	178,	200,	224,	251},
+	{	282,	316,	355,	398,	447,	501,	562,	631,	708,	794,	891,	1000},
+	{	1122,	1259,	1413,	1585,	1778,	1995,	2239,	2512,	2818,	3162,	3548,	3981},
+	{	4467,	5012,	5623,	6310,	7079,	7943,	8913,	10000,	11220,	12589,	14125,	15849},
+	{	17783,	19953,	22387,	25119,	28184,	31623,	35481,	39811,	44668,	50119,	56234,	65535}
+	};
+
+/*
+ * 20100515 Joseph: Add global variable to keep temporary scan list for antenna switching test.
+ * u8			tmpNumBssDesc;
+ * RT_WLAN_BSS	tmpbssDesc[MAX_BSS_DESC];
+ */
+
+/*
+ * ============================================================
+ * EDCA Paramter for AP/ADSL   by Mingzhi 2011-11-22
+ * ============================================================
+ */
+
+/*
+ * ============================================================
+ *  Global var
+ * ============================================================
+ */
+
+
+
+/*
+ * ============================================================
+ * Local Function predefine.
+ * ============================================================
+ */
+
+/* START------------COMMON INFO RELATED--------------- */
+/*
+void odm_FindMinimumRSSI(struct _rtw_dm *pDM_Odm);
+void odm_IsLinked(struct _rtw_dm *pDM_Odm);
+*/
+/* END------------COMMON INFO RELATED--------------- */
+
+/* START---------------DIG--------------------------- */
+void odm_DIGInit(struct _rtw_dm *pDM_Odm);
+void odm_AdaptivityInit(struct _rtw_dm *pDM_Odm);
+/* END---------------DIG--------------------------- */
+
+/* END---------BB POWER SAVE----------------------- */
+
+/* START-----------------PSD----------------------- */
+/* END-------------------PSD----------------------- */
+
+void odm_RateAdaptiveMaskInit(struct _rtw_dm *pDM_Odm);
+void odm_TXPowerTrackingThermalMeterInit(struct _rtw_dm *pDM_Odm);
+void odm_TXPowerTrackingInit(struct _rtw_dm *pDM_Odm);
+void odm_TXPowerTrackingCheckCE(struct _rtw_dm *pDM_Odm);
+
+#define	RxDefaultAnt1		0x65a9
+#define	RxDefaultAnt2		0x569a
+
+/*
+ * ============================================================
+ * Export Interface
+ * ============================================================
+ */
+
+
+
+
+/*
+ * Init /.. Fixed HW value. Only init time.
+ */
+
+
+void ODM_CmnInfoHook(struct _rtw_dm *pDM_Odm, ODM_CMNINFO_E	CmnInfo, void *pValue)
+{
+	struct rtl_priv *rtlpriv = pDM_Odm->rtlpriv;
+	struct rtl_mac *mac = rtl_mac(rtlpriv);
+	/*
+	 * Hook call by reference pointer.
+	 */
+	switch (CmnInfo) {
+	/*
+	 * Dynamic call by reference pointer.
+	 */
+
+	case	ODM_CMNINFO_SCAN:
+		mac->act_scanning = (bool *)pValue;
+		break;
+
+	/* To remove the compiler warning, must add an empty default statement to handle the other values. */
+	default:
+		/* do nothing */
+		break;
+		break;
+
+	}
+
+}
+
+/*
+ * 3============================================================
+ * 3 DIG
+ * 3============================================================
+ */
+
+/*-----------------------------------------------------------------------------
+ * Function:	odm_DIGInit()
+ *
+ * Overview:	Set DIG scheme init value.
+ *
+ * Input:		NONE
+ *
+ * Output:		NONE
+ *
+ * Return:		NONE
+ *
+ * Revised History:
+ *	When		Who		Remark
+ *
+ *---------------------------------------------------------------------------*/
+
+
+void odm_Adaptivity(struct rtl_priv *rtlpriv, u8 IGI)
+{
+	struct _rtw_hal	*pHalData = GET_HAL_DATA(rtlpriv);
+	struct _rtw_dm *pDM_Odm = &pHalData->odmpriv;
+	struct dig_t *dm_digtable = &(rtlpriv->dm_digtable);
+
+	int32_t TH_H_dmc, TH_L_dmc;
+	int32_t TH_H, TH_L, Diff, IGI_target;
+	bool EDCCA_State;
+
+	RT_TRACE(rtlpriv, COMP_DIG, DBG_LOUD, "odm_Adaptivity() =====> \n");
+
+	if (rtlpriv->rtlhal.current_bandtype == BAND_ON_5G) {
+		pDM_Odm->TH_H = 0xf4;	/* 0xf8; */
+		pDM_Odm->TH_L = 0xf7;	/* 0xfb; */
+	} else {
+		pDM_Odm->TH_H = 0xf4;	/* 0xfa; */
+		pDM_Odm->TH_L = 0xf7;	/* 0xfd; */
+	}
+
+	RT_TRACE(rtlpriv, COMP_DIG, DBG_LOUD, "pDM_Odm->ForceEDCCA=%d, IGI_Base=0x%x, TH_H=0x%x, TH_L=0x%x, AdapEn_RSSI = %d\n",
+	pDM_Odm->ForceEDCCA, pDM_Odm->IGI_Base, pDM_Odm->TH_H, pDM_Odm->TH_L, pDM_Odm->AdapEn_RSSI);
+
+	rtl_set_bbreg(pDM_Odm->rtlpriv, 0x800, BIT(10), 0);		/* ADC_mask enable */
+
+	if (rtlpriv->mac80211.link_state < MAC80211_LINKED) {
+		return;
+	}
+
+	if (!pDM_Odm->ForceEDCCA) {
+		if (dm_digtable->rssi_val_min > pDM_Odm->AdapEn_RSSI)
+			EDCCA_State = 1;
+		else if (dm_digtable->rssi_val < (pDM_Odm->AdapEn_RSSI - 5))
+			EDCCA_State = 0;
+	} else
+		EDCCA_State = 1;
+	/*
+	 * if ((pDM_Odm->SupportICType & ODM_IC_11AC_SERIES) && (*pDM_Odm->pBandType == BAND_ON_5G))
+	 * 	IGI_target = pDM_Odm->IGI_Base;
+	 * else
+	 */
+
+	if (rtlpriv->phy.current_chan_bw == CHANNEL_WIDTH_20)	/*CHANNEL_WIDTH_20 */
+		IGI_target = pDM_Odm->IGI_Base;
+	else if (rtlpriv->phy.current_chan_bw == CHANNEL_WIDTH_40)
+		IGI_target = pDM_Odm->IGI_Base + 2;
+	else if (rtlpriv->phy.current_chan_bw == CHANNEL_WIDTH_80)
+		IGI_target = pDM_Odm->IGI_Base + 6;
+	else
+		IGI_target = pDM_Odm->IGI_Base;
+
+
+	pDM_Odm->IGI_target = IGI_target;
+
+	if (pDM_Odm->TH_H & BIT(7))
+		TH_H = pDM_Odm->TH_H | 0xFFFFFF00;
+	else
+		TH_H = pDM_Odm->TH_H;
+	if (pDM_Odm->TH_L & BIT(7))
+		TH_L = pDM_Odm->TH_L | 0xFFFFFF00;
+	else
+		TH_L = pDM_Odm->TH_L;
+
+	RT_TRACE(rtlpriv, COMP_DIG, DBG_LOUD, "BandWidth=%s, IGI_target=0x%x, EDCCA_State=%d\n",
+		(rtlpriv->phy.current_chan_bw == CHANNEL_WIDTH_80) ? "80M" : ((rtlpriv->phy.current_chan_bw == CHANNEL_WIDTH_40) ? "40M" : "20M"), IGI_target, EDCCA_State);
+
+	if (EDCCA_State == 1) {
+		if (IGI < IGI_target) {
+			Diff = IGI_target - (int32_t)IGI;
+			TH_H_dmc = TH_H + Diff;
+			if (TH_H_dmc > 10)
+				TH_H_dmc = 10;
+			TH_L_dmc = TH_L + Diff;
+			if (TH_L_dmc > 10)
+				TH_L_dmc = 10;
+		} else 	{
+			Diff = (int32_t)IGI - IGI_target;
+			TH_H_dmc = TH_H - Diff;
+			TH_L_dmc = TH_L - Diff;
+		}
+		TH_H_dmc = (TH_H_dmc & 0xFF);
+		TH_L_dmc = (TH_L_dmc & 0xFF);
+	} else {
+		TH_H_dmc = 0x7f;
+		TH_L_dmc = 0x7f;
+	}
+	RT_TRACE(rtlpriv, COMP_DIG, DBG_LOUD, "IGI=0x%x, TH_H_dmc=0x%x, TH_L_dmc=0x%x\n",
+		IGI, TH_H_dmc, TH_L_dmc);
+
+	rtl_set_bbreg(pDM_Odm->rtlpriv, rFPGA0_XB_LSSIReadBack, 0xFFFF, (TH_H_dmc<<8) | TH_L_dmc);
+}
+
+/*
+ * 3============================================================
+ * 3 CCK Packet Detect Threshold
+ * 3============================================================
+ */
+
+
+void ODM_Write_CCK_CCA_Thres(struct rtl_priv *rtlpriv, u8 CurCCK_CCAThres)
+{
+	struct dig_t *pDM_DigTable = &(rtlpriv->dm_digtable);
+
+	if (pDM_DigTable->cur_cck_cca_thres != CurCCK_CCAThres) {	/* modify by Guo.Mingzhi 2012-01-03 */
+		rtl_write_byte(rtlpriv, ODM_REG_CCK_CCA_11AC, CurCCK_CCAThres);
+	}
+	pDM_DigTable->pre_cck_cca_thres = pDM_DigTable->cur_cck_cca_thres;
+	pDM_DigTable->cur_cck_cca_thres = CurCCK_CCAThres;
+
+}
+
+/*
+ * 3============================================================
+ * 3 RATR MASK
+ * 3============================================================
+ * 3============================================================
+ * 3 Rate Adaptive
+ * 3============================================================
+ */
+
+
+
+uint32_t ODM_Get_Rate_Bitmap(struct rtl_priv *rtlpriv, uint32_t macid,
+	uint32_t ra_mask, u8 rssi_level)
+{
+	struct rtl_hal  *rtlhal = rtl_hal(rtlpriv);
+	struct rtl_dm *rtldm = rtl_dm(rtlpriv);
+
+	struct sta_info *pEntry;
+	uint32_t 	rate_bitmap = 0;
+	u8 	WirelessMode;
+
+	pEntry = rtldm->pODM_StaInfo[macid];
+	if (!IS_STA_VALID(pEntry))
+		return ra_mask;
+
+	WirelessMode = pEntry->wireless_mode;
+
+	switch (WirelessMode) {
+	case WIRELESS_MODE_B:
+		if (ra_mask & 0x0000000c)		/* 11M or 5.5M enable */
+			rate_bitmap = 0x0000000d;
+		else
+			rate_bitmap = 0x0000000f;
+		break;
+
+	case WIRELESS_MODE_G:
+	case WIRELESS_MODE_A:
+		if (rssi_level == DM_RATR_STA_HIGH)
+			rate_bitmap = 0x00000f00;
+		else
+			rate_bitmap = 0x00000ff0;
+		break;
+
+	case WIRELESS_MODE_B | WIRELESS_MODE_G:
+		if (rssi_level == DM_RATR_STA_HIGH)
+			rate_bitmap = 0x00000f00;
+		else if (rssi_level == DM_RATR_STA_MIDDLE)
+			rate_bitmap = 0x00000ff0;
+		else
+			rate_bitmap = 0x00000ff5;
+		break;
+
+	case WIRELESS_MODE_B | WIRELESS_MODE_G | WIRELESS_MODE_N_24G:
+	case WIRELESS_MODE_B | WIRELESS_MODE_N_24G:
+	case WIRELESS_MODE_A | WIRELESS_MODE_N_5G:
+		if (rtlpriv->phy.rf_type == ODM_1T2R || rtlpriv->phy.rf_type == ODM_1T1R) {
+			if (rssi_level == DM_RATR_STA_HIGH) {
+				rate_bitmap = 0x000f0000;
+			} else if (rssi_level == DM_RATR_STA_MIDDLE) {
+				rate_bitmap = 0x000ff000;
+			} else {
+				if (rtlpriv->phy.current_chan_bw == CHANNEL_WIDTH_40)
+					rate_bitmap = 0x000ff015;
+				else
+					rate_bitmap = 0x000ff005;
+			}
+		} else {
+			if (rssi_level == DM_RATR_STA_HIGH) {
+				rate_bitmap = 0x0f8f0000;
+			} else if (rssi_level == DM_RATR_STA_MIDDLE) {
+				rate_bitmap = 0x0f8ff000;
+			} else {
+				if (rtlpriv->phy.current_chan_bw == CHANNEL_WIDTH_40)
+					rate_bitmap = 0x0f8ff015;
+				else
+					rate_bitmap = 0x0f8ff005;
+			}
+		}
+		break;
+	case WIRELESS_MODE_AC_5G | WIRELESS_MODE_A:
+	case WIRELESS_MODE_AC_5G | WIRELESS_MODE_G:
+		if (rtlpriv->phy.rf_type == RF_1T1R) {
+			if (IS_HARDWARE_TYPE_8811AU(rtlhal) ||
+				(IS_HARDWARE_TYPE_8812AU(rtlhal) && IS_NORMAL_CHIP(rtlhal->version))) {
+				if (IS_HARDWARE_TYPE_8821U(rtlhal)
+					&& (rtlpriv->phy.current_channel >= 149)) {
+					if (rssi_level == 1)				/* add by Gary for ac-series */
+						rate_bitmap = 0x001f8000;
+					else if (rssi_level == 2)
+						rate_bitmap = 0x001ff000;
+					else
+						rate_bitmap = 0x001ff010;
+				} else 	{
+					if (rssi_level == 1)				/* add by Gary for ac-series */
+						rate_bitmap = 0x003f8000;
+					else if (rssi_level == 2)
+						rate_bitmap = 0x003ff000;
+					else
+						rate_bitmap = 0x003ff010;
+				}
+			} else {
+				rate_bitmap = 0x000ff010;
+		       }
+		} else {
+			if (IS_NORMAL_CHIP(rtlhal->version)) {
+				if (rssi_level == 1)			/* add by Gary for ac-series */
+					rate_bitmap = 0xfe3f8000;       /* VHT 2SS MCS3~9 */
+				else if (rssi_level == 2)
+					rate_bitmap = 0xfffff000;       /* VHT 2SS MCS0~9 */
+				else
+					rate_bitmap = 0xfffff010;       /* All */
+			} else
+				rate_bitmap = 0x3fcff010;
+		}
+		break;
+
+	default:
+		if (rtlpriv->phy.rf_type == RF_1T2R)
+			rate_bitmap = 0x000fffff;
+		else
+			rate_bitmap = 0x0fffffff;
+		break;
+
+	}
+
+	/* printk("%s ==> rssi_level:0x%02x, WirelessMode:0x%02x, rate_bitmap:0x%08x \n",__FUNCTION__,rssi_level,WirelessMode,rate_bitmap); */
+	RT_TRACE(rtlpriv, COMP_RATE, DBG_LOUD, " ==> rssi_level:0x%02x, WirelessMode:0x%02x, rate_bitmap:0x%08x \n", rssi_level, WirelessMode, rate_bitmap);
+
+	return (ra_mask&rate_bitmap);
+
+}
+
+/*-----------------------------------------------------------------------------
+ * Function:	odm_RefreshRateAdaptiveMask()
+ *
+ * Overview:	Update rate table mask according to rssi
+ *
+ * Input:		NONE
+ *
+ * Output:		NONE
+ *
+ * Return:		NONE
+ *
+ * Revised History:
+ *	When		Who		Remark
+ *	05/27/2009	hpfan	Create Version 0.
+ *
+ *---------------------------------------------------------------------------*/
+
+/*
+ * Return Value: bool
+ * - true: RATRState is changed.
+ */
+static bool ODM_RAStateCheck(struct rtl_priv *rtlpriv, u32 RSSI,
+	bool bForceUpdate, u8 *pRATRState)
+{
+	struct rate_adaptive *p_ra = &(rtlpriv->ra);
+
+	const u8 GoUpGap = 5;
+	u8 HighRSSIThreshForRA = p_ra->high_rssi_thresh_for_ra;
+	u8 LowRSSIThreshForRA = p_ra->low2high_rssi_thresh_for_ra40m;
+	u8 RATRState;
+
+	/*
+	 * Threshold Adjustment:
+	 * when RSSI state trends to go up one or two levels, make sure RSSI is high enough.
+	 * Here GoUpGap is added to solve the boundary's level alternation issue.
+	 */
+	switch (*pRATRState) {
+	case DM_RATR_STA_INIT:
+	case DM_RATR_STA_HIGH:
+		break;
+	case DM_RATR_STA_MIDDLE:
+		HighRSSIThreshForRA += GoUpGap;
+		break;
+	case DM_RATR_STA_LOW:
+		HighRSSIThreshForRA += GoUpGap;
+		LowRSSIThreshForRA += GoUpGap;
+		break;
+
+	default:
+		ODM_RT_ASSERT(pDM_Odm, false, ("wrong rssi level setting %d !", *pRATRState));
+		break;
+	}
+
+	/* Decide RATRState by RSSI. */
+	if (RSSI > HighRSSIThreshForRA)
+		RATRState = DM_RATR_STA_HIGH;
+	else if (RSSI > LowRSSIThreshForRA)
+		RATRState = DM_RATR_STA_MIDDLE;
+	else
+		RATRState = DM_RATR_STA_LOW;
+	/* printk("==>%s,RATRState:0x%02x ,RSSI:%d \n",__FUNCTION__,RATRState,RSSI); */
+
+	if (*pRATRState != RATRState || bForceUpdate) {
+		RT_TRACE(rtlpriv, COMP_RATE, DBG_LOUD, "RSSI Level %d -> %d\n", *pRATRState, RATRState);
+		*pRATRState = RATRState;
+		return true;
+	}
+
+	return false;
+}
+
+void odm_RefreshRateAdaptiveMask(struct rtl_priv *rtlpriv)
+{
+	struct rate_adaptive *p_ra = &(rtlpriv->ra);
+	struct rtl_dm *rtldm = rtl_dm(rtlpriv);
+	u8	i;
+	struct _rtw_hal *pHalData = GET_HAL_DATA(rtlpriv);
+	struct _rtw_dm *	pDM_Odm = &(pHalData->odmpriv);
+
+	if (rtlpriv->bDriverStopped) {
+		RT_TRACE(rtlpriv, COMP_RATE, DBG_TRACE, "<---- odm_RefreshRateAdaptiveMask(): driver is going to unload\n");
+		return;
+	}
+
+	/* printk("==> %s \n",__FUNCTION__); */
+
+	for (i = 0; i < ODM_ASSOCIATE_ENTRY_NUM; i++) {
+		struct sta_info *pstat = rtldm->pODM_StaInfo[i];
+		if (IS_STA_VALID(pstat)) {
+			if (pstat->rssi_stat.UndecoratedSmoothedPWDB < p_ra->ldpc_thres) {
+				p_ra->use_ldpc = true;
+				Set_RA_LDPC_8812(pstat, true);
+				/* DbgPrint("RSSI=%d, bUseLdpc = true\n", pHalData->UndecoratedSmoothedPWDB); */
+			} else if (pstat->rssi_stat.UndecoratedSmoothedPWDB > (p_ra->ldpc_thres-5)) {
+				p_ra->use_ldpc = false;
+				Set_RA_LDPC_8812(pstat, false);
+				/* DbgPrint("RSSI=%d, bUseLdpc = false\n", pHalData->UndecoratedSmoothedPWDB); */
+			}
+
+			if (true == ODM_RAStateCheck(rtlpriv, pstat->rssi_stat.UndecoratedSmoothedPWDB, false , &pstat->rssi_level)) {
+				RT_TRACE(rtlpriv, COMP_RATE, DBG_LOUD, "RSSI:%d, RSSI_LEVEL:%d\n", pstat->rssi_stat.UndecoratedSmoothedPWDB, pstat->rssi_level);
+				/* printk("RSSI:%d, RSSI_LEVEL:%d\n", pstat->rssi_stat.UndecoratedSmoothedPWDB, pstat->rssi_level); */
+				rtw_hal_update_ra_mask(pstat->rtlpriv, pstat, pstat->rssi_level);
+			}
+		}
+	}
+
+}
diff -Naur linux-4.9/drivers/staging/rtl8821au/hal/rtl8812a_cmd.c linux-4.9.8821au/drivers/staging/rtl8821au/hal/rtl8812a_cmd.c
--- linux-4.9/drivers/staging/rtl8821au/hal/rtl8812a_cmd.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/hal/rtl8812a_cmd.c	2016-12-11 19:48:25.166978407 -0600
@@ -0,0 +1,46 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#define _RTL8812A_CMD_C_
+
+#include <drv_types.h>
+#include <rtl8812a_hal.h>
+#include <../rtl8821au/trx.h>
+#include <../rtl8821au/fw.h>
+
+
+
+
+
+
+
+void rtl8812_Add_RateATid(struct rtl_priv *rtlpriv, uint32_t bitmap, uint8_t * arg, uint8_t rssi_level)
+{
+	uint8_t	macid;
+
+	macid = arg[0];
+
+	if(rssi_level != DM_RATR_STA_INIT)
+		bitmap = ODM_Get_Rate_Bitmap(rtlpriv, macid, bitmap, rssi_level);
+
+	rtl8812_set_raid_cmd(rtlpriv, bitmap, arg);
+}
+
+
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/hal/rtl8812a_dm.c linux-4.9.8821au/drivers/staging/rtl8821au/hal/rtl8812a_dm.c
--- linux-4.9/drivers/staging/rtl8821au/hal/rtl8812a_dm.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/hal/rtl8812a_dm.c	2016-12-11 19:48:25.166978407 -0600
@@ -0,0 +1,71 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+#define _RTL8812A_DM_C_
+
+#include <drv_types.h>
+#include <rtl8812a_hal.h>
+#include <../rtl8821au/dm.h>
+
+
+/*
+ * Initialize GPIO setting registers
+ */
+
+
+/*
+ * ============================================================
+ * functions
+ * ============================================================
+ */
+
+static void Init_ODM_ComInfo_8812(struct rtl_priv *rtlpriv)
+{
+	struct _rtw_hal *pHalData = GET_HAL_DATA(rtlpriv);
+	struct _rtw_dm *pDM_Odm = &(pHalData->odmpriv);
+
+	/*
+	 * Init Value
+	 */
+
+	memset(pDM_Odm,0,sizeof(*pDM_Odm));
+
+	pDM_Odm->rtlpriv = rtlpriv;
+
+
+	/* 1 ============== End of BoardType ============== */
+
+
+	/* if(pHalData->AntDivCfg)
+	 *	pdmpriv->InitODMFlag |= ODM_BB_ANT_DIV;
+	 */
+}
+
+void rtl8812_init_dm_priv(struct rtl_priv *rtlpriv)
+{
+	struct _rtw_hal *pHalData = GET_HAL_DATA(rtlpriv);
+	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
+	memset(pdmpriv, 0, sizeof(struct dm_priv));
+
+	/* spin_lock_init(&(pHalData->odm_stainfo_lock)); */
+
+	Init_ODM_ComInfo_8812(rtlpriv);
+}
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/hal/rtl8812a_hal_init.c linux-4.9.8821au/drivers/staging/rtl8821au/hal/rtl8812a_hal_init.c
--- linux-4.9/drivers/staging/rtl8821au/hal/rtl8812a_hal_init.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/hal/rtl8812a_hal_init.c	2016-12-11 19:48:25.166978407 -0600
@@ -0,0 +1,196 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#define _RTL8812A_HAL_INIT_C_
+#include <drv_types.h>
+#include <rtl8812a_hal.h>
+
+/*
+ *-------------------------------------------------------------------------
+ *
+ * LLT R/W/Init function
+ *
+ *-------------------------------------------------------------------------
+ */
+
+/*====================================================================================
+ *
+ * 20100209 Joseph:
+ * This function is used only for 92C to set REG_BCN_CTRL(0x550) register.
+ * We just reserve the value of the register in variable pHalData->RegBcnCtrlVal and then operate
+ * the value of the register via atomic operation.
+ * This prevents from race condition when setting this register.
+ * The value of pHalData->RegBcnCtrlVal is initialized in HwConfigureRTL8192CE() function.
+ *
+ */
+
+void InitializeFirmwareVars8812(struct rtl_priv *rtlpriv)
+{
+	struct rtl_hal *rtlhal = rtl_hal(rtlpriv);
+
+	/* Init Fw LPS related. */
+	rtlpriv->pwrctrlpriv.fw_current_inpsmode = false;
+	/* Init H2C counter. by tynli. 2009.12.09. */
+	rtlhal->last_hmeboxnum = 0;
+}
+
+void rtl8812_free_hal_data(struct rtl_priv *rtlpriv)
+{
+	if (rtlpriv->HalData) {
+			rtw_mfree(rtlpriv->HalData);
+		rtlpriv->HalData = NULL;
+	}
+}
+
+/*
+ * ===========================================================
+ * 				Efuse related code
+ * ===========================================================
+ */
+
+
+/*
+ * ULLI need to refactoring for rtlwifi-lib
+ * static bool _rt8812au_phy_set_rf_power_state(struct ieee80211_hw *hw,
+ * 					    enum rf_pwrstate rfpwr_state)
+ *
+ */
+
+void rtw_set_sta_info(struct rtl_priv *rtlpriv, struct sta_info *psta, bool bSet)
+{
+	struct rtl_dm *rtldm = rtl_dm(rtlpriv);
+	/* _irqL irqL; */
+
+	if (bSet) {
+		RT_TRACE(rtlpriv, COMP_ERR, DBG_LOUD, "### Set STA_(%d) info\n", psta->mac_id);
+		rtldm->pODM_StaInfo[psta->mac_id] = psta;
+#if (RATE_ADAPTIVE_SUPPORT == 1)
+		ODM_RAInfo_Init(podmpriv, psta->mac_id);
+#endif
+	} else {
+		RT_TRACE(rtlpriv, COMP_ERR, DBG_LOUD, "### Clean STA_(%d) info\n", psta->mac_id);
+		/* spin_lock_bh(&pHalData->odm_stainfo_lock, &irqL); */
+		rtldm->pODM_StaInfo[psta->mac_id] = NULL;
+		/* spin_unlock_bh(&pHalData->odm_stainfo_lock, &irqL); */
+	}
+}
+
+void UpdateHalRAMask8812A(struct rtl_priv *rtlpriv, uint32_t mac_id, uint8_t rssi_level)
+{
+	/* volatile unsigned int result; */
+	uint8_t	init_rate = 0;
+	uint8_t	networkType, raid;
+	uint32_t	mask, rate_bitmap;
+	uint8_t	shortGIrate = false;
+	int	supportRateNum = 0;
+	uint8_t	arg[4] = {0};
+	struct sta_info	*psta;
+	 struct _rtw_hal	*pHalData = GET_HAL_DATA(rtlpriv);
+	/* struct dm_priv	*pdmpriv = &pHalData->dmpriv; */
+	struct mlme_ext_priv	*pmlmeext = &rtlpriv->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	WLAN_BSSID_EX 		*cur_network = &(pmlmeinfo->network);
+
+	if (mac_id >= NUM_STA) {	/* CAM_SIZE */
+		return;
+	}
+
+	psta = pmlmeinfo->FW_sta_info[mac_id].psta;
+	if (psta == NULL) {
+		return;
+	}
+
+	switch (mac_id) {
+	case 0:
+		/* for infra mode */
+		supportRateNum = rtw_get_rateset_len(cur_network->SupportedRates);
+		networkType = judge_network_type(rtlpriv, cur_network->SupportedRates, supportRateNum);
+		/* pmlmeext->cur_wireless_mode = networkType; */
+		/* raid = networktype_to_raid(networkType); */
+		raid = rtw_hal_networktype_to_raid(rtlpriv, networkType);
+
+		mask = update_supported_rate(cur_network->SupportedRates, supportRateNum);
+		if (pmlmeinfo->VHT_enable) {
+			mask |= (rtw_vht_rate_to_bitmap(psta->vhtpriv.vht_mcs_map) << 12);
+			shortGIrate = psta->vhtpriv.sgi;
+		} else
+			{
+				mask |= (pmlmeinfo->HT_enable) ? update_MCS_rate(&(pmlmeinfo->HT_caps)) : 0;
+				if (support_short_GI(rtlpriv, &(pmlmeinfo->HT_caps)))
+					shortGIrate = true;
+			}
+
+		break;
+
+	case 1:
+		/* for broadcast/multicast */
+		supportRateNum = rtw_get_rateset_len(pmlmeinfo->FW_sta_info[mac_id].SupportedRates);
+		if (pmlmeext->cur_wireless_mode & WIRELESS_11B)
+			networkType = WIRELESS_11B;
+		else
+			networkType = WIRELESS_11G;
+
+		/* raid = networktype_to_raid(networkType); */
+		raid = rtw_hal_networktype_to_raid(rtlpriv, networkType);
+		mask = update_basic_rate(cur_network->SupportedRates, supportRateNum);
+
+		break;
+
+	default:
+		/*for each sta in IBSS */
+		supportRateNum = rtw_get_rateset_len(pmlmeinfo->FW_sta_info[mac_id].SupportedRates);
+		networkType = judge_network_type(rtlpriv, pmlmeinfo->FW_sta_info[mac_id].SupportedRates, supportRateNum) & 0xf;
+		/*
+		 * pmlmeext->cur_wireless_mode = networkType;
+		 * raid = networktype_to_raid(networkType);
+		 */
+		raid = rtw_hal_networktype_to_raid(rtlpriv, networkType);
+		mask = update_supported_rate(cur_network->SupportedRates, supportRateNum);
+
+		/* todo: support HT in IBSS */
+
+		break;
+	}
+
+	/* mask &=0x0fffffff; */
+	rate_bitmap = ODM_Get_Rate_Bitmap(rtlpriv, mac_id, mask, rssi_level);
+		RT_TRACE(rtlpriv, COMP_RATE, DBG_LOUD, "%s => mac_id:%d, networkType:0x%02x, mask:0x%08x\n\t ==> rssi_level:%d, rate_bitmap:0x%08x\n",
+			__FUNCTION__, mac_id, networkType, mask, rssi_level, rate_bitmap);
+
+	mask &= rate_bitmap;
+	init_rate = get_highest_rate_idx(mask)&0x3f;
+
+	/*
+	 * arg[0] = macid
+	 * arg[1] = raid
+	 * arg[2] = shortGIrate
+	 * arg[3] = init_rate
+	 */
+
+	arg[0] = mac_id;
+	arg[1] = raid;
+	arg[2] = shortGIrate;
+	arg[3] = init_rate;
+
+	rtl8812_set_raid_cmd(rtlpriv, mask, arg);
+
+	/* set ra_id */
+	psta->raid = raid;
+	psta->init_rate = init_rate;
+}
diff -Naur linux-4.9/drivers/staging/rtl8821au/hal/rtl8812a_phycfg.c linux-4.9.8821au/drivers/staging/rtl8821au/hal/rtl8812a_phycfg.c
--- linux-4.9/drivers/staging/rtl8821au/hal/rtl8812a_phycfg.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/hal/rtl8812a_phycfg.c	2016-12-11 19:48:25.170311727 -0600
@@ -0,0 +1,234 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#define _RTL8812A_PHYCFG_C_
+
+#include <drv_types.h>
+#include <rtl8812a_hal.h>
+#include <../rtl8821au/phy.h>
+#include <../rtl8821au/dm.h>
+#include <../rtl8821au/reg.h>
+#include <../rtl8821au/rf.h>
+#include <../wifi.h>
+
+const char *const GLBwSrc[]={
+	"CHANNEL_WIDTH_20",
+	"CHANNEL_WIDTH_40",
+	"CHANNEL_WIDTH_80",
+	"CHANNEL_WIDTH_160",
+	"CHANNEL_WIDTH_80_80"
+};
+#define		ENABLE_POWER_BY_RATE		1
+#define		POWERINDEX_ARRAY_SIZE		48 //= cckRatesSize + ofdmRatesSize + htRates1TSize + htRates2TSize + vhtRates1TSize + vhtRates1TSize;
+
+/* ---------------------Define local function prototype----------------------- */
+
+/* ----------------------------Function Body---------------------------------- */
+
+/*
+ * 2. RF register R/W API
+ */
+/*
+ * 3. Initial MAC/BB/RF config by reading MAC/BB/RF txt.
+ */
+
+/* Ulli called in odm_RegConfig8812A.c and odm_RegConfig8821A.c */
+
+/**************************************************************************************************************
+ *   Description:
+ *       The low-level interface to get the FINAL Tx Power Index , called  by both MP and Normal Driver.
+ *
+ *                                                                                    <20120830, Kordan>
+ **************************************************************************************************************/
+
+/**************************************************************************************************************
+ *   Description:
+ *       The low-level interface to set TxAGC , called by both MP and Normal Driver.
+ *
+ *                                                                                    <20120830, Kordan>
+ **************************************************************************************************************/
+
+
+/*
+ * create new definition of PHY_SetTxPowerLevel8812 by YP.
+ * Page revised on 20121106
+ * the new way to set tx power by rate, NByte access, here N byte shall be 4 byte(DWord) or NByte(N>4) access. by page/YP, 20121106
+ */
+
+/* ULLI called in HalPhyRf8812A.c and HalPhyRf21A.c */
+
+/* ULLI used in rtl8821au/dm.c */
+
+
+
+
+/*
+ * Prototypes needed here, because functions are moved to rtl8821au/phy.c
+ */
+
+static void PHY_HandleSwChnlAndSetBW8812(struct rtl_priv *rtlpriv,
+	bool	bSwitchChannel, bool	bSetBandWidth,
+	uint8_t	ChannelNum, enum CHANNEL_WIDTH ChnlWidth,
+	uint8_t	ChnlOffsetOf40MHz, uint8_t ChnlOffsetOf80MHz,
+	uint8_t	CenterFrequencyIndex1
+)
+{
+	struct rtl_mac	*mac = &(rtlpriv->mac80211);
+	struct _rtw_hal *	pHalData = GET_HAL_DATA(rtlpriv);
+	uint8_t			tmpChannel = rtlpriv->phy.current_channel;
+	enum CHANNEL_WIDTH	tmpBW= rtlpriv->phy.current_chan_bw;
+	uint8_t			tmpnCur40MhzPrimeSC = mac->cur_40_prime_sc;
+	uint8_t			tmpnCur80MhzPrimeSC = mac->cur_80_prime_sc;
+
+	bool bSwChnl = false, bSetChnlBW = false;
+
+
+	/* DBG_871X("=> PHY_HandleSwChnlAndSetBW8812: bSwitchChannel %d, bSetBandWidth %d \n",bSwitchChannel,bSetBandWidth); */
+
+	/* check is swchnl or setbw */
+	if(!bSwitchChannel && !bSetBandWidth) {
+		RT_TRACE(rtlpriv, COMP_ERR, DBG_LOUD, "PHY_HandleSwChnlAndSetBW8812:  not switch channel and not set bandwidth \n");
+		return;
+	}
+
+	/* skip change for channel or bandwidth is the same */
+	if(bSwitchChannel) {
+		if(rtlpriv->phy.current_channel != ChannelNum) {
+			if (HAL_IsLegalChannel(rtlpriv, ChannelNum))
+				bSwChnl = true;
+			else
+				return;
+		}
+	}
+
+	if(bSetBandWidth) {
+		if(pHalData->bChnlBWInitialzed == false) {
+			pHalData->bChnlBWInitialzed = true;
+			bSetChnlBW = true;
+		} else if((rtlpriv->phy.current_chan_bw != ChnlWidth) ||
+			(mac->cur_40_prime_sc != ChnlOffsetOf40MHz) ||
+			(mac->cur_80_prime_sc != ChnlOffsetOf80MHz) ||
+			(rtlpriv->phy.current_channel != CenterFrequencyIndex1)) {
+
+			bSetChnlBW = true;
+		}
+	}
+
+	if(!bSetChnlBW && !bSwChnl) {
+		/* DBG_871X("<= PHY_HandleSwChnlAndSetBW8812: bSwChnl %d, bSetChnlBW %d \n",bSwChnl,bSetChnlBW); */
+		return;
+	}
+
+
+	if(bSwChnl) {
+		rtlpriv->phy.current_channel = ChannelNum;
+	}
+
+
+	if(bSetChnlBW) {
+		rtlpriv->phy.current_chan_bw = ChnlWidth;
+		mac->cur_40_prime_sc = ChnlOffsetOf40MHz;
+		mac->cur_80_prime_sc = ChnlOffsetOf80MHz;
+	}
+
+	/* Switch workitem or set timer to do switch channel or setbandwidth operation */
+	if((!rtlpriv->bDriverStopped) && (!rtlpriv->bSurpriseRemoved)) {
+		struct rtl_hal *rtlhal = rtl_hal(rtlpriv);
+
+		/* DBG_871X("phy_SwChnlAndSetBwMode8812(): bSwChnl %d, bSetChnlBW %d \n", bSwChnl, bSetChnlBW); */
+
+		if ((rtlpriv->bDriverStopped) || (rtlpriv->bSurpriseRemoved)) {
+			return;
+		}
+
+		if (bSwChnl) {
+			rtl8821au_phy_sw_chnl_callback(rtlpriv);
+			bSwChnl = false;
+		}
+
+		if (bSetChnlBW) {
+			rtlpriv->cfg->ops->phy_set_bw_mode_callback(rtlpriv);
+			bSetChnlBW = false;
+		}
+
+		rtl8821au_dm_clean_txpower_tracking_state(rtlpriv);
+		PHY_SetTxPowerLevel8812(rtlpriv, rtlpriv->phy.current_channel);
+
+		if ((rtlpriv->phy.need_iqk = false == true)) {
+			if(IS_HARDWARE_TYPE_8812(rtlhal))
+				rtl8812au_phy_iq_calibrate(rtlpriv, false);
+			else if(IS_HARDWARE_TYPE_8821(rtlhal))
+				rtl8821au_phy_iq_calibrate(rtlpriv, false);
+
+			rtlpriv->phy.need_iqk = false;
+		}
+	} else {
+		if(bSwChnl) {
+			rtlpriv->phy.current_channel = tmpChannel;
+		}
+		if(bSetChnlBW) {
+			rtlpriv->phy.current_chan_bw = tmpBW;
+			mac->cur_40_prime_sc = tmpnCur40MhzPrimeSC;
+			mac->cur_80_prime_sc = tmpnCur80MhzPrimeSC;
+		}
+	}
+
+	/*
+	 * DBG_871X("Channel %d ChannelBW %d ",pHalData->CurrentChannel, pHalData->CurrentChannelBW);
+	 * DBG_871X("40MhzPrimeSC %d 80MhzPrimeSC %d ",pHalData->nCur40MhzPrimeSC, pHalData->nCur80MhzPrimeSC);
+	 * DBG_871X("CenterFrequencyIndex1 %d \n",pHalData->CurrentCenterFrequencyIndex1);
+	 */
+
+	/*
+	 * DBG_871X("<= PHY_HandleSwChnlAndSetBW8812: bSwChnl %d, bSetChnlBW %d \n",bSwChnl,bSetChnlBW);
+	 */
+
+}
+
+void PHY_SetBWMode8812(struct rtl_priv *rtlpriv,
+	enum CHANNEL_WIDTH	Bandwidth,	/* 20M or 40M */
+	uint8_t	Offset)		/* Upper, Lower, or Don't care */
+{
+	/* DBG_871X("%s()===>\n",__FUNCTION__); */
+
+	PHY_HandleSwChnlAndSetBW8812(rtlpriv, false, true, rtlpriv->phy.current_channel, Bandwidth, Offset, Offset, rtlpriv->phy.current_channel);
+
+	//DBG_871X("<==%s()\n",__FUNCTION__);
+}
+
+void PHY_SwChnl8812(struct rtl_priv *rtlpriv, uint8_t channel)
+{
+	/* DBG_871X("%s()===>\n",__FUNCTION__); */
+
+	PHY_HandleSwChnlAndSetBW8812(rtlpriv, true, false, channel, 0, 0, 0, channel);
+
+	/* DBG_871X("<==%s()\n",__FUNCTION__); */
+}
+
+void PHY_SetSwChnlBWMode8812(struct rtl_priv *rtlpriv, uint8_t channel,
+	enum CHANNEL_WIDTH Bandwidth, uint8_t Offset40, uint8_t Offset80)
+{
+	/* DBG_871X("%s()===>\n",__FUNCTION__); */
+
+	PHY_HandleSwChnlAndSetBW8812(rtlpriv, true, true, channel, Bandwidth, Offset40, Offset80, channel);
+
+	/* DBG_871X("<==%s()\n",__FUNCTION__); */
+}
+
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/hal/rtl8812au_recv.c linux-4.9.8821au/drivers/staging/rtl8821au/hal/rtl8812au_recv.c
--- linux-4.9/drivers/staging/rtl8821au/hal/rtl8812au_recv.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/hal/rtl8812au_recv.c	2016-12-11 19:48:25.170311727 -0600
@@ -0,0 +1,135 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#define _RTL8812AU_RECV_C_
+
+#include <drv_types.h>
+#include <rtl8812a_hal.h>
+
+int	rtl8812au_init_recv_priv(struct rtl_priv *rtlpriv)
+{
+	struct recv_priv	*precvpriv = &rtlpriv->recvpriv;
+	int	i, res = _SUCCESS;
+	struct recv_buf *precvbuf;
+
+	tasklet_init(&precvpriv->recv_tasklet,
+	     (void(*)(unsigned long))rtl8812au_recv_tasklet,
+	     (unsigned long)rtlpriv);
+
+	/* init recv_buf */
+	_rtw_init_queue(&precvpriv->free_recv_buf_queue);
+
+	precvpriv->pallocated_recv_buf = rtw_zmalloc(NR_RECVBUFF * sizeof(struct recv_buf) + 4);
+	if (precvpriv->pallocated_recv_buf == NULL) {
+		res = _FAIL;
+		goto exit;
+	}
+	memset(precvpriv->pallocated_recv_buf, 0, NR_RECVBUFF * sizeof(struct recv_buf) + 4);
+
+	precvpriv->precv_buf = (uint8_t *) N_BYTE_ALIGMENT((__kernel_size_t)(precvpriv->pallocated_recv_buf), 4);
+	/*
+	 * precvpriv->precv_buf = precvpriv->pallocated_recv_buf + 4 -
+	 * 	((uint) (precvpriv->pallocated_recv_buf) &(4-1));
+	*/
+
+
+	precvbuf = (struct recv_buf *) precvpriv->precv_buf;
+
+	for (i = 0; i < NR_RECVBUFF; i++) {
+		INIT_LIST_HEAD(&precvbuf->list);
+
+		spin_lock_init(&precvbuf->recvbuf_lock);
+
+		precvbuf->alloc_sz = MAX_RECVBUF_SZ;
+
+		res = rtw_os_recvbuf_resource_alloc(rtlpriv, precvbuf);
+		if (res == _FAIL)
+			break;
+
+		precvbuf->ref_cnt = 0;
+		precvbuf->rtlpriv = rtlpriv;
+
+		/* list_add_tail(&precvbuf->list, &(precvpriv->free_recv_buf_queue.queue)); */
+
+		precvbuf++;
+
+	}
+
+	precvpriv->free_recv_buf_queue_cnt = NR_RECVBUFF;
+
+	skb_queue_head_init(&precvpriv->rx_skb_queue);
+
+	{
+		int i;
+		__kernel_size_t tmpaddr = 0;
+		__kernel_size_t alignment = 0;
+		struct sk_buff *skb = NULL;
+
+		skb_queue_head_init(&precvpriv->free_recv_skb_queue);
+
+		for (i = 0; i < NR_PREALLOC_RECV_SKB; i++) {
+
+			skb = __netdev_alloc_skb(rtlpriv->ndev, MAX_RECVBUF_SZ + RECVBUFF_ALIGN_SZ, GFP_KERNEL);
+
+			if (skb) {
+				skb->dev = rtlpriv->ndev;
+
+				tmpaddr = (__kernel_size_t) skb->data;
+				alignment = tmpaddr & (RECVBUFF_ALIGN_SZ-1);
+				skb_reserve(skb, (RECVBUFF_ALIGN_SZ - alignment));
+				skb_queue_tail(&precvpriv->free_recv_skb_queue, skb);
+			}
+
+		}
+	}
+
+exit:
+	return res;
+}
+
+void rtl8812au_free_recv_priv (struct rtl_priv *rtlpriv)
+{
+	int	i;
+	struct recv_buf	*precvbuf;
+	struct recv_priv	*precvpriv = &rtlpriv->recvpriv;
+
+	precvbuf = (struct recv_buf *)precvpriv->precv_buf;
+
+	for (i = 0; i < NR_RECVBUFF ; i++) {
+		rtw_os_recvbuf_resource_free(rtlpriv, precvbuf);
+		precvbuf++;
+	}
+
+	if (precvpriv->pallocated_recv_buf)
+		rtw_mfree(precvpriv->pallocated_recv_buf);
+
+	if (skb_queue_len(&precvpriv->rx_skb_queue)) {
+		RT_TRACE(rtlpriv, COMP_ERR, DBG_LOUD, "rx_skb_queue not empty\n");
+	}
+
+	skb_queue_purge(&precvpriv->rx_skb_queue);
+
+	if (skb_queue_len(&precvpriv->free_recv_skb_queue)) {
+		RT_TRACE(rtlpriv, COMP_ERR, DBG_LOUD, "free_recv_skb_queue not empty, %d\n", skb_queue_len(&precvpriv->free_recv_skb_queue));
+	}
+
+	skb_queue_purge(&precvpriv->free_recv_skb_queue);
+}
+
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/include/autoconf.h linux-4.9.8821au/drivers/staging/rtl8821au/include/autoconf.h
--- linux-4.9/drivers/staging/rtl8821au/include/autoconf.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/include/autoconf.h	2016-12-11 19:48:25.170311727 -0600
@@ -0,0 +1,58 @@
+//***** temporarily flag *******
+//for FPGA VERIFICATION config
+
+//***** temporarily flag *******
+/*
+ * Public  General Config
+ */
+#define DRV_NAME "rtl8821au"
+
+//#define CONFIG_IOCTL_CFG80211 1
+
+/*
+ * Internal  General Config
+ */
+//#define CONFIG_PWRCTRL
+
+#define CONFIG_RECV_REORDERING_CTRL	1
+
+#define CONFIG_DFS	1
+#define CONFIG_AP_MODE	1
+#define CONFIG_SKB_COPY	1//for amsdu
+#define CONFIG_NEW_SIGNAL_STAT_PROCESS
+#define CONFIG_TX_MCAST2UNI	1	// Support IP multicast->unicast
+
+/*
+ * Interface  Related Config
+ */
+
+/*
+ * CONFIG_USE_USB_BUFFER_ALLOC_XX uses Linux USB Buffer alloc API and is for Linux platform only now!
+ */
+
+#define CONFIG_USB_VENDOR_REQ_BUFFER_PREALLOC
+
+#define CONFIG_USB_VENDOR_REQ_MUTEX
+#define CONFIG_VENDOR_REQ_RETRY
+
+#define RTL8812A_RX_PACKET_INCLUDE_CRC	0
+
+#define ENABLE_USB_DROP_INCORRECT_OUT	0
+
+/* ULLI symbol used in usb_halinit.c */
+#define RTL8192CU_ADHOC_WORKAROUND_SETTING	1
+
+#define ENABLE_NEW_RFE_TYPE	0
+
+/*
+ * Outsource  Related Config
+ */
+
+#define RATE_ADAPTIVE_SUPPORT 		0
+
+#define	RTL8188E_EARLY_MODE_PKT_NUM_10	0
+
+#define CONFIG_80211D
+
+#define CONFIG_ATTEMPT_TO_FIX_AP_BEACON_ERROR
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/include/basic_types.h linux-4.9.8821au/drivers/staging/rtl8821au/include/basic_types.h
--- linux-4.9/drivers/staging/rtl8821au/include/basic_types.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/include/basic_types.h	2016-12-11 19:48:25.170311727 -0600
@@ -0,0 +1,48 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __BASIC_TYPES_H__
+#define __BASIC_TYPES_H__
+
+
+#define SUCCESS	0
+#define FAIL	(-1)
+
+	/* ULLI : the w*nd*ws hell */
+
+	#include <linux/types.h>
+
+//        #define UCHAR u8
+
+	typedef 	__kernel_size_t	SIZE_T;
+	typedef	__kernel_ssize_t	SSIZE_T;
+	#define FIELD_OFFSET(s,field)	((SSIZE_T)&((s*)(0))->field)
+
+
+#define MEM_ALIGNMENT_OFFSET	(sizeof (SIZE_T))
+#define MEM_ALIGNMENT_PADDING	(sizeof(SIZE_T) - 1)
+
+#define SIZE_PTR SIZE_T
+#define SSIZE_PTR SSIZE_T
+
+// Get the N-bytes aligment offset from the current length
+#define N_BYTE_ALIGMENT(__Value, __Aligment) ((__Aligment == 1) ? (__Value) : (((__Value + __Aligment - 1) / __Aligment) * __Aligment))
+
+#endif //__BASIC_TYPES_H__
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/include/drv_conf.h linux-4.9.8821au/drivers/staging/rtl8821au/include/drv_conf.h
--- linux-4.9/drivers/staging/rtl8821au/include/drv_conf.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/include/drv_conf.h	2016-12-11 19:48:25.170311727 -0600
@@ -0,0 +1,38 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __DRV_CONF_H__
+#define __DRV_CONF_H__
+#include "autoconf.h"
+
+//About USB VENDOR REQ
+#if defined(CONFIG_USB_VENDOR_REQ_BUFFER_PREALLOC) && !defined(CONFIG_USB_VENDOR_REQ_MUTEX)
+	#warning "define CONFIG_USB_VENDOR_REQ_MUTEX for CONFIG_USB_VENDOR_REQ_BUFFER_PREALLOC automatically"
+	#define CONFIG_USB_VENDOR_REQ_MUTEX
+#endif
+#if defined(CONFIG_VENDOR_REQ_RETRY) &&  !defined(CONFIG_USB_VENDOR_REQ_MUTEX)
+	#warning "define CONFIG_USB_VENDOR_REQ_MUTEX for CONFIG_VENDOR_REQ_RETRY automatically"
+	#define CONFIG_USB_VENDOR_REQ_MUTEX
+#endif
+
+
+//#include <rtl871x_byteorder.h>
+
+#endif // __DRV_CONF_H__
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/include/drv_types.h linux-4.9.8821au/drivers/staging/rtl8821au/include/drv_types.h
--- linux-4.9/drivers/staging/rtl8821au/include/drv_types.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/include/drv_types.h	2016-12-11 19:48:25.170311727 -0600
@@ -0,0 +1,133 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+/*-------------------------------------------------------------------------------
+
+	For type defines and data structure defines
+
+--------------------------------------------------------------------------------*/
+
+
+#ifndef __DRV_TYPES_H__
+#define __DRV_TYPES_H__
+
+#include <drv_conf.h>
+#include <basic_types.h>
+#include <osdep_service.h>
+#include <wlan_bssdef.h>
+#include <wifi.h>
+#include <ieee80211.h>
+
+struct rtl_priv;
+
+#include <rtw_recv.h>
+#include <rtw_security.h>
+#include <rtw_xmit.h>
+#include <recv_osdep.h>
+#include <../rtl8821au/led.h>			/* Cureently here needed */
+#include <hal_intf.h>
+#include <hal_com.h>
+#include <rtw_qos.h>
+#include <rtw_pwrctrl.h>
+#include <rtw_mlme.h>
+#include <mlme_osdep.h>
+#include <rtw_ioctl.h>
+#include <rtw_ioctl_set.h>
+#include <osdep_intf.h>
+#include <rtw_eeprom.h>
+#include <sta_info.h>
+#include <rtw_event.h>
+#include <rtw_mlme_ext.h>
+// #include <rtw_efuse.h>
+
+#include <ethernet.h>
+
+#define SPEC_DEV_ID_NONE BIT(0)
+#define SPEC_DEV_ID_DISABLE_HT BIT(1)
+#define SPEC_DEV_ID_ENABLE_PS BIT(2)
+#define SPEC_DEV_ID_RF_CONFIG_1T1R BIT(3)
+#define SPEC_DEV_ID_RF_CONFIG_2T2R BIT(4)
+#define SPEC_DEV_ID_ASSIGN_IFNAME BIT(5)
+
+struct specific_device_id{
+
+	u32		flags;
+
+	u16		idVendor;
+	u16		idProduct;
+
+};
+
+struct registry_priv
+{
+	NDIS_802_11_SSID	ssid;
+	uint8_t	channel;//ad-hoc support requirement
+	uint8_t	preamble;//long, short, auto
+	u16	rts_thresh;
+	uint8_t	adhoc_tx_pwr;
+	uint8_t	soft_ap;
+	uint8_t	power_mgnt;
+	uint8_t	smart_ps;
+	uint8_t	long_retry_lmt;
+	uint8_t	short_retry_lmt;
+	u16	busy_thresh;
+	uint8_t	ack_policy;
+	uint8_t	acm_method;
+	  //UAPSD
+	uint8_t	wmm_enable;
+	uint8_t	uapsd_enable;
+
+	WLAN_BSSID_EX    dev_network;
+
+	// 0: 20 MHz, 1: 40 MHz, 2: 80 MHz, 3: 160MHz
+	// 2.4G use bit 0 ~ 3, 5G use bit 4 ~ 7
+	// 0x21 means enable 2.4G 40MHz & 5G 80MHz
+	uint8_t 	rx_stbc;
+	uint8_t	ampdu_amsdu;//A-MPDU Supports A-MSDU is permitted
+	// Short GI support Bit Map
+	// BIT(0) - 20MHz, 1: support, 0: non-support
+	// BIT(1) - 40MHz, 1: support, 0: non-support
+	// BIT(2) - 80MHz, 1: support, 0: non-support
+	// BIT(3) - 160MHz, 1: support, 0: non-support
+
+	// BIT(0): Enable VHT LDPC Rx, BIT(1): Enable VHT LDPC Tx, BIT(4): Enable HT LDPC Rx, BIT(5): Enable HT LDPC Tx
+	// BIT(0): Enable VHT STBC Rx, BIT(1): Enable VHT STBC Tx, BIT(4): Enable HT STBC Rx, BIT(5): Enable HT STBC Tx
+	// BIT(0): Enable VHT Beamformer, BIT(1): Enable VHT Beamformee, BIT(4): Enable HT Beamformer, BIT(5): Enable HT Beamformee
+	uint8_t	beamform_cap;
+
+	uint8_t	low_power ;
+
+	bool	bAcceptAddbaReq;
+
+	uint8_t	usbss_enable;//0:disable,1:enable
+	uint8_t	hwpdn_mode;//0:disable,1:enable,2:decide by EFUSE config
+	uint8_t	hwpwrp_detect;//0:disable,1:enable
+
+	uint8_t	hw_wps_pbc;//0:disable,1:enable
+};
+
+
+//For registry parameters
+#define MAX_CONTINUAL_URB_ERR 4
+
+
+#include "../wifi.h"
+
+#endif //__DRV_TYPES_H__
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/include/ethernet.h linux-4.9.8821au/drivers/staging/rtl8821au/include/ethernet.h
--- linux-4.9/drivers/staging/rtl8821au/include/ethernet.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/include/ethernet.h	2016-12-11 19:48:25.170311727 -0600
@@ -0,0 +1,42 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+/*! \file */
+#ifndef __INC_ETHERNET_H
+#define __INC_ETHERNET_H
+
+#define ETHERNET_ADDRESS_LENGTH				6		//!< Ethernet Address Length
+#define ETHERNET_HEADER_SIZE				14		//!< Ethernet Header Length
+#define LLC_HEADER_SIZE						6		//!< LLC Header Length
+#define TYPE_LENGTH_FIELD_SIZE				2		//!< Type/Length Size
+#define MINIMUM_ETHERNET_PACKET_SIZE		60		//!< Minimum Ethernet Packet Size
+#define MAXIMUM_ETHERNET_PACKET_SIZE		1514	//!< Maximum Ethernet Packet Size
+
+#define RT_ETH_IS_MULTICAST(_pAddr)	((((UCHAR *)(_pAddr))[0]&0x01)!=0)		//!< Is Multicast Address?
+#define RT_ETH_IS_BROADCAST(_pAddr)	(										\
+											((UCHAR *)(_pAddr))[0]==0xff	&& 		\
+											((UCHAR *)(_pAddr))[1]==0xff	&&		\
+											((UCHAR *)(_pAddr))[2]==0xff	&&		\
+											((UCHAR *)(_pAddr))[3]==0xff	&&		\
+											((UCHAR *)(_pAddr))[4]==0xff	&&		\
+											((UCHAR *)(_pAddr))[5]==0xff		)	//!< Is Broadcast Address?
+
+
+#endif // #ifndef __INC_ETHERNET_H
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/include/h2clbk.h linux-4.9.8821au/drivers/staging/rtl8821au/include/h2clbk.h
--- linux-4.9/drivers/staging/rtl8821au/include/h2clbk.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/include/h2clbk.h	2016-12-11 19:48:25.170311727 -0600
@@ -0,0 +1,32 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+
+#define _H2CLBK_H_
+
+
+void _lbk_cmd(struct rtl_priv *rtlpriv);
+
+void _lbk_rsp(struct rtl_priv *rtlpriv);
+
+void _lbk_evt(IN struct rtl_priv *rtlpriv);
+
+void h2c_event_callback(unsigned char *dev, unsigned char *pbuf);
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/include/Hal8812PhyCfg.h linux-4.9.8821au/drivers/staging/rtl8821au/include/Hal8812PhyCfg.h
--- linux-4.9/drivers/staging/rtl8821au/include/Hal8812PhyCfg.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/include/Hal8812PhyCfg.h	2016-12-11 19:48:25.170311727 -0600
@@ -0,0 +1,91 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __INC_HAL8812PHYCFG_H__
+#define __INC_HAL8812PHYCFG_H__
+
+
+/*--------------------------Define Parameters-------------------------------*/
+#define LOOP_LIMIT				5
+#define MAX_STALL_TIME			50		//us
+#define AntennaDiversityValue	0x80	//(rtlpriv->bSoftwareAntennaDiversity ? 0x00:0x80)
+#define MAX_TXPWR_IDX_NMODE_92S	63
+#define Reset_Cnt_Limit			3
+
+
+#define MAX_AGGR_NUM	0x07
+
+
+/*--------------------------Define Parameters-------------------------------*/
+
+/*------------------------------Define structure----------------------------*/
+
+
+/* BB/RF related */
+
+/*------------------------------Define structure----------------------------*/
+
+
+/*------------------------Export global variable----------------------------*/
+/*------------------------Export global variable----------------------------*/
+
+
+/*------------------------Export Marco Definition---------------------------*/
+/*------------------------Export Marco Definition---------------------------*/
+
+
+/*--------------------------Exported Function prototype---------------------*/
+//
+// BB and RF register read/write
+//
+//
+// Initialization related function
+//
+/* MAC/BB/RF HAL config */
+
+/* RF config */
+
+//
+// BB TX Power R/W
+//
+
+u32 PHY_GetTxBBSwing_8812A(struct rtl_priv *rtlpriv, enum band_type Band, uint8_t RFPath);
+
+//
+// Switch bandwidth for 8192S
+//
+void PHY_SetBWMode8812(struct rtl_priv *rtlpriv, enum CHANNEL_WIDTH Bandwidth,
+	uint8_t Offset);
+
+//
+// channel switch related funciton
+//
+void PHY_SwChnl8812(struct rtl_priv *rtlpriv, uint8_t channel);
+
+void PHY_SetSwChnlBWMode8812(struct rtl_priv *rtlpriv, uint8_t channel,
+	enum CHANNEL_WIDTH Bandwidth, uint8_t Offset40, uint8_t	Offset80);
+
+//
+// BB/MAC/RF other monitor API
+//
+
+
+/*--------------------------Exported Function prototype---------------------*/
+#endif	// __INC_HAL8192CPHYCFG_H
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/include/Hal8812PhyReg.h linux-4.9.8821au/drivers/staging/rtl8821au/include/Hal8812PhyReg.h
--- linux-4.9/drivers/staging/rtl8821au/include/Hal8812PhyReg.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/include/Hal8812PhyReg.h	2016-12-11 19:48:25.170311727 -0600
@@ -0,0 +1,381 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __INC_HAL8812PHYREG_H__
+#define __INC_HAL8812PHYREG_H__
+/*--------------------------Define Parameters-------------------------------*/
+//
+// BB-PHY register PMAC 0x100 PHY 0x800 - 0xEFF
+// 1. PMAC duplicate register due to connection: RF_Mode, TRxRN, NumOf L-STF
+// 2. 0x800/0x900/0xA00/0xC00/0xD00/0xE00
+// 3. RF register 0x00-2E
+// 4. Bit Mask for BB/RF register
+// 5. Other defintion for BB/RF R/W
+//
+
+
+// BB Register Definition
+
+#define rCCAonSec_Jaguar		0x838
+
+// BW and sideband setting
+#define rBWIndication_Jaguar		0x834
+#define rL1PeakTH_Jaguar		0x848
+#define rRFMOD_Jaguar			0x8ac	//RF mode 
+#define rADC_Buf_Clk_Jaguar		0x8c4
+#define rRFECTRL_Jaguar			0x900
+#define bRFMOD_Jaguar			0xc3
+#define rCCK_System_Jaguar		0xa00   // for cck sideband
+#define bCCK_System_Jaguar		0x10
+
+// Block & Path enable
+#define rOFDMCCKEN_Jaguar 		0x808 // OFDM/CCK block enable
+#define bOFDMEN_Jaguar			0x20000000
+#define bCCKEN_Jaguar			0x10000000
+#define rRxPath_Jaguar			0x808	// Rx antenna
+#define bRxPath_Jaguar			0xff
+#define rTxPath_Jaguar			0x80c	// Tx antenna
+#define bTxPath_Jaguar			0x0fffffff
+#define rCCK_RX_Jaguar			0xa04	// for cck rx path selection
+#define bCCK_RX_Jaguar			0x0c000000 
+#define rVhtlen_Use_Lsig_Jaguar	0x8c3	// Use LSIG for VHT length
+
+// RF read/write-related
+#define rHSSIRead_Jaguar			0x8b0  // RF read addr
+#define bHSSIRead_addr_Jaguar		0xff
+#define bHSSIRead_trigger_Jaguar	0x100
+#define rA_PIRead_Jaguar			0xd04 // RF readback with PI
+#define rB_PIRead_Jaguar			0xd44 // RF readback with PI
+#define rA_SIRead_Jaguar			0xd08 // RF readback with SI
+#define rB_SIRead_Jaguar			0xd48 // RF readback with SI
+#define rRead_data_Jaguar			0xfffff
+#define rA_LSSIWrite_Jaguar			0xc90 // RF write addr
+#define rB_LSSIWrite_Jaguar			0xe90 // RF write addr
+#define bLSSIWrite_data_Jaguar		0x000fffff
+#define bLSSIWrite_addr_Jaguar		0x0ff00000
+
+
+
+// YN: mask the following register definition temporarily 
+#define rFPGA0_XA_RFInterfaceOE			0x860	// RF Channel switch
+#define rFPGA0_XB_RFInterfaceOE			0x864
+
+#define rFPGA0_XAB_RFInterfaceSW		0x870	// RF Interface Software Control
+#define rFPGA0_XCD_RFInterfaceSW		0x874
+
+//#define RFPGA0_XAB_RFPARAMETER		0x878	// RF Parameter
+//#define RFPGA0_XCD_RFPARAMETER		0x87c
+
+//#define RFPGA0_ANALOGPARAMETER1		0x880	// Crystal cap setting RF-R/W protection for parameter4??
+//#define RFPGA0_ANALOGPARAMETER2		0x884
+//#define RFPGA0_ANALOGPARAMETER3		0x888
+//#define rFPGA0_AdDaClockEn			0x888	// enable ad/da clock1 for dual-phy
+//#define RFPGA0_ANALOGPARAMETER4		0x88c
+
+
+// CCK TX scaling
+#define rCCK_TxFilter1_Jaguar		0xa20
+#define bCCK_TxFilter1_C0_Jaguar   	0x00ff0000
+#define bCCK_TxFilter1_C1_Jaguar		0xff000000
+#define rCCK_TxFilter2_Jaguar		0xa24
+#define bCCK_TxFilter2_C2_Jaguar		0x000000ff
+#define bCCK_TxFilter2_C3_Jaguar		0x0000ff00
+#define bCCK_TxFilter2_C4_Jaguar		0x00ff0000
+#define bCCK_TxFilter2_C5_Jaguar		0xff000000
+#define rCCK_TxFilter3_Jaguar		0xa28
+#define bCCK_TxFilter3_C6_Jaguar		0x000000ff
+#define bCCK_TxFilter3_C7_Jaguar		0x0000ff00
+
+
+// YN: mask the following register definition temporarily
+//#define RPDP_ANTA      					0xb00  
+//#define RPDP_ANTA_4    				0xb04
+//#define rConfig_Pmpd_AntA 			0xb28
+//#define rConfig_AntA 					0xb68
+//#define rConfig_AntB 					0xb6c
+//#define RPDP_ANTB 					0xb70
+//#define RPDP_ANTB_4 					0xb74
+//#define rConfig_Pmpd_AntB			0xb98
+//#define rAPK							0xbd8
+
+
+
+// DIG-related
+#define rA_IGI_Jaguar				0xc50	// Initial Gain for path-A
+#define rB_IGI_Jaguar				0xe50	// Initial Gain for path-B
+#define rOFDM_FalseAlarm1_Jaguar	0xf48  // counter for break
+#define rOFDM_FalseAlarm2_Jaguar	0xf4c  // counter for spoofing
+#define rCCK_FalseAlarm_Jaguar        	0xa5c // counter for cck false alarm
+#define b_FalseAlarm_Jaguar			0xffff
+#define rCCK_CCA_Jaguar				0xa08	// cca threshold
+#define bCCK_CCA_Jaguar				0x00ff0000
+
+// Tx Power Ttraining-related
+#define rA_TxPwrTraing_Jaguar		0xc54
+#define rB_TxPwrTraing_Jaguar		0xe54
+
+// Report-related
+#define rOFDM_ShortCFOAB_Jaguar	0xf60  
+#define rOFDM_LongCFOAB_Jaguar		0xf64
+#define rOFDM_EndCFOAB_Jaguar		0xf70
+#define rOFDM_AGCReport_Jaguar		0xf84
+#define rOFDM_RxSNR_Jaguar			0xf88
+#define rOFDM_RxEVMCSI_Jaguar		0xf8c
+#define rOFDM_SIGReport_Jaguar		0xf90
+
+
+// RFE
+#define rA_RFE_Pinmux_Jaguar	0xcb0  // Path_A RFE cotrol pinmux
+#define rB_RFE_Pinmux_Jaguar	0xeb0 // Path_B RFE control pinmux
+#define rA_RFE_Inv_Jaguar		0xcb4  // Path_A RFE cotrol   
+#define rB_RFE_Inv_Jaguar		0xeb4 // Path_B RFE control
+#define rA_RFE_Jaguar			0xcb8  // Path_A RFE cotrol   
+#define rB_RFE_Jaguar			0xeb8 // Path_B RFE control
+#define r_ANTSEL_SW_Jaguar		0x900 // ANTSEL SW Control
+#define bMask_RFEInv_Jaguar		0x3ff00000
+#define bMask_AntselPathFollow_Jaguar 0x00030000
+
+// IQK YN: temporaily mask this part
+//#define rFPGA0_IQK					0xe28
+//#define rTx_IQK_Tone_A				0xe30
+//#define rRx_IQK_Tone_A				0xe34
+//#define rTx_IQK_PI_A					0xe38
+//#define rRx_IQK_PI_A					0xe3c
+
+//#define rTx_IQK 						0xe40
+//#define rRx_IQK						0xe44
+//#define rIQK_AGC_Pts					0xe48
+//#define rIQK_AGC_Rsp					0xe4c
+//#define rTx_IQK_Tone_B				0xe50
+//#define rRx_IQK_Tone_B				0xe54
+//#define rTx_IQK_PI_B					0xe58
+//#define rRx_IQK_PI_B					0xe5c
+//#define rIQK_AGC_Cont				0xe60
+
+
+//
+//Bit Mask
+//
+// 1. Page1(0x100)
+#define bBBResetB					0x100	// Useless now?
+#define bGlobalResetB				0x200
+#define bOFDMTxStart				0x4
+#define bCCKTxStart					0x8
+#define bCRC32Debug					0x100
+#define bPMACLoopback				0x10
+#define bTxLSIG						0xffffff
+#define bOFDMTxRate					0xf
+#define bOFDMTxReserved			0x10
+#define bOFDMTxLength				0x1ffe0
+#define bOFDMTxParity				0x20000
+#define bTxHTSIG1					0xffffff
+#define bTxHTMCSRate				0x7f
+#define bTxHTBW						0x80
+#define bTxHTLength					0xffff00
+#define bTxHTSIG2					0xffffff
+#define bTxHTSmoothing				0x1
+#define bTxHTSounding				0x2
+#define bTxHTReserved				0x4
+#define bTxHTAggreation				0x8
+#define bTxHTSTBC					0x30
+#define bTxHTAdvanceCoding			0x40
+#define bTxHTShortGI					0x80
+#define bTxHTNumberHT_LTF			0x300
+#define bTxHTCRC8					0x3fc00
+#define bCounterReset				0x10000
+#define bNumOfOFDMTx				0xffff
+#define bNumOfCCKTx					0xffff0000
+#define bTxIdleInterval				0xffff
+#define bOFDMService				0xffff0000
+#define bTxMACHeader				0xffffffff
+#define bTxDataInit					0xff
+#define bTxHTMode					0x100
+#define bTxDataType					0x30000
+#define bTxRandomSeed				0xffffffff
+#define bCCKTxPreamble				0x1
+#define bCCKTxSFD					0xffff0000
+#define bCCKTxSIG					0xff
+#define bCCKTxService				0xff00
+#define bCCKLengthExt				0x8000
+#define bCCKTxLength				0xffff0000
+#define bCCKTxCRC16					0xffff
+#define bCCKTxStatus					0x1
+#define bOFDMTxStatus				0x2
+
+
+//
+// 1. PMAC duplicate register due to connection: RF_Mode, TRxRN, NumOf L-STF
+// 1. Page1(0x100)
+//
+#define rPMAC_Reset					0x100
+#define rPMAC_TxStart				0x104
+#define rPMAC_TxLegacySIG			0x108
+#define rPMAC_TxHTSIG1				0x10c
+#define rPMAC_TxHTSIG2				0x110
+#define rPMAC_PHYDebug				0x114
+#define rPMAC_TxPacketNum			0x118
+#define rPMAC_TxIdle					0x11c
+#define rPMAC_TxMACHeader0			0x120
+#define rPMAC_TxMACHeader1			0x124
+#define rPMAC_TxMACHeader2			0x128
+#define rPMAC_TxMACHeader3			0x12c
+#define rPMAC_TxMACHeader4			0x130
+#define rPMAC_TxMACHeader5			0x134
+#define rPMAC_TxDataType			0x138
+#define rPMAC_TxRandomSeed		0x13c
+#define rPMAC_CCKPLCPPreamble		0x140
+#define rPMAC_CCKPLCPHeader		0x144
+#define rPMAC_CCKCRC16				0x148
+#define rPMAC_OFDMRxCRC32OK		0x170
+#define rPMAC_OFDMRxCRC32Er		0x174
+#define rPMAC_OFDMRxParityEr		0x178
+#define rPMAC_OFDMRxCRC8Er			0x17c
+#define rPMAC_CCKCRxRC16Er			0x180
+#define rPMAC_CCKCRxRC32Er			0x184
+#define rPMAC_CCKCRxRC32OK			0x188
+#define rPMAC_TxStatus				0x18c
+
+
+
+
+
+// 2. Page8(0x800)
+#define bRFMOD						0x1	// Reg 0x800 RFPGA0_RFMOD
+#define bJapanMode					0x2
+#define bCCKTxSC					0x30
+#define bCCKEn						0x1000000
+#define bOFDMEn						0x2000000
+#define bXBTxAGC                  			0xf00	// Reg 80c rFPGA0_TxGainStage
+#define bXCTxAGC                  			0xf000
+#define bXDTxAGC                  			0xf0000
+
+// 4. PageA(0xA00)
+#define bCCKBBMode                			0x3	// Useless
+#define bCCKTxPowerSaving         		0x80
+#define bCCKRxPowerSaving         		0x40
+
+#define bCCKSideBand              		0x10	// Reg 0xa00 rCCK0_System 20/40 switch
+
+#define bCCKScramble              		0x8	// Useless
+#define bCCKAntDiversity    		      	0x8000
+#define bCCKCarrierRecovery   	    	0x4000
+#define bCCKTxRate           		     	0x3000
+#define bCCKDCCancel             	 		0x0800
+#define bCCKISICancel             			0x0400
+#define bCCKMatchFilter           		0x0200
+#define bCCKEqualizer             			0x0100
+#define bCCKPreambleDetect       	 	0x800000
+#define bCCKFastFalseCCA          		0x400000
+#define bCCKChEstStart            		0x300000
+#define bCCKCCACount              		0x080000
+#define bCCKcs_lim                			0x070000
+#define bCCKBistMode              			0x80000000
+#define bCCKCCAMask             	  		0x40000000
+#define bCCKTxDACPhase         	   	0x4
+#define bCCKRxADCPhase         	   	0x20000000   //r_rx_clk
+#define bCCKr_cp_mode0         	   	0x0100
+#define bCCKTxDCOffset           	 	0xf0
+#define bCCKRxDCOffset           	 	0xf
+#define bCCKCCAMode              	 		0xc000
+#define bCCKFalseCS_lim           		0x3f00
+#define bCCKCS_ratio              			0xc00000
+#define bCCKCorgBit_sel           		0x300000
+#define bCCKPD_lim                			0x0f0000
+#define bCCKNewCCA                		0x80000000
+#define bCCKRxHPofIG              		0x8000
+#define bCCKRxIG                  			0x7f00
+#define bCCKLNAPolarity           		0x800000
+#define bCCKRx1stGain             		0x7f0000
+#define bCCKRFExtend              		0x20000000 //CCK Rx Iinital gain polarity
+#define bCCKRxAGCSatLevel        	 	0x1f000000
+#define bCCKRxAGCSatCount       	  	0xe0
+#define bCCKRxRFSettle            		0x1f       //AGCsamp_dly
+#define bCCKFixedRxAGC           	 	0x8000
+//#define bCCKRxAGCFormat         	 	0x4000   //remove to HSSI register 0x824
+#define bCCKAntennaPolarity      	 	0x2000
+#define bCCKTxFilterType          		0x0c00
+#define bCCKRxAGCReportType   	   	0x0300
+#define bCCKRxDAGCEn              		0x80000000
+#define bCCKRxDAGCPeriod        	  	0x20000000
+#define bCCKRxDAGCSatLevel     	   	0x1f000000
+#define bCCKTimingRecovery       	 	0x800000
+#define bCCKTxC0                  			0x3f0000
+#define bCCKTxC1                  			0x3f000000
+#define bCCKTxC2                  			0x3f
+#define bCCKTxC3                  			0x3f00
+#define bCCKTxC4                  			0x3f0000
+#define bCCKTxC5                  			0x3f000000
+#define bCCKTxC6                  			0x3f
+#define bCCKTxC7                  			0x3f00
+#define bCCKDebugPort             		0xff0000
+#define bCCKDACDebug              		0x0f000000
+#define bCCKFalseAlarmEnable      		0x8000
+#define bCCKFalseAlarmRead        		0x4000
+#define bCCKTRSSI                 			0x7f
+#define bCCKRxAGCReport           		0xfe
+#define bCCKRxReport_AntSel       		0x80000000
+#define bCCKRxReport_MFOff        		0x40000000
+#define bCCKRxRxReport_SQLoss     	0x20000000
+#define bCCKRxReport_Pktloss      		0x10000000
+#define bCCKRxReport_Lockedbit    	0x08000000
+#define bCCKRxReport_RateError    	0x04000000
+#define bCCKRxReport_RxRate       		0x03000000
+#define bCCKRxFACounterLower      	0xff
+#define bCCKRxFACounterUpper      	0xff000000
+#define bCCKRxHPAGCStart          		0xe000
+#define bCCKRxHPAGCFinal          		0x1c00       		
+#define bCCKRxFalseAlarmEnable    	0x8000
+#define bCCKFACounterFreeze       		0x4000       		
+#define bCCKTxPathSel             		0x10000000
+#define bCCKDefaultRxPath         		0xc000000
+#define bCCKOptionRxPath          		0x3000000
+
+// 6. PageE(0xE00)
+#define bSTBCEn                  			0x4	// Useless
+#define bAntennaMapping          		0x10
+#define bNss                     				0x20
+#define bCFOAntSumD              		0x200
+#define bPHYCounterReset         		0x8000000
+#define bCFOReportGet            			0x4000000
+#define bOFDMContinueTx          		0x10000000
+#define bOFDMSingleCarrier       		0x20000000
+#define bOFDMSingleTone          		0x40000000
+
+
+//
+// Other Definition
+//
+
+#define bEnable                   0x1	// Useless
+#define bDisable                  0x0
+
+//byte endable for srwrite
+#define bByte0                    		0x1	// Useless
+#define bByte1                    		0x2
+#define bByte2                    		0x4
+#define bByte3                    		0x8
+#define bWord0                    		0x3
+#define bWord1                    		0xc
+#define bDWord                    		0xf
+
+/*--------------------------Define Parameters-------------------------------*/
+
+
+#endif
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/include/Hal8812PwrSeq.h linux-4.9.8821au/drivers/staging/rtl8821au/include/Hal8812PwrSeq.h
--- linux-4.9/drivers/staging/rtl8821au/include/Hal8812PwrSeq.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/include/Hal8812PwrSeq.h	2016-12-11 19:48:25.170311727 -0600
@@ -0,0 +1,210 @@
+
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+#ifndef __HAL8812PWRSEQ_H__
+#define __HAL8812PWRSEQ_H__
+
+#include "HalPwrSeqCmd.h"
+
+/* 
+	Check document WB-110628-DZ-RTL8195 (Jaguar) Power Architecture-R04.pdf
+	There are 6 HW Power States:
+	0: POFF--Power Off
+	1: PDN--Power Down
+	2: CARDEMU--Card Emulation
+	3: ACT--Active Mode
+	4: LPS--Low Power State
+	5: SUS--Suspend
+
+	The transision from different states are defined below
+	TRANS_CARDEMU_TO_ACT
+	TRANS_ACT_TO_CARDEMU
+	TRANS_CARDEMU_TO_SUS
+	TRANS_SUS_TO_CARDEMU
+	TRANS_CARDEMU_TO_PDN
+	TRANS_ACT_TO_LPS
+	TRANS_LPS_TO_ACT	
+
+	TRANS_END
+*/
+#define	RTL8812_TRANS_CARDEMU_TO_ACT_STEPS	15
+#define	RTL8812_TRANS_ACT_TO_CARDEMU_STEPS	15
+#define	RTL8812_TRANS_CARDEMU_TO_SUS_STEPS	15
+#define	RTL8812_TRANS_SUS_TO_CARDEMU_STEPS	15
+#define	RTL8812_TRANS_CARDEMU_TO_PDN_STEPS	15
+#define	RTL8812_TRANS_PDN_TO_CARDEMU_STEPS	15
+#define	RTL8812_TRANS_ACT_TO_LPS_STEPS	15
+#define	RTL8812_TRANS_LPS_TO_ACT_STEPS	15	
+#define	RTL8812_TRANS_END_STEPS	1
+
+
+#define RTL8812_TRANS_CARDEMU_TO_ACT 														\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT(2), 0},/* disable SW LPS 0x04[10]=0*/	\
+	{0x0006, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, BIT(1), BIT(1)},/* wait till 0x04[17] = 1    power ready*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT(7), 0},/* disable HWPDN 0x04[15]=0*/ \
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT(3), 0},/* disable WL suspend*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT(0), BIT(0)},/* polling until return 0*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, BIT(0), 0},/**/
+
+#define RTL8812_TRANS_ACT_TO_CARDEMU													\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0c00, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x04}, /* 0xc00[7:0] = 4	turn off 3-wire */	\
+	{0x0e00, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x04}, /* 0xe00[7:0] = 4	turn off 3-wire */	\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT(0), 0}, /* 0x2[0] = 0	 RESET BB, CLOSE RF */	\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_DELAY, 0, PWRSEQ_DELAY_US},/*Delay 1us*/	\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT(1), 0},  /* Whole BB is reset*/			\
+	/*{0x001F, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0},//0x1F[7:0] = 0 turn off RF*/	\
+	/*{0x004E, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT(7), 0},//0x4C[23] = 0x4E[7] = 0, switch DPDT_SEL_P output from register 0x65[2] */	\
+	{0x0007, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x28}, /* 0x07[7:0] = 0x28 sps pwm mode */	\
+	{0x0008, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0x02, 0},/*0x8[1] = 0 ANA clk =500k */	\
+	/*{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT(0)|BIT(1), 0}, //  0x02[1:0] = 0	reset BB */	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT(1), BIT(1)}, /*0x04[9] = 1 turn off MAC by HW state machine*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, BIT(1), 0}, /*wait till 0x04[9] = 0 polling until return 0 to disable*/	
+
+#define RTL8812_TRANS_CARDEMU_TO_SUS													\
+	/* format */								\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0042, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xF0, 0xcc},\
+	{0x0042, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xF0, 0xEC},\
+	{0x0043, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x07},/* gpio11 input mode, gpio10~8 output mode */	\
+	{0x0045, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x00},/* gpio 0~7 output same value as input ?? */	\
+	{0x0046, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0xff},/* gpio0~7 output mode */	\
+	{0x0047, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0},/* 0x47[7:0] = 00 gpio mode */	\
+	{0x0007, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0},/* suspend option all off */	\
+	{0x0014, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0x80, BIT(7)},/*0x14[7] = 1 turn on ZCD */	\
+	{0x0015, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0x01, BIT(0)},/* 0x15[0] =1 trun on ZCD */	\
+	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0x10, BIT(4)},/*0x23[4] = 1 hpon LDO sleep mode */	\
+	{0x0008, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0x02, 0},/*0x8[1] = 0 ANA clk =500k */	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT(3), BIT(3)}, /*0x04[11] = 2b'11 enable WL suspend for PCIe*/	
+
+#define RTL8812_TRANS_SUS_TO_CARDEMU													\
+	/* format */								\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT(3), 0}, /*0x04[11] = 2b'01enable WL suspend*/   \
+	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0x10, 0},/*0x23[4] = 0 hpon LDO sleep mode leave */	\
+	{0x0015, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0x01, 0},/* 0x15[0] =0 trun off ZCD */	\
+	{0x0014, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0x80, 0},/*0x14[7] = 0 turn off ZCD */	\
+	{0x0046, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x00},/* gpio0~7 input mode */	\
+	{0x0043, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x00},/* gpio11 input mode, gpio10~8 input mode */
+
+#define RTL8812_TRANS_CARDEMU_TO_CARDDIS													\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	/**{0x0194, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT(0), 0}, //0x194[0]=0 , disable 32K clock*/	\
+	/**{0x0093, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x94}, //0x93=0x94 , 90[30] =0 enable 500k ANA clock .switch clock from 12M to 500K , 90 [26] =0 disable EEprom loader clock*/	\
+	{0x0003, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT(2), 0}, /*0x03[2] = 0, reset 8051*/	\
+	{0x0080, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x05}, /*0x80=05h if reload fw, fill the default value of host_CPU handshake field*/	\
+	{0x0042, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xF0, 0xcc},\
+	{0x0042, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xF0, 0xEC},\
+	{0x0043, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x07},/* gpio11 input mode, gpio10~8 output mode */	\
+	{0x0045, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x00},/* gpio 0~7 output same value as input ?? */	\
+	{0x0046, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0xff},/* gpio0~7 output mode */	\
+	{0x0047, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0},/* 0x47[7:0] = 00 gpio mode */	\
+	{0x0014, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0x80, BIT(7)},/*0x14[7] = 1 turn on ZCD */	\
+	{0x0015, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0x01, BIT(0)},/* 0x15[0] =1 trun on ZCD */	\
+	{0x0012, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0x01, 0},/*0x12[0] = 0 force PFM mode */	\
+	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0x10, BIT(4)},/*0x23[4] = 1 hpon LDO sleep mode */	\
+	{0x0008, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0x02, 0},/*0x8[1] = 0 ANA clk =500k */	\
+	{0x0007, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x20}, /*0x07=0x20 , SOP option to disable BG/MB*/	\
+	{0x001f, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT(1), 0}, /*0x01f[1]=0 , disable RFC_0  control  REG_RF_CTRL_8812 */	\
+	{0x0076, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT(1), 0}, /*0x076[1]=0 , disable RFC_1  control REG_OPT_CTRL_8812 +2 */	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT(3), BIT(3)}, /*0x04[11] = 2b'01 enable WL suspend*/	
+
+#define RTL8812_TRANS_CARDDIS_TO_CARDEMU													\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/                       \
+	{0x0012, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT(0), BIT(0)},/*0x12[0] = 1 force PWM mode */	\
+	{0x0014, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0x80, 0},/*0x14[7] = 0 turn off ZCD */	\
+	{0x0015, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0x01, 0},/* 0x15[0] =0 trun off ZCD */	\
+	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0x10, 0},/*0x23[4] = 0 hpon LDO leave sleep mode */	\
+	{0x0046, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x00},/* gpio0~7 input mode */	\
+	{0x0043, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x00},/* gpio11 input mode, gpio10~8 input mode */ \
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT(2), 0}, /*0x04[10] = 0, enable SW LPS PCIE only*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT(3), 0}, /*0x04[11] = 2b'01enable WL suspend*/	\
+	{0x0003, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT(2), BIT(2)}, /*0x03[2] = 1, enable 8051*/	\
+	{0x0301, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0},/*PCIe DMA start*/
+
+
+#define RTL8812_TRANS_CARDEMU_TO_PDN												\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT(7), BIT(7)},/* 0x04[15] = 1*/
+
+#define RTL8812_TRANS_PDN_TO_CARDEMU												\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT(7), 0},/* 0x04[15] = 0*/
+
+#define RTL8812_TRANS_ACT_TO_LPS														\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0301, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0xFF},/*PCIe DMA stop*/	\
+	{0x0522, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x7F},/*Tx Pause*/		\
+	{0x05F8, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
+	{0x05F9, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
+	{0x05FA, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
+	{0x05FB, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
+	{0x0c00, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x04}, /* 0xc00[7:0] = 4	turn off 3-wire */	\
+	{0x0e00, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x04}, /* 0xe00[7:0] = 4	turn off 3-wire */	\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT(0), 0},/*CCK and OFDM are disabled,and clock are gated,and RF closed*/	\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_DELAY, 0, PWRSEQ_DELAY_US},/*Delay 1us*/	\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT(1), 0},  /* Whole BB is reset*/			\
+	{0x0100, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x03},/*Reset MAC TRX*/			\
+	{0x0101, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT(1), 0},/*check if removed later*/		\
+	{0x0553, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT(5), BIT(5)},/*Respond TxOK to scheduler*/	
+
+
+#define RTL8812_TRANS_LPS_TO_ACT															\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/	\
+	{0x0080, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_WRITE, 0xFF, 0x84}, /*SDIO RPWM*/	\
+	{0xFE58, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x84}, /*USB RPWM*/	\
+	{0x0361, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x84}, /*PCIe RPWM*/	\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_DELAY, 0, PWRSEQ_DELAY_MS}, /*Delay*/	\
+	{0x0008, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT(4), 0}, /*.	0x08[4] = 0		 switch TSF to 40M*/	\
+	{0x0109, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, BIT(7), 0}, /*Polling 0x109[7]=0  TSF in 40M*/			\
+	{0x0029, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT(6)|BIT(7), 0}, /*.	0x29[7:6] = 2b'00	 enable BB clock*/	\
+	{0x0101, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT(1), BIT(1)}, /*.	0x101[1] = 1*/					\
+	{0x0100, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0xFF}, /*.	0x100[7:0] = 0xFF	 enable WMAC TRX*/	\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT(1)|BIT(0), BIT(1)|BIT(0)}, /*.	0x02[1:0] = 2b'11	 enable BB macro*/	\
+	{0x0522, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0}, /*.	0x522 = 0*/
+ 
+#define RTL8812_TRANS_END																\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/		\
+	{0xFFFF, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,0,PWR_CMD_END, 0, 0}, //
+
+
+extern struct wlan_pwr_cfg rtl8812_power_on_flow[RTL8812_TRANS_CARDEMU_TO_ACT_STEPS+RTL8812_TRANS_END_STEPS];
+extern struct wlan_pwr_cfg rtl8812_radio_off_flow[RTL8812_TRANS_ACT_TO_CARDEMU_STEPS+RTL8812_TRANS_END_STEPS];
+extern struct wlan_pwr_cfg rtl8812_card_disable_flow[RTL8812_TRANS_ACT_TO_CARDEMU_STEPS+RTL8812_TRANS_CARDEMU_TO_PDN_STEPS+RTL8812_TRANS_END_STEPS];
+extern struct wlan_pwr_cfg rtl8812_card_enable_flow[RTL8812_TRANS_ACT_TO_CARDEMU_STEPS+RTL8812_TRANS_CARDEMU_TO_PDN_STEPS+RTL8812_TRANS_END_STEPS];
+extern struct wlan_pwr_cfg rtl8812_suspend_flow[RTL8812_TRANS_ACT_TO_CARDEMU_STEPS+RTL8812_TRANS_CARDEMU_TO_SUS_STEPS+RTL8812_TRANS_END_STEPS];
+extern struct wlan_pwr_cfg rtl8812_resume_flow[RTL8812_TRANS_ACT_TO_CARDEMU_STEPS+RTL8812_TRANS_CARDEMU_TO_SUS_STEPS+RTL8812_TRANS_END_STEPS];
+extern struct wlan_pwr_cfg rtl8812_hwpdn_flow[RTL8812_TRANS_ACT_TO_CARDEMU_STEPS+RTL8812_TRANS_CARDEMU_TO_PDN_STEPS+RTL8812_TRANS_END_STEPS];
+extern struct wlan_pwr_cfg rtl8812_enter_lps_flow[RTL8812_TRANS_ACT_TO_LPS_STEPS+RTL8812_TRANS_END_STEPS];
+extern struct wlan_pwr_cfg rtl8812_leave_lps_flow[RTL8812_TRANS_LPS_TO_ACT_STEPS+RTL8812_TRANS_END_STEPS];
+
+#endif //__HAL8812PWRSEQ_H__
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/include/Hal8821APwrSeq.h linux-4.9.8821au/drivers/staging/rtl8821au/include/Hal8821APwrSeq.h
--- linux-4.9/drivers/staging/rtl8821au/include/Hal8821APwrSeq.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/include/Hal8821APwrSeq.h	2016-12-11 19:48:25.170311727 -0600
@@ -0,0 +1,183 @@
+#ifndef REALTEK_POWER_SEQUENCE_8821
+#define REALTEK_POWER_SEQUENCE_8821
+
+#include "HalPwrSeqCmd.h"
+
+/* 
+	Check document WM-20121114-JackieLau-RTL8821A_Power_Architecture-R06.vsd
+	There are 6 HW Power States:
+	0: POFF--Power Off
+	1: PDN--Power Down
+	2: CARDEMU--Card Emulation
+	3: ACT--Active Mode
+	4: LPS--Low Power State
+	5: SUS--Suspend
+
+	The transision from different states are defined below
+	TRANS_CARDEMU_TO_ACT
+	TRANS_ACT_TO_CARDEMU
+	TRANS_CARDEMU_TO_SUS
+	TRANS_SUS_TO_CARDEMU
+	TRANS_CARDEMU_TO_PDN
+	TRANS_ACT_TO_LPS
+	TRANS_LPS_TO_ACT	
+
+	TRANS_END
+*/
+#define	RTL8821A_TRANS_CARDEMU_TO_ACT_STEPS	22
+#define	RTL8821A_TRANS_ACT_TO_CARDEMU_STEPS	15
+#define	RTL8821A_TRANS_CARDEMU_TO_SUS_STEPS	15
+#define	RTL8821A_TRANS_SUS_TO_CARDEMU_STEPS	15
+#define RTL8821A_TRANS_CARDDIS_TO_CARDEMU_STEPS	15
+#define	RTL8821A_TRANS_CARDEMU_TO_PDN_STEPS	15
+#define	RTL8821A_TRANS_PDN_TO_CARDEMU_STEPS	15
+#define	RTL8821A_TRANS_ACT_TO_LPS_STEPS	15
+#define	RTL8821A_TRANS_LPS_TO_ACT_STEPS	15	
+#define	RTL8821A_TRANS_END_STEPS	1
+
+
+#define RTL8821A_TRANS_CARDEMU_TO_ACT 														\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0020, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK|PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT(0), BIT(0)}, /*0x20[0] = 1b'1 enable LDOA12 MACRO block for all interface*/   \
+	{0x0067, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK|PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT(4), 0}, /*0x67[0] = 0 to disable BT_GPS_SEL pins*/	\
+	{0x0001, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK|PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_DELAY, 1, PWRSEQ_DELAY_MS},/*Delay 1ms*/   \
+	{0x0000, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK|PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT(5), 0}, /*0x00[5] = 1b'0 release analog Ips to digital ,1:isolation*/   \
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT(2), 0},/* disable SW LPS 0x04[10]=0*/	\
+	{0x0006, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, BIT(1), BIT(1)},/* wait till 0x04[17] = 1    power ready*/	\
+	{0x0006, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT(0), BIT(0)},/* release WLON reset  0x04[16]=1*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT(7), 0},/* disable HWPDN 0x04[15]=0*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, (BIT(4)|BIT(3)), 0},/* disable WL suspend*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT(0), BIT(0)},/* polling until return 0*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, BIT(0), 0},/**/	\
+	{0x004F, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT(0), BIT(0)},/*0x4C[24] = 0x4F[0] = 1, switch DPDT_SEL_P output from WL BB */\
+	{0x0067, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, (BIT(5)|BIT(4)), (BIT(5)|BIT(4))},/*0x66[13] = 0x67[5] = 1, switch for PAPE_G/PAPE_A from WL BB ; 0x66[12] = 0x67[4] = 1, switch LNAON from WL BB */\
+	{0x0025, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT(6), 0},/*anapar_mac<118> , 0x25[6]=0 by wlan single function*/\
+	{0x0049, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT(1), BIT(1)},/*Enable falling edge triggering interrupt*/\
+	{0x0063, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT(1), BIT(1)},/*Enable GPIO9 interrupt mode*/\
+	{0x0062, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT(1), 0},/*Enable GPIO9 input mode*/\
+	{0x0058, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT(0), BIT(0)},/*Enable HSISR GPIO[C:0] interrupt*/\
+	{0x005A, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT(1), BIT(1)},/*Enable HSISR GPIO9 interrupt*/\
+	{0x007A, PWR_CUT_TESTCHIP_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x3A},/*0x7A = 0x3A start BT*/\
+	{0x002E, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF , 0x82 },/* 0x2C[23:12]=0x820 ; XTAL trim */ \
+	{0x0010, PWR_CUT_A_MSK , PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT(6) , BIT(6) },/* 0x10[6]=1 ; MPsW0x2CvA0x10[6]]1~WLAN */ \
+
+
+#define RTL8821A_TRANS_ACT_TO_CARDEMU													\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x001F, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0},/*0x1F[7:0] = 0 turn off RF*/	\
+	{0x004F, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT(0), 0},/*0x4C[24] = 0x4F[0] = 0, switch DPDT_SEL_P output from register 0x65[2] */\
+	{0x0049, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT(1), 0},/*Enable rising edge triggering interrupt*/ \
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT(1), BIT(1)}, /*0x04[9] = 1 turn off MAC by HW state machine*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, BIT(1), 0}, /*wait till 0x04[9] = 0 polling until return 0 to disable*/	\
+	{0x0000, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK|PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT(5), BIT(5)}, /*0x00[5] = 1b'1 analog Ips to digital ,1:isolation*/   \
+	{0x0020, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK|PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT(0), 0}, /*0x20[0] = 1b'0 disable LDOA12 MACRO block*/   \
+
+
+#define RTL8821A_TRANS_CARDEMU_TO_SUS													\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT(4)|BIT(3), (BIT(4)|BIT(3))}, /*0x04[12:11] = 2b'11 enable WL suspend for PCIe*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK|PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT(3)|BIT(4), BIT(3)}, /*0x04[12:11] = 2b'01 enable WL suspend*/	\
+	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT(4), BIT(4)}, /*0x23[4] = 1b'1 12H LDO enter sleep mode*/   \
+	{0x0007, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x20}, /*0x07[7:0] = 0x20 SDIO SOP option to disable BG/MB/ACK/SWR*/   \
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT(3)|BIT(4), BIT(3)|BIT(4)}, /*0x04[12:11] = 2b'11 enable WL suspend for PCIe*/	\
+	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_WRITE, BIT(0), BIT(0)}, /*Set SDIO suspend local register*/	\
+	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_POLLING, BIT(1), 0}, /*wait power state to suspend*/
+
+#define RTL8821A_TRANS_SUS_TO_CARDEMU													\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT(3) | BIT(7), 0}, /*clear suspend enable and power down enable*/	\
+	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_WRITE, BIT(0), 0}, /*Set SDIO suspend local register*/	\
+	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_POLLING, BIT(1), BIT(1)}, /*wait power state to suspend*/\
+	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT(4), 0}, /*0x23[4] = 1b'0 12H LDO enter normal mode*/   \
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT(3)|BIT(4), 0}, /*0x04[12:11] = 2b'01enable WL suspend*/
+
+#define RTL8821A_TRANS_CARDEMU_TO_CARDDIS													\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0007, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x20}, /*0x07=0x20 , SOP option to disable BG/MB*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK|PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT(3)|BIT(4), BIT(3)}, /*0x04[12:11] = 2b'01 enable WL suspend*/	\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT(2), BIT(2)}, /*0x04[10] = 1, enable SW LPS*/	\
+        {0x004A, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT(0), 1}, /*0x48[16] = 1 to enable GPIO9 as EXT WAKEUP*/   \
+	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT(4), BIT(4)}, /*0x23[4] = 1b'1 12H LDO enter sleep mode*/   \
+	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_WRITE, BIT(0), BIT(0)}, /*Set SDIO suspend local register*/	\
+	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_POLLING, BIT(1), 0}, /*wait power state to suspend*/
+
+#define RTL8821A_TRANS_CARDDIS_TO_CARDEMU													\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT(3) | BIT(7), 0}, /*clear suspend enable and power down enable*/	\
+	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_WRITE, BIT(0), 0}, /*Set SDIO suspend local register*/	\
+	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_POLLING, BIT(1), BIT(1)}, /*wait power state to suspend*/\
+	{0x004A, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT(0), 0}, /*0x48[16] = 0 to disable GPIO9 as EXT WAKEUP*/   \
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT(3)|BIT(4), 0}, /*0x04[12:11] = 2b'01enable WL suspend*/\
+	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT(4), 0}, /*0x23[4] = 1b'0 12H LDO enter normal mode*/   \
+	{0x0301, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0},/*PCIe DMA start*/	
+
+
+#define RTL8821A_TRANS_CARDEMU_TO_PDN												\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT(4), BIT(4)}, /*0x23[4] = 1b'1 12H LDO enter sleep mode*/   \
+	{0x0007, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK|PWR_INTF_USB_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x20}, /*0x07[7:0] = 0x20 SOP option to disable BG/MB/ACK/SWR*/   \
+	{0x0006, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT(0), 0},/* 0x04[16] = 0*/\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT(7), BIT(7)},/* 0x04[15] = 1*/
+
+#define RTL8821A_TRANS_PDN_TO_CARDEMU												\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT(7), 0},/* 0x04[15] = 0*/
+
+#define RTL8821A_TRANS_ACT_TO_LPS														\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0301, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0xFF},/*PCIe DMA stop*/	\
+	{0x0522, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0xFF},/*Tx Pause*/	\
+	{0x05F8, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
+	{0x05F9, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
+	{0x05FA, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
+	{0x05FB, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, 0xFF, 0},/*Should be zero if no packet is transmitting*/	\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT(0), 0},/*CCK and OFDM are disabled,and clock are gated*/	\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_DELAY, 0, PWRSEQ_DELAY_US},/*Delay 1us*/	\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT(1), 0},/*Whole BB is reset*/	\
+	{0x0100, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x03},/*Reset MAC TRX*/	\
+	{0x0101, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT(1), 0},/*check if removed later*/	\
+	{0x0093, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x00},/*When driver enter Sus/ Disable, enable LOP for BT*/	\
+	{0x0553, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT(5), BIT(5)},/*Respond TxOK to scheduler*/	\
+
+
+#define RTL8821A_TRANS_LPS_TO_ACT															\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0x0080, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,PWR_BASEADDR_SDIO,PWR_CMD_WRITE, 0xFF, 0x84}, /*SDIO RPWM*/\
+	{0xFE58, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x84}, /*USB RPWM*/\
+	{0x0361, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0x84}, /*PCIe RPWM*/\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_DELAY, 0, PWRSEQ_DELAY_MS}, /*Delay*/\
+	{0x0008, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT(4), 0}, /*.	0x08[4] = 0		 switch TSF to 40M*/\
+	{0x0109, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_POLLING, BIT(7), 0}, /*Polling 0x109[7]=0  TSF in 40M*/\
+	{0x0029, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT(6)|BIT(7), 0}, /*.	0x29[7:6] = 2b'00	 enable BB clock*/\
+	{0x0101, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT(1), BIT(1)}, /*.	0x101[1] = 1*/\
+	{0x0100, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0xFF}, /*.	0x100[7:0] = 0xFF	 enable WMAC TRX*/\
+	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, BIT(1)|BIT(0), BIT(1)|BIT(0)}, /*.	0x02[1:0] = 2b'11	 enable BB macro*/\
+	{0x0522, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,PWR_BASEADDR_MAC,PWR_CMD_WRITE, 0xFF, 0}, /*.	0x522 = 0*/
+ 
+#define RTL8821A_TRANS_END															\
+	/* format */																\
+	/* { offset, cut_msk, fab_msk|interface_msk, base|cmd, msk, value }, // comments here*/								\
+	{0xFFFF, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,0,PWR_CMD_END, 0, 0}, //
+
+
+extern struct wlan_pwr_cfg rtl8821A_power_on_flow[RTL8821A_TRANS_CARDEMU_TO_ACT_STEPS+RTL8821A_TRANS_END_STEPS];
+extern struct wlan_pwr_cfg rtl8821A_radio_off_flow[RTL8821A_TRANS_ACT_TO_CARDEMU_STEPS+RTL8821A_TRANS_END_STEPS];
+extern struct wlan_pwr_cfg rtl8821A_card_disable_flow[RTL8821A_TRANS_ACT_TO_CARDEMU_STEPS+RTL8821A_TRANS_CARDEMU_TO_PDN_STEPS+RTL8821A_TRANS_END_STEPS];
+extern struct wlan_pwr_cfg rtl8821A_card_enable_flow[RTL8821A_TRANS_CARDDIS_TO_CARDEMU_STEPS+RTL8821A_TRANS_CARDEMU_TO_ACT_STEPS+RTL8821A_TRANS_END_STEPS];
+extern struct wlan_pwr_cfg rtl8821A_suspend_flow[RTL8821A_TRANS_ACT_TO_CARDEMU_STEPS+RTL8821A_TRANS_CARDEMU_TO_SUS_STEPS+RTL8821A_TRANS_END_STEPS];
+extern struct wlan_pwr_cfg rtl8821A_resume_flow[RTL8821A_TRANS_ACT_TO_CARDEMU_STEPS+RTL8821A_TRANS_CARDEMU_TO_SUS_STEPS+RTL8821A_TRANS_END_STEPS];
+extern struct wlan_pwr_cfg rtl8821A_hwpdn_flow[RTL8821A_TRANS_ACT_TO_CARDEMU_STEPS+RTL8821A_TRANS_CARDEMU_TO_PDN_STEPS+RTL8821A_TRANS_END_STEPS];
+extern struct wlan_pwr_cfg rtl8821A_enter_lps_flow[RTL8821A_TRANS_ACT_TO_LPS_STEPS+RTL8821A_TRANS_END_STEPS];
+extern struct wlan_pwr_cfg rtl8821A_leave_lps_flow[RTL8821A_TRANS_LPS_TO_ACT_STEPS+RTL8821A_TRANS_END_STEPS];
+
+#endif
diff -Naur linux-4.9/drivers/staging/rtl8821au/include/hal_com.h linux-4.9.8821au/drivers/staging/rtl8821au/include/hal_com.h
--- linux-4.9/drivers/staging/rtl8821au/include/hal_com.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/include/hal_com.h	2016-12-11 19:48:25.170311727 -0600
@@ -0,0 +1,75 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __HAL_COMMON_H__
+#define __HAL_COMMON_H__
+
+#include <../rtl8821au/def.h>
+#include "hal_phy.h"
+#include "hal_phy_reg.h"
+#include "hal_com_reg.h"
+#include "hal_com_phycfg.h"
+
+
+enum{
+	UP_LINK,
+	DOWN_LINK,
+};
+typedef enum _RT_MEDIA_STATUS {
+	RT_MEDIA_DISCONNECT = 0,
+	RT_MEDIA_CONNECT       = 1
+} RT_MEDIA_STATUS;
+
+#define MAX_DLFW_PAGE_SIZE			4096	// @ page : 4k bytes
+
+// BK, BE, VI, VO, HCCA, MANAGEMENT, COMMAND, HIGH, BEACON.
+//#define MAX_TX_QUEUE		9
+
+#define TX_SELE_HQ			BIT(0)		// High Queue
+#define TX_SELE_LQ			BIT(1)		// Low Queue
+#define TX_SELE_NQ			BIT(2)		// Normal Queue
+#define TX_SELE_EQ			BIT(3)		// Extern Queue
+
+#define PageNum_128(_Len)		(u32)(((_Len)>>7) + ((_Len)&0x7F ? 1:0))
+#define PageNum_256(_Len)		(u32)(((_Len)>>8) + ((_Len)&0xFF ? 1:0))
+#define PageNum_512(_Len)		(u32)(((_Len)>>9) + ((_Len)&0x1FF ? 1:0))
+#define PageNum(_Len, _Size)		(u32)(((_Len)/(_Size)) + ((_Len)&((_Size) - 1) ? 1:0))
+
+
+uint8_t	//return the final channel plan decision
+hal_com_get_channel_plan(
+	struct rtl_priv *rtlpriv,
+	uint8_t			hw_channel_plan,	//channel plan from HW (efuse/eeprom)
+	uint8_t			sw_channel_plan,	//channel plan from SW (registry/module param)
+	uint8_t			def_channel_plan,	//channel plan used when the former two is invalid
+	bool			AutoLoadFail
+	);
+
+bool HAL_IsLegalChannel(struct rtl_priv *rtlpriv, u32 Channel);
+
+void	HalSetBrateCfg(
+	struct rtl_priv *	rtlpriv,
+	uint8_t			*mBratesOS,
+	u16			*pBrateCfg);
+
+
+uint8_t rtw_hal_networktype_to_raid(struct rtl_priv *rtlpriv,unsigned char network_type);
+uint8_t rtw_get_mgntframe_raid(struct rtl_priv *rtlpriv,unsigned char network_type);
+#endif //__HAL_COMMON_H__
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/include/hal_com_phycfg.h linux-4.9.8821au/drivers/staging/rtl8821au/include/hal_com_phycfg.h
--- linux-4.9/drivers/staging/rtl8821au/include/hal_com_phycfg.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/include/hal_com_phycfg.h	2016-12-11 19:48:25.170311727 -0600
@@ -0,0 +1,27 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __HAL_COM_PHYCFG_H__
+#define __HAL_COM_PHYCFG_H__
+
+
+#define MAX_POWER_INDEX 		0x3F
+
+#endif //__HAL_COMMON_H__
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/include/hal_com_reg.h linux-4.9.8821au/drivers/staging/rtl8821au/include/hal_com_reg.h
--- linux-4.9/drivers/staging/rtl8821au/include/hal_com_reg.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/include/hal_com_reg.h	2016-12-11 19:48:25.170311727 -0600
@@ -0,0 +1,1654 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __HAL_COMMON_REG_H__
+#define __HAL_COMMON_REG_H__
+
+
+#define MAC_ADDR_LEN				6
+
+#define HAL_NAV_UPPER_UNIT		128		// micro-second
+
+// 8188E PKT_BUFF_ACCESS_CTRL value
+#define TXPKT_BUF_SELECT				0x69
+#define RXPKT_BUF_SELECT				0xA5
+#define DISABLE_TRXPKT_BUF_ACCESS		0x0
+
+//============================================================
+//
+//============================================================
+
+//-----------------------------------------------------
+//
+//	0x0000h ~ 0x00FFh	System Configuration
+//
+//-----------------------------------------------------
+#define REG_SYS_ISO_CTRL				0x0000
+#define REG_SYS_FUNC_EN				0x0002
+#define REG_APS_FSMCO					0x0004
+#define REG_SYS_CLKR					0x0008
+#define REG_9346CR						0x000A
+#define REG_SYS_EEPROM_CTRL			0x000A
+#define REG_EE_VPD						0x000C
+#define REG_AFE_MISC					0x0010
+#define REG_SPS0_CTRL					0x0011
+#define REG_SPS0_CTRL_6					0x0016
+#define REG_POWER_OFF_IN_PROCESS 		0x0017
+#define REG_SPS_OCP_CFG				0x0018
+#define REG_RSV_CTRL					0x001C
+#define REG_RF_CTRL						0x001F
+#define REG_LDOA15_CTRL				0x0020
+#define REG_LDOV12D_CTRL				0x0021
+#define REG_LDOHCI12_CTRL				0x0022
+#define REG_LPLDO_CTRL					0x0023
+#define REG_AFE_XTAL_CTRL				0x0024
+#define REG_AFE_LDO_CTRL				0x0027 // 1.5v for 8188EE test chip, 1.4v for MP chip
+#define REG_AFE_PLL_CTRL				0x0028
+#define REG_MAC_PHY_CTRL				0x002c //for 92d, DMDP,SMSP,DMSP contrl
+#define REG_APE_PLL_CTRL_EXT			0x002c
+#define REG_EFUSE_CTRL					0x0030
+#define REG_EFUSE_TEST					0x0034
+#define REG_PWR_DATA					0x0038
+#define REG_CAL_TIMER					0x003C
+#define REG_ACLK_MON					0x003E
+#define REG_GPIO_MUXCFG				0x0040
+#define REG_GPIO_IO_SEL					0x0042
+#define REG_MAC_PINMUX_CFG			0x0043
+#define REG_GPIO_PIN_CTRL				0x0044
+#define REG_GPIO_INTM					0x0048
+#define REG_LEDCFG0						0x004C
+#define REG_LEDCFG1						0x004D
+#define REG_LEDCFG2						0x004E
+#define REG_LEDCFG3						0x004F
+#define REG_FSIMR						0x0050
+#define REG_FSISR						0x0054
+#define REG_HSIMR						0x0058
+#define REG_HSISR						0x005c
+#define REG_GPIO_PIN_CTRL_2			0x0060 // RTL8723 WIFI/BT/GPS Multi-Function GPIO Pin Control.
+#define REG_GPIO_IO_SEL_2				0x0062 // RTL8723 WIFI/BT/GPS Multi-Function GPIO Select.
+#define REG_MULTI_FUNC_CTRL			0x0068 // RTL8723 WIFI/BT/GPS Multi-Function control source.
+#define REG_GSSR						0x006c
+#define REG_AFE_XTAL_CTRL_EXT			0x0078 //RTL8188E
+#define REG_XCK_OUT_CTRL				0x007c //RTL8188E
+#define REG_MCUFWDL					0x0080
+#define REG_WOL_EVENT					0x0081 //RTL8188E
+#define REG_MCUTSTCFG					0x0084
+#define REG_FDHM0						0x0088
+#define REG_HOST_SUSP_CNT				0x00BC	// RTL8192C Host suspend counter on FPGA platform
+#define REG_SYSTEM_ON_CTRL			0x00CC	// For 8723AE Reset after S3
+#define REG_EFUSE_ACCESS				0x00CF	// Efuse access protection for RTL8723
+#define REG_BIST_SCAN					0x00D0
+#define REG_BIST_RPT					0x00D4
+#define REG_BIST_ROM_RPT				0x00D8
+#define REG_USB_SIE_INTF				0x00E0
+#define REG_PCIE_MIO_INTF				0x00E4
+#define REG_PCIE_MIO_INTD				0x00E8
+#define REG_HPON_FSM					0x00EC
+#define REG_SYS_CFG						0x00F0
+#define REG_GPIO_OUTSTS				0x00F4	// For RTL8723 only.
+#define REG_TYPE_ID						0x00FC
+
+
+//-----------------------------------------------------
+//
+//	0x0100h ~ 0x01FFh	MACTOP General Configuration
+//
+//-----------------------------------------------------
+#define REG_CR							0x0100
+#define REG_PBP							0x0104
+#define REG_PKT_BUFF_ACCESS_CTRL		0x0106
+#define REG_TRXDMA_CTRL				0x010C
+#define REG_TRXFF_BNDY					0x0114
+#define REG_TRXFF_STATUS				0x0118
+#define REG_RXFF_PTR					0x011C
+#define REG_HIMR						0x0120
+#define REG_HISR						0x0124
+#define REG_HIMRE						0x0128
+#define REG_HISRE						0x012C
+#define REG_CPWM						0x012F
+#define REG_FWIMR						0x0130
+#define REG_FWISR						0x0134
+#define REG_FTIMR						0x0138
+#define REG_FTISR						0x013C //RTL8192C
+#define REG_PKTBUF_DBG_CTRL			0x0140
+#define REG_RXPKTBUF_CTRL				(REG_PKTBUF_DBG_CTRL+2)
+#define REG_PKTBUF_DBG_DATA_L			0x0144
+#define REG_PKTBUF_DBG_DATA_H		0x0148
+
+#define REG_TC0_CTRL					0x0150
+#define REG_TC1_CTRL					0x0154
+#define REG_TC2_CTRL					0x0158
+#define REG_TC3_CTRL					0x015C
+#define REG_TC4_CTRL					0x0160
+#define REG_TCUNIT_BASE				0x0164
+#define REG_MBIST_START				0x0174
+#define REG_MBIST_DONE					0x0178
+#define REG_MBIST_FAIL					0x017C
+#define REG_32K_CTRL					0x0194 //RTL8188E
+#define REG_C2HEVT_MSG_NORMAL		0x01A0
+#define REG_C2HEVT_CLEAR				0x01AF
+#define REG_MCUTST_1					0x01c0
+#define REG_MCUTST_WOWLAN			0x01C7	// Defined after 8188E series.
+#define REG_FMETHR						0x01C8
+#define REG_HMETFR						0x01CC
+#define REG_HMEBOX_0					0x01D0
+#define REG_HMEBOX_1					0x01D4
+#define REG_HMEBOX_2					0x01D8
+#define REG_HMEBOX_3					0x01DC
+#define REG_LLT_INIT					0x01E0
+
+
+//-----------------------------------------------------
+//
+//	0x0200h ~ 0x027Fh	TXDMA Configuration
+//
+//-----------------------------------------------------
+#define REG_RQPN						0x0200
+#define REG_FIFOPAGE					0x0204
+#define REG_TDECTRL						0x0208
+#define REG_TXDMA_OFFSET_CHK			0x020C
+#define REG_TXDMA_STATUS				0x0210
+#define REG_RQPN_NPQ					0x0214
+
+
+//-----------------------------------------------------
+//
+//	0x0280h ~ 0x02FFh	RXDMA Configuration
+//
+//-----------------------------------------------------
+#define REG_RXDMA_AGG_PG_TH			0x0280
+#define REG_RXPKT_NUM					0x0284
+#define REG_RXDMA_STATUS				0x0288
+
+//-----------------------------------------------------
+//
+//	0x0300h ~ 0x03FFh	PCIe
+//
+//-----------------------------------------------------
+#define REG_PCIE_CTRL_REG				0x0300
+#define REG_INT_MIG						0x0304	// Interrupt Migration
+#define REG_BCNQ_DESA					0x0308	// TX Beacon Descriptor Address
+#define REG_HQ_DESA					0x0310	// TX High Queue Descriptor Address
+#define REG_MGQ_DESA					0x0318	// TX Manage Queue Descriptor Address
+#define REG_VOQ_DESA					0x0320	// TX VO Queue Descriptor Address
+#define REG_VIQ_DESA					0x0328	// TX VI Queue Descriptor Address
+#define REG_BEQ_DESA					0x0330	// TX BE Queue Descriptor Address
+#define REG_BKQ_DESA					0x0338	// TX BK Queue Descriptor Address
+#define REG_RX_DESA						0x0340	// RX Queue	Descriptor Address
+//sherry added for DBI Read/Write  20091126
+#define REG_DBI_WDATA					0x0348	// Backdoor REG for Access Configuration
+#define REG_DBI_RDATA                         	0x034C	//Backdoor REG for Access Configuration
+#define REG_DBI_CTRL                      		0x0350	//Backdoor REG for Access Configuration
+#define REG_DBI_FLAG                      		0x0352	//Backdoor REG for Access Configuration
+#define REG_MDIO						0x0354	// MDIO for Access PCIE PHY
+#define REG_DBG_SEL						0x0360	// Debug Selection Register
+#define REG_PCIE_HRPWM					0x0361	//PCIe RPWM
+#define REG_PCIE_HCPWM					0x0363	//PCIe CPWM
+#define REG_WATCH_DOG					0x0368
+
+// RTL8723 series -------------------------------
+#define REG_PCIE_HISR_EN				0x0394	//PCIE Local Interrupt Enable Register
+#define REG_PCIE_HISR					0x03A0
+#define REG_PCIE_HISRE					0x03A4
+#define REG_PCIE_HIMR					0x03A8
+#define REG_PCIE_HIMRE					0x03AC
+
+#define REG_USB_HIMR					0xFE38
+#define REG_USB_HIMRE					0xFE3C
+#define REG_USB_HISR					0xFE78
+#define REG_USB_HISRE					0xFE7C
+
+
+//-----------------------------------------------------
+//
+//	0x0400h ~ 0x047Fh	Protocol Configuration
+//
+//-----------------------------------------------------
+#define REG_VOQ_INFORMATION			0x0400
+#define REG_VIQ_INFORMATION			0x0404
+#define REG_BEQ_INFORMATION			0x0408
+#define REG_BKQ_INFORMATION			0x040C
+#define REG_MGQ_INFORMATION			0x0410
+#define REG_HGQ_INFORMATION			0x0414
+#define REG_BCNQ_INFORMATION			0x0418
+#define REG_TXPKT_EMPTY				0x041A
+#define REG_CPU_MGQ_INFORMATION		0x041C
+#define REG_FWHW_TXQ_CTRL				0x0420
+#define REG_HWSEQ_CTRL					0x0423
+#define REG_BCNQ_BDNY					0x0424
+#define REG_MGQ_BDNY					0x0425
+#define REG_LIFETIME_CTRL				0x0426
+#define REG_MULTI_BCNQ_OFFSET			0x0427
+#define REG_SPEC_SIFS					0x0428
+#define REG_RL							0x042A
+#define REG_DARFRC						0x0430
+#define REG_RARFRC						0x0438
+#define REG_RRSR						0x0440
+#define REG_ARFR0						0x0444
+#define REG_ARFR1						0x0448
+#define REG_ARFR2						0x044C
+#define REG_ARFR3						0x0450
+#define REG_BCNQ1_BDNY					0x0457
+
+#define REG_AGGLEN_LMT					0x0458
+#define REG_AMPDU_MIN_SPACE			0x045C
+#define REG_WMAC_LBK_BF_HD			0x045D
+#define REG_FAST_EDCA_CTRL				0x0460
+#define REG_RD_RESP_PKT_TH				0x0463
+
+#define REG_INIRTS_RATE_SEL				0x0480
+#define REG_INIDATA_RATE_SEL			0x0484
+
+#define REG_POWER_STAGE1				0x04B4
+#define REG_POWER_STAGE2				0x04B8
+#define REG_PKT_VO_VI_LIFE_TIME		0x04C0
+#define REG_PKT_BE_BK_LIFE_TIME		0x04C2
+#define REG_STBC_SETTING				0x04C4
+#define REG_QUEUE_CTRL					0x04C6
+#define REG_PROT_MODE_CTRL			0x04C8
+#define REG_MAX_AGGR_NUM				0x04CA
+#define REG_RTS_MAX_AGGR_NUM			0x04CB
+#define REG_BAR_MODE_CTRL				0x04CC
+#define REG_RA_TRY_RATE_AGG_LMT		0x04CF
+#define REG_EARLY_MODE_CONTROL		0x04D0
+#define REG_NQOS_SEQ					0x04DC
+#define REG_QOS_SEQ					0x04DE
+#define REG_NEED_CPU_HANDLE			0x04E0
+#define REG_PKT_LOSE_RPT				0x04E1
+#define REG_PTCL_ERR_STATUS			0x04E2
+#define REG_TX_RPT_CTRL					0x04EC
+#define REG_TX_RPT_TIME					0x04F0	// 2 byte
+#define REG_DUMMY						0x04FC
+
+//-----------------------------------------------------
+//
+//	0x0500h ~ 0x05FFh	EDCA Configuration
+//
+//-----------------------------------------------------
+#define REG_EDCA_VO_PARAM				0x0500
+#define REG_EDCA_VI_PARAM				0x0504
+#define REG_EDCA_BE_PARAM				0x0508
+#define REG_EDCA_BK_PARAM				0x050C
+#define REG_BCNTCFG						0x0510
+#define REG_PIFS							0x0512
+#define REG_RDG_PIFS					0x0513
+#define REG_SIFS_CTX					0x0514
+#define REG_SIFS_TRX					0x0516
+#define REG_TSFTR_SYN_OFFSET			0x0518
+#define REG_AGGR_BREAK_TIME			0x051A
+#define REG_SLOT						0x051B
+#define REG_TX_PTCL_CTRL				0x0520
+#define REG_TXPAUSE						0x0522
+#define REG_DIS_TXREQ_CLR				0x0523
+#define REG_RD_CTRL						0x0524
+//
+// Format for offset 540h-542h:
+//	[3:0]:   TBTT prohibit setup in unit of 32us. The time for HW getting beacon content before TBTT.
+//	[7:4]:   Reserved.
+//	[19:8]:  TBTT prohibit hold in unit of 32us. The time for HW holding to send the beacon packet.
+//	[23:20]: Reserved
+// Description:
+//	              |
+//     |<--Setup--|--Hold------------>|
+//	--------------|----------------------
+//                |
+//               TBTT
+// Note: We cannot update beacon content to HW or send any AC packets during the time between Setup and Hold.
+// Described by Designer Tim and Bruce, 2011-01-14.
+//
+#define REG_TBTT_PROHIBIT				0x0540
+#define REG_RD_NAV_NXT					0x0544
+#define REG_NAV_PROT_LEN				0x0546
+#define REG_BCN_CTRL					0x0550
+#define REG_BCN_CTRL_1					0x0551
+#define REG_MBID_NUM					0x0552
+#define REG_DUAL_TSF_RST				0x0553
+#define REG_BCN_INTERVAL				0x0554	// The same as REG_MBSSID_BCN_SPACE
+#define REG_DRVERLYINT					0x0558
+#define REG_BCNDMATIM					0x0559
+#define REG_ATIMWND					0x055A
+#define REG_USTIME_TSF					0x055C
+#define REG_BCN_MAX_ERR				0x055D
+#define REG_RXTSF_OFFSET_CCK			0x055E
+#define REG_RXTSF_OFFSET_OFDM			0x055F
+#define REG_TSFTR						0x0560
+#define REG_TSFTR1						0x0568	// HW Port 1 TSF Register
+#define REG_ATIMWND_1					0x0570
+#define REG_P2P_CTWIN					0x0572 // 1 Byte long (in unit of TU)
+#define REG_PSTIMER						0x0580
+#define REG_TIMER0						0x0584
+#define REG_TIMER1						0x0588
+#define REG_ACMHWCTRL					0x05C0
+#define REG_NOA_DESC_SEL				0x05CF
+#define REG_NOA_DESC_DURATION		0x05E0
+#define REG_NOA_DESC_INTERVAL			0x05E4
+#define REG_NOA_DESC_START			0x05E8
+#define REG_NOA_DESC_COUNT			0x05EC
+
+#define REG_DMC							0x05F0	//Dual MAC Co-Existence Register
+#define REG_SCH_TX_CMD					0x05F8
+
+#define REG_FW_RESET_TSF_CNT_1		0x05FC
+#define REG_FW_RESET_TSF_CNT_0		0x05FD
+#define REG_FW_BCN_DIS_CNT			0x05FE
+
+//-----------------------------------------------------
+//
+//	0x0600h ~ 0x07FFh	WMAC Configuration
+//
+//-----------------------------------------------------
+#define REG_APSD_CTRL					0x0600
+#define REG_BWOPMODE					0x0603
+#define REG_TCR							0x0604
+#define REG_RCR							0x0608
+#define REG_RX_PKT_LIMIT				0x060C
+#define REG_RX_DLK_TIME				0x060D
+#define REG_RX_DRVINFO_SZ				0x060F
+
+#define REG_MACID						0x0610
+#define REG_BSSID						0x0618
+#define REG_MAR							0x0620
+#define REG_MBIDCAMCFG					0x0628
+
+#define REG_USTIME_EDCA				0x0638
+#define REG_MAC_SPEC_SIFS				0x063A
+// 20100719 Joseph: Hardware register definition change. (HW datasheet v54)
+#define REG_RESP_SIFS_CCK				0x063C	// [15:8]SIFS_R2T_OFDM, [7:0]SIFS_R2T_CCK
+#define REG_RESP_SIFS_OFDM                    0x063E	// [15:8]SIFS_T2T_OFDM, [7:0]SIFS_T2T_CCK
+
+#define REG_ACKTO						0x0640
+#define REG_CTS2TO						0x0641
+#define REG_EIFS							0x0642
+
+
+//RXERR_RPT
+#define RXERR_TYPE_OFDM_PPDU			0
+#define RXERR_TYPE_OFDM_FALSE_ALARM 	1
+#define RXERR_TYPE_OFDM_MPDU_OK 		2
+#define RXERR_TYPE_OFDM_MPDU_FAIL	3
+#define RXERR_TYPE_CCK_PPDU 			4
+#define RXERR_TYPE_CCK_FALSE_ALARM	5
+#define RXERR_TYPE_CCK_MPDU_OK		6
+#define RXERR_TYPE_CCK_MPDU_FAIL		7
+#define RXERR_TYPE_HT_PPDU				8
+#define RXERR_TYPE_HT_FALSE_ALARM	9
+#define RXERR_TYPE_HT_MPDU_TOTAL		10
+#define RXERR_TYPE_HT_MPDU_OK			11
+#define RXERR_TYPE_HT_MPDU_FAIL 		12
+#define RXERR_TYPE_RX_FULL_DROP 		15
+
+#define RXERR_COUNTER_MASK			0xFFFFF
+#define RXERR_RPT_RST					BIT(27)
+#define _RXERR_RPT_SEL(type)			((type) << 28)
+
+//
+// Note:
+//	The NAV upper value is very important to WiFi 11n 5.2.3 NAV test. The default value is
+//	always too small, but the WiFi TestPlan test by 25,000 microseconds of NAV through sending
+//	CTS in the air. We must update this value greater than 25,000 microseconds to pass the item.
+//	The offset of NAV_UPPER in 8192C Spec is incorrect, and the offset should be 0x0652. Commented
+//	by SD1 Scott.
+// By Bruce, 2011-07-18.
+//
+#define REG_NAV_UPPER					0x0652	// unit of 128
+
+//WMA, BA, CCX
+#define REG_NAV_CTRL					0x0650
+#define REG_BACAMCMD					0x0654
+#define REG_BACAMCONTENT				0x0658
+#define REG_LBDLY						0x0660
+#define REG_FWDLY						0x0661
+#define REG_RXERR_RPT					0x0664
+#define REG_WMAC_TRXPTCL_CTL			0x0668
+
+// Power
+#define REG_WOW_CTRL					0x0690
+#define REG_PS_RX_INFO					0x0692
+#define REG_UAPSD_TID					0x0693
+#define REG_WKFMCAM_CMD				0x0698
+#define REG_WKFMCAM_NUM				REG_WKFMCAM_CMD
+#define REG_WKFMCAM_RWD				0x069C
+#define REG_RXFLTMAP0					0x06A0
+#define REG_RXFLTMAP1					0x06A2
+#define REG_RXFLTMAP2					0x06A4
+#define REG_BCN_PSR_RPT				0x06A8
+#define REG_BT_COEX_TABLE				0x06C0
+
+// Hardware Port 2
+#define REG_MACID1						0x0700
+#define REG_BSSID1						0x0708
+
+
+//-----------------------------------------------------
+//
+//	0xFE00h ~ 0xFE55h	USB Configuration
+//
+//-----------------------------------------------------
+#define REG_USB_INFO					0xFE17
+#define REG_USB_SPECIAL_OPTION		0xFE55
+#define REG_USB_DMA_AGG_TO			0xFE5B
+#define REG_USB_AGG_TO					0xFE5C
+#define REG_USB_AGG_TH					0xFE5D
+
+#define REG_USB_HRPWM					0xFE58
+#define REG_USB_HCPWM					0xFE57
+
+// for 92DU high_Queue low_Queue Normal_Queue select
+#define REG_USB_High_NORMAL_Queue_Select_MAC0	0xFE44
+//#define REG_USB_LOW_Queue_Select_MAC0		0xFE45
+#define REG_USB_High_NORMAL_Queue_Select_MAC1	0xFE47
+//#define REG_USB_LOW_Queue_Select_MAC1		0xFE48
+
+// For test chip
+#define REG_TEST_USB_TXQS				0xFE48
+#define REG_TEST_SIE_VID				0xFE60		// 0xFE60~0xFE61
+#define REG_TEST_SIE_PID				0xFE62		// 0xFE62~0xFE63
+#define REG_TEST_SIE_OPTIONAL			0xFE64
+#define REG_TEST_SIE_CHIRP_K			0xFE65
+#define REG_TEST_SIE_PHY				0xFE66		// 0xFE66~0xFE6B
+#define REG_TEST_SIE_MAC_ADDR			0xFE70		// 0xFE70~0xFE75
+#define REG_TEST_SIE_STRING			0xFE80		// 0xFE80~0xFEB9
+
+
+// For normal chip
+#define REG_NORMAL_SIE_VID				0xFE60		// 0xFE60~0xFE61
+#define REG_NORMAL_SIE_PID				0xFE62		// 0xFE62~0xFE63
+#define REG_NORMAL_SIE_OPTIONAL		0xFE64
+#define REG_NORMAL_SIE_EP				0xFE65		// 0xFE65~0xFE67
+#define REG_NORMAL_SIE_PHY			0xFE68		// 0xFE68~0xFE6B
+#define REG_NORMAL_SIE_OPTIONAL2		0xFE6C
+#define REG_NORMAL_SIE_GPS_EP			0xFE6D		// 0xFE6D, for RTL8723 only.
+#define REG_NORMAL_SIE_MAC_ADDR		0xFE70		// 0xFE70~0xFE75
+#define REG_NORMAL_SIE_STRING			0xFE80		// 0xFE80~0xFEDF
+
+
+//-----------------------------------------------------
+//
+//	Redifine 8192C register definition for compatibility
+//
+//-----------------------------------------------------
+
+// TODO: use these definition when using REG_xxx naming rule.
+// NOTE: DO NOT Remove these definition. Use later.
+
+#define MSR						(REG_CR + 2)		// Media Status register
+//#define ISR						REG_HISR
+
+#define TSFR						REG_TSFTR			// Timing Sync Function Timer Register.
+#define TSFR1					REG_TSFTR1			// HW Port 1 TSF Register
+
+#define PBP						REG_PBP
+
+// Redifine MACID register, to compatible prior ICs.
+#define IDR0						REG_MACID			// MAC ID Register, Offset 0x0050-0x0053
+#define IDR4						(REG_MACID + 4)		// MAC ID Register, Offset 0x0054-0x0055
+
+// Unused register
+#define UnusedRegister			0x1BF
+#define DCAM					UnusedRegister
+#define PSR						UnusedRegister
+#define BBAddr					UnusedRegister
+#define PhyDataR					UnusedRegister
+
+// Min Spacing related settings.
+#define MAX_MSS_DENSITY_2T 			0x13
+#define MAX_MSS_DENSITY_1T 			0x0A
+
+//----------------------------------------------------------------------------
+//       8192C Cmd9346CR bits					(Offset 0xA, 16bit)
+//----------------------------------------------------------------------------
+#define CmdEEPROM_En				BIT(5)	 // EEPROM enable when set 1
+#define CmdEERPOMSEL				BIT(4) 	// System EEPROM select, 0: boot from E-FUSE, 1: The EEPROM used is 9346
+#define Cmd9346CR_9356SEL			BIT(4)
+
+//----------------------------------------------------------------------------
+//       8192C GPIO MUX Configuration Register (offset 0x40, 4 byte)
+//----------------------------------------------------------------------------
+#define GPIOSEL_GPIO				0
+#define GPIOSEL_ENBT				BIT(5)
+
+//----------------------------------------------------------------------------
+//       8192C GPIO PIN Control Register (offset 0x44, 4 byte)
+//----------------------------------------------------------------------------
+#define GPIO_IN					REG_GPIO_PIN_CTRL		// GPIO pins input value
+#define GPIO_OUT				(REG_GPIO_PIN_CTRL+1)	// GPIO pins output value
+#define GPIO_IO_SEL				(REG_GPIO_PIN_CTRL+2)	// GPIO pins output enable when a bit is set to "1"; otherwise, input is configured.
+#define GPIO_MOD				(REG_GPIO_PIN_CTRL+3)
+
+//----------------------------------------------------------------------------
+//       8811A GPIO PIN Control Register (offset 0x60, 4 byte)
+//----------------------------------------------------------------------------
+#define GPIO_IN_8811A			REG_GPIO_PIN_CTRL_2		// GPIO pins input value
+#define GPIO_OUT_8811A			(REG_GPIO_PIN_CTRL_2+1)	// GPIO pins output value
+#define GPIO_IO_SEL_8811A		(REG_GPIO_PIN_CTRL_2+2)	// GPIO pins output enable when a bit is set to "1"; otherwise, input is configured.
+#define GPIO_MOD_8811A			(REG_GPIO_PIN_CTRL_2+3)
+
+//----------------------------------------------------------------------------
+//       8723/8188E Host System Interrupt Mask Register (offset 0x58, 32 byte)
+//----------------------------------------------------------------------------
+#define HSIMR_GPIO12_0_INT_EN			BIT(0)
+#define HSIMR_SPS_OCP_INT_EN			BIT(5)
+#define HSIMR_RON_INT_EN				BIT(6)
+#define HSIMR_PDN_INT_EN				BIT(7)
+#define HSIMR_GPIO9_INT_EN				BIT(25)
+
+//----------------------------------------------------------------------------
+//       8723/8188E Host System Interrupt Status Register (offset 0x5C, 32 byte)
+//----------------------------------------------------------------------------
+#define HSISR_GPIO12_0_INT				BIT(0)
+#define HSISR_SPS_OCP_INT				BIT(5)
+#define HSISR_RON_INT					BIT(6)
+#define HSISR_PDNINT					BIT(7)
+#define HSISR_GPIO9_INT					BIT(25)
+
+//----------------------------------------------------------------------------
+//       8192C (MSR) Media Status Register	(Offset 0x4C, 8 bits)
+//----------------------------------------------------------------------------
+/*
+Network Type
+00: No link
+01: Link in ad hoc network
+10: Link in infrastructure network
+11: AP mode
+Default: 00b.
+*/
+#define MSR_NOLINK				0x00
+#define MSR_ADHOC				0x01
+#define MSR_INFRA				0x02
+#define MSR_AP					0x03
+
+//----------------------------------------------------------------------------
+//       USB INTR CONTENT
+//----------------------------------------------------------------------------
+#define USB_C2H_CMDID_OFFSET					0
+#define USB_C2H_SEQ_OFFSET					1
+#define USB_C2H_EVENT_OFFSET					2
+#define USB_INTR_CPWM_OFFSET					16
+#define USB_INTR_CONTENT_C2H_OFFSET			0
+#define USB_INTR_CONTENT_CPWM1_OFFSET		16
+#define USB_INTR_CONTENT_CPWM2_OFFSET		20
+#define USB_INTR_CONTENT_HISR_OFFSET			48
+#define USB_INTR_CONTENT_HISRE_OFFSET		52
+#define USB_INTR_CONTENT_LENGTH				56
+
+//----------------------------------------------------------------------------
+//       Response Rate Set Register	(offset 0x440, 24bits)
+//----------------------------------------------------------------------------
+#define RRSR_1M					BIT(0)
+#define RRSR_2M					BIT(1)
+#define RRSR_5_5M				BIT(2)
+#define RRSR_11M				BIT(3)
+#define RRSR_6M					BIT(4)
+#define RRSR_9M					BIT(5)
+#define RRSR_12M				BIT(6)
+#define RRSR_18M				BIT(7)
+#define RRSR_24M				BIT(8)
+#define RRSR_36M				BIT(9)
+#define RRSR_48M				BIT(10)
+#define RRSR_54M				BIT(11)
+#define RRSR_MCS0				BIT(12)
+#define RRSR_MCS1				BIT(13)
+#define RRSR_MCS2				BIT(14)
+#define RRSR_MCS3				BIT(15)
+#define RRSR_MCS4				BIT(16)
+#define RRSR_MCS5				BIT(17)
+#define RRSR_MCS6				BIT(18)
+#define RRSR_MCS7				BIT(19)
+
+// WOL bit information
+#define HAL92C_WOL_PTK_UPDATE_EVENT		BIT(0)
+#define HAL92C_WOL_GTK_UPDATE_EVENT		BIT(1)
+#define HAL92C_WOL_DISASSOC_EVENT		BIT(2)
+#define HAL92C_WOL_DEAUTH_EVENT			BIT(3)
+#define HAL92C_WOL_FW_DISCONNECT_EVENT	BIT(4)
+
+//----------------------------------------------------------------------------
+//       Rate Definition
+//----------------------------------------------------------------------------
+//CCK
+#define	RATR_1M					0x00000001
+#define	RATR_2M					0x00000002
+#define	RATR_55M					0x00000004
+#define	RATR_11M					0x00000008
+//OFDM
+#define	RATR_6M					0x00000010
+#define	RATR_9M					0x00000020
+#define	RATR_12M					0x00000040
+#define	RATR_18M					0x00000080
+#define	RATR_24M					0x00000100
+#define	RATR_36M					0x00000200
+#define	RATR_48M					0x00000400
+#define	RATR_54M					0x00000800
+//MCS 1 Spatial Stream
+#define	RATR_MCS0					0x00001000
+#define	RATR_MCS1					0x00002000
+#define	RATR_MCS2					0x00004000
+#define	RATR_MCS3					0x00008000
+#define	RATR_MCS4					0x00010000
+#define	RATR_MCS5					0x00020000
+#define	RATR_MCS6					0x00040000
+#define	RATR_MCS7					0x00080000
+//MCS 2 Spatial Stream
+#define	RATR_MCS8					0x00100000
+#define	RATR_MCS9					0x00200000
+#define	RATR_MCS10					0x00400000
+#define	RATR_MCS11					0x00800000
+#define	RATR_MCS12					0x01000000
+#define	RATR_MCS13					0x02000000
+#define	RATR_MCS14					0x04000000
+#define	RATR_MCS15					0x08000000
+
+//CCK
+#define RATE_1M					BIT(0)
+#define RATE_2M					BIT(1)
+#define RATE_5_5M				BIT(2)
+#define RATE_11M				BIT(3)
+//OFDM
+#define RATE_6M					BIT(4)
+#define RATE_9M					BIT(5)
+#define RATE_12M				BIT(6)
+#define RATE_18M				BIT(7)
+#define RATE_24M				BIT(8)
+#define RATE_36M				BIT(9)
+#define RATE_48M				BIT(10)
+#define RATE_54M				BIT(11)
+//MCS 1 Spatial Stream
+#define RATE_MCS0				BIT(12)
+#define RATE_MCS1				BIT(13)
+#define RATE_MCS2				BIT(14)
+#define RATE_MCS3				BIT(15)
+#define RATE_MCS4				BIT(16)
+#define RATE_MCS5				BIT(17)
+#define RATE_MCS6				BIT(18)
+#define RATE_MCS7				BIT(19)
+//MCS 2 Spatial Stream
+#define RATE_MCS8				BIT(20)
+#define RATE_MCS9				BIT(21)
+#define RATE_MCS10				BIT(22)
+#define RATE_MCS11				BIT(23)
+#define RATE_MCS12				BIT(24)
+#define RATE_MCS13				BIT(25)
+#define RATE_MCS14				BIT(26)
+#define RATE_MCS15				BIT(27)
+
+
+// ALL CCK Rate
+#define	RATE_ALL_CCK				RATR_1M|RATR_2M|RATR_55M|RATR_11M
+#define	RATE_ALL_OFDM_AG			RATR_6M|RATR_9M|RATR_12M|RATR_18M|RATR_24M|\
+						RATR_36M|RATR_48M|RATR_54M
+#define	RATE_ALL_OFDM_1SS			RATR_MCS0|RATR_MCS1|RATR_MCS2|RATR_MCS3 |\
+						RATR_MCS4|RATR_MCS5|RATR_MCS6	|RATR_MCS7
+#define	RATE_ALL_OFDM_2SS			RATR_MCS8|RATR_MCS9	|RATR_MCS10|RATR_MCS11|\
+						RATR_MCS12|RATR_MCS13|RATR_MCS14|RATR_MCS15
+
+#define RATE_BITMAP_ALL			0xFFFFF
+
+// Only use CCK 1M rate for ACK
+#define RATE_RRSR_CCK_ONLY_1M		0xFFFF1
+#define RATE_RRSR_WITHOUT_CCK		0xFFFF0
+
+//----------------------------------------------------------------------------
+//       BW_OPMODE bits				(Offset 0x603, 8bit)
+//----------------------------------------------------------------------------
+#define BW_OPMODE_20MHZ			BIT(2)
+#define BW_OPMODE_5G				BIT(1)
+
+//
+// 10. Power Save Control Registers
+//
+#define WOW_PMEN				BIT(0) // Power management Enable.
+#define WOW_WOMEN				BIT(1) // WoW function on or off.
+#define WOW_MAGIC				BIT(2) // Magic packet
+#define WOW_UWF				BIT(3) // Unicast Wakeup frame.
+
+//
+// 12. Host Interrupt Status Registers
+//
+//----------------------------------------------------------------------------
+//      8190 IMR/ISR bits
+//----------------------------------------------------------------------------
+#define IMR8190_DISABLED		0x0
+#define IMR_DISABLED			0x0
+// IMR DW0 Bit 0-31
+#define IMR_BCNDMAINT6			BIT(31)		// Beacon DMA Interrupt 6
+#define IMR_BCNDMAINT5			BIT(30)		// Beacon DMA Interrupt 5
+#define IMR_BCNDMAINT4			BIT(29)		// Beacon DMA Interrupt 4
+#define IMR_BCNDMAINT3			BIT(28)		// Beacon DMA Interrupt 3
+#define IMR_BCNDMAINT2			BIT(27)		// Beacon DMA Interrupt 2
+#define IMR_BCNDMAINT1			BIT(26)		// Beacon DMA Interrupt 1
+#define IMR_BCNDOK8				BIT(25)		// Beacon Queue DMA OK Interrup 8
+#define IMR_BCNDOK7				BIT(24)		// Beacon Queue DMA OK Interrup 7
+#define IMR_BCNDOK6				BIT(23)		// Beacon Queue DMA OK Interrup 6
+#define IMR_BCNDOK5				BIT(22)		// Beacon Queue DMA OK Interrup 5
+#define IMR_BCNDOK4				BIT(21)		// Beacon Queue DMA OK Interrup 4
+#define IMR_BCNDOK3				BIT(20)		// Beacon Queue DMA OK Interrup 3
+#define IMR_BCNDOK2				BIT(19)		// Beacon Queue DMA OK Interrup 2
+#define IMR_BCNDOK1				BIT(18)		// Beacon Queue DMA OK Interrup 1
+#define IMR_TIMEOUT2			BIT(17)		// Timeout interrupt 2
+#define IMR_TIMEOUT1			BIT(16)		// Timeout interrupt 1
+#define IMR_TXFOVW				BIT(15)		// Transmit FIFO Overflow
+#define IMR_PSTIMEOUT			BIT(14)		// Power save time out interrupt
+#define IMR_BcnInt				BIT(13)		// Beacon DMA Interrupt 0
+#define IMR_RXFOVW				BIT(12)		// Receive FIFO Overflow
+#define IMR_RDU					BIT(11)		// Receive Descriptor Unavailable
+#define IMR_ATIMEND				BIT(10)		// For 92C,ATIM Window End Interrupt. For 8723 and later ICs, it also means P2P CTWin End interrupt.
+#define IMR_BDOK				BIT(9)		// Beacon Queue DMA OK Interrup
+#define IMR_HIGHDOK				BIT(8)		// High Queue DMA OK Interrupt
+#define IMR_TBDOK				BIT(7)		// Transmit Beacon OK interrup
+#define IMR_MGNTDOK			BIT(6)		// Management Queue DMA OK Interrupt
+#define IMR_TBDER				BIT(5)		// For 92C,Transmit Beacon Error Interrupt
+#define IMR_BKDOK				BIT(4)		// AC_BK DMA OK Interrupt
+#define IMR_BEDOK				BIT(3)		// AC_BE DMA OK Interrupt
+#define IMR_VIDOK				BIT(2)		// AC_VI DMA OK Interrupt
+#define IMR_VODOK				BIT(1)		// AC_VO DMA Interrupt
+#define IMR_ROK					BIT(0)		// Receive DMA OK Interrupt
+
+// 13. Host Interrupt Status Extension Register	 (Offset: 0x012C-012Eh)
+#define IMR_TSF_BIT32_TOGGLE	BIT(15)
+#define IMR_BcnInt_E				BIT(12)
+#define IMR_TXERR				BIT(11)
+#define IMR_RXERR				BIT(10)
+#define IMR_C2HCMD				BIT(9)
+#define IMR_CPWM				BIT(8)
+//RSVD [2-7]
+#define IMR_OCPINT				BIT(1)
+#define IMR_WLANOFF			BIT(0)
+
+//----------------------------------------------------------------------------
+// 8723E series PCIE Host IMR/ISR bit
+//----------------------------------------------------------------------------
+// IMR DW0 Bit 0-31
+#define PHIMR_TIMEOUT2				BIT(31)
+#define PHIMR_TIMEOUT1				BIT(30)
+#define PHIMR_PSTIMEOUT			BIT(29)
+#define PHIMR_GTINT4				BIT(28)
+#define PHIMR_GTINT3				BIT(27)
+#define PHIMR_TXBCNERR				BIT(26)
+#define PHIMR_TXBCNOK				BIT(25)
+#define PHIMR_TSF_BIT32_TOGGLE	BIT(24)
+#define PHIMR_BCNDMAINT3			BIT(23)
+#define PHIMR_BCNDMAINT2			BIT(22)
+#define PHIMR_BCNDMAINT1			BIT(21)
+#define PHIMR_BCNDMAINT0			BIT(20)
+#define PHIMR_BCNDOK3				BIT(19)
+#define PHIMR_BCNDOK2				BIT(18)
+#define PHIMR_BCNDOK1				BIT(17)
+#define PHIMR_BCNDOK0				BIT(16)
+#define PHIMR_HSISR_IND_ON			BIT(15)
+#define PHIMR_BCNDMAINT_E			BIT(14)
+#define PHIMR_ATIMEND_E			BIT(13)
+#define PHIMR_ATIM_CTW_END		BIT(12)
+#define PHIMR_HISRE_IND			BIT(11)	// RO. HISRE Indicator (HISRE & HIMRE is true, this bit is set to 1)
+#define PHIMR_C2HCMD				BIT(10)
+#define PHIMR_CPWM2				BIT(9)
+#define PHIMR_CPWM					BIT(8)
+#define PHIMR_HIGHDOK				BIT(7)		// High Queue DMA OK Interrupt
+#define PHIMR_MGNTDOK				BIT(6)		// Management Queue DMA OK Interrupt
+#define PHIMR_BKDOK					BIT(5)		// AC_BK DMA OK Interrupt
+#define PHIMR_BEDOK					BIT(4)		// AC_BE DMA OK Interrupt
+#define PHIMR_VIDOK					BIT(3)		// AC_VI DMA OK Interrupt
+#define PHIMR_VODOK				BIT(2)		// AC_VO DMA Interrupt
+#define PHIMR_RDU					BIT(1)		// Receive Descriptor Unavailable
+#define PHIMR_ROK					BIT(0)		// Receive DMA OK Interrupt
+
+// PCIE Host Interrupt Status Extension bit
+#define PHIMR_BCNDMAINT7			BIT(23)
+#define PHIMR_BCNDMAINT6			BIT(22)
+#define PHIMR_BCNDMAINT5			BIT(21)
+#define PHIMR_BCNDMAINT4			BIT(20)
+#define PHIMR_BCNDOK7				BIT(19)
+#define PHIMR_BCNDOK6				BIT(18)
+#define PHIMR_BCNDOK5				BIT(17)
+#define PHIMR_BCNDOK4				BIT(16)
+// BIT(12) 15: RSVD
+#define PHIMR_TXERR					BIT(11)
+#define PHIMR_RXERR					BIT(10)
+#define PHIMR_TXFOVW				BIT(9)
+#define PHIMR_RXFOVW				BIT(8)
+// BIT(2)-7: RSVD
+#define PHIMR_OCPINT				BIT(1)
+// BIT(0): RSVD
+
+#define UHIMR_TIMEOUT2				BIT(31)
+#define UHIMR_TIMEOUT1				BIT(30)
+#define UHIMR_PSTIMEOUT			BIT(29)
+#define UHIMR_GTINT4				BIT(28)
+#define UHIMR_GTINT3				BIT(27)
+#define UHIMR_TXBCNERR				BIT(26)
+#define UHIMR_TXBCNOK				BIT(25)
+#define UHIMR_TSF_BIT32_TOGGLE	BIT(24)
+#define UHIMR_BCNDMAINT3			BIT(23)
+#define UHIMR_BCNDMAINT2			BIT(22)
+#define UHIMR_BCNDMAINT1			BIT(21)
+#define UHIMR_BCNDMAINT0			BIT(20)
+#define UHIMR_BCNDOK3				BIT(19)
+#define UHIMR_BCNDOK2				BIT(18)
+#define UHIMR_BCNDOK1				BIT(17)
+#define UHIMR_BCNDOK0				BIT(16)
+#define UHIMR_HSISR_IND			BIT(15)
+#define UHIMR_BCNDMAINT_E			BIT(14)
+//RSVD	BIT(13)
+#define UHIMR_CTW_END				BIT(12)
+//RSVD	BIT(11)
+#define UHIMR_C2HCMD				BIT(10)
+#define UHIMR_CPWM2				BIT(9)
+#define UHIMR_CPWM					BIT(8)
+#define UHIMR_HIGHDOK				BIT(7)		// High Queue DMA OK Interrupt
+#define UHIMR_MGNTDOK				BIT(6)		// Management Queue DMA OK Interrupt
+#define UHIMR_BKDOK				BIT(5)		// AC_BK DMA OK Interrupt
+#define UHIMR_BEDOK				BIT(4)		// AC_BE DMA OK Interrupt
+#define UHIMR_VIDOK					BIT(3)		// AC_VI DMA OK Interrupt
+#define UHIMR_VODOK				BIT(2)		// AC_VO DMA Interrupt
+#define UHIMR_RDU					BIT(1)		// Receive Descriptor Unavailable
+#define UHIMR_ROK					BIT(0)		// Receive DMA OK Interrupt
+
+// USB Host Interrupt Status Extension bit
+#define UHIMR_BCNDMAINT7			BIT(23)
+#define UHIMR_BCNDMAINT6			BIT(22)
+#define UHIMR_BCNDMAINT5			BIT(21)
+#define UHIMR_BCNDMAINT4			BIT(20)
+#define UHIMR_BCNDOK7				BIT(19)
+#define UHIMR_BCNDOK6				BIT(18)
+#define UHIMR_BCNDOK5				BIT(17)
+#define UHIMR_BCNDOK4				BIT(16)
+// BIT(14)-15: RSVD
+#define UHIMR_ATIMEND_E			BIT(13)
+#define UHIMR_ATIMEND				BIT(12)
+#define UHIMR_TXERR					BIT(11)
+#define UHIMR_RXERR					BIT(10)
+#define UHIMR_TXFOVW				BIT(9)
+#define UHIMR_RXFOVW				BIT(8)
+// BIT(2)-7: RSVD
+#define UHIMR_OCPINT				BIT(1)
+// BIT(0): RSVD
+
+
+#define HAL_NIC_UNPLUG_ISR			0xFFFFFFFF	// The value when the NIC is unplugged for PCI.
+#define HAL_NIC_UNPLUG_PCI_ISR		0xEAEAEAEA	// The value when the NIC is unplugged for PCI in PCI interrupt (page 3).
+
+//----------------------------------------------------------------------------
+//       8188 IMR/ISR bits
+//----------------------------------------------------------------------------
+#define IMR_DISABLED_88E			0x0
+// IMR DW0(0x0060-0063) Bit 0-31
+#define IMR_TXCCK_88E				BIT(30)		// TXRPT interrupt when CCX bit of the packet is set
+#define IMR_PSTIMEOUT_88E			BIT(29)		// Power Save Time Out Interrupt
+#define IMR_GTINT4_88E				BIT(28)		// When GTIMER4 expires, this bit is set to 1
+#define IMR_GTINT3_88E				BIT(27)		// When GTIMER3 expires, this bit is set to 1
+#define IMR_TBDER_88E				BIT(26)		// Transmit Beacon0 Error
+#define IMR_TBDOK_88E				BIT(25)		// Transmit Beacon0 OK
+#define IMR_TSF_BIT32_TOGGLE_88E	BIT(24)		// TSF Timer BIT(32) toggle indication interrupt
+#define IMR_BCNDMAINT0_88E		BIT(20)		// Beacon DMA Interrupt 0
+#define IMR_BCNDERR0_88E			BIT(16)		// Beacon Queue DMA Error 0
+#define IMR_HSISR_IND_ON_INT_88E	BIT(15)		// HSISR Indicator (HSIMR & HSISR is true, this bit is set to 1)
+#define IMR_BCNDMAINT_E_88E		BIT(14)		// Beacon DMA Interrupt Extension for Win7
+#define IMR_ATIMEND_88E			BIT(12)		// CTWidnow End or ATIM Window End
+#define IMR_HISR1_IND_INT_88E		BIT(11)		// HISR1 Indicator (HISR1 & HIMR1 is true, this bit is set to 1)
+#define IMR_C2HCMD_88E				BIT(10)		// CPU to Host Command INT Status, Write 1 clear
+#define IMR_CPWM2_88E				BIT(9)			// CPU power Mode exchange INT Status, Write 1 clear
+#define IMR_CPWM_88E				BIT(8)			// CPU power Mode exchange INT Status, Write 1 clear
+#define IMR_HIGHDOK_88E			BIT(7)			// High Queue DMA OK
+#define IMR_MGNTDOK_88E			BIT(6)			// Management Queue DMA OK
+#define IMR_BKDOK_88E				BIT(5)			// AC_BK DMA OK
+#define IMR_BEDOK_88E				BIT(4)			// AC_BE DMA OK
+#define IMR_VIDOK_88E				BIT(3)			// AC_VI DMA OK
+#define IMR_VODOK_88E				BIT(2)			// AC_VO DMA OK
+#define IMR_RDU_88E					BIT(1)			// Rx Descriptor Unavailable
+#define IMR_ROK_88E					BIT(0)			// Receive DMA OK
+
+// IMR DW1(0x00B4-00B7) Bit 0-31
+#define IMR_BCNDMAINT7_88E		BIT(27)		// Beacon DMA Interrupt 7
+#define IMR_BCNDMAINT6_88E		BIT(26)		// Beacon DMA Interrupt 6
+#define IMR_BCNDMAINT5_88E		BIT(25)		// Beacon DMA Interrupt 5
+#define IMR_BCNDMAINT4_88E		BIT(24)		// Beacon DMA Interrupt 4
+#define IMR_BCNDMAINT3_88E		BIT(23)		// Beacon DMA Interrupt 3
+#define IMR_BCNDMAINT2_88E		BIT(22)		// Beacon DMA Interrupt 2
+#define IMR_BCNDMAINT1_88E		BIT(21)		// Beacon DMA Interrupt 1
+#define IMR_BCNDOK7_88E			BIT(20)		// Beacon Queue DMA OK Interrup 7
+#define IMR_BCNDOK6_88E			BIT(19)		// Beacon Queue DMA OK Interrup 6
+#define IMR_BCNDOK5_88E			BIT(18)		// Beacon Queue DMA OK Interrup 5
+#define IMR_BCNDOK4_88E			BIT(17)		// Beacon Queue DMA OK Interrup 4
+#define IMR_BCNDOK3_88E			BIT(16)		// Beacon Queue DMA OK Interrup 3
+#define IMR_BCNDOK2_88E			BIT(15)		// Beacon Queue DMA OK Interrup 2
+#define IMR_BCNDOK1_88E			BIT(14)		// Beacon Queue DMA OK Interrup 1
+#define IMR_ATIMEND_E_88E			BIT(13)		// ATIM Window End Extension for Win7
+#define IMR_TXERR_88E				BIT(11)		// Tx Error Flag Interrupt Status, write 1 clear.
+#define IMR_RXERR_88E				BIT(10)		// Rx Error Flag INT Status, Write 1 clear
+#define IMR_TXFOVW_88E				BIT(9)			// Transmit FIFO Overflow
+#define IMR_RXFOVW_88E				BIT(8)			// Receive FIFO Overflow
+
+/*===================================================================
+=====================================================================
+Here the register defines are for 92C. When the define is as same with 92C,
+we will use the 92C's define for the consistency
+So the following defines for 92C is not entire!!!!!!
+=====================================================================
+=====================================================================*/
+/*
+Based on Datasheet V33---090401
+Register Summary
+Current IOREG MAP
+0x0000h ~ 0x00FFh   System Configuration (256 Bytes)
+0x0100h ~ 0x01FFh   MACTOP General Configuration (256 Bytes)
+0x0200h ~ 0x027Fh   TXDMA Configuration (128 Bytes)
+0x0280h ~ 0x02FFh   RXDMA Configuration (128 Bytes)
+0x0300h ~ 0x03FFh   PCIE EMAC Reserved Region (256 Bytes)
+0x0400h ~ 0x04FFh   Protocol Configuration (256 Bytes)
+0x0500h ~ 0x05FFh   EDCA Configuration (256 Bytes)
+0x0600h ~ 0x07FFh   WMAC Configuration (512 Bytes)
+0x2000h ~ 0x3FFFh   8051 FW Download Region (8196 Bytes)
+*/
+	//----------------------------------------------------------------------------
+	//		 8192C (TXPAUSE) transmission pause 	(Offset 0x522, 8 bits)
+	//----------------------------------------------------------------------------
+// Note:
+//	The the bits of stoping AC(VO/VI/BE/BK) queue in datasheet RTL8192S/RTL8192C are wrong,
+//	the correct arragement is VO - BIT(0), VI - BIT(1), BE - BIT(2), and BK - BIT(3).
+//	8723 and 88E may be not correct either in the eralier version. Confirmed with DD Tim.
+// By Bruce, 2011-09-22.
+#define StopBecon		BIT(6)
+#define StopHigh			BIT(5)
+#define StopMgt			BIT(4)
+#define StopBK			BIT(3)
+#define StopBE			BIT(2)
+#define StopVI			BIT(1)
+#define StopVO			BIT(0)
+
+//----------------------------------------------------------------------------
+//       8192C (RCR) Receive Configuration Register	(Offset 0x608, 32 bits)
+//----------------------------------------------------------------------------
+#define RCR_APPFCS				BIT(31)	// WMAC append FCS after pauload
+#define RCR_APP_MIC				BIT(30)	// MACRX will retain the MIC at the bottom of the packet.
+#define RCR_APP_ICV				BIT(29)	// MACRX will retain the ICV at the bottom of the packet.
+#define RCR_APP_PHYST_RXFF		BIT(28)	// PHY Status is appended before RX packet in RXFF
+#define RCR_APP_BA_SSN			BIT(27)	// SSN of previous TXBA is appended as after original RXDESC as the 4-th DW of RXDESC.
+#define RCR_NONQOS_VHT			BIT(26)	// Reserved
+#define RCR_RSVD_BIT25			BIT(25)	// Reserved
+#define RCR_ENMBID				BIT(24)	// Enable Multiple BssId. Only response ACK to the packets whose DID(A1) matching to the addresses in the MBSSID CAM Entries.
+#define RCR_LSIGEN				BIT(23)	// Enable LSIG TXOP Protection function. Search KEYCAM for each rx packet to check if LSIGEN bit is set.
+#define RCR_MFBEN				BIT(22)	// Enable immediate MCS Feedback function. When Rx packet with MRQ = 1'b1, then search KEYCAM to find sender's MCS Feedback function and send response.
+#define RCR_RSVD_BIT21			BIT(21)	// Reserved
+#define RCR_RSVD_BIT20			BIT(20)	// Reserved
+#define RCR_RSVD_BIT19			BIT(19)	// Reserved
+#define RCR_TIM_PARSER_EN		BIT(18)	// RX Beacon TIM Parser.
+#define RCR_BM_DATA_EN			BIT(17)	// Broadcast data packet interrupt enable.
+#define RCR_UC_DATA_EN			BIT(16)	// Unicast data packet interrupt enable.
+#define RCR_RSVD_BIT15			BIT(15)	// Reserved
+#define RCR_HTC_LOC_CTRL		BIT(14)	// MFC<--HTC=1 MFC-->HTC=0
+#define RCR_AMF					BIT(13)	// Accept management type frame
+#define RCR_ACF					BIT(12)	// Accept control type frame. Control frames BA, BAR, and PS-Poll (when in AP mode) are not controlled by this bit. They are controlled by ADF.
+#define RCR_ADF					BIT(11)	// Accept data type frame. This bit also regulates BA, BAR, and PS-Poll (AP mode only).
+#define RCR_RSVD_BIT10			BIT(10)	// Reserved
+#define RCR_AICV					BIT(9)		// Accept ICV error packet
+#define RCR_ACRC32				BIT(8)		// Accept CRC32 error packet
+#define RCR_CBSSID_BCN			BIT(7)		// Accept BSSID match packet (Rx beacon, probe rsp)
+#define RCR_CBSSID_DATA		BIT(6)		// Accept BSSID match packet (Data)
+#define RCR_CBSSID				RCR_CBSSID_DATA	// Accept BSSID match packet
+#define RCR_APWRMGT			BIT(5)		// Accept power management packet
+#define RCR_ADD3				BIT(4)		// Accept address 3 match packet
+#define RCR_AB					BIT(3)		// Accept broadcast packet
+#define RCR_AM					BIT(2)		// Accept multicast packet
+#define RCR_APM					BIT(1)		// Accept physical match packet
+#define RCR_AAP					BIT(0)		// Accept all unicast packet
+
+
+//-----------------------------------------------------
+//
+//	0x0000h ~ 0x00FFh	System Configuration
+//
+//-----------------------------------------------------
+
+//2 SYS_ISO_CTRL
+#define ISO_MD2PP				BIT(0)
+#define ISO_UA2USB				BIT(1)
+#define ISO_UD2CORE				BIT(2)
+#define ISO_PA2PCIE				BIT(3)
+#define ISO_PD2CORE				BIT(4)
+#define ISO_IP2MAC				BIT(5)
+#define ISO_DIOP					BIT(6)
+#define ISO_DIOE					BIT(7)
+#define ISO_EB2CORE				BIT(8)
+#define ISO_DIOR					BIT(9)
+#define PWC_EV12V				BIT(15)
+
+
+//2 SYS_FUNC_EN
+#define FEN_BBRSTB				BIT(0)
+#define FEN_BB_GLB_RSTn		BIT(1)
+#define FEN_USBA				BIT(2)
+#define FEN_UPLL				BIT(3)
+#define FEN_USBD				BIT(4)
+#define FEN_DIO_PCIE			BIT(5)
+#define FEN_PCIEA				BIT(6)
+#define FEN_PPLL					BIT(7)
+#define FEN_PCIED				BIT(8)
+#define FEN_DIOE				BIT(9)
+#define FEN_CPUEN				BIT(10)
+#define FEN_DCORE				BIT(11)
+#define FEN_ELDR				BIT(12)
+//#define FEN_DIO_RF				BIT(13)
+#define FEN_HWPDN				BIT(14)
+#define FEN_MREGEN				BIT(15)
+
+//2 APS_FSMCO
+#define PFM_LDALL				BIT(0)
+#define PFM_ALDN				BIT(1)
+#define PFM_LDKP				BIT(2)
+#define PFM_WOWL				BIT(3)
+#define EnPDN					BIT(4)
+#define PDN_PL					BIT(5)
+#define APFM_ONMAC				BIT(8)
+#define APFM_OFF				BIT(9)
+#define APFM_RSM				BIT(10)
+#define AFSM_HSUS				BIT(11)
+#define AFSM_PCIE				BIT(12)
+#define APDM_MAC				BIT(13)
+#define APDM_HOST				BIT(14)
+#define APDM_HPDN				BIT(15)
+#define RDY_MACON				BIT(16)
+#define SUS_HOST				BIT(17)
+#define ROP_ALD					BIT(20)
+#define ROP_PWR					BIT(21)
+#define ROP_SPS					BIT(22)
+#define SOP_MRST				BIT(25)
+#define SOP_FUSE				BIT(26)
+#define SOP_ABG					BIT(27)
+#define SOP_AMB					BIT(28)
+#define SOP_RCK					BIT(29)
+#define SOP_A8M					BIT(30)
+#define XOP_BTCK				BIT(31)
+
+//2 SYS_CLKR
+#define ANAD16V_EN				BIT(0)
+#define ANA8M					BIT(1)
+#define MACSLP					BIT(4)
+#define LOADER_CLK_EN			BIT(5)
+
+
+//2 9346CR /REG_SYS_EEPROM_CTRL
+#define BOOT_FROM_EEPROM		BIT(4)
+#define EEPROMSEL				BIT(4)
+#define EEPROM_EN				BIT(5)
+
+
+//2 RF_CTRL
+#define RF_EN					BIT(0)
+#define RF_RSTB					BIT(1)
+#define RF_SDMRSTB				BIT(2)
+
+
+//2 LDOV12D_CTRL
+#define LDV12_EN				BIT(0)
+#define LDV12_SDBY				BIT(1)
+#define LPLDO_HSM				BIT(2)
+#define LPLDO_LSM_DIS			BIT(3)
+#define _LDV12_VADJ(x)			(((x) & 0xF) << 4)
+
+
+
+//2 EFUSE_TEST (For RTL8723 partially)
+#define EF_TRPT					BIT(7)
+#define EF_CELL_SEL				(BIT(8)|BIT(9)) // 00: Wifi Efuse, 01: BT Efuse0, 10: BT Efuse1, 11: BT Efuse2
+#define LDOE25_EN				BIT(31)
+#define EFUSE_SEL(x)				(((x) & 0x3) << 8)
+#define EFUSE_SEL_MASK			0x300
+#define EFUSE_WIFI_SEL_0		0x0
+#define EFUSE_BT_SEL_0			0x1
+#define EFUSE_BT_SEL_1			0x2
+#define EFUSE_BT_SEL_2			0x3
+
+
+//2 8051FWDL
+//2 MCUFWDL
+#define MCUFWDL_EN				BIT(0)
+#define MCUFWDL_RDY			BIT(1)
+#define FWDL_ChkSum_rpt		BIT(2)
+#define MACINI_RDY				BIT(3)
+#define BBINI_RDY				BIT(4)
+#define RFINI_RDY				BIT(5)
+#define WINTINI_RDY				BIT(6)
+#define RAM_DL_SEL				BIT(7)
+#define ROM_DLEN				BIT(19)
+#define CPRST					BIT(23)
+
+
+//2 REG_SYS_CFG
+#define XCLK_VLD				BIT(0)
+#define ACLK_VLD				BIT(1)
+#define UCLK_VLD				BIT(2)
+#define PCLK_VLD				BIT(3)
+#define PCIRSTB					BIT(4)
+#define V15_VLD					BIT(5)
+#define SW_OFFLOAD_EN			BIT(7)
+#define SIC_IDLE					BIT(8)
+#define BD_MAC2					BIT(9)
+#define BD_MAC1					BIT(10)
+#define IC_MACPHY_MODE		BIT(11)
+#define CHIP_VER				(BIT(12)|BIT(13)|BIT(14)|BIT(15))
+#define BT_FUNC					BIT(16)
+#define VENDOR_ID				BIT(19)
+#define EXT_VENDOR_ID			(BIT(18)|BIT(19)) //Currently only for RTL8723B
+#define PAD_HWPD_IDN			BIT(22)
+#define TRP_VAUX_EN				BIT(23)	// RTL ID
+#define TRP_BT_EN				BIT(24)
+#define BD_PKG_SEL				BIT(25)
+#define BD_HCI_SEL				BIT(26)
+#define TYPE_ID					BIT(27)
+#define RF_TYPE_ID				BIT(27)
+
+#define RTL_ID					BIT(23) // TestChip ID, 1:Test(RLE); 0:MP(RL)
+#define SPS_SEL					BIT(24) // 1:LDO regulator mode; 0:Switching regulator mode
+
+
+#define CHIP_VER_RTL_MASK		0xF000	//Bit 12 ~ 15
+#define CHIP_VER_RTL_SHIFT		12
+#define EXT_VENDOR_ID_SHIFT	18
+
+//2 REG_GPIO_OUTSTS (For RTL8723 only)
+#define EFS_HCI_SEL				(BIT(0)|BIT(1))
+#define PAD_HCI_SEL				(BIT(2)|BIT(3))
+#define HCI_SEL					(BIT(4)|BIT(5))
+#define PKG_SEL_HCI				BIT(6)
+#define FEN_GPS					BIT(7)
+#define FEN_BT					BIT(8)
+#define FEN_WL					BIT(9)
+#define FEN_PCI					BIT(10)
+#define FEN_USB					BIT(11)
+#define BTRF_HWPDN_N			BIT(12)
+#define WLRF_HWPDN_N			BIT(13)
+#define PDN_BT_N				BIT(14)
+#define PDN_GPS_N				BIT(15)
+#define BT_CTL_HWPDN			BIT(16)
+#define GPS_CTL_HWPDN			BIT(17)
+#define PPHY_SUSB				BIT(20)
+#define UPHY_SUSB				BIT(21)
+#define PCI_SUSEN				BIT(22)
+#define USB_SUSEN				BIT(23)
+#define RF_RL_ID					(BIT(31)|BIT(30)|BIT(29)|BIT(28))
+
+
+//-----------------------------------------------------
+//
+//	0x0100h ~ 0x01FFh	MACTOP General Configuration
+//
+//-----------------------------------------------------
+
+//2 Function Enable Registers
+//2 CR
+#define HCI_TXDMA_EN			BIT(0)
+#define HCI_RXDMA_EN			BIT(1)
+#define TXDMA_EN				BIT(2)
+#define RXDMA_EN				BIT(3)
+#define PROTOCOL_EN				BIT(4)
+#define SCHEDULE_EN				BIT(5)
+#define MACTXEN					BIT(6)
+#define MACRXEN					BIT(7)
+#define ENSWBCN					BIT(8)
+#define ENSEC					BIT(9)
+#define CALTMR_EN				BIT(10)	// 32k CAL TMR enable
+
+// Network type
+#define _NETTYPE(x)				(((x) & 0x3) << 16)
+#define MASK_NETTYPE			0x30000
+#define NT_NO_LINK				0x0
+#define NT_LINK_AD_HOC			0x1
+#define NT_LINK_AP				0x2
+#define NT_AS_AP				0x3
+
+//2 PBP - Page Size Register
+#define GET_RX_PAGE_SIZE(value)			((value) & 0xF)
+#define GET_TX_PAGE_SIZE(value)			(((value) & 0xF0) >> 4)
+#define _PSRX_MASK				0xF
+#define _PSTX_MASK				0xF0
+#define _PSRX(x)				(x)
+#define _PSTX(x)				((x) << 4)
+
+#define PBP_64					0x0
+#define PBP_128					0x1
+#define PBP_256					0x2
+#define PBP_512					0x3
+#define PBP_1024				0x4
+
+
+//2 TX/RXDMA
+#define RXDMA_ARBBW_EN		BIT(0)
+#define RXSHFT_EN				BIT(1)
+#define RXDMA_AGG_EN			BIT(2)
+#define QS_VO_QUEUE			BIT(8)
+#define QS_VI_QUEUE				BIT(9)
+#define QS_BE_QUEUE			BIT(10)
+#define QS_BK_QUEUE			BIT(11)
+#define QS_MANAGER_QUEUE		BIT(12)
+#define QS_HIGH_QUEUE			BIT(13)
+
+#define HQSEL_VOQ				BIT(0)
+#define HQSEL_VIQ				BIT(1)
+#define HQSEL_BEQ				BIT(2)
+#define HQSEL_BKQ				BIT(3)
+#define HQSEL_MGTQ				BIT(4)
+#define HQSEL_HIQ				BIT(5)
+
+// For normal driver, 0x10C
+#define _TXDMA_CMQ_MAP(x) 	 		(((x)&0x3) << 16)
+#define _TXDMA_HIQ_MAP(x) 	 		(((x)&0x3) << 14)
+#define _TXDMA_MGQ_MAP(x) 	 		(((x)&0x3) << 12)
+#define _TXDMA_BKQ_MAP(x) 	 		(((x)&0x3) << 10)
+#define _TXDMA_BEQ_MAP(x) 	 		(((x)&0x3) << 8 )
+#define _TXDMA_VIQ_MAP(x) 	 		(((x)&0x3) << 6 )
+#define _TXDMA_VOQ_MAP(x) 	 		(((x)&0x3) << 4 )
+
+#define QUEUE_EXTRA				0
+#define QUEUE_LOW				1
+#define QUEUE_NORMAL			2
+#define QUEUE_HIGH				3
+
+
+//2 TRXFF_BNDY
+
+
+//2 LLT_INIT
+#define _LLT_NO_ACTIVE				0x0
+#define _LLT_WRITE_ACCESS			0x1
+#define _LLT_READ_ACCESS			0x2
+
+#define _LLT_INIT_DATA(x)			((x) & 0xFF)
+#define _LLT_INIT_ADDR(x)			(((x) & 0xFF) << 8)
+#define _LLT_OP(x)					(((x) & 0x3) << 30)
+#define _LLT_OP_VALUE(x)			(((x) >> 30) & 0x3)
+
+
+//-----------------------------------------------------
+//
+//	0x0200h ~ 0x027Fh	TXDMA Configuration
+//
+//-----------------------------------------------------
+//2 RQPN
+#define _HPQ(x)					((x) & 0xFF)
+#define _LPQ(x)					(((x) & 0xFF) << 8)
+#define _PUBQ(x)					(((x) & 0xFF) << 16)
+#define _NPQ(x)					((x) & 0xFF)			// NOTE: in RQPN_NPQ register
+#define _EPQ(x)					(((x) & 0xFF) << 16)	// NOTE: in RQPN_EPQ register
+
+
+#define HPQ_PUBLIC_DIS			BIT(24)
+#define LPQ_PUBLIC_DIS			BIT(25)
+#define LD_RQPN					BIT(31)
+
+
+//2 TDECTL
+#define BLK_DESC_NUM_SHIFT			4
+#define BLK_DESC_NUM_MASK			0xF
+
+
+//2 TXDMA_OFFSET_CHK
+#define DROP_DATA_EN				BIT(9)
+
+//-----------------------------------------------------
+//
+//	0x0280h ~ 0x028Bh	RX DMA Configuration
+//
+//-----------------------------------------------------
+
+//2 REG_RXDMA_CONTROL, 0x0286h
+// Write only. When this bit is set, RXDMA will decrease RX PKT counter by one. Before
+// this bit is polled, FW shall update RXFF_RD_PTR first. This register is write pulse and auto clear.
+//#define RXPKT_RELEASE_POLL			BIT(0)
+// Read only. When RXMA finishes on-going DMA operation, RXMDA will report idle state in
+// this bit. FW can start releasing packets after RXDMA entering idle mode.
+//#define RXDMA_IDLE					BIT(1)
+// When this bit is set, RXDMA will enter this mode after on-going RXDMA packet to host
+// completed, and stop DMA packet to host. RXDMA will then report Default: 0;
+//#define RW_RELEASE_EN				BIT(2)
+
+//2 REG_RXPKT_NUM, 0x0284
+#define 	RXPKT_RELEASE_POLL	BIT(16)
+#define	RXDMA_IDLE				BIT(17)
+#define	RW_RELEASE_EN			BIT(18)
+
+//-----------------------------------------------------
+//
+//	0x0400h ~ 0x047Fh	Protocol Configuration
+//
+//-----------------------------------------------------
+//2 FWHW_TXQ_CTRL
+#define EN_AMPDU_RTY_NEW			BIT(7)
+
+
+//2 SPEC SIFS
+#define _SPEC_SIFS_CCK(x)			((x) & 0xFF)
+#define _SPEC_SIFS_OFDM(x)			(((x) & 0xFF) << 8)
+
+//2 RL
+#define	RETRY_LIMIT_SHORT_SHIFT			8
+#define	RETRY_LIMIT_LONG_SHIFT			0
+
+//-----------------------------------------------------
+//
+//	0x0500h ~ 0x05FFh	EDCA Configuration
+//
+//-----------------------------------------------------
+
+//2 EDCA setting
+#define AC_PARAM_TXOP_LIMIT_OFFSET		16
+#define AC_PARAM_ECW_MAX_OFFSET			12
+#define AC_PARAM_ECW_MIN_OFFSET			8
+#define AC_PARAM_AIFS_OFFSET				0
+
+
+#define _LRL(x)					((x) & 0x3F)
+#define _SRL(x)					(((x) & 0x3F) << 8)
+
+
+//2 BCN_CTRL
+#define EN_TXBCN_RPT			BIT(2)
+#define EN_BCN_FUNCTION		BIT(3)
+#define STOP_BCNQ				BIT(6)
+#define DIS_RX_BSSID_FIT		BIT(6)
+
+#define DIS_ATIM					BIT(0)
+#define DIS_BCNQ_SUB			BIT(1)
+#define DIS_TSF_UDT				BIT(4)
+
+// The same function but different bit field.
+#define DIS_TSF_UDT0_NORMAL_CHIP	BIT(4)
+#define DIS_TSF_UDT0_TEST_CHIP	BIT(5)
+
+
+//2 ACMHWCTRL
+#define AcmHw_HwEn				BIT(0)
+#define AcmHw_BeqEn			BIT(1)
+#define AcmHw_ViqEn				BIT(2)
+#define AcmHw_VoqEn			BIT(3)
+#define AcmHw_BeqStatus		BIT(4)
+#define AcmHw_ViqStatus			BIT(5)
+#define AcmHw_VoqStatus		BIT(6)
+
+//2 //REG_DUAL_TSF_RST (0x553)
+#define DUAL_TSF_RST_P2P		BIT(4)
+
+//2 // REG_NOA_DESC_SEL (0x5CF)
+#define NOA_DESC_SEL_0			0
+#define NOA_DESC_SEL_1			BIT(4)
+
+//-----------------------------------------------------
+//
+//	0x0600h ~ 0x07FFh	WMAC Configuration
+//
+//-----------------------------------------------------
+
+//2 APSD_CTRL
+#define APSDOFF					BIT(6)
+
+//2 TCR
+#define TSFRST					BIT(0)
+#define DIS_GCLK					BIT(1)
+#define PAD_SEL					BIT(2)
+#define PWR_ST					BIT(6)
+#define PWRBIT_OW_EN			BIT(7)
+#define ACRC						BIT(8)
+#define CFENDFORM				BIT(9)
+#define ICV						BIT(10)
+
+
+//2 RCR
+#define AAP						BIT(0)
+#define APM						BIT(1)
+#define AM						BIT(2)
+#define AB						BIT(3)
+#define ADD3						BIT(4)
+#define APWRMGT				BIT(5)
+#define CBSSID					BIT(6)
+#define CBSSID_DATA				BIT(6)
+#define CBSSID_BCN				BIT(7)
+#define ACRC32					BIT(8)
+#define AICV						BIT(9)
+#define ADF						BIT(11)
+#define ACF						BIT(12)
+#define AMF						BIT(13)
+#define HTC_LOC_CTRL			BIT(14)
+#define UC_DATA_EN				BIT(16)
+#define BM_DATA_EN				BIT(17)
+#define MFBEN					BIT(22)
+#define LSIGEN					BIT(23)
+#define EnMBID					BIT(24)
+#define FORCEACK				BIT(26)
+#define APP_BASSN				BIT(27)
+#define APP_PHYSTS				BIT(28)
+#define APP_ICV					BIT(29)
+#define APP_MIC					BIT(30)
+#define APP_FCS					BIT(31)
+
+
+//2 SECCFG
+#define SCR_TxUseDK				BIT(0)			//Force Tx Use Default Key
+#define SCR_RxUseDK				BIT(1)			//Force Rx Use Default Key
+#define SCR_TxEncEnable			BIT(2)			//Enable Tx Encryption
+#define SCR_RxDecEnable			BIT(3)			//Enable Rx Decryption
+#define SCR_SKByA2				BIT(4)			//Search kEY BY A2
+#define SCR_NoSKMC				BIT(5)			//No Key Search Multicast
+#define SCR_TXBCUSEDK			BIT(6)			// Force Tx Broadcast packets Use Default Key
+#define SCR_RXBCUSEDK			BIT(7)			// Force Rx Broadcast packets Use Default Key
+
+//-----------------------------------------------------
+//
+//	0xFE00h ~ 0xFE55h	RTL8723 SDIO Configuration
+//
+//-----------------------------------------------------
+
+// I/O bus domain address mapping
+#define SDIO_LOCAL_BASE		0x10250000
+#define WLAN_IOREG_BASE		0x10260000
+#define FIRMWARE_FIFO_BASE	0x10270000
+#define TX_HIQ_BASE				0x10310000
+#define TX_MIQ_BASE				0x10320000
+#define TX_LOQ_BASE				0x10330000
+#define RX_RX0FF_BASE			0x10340000
+
+//SDIO host local register space mapping.
+#define SDIO_LOCAL_MSK				0x0FFF
+#define WLAN_IOREG_MSK 	             	0x7FFF
+#define WLAN_FIFO_MSK			      	0x1FFF	// Aggregation Length[12:0]
+#define WLAN_RX0FF_MSK			      	0x0003
+
+#define SDIO_WITHOUT_REF_DEVICE_ID	0	// Without reference to the SDIO Device ID
+#define SDIO_LOCAL_DEVICE_ID           		0	// 0b[16], 000b[15:13]
+#define WLAN_TX_HIQ_DEVICE_ID			4	// 0b[16], 100b[15:13]
+#define WLAN_TX_MIQ_DEVICE_ID 		5	// 0b[16], 101b[15:13]
+#define WLAN_TX_LOQ_DEVICE_ID 		6	// 0b[16], 110b[15:13]
+#define WLAN_RX0FF_DEVICE_ID 			7	// 0b[16], 111b[15:13]
+#define WLAN_IOREG_DEVICE_ID 			8	// 1b[16]
+
+//SDIO Tx Free Page Index
+#define HI_QUEUE_IDX           			0
+#define MID_QUEUE_IDX         			1
+#define LOW_QUEUE_IDX 	      			2
+#define PUBLIC_QUEUE_IDX    			3
+
+#define SDIO_MAX_TX_QUEUE			3		// HIQ, MIQ and LOQ
+#define SDIO_MAX_RX_QUEUE			1
+
+#define SDIO_REG_TX_CTRL			0x0000 // SDIO Tx Control
+#define SDIO_REG_HIMR				0x0014 // SDIO Host Interrupt Mask
+#define SDIO_REG_HISR				0x0018 // SDIO Host Interrupt Service Routine
+#define SDIO_REG_HCPWM			0x0019 // HCI Current Power Mode
+#define SDIO_REG_RX0_REQ_LEN		0x001C // RXDMA Request Length
+#define SDIO_REG_FREE_TXPG			0x0020 // Free Tx Buffer Page
+#define SDIO_REG_HCPWM1			0x0024 // HCI Current Power Mode 1
+#define SDIO_REG_HCPWM2			0x0026 // HCI Current Power Mode 2
+#define SDIO_REG_HTSFR_INFO		0x0030 // HTSF Informaion
+#define SDIO_REG_HRPWM1			0x0080 // HCI Request Power Mode 1
+#define SDIO_REG_HRPWM2			0x0082 // HCI Request Power Mode 2
+#define SDIO_REG_HPS_CLKR			0x0084 // HCI Power Save Clock
+#define SDIO_REG_HSUS_CTRL			0x0086 // SDIO HCI Suspend Control
+#define SDIO_REG_HIMR_ON			0x0090 //SDIO Host Extension Interrupt Mask Always
+#define SDIO_REG_HISR_ON			0x0091 //SDIO Host Extension Interrupt Status Always
+
+#define SDIO_HIMR_DISABLED			0
+
+// RTL8723/RTL8188E SDIO Host Interrupt Mask Register
+#define SDIO_HIMR_RX_REQUEST_MSK		BIT(0)
+#define SDIO_HIMR_AVAL_MSK			BIT(1)
+#define SDIO_HIMR_TXERR_MSK			BIT(2)
+#define SDIO_HIMR_RXERR_MSK			BIT(3)
+#define SDIO_HIMR_TXFOVW_MSK			BIT(4)
+#define SDIO_HIMR_RXFOVW_MSK			BIT(5)
+#define SDIO_HIMR_TXBCNOK_MSK			BIT(6)
+#define SDIO_HIMR_TXBCNERR_MSK		BIT(7)
+#define SDIO_HIMR_BCNERLY_INT_MSK		BIT(16)
+#define SDIO_HIMR_C2HCMD_MSK			BIT(17)
+#define SDIO_HIMR_CPWM1_MSK			BIT(18)
+#define SDIO_HIMR_CPWM2_MSK			BIT(19)
+#define SDIO_HIMR_HSISR_IND_MSK		BIT(20)
+#define SDIO_HIMR_GTINT3_IND_MSK		BIT(21)
+#define SDIO_HIMR_GTINT4_IND_MSK		BIT(22)
+#define SDIO_HIMR_PSTIMEOUT_MSK		BIT(23)
+#define SDIO_HIMR_OCPINT_MSK			BIT(24)
+#define SDIO_HIMR_ATIMEND_MSK			BIT(25)
+#define SDIO_HIMR_ATIMEND_E_MSK		BIT(26)
+#define SDIO_HIMR_CTWEND_MSK			BIT(27)
+
+//RTL8188E SDIO Specific
+#define SDIO_HIMR_MCU_ERR_MSK			BIT(28)
+#define SDIO_HIMR_TSF_BIT32_TOGGLE_MSK		BIT(29)
+
+// SDIO Host Interrupt Service Routine
+#define SDIO_HISR_RX_REQUEST			BIT(0)
+#define SDIO_HISR_AVAL					BIT(1)
+#define SDIO_HISR_TXERR					BIT(2)
+#define SDIO_HISR_RXERR					BIT(3)
+#define SDIO_HISR_TXFOVW				BIT(4)
+#define SDIO_HISR_RXFOVW				BIT(5)
+#define SDIO_HISR_TXBCNOK				BIT(6)
+#define SDIO_HISR_TXBCNERR				BIT(7)
+#define SDIO_HISR_BCNERLY_INT			BIT(16)
+#define SDIO_HISR_C2HCMD				BIT(17)
+#define SDIO_HISR_CPWM1				BIT(18)
+#define SDIO_HISR_CPWM2				BIT(19)
+#define SDIO_HISR_HSISR_IND			BIT(20)
+#define SDIO_HISR_GTINT3_IND			BIT(21)
+#define SDIO_HISR_GTINT4_IND			BIT(22)
+#define SDIO_HISR_PSTIMEOUT			BIT(23)
+#define SDIO_HISR_OCPINT				BIT(24)
+#define SDIO_HISR_ATIMEND				BIT(25)
+#define SDIO_HISR_ATIMEND_E			BIT(26)
+#define SDIO_HISR_CTWEND				BIT(27)
+
+//RTL8188E SDIO Specific
+#define SDIO_HISR_MCU_ERR				BIT(28)
+#define SDIO_HISR_TSF_BIT32_TOGGLE	BIT(29)
+
+#define MASK_SDIO_HISR_CLEAR		(SDIO_HISR_TXERR |\
+									SDIO_HISR_RXERR |\
+									SDIO_HISR_TXFOVW |\
+									SDIO_HISR_RXFOVW |\
+									SDIO_HISR_TXBCNOK |\
+									SDIO_HISR_TXBCNERR |\
+									SDIO_HISR_C2HCMD |\
+									SDIO_HISR_CPWM1 |\
+									SDIO_HISR_CPWM2 |\
+									SDIO_HISR_HSISR_IND |\
+									SDIO_HISR_GTINT3_IND |\
+									SDIO_HISR_GTINT4_IND |\
+									SDIO_HISR_PSTIMEOUT |\
+									SDIO_HISR_OCPINT)
+
+// SDIO HCI Suspend Control Register
+#define HCI_RESUME_PWR_RDY			BIT(1)
+#define HCI_SUS_CTRL					BIT(0)
+
+// SDIO Tx FIFO related
+#define SDIO_TX_FREE_PG_QUEUE			4	// The number of Tx FIFO free page
+#define SDIO_TX_FIFO_PAGE_SZ 			128
+
+	#define MAX_TX_AGG_PACKET_NUMBER 	0xFF
+	#define MAX_TX_AGG_PACKET_NUMBER_8812 	64
+
+//-----------------------------------------------------
+//
+//	0xFE00h ~ 0xFE55h	USB Configuration
+//
+//-----------------------------------------------------
+
+//2 USB Information (0xFE17)
+#define USB_IS_HIGH_SPEED			0
+#define USB_IS_FULL_SPEED			1
+#define USB_SPEED_MASK				BIT(5)
+
+#define USB_NORMAL_SIE_EP_MASK	0xF
+#define USB_NORMAL_SIE_EP_SHIFT	4
+
+//2 Special Option
+#define USB_AGG_EN				BIT(3)
+
+// 0; Use interrupt endpoint to upload interrupt pkt
+// 1; Use bulk endpoint to upload interrupt pkt,
+#define INT_BULK_SEL			BIT(4)
+
+//2REG_C2HEVT_CLEAR
+#define C2H_EVT_HOST_CLOSE		0x00	// Set by driver and notify FW that the driver has read the C2H command message
+#define C2H_EVT_FW_CLOSE		0xFF	// Set by FW indicating that FW had set the C2H command message and it's not yet read by driver.
+
+
+//2REG_MULTI_FUNC_CTRL(For RTL8723 Only)
+#define WL_HWPDN_EN			BIT(0)	// Enable GPIO[9] as WiFi HW PDn source
+#define WL_HWPDN_SL			BIT(1)	// WiFi HW PDn polarity control
+#define WL_FUNC_EN				BIT(2)	// WiFi function enable
+#define WL_HWROF_EN			BIT(3)	// Enable GPIO[9] as WiFi RF HW PDn source
+#define BT_HWPDN_EN			BIT(16)	// Enable GPIO[11] as BT HW PDn source
+#define BT_HWPDN_SL			BIT(17)	// BT HW PDn polarity control
+#define BT_FUNC_EN				BIT(18)	// BT function enable
+#define BT_HWROF_EN			BIT(19)	// Enable GPIO[11] as BT/GPS RF HW PDn source
+#define GPS_HWPDN_EN			BIT(20)	// Enable GPIO[10] as GPS HW PDn source
+#define GPS_HWPDN_SL			BIT(21)	// GPS HW PDn polarity control
+#define GPS_FUNC_EN			BIT(22)	// GPS function enable
+
+//3 REG_LIFECTRL_CTRL
+#define HAL92C_EN_PKT_LIFE_TIME_BK		BIT(3)
+#define HAL92C_EN_PKT_LIFE_TIME_BE		BIT(2)
+#define HAL92C_EN_PKT_LIFE_TIME_VI		BIT(1)
+#define HAL92C_EN_PKT_LIFE_TIME_VO		BIT(0)
+
+#define HAL92C_MSDU_LIFE_TIME_UNIT		128	// in us, said by Tim.
+
+//2 8192D PartNo.
+#define PARTNO_92D_NIC							(BIT(7)|BIT(6))
+#define PARTNO_92D_NIC_REMARK 				(BIT(5)|BIT(4))
+#define PARTNO_SINGLE_BAND_VS  				BIT(3)
+#define PARTNO_SINGLE_BAND_VS_REMARK 		BIT(1)
+#define PARTNO_CONCURRENT_BAND_VC 			(BIT(3)|BIT(2))
+#define PARTNO_CONCURRENT_BAND_VC_REMARK 	(BIT(1)|BIT(0))
+
+//========================================================
+// General definitions
+//========================================================
+
+#define LAST_ENTRY_OF_TX_PKT_BUFFER_8188E		176
+#define LAST_ENTRY_OF_TX_PKT_BUFFER_8812			255
+#define LAST_ENTRY_OF_TX_PKT_BUFFER_8723B		255
+#define LAST_ENTRY_OF_TX_PKT_BUFFER_8192C		255
+#define LAST_ENTRY_OF_TX_PKT_BUFFER_DUAL_MAC	127
+
+#define POLLING_LLT_THRESHOLD				20
+#define POLLING_READY_TIMEOUT_COUNT		1000
+
+// GPIO BIT
+#define HAL_8192C_HW_GPIO_WPS_BIT	BIT(2)
+
+#endif //__HAL_COMMON_H__
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/include/HalHWImg8812A_BB.h linux-4.9.8821au/drivers/staging/rtl8821au/include/HalHWImg8812A_BB.h
--- linux-4.9/drivers/staging/rtl8821au/include/HalHWImg8812A_BB.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/include/HalHWImg8812A_BB.h	2016-12-11 19:48:25.170311727 -0600
@@ -0,0 +1,48 @@
+/******************************************************************************
+*
+* Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or modify it
+* under the terms of version 2 of the GNU General Public License as
+* published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along with
+* this program; if not, write to the Free Software Foundation, Inc.,
+* 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+*
+*
+******************************************************************************/
+
+#ifndef __INC_MP_BB_HW_IMG_8812A_H
+#define __INC_MP_BB_HW_IMG_8812A_H
+
+static bool CheckCondition(const uint32_t Condition, const uint32_t Hex);
+
+/******************************************************************************
+*                           AGC_TAB.TXT
+******************************************************************************/
+
+/******************************************************************************
+*                           PHY_REG.TXT
+******************************************************************************/
+
+/******************************************************************************
+*                           PHY_REG_PG.TXT
+******************************************************************************/
+
+void ODM_ReadAndConfig_MP_8812A_PHY_REG_PG(struct rtl_priv *rtlpriv);
+
+/******************************************************************************
+*                           PHY_REG_PG_ASUS.TXT
+******************************************************************************/
+
+void ODM_ReadAndConfig_MP_8812A_PHY_REG_PG_ASUS(struct rtl_priv *rtlpriv);
+
+
+#endif
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/include/HalHWImg8812A_FW.h linux-4.9.8821au/drivers/staging/rtl8821au/include/HalHWImg8812A_FW.h
--- linux-4.9/drivers/staging/rtl8821au/include/HalHWImg8812A_FW.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/include/HalHWImg8812A_FW.h	2016-12-11 19:48:25.170311727 -0600
@@ -0,0 +1,54 @@
+/******************************************************************************
+*
+* Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or modify it
+* under the terms of version 2 of the GNU General Public License as
+* published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along with
+* this program; if not, write to the Free Software Foundation, Inc.,
+* 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+*
+*
+******************************************************************************/
+
+#ifndef __INC_MP_FW_HW_IMG_8812A_H
+#define __INC_MP_FW_HW_IMG_8812A_H
+
+
+/******************************************************************************
+*                           FW_NIC.TXT
+******************************************************************************/
+
+void ODM_ReadFirmware_MP_8812A_FW_NIC(u8 **pFirmware, uint32_t *pFirmwareSize);
+
+/******************************************************************************
+*                           FW_NIC_BT.TXT
+******************************************************************************/
+
+void
+ODM_ReadFirmware_MP_8812A_FW_NIC_BT(
+     IN   struct _rtw_dm *   pDM_Odm,
+     OUT  u8       *pFirmware,
+     OUT  uint32_t       *pFirmwareSize
+);
+
+/******************************************************************************
+*                           FW_WoWLAN.TXT
+******************************************************************************/
+
+void
+ODM_ReadFirmware_MP_8812A_FW_WoWLAN(
+     IN   struct _rtw_dm *   pDM_Odm,
+     OUT  u8       *pFirmware,
+     OUT  uint32_t       *pFirmwareSize
+);
+
+#endif
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/include/HalHWImg8821A_BB.h linux-4.9.8821au/drivers/staging/rtl8821au/include/HalHWImg8821A_BB.h
--- linux-4.9/drivers/staging/rtl8821au/include/HalHWImg8821A_BB.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/include/HalHWImg8821A_BB.h	2016-12-11 19:48:25.170311727 -0600
@@ -0,0 +1,43 @@
+/******************************************************************************
+*
+* Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or modify it
+* under the terms of version 2 of the GNU General Public License as
+* published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along with
+* this program; if not, write to the Free Software Foundation, Inc.,
+* 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+*
+*
+******************************************************************************/
+
+#ifndef __INC_MP_BB_HW_IMG_8821A_H
+#define __INC_MP_BB_HW_IMG_8821A_H
+
+static bool CheckCondition(const uint32_t Condition, const uint32_t Hex);
+
+/******************************************************************************
+*                           AGC_TAB.TXT
+******************************************************************************/
+
+void ODM_ReadAndConfig_MP_8821A_AGC_TAB(struct rtl_priv *rtlpirv);
+
+/******************************************************************************
+*                           PHY_REG.TXT
+******************************************************************************/
+
+/******************************************************************************
+*                           PHY_REG_PG.TXT
+******************************************************************************/
+
+void ODM_ReadAndConfig_MP_8821A_PHY_REG_PG(struct rtl_priv *rtlpriv);
+
+#endif
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/include/HalHWImg8821A_FW.h linux-4.9.8821au/drivers/staging/rtl8821au/include/HalHWImg8821A_FW.h
--- linux-4.9/drivers/staging/rtl8821au/include/HalHWImg8821A_FW.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/include/HalHWImg8821A_FW.h	2016-12-11 19:48:25.170311727 -0600
@@ -0,0 +1,60 @@
+/******************************************************************************
+*
+* Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+*
+* This program is free software; you can redistribute it and/or modify it
+* under the terms of version 2 of the GNU General Public License as
+* published by the Free Software Foundation.
+*
+* This program is distributed in the hope that it will be useful, but WITHOUT
+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+* more details.
+*
+* You should have received a copy of the GNU General Public License along with
+* this program; if not, write to the Free Software Foundation, Inc.,
+* 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+*
+*
+******************************************************************************/
+
+#ifndef __INC_MP_FW_HW_IMG_8821A_H
+#define __INC_MP_FW_HW_IMG_8821A_H
+
+
+/******************************************************************************
+*                           FW_AP.TXT
+******************************************************************************/
+
+void ODM_ReadFirmware_MP_8821A_FW_AP(u8 **pFirmware, uint32_t *pFirmwareSize);
+
+/******************************************************************************
+*                           FW_BT.TXT
+******************************************************************************/
+
+void
+ODM_ReadFirmware_MP_8821A_FW_BT(
+     IN   struct _rtw_dm *   pDM_Odm,
+     OUT  u8       *pFirmware,
+     OUT  uint32_t       *pFirmwareSize
+);
+
+/******************************************************************************
+*                           FW_NIC.TXT
+******************************************************************************/
+
+void ODM_ReadFirmware_MP_8821A_FW_NIC(u8 **pFirmware, uint32_t *pFirmwareSize);
+
+/******************************************************************************
+*                           FW_WoWLAN.TXT
+******************************************************************************/
+
+void
+ODM_ReadFirmware_MP_8821A_FW_WoWLAN(
+     IN   struct _rtw_dm *   pDM_Odm,
+     OUT  u8       *pFirmware,
+     OUT  uint32_t       *pFirmwareSize
+);
+
+#endif
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/include/hal_intf.h linux-4.9.8821au/drivers/staging/rtl8821au/include/hal_intf.h
--- linux-4.9/drivers/staging/rtl8821au/include/hal_intf.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/include/hal_intf.h	2016-12-11 19:48:25.170311727 -0600
@@ -0,0 +1,72 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __HAL_INTF_H__
+#define __HAL_INTF_H__
+
+
+enum RTL871X_HCI_TYPE {
+	RTW_USB 	= BIT(1),
+};
+
+enum _CHIP_TYPE {
+	NULL_CHIP_TYPE,
+	RTL8812,
+	RTL8821, //RTL8811
+	MAX_CHIP_TYPE
+};
+
+typedef enum _HAL_ODM_VARIABLE{
+	HAL_ODM_STA_INFO,
+}HAL_ODM_VARIABLE;
+
+typedef enum _HAL_INTF_PS_FUNC{
+	HAL_USB_SELECT_SUSPEND,
+	HAL_MAX_ID,
+}HAL_INTF_PS_FUNC;
+
+typedef int32_t (*c2h_id_filter)(uint8_t id);
+
+
+typedef	enum _RT_EEPROM_TYPE{
+	EEPROM_93C46,
+	EEPROM_93C56,
+	EEPROM_BOOT_EFUSE,
+}RT_EEPROM_TYPE,*PRT_EEPROM_TYPE;
+
+
+
+#define RF_CHANGE_BY_INIT	0
+#define RF_CHANGE_BY_IPS 	BIT28
+#define RF_CHANGE_BY_PS 	BIT29
+#define RF_CHANGE_BY_HW 	BIT30
+#define RF_CHANGE_BY_SW 	BIT31
+
+uint rtw_hal_init(struct rtl_priv *rtlpriv);
+uint rtw_hal_deinit(struct rtl_priv *rtlpriv);
+void rtw_hal_stop(struct rtl_priv *rtlpriv);
+
+void	rtw_hal_get_odm_var(struct rtl_priv *rtlpriv, HAL_ODM_VARIABLE eVariable, void *pValue1,bool bSet);
+
+int32_t	rtw_hal_mgnt_xmit(struct rtl_priv *rtlpriv, struct xmit_frame *pmgntframe);
+
+void rtw_hal_update_ra_mask(struct rtl_priv *rtlpriv, struct sta_info *psta, uint8_t rssi_level);
+
+#endif //__HAL_INTF_H__
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/include/hal_phy.h linux-4.9.8821au/drivers/staging/rtl8821au/include/hal_phy.h
--- linux-4.9/drivers/staging/rtl8821au/include/hal_phy.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/include/hal_phy.h	2016-12-11 19:48:25.170311727 -0600
@@ -0,0 +1,164 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __HAL_PHY_H__
+#define __HAL_PHY_H__
+
+
+#define	RF6052_MAX_TX_PWR			0x3F
+#define	RF6052_MAX_REG_88E			0xFF
+#define	RF6052_MAX_REG_92C			0x7F
+
+#define	RF6052_MAX_REG	\
+		(RF6052_MAX_REG_88E > RF6052_MAX_REG_92C) ? RF6052_MAX_REG_88E: RF6052_MAX_REG_92C
+
+#define GET_RF6052_REAL_MAX_REG(_Adapter)	\
+		IS_HARDWARE_TYPE_8188E(_Adapter) ? RF6052_MAX_REG_88E : RF6052_MAX_REG_92C
+
+#define	RF6052_MAX_PATH				2
+
+/*--------------------------Define Parameters-------------------------------*/
+
+#define	TX_1S			0
+#define	TX_2S			1
+#define	TX_3S			2
+#define	TX_4S			3
+
+#define	RF_PATH_MAX_92C_88E 		2
+#define	RF_PATH_MAX_90_8812		4	//Max RF number 90 support
+
+typedef enum _ANTENNA_PATH{
+       ANTENNA_NONE 	= 0,
+	ANTENNA_D		= 1,
+	ANTENNA_C		= 2,
+	ANTENNA_CD	= 3,
+	ANTENNA_B		= 4,
+	ANTENNA_BD	= 5,
+	ANTENNA_BC	= 6,
+	ANTENNA_BCD	= 7,
+	ANTENNA_A		= 8,
+	ANTENNA_AD	= 9,
+	ANTENNA_AC	= 10,
+	ANTENNA_ACD	= 11,
+	ANTENNA_AB	= 12,
+	ANTENNA_ABD	= 13,
+	ANTENNA_ABC	= 14,
+	ANTENNA_ABCD	= 15
+} ANTENNA_PATH;
+
+typedef enum _RF_CONTENT{
+	radioa_txt = 0x1000,
+	radiob_txt = 0x1001,
+	radioc_txt = 0x1002,
+	radiod_txt = 0x1003
+} RF_CONTENT;
+
+typedef enum _BaseBand_Config_Type{
+	BaseBand_Config_PHY_REG = 0,			//Radio Path A
+	BaseBand_Config_AGC_TAB = 1,			//Radio Path B
+	BaseBand_Config_AGC_TAB_2G = 2,
+	BaseBand_Config_AGC_TAB_5G = 3,
+	BaseBand_Config_PHY_REG_PG
+}BaseBand_Config_Type, *PBaseBand_Config_Type;
+
+typedef enum _HW_BLOCK{
+	HW_BLOCK_MAC = 0,
+	HW_BLOCK_PHY0 = 1,
+	HW_BLOCK_PHY1 = 2,
+	HW_BLOCK_RF = 3,
+	HW_BLOCK_MAXIMUM = 4, // Never use this
+}HW_BLOCK_E, *PHW_BLOCK_E;
+
+typedef enum _SwChnlCmdID{
+	CmdID_End,
+	CmdID_SetTxPowerLevel,
+	CmdID_BBRegWrite10,
+	CmdID_WritePortUlong,
+	CmdID_WritePortu16,
+	CmdID_WritePortUchar,
+	CmdID_RF_WriteReg,
+}SwChnlCmdID;
+
+typedef struct _SwChnlCmd{
+	SwChnlCmdID	CmdID;
+	u32				Para1;
+	u32				Para2;
+	u32				msDelay;
+}SwChnlCmd;
+
+typedef struct _R_ANTENNA_SELECT_OFDM{
+	u32			r_tx_antenna:4;
+	u32			r_ant_l:4;
+	u32			r_ant_non_ht:4;
+	u32			r_ant_ht1:4;
+	u32			r_ant_ht2:4;
+	u32			r_ant_ht_s1:4;
+	u32			r_ant_non_ht_s1:4;
+	u32			OFDM_TXSC:2;
+	u32			Reserved:2;
+}R_ANTENNA_SELECT_OFDM;
+
+typedef struct _R_ANTENNA_SELECT_CCK{
+	uint8_t			r_cckrx_enable_2:2;
+	uint8_t			r_cckrx_enable:2;
+	uint8_t			r_ccktx_enable:4;
+}R_ANTENNA_SELECT_CCK;
+
+typedef struct RF_Shadow_Compare_Map {
+	// Shadow register value
+	u32		Value;
+	// Compare or not flag
+	uint8_t		Compare;
+	// Record If it had ever modified unpredicted
+	uint8_t		ErrorOrNot;
+	// Recorver Flag
+	uint8_t		Recorver;
+	//
+	uint8_t		Driver_Write;
+}RF_SHADOW_T;
+
+/*--------------------------Exported Function prototype---------------------*/
+
+u32 PHY_RFShadowRead(struct rtl_priv *rtlpriv, uint8_t eRFPath, u32 Offset);
+
+void PHY_RFShadowWrite(struct rtl_priv *rtlpriv, uint8_t eRFPath,
+	u32 Offset, u32	Data);
+
+bool PHY_RFShadowCompare(struct rtl_priv *rtlpriv, uint8_t eRFPath, u32	Offset);
+
+void PHY_RFShadowRecorver(struct rtl_priv *rtlpriv, uint8_t eRFPath, u32 Offset);
+
+void PHY_RFShadowCompareAll(struct rtl_priv *rtlpriv);
+
+void PHY_RFShadowRecorverAll(struct rtl_priv *rtlpriv);
+
+void PHY_RFShadowCompareFlagSet(struct rtl_priv *rtlpriv, uint8_t eRFPath,
+	u32 Offset, uint8_t Type);
+
+void PHY_RFShadowRecorverFlagSet(struct rtl_priv *rtlpriv, uint8_t eRFPath,
+	u32 Offset, uint8_t Type);
+
+void PHY_RFShadowCompareFlagSetAll(struct rtl_priv *rtlpriv);
+
+void PHY_RFShadowRecorverFlagSetAll(struct rtl_priv *rtlpriv);
+
+void PHY_RFShadowRefresh(struct rtl_priv *rtlpriv);
+
+#endif //__HAL_COMMON_H__
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/include/hal_phy_reg.h linux-4.9.8821au/drivers/staging/rtl8821au/include/hal_phy_reg.h
--- linux-4.9/drivers/staging/rtl8821au/include/hal_phy_reg.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/include/hal_phy_reg.h	2016-12-11 19:48:25.170311727 -0600
@@ -0,0 +1,31 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __HAL_PHY_REG_H__
+#define __HAL_PHY_REG_H__
+
+//for PutRFRegsetting & GetRFRegSetting BitMask
+//#if (RTL92SE_FPGA_VERIFY == 1)
+//#define 		bRFRegOffsetMask	0xfff		
+//#else
+#define 		bRFRegOffsetMask	0xfffff
+//#endif
+
+#endif //__HAL_PHY_REG_H__
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/include/HalPhyRf_8812A.h linux-4.9.8821au/drivers/staging/rtl8821au/include/HalPhyRf_8812A.h
--- linux-4.9/drivers/staging/rtl8821au/include/HalPhyRf_8812A.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/include/HalPhyRf_8812A.h	2016-12-11 19:48:25.170311727 -0600
@@ -0,0 +1,41 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+#ifndef __HAL_PHY_RF_8812A_H__
+#define __HAL_PHY_RF_8812A_H__
+
+/*--------------------------Define Parameters-------------------------------*/
+#define	IQK_DELAY_TIME_8812A		10		//ms
+#define	IQK_DEFERRED_TIME_8812A		4		//sec
+#define	index_mapping_NUM_8812A	15
+
+//1 7.	IQK
+
+
+
+//
+// AP calibrate
+//
+void PHY_APCalibrate_8812A(struct rtl_priv *rtlpriv, s8	delta);
+void PHY_DigitalPredistortion_8812A(struct rtl_priv *rtlpriv);
+void PHY_DPCalibrate_8812A(struct _rtw_dm *pDM_Odm);
+
+#endif	// #ifndef __HAL_PHY_RF_8812A_H__
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/include/HalPhyRf_8821A.h linux-4.9.8821au/drivers/staging/rtl8821au/include/HalPhyRf_8821A.h
--- linux-4.9/drivers/staging/rtl8821au/include/HalPhyRf_8821A.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/include/HalPhyRf_8821A.h	2016-12-11 19:48:25.170311727 -0600
@@ -0,0 +1,36 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+#ifndef __HAL_PHY_RF_8821A_H__
+#define __HAL_PHY_RF_8821A_H__
+
+/*--------------------------Define Parameters-------------------------------*/
+#define	IQK_DELAY_TIME_8821A		10		//ms
+#define	index_mapping_NUM_8821A	15
+#define AVG_THERMAL_NUM_8821A	4
+#define RF_T_METER_8821A 		0x42
+
+//1 7.	IQK
+
+void PHY_SetRFPathSwitch_8821A(struct rtl_priv *rtlpriv, bool bMain);
+
+
+#endif	// #ifndef __HAL_PHY_RF_8821A_H__
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/include/HalPwrSeqCmd.h linux-4.9.8821au/drivers/staging/rtl8821au/include/HalPwrSeqCmd.h
--- linux-4.9/drivers/staging/rtl8821au/include/HalPwrSeqCmd.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/include/HalPwrSeqCmd.h	2016-12-11 19:48:25.170311727 -0600
@@ -0,0 +1,135 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __HALPWRSEQCMD_H__
+#define __HALPWRSEQCMD_H__
+
+#include <drv_types.h>
+
+/*---------------------------------------------*/
+//3 The value of cmd: 4 bits
+/*---------------------------------------------*/
+#define PWR_CMD_READ			0x00
+     // offset: the read register offset
+     // msk: the mask of the read value
+     // value: N/A, left by 0
+     // note: dirver shall implement this function by read & msk
+
+#define PWR_CMD_WRITE			0x01
+     // offset: the read register offset
+     // msk: the mask of the write bits
+     // value: write value
+     // note: driver shall implement this cmd by read & msk after write
+
+#define PWR_CMD_POLLING			0x02
+     // offset: the read register offset
+     // msk: the mask of the polled value
+     // value: the value to be polled, masked by the msd field.
+     // note: driver shall implement this cmd by
+     // do{
+     // if( (Read(offset) & msk) == (value & msk) )
+     // break;
+     // } while(not timeout);
+
+#define PWR_CMD_DELAY			0x03
+     // offset: the value to delay
+     // msk: N/A
+     // value: the unit of delay, 0: us, 1: ms
+
+#define PWR_CMD_END				0x04
+     // offset: N/A
+     // msk: N/A
+     // value: N/A
+
+/*---------------------------------------------*/
+//3 The value of base: 4 bits
+/*---------------------------------------------*/
+   // define the base address of each block
+#define PWR_BASEADDR_MAC		0x00
+#define PWR_BASEADDR_USB		0x01
+#define PWR_BASEADDR_PCIE		0x02
+#define PWR_BASEADDR_SDIO		0x03
+
+/*---------------------------------------------*/
+//3 The value of interface_msk: 4 bits
+/*---------------------------------------------*/
+#define	PWR_INTF_SDIO_MSK		BIT(0)
+#define	PWR_INTF_USB_MSK		BIT(1)
+#define	PWR_INTF_PCI_MSK		BIT(2)
+#define	PWR_INTF_ALL_MSK		(BIT(0)|BIT(1)|BIT(2)|BIT(3))
+
+/*---------------------------------------------*/
+//3 The value of fab_msk: 4 bits
+/*---------------------------------------------*/
+#define	PWR_FAB_TSMC_MSK		BIT(0)
+#define	PWR_FAB_UMC_MSK			BIT(1)
+#define	PWR_FAB_ALL_MSK			(BIT(0)|BIT(1)|BIT(2)|BIT(3))
+
+/*---------------------------------------------*/
+//3 The value of cut_msk: 8 bits
+/*---------------------------------------------*/
+#define	PWR_CUT_TESTCHIP_MSK	BIT(0)
+#define	PWR_CUT_A_MSK			BIT(1)
+#define	PWR_CUT_B_MSK			BIT(2)
+#define	PWR_CUT_C_MSK			BIT(3)
+#define	PWR_CUT_D_MSK			BIT(4)
+#define	PWR_CUT_E_MSK			BIT(5)
+#define	PWR_CUT_F_MSK			BIT(6)
+#define	PWR_CUT_G_MSK			BIT(7)
+#define	PWR_CUT_ALL_MSK			0xFF
+
+
+typedef enum _PWRSEQ_CMD_DELAY_UNIT_
+{
+	PWRSEQ_DELAY_US,
+	PWRSEQ_DELAY_MS,
+} PWRSEQ_DELAY_UNIT;
+
+struct wlan_pwr_cfg {
+	u16 offset;
+	uint8_t cut_msk;
+	uint8_t fab_msk:4;
+	uint8_t interface_msk:4;
+	uint8_t base:4;
+	uint8_t cmd:4;
+	uint8_t msk;
+	uint8_t value;
+};
+
+
+#define GET_PWR_CFG_OFFSET(__PWR_CMD)		__PWR_CMD.offset
+#define GET_PWR_CFG_CUT_MASK(__PWR_CMD)		__PWR_CMD.cut_msk
+#define GET_PWR_CFG_FAB_MASK(__PWR_CMD)		__PWR_CMD.fab_msk
+#define GET_PWR_CFG_INTF_MASK(__PWR_CMD)	__PWR_CMD.interface_msk
+#define GET_PWR_CFG_BASE(__PWR_CMD)			__PWR_CMD.base
+#define GET_PWR_CFG_CMD(__PWR_CMD)			__PWR_CMD.cmd
+#define GET_PWR_CFG_MASK(__PWR_CMD)			__PWR_CMD.msk
+#define GET_PWR_CFG_VALUE(__PWR_CMD)		__PWR_CMD.value
+
+
+//================================================================================
+//	Prototype of protected function.
+//================================================================================
+bool rtw_hal_pwrseqcmdparsing(struct rtl_priv *rtlpriv, u8 cut_version,
+				 u8 fabversion, u8 interface_type,
+				 struct wlan_pwr_cfg pwrcfgcmd[]);
+
+
+#endif
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/include/ieee80211_ext.h linux-4.9.8821au/drivers/staging/rtl8821au/include/ieee80211_ext.h
--- linux-4.9/drivers/staging/rtl8821au/include/ieee80211_ext.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/include/ieee80211_ext.h	2016-12-11 19:48:25.170311727 -0600
@@ -0,0 +1,311 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __IEEE80211_EXT_H
+#define __IEEE80211_EXT_H
+
+#include <drv_conf.h>
+#include <osdep_service.h>
+#include <drv_types.h>
+
+#define WMM_OUI_TYPE 2
+#define WMM_OUI_SUBTYPE_INFORMATION_ELEMENT 0
+#define WMM_OUI_SUBTYPE_PARAMETER_ELEMENT 1
+#define WMM_OUI_SUBTYPE_TSPEC_ELEMENT 2
+#define WMM_VERSION 1
+
+#define WPA_PROTO_WPA BIT(0)
+#define WPA_PROTO_RSN BIT(1)
+
+#define WPA_KEY_MGMT_IEEE8021X BIT(0)
+#define WPA_KEY_MGMT_PSK BIT(1)
+#define WPA_KEY_MGMT_NONE BIT(2)
+#define WPA_KEY_MGMT_IEEE8021X_NO_WPA BIT(3)
+#define WPA_KEY_MGMT_WPA_NONE BIT(4)
+
+
+#define WPA_CAPABILITY_PREAUTH BIT(0)
+#define WPA_CAPABILITY_MGMT_FRAME_PROTECTION BIT(6)
+#define WPA_CAPABILITY_PEERKEY_ENABLED BIT(9)
+
+
+#define PMKID_LEN 16
+
+
+struct wpa_ie_hdr {
+	uint8_t elem_id;
+	uint8_t len;
+	uint8_t oui[4]; /* 24-bit OUI followed by 8-bit OUI type */
+	uint8_t version[2]; /* little endian */
+}__attribute__ ((packed));
+
+struct rsn_ie_hdr {
+	uint8_t elem_id; /* WLAN_EID_RSN */
+	uint8_t len;
+	uint8_t version[2]; /* little endian */
+}__attribute__ ((packed));
+
+struct wme_ac_parameter {
+#if defined(CONFIG_LITTLE_ENDIAN)
+	/* byte 1 */
+	uint8_t 	aifsn:4,
+		acm:1,
+	 	aci:2,
+	 	reserved:1;
+
+	/* byte 2 */
+	uint8_t 	eCWmin:4,
+	 	eCWmax:4;
+#elif defined(CONFIG_BIG_ENDIAN)
+	/* byte 1 */
+	uint8_t 	reserved:1,
+	 	aci:2,
+	 	acm:1,
+	 	aifsn:4;
+
+	/* byte 2 */
+	uint8_t 	eCWmax:4,
+	 	eCWmin:4;
+#else
+#error	"Please fix <endian.h>"
+#endif
+
+	/* bytes 3 & 4 */
+	u16 txopLimit;
+} __attribute__ ((packed));
+
+struct wme_parameter_element {
+	/* required fields for WME version 1 */
+	uint8_t oui[3];
+	uint8_t oui_type;
+	uint8_t oui_subtype;
+	uint8_t version;
+	uint8_t acInfo;
+	uint8_t reserved;
+	struct wme_ac_parameter ac[4];
+
+} __attribute__ ((packed));
+
+#define WPA_PUT_LE16(a, val)			\
+	do {					\
+		(a)[1] = ((u16) (val)) >> 8;	\
+		(a)[0] = ((u16) (val)) & 0xff;	\
+	} while (0)
+
+#define WPA_PUT_BE32(a, val)					\
+	do {							\
+		(a)[0] = (uint8_t) ((((u32) (val)) >> 24) & 0xff);	\
+		(a)[1] = (uint8_t) ((((u32) (val)) >> 16) & 0xff);	\
+		(a)[2] = (uint8_t) ((((u32) (val)) >> 8) & 0xff);	\
+		(a)[3] = (uint8_t) (((u32) (val)) & 0xff);		\
+	} while (0)
+
+#define WPA_PUT_LE32(a, val)					\
+	do {							\
+		(a)[3] = (uint8_t) ((((u32) (val)) >> 24) & 0xff);	\
+		(a)[2] = (uint8_t) ((((u32) (val)) >> 16) & 0xff);	\
+		(a)[1] = (uint8_t) ((((u32) (val)) >> 8) & 0xff);	\
+		(a)[0] = (uint8_t) (((u32) (val)) & 0xff);		\
+	} while (0)
+
+#define RSN_SELECTOR_PUT(a, val) WPA_PUT_BE32((uint8_t *) (a), (val))
+//#define RSN_SELECTOR_PUT(a, val) WPA_PUT_LE32((uint8_t *) (a), (val))
+
+
+
+/* Action category code */
+enum ieee80211_category {
+	WLAN_CATEGORY_SPECTRUM_MGMT = 0,
+	WLAN_CATEGORY_QOS = 1,
+	WLAN_CATEGORY_DLS = 2,
+	WLAN_CATEGORY_BACK = 3,
+	WLAN_CATEGORY_HT = 7,
+	WLAN_CATEGORY_WMM = 17,
+};
+
+/* SPECTRUM_MGMT action code */
+enum ieee80211_spectrum_mgmt_actioncode {
+	WLAN_ACTION_SPCT_MSR_REQ = 0,
+	WLAN_ACTION_SPCT_MSR_RPRT = 1,
+	WLAN_ACTION_SPCT_TPC_REQ = 2,
+	WLAN_ACTION_SPCT_TPC_RPRT = 3,
+	WLAN_ACTION_SPCT_CHL_SWITCH = 4,
+	WLAN_ACTION_SPCT_EXT_CHL_SWITCH = 5,
+};
+
+/* BACK action code */
+enum ieee80211_back_actioncode {
+	WLAN_ACTION_ADDBA_REQ = 0,
+	WLAN_ACTION_ADDBA_RESP = 1,
+	WLAN_ACTION_DELBA = 2,
+};
+
+/* HT features action code */
+enum ieee80211_ht_actioncode {
+	WLAN_ACTION_NOTIFY_CH_WIDTH = 0,
+       WLAN_ACTION_SM_PS = 1,
+       WLAN_ACTION_PSPM = 2,
+       WLAN_ACTION_PCO_PHASE = 3,
+       WLAN_ACTION_MIMO_CSI_MX = 4,
+       WLAN_ACTION_MIMO_NONCP_BF = 5,
+       WLAN_ACTION_MIMP_CP_BF = 6,
+       WLAN_ACTION_ASEL_INDICATES_FB = 7,
+       WLAN_ACTION_HI_INFO_EXCHG = 8,
+};
+
+/* BACK (block-ack) parties */
+enum ieee80211_back_parties {
+	WLAN_BACK_RECIPIENT = 0,
+	WLAN_BACK_INITIATOR = 1,
+	WLAN_BACK_TIMER = 2,
+};
+
+struct ieee80211_mgmt {
+	u16 frame_control;
+	u16 duration;
+	uint8_t da[6];
+	uint8_t sa[6];
+	uint8_t bssid[6];
+	u16 seq_ctrl;
+	union {
+		struct {
+			u16 auth_alg;
+			u16 auth_transaction;
+			u16 status_code;
+			/* possibly followed by Challenge text */
+			uint8_t variable[0];
+		}  __attribute__ ((packed)) auth;
+		struct {
+			u16 reason_code;
+		}  __attribute__ ((packed)) deauth;
+		struct {
+			u16 capab_info;
+			u16 listen_interval;
+			/* followed by SSID and Supported rates */
+			uint8_t variable[0];
+		}  __attribute__ ((packed)) assoc_req;
+		struct {
+			u16 capab_info;
+			u16 status_code;
+			u16 aid;
+			/* followed by Supported rates */
+			uint8_t variable[0];
+		}  __attribute__ ((packed)) assoc_resp, reassoc_resp;
+		struct {
+			u16 capab_info;
+			u16 listen_interval;
+			uint8_t current_ap[6];
+			/* followed by SSID and Supported rates */
+			uint8_t variable[0];
+		}  __attribute__ ((packed)) reassoc_req;
+		struct {
+			u16 reason_code;
+		}  __attribute__ ((packed)) disassoc;
+		struct {
+			__le64 timestamp;
+			u16 beacon_int;
+			u16 capab_info;
+			/* followed by some of SSID, Supported rates,
+			 * FH Params, DS Params, CF Params, IBSS Params, TIM */
+			uint8_t variable[0];
+		}  __attribute__ ((packed)) beacon;
+		struct {
+			/* only variable items: SSID, Supported rates */
+			uint8_t variable[0];
+		}  __attribute__ ((packed)) probe_req;
+		struct {
+			__le64 timestamp;
+			u16 beacon_int;
+			u16 capab_info;
+			/* followed by some of SSID, Supported rates,
+			 * FH Params, DS Params, CF Params, IBSS Params */
+			uint8_t variable[0];
+		}  __attribute__ ((packed)) probe_resp;
+		struct {
+			uint8_t category;
+			union {
+				struct {
+					uint8_t action_code;
+					uint8_t dialog_token;
+					uint8_t status_code;
+					uint8_t variable[0];
+				}  __attribute__ ((packed)) wme_action;
+#if 0
+				struct{
+					uint8_t action_code;
+					uint8_t element_id;
+					uint8_t length;
+					struct ieee80211_channel_sw_ie sw_elem;
+				}  __attribute__ ((packed)) chan_switch;
+				struct{
+					uint8_t action_code;
+					uint8_t dialog_token;
+					uint8_t element_id;
+					uint8_t length;
+					struct ieee80211_msrment_ie msr_elem;
+				}  __attribute__ ((packed)) measurement;
+#endif
+				struct{
+					uint8_t action_code;
+					uint8_t dialog_token;
+					u16 capab;
+					u16 timeout;
+					u16 start_seq_num;
+				}  __attribute__ ((packed)) addba_req;
+				struct{
+					uint8_t action_code;
+					uint8_t dialog_token;
+					u16 status;
+					u16 capab;
+					u16 timeout;
+				}  __attribute__ ((packed)) addba_resp;
+				struct{
+					uint8_t action_code;
+					u16 params;
+					u16 reason_code;
+				}  __attribute__ ((packed)) delba;
+				struct{
+					uint8_t action_code;
+					/* capab_info for open and confirm,
+					 * reason for close
+					 */
+					u16 aux;
+					/* Followed in plink_confirm by status
+					 * code, AID and supported rates,
+					 * and directly by supported rates in
+					 * plink_open and plink_close
+					 */
+					uint8_t variable[0];
+				}  __attribute__ ((packed)) plink_action;
+				struct{
+					uint8_t action_code;
+					uint8_t variable[0];
+				}  __attribute__ ((packed)) mesh_action;
+			} __attribute__ ((packed)) u;
+		}  __attribute__ ((packed)) action;
+	} __attribute__ ((packed)) u;
+}__attribute__ ((packed));
+
+/* mgmt header + 1 byte category code */
+#define IEEE80211_MIN_ACTION_SIZE FIELD_OFFSET(struct ieee80211_mgmt, u.action.u)
+
+
+
+#endif
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/include/ieee80211.h linux-4.9.8821au/drivers/staging/rtl8821au/include/ieee80211.h
--- linux-4.9/drivers/staging/rtl8821au/include/ieee80211.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/include/ieee80211.h	2016-12-11 19:48:25.170311727 -0600
@@ -0,0 +1,1189 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __IEEE80211_H
+#define __IEEE80211_H
+
+#include <linux/wireless.h>
+
+#define MGMT_QUEUE_NUM 5
+
+#define ETH_ALEN	6
+#define ETH_TYPE_LEN		2
+#define PAYLOAD_TYPE_LEN	1
+
+#ifdef CONFIG_AP_MODE
+
+#define RTL_IOCTL_HOSTAPD (SIOCIWFIRSTPRIV + 28)
+
+/* RTL871X_IOCTL_HOSTAPD ioctl() cmd: */
+enum {
+	RTL871X_HOSTAPD_FLUSH = 1,
+	RTL871X_HOSTAPD_ADD_STA = 2,
+	RTL871X_HOSTAPD_REMOVE_STA = 3,
+	RTL871X_HOSTAPD_GET_INFO_STA = 4,
+	/* REMOVED: PRISM2_HOSTAPD_RESET_TXEXC_STA = 5, */
+	RTL871X_HOSTAPD_GET_WPAIE_STA = 5,
+	RTL871X_SET_ENCRYPTION = 6,
+	RTL871X_GET_ENCRYPTION = 7,
+	RTL871X_HOSTAPD_SET_FLAGS_STA = 8,
+	RTL871X_HOSTAPD_GET_RID = 9,
+	RTL871X_HOSTAPD_SET_RID = 10,
+	RTL871X_HOSTAPD_SET_ASSOC_AP_ADDR = 11,
+	RTL871X_HOSTAPD_SET_GENERIC_ELEMENT = 12,
+	RTL871X_HOSTAPD_MLME = 13,
+	RTL871X_HOSTAPD_SCAN_REQ = 14,
+	RTL871X_HOSTAPD_STA_CLEAR_STATS = 15,
+	RTL871X_HOSTAPD_SET_BEACON=16,
+	RTL871X_HOSTAPD_SET_WPS_BEACON = 17,
+	RTL871X_HOSTAPD_SET_WPS_PROBE_RESP = 18,
+	RTL871X_HOSTAPD_SET_WPS_ASSOC_RESP = 19,
+	RTL871X_HOSTAPD_SET_HIDDEN_SSID = 20,
+	RTL871X_HOSTAPD_SET_MACADDR_ACL = 21,
+	RTL871X_HOSTAPD_ACL_ADD_STA = 22,
+	RTL871X_HOSTAPD_ACL_REMOVE_STA = 23,
+};
+
+/* STA flags */
+#define WLAN_STA_AUTH BIT(0)
+#define WLAN_STA_ASSOC BIT(1)
+#define WLAN_STA_PS BIT(2)
+#define WLAN_STA_TIM BIT(3)
+#define WLAN_STA_PERM BIT(4)
+#define WLAN_STA_AUTHORIZED BIT(5)
+#define WLAN_STA_PENDING_POLL BIT(6) /* pending activity poll not ACKed */
+#define WLAN_STA_SHORT_PREAMBLE BIT(7)
+#define WLAN_STA_PREAUTH BIT(8)
+#define WLAN_STA_WME BIT(9)
+#define WLAN_STA_MFP BIT(10)
+#define WLAN_STA_HT BIT(11)
+#define WLAN_STA_WPS BIT(12)
+#define WLAN_STA_MAYBE_WPS BIT(13)
+#define WLAN_STA_VHT BIT(14)
+#define WLAN_STA_NONERP BIT(31)
+
+#endif
+
+#define IEEE_CMD_SET_WPA_PARAM			1
+#define IEEE_CMD_SET_WPA_IE				2
+#define IEEE_CMD_SET_ENCRYPTION			3
+#define IEEE_CMD_MLME						4
+
+#define IEEE_PARAM_WPA_ENABLED				1
+#define IEEE_PARAM_TKIP_COUNTERMEASURES		2
+#define IEEE_PARAM_DROP_UNENCRYPTED			3
+#define IEEE_PARAM_PRIVACY_INVOKED			4
+#define IEEE_PARAM_AUTH_ALGS					5
+#define IEEE_PARAM_IEEE_802_1X				6
+#define IEEE_PARAM_WPAX_SELECT				7
+
+#define AUTH_ALG_OPEN_SYSTEM			0x1
+#define AUTH_ALG_SHARED_KEY			0x2
+#define AUTH_ALG_LEAP				0x00000004
+
+#define IEEE_MLME_STA_DEAUTH				1
+#define IEEE_MLME_STA_DISASSOC			2
+
+#define IEEE_CRYPT_ERR_UNKNOWN_ALG			2
+#define IEEE_CRYPT_ERR_UNKNOWN_ADDR			3
+#define IEEE_CRYPT_ERR_CRYPT_INIT_FAILED		4
+#define IEEE_CRYPT_ERR_KEY_SET_FAILED			5
+#define IEEE_CRYPT_ERR_TX_KEY_SET_FAILED		6
+#define IEEE_CRYPT_ERR_CARD_CONF_FAILED		7
+
+
+#define	IEEE_CRYPT_ALG_NAME_LEN			16
+
+#define WPA_CIPHER_NONE 	BIT(0)
+#define WPA_CIPHER_WEP40 	BIT(1)
+#define WPA_CIPHER_WEP104 BIT(2)
+#define WPA_CIPHER_TKIP 	BIT(3)
+#define WPA_CIPHER_CCMP 	BIT(4)
+
+
+
+#define WPA_SELECTOR_LEN 4
+extern uint8_t RTW_WPA_OUI_TYPE[] ;
+extern u16 RTW_WPA_VERSION ;
+extern uint8_t WPA_AUTH_KEY_MGMT_NONE[];
+extern uint8_t WPA_AUTH_KEY_MGMT_UNSPEC_802_1X[];
+extern uint8_t WPA_AUTH_KEY_MGMT_PSK_OVER_802_1X[];
+extern uint8_t WPA_CIPHER_SUITE_NONE[];
+extern uint8_t WPA_CIPHER_SUITE_WEP40[];
+extern uint8_t WPA_CIPHER_SUITE_TKIP[];
+extern uint8_t WPA_CIPHER_SUITE_WRAP[];
+extern uint8_t WPA_CIPHER_SUITE_CCMP[];
+extern uint8_t WPA_CIPHER_SUITE_WEP104[];
+
+
+#define RSN_HEADER_LEN 4
+#define RSN_SELECTOR_LEN 4
+
+extern uint8_t RSN_AUTH_KEY_MGMT_UNSPEC_802_1X[];
+extern uint8_t RSN_AUTH_KEY_MGMT_PSK_OVER_802_1X[];
+extern uint8_t RSN_CIPHER_SUITE_NONE[];
+extern uint8_t RSN_CIPHER_SUITE_WEP40[];
+extern uint8_t RSN_CIPHER_SUITE_TKIP[];
+extern uint8_t RSN_CIPHER_SUITE_WRAP[];
+extern uint8_t RSN_CIPHER_SUITE_CCMP[];
+extern uint8_t RSN_CIPHER_SUITE_WEP104[];
+
+
+typedef enum _RATEID_IDX_ {
+	RATEID_IDX_BGN_40M_2SS = 0,
+	RATEID_IDX_BGN_40M_1SS = 1,
+	RATEID_IDX_BGN_20M_2SS_BN = 2,
+	RATEID_IDX_BGN_20M_1SS_BN = 3,
+	RATEID_IDX_GN_N2SS = 4,
+	RATEID_IDX_GN_N1SS = 5,
+	RATEID_IDX_BG = 6,
+	RATEID_IDX_G = 7,
+	RATEID_IDX_B = 8,
+	RATEID_IDX_VHT_2SS = 9,
+	RATEID_IDX_VHT_1SS = 10,
+} RATEID_IDX, *PRATEID_IDX;
+
+typedef enum _RATR_TABLE_MODE{
+	RATR_INX_WIRELESS_NGB = 0,	// BGN 40 Mhz 2SS 1SS
+	RATR_INX_WIRELESS_NG = 1,		// GN or N
+	RATR_INX_WIRELESS_NB = 2,		// BGN 20 Mhz 2SS 1SS  or BN
+	RATR_INX_WIRELESS_N = 3,
+	RATR_INX_WIRELESS_GB = 4,
+	RATR_INX_WIRELESS_G = 5,
+	RATR_INX_WIRELESS_B = 6,
+	RATR_INX_WIRELESS_MC = 7,
+	RATR_INX_WIRELESS_AC_N = 8,
+}RATR_TABLE_MODE, *PRATR_TABLE_MODE;
+
+
+enum NETWORK_TYPE
+{
+	WIRELESS_INVALID = 0,
+	//Sub-Element
+	WIRELESS_11B = BIT(0), // tx: cck only , rx: cck only, hw: cck
+	WIRELESS_11G = BIT(1), // tx: ofdm only, rx: ofdm & cck, hw: cck & ofdm
+	WIRELESS_11A = BIT(2), // tx: ofdm only, rx: ofdm only, hw: ofdm only
+	WIRELESS_11_24N = BIT(3), // tx: MCS only, rx: MCS & cck, hw: MCS & cck
+	WIRELESS_11_5N = BIT(4), // tx: MCS only, rx: MCS & ofdm, hw: ofdm only
+	WIRELESS_AUTO = BIT(5),
+	WIRELESS_11AC = BIT(6),
+
+	//Combination
+	//Type for current wireless mode
+	WIRELESS_11BG = (WIRELESS_11B|WIRELESS_11G), // tx: cck & ofdm, rx: cck & ofdm & MCS, hw: cck & ofdm
+	WIRELESS_11G_24N = (WIRELESS_11G|WIRELESS_11_24N), // tx: ofdm & MCS, rx: ofdm & cck & MCS, hw: cck & ofdm
+	WIRELESS_11A_5N = (WIRELESS_11A|WIRELESS_11_5N), // tx: ofdm & MCS, rx: ofdm & MCS, hw: ofdm only
+	WIRELESS_11B_24N = (WIRELESS_11B|WIRELESS_11_24N), // tx: ofdm & cck & MCS, rx: ofdm & cck & MCS, hw: ofdm & cck
+	WIRELESS_11BG_24N = (WIRELESS_11B|WIRELESS_11G|WIRELESS_11_24N), // tx: ofdm & cck & MCS, rx: ofdm & cck & MCS, hw: ofdm & cck
+	WIRELESS_11_24AC = (WIRELESS_11G|WIRELESS_11AC),
+	WIRELESS_11_5AC = (WIRELESS_11A|WIRELESS_11AC),
+
+
+	//Type for registry default wireless mode
+	WIRELESS_11AGN = (WIRELESS_11A|WIRELESS_11G|WIRELESS_11_24N|WIRELESS_11_5N), // tx: ofdm & MCS, rx: ofdm & MCS, hw: ofdm only
+	WIRELESS_11ABGN = (WIRELESS_11A|WIRELESS_11B|WIRELESS_11G|WIRELESS_11_24N|WIRELESS_11_5N),
+	WIRELESS_MODE_24G = (WIRELESS_11B|WIRELESS_11G|WIRELESS_11_24N|WIRELESS_11AC),
+	WIRELESS_MODE_5G = (WIRELESS_11A|WIRELESS_11_5N|WIRELESS_11AC),
+	WIRELESS_MODE_MAX = (WIRELESS_11A|WIRELESS_11B|WIRELESS_11G|WIRELESS_11_24N|WIRELESS_11_5N|WIRELESS_11AC),
+};
+
+#define SUPPORTED_24G_NETTYPE_MSK (WIRELESS_11B | WIRELESS_11G | WIRELESS_11_24N)
+#define SUPPORTED_5G_NETTYPE_MSK (WIRELESS_11A | WIRELESS_11_5N)
+
+#define IsSupported24G(NetType) ((NetType) & SUPPORTED_24G_NETTYPE_MSK ? true : false)
+#define IsSupported5G(NetType) ((NetType) & SUPPORTED_5G_NETTYPE_MSK ? true : false)
+
+#define IsEnableHWCCK(NetType) IsSupported24G(NetType)
+#define IsEnableHWOFDM(NetType) ((NetType) & (WIRELESS_11G|WIRELESS_11_24N|SUPPORTED_5G_NETTYPE_MSK) ? true : false)
+
+#define IsSupportedRxCCK(NetType) IsEnableHWCCK(NetType)
+#define IsSupportedRxOFDM(NetType) IsEnableHWOFDM(NetType)
+#define IsSupportedRxHT(NetType) IsEnableHWOFDM(NetType)
+
+#define IsSupportedTxCCK(NetType) ((NetType) & (WIRELESS_11B) ? true : false)
+#define IsSupportedTxOFDM(NetType) ((NetType) & (WIRELESS_11G|WIRELESS_11A) ? true : false)
+#define IsSupportedTxHT(NetType) ((NetType) & (WIRELESS_11_24N|WIRELESS_11_5N) ? true : false)
+
+#define IsSupportedVHT(NetType) ((NetType) & (WIRELESS_11AC) ? true : false)
+
+
+typedef struct ieee_param {
+	u32 cmd;
+	uint8_t sta_addr[ETH_ALEN];
+	union {
+		struct {
+			uint8_t name;
+			u32 value;
+		} wpa_param;
+		struct {
+			u32 len;
+			uint8_t reserved[32];
+			uint8_t data[0];
+		} wpa_ie;
+	        struct{
+			int command;
+    			int reason_code;
+		} mlme;
+		struct {
+			uint8_t alg[IEEE_CRYPT_ALG_NAME_LEN];
+			uint8_t set_tx;
+			u32 err;
+			uint8_t idx;
+			uint8_t seq[8]; /* sequence counter (set: RX, get: TX) */
+			u16 key_len;
+			uint8_t key[0];
+		} crypt;
+#ifdef CONFIG_AP_MODE
+		struct {
+			u16 aid;
+			u16 capability;
+			int flags;
+			uint8_t tx_supp_rates[16];
+			struct rtw_ieee80211_ht_cap ht_cap;
+		} add_sta;
+		struct {
+			uint8_t	reserved[2];//for set max_num_sta
+			uint8_t	buf[0];
+		} bcn_ie;
+#endif
+
+	} u;
+}ieee_param;
+
+#ifdef CONFIG_AP_MODE
+typedef struct ieee_param_ex {
+	u32 cmd;
+	uint8_t sta_addr[ETH_ALEN];
+	uint8_t data[0];
+}ieee_param_ex;
+
+struct sta_data{
+	u16 aid;
+	u16 capability;
+	int flags;
+	u32 sta_set;
+	uint8_t tx_supp_rates[16];
+	u32 tx_supp_rates_len;
+	struct rtw_ieee80211_ht_cap ht_cap;
+	u64	rx_pkts;
+	u64	rx_bytes;
+	u64	rx_drops;
+	u64	tx_pkts;
+	u64	tx_bytes;
+	u64	tx_drops;
+};
+#endif
+
+
+#if WIRELESS_EXT < 17
+#define IW_QUAL_QUAL_INVALID   0x10
+#define IW_QUAL_LEVEL_INVALID  0x20
+#define IW_QUAL_NOISE_INVALID  0x40
+#define IW_QUAL_QUAL_UPDATED   0x1
+#define IW_QUAL_LEVEL_UPDATED  0x2
+#define IW_QUAL_NOISE_UPDATED  0x4
+#endif
+
+#define IEEE80211_DATA_LEN		2304
+/* Maximum size for the MA-UNITDATA primitive, 802.11 standard section
+   6.2.1.1.2.
+
+   The figure in section 7.1.2 suggests a body size of up to 2312
+   bytes is allowed, which is a bit confusing, I suspect this
+   represents the 2304 bytes of real data, plus a possible 8 bytes of
+   WEP IV and ICV. (this interpretation suggested by Ramiro Barreiro) */
+
+
+#define IEEE80211_HLEN			30
+#define IEEE80211_FRAME_LEN		(IEEE80211_DATA_LEN + IEEE80211_HLEN)
+
+
+/* this is stolen from ipw2200 driver */
+#define IEEE_IBSS_MAC_HASH_SIZE 31
+
+struct ieee_ibss_seq {
+	uint8_t mac[ETH_ALEN];
+	u16 seq_num;
+	u16 frag_num;
+	unsigned long packet_time;
+	struct list_head	list;
+};
+
+struct rtw_ieee80211_hdr {
+	u16 frame_ctl;
+	u16 duration_id;
+	uint8_t addr1[ETH_ALEN];
+	uint8_t addr2[ETH_ALEN];
+	uint8_t addr3[ETH_ALEN];
+	u16 seq_ctl;
+	uint8_t addr4[ETH_ALEN];
+} __attribute__ ((packed));
+
+struct rtw_ieee80211_hdr_3addr {
+	u16 frame_ctl;
+	u16 duration_id;
+	uint8_t addr1[ETH_ALEN];
+	uint8_t addr2[ETH_ALEN];
+	uint8_t addr3[ETH_ALEN];
+	u16 seq_ctl;
+} __attribute__ ((packed));
+
+
+struct rtw_ieee80211_hdr_qos {
+	u16 frame_ctl;
+	u16 duration_id;
+	uint8_t addr1[ETH_ALEN];
+	uint8_t addr2[ETH_ALEN];
+	uint8_t addr3[ETH_ALEN];
+	u16 seq_ctl;
+	uint8_t addr4[ETH_ALEN];
+	u16	qc;
+}  __attribute__ ((packed));
+
+struct rtw_ieee80211_hdr_3addr_qos {
+        u16 frame_ctl;
+	u16 duration_id;
+	uint8_t addr1[ETH_ALEN];
+	uint8_t addr2[ETH_ALEN];
+	uint8_t addr3[ETH_ALEN];
+	u16 seq_ctl;
+       u16     qc;
+}  __attribute__ ((packed));
+
+struct eapol {
+	uint8_t snap[6];
+	u16 ethertype;
+	uint8_t version;
+	uint8_t type;
+	u16 length;
+} __attribute__ ((packed));
+
+enum eap_type {
+	EAP_PACKET = 0,
+	EAPOL_START,
+	EAPOL_LOGOFF,
+	EAPOL_KEY,
+	EAPOL_ENCAP_ASF_ALERT
+};
+
+#define IEEE80211_3ADDR_LEN 24
+#define IEEE80211_4ADDR_LEN 30
+#define IEEE80211_FCS_LEN    4
+
+#define MIN_FRAG_THRESHOLD     256U
+#define	MAX_FRAG_THRESHOLD     2346U
+
+/* Frame control field constants */
+#define RTW_IEEE80211_FCTL_VERS		0x0003
+#define RTW_IEEE80211_FCTL_FTYPE		0x000c
+#define RTW_IEEE80211_FCTL_STYPE		0x00f0
+#define RTW_IEEE80211_FCTL_TODS		0x0100
+#define RTW_IEEE80211_FCTL_FROMDS	0x0200
+#define RTW_IEEE80211_FCTL_MOREFRAGS	0x0400
+#define RTW_IEEE80211_FCTL_RETRY		0x0800
+#define RTW_IEEE80211_FCTL_PM		0x1000
+#define RTW_IEEE80211_FCTL_MOREDATA	0x2000
+#define RTW_IEEE80211_FCTL_PROTECTED	0x4000
+#define RTW_IEEE80211_FCTL_ORDER		0x8000
+#define RTW_IEEE80211_FCTL_CTL_EXT	0x0f00
+
+#define RTW_IEEE80211_FTYPE_MGMT		0x0000
+#define RTW_IEEE80211_FTYPE_CTL		0x0004
+#define RTW_IEEE80211_FTYPE_DATA		0x0008
+#define RTW_IEEE80211_FTYPE_EXT		0x000c
+
+/* management */
+#define RTW_IEEE80211_STYPE_ASSOC_REQ	0x0000
+#define RTW_IEEE80211_STYPE_ASSOC_RESP 	0x0010
+#define RTW_IEEE80211_STYPE_REASSOC_REQ	0x0020
+#define RTW_IEEE80211_STYPE_REASSOC_RESP	0x0030
+#define RTW_IEEE80211_STYPE_PROBE_REQ	0x0040
+#define RTW_IEEE80211_STYPE_PROBE_RESP	0x0050
+#define RTW_IEEE80211_STYPE_BEACON		0x0080
+#define RTW_IEEE80211_STYPE_ATIM		0x0090
+#define RTW_IEEE80211_STYPE_DISASSOC	0x00A0
+#define RTW_IEEE80211_STYPE_AUTH		0x00B0
+#define RTW_IEEE80211_STYPE_DEAUTH		0x00C0
+#define RTW_IEEE80211_STYPE_ACTION		0x00D0
+
+/* control */
+#define RTW_IEEE80211_STYPE_CTL_EXT		0x0060
+#define RTW_IEEE80211_STYPE_BACK_REQ		0x0080
+#define RTW_IEEE80211_STYPE_BACK		0x0090
+#define RTW_IEEE80211_STYPE_PSPOLL		0x00A0
+#define RTW_IEEE80211_STYPE_RTS		0x00B0
+#define RTW_IEEE80211_STYPE_CTS		0x00C0
+#define RTW_IEEE80211_STYPE_ACK		0x00D0
+#define RTW_IEEE80211_STYPE_CFEND		0x00E0
+#define RTW_IEEE80211_STYPE_CFENDACK		0x00F0
+
+/* data */
+#define RTW_IEEE80211_STYPE_DATA		0x0000
+#define RTW_IEEE80211_STYPE_DATA_CFACK	0x0010
+#define RTW_IEEE80211_STYPE_DATA_CFPOLL	0x0020
+#define RTW_IEEE80211_STYPE_DATA_CFACKPOLL	0x0030
+#define RTW_IEEE80211_STYPE_NULLFUNC	0x0040
+#define RTW_IEEE80211_STYPE_CFACK		0x0050
+#define RTW_IEEE80211_STYPE_CFPOLL		0x0060
+#define RTW_IEEE80211_STYPE_CFACKPOLL	0x0070
+#define RTW_IEEE80211_STYPE_QOS_DATA		0x0080
+#define RTW_IEEE80211_STYPE_QOS_DATA_CFACK		0x0090
+#define RTW_IEEE80211_STYPE_QOS_DATA_CFPOLL		0x00A0
+#define RTW_IEEE80211_STYPE_QOS_DATA_CFACKPOLL	0x00B0
+#define RTW_IEEE80211_STYPE_QOS_NULLFUNC	0x00C0
+#define RTW_IEEE80211_STYPE_QOS_CFACK		0x00D0
+#define RTW_IEEE80211_STYPE_QOS_CFPOLL		0x00E0
+#define RTW_IEEE80211_STYPE_QOS_CFACKPOLL	0x00F0
+
+/* sequence control field */
+#define RTW_IEEE80211_SCTL_FRAG	0x000F
+#define RTW_IEEE80211_SCTL_SEQ	0xFFF0
+
+
+#define RTW_ERP_INFO_NON_ERP_PRESENT BIT(0)
+#define RTW_ERP_INFO_USE_PROTECTION BIT(1)
+#define RTW_ERP_INFO_BARKER_PREAMBLE_MODE BIT(2)
+
+/* QoS,QOS */
+#define NORMAL_ACK			0
+#define NO_ACK				1
+#define NON_EXPLICIT_ACK	2
+#define BLOCK_ACK			3
+
+#ifndef ETH_P_PAE
+#define ETH_P_PAE 0x888E /* Port Access Entity (IEEE 802.1X) */
+#endif /* ETH_P_PAE */
+
+#define ETH_P_PREAUTH 0x88C7 /* IEEE 802.11i pre-authentication */
+
+#define ETH_P_ECONET	0x0018
+
+#ifndef ETH_P_80211_RAW
+#define ETH_P_80211_RAW (ETH_P_ECONET + 1)
+#endif
+
+/* IEEE 802.11 defines */
+
+#define P80211_OUI_LEN 3
+
+struct ieee80211_snap_hdr {
+
+        uint8_t    dsap;   /* always 0xAA */
+        uint8_t    ssap;   /* always 0xAA */
+        uint8_t    ctrl;   /* always 0x03 */
+        uint8_t    oui[P80211_OUI_LEN];    /* organizational universal id */
+
+} __attribute__ ((packed));
+
+#define SNAP_SIZE sizeof(struct ieee80211_snap_hdr)
+
+#define WLAN_FC_GET_TYPE(fc) ((fc) & RTW_IEEE80211_FCTL_FTYPE)
+#define WLAN_FC_GET_STYPE(fc) ((fc) & RTW_IEEE80211_FCTL_STYPE)
+
+#define WLAN_QC_GET_TID(qc) ((qc) & 0x0f)
+
+#define WLAN_GET_SEQ_FRAG(seq) ((seq) & RTW_IEEE80211_SCTL_FRAG)
+#define WLAN_GET_SEQ_SEQ(seq)  ((seq) & RTW_IEEE80211_SCTL_SEQ)
+
+/* Authentication algorithms */
+#define WLAN_AUTH_OPEN 0
+#define WLAN_AUTH_SHARED_KEY 1
+
+#define WLAN_AUTH_CHALLENGE_LEN 128
+
+#define WLAN_CAPABILITY_BSS (1<<0)
+#define WLAN_CAPABILITY_IBSS (1<<1)
+#define WLAN_CAPABILITY_CF_POLLABLE (1<<2)
+#define WLAN_CAPABILITY_CF_POLL_REQUEST (1<<3)
+#define WLAN_CAPABILITY_PRIVACY (1<<4)
+#define WLAN_CAPABILITY_SHORT_PREAMBLE (1<<5)
+#define WLAN_CAPABILITY_PBCC (1<<6)
+#define WLAN_CAPABILITY_CHANNEL_AGILITY (1<<7)
+#define WLAN_CAPABILITY_SHORT_SLOT (1<<10)
+
+/* Status codes */
+#define WLAN_STATUS_SUCCESS 0
+#define WLAN_STATUS_UNSPECIFIED_FAILURE 1
+#define WLAN_STATUS_CAPS_UNSUPPORTED 10
+#define WLAN_STATUS_REASSOC_NO_ASSOC 11
+#define WLAN_STATUS_ASSOC_DENIED_UNSPEC 12
+#define WLAN_STATUS_NOT_SUPPORTED_AUTH_ALG 13
+#define WLAN_STATUS_UNKNOWN_AUTH_TRANSACTION 14
+#define WLAN_STATUS_CHALLENGE_FAIL 15
+#define WLAN_STATUS_AUTH_TIMEOUT 16
+#define WLAN_STATUS_AP_UNABLE_TO_HANDLE_NEW_STA 17
+#define WLAN_STATUS_ASSOC_DENIED_RATES 18
+/* 802.11b */
+#define WLAN_STATUS_ASSOC_DENIED_NOSHORT 19
+#define WLAN_STATUS_ASSOC_DENIED_NOPBCC 20
+#define WLAN_STATUS_ASSOC_DENIED_NOAGILITY 21
+
+/* Reason codes */
+#define WLAN_REASON_UNSPECIFIED 1
+#define WLAN_REASON_PREV_AUTH_NOT_VALID 2
+#define WLAN_REASON_DEAUTH_LEAVING 3
+#define WLAN_REASON_DISASSOC_DUE_TO_INACTIVITY 4
+#define WLAN_REASON_DISASSOC_AP_BUSY 5
+#define WLAN_REASON_CLASS2_FRAME_FROM_NONAUTH_STA 6
+#define WLAN_REASON_CLASS3_FRAME_FROM_NONASSOC_STA 7
+#define WLAN_REASON_DISASSOC_STA_HAS_LEFT 8
+#define WLAN_REASON_STA_REQ_ASSOC_WITHOUT_AUTH 9
+#define WLAN_REASON_JOIN_WRONG_CHANNEL       65534
+#define WLAN_REASON_EXPIRATION_CHK 65535
+
+/* Information Element IDs */
+#define WLAN_EID_SSID 0
+#define WLAN_EID_SUPP_RATES 1
+#define WLAN_EID_FH_PARAMS 2
+#define WLAN_EID_DS_PARAMS 3
+#define WLAN_EID_CF_PARAMS 4
+#define WLAN_EID_TIM 5
+#define WLAN_EID_IBSS_PARAMS 6
+#define WLAN_EID_CHALLENGE 16
+/* EIDs defined by IEEE 802.11h - START */
+#define WLAN_EID_PWR_CONSTRAINT 32
+#define WLAN_EID_PWR_CAPABILITY 33
+#define WLAN_EID_TPC_REQUEST 34
+#define WLAN_EID_TPC_REPORT 35
+#define WLAN_EID_SUPPORTED_CHANNELS 36
+#define WLAN_EID_CHANNEL_SWITCH 37
+#define WLAN_EID_MEASURE_REQUEST 38
+#define WLAN_EID_MEASURE_REPORT 39
+#define WLAN_EID_QUITE 40
+#define WLAN_EID_IBSS_DFS 41
+/* EIDs defined by IEEE 802.11h - END */
+#define WLAN_EID_ERP_INFO 42
+#define WLAN_EID_HT_CAP 45
+#define WLAN_EID_RSN 48
+#define WLAN_EID_EXT_SUPP_RATES 50
+#define WLAN_EID_MOBILITY_DOMAIN 54
+#define WLAN_EID_FAST_BSS_TRANSITION 55
+#define WLAN_EID_TIMEOUT_INTERVAL 56
+#define WLAN_EID_RIC_DATA 57
+#define WLAN_EID_HT_OPERATION 61
+#define WLAN_EID_SECONDARY_CHANNEL_OFFSET 62
+#define WLAN_EID_20_40_BSS_COEXISTENCE 72
+#define WLAN_EID_20_40_BSS_INTOLERANT 73
+#define WLAN_EID_OVERLAPPING_BSS_SCAN_PARAMS 74
+#define WLAN_EID_MMIE 76
+#define WLAN_EID_VENDOR_SPECIFIC 221
+#define WLAN_EID_GENERIC (WLAN_EID_VENDOR_SPECIFIC)
+#define WLAN_EID_VHT_CAPABILITY 191
+#define WLAN_EID_VHT_OPERATION 192
+#define WLAN_EID_VHT_OP_MODE_NOTIFY 193
+
+#define IEEE80211_MGMT_HDR_LEN 24
+#define IEEE80211_DATA_HDR3_LEN 24
+#define IEEE80211_DATA_HDR4_LEN 30
+
+
+#define IEEE80211_STATMASK_SIGNAL (1<<0)
+#define IEEE80211_STATMASK_RSSI (1<<1)
+#define IEEE80211_STATMASK_NOISE (1<<2)
+#define IEEE80211_STATMASK_RATE (1<<3)
+#define IEEE80211_STATMASK_WEMASK 0x7
+
+
+#define IEEE80211_CCK_MODULATION    (1<<0)
+#define IEEE80211_OFDM_MODULATION   (1<<1)
+
+#define IEEE80211_24GHZ_BAND     (1<<0)
+#define IEEE80211_52GHZ_BAND     (1<<1)
+
+#define IEEE80211_CCK_RATE_LEN  		4
+#define IEEE80211_NUM_OFDM_RATESLEN	8
+
+
+#define IEEE80211_CCK_RATE_1MB		        0x02
+#define IEEE80211_CCK_RATE_2MB		        0x04
+#define IEEE80211_CCK_RATE_5MB		        0x0B
+#define IEEE80211_CCK_RATE_11MB		        0x16
+#define IEEE80211_OFDM_RATE_LEN 		8
+#define IEEE80211_OFDM_RATE_6MB		        0x0C
+#define IEEE80211_OFDM_RATE_9MB		        0x12
+#define IEEE80211_OFDM_RATE_12MB		0x18
+#define IEEE80211_OFDM_RATE_18MB		0x24
+#define IEEE80211_OFDM_RATE_24MB		0x30
+#define IEEE80211_OFDM_RATE_36MB		0x48
+#define IEEE80211_OFDM_RATE_48MB		0x60
+#define IEEE80211_OFDM_RATE_54MB		0x6C
+#define IEEE80211_BASIC_RATE_MASK		0x80
+
+#define IEEE80211_NUM_OFDM_RATES	    8
+#define IEEE80211_NUM_CCK_RATES	            4
+#define IEEE80211_OFDM_SHIFT_MASK_A         4
+
+
+
+#define IS_HT_RATE(rate)		(((rate) & 0x80) ? true : false)
+#define IS_CCK_RATE(_rate) 	(_rate == MGN_1M || _rate == MGN_2M || _rate == MGN_5_5M || _rate == MGN_11M)
+
+/* IEEE 802.11 requires that STA supports concurrent reception of at least
+ * three fragmented frames. This define can be increased to support more
+ * concurrent frames, but it should be noted that each entry can consume about
+ * 2 kB of RAM and increasing cache size will slow down frame reassembly. */
+#define IEEE80211_FRAG_CACHE_LEN 4
+
+#define SEC_KEY_1         (1<<0)
+#define SEC_KEY_2         (1<<1)
+#define SEC_KEY_3         (1<<2)
+#define SEC_KEY_4         (1<<3)
+#define SEC_ACTIVE_KEY    (1<<4)
+#define SEC_AUTH_MODE     (1<<5)
+#define SEC_UNICAST_GROUP (1<<6)
+#define SEC_LEVEL         (1<<7)
+#define SEC_ENABLED       (1<<8)
+
+#define SEC_LEVEL_0      0 /* None */
+#define SEC_LEVEL_1      1 /* WEP 40 and 104 bit */
+#define SEC_LEVEL_2      2 /* Level 1 + TKIP */
+#define SEC_LEVEL_2_CKIP 3 /* Level 1 + CKIP */
+#define SEC_LEVEL_3      4 /* Level 2 + CCMP */
+
+#define WEP_KEYS 4
+#define WEP_KEY_LEN 13
+
+struct ieee80211_security {
+	u16 active_key:2,
+            enabled:1,
+	    auth_mode:2,
+            auth_algo:4,
+            unicast_uses_group:1;
+	uint8_t key_sizes[WEP_KEYS];
+	uint8_t keys[WEP_KEYS][WEP_KEY_LEN];
+	uint8_t level;
+	u16 flags;
+} __attribute__ ((packed));
+
+/*
+
+ 802.11 data frame from AP
+
+      ,-------------------------------------------------------------------.
+Bytes |  2   |  2   |    6    |    6    |    6    |  2   | 0..2312 |   4  |
+      |------|------|---------|---------|---------|------|---------|------|
+Desc. | ctrl | dura |  DA/RA  |   TA    |    SA   | Sequ |  frame  |  fcs |
+      |      | tion | (BSSID) |         |         | ence |  data   |      |
+      `-------------------------------------------------------------------'
+
+Total: 28-2340 bytes
+
+*/
+
+struct ieee80211_header_data {
+	u16 frame_ctl;
+	u16 duration_id;
+	uint8_t addr1[6];
+	uint8_t addr2[6];
+	uint8_t addr3[6];
+	u16 seq_ctrl;
+};
+
+#define BEACON_PROBE_SSID_ID_POSITION 12
+
+/* Management Frame Information Element Types */
+#define MFIE_TYPE_SSID       0
+#define MFIE_TYPE_RATES      1
+#define MFIE_TYPE_FH_SET     2
+#define MFIE_TYPE_DS_SET     3
+#define MFIE_TYPE_CF_SET     4
+#define MFIE_TYPE_TIM        5
+#define MFIE_TYPE_IBSS_SET   6
+#define MFIE_TYPE_CHALLENGE  16
+#define MFIE_TYPE_ERP        42
+#define MFIE_TYPE_RSN	     48
+#define MFIE_TYPE_RATES_EX   50
+#define MFIE_TYPE_GENERIC    221
+
+struct ieee80211_info_element_hdr {
+	uint8_t id;
+	uint8_t len;
+} __attribute__ ((packed));
+
+struct ieee80211_info_element {
+	uint8_t id;
+	uint8_t len;
+	uint8_t data[0];
+} __attribute__ ((packed));
+
+/*
+ * These are the data types that can make up management packets
+ *
+	u16 auth_algorithm;
+	u16 auth_sequence;
+	u16 beacon_interval;
+	u16 capability;
+	uint8_t current_ap[ETH_ALEN];
+	u16 listen_interval;
+	struct {
+		u16 association_id:14, reserved:2;
+	} __attribute__ ((packed));
+	u32 time_stamp[2];
+	u16 reason;
+	u16 status;
+*/
+
+#define IEEE80211_DEFAULT_TX_ESSID "Penguin"
+#define IEEE80211_DEFAULT_BASIC_RATE 10
+
+
+struct ieee80211_txb {
+	uint8_t nr_frags;
+	uint8_t encrypted;
+	u16 reserved;
+	u16 frag_size;
+	u16 payload_size;
+	struct sk_buff *fragments[0];
+};
+
+
+/* SWEEP TABLE ENTRIES NUMBER*/
+#define MAX_SWEEP_TAB_ENTRIES		  42
+#define MAX_SWEEP_TAB_ENTRIES_PER_PACKET  7
+/* MAX_RATES_LENGTH needs to be 12.  The spec says 8, and many APs
+ * only use 8, and then use extended rates for the remaining supported
+ * rates.  Other APs, however, stick all of their supported rates on the
+ * main rates information element... */
+#define MAX_RATES_LENGTH                  ((u8)12)
+#define MAX_RATES_EX_LENGTH               ((u8)16)
+#define MAX_NETWORK_COUNT                  128
+#define MAX_CHANNEL_NUMBER                 161
+#define IEEE80211_SOFTMAC_SCAN_TIME	  400
+//(HZ / 2)
+#define IEEE80211_SOFTMAC_ASSOC_RETRY_TIME (HZ * 2)
+
+#define CRC_LENGTH                 4U
+
+#define MAX_WPA_IE_LEN (256)
+#define MAX_WPS_IE_LEN (512)
+#define MAX_P2P_IE_LEN (256)
+#define MAX_WFD_IE_LEN (128)
+
+#define NETWORK_EMPTY_ESSID (1<<0)
+#define NETWORK_HAS_OFDM    (1<<1)
+#define NETWORK_HAS_CCK     (1<<2)
+
+#define IEEE80211_DTIM_MBCAST 4
+#define IEEE80211_DTIM_UCAST 2
+#define IEEE80211_DTIM_VALID 1
+#define IEEE80211_DTIM_INVALID 0
+
+#define IEEE80211_PS_DISABLED 0
+#define IEEE80211_PS_UNICAST IEEE80211_DTIM_UCAST
+#define IEEE80211_PS_MBCAST IEEE80211_DTIM_MBCAST
+#define IW_ESSID_MAX_SIZE 32
+/*
+join_res:
+-1: authentication fail
+-2: association fail
+> 0: TID
+*/
+
+
+enum ieee80211_state {
+
+	/* the card is not linked at all */
+	IEEE80211_NOLINK = 0,
+
+	/* IEEE80211_ASSOCIATING* are for BSS client mode
+	 * the driver shall not perform RX filtering unless
+	 * the state is LINKED.
+	 * The driver shall just check for the state LINKED and
+	 * defaults to NOLINK for ALL the other states (including
+	 * LINKED_SCANNING)
+	 */
+
+	/* the association procedure will start (wq scheduling)*/
+	IEEE80211_ASSOCIATING,
+	IEEE80211_ASSOCIATING_RETRY,
+
+	/* the association procedure is sending AUTH request*/
+	IEEE80211_ASSOCIATING_AUTHENTICATING,
+
+	/* the association procedure has successfully authentcated
+	 * and is sending association request
+	 */
+	IEEE80211_ASSOCIATING_AUTHENTICATED,
+
+	/* the link is ok. the card associated to a BSS or linked
+	 * to a ibss cell or acting as an AP and creating the bss
+	 */
+	IEEE80211_LINKED,
+
+	/* same as LINKED, but the driver shall apply RX filter
+	 * rules as we are in NO_LINK mode. As the card is still
+	 * logically linked, but it is doing a syncro site survey
+	 * then it will be back to LINKED state.
+	 */
+	IEEE80211_LINKED_SCANNING,
+
+};
+
+#define DEFAULT_MAX_SCAN_AGE (15 * HZ)
+#define DEFAULT_FTS 2346
+#define MAC_FMT "%02x:%02x:%02x:%02x:%02x:%02x"
+#define MAC_ARG(x) ((u8*)(x))[0],((u8*)(x))[1],((u8*)(x))[2],((u8*)(x))[3],((u8*)(x))[4],((u8*)(x))[5]
+
+extern __inline int is_multicast_mac_addr(const uint8_t *addr)
+{
+        return ((addr[0] != 0xff) && (0x01 & addr[0]));
+}
+
+extern __inline int is_broadcast_mac_addr(const uint8_t *addr)
+{
+	return ((addr[0] == 0xff) && (addr[1] == 0xff) && (addr[2] == 0xff) &&   \
+		(addr[3] == 0xff) && (addr[4] == 0xff) && (addr[5] == 0xff));
+}
+
+#define CFG_IEEE80211_RESERVE_FCS (1<<0)
+#define CFG_IEEE80211_COMPUTE_FCS (1<<1)
+
+typedef struct tx_pending_t{
+	int frag;
+	struct ieee80211_txb *txb;
+}tx_pending_t;
+
+
+
+#define MAXTID	16
+
+#define IEEE_A            (1<<0)
+#define IEEE_B            (1<<1)
+#define IEEE_G            (1<<2)
+#define IEEE_MODE_MASK    (IEEE_A|IEEE_B|IEEE_G)
+
+//Baron move to ieee80211.c
+int ieee80211_is_empty_essid(const char *essid, int essid_len);
+int ieee80211_get_hdrlen(u16 fc);
+
+#if 0
+/* Action frame categories (IEEE 802.11-2007, 7.3.1.11, Table 7-24) */
+#define WLAN_ACTION_SPECTRUM_MGMT 0
+#define WLAN_ACTION_QOS 1
+#define WLAN_ACTION_DLS 2
+#define WLAN_ACTION_BLOCK_ACK 3
+#define WLAN_ACTION_RADIO_MEASUREMENT 5
+#define WLAN_ACTION_FT 6
+#define WLAN_ACTION_SA_QUERY 8
+#define WLAN_ACTION_WMM 17
+#endif
+
+
+/* Action category code */
+enum rtw_ieee80211_category {
+	RTW_WLAN_CATEGORY_SPECTRUM_MGMT = 0,
+	RTW_WLAN_CATEGORY_QOS = 1,
+	RTW_WLAN_CATEGORY_DLS = 2,
+	RTW_WLAN_CATEGORY_BACK = 3,
+	RTW_WLAN_CATEGORY_PUBLIC = 4, //IEEE 802.11 public action frames
+	RTW_WLAN_CATEGORY_RADIO_MEASUREMENT  = 5,
+	RTW_WLAN_CATEGORY_FT = 6,
+	RTW_WLAN_CATEGORY_HT = 7,
+	RTW_WLAN_CATEGORY_SA_QUERY = 8,
+	RTW_WLAN_CATEGORY_TDLS = 12,
+	RTW_WLAN_CATEGORY_WMM = 17,
+	RTW_WLAN_CATEGORY_P2P = 0x7f,//P2P action frames
+};
+
+/* SPECTRUM_MGMT action code */
+enum rtw_ieee80211_spectrum_mgmt_actioncode {
+	RTW_WLAN_ACTION_SPCT_MSR_REQ = 0,
+	RTW_WLAN_ACTION_SPCT_MSR_RPRT = 1,
+	RTW_WLAN_ACTION_SPCT_TPC_REQ = 2,
+	RTW_WLAN_ACTION_SPCT_TPC_RPRT = 3,
+	RTW_WLAN_ACTION_SPCT_CHL_SWITCH = 4,
+	RTW_WLAN_ACTION_SPCT_EXT_CHL_SWITCH = 5,
+};
+
+enum _PUBLIC_ACTION{
+	ACT_PUBLIC_BSSCOEXIST = 0, // 20/40 BSS Coexistence
+	ACT_PUBLIC_DSE_ENABLE = 1,
+	ACT_PUBLIC_DSE_DEENABLE = 2,
+	ACT_PUBLIC_DSE_REG_LOCATION = 3,
+	ACT_PUBLIC_EXT_CHL_SWITCH = 4,
+	ACT_PUBLIC_DSE_MSR_REQ = 5,
+	ACT_PUBLIC_DSE_MSR_RPRT = 6,
+	ACT_PUBLIC_MP = 7, // Measurement Pilot
+	ACT_PUBLIC_DSE_PWR_CONSTRAINT = 8,
+	ACT_PUBLIC_VENDOR = 9, // for WIFI_DIRECT
+	ACT_PUBLIC_GAS_INITIAL_REQ = 10,
+	ACT_PUBLIC_GAS_INITIAL_RSP = 11,
+	ACT_PUBLIC_GAS_COMEBACK_REQ = 12,
+	ACT_PUBLIC_GAS_COMEBACK_RSP = 13,
+	ACT_PUBLIC_TDLS_DISCOVERY_RSP = 14,
+	ACT_PUBLIC_LOCATION_TRACK = 15,
+	ACT_PUBLIC_MAX
+};
+
+
+/* BACK action code */
+enum rtw_ieee80211_back_actioncode {
+	RTW_WLAN_ACTION_ADDBA_REQ = 0,
+	RTW_WLAN_ACTION_ADDBA_RESP = 1,
+	RTW_WLAN_ACTION_DELBA = 2,
+};
+
+/* HT features action code */
+enum rtw_ieee80211_ht_actioncode {
+	RTW_WLAN_ACTION_NOTIFY_CH_WIDTH = 0,
+       RTW_WLAN_ACTION_SM_PS = 1,
+       RTW_WLAN_ACTION_PSPM = 2,
+       RTW_WLAN_ACTION_PCO_PHASE = 3,
+       RTW_WLAN_ACTION_MIMO_CSI_MX = 4,
+       RTW_WLAN_ACTION_MIMO_NONCP_BF = 5,
+       RTW_WLAN_ACTION_MIMP_CP_BF = 6,
+       RTW_WLAN_ACTION_ASEL_INDICATES_FB = 7,
+       RTW_WLAN_ACTION_HI_INFO_EXCHG = 8,
+};
+
+/* BACK (block-ack) parties */
+enum rtw_ieee80211_back_parties {
+	RTW_WLAN_BACK_RECIPIENT = 0,
+	RTW_WLAN_BACK_INITIATOR = 1,
+	RTW_WLAN_BACK_TIMER = 2,
+};
+
+
+#define OUI_MICROSOFT 0x0050f2 /* Microsoft (also used in Wi-Fi specs)
+				* 00:50:F2 */
+#define WME_OUI_TYPE 2
+#define WME_OUI_SUBTYPE_INFORMATION_ELEMENT 0
+#define WME_OUI_SUBTYPE_PARAMETER_ELEMENT 1
+#define WME_OUI_SUBTYPE_TSPEC_ELEMENT 2
+#define WME_VERSION 1
+
+#define WME_ACTION_CODE_SETUP_REQUEST 0
+#define WME_ACTION_CODE_SETUP_RESPONSE 1
+#define WME_ACTION_CODE_TEARDOWN 2
+
+#define WME_SETUP_RESPONSE_STATUS_ADMISSION_ACCEPTED 0
+#define WME_SETUP_RESPONSE_STATUS_INVALID_PARAMETERS 1
+#define WME_SETUP_RESPONSE_STATUS_REFUSED 3
+
+#define WME_TSPEC_DIRECTION_UPLINK 0
+#define WME_TSPEC_DIRECTION_DOWNLINK 1
+#define WME_TSPEC_DIRECTION_BI_DIRECTIONAL 3
+
+
+#define OUI_BROADCOM 0x00904c /* Broadcom (Epigram) */
+
+#define VENDOR_HT_CAPAB_OUI_TYPE 0x33 /* 00-90-4c:0x33 */
+
+/**
+ * enum rtw_ieee80211_channel_flags - channel flags
+ *
+ * Channel flags set by the regulatory control code.
+ *
+ * @RTW_IEEE80211_CHAN_DISABLED: This channel is disabled.
+ * @RTW_IEEE80211_CHAN_PASSIVE_SCAN: Only passive scanning is permitted
+ *      on this channel.
+ * @RTW_IEEE80211_CHAN_NO_IBSS: IBSS is not allowed on this channel.
+ * @RTW_IEEE80211_CHAN_RADAR: Radar detection is required on this channel.
+ * @RTW_IEEE80211_CHAN_NO_HT40PLUS: extension channel above this channel
+ *      is not permitted.
+ * @RTW_IEEE80211_CHAN_NO_HT40MINUS: extension channel below this channel
+ *      is not permitted.
+ */
+  enum rtw_ieee80211_channel_flags {
+          RTW_IEEE80211_CHAN_DISABLED         = 1<<0,
+          RTW_IEEE80211_CHAN_PASSIVE_SCAN     = 1<<1,
+          RTW_IEEE80211_CHAN_NO_IBSS          = 1<<2,
+          RTW_IEEE80211_CHAN_RADAR            = 1<<3,
+          RTW_IEEE80211_CHAN_NO_HT40PLUS      = 1<<4,
+          RTW_IEEE80211_CHAN_NO_HT40MINUS     = 1<<5,
+  };
+
+  #define RTW_IEEE80211_CHAN_NO_HT40 \
+          (RTW_IEEE80211_CHAN_NO_HT40PLUS | RTW_IEEE80211_CHAN_NO_HT40MINUS)
+
+/* Represent channel details, subset of ieee80211_channel */
+struct rtw_ieee80211_channel {
+	//enum ieee80211_band band;
+	//u16 center_freq;
+	u16 hw_value;
+	u32 flags;
+	//int max_antenna_gain;
+	//int max_power;
+	//int max_reg_power;
+	//bool beacon_found;
+	//u32 orig_flags;
+	//int orig_mag;
+	//int orig_mpwr;
+};
+
+#define CHAN_FMT \
+	/*"band:%d, "*/ \
+	/*"center_freq:%u, "*/ \
+	"hw_value:%u, " \
+	"flags:0x%08x" \
+	/*"max_antenna_gain:%d\n"*/ \
+	/*"max_power:%d\n"*/ \
+	/*"max_reg_power:%d\n"*/ \
+	/*"beacon_found:%u\n"*/ \
+	/*"orig_flags:0x%08x\n"*/ \
+	/*"orig_mag:%d\n"*/ \
+	/*"orig_mpwr:%d\n"*/
+
+#define CHAN_ARG(channel) \
+	/*(channel)->band*/ \
+	/*, (channel)->center_freq*/ \
+	(channel)->hw_value \
+	, (channel)->flags \
+	/*, (channel)->max_antenna_gain*/ \
+	/*, (channel)->max_power*/ \
+	/*, (channel)->max_reg_power*/ \
+	/*, (channel)->beacon_found*/ \
+	/*, (channel)->orig_flags*/ \
+	/*, (channel)->orig_mag*/ \
+	/*, (channel)->orig_mpwr*/ \
+
+/* Parsed Information Elements */
+struct rtw_ieee802_11_elems {
+	uint8_t *ssid;
+	uint8_t ssid_len;
+	uint8_t *supp_rates;
+	uint8_t supp_rates_len;
+	uint8_t *fh_params;
+	uint8_t fh_params_len;
+	uint8_t *ds_params;
+	uint8_t ds_params_len;
+	uint8_t *cf_params;
+	uint8_t cf_params_len;
+	uint8_t *tim;
+	uint8_t tim_len;
+	uint8_t *ibss_params;
+	uint8_t ibss_params_len;
+	uint8_t *challenge;
+	uint8_t challenge_len;
+	uint8_t *erp_info;
+	uint8_t erp_info_len;
+	uint8_t *ext_supp_rates;
+	uint8_t ext_supp_rates_len;
+	uint8_t *wpa_ie;
+	uint8_t wpa_ie_len;
+	uint8_t *rsn_ie;
+	uint8_t rsn_ie_len;
+	uint8_t *wme;
+	uint8_t wme_len;
+	uint8_t *wme_tspec;
+	uint8_t wme_tspec_len;
+	uint8_t *wps_ie;
+	uint8_t wps_ie_len;
+	uint8_t *power_cap;
+	uint8_t power_cap_len;
+	uint8_t *supp_channels;
+	uint8_t supp_channels_len;
+	uint8_t *mdie;
+	uint8_t mdie_len;
+	uint8_t *ftie;
+	uint8_t ftie_len;
+	uint8_t *timeout_int;
+	uint8_t timeout_int_len;
+	uint8_t *ht_capabilities;
+	uint8_t ht_capabilities_len;
+	uint8_t *ht_operation;
+	uint8_t ht_operation_len;
+	uint8_t *vendor_ht_cap;
+	uint8_t vendor_ht_cap_len;
+	uint8_t *vht_capabilities;
+	uint8_t vht_capabilities_len;
+	uint8_t *vht_operation;
+	uint8_t vht_operation_len;
+	uint8_t *vht_op_mode_notify;
+	uint8_t vht_op_mode_notify_len;
+};
+
+typedef enum { ParseOK = 0, ParseUnknown = 1, ParseFailed = -1 } ParseRes;
+
+ParseRes rtw_ieee802_11_parse_elems(uint8_t *start, uint len,
+				struct rtw_ieee802_11_elems *elems,
+				int show_errors);
+
+uint8_t *rtw_set_fixed_ie(unsigned char *pbuf, unsigned int len, unsigned char *source, unsigned int *frlen);
+uint8_t *rtw_set_ie(uint8_t *pbuf, int index, uint len, uint8_t *source, uint *frlen);
+
+enum secondary_ch_offset {
+	SCN = 0, /* no secondary channel */
+	SCA = 1, /* secondary channel above */
+	SCB = 3,  /* secondary channel below */
+};
+uint8_t secondary_ch_offset_to_hal_ch_offset(uint8_t ch_offset);
+uint8_t hal_ch_offset_to_secondary_ch_offset(uint8_t ch_offset);
+uint8_t *rtw_set_ie_ch_switch(uint8_t *buf, u32 *buf_len, uint8_t ch_switch_mode, uint8_t new_ch, uint8_t ch_switch_cnt);
+uint8_t *rtw_set_ie_secondary_ch_offset(uint8_t *buf, u32 *buf_len, uint8_t secondary_ch_offset);
+uint8_t *rtw_set_ie_mesh_ch_switch_parm(uint8_t *buf, u32 *buf_len, uint8_t ttl, uint8_t flags, u16 reason, u16 precedence);
+
+uint8_t *rtw_get_ie(u8*pbuf, int index, int *len, int limit);
+uint8_t *rtw_get_ie_ex(uint8_t *in_ie, uint in_len, uint8_t eid, uint8_t *oui, uint8_t oui_len, uint8_t *ie, uint *ielen);
+int rtw_ies_remove_ie(uint8_t *ies, uint *ies_len, uint offset, uint8_t eid, uint8_t *oui, uint8_t oui_len);
+
+void rtw_set_supported_rate(u8* SupportedRates, uint mode) ;
+
+unsigned char *rtw_get_wpa_ie(unsigned char *pie, int *wpa_ie_len, int limit);
+unsigned char *rtw_get_wpa2_ie(unsigned char *pie, int *rsn_ie_len, int limit);
+int rtw_get_wpa_cipher_suite(uint8_t *s);
+int rtw_get_wpa2_cipher_suite(uint8_t *s);
+int rtw_get_wapi_ie(uint8_t *in_ie,uint in_len,uint8_t *wapi_ie,u16 *wapi_len);
+int rtw_parse_wpa_ie(u8* wpa_ie, int wpa_ie_len, int *group_cipher, int *pairwise_cipher, int *is_8021x);
+int rtw_parse_wpa2_ie(u8* wpa_ie, int wpa_ie_len, int *group_cipher, int *pairwise_cipher, int *is_8021x);
+
+int rtw_get_sec_ie(uint8_t *in_ie,uint in_len,uint8_t *rsn_ie,u16 *rsn_len,uint8_t *wpa_ie,u16 *wpa_len);
+
+uint8_t rtw_is_wps_ie(uint8_t *ie_ptr, uint *wps_ielen);
+uint8_t *rtw_get_wps_ie(uint8_t *in_ie, uint in_len, uint8_t *wps_ie, uint *wps_ielen);
+uint8_t *rtw_get_wps_attr(uint8_t *wps_ie, uint wps_ielen, u16 target_attr_id ,uint8_t *buf_attr, u32 *len_attr);
+uint8_t *rtw_get_wps_attr_content(uint8_t *wps_ie, uint wps_ielen, u16 target_attr_id ,uint8_t *buf_content, uint *len_content);
+
+/**
+ * for_each_ie - iterate over continuous IEs
+ * @ie:
+ * @buf:
+ * @buf_len:
+ */
+#define for_each_ie(ie, buf, buf_len) \
+	for (ie = (void*)buf; (((u8*)ie) - ((u8*)buf) + 1) < buf_len; ie = (void*)(((u8*)ie) + *(((u8*)ie)+1) + 2))
+
+void dump_ies(uint8_t *buf, u32 buf_len);
+void dump_wps_ie(uint8_t *ie, u32 ie_len);
+
+uint	rtw_get_rateset_len(uint8_t	*rateset);
+
+struct registry_priv;
+int rtw_generate_ie(struct registry_priv *pregistrypriv);
+
+
+int rtw_get_bit_value_from_ieee_value(uint8_t val);
+
+uint	rtw_is_cckrates_included(uint8_t *rate);
+
+uint	rtw_is_cckratesonly_included(uint8_t *rate);
+
+int rtw_check_network_type(unsigned char *rate, int ratelen, int channel);
+
+void rtw_get_bcn_info(struct wlan_network *pnetwork);
+
+void rtw_macaddr_cfg(uint8_t *mac_addr);
+
+u16 rtw_mcs_rate(uint8_t rf_type, uint8_t bw_40MHz, uint8_t short_GI_20, uint8_t short_GI_40, unsigned char * MCS_rate);
+
+int rtw_action_frame_parse(const uint8_t *frame, u32 frame_len, u8* category, uint8_t *action);
+const char *action_public_str(uint8_t action);
+
+#endif /* IEEE80211_H */
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/include/linux/wireless.h linux-4.9.8821au/drivers/staging/rtl8821au/include/linux/wireless.h
--- linux-4.9/drivers/staging/rtl8821au/include/linux/wireless.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/include/linux/wireless.h	2016-12-11 19:48:25.170311727 -0600
@@ -0,0 +1,91 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+#ifndef _LINUX_WIRELESS_H
+#define _LINUX_WIRELESS_H
+
+/***************************** INCLUDES *****************************/
+
+#if 0
+#include <linux/types.h>		/* for __u* and __s* typedefs */
+#include <linux/socket.h>		/* for "struct sockaddr" et al	*/
+#include <linux/if.h>			/* for IFNAMSIZ and co... */
+#else
+#define __user
+//typedef u16	__u16;
+#include <sys/socket.h>			/* for "struct sockaddr" et al	*/
+#include <net/if.h>			/* for IFNAMSIZ and co... */
+#endif
+
+/****************************** TYPES ******************************/
+
+/* --------------------------- SUBTYPES --------------------------- */
+/*
+ *	For all data larger than 16 octets, we need to use a
+ *	pointer to memory allocated in user space.
+ */
+struct	iw_point
+{
+  void __user	*pointer;	/* Pointer to the data  (in user space) */
+  __u16		length;		/* number of fields or size in bytes */
+  __u16		flags;		/* Optional params */
+};
+
+
+/* ------------------------ IOCTL REQUEST ------------------------ */
+/*
+ * This structure defines the payload of an ioctl, and is used
+ * below.
+ *
+ * Note that this structure should fit on the memory footprint
+ * of iwreq (which is the same as ifreq), which mean a max size of
+ * 16 octets = 128 bits. Warning, pointers might be 64 bits wide...
+ * You should check this when increasing the structures defined
+ * above in this file...
+ */
+union	iwreq_data
+{
+	/* Config - generic */
+	char		name[IFNAMSIZ];
+	/* Name : used to verify the presence of  wireless extensions.
+	 * Name of the protocol/provider... */
+
+	struct iw_point	data;		/* Other large parameters */
+};
+
+/*
+ * The structure to exchange data for ioctl.
+ * This structure is the same as 'struct ifreq', but (re)defined for
+ * convenience...
+ * Do I need to remind you about structure size (32 octets) ?
+ */
+struct	iwreq
+{
+	union
+	{
+		char	ifrn_name[IFNAMSIZ];	/* if name, e.g. "eth0" */
+	} ifr_ifrn;
+
+	/* Data part (defined just above) */
+	union	iwreq_data	u;
+};
+
+#endif	/* _LINUX_WIRELESS_H */
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/include/mlme_osdep.h linux-4.9.8821au/drivers/staging/rtl8821au/include/mlme_osdep.h
--- linux-4.9/drivers/staging/rtl8821au/include/mlme_osdep.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/include/mlme_osdep.h	2016-12-11 19:48:25.170311727 -0600
@@ -0,0 +1,39 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef	__MLME_OSDEP_H_
+#define __MLME_OSDEP_H_
+
+
+#if defined(PLATFORM_MPIXEL)
+extern int time_after(u32 now, u32 old);
+#endif
+
+extern void rtw_init_mlme_timer(struct rtl_priv *rtlpriv);
+extern void rtw_os_indicate_disconnect( struct rtl_priv *rtlpriv );
+extern void rtw_os_indicate_connect( struct rtl_priv *rtlpriv );
+void rtw_os_indicate_scan_done( struct rtl_priv *rtlpriv, bool aborted);
+extern void rtw_report_sec_ie(struct rtl_priv *rtlpriv,u8 authmode,u8 *sec_ie);
+
+void rtw_reset_securitypriv( struct rtl_priv *rtlpriv );
+
+u8 rtw_handle_tkip_countermeasure(struct rtl_priv* rtlpriv);
+
+#endif	//_MLME_OSDEP_H_
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/include/nic_spec.h linux-4.9.8821au/drivers/staging/rtl8821au/include/nic_spec.h
--- linux-4.9/drivers/staging/rtl8821au/include/nic_spec.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/include/nic_spec.h	2016-12-11 19:48:25.170311727 -0600
@@ -0,0 +1,47 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/	
+
+
+#ifndef __NIC_SPEC_H__
+#define __NIC_SPEC_H__
+
+#include <drv_conf.h>
+
+#define RTL8711_MCTRL_		(0x20000)
+#define RTL8711_UART_		(0x30000)
+#define RTL8711_TIMER_		(0x40000)
+#define RTL8711_FINT_		(0x50000)
+#define RTL8711_HINT_		(0x50000)
+#define RTL8711_GPIO_		(0x60000)
+#define RTL8711_WLANCTRL_	(0x200000)
+#define RTL8711_WLANFF_		(0xe00000)
+#define RTL8711_HCICTRL_	(0x600000)
+#define RTL8711_SYSCFG_		(0x620000)
+#define RTL8711_SYSCTRL_	(0x620000)
+#define RTL8711_MCCTRL_		(0x020000)
+
+
+#include <rtl8711_regdef.h>
+
+#include <rtl8711_bitdef.h>
+
+
+#endif // __RTL8711_SPEC_H__
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/include/odm.h linux-4.9.8821au/drivers/staging/rtl8821au/include/odm.h
--- linux-4.9/drivers/staging/rtl8821au/include/odm.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/include/odm.h	2016-12-11 19:48:25.173645047 -0600
@@ -0,0 +1,595 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+
+#ifndef	__HALDMOUTSRC_H__
+#define __HALDMOUTSRC_H__
+
+//============================================================
+// Definition
+//============================================================
+//
+// 2011/09/22 MH Define all team supprt ability.
+//
+
+//
+// 2011/09/22 MH Define for all teams. Please Define the constan in your precomp header.
+//
+//#define		DM_ODM_SUPPORT_AP			0
+//#define		DM_ODM_SUPPORT_ADSL			0
+//#define		DM_ODM_SUPPORT_CE			0
+//#define		DM_ODM_SUPPORT_MP			1
+
+//
+// 2011/09/28 MH Define ODM SW team support flag.
+//
+
+
+
+//
+// Antenna Switch Relative Definition.
+//
+
+//
+// 20100503 Joseph:
+// Add new function SwAntDivCheck8192C().
+// This is the main function of Antenna diversity function before link.
+// Mainly, it just retains last scan result and scan again.
+// After that, it compares the scan result to see which one gets better RSSI.
+// It selects antenna with better receiving power and returns better scan result.
+//
+#define	TP_MODE		0
+#define	RSSI_MODE		1
+#define	TRAFFIC_LOW	0
+#define	TRAFFIC_HIGH	1
+
+
+//============================================================
+//3 Tx Power Tracking
+//3============================================================
+#define DPK_DELTA_MAPPING_NUM	13
+#define index_mapping_HP_NUM		15
+#define OFDM_TABLE_SIZE 			37
+#define OFDM_TABLE_SIZE_92D 		43
+#define TXSCALE_TABLE_SIZE 			37
+#define DELTA_SWINGIDX_SIZE		30
+#define BAND_NUM 					3
+
+//============================================================
+//3 PSD Handler
+//3============================================================
+
+#define	AFH_PSD		1	//0:normal PSD scan, 1: only do 20 pts PSD
+#define	MODE_40M		0	//0:20M, 1:40M
+#define	PSD_TH2		3
+#define	PSD_CHMIN		20   // Minimum channel number for BT AFH
+#define	SIR_STEP_SIZE	3
+#define   Smooth_Size_1 	5
+#define	Smooth_TH_1	3
+#define   Smooth_Size_2 	10
+#define	Smooth_TH_2	4
+#define   Smooth_Size_3 	20
+#define	Smooth_TH_3	4
+#define   Smooth_Step_Size 5
+#define	Adaptive_SIR	1
+#define	PSD_SCAN_INTERVAL	700 //ms
+
+
+
+//8723A High Power IGI Setting
+#define		DM_DIG_HIGH_PWR_IGI_LOWER_BOUND	0x22
+#define  		DM_DIG_Gmode_HIGH_PWR_IGI_LOWER_BOUND 0x28
+#define		DM_DIG_HIGH_PWR_THRESHOLD	0x3a
+#define		DM_DIG_LOW_PWR_THRESHOLD	0x14
+
+//ANT Test
+#define 		ANTTESTALL		0x00		//Ant A or B will be Testing
+#define		ANTTESTA		0x01		//Ant A will be Testing
+#define		ANTTESTB		0x02		//Ant B will be testing
+
+// LPS define
+#define DM_DIG_FA_TH0_LPS				4 //-> 4 in lps
+#define DM_DIG_FA_TH1_LPS				15 //-> 15 lps
+#define DM_DIG_FA_TH2_LPS				30 //-> 30 lps
+#define RSSI_OFFSET_DIG					0x05;
+
+
+
+//for 8723A Ant Definition--2012--06--07 due to different IC may be different ANT define
+#define		MAIN_ANT		1		//Ant A or Ant Main
+#define		AUX_ANT		2		//AntB or Ant Aux
+#define		MAX_ANT		3		// 3 for AP using
+
+
+//Antenna Diversity Type
+#define	SW_ANTDIV	0
+#define	HW_ANTDIV	1
+
+//Antenna Diversty Control Type
+#define	ODM_AUTO_ANT	0
+#define	ODM_FIX_MAIN_ANT	1
+#define	ODM_FIX_AUX_ANT	2
+
+//============================================================
+// structure and define
+//============================================================
+
+//
+// 2011/09/20 MH Add for AP/ADSLpseudo DM structuer requirement.
+// We need to remove to other position???
+//
+
+
+
+//#ifdef CONFIG_ANTENNA_DIVERSITY
+// This indicates two different the steps.
+// In SWAW_STEP_PEAK, driver needs to switch antenna and listen to the signal on the air.
+// In SWAW_STEP_DETERMINE, driver just compares the signal captured in SWAW_STEP_PEAK
+// with original RSSI to determine if it is necessary to switch antenna.
+#define SWAW_STEP_PEAK		0
+#define SWAW_STEP_DETERMINE	1
+
+#define	TP_MODE		0
+#define	RSSI_MODE		1
+#define	TRAFFIC_LOW	0
+#define	TRAFFIC_HIGH	1
+
+
+
+
+
+
+#define IQK_MAC_REG_NUM		4
+#define IQK_ADDA_REG_NUM		16
+#define IQK_BB_REG_NUM_MAX	10
+
+
+#define IQK_BB_REG_NUM			10
+#define HP_THERMAL_NUM		8
+
+
+#define		DM_Type_ByFW			0
+#define		DM_Type_ByDriver		1
+
+//
+// Declare for common info
+//
+#define MAX_PATH_NUM_92CS			2
+#define MAX_PATH_NUM_8188E		1
+#define MAX_PATH_NUM_8192E		2
+#define MAX_PATH_NUM_8723B		1
+#define MAX_PATH_NUM_8812A		2
+#define MAX_PATH_NUM_8821A		1
+
+#define IQK_THRESHOLD				8
+
+struct _ODM_Phy_Status_Info_ {
+	//
+	// Be care, if you want to add any element please insert between
+	// RxPWDBAll & SignalStrength.
+	//
+	u8		RxPWDBAll;
+
+	u8		SignalQuality;	 		// in 0-100 index.
+	s8		RxMIMOSignalQuality[4];	//per-path's EVM
+	u8		RxMIMOEVMdbm[4]; 		//per-path's EVM dbm
+
+	u8		RxMIMOSignalStrength[4];// in 0~100 index
+
+	u16		Cfo_short[4]; 			// per-path's Cfo_short
+	u16		Cfo_tail[4];			// per-path's Cfo_tail
+
+	s8		RxPower;				// in dBm Translate from PWdB
+	s8		RecvSignalPower;		// Real power in dBm for this packet, no beautification and aggregation. Keep this raw info to be used for the other procedures.
+	u8		BTRxRSSIPercentage;
+	u8		SignalStrength; 		// in 0-100 index.
+
+	u8		RxPwr[4];				//per-path's pwdb
+	u8		RxSNR[4];				//per-path's SNR
+	u8		BandWidth;
+	u8		btCoexPwrAdjust;
+};
+
+
+struct _ODM_Per_Pkt_Info_ {
+	//u8		Rate;
+	u8		DataRate;
+	u8		StationID;
+	bool		bPacketMatchBSSID;
+	bool		bPacketToSelf;
+	bool		bPacketBeacon;
+};
+
+//
+// 2011/20/20 MH For MP driver RT_WLAN_STA =  STA_INFO_T
+// Please declare below ODM relative info in your STA info structure.
+//
+#if 1
+typedef		struct _ODM_STA_INFO{
+	// Driver Write
+	bool		bUsed;				// record the sta status link or not?
+	//u8		WirelessMode;		//
+	u8		IOTPeer;			// Enum value.	HT_IOT_PEER_E
+
+	// ODM Write
+	//1 PHY_STATUS_INFO
+	u8		RSSI_Path[4];		//
+	u8		RSSI_Ave;
+	u8		RXEVM[4];
+	u8		RXSNR[4];
+
+	// ODM Write
+	//1 TX_INFO (may changed by IC)
+	//TX_INFO_T		pTxInfo;				// Define in IC folder. Move lower layer.
+#if 0
+	u8		ANTSEL_A;			//in Jagar: 4bit; others: 2bit
+	u8		ANTSEL_B;			//in Jagar: 4bit; others: 2bit
+	u8		ANTSEL_C;			//only in Jagar: 4bit
+	u8		ANTSEL_D;			//only in Jagar: 4bit
+	u8		TX_ANTL;			//not in Jagar: 2bit
+	u8		TX_ANT_HT;			//not in Jagar: 2bit
+	u8		TX_ANT_CCK;			//not in Jagar: 2bit
+	u8		TXAGC_A;			//not in Jagar: 4bit
+	u8		TXAGC_B;			//not in Jagar: 4bit
+	u8		TXPWR_OFFSET;		//only in Jagar: 3bit
+	u8		TX_ANT;				//only in Jagar: 4bit for TX_ANTL/TX_ANTHT/TX_ANT_CCK
+#endif
+
+	//
+	// 	Please use compile flag to disabe the strcutrue for other IC except 88E.
+	//	Move To lower layer.
+	//
+	// ODM Write Wilson will handle this part(said by Luke.Lee)
+	//TX_RPT_T		pTxRpt;				// Define in IC folder. Move lower layer.
+#if 0
+	//1 For 88E RA (don't redefine the naming)
+	u8		rate_id;
+	u8		rate_SGI;
+	u8		rssi_sta_ra;
+	u8		SGI_enable;
+	u8		Decision_rate;
+	u8		Pre_rate;
+	u8		Active;
+
+	// Driver write Wilson handle.
+	//1 TX_RPT (don't redefine the naming)
+	u16		RTY[4];				// ???
+	u16		TOTAL;				// ???
+	u16		DROP;				// ???
+	//
+	// Please use compile flag to disabe the strcutrue for other IC except 88E.
+	//
+#endif
+
+}ODM_STA_INFO_T, *PODM_STA_INFO_T;
+#endif
+
+//
+// 2011/10/20 MH Define Common info enum for all team.
+//
+typedef enum _ODM_Common_Info_Definition {
+	ODM_CMNINFO_SCAN,
+	ODM_CMNINFO_PHY_STATUS,
+	ODM_CMNINFO_MAX,
+}ODM_CMNINFO_E;
+
+// ODM_CMNINFO_RF_TYPE
+//
+// For example 1T2R (A+AB = BIT0|BIT4|BIT5)
+//
+typedef enum tag_ODM_RF_Path_Bit_Definition
+{
+	ODM_RF_TX_A 	=	BIT(0),
+	ODM_RF_TX_B 	=	BIT(1),
+	ODM_RF_TX_C	=	BIT(2),
+	ODM_RF_TX_D	=	BIT(3),
+	ODM_RF_RX_A	=	BIT(4),
+	ODM_RF_RX_B	=	BIT(5),
+	ODM_RF_RX_C	=	BIT(6),
+	ODM_RF_RX_D	=	BIT(7),
+}ODM_RF_PATH_E;
+
+
+typedef enum tag_ODM_RF_Type_Definition
+{
+	ODM_1T1R 	=	0,
+	ODM_1T2R 	=	1,
+	ODM_2T2R	=	2,
+	ODM_2T3R	=	3,
+	ODM_2T4R	=	4,
+	ODM_3T3R	=	5,
+	ODM_3T4R	=	6,
+	ODM_4T4R	=	7,
+}ODM_RF_TYPE_E;
+
+
+//
+// ODM Dynamic common info value definition
+//
+
+//typedef enum _MACPHY_MODE_8192D{
+//	SINGLEMAC_SINGLEPHY,
+//	DUALMAC_DUALPHY,
+//	DUALMAC_SINGLEPHY,
+//}MACPHY_MODE_8192D,*PMACPHY_MODE_8192D;
+// Above is the original define in MP driver. Please use the same define. THX.
+typedef enum tag_ODM_MAC_PHY_Mode_Definition
+{
+	ODM_SMSP	= 0,
+	ODM_DMSP	= 1,
+	ODM_DMDP	= 2,
+}ODM_MAC_PHY_MODE_E;
+
+
+typedef enum tag_BT_Coexist_Definition
+{
+	ODM_BT_BUSY 		= 1,
+	ODM_BT_ON 			= 2,
+	ODM_BT_OFF 		= 3,
+	ODM_BT_NONE 		= 4,
+}ODM_BT_COEXIST_E;
+
+// ODM_CMNINFO_OP_MODE
+typedef enum tag_Operation_Mode_Definition
+{
+	ODM_NO_LINK 		= BIT(0),
+	ODM_LINK 		= BIT(1),
+	ODM_SCAN 		= BIT(2),
+	ODM_POWERSAVE 		= BIT(3),
+	ODM_CLIENT_MODE		= BIT(5),
+	ODM_AD_HOC 		= BIT(6),
+	ODM_WIFI_DIRECT		= BIT(7),
+	ODM_WIFI_DISPLAY	= BIT(8),
+}ODM_OPERATION_MODE_E;
+
+//
+// ODM Dynamic common info value definition
+//
+
+typedef enum _FAT_STATE
+{
+	FAT_NORMAL_STATE			= 0,
+	FAT_TRAINING_STATE 		= 1,
+}FAT_STATE_E, *PFAT_STATE_E;
+
+//
+// Antenna detection information from single tone mechanism, added by Roger, 2012.11.27.
+//
+
+
+#if 1 //92c-series
+#define ODM_RF_PATH_MAX 2
+#else //jaguar - series
+#define ODM_RF_PATH_MAX 4
+#endif
+ typedef enum _ODM_RF_CONTENT{
+	odm_radioa_txt = 0x1000,
+	odm_radiob_txt = 0x1001,
+	odm_radioc_txt = 0x1002,
+	odm_radiod_txt = 0x1003
+} ODM_RF_CONTENT;
+
+typedef enum _ODM_BB_Config_Type{
+    CONFIG_BB_PHY_REG,
+    CONFIG_BB_AGC_TAB,
+    CONFIG_BB_AGC_TAB_2G,
+    CONFIG_BB_AGC_TAB_5G,
+    CONFIG_BB_PHY_REG_PG,
+} ODM_BB_Config_Type, *PODM_BB_Config_Type;
+
+typedef enum _ODM_RF_Config_Type{
+	CONFIG_RF_RADIO,
+} ODM_RF_Config_Type, *PODM_RF_Config_Type;
+
+// Status code
+typedef enum _RT_STATUS{
+	RT_STATUS_SUCCESS,
+	RT_STATUS_FAILURE,
+	RT_STATUS_PENDING,
+	RT_STATUS_RESOURCE,
+	RT_STATUS_INVALID_CONTEXT,
+	RT_STATUS_INVALID_PARAMETER,
+	RT_STATUS_NOT_SUPPORT,
+	RT_STATUS_OS_API_FAILED,
+}RT_STATUS,*PRT_STATUS;
+
+#ifdef REMOVE_PACK
+#pragma pack()
+#endif
+
+//#include "odm_function.h"
+
+//3===========================================================
+//3 DIG
+//3===========================================================
+
+typedef enum tag_Dynamic_Init_Gain_Operation_Type_Definition
+{
+	DIG_TYPE_THRESH_HIGH	= 0,
+	DIG_TYPE_THRESH_LOW	= 1,
+	DIG_TYPE_BACKOFF		= 2,
+	DIG_TYPE_RX_GAIN_MIN	= 3,
+	DIG_TYPE_RX_GAIN_MAX	= 4,
+	DIG_TYPE_ENABLE 		= 5,
+	DIG_TYPE_DISABLE 		= 6,
+	DIG_OP_TYPE_MAX
+}DM_DIG_OP_E;
+/*
+typedef enum tag_CCK_Packet_Detection_Threshold_Type_Definition
+{
+	CCK_PD_STAGE_LowRssi = 0,
+	CCK_PD_STAGE_HighRssi = 1,
+	CCK_PD_STAGE_MAX = 3,
+}DM_CCK_PDTH_E;
+
+typedef enum tag_DIG_EXT_PORT_ALGO_Definition
+{
+	DIG_EXT_PORT_STAGE_0 = 0,
+	DIG_EXT_PORT_STAGE_1 = 1,
+	DIG_EXT_PORT_STAGE_2 = 2,
+	DIG_EXT_PORT_STAGE_3 = 3,
+	DIG_EXT_PORT_STAGE_MAX = 4,
+}DM_DIG_EXT_PORT_ALG_E;
+
+typedef enum tag_DIG_Connect_Definition
+{
+	DIG_STA_DISCONNECT = 0,
+	DIG_STA_CONNECT = 1,
+	DIG_STA_BEFORE_CONNECT = 2,
+	DIG_MultiSTA_DISCONNECT = 3,
+	DIG_MultiSTA_CONNECT = 4,
+	DIG_CONNECT_MAX
+}DM_DIG_CONNECT_E;
+
+
+#define DM_MultiSTA_InitGainChangeNotify(Event) {DM_DigTable.CurMultiSTAConnectState = Event;}
+
+#define DM_MultiSTA_InitGainChangeNotify_CONNECT(_ADAPTER)	\
+	DM_MultiSTA_InitGainChangeNotify(DIG_MultiSTA_CONNECT)
+
+#define DM_MultiSTA_InitGainChangeNotify_DISCONNECT(_ADAPTER)	\
+	DM_MultiSTA_InitGainChangeNotify(DIG_MultiSTA_DISCONNECT)
+*/
+#define		DM_DIG_THRESH_HIGH			40
+#define		DM_DIG_THRESH_LOW			35
+
+#define		DM_FALSEALARM_THRESH_LOW	400
+#define		DM_FALSEALARM_THRESH_HIGH	1000
+
+#define		DM_DIG_MAX_NIC				0x3e
+#define		DM_DIG_MIN_NIC				0x1e //0x22//0x1c
+
+#define		DM_DIG_MAX_AP					0x32
+#define		DM_DIG_MIN_AP					0x20
+
+#define		DM_DIG_MAX_NIC_HP			0x46
+#define		DM_DIG_MIN_NIC_HP			0x2e
+
+#define		DM_DIG_MAX_AP_HP				0x42
+#define		DM_DIG_MIN_AP_HP				0x30
+
+//vivi 92c&92d has different definition, 20110504
+//this is for 92c
+#define		DM_DIG_FA_TH0				0x200//0x20
+#define		DM_DIG_FA_TH1				0x300//0x100
+#define		DM_DIG_FA_TH2				0x400//0x200
+//this is for 92d
+#define		DM_DIG_FA_TH0_92D			0x100
+#define		DM_DIG_FA_TH1_92D			0x400
+#define		DM_DIG_FA_TH2_92D			0x600
+
+#define		DM_DIG_BACKOFF_MAX			12
+#define		DM_DIG_BACKOFF_MIN			-4
+#define		DM_DIG_BACKOFF_DEFAULT		10
+
+//3===========================================================
+//3 AGC RX High Power Mode
+//3===========================================================
+#define          LNA_Low_Gain_1                      0x64
+#define          LNA_Low_Gain_2                      0x5A
+#define          LNA_Low_Gain_3                      0x58
+
+#define          FA_RXHP_TH1                           5000
+#define          FA_RXHP_TH2                           1500
+#define          FA_RXHP_TH3                             800
+#define          FA_RXHP_TH4                             600
+#define          FA_RXHP_TH5                             500
+
+//3===========================================================
+//3 EDCA
+//3===========================================================
+
+//3===========================================================
+//3 Tx Power Tracking
+//3===========================================================
+#if 0 //mask this, since these have been defined in typdef.h, vivi
+#define	OFDM_TABLE_SIZE 	37
+#define	OFDM_TABLE_SIZE_92D 	43
+#endif
+
+
+//3===========================================================
+//3 Rate Adaptive
+//3===========================================================
+#define		DM_RATR_STA_INIT			0
+#define		DM_RATR_STA_HIGH			1
+#define 		DM_RATR_STA_MIDDLE		2
+#define 		DM_RATR_STA_LOW			3
+
+//3===========================================================
+//3 BB Power Save
+//3===========================================================
+
+
+//3===========================================================
+//3 Dynamic ATC switch
+//3===========================================================
+#define		ATC_Status_Off				0x0			// enable
+#define		ATC_Status_On				0x1			// disable
+#define		CFO_Threshold_Xtal			10			// kHz
+#define		CFO_Threshold_ATC			80			// kHz
+
+typedef enum tag_1R_CCA_Type_Definition
+{
+	CCA_1R =0,
+	CCA_2R = 1,
+	CCA_MAX = 2,
+}DM_1R_CCA_E;
+
+typedef enum tag_RF_Type_Definition
+{
+	RF_Save =0,
+	RF_Normal = 1,
+	RF_MAX = 2,
+}DM_RF_E;
+
+
+// Maximal number of antenna detection mechanism needs to perform, added by Roger, 2011.12.28.
+#define	MAX_ANTENNA_DETECTION_CNT	10
+
+//
+// Extern Global Variables.
+//
+
+// <20121018, Kordan> In case fail to read TxPowerTrack.txt, we use the table of 88E as the default table.
+
+//
+// check Sta pointer valid or not
+//
+#define IS_STA_VALID(pSta)		(pSta)
+// 20100514 Joseph: Add definition for antenna switching test after link.
+// This indicates two different the steps.
+// In SWAW_STEP_PEAK, driver needs to switch antenna and listen to the signal on the air.
+// In SWAW_STEP_DETERMINE, driver just compares the signal captured in SWAW_STEP_PEAK
+// with original RSSI to determine if it is necessary to switch antenna.
+#define SWAW_STEP_PEAK		0
+#define SWAW_STEP_DETERMINE	1
+
+void ODM_Write_CCK_CCA_Thres(struct rtl_priv *rtlpriv, u8 CurCCK_CCAThres);
+
+uint32_t ODM_Get_Rate_Bitmap(struct rtl_priv *rtlpriv, uint32_t macid,
+	uint32_t ra_mask, u8 rssi_level);
+
+void ODM_DMInit(struct rtl_priv *rtlpriv);
+
+void ODM_CmnInfoHook(struct _rtw_dm *pDM_Odm, ODM_CMNINFO_E CmnInfo, void *pValue);
+
+#endif
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/include/odm_interface.h linux-4.9.8821au/drivers/staging/rtl8821au/include/odm_interface.h
--- linux-4.9/drivers/staging/rtl8821au/include/odm_interface.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/include/odm_interface.h	2016-12-11 19:48:25.173645047 -0600
@@ -0,0 +1,32 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+
+#ifndef	__ODM_INTERFACE_H__
+#define __ODM_INTERFACE_H__
+
+
+
+
+#define _reg_11AC(_name)		ODM_REG_##_name##_11AC
+#define _bit_11AC(_name)		ODM_BIT_##_name##_11AC
+
+#endif	// __ODM_INTERFACE_H__
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/include/odm_precomp.h linux-4.9.8821au/drivers/staging/rtl8821au/include/odm_precomp.h
--- linux-4.9/drivers/staging/rtl8821au/include/odm_precomp.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/include/odm_precomp.h	2016-12-11 19:48:25.173645047 -0600
@@ -0,0 +1,33 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+#ifndef	__ODM_PRECOMP_H__
+#define __ODM_PRECOMP_H__
+
+#include <odm_types.h>
+
+#include <odm.h>
+#include <odm_RegDefine11AC.h>
+
+#include <odm_interface.h>
+#include <odm_reg.h>
+
+#endif	// __ODM_PRECOMP_H__
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/include/odm_RegDefine11AC.h linux-4.9.8821au/drivers/staging/rtl8821au/include/odm_RegDefine11AC.h
--- linux-4.9/drivers/staging/rtl8821au/include/odm_RegDefine11AC.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/include/odm_RegDefine11AC.h	2016-12-11 19:48:25.173645047 -0600
@@ -0,0 +1,57 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+ 
+#ifndef	__ODM_REGDEFINE11AC_H__
+#define __ODM_REGDEFINE11AC_H__
+
+//2 RF REG LIST
+
+
+
+//2 BB REG LIST
+//PAGE 8
+#define	ODM_REG_CCK_RPT_FORMAT_11AC	0x804
+#define	ODM_REG_BB_RX_PATH_11AC			0x808
+//PAGE 9
+#define	ODM_REG_OFDM_FA_RST_11AC		0x9A4
+//PAGE A
+#define	ODM_REG_CCK_CCA_11AC			0xA0A
+#define	ODM_REG_CCK_FA_RST_11AC			0xA2C
+#define	ODM_REG_CCK_FA_11AC				0xA5C
+//PAGE C
+#define	ODM_REG_IGI_A_11AC				0xC50
+//PAGE E
+#define	ODM_REG_IGI_B_11AC				0xE50
+//PAGE F
+#define	ODM_REG_OFDM_FA_11AC			0xF48
+
+
+//2 MAC REG LIST
+
+
+
+
+//DIG Related
+#define	ODM_BIT_IGI_11AC					0xFFFFFFFF
+#define	ODM_BIT_CCK_RPT_FORMAT_11AC		BIT(16)
+#define	ODM_BIT_BB_RX_PATH_11AC			0xF
+
+#endif
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/include/odm_reg.h linux-4.9.8821au/drivers/staging/rtl8821au/include/odm_reg.h
--- linux-4.9/drivers/staging/rtl8821au/include/odm_reg.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/include/odm_reg.h	2016-12-11 19:48:25.173645047 -0600
@@ -0,0 +1,123 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *                                        
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+//============================================================
+// File Name: odm_reg.h
+//
+// Description:
+//
+// This file is for general register definition.
+//
+//
+//============================================================
+#ifndef	__HAL_ODM_REG_H__
+#define __HAL_ODM_REG_H__
+
+//
+// Register Definition
+//
+
+//MAC REG
+#define	ODM_BB_RESET					0x002
+#define	ODM_DUMMY					0x4fe
+#define	RF_T_METER_OLD				0x24
+#define	RF_T_METER_NEW				0x42
+
+#define	ODM_EDCA_VO_PARAM			0x500
+#define	ODM_EDCA_VI_PARAM			0x504
+#define	ODM_EDCA_BE_PARAM			0x508
+#define	ODM_EDCA_BK_PARAM			0x50C
+#define	ODM_TXPAUSE					0x522
+
+//BB REG
+#define	ODM_FPGA_PHY0_PAGE8			0x800
+#define	ODM_PSD_SETTING				0x808
+#define	ODM_AFE_SETTING				0x818
+#define	ODM_TXAGC_B_6_18				0x830
+#define	ODM_TXAGC_B_24_54			0x834
+#define	ODM_TXAGC_B_MCS32_5			0x838
+#define	ODM_TXAGC_B_MCS0_MCS3		0x83c
+#define	ODM_TXAGC_B_MCS4_MCS7		0x848
+#define	ODM_TXAGC_B_MCS8_MCS11		0x84c
+#define	ODM_ANALOG_REGISTER			0x85c
+#define	ODM_RF_INTERFACE_OUTPUT		0x860
+#define	ODM_TXAGC_B_MCS12_MCS15	0x868
+#define	ODM_TXAGC_B_11_A_2_11		0x86c
+#define	ODM_AD_DA_LSB_MASK			0x874
+#define	ODM_ENABLE_3_WIRE			0x88c
+#define	ODM_PSD_REPORT				0x8b4
+#define	ODM_R_ANT_SELECT				0x90c
+#define	ODM_CCK_ANT_SELECT			0xa07
+#define	ODM_CCK_PD_THRESH			0xa0a
+#define	ODM_CCK_RF_REG1				0xa11
+#define	ODM_CCK_MATCH_FILTER			0xa20
+#define	ODM_CCK_RAKE_MAC				0xa2e
+#define	ODM_CCK_CNT_RESET			0xa2d
+#define	ODM_CCK_TX_DIVERSITY			0xa2f
+#define	ODM_CCK_FA_CNT_MSB			0xa5b
+#define	ODM_CCK_FA_CNT_LSB			0xa5c
+#define	ODM_CCK_NEW_FUNCTION		0xa75
+#define	ODM_OFDM_PHY0_PAGE_C		0xc00
+#define	ODM_OFDM_RX_ANT				0xc04
+#define	ODM_R_A_RXIQI					0xc14
+#define	ODM_R_A_AGC_CORE1			0xc50
+#define	ODM_R_A_AGC_CORE2			0xc54
+#define	ODM_R_B_AGC_CORE1			0xc58
+#define	ODM_R_AGC_PAR					0xc70
+#define	ODM_R_HTSTF_AGC_PAR			0xc7c
+#define	ODM_TX_PWR_TRAINING_A		0xc90
+#define	ODM_TX_PWR_TRAINING_B		0xc98
+#define	ODM_OFDM_FA_CNT1				0xcf0
+#define	ODM_OFDM_PHY0_PAGE_D		0xd00
+#define	ODM_OFDM_FA_CNT2				0xda0
+#define	ODM_OFDM_FA_CNT3				0xda4
+#define	ODM_OFDM_FA_CNT4				0xda8
+#define	ODM_TXAGC_A_6_18				0xe00
+#define	ODM_TXAGC_A_24_54			0xe04
+#define	ODM_TXAGC_A_1_MCS32			0xe08
+#define	ODM_TXAGC_A_MCS0_MCS3		0xe10
+#define	ODM_TXAGC_A_MCS4_MCS7		0xe14
+#define	ODM_TXAGC_A_MCS8_MCS11		0xe18
+#define	ODM_TXAGC_A_MCS12_MCS15		0xe1c
+
+//RF REG
+#define	ODM_GAIN_SETTING				0x00
+#define	ODM_CHANNEL					0x18
+
+//Ant Detect Reg
+#define	ODM_DPDT						0x300
+
+//PSD Init
+#define	ODM_PSDREG					0x808
+
+//92D Path Div
+#define	PATHDIV_REG					0xB30
+#define	PATHDIV_TRI					0xBA0
+
+
+//
+// Bitmap Definition
+//
+
+#define	BIT_FA_RESET					BIT0
+
+
+
+#endif
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/include/odm_types.h linux-4.9.8821au/drivers/staging/rtl8821au/include/odm_types.h
--- linux-4.9/drivers/staging/rtl8821au/include/odm_types.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/include/odm_types.h	2016-12-11 19:48:25.173645047 -0600
@@ -0,0 +1,30 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __ODM_TYPES_H__
+#define __ODM_TYPES_H__
+
+//
+// Define Different SW team support
+//
+#define	ODM_AP		 	0x01	//BIT0
+#define	ODM_CE		 	0x04	//BIT2
+
+#endif // __ODM_TYPES_H__
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/include/osdep_intf.h linux-4.9.8821au/drivers/staging/rtl8821au/include/osdep_intf.h
--- linux-4.9/drivers/staging/rtl8821au/include/osdep_intf.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/include/osdep_intf.h	2016-12-11 19:48:25.173645047 -0600
@@ -0,0 +1,38 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+#ifndef __OSDEP_INTF_H_
+#define __OSDEP_INTF_H_
+
+u32 rtw_start_drv_threads(struct rtl_priv *rtlpriv);
+void rtw_stop_drv_threads (struct rtl_priv *rtlpriv);
+
+int rtw_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);
+
+u16 rtw_recv_select_queue(struct sk_buff *skb);
+
+void rtw_ips_dev_unload(struct rtl_priv *rtlpriv);
+int rtw_ips_pwr_up(struct rtl_priv *rtlpriv);
+void rtw_ips_pwr_down(struct rtl_priv *rtlpriv);
+
+void rtw_ndev_destructor(struct  net_device *ndev);
+
+#endif	//_OSDEP_INTF_H_
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/include/osdep_service.h linux-4.9.8821au/drivers/staging/rtl8821au/include/osdep_service.h
--- linux-4.9/drivers/staging/rtl8821au/include/osdep_service.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/include/osdep_service.h	2016-12-11 19:48:25.173645047 -0600
@@ -0,0 +1,278 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2013 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __OSDEP_SERVICE_H_
+#define __OSDEP_SERVICE_H_
+
+
+#define _FAIL		0
+#define _SUCCESS	1
+#define RTW_RX_HANDLED 2
+//#define RTW_STATUS_TIMEDOUT -110
+
+#include <osdep_service_linux.h>
+
+#define RTW_TIMER_HDL_NAME(name) rtw_##name##_timer_hdl
+#define RTW_DECLARE_TIMER_HDL(name) void RTW_TIMER_HDL_NAME(name)(RTW_TIMER_HDL_ARGS)
+
+#define CONFIG_USE_VMALLOC
+
+//flags used for rtw_update_mem_stat()
+enum {
+	MEM_STAT_VIR_ALLOC_SUCCESS,
+	MEM_STAT_VIR_ALLOC_FAIL,
+	MEM_STAT_VIR_FREE,
+	MEM_STAT_PHY_ALLOC_SUCCESS,
+	MEM_STAT_PHY_ALLOC_FAIL,
+	MEM_STAT_PHY_FREE,
+	MEM_STAT_TX, //used to distinguish TX/RX, asigned from caller
+	MEM_STAT_TX_ALLOC_SUCCESS,
+	MEM_STAT_TX_ALLOC_FAIL,
+	MEM_STAT_TX_FREE,
+	MEM_STAT_RX, //used to distinguish TX/RX, asigned from caller
+	MEM_STAT_RX_ALLOC_SUCCESS,
+	MEM_STAT_RX_ALLOC_FAIL,
+	MEM_STAT_RX_FREE
+};
+
+#define rtw_update_mem_stat(flag, sz) do {} while(0)
+extern void *_rtw_vmalloc(u32 sz);
+extern void *_rtw_zvmalloc(u32 sz);
+extern void	_rtw_vmfree(void *pbuf);
+extern void *_rtw_zmalloc(u32 sz);
+extern void *_rtw_malloc(u32 sz);
+extern void _rtw_mfree(void *pbuf);
+#ifdef CONFIG_USE_VMALLOC
+#define rtw_vmalloc(sz)		_rtw_vmalloc((sz))
+#define rtw_zvmalloc(sz)	_rtw_zvmalloc((sz))
+#define rtw_vmfree(pbuf)	_rtw_vmfree((pbuf))
+#else //CONFIG_USE_VMALLOC
+#define rtw_vmalloc(sz)		_rtw_malloc((sz))
+#define rtw_zvmalloc(sz)	_rtw_zmalloc((sz))
+#define rtw_vmfree(pbuf)	_rtw_mfree((pbuf))
+#endif //CONFIG_USE_VMALLOC
+#define rtw_malloc(sz)		_rtw_malloc((sz))
+#define rtw_zmalloc(sz)		_rtw_zmalloc((sz))
+#define rtw_mfree(pbuf)		_rtw_mfree((pbuf))
+
+extern void*	rtw_malloc2d(int h, int w, int size);
+extern void	rtw_mfree2d(void *pbuf, int h, int w, int size);
+
+extern int	_rtw_memcmp(void *dst, void *src, u32 sz);
+
+extern void	_rtw_init_queue(struct __queue	*pqueue);
+extern u32	rtw_end_of_queue_search(struct list_head *queue, struct list_head *pelement);
+
+extern u32	rtw_systime_to_ms(u32 systime);
+extern u32	rtw_ms_to_systime(u32 ms);
+extern int32_t	rtw_get_passing_time_ms(u32 start);
+extern int32_t	rtw_get_time_interval_ms(u32 start, u32 end);
+
+extern void	rtw_usleep_os(int us);
+
+extern u32 	rtw_atoi(u8* s);
+extern void rtw_yield_os(void);
+
+
+__inline static unsigned char del_timer_sync_ex(struct timer_list *ptimer)
+{
+	return del_timer_sync(ptimer);
+}
+
+static __inline void thread_enter(char *name)
+{
+	allow_signal(SIGTERM);
+}
+
+__inline static void flush_signals_thread(void)
+{
+	if (signal_pending (current)) {
+		flush_signals(current);
+	}
+}
+
+__inline static _OS_STATUS res_to_status(int res)
+{
+	return res;
+}
+
+__inline static void rtw_dump_stack(void)
+{
+	dump_stack();
+}
+
+__inline static int rtw_bug_check(void *parg1, void *parg2, void *parg3, void *parg4)
+{
+	int ret = true;
+
+
+	return ret;
+
+}
+
+#define _RND(sz, r) ((((sz)+((r)-1))/(r))*(r))
+#define RND4(x)	(((x >> 2) + (((x & 3) == 0) ?  0: 1)) << 2)
+
+__inline static u32 _RND4(u32 sz)
+{
+
+	u32	val;
+
+	val = ((sz >> 2) + ((sz & 3) ? 1: 0)) << 2;
+
+	return val;
+
+}
+
+__inline static u32 _RND8(u32 sz)
+{
+
+	u32	val;
+
+	val = ((sz >> 3) + ((sz & 7) ? 1: 0)) << 3;
+
+	return val;
+
+}
+
+__inline static u32 _RND128(u32 sz)
+{
+
+	u32	val;
+
+	val = ((sz >> 7) + ((sz & 127) ? 1: 0)) << 7;
+
+	return val;
+
+}
+
+__inline static u32 _RND256(u32 sz)
+{
+
+	u32	val;
+
+	val = ((sz >> 8) + ((sz & 255) ? 1: 0)) << 8;
+
+	return val;
+
+}
+
+__inline static u32 _RND512(u32 sz)
+{
+
+	u32	val;
+
+	val = ((sz >> 9) + ((sz & 511) ? 1: 0)) << 9;
+
+	return val;
+
+}
+
+__inline static u32 bitshift(u32 bitmask)
+{
+	u32 i;
+
+	for (i = 0; i <= 31; i++)
+		if (((bitmask>>i) &  0x1) == 1) break;
+
+	return i;
+}
+
+#ifndef MAC_FMT
+#define MAC_FMT "%02x:%02x:%02x:%02x:%02x:%02x"
+#endif
+#ifndef MAC_ARG
+#define MAC_ARG(x) ((u8*)(x))[0],((u8*)(x))[1],((u8*)(x))[2],((u8*)(x))[3],((u8*)(x))[4],((u8*)(x))[5]
+#endif
+
+extern u64 rtw_modular64(u64 x, u64 y);
+
+
+/* Macros for handling unaligned memory accesses */
+
+#define RTW_GET_BE16(a) ((u16) (((a)[0] << 8) | (a)[1]))
+#define RTW_PUT_BE16(a, val)			\
+	do {					\
+		(a)[0] = ((u16) (val)) >> 8;	\
+		(a)[1] = ((u16) (val)) & 0xff;	\
+	} while (0)
+
+#define RTW_GET_LE16(a) ((u16) (((a)[1] << 8) | (a)[0]))
+#define RTW_PUT_LE16(a, val)			\
+	do {					\
+		(a)[1] = ((u16) (val)) >> 8;	\
+		(a)[0] = ((u16) (val)) & 0xff;	\
+	} while (0)
+
+#define RTW_GET_BE24(a) ((((u32) (a)[0]) << 16) | (((u32) (a)[1]) << 8) | \
+			 ((u32) (a)[2]))
+#define RTW_PUT_BE24(a, val)					\
+	do {							\
+		(a)[0] = (uint8_t) ((((u32) (val)) >> 16) & 0xff);	\
+		(a)[1] = (uint8_t) ((((u32) (val)) >> 8) & 0xff);	\
+		(a)[2] = (uint8_t) (((u32) (val)) & 0xff);		\
+	} while (0)
+
+#define RTW_GET_BE32(a) ((((u32) (a)[0]) << 24) | (((u32) (a)[1]) << 16) | \
+			 (((u32) (a)[2]) << 8) | ((u32) (a)[3]))
+#define RTW_PUT_BE32(a, val)					\
+	do {							\
+		(a)[0] = (uint8_t) ((((u32) (val)) >> 24) & 0xff);	\
+		(a)[1] = (uint8_t) ((((u32) (val)) >> 16) & 0xff);	\
+		(a)[2] = (uint8_t) ((((u32) (val)) >> 8) & 0xff);	\
+		(a)[3] = (uint8_t) (((u32) (val)) & 0xff);		\
+	} while (0)
+
+#define RTW_GET_LE32(a) ((((u32) (a)[3]) << 24) | (((u32) (a)[2]) << 16) | \
+			 (((u32) (a)[1]) << 8) | ((u32) (a)[0]))
+#define RTW_PUT_LE32(a, val)					\
+	do {							\
+		(a)[3] = (uint8_t) ((((u32) (val)) >> 24) & 0xff);	\
+		(a)[2] = (uint8_t) ((((u32) (val)) >> 16) & 0xff);	\
+		(a)[1] = (uint8_t) ((((u32) (val)) >> 8) & 0xff);	\
+		(a)[0] = (uint8_t) (((u32) (val)) & 0xff);		\
+	} while (0)
+
+#define RTW_GET_BE64(a) ((((u64) (a)[0]) << 56) | (((u64) (a)[1]) << 48) | \
+			 (((u64) (a)[2]) << 40) | (((u64) (a)[3]) << 32) | \
+			 (((u64) (a)[4]) << 24) | (((u64) (a)[5]) << 16) | \
+			 (((u64) (a)[6]) << 8) | ((u64) (a)[7]))
+#define RTW_PUT_BE64(a, val)				\
+	do {						\
+		(a)[0] = (uint8_t) (((u64) (val)) >> 56);	\
+		(a)[1] = (uint8_t) (((u64) (val)) >> 48);	\
+		(a)[2] = (uint8_t) (((u64) (val)) >> 40);	\
+		(a)[3] = (uint8_t) (((u64) (val)) >> 32);	\
+		(a)[4] = (uint8_t) (((u64) (val)) >> 24);	\
+		(a)[5] = (uint8_t) (((u64) (val)) >> 16);	\
+		(a)[6] = (uint8_t) (((u64) (val)) >> 8);	\
+		(a)[7] = (uint8_t) (((u64) (val)) & 0xff);	\
+	} while (0)
+
+#define RTW_GET_LE64(a) ((((u64) (a)[7]) << 56) | (((u64) (a)[6]) << 48) | \
+			 (((u64) (a)[5]) << 40) | (((u64) (a)[4]) << 32) | \
+			 (((u64) (a)[3]) << 24) | (((u64) (a)[2]) << 16) | \
+			 (((u64) (a)[1]) << 8) | ((u64) (a)[0]))
+
+void rtw_buf_free(uint8_t **buf, u32 *buf_len);
+void rtw_buf_update(uint8_t **buf, u32 *buf_len, uint8_t *src, u32 src_len);
+
+#endif
+
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/include/osdep_service_linux.h linux-4.9.8821au/drivers/staging/rtl8821au/include/osdep_service_linux.h
--- linux-4.9/drivers/staging/rtl8821au/include/osdep_service_linux.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/include/osdep_service_linux.h	2016-12-11 19:48:25.173645047 -0600
@@ -0,0 +1,78 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2013 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __OSDEP_LINUX_SERVICE_H_
+#define __OSDEP_LINUX_SERVICE_H_
+
+#include <linux/netdevice.h>
+
+#ifdef CONFIG_USB_SUSPEND
+#define CONFIG_AUTOSUSPEND	1
+#endif
+
+struct __queue {
+		struct	list_head list;
+		spinlock_t	lock;
+};
+
+	typedef	int	_OS_STATUS;
+
+
+__inline static struct list_head	*get_list_head(struct __queue	*queue)
+{
+	return (&(queue->list));
+}
+
+#define RTW_TIMER_HDL_ARGS void *FunctionContext
+
+__inline static void _init_timer(struct timer_list *ptimer,struct net_device *nic_hdl,void *pfunc,void* cntx)
+{
+	//setup_timer(ptimer, pfunc,(u32)cntx);
+	ptimer->function = pfunc;
+	ptimer->data = (unsigned long)cntx;
+	init_timer(ptimer);
+}
+
+__inline static void _set_timer(struct timer_list *ptimer,u32 delay_time)
+{
+	mod_timer(ptimer , (jiffies+(delay_time*HZ/1000)));
+}
+
+static inline int rtw_netif_queue_stopped(struct net_device *ndev)
+{
+	return (netif_tx_queue_stopped(netdev_get_tx_queue(ndev, 0)) &&
+		netif_tx_queue_stopped(netdev_get_tx_queue(ndev, 1)) &&
+		netif_tx_queue_stopped(netdev_get_tx_queue(ndev, 2)) &&
+		netif_tx_queue_stopped(netdev_get_tx_queue(ndev, 3)) );
+}
+
+// limitation of path length
+#define PATH_LENGTH_MAX PATH_MAX
+
+#define NDEV_FMT "%s"
+#define NDEV_ARG(ndev) ndev->name
+#define ADPT_FMT "%s"
+#define ADPT_ARG(rtlpriv) rtlpriv->ndev->name
+#define FUNC_NDEV_FMT "%s(%s)"
+#define FUNC_NDEV_ARG(ndev) __func__, ndev->name
+#define FUNC_ADPT_FMT "%s(%s)"
+#define FUNC_ADPT_ARG(rtlpriv) __func__, rtlpriv->ndev->name
+
+#endif
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/include/recv_osdep.h linux-4.9.8821au/drivers/staging/rtl8821au/include/recv_osdep.h
--- linux-4.9/drivers/staging/rtl8821au/include/recv_osdep.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/include/recv_osdep.h	2016-12-11 19:48:25.173645047 -0600
@@ -0,0 +1,52 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RECV_OSDEP_H_
+#define __RECV_OSDEP_H_
+
+
+extern int _rtw_init_recv_priv(struct recv_priv *precvpriv, struct rtl_priv *rtlpriv);
+extern void _rtw_free_recv_priv (struct recv_priv *precvpriv);
+
+
+extern int32_t  rtw_recv_entry(struct recv_frame *precv_frame);
+extern int rtw_recv_indicatepkt(struct rtl_priv *rtlpriv, struct recv_frame *precv_frame);
+extern void rtw_recv_returnpacket(struct  net_device *cnxt, struct sk_buff *preturnedpkt);
+
+extern void rtw_handle_tkip_mic_err(struct rtl_priv *rtlpriv,u8 bgroup);
+
+
+int	rtw_init_recv_priv(struct recv_priv *precvpriv, struct rtl_priv *rtlpriv);
+void rtw_free_recv_priv (struct recv_priv *precvpriv);
+
+int rtw_os_alloc_recvframe(struct rtl_priv *rtlpriv, struct recv_frame *precvframe, u8 *pdata, struct sk_buff *pskb);
+void rtw_os_free_recvframe(struct recv_frame *precvframe);
+
+
+int rtw_os_recvbuf_resource_alloc(struct rtl_priv *rtlpriv, struct recv_buf *precvbuf);
+int rtw_os_recvbuf_resource_free(struct rtl_priv *rtlpriv, struct recv_buf *precvbuf);
+
+struct sk_buff *rtw_os_alloc_msdu_pkt(struct recv_frame *prframe, u16 nSubframe_Length, u8 *pdata);
+void rtw_os_recv_indicate_pkt(struct rtl_priv *rtlpriv, struct sk_buff *pkt, struct rx_pkt_attrib *pattrib);
+
+void rtw_init_recv_timer(struct recv_reorder_ctrl *preorder_ctrl);
+
+
+#endif //
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/include/rtl8812a_cmd.h linux-4.9.8821au/drivers/staging/rtl8821au/include/rtl8812a_cmd.h
--- linux-4.9/drivers/staging/rtl8821au/include/rtl8812a_cmd.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/include/rtl8812a_cmd.h	2016-12-11 19:48:25.173645047 -0600
@@ -0,0 +1,100 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8812A_CMD_H__
+#define __RTL8812A_CMD_H__
+
+typedef enum _RTL8812_H2C_CMD
+{
+	H2C_8812_RSVDPAGE = 0,
+	H2C_8812_MSRRPT = 1,
+	H2C_8812_SCAN = 2,
+	H2C_8812_KEEP_ALIVE_CTRL = 3,
+	H2C_8812_DISCONNECT_DECISION = 4,
+
+	H2C_8812_INIT_OFFLOAD = 6,
+	H2C_8812_AP_OFFLOAD = 8,
+	H2C_8812_BCN_RSVDPAGE = 9,
+	H2C_8812_PROBERSP_RSVDPAGE = 10,
+
+	H2C_8812_SETPWRMODE = 0x20,
+	H2C_8812_PS_TUNING_PARA = 0x21,
+	H2C_8812_PS_TUNING_PARA2 = 0x22,
+	H2C_8812_PS_LPS_PARA = 0x23,
+	H2C_8812_P2P_PS_OFFLOAD = 0x24,
+	H2C_8812_RA_MASK = 0x40,
+	H2C_8812_RSSI_REPORT = 0x42,
+
+	H2C_8812_WO_WLAN = 0x80,
+	H2C_8812_REMOTE_WAKE_CTRL = 0x81,
+	H2C_8812_AOAC_GLOBAL_INFO = 0x82,
+	H2C_8812_AOAC_RSVDPAGE = 0x83,
+
+	H2C_8812_TSF_RESET = 0xC0,
+
+	MAX_8812_H2CCMD
+}RTL8812_H2C_CMD;
+
+
+typedef enum _RTL8812_C2H_EVT
+{
+	C2H_8812_DBG = 0,
+	C2H_8812_LB = 1,
+	C2H_8812_TXBF = 2,
+	C2H_8812_TX_REPORT = 3,
+	C2H_8812_BT_INFO = 9,
+	C2H_8812_BT_MP = 11,
+	C2H_8812_RA_RPT=12,
+
+	C2H_8812_FW_SWCHNL = 0x10,
+	C2H_8812_IQK_FINISH = 0x11,
+	MAX_8812_C2HEVENT
+}RTL8812_C2H_EVT;
+
+
+struct cmd_msg_parm {
+	uint8_t eid; //element id
+	uint8_t sz; // sz
+	uint8_t buf[6];
+};
+
+enum{
+	PWRS
+};
+
+struct H2C_SS_RFOFF_PARAM{
+	uint8_t ROFOn; // 1: on, 0:off
+	u16 gpio_period; // unit: 1024 us
+}__attribute__ ((packed));
+
+
+
+
+void	Set_RA_LDPC_8812(struct sta_info	*psta, bool bLDPC);
+
+// host message to firmware cmd
+void rtl8812au_set_fw_pwrmode_cmd(struct rtl_priv *rtlpriv, uint8_t PSMode);
+void rtl8812_set_raid_cmd(struct rtl_priv *rtlpriv, u32 bitmap, u8* arg);
+void rtl8812_Add_RateATid(struct rtl_priv *rtlpriv, u32 bitmap, u8* arg, uint8_t rssi_level);
+
+void rtl8812_set_FwMediaStatus_cmd(struct rtl_priv *rtlpriv, u16 mstatus_rpt );
+
+#endif//__RTL8188E_CMD_H__
+
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/include/rtl8812a_dm.h linux-4.9.8821au/drivers/staging/rtl8821au/include/rtl8812a_dm.h
--- linux-4.9/drivers/staging/rtl8821au/include/rtl8812a_dm.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/include/rtl8812a_dm.h	2016-12-11 19:48:25.173645047 -0600
@@ -0,0 +1,30 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8812A_DM_H__
+#define __RTL8812A_DM_H__
+
+void rtl8812_init_dm_priv(struct rtl_priv *rtlpriv);
+
+//void rtl8192c_dm_CheckTXPowerTracking(IN struct rtl_priv *rtlpriv);
+
+//void rtl8192c_dm_RF_Saving(IN struct rtl_priv *rtlpriv, IN uint8_t bForceInNormal);
+
+#endif
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/include/rtl8812a_hal.h linux-4.9.8821au/drivers/staging/rtl8821au/include/rtl8812a_hal.h
--- linux-4.9/drivers/staging/rtl8821au/include/rtl8812a_hal.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/include/rtl8812a_hal.h	2016-12-11 19:48:25.173645047 -0600
@@ -0,0 +1,156 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8812A_HAL_H__
+#define __RTL8812A_HAL_H__
+
+//#include "hal_com.h"
+#include <odm_precomp.h>
+
+//include HAL Related header after HAL Related compiling flags
+#include "rtl8812a_spec.h"
+#include "rtl8812a_rf.h"
+#include "rtl8812a_dm.h"
+#include "rtl8812a_recv.h"
+#include "rtl8812a_xmit.h"
+#include "rtl8812a_cmd.h"
+#include "Hal8812PwrSeq.h"
+#include "Hal8821APwrSeq.h" //for 8821A/8811A
+#include "Hal8812PhyReg.h"
+#include "Hal8812PhyCfg.h"
+#ifdef DBG_CONFIG_ERROR_DETECT
+#include "rtl8812a_sreset.h"
+#endif
+
+#define Rtl8812_NIC_PWR_ON_FLOW				rtl8812_power_on_flow
+#define Rtl8812_NIC_RF_OFF_FLOW				rtl8812_radio_off_flow
+#define Rtl8812_NIC_DISABLE_FLOW				rtl8812_card_disable_flow
+#define Rtl8812_NIC_ENABLE_FLOW				rtl8812_card_enable_flow
+#define Rtl8812_NIC_SUSPEND_FLOW				rtl8812_suspend_flow
+#define Rtl8812_NIC_RESUME_FLOW				rtl8812_resume_flow
+#define Rtl8812_NIC_PDN_FLOW					rtl8812_hwpdn_flow
+#define Rtl8812_NIC_LPS_ENTER_FLOW			rtl8812_enter_lps_flow
+#define Rtl8812_NIC_LPS_LEAVE_FLOW				rtl8812_leave_lps_flow
+
+//---------------------------------------------------------------------
+//		RTL8821 Power Configuration CMDs for PCIe interface
+//---------------------------------------------------------------------
+#define Rtl8821A_NIC_PWR_ON_FLOW				rtl8821A_power_on_flow
+#define Rtl8821A_NIC_RF_OFF_FLOW				rtl8821A_radio_off_flow
+#define Rtl8821A_NIC_DISABLE_FLOW				rtl8821A_card_disable_flow
+#define Rtl8821A_NIC_ENABLE_FLOW				rtl8821A_card_enable_flow
+#define Rtl8821A_NIC_SUSPEND_FLOW				rtl8821A_suspend_flow
+#define Rtl8821A_NIC_RESUME_FLOW				rtl8821A_resume_flow
+#define Rtl8821A_NIC_PDN_FLOW					rtl8821A_hwpdn_flow
+#define Rtl8821A_NIC_LPS_ENTER_FLOW			rtl8821A_enter_lps_flow
+#define Rtl8821A_NIC_LPS_LEAVE_FLOW			rtl8821A_leave_lps_flow
+
+
+#if 1 // download firmware related data structure
+
+#endif // download firmware related data structure
+
+
+#define DRIVER_EARLY_INT_TIME_8812		0x05
+#define BCN_DMA_ATIME_INT_TIME_8812		0x02
+
+#define TX_TOTAL_PAGE_NUMBER_8812		0xF8
+
+#define TX_PAGE_BOUNDARY_8812			(TX_TOTAL_PAGE_NUMBER_8812 + 1)
+#define TX_PAGE_LOAD_FW_BOUNDARY_8812		0x47 //0xA5
+#define TX_PAGE_BOUNDARY_WOWLAN_8812		0xE0
+
+// For Normal Chip Setting
+// (HPQ + LPQ + NPQ + PUBQ) shall be TX_TOTAL_PAGE_NUMBER_92C
+#define NORMAL_PAGE_NUM_PUBQ_8812			0xD8
+#define NORMAL_PAGE_NUM_LPQ_8812				0x10
+#define NORMAL_PAGE_NUM_HPQ_8812			0x10
+#define NORMAL_PAGE_NUM_NPQ_8812				0x00
+
+//Note: For WMM Normal Chip Setting ,modify later
+#define WMM_NORMAL_TX_TOTAL_PAGE_NUMBER_8812	0xFB
+#define WMM_NORMAL_TX_PAGE_BOUNDARY_8812		(WMM_NORMAL_TX_TOTAL_PAGE_NUMBER_8812 + 1)
+
+#define WMM_NORMAL_PAGE_NUM_PUBQ_8812		0x8B
+#define WMM_NORMAL_PAGE_NUM_HPQ_8812		0x30
+#define WMM_NORMAL_PAGE_NUM_LPQ_8812		0x20
+#define WMM_NORMAL_PAGE_NUM_NPQ_8812		0x20
+
+
+// for 8821A
+// TX 64K, RX 16K, Page size 256B for TX, 128B for RX
+#define PAGE_SIZE_TX_8821A					256
+#define PAGE_SIZE_RX_8821A					128
+
+// For Normal Chip Setting
+#define TX_TOTAL_PAGE_NUMBER_8821			0xF7
+#define TX_PAGE_BOUNDARY_8821				(TX_TOTAL_PAGE_NUMBER_8821 + 1)
+//#define TX_PAGE_BOUNDARY_WOWLAN_8821		0xE0
+
+// (HPQ + LPQ + NPQ + PUBQ) shall be TX_TOTAL_PAGE_NUMBER
+#define NORMAL_PAGE_NUM_PUBQ_8821			0xE7
+#define NORMAL_PAGE_NUM_LPQ_8821			0x08
+#define NORMAL_PAGE_NUM_HPQ_8821			0x08
+#define NORMAL_PAGE_NUM_NPQ_8821			0x00
+
+// For WMM Normal Chip Setting
+#define WMM_NORMAL_TX_TOTAL_PAGE_NUMBER_8821	0xFB
+#define WMM_NORMAL_TX_PAGE_BOUNDARY_8821		(WMM_NORMAL_TX_TOTAL_PAGE_NUMBER_8821 + 1)
+
+#define WMM_NORMAL_PAGE_NUM_PUBQ_8821		0x8B
+#define WMM_NORMAL_PAGE_NUM_HPQ_8821		0x30
+#define WMM_NORMAL_PAGE_NUM_LPQ_8821		0x20
+#define WMM_NORMAL_PAGE_NUM_NPQ_8821		0x20
+
+
+#define	EFUSE_HIDDEN_812AU					0
+#define	EFUSE_HIDDEN_812AU_VS				1
+#define	EFUSE_HIDDEN_812AU_VL				2
+#define	EFUSE_HIDDEN_812AU_VN				3
+
+#define EFUSE_REAL_CONTENT_LEN_JAGUAR		512
+#define HWSET_MAX_SIZE_JAGUAR					512
+
+#define EFUSE_MAX_BANK_8812A					2
+#define EFUSE_MAP_LEN_JAGUAR					512
+#define EFUSE_MAX_SECTION_JAGUAR				64
+#define EFUSE_MAX_WORD_UNIT_JAGUAR			4
+#define EFUSE_IC_ID_OFFSET_JAGUAR				506	//For some inferiority IC purpose. added by Roger, 2009.09.02.
+#define AVAILABLE_EFUSE_ADDR_8812(addr) 	(addr < EFUSE_REAL_CONTENT_LEN_JAGUAR)
+// <Roger_Notes> To prevent out of boundary programming case, leave 1byte and program full section
+// 9bytes + 1byt + 5bytes and pre 1byte.
+// For worst case:
+// | 2byte|----8bytes----|1byte|--7bytes--| //92D
+#define EFUSE_OOB_PROTECT_BYTES_JAGUAR		18 	// PG data exclude header, dummy 7 bytes frome CP test and reserved 1byte.
+#define EFUSE_PROTECT_BYTES_BANK_JAGUAR		16
+
+//#define RT_IS_FUNC_DISABLED(rtlpriv, __FuncBits) ( (rtlpriv)->DisabledFunctions & (__FuncBits) )
+
+// rtl8812_hal_init.c
+void	InitializeFirmwareVars8812(struct rtl_priv *rtlpriv);
+
+
+// EFuse
+void UpdateHalRAMask8812A(struct rtl_priv *rtlpriv, uint32_t mac_id, uint8_t rssi_level);
+// register
+void SetBcnCtrlReg(struct rtl_priv *rtlpriv, uint8_t SetBits, uint8_t ClearBits);
+void rtw_set_sta_info(struct rtl_priv *rtlpriv, struct sta_info *psta, bool bSet);
+
+#endif //__RTL8188E_HAL_H__
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/include/rtl8812a_recv.h linux-4.9.8821au/drivers/staging/rtl8821au/include/rtl8812a_recv.h
--- linux-4.9/drivers/staging/rtl8821au/include/rtl8812a_recv.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/include/rtl8812a_recv.h	2016-12-11 19:48:25.173645047 -0600
@@ -0,0 +1,36 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8812A_RECV_H__
+#define __RTL8812A_RECV_H__
+
+#define MAX_RECVBUF_SZ (24576) // 24k
+
+// Rx smooth factor
+#define Rx_Smooth_Factor (20)
+
+
+#define INTERRUPT_MSG_FORMAT_LEN 60
+int32_t rtl8812au_init_recv_priv(struct rtl_priv *rtlpriv);
+void rtl8812au_free_recv_priv(struct rtl_priv *rtlpriv);
+void rtl8812au_recv_hdl(struct rtl_priv *rtlpriv, struct recv_buf *precvbuf);
+void rtl8812au_recv_tasklet(void *priv);
+
+#endif
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/include/rtl8812a_rf.h linux-4.9.8821au/drivers/staging/rtl8821au/include/rtl8812a_rf.h
--- linux-4.9/drivers/staging/rtl8821au/include/rtl8812a_rf.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/include/rtl8812a_rf.h	2016-12-11 19:48:25.173645047 -0600
@@ -0,0 +1,27 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8812A_RF_H__
+#define __RTL8812A_RF_H__
+
+void PHY_RF6052SetOFDMTxPower8812(struct rtl_priv *rtlpriv, u8 *pPowerLevelOFDM,
+	u8 *pPowerLevelBW20, u8 *pPowerLevelBW40, uint8_t Channel);
+
+#endif//__RTL8188E_RF_H__
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/include/rtl8812a_spec.h linux-4.9.8821au/drivers/staging/rtl8821au/include/rtl8812a_spec.h
--- linux-4.9/drivers/staging/rtl8821au/include/rtl8812a_spec.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/include/rtl8812a_spec.h	2016-12-11 19:48:25.173645047 -0600
@@ -0,0 +1,225 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *******************************************************************************/
+#ifndef __RTL8812A_SPEC_H__
+#define __RTL8812A_SPEC_H__
+
+#include <drv_conf.h>
+
+
+//============================================================
+//       8812 Regsiter offset definition
+//============================================================
+
+//============================================================
+//
+//============================================================
+
+//-----------------------------------------------------
+//
+//	0x0000h ~ 0x00FFh	System Configuration
+//
+//-----------------------------------------------------
+
+#define REG_SDIO_CTRL_8812				0x0070
+#define REG_OPT_CTRL_8812				0x0074
+#define REG_RF_B_CTRL_8812				0x0076
+#define REG_FW_DRV_MSG_8812			0x0088
+#define REG_HMEBOX_E2_E3_8812			0x008C
+#define REG_HIMR0_8812					0x00B0
+#define REG_HISR0_8812					0x00B4
+#define REG_HIMR1_8812					0x00B8
+#define REG_HISR1_8812					0x00BC
+#define REG_EFUSE_BURN_GNT_8812		0x00CF
+#define REG_SYS_CFG1_8812				0x00FC
+
+//-----------------------------------------------------
+//
+//	0x0100h ~ 0x01FFh	MACTOP General Configuration
+//
+//-----------------------------------------------------
+#define REG_PKTBUF_DBG_ADDR 			(REG_PKTBUF_DBG_CTRL)
+#define REG_RXPKTBUF_DBG				(REG_PKTBUF_DBG_CTRL+2)
+#define REG_TXPKTBUF_DBG				(REG_PKTBUF_DBG_CTRL+3)
+
+#define REG_RSVD3_8812					0x0168
+#define REG_C2HEVT_CMD_SEQ_88XX		0x01A1
+#define REG_C2hEVT_CMD_CONTENT_88XX	0x01A2
+#define REG_C2HEVT_CMD_LEN_88XX		0x01AE
+
+#define REG_HMEBOX_EXT0_8812			0x01F0
+#define REG_HMEBOX_EXT1_8812			0x01F4
+#define REG_HMEBOX_EXT2_8812			0x01F8
+#define REG_HMEBOX_EXT3_8812			0x01FC
+
+//-----------------------------------------------------
+//
+//	0x0200h ~ 0x027Fh	TXDMA Configuration
+//
+//-----------------------------------------------------
+#define REG_TDECTRL1_8812				0x0228
+
+//-----------------------------------------------------
+//
+//	0x0280h ~ 0x02FFh	RXDMA Configuration
+//
+//-----------------------------------------------------
+#define REG_RXDMA_PRO_8812			0x0290
+#define REG_EARLY_MODE_CONTROL_8812	0x02BC
+#define REG_RSVD5_8812					0x02F0
+#define REG_RSVD6_8812					0x02F4
+#define REG_RSVD7_8812					0x02F8
+#define REG_RSVD8_8812					0x02FC
+
+
+//-----------------------------------------------------
+//
+//	0x0300h ~ 0x03FFh	PCIe
+//
+//-----------------------------------------------------
+#define	REG_PCIE_MULTIFET_CTRL_8812	0x036A	//PCIE Multi-Fethc Control
+
+//-----------------------------------------------------
+//
+//	0x0400h ~ 0x047Fh	Protocol Configuration
+//
+//-----------------------------------------------------
+#define REG_TXBF_CTRL_8812				0x042C
+#define REG_ARFR1_8812					0x044C
+#define REG_CCK_CHECK_8812				0x0454
+#define REG_AMPDU_MAX_TIME_8812		0x0456
+#define REG_TXPKTBUF_BCNQ_BDNY1_8812	0x0457
+
+#define REG_AMPDU_MAX_LENGTH_8812	0x0458
+#define REG_TXPKTBUF_WMAC_LBK_BF_HD_8812	0x045D
+#define REG_NDPA_OPT_CTRL_8812		0x045F
+#define REG_DATA_SC_8812				0x0483
+#define REG_ARFR2_8812					0x048C
+#define REG_ARFR3_8812					0x0494
+#define REG_TXRPT_START_OFFSET		0x04AC
+#define REG_AMPDU_BURST_MODE_8812	0x04BC
+#define REG_HT_SINGLE_AMPDU_8812		0x04C7
+#define REG_MACID_PKT_DROP0_8812		0x04D0
+
+//-----------------------------------------------------
+//
+//	0x0500h ~ 0x05FFh	EDCA Configuration
+//
+//-----------------------------------------------------
+#define REG_CTWND_8812					0x0572
+#define REG_SECONDARY_CCA_CTRL_8812	0x0577
+#define REG_SCH_TXCMD_8812			0x05F8
+
+//-----------------------------------------------------
+//
+//	0x0600h ~ 0x07FFh	WMAC Configuration
+//
+//-----------------------------------------------------
+#define REG_MAC_CR_8812				0x0600
+
+#define REG_MAC_TX_SM_STATE_8812		0x06B4
+
+// Power
+#define REG_BFMER0_INFO_8812			0x06E4
+#define REG_BFMER1_INFO_8812			0x06EC
+#define REG_CSI_RPT_PARAM_BW20_8812	0x06F4
+#define REG_CSI_RPT_PARAM_BW40_8812	0x06F8
+#define REG_CSI_RPT_PARAM_BW80_8812	0x06FC
+
+// Hardware Port 2
+#define REG_BFMEE_SEL_8812				0x0714
+#define REG_SND_PTCL_CTRL_8812		0x0718
+
+
+//-----------------------------------------------------
+//
+//	Redifine register definition for compatibility
+//
+//-----------------------------------------------------
+
+// TODO: use these definition when using REG_xxx naming rule.
+// NOTE: DO NOT Remove these definition. Use later.
+#define	ISR_8812							REG_HISR0_8812
+
+//----------------------------------------------------------------------------
+//       8195 IMR/ISR bits						(offset 0xB0,  8bits)
+//----------------------------------------------------------------------------
+#define	IMR_DISABLED_8812					0
+// IMR DW0(0x00B0-00B3) Bit 0-31
+#define	IMR_TIMER2_8812					BIT(31)		// Timeout interrupt 2
+#define	IMR_TIMER1_8812					BIT(30)		// Timeout interrupt 1	
+#define	IMR_PSTIMEOUT_8812				BIT(29)		// Power Save Time Out Interrupt
+#define	IMR_GTINT4_8812					BIT(28)		// When GTIMER4 expires, this bit is set to 1	
+#define	IMR_GTINT3_8812					BIT(27)		// When GTIMER3 expires, this bit is set to 1	
+#define	IMR_TXBCN0ERR_8812				BIT(26)		// Transmit Beacon0 Error			
+#define	IMR_TXBCN0OK_8812					BIT(25)		// Transmit Beacon0 OK			
+#define	IMR_TSF_BIT32_TOGGLE_8812		BIT(24)		// TSF Timer BIT(32) toggle indication interrupt
+#define	IMR_BCNDMAINT0_8812				BIT(20)		// Beacon DMA Interrupt 0			
+#define	IMR_BCNDERR0_8812					BIT(16)		// Beacon Queue DMA OK0			
+#define	IMR_HSISR_IND_ON_INT_8812		BIT(15)		// HSISR Indicator (HSIMR & HSISR is true, this bit is set to 1)
+#define	IMR_BCNDMAINT_E_8812				BIT(14)		// Beacon DMA Interrupt Extension for Win7			
+#define	IMR_ATIMEND_8812					BIT(12)		// CTWidnow End or ATIM Window End
+#define	IMR_C2HCMD_8812					BIT(10)		// CPU to Host Command INT Status, Write 1 clear	
+#define	IMR_CPWM2_8812					BIT(9)			// CPU power Mode exchange INT Status, Write 1 clear	
+#define	IMR_CPWM_8812						BIT(8)			// CPU power Mode exchange INT Status, Write 1 clear	
+#define	IMR_HIGHDOK_8812					BIT(7)			// High Queue DMA OK	
+#define	IMR_MGNTDOK_8812					BIT(6)			// Management Queue DMA OK	
+#define	IMR_BKDOK_8812					BIT(5)			// AC_BK DMA OK		
+#define	IMR_BEDOK_8812					BIT(4)			// AC_BE DMA OK	
+#define	IMR_VIDOK_8812					BIT(3)			// AC_VI DMA OK		
+#define	IMR_VODOK_8812					BIT(2)			// AC_VO DMA OK	
+#define	IMR_RDU_8812						BIT(1)			// Rx Descriptor Unavailable	
+#define	IMR_ROK_8812						BIT(0)			// Receive DMA OK
+
+// IMR DW1(0x00B4-00B7) Bit 0-31
+#define	IMR_BCNDMAINT7_8812				BIT(27)		// Beacon DMA Interrupt 7
+#define	IMR_BCNDMAINT6_8812				BIT(26)		// Beacon DMA Interrupt 6
+#define	IMR_BCNDMAINT5_8812				BIT(25)		// Beacon DMA Interrupt 5
+#define	IMR_BCNDMAINT4_8812				BIT(24)		// Beacon DMA Interrupt 4
+#define	IMR_BCNDMAINT3_8812				BIT(23)		// Beacon DMA Interrupt 3
+#define	IMR_BCNDMAINT2_8812				BIT(22)		// Beacon DMA Interrupt 2
+#define	IMR_BCNDMAINT1_8812				BIT(21)		// Beacon DMA Interrupt 1
+#define	IMR_BCNDOK7_8812					BIT(20)		// Beacon Queue DMA OK Interrup 7
+#define	IMR_BCNDOK6_8812					BIT(19)		// Beacon Queue DMA OK Interrup 6
+#define	IMR_BCNDOK5_8812					BIT(18)		// Beacon Queue DMA OK Interrup 5
+#define	IMR_BCNDOK4_8812					BIT(17)		// Beacon Queue DMA OK Interrup 4
+#define	IMR_BCNDOK3_8812					BIT(16)		// Beacon Queue DMA OK Interrup 3
+#define	IMR_BCNDOK2_8812					BIT(15)		// Beacon Queue DMA OK Interrup 2
+#define	IMR_BCNDOK1_8812					BIT(14)		// Beacon Queue DMA OK Interrup 1
+#define	IMR_ATIMEND_E_8812				BIT(13)		// ATIM Window End Extension for Win7
+#define	IMR_TXERR_8812					BIT(11)		// Tx Error Flag Interrupt Status, write 1 clear.
+#define	IMR_RXERR_8812					BIT(10)		// Rx Error Flag INT Status, Write 1 clear
+#define	IMR_TXFOVW_8812					BIT(9)			// Transmit FIFO Overflow
+#define	IMR_RXFOVW_8812					BIT(8)			// Receive FIFO Overflow
+
+
+//============================================================================
+//       Regsiter Bit and Content definition 
+//============================================================================
+
+//2 ACMHWCTRL 0x05C0
+#define	AcmHw_HwEn_8812				BIT(0)
+#define	AcmHw_VoqEn_8812				BIT(1)
+#define	AcmHw_ViqEn_8812				BIT(2)
+#define	AcmHw_BeqEn_8812				BIT(3)
+#define	AcmHw_VoqStatus_8812			BIT(5)
+#define	AcmHw_ViqStatus_8812			BIT(6)
+#define	AcmHw_BeqStatus_8812			BIT(7)
+
+#endif //__RTL8188E_SPEC_H__
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/include/rtl8812a_xmit.h linux-4.9.8821au/drivers/staging/rtl8821au/include/rtl8812a_xmit.h
--- linux-4.9/drivers/staging/rtl8821au/include/rtl8812a_xmit.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/include/rtl8812a_xmit.h	2016-12-11 19:48:25.173645047 -0600
@@ -0,0 +1,93 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8812A_XMIT_H__
+#define __RTL8812A_XMIT_H__
+
+
+
+//
+//defined for TX DESC Operation
+//
+
+#define MAX_TID (15)
+
+//OFFSET 0
+#define OFFSET_SZ	0
+#define OFFSET_SHT	16
+#define BMC			BIT(24)
+#define LSG			BIT(26)
+#define FSG			BIT(27)
+#define OWN 		BIT(31)
+
+
+//OFFSET 4
+#define PKT_OFFSET_SZ		0
+#define QSEL_SHT			8
+#define RATE_ID_SHT			16
+#define NAVUSEHDR			BIT(20)
+#define SEC_TYPE_SHT 		22
+#define PKT_OFFSET_SHT		26
+
+//OFFSET 8
+#define AGG_EN				BIT(12)
+#define AGG_BK				BIT(16)
+#define AMPDU_DENSITY_SHT	20
+#define ANTSEL_A			BIT(24)
+#define ANTSEL_B			BIT(25)
+#define TX_ANT_CCK_SHT		26
+#define TX_ANTL_SHT			28
+#define TX_ANT_HT_SHT		30
+
+//OFFSET 12
+#define SEQ_SHT				16
+#define EN_HWSEQ			BIT(31)
+
+//OFFSET 16
+#define QOS					BIT(6)
+#define	HW_SSN				BIT(7)
+#define USERATE				BIT(8)
+#define DISDATAFB			BIT(10)
+#define CTS_2_SELF			BIT(11)
+#define	RTS_EN				BIT(12)
+#define	HW_RTS_EN			BIT(13)
+#define DATA_SHORT			BIT(24)
+#define PWR_STATUS_SHT	15
+#define DATA_SC_SHT		20
+#define DATA_BW				BIT(25)
+
+//OFFSET 20
+#define	RTY_LMT_EN			BIT(17)
+
+//OFFSET 20
+#define SGI					BIT(6)
+#define USB_TXAGG_NUM_SHT	24
+
+
+#define USB_DUMMY_OFFSET		1
+#define USB_DUMMY_LENGTH		(USB_DUMMY_OFFSET * PACKET_OFFSET_SZ)
+
+void rtl8812au_xmit_tasklet(void *priv);
+
+u8	BWMapping_8812(struct rtl_priv *rtlpriv, struct tx_pkt_attrib *pattrib);
+
+#endif //__RTL8812_XMIT_H__
+
+#include "rtl8821a_xmit.h"
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/include/rtl8821a_xmit.h linux-4.9.8821au/drivers/staging/rtl8821au/include/rtl8821a_xmit.h
--- linux-4.9/drivers/staging/rtl8821au/include/rtl8821a_xmit.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/include/rtl8821a_xmit.h	2016-12-11 19:48:25.173645047 -0600
@@ -0,0 +1,158 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2013 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTL8821A_XMIT_H__
+#define __RTL8821A_XMIT_H__
+
+#include <drv_types.h>
+
+typedef struct txdescriptor_8821a
+{
+	// Offset 0
+	u32 pktlen:16;
+	u32 offset:8;
+	u32 bmc:1;
+	u32 htc:1;
+	u32 rsvd0026:1;
+	u32 rsvd0027:1;
+	u32 linip:1;
+	u32 noacm:1;
+	u32 gf:1;
+	u32 rsvd0031:1;
+
+	// Offset 4
+	u32 macid:7;
+	u32 rsvd0407:1;
+	u32 qsel:5;
+	u32 rdg_nav_ext:1;
+	u32 lsig_txop_en:1;
+	u32 pifs:1;
+	u32 rate_id:5;
+	u32 en_desc_id:1;
+	u32 sectype:2;
+	u32 pkt_offset:5; // unit: 8 bytes
+	u32 moredata:1;
+	u32 txop_ps_cap:1;
+	u32 txop_ps_mode:1;
+
+	// Offset 8
+	u32 p_aid:9;
+	u32 rsvd0809:1;
+	u32 cca_rts:2;
+	u32 agg_en:1;
+	u32 rdg_en:1;
+	u32 null_0:1;
+	u32 null_1:1;
+	u32 bk:1;
+	u32 morefrag:1;
+	u32 raw:1;
+	u32 spe_rpt:1;
+	u32 ampdu_density:3;
+	u32 bt_null:1;
+	u32 g_id:6;
+	u32 rsvd0830:2;
+
+	// Offset 12
+	u32 wheader_len:4;
+	u32 chk_en:1;
+	u32 early_rate:1;
+	u32 hw_ssn_sel:2;
+	u32 userate:1;
+	u32 disrtsfb:1;
+	u32 disdatafb:1;
+	u32 cts2self:1;
+	u32 rtsen:1;
+	u32 hw_rts_en:1;
+	u32 port_id:1;
+	u32 navusehdr:1;
+	u32 use_max_len:1;
+	u32 max_agg_num:5;
+	u32 ndpa:2;
+	u32 ampdu_max_time:8;
+
+	// Offset 16
+	u32 datarate:7;
+	u32 try_rate:1;
+	u32 data_ratefb_lmt:5;
+	u32 rts_ratefb_lmt:4;
+	u32 rty_lmt_en:1;
+	u32 data_rt_lmt:6;
+	u32 rtsrate:5;
+	u32 pcts_en:1;
+	u32 pcts_mask_idx:2;
+
+	// Offset 20
+	u32 data_sc:4;
+	u32 data_short:1;
+	u32 data_bw:2;
+	u32 data_ldpc:1;
+	u32 data_stbc:2;
+	u32 vcs_stbc:2;
+	u32 rts_short:1;
+	u32 rts_sc:4;
+	u32 rsvd2016:7;
+	u32 tx_ant:4;
+	u32 txpwr_offset:3;
+	u32 rsvd2031:1;
+
+	// Offset 24
+	u32 sw_define:12;
+	u32 mbssid:4;
+	u32 antsel_A:3;
+	u32 antsel_B:3;
+	u32 antsel_C:3;
+	u32 antsel_D:3;
+	u32 rsvd2428:4;
+
+	// Offset 28
+	u32 checksum:16;
+	u32 rsvd2816:8;
+	u32 usb_txagg_num:8;
+
+	// Offset 32
+	u32 rts_rc:6;
+	u32 bar_rty_th:2;
+	u32 data_rc:6;
+	u32 rsvd3214:1;
+	u32 en_hwseq:1;
+	u32 nextneadpage:8;
+	u32 tailpage:8;
+
+	// Offset 36
+	u32 padding_len:11;
+	u32 txbf_path:1;
+	u32 seq:12;
+	u32 final_data_rate:8;
+}TXDESC_8821A, *PTXDESC_8821A;
+
+
+#if 0
+int32_t rtl8821au_init_xmit_priv(struct rtl_priv *rtlpriv);
+void rtl8821au_free_xmit_priv(struct rtl_priv *rtlpriv);
+int32_t rtl8821au_hal_xmit(struct rtl_priv *rtlpriv, struct xmit_frame *pxmitframe);
+int32_t rtl8821au_mgnt_xmit(struct rtl_priv *rtlpriv, struct xmit_frame *pmgntframe);
+int32_t rtl8821au_hal_xmitframe_enqueue(struct rtl_priv *rtlpriv, struct xmit_frame *pxmitframe);
+int32_t rtl8821au_xmit_buf_handler(struct rtl_priv *rtlpriv);
+void rtl8821au_xmit_tasklet(void *priv);
+int32_t rtl8821au_xmitframe_complete(struct rtl_priv *rtlpriv, struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf);
+
+#endif
+
+#endif //__RTL8821_XMIT_H__
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/include/rtw_ap.h linux-4.9.8821au/drivers/staging/rtl8821au/include/rtw_ap.h
--- linux-4.9/drivers/staging/rtl8821au/include/rtw_ap.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/include/rtw_ap.h	2016-12-11 19:48:25.173645047 -0600
@@ -0,0 +1,64 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTW_AP_H_
+#define __RTW_AP_H_
+
+
+#ifdef CONFIG_AP_MODE
+
+//external function
+extern void rtw_indicate_sta_assoc_event(struct rtl_priv *rtlpriv, struct sta_info *psta);
+extern void rtw_indicate_sta_disassoc_event(struct rtl_priv *rtlpriv, struct sta_info *psta);
+
+
+void init_mlme_ap_info(struct rtl_priv *rtlpriv);
+void free_mlme_ap_info(struct rtl_priv *rtlpriv);
+//void update_BCNTIM(struct rtl_priv *rtlpriv);
+void rtw_add_bcn_ie(struct rtl_priv *rtlpriv, WLAN_BSSID_EX *pnetwork, uint8_t index, uint8_t *data, uint8_t len);
+void rtw_remove_bcn_ie(struct rtl_priv *rtlpriv, WLAN_BSSID_EX *pnetwork, uint8_t index);
+void update_beacon(struct rtl_priv *rtlpriv, uint8_t ie_id, uint8_t *oui, uint8_t tx);
+void add_RATid(struct rtl_priv *rtlpriv, struct sta_info *psta, uint8_t rssi_level);
+void expire_timeout_chk(struct rtl_priv *rtlpriv);
+void update_sta_info_apmode(struct rtl_priv *rtlpriv, struct sta_info *psta);
+int rtw_check_beacon_data(struct rtl_priv *rtlpriv, uint8_t *pbuf,  int len);
+void rtw_ap_restore_network(struct rtl_priv *rtlpriv);
+void rtw_set_macaddr_acl(struct rtl_priv *rtlpriv, int mode);
+int rtw_acl_add_sta(struct rtl_priv *rtlpriv, uint8_t *addr);
+int rtw_acl_remove_sta(struct rtl_priv *rtlpriv, uint8_t *addr);
+
+uint8_t rtw_ap_set_pairwise_key(struct rtl_priv *rtlpriv, struct sta_info *psta);
+int rtw_ap_set_group_key(struct rtl_priv *rtlpriv, uint8_t *key, uint8_t alg, int keyid);
+int rtw_ap_set_wep_key(struct rtl_priv *rtlpriv, uint8_t *key, uint8_t keylen, int keyid, uint8_t set_tx);
+
+void associated_clients_update(struct rtl_priv *rtlpriv, uint8_t updated);
+void bss_cap_update_on_sta_join(struct rtl_priv *rtlpriv, struct sta_info *psta);
+uint8_t bss_cap_update_on_sta_leave(struct rtl_priv *rtlpriv, struct sta_info *psta);
+void sta_info_update(struct rtl_priv *rtlpriv, struct sta_info *psta);
+void ap_sta_info_defer_update(struct rtl_priv *rtlpriv, struct sta_info *psta);
+uint8_t ap_free_sta(struct rtl_priv *rtlpriv, struct sta_info *psta, bool active, u16 reason);
+int rtw_sta_flush(struct rtl_priv *rtlpriv);
+int rtw_ap_inform_ch_switch(struct rtl_priv *rtlpriv, uint8_t new_ch, uint8_t ch_offset);
+void start_ap_mode(struct rtl_priv *rtlpriv);
+void stop_ap_mode(struct rtl_priv *rtlpriv);
+
+#endif //end of CONFIG_AP_MODE
+
+#endif
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/include/rtw_cmd.h linux-4.9.8821au/drivers/staging/rtl8821au/include/rtw_cmd.h
--- linux-4.9/drivers/staging/rtl8821au/include/rtw_cmd.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/include/rtw_cmd.h	2016-12-11 19:48:25.173645047 -0600
@@ -0,0 +1,948 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTW_CMD_H_
+#define __RTW_CMD_H_
+
+#include <rtw_rf.h>
+
+#define C2H_MEM_SZ (16*1024)
+
+	#define FREE_CMDOBJ_SZ	128
+
+	#define MAX_CMDSZ	1024
+	#define MAX_RSPSZ	512
+	#define MAX_EVTSZ	1024
+
+	#define CMDBUFF_ALIGN_SZ 512
+
+	struct cmd_obj {
+		struct rtl_priv *rtlpriv;
+		u16	cmdcode;
+		uint8_t	res;
+		uint8_t	*parmbuf;
+		u32	cmdsz;
+		uint8_t	*rsp;
+		u32	rspsz;
+		//struct semaphore 	cmd_sem;
+		struct list_head	list;
+	};
+
+	struct cmd_priv {
+		struct semaphore	cmd_queue_sema;
+		//struct semaphore	cmd_done_sema;
+		struct semaphore	terminate_cmdthread_sema;
+		struct __queue	cmd_queue;
+		uint8_t	cmd_seq;
+		uint8_t	*cmd_buf;	//shall be non-paged, and 4 bytes aligned
+		uint8_t	*cmd_allocated_buf;
+		uint8_t	*rsp_buf;	//shall be non-paged, and 4 bytes aligned
+		uint8_t	*rsp_allocated_buf;
+		u32	cmd_issued_cnt;
+		u32	cmd_done_cnt;
+		u32	rsp_cnt;
+		uint8_t cmdthd_running;
+		struct rtl_priv *rtlpriv;
+	};
+
+	struct	evt_priv {
+		atomic_t event_seq;
+		uint8_t	*evt_buf;	//shall be non-paged, and 4 bytes aligned
+		uint8_t	*evt_allocated_buf;
+		u32	evt_done_cnt;
+
+	};
+
+#define init_h2fwcmd_w_parm_no_rsp(pcmd, pparm, code) \
+do {\
+	INIT_LIST_HEAD(&pcmd->list);\
+	pcmd->cmdcode = code;\
+	pcmd->parmbuf = (uint8_t *)(pparm);\
+	pcmd->cmdsz = sizeof (*pparm);\
+	pcmd->rsp = NULL;\
+	pcmd->rspsz = 0;\
+} while(0)
+
+struct c2h_evt_hdr {
+	uint8_t id:4;
+	uint8_t plen:4;
+	uint8_t seq;
+	uint8_t payload[0];
+};
+
+struct P2P_PS_Offload_t {
+	uint8_t Offload_En:1;
+	uint8_t role:1; // 1: Owner, 0: Client
+	uint8_t CTWindow_En:1;
+	uint8_t NoA0_En:1;
+	uint8_t NoA1_En:1;
+	uint8_t AllStaSleep:1; // Only valid in Owner
+	uint8_t discovery:1;
+	uint8_t rsvd:1;
+};
+
+struct P2P_PS_CTWPeriod_t {
+	uint8_t CTWPeriod;	//TU
+};
+
+#define c2h_evt_exist(c2h_evt) ((c2h_evt)->id || (c2h_evt)->plen)
+
+extern u32 rtw_enqueue_cmd(struct cmd_priv *pcmdpriv, struct cmd_obj *obj);
+extern struct cmd_obj *rtw_dequeue_cmd(struct cmd_priv *pcmdpriv);
+extern void rtw_free_cmd_obj(struct cmd_obj *pcmd);
+
+int rtw_cmd_thread(void *context);
+
+extern u32 rtw_init_cmd_priv (struct cmd_priv *pcmdpriv);
+extern void rtw_free_cmd_priv (struct cmd_priv *pcmdpriv);
+
+extern u32 rtw_init_evt_priv (struct evt_priv *pevtpriv);
+extern void rtw_free_evt_priv (struct evt_priv *pevtpriv);
+extern void rtw_cmd_clr_isr(struct cmd_priv *pcmdpriv);
+extern void rtw_evt_notify_isr(struct evt_priv *pevtpriv);
+
+enum rtw_drvextra_cmd_id
+{
+	NONE_WK_CID,
+	DYNAMIC_CHK_WK_CID,
+	DM_CTRL_WK_CID,
+	PBC_POLLING_WK_CID,
+	POWER_SAVING_CTRL_WK_CID,//IPS,AUTOSuspend
+	LPS_CTRL_WK_CID,
+	ANT_SELECT_WK_CID,
+	P2P_PS_WK_CID,
+	P2P_PROTO_WK_CID,
+	CHECK_HIQ_WK_CID,//for softap mode, check hi queue if empty
+	INTEl_WIDI_WK_CID,
+	C2H_WK_CID,
+	RTP_TIMER_CFG_WK_CID,
+	MAX_WK_CID
+};
+
+enum LPS_CTRL_TYPE
+{
+	LPS_CTRL_SCAN=0,
+	LPS_CTRL_JOINBSS=1,
+	LPS_CTRL_CONNECT=2,
+	LPS_CTRL_DISCONNECT=3,
+	LPS_CTRL_SPECIAL_PACKET=4,
+	LPS_CTRL_LEAVE=5,
+};
+
+enum RFINTFS {
+	SWSI,
+	HWSI,
+	HWPI,
+};
+
+/*
+Caller Mode: Infra, Ad-HoC(C)
+
+Notes: To enter USB suspend mode
+
+Command Mode
+
+*/
+struct usb_suspend_parm {
+	u32 action;// 1: sleep, 0:resume
+};
+
+/*
+Caller Mode: Infra, Ad-HoC
+
+Notes: To join a known BSS.
+
+Command-Event Mode
+
+*/
+
+/*
+Caller Mode: Infra, Ad-Hoc
+
+Notes: To join the specified bss
+
+Command Event Mode
+
+*/
+struct joinbss_parm {
+	WLAN_BSSID_EX network;
+};
+
+/*
+Caller Mode: Infra, Ad-HoC(C)
+
+Notes: To disconnect the current associated BSS
+
+Command Mode
+
+*/
+struct disconnect_parm {
+	u32 deauth_timeout_ms;
+};
+
+/*
+Caller Mode: AP, Ad-HoC(M)
+
+Notes: To create a BSS
+
+Command Mode
+*/
+struct createbss_parm {
+	WLAN_BSSID_EX network;
+};
+
+/*
+Caller Mode: AP, Ad-HoC, Infra
+
+Notes: To set the NIC mode of RTL8711
+
+Command Mode
+
+The definition of mode:
+
+#define IW_MODE_AUTO	0	// Let the driver decides which AP to join
+#define IW_MODE_ADHOC	1	// Single cell network (Ad-Hoc Clients)
+#define IW_MODE_INFRA	2	// Multi cell network, roaming, ..
+#define IW_MODE_MASTER	3	// Synchronisation master or Access Point
+#define IW_MODE_REPEAT	4	// Wireless Repeater (forwarder)
+#define IW_MODE_SECOND	5	// Secondary master/repeater (backup)
+#define IW_MODE_MONITOR	6	// Passive monitor (listen only)
+
+*/
+struct	setopmode_parm {
+	uint8_t	mode;
+	uint8_t	rsvd[3];
+};
+
+/*
+Caller Mode: AP, Ad-HoC, Infra
+
+Notes: To ask RTL8711 performing site-survey
+
+Command-Event Mode
+
+*/
+
+#define RTW_SSID_SCAN_AMOUNT 9 // for WEXT_CSCAN_AMOUNT 9
+#define RTW_CHANNEL_SCAN_AMOUNT (14+37)
+struct sitesurvey_parm {
+	int scan_mode;	//active: 1, passive: 0
+	/* int bsslimit;	// 1 ~ 48 */
+	uint8_t ssid_num;
+	uint8_t ch_num;
+	NDIS_802_11_SSID ssid[RTW_SSID_SCAN_AMOUNT];
+	struct rtw_ieee80211_channel ch[RTW_CHANNEL_SCAN_AMOUNT];
+};
+
+/*
+Caller Mode: Any
+
+Notes: To set the auth type of RTL8711. open/shared/802.1x
+
+Command Mode
+
+*/
+struct setauth_parm {
+	uint8_t mode;  //0: legacy open, 1: legacy shared 2: 802.1x
+	uint8_t _1x;   //0: PSK, 1: TLS
+	uint8_t rsvd[2];
+};
+
+/*
+Caller Mode: Infra
+
+a. algorithm: wep40, wep104, tkip & aes
+b. keytype: grp key/unicast key
+c. key contents
+
+when shared key ==> keyid is the camid
+when 802.1x ==> keyid [0:1] ==> grp key
+when 802.1x ==> keyid > 2 ==> unicast key
+
+*/
+struct setkey_parm {
+	uint8_t	algorithm;	// encryption algorithm, could be none, wep40, TKIP, CCMP, wep104
+	uint8_t	keyid;
+	uint8_t 	grpkey;		// 1: this is the grpkey for 802.1x. 0: this is the unicast key for 802.1x
+	uint8_t 	set_tx;		// 1: main tx key for wep. 0: other key.
+	uint8_t	key[16];	// this could be 40 or 104
+};
+
+/*
+When in AP or Ad-Hoc mode, this is used to
+allocate an sw/hw entry for a newly associated sta.
+
+Command
+
+when shared key ==> algorithm/keyid
+
+*/
+struct set_stakey_parm {
+	uint8_t	addr[ETH_ALEN];
+	uint8_t	algorithm;
+	uint8_t 	id;// currently for erasing cam entry if algorithm == _NO_PRIVACY_
+	uint8_t	key[16];
+};
+
+struct set_stakey_rsp {
+	uint8_t	addr[ETH_ALEN];
+	uint8_t	keyid;
+	uint8_t	rsvd;
+};
+
+/*
+Caller Ad-Hoc/AP
+
+Command -Rsp(AID == CAMID) mode
+
+This is to force fw to add an sta_data entry per driver's request.
+
+FW will write an cam entry associated with it.
+
+*/
+struct set_assocsta_parm {
+	uint8_t	addr[ETH_ALEN];
+};
+
+struct set_assocsta_rsp {
+	uint8_t	cam_id;
+	uint8_t	rsvd[3];
+};
+
+/*
+	Caller Ad-Hoc/AP
+
+	Command mode
+
+	This is to force fw to del an sta_data entry per driver's request
+
+	FW will invalidate the cam entry associated with it.
+
+*/
+struct del_assocsta_parm {
+	uint8_t  	addr[ETH_ALEN];
+};
+
+/*
+Caller Mode: AP/Ad-HoC(M)
+
+Notes: To notify fw that given staid has changed its power state
+
+Command Mode
+
+*/
+struct setstapwrstate_parm {
+	uint8_t	staid;
+	uint8_t	status;
+	uint8_t	hwaddr[6];
+};
+
+/*
+Caller Mode: Any
+
+Notes: To setup the basic rate of RTL8711
+
+Command Mode
+
+*/
+struct	setbasicrate_parm {
+	uint8_t	basicrates[NumRates];
+};
+
+/*
+Caller Mode: Any
+
+Notes: To read the current basic rate
+
+Command-Rsp Mode
+
+*/
+struct getbasicrate_parm {
+	u32 rsvd;
+};
+
+struct getbasicrate_rsp {
+	uint8_t basicrates[NumRates];
+};
+
+/*
+Caller Mode: Any
+
+Notes: To setup the data rate of RTL8711
+
+Command Mode
+
+*/
+struct setdatarate_parm {
+#ifdef MP_FIRMWARE_OFFLOAD
+	u32	curr_rateidx;
+#else
+	uint8_t	mac_id;
+	uint8_t	datarates[NumRates];
+#endif
+};
+
+/*
+Caller Mode: Any
+
+Notes: To read the current data rate
+
+Command-Rsp Mode
+
+*/
+struct getdatarate_parm {
+	u32 rsvd;
+
+};
+struct getdatarate_rsp {
+	uint8_t datarates[NumRates];
+};
+
+
+/*
+Caller Mode: Any
+AP: AP can use the info for the contents of beacon frame
+Infra: STA can use the info when sitesurveying
+Ad-HoC(M): Like AP
+Ad-HoC(C): Like STA
+
+
+Notes: To set the phy capability of the NIC
+
+Command Mode
+
+*/
+
+struct	setphyinfo_parm {
+	struct regulatory_class class_sets[NUM_REGULATORYS];
+	uint8_t	status;
+};
+
+struct	getphyinfo_parm {
+	u32 rsvd;
+};
+
+struct	getphyinfo_rsp {
+	struct regulatory_class class_sets[NUM_REGULATORYS];
+	uint8_t	status;
+};
+
+/*
+Caller Mode: Any
+
+Notes: To set the channel/modem/band
+This command will be used when channel/modem/band is changed.
+
+Command Mode
+
+*/
+struct	setphy_parm {
+	uint8_t	rfchannel;
+	uint8_t	modem;
+};
+
+/*
+Caller Mode: Any
+
+Notes: To get the current setting of channel/modem/band
+
+Command-Rsp Mode
+
+*/
+struct	getphy_parm {
+	u32 rsvd;
+
+};
+struct	getphy_rsp {
+	uint8_t	rfchannel;
+	uint8_t	modem;
+};
+
+struct readBB_parm {
+	uint8_t	offset;
+};
+struct readBB_rsp {
+	uint8_t	value;
+};
+
+struct readTSSI_parm {
+	uint8_t	offset;
+};
+struct readTSSI_rsp {
+	uint8_t	value;
+};
+
+struct writeBB_parm {
+	uint8_t	offset;
+	uint8_t	value;
+};
+
+struct readRF_parm {
+	uint8_t	offset;
+};
+struct readRF_rsp {
+	u32	value;
+};
+
+struct writeRF_parm {
+	u32	offset;
+	u32	value;
+};
+
+struct getrfintfs_parm {
+	uint8_t	rfintfs;
+};
+
+
+struct Tx_Beacon_param
+{
+	WLAN_BSSID_EX network;
+};
+
+/*
+	Notes: This command is used for H2C/C2H loopback testing
+
+	mac[0] == 0
+	==> CMD mode, return H2C_SUCCESS.
+	The following condition must be ture under CMD mode
+		mac[1] == mac[4], mac[2] == mac[3], mac[0]=mac[5]= 0;
+		s0 == 0x1234, s1 == 0xabcd, w0 == 0x78563412, w1 == 0x5aa5def7;
+		s2 == (b1 << 8 | b0);
+
+	mac[0] == 1
+	==> CMD_RSP mode, return H2C_SUCCESS_RSP
+
+	The rsp layout shall be:
+	rsp: 			parm:
+		mac[0]  =   mac[5];
+		mac[1]  =   mac[4];
+		mac[2]  =   mac[3];
+		mac[3]  =   mac[2];
+		mac[4]  =   mac[1];
+		mac[5]  =   mac[0];
+		s0		=   s1;
+		s1		=   swap16(s0);
+		w0		=  	swap32(w1);
+		b0		= 	b1
+		s2		= 	s0 + s1
+		b1		= 	b0
+		w1		=	w0
+
+	mac[0] == 	2
+	==> CMD_EVENT mode, return 	H2C_SUCCESS
+	The event layout shall be:
+	event:			parm:
+		mac[0]  =   mac[5];
+		mac[1]  =   mac[4];
+		mac[2]  =   event's sequence number, starting from 1 to parm's marc[3]
+		mac[3]  =   mac[2];
+		mac[4]  =   mac[1];
+		mac[5]  =   mac[0];
+		s0		=   swap16(s0) - event.mac[2];
+		s1		=   s1 + event.mac[2];
+		w0		=  	swap32(w0);
+		b0		= 	b1
+		s2		= 	s0 + event.mac[2]
+		b1		= 	b0
+		w1		=	swap32(w1) - event.mac[2];
+
+		parm->mac[3] is the total event counts that host requested.
+
+
+	event will be the same with the cmd's param.
+
+*/
+
+// CMD param Formart for driver extra cmd handler
+struct drvextra_cmd_parm {
+	int ec_id; //extra cmd id
+	int type_size; // Can use this field as the type id or command size
+	unsigned char *pbuf;
+};
+
+/*------------------- Below are used for RF/BB tunning ---------------------*/
+
+struct	setantenna_parm {
+	uint8_t	tx_antset;
+	uint8_t	rx_antset;
+	uint8_t	tx_antenna;
+	uint8_t	rx_antenna;
+};
+
+struct	enrateadaptive_parm {
+	u32	en;
+};
+
+struct settxagctbl_parm {
+	u32	txagc[MAX_RATES_LENGTH];
+};
+
+struct gettxagctbl_parm {
+	u32 rsvd;
+};
+struct gettxagctbl_rsp {
+	u32	txagc[MAX_RATES_LENGTH];
+};
+
+struct setagcctrl_parm {
+	u32	agcctrl;		// 0: pure hw, 1: fw
+};
+
+
+struct setssup_parm	{
+	u32	ss_ForceUp[MAX_RATES_LENGTH];
+};
+
+struct getssup_parm	{
+	u32 rsvd;
+};
+struct getssup_rsp	{
+	uint8_t	ss_ForceUp[MAX_RATES_LENGTH];
+};
+
+
+struct setssdlevel_parm	{
+	uint8_t	ss_DLevel[MAX_RATES_LENGTH];
+};
+
+struct getssdlevel_parm	{
+	u32 rsvd;
+};
+struct getssdlevel_rsp	{
+	uint8_t	ss_DLevel[MAX_RATES_LENGTH];
+};
+
+struct setssulevel_parm	{
+	uint8_t	ss_ULevel[MAX_RATES_LENGTH];
+};
+
+struct getssulevel_parm	{
+	u32 rsvd;
+};
+struct getssulevel_rsp	{
+	uint8_t	ss_ULevel[MAX_RATES_LENGTH];
+};
+
+
+struct	setcountjudge_parm {
+	uint8_t	count_judge[MAX_RATES_LENGTH];
+};
+
+struct	getcountjudge_parm {
+	u32 rsvd;
+};
+struct	getcountjudge_rsp {
+	uint8_t	count_judge[MAX_RATES_LENGTH];
+};
+
+
+struct setratable_parm {
+	uint8_t ss_ForceUp[NumRates];
+	uint8_t ss_ULevel[NumRates];
+	uint8_t ss_DLevel[NumRates];
+	uint8_t count_judge[NumRates];
+};
+
+struct getratable_parm {
+                uint rsvd;
+};
+struct getratable_rsp {
+        uint8_t ss_ForceUp[NumRates];
+        uint8_t ss_ULevel[NumRates];
+        uint8_t ss_DLevel[NumRates];
+        uint8_t count_judge[NumRates];
+};
+
+
+//to get TX,RX retry count
+struct gettxretrycnt_parm{
+	unsigned int rsvd;
+};
+struct gettxretrycnt_rsp{
+	unsigned long tx_retrycnt;
+};
+
+struct getrxretrycnt_parm{
+	unsigned int rsvd;
+};
+struct getrxretrycnt_rsp{
+	unsigned long rx_retrycnt;
+};
+
+//to get BCNOK,BCNERR count
+struct getbcnokcnt_parm{
+	unsigned int rsvd;
+};
+struct getbcnokcnt_rsp{
+	unsigned long  bcnokcnt;
+};
+
+struct getbcnerrcnt_parm{
+	unsigned int rsvd;
+};
+struct getbcnerrcnt_rsp{
+	unsigned long bcnerrcnt;
+};
+
+// to get current TX power level
+struct getcurtxpwrlevel_parm{
+	unsigned int rsvd;
+};
+struct getcurtxpwrlevel_rsp{
+	unsigned short tx_power;
+};
+
+struct setprobereqextraie_parm {
+	unsigned char e_id;
+	unsigned char ie_len;
+	unsigned char ie[0];
+};
+
+struct setassocreqextraie_parm {
+	unsigned char e_id;
+	unsigned char ie_len;
+	unsigned char ie[0];
+};
+
+struct setproberspextraie_parm {
+	unsigned char e_id;
+	unsigned char ie_len;
+	unsigned char ie[0];
+};
+
+struct setassocrspextraie_parm {
+	unsigned char e_id;
+	unsigned char ie_len;
+	unsigned char ie[0];
+};
+
+
+struct addBaReq_parm
+{
+ 	unsigned int tid;
+	uint8_t	addr[ETH_ALEN];
+};
+
+/*H2C Handler index: 46 */
+struct set_ch_parm {
+	uint8_t ch;
+	uint8_t bw;
+	uint8_t ch_offset;
+};
+
+#ifdef MP_FIRMWARE_OFFLOAD
+/*H2C Handler index: 47 */
+struct SetTxPower_parm
+{
+	uint8_t TxPower;
+};
+
+/*H2C Handler index: 48 */
+struct SwitchAntenna_parm
+{
+	u16 antenna_tx;
+	u16 antenna_rx;
+//	R_ANTENNA_SELECT_CCK cck_txrx;
+	uint8_t cck_txrx;
+};
+
+/*H2C Handler index: 49 */
+struct SetCrystalCap_parm
+{
+	u32 curr_crystalcap;
+};
+
+/*H2C Handler index: 50 */
+struct SetSingleCarrierTx_parm
+{
+	uint8_t bStart;
+};
+
+/*H2C Handler index: 51 */
+struct SetSingleToneTx_parm
+{
+	uint8_t bStart;
+	uint8_t curr_rfpath;
+};
+
+/*H2C Handler index: 52 */
+struct SetCarrierSuppressionTx_parm
+{
+	uint8_t bStart;
+	u32 curr_rateidx;
+};
+
+/*H2C Handler index: 53 */
+struct SetContinuousTx_parm
+{
+	uint8_t bStart;
+	uint8_t CCK_flag; /*1:CCK 2:OFDM*/
+	u32 curr_rateidx;
+};
+
+/*H2C Handler index: 54 */
+struct SwitchBandwidth_parm
+{
+	uint8_t curr_bandwidth;
+};
+
+#endif	/* MP_FIRMWARE_OFFLOAD */
+
+/*H2C Handler index: 59 */
+struct SetChannelPlan_param
+{
+	uint8_t channel_plan;
+};
+
+/*H2C Handler index: 60 */
+struct LedBlink_param
+{
+	void *pLed;
+};
+
+/*H2C Handler index: 61 */
+struct SetChannelSwitch_param
+{
+	uint8_t new_ch_no;
+};
+
+/*H2C Handler index: 62 */
+struct TDLSoption_param
+{
+	uint8_t addr[ETH_ALEN];
+	uint8_t option;
+};
+
+#define GEN_CMD_CODE(cmd)	cmd ## _CMD_
+
+
+/*
+
+Result:
+0x00: success
+0x01: sucess, and check Response.
+0x02: cmd ignored due to duplicated sequcne number
+0x03: cmd dropped due to invalid cmd code
+0x04: reserved.
+
+*/
+
+#define H2C_RSP_OFFSET			512
+
+#define H2C_SUCCESS			0x00
+#define H2C_SUCCESS_RSP			0x01
+#define H2C_DUPLICATED			0x02
+#define H2C_DROPPED			0x03
+#define H2C_PARAMETERS_ERROR		0x04
+#define H2C_REJECTED			0x05
+#define H2C_CMD_OVERFLOW		0x06
+#define H2C_RESERVED			0x07
+
+uint8_t rtw_sitesurvey_cmd(struct rtl_priv  *rtlpriv, NDIS_802_11_SSID *ssid, int ssid_num, struct rtw_ieee80211_channel *ch, int ch_num);
+extern uint8_t rtw_createbss_cmd(struct rtl_priv  *rtlpriv);
+extern uint8_t rtw_createbss_cmd_ex(struct rtl_priv  *rtlpriv, unsigned char *pbss, unsigned int sz);
+extern uint8_t rtw_setphy_cmd(struct rtl_priv  *rtlpriv, uint8_t modem, uint8_t ch);
+extern uint8_t rtw_setstakey_cmd(struct rtl_priv  *rtlpriv, uint8_t *psta, uint8_t unicast_key);
+extern uint8_t rtw_clearstakey_cmd(struct rtl_priv *rtlpriv, uint8_t *psta, uint8_t entry, uint8_t enqueue);
+extern uint8_t rtw_joinbss_cmd(struct rtl_priv  *rtlpriv, struct wlan_network* pnetwork);
+uint8_t rtw_disassoc_cmd(struct rtl_priv *rtlpriv, u32 deauth_timeout_ms, bool enqueue);
+extern uint8_t rtw_setopmode_cmd(struct rtl_priv  *rtlpriv, NDIS_802_11_NETWORK_INFRASTRUCTURE networktype);
+extern uint8_t rtw_setrfintfs_cmd(struct rtl_priv  *rtlpriv, uint8_t mode);
+
+extern uint8_t rtw_gettssi_cmd(struct rtl_priv  *rtlpriv, uint8_t offset,uint8_t *pval);
+extern uint8_t rtw_setfwdig_cmd(struct rtl_priv*rtlpriv, uint8_t type);
+extern uint8_t rtw_setfwra_cmd(struct rtl_priv*rtlpriv, uint8_t type);
+
+extern uint8_t rtw_addbareq_cmd(struct rtl_priv*rtlpriv, uint8_t tid, uint8_t *addr);
+
+extern uint8_t rtw_dynamic_chk_wk_cmd(struct rtl_priv *rtlpriv);
+
+uint8_t rtw_lps_ctrl_wk_cmd(struct rtl_priv*rtlpriv, uint8_t lps_ctrl_type, uint8_t enqueue);
+#if (RATE_ADAPTIVE_SUPPORT==1)
+uint8_t rtw_rpt_timer_cfg_cmd(struct rtl_priv*rtlpriv, u16 minRptTime);
+#endif
+
+extern uint8_t rtw_ps_cmd(struct rtl_priv*rtlpriv);
+
+#ifdef CONFIG_AP_MODE
+uint8_t rtw_chk_hi_queue_cmd(struct rtl_priv*rtlpriv);
+#endif
+
+uint8_t rtw_set_ch_cmd(struct rtl_priv*rtlpriv, uint8_t ch, uint8_t bw, uint8_t ch_offset, uint8_t enqueue);
+extern uint8_t rtw_set_csa_cmd(struct rtl_priv*rtlpriv, uint8_t new_ch_no);
+
+uint8_t rtw_drvextra_cmd_hdl(struct rtl_priv *rtlpriv, unsigned char *pbuf);
+
+extern void rtw_survey_cmd_callback(struct rtl_priv  *rtlpriv, struct cmd_obj *pcmd);
+extern void rtw_disassoc_cmd_callback(struct rtl_priv  *rtlpriv, struct cmd_obj *pcmd);
+extern void rtw_joinbss_cmd_callback(struct rtl_priv  *rtlpriv, struct cmd_obj *pcmd);
+extern void rtw_createbss_cmd_callback(struct rtl_priv  *rtlpriv, struct cmd_obj *pcmd);
+extern void rtw_getbbrfreg_cmdrsp_callback(struct rtl_priv  *rtlpriv, struct cmd_obj *pcmd);
+extern void rtw_readtssi_cmdrsp_callback(struct rtl_priv*	rtlpriv,  struct cmd_obj *pcmd);
+
+extern void rtw_setstaKey_cmdrsp_callback(struct rtl_priv  *rtlpriv,  struct cmd_obj *pcmd);
+extern void rtw_setassocsta_cmdrsp_callback(struct rtl_priv  *rtlpriv,  struct cmd_obj *pcmd);
+extern void rtw_getrttbl_cmdrsp_callback(struct rtl_priv  *rtlpriv,  struct cmd_obj *pcmd);
+
+
+struct _cmd_callback {
+	u32	cmd_code;
+	void (*callback)(struct rtl_priv  *rtlpriv, struct cmd_obj *cmd);
+};
+
+enum rtw_h2c_cmd {
+ 	GEN_CMD_CODE(_JoinBss),		/*  1 */
+ 	GEN_CMD_CODE(_DisConnect) ,	/*  2 */
+ 	GEN_CMD_CODE(_CreateBss) ,	/*  3 */
+	GEN_CMD_CODE(_SetOpMode) ,	/*  4 */
+	GEN_CMD_CODE(_SiteSurvey),	/*  5 */
+ 	GEN_CMD_CODE(_SetAuth) ,	/*  6 */
+ 	GEN_CMD_CODE(_SetKey) ,		/*  7 */
+ 	GEN_CMD_CODE(_SetStaKey) ,	/*  8 */
+ 	GEN_CMD_CODE(_AddBAReq) ,	/*  9 */
+	GEN_CMD_CODE(_SetChannel),	/* 10 */
+	GEN_CMD_CODE(_TX_Beacon),	/* 11 */
+	GEN_CMD_CODE(_Set_MLME_EVT),	/* 12 */
+	GEN_CMD_CODE(_Set_Drv_Extra),	/* 13 */
+	GEN_CMD_CODE(_SetChannelSwitch),/* 15 */
+
+	MAX_H2CCMD
+};
+
+#ifdef _RTW_CMD_C_
+struct _cmd_callback 	rtw_cmd_callback[] = {
+	{GEN_CMD_CODE(_JoinBss), &rtw_joinbss_cmd_callback},		/*  1 */
+	{GEN_CMD_CODE(_DisConnect), &rtw_disassoc_cmd_callback},	/*  2 */
+	{GEN_CMD_CODE(_CreateBss), &rtw_createbss_cmd_callback},	/*  3 */
+	{GEN_CMD_CODE(_SetOpMode), NULL},				/*  4 */
+	{GEN_CMD_CODE(_SiteSurvey), &rtw_survey_cmd_callback},		/*  5 */
+	{GEN_CMD_CODE(_SetAuth), NULL},					/*  6 */
+	{GEN_CMD_CODE(_SetKey), NULL},					/*  7 */
+	{GEN_CMD_CODE(_SetStaKey), &rtw_setstaKey_cmdrsp_callback},	/*  8 */
+ 	{GEN_CMD_CODE(_AddBAReq), NULL},				/*  9 */
+	{GEN_CMD_CODE(_SetChannel), NULL},				/* 10 */
+	{GEN_CMD_CODE(_TX_Beacon), NULL},				/* 11 */
+	{GEN_CMD_CODE(_Set_MLME_EVT), NULL},				/* 12 */
+	{GEN_CMD_CODE(_Set_Drv_Extra), NULL},				/* 13 */
+	{GEN_CMD_CODE(_SetChannelSwitch), NULL},			/* 15 */
+};
+#endif
+
+#endif // _CMD_H_
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/include/rtw_eeprom.h linux-4.9.8821au/drivers/staging/rtl8821au/include/rtw_eeprom.h
--- linux-4.9/drivers/staging/rtl8821au/include/rtw_eeprom.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/include/rtw_eeprom.h	2016-12-11 19:48:25.173645047 -0600
@@ -0,0 +1,73 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTW_EEPROM_H__
+#define __RTW_EEPROM_H__
+
+
+#define	RTL8712_EEPROM_ID			0x8712
+//#define	EEPROM_MAX_SIZE			256
+
+#define	HWSET_MAX_SIZE_128		128
+#define	HWSET_MAX_SIZE_256		256
+#define	HWSET_MAX_SIZE_512		512
+
+#define	EEPROM_MAX_SIZE			HWSET_MAX_SIZE_512
+
+#define	CLOCK_RATE					50			//100us
+
+//- EEPROM opcodes
+#define EEPROM_READ_OPCODE		06
+#define EEPROM_WRITE_OPCODE		05
+#define EEPROM_ERASE_OPCODE		07
+#define EEPROM_EWEN_OPCODE		19      // Erase/write enable
+#define EEPROM_EWDS_OPCODE		16      // Erase/write disable
+
+//Country codes
+#define USA							0x555320
+#define EUROPE						0x1 //temp, should be provided later
+#define JAPAN						0x2 //temp, should be provided later
+
+
+//
+// Customer ID, note that:
+// This variable is initiailzed through EEPROM or registry,
+// however, its definition may be different with that in EEPROM for
+// EEPROM size consideration. So, we have to perform proper translation between them.
+// Besides, CustomerID of registry has precedence of that of EEPROM.
+// defined below. 060703, by rcnjko.
+//
+typedef enum _RT_CUSTOMER_ID
+{
+	RT_CID_DEFAULT = 0,
+	RT_CID_Sercomm_Belkin = 22,
+	RT_CID_Edimax_ASUS = 35,
+	RT_CID_NETGEAR = 36,
+	RT_CID_Sercomm_Netgear = 43,
+	RT_CID_ALPHA_Dlink = 44,//add by ylb 20121012 for customer led for alpha
+}RT_CUSTOMER_ID, *PRT_CUSTOMER_ID;
+
+extern void eeprom_write16(struct rtl_priv *rtlpriv, u16 reg, u16 data);
+extern u16 eeprom_read16(struct rtl_priv *rtlpriv, u16 reg);
+extern void read_eeprom_content(struct rtl_priv *rtlpriv);
+extern void eeprom_read_sz(struct rtl_priv * rtlpriv, u16 reg,u8* data, u32 sz);
+
+extern void read_eeprom_content_by_attrib(struct rtl_priv *	rtlpriv	);
+#endif  //__RTL871X_EEPROM_H__
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/include/rtw_event.h linux-4.9.8821au/drivers/staging/rtl8821au/include/rtw_event.h
--- linux-4.9/drivers/staging/rtl8821au/include/rtw_event.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/include/rtw_event.h	2016-12-11 19:48:25.173645047 -0600
@@ -0,0 +1,119 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef _RTW_EVENT_H_
+#define _RTW_EVENT_H_
+
+/*
+Used to report a bss has been scanned
+
+*/
+struct survey_event	{
+	WLAN_BSSID_EX bss;
+};
+
+/*
+Used to report that the requested site survey has been done.
+
+bss_cnt indicates the number of bss that has been reported.
+
+
+*/
+struct surveydone_event {
+	unsigned int	bss_cnt;
+
+};
+
+/*
+Used to report the link result of joinning the given bss
+
+
+join_res:
+-1: authentication fail
+-2: association fail
+> 0: TID
+
+*/
+struct joinbss_event {
+	struct	wlan_network	network;
+};
+
+/*
+Used to report a given STA has joinned the created BSS.
+It is used in AP/Ad-HoC(M) mode.
+
+
+*/
+struct stassoc_event {
+	unsigned char macaddr[6];
+	unsigned char rsvd[2];
+	int    cam_id;
+
+};
+
+struct stadel_event {
+ unsigned char macaddr[6];
+ unsigned char rsvd[2]; //for reason
+ int mac_id;
+};
+
+struct addba_event
+{
+ 	unsigned int tid;
+};
+
+
+#define GEN_EVT_CODE(event)	event ## _EVT_
+
+
+
+struct fwevent {
+	u32	parmsize;
+	void (*event_callback)(struct rtl_priv *dev, uint8_t *pbuf);
+};
+
+
+#define C2HEVENT_SZ			32
+
+struct event_node{
+	unsigned char *node;
+	unsigned char evt_code;
+	unsigned short evt_sz;
+	volatile int	*caller_ff_tail;
+	int	caller_ff_sz;
+};
+
+struct c2hevent_queue {
+	volatile int	head;
+	volatile int	tail;
+	struct	event_node	nodes[C2HEVENT_SZ];
+	unsigned char	seq;
+};
+
+#define NETWORK_QUEUE_SZ	4
+
+struct network_queue {
+	volatile int	head;
+	volatile int	tail;
+	WLAN_BSSID_EX networks[NETWORK_QUEUE_SZ];
+};
+
+
+#endif // _WLANEVENT_H_
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/include/rtw_ht.h linux-4.9.8821au/drivers/staging/rtl8821au/include/rtw_ht.h
--- linux-4.9/drivers/staging/rtl8821au/include/rtw_ht.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/include/rtw_ht.h	2016-12-11 19:48:25.173645047 -0600
@@ -0,0 +1,83 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef _RTW_HT_H_
+#define _RTW_HT_H_
+
+
+struct ht_priv
+{
+	u32	ht_option;
+	u32	ampdu_enable;//for enable Tx A-MPDU
+	//uint8_t	baddbareq_issued[16];
+	u32	tx_amsdu_enable;//for enable Tx A-MSDU
+	u32	tx_amsdu_maxlen; // 1: 8k, 0:4k ; default:8k, for tx
+	u32	rx_ampdu_maxlen; //for rx reordering ctrl win_sz, updated when join_callback.
+
+	uint8_t	bwmode;//
+	uint8_t	ch_offset;//PRIME_CHNL_OFFSET
+	uint8_t	sgi;//short GI
+
+	//for processing Tx A-MPDU
+	uint8_t	agg_enable_bitmap;
+	//uint8_t	ADDBA_retry_count;
+	uint8_t	candidate_tid_bitmap;
+
+	uint8_t	ldpc_cap;
+	uint8_t	stbc_cap;
+	uint8_t	beamform_cap;
+
+	struct rtw_ieee80211_ht_cap ht_cap;
+
+};
+
+typedef enum AGGRE_SIZE{
+	HT_AGG_SIZE_8K = 0,
+	HT_AGG_SIZE_16K = 1,
+	HT_AGG_SIZE_32K = 2,
+	HT_AGG_SIZE_64K = 3,
+	VHT_AGG_SIZE_128K = 4,
+	VHT_AGG_SIZE_256K = 5,
+	VHT_AGG_SIZE_512K = 6,
+	VHT_AGG_SIZE_1024K = 7,
+}AGGRE_SIZE_E, *PAGGRE_SIZE_E;
+
+typedef enum _RT_HT_INF0_CAP{
+	RT_HT_CAP_USE_TURBO_AGGR = 0x01,
+	RT_HT_CAP_USE_LONG_PREAMBLE = 0x02,
+	RT_HT_CAP_USE_AMPDU = 0x04,
+	RT_HT_CAP_USE_WOW = 0x8,
+	RT_HT_CAP_USE_SOFTAP = 0x10,
+	RT_HT_CAP_USE_92SE = 0x20,
+	RT_HT_CAP_USE_88C_92C = 0x40,
+	RT_HT_CAP_USE_AP_CLIENT_MODE = 0x80,	// AP team request to reserve this bit, by Emily
+}RT_HT_INF0_CAPBILITY, *PRT_HT_INF0_CAPBILITY;
+
+typedef enum _RT_HT_INF1_CAP{
+	RT_HT_CAP_USE_VIDEO_CLIENT = 0x01,
+	RT_HT_CAP_USE_JAGUAR_BCUT = 0x02,
+	RT_HT_CAP_USE_JAGUAR_CCUT = 0x04,
+}RT_HT_INF1_CAPBILITY, *PRT_HT_INF1_CAPBILITY;
+
+#define	BEAMFORMING_HT_BEAMFORMER_ENABLE	BIT0	// Declare our NIC supports beamformer
+#define	BEAMFORMING_HT_BEAMFORMEE_ENABLE	BIT1	// Declare our NIC supports beamformee
+#define	BEAMFORMING_HT_BEAMFORMER_TEST		BIT2	// Transmiting Beamforming no matter the target supports it or not
+
+#endif	//_RTL871X_HT_H_
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/include/rtw_ioctl.h linux-4.9.8821au/drivers/staging/rtl8821au/include/rtw_ioctl.h
--- linux-4.9/drivers/staging/rtl8821au/include/rtw_ioctl.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/include/rtw_ioctl.h	2016-12-11 19:48:25.173645047 -0600
@@ -0,0 +1,174 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef _RTW_IOCTL_H_
+#define _RTW_IOCTL_H_
+
+//	00 - Success
+//	11 - Error
+#define STATUS_SUCCESS				(0x00000000L)
+#define STATUS_PENDING				(0x00000103L)
+
+#define STATUS_UNSUCCESSFUL			(0xC0000001L)
+#define STATUS_INSUFFICIENT_RESOURCES		(0xC000009AL)
+#define STATUS_NOT_SUPPORTED			(0xC00000BBL)
+
+#define NDIS_STATUS_SUCCESS			((uint)STATUS_SUCCESS)
+#define NDIS_STATUS_PENDING			((uint)STATUS_PENDING)
+#define NDIS_STATUS_NOT_RECOGNIZED		((uint)0x00010001L)
+#define NDIS_STATUS_NOT_COPIED			((uint)0x00010002L)
+#define NDIS_STATUS_NOT_ACCEPTED		((uint)0x00010003L)
+#define NDIS_STATUS_CALL_ACTIVE			((uint)0x00010007L)
+
+#define NDIS_STATUS_FAILURE			((uint)STATUS_UNSUCCESSFUL)
+#define NDIS_STATUS_RESOURCES			((uint)STATUS_INSUFFICIENT_RESOURCES)
+#define NDIS_STATUS_CLOSING			((uint)0xC0010002L)
+#define NDIS_STATUS_BAD_VERSION			((uint)0xC0010004L)
+#define NDIS_STATUS_BAD_CHARACTERISTICS		((uint)0xC0010005L)
+#define NDIS_STATUS_ADAPTER_NOT_FOUND		((uint)0xC0010006L)
+#define NDIS_STATUS_OPEN_FAILED			((uint)0xC0010007L)
+#define NDIS_STATUS_DEVICE_FAILED		((uint)0xC0010008L)
+#define NDIS_STATUS_MULTICAST_FULL		((uint)0xC0010009L)
+#define NDIS_STATUS_MULTICAST_EXISTS		((uint)0xC001000AL)
+#define NDIS_STATUS_MULTICAST_NOT_FOUND		((uint)0xC001000BL)
+#define NDIS_STATUS_REQUEST_ABORTED		((uint)0xC001000CL)
+#define NDIS_STATUS_RESET_IN_PROGRESS		((uint)0xC001000DL)
+#define NDIS_STATUS_CLOSING_INDICATING		((uint)0xC001000EL)
+#define NDIS_STATUS_NOT_SUPPORTED		((uint)STATUS_NOT_SUPPORTED)
+#define NDIS_STATUS_INVALID_PACKET		((uint)0xC001000FL)
+#define NDIS_STATUS_OPEN_LIST_FULL		((uint)0xC0010010L)
+#define NDIS_STATUS_ADAPTER_NOT_READY		((uint)0xC0010011L)
+#define NDIS_STATUS_ADAPTER_NOT_OPEN		((uint)0xC0010012L)
+#define NDIS_STATUS_NOT_INDICATING		((uint)0xC0010013L)
+#define NDIS_STATUS_INVALID_LENGTH		((uint)0xC0010014L)
+#define NDIS_STATUS_INVALID_DATA		((uint)0xC0010015L)
+#define NDIS_STATUS_BUFFER_TOO_SHORT		((uint)0xC0010016L)
+#define NDIS_STATUS_INVALID_OID			((uint)0xC0010017L)
+#define NDIS_STATUS_ADAPTER_REMOVED		((uint)0xC0010018L)
+#define NDIS_STATUS_UNSUPPORTED_MEDIA		((uint)0xC0010019L)
+#define NDIS_STATUS_GROUP_ADDRESS_IN_USE	((uint)0xC001001AL)
+#define NDIS_STATUS_FILE_NOT_FOUND		((uint)0xC001001BL)
+#define NDIS_STATUS_ERROR_READING_FILE		((uint)0xC001001CL)
+#define NDIS_STATUS_ALREADY_MAPPED		((uint)0xC001001DL)
+#define NDIS_STATUS_RESOURCE_CONFLICT		((uint)0xC001001EL)
+#define NDIS_STATUS_NO_CABLE			((uint)0xC001001FL)
+
+#define NDIS_STATUS_INVALID_SAP			((uint)0xC0010020L)
+#define NDIS_STATUS_SAP_IN_USE			((uint)0xC0010021L)
+#define NDIS_STATUS_INVALID_ADDRESS		((uint)0xC0010022L)
+#define NDIS_STATUS_VC_NOT_ACTIVATED		((uint)0xC0010023L)
+#define NDIS_STATUS_DEST_OUT_OF_ORDER		((uint)0xC0010024L)  // cause 27
+#define NDIS_STATUS_VC_NOT_AVAILABLE		((uint)0xC0010025L)  // cause 35,45
+#define NDIS_STATUS_CELLRATE_NOT_AVAILABLE	((uint)0xC0010026L)  // cause 37
+#define NDIS_STATUS_INCOMPATABLE_QOS		((uint)0xC0010027L)  // cause 49
+#define NDIS_STATUS_AAL_PARAMS_UNSUPPORTED	((uint)0xC0010028L)  // cause 93
+#define NDIS_STATUS_NO_ROUTE_TO_DESTINATION	((uint)0xC0010029L)  // cause 3
+
+
+#ifndef OID_802_11_CAPABILITY
+	#define OID_802_11_CAPABILITY                   0x0d010122
+#endif
+
+#ifndef OID_802_11_PMKID
+	#define OID_802_11_PMKID                        0x0d010123
+#endif
+
+
+// For DDK-defined OIDs
+#define OID_NDIS_SEG1	0x00010100
+#define OID_NDIS_SEG2	0x00010200
+#define OID_NDIS_SEG3	0x00020100
+#define OID_NDIS_SEG4	0x01010100
+#define OID_NDIS_SEG5	0x01020100
+#define OID_NDIS_SEG6	0x01020200
+#define OID_NDIS_SEG7	0xFD010100
+#define OID_NDIS_SEG8	0x0D010100
+#define OID_NDIS_SEG9	0x0D010200
+#define OID_NDIS_SEG10	0x0D020200
+
+#define SZ_OID_NDIS_SEG1		  23
+#define SZ_OID_NDIS_SEG2		    3
+#define SZ_OID_NDIS_SEG3		    6
+#define SZ_OID_NDIS_SEG4		    6
+#define SZ_OID_NDIS_SEG5		    4
+#define SZ_OID_NDIS_SEG6		    8
+#define SZ_OID_NDIS_SEG7		    7
+#define SZ_OID_NDIS_SEG8		  36
+#define SZ_OID_NDIS_SEG9		  24
+#define SZ_OID_NDIS_SEG10		  19
+
+// For Realtek-defined OIDs
+#define OID_MP_SEG1		0xFF871100
+#define OID_MP_SEG2		0xFF818000
+
+#define OID_MP_SEG3		0xFF818700
+#define OID_MP_SEG4		0xFF011100
+
+#define DEBUG_OID(dbg, str)     		\
+       if((!dbg))				    			\
+      	{					    			\
+	   RT_TRACE(_module_rtl871x_ioctl_c_,_drv_info_,("%s(%d): %s", __FUNCTION__, __LINE__, str));	\
+      	}
+
+
+enum oid_type
+{
+	QUERY_OID,
+	SET_OID
+};
+
+struct oid_funs_node {
+	unsigned int oid_start; //the starting number for OID
+	unsigned int oid_end; //the ending number for OID
+	struct oid_obj_priv *node_array;
+	unsigned int array_sz; //the size of node_array
+	int query_counter; //count the number of query hits for this segment
+	int set_counter; //count the number of set hits for this segment
+};
+
+struct oid_par_priv
+{
+	void		*adapter_context;
+	uint	oid;
+	void		*information_buf;
+	u32		information_buf_len;
+	u32		*bytes_rw;
+	u32		*bytes_needed;
+	enum oid_type	type_of_oid;
+	u32		dbg;
+};
+
+struct oid_obj_priv {
+	unsigned char	dbg; // 0: without OID debug message  1: with OID debug message
+	uint (*oidfuns)(struct oid_par_priv *poid_par_priv);
+};
+
+
+extern struct iw_handler_def  rtw_handlers_def;
+
+extern	uint drv_query_info(struct net_device *MiniportAdapterContext,
+	uint Oid, void *InformationBuffer, u32 InformationBufferLength,
+	u32 *BytesWritten, u32 *BytesNeeded);
+
+extern	uint drv_set_info(struct net_device *MiniportAdapterContext,
+	uint Oid, void *InformationBuffer, u32 InformationBufferLength,
+	u32 *BytesRead, u32 *BytesNeeded);
+
+#endif // #ifndef __INC_CEINFO_
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/include/rtw_ioctl_set.h linux-4.9.8821au/drivers/staging/rtl8821au/include/rtw_ioctl_set.h
--- linux-4.9/drivers/staging/rtl8821au/include/rtw_ioctl_set.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/include/rtw_ioctl_set.h	2016-12-11 19:48:25.173645047 -0600
@@ -0,0 +1,52 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTW_IOCTL_SET_H_
+#define __RTW_IOCTL_SET_H_
+
+
+typedef uint8_t NDIS_802_11_PMKID_VALUE[16];
+
+typedef struct _BSSIDInfo {
+	NDIS_802_11_MAC_ADDRESS  BSSID;
+	NDIS_802_11_PMKID_VALUE  PMKID;
+} BSSIDInfo, *PBSSIDInfo;
+
+
+
+
+uint8_t rtw_set_802_11_add_key(struct rtl_priv * rtlpriv, NDIS_802_11_KEY * key);
+uint8_t rtw_set_802_11_authentication_mode(struct rtl_priv *pdapter, NDIS_802_11_AUTHENTICATION_MODE authmode);
+uint8_t rtw_set_802_11_bssid(struct rtl_priv* rtlpriv, uint8_t *bssid);
+uint8_t rtw_set_802_11_add_wep(struct rtl_priv * rtlpriv, NDIS_802_11_WEP * wep);
+uint8_t rtw_set_802_11_disassociate(struct rtl_priv * rtlpriv);
+uint8_t rtw_set_802_11_bssid_list_scan(struct rtl_priv* rtlpriv, NDIS_802_11_SSID *pssid, int ssid_max_num);
+uint8_t rtw_set_802_11_infrastructure_mode(struct rtl_priv * rtlpriv, NDIS_802_11_NETWORK_INFRASTRUCTURE networktype);
+uint8_t rtw_set_802_11_remove_wep(struct rtl_priv * rtlpriv, u32 keyindex);
+uint8_t rtw_set_802_11_ssid(struct rtl_priv * rtlpriv, NDIS_802_11_SSID * ssid);
+uint8_t rtw_set_802_11_remove_key(struct rtl_priv * rtlpriv, NDIS_802_11_REMOVE_KEY * key);
+
+
+uint8_t rtw_validate_ssid(NDIS_802_11_SSID *ssid);
+
+u16 rtw_get_cur_max_rate(struct rtl_priv *rtlpriv);
+int rtw_set_scan_mode(struct rtl_priv *rtlpriv, RT_SCAN_TYPE scan_mode);
+
+#endif
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/include/rtw_io.h linux-4.9.8821au/drivers/staging/rtl8821au/include/rtw_io.h
--- linux-4.9/drivers/staging/rtl8821au/include/rtw_io.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/include/rtw_io.h	2016-12-11 19:48:25.173645047 -0600
@@ -0,0 +1,305 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+#ifndef _RTW_IO_H_
+#define _RTW_IO_H_
+
+/* ULLI : must remove this ?? */
+
+#define rtw_usb_buffer_alloc(dev, size, dma) usb_alloc_coherent((dev), (size), (in_interrupt() ? GFP_ATOMIC : GFP_KERNEL), (dma))
+#define rtw_usb_buffer_free(dev, size, addr, dma) usb_free_coherent((dev), (size), (addr), (dma))
+
+#define NUM_IOREQ		8
+
+#define MAX_PROT_SZ	(64-16)
+
+#define _IOREADY			0
+#define _IO_WAIT_COMPLETE   1
+#define _IO_WAIT_RSP        2
+
+// IO COMMAND TYPE
+#define _IOSZ_MASK_		(0x7F)
+#define _IO_WRITE_		BIT(7)
+#define _IO_FIXED_		BIT(8)
+#define _IO_BURST_		BIT(9)
+#define _IO_BYTE_		BIT(10)
+#define _IO_HW_			BIT(11)
+#define _IO_WORD_		BIT(12)
+#define _IO_SYNC_		BIT(13)
+#define _IO_CMDMASK_	(0x1F80)
+
+
+/*
+	For prompt mode accessing, caller shall free io_req
+	Otherwise, io_handler will free io_req
+*/
+
+
+
+// IO STATUS TYPE
+#define _IO_ERR_		BIT(2)
+#define _IO_SUCCESS_	BIT(1)
+#define _IO_DONE_		BIT(0)
+
+
+#define IO_RD32			(_IO_SYNC_ | _IO_WORD_)
+#define IO_RD16			(_IO_SYNC_ | _IO_HW_)
+#define IO_RD8			(_IO_SYNC_ | _IO_BYTE_)
+
+#define IO_RD32_ASYNC	(_IO_WORD_)
+#define IO_RD16_ASYNC	(_IO_HW_)
+#define IO_RD8_ASYNC	(_IO_BYTE_)
+
+#define IO_WR32			(_IO_WRITE_ | _IO_SYNC_ | _IO_WORD_)
+#define IO_WR16			(_IO_WRITE_ | _IO_SYNC_ | _IO_HW_)
+#define IO_WR8			(_IO_WRITE_ | _IO_SYNC_ | _IO_BYTE_)
+
+#define IO_WR32_ASYNC	(_IO_WRITE_ | _IO_WORD_)
+#define IO_WR16_ASYNC	(_IO_WRITE_ | _IO_HW_)
+#define IO_WR8_ASYNC	(_IO_WRITE_ | _IO_BYTE_)
+
+/*
+
+	Only Sync. burst accessing is provided.
+
+*/
+
+#define IO_WR_BURST(x)		(_IO_WRITE_ | _IO_SYNC_ | _IO_BURST_ | ( (x) & _IOSZ_MASK_))
+#define IO_RD_BURST(x)		(_IO_SYNC_ | _IO_BURST_ | ( (x) & _IOSZ_MASK_))
+
+
+
+//below is for the intf_option bit defition...
+
+#define _INTF_ASYNC_	BIT(0)	//support async io
+
+struct intf_priv;
+struct intf_hdl;
+struct io_queue;
+
+struct io_req {
+	struct list_head	list;
+	u32	addr;
+	volatile u32	val;
+	u32	command;
+	u32	status;
+	uint8_t	*pbuf;
+	struct semaphore	sema;
+
+
+	void (*_async_io_callback)(struct rtl_priv *padater, struct io_req *pio_req, uint8_t *cnxt);
+	uint8_t *cnxt;
+
+
+
+};
+
+struct reg_protocol_rd {
+
+#ifdef CONFIG_LITTLE_ENDIAN
+
+	//DW1
+	u32		NumOfTrans:4;
+	u32		Reserved1:4;
+	u32		Reserved2:24;
+	//DW2
+	u32		ByteCount:7;
+	u32		WriteEnable:1;		//0:read, 1:write
+	u32		FixOrContinuous:1;	//0:continuous, 1: Fix
+	u32		BurstMode:1;
+	u32		Byte1Access:1;
+	u32		Byte2Access:1;
+	u32		Byte4Access:1;
+	u32		Reserved3:3;
+	u32		Reserved4:16;
+	//DW3
+	u32		BusAddress;
+	//DW4
+	//u32		Value;
+#else
+
+
+//DW1
+	u32 Reserved1  :4;
+	u32 NumOfTrans :4;
+
+	u32 Reserved2  :24;
+
+	//DW2
+	u32 WriteEnable : 1;
+	u32 ByteCount :7;
+
+
+	u32 Reserved3 : 3;
+	u32 Byte4Access : 1;
+
+	u32 Byte2Access : 1;
+	u32 Byte1Access : 1;
+	u32 BurstMode :1 ;
+	u32 FixOrContinuous : 1;
+
+	u32 Reserved4 : 16;
+
+	//DW3
+	u32		BusAddress;
+
+	//DW4
+	//u32		Value;
+
+#endif
+
+};
+
+
+struct reg_protocol_wt {
+
+
+#ifdef CONFIG_LITTLE_ENDIAN
+
+	//DW1
+	u32		NumOfTrans:4;
+	u32		Reserved1:4;
+	u32		Reserved2:24;
+	//DW2
+	u32		ByteCount:7;
+	u32		WriteEnable:1;		//0:read, 1:write
+	u32		FixOrContinuous:1;	//0:continuous, 1: Fix
+	u32		BurstMode:1;
+	u32		Byte1Access:1;
+	u32		Byte2Access:1;
+	u32		Byte4Access:1;
+	u32		Reserved3:3;
+	u32		Reserved4:16;
+	//DW3
+	u32		BusAddress;
+	//DW4
+	u32		Value;
+
+#else
+	//DW1
+	u32 Reserved1  :4;
+	u32 NumOfTrans :4;
+
+	u32 Reserved2  :24;
+
+	//DW2
+	u32 WriteEnable : 1;
+	u32 ByteCount :7;
+
+	u32 Reserved3 : 3;
+	u32 Byte4Access : 1;
+
+	u32 Byte2Access : 1;
+	u32 Byte1Access : 1;
+	u32 BurstMode :1 ;
+	u32 FixOrContinuous : 1;
+
+	u32 Reserved4 : 16;
+
+	//DW3
+	u32		BusAddress;
+
+	//DW4
+	u32		Value;
+
+#endif
+
+};
+
+
+
+/*
+Below is the data structure used by _io_handler
+
+*/
+
+extern uint ioreq_flush(struct rtl_priv *rtlpriv, struct io_queue *ioqueue);
+extern void sync_ioreq_enqueue(struct io_req *preq,struct io_queue *ioqueue);
+extern uint sync_ioreq_flush(struct rtl_priv *rtlpriv, struct io_queue *ioqueue);
+
+
+extern uint free_ioreq(struct io_req *preq, struct io_queue *pio_queue);
+extern struct io_req *alloc_ioreq(struct io_queue *pio_q);
+
+extern uint register_intf_hdl(uint8_t *dev, struct intf_hdl *pintfhdl);
+extern void unregister_intf_hdl(struct intf_hdl *pintfhdl);
+
+extern void _rtw_attrib_read(struct rtl_priv *rtlpriv, u32 addr, u32 cnt, uint8_t *pmem);
+extern void _rtw_attrib_write(struct rtl_priv *rtlpriv, u32 addr, u32 cnt, uint8_t *pmem);
+
+extern void rtw_write_scsi(struct rtl_priv *rtlpriv, u32 cnt, uint8_t *pmem);
+
+//ioreq
+extern void ioreq_read8(struct rtl_priv *rtlpriv, u32 addr, uint8_t *pval);
+extern void ioreq_read16(struct rtl_priv *rtlpriv, u32 addr, u16 *pval);
+extern void ioreq_read32(struct rtl_priv *rtlpriv, u32 addr, u32 *pval);
+extern void ioreq_write8(struct rtl_priv *rtlpriv, u32 addr, uint8_t val);
+extern void ioreq_write16(struct rtl_priv *rtlpriv, u32 addr, u16 val);
+extern void ioreq_write32(struct rtl_priv *rtlpriv, u32 addr, u32 val);
+
+
+extern uint async_read8(struct rtl_priv *rtlpriv, u32 addr, uint8_t *pbuff,
+	void (*_async_io_callback)(struct rtl_priv *padater, struct io_req *pio_req, uint8_t *cnxt), uint8_t *cnxt);
+extern uint async_read16(struct rtl_priv *rtlpriv, u32 addr,  uint8_t *pbuff,
+	void (*_async_io_callback)(struct rtl_priv *padater, struct io_req *pio_req, uint8_t *cnxt), uint8_t *cnxt);
+extern uint async_read32(struct rtl_priv *rtlpriv, u32 addr,  uint8_t *pbuff,
+	void (*_async_io_callback)(struct rtl_priv *padater, struct io_req *pio_req, uint8_t *cnxt), uint8_t *cnxt);
+
+extern void async_read_mem(struct rtl_priv *rtlpriv, u32 addr, u32 cnt, uint8_t *pmem);
+extern void async_read_port(struct rtl_priv *rtlpriv, u32 addr, u32 cnt, uint8_t *pmem);
+
+extern void async_write8(struct rtl_priv *rtlpriv, u32 addr, uint8_t val,
+	void (*_async_io_callback)(struct rtl_priv *padater, struct io_req *pio_req, uint8_t *cnxt), uint8_t *cnxt);
+extern void async_write16(struct rtl_priv *rtlpriv, u32 addr, u16 val,
+	void (*_async_io_callback)(struct rtl_priv *padater, struct io_req *pio_req, uint8_t *cnxt), uint8_t *cnxt);
+extern void async_write32(struct rtl_priv *rtlpriv, u32 addr, u32 val,
+	void (*_async_io_callback)(struct rtl_priv *padater, struct io_req *pio_req, uint8_t *cnxt), uint8_t *cnxt);
+
+extern void async_write_mem(struct rtl_priv *rtlpriv, u32 addr, u32 cnt, uint8_t *pmem);
+extern void async_write_port(struct rtl_priv *rtlpriv, u32 addr, u32 cnt, uint8_t *pmem);
+
+extern uint alloc_io_queue(struct rtl_priv *rtlpriv);
+extern void free_io_queue(struct rtl_priv *rtlpriv);
+extern void async_bus_io(struct io_queue *pio_q);
+extern void bus_sync_io(struct io_queue *pio_q);
+extern u32 _ioreq2rwmem(struct io_queue *pio_q);
+extern void dev_power_down(struct rtl_priv * rtlpriv, uint8_t bpwrup);
+
+/*
+#define RTL_R8(reg)		rtw_read8(rtlpriv, reg)
+#define RTL_R16(reg)            rtl_read_word(rtlpriv, reg)
+#define RTL_R32(reg)            rtl_read_dword(rtlpriv, reg)
+#define RTL_W8(reg, val8)       rtl_write_byte(rtlpriv, reg, val8)
+#define RTL_W16(reg, val16)     rtl_write_word(rtlpriv, reg, val16)
+#define RTL_W32(reg, val32)     rtl_write_dword(rtlpriv, reg, val32)
+*/
+
+/*
+#define RTL_W8_ASYNC(reg, val8) rtw_write32_async(rtlpriv, reg, val8)
+#define RTL_W16_ASYNC(reg, val16) rtw_write32_async(rtlpriv, reg, val16)
+#define RTL_W32_ASYNC(reg, val32) rtw_write32_async(rtlpriv, reg, val32)
+
+#define RTL_WRITE_BB(reg, val32)	phy_SetUsbBBReg(rtlpriv, reg, val32)
+#define RTL_READ_BB(reg)	phy_QueryUsbBBReg(rtlpriv, reg)
+*/
+
+
+#endif	//_RTL8711_IO_H_
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/include/rtw_mlme_ext.h linux-4.9.8821au/drivers/staging/rtl8821au/include/rtw_mlme_ext.h
--- linux-4.9/drivers/staging/rtl8821au/include/rtw_mlme_ext.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/include/rtw_mlme_ext.h	2016-12-11 19:48:25.173645047 -0600
@@ -0,0 +1,813 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTW_MLME_EXT_H_
+#define __RTW_MLME_EXT_H_
+
+#include <rtw_cmd.h>
+
+//	Commented by Albert 20101105
+//	Increase the SURVEY_TO value from 100 to 150  ( 100ms to 150ms )
+//	The Realtek 8188CE SoftAP will spend around 100ms to send the probe response after receiving the probe request.
+//	So, this driver tried to extend the dwell time for each scanning channel.
+//	This will increase the chance to receive the probe response from SoftAP.
+
+#define SURVEY_TO		(100)
+#define REAUTH_TO		(300) //(50)
+#define REASSOC_TO		(300) //(50)
+//#define DISCONNECT_TO	(3000)
+#define ADDBA_TO			(2000)
+
+#define LINKED_TO (1) //unit:2 sec, 1x2=2 sec
+
+#define REAUTH_LIMIT	(4)
+#define REASSOC_LIMIT	(4)
+#define READDBA_LIMIT	(2)
+
+	#define ROAMING_LIMIT	8
+//#define	IOCMD_REG0		0x10250370
+//#define	IOCMD_REG1		0x10250374
+//#define	IOCMD_REG2		0x10250378
+
+//#define	FW_DYNAMIC_FUN_SWITCH	0x10250364
+
+//#define	WRITE_BB_CMD		0xF0000001
+//#define	SET_CHANNEL_CMD	0xF3000000
+//#define	UPDATE_RA_CMD	0xFD0000A2
+
+// ====== ODM_ABILITY_E ========
+// BB ODM section BIT 0-15
+#define	DYNAMIC_BB_DIG				BIT(0)
+#define	DYNAMIC_BB_RA_MASK			BIT(1)
+#define	DYNAMIC_BB_DYNAMIC_TXPWR	BIT(2)
+#define	DYNAMIC_BB_BB_FA_CNT			BIT(3)
+
+#define 	DYNAMIC_BB_RSSI_MONITOR		BIT(4)
+#define 	DYNAMIC_BB_CCK_PD			BIT(5)
+#define 	DYNAMIC_BB_ANT_DIV			BIT(6)
+#define 	DYNAMIC_BB_PWR_SAVE			BIT(7)
+#define 	DYNAMIC_BB_PWR_TRAIN			BIT(8)
+#define 	DYNAMIC_BB_RATE_ADAPTIVE		BIT(9)
+#define 	DYNAMIC_BB_PATH_DIV			BIT(10)
+#define 	DYNAMIC_BB_PSD				BIT(11)
+
+// MAC DM section BIT 16-23
+#define 	DYNAMIC_MAC_EDCA_TURBO		BIT(16)
+#define 	DYNAMIC_MAC_EARLY_MODE		BIT(17)
+
+// RF ODM section BIT 24-31
+#define 	DYNAMIC_RF_TX_PWR_TRACK		BIT(24)
+#define 	DYNAMIC_RF_RX_GAIN_TRACK		BIT(25)
+#define 	DYNAMIC_RF_CALIBRATION		BIT(26)
+
+#define 	DYNAMIC_ALL_FUNC_ENABLE		0xFFFFFFF
+
+#define _HW_STATE_NOLINK_		0x00
+#define _HW_STATE_ADHOC_		0x01
+#define _HW_STATE_STATION_ 	0x02
+#define _HW_STATE_AP_			0x03
+
+
+#define		_1M_RATE_	0
+#define		_2M_RATE_	1
+#define		_5M_RATE_	2
+#define		_11M_RATE_	3
+#define		_6M_RATE_	4
+#define		_9M_RATE_	5
+#define		_12M_RATE_	6
+#define		_18M_RATE_	7
+#define		_24M_RATE_	8
+#define		_36M_RATE_	9
+#define		_48M_RATE_	10
+#define		_54M_RATE_	11
+
+
+extern unsigned char RTW_WPA_OUI[];
+extern unsigned char WMM_OUI[];
+extern unsigned char WPS_OUI[];
+extern unsigned char WFD_OUI[];
+extern unsigned char P2P_OUI[];
+
+extern unsigned char WMM_INFO_OUI[];
+extern unsigned char WMM_PARA_OUI[];
+
+
+//
+// Channel Plan Type.
+// Note:
+//	We just add new channel plan when the new channel plan is different from any of the following
+//	channel plan.
+//	If you just wnat to customize the acitions(scan period or join actions) about one of the channel plan,
+//	customize them in RT_CHANNEL_INFO in the RT_CHANNEL_LIST.
+//
+typedef enum _RT_CHANNEL_DOMAIN
+{
+	//===== old channel plan mapping =====//
+	RT_CHANNEL_DOMAIN_FCC = 0x00,
+	RT_CHANNEL_DOMAIN_IC = 0x01,
+	RT_CHANNEL_DOMAIN_ETSI = 0x02,
+	RT_CHANNEL_DOMAIN_SPAIN = 0x03,
+	RT_CHANNEL_DOMAIN_FRANCE = 0x04,
+	RT_CHANNEL_DOMAIN_MKK = 0x05,
+	RT_CHANNEL_DOMAIN_MKK1 = 0x06,
+	RT_CHANNEL_DOMAIN_ISRAEL = 0x07,
+	RT_CHANNEL_DOMAIN_TELEC = 0x08,
+	RT_CHANNEL_DOMAIN_GLOBAL_DOAMIN = 0x09,
+	RT_CHANNEL_DOMAIN_WORLD_WIDE_13 = 0x0A,
+	RT_CHANNEL_DOMAIN_TAIWAN = 0x0B,
+	RT_CHANNEL_DOMAIN_CHINA = 0x0C,
+	RT_CHANNEL_DOMAIN_SINGAPORE_INDIA_MEXICO = 0x0D,
+	RT_CHANNEL_DOMAIN_KOREA = 0x0E,
+	RT_CHANNEL_DOMAIN_TURKEY = 0x0F,
+	RT_CHANNEL_DOMAIN_JAPAN = 0x10,
+	RT_CHANNEL_DOMAIN_FCC_NO_DFS = 0x11,
+	RT_CHANNEL_DOMAIN_JAPAN_NO_DFS = 0x12,
+	RT_CHANNEL_DOMAIN_WORLD_WIDE_5G = 0x13,
+	RT_CHANNEL_DOMAIN_TAIWAN_NO_DFS = 0x14,
+
+	//===== new channel plan mapping, (2GDOMAIN_5GDOMAIN) =====//
+	RT_CHANNEL_DOMAIN_WORLD_NULL = 0x20,
+	RT_CHANNEL_DOMAIN_ETSI1_NULL = 0x21,
+	RT_CHANNEL_DOMAIN_FCC1_NULL = 0x22,
+	RT_CHANNEL_DOMAIN_MKK1_NULL = 0x23,
+	RT_CHANNEL_DOMAIN_ETSI2_NULL = 0x24,
+	RT_CHANNEL_DOMAIN_FCC1_FCC1 = 0x25,
+	RT_CHANNEL_DOMAIN_WORLD_ETSI1 = 0x26,
+	RT_CHANNEL_DOMAIN_MKK1_MKK1 = 0x27,
+	RT_CHANNEL_DOMAIN_WORLD_KCC1 = 0x28,
+	RT_CHANNEL_DOMAIN_WORLD_FCC2 = 0x29,
+	RT_CHANNEL_DOMAIN_WORLD_FCC3 = 0x30,
+	RT_CHANNEL_DOMAIN_WORLD_FCC4 = 0x31,
+	RT_CHANNEL_DOMAIN_WORLD_FCC5 = 0x32,
+	RT_CHANNEL_DOMAIN_WORLD_FCC6 = 0x33,
+	RT_CHANNEL_DOMAIN_FCC1_FCC7 = 0x34,
+	RT_CHANNEL_DOMAIN_WORLD_ETSI2 = 0x35,
+	RT_CHANNEL_DOMAIN_WORLD_ETSI3 = 0x36,
+	RT_CHANNEL_DOMAIN_MKK1_MKK2 = 0x37,
+	RT_CHANNEL_DOMAIN_MKK1_MKK3 = 0x38,
+	RT_CHANNEL_DOMAIN_FCC1_NCC1 = 0x39,
+	RT_CHANNEL_DOMAIN_FCC1_NCC2 = 0x40,
+	RT_CHANNEL_DOMAIN_GLOBAL_DOAMIN_2G = 0x41,
+	//===== Add new channel plan above this line===============//
+	RT_CHANNEL_DOMAIN_MAX,
+	RT_CHANNEL_DOMAIN_REALTEK_DEFINE = 0x7F,
+}RT_CHANNEL_DOMAIN, *PRT_CHANNEL_DOMAIN;
+
+typedef enum _RT_CHANNEL_DOMAIN_2G
+{
+	RT_CHANNEL_DOMAIN_2G_WORLD = 0x00,		//Worldwird 13
+	RT_CHANNEL_DOMAIN_2G_ETSI1 = 0x01,		//Europe
+	RT_CHANNEL_DOMAIN_2G_FCC1 = 0x02,		//US
+	RT_CHANNEL_DOMAIN_2G_MKK1 = 0x03,		//Japan
+	RT_CHANNEL_DOMAIN_2G_ETSI2 = 0x04,		//France
+	RT_CHANNEL_DOMAIN_2G_NULL = 0x05,
+	//===== Add new channel plan above this line===============//
+	RT_CHANNEL_DOMAIN_2G_MAX,
+}RT_CHANNEL_DOMAIN_2G, *PRT_CHANNEL_DOMAIN_2G;
+
+typedef enum _RT_CHANNEL_DOMAIN_5G
+{
+	RT_CHANNEL_DOMAIN_5G_NULL = 0x00,
+	RT_CHANNEL_DOMAIN_5G_ETSI1 = 0x01,		//Europe
+	RT_CHANNEL_DOMAIN_5G_ETSI2 = 0x02,		//Australia, New Zealand
+	RT_CHANNEL_DOMAIN_5G_ETSI3 = 0x03,		//Russia
+	RT_CHANNEL_DOMAIN_5G_FCC1 = 0x04,		//US
+	RT_CHANNEL_DOMAIN_5G_FCC2 = 0x05,		//FCC o/w DFS Channels
+	RT_CHANNEL_DOMAIN_5G_FCC3 = 0x06,		//India, Mexico
+	RT_CHANNEL_DOMAIN_5G_FCC4 = 0x07,		//Venezuela
+	RT_CHANNEL_DOMAIN_5G_FCC5 = 0x08,		//China
+	RT_CHANNEL_DOMAIN_5G_FCC6 = 0x09,		//Israel
+	RT_CHANNEL_DOMAIN_5G_FCC7_IC1 = 0x0A,	//US, Canada
+	RT_CHANNEL_DOMAIN_5G_KCC1 = 0x0B,		//Korea
+	RT_CHANNEL_DOMAIN_5G_MKK1 = 0x0C,		//Japan
+	RT_CHANNEL_DOMAIN_5G_MKK2 = 0x0D,		//Japan (W52, W53)
+	RT_CHANNEL_DOMAIN_5G_MKK3 = 0x0E,		//Japan (W56)
+	RT_CHANNEL_DOMAIN_5G_NCC1 = 0x0F,		//Taiwan
+	RT_CHANNEL_DOMAIN_5G_NCC2 = 0x10,		//Taiwan o/w DFS
+	//===== Add new channel plan above this line===============//
+	//===== Driver Self Defined =====//
+	RT_CHANNEL_DOMAIN_5G_FCC = 0x11,
+	RT_CHANNEL_DOMAIN_5G_JAPAN_NO_DFS = 0x12,
+	RT_CHANNEL_DOMAIN_5G_FCC4_NO_DFS = 0x13,
+	RT_CHANNEL_DOMAIN_5G_MAX,
+}RT_CHANNEL_DOMAIN_5G, *PRT_CHANNEL_DOMAIN_5G;
+
+typedef struct _RT_CHANNEL_PLAN_MAP
+{
+	unsigned char	Index2G;
+	unsigned char	Index5G;
+}RT_CHANNEL_PLAN_MAP, *PRT_CHANNEL_PLAN_MAP;
+
+enum Associated_AP
+{
+	atherosAP	= 0,
+	broadcomAP	= 1,
+	ciscoAP		= 2,
+	marvellAP	= 3,
+	ralinkAP	= 4,
+	realtekAP	= 5,
+	airgocapAP 	= 6,
+	unknownAP	= 7,
+	maxAP,
+};
+
+typedef enum _HT_IOT_PEER
+{
+	HT_IOT_PEER_UNKNOWN 			= 0,
+	HT_IOT_PEER_REALTEK 			= 1,
+	HT_IOT_PEER_REALTEK_92SE 		= 2,
+	HT_IOT_PEER_BROADCOM 		= 3,
+	HT_IOT_PEER_RALINK 			= 4,
+	HT_IOT_PEER_ATHEROS 			= 5,
+	HT_IOT_PEER_CISCO 				= 6,
+	HT_IOT_PEER_MERU 				= 7,
+	HT_IOT_PEER_MARVELL 			= 8,
+	HT_IOT_PEER_REALTEK_SOFTAP 	= 9,// peer is RealTek SOFT_AP, by Bohn, 2009.12.17
+	HT_IOT_PEER_SELF_SOFTAP 		= 10, // Self is SoftAP
+	HT_IOT_PEER_AIRGO 				= 11,
+	HT_IOT_PEER_INTEL 				= 12,
+	HT_IOT_PEER_RTK_APCLIENT 		= 13,
+	HT_IOT_PEER_REALTEK_81XX 		= 14,
+	HT_IOT_PEER_REALTEK_WOW 		= 15,
+	HT_IOT_PEER_REALTEK_JAGUAR_BCUTAP = 16,
+	HT_IOT_PEER_REALTEK_JAGUAR_CCUTAP = 17,
+	HT_IOT_PEER_MAX 				= 18
+}HT_IOT_PEER_E, *PHTIOT_PEER_E;
+
+
+enum SCAN_STATE
+{
+	SCAN_DISABLE = 0,
+	SCAN_START = 1,
+	SCAN_TXNULL = 2,
+	SCAN_PROCESS = 3,
+	SCAN_COMPLETE = 4,
+	SCAN_STATE_MAX,
+};
+
+struct mlme_handler {
+	unsigned int   num;
+	char* str;
+	unsigned int (*func)(struct rtl_priv *rtlpriv, struct recv_frame *precv_frame);
+};
+
+struct action_handler {
+	unsigned int   num;
+	char* str;
+	unsigned int (*func)(struct rtl_priv *rtlpriv, struct recv_frame *precv_frame);
+};
+
+struct	ss_res
+{
+	int	state;
+	int	bss_cnt;
+	int	channel_idx;
+	int	scan_mode;
+	uint8_t ssid_num;
+	uint8_t ch_num;
+	NDIS_802_11_SSID ssid[RTW_SSID_SCAN_AMOUNT];
+	struct rtw_ieee80211_channel ch[RTW_CHANNEL_SCAN_AMOUNT];
+};
+
+//#define AP_MODE				0x0C
+//#define STATION_MODE	0x08
+//#define AD_HOC_MODE		0x04
+//#define NO_LINK_MODE	0x00
+
+#define 	WIFI_FW_NULL_STATE			_HW_STATE_NOLINK_
+#define	WIFI_FW_STATION_STATE		_HW_STATE_STATION_
+#define	WIFI_FW_AP_STATE				_HW_STATE_AP_
+#define	WIFI_FW_ADHOC_STATE			_HW_STATE_ADHOC_
+
+#define	WIFI_FW_AUTH_NULL			0x00000100
+#define	WIFI_FW_AUTH_STATE			0x00000200
+#define	WIFI_FW_AUTH_SUCCESS			0x00000400
+
+#define	WIFI_FW_ASSOC_STATE			0x00002000
+#define	WIFI_FW_ASSOC_SUCCESS		0x00004000
+
+#define	WIFI_FW_LINKING_STATE		(WIFI_FW_AUTH_NULL | WIFI_FW_AUTH_STATE | WIFI_FW_AUTH_SUCCESS |WIFI_FW_ASSOC_STATE)
+
+
+struct FW_Sta_Info
+{
+	struct sta_info	*psta;
+	u32	status;
+	u32	rx_pkt;
+	u32	retry;
+	NDIS_802_11_RATES_EX  SupportedRates;
+};
+
+/*
+ * Usage:
+ * When one iface acted as AP mode and the other iface is STA mode and scanning,
+ * it should switch back to AP's operating channel periodically.
+ * Parameters info:
+ * When the driver scanned RTW_SCAN_NUM_OF_CH channels, it would switch back to AP's operating channel for
+ * RTW_STAY_AP_CH_MILLISECOND * SURVEY_TO milliseconds.
+ * Example:
+ * For chip supports 2.4G + 5GHz and AP mode is operating in channel 1,
+ * RTW_SCAN_NUM_OF_CH is 8, RTW_STAY_AP_CH_MILLISECOND is 3 and SURVEY_TO is 100.
+ * When it's STA mode gets set_scan command,
+ * it would
+ * 1. Doing the scan on channel 1.2.3.4.5.6.7.8
+ * 2. Back to channel 1 for 300 milliseconds
+ * 3. Go through doing site survey on channel 9.10.11.36.40.44.48.52
+ * 4. Back to channel 1 for 300 milliseconds
+ * 5. ... and so on, till survey done.
+ */
+
+struct mlme_ext_info
+{
+	u32	state;
+	u32	reauth_count;
+	u32	reassoc_count;
+	u32	link_count;
+	u32	auth_seq;
+	u32	auth_algo;	// 802.11 auth, could be open, shared, auto
+	u32	authModeToggle;
+	u32	enc_algo;//encrypt algorithm;
+	u32	key_index;	// this is only valid for legendary wep, 0~3 for key id.
+	u32	iv;
+	uint8_t	chg_txt[128];
+	u16	aid;
+	u16	capability;
+	uint8_t	assoc_AP_vendor;
+	uint8_t	slotTime;
+	uint8_t	preamble_mode;
+	uint8_t	WMM_enable;
+	uint8_t	ERP_enable;
+	uint8_t	ERP_IE;
+	uint8_t	HT_enable;
+	uint8_t	HT_caps_enable;
+	uint8_t	HT_info_enable;
+	uint8_t	HT_protection;
+	uint8_t	turboMode_cts2self;
+	uint8_t	turboMode_rtsen;
+	uint8_t	SM_PS;
+	uint8_t	agg_enable_bitmap;
+	uint8_t	ADDBA_retry_count;
+	uint8_t	candidate_tid_bitmap;
+	uint8_t	dialogToken;
+	// Accept ADDBA Request
+	bool bAcceptAddbaReq;
+	uint8_t	bwmode_updated;
+	uint8_t	hidden_ssid_mode;
+	uint8_t	VHT_enable;
+
+	struct ADDBA_request		ADDBA_req;
+	struct WMM_para_element	WMM_param;
+	struct HT_caps_element	HT_caps;
+	struct HT_info_element		HT_info;
+	WLAN_BSSID_EX			network;//join network or bss_network, if in ap mode, it is the same to cur_network.network
+	struct FW_Sta_Info		FW_sta_info[NUM_STA];
+};
+
+// The channel information about this channel including joining, scanning, and power constraints.
+typedef struct _RT_CHANNEL_INFO
+{
+	uint8_t				ChannelNum;		// The channel number.
+	RT_SCAN_TYPE	ScanType;		// Scan type such as passive or active scan.
+	//u16				ScanPeriod;		// Listen time in millisecond in this channel.
+	//int32_t				MaxTxPwrDbm;	// Max allowed tx power.
+	//u32				ExInfo;			// Extended Information for this channel.
+}RT_CHANNEL_INFO, *PRT_CHANNEL_INFO;
+
+int rtw_ch_set_search_ch(RT_CHANNEL_INFO *ch_set, const u32 ch);
+
+// P2P_MAX_REG_CLASSES - Maximum number of regulatory classes
+#define P2P_MAX_REG_CLASSES 10
+
+// P2P_MAX_REG_CLASS_CHANNELS - Maximum number of channels per regulatory class
+#define P2P_MAX_REG_CLASS_CHANNELS 20
+
+//  struct p2p_channels - List of supported channels
+struct p2p_channels {
+	// struct p2p_reg_class - Supported regulatory class
+	struct p2p_reg_class {
+		// reg_class - Regulatory class (IEEE 802.11-2007, Annex J)
+		uint8_t reg_class;
+
+		// channel - Supported channels
+		uint8_t channel[P2P_MAX_REG_CLASS_CHANNELS];
+
+		// channels - Number of channel entries in use
+		size_t channels;
+	} reg_class[P2P_MAX_REG_CLASSES];
+
+	// reg_classes - Number of reg_class entries in use
+	size_t reg_classes;
+};
+
+struct p2p_oper_class_map {
+	enum hw_mode {IEEE80211G,IEEE80211A} mode;
+	uint8_t op_class;
+	uint8_t min_chan;
+	uint8_t max_chan;
+	uint8_t inc;
+	enum { BW20, BW40PLUS, BW40MINUS } bw;
+};
+
+struct mlme_ext_priv
+{
+	struct rtl_priv	*rtlpriv;
+	uint8_t	mlmeext_init;
+	atomic_t event_seq;
+	u16	mgnt_seq;
+
+	//struct fw_priv 	fwpriv;
+
+	unsigned char	cur_channel;
+	unsigned char	cur_bwmode;
+	unsigned char	cur_ch_offset;//PRIME_CHNL_OFFSET
+	unsigned char	cur_wireless_mode;	// NETWORK_TYPE
+
+	unsigned char	max_chan_nums;
+	RT_CHANNEL_INFO		channel_set[MAX_CHANNEL_NUM];
+	struct p2p_channels channel_list;
+	unsigned char	basicrate[NumRates];
+	unsigned char	datarate[NumRates];
+
+	struct ss_res		sitesurvey_res;
+	struct mlme_ext_info	mlmext_info;//for sta/adhoc mode, including current scanning/connecting/connected related info.
+                                                     //for ap mode, network includes ap's cap_info
+	struct timer_list	survey_timer;
+	struct timer_list	link_timer;
+	//_timer		ADDBA_timer;
+	u16			chan_scan_time;
+
+	uint8_t	scan_abort;
+	uint8_t	tx_rate; // TXRATE when USERATE is set.
+
+	u32	retry; //retry for issue probereq
+
+	u64 TSFValue;
+
+#ifdef CONFIG_AP_MODE
+	unsigned char bstart_bss;
+#endif
+
+#ifdef CONFIG_80211D
+	uint8_t update_channel_plan_by_ap_done;
+#endif
+	//recv_decache check for Action_public frame
+	uint8_t action_public_dialog_token;
+	u16 	 action_public_rxseq;
+
+#ifdef DBG_FIXED_CHAN
+	uint8_t fixed_chan;
+#endif
+
+};
+
+int init_mlme_ext_priv(struct rtl_priv* rtlpriv);
+int init_hw_mlme_ext(struct rtl_priv *rtlpriv);
+void free_mlme_ext_priv (struct mlme_ext_priv *pmlmeext);
+extern void init_mlme_ext_timer(struct rtl_priv *rtlpriv);
+extern void init_addba_retry_timer(struct rtl_priv *rtlpriv, struct sta_info *psta);
+extern struct xmit_frame *alloc_mgtxmitframe(struct xmit_priv *pxmitpriv);
+struct xmit_frame *alloc_mgtxmitframe_once(struct xmit_priv *pxmitpriv);
+
+//void fill_fwpriv(struct rtl_priv * rtlpriv, struct fw_priv *pfwpriv);
+
+unsigned char networktype_to_raid(struct rtl_priv *rtlpriv,unsigned char network_type);
+unsigned char networktype_to_raid_ex(struct rtl_priv *rtlpriv,unsigned char network_type);
+
+uint8_t judge_network_type(struct rtl_priv *rtlpriv, unsigned char *rate, int ratelen);
+void get_rate_set(struct rtl_priv *rtlpriv, unsigned char *pbssrate, int *bssrate_len);
+void UpdateBrateTbl(struct rtl_priv *rtlpriv,uint8_t *mBratesOS);
+void UpdateBrateTblForSoftAP(uint8_t *bssrateset, u32 bssratelen);
+void change_band_update_ie(struct rtl_priv *rtlpriv, WLAN_BSSID_EX *pnetwork);
+
+//void Set_NETYPE1_MSR(struct rtl_priv *rtlpriv, uint8_t type);
+//void Set_NETYPE0_MSR(struct rtl_priv *rtlpriv, uint8_t type);
+
+uint8_t	rtw_get_center_ch(uint8_t channel, uint8_t chnl_bw, uint8_t chnl_offset);
+void set_channel_bwmode(struct rtl_priv *rtlpriv, unsigned char channel, unsigned char channel_offset, unsigned short bwmode);
+void SelectChannel(struct rtl_priv *rtlpriv, unsigned char channel);
+void SetBWMode(struct rtl_priv *rtlpriv, unsigned short bwmode, unsigned char channel_offset);
+
+unsigned int decide_wait_for_beacon_timeout(unsigned int bcn_interval);
+
+int allocate_fw_sta_entry(struct rtl_priv *rtlpriv);
+void flush_all_cam_entry(struct rtl_priv *rtlpriv);
+
+bool IsLegal5GChannel(struct rtl_priv *rtlpriv, uint8_t channel);
+
+void site_survey(struct rtl_priv *rtlpriv);
+uint8_t collect_bss_info(struct rtl_priv *rtlpriv, struct recv_frame *precv_frame, WLAN_BSSID_EX *bssid);
+void update_network(WLAN_BSSID_EX *dst, WLAN_BSSID_EX *src, struct rtl_priv * rtlpriv, bool update_ie);
+
+int get_bsstype(unsigned short capability);
+u8* get_my_bssid(WLAN_BSSID_EX *pnetwork);
+u16 get_beacon_interval(WLAN_BSSID_EX *bss);
+
+int is_client_associated_to_ap(struct rtl_priv *rtlpriv);
+int is_client_associated_to_ibss(struct rtl_priv *rtlpriv);
+int is_IBSS_empty(struct rtl_priv *rtlpriv);
+
+unsigned char check_assoc_AP(uint8_t *pframe, uint len);
+
+int WMM_param_handler(struct rtl_priv *rtlpriv, PNDIS_802_11_VARIABLE_IEs	pIE);
+void WMMOnAssocRsp(struct rtl_priv *rtlpriv);
+
+void HT_caps_handler(struct rtl_priv *rtlpriv, PNDIS_802_11_VARIABLE_IEs pIE);
+void HT_info_handler(struct rtl_priv *rtlpriv, PNDIS_802_11_VARIABLE_IEs pIE);
+void HTOnAssocRsp(struct rtl_priv *rtlpriv);
+
+void ERP_IE_handler(struct rtl_priv *rtlpriv, PNDIS_802_11_VARIABLE_IEs pIE);
+void VCS_update(struct rtl_priv *rtlpriv, struct sta_info *psta);
+
+void update_beacon_info(struct rtl_priv *rtlpriv, uint8_t *pframe, uint len, struct sta_info *psta);
+int rtw_check_bcn_info(struct rtl_priv *rtlpriv, uint8_t *pframe, u32 packet_len);
+#ifdef CONFIG_DFS
+void process_csa_ie(struct rtl_priv *rtlpriv, uint8_t *pframe, uint len);
+#endif //CONFIG_DFS
+void update_IOT_info(struct rtl_priv *rtlpriv);
+void update_capinfo(struct rtl_priv *rtlpriv, u16 updateCap);
+void update_wireless_mode(struct rtl_priv * rtlpriv);
+void update_tx_basic_rate(struct rtl_priv *rtlpriv, uint8_t modulation);
+void update_bmc_sta_support_rate(struct rtl_priv *rtlpriv, u32 mac_id);
+int update_sta_support_rate(struct rtl_priv *rtlpriv, u8* pvar_ie, uint var_ie_len, int cam_idx);
+
+//for sta/adhoc mode
+void update_sta_info(struct rtl_priv *rtlpriv, struct sta_info *psta);
+unsigned int update_basic_rate(unsigned char *ptn, unsigned int ptn_sz);
+unsigned int update_supported_rate(unsigned char *ptn, unsigned int ptn_sz);
+unsigned int update_MCS_rate(struct HT_caps_element *pHT_caps);
+void Update_RA_Entry(struct rtl_priv *rtlpriv, struct sta_info *psta);
+void set_sta_rate(struct rtl_priv *rtlpriv, struct sta_info *psta);
+
+unsigned int receive_disconnect(struct rtl_priv *rtlpriv, unsigned char *MacAddr, unsigned short reason);
+
+unsigned char get_highest_rate_idx(u32 mask);
+int support_short_GI(struct rtl_priv *rtlpriv, struct HT_caps_element *pHT_caps);
+unsigned int is_ap_in_tkip(struct rtl_priv *rtlpriv);
+unsigned int is_ap_in_wep(struct rtl_priv *rtlpriv);
+unsigned int should_forbid_n_rate(struct rtl_priv * rtlpriv);
+
+extern uint rtw_get_camid(uint macid);
+extern void rtw_alloc_macid(struct rtl_priv *rtlpriv, struct sta_info *psta);
+extern void rtw_release_macid(struct rtl_priv *rtlpriv, struct sta_info *psta);
+
+void report_join_res(struct rtl_priv *rtlpriv, int res);
+void report_survey_event(struct rtl_priv *rtlpriv, struct recv_frame *precv_frame);
+void report_surveydone_event(struct rtl_priv *rtlpriv);
+void report_del_sta_event(struct rtl_priv *rtlpriv, unsigned char* MacAddr, unsigned short reason);
+void report_add_sta_event(struct rtl_priv *rtlpriv, unsigned char* MacAddr, int cam_idx);
+
+void beacon_timing_control(struct rtl_priv *rtlpriv);
+extern uint8_t set_tx_beacon_cmd(struct rtl_priv*rtlpriv);
+unsigned int setup_beacon_frame(struct rtl_priv *rtlpriv, unsigned char *beacon_frame);
+void update_mgnt_tx_rate(struct rtl_priv *rtlpriv, uint8_t rate);
+void update_mgntframe_attrib(struct rtl_priv *rtlpriv, struct tx_pkt_attrib *pattrib);
+void update_mgntframe_attrib_addr(struct rtl_priv *rtlpriv, struct xmit_frame *pmgntframe);
+void dump_mgntframe(struct rtl_priv *rtlpriv, struct xmit_frame *pmgntframe);
+int32_t dump_mgntframe_and_wait(struct rtl_priv *rtlpriv, struct xmit_frame *pmgntframe, int timeout_ms);
+int32_t dump_mgntframe_and_wait_ack(struct rtl_priv *rtlpriv, struct xmit_frame *pmgntframe);
+
+void issue_beacon(struct rtl_priv *rtlpriv, int timeout_ms);
+void issue_probersp(struct rtl_priv *rtlpriv, unsigned char *da, uint8_t is_valid_p2p_probereq);
+void issue_assocreq(struct rtl_priv *rtlpriv);
+void issue_asocrsp(struct rtl_priv *rtlpriv, unsigned short status, struct sta_info *pstat, int pkt_type);
+void issue_auth(struct rtl_priv *rtlpriv, struct sta_info *psta, unsigned short status);
+void issue_probereq(struct rtl_priv *rtlpriv, NDIS_802_11_SSID *pssid, uint8_t *da);
+int32_t issue_probereq_ex(struct rtl_priv *rtlpriv, NDIS_802_11_SSID *pssid, u8* da, int try_cnt, int wait_ms);
+int issue_nulldata(struct rtl_priv *rtlpriv, unsigned char *da, unsigned int power_mode, int try_cnt, int wait_ms);
+int issue_qos_nulldata(struct rtl_priv *rtlpriv, unsigned char *da, u16 tid, int try_cnt, int wait_ms);
+int issue_deauth(struct rtl_priv *rtlpriv, unsigned char *da, unsigned short reason);
+int issue_deauth_ex(struct rtl_priv *rtlpriv, uint8_t *da, unsigned short reason, int try_cnt, int wait_ms);
+void issue_action_spct_ch_switch(struct rtl_priv *rtlpriv, uint8_t *ra, uint8_t new_ch, uint8_t ch_offset);
+void issue_action_BA(struct rtl_priv *rtlpriv, unsigned char *raddr, unsigned char action, unsigned short status);
+unsigned int send_delba(struct rtl_priv *rtlpriv, uint8_t initiator, uint8_t *addr);
+unsigned int send_beacon(struct rtl_priv *rtlpriv);
+
+void start_clnt_assoc(struct rtl_priv *rtlpriv);
+void start_clnt_auth(struct rtl_priv* rtlpriv);
+void start_clnt_join(struct rtl_priv* rtlpriv);
+void start_create_ibss(struct rtl_priv* rtlpriv);
+
+unsigned int OnAssocReq(struct rtl_priv *rtlpriv, struct recv_frame *precv_frame);
+unsigned int OnAssocRsp(struct rtl_priv *rtlpriv, struct recv_frame *precv_frame);
+unsigned int OnProbeReq(struct rtl_priv *rtlpriv, struct recv_frame *precv_frame);
+unsigned int OnProbeRsp(struct rtl_priv *rtlpriv, struct recv_frame *precv_frame);
+unsigned int DoReserved(struct rtl_priv *rtlpriv, struct recv_frame *precv_frame);
+unsigned int OnBeacon(struct rtl_priv *rtlpriv, struct recv_frame *precv_frame);
+unsigned int OnAtim(struct rtl_priv *rtlpriv, struct recv_frame *precv_frame);
+unsigned int OnDisassoc(struct rtl_priv *rtlpriv, struct recv_frame *precv_frame);
+unsigned int OnAuth(struct rtl_priv *rtlpriv, struct recv_frame *precv_frame);
+unsigned int OnAuthClient(struct rtl_priv *rtlpriv, struct recv_frame *precv_frame);
+unsigned int OnDeAuth(struct rtl_priv *rtlpriv, struct recv_frame *precv_frame);
+unsigned int OnAction(struct rtl_priv *rtlpriv, struct recv_frame *precv_frame);
+
+unsigned int on_action_spct(struct rtl_priv *rtlpriv, struct recv_frame *precv_frame);
+unsigned int OnAction_qos(struct rtl_priv *rtlpriv, struct recv_frame *precv_frame);
+unsigned int OnAction_dls(struct rtl_priv *rtlpriv, struct recv_frame *precv_frame);
+unsigned int OnAction_back(struct rtl_priv *rtlpriv, struct recv_frame *precv_frame);
+unsigned int on_action_public(struct rtl_priv *rtlpriv, struct recv_frame *precv_frame);
+unsigned int OnAction_ht(struct rtl_priv *rtlpriv, struct recv_frame *precv_frame);
+unsigned int OnAction_wmm(struct rtl_priv *rtlpriv, struct recv_frame *precv_frame);
+unsigned int OnAction_p2p(struct rtl_priv *rtlpriv, struct recv_frame *precv_frame);
+
+
+void mlmeext_joinbss_event_callback(struct rtl_priv *rtlpriv, int join_res);
+void mlmeext_sta_del_event_callback(struct rtl_priv *rtlpriv);
+void mlmeext_sta_add_event_callback(struct rtl_priv *rtlpriv, struct sta_info *psta);
+
+void linked_status_chk(struct rtl_priv *rtlpriv);
+
+void survey_timer_hdl (struct rtl_priv *rtlpriv);
+void link_timer_hdl (struct rtl_priv *rtlpriv);
+void addba_timer_hdl(struct sta_info *psta);
+//void reauth_timer_hdl(struct rtl_priv *rtlpriv);
+//void reassoc_timer_hdl(struct rtl_priv *rtlpriv);
+
+#define set_survey_timer(mlmeext, ms) \
+	do { \
+		/*DBG_871X("%s set_survey_timer(%p, %d)\n", __FUNCTION__, (mlmeext), (ms));*/ \
+		_set_timer(&(mlmeext)->survey_timer, (ms)); \
+	} while(0)
+
+#define set_link_timer(mlmeext, ms) \
+	do { \
+		/*DBG_871X("%s set_link_timer(%p, %d)\n", __FUNCTION__, (mlmeext), (ms));*/ \
+		_set_timer(&(mlmeext)->link_timer, (ms)); \
+	} while(0)
+
+extern int cckrates_included(unsigned char *rate, int ratelen);
+extern int cckratesonly_included(unsigned char *rate, int ratelen);
+
+extern void process_addba_req(struct rtl_priv *rtlpriv, uint8_t *paddba_req, uint8_t *addr);
+
+extern void update_TSF(struct mlme_ext_priv *pmlmeext, uint8_t *pframe, uint len);
+extern void correct_TSF(struct rtl_priv *rtlpriv, struct mlme_ext_priv *pmlmeext);
+
+struct cmd_hdl {
+	uint	parmsize;
+	uint8_t (*h2cfuns)(struct rtl_priv *rtlpriv, uint8_t *pbuf);
+};
+
+
+uint8_t read_macreg_hdl(struct rtl_priv *rtlpriv, uint8_t *pbuf);
+uint8_t write_macreg_hdl(struct rtl_priv *rtlpriv, uint8_t *pbuf);
+uint8_t read_bbreg_hdl(struct rtl_priv *rtlpriv, uint8_t *pbuf);
+uint8_t write_bbreg_hdl(struct rtl_priv *rtlpriv, uint8_t *pbuf);
+uint8_t read_rfreg_hdl(struct rtl_priv *rtlpriv, uint8_t *pbuf);
+uint8_t write_rfreg_hdl(struct rtl_priv *rtlpriv, uint8_t *pbuf);
+
+
+uint8_t NULL_hdl(struct rtl_priv *rtlpriv, uint8_t *pbuf);
+uint8_t join_cmd_hdl(struct rtl_priv *rtlpriv, uint8_t *pbuf);
+uint8_t disconnect_hdl(struct rtl_priv *rtlpriv, uint8_t *pbuf);
+uint8_t createbss_hdl(struct rtl_priv *rtlpriv, uint8_t *pbuf);
+uint8_t setopmode_hdl(struct rtl_priv *rtlpriv, uint8_t *pbuf);
+uint8_t sitesurvey_cmd_hdl(struct rtl_priv *rtlpriv, uint8_t *pbuf);
+uint8_t setauth_hdl(struct rtl_priv *rtlpriv, uint8_t *pbuf);
+uint8_t setkey_hdl(struct rtl_priv *rtlpriv, uint8_t *pbuf);
+uint8_t set_stakey_hdl(struct rtl_priv *rtlpriv, uint8_t *pbuf);
+uint8_t set_assocsta_hdl(struct rtl_priv *rtlpriv, uint8_t *pbuf);
+uint8_t del_assocsta_hdl(struct rtl_priv *rtlpriv, uint8_t *pbuf);
+uint8_t add_ba_hdl(struct rtl_priv *rtlpriv, unsigned char *pbuf);
+
+uint8_t mlme_evt_hdl(struct rtl_priv *rtlpriv, unsigned char *pbuf);
+uint8_t tx_beacon_hdl(struct rtl_priv *rtlpriv, unsigned char *pbuf);
+uint8_t set_ch_hdl(struct rtl_priv *rtlpriv, uint8_t *pbuf);
+uint8_t set_csa_hdl(struct rtl_priv *rtlpriv, unsigned char *pbuf);	//Kurt: Handling DFS channel switch announcement ie.
+uint8_t tdls_hdl(struct rtl_priv *rtlpriv, unsigned char *pbuf);
+
+
+#define GEN_DRV_CMD_HANDLER(size, cmd)	{size, &cmd ## _hdl},
+#define GEN_MLME_EXT_HANDLER(size, cmd)	{size, cmd},
+
+#ifdef _RTW_CMD_C_
+
+struct cmd_hdl wlancmds[] = {
+	GEN_MLME_EXT_HANDLER(sizeof (struct joinbss_parm), join_cmd_hdl)		/*  1 */
+	GEN_MLME_EXT_HANDLER(sizeof (struct disconnect_parm), disconnect_hdl)		/*  2 */
+	GEN_MLME_EXT_HANDLER(sizeof (struct createbss_parm), createbss_hdl)		/*  3 */
+	GEN_MLME_EXT_HANDLER(sizeof (struct setopmode_parm), setopmode_hdl)		/*  4 */
+	GEN_MLME_EXT_HANDLER(sizeof (struct sitesurvey_parm), sitesurvey_cmd_hdl)	/*  5 */
+	GEN_MLME_EXT_HANDLER(sizeof (struct setauth_parm), setauth_hdl)			/*  6 */
+	GEN_MLME_EXT_HANDLER(sizeof (struct setkey_parm), setkey_hdl)			/*  7 */
+	GEN_MLME_EXT_HANDLER(sizeof (struct set_stakey_parm), set_stakey_hdl)		/*  8 */
+	GEN_MLME_EXT_HANDLER(sizeof(struct addBaReq_parm), add_ba_hdl)			/*  9 */
+	GEN_MLME_EXT_HANDLER(sizeof(struct set_ch_parm), set_ch_hdl)			/* 10 */
+	GEN_MLME_EXT_HANDLER(sizeof(struct Tx_Beacon_param), tx_beacon_hdl)		/* 11 */
+	GEN_MLME_EXT_HANDLER(0, mlme_evt_hdl)						/* 12 */
+	GEN_MLME_EXT_HANDLER(0, rtw_drvextra_cmd_hdl)					/* 13 */
+	GEN_MLME_EXT_HANDLER(sizeof(struct SetChannelSwitch_param), set_csa_hdl)	/* 15 */
+};
+
+#endif
+
+struct C2HEvent_Header
+{
+
+#ifdef CONFIG_LITTLE_ENDIAN
+
+	unsigned int len:16;
+	unsigned int ID:8;
+	unsigned int seq:8;
+
+#elif defined(CONFIG_BIG_ENDIAN)
+
+	unsigned int seq:8;
+	unsigned int ID:8;
+	unsigned int len:16;
+
+#else
+
+#  error "Must be LITTLE or BIG Endian"
+
+#endif
+
+	unsigned int rsvd;
+
+};
+
+void rtw_dummy_event_callback(struct rtl_priv *rtlpriv , uint8_t *pbuf);
+void rtw_fwdbg_event_callback(struct rtl_priv *rtlpriv , uint8_t *pbuf);
+
+enum rtw_c2h_event
+{
+	GEN_EVT_CODE(_Read_MACREG)=0, /*0*/
+	GEN_EVT_CODE(_Read_BBREG),
+ 	GEN_EVT_CODE(_Read_RFREG),
+ 	GEN_EVT_CODE(_Read_EEPROM),
+ 	GEN_EVT_CODE(_Read_EFUSE),
+	GEN_EVT_CODE(_Read_CAM),			/*5*/
+ 	GEN_EVT_CODE(_Get_BasicRate),
+ 	GEN_EVT_CODE(_Get_DataRate),
+ 	GEN_EVT_CODE(_Survey),	 /*8*/
+ 	GEN_EVT_CODE(_SurveyDone),	 /*9*/
+
+ 	GEN_EVT_CODE(_JoinBss) , /*10*/
+ 	GEN_EVT_CODE(_AddSTA),
+ 	GEN_EVT_CODE(_DelSTA),
+ 	GEN_EVT_CODE(_AtimDone) ,
+ 	GEN_EVT_CODE(_TX_Report),
+	GEN_EVT_CODE(_CCX_Report),			/*15*/
+ 	GEN_EVT_CODE(_DTM_Report),
+ 	GEN_EVT_CODE(_TX_Rate_Statistics),
+ 	GEN_EVT_CODE(_C2HLBK),
+ 	GEN_EVT_CODE(_FWDBG),
+	GEN_EVT_CODE(_C2HFEEDBACK),               /*20*/
+	GEN_EVT_CODE(_ADDBA),
+	GEN_EVT_CODE(_C2HBCN),
+	GEN_EVT_CODE(_ReportPwrState),		//filen: only for PCIE, USB
+	GEN_EVT_CODE(_CloseRF),				//filen: only for PCIE, work around ASPM
+ 	MAX_C2HEVT
+};
+
+
+#ifdef _RTW_MLME_EXT_C_
+
+static struct fwevent wlanevents[] =
+{
+	{0, rtw_dummy_event_callback}, 	/*0*/
+	{0, NULL},
+	{0, NULL},
+	{0, NULL},
+	{0, NULL},
+	{0, NULL},
+	{0, NULL},
+	{0, NULL},
+	{0, &rtw_survey_event_callback},		/*8*/
+	{sizeof (struct surveydone_event), &rtw_surveydone_event_callback},	/*9*/
+
+	{0, &rtw_joinbss_event_callback},		/*10*/
+	{sizeof(struct stassoc_event), &rtw_stassoc_event_callback},
+	{sizeof(struct stadel_event), &rtw_stadel_event_callback},
+	{0, &rtw_atimdone_event_callback},
+	{0, rtw_dummy_event_callback},
+	{0, NULL},	/*15*/
+	{0, NULL},
+	{0, NULL},
+	{0, NULL},
+	{0, rtw_fwdbg_event_callback},
+	{0, NULL},	 /*20*/
+	{0, NULL},
+	{0, NULL},
+	{0, &rtw_cpwm_event_callback},
+};
+
+#endif//_RTL8192C_CMD_C_
+
+#endif
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/include/rtw_mlme.h linux-4.9.8821au/drivers/staging/rtl8821au/include/rtw_mlme.h
--- linux-4.9/drivers/staging/rtl8821au/include/rtw_mlme.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/include/rtw_mlme.h	2016-12-11 19:48:25.173645047 -0600
@@ -0,0 +1,627 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTW_MLME_H_
+#define __RTW_MLME_H_
+
+#include <rtw_rf.h>
+#include <rtw_ht.h>
+#include <rtw_vht.h>
+
+#define	MAX_BSS_CNT	128
+//#define   MAX_JOIN_TIMEOUT	2000
+//#define   MAX_JOIN_TIMEOUT	2500
+#define   MAX_JOIN_TIMEOUT	6500
+
+//	Commented by Albert 20101105
+//	Increase the scanning timeout because of increasing the SURVEY_TO value.
+
+#define 	SCANNING_TIMEOUT 	8000
+
+#define	SCAN_INTERVAL	(30) // unit:2sec, 30*2=60sec
+
+#ifdef PALTFORM_OS_WINCE
+#define	SCANQUEUE_LIFETIME 12000000 // unit:us
+#else
+#define	SCANQUEUE_LIFETIME 20000 // 20sec, unit:msec
+#endif
+
+#define WIFI_NULL_STATE		0x00000000
+#define WIFI_ASOC_STATE		0x00000001		// Under Linked state...
+#define WIFI_REASOC_STATE	0x00000002
+#define WIFI_SLEEP_STATE	0x00000004
+#define WIFI_STATION_STATE	0x00000008
+#define	WIFI_AP_STATE			0x00000010
+#define	WIFI_ADHOC_STATE		0x00000020
+#define WIFI_ADHOC_MASTER_STATE	0x00000040
+#define WIFI_UNDER_LINKING	0x00000080
+
+#define WIFI_UNDER_WPS			0x00000100
+//#define	WIFI_UNDER_CMD			0x00000200
+//#define	WIFI_UNDER_P2P			0x00000400
+#define	WIFI_STA_ALIVE_CHK_STATE	0x00000400
+#define	WIFI_SITE_MONITOR			0x00000800		//to indicate the station is under site surveying
+#ifdef WDS
+#define	WIFI_WDS				0x00001000
+#define	WIFI_WDS_RX_BEACON	0x00002000		// already rx WDS AP beacon
+#endif
+#ifdef AUTO_CONFIG
+#define	WIFI_AUTOCONF			0x00004000
+#define	WIFI_AUTOCONF_IND	0x00008000
+#endif
+
+/*
+// ========== P2P Section Start ===============
+#define	WIFI_P2P_LISTEN_STATE		0x00010000
+#define	WIFI_P2P_GROUP_FORMATION_STATE		0x00020000
+// ========== P2P Section End ===============
+*/
+
+//#ifdef UNDER_MPTEST
+#define	WIFI_MP_STATE							0x00010000
+#define	WIFI_MP_CTX_BACKGROUND				0x00020000	// in continous tx background
+#define	WIFI_MP_CTX_ST						0x00040000	// in continous tx with single-tone
+#define	WIFI_MP_CTX_BACKGROUND_PENDING	0x00080000	// pending in continous tx background due to out of skb
+#define	WIFI_MP_CTX_CCK_HW					0x00100000	// in continous tx
+#define	WIFI_MP_CTX_CCK_CS					0x00200000	// in continous tx with carrier suppression
+#define   WIFI_MP_LPBK_STATE					0x00400000
+//#endif
+
+//#define _FW_UNDER_CMD		WIFI_UNDER_CMD
+#define _FW_UNDER_LINKING	WIFI_UNDER_LINKING
+#define _FW_LINKED			WIFI_ASOC_STATE
+#define _FW_UNDER_SURVEY	WIFI_SITE_MONITOR
+
+
+enum dot11AuthAlgrthmNum {
+ dot11AuthAlgrthm_Open = 0,
+ dot11AuthAlgrthm_Shared,
+ dot11AuthAlgrthm_8021X,
+ dot11AuthAlgrthm_Auto,
+ dot11AuthAlgrthm_WAPI,
+ dot11AuthAlgrthm_MaxNum
+};
+
+// Scan type including active and passive scan.
+typedef enum _RT_SCAN_TYPE
+{
+	SCAN_PASSIVE,
+	SCAN_ACTIVE,
+	SCAN_MIX,
+}RT_SCAN_TYPE, *PRT_SCAN_TYPE;
+
+enum  _BAND
+{
+	GHZ24_50 = 0,
+	GHZ_50,
+	GHZ_24,
+};
+
+enum DriverInterface {
+	DRIVER_WEXT =  1,
+	DRIVER_CFG80211 = 2
+};
+
+enum SCAN_RESULT_TYPE
+{
+	SCAN_RESULT_P2P_ONLY = 0,		//	Will return all the P2P devices.
+	SCAN_RESULT_ALL = 1,			//	Will return all the scanned device, include AP.
+	SCAN_RESULT_WFD_TYPE = 2		//	Will just return the correct WFD device.
+									//	If this device is Miracast sink device, it will just return all the Miracast source devices.
+};
+
+/*
+
+there are several "locks" in mlme_priv,
+since mlme_priv is a shared resource between many threads,
+like ISR/Call-Back functions, the OID handlers, and even timer functions.
+
+
+Each struct __queue has its own locks, already.
+Other items are protected by mlme_priv.lock.
+
+To avoid possible dead lock, any thread trying to modifiying mlme_priv
+SHALL not lock up more than one locks at a time!
+
+*/
+
+
+#define traffic_threshold	10
+#define	traffic_scan_period	500
+
+struct sitesurvey_ctrl {
+	u64	last_tx_pkts;
+	uint	last_rx_pkts;
+	int	traffic_busy;
+	struct timer_list sitesurvey_ctrl_timer;
+};
+
+typedef struct _RT_LINK_DETECT_T{
+	u32				NumTxOkInPeriod;
+	u32				NumRxOkInPeriod;
+	u32				NumRxUnicastOkInPeriod;
+	bool			bBusyTraffic;
+	bool			bTxBusyTraffic;
+	bool			bRxBusyTraffic;
+	bool			bHigherBusyTraffic; // For interrupt migration purpose.
+	bool			bHigherBusyRxTraffic; // We may disable Tx interrupt according as Rx traffic.
+	bool			bHigherBusyTxTraffic; // We may disable Tx interrupt according as Tx traffic.
+}RT_LINK_DETECT_T, *PRT_LINK_DETECT_T;
+
+struct profile_info {
+	uint8_t	ssidlen;
+	uint8_t	ssid[ WLAN_SSID_MAXLEN ];
+	uint8_t	peermac[ ETH_ALEN ];
+};
+
+struct tx_invite_req_info{
+	uint8_t					token;
+	uint8_t					benable;
+	uint8_t					go_ssid[ WLAN_SSID_MAXLEN ];
+	uint8_t					ssidlen;
+	uint8_t					go_bssid[ ETH_ALEN ];
+	uint8_t					peer_macaddr[ ETH_ALEN ];
+	uint8_t					operating_ch;	//	This information will be set by using the p2p_set op_ch=x
+	uint8_t					peer_ch;		//	The listen channel for peer P2P device
+
+};
+
+struct tx_invite_resp_info{
+	uint8_t					token;	//	Used to record the dialog token of p2p invitation request frame.
+};
+
+struct tx_provdisc_req_info{
+	u16					wps_config_method_request;	//	Used when sending the provisioning request frame
+	u16					peer_channel_num[2];		//	The channel number which the receiver stands.
+	NDIS_802_11_SSID	ssid;
+	uint8_t					peerDevAddr[ ETH_ALEN ];		//	Peer device address
+	uint8_t					peerIFAddr[ ETH_ALEN ];		//	Peer interface address
+	uint8_t					benable;					//	This provision discovery request frame is trigger to send or not
+};
+
+struct rx_provdisc_req_info{	//When peer device issue prov_disc_req first, we should store the following informations
+	uint8_t					peerDevAddr[ ETH_ALEN ];		//	Peer device address
+	uint8_t					strconfig_method_desc_of_prov_disc_req[4];	//	description for the config method located in the provisioning discovery request frame.
+																	//	The UI must know this information to know which config method the remote p2p device is requiring.
+};
+
+struct tx_nego_req_info{
+	u16					peer_channel_num[2];		//	The channel number which the receiver stands.
+	uint8_t					peerDevAddr[ ETH_ALEN ];		//	Peer device address
+	uint8_t					benable;					//	This negoitation request frame is trigger to send or not
+};
+
+struct group_id_info{
+	uint8_t					go_device_addr[ ETH_ALEN ];	//	The GO's device address of this P2P group
+	uint8_t					ssid[ WLAN_SSID_MAXLEN ];	//	The SSID of this P2P group
+};
+
+struct scan_limit_info{
+	uint8_t					scan_op_ch_only;			//	When this flag is set, the driver should just scan the operation channel
+	uint8_t					operation_ch[2];				//	Store the operation channel of invitation request frame
+};
+
+struct wifidirect_info{
+	struct rtl_priv*				rtlpriv;
+	struct timer_list				find_phase_timer;
+	struct timer_list				restore_p2p_state_timer;
+
+	//	Used to do the scanning. After confirming the peer is availalble, the driver transmits the P2P frame to peer.
+	struct timer_list				pre_tx_scan_timer;
+	struct timer_list				reset_ch_sitesurvey;
+	struct timer_list				reset_ch_sitesurvey2;	//	Just for resetting the scan limit function by using p2p nego
+	struct tx_provdisc_req_info	tx_prov_disc_info;
+	struct rx_provdisc_req_info rx_prov_disc_info;
+	struct tx_invite_req_info	invitereq_info;
+	struct profile_info			profileinfo[ P2P_MAX_PERSISTENT_GROUP_NUM ];	//	Store the profile information of persistent group
+	struct tx_invite_resp_info	inviteresp_info;
+	struct tx_nego_req_info	nego_req_info;
+	struct group_id_info		groupid_info;	//	Store the group id information when doing the group negotiation handshake.
+	struct scan_limit_info		rx_invitereq_info;	//	Used for get the limit scan channel from the Invitation procedure
+	struct scan_limit_info		p2p_info;		//	Used for get the limit scan channel from the P2P negotiation handshake
+	enum P2P_ROLE			role;
+	enum P2P_STATE			pre_p2p_state;
+	enum P2P_STATE			p2p_state;
+	uint8_t 						device_addr[ETH_ALEN];	//	The device address should be the mac address of this device.
+	uint8_t						interface_addr[ETH_ALEN];
+	uint8_t						social_chan[4];
+	uint8_t						listen_channel;
+	uint8_t						operating_channel;
+	uint8_t						listen_dwell;		//	This value should be between 1 and 3
+	uint8_t						support_rate[8];
+	uint8_t						p2p_wildcard_ssid[P2P_WILDCARD_SSID_LEN];
+	uint8_t						intent;		//	should only include the intent value.
+	uint8_t						p2p_peer_interface_addr[ ETH_ALEN ];
+	uint8_t						p2p_peer_device_addr[ ETH_ALEN ];
+	uint8_t						peer_intent;	//	Included the intent value and tie breaker value.
+	uint8_t						device_name[ WPS_MAX_DEVICE_NAME_LEN ];	//	Device name for displaying on searching device screen
+	uint8_t						device_name_len;
+	uint8_t						profileindex;	//	Used to point to the index of profileinfo array
+	uint8_t						peer_operating_ch;
+	uint8_t						find_phase_state_exchange_cnt;
+	u16						device_password_id_for_nego;	//	The device password ID for group negotation
+	uint8_t						negotiation_dialog_token;
+	uint8_t						nego_ssid[ WLAN_SSID_MAXLEN ];	//	SSID information for group negotitation
+	uint8_t						nego_ssidlen;
+	uint8_t 						p2p_group_ssid[WLAN_SSID_MAXLEN];
+	uint8_t 						p2p_group_ssid_len;
+	uint8_t						persistent_supported;		//	Flag to know the persistent function should be supported or not.
+														//	In the Sigma test, the Sigma will provide this enable from the sta_set_p2p CAPI.
+														//	0: disable
+														//	1: enable
+	uint8_t						session_available;			//	Flag to set the WFD session available to enable or disable "by Sigma"
+														//	In the Sigma test, the Sigma will disable the session available by using the sta_preset CAPI.
+														//	0: disable
+														//	1: enable
+
+	uint8_t						wfd_tdls_enable;			//	Flag to enable or disable the TDLS by WFD Sigma
+														//	0: disable
+														//	1: enable
+	uint8_t						wfd_tdls_weaksec;			//	Flag to enable or disable the weak security function for TDLS by WFD Sigma
+														//	0: disable
+														//	In this case, the driver can't issue the tdsl setup request frame.
+														//	1: enable
+														//	In this case, the driver can issue the tdls setup request frame
+														//	even the current security is weak security.
+
+	enum	P2P_WPSINFO		ui_got_wps_info;			//	This field will store the WPS value (PIN value or PBC) that UI had got from the user.
+	u16						supported_wps_cm;			//	This field describes the WPS config method which this driver supported.
+														//	The value should be the combination of config method defined in page104 of WPS v2.0 spec.
+	uint						channel_list_attr_len;		//	This field will contain the length of body of P2P Channel List attribute of group negotitation response frame.
+	uint8_t						channel_list_attr[100];		//	This field will contain the body of P2P Channel List attribute of group negotitation response frame.
+														//	We will use the channel_cnt and channel_list fields when constructing the group negotitation confirm frame.
+	uint8_t						driver_interface;			//	Indicate DRIVER_WEXT or DRIVER_CFG80211
+};
+
+struct tdls_ss_record{	//signal strength record
+	uint8_t		macaddr[ETH_ALEN];
+	uint8_t		RxPWDBAll;
+	uint8_t		is_tdls_sta;	// true: direct link sta, false: else
+};
+
+struct tdls_info{
+	uint8_t					ap_prohibited;
+	uint					setup_state;
+	uint8_t					sta_cnt;
+	uint8_t					sta_maximum;	// 1:tdls sta is equal (NUM_STA-1), reach max direct link number; 0: else;
+	struct tdls_ss_record	ss_record;
+	uint8_t					macid_index;	//macid entry that is ready to write
+	uint8_t					clear_cam;	//cam entry that is trying to clear, using it in direct link teardown
+	uint8_t					ch_sensing;
+	uint8_t					cur_channel;
+	uint8_t					candidate_ch;
+	uint8_t					collect_pkt_num[MAX_CHANNEL_NUM];
+	spinlock_t				cmd_lock;
+	spinlock_t				hdl_lock;
+	uint8_t					watchdog_count;
+	uint8_t					dev_discovered;		//WFD_TDLS: for sigma test
+	uint8_t					enable;
+};
+
+struct mlme_priv {
+
+	spinlock_t	lock;
+	int	fw_state;	//shall we protect this variable? maybe not necessarily...
+	uint8_t bScanInProcess;
+	uint8_t	to_join; //flag
+
+	uint8_t	*nic_hdl;
+
+	uint8_t	not_indic_disco;
+	struct list_head		*pscanned;
+	struct __queue	free_bss_pool;
+	struct __queue	scanned_queue;
+	uint8_t		*free_bss_buf;
+	u32	num_of_scanned;
+
+	NDIS_802_11_SSID	assoc_ssid;
+	uint8_t	assoc_bssid[6];
+
+	struct wlan_network	cur_network;
+
+	//uint wireless_mode; no used, remove it
+
+	u32	scan_interval;
+
+	struct timer_list assoc_timer;
+
+	uint assoc_by_bssid;
+	uint assoc_by_rssi;
+
+	struct timer_list scan_to_timer; // driver itself handles scan_timeout status.
+	u32 scan_start_time; // used to evaluate the time spent in scanning
+
+	struct qos_priv qospriv;
+
+	/* Number of non-HT AP/stations */
+	int num_sta_no_ht;
+
+	/* Number of HT AP/stations 20 MHz */
+	//int num_sta_ht_20mhz;
+
+
+	int num_FortyMHzIntolerant;
+
+	struct ht_priv	htpriv;
+
+	struct vht_priv	vhtpriv;
+
+	RT_LINK_DETECT_T	LinkDetectInfo;
+	struct timer_list	dynamic_chk_timer; //dynamic/periodic check timer
+
+ 	uint8_t 	key_mask; //use for ips to set wep key after ips_leave
+	uint8_t	acm_mask; // for wmm acm mask
+	uint8_t	ChannelPlan;
+	RT_SCAN_TYPE 	scan_mode; // active: 1, passive: 0
+
+	//uint8_t probereq_wpsie[MAX_WPS_IE_LEN];//added in probe req
+	//int probereq_wpsie_len;
+	uint8_t *wps_probe_req_ie;
+	u32 wps_probe_req_ie_len;
+
+#if defined (CONFIG_AP_MODE)
+	/* Number of associated Non-ERP stations (i.e., stations using 802.11b
+	 * in 802.11g BSS) */
+	int num_sta_non_erp;
+
+	/* Number of associated stations that do not support Short Slot Time */
+	int num_sta_no_short_slot_time;
+
+	/* Number of associated stations that do not support Short Preamble */
+	int num_sta_no_short_preamble;
+
+	int olbc; /* Overlapping Legacy BSS Condition */
+
+	/* Number of HT associated stations that do not support greenfield */
+	int num_sta_ht_no_gf;
+
+	/* Number of associated non-HT stations */
+	//int num_sta_no_ht;
+
+	/* Number of HT associated stations 20 MHz */
+	int num_sta_ht_20mhz;
+
+	/* Overlapping BSS information */
+	int olbc_ht;
+
+	u16 ht_op_mode;
+
+	uint8_t *assoc_req;
+	u32 assoc_req_len;
+	uint8_t *assoc_rsp;
+	u32 assoc_rsp_len;
+
+	uint8_t *wps_beacon_ie;
+	//uint8_t *wps_probe_req_ie;
+	uint8_t *wps_probe_resp_ie;
+	uint8_t *wps_assoc_resp_ie; // for CONFIG_IOCTL_CFG80211, this IE could include p2p ie / wfd ie
+
+	u32 wps_beacon_ie_len;
+	//u32 wps_probe_req_ie_len;
+	u32 wps_probe_resp_ie_len;
+	u32 wps_assoc_resp_ie_len; // for CONFIG_IOCTL_CFG80211, this IE len could include p2p ie / wfd ie
+
+	uint8_t *p2p_beacon_ie;
+	uint8_t *p2p_probe_req_ie;
+	uint8_t *p2p_probe_resp_ie;
+	uint8_t *p2p_go_probe_resp_ie; //for GO
+	uint8_t *p2p_assoc_req_ie;
+
+	u32 p2p_beacon_ie_len;
+	u32 p2p_probe_req_ie_len;
+	u32 p2p_probe_resp_ie_len;
+	u32 p2p_go_probe_resp_ie_len; //for GO
+	u32 p2p_assoc_req_ie_len;
+
+	spinlock_t	bcn_update_lock;
+	uint8_t		update_bcn;
+
+
+#endif //#if defined (CONFIG_AP_MODE)
+};
+
+#ifdef CONFIG_AP_MODE
+
+struct hostapd_priv
+{
+	struct rtl_priv *rtlpriv;
+};
+
+extern int hostapd_mode_init(struct rtl_priv *rtlpriv);
+extern void hostapd_mode_unload(struct rtl_priv *rtlpriv);
+#endif
+
+
+extern void rtw_joinbss_event_prehandle(struct rtl_priv *rtlpriv, uint8_t *pbuf);
+extern void rtw_survey_event_callback(struct rtl_priv *rtlpriv, uint8_t *pbuf);
+extern void rtw_surveydone_event_callback(struct rtl_priv *rtlpriv, uint8_t *pbuf);
+extern void rtw_joinbss_event_callback(struct rtl_priv *rtlpriv, uint8_t *pbuf);
+extern void rtw_stassoc_event_callback(struct rtl_priv *rtlpriv, uint8_t *pbuf);
+extern void rtw_stadel_event_callback(struct rtl_priv *rtlpriv, uint8_t *pbuf);
+extern void rtw_atimdone_event_callback(struct rtl_priv *rtlpriv, uint8_t *pbuf);
+extern void rtw_cpwm_event_callback(struct rtl_priv *rtlpriv, uint8_t *pbuf);
+
+extern void rtw_join_timeout_handler(RTW_TIMER_HDL_ARGS);
+extern void _rtw_scan_timeout_handler(RTW_TIMER_HDL_ARGS);
+
+int event_thread(void *context);
+
+extern void rtw_free_network_queue(struct rtl_priv *rtlpriv,uint8_t isfreeall);
+extern int rtw_init_mlme_priv(struct rtl_priv *rtlpriv);// (struct mlme_priv *pmlmepriv);
+
+extern void rtw_free_mlme_priv (struct mlme_priv *pmlmepriv);
+
+
+extern int rtw_select_and_join_from_scanned_queue(struct mlme_priv *pmlmepriv);
+extern int rtw_set_key(struct rtl_priv *rtlpriv,struct security_priv *psecuritypriv,int keyid, uint8_t set_tx);
+extern int rtw_set_auth(struct rtl_priv *rtlpriv,struct security_priv *psecuritypriv);
+
+__inline static uint8_t *get_bssid(struct mlme_priv *pmlmepriv)
+{	//if sta_mode:pmlmepriv->cur_network.network.MacAddress=> bssid
+	// if adhoc_mode:pmlmepriv->cur_network.network.MacAddress=> ibss mac address
+	return pmlmepriv->cur_network.network.MacAddress;
+}
+
+__inline static int check_fwstate(struct mlme_priv *pmlmepriv, int state)
+{
+	if (pmlmepriv->fw_state & state)
+		return true;
+
+	return false;
+}
+
+__inline static int get_fwstate(struct mlme_priv *pmlmepriv)
+{
+	return pmlmepriv->fw_state;
+}
+
+/*
+ * No Limit on the calling context,
+ * therefore set it to be the critical section...
+ *
+ * ### NOTE:#### (!!!!)
+ * MUST TAKE CARE THAT BEFORE CALLING THIS FUNC, YOU SHOULD HAVE LOCKED pmlmepriv->lock
+ */
+__inline static void set_fwstate(struct mlme_priv *pmlmepriv, int state)
+{
+	pmlmepriv->fw_state |= state;
+	//FOR HW integration
+	if(_FW_UNDER_SURVEY==state){
+		pmlmepriv->bScanInProcess = true;
+	}
+}
+
+__inline static void _clr_fwstate_(struct mlme_priv *pmlmepriv, int state)
+{
+	pmlmepriv->fw_state &= ~state;
+	//FOR HW integration
+	if(_FW_UNDER_SURVEY==state){
+		pmlmepriv->bScanInProcess = false;
+	}
+}
+
+/*
+ * No Limit on the calling context,
+ * therefore set it to be the critical section...
+ */
+__inline static void clr_fwstate(struct mlme_priv *pmlmepriv, int state)
+{
+	spin_lock_bh(&pmlmepriv->lock);
+	if (check_fwstate(pmlmepriv, state) == true)
+		pmlmepriv->fw_state ^= state;
+	spin_unlock_bh(&pmlmepriv->lock);
+}
+
+__inline static void clr_fwstate_ex(struct mlme_priv *pmlmepriv, int state)
+{
+	spin_lock_bh(&pmlmepriv->lock);
+	_clr_fwstate_(pmlmepriv, state);
+	spin_unlock_bh(&pmlmepriv->lock);
+}
+
+__inline static void up_scanned_network(struct mlme_priv *pmlmepriv)
+{
+	spin_lock_bh(&pmlmepriv->lock);
+	pmlmepriv->num_of_scanned++;
+	spin_unlock_bh(&pmlmepriv->lock);
+}
+
+__inline static void down_scanned_network(struct mlme_priv *pmlmepriv)
+{
+	spin_lock_bh(&pmlmepriv->lock);
+	pmlmepriv->num_of_scanned--;
+	spin_unlock_bh(&pmlmepriv->lock);
+}
+
+__inline static void set_scanned_network_val(struct mlme_priv *pmlmepriv, int val)
+{
+	spin_lock_bh(&pmlmepriv->lock);
+	pmlmepriv->num_of_scanned = val;
+	spin_unlock_bh(&pmlmepriv->lock);
+}
+
+extern u16 rtw_get_capability(WLAN_BSSID_EX *bss);
+extern void rtw_update_scanned_network(struct rtl_priv *rtlpriv, WLAN_BSSID_EX *target);
+extern void rtw_disconnect_hdl_under_linked(struct rtl_priv* rtlpriv, struct sta_info *psta, uint8_t free_assoc);
+extern void rtw_generate_random_ibss(uint8_t *pibss);
+extern struct wlan_network* rtw_find_network(struct __queue *scanned_queue, uint8_t *addr);
+extern struct wlan_network* rtw_get_oldest_wlan_network(struct __queue *scanned_queue);
+
+extern void rtw_free_assoc_resources(struct rtl_priv* rtlpriv, int lock_scanned_queue);
+extern void rtw_indicate_disconnect(struct rtl_priv* rtlpriv);
+extern void rtw_indicate_connect(struct rtl_priv* rtlpriv);
+void rtw_indicate_scan_done( struct rtl_priv *rtlpriv, bool aborted);
+void rtw_scan_abort(struct rtl_priv *rtlpriv);
+
+extern int rtw_restruct_sec_ie(struct rtl_priv *rtlpriv,uint8_t *in_ie,uint8_t *out_ie,uint in_len);
+extern int rtw_restruct_wmm_ie(struct rtl_priv *rtlpriv, uint8_t *in_ie, uint8_t *out_ie, uint in_len, uint initial_out_len);
+extern void rtw_init_registrypriv_dev_network(struct rtl_priv *rtlpriv);
+
+extern void rtw_update_registrypriv_dev_network(struct rtl_priv *rtlpriv);
+
+extern void rtw_get_encrypt_decrypt_from_registrypriv(struct rtl_priv *rtlpriv);
+
+extern void _rtw_join_timeout_handler(struct rtl_priv *rtlpriv);
+extern void rtw_scan_timeout_handler(struct rtl_priv *rtlpriv);
+
+extern void rtw_dynamic_check_timer_handlder(struct rtl_priv *rtlpriv);
+
+extern int _rtw_init_mlme_priv(struct rtl_priv *rtlpriv);
+
+void rtw_free_mlme_priv_ie_data(struct mlme_priv *pmlmepriv);
+
+extern void _rtw_free_mlme_priv(struct mlme_priv *pmlmepriv);
+
+extern int _rtw_enqueue_network(struct __queue *queue, struct wlan_network *pnetwork);
+
+//extern struct wlan_network* _rtw_dequeue_network(struct __queue *queue);
+
+extern struct wlan_network* _rtw_alloc_network(struct mlme_priv *pmlmepriv);
+
+
+extern void _rtw_free_network(struct mlme_priv *pmlmepriv, struct wlan_network *pnetwork, uint8_t isfreeall);
+extern void _rtw_free_network_nolock(struct mlme_priv *pmlmepriv, struct wlan_network *pnetwork);
+
+
+extern struct wlan_network* _rtw_find_network(struct __queue *scanned_queue, uint8_t *addr);
+
+extern void _rtw_free_network_queue(struct rtl_priv* rtlpriv, uint8_t isfreeall);
+
+extern int rtw_if_up(struct rtl_priv *rtlpriv);
+
+int rtw_linked_check(struct rtl_priv *rtlpriv);
+
+uint8_t *rtw_get_capability_from_ie(uint8_t *ie);
+uint8_t *rtw_get_timestampe_from_ie(uint8_t *ie);
+uint8_t *rtw_get_beacon_interval_from_ie(uint8_t *ie);
+
+
+void rtw_joinbss_reset(struct rtl_priv *rtlpriv);
+
+unsigned int rtw_restructure_ht_ie(struct rtl_priv *rtlpriv, uint8_t *in_ie, uint8_t *out_ie, uint in_len, uint *pout_len);
+void rtw_update_ht_cap(struct rtl_priv *rtlpriv, uint8_t *pie, uint ie_len, uint8_t channel);
+void rtw_issue_addbareq_cmd(struct rtl_priv *rtlpriv, struct xmit_frame *pxmitframe);
+
+int rtw_is_same_ibss(struct rtl_priv *rtlpriv, struct wlan_network *pnetwork);
+int is_same_network(WLAN_BSSID_EX *src, WLAN_BSSID_EX *dst);
+
+void rtw_stassoc_hw_rpt(struct rtl_priv *rtlpriv,struct sta_info *psta);
+
+#endif //__RTL871X_MLME_H_
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/include/rtw_pwrctrl.h linux-4.9.8821au/drivers/staging/rtl8821au/include/rtw_pwrctrl.h
--- linux-4.9/drivers/staging/rtl8821au/include/rtw_pwrctrl.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/include/rtw_pwrctrl.h	2016-12-11 19:48:25.173645047 -0600
@@ -0,0 +1,180 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTW_PWRCTRL_H_
+#define __RTW_PWRCTRL_H_
+
+
+#define FW_PWR0	0
+#define FW_PWR1 	1
+#define FW_PWR2 	2
+#define FW_PWR3 	3
+
+
+#define HW_PWR0	7
+#define HW_PWR1 	6
+#define HW_PWR2 	2
+#define HW_PWR3	0
+#define HW_PWR4	8
+
+#define FW_PWRMSK	0x7
+
+
+#define XMIT_ALIVE	BIT(0)
+#define RECV_ALIVE	BIT(1)
+#define CMD_ALIVE	BIT(2)
+#define EVT_ALIVE	BIT(3)
+
+
+enum Power_Mgnt
+{
+	PS_MODE_ACTIVE	= 0	,
+	PS_MODE_MIN			,
+	PS_MODE_MAX			,
+	PS_MODE_DTIM			,
+	PS_MODE_VOIP			,
+	PS_MODE_UAPSD_WMM	,
+	PS_MODE_UAPSD			,
+	PS_MODE_IBSS			,
+	PS_MODE_WWLAN		,
+	PM_Radio_Off			,
+	PM_Card_Disable		,
+	PS_MODE_NUM,
+};
+
+
+/*
+	BIT[2:0] = HW state
+	BIT[3] = Protocol PS state,   0: register active state , 1: register sleep state
+	BIT[4] = sub-state
+*/
+
+#define PS_DPS				BIT(0)
+#define PS_LCLK				(PS_DPS)
+#define PS_RF_OFF			BIT(1)
+#define PS_ALL_ON			BIT(2)
+#define PS_ST_ACTIVE		BIT(3)
+
+#define PS_ISR_ENABLE		BIT(4)
+#define PS_IMR_ENABLE		BIT(5)
+#define PS_ACK				BIT(6)
+#define PS_TOGGLE			BIT(7)
+
+#define PS_STATE_MASK		(0x0F)
+#define PS_STATE_HW_MASK	(0x07)
+#define PS_SEQ_MASK			(0xc0)
+
+#define PS_STATE(x)		(PS_STATE_MASK & (x))
+#define PS_STATE_HW(x)	(PS_STATE_HW_MASK & (x))
+#define PS_SEQ(x)		(PS_SEQ_MASK & (x))
+
+#define PS_STATE_S0		(PS_DPS)
+#define PS_STATE_S1		(PS_LCLK)
+#define PS_STATE_S2		(PS_RF_OFF)
+#define PS_STATE_S3		(PS_ALL_ON)
+#define PS_STATE_S4		((PS_ST_ACTIVE) | (PS_ALL_ON))
+
+
+#define PS_IS_RF_ON(x)	((x) & (PS_ALL_ON))
+#define PS_IS_ACTIVE(x)	((x) & (PS_ST_ACTIVE))
+#define CLR_PS_STATE(x)	((x) = ((x) & (0xF0)))
+
+
+struct reportpwrstate_parm {
+	unsigned char mode;
+	unsigned char state; //the CPWM value
+	unsigned short rsvd;
+};
+
+
+#define LPS_DELAY_TIME	1*HZ // 1 sec
+
+#define EXE_PWR_NONE	0x01
+#define EXE_PWR_IPS		0x02
+#define EXE_PWR_LPS		0x04
+
+// RF Off Level for IPS or HW/SW radio off
+#define	RT_RF_OFF_LEVL_ASPM			BIT(0)	// PCI ASPM
+#define	RT_RF_OFF_LEVL_CLK_REQ		BIT(1)	// PCI clock request
+#define	RT_RF_OFF_LEVL_PCI_D3			BIT(2)	// PCI D3 mode
+#define	RT_RF_OFF_LEVL_HALT_NIC		BIT(3)	// NIC halt, re-initialize hw parameters
+#define	RT_RF_OFF_LEVL_FREE_FW		BIT(4)	// FW free, re-download the FW
+#define	RT_RF_OFF_LEVL_FW_32K		BIT(5)	// FW in 32k
+#define	RT_RF_PS_LEVEL_ALWAYS_ASPM	BIT(6)	// Always enable ASPM and Clock Req in initialization.
+#define	RT_RF_LPS_DISALBE_2R			BIT(30)	// When LPS is on, disable 2R if no packet is received or transmittd.
+#define	RT_RF_LPS_LEVEL_ASPM			BIT(31)	// LPS with ASPM
+
+#define	RT_IN_PS_LEVEL(ppsc, _PS_FLAG)		((ppsc->cur_ps_level & _PS_FLAG) ? true : false)
+#define	RT_CLEAR_PS_LEVEL(ppsc, _PS_FLAG)	(ppsc->cur_ps_level &= (~(_PS_FLAG)))
+#define	RT_SET_PS_LEVEL(ppsc, _PS_FLAG)		(ppsc->cur_ps_level |= _PS_FLAG)
+
+
+enum _PS_BBRegBackup_ {
+	PSBBREG_RF0 = 0,
+	PSBBREG_RF1,
+	PSBBREG_RF2,
+	PSBBREG_AFE0,
+	PSBBREG_TOTALCNT
+};
+
+enum { // for ips_mode
+	IPS_NONE=0,
+	IPS_NORMAL,
+};
+
+#define RTW_PWR_STATE_CHK_INTERVAL 2000
+
+#define _rtw_set_pwr_state_check_timer(pwrctrlpriv, ms) \
+	do { \
+		/*DBG_871X("%s _rtw_set_pwr_state_check_timer(%p, %d)\n", __FUNCTION__, (pwrctrlpriv), (ms));*/ \
+		_set_timer(&(pwrctrlpriv)->pwr_state_check_timer, (ms)); \
+	} while(0)
+
+#define rtw_set_pwr_state_check_timer(pwrctrlpriv) \
+	_rtw_set_pwr_state_check_timer((pwrctrlpriv), (pwrctrlpriv)->pwr_state_check_interval)
+
+extern void rtw_init_pwrctrl_priv(struct rtl_priv *rtlpriv);
+
+extern void rtw_set_ps_mode(struct rtl_priv *rtlpriv, uint8_t ps_mode, uint8_t smart_ps, uint8_t bcn_ant_mode);
+extern void rtw_set_rpwm(struct rtl_priv * rtlpriv, uint8_t val8);
+extern void LeaveAllPowerSaveMode(struct rtl_priv *rtlpriv);
+#ifdef CONFIG_IPS
+void ips_enter(struct rtl_priv * rtlpriv);
+int ips_leave(struct rtl_priv * rtlpriv);
+#endif
+
+void rtw_ps_processor(struct rtl_priv*rtlpriv);
+
+#ifdef CONFIG_AUTOSUSPEND
+int autoresume_enter(struct rtl_priv* rtlpriv);
+#endif
+
+int32_t LPS_RF_ON_check(struct rtl_priv *rtlpriv, u32 delay_ms);
+void LPS_Enter(struct rtl_priv *rtlpriv);
+void LPS_Leave(struct rtl_priv *rtlpriv);
+
+/* ULLI resolve these #define's */
+
+int _rtw_pwr_wakeup(struct rtl_priv *rtlpriv, u32 ips_deffer_ms, const char *caller);
+#define rtw_pwr_wakeup(rtlpriv) _rtw_pwr_wakeup(rtlpriv, RTW_PWR_STATE_CHK_INTERVAL, __FUNCTION__)
+int rtw_pm_set_ips(struct rtl_priv *rtlpriv, uint8_t mode);
+int rtw_pm_set_lps(struct rtl_priv *rtlpriv, uint8_t mode);
+
+#endif  //__RTL871X_PWRCTRL_H_
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/include/rtw_qos.h linux-4.9.8821au/drivers/staging/rtl8821au/include/rtw_qos.h
--- linux-4.9/drivers/staging/rtl8821au/include/rtw_qos.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/include/rtw_qos.h	2016-12-11 19:48:25.173645047 -0600
@@ -0,0 +1,35 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+
+#ifndef _RTW_QOS_H_
+#define _RTW_QOS_H_
+
+
+
+struct	qos_priv	{
+	
+	unsigned int	  qos_option;	//bit mask option: u-apsd, s-apsd, ts, block ack...		
+
+};
+
+
+#endif	//_RTL871X_QOS_H_
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/include/rtw_recv.h linux-4.9.8821au/drivers/staging/rtl8821au/include/rtw_recv.h
--- linux-4.9/drivers/staging/rtl8821au/include/rtw_recv.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/include/rtw_recv.h	2016-12-11 19:48:25.173645047 -0600
@@ -0,0 +1,617 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef _RTW_RECV_H_
+#define _RTW_RECV_H_
+
+
+	#ifdef CONFIG_SINGLE_RECV_BUF
+		#define NR_RECVBUFF (1)
+	#else
+			#define NR_RECVBUFF (4)
+	#endif //CONFIG_SINGLE_RECV_BUF
+
+	#define NR_PREALLOC_RECV_SKB (8)
+
+#define NR_RECVFRAME 256
+
+#define RXFRAME_ALIGN	8
+#define RXFRAME_ALIGN_SZ	(1<<RXFRAME_ALIGN)
+
+#define DRVINFO_SZ	4 // unit is 8bytes
+
+#define MAX_RXFRAME_CNT	512
+#define MAX_RX_NUMBLKS		(32)
+#define RECVFRAME_HDR_ALIGN 128
+
+
+#define PHY_RSSI_SLID_WIN_MAX				100
+#define PHY_LINKQUALITY_SLID_WIN_MAX		20
+
+
+#define SNAP_SIZE sizeof(struct ieee80211_snap_hdr)
+
+#define RX_MPDU_QUEUE				0
+#define RX_CMD_QUEUE				1
+#define RX_MAX_QUEUE				2
+
+static uint8_t SNAP_ETH_TYPE_IPX[2] = {0x81, 0x37};
+
+static uint8_t SNAP_ETH_TYPE_APPLETALK_AARP[2] = {0x80, 0xf3};
+static uint8_t SNAP_ETH_TYPE_APPLETALK_DDP[2] = {0x80, 0x9b};
+static uint8_t SNAP_ETH_TYPE_TDLS[2] = {0x89, 0x0d};
+static uint8_t SNAP_HDR_APPLETALK_DDP[3] = {0x08, 0x00, 0x07}; // Datagram Delivery Protocol
+
+static uint8_t oui_8021h[] = {0x00, 0x00, 0xf8};
+static uint8_t oui_rfc1042[]= {0x00,0x00,0x00};
+
+#define MAX_SUBFRAME_COUNT	64
+static uint8_t rtw_rfc1042_header[] =
+{ 0xaa, 0xaa, 0x03, 0x00, 0x00, 0x00 };
+/* Bridge-Tunnel header (for EtherTypes ETH_P_AARP and ETH_P_IPX) */
+static uint8_t rtw_bridge_tunnel_header[] =
+{ 0xaa, 0xaa, 0x03, 0x00, 0x00, 0xf8 };
+
+//for Rx reordering buffer control
+struct recv_reorder_ctrl
+{
+	struct rtl_priv	*rtlpriv;
+	uint8_t enable;
+	u16 indicate_seq;//=wstart_b, init_value=0xffff
+	u16 wend_b;
+	uint8_t wsize_b;
+	struct __queue pending_recvframe_queue;
+	struct timer_list reordering_ctrl_timer;
+};
+
+struct	stainfo_rxcache	{
+	u16 	tid_rxseq[16];
+/*
+	unsigned short 	tid0_rxseq;
+	unsigned short 	tid1_rxseq;
+	unsigned short 	tid2_rxseq;
+	unsigned short 	tid3_rxseq;
+	unsigned short 	tid4_rxseq;
+	unsigned short 	tid5_rxseq;
+	unsigned short 	tid6_rxseq;
+	unsigned short 	tid7_rxseq;
+	unsigned short 	tid8_rxseq;
+	unsigned short 	tid9_rxseq;
+	unsigned short 	tid10_rxseq;
+	unsigned short 	tid11_rxseq;
+	unsigned short 	tid12_rxseq;
+	unsigned short 	tid13_rxseq;
+	unsigned short 	tid14_rxseq;
+	unsigned short 	tid15_rxseq;
+*/
+};
+
+
+struct smooth_rssi_data {
+	u32	elements[100];	//array to store values
+	u32	index;			//index to current array to store
+	u32	total_num;		//num of valid elements
+	u32	total_val;		//sum of valid elements
+};
+
+struct signal_stat {
+	uint8_t	update_req;		//used to indicate
+	uint8_t	avg_val;		//avg of valid elements
+	u32	total_num;		//num of valid elements
+	u32	total_val;		//sum of valid elements
+};
+
+struct phy_info
+{
+	uint8_t		RxPWDBAll;
+
+	uint8_t		SignalQuality;	 // in 0-100 index.
+	s8		RxMIMOSignalQuality[4];	//per-path's EVM
+	uint8_t		RxMIMOEVMdbm[4]; 		//per-path's EVM dbm
+
+	uint8_t		RxMIMOSignalStrength[4];// in 0~100 index
+
+	u16		Cfo_short[4]; 			// per-path's Cfo_short
+	u16		Cfo_tail[4];			// per-path's Cfo_tail
+
+	s8		RxPower; // in dBm Translate from PWdB
+	s8		RecvSignalPower;// Real power in dBm for this packet, no beautification and aggregation. Keep this raw info to be used for the other procedures.
+	uint8_t		BTRxRSSIPercentage;
+	uint8_t		SignalStrength; // in 0-100 index.
+
+	uint8_t		RxPwr[4];				//per-path's pwdb
+	uint8_t		RxSNR[4];				//per-path's SNR
+	uint8_t		BandWidth;
+	uint8_t		btCoexPwrAdjust;
+};
+
+
+struct rx_pkt_attrib	{
+	u16	pkt_len;
+	uint8_t	physt;
+	uint8_t	drvinfo_sz;
+	uint8_t	shift_sz;
+	uint8_t	hdrlen; //the WLAN Header Len
+	uint8_t 	to_fr_ds;
+	uint8_t 	amsdu;
+	uint8_t	qos;
+	uint8_t	priority;
+	uint8_t	pw_save;
+	uint8_t	mdata;
+	u16	seq_num;
+	uint8_t	frag_num;
+	uint8_t	mfrag;
+	uint8_t	order;
+	uint8_t	privacy; //in frame_ctrl field
+	uint8_t	bdecrypted;
+	uint8_t	encrypt; //when 0 indicate no encrypt. when non-zero, indicate the encrypt algorith
+	uint8_t	iv_len;
+	uint8_t	icv_len;
+	uint8_t	crc_err;
+	uint8_t	icv_err;
+
+	u16	eth_type;
+
+	uint8_t 	dst[ETH_ALEN];
+	uint8_t 	src[ETH_ALEN];
+	uint8_t 	ta[ETH_ALEN];
+	uint8_t 	ra[ETH_ALEN];
+	uint8_t 	bssid[ETH_ALEN];
+
+	uint8_t	ack_policy;
+
+	uint8_t 	key_index;
+
+	uint8_t	data_rate;
+	uint8_t 	sgi;
+	uint8_t 	pkt_rpt_type;
+	u32	MacIDValidEntry[2];	// 64 bits present 64 entry.
+
+/*
+	uint8_t	signal_qual;
+	s8	rx_mimo_signal_qual[2];
+	uint8_t	signal_strength;
+	u32	RxPWDBAll;
+	int32_t	RecvSignalPower;
+*/
+	struct phy_info phy_info;
+};
+
+
+//These definition is used for Rx packet reordering.
+#define SN_LESS(a, b)		(((a-b)&0x800)!=0)
+#define SN_EQUAL(a, b)	(a == b)
+//#define REORDER_WIN_SIZE	128
+//#define REORDER_ENTRY_NUM	128
+#define REORDER_WAIT_TIME	(50) // (ms)
+
+#define RECVBUFF_ALIGN_SZ 8
+
+#define RXDESC_SIZE	24
+#define RXDESC_OFFSET RXDESC_SIZE
+
+struct recv_stat
+{
+	unsigned int rxdw0;
+
+	unsigned int rxdw1;
+
+	unsigned int rxdw2;
+
+	unsigned int rxdw3;
+
+	unsigned int rxdw4;
+
+	unsigned int rxdw5;
+
+};
+
+#define EOR BIT(30)
+
+
+/*
+accesser of recv_priv: rtw_recv_entry(dispatch / passive level); recv_thread(passive) ; returnpkt(dispatch)
+; halt(passive) ;
+
+using enter_critical section to protect
+*/
+struct recv_priv
+{
+	spinlock_t	lock;
+
+	//struct __queue	blk_strms[MAX_RX_NUMBLKS];    // keeping the block ack frame until return ack
+	struct __queue	free_recv_queue;
+	struct __queue	recv_pending_queue;
+	struct __queue	uc_swdec_pending_queue;
+
+
+	uint8_t *pallocated_frame_buf;
+	uint8_t *precv_frame_buf;
+
+	uint free_recvframe_cnt;
+
+	struct rtl_priv	*rtlpriv;
+
+	u64	rx_bytes;
+	u64	rx_pkts;
+	u64	rx_drop;
+	u64	last_rx_bytes;
+
+	uint  rx_icv_err;
+	uint  rx_largepacket_crcerr;
+	uint  rx_smallpacket_crcerr;
+	uint  rx_middlepacket_crcerr;
+
+	//uint8_t *pallocated_urb_buf;
+	struct semaphore allrxreturnevt;
+	uint8_t	rx_pending_cnt;
+
+
+	struct tasklet_struct irq_prepare_beacon_tasklet;
+	struct tasklet_struct recv_tasklet;
+	struct sk_buff_head free_recv_skb_queue;
+	struct sk_buff_head rx_skb_queue;
+#ifdef CONFIG_RX_INDICATE_QUEUE
+	struct task rx_indicate_tasklet;
+	struct ifqueue rx_indicate_queue;
+#endif	// CONFIG_RX_INDICATE_QUEUE
+
+	uint8_t *pallocated_recv_buf;
+	uint8_t *precv_buf;    // 4 alignment
+	struct __queue	free_recv_buf_queue;
+	u32	free_recv_buf_queue_cnt;
+
+
+
+	//For display the phy informatiom
+	uint8_t is_signal_dbg;	// for debug
+	uint8_t signal_strength_dbg;	// for debug
+	s8 rssi;
+	s8 rxpwdb;
+	uint8_t signal_strength;
+	uint8_t signal_qual;
+	uint8_t noise;
+	int RxSNRdB[2];
+	s8 RxRssi[2];
+	int FalseAlmCnt_all;
+
+#ifdef CONFIG_NEW_SIGNAL_STAT_PROCESS
+	struct timer_list signal_stat_timer;
+	u32 signal_stat_sampling_interval;
+	//u32 signal_stat_converging_constant;
+	struct signal_stat signal_qual_data;
+	struct signal_stat signal_strength_data;
+#else //CONFIG_NEW_SIGNAL_STAT_PROCESS
+	struct smooth_rssi_data signal_qual_data;
+	struct smooth_rssi_data signal_strength_data;
+#endif //CONFIG_NEW_SIGNAL_STAT_PROCESS
+
+};
+
+#ifdef CONFIG_NEW_SIGNAL_STAT_PROCESS
+#define rtw_set_signal_stat_timer(recvpriv) _set_timer(&(recvpriv)->signal_stat_timer, (recvpriv)->signal_stat_sampling_interval)
+#endif //CONFIG_NEW_SIGNAL_STAT_PROCESS
+
+struct sta_recv_priv {
+
+	spinlock_t	lock;
+	int	option;
+
+	//struct __queue	blk_strms[MAX_RX_NUMBLKS];
+	struct __queue defrag_q;	 //keeping the fragment frame until defrag
+
+	struct	stainfo_rxcache rxcache;
+
+	//uint	sta_rx_bytes;
+	//uint	sta_rx_pkts;
+	//uint	sta_rx_fail;
+
+};
+
+
+struct recv_buf
+{
+	struct list_head list;
+
+	spinlock_t recvbuf_lock;
+
+	u32	ref_cnt;
+
+	struct rtl_priv *rtlpriv;
+	u32	len;
+
+	struct urb *purb;
+	dma_addr_t dma_transfer_addr;	/* (in) dma addr for transfer_buffer */
+	u32 alloc_sz;
+
+	uint8_t  irp_pending;
+
+	struct sk_buff *skb;
+	uint8_t	reuse;
+};
+
+
+/*
+	head  ----->
+
+		data  ----->
+
+			payload
+
+		tail  ----->
+
+
+	end   ----->
+
+	len = (unsigned int )(tail - data);
+
+*/
+struct recv_frame {
+	struct list_head	list;
+	struct sk_buff *skb;
+	struct rtl_priv  *rtlpriv;
+
+	uint8_t fragcnt;
+
+	int frame_tag;
+
+	struct rx_pkt_attrib attrib;
+
+	uint  len;
+	uint8_t *rx_head;
+	uint8_t *rx_data;
+	uint8_t *rx_tail;
+	uint8_t *rx_end;
+
+	void *precvbuf;
+
+
+	//
+	struct sta_info *psta;
+
+	//for A-MPDU Rx reordering buffer control
+	struct recv_reorder_ctrl *preorder_ctrl;
+};
+
+typedef enum _RX_PACKET_TYPE{
+	NORMAL_RX,//Normal rx packet
+	TX_REPORT1,//CCX
+	TX_REPORT2,//TX RPT
+	HIS_REPORT,// USB HISR RPT
+	C2H_PACKET
+}RX_PACKET_TYPE, *PRX_PACKET_TYPE;
+
+extern struct recv_frame *_rtw_alloc_recvframe (struct __queue *pfree_recv_queue);  //get a free recv_frame from pfree_recv_queue
+extern struct recv_frame *rtw_alloc_recvframe (struct __queue *pfree_recv_queue);  //get a free recv_frame from pfree_recv_queue
+extern void rtw_init_recvframe(struct recv_frame *precvframe ,struct recv_priv *precvpriv);
+extern int	 rtw_free_recvframe(struct recv_frame *precvframe, struct __queue *pfree_recv_queue);
+
+#define rtw_dequeue_recvframe(queue) rtw_alloc_recvframe(queue)
+extern int _rtw_enqueue_recvframe(struct recv_frame *precvframe, struct __queue *queue);
+extern int rtw_enqueue_recvframe(struct recv_frame *precvframe, struct __queue *queue);
+
+extern void rtw_free_recvframe_queue(struct __queue *pframequeue,  struct __queue *pfree_recv_queue);
+u32 rtw_free_uc_swdec_pending_queue(struct rtl_priv *rtlpriv);
+
+int rtw_enqueue_recvbuf_to_head(struct recv_buf *precvbuf, struct __queue *queue);
+int rtw_enqueue_recvbuf(struct recv_buf *precvbuf, struct __queue *queue);
+struct recv_buf *rtw_dequeue_recvbuf (struct __queue *queue);
+
+void rtw_reordering_ctrl_timeout_handler(void *pcontext);
+
+__inline static uint8_t *get_rxmem(struct recv_frame *precvframe)
+{
+	//always return rx_head...
+	if(precvframe==NULL)
+		return NULL;
+
+	return precvframe->rx_head;
+}
+
+__inline static uint8_t *get_rx_status(struct recv_frame *precvframe)
+{
+
+	return get_rxmem(precvframe);
+
+}
+
+__inline static uint8_t *get_recvframe_data(struct recv_frame *precvframe)
+{
+
+	//alwasy return rx_data
+	if(precvframe==NULL)
+		return NULL;
+
+	return precvframe->rx_data;
+
+}
+
+__inline static uint8_t *recvframe_push(struct recv_frame *precvframe, int sz)
+{
+	// append data before rx_data
+
+	/* add data to the start of recv_frame
+ *
+ *      This function extends the used data area of the recv_frame at the buffer
+ *      start. rx_data must be still larger than rx_head, after pushing.
+ */
+
+	if(precvframe==NULL)
+		return NULL;
+
+
+	precvframe->rx_data -= sz ;
+	if( precvframe->rx_data < precvframe->rx_head )
+	{
+		precvframe->rx_data += sz ;
+		return NULL;
+	}
+
+	precvframe->len +=sz;
+
+	return precvframe->rx_data;
+
+}
+
+
+__inline static uint8_t *recvframe_pull(struct recv_frame *precvframe, int sz)
+{
+	// rx_data += sz; move rx_data sz bytes  hereafter
+
+	//used for extract sz bytes from rx_data, update rx_data and return the updated rx_data to the caller
+
+
+	if(precvframe==NULL)
+		return NULL;
+
+
+	precvframe->rx_data += sz;
+
+	if(precvframe->rx_data > precvframe->rx_tail)
+	{
+		precvframe->rx_data -= sz;
+		return NULL;
+	}
+
+	precvframe->len -=sz;
+
+	return precvframe->rx_data;
+
+}
+
+__inline static uint8_t *recvframe_put(struct recv_frame *precvframe, int sz)
+{
+	// rx_tai += sz; move rx_tail sz bytes  hereafter
+
+	//used for append sz bytes from ptr to rx_tail, update rx_tail and return the updated rx_tail to the caller
+	//after putting, rx_tail must be still larger than rx_end.
+ 	unsigned char * prev_rx_tail;
+
+	if(precvframe==NULL)
+		return NULL;
+
+	prev_rx_tail = precvframe->rx_tail;
+
+	precvframe->rx_tail += sz;
+
+	if(precvframe->rx_tail > precvframe->rx_end)
+	{
+		precvframe->rx_tail -= sz;
+		return NULL;
+	}
+
+	precvframe->len +=sz;
+
+	return precvframe->rx_tail;
+
+}
+
+
+
+__inline static uint8_t *recvframe_pull_tail(struct recv_frame *precvframe, int sz)
+{
+	// rmv data from rx_tail (by yitsen)
+
+	//used for extract sz bytes from rx_end, update rx_end and return the updated rx_end to the caller
+	//after pulling, rx_end must be still larger than rx_data.
+
+	if(precvframe==NULL)
+		return NULL;
+
+	precvframe->rx_tail -= sz;
+
+	if(precvframe->rx_tail < precvframe->rx_data)
+	{
+		precvframe->rx_tail += sz;
+		return NULL;
+	}
+
+	precvframe->len -=sz;
+
+	return precvframe->rx_tail;
+
+}
+
+__inline static struct recv_frame *rxmem_to_recvframe(uint8_t *rxmem)
+{
+	//due to the design of 2048 bytes alignment of recv_frame, we can reference the struct recv_frame
+	//from any given member of recv_frame.
+	// rxmem indicates the any member/address in recv_frame
+
+	return (struct recv_frame*)(((SIZE_PTR)rxmem >> RXFRAME_ALIGN) << RXFRAME_ALIGN);
+
+}
+
+__inline static struct recv_frame *pkt_to_recvframe(struct sk_buff *pkt)
+{
+
+	uint8_t * buf_star;
+	struct recv_frame * precv_frame;
+	precv_frame = rxmem_to_recvframe((unsigned char*)buf_star);
+
+	return precv_frame;
+}
+
+__inline static uint8_t *pkt_to_recvmem(struct sk_buff *pkt)
+{
+	// return the rx_head
+
+	struct recv_frame * precv_frame = pkt_to_recvframe(pkt);
+
+	return 	precv_frame->rx_head;
+
+}
+
+__inline static uint8_t *pkt_to_recvdata(struct sk_buff *pkt)
+{
+	// return the rx_data
+
+	struct recv_frame * precv_frame =pkt_to_recvframe(pkt);
+
+	return 	precv_frame->rx_data;
+
+}
+
+
+__inline static int get_recvframe_len(struct recv_frame *precvframe)
+{
+	return precvframe->len;
+}
+
+
+__inline static int32_t translate_percentage_to_dbm(u32 SignalStrengthIndex)
+{
+	int32_t	SignalPower; // in dBm.
+
+	// Translate to dBm (x=0.5y-95).
+	SignalPower = (int32_t)((SignalStrengthIndex + 1) >> 1);
+	SignalPower -= 95;
+
+	return SignalPower;
+}
+
+
+struct sta_info;
+
+extern void _rtw_init_sta_recv_priv(struct sta_recv_priv *psta_recvpriv);
+
+extern void  mgt_dispatcher(struct rtl_priv *rtlpriv, struct recv_frame *precv_frame);
+
+#endif
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/include/rtw_rf.h linux-4.9.8821au/drivers/staging/rtl8821au/include/rtw_rf.h
--- linux-4.9/drivers/staging/rtl8821au/include/rtw_rf.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/include/rtw_rf.h	2016-12-11 19:48:25.173645047 -0600
@@ -0,0 +1,180 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef	__RTW_RF_H_
+#define __RTW_RF_H_
+
+
+#define OFDM_PHY		1
+#define MIXED_PHY		2
+#define CCK_PHY		3
+
+#define NumRates	(13)
+
+// slot time for 11g
+#define SHORT_SLOT_TIME					9
+#define NON_SHORT_SLOT_TIME				20
+
+#define RTL8711_RF_MAX_SENS 6
+#define RTL8711_RF_DEF_SENS 4
+
+//
+// We now define the following channels as the max channels in each channel plan.
+// 2G, total 14 chnls
+// {1,2,3,4,5,6,7,8,9,10,11,12,13,14}
+// 5G, total 24 chnls
+// {36,40,44,48,52,56,60,64,100,104,108,112,116,120,124,128,132,136,140,149,153,157,161,165}
+#define	MAX_CHANNEL_NUM_2G				14
+#define	MAX_CHANNEL_NUM_5G				24
+#define	MAX_CHANNEL_NUM					38//14+24
+
+//#define NUM_REGULATORYS	21
+#define NUM_REGULATORYS	1
+
+//Country codes
+#define USA							0x555320
+#define EUROPE						0x1 //temp, should be provided later
+#define JAPAN						0x2 //temp, should be provided later
+
+struct	regulatory_class {
+	u32	starting_freq;					//MHz,
+	uint8_t	channel_set[MAX_CHANNEL_NUM];
+	uint8_t	channel_cck_power[MAX_CHANNEL_NUM];//dbm
+	uint8_t	channel_ofdm_power[MAX_CHANNEL_NUM];//dbm
+	uint8_t	txpower_limit;  				//dbm
+	uint8_t	channel_spacing;				//MHz
+	uint8_t	modem;
+};
+
+typedef enum _CAPABILITY{
+	cESS			= 0x0001,
+	cIBSS			= 0x0002,
+	cPollable		= 0x0004,
+	cPollReq			= 0x0008,
+	cPrivacy		= 0x0010,
+	cShortPreamble	= 0x0020,
+	cPBCC			= 0x0040,
+	cChannelAgility	= 0x0080,
+	cSpectrumMgnt	= 0x0100,
+	cQos			= 0x0200,	// For HCCA, use with CF-Pollable and CF-PollReq
+	cShortSlotTime	= 0x0400,
+	cAPSD			= 0x0800,
+	cRM				= 0x1000,	// RRM (Radio Request Measurement)
+	cDSSS_OFDM	= 0x2000,
+	cDelayedBA		= 0x4000,
+	cImmediateBA	= 0x8000,
+}CAPABILITY, *PCAPABILITY;
+
+enum	_REG_PREAMBLE_MODE{
+	PREAMBLE_LONG	= 1,
+	PREAMBLE_AUTO	= 2,
+	PREAMBLE_SHORT	= 3,
+};
+
+
+enum _RTL8712_RF_MIMO_CONFIG_{
+ RTL8712_RFCONFIG_1T=0x10,
+ RTL8712_RFCONFIG_2T=0x20,
+ RTL8712_RFCONFIG_1R=0x01,
+ RTL8712_RFCONFIG_2R=0x02,
+ RTL8712_RFCONFIG_1T1R=0x11,
+ RTL8712_RFCONFIG_1T2R=0x12,
+ RTL8712_RFCONFIG_TURBO=0x92,
+ RTL8712_RFCONFIG_2T2R=0x22
+};
+
+// Bandwidth Offset
+#define HAL_PRIME_CHNL_OFFSET_DONT_CARE	0
+#define HAL_PRIME_CHNL_OFFSET_LOWER	1
+#define HAL_PRIME_CHNL_OFFSET_UPPER	2
+
+// Represent Channel Width in HT Capabilities
+//
+enum CHANNEL_WIDTH{
+	CHANNEL_WIDTH_20 = 0,
+	CHANNEL_WIDTH_40 = 1,
+	CHANNEL_WIDTH_80 = 2,
+	CHANNEL_WIDTH_160 = 3,
+	CHANNEL_WIDTH_80_80 = 4,
+	CHANNEL_WIDTH_MAX = 5,
+};
+
+//
+// Represent Extention Channel Offset in HT Capabilities
+// This is available only in 40Mhz mode.
+//
+typedef enum _EXTCHNL_OFFSET{
+	EXTCHNL_OFFSET_NO_EXT = 0,
+	EXTCHNL_OFFSET_UPPER = 1,
+	EXTCHNL_OFFSET_NO_DEF = 2,
+	EXTCHNL_OFFSET_LOWER = 3,
+}EXTCHNL_OFFSET, *PEXTCHNL_OFFSET;
+
+typedef enum _VHT_DATA_SC{
+	VHT_DATA_SC_DONOT_CARE = 0,
+	VHT_DATA_SC_20_UPPER_OF_80MHZ = 1,
+	VHT_DATA_SC_20_LOWER_OF_80MHZ = 2,
+	VHT_DATA_SC_20_UPPERST_OF_80MHZ = 3,
+	VHT_DATA_SC_20_LOWEST_OF_80MHZ = 4,
+	VHT_DATA_SC_20_RECV1 = 5,
+	VHT_DATA_SC_20_RECV2 = 6,
+	VHT_DATA_SC_20_RECV3 = 7,
+	VHT_DATA_SC_20_RECV4 = 8,
+	VHT_DATA_SC_40_UPPER_OF_80MHZ = 9,
+	VHT_DATA_SC_40_LOWER_OF_80MHZ = 10,
+}VHT_DATA_SC, *PVHT_DATA_SC_E;
+
+typedef enum _PROTECTION_MODE{
+	PROTECTION_MODE_AUTO = 0,
+	PROTECTION_MODE_FORCE_ENABLE = 1,
+	PROTECTION_MODE_FORCE_DISABLE = 2,
+}PROTECTION_MODE, *PPROTECTION_MODE;
+
+#define	LDPC_VHT_ENABLE_RX			BIT(0)
+#define	LDPC_VHT_ENABLE_TX			BIT(1)
+#define	LDPC_VHT_TEST_TX_ENABLE			BIT(2)
+#define	LDPC_VHT_CAP_TX				BIT(3)
+
+#define	STBC_VHT_ENABLE_RX			BIT(0)
+#define	STBC_VHT_ENABLE_TX			BIT(1)
+#define	STBC_VHT_TEST_TX_ENABLE			BIT(2)
+#define	STBC_VHT_CAP_TX				BIT(3)
+
+#define	BEAMFORMING_VHT_BEAMFORMER_ENABLE	BIT(0)	// Declare our NIC supports beamformer
+#define	BEAMFORMING_VHT_BEAMFORMEE_ENABLE	BIT(1)	// Declare our NIC supports beamformee
+#define	BEAMFORMING_VHT_BEAMFORMER_TEST		BIT(2)	// Transmiting Beamforming no matter the target supports it or not
+
+/* 2007/11/15 MH Define different RF type. */
+typedef	enum _RT_RF_TYPE_DEFINITION
+{
+	RF_1T2R = 0,
+	RF_2T4R = 1,
+	RF_2T2R = 2,
+	RF_1T1R = 3,
+	RF_2T2R_GREEN = 4,
+	RF_MAX_TYPE = 5,
+}RT_RF_TYPE_DEF_E;
+
+
+u32 rtw_ch2freq(u32 ch);
+u32 rtw_freq2ch(u32 freq);
+
+
+#endif //_RTL8711_RF_H_
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/include/rtw_security.h linux-4.9.8821au/drivers/staging/rtl8821au/include/rtw_security.h
--- linux-4.9/drivers/staging/rtl8821au/include/rtw_security.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/include/rtw_security.h	2016-12-11 19:48:25.173645047 -0600
@@ -0,0 +1,404 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __RTW_SECURITY_H_
+#define __RTW_SECURITY_H_
+
+#define is_wep_enc(alg) (((alg) == WEP40_ENCRYPTION) || ((alg) == WEP104_ENCRYPTION))
+
+#define _WPA_IE_ID_	0xdd
+#define _WPA2_IE_ID_	0x30
+
+#define SHA256_MAC_LEN 32
+#define AES_BLOCK_SIZE 16
+#define AES_PRIV_SIZE (4 * 44)
+
+typedef enum {
+	ENCRYP_PROTOCOL_OPENSYS,   //open system
+	ENCRYP_PROTOCOL_WEP,       //WEP
+	ENCRYP_PROTOCOL_WPA,       //WPA
+	ENCRYP_PROTOCOL_WPA2,      //WPA2
+	ENCRYP_PROTOCOL_WAPI,      //WAPI: Not support in this version
+	ENCRYP_PROTOCOL_MAX
+}ENCRYP_PROTOCOL_E;
+
+
+#ifndef Ndis802_11AuthModeWPA2
+#define Ndis802_11AuthModeWPA2 (Ndis802_11AuthModeWPANone + 1)
+#endif
+
+#ifndef Ndis802_11AuthModeWPA2PSK
+#define Ndis802_11AuthModeWPA2PSK (Ndis802_11AuthModeWPANone + 2)
+#endif
+
+union pn48	{
+
+	u64	val;
+
+#ifdef CONFIG_LITTLE_ENDIAN
+
+struct {
+  uint8_t TSC0;
+  uint8_t TSC1;
+  uint8_t TSC2;
+  uint8_t TSC3;
+  uint8_t TSC4;
+  uint8_t TSC5;
+  uint8_t TSC6;
+  uint8_t TSC7;
+} _byte_;
+
+#elif defined(CONFIG_BIG_ENDIAN)
+
+struct {
+  uint8_t TSC7;
+  uint8_t TSC6;
+  uint8_t TSC5;
+  uint8_t TSC4;
+  uint8_t TSC3;
+  uint8_t TSC2;
+  uint8_t TSC1;
+  uint8_t TSC0;
+} _byte_;
+
+#endif
+
+};
+
+union Keytype {
+        uint8_t   skey[16];
+        u32    lkey[4];
+};
+
+
+typedef struct _RT_PMKID_LIST
+{
+	uint8_t						bUsed;
+	uint8_t 						Bssid[6];
+	uint8_t						PMKID[16];
+	uint8_t						SsidBuf[33];
+	u8*						ssid_octet;
+	u16 						ssid_length;
+} RT_PMKID_LIST, *PRT_PMKID_LIST;
+
+
+struct security_priv
+{
+	u32	  dot11AuthAlgrthm;		// 802.11 auth, could be open, shared, 8021x and authswitch
+	u32	  dot11PrivacyAlgrthm;	// This specify the privacy for shared auth. algorithm.
+
+	/* WEP */
+	u32	  dot11PrivacyKeyIndex;	// this is only valid for legendary wep, 0~3 for key id. (tx key index)
+	union Keytype dot11DefKey[4];			// this is only valid for def. key
+	u32 	dot11DefKeylen[4];
+
+	u32 dot118021XGrpPrivacy;	// This specify the privacy algthm. used for Grp key
+	u32	dot118021XGrpKeyid;		// key id used for Grp Key ( tx key index)
+	union Keytype	dot118021XGrpKey[4];	// 802.1x Group Key, for inx0 and inx1
+	union Keytype	dot118021XGrptxmickey[4];
+	union Keytype	dot118021XGrprxmickey[4];
+	union pn48		dot11Grptxpn;			// PN48 used for Grp Key xmit.
+	union pn48		dot11Grprxpn;			// PN48 used for Grp Key recv.
+
+#ifdef CONFIG_AP_MODE
+	//extend security capabilities for AP_MODE
+	unsigned int dot8021xalg;//0:disable, 1:psk, 2:802.1x
+	unsigned int wpa_psk;//0:disable, bit(0): WPA, bit(1):WPA2
+	unsigned int wpa_group_cipher;
+	unsigned int wpa2_group_cipher;
+	unsigned int wpa_pairwise_cipher;
+	unsigned int wpa2_pairwise_cipher;
+#endif
+
+	uint8_t wps_ie[MAX_WPS_IE_LEN];//added in assoc req
+	int wps_ie_len;
+
+
+	uint8_t	binstallGrpkey;
+	uint8_t	busetkipkey;
+	//_timer tkip_timer;
+	uint8_t	bcheck_grpkey;
+	uint8_t	bgrpkey_handshake;
+
+	//uint8_t	packet_cnt;//unused, removed
+
+	int32_t	sw_encrypt;//from registry_priv
+	int32_t	sw_decrypt;//from registry_priv
+
+	int32_t 	hw_decrypted;//if the rx packets is hw_decrypted==false, it means the hw has not been ready.
+
+
+	//keeps the auth_type & enc_status from upper layer ioctl(wpa_supplicant or wzc)
+	u32 ndisauthtype;	// NDIS_802_11_AUTHENTICATION_MODE
+	u32 ndisencryptstatus;	// NDIS_802_11_ENCRYPTION_STATUS
+
+	WLAN_BSSID_EX sec_bss;  //for joinbss (h2c buffer) usage
+
+	NDIS_802_11_WEP ndiswep;
+
+	uint8_t assoc_info[600];
+	uint8_t szofcapability[256]; //for wpa2 usage
+	uint8_t oidassociation[512]; //for wpa/wpa2 usage
+	uint8_t authenticator_ie[256];  //store ap security information element
+	uint8_t supplicant_ie[256];  //store sta security information element
+
+
+	//for tkip countermeasure
+	u32 last_mic_err_time;
+	uint8_t	btkip_countermeasure;
+	uint8_t	btkip_wait_report;
+	u32 btkip_countermeasure_time;
+
+	//---------------------------------------------------------------------------
+	// For WPA2 Pre-Authentication.
+	//---------------------------------------------------------------------------
+	//uint8_t				RegEnablePreAuth;				// Default value: Pre-Authentication enabled or not, from registry "EnablePreAuth". Added by Annie, 2005-11-01.
+	//uint8_t				EnablePreAuthentication;			// Current Value: Pre-Authentication enabled or not.
+	RT_PMKID_LIST		PMKIDList[NUM_PMKID_CACHE];	// Renamed from PreAuthKey[NUM_PRE_AUTH_KEY]. Annie, 2006-10-13.
+	uint8_t				PMKIDIndex;
+	//u32				PMKIDCount;						// Added by Annie, 2006-10-13.
+	//uint8_t				szCapability[256];				// For WPA2-PSK using zero-config, by Annie, 2005-09-20.
+
+	uint8_t bWepDefaultKeyIdxSet;
+};
+
+struct sha256_state {
+	u64 length;
+	u32 state[8], curlen;
+	uint8_t buf[64];
+};
+
+#define GET_ENCRY_ALGO(psecuritypriv, psta, encry_algo, bmcst)\
+do{\
+	switch(psecuritypriv->dot11AuthAlgrthm)\
+	{\
+		case dot11AuthAlgrthm_Open:\
+		case dot11AuthAlgrthm_Shared:\
+		case dot11AuthAlgrthm_Auto:\
+			encry_algo = (uint8_t)psecuritypriv->dot11PrivacyAlgrthm;\
+			break;\
+		case dot11AuthAlgrthm_8021X:\
+			if(bmcst)\
+				encry_algo = (uint8_t)psecuritypriv->dot118021XGrpPrivacy;\
+			else\
+				encry_algo =(uint8_t) psta->dot118021XPrivacy;\
+			break;\
+	     case dot11AuthAlgrthm_WAPI:\
+		     encry_algo = (uint8_t)psecuritypriv->dot11PrivacyAlgrthm;\
+		     break;\
+	}\
+}while(0)
+
+
+#define SET_ICE_IV_LEN( iv_len, icv_len, encrypt)\
+do{\
+	switch(encrypt)\
+	{\
+		case WEP40_ENCRYPTION:\
+		case WEP104_ENCRYPTION:\
+			iv_len = 4;\
+			icv_len = 4;\
+			break;\
+		case TKIP_ENCRYPTION:\
+			iv_len = 8;\
+			icv_len = 4;\
+			break;\
+		case AESCCMP_ENCRYPTION:\
+			iv_len = 8;\
+			icv_len = 8;\
+			break;\
+		default:\
+			iv_len = 0;\
+			icv_len = 0;\
+			break;\
+	}\
+}while(0)
+
+
+#define GET_TKIP_PN(iv,dot11txpn)\
+do{\
+	dot11txpn._byte_.TSC0=iv[2];\
+	dot11txpn._byte_.TSC1=iv[0];\
+	dot11txpn._byte_.TSC2=iv[4];\
+	dot11txpn._byte_.TSC3=iv[5];\
+	dot11txpn._byte_.TSC4=iv[6];\
+	dot11txpn._byte_.TSC5=iv[7];\
+}while(0)
+
+
+#define ROL32( A, n )	( ((A) << (n)) | ( ((A)>>(32-(n)))  & ( (1UL << (n)) - 1 ) ) )
+#define ROR32( A, n ) 	ROL32( (A), 32-(n) )
+
+struct mic_data
+{
+	u32  K0, K1;         // Key
+	u32  L, R;           // Current state
+	u32  M;              // Message accumulator (single word)
+	u32     nBytesInM;      // # bytes in M
+};
+
+extern const u32 Te0[256];
+extern const u32 Te1[256];
+extern const u32 Te2[256];
+extern const u32 Te3[256];
+extern const u32 Te4[256];
+extern const u32 Td0[256];
+extern const u32 Td1[256];
+extern const u32 Td2[256];
+extern const u32 Td3[256];
+extern const u32 Td4[256];
+extern const u32 rcon[10];
+extern const uint8_t Td4s[256];
+extern const uint8_t rcons[10];
+
+#define RCON(i) (rcons[(i)] << 24)
+
+static inline u32 rotr(u32 val, int bits)
+{
+	return (val >> bits) | (val << (32 - bits));
+}
+
+#define TE0(i) Te0[((i) >> 24) & 0xff]
+#define TE1(i) rotr(Te0[((i) >> 16) & 0xff], 8)
+#define TE2(i) rotr(Te0[((i) >> 8) & 0xff], 16)
+#define TE3(i) rotr(Te0[(i) & 0xff], 24)
+#define TE41(i) ((Te0[((i) >> 24) & 0xff] << 8) & 0xff000000)
+#define TE42(i) (Te0[((i) >> 16) & 0xff] & 0x00ff0000)
+#define TE43(i) (Te0[((i) >> 8) & 0xff] & 0x0000ff00)
+#define TE44(i) ((Te0[(i) & 0xff] >> 8) & 0x000000ff)
+#define TE421(i) ((Te0[((i) >> 16) & 0xff] << 8) & 0xff000000)
+#define TE432(i) (Te0[((i) >> 8) & 0xff] & 0x00ff0000)
+#define TE443(i) (Te0[(i) & 0xff] & 0x0000ff00)
+#define TE414(i) ((Te0[((i) >> 24) & 0xff] >> 8) & 0x000000ff)
+#define TE4(i) ((Te0[(i)] >> 8) & 0x000000ff)
+
+#define TD0(i) Td0[((i) >> 24) & 0xff]
+#define TD1(i) rotr(Td0[((i) >> 16) & 0xff], 8)
+#define TD2(i) rotr(Td0[((i) >> 8) & 0xff], 16)
+#define TD3(i) rotr(Td0[(i) & 0xff], 24)
+#define TD41(i) (Td4s[((i) >> 24) & 0xff] << 24)
+#define TD42(i) (Td4s[((i) >> 16) & 0xff] << 16)
+#define TD43(i) (Td4s[((i) >> 8) & 0xff] << 8)
+#define TD44(i) (Td4s[(i) & 0xff])
+#define TD0_(i) Td0[(i) & 0xff]
+#define TD1_(i) rotr(Td0[(i) & 0xff], 8)
+#define TD2_(i) rotr(Td0[(i) & 0xff], 16)
+#define TD3_(i) rotr(Td0[(i) & 0xff], 24)
+
+#define GETU32(pt) (((u32)(pt)[0] << 24) ^ ((u32)(pt)[1] << 16) ^ \
+			((u32)(pt)[2] <<  8) ^ ((u32)(pt)[3]))
+
+#define PUTU32(ct, st) { \
+(ct)[0] = (uint8_t)((st) >> 24); (ct)[1] = (uint8_t)((st) >> 16); \
+(ct)[2] = (uint8_t)((st) >>  8); (ct)[3] = (uint8_t)(st); }
+
+#define WPA_GET_BE32(a) ((((u32) (a)[0]) << 24) | (((u32) (a)[1]) << 16) | \
+			 (((u32) (a)[2]) << 8) | ((u32) (a)[3]))
+
+#define WPA_PUT_LE16(a, val)			\
+	do {					\
+		(a)[1] = ((u16) (val)) >> 8;	\
+		(a)[0] = ((u16) (val)) & 0xff;	\
+	} while (0)
+
+#define WPA_PUT_BE32(a, val)					\
+	do {							\
+		(a)[0] = (uint8_t) ((((u32) (val)) >> 24) & 0xff);	\
+		(a)[1] = (uint8_t) ((((u32) (val)) >> 16) & 0xff);	\
+		(a)[2] = (uint8_t) ((((u32) (val)) >> 8) & 0xff);	\
+		(a)[3] = (uint8_t) (((u32) (val)) & 0xff);		\
+	} while (0)
+
+#define WPA_PUT_BE64(a, val)				\
+	do {						\
+		(a)[0] = (uint8_t) (((u64) (val)) >> 56);	\
+		(a)[1] = (uint8_t) (((u64) (val)) >> 48);	\
+		(a)[2] = (uint8_t) (((u64) (val)) >> 40);	\
+		(a)[3] = (uint8_t) (((u64) (val)) >> 32);	\
+		(a)[4] = (uint8_t) (((u64) (val)) >> 24);	\
+		(a)[5] = (uint8_t) (((u64) (val)) >> 16);	\
+		(a)[6] = (uint8_t) (((u64) (val)) >> 8);	\
+		(a)[7] = (uint8_t) (((u64) (val)) & 0xff);	\
+	} while (0)
+
+/* ===== start - public domain SHA256 implementation ===== */
+
+/* This is based on SHA256 implementation in LibTomCrypt that was released into
+ * public domain by Tom St Denis. */
+
+/* the K array */
+static const unsigned long K[64] = {
+	0x428a2f98UL, 0x71374491UL, 0xb5c0fbcfUL, 0xe9b5dba5UL, 0x3956c25bUL,
+	0x59f111f1UL, 0x923f82a4UL, 0xab1c5ed5UL, 0xd807aa98UL, 0x12835b01UL,
+	0x243185beUL, 0x550c7dc3UL, 0x72be5d74UL, 0x80deb1feUL, 0x9bdc06a7UL,
+	0xc19bf174UL, 0xe49b69c1UL, 0xefbe4786UL, 0x0fc19dc6UL, 0x240ca1ccUL,
+	0x2de92c6fUL, 0x4a7484aaUL, 0x5cb0a9dcUL, 0x76f988daUL, 0x983e5152UL,
+	0xa831c66dUL, 0xb00327c8UL, 0xbf597fc7UL, 0xc6e00bf3UL, 0xd5a79147UL,
+	0x06ca6351UL, 0x14292967UL, 0x27b70a85UL, 0x2e1b2138UL, 0x4d2c6dfcUL,
+	0x53380d13UL, 0x650a7354UL, 0x766a0abbUL, 0x81c2c92eUL, 0x92722c85UL,
+	0xa2bfe8a1UL, 0xa81a664bUL, 0xc24b8b70UL, 0xc76c51a3UL, 0xd192e819UL,
+	0xd6990624UL, 0xf40e3585UL, 0x106aa070UL, 0x19a4c116UL, 0x1e376c08UL,
+	0x2748774cUL, 0x34b0bcb5UL, 0x391c0cb3UL, 0x4ed8aa4aUL, 0x5b9cca4fUL,
+	0x682e6ff3UL, 0x748f82eeUL, 0x78a5636fUL, 0x84c87814UL, 0x8cc70208UL,
+	0x90befffaUL, 0xa4506cebUL, 0xbef9a3f7UL, 0xc67178f2UL
+};
+
+
+/* Various logical functions */
+#define RORc(x, y) \
+( ((((unsigned long) (x) & 0xFFFFFFFFUL) >> (unsigned long) ((y) & 31)) | \
+   ((unsigned long) (x) << (unsigned long) (32 - ((y) & 31)))) & 0xFFFFFFFFUL)
+#define Ch(x,y,z)       (z ^ (x & (y ^ z)))
+#define Maj(x,y,z)      (((x | y) & z) | (x & y))
+#define S(x, n)         RORc((x), (n))
+#define R(x, n)         (((x)&0xFFFFFFFFUL)>>(n))
+#define Sigma0(x)       (S(x, 2) ^ S(x, 13) ^ S(x, 22))
+#define Sigma1(x)       (S(x, 6) ^ S(x, 11) ^ S(x, 25))
+#define Gamma0(x)       (S(x, 7) ^ S(x, 18) ^ R(x, 3))
+#define Gamma1(x)       (S(x, 17) ^ S(x, 19) ^ R(x, 10))
+#ifndef MIN
+#define MIN(x, y) (((x) < (y)) ? (x) : (y))
+#endif
+
+void rtw_secmicsetkey(struct mic_data *pmicdata, uint8_t * key );
+void rtw_secmicappendbyte(struct mic_data *pmicdata, uint8_t b );
+void rtw_secmicappend(struct mic_data *pmicdata, uint8_t * src, u32 nBytes );
+void rtw_secgetmic(struct mic_data *pmicdata, uint8_t * dst );
+
+void rtw_seccalctkipmic(
+	uint8_t * key,
+	uint8_t *header,
+	uint8_t *data,
+	u32 data_len,
+	uint8_t *Miccode,
+	uint8_t   priority);
+
+u32 rtw_aes_encrypt(struct rtl_priv *rtlpriv, uint8_t *pxmitframe);
+u32 rtw_tkip_encrypt(struct rtl_priv *rtlpriv, uint8_t *pxmitframe);
+void rtw_wep_encrypt(struct rtl_priv *rtlpriv, uint8_t  *pxmitframe);
+
+u32 rtw_aes_decrypt(struct rtl_priv *rtlpriv, struct recv_frame *precvframe);
+u32 rtw_tkip_decrypt(struct rtl_priv *rtlpriv, struct recv_frame *precvframe);
+void rtw_wep_decrypt(struct rtl_priv *rtlpriv, struct recv_frame *precvframe);
+
+
+void rtw_use_tkipkey_handler(RTW_TIMER_HDL_ARGS);
+
+#endif	//__RTL871X_SECURITY_H_
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/include/rtw_vht.h linux-4.9.8821au/drivers/staging/rtl8821au/include/rtw_vht.h
--- linux-4.9/drivers/staging/rtl8821au/include/rtw_vht.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/include/rtw_vht.h	2016-12-11 19:48:25.176978367 -0600
@@ -0,0 +1,126 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef _RTW_VHT_H_
+#define _RTW_VHT_H_
+
+
+//VHT capability info
+#define SET_VHT_CAPABILITY_ELE_MAX_MPDU_LENGTH(_pEleStart, _val)			SET_BITS_TO_LE_1BYTE(_pEleStart, 0, 2, _val)
+#define SET_VHT_CAPABILITY_ELE_CHL_WIDTH(_pEleStart, _val)			SET_BITS_TO_LE_1BYTE(_pEleStart, 2, 2, _val)
+#define SET_VHT_CAPABILITY_ELE_RX_LDPC(_pEleStart, _val)			SET_BITS_TO_LE_1BYTE(_pEleStart, 4, 1, _val)
+#define SET_VHT_CAPABILITY_ELE_SHORT_GI80M(_pEleStart, _val)				SET_BITS_TO_LE_1BYTE(_pEleStart, 5, 1, _val)
+#define SET_VHT_CAPABILITY_ELE_SHORT_GI160M(_pEleStart, _val)				SET_BITS_TO_LE_1BYTE(_pEleStart, 6, 1, _val)
+#define SET_VHT_CAPABILITY_ELE_TX_STBC(_pEleStart, _val)				SET_BITS_TO_LE_1BYTE(_pEleStart, 7, 1, _val)
+#define SET_VHT_CAPABILITY_ELE_RX_STBC(_pEleStart, _val)				SET_BITS_TO_LE_1BYTE((_pEleStart)+1, 0, 3, _val)
+#define SET_VHT_CAPABILITY_ELE_SU_BFER(_pEleStart, _val)				SET_BITS_TO_LE_1BYTE((_pEleStart)+1, 3, 1, _val)
+#define SET_VHT_CAPABILITY_ELE_SU_BFEE(_pEleStart, _val)				SET_BITS_TO_LE_1BYTE((_pEleStart)+1, 4, 1, _val)
+#define SET_VHT_CAPABILITY_ELE_BFER_ANT_SUPP(_pEleStart, _val)				SET_BITS_TO_LE_1BYTE((_pEleStart)+1, 5, 3, _val)
+#define SET_VHT_CAPABILITY_ELE_SOUNDING_DIMENSIONS(_pEleStart, _val)				SET_BITS_TO_LE_1BYTE((_pEleStart)+2, 0, 3, _val)
+#define SET_VHT_CAPABILITY_ELE_MU_BFER(_pEleStart, _val)				SET_BITS_TO_LE_1BYTE((_pEleStart)+2, 3, 1, _val)
+#define SET_VHT_CAPABILITY_ELE_MU_BFEE(_pEleStart, _val)				SET_BITS_TO_LE_1BYTE((_pEleStart)+2, 4, 1, _val)
+#define SET_VHT_CAPABILITY_ELE_TXOP_PS(_pEleStart, _val)				SET_BITS_TO_LE_1BYTE((_pEleStart)+2, 5, 1, _val)
+#define SET_VHT_CAPABILITY_ELE_HTC_VHT(_pEleStart, _val)				SET_BITS_TO_LE_1BYTE((_pEleStart)+2, 6, 1, _val)
+#define SET_VHT_CAPABILITY_ELE_MAX_RXAMPDU_FACTOR(_pEleStart, _val)		SET_BITS_TO_LE_2BYTE((_pEleStart)+2, 7, 3, _val) //B23~B25
+#define SET_VHT_CAPABILITY_ELE_LINK_ADAPTION(_pEleStart, _val)				SET_BITS_TO_LE_1BYTE((_pEleStart)+2, 2, 2, _val)
+#define SET_VHT_CAPABILITY_ELE_MCS_RX_MAP(_pEleStart, _val)				SET_BITS_TO_LE_2BYTE((_pEleStart)+4, 0, 16, _val)   //B0~B15 indicate Rx MCS MAP, we write 0 to indicate MCS0~7. by page
+#define SET_VHT_CAPABILITY_ELE_MCS_RX_HIGHEST_RATE(_pEleStart, _val)				SET_BITS_TO_LE_2BYTE((_pEleStart)+6, 0, 13, _val)
+#define SET_VHT_CAPABILITY_ELE_MCS_TX_MAP(_pEleStart, _val)				SET_BITS_TO_LE_2BYTE((_pEleStart)+8, 0, 16, _val)   //B0~B15 indicate Tx MCS MAP, we write 0 to indicate MCS0~7. by page
+#define SET_VHT_CAPABILITY_ELE_MCS_TX_HIGHEST_RATE(_pEleStart, _val)				SET_BITS_TO_LE_2BYTE((_pEleStart)+10, 0, 13, _val)
+
+
+#define GET_VHT_CAPABILITY_ELE_MAX_MPDU_LENGTH(_pEleStart)			LE_BITS_TO_1BYTE(_pEleStart, 0, 2)
+#define GET_VHT_CAPABILITY_ELE_CHL_WIDTH(_pEleStart)				LE_BITS_TO_1BYTE(_pEleStart, 2, 2)
+#define GET_VHT_CAPABILITY_ELE_RX_LDPC(_pEleStart)			LE_BITS_TO_1BYTE(_pEleStart, 4, 1)
+#define GET_VHT_CAPABILITY_ELE_SHORT_GI80M(_pEleStart)				LE_BITS_TO_1BYTE(_pEleStart, 5, 1)
+#define GET_VHT_CAPABILITY_ELE_SHORT_GI160M(_pEleStart)				LE_BITS_TO_1BYTE(_pEleStart, 6, 1)
+#define GET_VHT_CAPABILITY_ELE_TX_STBC(_pEleStart)				LE_BITS_TO_1BYTE(_pEleStart, 7, 1)
+#define GET_VHT_CAPABILITY_ELE_RX_STBC(_pEleStart)				LE_BITS_TO_1BYTE((_pEleStart)+1, 0, 3)
+#define GET_VHT_CAPABILITY_ELE_SU_BFER(_pEleStart)					LE_BITS_TO_1BYTE((_pEleStart)+1, 3, 1)
+#define GET_VHT_CAPABILITY_ELE_SU_BFEE(_pEleStart)					LE_BITS_TO_1BYTE((_pEleStart)+1, 4, 1)
+#define GET_VHT_CAPABILITY_ELE_TXOP_PS(_pEleStart)				LE_BITS_TO_1BYTE((_pEleStart)+2, 5, 1)
+#define GET_VHT_CAPABILITY_ELE_MAX_RXAMPDU_FACTOR(_pEleStart)	LE_BITS_TO_2BYTE((_pEleStart)+2, 7, 3)
+#define GET_VHT_CAPABILITY_ELE_RX_MCS(_pEleStart)					       ((_pEleStart)+4)
+#define GET_VHT_CAPABILITY_ELE_MCS_RX_HIGHEST_RATE(_pEleStart)			LE_BITS_TO_2BYTE((_pEleStart)+6, 0, 13)
+#define GET_VHT_CAPABILITY_ELE_TX_MCS(_pEleStart)					       ((_pEleStart)+8)
+#define GET_VHT_CAPABILITY_ELE_MCS_TX_HIGHEST_RATE(_pEleStart)			LE_BITS_TO_2BYTE((_pEleStart)+10, 0, 13)
+
+
+//VHT Operation Information Element
+#define SET_VHT_OPERATION_ELE_CHL_WIDTH(_pEleStart, _val)			SET_BITS_TO_LE_1BYTE(_pEleStart, 0, 8, _val)
+#define SET_VHT_OPERATION_ELE_CHL_CENTER_FREQ1(_pEleStart, _val)			SET_BITS_TO_LE_2BYTE(_pEleStart+1, 0, 8, _val)
+#define SET_VHT_OPERATION_ELE_CHL_CENTER_FREQ2(_pEleStart, _val)			SET_BITS_TO_LE_2BYTE(_pEleStart+2, 0, 8, _val)
+#define SET_VHT_OPERATION_ELE_BASIC_MCS_SET(_pEleStart, _val)			SET_BITS_TO_LE_2BYTE(_pEleStart+3, 0, 16, _val)
+
+#define GET_VHT_OPERATION_ELE_CHL_WIDTH(_pEleStart)		LE_BITS_TO_1BYTE(_pEleStart,0,8)
+#define GET_VHT_OPERATION_ELE_CENTER_FREQ1(_pEleStart)	LE_BITS_TO_1BYTE((_pEleStart)+1,0,8)
+#define GET_VHT_OPERATION_ELE_CENTER_FREQ2(_pEleStart)     LE_BITS_TO_1BYTE((_pEleStart)+2,0,8)
+
+//VHT Operating Mode
+#define SET_VHT_OPERATING_MODE_FIELD_CHNL_WIDTH(_pEleStart, _val)		SET_BITS_TO_LE_1BYTE(_pEleStart, 0, 2, _val)
+#define SET_VHT_OPERATING_MODE_FIELD_RX_NSS(_pEleStart, _val)			SET_BITS_TO_LE_1BYTE(_pEleStart, 4, 3, _val)
+#define SET_VHT_OPERATING_MODE_FIELD_RX_NSS_TYPE(_pEleStart, _val)	SET_BITS_TO_LE_1BYTE(_pEleStart, 7, 1, _val)
+#define GET_VHT_OPERATING_MODE_FIELD_CHNL_WIDTH(_pEleStart)			LE_BITS_TO_1BYTE(_pEleStart, 0, 2)
+#define GET_VHT_OPERATING_MODE_FIELD_RX_NSS(_pEleStart)				LE_BITS_TO_1BYTE(_pEleStart, 4, 3)
+#define GET_VHT_OPERATING_MODE_FIELD_RX_NSS_TYPE(_pEleStart)		LE_BITS_TO_1BYTE(_pEleStart, 7, 1)
+
+#define SET_EXT_CAPABILITY_ELE_OP_MODE_NOTIF(_pEleStart, _val)			SET_BITS_TO_LE_1BYTE((_pEleStart)+7, 6, 1, _val)
+#define GET_EXT_CAPABILITY_ELE_OP_MODE_NOTIF(_pEleStart)				LE_BITS_TO_1BYTE((_pEleStart)+7, 6, 1)
+
+
+#define TEST_FLAG(__Flag,__testFlag)		(((__Flag) & (__testFlag)) != 0)
+#define SET_FLAG(__Flag, __setFlag)			((__Flag) |= __setFlag)
+#define CLEAR_FLAG(__Flag, __clearFlag)		((__Flag) &= ~(__clearFlag))
+#define CLEAR_FLAGS(__Flag)					((__Flag) = 0)
+#define TEST_FLAGS(__Flag, __testFlags)		(((__Flag) & (__testFlags)) == (__testFlags))
+
+struct vht_priv
+{
+	uint8_t	vht_option;
+
+	uint8_t	ldpc_cap;
+	uint8_t	stbc_cap;
+	uint8_t	beamform_cap;
+
+	uint8_t	vht_bwmode;
+	uint8_t	sgi;//short GI
+	uint8_t	ampdu_len;
+
+	uint8_t	vht_highest_rate;
+	uint8_t	vht_mcs_map[2];
+
+	uint8_t	vht_cap[32];
+};
+
+uint8_t	rtw_get_vht_highest_rate(struct rtl_priv *rtlpriv, uint8_t *pvht_mcs_map);
+u16	rtw_vht_data_rate(uint8_t bw, uint8_t short_GI, uint8_t vht_mcs_rate);
+u32	rtw_vht_rate_to_bitmap(uint8_t *pVHTRate);
+void	rtw_vht_use_default_setting(struct rtl_priv *rtlpriv);
+u32	rtw_build_vht_operation_ie(struct rtl_priv *rtlpriv, uint8_t *pbuf, uint8_t channel);
+u32	rtw_build_vht_op_mode_notify_ie(struct rtl_priv *rtlpriv, uint8_t *pbuf);
+u32	rtw_build_vht_cap_ie(struct rtl_priv *rtlpriv, uint8_t *pbuf);
+void	update_sta_vht_info_apmode(struct rtl_priv *rtlpriv, void *psta);
+void	update_hw_vht_param(struct rtl_priv *rtlpriv);
+void	VHT_caps_handler(struct rtl_priv *rtlpriv, PNDIS_802_11_VARIABLE_IEs pIE);
+void	VHT_operation_handler(struct rtl_priv *rtlpriv, PNDIS_802_11_VARIABLE_IEs pIE);
+u32	rtw_restructure_vht_ie(struct rtl_priv *rtlpriv, uint8_t *in_ie, uint8_t *out_ie, uint in_len, uint *pout_len);
+void	VHTOnAssocRsp(struct rtl_priv *rtlpriv);
+
+#endif	//_RTW_VHT_H_
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/include/rtw_xmit.h linux-4.9.8821au/drivers/staging/rtl8821au/include/rtw_xmit.h
--- linux-4.9/drivers/staging/rtl8821au/include/rtw_xmit.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/include/rtw_xmit.h	2016-12-11 19:48:25.176978367 -0600
@@ -0,0 +1,501 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef _RTW_XMIT_H_
+#define _RTW_XMIT_H_
+
+#define MAX_XMITBUF_SZ	(20480)	// 20k
+
+#ifdef CONFIG_SINGLE_XMIT_BUF
+#define NR_XMITBUFF	(1)
+#else
+#define NR_XMITBUFF	(4)
+#endif //CONFIG_SINGLE_XMIT_BUF
+
+#define XMITBUF_ALIGN_SZ 512
+
+// xmit extension buff defination
+#define MAX_XMIT_EXTBUF_SZ	(1536)
+#define NR_XMIT_EXTBUFF	(32)
+
+#define MAX_NUMBLKS		(1)
+
+#define XMIT_VO_QUEUE (0)
+#define XMIT_VI_QUEUE (1)
+#define XMIT_BE_QUEUE (2)
+#define XMIT_BK_QUEUE (3)
+
+#define HW_QUEUE_ENTRY	8
+
+
+#define WEP_IV(pattrib_iv, dot11txpn, keyidx)\
+do{\
+	pattrib_iv[0] = dot11txpn._byte_.TSC0;\
+	pattrib_iv[1] = dot11txpn._byte_.TSC1;\
+	pattrib_iv[2] = dot11txpn._byte_.TSC2;\
+	pattrib_iv[3] = ((keyidx & 0x3)<<6);\
+	dot11txpn.val = (dot11txpn.val == 0xffffff) ? 0: (dot11txpn.val+1);\
+}while(0)
+
+
+#define TKIP_IV(pattrib_iv, dot11txpn, keyidx)\
+do{\
+	pattrib_iv[0] = dot11txpn._byte_.TSC1;\
+	pattrib_iv[1] = (dot11txpn._byte_.TSC1 | 0x20) & 0x7f;\
+	pattrib_iv[2] = dot11txpn._byte_.TSC0;\
+	pattrib_iv[3] = BIT(5) | ((keyidx & 0x3)<<6);\
+	pattrib_iv[4] = dot11txpn._byte_.TSC2;\
+	pattrib_iv[5] = dot11txpn._byte_.TSC3;\
+	pattrib_iv[6] = dot11txpn._byte_.TSC4;\
+	pattrib_iv[7] = dot11txpn._byte_.TSC5;\
+	dot11txpn.val = dot11txpn.val == 0xffffffffffffULL ? 0: (dot11txpn.val+1);\
+}while(0)
+
+#define AES_IV(pattrib_iv, dot11txpn, keyidx)\
+do{\
+	pattrib_iv[0] = dot11txpn._byte_.TSC0;\
+	pattrib_iv[1] = dot11txpn._byte_.TSC1;\
+	pattrib_iv[2] = 0;\
+	pattrib_iv[3] = BIT(5) | ((keyidx & 0x3)<<6);\
+	pattrib_iv[4] = dot11txpn._byte_.TSC2;\
+	pattrib_iv[5] = dot11txpn._byte_.TSC3;\
+	pattrib_iv[6] = dot11txpn._byte_.TSC4;\
+	pattrib_iv[7] = dot11txpn._byte_.TSC5;\
+	dot11txpn.val = dot11txpn.val == 0xffffffffffffULL ? 0: (dot11txpn.val+1);\
+}while(0)
+
+
+#define HWXMIT_ENTRY	4
+
+#define TXDESC_SIZE 40
+
+#define PACKET_OFFSET_SZ (8)
+#define TXDESC_OFFSET (TXDESC_SIZE + PACKET_OFFSET_SZ)
+
+
+enum TXDESC_SC{
+	SC_DONT_CARE = 0x00,
+	SC_UPPER= 0x01,
+	SC_LOWER=0x02,
+	SC_DUPLICATE=0x03
+};
+
+#define TXDESC_40_BYTES
+
+struct tx_desc
+{
+	unsigned int txdw0;
+	unsigned int txdw1;
+	unsigned int txdw2;
+	unsigned int txdw3;
+	unsigned int txdw4;
+	unsigned int txdw5;
+	unsigned int txdw6;
+	unsigned int txdw7;
+
+#if defined(TXDESC_40_BYTES) || defined(TXDESC_64_BYTES)
+	unsigned int txdw8;
+	unsigned int txdw9;
+#endif // TXDESC_40_BYTES
+
+#ifdef TXDESC_64_BYTES
+	unsigned int txdw10;
+	unsigned int txdw11;
+
+	// 2008/05/15 MH Because PCIE HW memory R/W 4K limit. And now,  our descriptor
+	// size is 40 bytes. If you use more than 102 descriptor( 103*40>4096), HW will execute
+	// memoryR/W CRC error. And then all DMA fetch will fail. We must decrease descriptor
+	// number or enlarge descriptor size as 64 bytes.
+	unsigned int txdw12;
+	unsigned int txdw13;
+	unsigned int txdw14;
+	unsigned int txdw15;
+#endif
+};
+
+
+union txdesc {
+	struct tx_desc txdesc;
+	unsigned int value[TXDESC_SIZE>>2];
+};
+
+
+struct	hw_xmit	{
+	//spinlock_t xmit_lock;
+	//struct list_head	pending;
+	struct __queue *sta_queue;
+	//struct hw_txqueue *phwtxqueue;
+	//int	txcmdcnt;
+};
+
+//reduce size
+struct tx_pkt_attrib {
+	uint8_t	type;
+	uint8_t	subtype;
+	uint8_t	bswenc;
+	uint8_t	dhcp_pkt;
+	u16	ether_type;
+	u16	seqnum;
+	u16	pkt_hdrlen;	//the original 802.3 pkt header len
+	u16	hdrlen;		//the WLAN Header Len
+	u32	pktlen;		//the original 802.3 pkt raw_data len (not include ether_hdr data)
+	u32	last_txcmdsz;
+	uint8_t	nr_frags;
+	uint8_t	encrypt;	//when 0 indicate no encrypt. when non-zero, indicate the encrypt algorith
+	uint8_t	iv_len;
+	uint8_t	icv_len;
+	uint8_t	iv[18];
+	uint8_t	icv[16];
+	uint8_t	tx_priority;
+	uint8_t	ack_policy;
+	uint8_t	mac_id;
+	uint8_t	vcs_mode;	//virtual carrier sense method
+	uint8_t 	dst[ETH_ALEN];
+	uint8_t	src[ETH_ALEN];
+	uint8_t	ta[ETH_ALEN];
+	uint8_t 	ra[ETH_ALEN];
+	uint8_t	key_idx;
+	uint8_t	qos_en;
+	uint8_t	ht_en;
+	uint8_t	raid;//rate adpative id
+	uint8_t	bwmode;
+	uint8_t	ch_offset;//PRIME_CHNL_OFFSET
+	uint8_t	sgi;//short GI
+	uint8_t	ampdu_en;//tx ampdu enable
+	uint8_t	mdata;//more data bit
+	uint8_t	pctrl;//per packet txdesc control enable
+	uint8_t	triggered;//for ap mode handling Power Saving sta
+	uint8_t	tx_qsel;
+	uint8_t	eosp;
+	uint8_t	rate;
+	uint8_t	intel_proxim;
+	uint8_t 	retry_ctrl;
+	uint8_t   mbssid;
+	uint8_t	ldpc;
+	uint8_t	stbc;
+	struct sta_info * psta;
+#ifdef CONFIG_TCP_CSUM_OFFLOAD_TX
+	uint8_t	hw_tcp_csum;
+#endif
+
+	uint8_t rtsen;
+	uint8_t cts2self;
+	union Keytype	dot11tkiptxmickey;
+	//union Keytype	dot11tkiprxmickey;
+	union Keytype	dot118021x_UncstKey;
+
+
+};
+
+
+#define WLANHDR_OFFSET	64
+
+#define NULL_FRAMETAG		(0x0)
+#define DATA_FRAMETAG		0x01
+#define L2_FRAMETAG		0x02
+#define MGNT_FRAMETAG		0x03
+#define AMSDU_FRAMETAG	0x04
+
+#define EII_FRAMETAG		0x05
+#define IEEE8023_FRAMETAG  0x06
+
+#define MP_FRAMETAG		0x07
+
+#define TXAGG_FRAMETAG 	0x08
+
+enum {
+	XMITBUF_DATA = 0,
+	XMITBUF_MGNT = 1,
+	XMITBUF_CMD = 2,
+};
+
+struct  submit_ctx{
+	u32 submit_time; /* */
+	u32 timeout_ms; /* <0: not synchronous, 0: wait forever, >0: up to ms waiting */
+	int status; /* status for operation */
+
+	struct completion done;
+};
+
+enum {
+	RTW_SCTX_SUBMITTED = -1,
+	RTW_SCTX_DONE_SUCCESS = 0,
+	RTW_SCTX_DONE_UNKNOWN,
+	RTW_SCTX_DONE_TIMEOUT,
+	RTW_SCTX_DONE_BUF_ALLOC,
+	RTW_SCTX_DONE_BUF_FREE,
+	RTW_SCTX_DONE_WRITE_PORT_ERR,
+	RTW_SCTX_DONE_TX_DESC_NA,
+	RTW_SCTX_DONE_TX_DENY,
+	RTW_SCTX_DONE_CCX_PKT_FAIL,
+	RTW_SCTX_DONE_DRV_STOP,
+	RTW_SCTX_DONE_DEV_REMOVE,
+};
+
+
+void rtw_sctx_init(struct submit_ctx *sctx, int timeout_ms);
+int rtw_sctx_wait(struct submit_ctx *sctx);
+void rtw_sctx_done_err(struct submit_ctx **sctx, int status);
+void rtw_sctx_done(struct submit_ctx **sctx);
+
+struct xmit_buf
+{
+	struct list_head	list;
+
+	struct rtl_priv *rtlpriv;
+
+	uint8_t *pallocated_buf;
+
+	uint8_t *pbuf;
+
+	void *priv_data;
+
+	u16 buf_tag; // 0: Normal xmitbuf, 1: extension xmitbuf, 2:cmd xmitbuf
+	u16 flags;
+	u32 alloc_sz;
+
+	u32  len;
+
+	struct submit_ctx *sctx;
+
+
+	//u32 sz[8];
+	u32	ff_hwaddr;
+
+	struct urb *pxmit_urb[8];
+	dma_addr_t dma_transfer_addr;	/* (in) dma addr for transfer_buffer */
+
+	uint8_t bpending[8];
+
+	int last[8];
+
+
+
+
+};
+
+
+struct xmit_frame {
+	struct list_head	list;
+
+	struct tx_pkt_attrib tx_attrib;
+
+	struct sk_buff *skb;
+
+	int	frame_tag;
+
+	struct rtl_priv *rtlpriv;
+
+	uint8_t	*buf_addr;
+
+	struct xmit_buf *pxmitbuf;
+
+
+	uint8_t	agg_num;
+	s8	pkt_offset;
+
+	uint8_t *alloc_addr; /* the actual address this xmitframe allocated */
+	uint8_t ext_tag; /* 0:data, 1:mgmt */
+
+};
+
+struct tx_servq {
+	struct list_head	tx_pending;
+	struct __queue	sta_pending;
+};
+
+
+struct sta_xmit_priv
+{
+	spinlock_t	lock;
+	int	option;
+	int	apsd_setting;	//When bit mask is on, the associated edca queue supports APSD.
+
+
+	//struct tx_servq blk_q[MAX_NUMBLKS];
+	struct tx_servq	be_q;			//priority == 0,3
+	struct tx_servq	bk_q;			//priority == 1,2
+	struct tx_servq	vi_q;			//priority == 4,5
+	struct tx_servq	vo_q;			//priority == 6,7
+	struct list_head 	legacy_dz;
+	struct list_head  apsd;
+
+	u16 txseq_tid[16];
+
+	//uint	sta_tx_bytes;
+	//u64	sta_tx_pkts;
+	//uint	sta_tx_fail;
+
+
+};
+
+
+struct	hw_txqueue	{
+	volatile int	head;
+	volatile int	tail;
+	volatile int 	free_sz;	//in units of 64 bytes
+	volatile int      free_cmdsz;
+	volatile int	 txsz[8];
+	uint	ff_hwaddr;
+	uint	cmd_hwaddr;
+	int	ac_tag;
+};
+
+struct agg_pkt_info{
+	u16 offset;
+	u16 pkt_len;
+};
+
+struct	xmit_priv	{
+
+	spinlock_t	lock;
+
+	struct semaphore	xmit_sema;
+	struct semaphore	terminate_xmitthread_sema;
+
+	//struct __queue	blk_strms[MAX_NUMBLKS];
+	struct __queue	be_pending;
+	struct __queue	bk_pending;
+	struct __queue	vi_pending;
+	struct __queue	vo_pending;
+
+	//struct __queue	legacy_dz_queue;
+	//struct __queue	apsd_queue;
+
+	uint8_t *pallocated_frame_buf;
+	uint8_t *pxmit_frame_buf;
+	uint free_xmitframe_cnt;
+	struct __queue	free_xmit_queue;
+
+	//uint mapping_addr;
+	//uint pkt_sz;
+
+	uint8_t *xframe_ext_alloc_addr;
+	uint8_t *xframe_ext;
+	uint free_xframe_ext_cnt;
+	struct __queue free_xframe_ext_queue;
+
+	//struct	hw_txqueue	be_txqueue;
+	//struct	hw_txqueue	bk_txqueue;
+	//struct	hw_txqueue	vi_txqueue;
+	//struct	hw_txqueue	vo_txqueue;
+	//struct	hw_txqueue	bmc_txqueue;
+
+	uint	frag_len;
+
+	struct rtl_priv	*rtlpriv;
+
+	uint8_t   vcs_setting;
+	uint8_t	vcs;
+	uint8_t	vcs_type;
+	//u16  rts_thresh;
+
+	u64	tx_bytes;
+	u64	tx_pkts;
+	u64	tx_drop;
+	u64	last_tx_bytes;
+	u64	last_tx_pkts;
+
+	struct hw_xmit hwxmits[HWXMIT_ENTRY];
+
+	uint8_t	wmm_para_seq[4];//sequence for wmm ac parameter strength from large to small. it's value is 0->vo, 1->vi, 2->be, 3->bk.
+
+	struct semaphore	tx_retevt;//all tx return event;
+	uint8_t		txirp_cnt;//
+
+	struct tasklet_struct xmit_tasklet;
+
+	struct __queue free_xmitbuf_queue;
+	struct __queue pending_xmitbuf_queue;
+	uint8_t *pallocated_xmitbuf;
+	uint8_t *pxmitbuf;
+	uint free_xmitbuf_cnt;
+
+	struct __queue free_xmit_extbuf_queue;
+	uint8_t *pallocated_xmit_extbuf;
+	uint8_t *pxmit_extbuf;
+	uint free_xmit_extbuf_cnt;
+
+	struct xmit_buf	pcmd_xmitbuf;
+
+	u16	nqos_ssn;
+
+	spinlock_t lock_sctx;
+};
+
+extern struct xmit_frame *rtw_alloc_cmdxmitframe(struct xmit_priv *pxmitpriv, u32 buffsize);
+extern void	rtw_free_cmdxmitframe(struct xmit_priv *pxmitpriv, struct xmit_frame *pxmitframe);
+extern struct xmit_buf *rtw_alloc_cmd_xmitbuf(struct xmit_priv *pxmitpriv, u32 buffsize);
+extern int32_t	rtw_free_cmd_xmitbuf(struct xmit_priv *pxmitpriv);
+
+extern struct xmit_buf *rtw_alloc_xmitbuf_ext(struct xmit_priv *pxmitpriv);
+extern int32_t rtw_free_xmitbuf_ext(struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf);
+
+extern struct xmit_buf *rtw_alloc_xmitbuf(struct xmit_priv *pxmitpriv);
+extern int32_t rtw_free_xmitbuf(struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf);
+
+void rtw_count_tx_stats(struct rtl_priv *rtlpriv, struct xmit_frame *pxmitframe, int sz);
+extern void rtw_update_protection(struct rtl_priv *rtlpriv, uint8_t *ie, uint ie_len);
+extern int32_t rtw_make_wlanhdr(struct rtl_priv *rtlpriv, uint8_t *hdr, struct tx_pkt_attrib *pattrib);
+extern int32_t rtw_put_snap(uint8_t *data, u16 h_proto);
+
+extern struct xmit_frame *rtw_alloc_xmitframe(struct xmit_priv *pxmitpriv);
+struct xmit_frame *rtw_alloc_xmitframe_ext(struct xmit_priv *pxmitpriv);
+struct xmit_frame *rtw_alloc_xmitframe_once(struct xmit_priv *pxmitpriv);
+extern int32_t rtw_free_xmitframe(struct xmit_priv *pxmitpriv, struct xmit_frame *pxmitframe);
+extern void rtw_free_xmitframe_queue(struct xmit_priv *pxmitpriv, struct __queue *pframequeue);
+extern int32_t rtw_xmitframe_enqueue(struct rtl_priv *rtlpriv, struct xmit_frame *pxmitframe);
+extern struct xmit_frame* rtw_dequeue_xframe(struct xmit_priv *pxmitpriv, struct hw_xmit *phwxmit_i);
+
+extern int32_t rtw_xmit_classifier(struct rtl_priv *rtlpriv, struct xmit_frame *pxmitframe);
+extern u32 rtw_calculate_wlan_pkt_size_by_attribue(struct tx_pkt_attrib *pattrib);
+#define rtw_wlan_pkt_size(f) rtw_calculate_wlan_pkt_size_by_attribue(&f->attrib)
+extern int32_t rtw_xmitframe_coalesce(struct rtl_priv *rtlpriv, struct sk_buff *pkt, struct xmit_frame *pxmitframe);
+int32_t _rtw_init_hw_txqueue(struct hw_txqueue* phw_txqueue, uint8_t ac_tag);
+void _rtw_init_sta_xmit_priv(struct sta_xmit_priv *psta_xmitpriv);
+
+
+int32_t rtw_txframes_pending(struct rtl_priv *rtlpriv);
+bool rtw_txframes_sta_ac_pending(struct rtl_priv *rtlpriv, struct tx_pkt_attrib *pattrib);
+void rtw_init_hwxmits(struct hw_xmit *phwxmit);
+
+
+int32_t _rtw_init_xmit_priv(struct xmit_priv *pxmitpriv, struct rtl_priv *rtlpriv);
+void _rtw_free_xmit_priv (struct xmit_priv *pxmitpriv);
+
+
+void rtw_alloc_hwxmits(struct rtl_priv *rtlpriv);
+
+
+int32_t rtw_xmit(struct rtl_priv *rtlpriv, struct sk_buff **pkt);
+
+#if defined(CONFIG_AP_MODE)
+int xmitframe_enqueue_for_sleeping_sta(struct rtl_priv *rtlpriv, struct xmit_frame *pxmitframe);
+void stop_sta_xmit(struct rtl_priv *rtlpriv, struct sta_info *psta);
+void wakeup_sta_to_xmit(struct rtl_priv *rtlpriv, struct sta_info *psta);
+void xmit_delivery_enabled_frames(struct rtl_priv *rtlpriv, struct sta_info *psta);
+#endif
+
+uint8_t	qos_acm(uint8_t acm_mask, uint8_t priority);
+
+//include after declaring struct xmit_buf, in order to avoid warning
+#include <xmit_osdep.h>
+
+#endif	//_RTL871X_XMIT_H_
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/include/sta_info.h linux-4.9.8821au/drivers/staging/rtl8821au/include/sta_info.h
--- linux-4.9/drivers/staging/rtl8821au/include/sta_info.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/include/sta_info.h	2016-12-11 19:48:25.176978367 -0600
@@ -0,0 +1,398 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __STA_INFO_H_
+#define __STA_INFO_H_
+
+
+#define IBSS_START_MAC_ID	2
+#define NUM_STA 32
+#define NUM_ACL 16
+
+
+//if mode ==0, then the sta is allowed once the addr is hit.
+//if mode ==1, then the sta is rejected once the addr is non-hit.
+struct rtw_wlan_acl_node {
+        struct list_head		        list;
+        uint8_t       addr[ETH_ALEN];
+        uint8_t       valid;
+};
+
+//mode=0, disable
+//mode=1, accept unless in deny list
+//mode=2, deny unless in accept list
+struct wlan_acl_pool {
+	int mode;
+	int num;
+	struct rtw_wlan_acl_node aclnode[NUM_ACL];
+	struct __queue	acl_node_q;
+};
+
+typedef struct _RSSI_STA{
+	int32_t	UndecoratedSmoothedPWDB;
+	int32_t	UndecoratedSmoothedCCK;
+	int32_t	UndecoratedSmoothedOFDM;
+	u64	PacketMap;
+	uint8_t	ValidBit;
+}RSSI_STA, *PRSSI_STA;
+
+struct	stainfo_stats	{
+
+	u64 rx_mgnt_pkts;
+		u64 rx_beacon_pkts;
+		u64 rx_probereq_pkts;
+		u64 rx_probersp_pkts;
+		u64 rx_probersp_bm_pkts;
+		u64 rx_probersp_uo_pkts;
+	u64 rx_ctrl_pkts;
+	u64 rx_data_pkts;
+
+	u64	last_rx_mgnt_pkts;
+		u64 last_rx_beacon_pkts;
+		u64 last_rx_probereq_pkts;
+		u64 last_rx_probersp_pkts;
+		u64 last_rx_probersp_bm_pkts;
+		u64 last_rx_probersp_uo_pkts;
+	u64	last_rx_ctrl_pkts;
+	u64	last_rx_data_pkts;
+
+	u64	rx_bytes;
+	u64	rx_drops;
+
+	u64	tx_pkts;
+	u64	tx_bytes;
+	u64  tx_drops;
+
+};
+
+
+struct sta_info {
+
+	spinlock_t	lock;
+	struct list_head	list; //free_sta_queue
+	struct list_head	hash_list; //sta_hash
+	//struct list_head asoc_list; //20061114
+	//struct list_head sleep_list;//sleep_q
+	//struct list_head wakeup_list;//wakeup_q
+	struct rtl_priv *rtlpriv;
+
+	struct sta_xmit_priv sta_xmitpriv;
+	struct sta_recv_priv sta_recvpriv;
+
+	struct __queue sleep_q;
+	unsigned int sleepq_len;
+
+	uint state;
+	uint aid;
+	uint mac_id;
+	uint qos_option;
+	uint8_t	hwaddr[ETH_ALEN];
+
+	uint	ieee8021x_blocked;	//0: allowed, 1:blocked
+	uint	dot118021XPrivacy; //aes, tkip...
+	union Keytype	dot11tkiptxmickey;
+	union Keytype	dot11tkiprxmickey;
+	union Keytype	dot118021x_UncstKey;
+	union pn48		dot11txpn;			// PN48 used for Unicast xmit.
+	union pn48		dot11rxpn;			// PN48 used for Unicast recv.
+
+
+	uint8_t	bssrateset[16];
+	u32	bssratelen;
+	int32_t  rssi;
+	int32_t	signal_quality;
+
+	uint8_t	cts2self;
+	uint8_t	rtsen;
+
+	uint8_t	raid;
+	uint8_t 	init_rate;
+	u32	ra_mask;
+	uint8_t	wireless_mode;	// NETWORK_TYPE
+
+	struct stainfo_stats sta_stats;
+
+	//for A-MPDU TX, ADDBA timeout check
+	struct timer_list addba_retry_timer;
+
+	//for A-MPDU Rx reordering buffer control
+	struct recv_reorder_ctrl recvreorder_ctrl[16];
+
+	//for A-MPDU Tx
+	//unsigned char		ampdu_txen_bitmap;
+	u16	BA_starting_seqctrl[16];
+
+
+	struct ht_priv	htpriv;
+
+	struct vht_priv	vhtpriv;
+
+	//Notes:
+	//STA_Mode:
+	//curr_network(mlme_priv/security_priv/qos/ht) + sta_info: (STA & AP) CAP/INFO
+	//scan_q: AP CAP/INFO
+
+	//AP_Mode:
+	//curr_network(mlme_priv/security_priv/qos/ht) : AP CAP/INFO
+	//sta_info: (AP & STA) CAP/INFO
+
+#ifdef CONFIG_AP_MODE
+
+	struct list_head asoc_list;
+	struct list_head auth_list;
+
+	unsigned int expire_to;
+	unsigned int auth_seq;
+	unsigned int authalg;
+	unsigned char chg_txt[128];
+
+	u16 capability;
+	int flags;
+
+	int dot8021xalg;//0:disable, 1:psk, 2:802.1x
+	int wpa_psk;//0:disable, bit(0): WPA, bit(1):WPA2
+	int wpa_group_cipher;
+	int wpa2_group_cipher;
+	int wpa_pairwise_cipher;
+	int wpa2_pairwise_cipher;
+
+	uint8_t bpairwise_key_installed;
+
+	uint8_t wpa_ie[32];
+
+	uint8_t nonerp_set;
+	uint8_t no_short_slot_time_set;
+	uint8_t no_short_preamble_set;
+	uint8_t no_ht_gf_set;
+	uint8_t no_ht_set;
+	uint8_t ht_20mhz_set;
+
+	unsigned int tx_ra_bitmap;
+	uint8_t qos_info;
+
+	uint8_t max_sp_len;
+	uint8_t uapsd_bk;//BIT(0): Delivery enabled, BIT(1): Trigger enabled
+	uint8_t uapsd_be;
+	uint8_t uapsd_vi;
+	uint8_t uapsd_vo;
+
+	uint8_t has_legacy_ac;
+	unsigned int sleepq_ac_len;
+
+#ifdef CONFIG_TX_MCAST2UNI
+	uint8_t under_exist_checking;
+#endif	// CONFIG_TX_MCAST2UNI
+
+	uint8_t keep_alive_trycnt;
+
+#endif	// CONFIG_AP_MODE
+
+	//for DM
+	RSSI_STA	 rssi_stat;
+
+	//
+	// ================ODM Relative Info=======================
+	// Please be care, dont declare too much structure here. It will cost memory * STA support num.
+	//
+	//
+	// 2011/10/20 MH Add for ODM STA info.
+	//
+	// Driver Write
+	uint8_t		bValid;				// record the sta status link or not?
+	//uint8_t		WirelessMode;		//
+	uint8_t		IOTPeer;			// Enum value.	HT_IOT_PEER_E
+	uint8_t		rssi_level;			//for Refresh RA mask
+	// ODM Write
+	//1 PHY_STATUS_INFO
+	uint8_t		RSSI_Path[4];		//
+	uint8_t		RSSI_Ave;
+	uint8_t		RXEVM[4];
+	uint8_t		RXSNR[4];
+
+	// ODM Write
+	//1 TX_INFO (may changed by IC)
+	//TX_INFO_T		pTxInfo;				// Define in IC folder. Move lower layer.
+	//
+	// ================ODM Relative Info=======================
+	//
+
+	/* To store the sequence number of received management frame */
+	u16 RxMgmtFrameSeqNum;
+};
+
+#define sta_rx_pkts(sta) \
+	(sta->sta_stats.rx_mgnt_pkts \
+	+ sta->sta_stats.rx_ctrl_pkts \
+	+ sta->sta_stats.rx_data_pkts)
+
+#define sta_last_rx_pkts(sta) \
+	(sta->sta_stats.last_rx_mgnt_pkts \
+	+ sta->sta_stats.last_rx_ctrl_pkts \
+	+ sta->sta_stats.last_rx_data_pkts)
+
+#define sta_rx_data_pkts(sta) \
+	(sta->sta_stats.rx_data_pkts)
+
+#define sta_last_rx_data_pkts(sta) \
+	(sta->sta_stats.last_rx_data_pkts)
+
+#define sta_rx_mgnt_pkts(sta) \
+	(sta->sta_stats.rx_mgnt_pkts)
+
+#define sta_last_rx_mgnt_pkts(sta) \
+	(sta->sta_stats.last_rx_mgnt_pkts)
+
+#define sta_rx_beacon_pkts(sta) \
+	(sta->sta_stats.rx_beacon_pkts)
+
+#define sta_last_rx_beacon_pkts(sta) \
+	(sta->sta_stats.last_rx_beacon_pkts)
+
+#define sta_rx_probereq_pkts(sta) \
+	(sta->sta_stats.rx_probereq_pkts)
+
+#define sta_last_rx_probereq_pkts(sta) \
+	(sta->sta_stats.last_rx_probereq_pkts)
+
+#define sta_rx_probersp_pkts(sta) \
+	(sta->sta_stats.rx_probersp_pkts)
+
+#define sta_last_rx_probersp_pkts(sta) \
+	(sta->sta_stats.last_rx_probersp_pkts)
+
+#define sta_rx_probersp_bm_pkts(sta) \
+	(sta->sta_stats.rx_probersp_bm_pkts)
+
+#define sta_last_rx_probersp_bm_pkts(sta) \
+	(sta->sta_stats.last_rx_probersp_bm_pkts)
+
+#define sta_rx_probersp_uo_pkts(sta) \
+	(sta->sta_stats.rx_probersp_uo_pkts)
+
+#define sta_last_rx_probersp_uo_pkts(sta) \
+	(sta->sta_stats.last_rx_probersp_uo_pkts)
+
+#define sta_update_last_rx_pkts(sta) \
+	do { \
+		sta->sta_stats.last_rx_mgnt_pkts = sta->sta_stats.rx_mgnt_pkts; \
+		sta->sta_stats.last_rx_beacon_pkts = sta->sta_stats.rx_beacon_pkts; \
+		sta->sta_stats.last_rx_probereq_pkts = sta->sta_stats.rx_probereq_pkts; \
+		sta->sta_stats.last_rx_probersp_pkts = sta->sta_stats.rx_probersp_pkts; \
+		sta->sta_stats.last_rx_probersp_bm_pkts = sta->sta_stats.rx_probersp_bm_pkts; \
+		sta->sta_stats.last_rx_probersp_uo_pkts = sta->sta_stats.rx_probersp_uo_pkts; \
+		sta->sta_stats.last_rx_ctrl_pkts = sta->sta_stats.rx_ctrl_pkts; \
+		sta->sta_stats.last_rx_data_pkts = sta->sta_stats.rx_data_pkts; \
+	} while(0)
+
+#define STA_RX_PKTS_ARG(sta) \
+	sta->sta_stats.rx_mgnt_pkts \
+	, sta->sta_stats.rx_ctrl_pkts \
+	, sta->sta_stats.rx_data_pkts
+
+#define STA_LAST_RX_PKTS_ARG(sta) \
+	sta->sta_stats.last_rx_mgnt_pkts \
+	, sta->sta_stats.last_rx_ctrl_pkts \
+	, sta->sta_stats.last_rx_data_pkts
+
+#define STA_RX_PKTS_DIFF_ARG(sta) \
+	sta->sta_stats.rx_mgnt_pkts - sta->sta_stats.last_rx_mgnt_pkts \
+	, sta->sta_stats.rx_ctrl_pkts - sta->sta_stats.last_rx_ctrl_pkts \
+	, sta->sta_stats.rx_data_pkts -sta->sta_stats.last_rx_data_pkts
+
+#define STA_PKTS_FMT "(m:%llu, c:%llu, d:%llu)"
+
+struct	sta_priv {
+
+	uint8_t *pallocated_stainfo_buf;
+	uint8_t *pstainfo_buf;
+	struct __queue	free_sta_queue;
+
+	spinlock_t sta_hash_lock;
+	struct list_head   sta_hash[NUM_STA];
+	int asoc_sta_count;
+	struct __queue sleep_q;
+	struct __queue wakeup_q;
+
+	struct rtl_priv *rtlpriv;
+
+
+#ifdef CONFIG_AP_MODE
+	struct list_head asoc_list;
+	struct list_head auth_list;
+	spinlock_t asoc_list_lock;
+	spinlock_t auth_list_lock;
+	uint8_t asoc_list_cnt;
+	uint8_t auth_list_cnt;
+
+	unsigned int auth_to;  //sec, time to expire in authenticating.
+	unsigned int assoc_to; //sec, time to expire before associating.
+	unsigned int expire_to; //sec , time to expire after associated.
+
+	/* pointers to STA info; based on allocated AID or NULL if AID free
+	 * AID is in the range 1-2007, so sta_aid[0] corresponders to AID 1
+	 * and so on
+	 */
+	struct sta_info *sta_aid[NUM_STA];
+
+	u16 sta_dz_bitmap;//only support 15 stations, staion aid bitmap for sleeping sta.
+	u16 tim_bitmap;//only support 15 stations, aid=0~15 mapping bit0~bit15
+
+	u16 max_num_sta;
+
+	struct wlan_acl_pool acl_list;
+#endif
+
+};
+
+
+__inline static u32 wifi_mac_hash(uint8_t *mac)
+{
+        u32 x;
+
+        x = mac[0];
+        x = (x << 2) ^ mac[1];
+        x = (x << 2) ^ mac[2];
+        x = (x << 2) ^ mac[3];
+        x = (x << 2) ^ mac[4];
+        x = (x << 2) ^ mac[5];
+
+        x ^= x >> 8;
+        x  = x & (NUM_STA - 1);
+
+        return x;
+}
+
+
+extern u32	_rtw_init_sta_priv(struct sta_priv *pstapriv);
+extern u32	_rtw_free_sta_priv(struct sta_priv *pstapriv);
+
+#define stainfo_offset_valid(offset) (offset < NUM_STA && offset >= 0)
+int rtw_stainfo_offset(struct sta_priv *stapriv, struct sta_info *sta);
+struct sta_info *rtw_get_stainfo_by_offset(struct sta_priv *stapriv, int offset);
+
+extern struct sta_info *rtw_alloc_stainfo(struct	sta_priv *pstapriv, uint8_t *hwaddr);
+extern u32	rtw_free_stainfo(struct rtl_priv *rtlpriv , struct sta_info *psta);
+extern void rtw_free_all_stainfo(struct rtl_priv *rtlpriv);
+extern struct sta_info *rtw_get_stainfo(struct sta_priv *pstapriv, uint8_t *hwaddr);
+extern u32 rtw_init_bcmc_stainfo(struct rtl_priv* rtlpriv);
+extern struct sta_info* rtw_get_bcmc_stainfo(struct rtl_priv* rtlpriv);
+extern uint8_t rtw_access_ctrl(struct rtl_priv *rtlpriv, uint8_t *mac_addr);
+
+#endif //_STA_INFO_H_
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/include/usb_ops.h linux-4.9.8821au/drivers/staging/rtl8821au/include/usb_ops.h
--- linux-4.9/drivers/staging/rtl8821au/include/usb_ops.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/include/usb_ops.h	2016-12-11 19:48:25.176978367 -0600
@@ -0,0 +1,68 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __USB_OPS_H_
+#define __USB_OPS_H_
+
+#define REALTEK_USB_VENQT_READ		0xC0
+#define REALTEK_USB_VENQT_WRITE		0x40
+#define REALTEK_USB_VENQT_CMD_REQ	0x05
+#define REALTEK_USB_VENQT_CMD_IDX	0x00
+
+enum{
+	VENDOR_WRITE = 0x00,
+	VENDOR_READ = 0x01,
+};
+#define ALIGNMENT_UNIT				16
+#define MAX_VENDOR_REQ_CMD_SIZE	254		//8188cu SIE Support
+#define MAX_USB_IO_CTL_SIZE		(MAX_VENDOR_REQ_CMD_SIZE +ALIGNMENT_UNIT)
+
+/*
+ * ULLI some 'user' defines as wrapper
+ * we may remove this
+ */
+#include <usb_ops_linux.h>
+
+
+
+/*
+* Set the continual_urb_error of this @param dvobjprive to 0
+*/
+static inline void rtw_reset_continual_urb_error(struct rtl_usb *dvobj)
+{
+	atomic_set(&dvobj->continual_urb_error, 0);
+}
+
+enum RTW_USB_SPEED {
+	RTW_USB_SPEED_UNKNOWN	= 0,
+	RTW_USB_SPEED_1_1	= 1,
+	RTW_USB_SPEED_2		= 2,
+	RTW_USB_SPEED_3		= 3,
+};
+
+#define IS_FULL_SPEED_USB(rtlpriv)	(rtl_usbdev(rtlpriv)->usb_speed == RTW_USB_SPEED_1_1)
+#define IS_HIGH_SPEED_USB(rtlpriv)	(rtl_usbdev(rtlpriv)->usb_speed == RTW_USB_SPEED_2)
+#define IS_SUPER_SPEED_USB(rtlpriv)	(rtl_usbdev(rtlpriv)->usb_speed == RTW_USB_SPEED_3)
+
+#define USB_SUPER_SPEED_BULK_SIZE	1024	// usb 3.0
+#define USB_HIGH_SPEED_BULK_SIZE	512		// usb 2.0
+#define USB_FULL_SPEED_BULK_SIZE	64		// usb 1.1
+
+#endif //__USB_OPS_H_
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/include/usb_ops_linux.h linux-4.9.8821au/drivers/staging/rtl8821au/include/usb_ops_linux.h
--- linux-4.9/drivers/staging/rtl8821au/include/usb_ops_linux.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/include/usb_ops_linux.h	2016-12-11 19:48:25.176978367 -0600
@@ -0,0 +1,41 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __USB_OPS_LINUX_H__
+#define __USB_OPS_LINUX_H__
+
+#define VENDOR_CMD_MAX_DATA_LEN	254
+
+#define RTW_USB_CONTROL_MSG_TIMEOUT_TEST	10//ms
+#define RTW_USB_CONTROL_MSG_TIMEOUT	500//ms
+
+#define RECV_BULK_IN_ADDR		0x80//assign by drv,not real address
+
+
+#if defined(CONFIG_VENDOR_REQ_RETRY) && defined(CONFIG_USB_VENDOR_REQ_MUTEX)
+/* vendor req retry should be in the situation when each vendor req is atomically submitted from others */
+#define MAX_USBCTRL_VENDORREQ_TIMES	10
+#else
+#define MAX_USBCTRL_VENDORREQ_TIMES	1
+#endif
+
+#define RTW_USB_BULKOUT_TIMEOUT	5000//ms
+
+#endif
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/include/usb_vendor_req.h linux-4.9.8821au/drivers/staging/rtl8821au/include/usb_vendor_req.h
--- linux-4.9/drivers/staging/rtl8821au/include/usb_vendor_req.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/include/usb_vendor_req.h	2016-12-11 19:48:25.176978367 -0600
@@ -0,0 +1,60 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef _USB_VENDOR_REQUEST_H_
+#define _USB_VENDOR_REQUEST_H_
+
+//4	Set/Get Register related wIndex/Data
+#define	RT_USB_RESET_MASK_OFF		0
+#define	RT_USB_RESET_MASK_ON		1
+#define	RT_USB_SLEEP_MASK_OFF		0
+#define	RT_USB_SLEEP_MASK_ON		1
+#define	RT_USB_LDO_ON				1
+#define	RT_USB_LDO_OFF				0
+
+//4	Set/Get SYSCLK related	wValue or Data
+#define	RT_USB_SYSCLK_32KHZ		0
+#define	RT_USB_SYSCLK_40MHZ		1
+#define	RT_USB_SYSCLK_60MHZ		2
+
+
+typedef enum _RT_USB_BREQUEST {
+	RT_USB_SET_REGISTER		= 1,
+	RT_USB_SET_SYSCLK		= 2,
+	RT_USB_GET_SYSCLK		= 3,
+	RT_USB_GET_REGISTER		= 4
+} RT_USB_BREQUEST;
+
+
+typedef enum _RT_USB_WVALUE {
+	RT_USB_RESET_MASK	=	1,
+	RT_USB_SLEEP_MASK	=	2,
+	RT_USB_USB_HRCPWM	=	3,
+	RT_USB_LDO			=	4,
+	RT_USB_BOOT_TYPE	=	5
+} RT_USB_WVALUE;
+
+
+//bool usbvendorrequest(PCE_USB_DEVICE	CEdevice, RT_USB_BREQUEST bRequest, RT_USB_WVALUE wValue, UCHAR wIndex, PVOID Data, UCHAR DataLength, bool isDirectionIn);
+//bool CEusbGetStatusRequest(PCE_USB_DEVICE CEdevice, IN USHORT Op, IN USHORT Index, PVOID Data);
+//bool CEusbFeatureRequest(PCE_USB_DEVICE CEdevice, IN USHORT Op, IN USHORT FeatureSelector, IN USHORT Index);
+//bool CEusbGetDescriptorRequest(PCE_USB_DEVICE CEdevice, IN short urbLength, IN UCHAR DescriptorType, IN UCHAR Index, IN USHORT LanguageId, IN PVOID  TransferBuffer, IN ULONG TransferBufferLength);
+
+#endif
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/include/wifi.h linux-4.9.8821au/drivers/staging/rtl8821au/include/wifi.h
--- linux-4.9/drivers/staging/rtl8821au/include/wifi.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/include/wifi.h	2016-12-11 19:48:25.176978367 -0600
@@ -0,0 +1,1201 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef _WIFI_H_
+#define _WIFI_H_
+
+
+#ifdef BIT
+//#error	"BIT define occurred earlier elsewhere!\n"
+#undef BIT
+#endif
+#define BIT(x)	(1 << (x))
+
+
+#define WLAN_ETHHDR_LEN		14
+#define WLAN_ETHADDR_LEN	6
+#define WLAN_IEEE_OUI_LEN	3
+#define WLAN_ADDR_LEN		6
+#define WLAN_CRC_LEN		4
+#define WLAN_BSSID_LEN		6
+#define WLAN_BSS_TS_LEN		8
+#define WLAN_HDR_A3_LEN		24
+#define WLAN_HDR_A4_LEN		30
+#define WLAN_HDR_A3_QOS_LEN	26
+#define WLAN_HDR_A4_QOS_LEN	32
+#define WLAN_SSID_MAXLEN	32
+#define WLAN_DATA_MAXLEN	2312
+
+#define WLAN_A3_PN_OFFSET	24
+#define WLAN_A4_PN_OFFSET	30
+
+#define WLAN_MIN_ETHFRM_LEN	60
+#define WLAN_MAX_ETHFRM_LEN	1514
+#define WLAN_ETHHDR_LEN		14
+
+#define P80211CAPTURE_VERSION	0x80211001
+
+// This value is tested by WiFi 11n Test Plan 5.2.3.
+// This test verifies the WLAN NIC can update the NAV through sending the CTS with large duration.
+#define	WiFiNavUpperUs				30000	// 30 ms
+
+#ifdef GREEN_HILL
+#pragma pack(1)
+#endif
+
+enum WIFI_FRAME_TYPE {
+	WIFI_MGT_TYPE  =	(0),
+	WIFI_CTRL_TYPE =	(BIT(2)),
+	WIFI_DATA_TYPE =	(BIT(3)),
+	WIFI_QOS_DATA_TYPE	= (BIT(7)|BIT(3)),	//!< QoS Data
+};
+
+enum WIFI_FRAME_SUBTYPE {
+
+    // below is for mgt frame
+    WIFI_ASSOCREQ       = (0 | WIFI_MGT_TYPE),
+    WIFI_ASSOCRSP       = (BIT(4) | WIFI_MGT_TYPE),
+    WIFI_REASSOCREQ     = (BIT(5) | WIFI_MGT_TYPE),
+    WIFI_REASSOCRSP     = (BIT(5) | BIT(4) | WIFI_MGT_TYPE),
+    WIFI_PROBEREQ       = (BIT(6) | WIFI_MGT_TYPE),
+    WIFI_PROBERSP       = (BIT(6) | BIT(4) | WIFI_MGT_TYPE),
+    WIFI_BEACON         = (BIT(7) | WIFI_MGT_TYPE),
+    WIFI_ATIM           = (BIT(7) | BIT(4) | WIFI_MGT_TYPE),
+    WIFI_DISASSOC       = (BIT(7) | BIT(5) | WIFI_MGT_TYPE),
+    WIFI_AUTH           = (BIT(7) | BIT(5) | BIT(4) | WIFI_MGT_TYPE),
+    WIFI_DEAUTH         = (BIT(7) | BIT(6) | WIFI_MGT_TYPE),
+    WIFI_ACTION         = (BIT(7) | BIT(6) | BIT(4) | WIFI_MGT_TYPE),
+
+    // below is for control frame
+    WIFI_PSPOLL         = (BIT(7) | BIT(5) | WIFI_CTRL_TYPE),
+    WIFI_RTS            = (BIT(7) | BIT(5) | BIT(4) | WIFI_CTRL_TYPE),
+    WIFI_CTS            = (BIT(7) | BIT(6) | WIFI_CTRL_TYPE),
+    WIFI_ACK            = (BIT(7) | BIT(6) | BIT(4) | WIFI_CTRL_TYPE),
+    WIFI_CFEND          = (BIT(7) | BIT(6) | BIT(5) | WIFI_CTRL_TYPE),
+    WIFI_CFEND_CFACK    = (BIT(7) | BIT(6) | BIT(5) | BIT(4) | WIFI_CTRL_TYPE),
+
+    // below is for data frame
+    WIFI_DATA           = (0 | WIFI_DATA_TYPE),
+    WIFI_DATA_CFACK     = (BIT(4) | WIFI_DATA_TYPE),
+    WIFI_DATA_CFPOLL    = (BIT(5) | WIFI_DATA_TYPE),
+    WIFI_DATA_CFACKPOLL = (BIT(5) | BIT(4) | WIFI_DATA_TYPE),
+    WIFI_DATA_NULL      = (BIT(6) | WIFI_DATA_TYPE),
+    WIFI_CF_ACK         = (BIT(6) | BIT(4) | WIFI_DATA_TYPE),
+    WIFI_CF_POLL        = (BIT(6) | BIT(5) | WIFI_DATA_TYPE),
+    WIFI_CF_ACKPOLL     = (BIT(6) | BIT(5) | BIT(4) | WIFI_DATA_TYPE),
+    WIFI_QOS_DATA_NULL	= (BIT(6) | WIFI_QOS_DATA_TYPE),
+};
+
+enum WIFI_REASON_CODE	{
+	_RSON_RESERVED_					= 0,
+	_RSON_UNSPECIFIED_				= 1,
+	_RSON_AUTH_NO_LONGER_VALID_		= 2,
+	_RSON_DEAUTH_STA_LEAVING_		= 3,
+	_RSON_INACTIVITY_				= 4,
+	_RSON_UNABLE_HANDLE_			= 5,
+	_RSON_CLS2_						= 6,
+	_RSON_CLS3_						= 7,
+	_RSON_DISAOC_STA_LEAVING_		= 8,
+	_RSON_ASOC_NOT_AUTH_			= 9,
+
+	// WPA reason
+	_RSON_INVALID_IE_				= 13,
+	_RSON_MIC_FAILURE_				= 14,
+	_RSON_4WAY_HNDSHK_TIMEOUT_		= 15,
+	_RSON_GROUP_KEY_UPDATE_TIMEOUT_	= 16,
+	_RSON_DIFF_IE_					= 17,
+	_RSON_MLTCST_CIPHER_NOT_VALID_	= 18,
+	_RSON_UNICST_CIPHER_NOT_VALID_	= 19,
+	_RSON_AKMP_NOT_VALID_			= 20,
+	_RSON_UNSUPPORT_RSNE_VER_		= 21,
+	_RSON_INVALID_RSNE_CAP_			= 22,
+	_RSON_IEEE_802DOT1X_AUTH_FAIL_	= 23,
+
+	//belowing are Realtek definition
+	_RSON_PMK_NOT_AVAILABLE_		= 24,
+	_RSON_TDLS_TEAR_TOOFAR_			= 25,
+	_RSON_TDLS_TEAR_UN_RSN_			= 26,
+};
+
+/* Reason codes (IEEE 802.11-2007, 7.3.1.7, Table 7-22) */
+#if 0
+#define WLAN_REASON_UNSPECIFIED 1
+#define WLAN_REASON_PREV_AUTH_NOT_VALID 2
+#define WLAN_REASON_DEAUTH_LEAVING 3
+#define WLAN_REASON_DISASSOC_DUE_TO_INACTIVITY 4
+#define WLAN_REASON_DISASSOC_AP_BUSY 5
+#define WLAN_REASON_CLASS2_FRAME_FROM_NONAUTH_STA 6
+#define WLAN_REASON_CLASS3_FRAME_FROM_NONASSOC_STA 7
+#define WLAN_REASON_DISASSOC_STA_HAS_LEFT 8
+#define WLAN_REASON_STA_REQ_ASSOC_WITHOUT_AUTH 9
+#endif
+/* IEEE 802.11h */
+#define WLAN_REASON_PWR_CAPABILITY_NOT_VALID 10
+#define WLAN_REASON_SUPPORTED_CHANNEL_NOT_VALID 11
+#if 0
+/* IEEE 802.11i */
+#define WLAN_REASON_INVALID_IE 13
+#define WLAN_REASON_MICHAEL_MIC_FAILURE 14
+#define WLAN_REASON_4WAY_HANDSHAKE_TIMEOUT 15
+#define WLAN_REASON_GROUP_KEY_UPDATE_TIMEOUT 16
+#define WLAN_REASON_IE_IN_4WAY_DIFFERS 17
+#define WLAN_REASON_GROUP_CIPHER_NOT_VALID 18
+#define WLAN_REASON_PAIRWISE_CIPHER_NOT_VALID 19
+#define WLAN_REASON_AKMP_NOT_VALID 20
+#define WLAN_REASON_UNSUPPORTED_RSN_IE_VERSION 21
+#define WLAN_REASON_INVALID_RSN_IE_CAPAB 22
+#define WLAN_REASON_IEEE_802_1X_AUTH_FAILED 23
+#define WLAN_REASON_CIPHER_SUITE_REJECTED 24
+#endif
+
+enum WIFI_STATUS_CODE {
+	_STATS_SUCCESSFUL_			= 0,
+	_STATS_FAILURE_				= 1,
+	_STATS_CAP_FAIL_			= 10,
+	_STATS_NO_ASOC_				= 11,
+	_STATS_OTHER_				= 12,
+	_STATS_NO_SUPP_ALG_			= 13,
+	_STATS_OUT_OF_AUTH_SEQ_		= 14,
+	_STATS_CHALLENGE_FAIL_		= 15,
+	_STATS_AUTH_TIMEOUT_		= 16,
+	_STATS_UNABLE_HANDLE_STA_	= 17,
+	_STATS_RATE_FAIL_			= 18,
+};
+
+/* Status codes (IEEE 802.11-2007, 7.3.1.9, Table 7-23) */
+#if 0
+#define WLAN_STATUS_SUCCESS 0
+#define WLAN_STATUS_UNSPECIFIED_FAILURE 1
+#define WLAN_STATUS_CAPS_UNSUPPORTED 10
+#define WLAN_STATUS_REASSOC_NO_ASSOC 11
+#define WLAN_STATUS_ASSOC_DENIED_UNSPEC 12
+#define WLAN_STATUS_NOT_SUPPORTED_AUTH_ALG 13
+#define WLAN_STATUS_UNKNOWN_AUTH_TRANSACTION 14
+#define WLAN_STATUS_CHALLENGE_FAIL 15
+#define WLAN_STATUS_AUTH_TIMEOUT 16
+#define WLAN_STATUS_AP_UNABLE_TO_HANDLE_NEW_STA 17
+#define WLAN_STATUS_ASSOC_DENIED_RATES 18
+#endif
+//entended
+/* IEEE 802.11b */
+#define WLAN_STATUS_ASSOC_DENIED_NOSHORT 19
+#define WLAN_STATUS_ASSOC_DENIED_NOPBCC 20
+#define WLAN_STATUS_ASSOC_DENIED_NOAGILITY 21
+/* IEEE 802.11h */
+#define WLAN_STATUS_SPEC_MGMT_REQUIRED 22
+#define WLAN_STATUS_PWR_CAPABILITY_NOT_VALID 23
+#define WLAN_STATUS_SUPPORTED_CHANNEL_NOT_VALID 24
+/* IEEE 802.11g */
+#define WLAN_STATUS_ASSOC_DENIED_NO_SHORT_SLOT_TIME 25
+#define WLAN_STATUS_ASSOC_DENIED_NO_ER_PBCC 26
+#define WLAN_STATUS_ASSOC_DENIED_NO_DSSS_OFDM 27
+/* IEEE 802.11w */
+#define WLAN_STATUS_ASSOC_REJECTED_TEMPORARILY 30
+#define WLAN_STATUS_ROBUST_MGMT_FRAME_POLICY_VIOLATION 31
+/* IEEE 802.11i */
+#define WLAN_STATUS_INVALID_IE 40
+#define WLAN_STATUS_GROUP_CIPHER_NOT_VALID 41
+#define WLAN_STATUS_PAIRWISE_CIPHER_NOT_VALID 42
+#define WLAN_STATUS_AKMP_NOT_VALID 43
+#define WLAN_STATUS_UNSUPPORTED_RSN_IE_VERSION 44
+#define WLAN_STATUS_INVALID_RSN_IE_CAPAB 45
+#define WLAN_STATUS_CIPHER_REJECTED_PER_POLICY 46
+#define WLAN_STATUS_TS_NOT_CREATED 47
+#define WLAN_STATUS_DIRECT_LINK_NOT_ALLOWED 48
+#define WLAN_STATUS_DEST_STA_NOT_PRESENT 49
+#define WLAN_STATUS_DEST_STA_NOT_QOS_STA 50
+#define WLAN_STATUS_ASSOC_DENIED_LISTEN_INT_TOO_LARGE 51
+/* IEEE 802.11r */
+#define WLAN_STATUS_INVALID_FT_ACTION_FRAME_COUNT 52
+#define WLAN_STATUS_INVALID_PMKID 53
+#define WLAN_STATUS_INVALID_MDIE 54
+#define WLAN_STATUS_INVALID_FTIE 55
+
+
+enum WIFI_REG_DOMAIN {
+	DOMAIN_FCC		= 1,
+	DOMAIN_IC		= 2,
+	DOMAIN_ETSI		= 3,
+	DOMAIN_SPAIN	= 4,
+	DOMAIN_FRANCE	= 5,
+	DOMAIN_MKK		= 6,
+	DOMAIN_ISRAEL	= 7,
+	DOMAIN_MKK1		= 8,
+	DOMAIN_MKK2		= 9,
+	DOMAIN_MKK3		= 10,
+	DOMAIN_MAX
+};
+
+#define _TO_DS_		BIT(8)
+#define _FROM_DS_	BIT(9)
+#define _MORE_FRAG_	BIT(10)
+#define _RETRY_		BIT(11)
+#define _PWRMGT_	BIT(12)
+#define _MORE_DATA_	BIT(13)
+#define _PRIVACY_	BIT(14)
+#define _ORDER_			BIT(15)
+
+#define SetToDs(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) |= cpu_to_le16(_TO_DS_); \
+	} while(0)
+
+#define GetToDs(pbuf)	(((*(unsigned short *)(pbuf)) & le16_to_cpu(_TO_DS_)) != 0)
+
+#define ClearToDs(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) &= (~cpu_to_le16(_TO_DS_)); \
+	} while(0)
+
+#define SetFrDs(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) |= cpu_to_le16(_FROM_DS_); \
+	} while(0)
+
+#define GetFrDs(pbuf)	(((*(unsigned short *)(pbuf)) & le16_to_cpu(_FROM_DS_)) != 0)
+
+#define ClearFrDs(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) &= (~cpu_to_le16(_FROM_DS_)); \
+	} while(0)
+
+#define get_tofr_ds(pframe)	((GetToDs(pframe) << 1) | GetFrDs(pframe))
+
+
+#define SetMFrag(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) |= cpu_to_le16(_MORE_FRAG_); \
+	} while(0)
+
+#define GetMFrag(pbuf)	(((*(unsigned short *)(pbuf)) & le16_to_cpu(_MORE_FRAG_)) != 0)
+
+#define ClearMFrag(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) &= (~cpu_to_le16(_MORE_FRAG_)); \
+	} while(0)
+
+#define SetRetry(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) |= cpu_to_le16(_RETRY_); \
+	} while(0)
+
+#define GetRetry(pbuf)	(((*(unsigned short *)(pbuf)) & le16_to_cpu(_RETRY_)) != 0)
+
+#define ClearRetry(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) &= (~cpu_to_le16(_RETRY_)); \
+	} while(0)
+
+#define SetPwrMgt(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) |= cpu_to_le16(_PWRMGT_); \
+	} while(0)
+
+#define GetPwrMgt(pbuf)	(((*(unsigned short *)(pbuf)) & le16_to_cpu(_PWRMGT_)) != 0)
+
+#define ClearPwrMgt(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) &= (~cpu_to_le16(_PWRMGT_)); \
+	} while(0)
+
+#define SetMData(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) |= cpu_to_le16(_MORE_DATA_); \
+	} while(0)
+
+#define GetMData(pbuf)	(((*(unsigned short *)(pbuf)) & le16_to_cpu(_MORE_DATA_)) != 0)
+
+#define ClearMData(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) &= (~cpu_to_le16(_MORE_DATA_)); \
+	} while(0)
+
+#define SetPrivacy(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) |= cpu_to_le16(_PRIVACY_); \
+	} while(0)
+
+#define GetPrivacy(pbuf)	(((*(unsigned short *)(pbuf)) & le16_to_cpu(_PRIVACY_)) != 0)
+
+#define ClearPrivacy(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) &= (~cpu_to_le16(_PRIVACY_)); \
+	} while(0)
+
+
+#define GetOrder(pbuf)	(((*(unsigned short *)(pbuf)) & le16_to_cpu(_ORDER_)) != 0)
+
+#define GetFrameType(pbuf)	(le16_to_cpu(*(unsigned short *)(pbuf)) & (BIT(3) | BIT(2)))
+
+#define SetFrameType(pbuf,type)	\
+	do { 	\
+		*(unsigned short *)(pbuf) &= __constant_cpu_to_le16(~(BIT(3) | BIT(2))); \
+		*(unsigned short *)(pbuf) |= __constant_cpu_to_le16(type); \
+	} while(0)
+
+#define GetFrameSubType(pbuf)	(cpu_to_le16(*(unsigned short *)(pbuf)) & (BIT(7) | BIT(6) | BIT(5) | BIT(4) | BIT(3) | BIT(2)))
+
+#define SetFrameSubType(pbuf,type) \
+	do {    \
+		*(unsigned short *)(pbuf) &= cpu_to_le16(~(BIT(7) | BIT(6) | BIT(5) | BIT(4) | BIT(3) | BIT(2))); \
+		*(unsigned short *)(pbuf) |= cpu_to_le16(type); \
+	} while(0)
+
+#define GetSequence(pbuf)	(cpu_to_le16(*(unsigned short *)((u8 *)(pbuf) + 22)) >> 4)
+
+#define GetFragNum(pbuf)	(cpu_to_le16(*(unsigned short *)((u8 *)(pbuf) + 22)) & 0x0f)
+
+#define GetTupleCache(pbuf)	(cpu_to_le16(*(unsigned short *)((u8 *)(pbuf) + 22)))
+
+#define SetFragNum(pbuf, num) \
+	do {    \
+		*(unsigned short *)((u8 *)(pbuf) + 22) = \
+			((*(unsigned short *)((u8 *)(pbuf) + 22)) & le16_to_cpu(~(0x000f))) | \
+			cpu_to_le16(0x0f & (num));     \
+	} while(0)
+
+#define SetSeqNum(pbuf, num) \
+	do {    \
+		*(unsigned short *)((u8 *)(pbuf) + 22) = \
+			((*(unsigned short *)((u8 *)(pbuf) + 22)) & le16_to_cpu((unsigned short)~0xfff0)) | \
+			le16_to_cpu((unsigned short)(0xfff0 & (num << 4))); \
+	} while(0)
+
+#define SetDuration(pbuf, dur) \
+	do {    \
+		*(unsigned short *)((u8 *)(pbuf) + 2) = cpu_to_le16(0xffff & (dur)); \
+	} while(0)
+
+
+#define SetPriority(pbuf, tid)	\
+	do	{	\
+		*(unsigned short *)(pbuf) |= cpu_to_le16(tid & 0xf); \
+	} while(0)
+
+#define GetPriority(pbuf)	((le16_to_cpu(*(unsigned short *)(pbuf))) & 0xf)
+
+#define SetEOSP(pbuf, eosp)	\
+	do	{	\
+		*(unsigned short *)(pbuf) |= cpu_to_le16( (eosp & 1) << 4); \
+	} while(0)
+
+#define SetAckpolicy(pbuf, ack)	\
+	do	{	\
+		*(unsigned short *)(pbuf) |= cpu_to_le16( (ack & 3) << 5); \
+	} while(0)
+
+#define GetAckpolicy(pbuf) (((le16_to_cpu(*(unsigned short *)pbuf)) >> 5) & 0x3)
+
+#define GetAMsdu(pbuf) (((le16_to_cpu(*(unsigned short *)pbuf)) >> 7) & 0x1)
+
+#define SetAMsdu(pbuf, amsdu)	\
+	do	{	\
+		*(unsigned short *)(pbuf) |= cpu_to_le16( (amsdu & 1) << 7); \
+	} while(0)
+
+#define GetAid(pbuf)	(cpu_to_le16(*(unsigned short *)((u8 *)(pbuf) + 2)) & 0x3fff)
+
+#define GetTid(pbuf)	(cpu_to_le16(*(unsigned short *)((u8 *)(pbuf) + (((GetToDs(pbuf)<<1)|GetFrDs(pbuf))==3?30:24))) & 0x000f)
+
+#define GetAddr1Ptr(pbuf)	((unsigned char *)((u8 *)(pbuf) + 4))
+
+#define GetAddr2Ptr(pbuf)	((unsigned char *)((u8 *)(pbuf) + 10))
+
+#define GetAddr3Ptr(pbuf)	((unsigned char *)((u8 *)(pbuf) + 16))
+
+#define GetAddr4Ptr(pbuf)	((unsigned char *)((u8 *)(pbuf) + 24))
+
+#define MacAddr_isBcst(addr) \
+( \
+	( (addr[0] == 0xff) && (addr[1] == 0xff) && \
+		(addr[2] == 0xff) && (addr[3] == 0xff) && \
+		(addr[4] == 0xff) && (addr[5] == 0xff) )  ? true : false \
+)
+
+__inline static unsigned char * get_da(unsigned char *pframe)
+{
+	unsigned char 	*da;
+	unsigned int	to_fr_ds	= (GetToDs(pframe) << 1) | GetFrDs(pframe);
+
+	switch (to_fr_ds) {
+		case 0x00:	// ToDs=0, FromDs=0
+			da = GetAddr1Ptr(pframe);
+			break;
+		case 0x01:	// ToDs=0, FromDs=1
+			da = GetAddr1Ptr(pframe);
+			break;
+		case 0x02:	// ToDs=1, FromDs=0
+			da = GetAddr3Ptr(pframe);
+			break;
+		default:	// ToDs=1, FromDs=1
+			da = GetAddr3Ptr(pframe);
+			break;
+	}
+
+	return da;
+}
+
+
+__inline static unsigned char * get_sa(unsigned char *pframe)
+{
+	unsigned char 	*sa;
+	unsigned int	to_fr_ds	= (GetToDs(pframe) << 1) | GetFrDs(pframe);
+
+	switch (to_fr_ds) {
+		case 0x00:	// ToDs=0, FromDs=0
+			sa = GetAddr2Ptr(pframe);
+			break;
+		case 0x01:	// ToDs=0, FromDs=1
+			sa = GetAddr3Ptr(pframe);
+			break;
+		case 0x02:	// ToDs=1, FromDs=0
+			sa = GetAddr2Ptr(pframe);
+			break;
+		default:	// ToDs=1, FromDs=1
+			sa = GetAddr4Ptr(pframe);
+			break;
+	}
+
+	return sa;
+}
+
+__inline static unsigned char * get_hdr_bssid(unsigned char *pframe)
+{
+	unsigned char 	*sa;
+	unsigned int	to_fr_ds	= (GetToDs(pframe) << 1) | GetFrDs(pframe);
+
+	switch (to_fr_ds) {
+		case 0x00:	// ToDs=0, FromDs=0
+			sa = GetAddr3Ptr(pframe);
+			break;
+		case 0x01:	// ToDs=0, FromDs=1
+			sa = GetAddr2Ptr(pframe);
+			break;
+		case 0x02:	// ToDs=1, FromDs=0
+			sa = GetAddr1Ptr(pframe);
+			break;
+		case 0x03:	// ToDs=1, FromDs=1
+			sa = GetAddr1Ptr(pframe);
+			break;
+		default:
+			sa =NULL; //???????
+			break;
+	}
+
+	return sa;
+}
+
+
+__inline static int IsFrameTypeCtrl(unsigned char *pframe)
+{
+	if(WIFI_CTRL_TYPE == GetFrameType(pframe))
+		return true;
+	else
+		return false;
+}
+/*-----------------------------------------------------------------------------
+			Below is for the security related definition
+------------------------------------------------------------------------------*/
+#define _RESERVED_FRAME_TYPE_	0
+#define _SKB_FRAME_TYPE_		2
+#define _PRE_ALLOCMEM_			1
+#define _PRE_ALLOCHDR_			3
+#define _PRE_ALLOCLLCHDR_		4
+#define _PRE_ALLOCICVHDR_		5
+#define _PRE_ALLOCMICHDR_		6
+
+#define _SIFSTIME_				((priv->pmib->dot11BssType.net_work_type&WIRELESS_11A)?16:10)
+#define _ACKCTSLNG_				14	//14 bytes long, including crclng
+#define _CRCLNG_				4
+
+#define _ASOCREQ_IE_OFFSET_		4	// excluding wlan_hdr
+#define	_ASOCRSP_IE_OFFSET_		6
+#define _REASOCREQ_IE_OFFSET_	10
+#define _REASOCRSP_IE_OFFSET_	6
+#define _PROBEREQ_IE_OFFSET_	0
+#define	_PROBERSP_IE_OFFSET_	12
+#define _AUTH_IE_OFFSET_		6
+#define _DEAUTH_IE_OFFSET_		0
+#define _BEACON_IE_OFFSET_		12
+#define _PUBLIC_ACTION_IE_OFFSET_	8
+
+#define _FIXED_IE_LENGTH_			_BEACON_IE_OFFSET_
+
+#define _SSID_IE_				0
+#define _SUPPORTEDRATES_IE_	1
+#define _DSSET_IE_				3
+#define _TIM_IE_					5
+#define _IBSS_PARA_IE_			6
+#define _COUNTRY_IE_			7
+#define _CHLGETXT_IE_			16
+#define _SUPPORTED_CH_IE_		36
+#define _CH_SWTICH_ANNOUNCE_	37	//Secondary Channel Offset
+#define _RSN_IE_2_				48
+#define _SSN_IE_1_					221
+#define _ERPINFO_IE_			42
+#define _EXT_SUPPORTEDRATES_IE_	50
+
+#define _HT_CAPABILITY_IE_			45
+#define _FTIE_						55
+#define _TIMEOUT_ITVL_IE_			56
+#define _SRC_IE_				59
+#define _HT_EXTRA_INFO_IE_			61
+#define _HT_ADD_INFO_IE_			61 //_HT_EXTRA_INFO_IE_
+#define _WAPI_IE_					68
+
+
+//#define EID_BSSCoexistence			72 // 20/40 BSS Coexistence
+//#define EID_BSSIntolerantChlReport	73
+#define _RIC_Descriptor_IE_			75
+
+#define _LINK_ID_IE_					101
+#define _CH_SWITCH_TIMING_		104
+#define _PTI_BUFFER_STATUS_		106
+#define _EXT_CAP_IE_				127
+#define _VENDOR_SPECIFIC_IE_		221
+
+#define	_RESERVED47_				47
+
+typedef	enum _ELEMENT_ID{
+	EID_SsId					= 0, /* service set identifier (0:32) */
+	EID_SupRates				= 1, /* supported rates (1:8) */
+	EID_FHParms				= 2, /* FH parameter set (5) */
+	EID_DSParms				= 3, /* DS parameter set (1) */
+	EID_CFParms				= 4, /* CF parameter set (6) */
+	EID_Tim						= 5, /* Traffic Information Map (4:254) */
+	EID_IbssParms				= 6, /* IBSS parameter set (2) */
+	EID_Country					= 7, /* */
+
+	// Form 7.3.2: Information elements in 802.11E/D13.0, page 46.
+	EID_QBSSLoad				= 11,
+	EID_EDCAParms				= 12,
+	EID_TSpec					= 13,
+	EID_TClass					= 14,
+	EID_Schedule				= 15,
+	//
+
+	EID_Ctext					= 16, /* challenge text*/
+	EID_POWER_CONSTRAINT		= 32, /* Power Constraint*/
+
+	//vivi for WIFITest, 802.11h AP, 20100427
+	// 2010/12/26 MH The definition we can declare always!!
+	EID_PowerCap				= 33,
+	EID_SupportedChannels		= 36,
+	EID_ChlSwitchAnnounce		= 37,
+
+	EID_MeasureRequest			= 38, // Measurement Request
+	EID_MeasureReport			= 39, // Measurement Report
+
+	EID_ERPInfo 				= 42,
+
+	// Form 7.3.2: Information elements in 802.11E/D13.0, page 46.
+	EID_TSDelay				= 43,
+	EID_TCLASProc				= 44,
+	EID_HTCapability			= 45,
+	EID_QoSCap					= 46,
+	//
+
+	EID_WPA2					= 48,
+	EID_ExtSupRates			= 50,
+
+	EID_FTIE					= 55, // Defined in 802.11r
+	EID_Timeout				= 56, // Defined in 802.11r
+
+	EID_SupRegulatory			= 59, // Supported Requlatory Classes 802.11y
+	EID_HTInfo 					= 61,
+	EID_SecondaryChnlOffset		= 62,
+
+	EID_BSSCoexistence			= 72, // 20/40 BSS Coexistence
+	EID_BSSIntolerantChlReport	= 73,
+	EID_OBSS					= 74, // Overlapping BSS Scan Parameters
+
+	EID_LinkIdentifier			= 101, // Defined in 802.11z
+	EID_WakeupSchedule		= 102, // Defined in 802.11z
+	EID_ChnlSwitchTimeing		= 104, // Defined in 802.11z
+	EID_PTIControl				= 105, // Defined in 802.11z
+	EID_PUBufferStatus			= 106, // Defined in 802.11z
+
+	EID_EXTCapability			= 127, // Extended Capabilities
+	// From S19:Aironet IE and S21:AP IP address IE in CCX v1.13, p16 and p18.
+	EID_Aironet					= 133, // 0x85: Aironet Element for Cisco CCX
+	EID_CiscoIP					= 149, // 0x95: IP Address IE for Cisco CCX
+
+	EID_CellPwr					= 150, // 0x96: Cell Power Limit IE. Ref. 0x96.
+
+	EID_CCKM    					= 156,
+
+	EID_Vendor					= 221, // 0xDD: Vendor Specific
+
+	EID_WAPI					= 68,
+	EID_VHTCapability 			= 191, // Based on 802.11ac D2.0
+	EID_VHTOperation 			= 192, // Based on 802.11ac D2.0
+	EID_OpModeNotification		= 199, // Based on 802.11ac D3.0
+}ELEMENT_ID, *PELEMENT_ID;
+
+/* ---------------------------------------------------------------------------
+					Below is the fixed elements...
+-----------------------------------------------------------------------------*/
+#define _AUTH_ALGM_NUM_			2
+#define _AUTH_SEQ_NUM_			2
+#define _BEACON_ITERVAL_		2
+#define _CAPABILITY_			2
+#define _CURRENT_APADDR_		6
+#define _LISTEN_INTERVAL_		2
+#define _RSON_CODE_				2
+#define _ASOC_ID_				2
+#define _STATUS_CODE_			2
+#define _TIMESTAMP_				8
+
+#define AUTH_ODD_TO				0
+#define AUTH_EVEN_TO			1
+
+#define WLAN_ETHCONV_ENCAP		1
+#define WLAN_ETHCONV_RFC1042	2
+#define WLAN_ETHCONV_8021h		3
+
+#define cap_ESS BIT(0)
+#define cap_IBSS BIT(1)
+#define cap_CFPollable BIT(2)
+#define cap_CFRequest BIT(3)
+#define cap_Privacy BIT(4)
+#define cap_ShortPremble BIT(5)
+#define cap_PBCC	BIT(6)
+#define cap_ChAgility	BIT(7)
+#define cap_SpecMgmt	BIT(8)
+#define cap_QoS	BIT(9)
+#define cap_ShortSlot	BIT(10)
+
+/*-----------------------------------------------------------------------------
+				Below is the definition for 802.11i / 802.1x
+------------------------------------------------------------------------------*/
+#define _IEEE8021X_MGT_			1		// WPA
+#define _IEEE8021X_PSK_			2		// WPA with pre-shared key
+
+/*
+#define _NO_PRIVACY_			0
+#define _WEP_40_PRIVACY_		1
+#define _TKIP_PRIVACY_			2
+#define _WRAP_PRIVACY_			3
+#define _CCMP_PRIVACY_			4
+#define _WEP_104_PRIVACY_		5
+#define _WEP_WPA_MIXED_PRIVACY_ 6	// WEP + WPA
+*/
+
+/*-----------------------------------------------------------------------------
+				Below is the definition for WMM
+------------------------------------------------------------------------------*/
+#define _WMM_IE_Length_				7  // for WMM STA
+#define _WMM_Para_Element_Length_		24
+
+
+/*-----------------------------------------------------------------------------
+				Below is the definition for 802.11n
+------------------------------------------------------------------------------*/
+
+#define SetOrderBit(pbuf)	\
+	do	{	\
+		*(unsigned short *)(pbuf) |= cpu_to_le16(_ORDER_); \
+	} while(0)
+
+#define GetOrderBit(pbuf)	(((*(unsigned short *)(pbuf)) & le16_to_cpu(_ORDER_)) != 0)
+
+
+/**
+ * struct rtw_ieee80211_bar - HT Block Ack Request
+ *
+ * This structure refers to "HT BlockAckReq" as
+ * described in 802.11n draft section 7.2.1.7.1
+ */
+struct rtw_ieee80211_bar {
+	unsigned short frame_control;
+	unsigned short duration;
+	unsigned char ra[6];
+	unsigned char ta[6];
+	unsigned short control;
+	unsigned short start_seq_num;
+} __attribute__((packed));
+
+/* 802.11 BAR control masks */
+#define IEEE80211_BAR_CTRL_ACK_POLICY_NORMAL     0x0000
+#define IEEE80211_BAR_CTRL_CBMTID_COMPRESSED_BA  0x0004
+
+ /**
+ * struct rtw_ieee80211_ht_cap - HT capabilities
+ *
+ * This structure refers to "HT capabilities element" as
+ * described in 802.11n draft section 7.3.2.52
+ */
+
+struct rtw_ieee80211_ht_cap {
+	unsigned short 	cap_info;
+	unsigned char 	ampdu_params_info;
+	unsigned char 	supp_mcs_set[16];
+	unsigned short 	extended_ht_cap_info;
+	unsigned int		tx_BF_cap_info;
+	unsigned char	       antenna_selection_info;
+} __attribute__ ((packed));
+
+/**
+ * struct rtw_ieee80211_ht_cap - HT additional information
+ *
+ * This structure refers to "HT information element" as
+ * described in 802.11n draft section 7.3.2.53
+ */
+struct ieee80211_ht_addt_info {
+	unsigned char 	control_chan;
+	unsigned char		ht_param;
+	unsigned short	operation_mode;
+	unsigned short	stbc_param;
+	unsigned char		basic_set[16];
+} __attribute__ ((packed));
+
+
+struct HT_caps_element
+{
+	union
+	{
+		struct
+		{
+			unsigned short	HT_caps_info;
+			unsigned char	AMPDU_para;
+			unsigned char	MCS_rate[16];
+			unsigned short	HT_ext_caps;
+			unsigned int	Beamforming_caps;
+			unsigned char	ASEL_caps;
+		} HT_cap_element;
+		unsigned char HT_cap[26];
+	}u;
+} __attribute__ ((packed));
+
+struct HT_info_element
+{
+	unsigned char	primary_channel;
+	unsigned char	infos[5];
+	unsigned char	MCS_rate[16];
+}  __attribute__ ((packed));
+
+struct AC_param
+{
+	unsigned char		ACI_AIFSN;
+	unsigned char		CW;
+	unsigned short	TXOP_limit;
+}  __attribute__ ((packed));
+
+struct WMM_para_element
+{
+	unsigned char		QoS_info;
+	unsigned char		reserved;
+	struct AC_param	ac_param[4];
+}  __attribute__ ((packed));
+
+struct ADDBA_request
+{
+	unsigned char		dialog_token;
+	unsigned short	BA_para_set;
+	unsigned short	BA_timeout_value;
+	unsigned short	BA_starting_seqctrl;
+}  __attribute__ ((packed));
+
+typedef enum _HT_CAP_AMPDU_FACTOR {
+	MAX_AMPDU_FACTOR_8K		= 0,
+	MAX_AMPDU_FACTOR_16K	= 1,
+	MAX_AMPDU_FACTOR_32K	= 2,
+	MAX_AMPDU_FACTOR_64K	= 3,
+}HT_CAP_AMPDU_FACTOR;
+
+/* 802.11n HT capabilities masks */
+#define IEEE80211_HT_CAP_SUP_WIDTH		0x0002
+#define IEEE80211_HT_CAP_SM_PS			0x000C
+#define IEEE80211_HT_CAP_GRN_FLD		0x0010
+#define IEEE80211_HT_CAP_SGI_20			0x0020
+#define IEEE80211_HT_CAP_SGI_40			0x0040
+#define IEEE80211_HT_CAP_TX_STBC			0x0080
+#define IEEE80211_HT_CAP_RX_STBC		0x0300
+#define IEEE80211_HT_CAP_DELAY_BA		0x0400
+#define IEEE80211_HT_CAP_MAX_AMSDU		0x0800
+#define IEEE80211_HT_CAP_DSSSCCK40		0x1000
+/* 802.11n HT capability AMPDU settings */
+#define IEEE80211_HT_CAP_AMPDU_FACTOR		0x03
+#define IEEE80211_HT_CAP_AMPDU_DENSITY		0x1C
+/* 802.11n HT capability MSC set */
+#define IEEE80211_SUPP_MCS_SET_UEQM		4
+#define IEEE80211_HT_CAP_MAX_STREAMS		4
+#define IEEE80211_SUPP_MCS_SET_LEN		10
+/* maximum streams the spec allows */
+#define IEEE80211_HT_CAP_MCS_TX_DEFINED		0x01
+#define IEEE80211_HT_CAP_MCS_TX_RX_DIFF		0x02
+#define IEEE80211_HT_CAP_MCS_TX_STREAMS		0x0C
+#define IEEE80211_HT_CAP_MCS_TX_UEQM		0x10
+/* 802.11n HT IE masks */
+#define IEEE80211_HT_IE_CHA_SEC_OFFSET		0x03
+#define IEEE80211_HT_IE_CHA_SEC_NONE	 	0x00
+#define IEEE80211_HT_IE_CHA_SEC_ABOVE 		0x01
+#define IEEE80211_HT_IE_CHA_SEC_BELOW 		0x03
+#define IEEE80211_HT_IE_CHA_WIDTH		0x04
+#define IEEE80211_HT_IE_HT_PROTECTION		0x0003
+#define IEEE80211_HT_IE_NON_GF_STA_PRSNT	0x0004
+#define IEEE80211_HT_IE_NON_HT_STA_PRSNT	0x0010
+
+/* block-ack parameters */
+#define IEEE80211_ADDBA_PARAM_POLICY_MASK 0x0002
+#define IEEE80211_ADDBA_PARAM_TID_MASK 0x003C
+#define RTW_IEEE80211_ADDBA_PARAM_BUF_SIZE_MASK 0xFFC0
+#define IEEE80211_DELBA_PARAM_TID_MASK 0xF000
+#define IEEE80211_DELBA_PARAM_INITIATOR_MASK 0x0800
+
+/*
+ * A-PMDU buffer sizes
+ * According to IEEE802.11n spec size varies from 8K to 64K (in powers of 2)
+ */
+#define IEEE80211_MIN_AMPDU_BUF 0x8
+#define IEEE80211_MAX_AMPDU_BUF 0x40
+
+
+/* Spatial Multiplexing Power Save Modes */
+#define WLAN_HT_CAP_SM_PS_STATIC		0
+#define WLAN_HT_CAP_SM_PS_DYNAMIC	1
+#define WLAN_HT_CAP_SM_PS_INVALID	2
+#define WLAN_HT_CAP_SM_PS_DISABLED	3
+
+
+#define OP_MODE_PURE                    0
+#define OP_MODE_MAY_BE_LEGACY_STAS      1
+#define OP_MODE_20MHZ_HT_STA_ASSOCED    2
+#define OP_MODE_MIXED                   3
+
+#define HT_INFO_HT_PARAM_SECONDARY_CHNL_OFF_MASK	((uint8_t) BIT(0) | BIT(1))
+#define HT_INFO_HT_PARAM_SECONDARY_CHNL_ABOVE		((uint8_t) BIT(0))
+#define HT_INFO_HT_PARAM_SECONDARY_CHNL_BELOW		((uint8_t) BIT(0) | BIT(1))
+#define HT_INFO_HT_PARAM_REC_TRANS_CHNL_WIDTH		((uint8_t) BIT(2))
+#define HT_INFO_HT_PARAM_RIFS_MODE			((uint8_t) BIT(3))
+#define HT_INFO_HT_PARAM_CTRL_ACCESS_ONLY		((uint8_t) BIT(4))
+#define HT_INFO_HT_PARAM_SRV_INTERVAL_GRANULARITY	((uint8_t) BIT(5))
+
+#define HT_INFO_OPERATION_MODE_OP_MODE_MASK	\
+		((u16) (0x0001 | 0x0002))
+#define HT_INFO_OPERATION_MODE_OP_MODE_OFFSET		0
+#define HT_INFO_OPERATION_MODE_NON_GF_DEVS_PRESENT	((uint8_t) BIT(2))
+#define HT_INFO_OPERATION_MODE_TRANSMIT_BURST_LIMIT	((uint8_t) BIT(3))
+#define HT_INFO_OPERATION_MODE_NON_HT_STA_PRESENT	((uint8_t) BIT(4))
+
+#define HT_INFO_STBC_PARAM_DUAL_BEACON			((u16) BIT(6))
+#define HT_INFO_STBC_PARAM_DUAL_STBC_PROTECT		((u16) BIT(7))
+#define HT_INFO_STBC_PARAM_SECONDARY_BCN		((u16) BIT(8))
+#define HT_INFO_STBC_PARAM_LSIG_TXOP_PROTECT_ALLOWED	((u16) BIT(9))
+#define HT_INFO_STBC_PARAM_PCO_ACTIVE			((u16) BIT(10))
+#define HT_INFO_STBC_PARAM_PCO_PHASE			((u16) BIT(11))
+
+
+
+//#endif
+
+//	===============WPS Section===============
+//	For WPSv1.0
+#define WPSOUI							0x0050f204
+//	WPS attribute ID
+#define WPS_ATTR_VER1					0x104A
+#define WPS_ATTR_SIMPLE_CONF_STATE	0x1044
+#define WPS_ATTR_RESP_TYPE			0x103B
+#define WPS_ATTR_UUID_E				0x1047
+#define WPS_ATTR_MANUFACTURER		0x1021
+#define WPS_ATTR_MODEL_NAME			0x1023
+#define WPS_ATTR_MODEL_NUMBER		0x1024
+#define WPS_ATTR_SERIAL_NUMBER		0x1042
+#define WPS_ATTR_PRIMARY_DEV_TYPE	0x1054
+#define WPS_ATTR_SEC_DEV_TYPE_LIST	0x1055
+#define WPS_ATTR_DEVICE_NAME			0x1011
+#define WPS_ATTR_CONF_METHOD			0x1008
+#define WPS_ATTR_RF_BANDS				0x103C
+#define WPS_ATTR_DEVICE_PWID			0x1012
+#define WPS_ATTR_REQUEST_TYPE			0x103A
+#define WPS_ATTR_ASSOCIATION_STATE	0x1002
+#define WPS_ATTR_CONFIG_ERROR			0x1009
+#define WPS_ATTR_VENDOR_EXT			0x1049
+#define WPS_ATTR_SELECTED_REGISTRAR	0x1041
+
+//	Value of WPS attribute "WPS_ATTR_DEVICE_NAME
+#define WPS_MAX_DEVICE_NAME_LEN		32
+
+//	Value of WPS Request Type Attribute
+#define WPS_REQ_TYPE_ENROLLEE_INFO_ONLY			0x00
+#define WPS_REQ_TYPE_ENROLLEE_OPEN_8021X		0x01
+#define WPS_REQ_TYPE_REGISTRAR					0x02
+#define WPS_REQ_TYPE_WLAN_MANAGER_REGISTRAR	0x03
+
+//	Value of WPS Response Type Attribute
+#define WPS_RESPONSE_TYPE_INFO_ONLY	0x00
+#define WPS_RESPONSE_TYPE_8021X		0x01
+#define WPS_RESPONSE_TYPE_REGISTRAR	0x02
+#define WPS_RESPONSE_TYPE_AP			0x03
+
+//	Value of WPS WiFi Simple Configuration State Attribute
+#define WPS_WSC_STATE_NOT_CONFIG	0x01
+#define WPS_WSC_STATE_CONFIG			0x02
+
+//	Value of WPS Version Attribute
+#define WPS_VERSION_1					0x10
+
+//	Value of WPS Configuration Method Attribute
+#define WPS_CONFIG_METHOD_FLASH		0x0001
+#define WPS_CONFIG_METHOD_ETHERNET	0x0002
+#define WPS_CONFIG_METHOD_LABEL		0x0004
+#define WPS_CONFIG_METHOD_DISPLAY	0x0008
+#define WPS_CONFIG_METHOD_E_NFC		0x0010
+#define WPS_CONFIG_METHOD_I_NFC		0x0020
+#define WPS_CONFIG_METHOD_NFC		0x0040
+#define WPS_CONFIG_METHOD_PBC		0x0080
+#define WPS_CONFIG_METHOD_KEYPAD	0x0100
+#define WPS_CONFIG_METHOD_VPBC		0x0280
+#define WPS_CONFIG_METHOD_PPBC		0x0480
+#define WPS_CONFIG_METHOD_VDISPLAY	0x2008
+#define WPS_CONFIG_METHOD_PDISPLAY	0x4008
+
+//	Value of Category ID of WPS Primary Device Type Attribute
+#define WPS_PDT_CID_DISPLAYS			0x0007
+#define WPS_PDT_CID_MULIT_MEDIA		0x0008
+#define WPS_PDT_CID_RTK_WIDI			WPS_PDT_CID_MULIT_MEDIA
+
+//	Value of Sub Category ID of WPS Primary Device Type Attribute
+#define WPS_PDT_SCID_MEDIA_SERVER	0x0005
+#define WPS_PDT_SCID_RTK_DMP			WPS_PDT_SCID_MEDIA_SERVER
+
+//	Value of Device Password ID
+#define WPS_DPID_PIN					0x0000
+#define WPS_DPID_USER_SPEC			0x0001
+#define WPS_DPID_MACHINE_SPEC			0x0002
+#define WPS_DPID_REKEY					0x0003
+#define WPS_DPID_PBC					0x0004
+#define WPS_DPID_REGISTRAR_SPEC		0x0005
+
+//	Value of WPS RF Bands Attribute
+#define WPS_RF_BANDS_2_4_GHZ		0x01
+#define WPS_RF_BANDS_5_GHZ		0x02
+
+//	Value of WPS Association State Attribute
+#define WPS_ASSOC_STATE_NOT_ASSOCIATED			0x00
+#define WPS_ASSOC_STATE_CONNECTION_SUCCESS		0x01
+#define WPS_ASSOC_STATE_CONFIGURATION_FAILURE	0x02
+#define WPS_ASSOC_STATE_ASSOCIATION_FAILURE		0x03
+#define WPS_ASSOC_STATE_IP_FAILURE				0x04
+
+//	=====================P2P Section=====================
+//	For P2P
+#define	P2POUI							0x506F9A09
+
+//	P2P Attribute ID
+#define	P2P_ATTR_STATUS					0x00
+#define	P2P_ATTR_MINOR_REASON_CODE		0x01
+#define	P2P_ATTR_CAPABILITY				0x02
+#define	P2P_ATTR_DEVICE_ID				0x03
+#define	P2P_ATTR_GO_INTENT				0x04
+#define	P2P_ATTR_CONF_TIMEOUT			0x05
+#define	P2P_ATTR_LISTEN_CH				0x06
+#define	P2P_ATTR_GROUP_BSSID				0x07
+#define	P2P_ATTR_EX_LISTEN_TIMING		0x08
+#define	P2P_ATTR_INTENTED_IF_ADDR		0x09
+#define	P2P_ATTR_MANAGEABILITY			0x0A
+#define	P2P_ATTR_CH_LIST					0x0B
+#define	P2P_ATTR_NOA						0x0C
+#define	P2P_ATTR_DEVICE_INFO				0x0D
+#define	P2P_ATTR_GROUP_INFO				0x0E
+#define	P2P_ATTR_GROUP_ID					0x0F
+#define	P2P_ATTR_INTERFACE				0x10
+#define	P2P_ATTR_OPERATING_CH			0x11
+#define	P2P_ATTR_INVITATION_FLAGS		0x12
+
+//	Value of Status Attribute
+#define	P2P_STATUS_SUCCESS						0x00
+#define	P2P_STATUS_FAIL_INFO_UNAVAILABLE		0x01
+#define	P2P_STATUS_FAIL_INCOMPATIBLE_PARAM		0x02
+#define	P2P_STATUS_FAIL_LIMIT_REACHED			0x03
+#define	P2P_STATUS_FAIL_INVALID_PARAM			0x04
+#define	P2P_STATUS_FAIL_REQUEST_UNABLE			0x05
+#define	P2P_STATUS_FAIL_PREVOUS_PROTO_ERR		0x06
+#define	P2P_STATUS_FAIL_NO_COMMON_CH			0x07
+#define	P2P_STATUS_FAIL_UNKNOWN_P2PGROUP		0x08
+#define	P2P_STATUS_FAIL_BOTH_GOINTENT_15		0x09
+#define	P2P_STATUS_FAIL_INCOMPATIBLE_PROVSION	0x0A
+#define	P2P_STATUS_FAIL_USER_REJECT				0x0B
+
+//	Value of Inviation Flags Attribute
+#define	P2P_INVITATION_FLAGS_PERSISTENT			BIT(0)
+
+#define	DMP_P2P_DEVCAP_SUPPORT	(P2P_DEVCAP_SERVICE_DISCOVERY | \
+									P2P_DEVCAP_CLIENT_DISCOVERABILITY | \
+									P2P_DEVCAP_CONCURRENT_OPERATION | \
+									P2P_DEVCAP_INVITATION_PROC)
+
+#define	DMP_P2P_GRPCAP_SUPPORT	(P2P_GRPCAP_INTRABSS)
+
+//	Value of Device Capability Bitmap
+#define	P2P_DEVCAP_SERVICE_DISCOVERY		BIT(0)
+#define	P2P_DEVCAP_CLIENT_DISCOVERABILITY	BIT(1)
+#define	P2P_DEVCAP_CONCURRENT_OPERATION	BIT(2)
+#define	P2P_DEVCAP_INFRA_MANAGED			BIT(3)
+#define	P2P_DEVCAP_DEVICE_LIMIT				BIT(4)
+#define	P2P_DEVCAP_INVITATION_PROC			BIT(5)
+
+//	Value of Group Capability Bitmap
+#define	P2P_GRPCAP_GO							BIT(0)
+#define	P2P_GRPCAP_PERSISTENT_GROUP			BIT(1)
+#define	P2P_GRPCAP_GROUP_LIMIT				BIT(2)
+#define	P2P_GRPCAP_INTRABSS					BIT(3)
+#define	P2P_GRPCAP_CROSS_CONN				BIT(4)
+#define	P2P_GRPCAP_PERSISTENT_RECONN		BIT(5)
+#define	P2P_GRPCAP_GROUP_FORMATION			BIT(6)
+
+//	P2P Public Action Frame ( Management Frame )
+#define	P2P_PUB_ACTION_ACTION				0x09
+
+//	P2P Public Action Frame Type
+#define	P2P_GO_NEGO_REQ						0
+#define	P2P_GO_NEGO_RESP						1
+#define	P2P_GO_NEGO_CONF						2
+#define	P2P_INVIT_REQ							3
+#define	P2P_INVIT_RESP							4
+#define	P2P_DEVDISC_REQ						5
+#define	P2P_DEVDISC_RESP						6
+#define	P2P_PROVISION_DISC_REQ				7
+#define	P2P_PROVISION_DISC_RESP				8
+
+//	P2P Action Frame Type
+#define	P2P_NOTICE_OF_ABSENCE	0
+#define	P2P_PRESENCE_REQUEST		1
+#define	P2P_PRESENCE_RESPONSE	2
+#define	P2P_GO_DISC_REQUEST		3
+
+
+#define	P2P_MAX_PERSISTENT_GROUP_NUM		10
+
+#define	P2P_PROVISIONING_SCAN_CNT			3
+
+#define	P2P_WILDCARD_SSID_LEN				7
+
+#define	P2P_FINDPHASE_EX_NONE				0	// default value, used when: (1)p2p disabed or (2)p2p enabled but only do 1 scan phase
+#define	P2P_FINDPHASE_EX_FULL				1	// used when p2p enabled and want to do 1 scan phase and P2P_FINDPHASE_EX_MAX-1 find phase
+#define	P2P_FINDPHASE_EX_SOCIAL_FIRST		(P2P_FINDPHASE_EX_FULL+1)
+#define	P2P_FINDPHASE_EX_MAX					4
+#define	P2P_FINDPHASE_EX_SOCIAL_LAST		P2P_FINDPHASE_EX_MAX
+
+#define	P2P_PROVISION_TIMEOUT				5000	//	5 seconds timeout for sending the provision discovery request
+#define	P2P_CONCURRENT_PROVISION_TIMEOUT	3000	//	3 seconds timeout for sending the provision discovery request under concurrent mode
+#define	P2P_GO_NEGO_TIMEOUT					5000	//	5 seconds timeout for receiving the group negotation response
+#define	P2P_CONCURRENT_GO_NEGO_TIMEOUT		3000	//	3 seconds timeout for sending the negotiation request under concurrent mode
+#define	P2P_TX_PRESCAN_TIMEOUT				100		//	100ms
+#define	P2P_INVITE_TIMEOUT					5000	//	5 seconds timeout for sending the invitation request
+#define	P2P_CONCURRENT_INVITE_TIMEOUT		3000	//	3 seconds timeout for sending the invitation request under concurrent mode
+#define	P2P_RESET_SCAN_CH						25000	//	25 seconds timeout to reset the scan channel ( based on channel plan )
+#define	P2P_MAX_INTENT						15
+
+#define	P2P_MAX_NOA_NUM						2
+
+//	WPS Configuration Method
+#define	WPS_CM_NONE							0x0000
+#define	WPS_CM_LABEL							0x0004
+#define	WPS_CM_DISPLYA						0x0008
+#define	WPS_CM_EXTERNAL_NFC_TOKEN			0x0010
+#define	WPS_CM_INTEGRATED_NFC_TOKEN		0x0020
+#define	WPS_CM_NFC_INTERFACE					0x0040
+#define	WPS_CM_PUSH_BUTTON					0x0080
+#define	WPS_CM_KEYPAD						0x0100
+#define	WPS_CM_SW_PUHS_BUTTON				0x0280
+#define	WPS_CM_HW_PUHS_BUTTON				0x0480
+#define	WPS_CM_SW_DISPLAY_PIN				0x2008
+#define	WPS_CM_LCD_DISPLAY_PIN				0x4008
+
+enum P2P_ROLE {
+	P2P_ROLE_DISABLE = 0,
+	P2P_ROLE_DEVICE = 1,
+	P2P_ROLE_CLIENT = 2,
+	P2P_ROLE_GO = 3
+};
+
+enum P2P_STATE {
+	P2P_STATE_NONE = 0,							//	P2P disable
+	P2P_STATE_IDLE = 1,								//	P2P had enabled and do nothing
+	P2P_STATE_LISTEN = 2,							//	In pure listen state
+	P2P_STATE_SCAN = 3,							//	In scan phase
+	P2P_STATE_FIND_PHASE_LISTEN = 4,				//	In the listen state of find phase
+	P2P_STATE_FIND_PHASE_SEARCH = 5,				//	In the search state of find phase
+	P2P_STATE_TX_PROVISION_DIS_REQ = 6,			//	In P2P provisioning discovery
+	P2P_STATE_RX_PROVISION_DIS_RSP = 7,
+	P2P_STATE_RX_PROVISION_DIS_REQ = 8,
+	P2P_STATE_GONEGO_ING = 9,						//	Doing the group owner negoitation handshake
+	P2P_STATE_GONEGO_OK = 10,						//	finish the group negoitation handshake with success
+	P2P_STATE_GONEGO_FAIL = 11,					//	finish the group negoitation handshake with failure
+	P2P_STATE_RECV_INVITE_REQ_MATCH = 12,		//	receiving the P2P Inviation request and match with the profile.
+	P2P_STATE_PROVISIONING_ING = 13,				//	Doing the P2P WPS
+	P2P_STATE_PROVISIONING_DONE = 14,			//	Finish the P2P WPS
+	P2P_STATE_TX_INVITE_REQ = 15,					//	Transmit the P2P Invitation request
+	P2P_STATE_RX_INVITE_RESP_OK = 16,				//	Receiving the P2P Invitation response
+	P2P_STATE_RECV_INVITE_REQ_DISMATCH = 17,	//	receiving the P2P Inviation request and dismatch with the profile.
+	P2P_STATE_RECV_INVITE_REQ_GO = 18,			//	receiving the P2P Inviation request and this wifi is GO.
+	P2P_STATE_RECV_INVITE_REQ_JOIN = 19,			//	receiving the P2P Inviation request to join an existing P2P Group.
+	P2P_STATE_RX_INVITE_RESP_FAIL = 20,			//	recveing the P2P Inviation response with failure
+	P2P_STATE_RX_INFOR_NOREADY = 21, 			// receiving p2p negoitation response with information is not available
+	P2P_STATE_TX_INFOR_NOREADY = 22, 			// sending p2p negoitation response with information is not available
+};
+
+enum P2P_WPSINFO {
+	P2P_NO_WPSINFO						= 0,
+	P2P_GOT_WPSINFO_PEER_DISPLAY_PIN	= 1,
+	P2P_GOT_WPSINFO_SELF_DISPLAY_PIN	= 2,
+	P2P_GOT_WPSINFO_PBC					= 3,
+};
+
+#define	P2P_PRIVATE_IOCTL_SET_LEN		64
+
+enum P2P_PROTO_WK_ID
+{
+	P2P_FIND_PHASE_WK = 0,
+	P2P_RESTORE_STATE_WK = 1,
+	P2P_PRE_TX_PROVDISC_PROCESS_WK = 2,
+	P2P_PRE_TX_NEGOREQ_PROCESS_WK = 3,
+	P2P_PRE_TX_INVITEREQ_PROCESS_WK = 4,
+	P2P_AP_P2P_CH_SWITCH_PROCESS_WK =5,
+	P2P_RO_CH_WK = 6,
+};
+
+//	=====================WFD Section=====================
+//	For Wi-Fi Display
+#define	WFD_ATTR_DEVICE_INFO			0x00
+#define	WFD_ATTR_ASSOC_BSSID			0x01
+#define	WFD_ATTR_COUPLED_SINK_INFO	0x06
+#define	WFD_ATTR_LOCAL_IP_ADDR		0x08
+#define	WFD_ATTR_SESSION_INFO		0x09
+#define	WFD_ATTR_ALTER_MAC			0x0a
+
+//	For WFD Device Information Attribute
+#define	WFD_DEVINFO_SOURCE					0x0000
+#define	WFD_DEVINFO_PSINK					0x0001
+#define	WFD_DEVINFO_SSINK					0x0002
+#define	WFD_DEVINFO_DUAL 					0x0003
+
+#define	WFD_DEVINFO_SESSION_AVAIL			0x0010
+#define	WFD_DEVINFO_WSD						0x0040
+#define	WFD_DEVINFO_PC_TDLS					0x0080
+#define	WFD_DEVINFO_HDCP_SUPPORT			0x0100
+
+#ifdef  CONFIG_TX_MCAST2UNI
+#define IP_MCAST_MAC(mac)		((mac[0]==0x01)&&(mac[1]==0x00)&&(mac[2]==0x5e))
+#define ICMPV6_MCAST_MAC(mac)	((mac[0]==0x33)&&(mac[1]==0x33)&&(mac[2]!=0xff))
+#endif	// CONFIG_TX_MCAST2UNI
+
+#endif // _WIFI_H_
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/include/wlan_bssdef.h linux-4.9.8821au/drivers/staging/rtl8821au/include/wlan_bssdef.h
--- linux-4.9/drivers/staging/rtl8821au/include/wlan_bssdef.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/include/wlan_bssdef.h	2016-12-11 19:48:25.176978367 -0600
@@ -0,0 +1,421 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __WLAN_BSSDEF_H__
+#define __WLAN_BSSDEF_H__
+
+
+#define MAX_IE_SZ	768
+
+#define NDIS_802_11_LENGTH_SSID         32
+#define NDIS_802_11_LENGTH_RATES        8
+#define NDIS_802_11_LENGTH_RATES_EX     16
+
+typedef unsigned char   NDIS_802_11_MAC_ADDRESS[6];
+typedef long    		NDIS_802_11_RSSI;           // in dBm
+typedef unsigned char   NDIS_802_11_RATES[NDIS_802_11_LENGTH_RATES];        // Set of 8 data rates
+typedef unsigned char   NDIS_802_11_RATES_EX[NDIS_802_11_LENGTH_RATES_EX];  // Set of 16 data rates
+
+
+typedef  u32  NDIS_802_11_KEY_INDEX;
+typedef unsigned long long NDIS_802_11_KEY_RSC;
+
+
+typedef struct _NDIS_802_11_SSID
+{
+  u32  SsidLength;
+  uint8_t  Ssid[32];
+} NDIS_802_11_SSID, *PNDIS_802_11_SSID;
+
+typedef enum _NDIS_802_11_NETWORK_TYPE
+{
+    Ndis802_11FH,
+    Ndis802_11DS,
+    Ndis802_11OFDM5,
+    Ndis802_11OFDM24,
+    Ndis802_11NetworkTypeMax    // not a real type, defined as an upper bound
+} NDIS_802_11_NETWORK_TYPE, *PNDIS_802_11_NETWORK_TYPE;
+
+typedef struct _NDIS_802_11_CONFIGURATION_FH
+{
+    u32           Length;             // Length of structure
+    u32           HopPattern;         // As defined by 802.11, MSB set
+    u32           HopSet;             // to one if non-802.11
+    u32           DwellTime;          // units are Kusec
+} NDIS_802_11_CONFIGURATION_FH, *PNDIS_802_11_CONFIGURATION_FH;
+
+
+/*
+	FW will only save the channel number in DSConfig.
+	ODI Handler will convert the channel number to freq. number.
+*/
+typedef struct _NDIS_802_11_CONFIGURATION
+{
+    u32           Length;             // Length of structure
+    u32           BeaconPeriod;       // units are Kusec
+    u32           ATIMWindow;         // units are Kusec
+    u32           DSConfig;           // Frequency, units are kHz
+    NDIS_802_11_CONFIGURATION_FH    FHConfig;
+} NDIS_802_11_CONFIGURATION, *PNDIS_802_11_CONFIGURATION;
+
+
+
+typedef enum _NDIS_802_11_NETWORK_INFRASTRUCTURE
+{
+    Ndis802_11IBSS,
+    Ndis802_11Infrastructure,
+    Ndis802_11AutoUnknown,
+    Ndis802_11InfrastructureMax,     // Not a real value, defined as upper bound
+    Ndis802_11APMode
+} NDIS_802_11_NETWORK_INFRASTRUCTURE, *PNDIS_802_11_NETWORK_INFRASTRUCTURE;
+
+
+
+
+
+typedef struct _NDIS_802_11_FIXED_IEs
+{
+  uint8_t  Timestamp[8];
+  u16  BeaconInterval;
+  u16  Capabilities;
+} NDIS_802_11_FIXED_IEs, *PNDIS_802_11_FIXED_IEs;
+
+
+
+typedef struct _NDIS_802_11_VARIABLE_IEs
+{
+  uint8_t  ElementID;
+  uint8_t  Length;
+  uint8_t  data[1];
+} NDIS_802_11_VARIABLE_IEs, *PNDIS_802_11_VARIABLE_IEs;
+
+
+
+/*
+
+
+
+Length is the 4 bytes multiples of the sume of
+	sizeof (NDIS_802_11_MAC_ADDRESS) + 2 + sizeof (NDIS_802_11_SSID) + sizeof (u32)
++   sizeof (NDIS_802_11_RSSI) + sizeof (NDIS_802_11_NETWORK_TYPE) + sizeof (NDIS_802_11_CONFIGURATION)
++   sizeof (NDIS_802_11_RATES_EX) + IELength
+
+Except the IELength, all other fields are fixed length. Therefore, we can define a marco to present the
+partial sum.
+
+*/
+#if 0
+typedef struct _NDIS_WLAN_BSSID_EX
+{
+  u32  Length;
+  NDIS_802_11_MAC_ADDRESS  MacAddress;
+  uint8_t  Reserved[2];//[0]: IS beacon frame, [1]:optimum_antenna=>For antenna diversity;
+  NDIS_802_11_SSID  Ssid;
+  u32  Privacy;
+  NDIS_802_11_RSSI  Rssi;
+  NDIS_802_11_NETWORK_TYPE  NetworkTypeInUse;
+  NDIS_802_11_CONFIGURATION  Configuration;
+  NDIS_802_11_NETWORK_INFRASTRUCTURE  InfrastructureMode;
+  NDIS_802_11_RATES_EX  SupportedRates;
+  u32  IELength;
+  uint8_t  IEs[MAX_IE_SZ];	//(timestamp, beacon interval, and capability information)
+} NDIS_WLAN_BSSID_EX, *PNDIS_WLAN_BSSID_EX;
+
+
+typedef struct _NDIS_802_11_BSSID_LIST_EX
+{
+  u32  NumberOfItems;
+  NDIS_WLAN_BSSID_EX  Bssid[1];
+} NDIS_802_11_BSSID_LIST_EX, *PNDIS_802_11_BSSID_LIST_EX;
+#endif
+
+typedef enum _NDIS_802_11_AUTHENTICATION_MODE
+{
+    Ndis802_11AuthModeOpen,
+    Ndis802_11AuthModeShared,
+    Ndis802_11AuthModeAutoSwitch,
+    Ndis802_11AuthModeWPA,
+    Ndis802_11AuthModeWPAPSK,
+    Ndis802_11AuthModeWPANone,
+    Ndis802_11AuthModeWAPI,
+    Ndis802_11AuthModeMax               // Not a real mode, defined as upper bound
+} NDIS_802_11_AUTHENTICATION_MODE, *PNDIS_802_11_AUTHENTICATION_MODE;
+
+typedef enum _NDIS_802_11_WEP_STATUS
+{
+    Ndis802_11WEPEnabled,
+    Ndis802_11Encryption1Enabled = Ndis802_11WEPEnabled,
+    Ndis802_11WEPDisabled,
+    Ndis802_11EncryptionDisabled = Ndis802_11WEPDisabled,
+    Ndis802_11WEPKeyAbsent,
+    Ndis802_11Encryption1KeyAbsent = Ndis802_11WEPKeyAbsent,
+    Ndis802_11WEPNotSupported,
+    Ndis802_11EncryptionNotSupported = Ndis802_11WEPNotSupported,
+    Ndis802_11Encryption2Enabled,
+    Ndis802_11Encryption2KeyAbsent,
+    Ndis802_11Encryption3Enabled,
+    Ndis802_11Encryption3KeyAbsent,
+    Ndis802_11_EncrypteionWAPI
+} NDIS_802_11_WEP_STATUS, *PNDIS_802_11_WEP_STATUS,
+  NDIS_802_11_ENCRYPTION_STATUS, *PNDIS_802_11_ENCRYPTION_STATUS;
+
+
+#define NDIS_802_11_AI_REQFI_CAPABILITIES      1
+#define NDIS_802_11_AI_REQFI_LISTENINTERVAL    2
+#define NDIS_802_11_AI_REQFI_CURRENTAPADDRESS  4
+
+#define NDIS_802_11_AI_RESFI_CAPABILITIES      1
+#define NDIS_802_11_AI_RESFI_STATUSCODE        2
+#define NDIS_802_11_AI_RESFI_ASSOCIATIONID     4
+
+typedef struct _NDIS_802_11_AI_REQFI
+{
+    u16 Capabilities;
+    u16 ListenInterval;
+    NDIS_802_11_MAC_ADDRESS  CurrentAPAddress;
+} NDIS_802_11_AI_REQFI, *PNDIS_802_11_AI_REQFI;
+
+typedef struct _NDIS_802_11_AI_RESFI
+{
+    u16 Capabilities;
+    u16 StatusCode;
+    u16 AssociationId;
+} NDIS_802_11_AI_RESFI, *PNDIS_802_11_AI_RESFI;
+
+typedef struct _NDIS_802_11_ASSOCIATION_INFORMATION
+{
+    u32                   Length;
+    u16                  AvailableRequestFixedIEs;
+    NDIS_802_11_AI_REQFI    RequestFixedIEs;
+    u32                   RequestIELength;
+    u32                   OffsetRequestIEs;
+    u16                  AvailableResponseFixedIEs;
+    NDIS_802_11_AI_RESFI    ResponseFixedIEs;
+    u32                   ResponseIELength;
+    u32                   OffsetResponseIEs;
+} NDIS_802_11_ASSOCIATION_INFORMATION, *PNDIS_802_11_ASSOCIATION_INFORMATION;
+
+typedef enum _NDIS_802_11_RELOAD_DEFAULTS
+{
+   Ndis802_11ReloadWEPKeys
+} NDIS_802_11_RELOAD_DEFAULTS, *PNDIS_802_11_RELOAD_DEFAULTS;
+
+
+// Key mapping keys require a BSSID
+typedef struct _NDIS_802_11_KEY
+{
+    u32           Length;             // Length of this structure
+    u32           KeyIndex;
+    u32           KeyLength;          // length of key in bytes
+    NDIS_802_11_MAC_ADDRESS BSSID;
+    NDIS_802_11_KEY_RSC KeyRSC;
+    uint8_t           KeyMaterial[32];     // variable length depending on above field
+} NDIS_802_11_KEY, *PNDIS_802_11_KEY;
+
+typedef struct _NDIS_802_11_REMOVE_KEY
+{
+    u32                   Length;        // Length of this structure
+    u32                   KeyIndex;
+    NDIS_802_11_MAC_ADDRESS BSSID;
+} NDIS_802_11_REMOVE_KEY, *PNDIS_802_11_REMOVE_KEY;
+
+typedef struct _NDIS_802_11_WEP
+{
+    u32     Length;        // Length of this structure
+    u32     KeyIndex;      // 0 is the per-client key, 1-N are the global keys
+    u32     KeyLength;     // length of key in bytes
+    uint8_t     KeyMaterial[16];// variable length depending on above field
+} NDIS_802_11_WEP, *PNDIS_802_11_WEP;
+
+typedef struct _NDIS_802_11_AUTHENTICATION_REQUEST
+{
+    u32 Length;            // Length of structure
+    NDIS_802_11_MAC_ADDRESS Bssid;
+    u32 Flags;
+} NDIS_802_11_AUTHENTICATION_REQUEST, *PNDIS_802_11_AUTHENTICATION_REQUEST;
+
+typedef enum _NDIS_802_11_STATUS_TYPE
+{
+	Ndis802_11StatusType_Authentication,
+	Ndis802_11StatusType_MediaStreamMode,
+	Ndis802_11StatusType_PMKID_CandidateList,
+	Ndis802_11StatusTypeMax    // not a real type, defined as an upper bound
+} NDIS_802_11_STATUS_TYPE, *PNDIS_802_11_STATUS_TYPE;
+
+typedef struct _NDIS_802_11_STATUS_INDICATION
+{
+    NDIS_802_11_STATUS_TYPE StatusType;
+} NDIS_802_11_STATUS_INDICATION, *PNDIS_802_11_STATUS_INDICATION;
+
+// mask for authentication/integrity fields
+#define NDIS_802_11_AUTH_REQUEST_AUTH_FIELDS        0x0f
+#define NDIS_802_11_AUTH_REQUEST_REAUTH			0x01
+#define NDIS_802_11_AUTH_REQUEST_KEYUPDATE		0x02
+#define NDIS_802_11_AUTH_REQUEST_PAIRWISE_ERROR		0x06
+#define NDIS_802_11_AUTH_REQUEST_GROUP_ERROR		0x0E
+
+// MIC check time, 60 seconds.
+#define MIC_CHECK_TIME	60000000
+
+typedef struct _NDIS_802_11_AUTHENTICATION_EVENT
+{
+    NDIS_802_11_STATUS_INDICATION       Status;
+    NDIS_802_11_AUTHENTICATION_REQUEST  Request[1];
+} NDIS_802_11_AUTHENTICATION_EVENT, *PNDIS_802_11_AUTHENTICATION_EVENT;
+
+typedef struct _NDIS_802_11_TEST
+{
+    u32 Length;
+    u32 Type;
+    union
+    {
+        NDIS_802_11_AUTHENTICATION_EVENT AuthenticationEvent;
+        NDIS_802_11_RSSI RssiTrigger;
+    }tt;
+} NDIS_802_11_TEST, *PNDIS_802_11_TEST;
+
+#ifndef Ndis802_11APMode
+#define Ndis802_11APMode (Ndis802_11InfrastructureMax+1)
+#endif
+
+typedef struct _WLAN_PHY_INFO
+{
+	uint8_t	SignalStrength;//(in percentage)
+  	uint8_t	SignalQuality;//(in percentage)
+  	uint8_t	Optimum_antenna;  //for Antenna diversity
+  	uint8_t  	Reserved_0;
+}WLAN_PHY_INFO,*PWLAN_PHY_INFO;
+
+typedef struct _WLAN_BCN_INFO
+{
+	/* these infor get from rtw_get_encrypt_info when
+	 * 	 * translate scan to UI */
+	uint8_t encryp_protocol;//ENCRYP_PROTOCOL_E: OPEN/WEP/WPA/WPA2/WAPI
+	int group_cipher; //WPA/WPA2 group cipher
+	int pairwise_cipher;////WPA/WPA2/WEP pairwise cipher
+	int is_8021x;
+
+	/* bwmode 20/40 and ch_offset UP/LOW */
+	unsigned short 	ht_cap_info;
+	unsigned char	ht_info_infos_0;
+}WLAN_BCN_INFO,*PWLAN_BCN_INFO;
+
+/* temporally add #pragma pack for structure alignment issue of
+*   WLAN_BSSID_EX and get_WLAN_BSSID_EX_sz()
+*/
+typedef struct _WLAN_BSSID_EX
+{
+  u32  Length;
+  NDIS_802_11_MAC_ADDRESS  MacAddress;
+  uint8_t  Reserved[2];//[0]: IS beacon frame
+  NDIS_802_11_SSID  Ssid;
+  u32  Privacy;
+  NDIS_802_11_RSSI  Rssi;//(in dBM,raw data ,get from PHY)
+  NDIS_802_11_NETWORK_TYPE  NetworkTypeInUse;
+  NDIS_802_11_CONFIGURATION  Configuration;
+  NDIS_802_11_NETWORK_INFRASTRUCTURE  InfrastructureMode;
+  NDIS_802_11_RATES_EX  SupportedRates;
+  WLAN_PHY_INFO	PhyInfo;
+  u32  IELength;
+  uint8_t  IEs[MAX_IE_SZ];	//(timestamp, beacon interval, and capability information)
+} __attribute__((packed))
+WLAN_BSSID_EX, *PWLAN_BSSID_EX;
+
+__inline  static uint get_WLAN_BSSID_EX_sz(WLAN_BSSID_EX *bss)
+{
+#if 0
+	uint t_len;
+
+	t_len = sizeof (u32)
+		+ sizeof (NDIS_802_11_MAC_ADDRESS)
+		+ 2
+		+ sizeof (NDIS_802_11_SSID)
+		+ sizeof (u32)
+		+ sizeof (NDIS_802_11_RSSI)
+		+ sizeof (NDIS_802_11_NETWORK_TYPE)
+		+ sizeof (NDIS_802_11_CONFIGURATION)
+		+ sizeof (NDIS_802_11_NETWORK_INFRASTRUCTURE)
+		+ sizeof (NDIS_802_11_RATES_EX)
+		//all new member add here
+		+ sizeof(WLAN_PHY_INFO)
+		//all new member add here
+		+ sizeof (u32)
+		+ bss->IELength;
+	return t_len;
+#else
+	return (sizeof(WLAN_BSSID_EX) -MAX_IE_SZ + bss->IELength);
+#endif
+}
+
+struct	wlan_network {
+	struct list_head	list;
+	int	network_type;	//refer to ieee80211.h for WIRELESS_11A/B/G
+	int	fixed;			// set to fixed when not to be removed as site-surveying
+	unsigned long	last_scanned; //timestamp for the network
+	int	aid;			//will only be valid when a BSS is joinned.
+	int	join_res;
+	WLAN_BSSID_EX	network; //must be the last item
+	WLAN_BCN_INFO	BcnInfo;
+};
+
+enum VRTL_CARRIER_SENSE
+{
+    DISABLE_VCS,
+    ENABLE_VCS,
+    AUTO_VCS
+};
+
+enum VCS_TYPE
+{
+    NONE_VCS,
+    RTS_CTS,
+    CTS_TO_SELF
+};
+
+
+
+
+#define PWR_CAM 0
+#define PWR_MINPS 1
+#define PWR_MAXPS 2
+#define PWR_UAPSD 3
+#define PWR_VOIP 4
+
+
+enum UAPSD_MAX_SP
+{
+	NO_LIMIT,
+       TWO_MSDU,
+       FOUR_MSDU,
+       SIX_MSDU
+};
+
+
+//john
+#define NUM_PRE_AUTH_KEY 16
+#define NUM_PMKID_CACHE NUM_PRE_AUTH_KEY
+
+/*
+* 	WPA2
+*/
+
+
+
+#endif //#ifndef WLAN_BSSDEF_H_
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/include/xmit_osdep.h linux-4.9.8821au/drivers/staging/rtl8821au/include/xmit_osdep.h
--- linux-4.9/drivers/staging/rtl8821au/include/xmit_osdep.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/include/xmit_osdep.h	2016-12-11 19:48:25.176978367 -0600
@@ -0,0 +1,48 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#ifndef __XMIT_OSDEP_H_
+#define __XMIT_OSDEP_H_
+
+
+
+
+
+#define NR_XMITFRAME	256
+
+struct xmit_priv;
+struct pkt_attrib;
+struct sta_xmit_priv;
+struct xmit_frame;
+struct xmit_buf;
+
+extern int rtw_xmit_entry(struct sk_buff *pkt, struct  net_device *ndev);
+
+void rtw_os_xmit_schedule(struct rtl_priv *rtlpriv);
+
+int rtw_os_xmit_resource_alloc(struct rtl_priv *rtlpriv, struct xmit_buf *pxmitbuf, u32 alloc_sz, uint8_t flag);
+void rtw_os_xmit_resource_free(struct rtl_priv *rtlpriv, struct xmit_buf *pxmitbuf, u32 free_sz, uint8_t flag);
+
+extern void rtw_set_tx_chksum_offload(struct sk_buff *pkt, struct tx_pkt_attrib *pattrib);
+
+extern void rtw_os_pkt_complete(struct rtl_priv *rtlpriv, struct sk_buff *pkt);
+extern void rtw_os_xmit_complete(struct rtl_priv *rtlpriv, struct xmit_frame *pxframe);
+
+#endif //__XMIT_OSDEP_H_
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/Kconfig linux-4.9.8821au/drivers/staging/rtl8821au/Kconfig
--- linux-4.9/drivers/staging/rtl8821au/Kconfig	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/Kconfig	2016-12-11 19:48:25.176978367 -0600
@@ -0,0 +1,6 @@
+config RTL8821AU
+	tristate "Realtek 8821 USB WiFi"
+	depends on USB
+	---help---
+	  Help message of RTL8821AU
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/Makefile linux-4.9.8821au/drivers/staging/rtl8821au/Makefile
--- linux-4.9/drivers/staging/rtl8821au/Makefile	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/Makefile	2016-12-11 19:48:25.176978367 -0600
@@ -0,0 +1,143 @@
+EXTRA_CFLAGS += -Wno-unused-label
+EXTRA_CFLAGS += -Wno-unused
+
+EXTRA_CFLAGS += -Wno-uninitialized
+
+CONFIG_RTL8821A = y
+
+# Note CONFIG_RTLWIFI_DEBUG
+# this enables *only* the compiling for this
+# to enable the output use i.e.
+# insmod rtl8821au.ko debug=5
+# see modinfo rtl8821au.ko
+
+CONFIG_RTLWIFI_DEBUG = y
+
+CONFIG_POWER_SAVING = y
+CONFIG_PLATFORM_I386_PC = y
+
+RTLWIFI_FILES :=	cam.o \
+			debug.o \
+			efuse.o \
+			usb.o
+
+RTL8821AU_FILES	:=	rtl8821au/dm.o \
+			rtl8821au/fw.o \
+			rtl8821au/hw.o \
+			rtl8821au/led.o \
+			rtl8821au/phy.o \
+			rtl8821au/rf.o \
+			rtl8821au/quirks.o \
+			rtl8821au/sw.o \
+			rtl8821au/table.o \
+			rtl8821au/trx.o
+
+OS_FILES :=		os_dep/osdep_service.o \
+			os_dep/os_intfs.o \
+			os_dep/usb_ops_linux.o \
+			os_dep/ioctl_linux.o \
+			os_dep/xmit_linux.o \
+			os_dep/mlme_linux.o \
+			os_dep/recv_linux.o \
+			os_dep/usb_halinit.o 
+
+HAL_FILES 	:=	hal/hal_intf.o \
+			hal/hal_com.o \
+			hal/odm.o \
+			hal/HalPwrSeqCmd.o \
+			hal/Hal8812PwrSeq.o \
+			hal/Hal8821APwrSeq.o\
+			hal/rtl8812a_hal_init.o \
+			hal/rtl8812a_phycfg.o \
+			hal/rtl8812a_dm.o \
+			hal/rtl8812a_cmd.o \
+			hal/rtl8812au_recv.o
+
+CORE_FILES :=		core/rtw_cmd.o \
+			core/rtw_security.o \
+			core/rtw_ioctl_set.o \
+			core/rtw_ieee80211.o \
+			core/rtw_mlme.o \
+			core/rtw_mlme_ext.o \
+			core/rtw_wlan_util.o \
+			core/rtw_vht.o \
+			core/rtw_pwrctrl.o \
+			core/rtw_rf.o \
+			core/rtw_recv.o \
+			core/rtw_sta_mgt.o \
+			core/rtw_ap.o \
+			core/rtw_xmit.o	\
+
+EXTRA_CFLAGS += -DCONFIG_RTL8821A
+EXTRA_CFLAGS += -DCONFIG_RTLWIFI_DEBUG
+
+MODULE_NAME = rtl8821au
+
+ifneq ($(RTLWIFI),y)
+$(MODULE_NAME)-y += 	$(OS_FILES) \
+			$(CORE_FILES) \
+			$(RTLWIFI_FILES) \
+			$(HAL_FILES)
+EXTRA_CFLAGS += -I$(src)/include
+else
+EXTRA_CFLAGS += -DCONFIG_RTLWIFI
+endif
+$(MODULE_NAME)-y +=	$(RTL8821AU_FILES)
+
+			
+
+########### END OF PATH  #################################
+ifeq ($(CONFIG_POWER_SAVING), y)
+EXTRA_CFLAGS += -DCONFIG_POWER_SAVING
+endif
+
+ifeq ($(CONFIG_PLATFORM_I386_PC), y)
+EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN
+SUBARCH := $(shell uname -m | sed -e s/i.86/i386/)
+ARCH ?= $(SUBARCH)
+CROSS_COMPILE ?=
+PWD  := $(shell pwd)
+KSRC := /lib/modules/$(shell uname -r)/build
+MODDESTDIR := /lib/modules/$(KVER)/kernel/drivers/net/wireless/
+INSTALL_PREFIX :=
+endif
+
+ifneq ($(KERNELRELEASE),)
+
+obj-$(CONFIG_RTL8821AU) := $(MODULE_NAME).o
+
+else
+
+export CONFIG_RTL8821AU = m
+
+all: modules
+
+modules:
+	$(MAKE) ARCH=$(ARCH) CROSS_COMPILE=$(CROSS_COMPILE) -C $(KSRC) M=$(PWD)  modules
+
+strip:
+	$(CROSS_COMPILE)strip $(MODULE_NAME).ko --strip-unneeded
+
+config_r:
+	@echo "make config"
+	/bin/bash script/Configure script/config.in
+
+installfw:
+	mkdir -p /lib/firmware/rtlwifi
+	cp -n firmware/* /lib/firmware/rtlwifi/.
+
+.PHONY: modules clean
+
+clean:
+	rm -fr */*.mod.c */*.mod */*.o */.*.cmd */*/.*.cmd */*/*/.*cmd
+	rm -f *.mod.c *.o .*.cmd *.ko
+	rm -f Module.symvers Module.markers modules.order
+	rm -fr .tmp_versions
+endif
+
+help:
+	@echo "options :"
+	@echo "modules		build this module"
+	@echo "installfw	install firmware"
+	@echo "clean		clean"
+	@echo "RTLWIFI=y	use RTLWIFI from linux kernel not complete !!"
diff -Naur linux-4.9/drivers/staging/rtl8821au/os_dep/ioctl_linux.c linux-4.9.8821au/drivers/staging/rtl8821au/os_dep/ioctl_linux.c
--- linux-4.9/drivers/staging/rtl8821au/os_dep/ioctl_linux.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/os_dep/ioctl_linux.c	2016-12-11 19:48:25.176978367 -0600
@@ -0,0 +1,3997 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#define _IOCTL_LINUX_C_
+
+#include <net/iw_handler.h>
+#include <linux/if_arp.h>
+
+#include <drv_types.h>
+#include <rtw_ap.h>
+
+#include <odm_precomp.h>
+
+#undef DBG_871X
+static inline void DBG_871X(const char *fmt, ...)
+{
+}
+
+#define _drv_always_		1
+#undef DBG_871X_LEVEL
+static inline void DBG_871X_LEVEL(const int level, const char *fmt, ...)
+{
+}
+
+#define RTL_IOCTL_WPA_SUPPLICANT	(SIOCIWFIRSTPRIV+30)
+
+#define SCAN_ITEM_SIZE 768
+#define MAX_CUSTOM_LEN 64
+#define RATE_COUNT 4
+
+/* combo scan */
+#define WEXT_CSCAN_AMOUNT 9
+#define WEXT_CSCAN_BUF_LEN		360
+#define WEXT_CSCAN_HEADER		"CSCAN S\x01\x00\x00S\x00"
+#define WEXT_CSCAN_HEADER_SIZE		12
+#define WEXT_CSCAN_SSID_SECTION		'S'
+#define WEXT_CSCAN_CHANNEL_SECTION	'C'
+#define WEXT_CSCAN_NPROBE_SECTION	'N'
+#define WEXT_CSCAN_ACTV_DWELL_SECTION	'A'
+#define WEXT_CSCAN_PASV_DWELL_SECTION	'P'
+#define WEXT_CSCAN_HOME_DWELL_SECTION	'H'
+#define WEXT_CSCAN_TYPE_SECTION		'T'
+
+
+extern uint8_t key_2char2num(uint8_t hch, uint8_t lch);
+extern uint8_t str_2char2num(uint8_t hch, uint8_t lch);
+extern uint8_t convert_ip_addr(uint8_t hch, uint8_t mch, uint8_t lch);
+
+u32 rtw_rates[] = {	1000000,
+			2000000,
+			5500000,
+			11000000,
+			6000000,
+			9000000,
+			12000000,
+			18000000,
+			24000000,
+			36000000,
+			48000000,
+			54000000};
+
+static const char * const iw_operation_mode[] = {
+	"Auto", "Ad-Hoc", "Managed",  "Master", "Repeater", "Secondary", "Monitor"
+};
+
+static int hex2num_i(char c)
+{
+	if (c >= '0' && c <= '9')
+		return c - '0';
+	if (c >= 'a' && c <= 'f')
+		return c - 'a' + 10;
+	if (c >= 'A' && c <= 'F')
+		return c - 'A' + 10;
+	return -1;
+}
+
+static int hex2byte_i(const char *hex)
+{
+	int a, b;
+	a = hex2num_i(*hex++);
+	if (a < 0)
+		return -1;
+	b = hex2num_i(*hex++);
+	if (b < 0)
+		return -1;
+	return (a << 4) | b;
+}
+
+/**
+ * hwaddr_aton - Convert ASCII string to MAC address
+ * @txt: MAC address as a string (e.g., "00:11:22:33:44:55")
+ * @addr: Buffer for the MAC address (ETH_ALEN = 6 bytes)
+ * Returns: 0 on success, -1 on failure (e.g., string not a MAC address)
+ */
+static int hwaddr_aton_i(const char *txt, uint8_t *addr)
+{
+	int i;
+
+	for (i = 0; i < 6; i++) {
+		int a, b;
+
+		a = hex2num_i(*txt++);
+		if (a < 0)
+			return -1;
+		b = hex2num_i(*txt++);
+		if (b < 0)
+			return -1;
+		*addr++ = (a << 4) | b;
+		if (i < 5 && *txt++ != ':')
+			return -1;
+	}
+
+	return 0;
+}
+
+static void indicate_wx_custom_event(struct rtl_priv *rtlpriv, char *msg)
+{
+	uint8_t *buff;
+	union iwreq_data wrqu;
+
+	if (strlen(msg) > IW_CUSTOM_MAX) {
+		DBG_871X("%s strlen(msg):%zu > IW_CUSTOM_MAX:%u\n", __FUNCTION__ , strlen(msg), IW_CUSTOM_MAX);
+		return;
+	}
+
+	buff = rtw_zmalloc(IW_CUSTOM_MAX+1);
+	if (!buff)
+		return;
+
+	memcpy(buff, msg, strlen(msg));
+
+	memset(&wrqu, 0, sizeof(wrqu));
+	wrqu.data.length = strlen(msg);
+
+	DBG_871X("%s %s\n", __FUNCTION__, buff);
+	wireless_send_event(rtlpriv->ndev, IWEVCUSTOM, &wrqu, buff);
+
+	rtw_mfree(buff);
+}
+
+
+static void request_wps_pbc_event(struct rtl_priv *rtlpriv)
+{
+	uint8_t *buff, *p;
+	union iwreq_data wrqu;
+
+
+	buff = rtw_malloc(IW_CUSTOM_MAX);
+	if (!buff)
+		return;
+
+	memset(buff, 0, IW_CUSTOM_MAX);
+
+	p = buff;
+
+	p += sprintf(p, "WPS_PBC_START.request=true");
+
+	memset(&wrqu, 0, sizeof(wrqu));
+
+	wrqu.data.length = p-buff;
+
+	wrqu.data.length = (wrqu.data.length < IW_CUSTOM_MAX) ? wrqu.data.length:IW_CUSTOM_MAX;
+
+	DBG_871X("%s\n", __FUNCTION__);
+
+	wireless_send_event(rtlpriv->ndev, IWEVCUSTOM, &wrqu, buff);
+
+	if (buff) {
+		rtw_mfree(buff);
+	}
+
+}
+
+void indicate_wx_scan_complete_event(struct rtl_priv *rtlpriv)
+{
+	union iwreq_data wrqu;
+
+	memset(&wrqu, 0, sizeof(union iwreq_data));
+
+	/* DBG_871X("+rtw_indicate_wx_scan_complete_event\n"); */
+	wireless_send_event(rtlpriv->ndev, SIOCGIWSCAN, &wrqu, NULL);
+}
+
+
+void rtw_indicate_wx_assoc_event(struct rtl_priv *rtlpriv)
+{
+	union iwreq_data wrqu;
+	struct	mlme_priv *pmlmepriv = &rtlpriv->mlmepriv;
+
+	memset(&wrqu, 0, sizeof(union iwreq_data));
+
+	wrqu.ap_addr.sa_family = ARPHRD_ETHER;
+
+	memcpy(wrqu.ap_addr.sa_data, pmlmepriv->cur_network.network.MacAddress, ETH_ALEN);
+	DBG_871X("BSSID:" MAC_FMT "\n", MAC_ARG(pmlmepriv->cur_network.network.MacAddress));
+	DBG_871X_LEVEL(_drv_always_, "assoc success\n");
+	wireless_send_event(rtlpriv->ndev, SIOCGIWAP, &wrqu, NULL);
+}
+
+void rtw_indicate_wx_disassoc_event(struct rtl_priv *rtlpriv)
+{
+	union iwreq_data wrqu;
+
+	memset(&wrqu, 0, sizeof(union iwreq_data));
+
+	wrqu.ap_addr.sa_family = ARPHRD_ETHER;
+	memset(wrqu.ap_addr.sa_data, 0, ETH_ALEN);
+
+	DBG_871X_LEVEL(_drv_always_, "indicate disassoc\n");
+	wireless_send_event(rtlpriv->ndev, SIOCGIWAP, &wrqu, NULL);
+}
+
+/*
+uint	rtw_is_cckrates_included(uint8_t *rate)
+{
+		u32	i = 0;
+
+		while(rate[i]!=0)
+		{
+			if  (  (((rate[i]) & 0x7f) == 2)	|| (((rate[i]) & 0x7f) == 4) ||
+			(((rate[i]) & 0x7f) == 11)  || (((rate[i]) & 0x7f) == 22) )
+			return true;
+			i++;
+		}
+
+		return false;
+}
+
+uint	rtw_is_cckratesonly_included(uint8_t *rate)
+{
+	u32 i = 0;
+
+	while(rate[i]!=0)
+	{
+			if  (  (((rate[i]) & 0x7f) != 2) && (((rate[i]) & 0x7f) != 4) &&
+				(((rate[i]) & 0x7f) != 11)  && (((rate[i]) & 0x7f) != 22) )
+			return false;
+			i++;
+	}
+
+	return true;
+}
+*/
+
+static char *translate_scan(struct rtl_priv *rtlpriv,
+				struct iw_request_info *info, struct wlan_network *pnetwork,
+				char *start, char *stop)
+{
+	struct iw_event iwe;
+	u16 cap;
+	u32 ht_ielen = 0, vht_ielen = 0;
+	char custom[MAX_CUSTOM_LEN];
+	char *p;
+	u16 max_rate = 0, rate, ht_cap = false, vht_cap = false;
+	u32 i = 0;
+	uint8_t bw_40MHz = 0, short_GI = 0, bw_160MHz = 0, vht_highest_rate = 0;
+	u16 mcs_rate = 0, vht_data_rate = 0;
+
+	/*  AP MAC address  */
+	iwe.cmd = SIOCGIWAP;
+	iwe.u.ap_addr.sa_family = ARPHRD_ETHER;
+
+	memcpy(iwe.u.ap_addr.sa_data, pnetwork->network.MacAddress, ETH_ALEN);
+	start = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_ADDR_LEN);
+
+	/* Add the ESSID */
+	iwe.cmd = SIOCGIWESSID;
+	iwe.u.data.flags = 1;
+	iwe.u.data.length = min((u16)pnetwork->network.Ssid.SsidLength, (u16)32);
+	start = iwe_stream_add_point(info, start, stop, &iwe, pnetwork->network.Ssid.Ssid);
+
+	/* parsing HT_CAP_IE */
+	p = rtw_get_ie(&pnetwork->network.IEs[12], _HT_CAPABILITY_IE_, &ht_ielen, pnetwork->network.IELength-12);
+
+	if (p && ht_ielen > 0) {
+		struct rtw_ieee80211_ht_cap *pht_capie;
+		ht_cap = true;
+		pht_capie = (struct rtw_ieee80211_ht_cap *)(p+2);
+		memcpy(&mcs_rate , pht_capie->supp_mcs_set, 2);
+		bw_40MHz = (pht_capie->cap_info&IEEE80211_HT_CAP_SUP_WIDTH) ? 1:0;
+		short_GI = (pht_capie->cap_info&(IEEE80211_HT_CAP_SGI_20|IEEE80211_HT_CAP_SGI_40)) ? 1:0;
+	}
+
+	/* parsing VHT_CAP_IE */
+	p = rtw_get_ie(&pnetwork->network.IEs[12], EID_VHTCapability, &vht_ielen, pnetwork->network.IELength-12);
+	if (p && vht_ielen > 0) {
+		uint8_t	mcs_map[2];
+
+		vht_cap = true;
+		bw_160MHz = GET_VHT_CAPABILITY_ELE_CHL_WIDTH(p+2);
+		if (bw_160MHz)
+			short_GI = GET_VHT_CAPABILITY_ELE_SHORT_GI160M(p+2);
+		else
+			short_GI = GET_VHT_CAPABILITY_ELE_SHORT_GI80M(p+2);
+
+		memcpy(mcs_map, GET_VHT_CAPABILITY_ELE_TX_MCS(p+2), 2);
+
+		vht_highest_rate = rtw_get_vht_highest_rate(rtlpriv, mcs_map);
+		vht_data_rate = rtw_vht_data_rate(CHANNEL_WIDTH_80, short_GI, vht_highest_rate);
+	}
+
+	/* Add the protocol name */
+	iwe.cmd = SIOCGIWNAME;
+	if ((rtw_is_cckratesonly_included((uint8_t *)&pnetwork->network.SupportedRates)) == true) {
+		if (ht_cap == true)
+			snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11bn");
+		else
+		snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11b");
+	} else if ((rtw_is_cckrates_included((uint8_t *)&pnetwork->network.SupportedRates)) == true) {
+		if (ht_cap == true)
+			snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11bgn");
+		else
+			snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11bg");
+	} else {
+		if (pnetwork->network.Configuration.DSConfig > 14) {
+			if (vht_cap == true)
+				snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11AC");
+			else if (ht_cap == true)
+				snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11an");
+			else
+				snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11a");
+		} else {
+			if (ht_cap == true)
+				snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11gn");
+			else
+				snprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11g");
+		}
+	}
+
+	start = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_CHAR_LEN);
+
+	  /* Add mode */
+	iwe.cmd = SIOCGIWMODE;
+	memcpy((uint8_t *)&cap, rtw_get_capability_from_ie(pnetwork->network.IEs), 2);
+
+
+	cap = le16_to_cpu(cap);
+
+	if (cap & (WLAN_CAPABILITY_IBSS | WLAN_CAPABILITY_BSS)) {
+		if (cap & WLAN_CAPABILITY_BSS)
+			iwe.u.mode = IW_MODE_MASTER;
+		else
+			iwe.u.mode = IW_MODE_ADHOC;
+
+		start = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_UINT_LEN);
+	}
+
+	if (pnetwork->network.Configuration.DSConfig < 1 /*|| pnetwork->network.Configuration.DSConfig>14*/)
+		pnetwork->network.Configuration.DSConfig = 1;
+
+	 /* Add frequency/channel */
+	iwe.cmd = SIOCGIWFREQ;
+	iwe.u.freq.m = rtw_ch2freq(pnetwork->network.Configuration.DSConfig) * 100000;
+	iwe.u.freq.e = 1;
+	iwe.u.freq.i = pnetwork->network.Configuration.DSConfig;
+	start = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_FREQ_LEN);
+
+	/* Add encryption capability */
+	iwe.cmd = SIOCGIWENCODE;
+	if (cap & WLAN_CAPABILITY_PRIVACY)
+		iwe.u.data.flags = IW_ENCODE_ENABLED | IW_ENCODE_NOKEY;
+	else
+		iwe.u.data.flags = IW_ENCODE_DISABLED;
+	iwe.u.data.length = 0;
+	start = iwe_stream_add_point(info, start, stop, &iwe, pnetwork->network.Ssid.Ssid);
+
+	/*Add basic and extended rates */
+	max_rate = 0;
+	p = custom;
+	p += snprintf(p, MAX_CUSTOM_LEN - (p - custom), " Rates (Mb/s): ");
+	while (pnetwork->network.SupportedRates[i] != 0) {
+		rate = pnetwork->network.SupportedRates[i] & 0x7F;
+		if (rate > max_rate)
+			max_rate = rate;
+		p += snprintf(p, MAX_CUSTOM_LEN - (p - custom),
+			      "%d%s ", rate >> 1, (rate & 1) ? ".5" : "");
+		i++;
+	}
+
+	if (vht_cap == true) {
+		max_rate = vht_data_rate;
+	} else if (ht_cap == true) {
+		if (mcs_rate&0x8000) {
+			/* MCS15 */
+			max_rate = (bw_40MHz) ? ((short_GI)?300:270):((short_GI)?144:130);
+
+		} else if (mcs_rate&0x0080) {
+			/* MCS7 */
+			max_rate = (bw_40MHz) ? ((short_GI)?150:135):((short_GI)?72:65);
+		} else {
+			/*default MCS7 */
+			/* DBG_871X("wx_get_scan, mcs_rate_bitmap=0x%x\n", mcs_rate); */
+			max_rate = (bw_40MHz) ? ((short_GI)?150:135):((short_GI)?72:65);
+		}
+
+		max_rate = max_rate*2;	/* Mbps/2; */
+	}
+
+	iwe.cmd = SIOCGIWRATE;
+	iwe.u.bitrate.fixed = iwe.u.bitrate.disabled = 0;
+	iwe.u.bitrate.value = max_rate * 500000;
+	start = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_PARAM_LEN);
+
+	/* parsing WPA/WPA2 IE */
+	{
+		uint8_t buf[MAX_WPA_IE_LEN];
+		uint8_t wpa_ie[255], rsn_ie[255];
+		u16 wpa_len = 0, rsn_len = 0;
+		uint8_t *p;
+		int out_len = 0;
+		out_len = rtw_get_sec_ie(pnetwork->network.IEs, pnetwork->network.IELength, rsn_ie, &rsn_len, wpa_ie, &wpa_len);
+
+		if (wpa_len > 0) {
+			p = buf;
+			memset(buf, 0, MAX_WPA_IE_LEN);
+			p += sprintf(p, "wpa_ie=");
+			for (i = 0; i < wpa_len; i++) {
+				p += sprintf(p, "%02x", wpa_ie[i]);
+			}
+
+			memset(&iwe, 0, sizeof(iwe));
+			iwe.cmd = IWEVCUSTOM;
+			iwe.u.data.length = strlen(buf);
+			start = iwe_stream_add_point(info, start, stop, &iwe, buf);
+
+			memset(&iwe, 0, sizeof(iwe));
+			iwe.cmd = IWEVGENIE;
+			iwe.u.data.length = wpa_len;
+			start = iwe_stream_add_point(info, start, stop, &iwe, wpa_ie);
+		}
+
+		if (rsn_len > 0) {
+			p = buf;
+			memset(buf, 0, MAX_WPA_IE_LEN);
+			p += sprintf(p, "rsn_ie=");
+			for (i = 0; i < rsn_len; i++) {
+				p += sprintf(p, "%02x", rsn_ie[i]);
+			}
+			memset(&iwe, 0, sizeof(iwe));
+			iwe.cmd = IWEVCUSTOM;
+			iwe.u.data.length = strlen(buf);
+			start = iwe_stream_add_point(info, start, stop, &iwe, buf);
+
+			memset(&iwe, 0, sizeof(iwe));
+			iwe.cmd = IWEVGENIE;
+			iwe.u.data.length = rsn_len;
+			start = iwe_stream_add_point(info, start, stop, &iwe, rsn_ie);
+		}
+	}
+
+	{	/* parsing WPS IE */
+		uint cnt = 0, total_ielen;
+		uint8_t *wpsie_ptr = NULL;
+		uint wps_ielen = 0;
+
+		uint8_t *ie_ptr = pnetwork->network.IEs + _FIXED_IE_LENGTH_;
+		total_ielen = pnetwork->network.IELength - _FIXED_IE_LENGTH_;
+
+		while (cnt < total_ielen) {
+			if (rtw_is_wps_ie(&ie_ptr[cnt], &wps_ielen) && (wps_ielen > 2)) {
+				wpsie_ptr = &ie_ptr[cnt];
+				iwe.cmd = IWEVGENIE;
+				iwe.u.data.length = (u16)wps_ielen;
+				start = iwe_stream_add_point(info, start, stop, &iwe, wpsie_ptr);
+			}
+			cnt += ie_ptr[cnt+1] + 2; /* goto next */
+		}
+	}
+
+
+	{
+		struct mlme_priv *pmlmepriv = &(rtlpriv->mlmepriv);
+		uint8_t ss, sq;
+
+		/* Add quality statistics */
+		iwe.cmd = IWEVQUAL;
+		iwe.u.qual.updated = IW_QUAL_QUAL_UPDATED | IW_QUAL_LEVEL_UPDATED | IW_QUAL_NOISE_INVALID
+		;
+
+		if (check_fwstate(pmlmepriv, _FW_LINKED) == true &&
+			is_same_network(&pmlmepriv->cur_network.network, &pnetwork->network)) {
+			ss = rtlpriv->recvpriv.signal_strength;
+			sq = rtlpriv->recvpriv.signal_qual;
+		} else {
+			ss = pnetwork->network.PhyInfo.SignalStrength;
+			sq = pnetwork->network.PhyInfo.SignalQuality;
+		}
+
+
+		iwe.u.qual.level = (uint8_t)ss;		/* % */
+
+		iwe.u.qual.qual = (uint8_t)sq;	/* signal quality */
+
+		iwe.u.qual.noise = 0;		/* noise level */
+
+		/* DBG_871X("iqual=%d, ilevel=%d, inoise=%d, iupdated=%d\n", iwe.u.qual.qual, iwe.u.qual.level , iwe.u.qual.noise, iwe.u.qual.updated); */
+
+		start = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_QUAL_LEN);
+	}
+
+	return start;
+}
+
+static int wpa_set_auth_algs(struct net_device *ndev, u32 value)
+{
+	struct rtl_priv *rtlpriv =  rtl_priv(ndev);
+	int ret = 0;
+
+	if ((value & AUTH_ALG_SHARED_KEY) && (value & AUTH_ALG_OPEN_SYSTEM)) {
+		DBG_871X("wpa_set_auth_algs, AUTH_ALG_SHARED_KEY and  AUTH_ALG_OPEN_SYSTEM [value:0x%x]\n", value);
+		rtlpriv->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;
+		rtlpriv->securitypriv.ndisauthtype = Ndis802_11AuthModeAutoSwitch;
+		rtlpriv->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_Auto;
+	} else if (value & AUTH_ALG_SHARED_KEY) {
+		DBG_871X("wpa_set_auth_algs, AUTH_ALG_SHARED_KEY  [value:0x%x]\n", value);
+		rtlpriv->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;
+
+		rtlpriv->securitypriv.ndisauthtype = Ndis802_11AuthModeShared;
+		rtlpriv->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_Shared;
+	} else if (value & AUTH_ALG_OPEN_SYSTEM) {
+		DBG_871X("wpa_set_auth_algs, AUTH_ALG_OPEN_SYSTEM\n");
+		/* rtlpriv->securitypriv.ndisencryptstatus = Ndis802_11EncryptionDisabled; */
+		if (rtlpriv->securitypriv.ndisauthtype < Ndis802_11AuthModeWPAPSK) {
+			rtlpriv->securitypriv.ndisauthtype = Ndis802_11AuthModeOpen;
+			rtlpriv->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_Open;
+		}
+
+	} else if (value & AUTH_ALG_LEAP) {
+		DBG_871X("wpa_set_auth_algs, AUTH_ALG_LEAP\n");
+	} else {
+		DBG_871X("wpa_set_auth_algs, error!\n");
+		ret = -EINVAL;
+	}
+
+	return ret;
+
+}
+
+static int wpa_set_encryption(struct net_device *ndev, struct ieee_param *param, u32 param_len)
+{
+	int ret = 0;
+	u32 wep_key_idx, wep_key_len, wep_total_len;
+	NDIS_802_11_WEP	 *pwep = NULL;
+	struct rtl_priv *rtlpriv = rtl_priv(ndev);
+	struct mlme_priv 	*pmlmepriv = &rtlpriv->mlmepriv;
+	struct security_priv *psecuritypriv = &rtlpriv->securitypriv;
+
+	param->u.crypt.err = 0;
+	param->u.crypt.alg[IEEE_CRYPT_ALG_NAME_LEN - 1] = '\0';
+
+	if (param_len < (u32) ((uint8_t *) param->u.crypt.key - (uint8_t *) param) + param->u.crypt.key_len) {
+		ret =  -EINVAL;
+		goto exit;
+	}
+
+	if (param->sta_addr[0] == 0xff && param->sta_addr[1] == 0xff &&
+	    param->sta_addr[2] == 0xff && param->sta_addr[3] == 0xff &&
+	    param->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff) {
+		if (param->u.crypt.idx >= WEP_KEYS) {
+			ret = -EINVAL;
+			goto exit;
+		}
+	} else {
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	if (strcmp(param->u.crypt.alg, "WEP") == 0) {
+		DBG_871X("wpa_set_encryption, crypt.alg = WEP\n");
+
+		rtlpriv->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;
+		rtlpriv->securitypriv.dot11PrivacyAlgrthm = WEP40_ENCRYPTION;
+		rtlpriv->securitypriv.dot118021XGrpPrivacy = WEP40_ENCRYPTION;
+
+		wep_key_idx = param->u.crypt.idx;
+		wep_key_len = param->u.crypt.key_len;
+
+		DBG_871X("(1)wep_key_idx=%d\n", wep_key_idx);
+
+		if (wep_key_idx > WEP_KEYS)
+			return -EINVAL;
+
+		if (wep_key_len > 0) {
+			wep_key_len = wep_key_len <= 5 ? 5 : 13;
+			wep_total_len = wep_key_len + FIELD_OFFSET(NDIS_802_11_WEP, KeyMaterial);
+			pwep = (NDIS_802_11_WEP	 *) rtw_malloc(wep_total_len);
+			if (pwep == NULL) {
+				goto exit;
+			}
+
+			memset(pwep, 0, wep_total_len);
+
+			pwep->KeyLength = wep_key_len;
+			pwep->Length = wep_total_len;
+
+			if (wep_key_len == 13) {
+				rtlpriv->securitypriv.dot11PrivacyAlgrthm = WEP104_ENCRYPTION;
+				rtlpriv->securitypriv.dot118021XGrpPrivacy = WEP104_ENCRYPTION;
+			}
+		} else {
+			ret = -EINVAL;
+			goto exit;
+		}
+
+		pwep->KeyIndex = wep_key_idx;
+		pwep->KeyIndex |= 0x80000000;
+
+		memcpy(pwep->KeyMaterial,  param->u.crypt.key, pwep->KeyLength);
+
+		if (param->u.crypt.set_tx) {
+			DBG_871X("wep, set_tx=1\n");
+
+			if (rtw_set_802_11_add_wep(rtlpriv, pwep) == (uint8_t)_FAIL) {
+				ret = -EOPNOTSUPP ;
+			}
+		} else {
+			DBG_871X("wep, set_tx=0\n");
+
+			/*
+			 * don't update "psecuritypriv->dot11PrivacyAlgrthm" and
+			 * "psecuritypriv->dot11PrivacyKeyIndex=keyid", but can rtw_set_key to fw/cam
+			 */
+
+			if (wep_key_idx >= WEP_KEYS) {
+				ret = -EOPNOTSUPP ;
+				goto exit;
+			}
+
+			memcpy(&(psecuritypriv->dot11DefKey[wep_key_idx].skey[0]), pwep->KeyMaterial, pwep->KeyLength);
+			psecuritypriv->dot11DefKeylen[wep_key_idx] = pwep->KeyLength;
+			rtw_set_key(rtlpriv, psecuritypriv, wep_key_idx, 0);
+		}
+
+		goto exit;
+	}
+
+	if (rtlpriv->securitypriv.dot11AuthAlgrthm == dot11AuthAlgrthm_8021X) {
+		/* 802_1x */
+		struct sta_info *psta, *pbcmc_sta;
+		struct sta_priv *pstapriv = &rtlpriv->stapriv;
+
+		if (check_fwstate(pmlmepriv, WIFI_STATION_STATE | WIFI_MP_STATE) == true) {
+			/* sta mode */
+			psta = rtw_get_stainfo(pstapriv, get_bssid(pmlmepriv));
+			if (psta == NULL) {
+				/* DEBUG_ERR( ("Set wpa_set_encryption: Obtain Sta_info fail \n")); */
+			} else 	{
+				/* Jeff: don't disable ieee8021x_blocked while clearing key */
+				if (strcmp(param->u.crypt.alg, "none") != 0)
+					psta->ieee8021x_blocked = false;
+
+				if ((rtlpriv->securitypriv.ndisencryptstatus == Ndis802_11Encryption2Enabled) ||
+						(rtlpriv->securitypriv.ndisencryptstatus ==  Ndis802_11Encryption3Enabled)) {
+					psta->dot118021XPrivacy = rtlpriv->securitypriv.dot11PrivacyAlgrthm;
+				}
+
+				if (param->u.crypt.set_tx == 1) {
+					/* pairwise key */
+					memcpy(psta->dot118021x_UncstKey.skey,  param->u.crypt.key, (param->u.crypt.key_len > 16 ? 16 : param->u.crypt.key_len));
+
+					if (strcmp(param->u.crypt.alg, "TKIP") == 0) {	/*set mic key */
+						/* DEBUG_ERR(("\nset key length :param->u.crypt.key_len=%d\n", param->u.crypt.key_len)); */
+						memcpy(psta->dot11tkiptxmickey.skey, &(param->u.crypt.key[16]), 8);
+						memcpy(psta->dot11tkiprxmickey.skey, &(param->u.crypt.key[24]), 8);
+
+						rtlpriv->securitypriv.busetkipkey = false;
+						/* _set_timer(&rtlpriv->securitypriv.tkip_timer, 50); */
+					}
+
+					/* DEBUG_ERR((" param->u.crypt.key_len=%d\n",param->u.crypt.key_len)); */
+					DBG_871X(" ~~~~set sta key:unicastkey\n");
+
+					rtw_setstakey_cmd(rtlpriv, (unsigned char *)psta, true);
+				} else {
+					/* group key */
+					memcpy(rtlpriv->securitypriv.dot118021XGrpKey[param->u.crypt.idx].skey,  param->u.crypt.key, (param->u.crypt.key_len > 16 ? 16 : param->u.crypt.key_len));
+					memcpy(rtlpriv->securitypriv.dot118021XGrptxmickey[param->u.crypt.idx].skey, &(param->u.crypt.key[16]), 8);
+					memcpy(rtlpriv->securitypriv.dot118021XGrprxmickey[param->u.crypt.idx].skey, &(param->u.crypt.key[24]), 8);
+					rtlpriv->securitypriv.binstallGrpkey = true;
+					/* DEBUG_ERR((" param->u.crypt.key_len=%d\n", param->u.crypt.key_len)); */
+					DBG_871X(" ~~~~set sta key:groupkey\n");
+
+					rtlpriv->securitypriv.dot118021XGrpKeyid = param->u.crypt.idx;
+
+					rtw_set_key(rtlpriv, &rtlpriv->securitypriv, param->u.crypt.idx, 1);
+
+				}
+			}
+
+			pbcmc_sta = rtw_get_bcmc_stainfo(rtlpriv);
+			if (pbcmc_sta == NULL) 	{
+				/* DEBUG_ERR( ("Set OID_802_11_ADD_KEY: bcmc stainfo is null \n")); */
+			} else {
+				/* Jeff: don't disable ieee8021x_blocked while clearing key */
+				if (strcmp(param->u.crypt.alg, "none") != 0)
+					pbcmc_sta->ieee8021x_blocked = false;
+
+				if ((rtlpriv->securitypriv.ndisencryptstatus == Ndis802_11Encryption2Enabled) ||
+						(rtlpriv->securitypriv.ndisencryptstatus ==  Ndis802_11Encryption3Enabled)) {
+					pbcmc_sta->dot118021XPrivacy = rtlpriv->securitypriv.dot11PrivacyAlgrthm;
+				}
+			}
+		} else if (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)) {
+			/* adhoc mode */
+		}
+	}
+
+
+exit:
+
+	if (pwep) {
+		rtw_mfree(pwep);
+	}
+
+
+
+	return ret;
+}
+
+static int rtw_set_wpa_ie(struct rtl_priv *rtlpriv, char *pie, unsigned short ielen)
+{
+	uint8_t *buf = NULL, *pos = NULL;
+	int group_cipher = 0, pairwise_cipher = 0;
+	int ret = 0;
+	uint8_t null_addr[] = {0, 0, 0, 0, 0, 0};
+
+	if ((ielen > MAX_WPA_IE_LEN) || (pie == NULL)) {
+		_clr_fwstate_(&rtlpriv->mlmepriv, WIFI_UNDER_WPS);
+		if (pie == NULL)
+			return ret;
+		else
+			return -EINVAL;
+	}
+
+	if (ielen) {
+		buf = rtw_zmalloc(ielen);
+		if (buf == NULL) {
+			ret =  -ENOMEM;
+			goto exit;
+		}
+
+		memcpy(buf, pie , ielen);
+
+		/* dump */
+		{
+			int i;
+			DBG_871X("\n wpa_ie(length:%d):\n", ielen);
+			for (i = 0; i < ielen; i = i + 8)
+				DBG_871X("0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x \n", buf[i], buf[i+1], buf[i+2], buf[i+3], buf[i+4], buf[i+5], buf[i+6], buf[i+7]);
+		}
+
+		pos = buf;
+		if (ielen < RSN_HEADER_LEN) {
+			ret  = -1;
+			goto exit;
+		}
+
+		if (rtw_parse_wpa_ie(buf, ielen, &group_cipher, &pairwise_cipher, NULL) == _SUCCESS) {
+			rtlpriv->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_8021X;
+			rtlpriv->securitypriv.ndisauthtype = Ndis802_11AuthModeWPAPSK;
+			memcpy(rtlpriv->securitypriv.supplicant_ie, &buf[0], ielen);
+		}
+
+		if (rtw_parse_wpa2_ie(buf, ielen, &group_cipher, &pairwise_cipher, NULL) == _SUCCESS) {
+			rtlpriv->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_8021X;
+			rtlpriv->securitypriv.ndisauthtype = Ndis802_11AuthModeWPA2PSK;
+			memcpy(rtlpriv->securitypriv.supplicant_ie, &buf[0], ielen);
+		}
+
+		if (group_cipher == 0) {
+			group_cipher = WPA_CIPHER_NONE;
+		}
+
+		if (pairwise_cipher == 0) {
+			pairwise_cipher = WPA_CIPHER_NONE;
+		}
+
+		switch (group_cipher) {
+		case WPA_CIPHER_NONE:
+			rtlpriv->securitypriv.dot118021XGrpPrivacy = NO_ENCRYPTION;
+			rtlpriv->securitypriv.ndisencryptstatus = Ndis802_11EncryptionDisabled;
+			break;
+		case WPA_CIPHER_WEP40:
+			rtlpriv->securitypriv.dot118021XGrpPrivacy = WEP40_ENCRYPTION;
+			rtlpriv->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;
+			break;
+		case WPA_CIPHER_TKIP:
+			rtlpriv->securitypriv.dot118021XGrpPrivacy = TKIP_ENCRYPTION;
+			rtlpriv->securitypriv.ndisencryptstatus = Ndis802_11Encryption2Enabled;
+			break;
+		case WPA_CIPHER_CCMP:
+			rtlpriv->securitypriv.dot118021XGrpPrivacy = AESCCMP_ENCRYPTION;
+			rtlpriv->securitypriv.ndisencryptstatus = Ndis802_11Encryption3Enabled;
+			break;
+		case WPA_CIPHER_WEP104:
+			rtlpriv->securitypriv.dot118021XGrpPrivacy = WEP104_ENCRYPTION;
+			rtlpriv->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;
+			break;
+		}
+
+		switch (pairwise_cipher) {
+		case WPA_CIPHER_NONE:
+			rtlpriv->securitypriv.dot11PrivacyAlgrthm = NO_ENCRYPTION;
+			rtlpriv->securitypriv.ndisencryptstatus = Ndis802_11EncryptionDisabled;
+			break;
+		case WPA_CIPHER_WEP40:
+			rtlpriv->securitypriv.dot11PrivacyAlgrthm = WEP40_ENCRYPTION;
+			rtlpriv->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;
+			break;
+		case WPA_CIPHER_TKIP:
+			rtlpriv->securitypriv.dot11PrivacyAlgrthm = TKIP_ENCRYPTION;
+			rtlpriv->securitypriv.ndisencryptstatus = Ndis802_11Encryption2Enabled;
+			break;
+		case WPA_CIPHER_CCMP:
+			rtlpriv->securitypriv.dot11PrivacyAlgrthm = AESCCMP_ENCRYPTION;
+			rtlpriv->securitypriv.ndisencryptstatus = Ndis802_11Encryption3Enabled;
+			break;
+		case WPA_CIPHER_WEP104:
+			rtlpriv->securitypriv.dot11PrivacyAlgrthm = WEP104_ENCRYPTION;
+			rtlpriv->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;
+			break;
+		}
+
+		_clr_fwstate_(&rtlpriv->mlmepriv, WIFI_UNDER_WPS);
+		{
+			/* set wps_ie */
+			u16 cnt = 0;
+			uint8_t eid, wps_oui[4] = { 0x0, 0x50, 0xf2, 0x04};
+
+			while (cnt < ielen) {
+				eid = buf[cnt];
+
+				if ((eid == _VENDOR_SPECIFIC_IE_) &&
+				    (_rtw_memcmp(&buf[cnt+2], wps_oui, 4) == true)) {
+					DBG_871X("SET WPS_IE\n");
+
+					rtlpriv->securitypriv.wps_ie_len = ((buf[cnt+1]+2) < (MAX_WPA_IE_LEN << 2)) ? (buf[cnt+1] + 2) : (MAX_WPA_IE_LEN << 2);
+					memcpy(rtlpriv->securitypriv.wps_ie, &buf[cnt], rtlpriv->securitypriv.wps_ie_len);
+					set_fwstate(&rtlpriv->mlmepriv, WIFI_UNDER_WPS);
+
+					cnt += buf[cnt+1]+2;
+
+					break;
+				} else {
+					cnt += buf[cnt+1]+2; /* goto next */
+				}
+			}
+		}
+	}
+
+	/* TKIP and AES disallow multicast packets until installing group key */
+	if (rtlpriv->securitypriv.dot11PrivacyAlgrthm == TKIP_ENCRYPTION ||
+	    rtlpriv->securitypriv.dot11PrivacyAlgrthm == RSERVED_ENCRYPTION ||
+	    rtlpriv->securitypriv.dot11PrivacyAlgrthm == AESCCMP_ENCRYPTION)
+		/*
+		 * WPS open need to enable multicast
+		 * || check_fwstate(&rtlpriv->mlmepriv, WIFI_UNDER_WPS) == true)
+		 */
+		rtlpriv->cfg->ops->set_hw_reg(rtlpriv, HW_VAR_OFF_RCR_AM, null_addr);
+
+exit:
+	if (buf)
+		rtw_mfree(buf);
+
+	return ret;
+}
+
+static int rtw_wx_get_name(struct net_device *ndev,
+			     struct iw_request_info *info,
+			     union iwreq_data *wrqu, char *extra)
+{
+	struct rtl_priv *rtlpriv = rtl_priv(ndev);
+	u32 ht_ielen = 0;
+	char *p;
+	uint8_t ht_cap = false, vht_cap = false;
+	struct	mlme_priv	*pmlmepriv = &(rtlpriv->mlmepriv);
+	WLAN_BSSID_EX  *pcur_bss = &pmlmepriv->cur_network.network;
+	NDIS_802_11_RATES_EX *prates = NULL;
+
+	if (check_fwstate(pmlmepriv, _FW_LINKED|WIFI_ADHOC_MASTER_STATE) == true) {
+		/* parsing HT_CAP_IE */
+		p = rtw_get_ie(&pcur_bss->IEs[12], _HT_CAPABILITY_IE_, &ht_ielen, pcur_bss->IELength-12);
+		if (p && ht_ielen > 0) {
+			ht_cap = true;
+		}
+
+		if (pmlmepriv->vhtpriv.vht_option == true)
+			vht_cap = true;
+
+		prates = &pcur_bss->SupportedRates;
+
+		if (rtw_is_cckratesonly_included((uint8_t *)prates) == true) 	{
+			if (ht_cap == true)
+				snprintf(wrqu->name, IFNAMSIZ, "IEEE 802.11bn");
+			else
+				snprintf(wrqu->name, IFNAMSIZ, "IEEE 802.11b");
+		} else if ((rtw_is_cckrates_included((uint8_t *)prates)) == true) {
+			if (ht_cap == true)
+				snprintf(wrqu->name, IFNAMSIZ, "IEEE 802.11bgn");
+			else
+				snprintf(wrqu->name, IFNAMSIZ, "IEEE 802.11bg");
+		} else 	{
+			if (pcur_bss->Configuration.DSConfig > 14) {
+				if (vht_cap == true)
+					snprintf(wrqu->name, IFNAMSIZ, "IEEE 802.11AC");
+				else if (ht_cap == true)
+					snprintf(wrqu->name, IFNAMSIZ, "IEEE 802.11an");
+				else
+					snprintf(wrqu->name, IFNAMSIZ, "IEEE 802.11a");
+			} else {
+				if (ht_cap == true)
+					snprintf(wrqu->name, IFNAMSIZ, "IEEE 802.11gn");
+				else
+					snprintf(wrqu->name, IFNAMSIZ, "IEEE 802.11g");
+			}
+		}
+	} else {
+		/*
+		 * prates = &rtlpriv->registrypriv.dev_network.SupportedRates;
+		 * snprintf(wrqu->name, IFNAMSIZ, "IEEE 802.11g");
+		 */
+		snprintf(wrqu->name, IFNAMSIZ, "unassociated");
+	}
+
+	return 0;
+}
+
+static int rtw_wx_set_freq(struct net_device *ndev,
+			     struct iw_request_info *info,
+			     union iwreq_data *wrqu, char *extra)
+{
+	return 0;
+}
+
+static int rtw_wx_get_freq(struct net_device *ndev,
+			     struct iw_request_info *info,
+			     union iwreq_data *wrqu, char *extra)
+{
+	struct rtl_priv *rtlpriv = rtl_priv(ndev);
+	struct	mlme_priv	*pmlmepriv = &(rtlpriv->mlmepriv);
+	WLAN_BSSID_EX  *pcur_bss = &pmlmepriv->cur_network.network;
+
+	if (check_fwstate(pmlmepriv, _FW_LINKED) == true) {
+		/* wrqu->freq.m = ieee80211_wlan_frequencies[pcur_bss->Configuration.DSConfig-1] * 100000; */
+		wrqu->freq.m = rtw_ch2freq(pcur_bss->Configuration.DSConfig) * 100000;
+		wrqu->freq.e = 1;
+		wrqu->freq.i = pcur_bss->Configuration.DSConfig;
+
+	} else {
+		wrqu->freq.m = rtw_ch2freq(rtlpriv->mlmeextpriv.cur_channel) * 100000;
+		wrqu->freq.e = 1;
+		wrqu->freq.i = rtlpriv->mlmeextpriv.cur_channel;
+	}
+
+	return 0;
+}
+
+static int rtw_wx_set_mode(struct net_device *ndev, struct iw_request_info *a,
+			     union iwreq_data *wrqu, char *b)
+{
+	struct rtl_priv *rtlpriv = rtl_priv(ndev);
+	NDIS_802_11_NETWORK_INFRASTRUCTURE networkType ;
+	int ret = 0;
+
+	if (_FAIL == rtw_pwr_wakeup(rtlpriv)) {
+		ret = -EPERM;
+		goto exit;
+	}
+
+	if (rtlpriv->hw_init_completed == false) {
+		ret = -EPERM;
+		goto exit;
+	}
+
+	switch (wrqu->mode) {
+	case IW_MODE_AUTO:
+		networkType = Ndis802_11AutoUnknown;
+		DBG_871X("set_mode = IW_MODE_AUTO\n");
+		break;
+	case IW_MODE_ADHOC:
+		networkType = Ndis802_11IBSS;
+		DBG_871X("set_mode = IW_MODE_ADHOC\n");
+		break;
+	case IW_MODE_MASTER:
+		networkType = Ndis802_11APMode;
+		DBG_871X("set_mode = IW_MODE_MASTER\n");
+		/* rtw_setopmode_cmd(rtlpriv, networkType); */
+		break;
+	case IW_MODE_INFRA:
+		networkType = Ndis802_11Infrastructure;
+		DBG_871X("set_mode = IW_MODE_INFRA\n");
+		break;
+
+	default:
+		ret = -EINVAL;;
+		goto exit;
+	}
+
+/*
+	if (Ndis802_11APMode == networkType)
+	{
+		rtw_setopmode_cmd(rtlpriv, networkType);
+	}
+	else
+	{
+		rtw_setopmode_cmd(rtlpriv, Ndis802_11AutoUnknown);
+	}
+*/
+
+	if (rtw_set_802_11_infrastructure_mode(rtlpriv, networkType) == false) {
+		ret = -EPERM;
+		goto exit;
+
+	}
+
+	rtw_setopmode_cmd(rtlpriv, networkType);
+
+exit:
+
+	return ret;
+
+}
+
+static int rtw_wx_get_mode(struct net_device *ndev, struct iw_request_info *a,
+			     union iwreq_data *wrqu, char *b)
+{
+	struct rtl_priv *rtlpriv = rtl_priv(ndev);
+	struct	mlme_priv	*pmlmepriv = &(rtlpriv->mlmepriv);
+
+	if (check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true) {
+		wrqu->mode = IW_MODE_INFRA;
+	} else
+		if ((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true) ||
+		    (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true)) {
+			wrqu->mode = IW_MODE_ADHOC;
+	} else if (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true) {
+		wrqu->mode = IW_MODE_MASTER;
+	} else {
+		wrqu->mode = IW_MODE_AUTO;
+	}
+
+	return 0;
+
+}
+
+
+static int rtw_wx_set_pmkid(struct net_device *ndev, struct iw_request_info *a,
+			     union iwreq_data *wrqu, char *extra)
+{
+	struct rtl_priv *rtlpriv = rtl_priv(ndev);
+	uint8_t j, blInserted = false;
+	int intReturn = false;
+	struct security_priv *psecuritypriv = &rtlpriv->securitypriv;
+	struct iw_pmksa *pPMK = (struct iw_pmksa *) extra;
+	uint8_t strZeroMacAddress[ETH_ALEN] = { 0x00 };
+	uint8_t strIssueBssid[ETH_ALEN] = { 0x00 };
+
+	memcpy(strIssueBssid, pPMK->bssid.sa_data, ETH_ALEN);
+	if (pPMK->cmd == IW_PMKSA_ADD) {
+		DBG_871X("[rtw_wx_set_pmkid] IW_PMKSA_ADD!\n");
+		if (_rtw_memcmp(strIssueBssid, strZeroMacAddress, ETH_ALEN) == true) {
+			return intReturn;
+		} else {
+			intReturn = true;
+		}
+		blInserted = false;
+
+		/* overwrite PMKID */
+		for (j = 0 ; j < NUM_PMKID_CACHE; j++) {
+			if (_rtw_memcmp(psecuritypriv->PMKIDList[j].Bssid, strIssueBssid, ETH_ALEN) == true) {
+				/* BSSID is matched, the same AP => rewrite with new PMKID. */
+
+				DBG_871X("[rtw_wx_set_pmkid] BSSID exists in the PMKList.\n");
+
+				memcpy(psecuritypriv->PMKIDList[j].PMKID, pPMK->pmkid, IW_PMKID_LEN);
+				psecuritypriv->PMKIDList[j].bUsed = true;
+				psecuritypriv->PMKIDIndex = j + 1;
+				blInserted = true;
+				break;
+			}
+		}
+
+		if (!blInserted) {
+			/* Find a new entry */
+			DBG_871X("[rtw_wx_set_pmkid] Use the new entry index = %d for this PMKID.\n",
+				psecuritypriv->PMKIDIndex);
+
+			memcpy(psecuritypriv->PMKIDList[psecuritypriv->PMKIDIndex].Bssid, strIssueBssid, ETH_ALEN);
+			memcpy(psecuritypriv->PMKIDList[psecuritypriv->PMKIDIndex].PMKID, pPMK->pmkid, IW_PMKID_LEN);
+
+			psecuritypriv->PMKIDList[psecuritypriv->PMKIDIndex].bUsed = true;
+			psecuritypriv->PMKIDIndex++ ;
+			if (psecuritypriv->PMKIDIndex == 16) {
+				psecuritypriv->PMKIDIndex = 0;
+			}
+		}
+	} else
+		if (pPMK->cmd == IW_PMKSA_REMOVE) {
+			DBG_871X("[rtw_wx_set_pmkid] IW_PMKSA_REMOVE!\n");
+			intReturn = true;
+			for (j = 0 ; j < NUM_PMKID_CACHE; j++) {
+				if (_rtw_memcmp(psecuritypriv->PMKIDList[j].Bssid, strIssueBssid, ETH_ALEN) == true) {
+					/*  BSSID is matched, the same AP => Remove this PMKID information and reset it. */
+					memset(psecuritypriv->PMKIDList[j].Bssid, 0x00, ETH_ALEN);
+					psecuritypriv->PMKIDList[j].bUsed = false;
+					break;
+				}
+		}
+	} else
+		if (pPMK->cmd == IW_PMKSA_FLUSH) {
+			DBG_871X("[rtw_wx_set_pmkid] IW_PMKSA_FLUSH!\n");
+			memset(&psecuritypriv->PMKIDList[0], 0x00, sizeof(RT_PMKID_LIST) * NUM_PMKID_CACHE);
+			psecuritypriv->PMKIDIndex = 0;
+			intReturn = true;
+		}
+
+	return intReturn;
+}
+
+static int rtw_wx_get_sens(struct net_device *ndev, struct iw_request_info *info,
+				union iwreq_data *wrqu, char *extra)
+{
+	{
+		wrqu->sens.value = 0;
+		wrqu->sens.fixed = 0;	/* no auto select */
+		wrqu->sens.disabled = 1;
+	}
+	return 0;
+}
+
+static int rtw_wx_get_range(struct net_device *ndev,
+				struct iw_request_info *info,
+				union iwreq_data *wrqu, char *extra)
+{
+	struct iw_range *range = (struct iw_range *)extra;
+	struct rtl_priv *rtlpriv = rtl_priv(ndev);
+	struct mlme_ext_priv	*pmlmeext = &rtlpriv->mlmeextpriv;
+
+	u16 val;
+	int i;
+
+	wrqu->data.length = sizeof(*range);
+	memset(range, 0, sizeof(*range));
+
+	/* Let's try to keep this struct in the same order as in
+	 * linux/include/wireless.h
+	 */
+
+	/* TODO: See what values we can set, and remove the ones we can't
+	 * set, or fill them with some default data.
+	 */
+
+	/* ~5 Mb/s real (802.11b) */
+	range->throughput = 5 * 1000 * 1000;
+
+	/*  TODO: Not used in 802.11b? */
+	/* Minimal NWID we are able to set */
+	/*	range->min_nwid; */
+
+	/* TODO: Not used in 802.11b? */
+	/* Maximal NWID we are able to set */
+	/* range->max_nwid; */
+
+	/* Old Frequency (backward compat - moved lower ) */
+	/* range->old_num_channels; */
+	/*range->old_num_frequency; */
+
+	/* Filler to keep "version" at the same offset */
+	/* range->old_freq[6]; */
+
+	/* signal level threshold range */
+
+	/* percent values between 0 and 100. */
+	range->max_qual.qual = 100;
+	range->max_qual.level = 100;
+	range->max_qual.noise = 100;
+	range->max_qual.updated = 7; /* Updated all three */
+
+
+	range->avg_qual.qual = 92; /* > 8% missed beacons is 'bad' */
+	/* TODO: Find real 'good' to 'bad' threshol value for RSSI */
+	range->avg_qual.level = 20 + -98;
+	range->avg_qual.noise = 0;
+	range->avg_qual.updated = 7; /* Updated all three */
+
+	range->num_bitrates = RATE_COUNT;
+
+	for (i = 0; i < RATE_COUNT && i < IW_MAX_BITRATES; i++) {
+		range->bitrate[i] = rtw_rates[i];
+	}
+
+	range->min_frag = MIN_FRAG_THRESHOLD;
+	range->max_frag = MAX_FRAG_THRESHOLD;
+
+	range->pm_capa = 0;
+
+	range->we_version_compiled = WIRELESS_EXT;
+	range->we_version_source = 16;
+
+	for (i = 0, val = 0; i < MAX_CHANNEL_NUM; i++) {
+		/* Include only legal frequencies for some countries */
+		if (pmlmeext->channel_set[i].ChannelNum != 0) {
+			range->freq[val].i = pmlmeext->channel_set[i].ChannelNum;
+			range->freq[val].m = rtw_ch2freq(pmlmeext->channel_set[i].ChannelNum) * 100000;
+			range->freq[val].e = 1;
+			val++;
+		}
+
+		if (val == IW_MAX_FREQUENCIES)
+			break;
+	}
+
+	range->num_channels = val;
+	range->num_frequency = val;
+
+/*
+ * Commented by Albert 2009/10/13
+ * The following code will proivde the security capability to network manager.
+ * If the driver doesn't provide this capability to network manager,
+ * the WPA/WPA2 routers can't be choosen in the network manager.
+ */
+
+/*
+#define IW_SCAN_CAPA_NONE		0x00
+#define IW_SCAN_CAPA_ESSID		0x01
+#define IW_SCAN_CAPA_BSSID		0x02
+#define IW_SCAN_CAPA_CHANNEL	0x04
+#define IW_SCAN_CAPA_MODE		0x08
+#define IW_SCAN_CAPA_RATE		0x10
+#define IW_SCAN_CAPA_TYPE		0x20
+#define IW_SCAN_CAPA_TIME		0x40
+*/
+
+#if WIRELESS_EXT > 17
+	range->enc_capa = IW_ENC_CAPA_WPA|IW_ENC_CAPA_WPA2|
+			  IW_ENC_CAPA_CIPHER_TKIP|IW_ENC_CAPA_CIPHER_CCMP;
+#endif
+
+#ifdef IW_SCAN_CAPA_ESSID /* WIRELESS_EXT > 21 */
+	range->scan_capa = IW_SCAN_CAPA_ESSID | IW_SCAN_CAPA_TYPE | IW_SCAN_CAPA_BSSID |
+					IW_SCAN_CAPA_CHANNEL | IW_SCAN_CAPA_MODE | IW_SCAN_CAPA_RATE;
+#endif
+
+	return 0;
+
+}
+
+/*
+ * set bssid flow
+ * s1. rtw_set_802_11_infrastructure_mode()
+ * s2. rtw_set_802_11_authentication_mode()
+ * s3. set_802_11_encryption_mode()
+ * s4. rtw_set_802_11_bssid()
+*/
+static int rtw_wx_set_wap(struct net_device *ndev,
+			 struct iw_request_info *info,
+			 union iwreq_data *awrq,
+			 char *extra)
+{
+	uint ret = 0;
+	struct rtl_priv *rtlpriv = rtl_priv(ndev);
+	struct sockaddr *temp = (struct sockaddr *) awrq;
+	struct	mlme_priv	*pmlmepriv = &(rtlpriv->mlmepriv);
+	struct list_head	*phead;
+	uint8_t *dst_bssid, *src_bssid;
+	struct __queue	*queue	= &(pmlmepriv->scanned_queue);
+	struct	wlan_network	*pnetwork = NULL;
+	NDIS_802_11_AUTHENTICATION_MODE	authmode;
+
+	if (_FAIL == rtw_pwr_wakeup(rtlpriv)) {
+		ret = -1;
+		goto exit;
+	}
+
+	if (!rtlpriv->initialized) {
+		ret = -1;
+		goto exit;
+	}
+
+
+	if (temp->sa_family != ARPHRD_ETHER) {
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	authmode = rtlpriv->securitypriv.ndisauthtype;
+	spin_lock_bh(&queue->lock);
+	phead = get_list_head(queue);
+	pmlmepriv->pscanned = phead->next;
+
+	while (1) {
+		if ((rtw_end_of_queue_search(phead, pmlmepriv->pscanned)) == true) {
+			break;
+		}
+
+		pnetwork = container_of(pmlmepriv->pscanned, struct wlan_network, list);
+
+		pmlmepriv->pscanned = pmlmepriv->pscanned->next;
+
+		dst_bssid = pnetwork->network.MacAddress;
+
+		src_bssid = temp->sa_data;
+
+		if ((_rtw_memcmp(dst_bssid, src_bssid, ETH_ALEN)) == true) {
+			if (!rtw_set_802_11_infrastructure_mode(rtlpriv, pnetwork->network.InfrastructureMode)) {
+				ret = -1;
+				spin_unlock_bh(&queue->lock);
+				goto exit;
+			}
+			break;
+		}
+
+	}
+	spin_unlock_bh(&queue->lock);
+
+	rtw_set_802_11_authentication_mode(rtlpriv, authmode);
+	/* set_802_11_encryption_mode(rtlpriv, rtlpriv->securitypriv.ndisencryptstatus); */
+	if (rtw_set_802_11_bssid(rtlpriv, temp->sa_data) == false) {
+		ret = -1;
+		goto exit;
+	}
+
+exit:
+
+	return ret;
+}
+
+static int rtw_wx_get_wap(struct net_device *ndev,
+			    struct iw_request_info *info,
+			    union iwreq_data *wrqu, char *extra)
+{
+
+	struct rtl_priv *rtlpriv = rtl_priv(ndev);
+	struct	mlme_priv	*pmlmepriv = &(rtlpriv->mlmepriv);
+	WLAN_BSSID_EX  *pcur_bss = &pmlmepriv->cur_network.network;
+
+	wrqu->ap_addr.sa_family = ARPHRD_ETHER;
+
+	memset(wrqu->ap_addr.sa_data, 0, ETH_ALEN);
+
+
+
+	if  (((check_fwstate(pmlmepriv, _FW_LINKED)) == true) ||
+	     ((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)) == true) ||
+	     ((check_fwstate(pmlmepriv, WIFI_AP_STATE)) == true)) {
+		memcpy(wrqu->ap_addr.sa_data, pcur_bss->MacAddress, ETH_ALEN);
+	} else {
+		memset(wrqu->ap_addr.sa_data, 0, ETH_ALEN);
+	}
+
+	return 0;
+
+}
+
+static int rtw_wx_set_mlme(struct net_device *ndev,
+			     struct iw_request_info *info,
+			     union iwreq_data *wrqu, char *extra)
+{
+
+	int ret = 0;
+	u16 reason;
+	struct rtl_priv *rtlpriv = rtl_priv(ndev);
+	struct iw_mlme *mlme = (struct iw_mlme *) extra;
+
+
+	if (mlme == NULL)
+		return -1;
+
+	DBG_871X("%s\n", __FUNCTION__);
+
+	reason = cpu_to_le16(mlme->reason_code);
+
+	DBG_871X("%s, cmd=%d, reason=%d\n", __FUNCTION__, mlme->cmd, reason);
+
+	switch (mlme->cmd) {
+	case IW_MLME_DEAUTH:
+			if (!rtw_set_802_11_disassociate(rtlpriv))
+			ret = -1;
+			break;
+
+	case IW_MLME_DISASSOC:
+			if (!rtw_set_802_11_disassociate(rtlpriv))
+					ret = -1;
+
+			break;
+
+	default:
+		return -EOPNOTSUPP;
+	}
+
+	return ret;
+}
+
+static int rtw_wx_set_scan(struct net_device *ndev, struct iw_request_info *a,
+			     union iwreq_data *wrqu, char *extra)
+{
+	uint8_t _status = false;
+	int ret = 0;
+	struct rtl_priv *rtlpriv = rtl_priv(ndev);
+	struct mlme_priv *pmlmepriv = &rtlpriv->mlmepriv;
+	NDIS_802_11_SSID ssid[RTW_SSID_SCAN_AMOUNT];
+
+	if (_FAIL == rtw_pwr_wakeup(rtlpriv)) {
+		ret = -1;
+		goto exit;
+	}
+
+	if (rtlpriv->bDriverStopped) {
+		DBG_871X("bDriverStopped=%d\n", rtlpriv->bDriverStopped);
+		ret = -1;
+		goto exit;
+		}
+
+	if (!rtlpriv->initialized) {
+		ret = -1;
+		goto exit;
+	}
+
+	if (rtlpriv->hw_init_completed == false) {
+		ret = -1;
+		goto exit;
+	}
+
+	/*
+	 * When Busy Traffic, driver do not site survey. So driver return success.
+	 * wpa_supplicant will not issue SIOCSIWSCAN cmd again after scan timeout.
+	 * modify by thomas 2011-02-22.
+	 */
+	if (pmlmepriv->LinkDetectInfo.bBusyTraffic == true) {
+		indicate_wx_scan_complete_event(rtlpriv);
+		goto exit;
+	}
+
+	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY|_FW_UNDER_LINKING) == true) {
+		indicate_wx_scan_complete_event(rtlpriv);
+		goto exit;
+	}
+
+	/*
+	 * Mareded by Albert 20101103
+	 * For the DMP WiFi Display project, the driver won't to scan because
+	 * the pmlmepriv->scan_interval is always equal to 3.
+	 * So, the wpa_supplicant won't find out the WPS SoftAP.
+	 */
+
+/*
+	if (pmlmepriv->scan_interval>10)
+		pmlmepriv->scan_interval = 0;
+
+	if (pmlmepriv->scan_interval > 0)
+	{
+		DBG_871X("scan done\n");
+		ret = 0;
+		goto exit;
+	}
+
+*/
+
+	memset(ssid, 0, sizeof(NDIS_802_11_SSID)*RTW_SSID_SCAN_AMOUNT);
+
+#if WIRELESS_EXT >= 17
+	if (wrqu->data.length == sizeof(struct iw_scan_req)) {
+		struct iw_scan_req *req = (struct iw_scan_req *)extra;
+
+		if (wrqu->data.flags & IW_SCAN_THIS_ESSID) {
+			int len = min((int)req->essid_len, IW_ESSID_MAX_SIZE);
+
+			memcpy(ssid[0].Ssid, req->essid, len);
+			ssid[0].SsidLength = len;
+
+			DBG_871X("IW_SCAN_THIS_ESSID, ssid=%s, len=%d\n", req->essid, req->essid_len);
+
+			spin_lock_bh(&pmlmepriv->lock);
+
+			_status = rtw_sitesurvey_cmd(rtlpriv, ssid, 1, NULL, 0);
+
+			spin_unlock_bh(&pmlmepriv->lock);
+
+		} else if (req->scan_type == IW_SCAN_TYPE_PASSIVE) {
+			DBG_871X("rtw_wx_set_scan, req->scan_type == IW_SCAN_TYPE_PASSIVE\n");
+		}
+
+	} else
+#endif
+
+		if (wrqu->data.length >= WEXT_CSCAN_HEADER_SIZE &&
+		    _rtw_memcmp(extra, WEXT_CSCAN_HEADER, WEXT_CSCAN_HEADER_SIZE) == true) {
+			int len = wrqu->data.length - WEXT_CSCAN_HEADER_SIZE;
+			char *pos = extra+WEXT_CSCAN_HEADER_SIZE;
+			char section;
+			char sec_len;
+			int ssid_index = 0;
+
+			/* DBG_871X("%s COMBO_SCAN header is recognized\n", __FUNCTION__); */
+
+			while (len >= 1) {
+				section = *(pos++);
+				len -= 1;
+
+				switch (section) {
+				case WEXT_CSCAN_SSID_SECTION:
+					/* DBG_871X("WEXT_CSCAN_SSID_SECTION\n"); */
+					if (len < 1) {
+						len = 0;
+						break;
+					}
+
+					sec_len = *(pos++);
+					len -= 1;
+
+					if (sec_len > 0 && sec_len <= len) {
+						ssid[ssid_index].SsidLength = sec_len;
+						memcpy(ssid[ssid_index].Ssid, pos, ssid[ssid_index].SsidLength);
+						/*
+						 * DBG_871X("%s COMBO_SCAN with specific ssid:%s, %d\n", __FUNCTION__
+						 * 	, ssid[ssid_index].Ssid, ssid[ssid_index].SsidLength);
+						 */
+						ssid_index++;
+					}
+
+					pos += sec_len;
+					len -= sec_len;
+					break;
+
+
+				case WEXT_CSCAN_CHANNEL_SECTION:
+					/* DBG_871X("WEXT_CSCAN_CHANNEL_SECTION\n"); */
+					pos += 1;
+					len -= 1;
+					break;
+				case WEXT_CSCAN_ACTV_DWELL_SECTION:
+					/* DBG_871X("WEXT_CSCAN_ACTV_DWELL_SECTION\n"); */
+					pos += 2;
+					len -= 2;
+					break;
+				case WEXT_CSCAN_PASV_DWELL_SECTION:
+					/* DBG_871X("WEXT_CSCAN_PASV_DWELL_SECTION\n"); */
+					pos += 2;
+					len -= 2;
+					break;
+				case WEXT_CSCAN_HOME_DWELL_SECTION:
+					/* DBG_871X("WEXT_CSCAN_HOME_DWELL_SECTION\n"); */
+					pos += 2;
+					len -= 2;
+					break;
+				case WEXT_CSCAN_TYPE_SECTION:
+					/* DBG_871X("WEXT_CSCAN_TYPE_SECTION\n"); */
+					pos += 1;
+					len -= 1;
+					break;
+
+				default:
+					/* DBG_871X("Unknown CSCAN section %c\n", section); */
+					len = 0; 	/* stop parsing */
+				}
+			/* DBG_871X("len:%d\n", len); */
+
+			}
+
+			/* jeff: it has still some scan paramater to parse, we only do this now... */
+			_status = rtw_set_802_11_bssid_list_scan(rtlpriv, ssid, RTW_SSID_SCAN_AMOUNT);
+
+		} else {
+			_status = rtw_set_802_11_bssid_list_scan(rtlpriv, NULL, 0);
+		}
+
+	if (_status == false)
+		ret = -1;
+
+exit:
+
+	return ret;
+}
+
+static int rtw_wx_get_scan(struct net_device *ndev, struct iw_request_info *a,
+			     union iwreq_data *wrqu, char *extra)
+{
+	struct list_head					*plist, *phead;
+	struct rtl_priv *rtlpriv = rtl_priv(ndev);
+	struct	mlme_priv	*pmlmepriv = &(rtlpriv->mlmepriv);
+	struct __queue				*queue	= &(pmlmepriv->scanned_queue);
+	struct	wlan_network	*pnetwork = NULL;
+	char *ev = extra;
+	char *stop = ev + wrqu->data.length;
+	u32 ret = 0;
+	u32 cnt = 0;
+	u32 wait_for_surveydone;
+	int wait_status;
+
+	if (rtlpriv->pwrctrlpriv.brfoffbyhw && rtlpriv->bDriverStopped) {
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	wait_for_surveydone = 100;
+
+
+	wait_status = _FW_UNDER_SURVEY | _FW_UNDER_LINKING;
+
+	while (check_fwstate(pmlmepriv, wait_status) == true) {
+		msleep(30);
+		cnt++;
+		if (cnt > wait_for_surveydone)
+			break;
+	}
+
+	spin_lock_bh(&(pmlmepriv->scanned_queue.lock));
+
+	phead = get_list_head(queue);
+	plist = phead->next;
+
+	while (1) {
+		if (rtw_end_of_queue_search(phead,plist) == true)
+			break;
+
+		if ((stop - ev) < SCAN_ITEM_SIZE) {
+			ret = -E2BIG;
+			break;
+		}
+
+		pnetwork = container_of(plist, struct wlan_network, list);
+
+		/* report network only if the current channel set contains the channel to which this network belongs */
+		if (rtw_ch_set_search_ch(rtlpriv->mlmeextpriv.channel_set, pnetwork->network.Configuration.DSConfig) >= 0
+#ifdef CONFIG_VALIDATE_SSID
+			&& true == rtw_validate_ssid(&(pnetwork->network.Ssid))
+#endif
+		)
+		{
+			ev = translate_scan(rtlpriv, a, pnetwork, ev, stop);
+		}
+
+		plist = plist->next;
+
+	}
+
+	spin_unlock_bh(&(pmlmepriv->scanned_queue.lock));
+
+	wrqu->data.length = ev-extra;
+	wrqu->data.flags = 0;
+
+exit:
+
+	return ret ;
+}
+
+/*
+ * set ssid flow
+ * s1. rtw_set_802_11_infrastructure_mode()
+ * s2. set_802_11_authenticaion_mode()
+ * s3. set_802_11_encryption_mode()
+ * s4. rtw_set_802_11_ssid()
+ */
+static int rtw_wx_set_essid(struct net_device *ndev,
+			      struct iw_request_info *a,
+			      union iwreq_data *wrqu, char *extra)
+{
+	struct rtl_priv *rtlpriv = rtl_priv(ndev);
+	struct mlme_priv *pmlmepriv = &rtlpriv->mlmepriv;
+	struct __queue *queue = &pmlmepriv->scanned_queue;
+	struct list_head *phead;
+	struct wlan_network *pnetwork = NULL;
+	NDIS_802_11_AUTHENTICATION_MODE authmode;
+	NDIS_802_11_SSID ndis_ssid;
+	uint8_t *dst_ssid, *src_ssid;
+
+	uint ret = 0, len;
+
+	if (_FAIL == rtw_pwr_wakeup(rtlpriv)) {
+		ret = -1;
+		goto exit;
+	}
+
+	if (!rtlpriv->initialized) {
+		ret = -1;
+		goto exit;
+	}
+
+#if WIRELESS_EXT <= 20
+	if ((wrqu->essid.length-1) > IW_ESSID_MAX_SIZE) {
+#else
+	if (wrqu->essid.length > IW_ESSID_MAX_SIZE) {
+#endif
+		ret = -E2BIG;
+		goto exit;
+	}
+
+	if (check_fwstate(pmlmepriv, WIFI_AP_STATE)) {
+		ret = -1;
+		goto exit;
+	}
+
+	authmode = rtlpriv->securitypriv.ndisauthtype;
+	DBG_871X("=>%s\n", __FUNCTION__);
+	if (wrqu->essid.flags && wrqu->essid.length) {
+		/*
+		 * Commented by Albert 20100519
+		 * We got the codes in "set_info" function of iwconfig source code.
+		 * 	=========================================
+		 * 	wrq.u.essid.length = strlen(essid) + 1;
+		 * 	if (we_kernel_version > 20)
+		 * 		wrq.u.essid.length--;
+		 * 	=========================================
+		 * 	That means, if the WIRELESS_EXT less than or equal to 20, the correct ssid len should subtract 1.
+		 */
+#if WIRELESS_EXT <= 20
+		len = ((wrqu->essid.length-1) < IW_ESSID_MAX_SIZE) ? (wrqu->essid.length-1) : IW_ESSID_MAX_SIZE;
+#else
+		len = (wrqu->essid.length < IW_ESSID_MAX_SIZE) ? wrqu->essid.length : IW_ESSID_MAX_SIZE;
+#endif
+
+		if (wrqu->essid.length != 33)
+			DBG_871X("ssid=%s, len=%d\n", extra, wrqu->essid.length);
+
+		memset(&ndis_ssid, 0, sizeof(NDIS_802_11_SSID));
+		ndis_ssid.SsidLength = len;
+		memcpy(ndis_ssid.Ssid, extra, len);
+		src_ssid = ndis_ssid.Ssid;
+
+		spin_lock_bh(&queue->lock);
+		phead = get_list_head(queue);
+		pmlmepriv->pscanned = phead->next;
+
+		while (1) {
+			if (rtw_end_of_queue_search(phead, pmlmepriv->pscanned) == true) {
+
+				break;
+			}
+
+			pnetwork = container_of(pmlmepriv->pscanned, struct wlan_network, list);
+
+			pmlmepriv->pscanned = pmlmepriv->pscanned->next;
+
+			dst_ssid = pnetwork->network.Ssid.Ssid;
+
+			if ((_rtw_memcmp(dst_ssid, src_ssid, ndis_ssid.SsidLength) == true) &&
+			    (pnetwork->network.Ssid.SsidLength == ndis_ssid.SsidLength)) {
+
+				if (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true) {
+					if (pnetwork->network.InfrastructureMode != pmlmepriv->cur_network.network.InfrastructureMode)
+						continue;
+				}
+
+				if (rtw_set_802_11_infrastructure_mode(rtlpriv, pnetwork->network.InfrastructureMode) == false) {
+					ret = -1;
+					spin_unlock_bh(&queue->lock);
+					goto exit;
+				}
+
+				break;
+			}
+		}
+		spin_unlock_bh(&queue->lock);
+		rtw_set_802_11_authentication_mode(rtlpriv, authmode);
+		/* set_802_11_encryption_mode(rtlpriv, rtlpriv->securitypriv.ndisencryptstatus); */
+		if (rtw_set_802_11_ssid(rtlpriv, &ndis_ssid) == false) {
+			ret = -1;
+			goto exit;
+		}
+	}
+
+exit:
+
+	DBG_871X("<=%s, ret %d\n", __FUNCTION__, ret);
+
+	return ret;
+}
+
+static int rtw_wx_get_essid(struct net_device *ndev,
+			      struct iw_request_info *a,
+			      union iwreq_data *wrqu, char *extra)
+{
+	u32 len, ret = 0;
+	struct rtl_priv *rtlpriv = rtl_priv(ndev);
+	struct	mlme_priv	*pmlmepriv = &(rtlpriv->mlmepriv);
+	WLAN_BSSID_EX  *pcur_bss = &pmlmepriv->cur_network.network;
+
+	if ((check_fwstate(pmlmepriv, _FW_LINKED) == true) ||
+	   (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true)) {
+		len = pcur_bss->Ssid.SsidLength;
+
+		wrqu->essid.length = len;
+
+		memcpy(extra, pcur_bss->Ssid.Ssid, len);
+
+		wrqu->essid.flags = 1;
+	} else {
+		ret = -1;
+		goto exit;
+	}
+
+exit:
+
+	return ret;
+
+}
+
+static int rtw_wx_get_rate(struct net_device *ndev,
+			     struct iw_request_info *info,
+			     union iwreq_data *wrqu, char *extra)
+{
+	u16 max_rate = 0;
+
+	max_rate = rtw_get_cur_max_rate(rtl_priv(ndev));
+
+	if (max_rate == 0)
+		return -EPERM;
+
+	wrqu->bitrate.fixed = 0;	/* no auto select */
+	wrqu->bitrate.value = max_rate * 100000;
+
+	return 0;
+}
+
+static int rtw_wx_set_rts(struct net_device *ndev,
+			     struct iw_request_info *info,
+			     union iwreq_data *wrqu, char *extra)
+{
+	struct rtl_priv *rtlpriv = rtl_priv(ndev);
+
+	if (wrqu->rts.disabled)
+		rtlpriv->registrypriv.rts_thresh = 2347;
+	else {
+		if (wrqu->rts.value < 0 ||
+		    wrqu->rts.value > 2347)
+			return -EINVAL;
+
+		rtlpriv->registrypriv.rts_thresh = wrqu->rts.value;
+	}
+
+	DBG_871X("%s, rts_thresh=%d\n", __func__, rtlpriv->registrypriv.rts_thresh);
+
+	return 0;
+
+}
+
+static int rtw_wx_get_rts(struct net_device *ndev,
+			     struct iw_request_info *info,
+			     union iwreq_data *wrqu, char *extra)
+{
+	struct rtl_priv *rtlpriv = rtl_priv(ndev);
+
+	DBG_871X("%s, rts_thresh=%d\n", __func__, rtlpriv->registrypriv.rts_thresh);
+
+	wrqu->rts.value = rtlpriv->registrypriv.rts_thresh;
+	wrqu->rts.fixed = 0;	/* no auto select */
+	/* wrqu->rts.disabled = (wrqu->rts.value == DEFAULT_RTS_THRESHOLD); */
+
+	return 0;
+}
+
+static int rtw_wx_set_frag(struct net_device *ndev,
+			     struct iw_request_info *info,
+			     union iwreq_data *wrqu, char *extra)
+{
+	struct rtl_priv *rtlpriv = rtl_priv(ndev);
+
+	if (wrqu->frag.disabled)
+		rtlpriv->xmitpriv.frag_len = MAX_FRAG_THRESHOLD;
+	else {
+		if (wrqu->frag.value < MIN_FRAG_THRESHOLD ||
+		    wrqu->frag.value > MAX_FRAG_THRESHOLD)
+			return -EINVAL;
+
+		rtlpriv->xmitpriv.frag_len = wrqu->frag.value & ~0x1;
+	}
+
+	DBG_871X("%s, frag_len=%d\n", __func__, rtlpriv->xmitpriv.frag_len);
+
+	return 0;
+
+}
+
+static int rtw_wx_get_frag(struct net_device *ndev,
+			     struct iw_request_info *info,
+			     union iwreq_data *wrqu, char *extra)
+{
+	struct rtl_priv *rtlpriv = rtl_priv(ndev);
+
+	DBG_871X("%s, frag_len=%d\n", __func__, rtlpriv->xmitpriv.frag_len);
+
+	wrqu->frag.value = rtlpriv->xmitpriv.frag_len;
+	wrqu->frag.fixed = 0;	/* no auto select */
+	/* wrqu->frag.disabled = (wrqu->frag.value == DEFAULT_FRAG_THRESHOLD); */
+
+	return 0;
+}
+
+static int rtw_wx_get_retry(struct net_device *ndev,
+			     struct iw_request_info *info,
+			     union iwreq_data *wrqu, char *extra)
+{
+	/* struct rtl_priv *rtlpriv = rtl_priv(ndev); */
+
+
+	wrqu->retry.value = 7;
+	wrqu->retry.fixed = 0;	/* no auto select */
+	wrqu->retry.disabled = 1;
+
+	return 0;
+
+}
+
+
+static int rtw_wx_set_enc(struct net_device *ndev,
+			    struct iw_request_info *info,
+			    union iwreq_data *wrqu, char *keybuf)
+{
+	u32 key, ret = 0;
+	u32 keyindex_provided;
+	NDIS_802_11_WEP	 wep;
+	NDIS_802_11_AUTHENTICATION_MODE authmode;
+
+	struct iw_point *erq = &(wrqu->encoding);
+	struct rtl_priv *rtlpriv = rtl_priv(ndev);
+	struct pwrctrl_priv *pwrpriv = &rtlpriv->pwrctrlpriv;
+	DBG_871X("+rtw_wx_set_enc, flags=0x%x\n", erq->flags);
+
+	memset(&wep, 0, sizeof(NDIS_802_11_WEP));
+
+	key = erq->flags & IW_ENCODE_INDEX;
+
+	if (erq->flags & IW_ENCODE_DISABLED) {
+		DBG_871X("EncryptionDisabled\n");
+		rtlpriv->securitypriv.ndisencryptstatus = Ndis802_11EncryptionDisabled;
+		rtlpriv->securitypriv.dot11PrivacyAlgrthm = NO_ENCRYPTION;
+		rtlpriv->securitypriv.dot118021XGrpPrivacy = NO_ENCRYPTION;
+		rtlpriv->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_Open; /* open system */
+		authmode = Ndis802_11AuthModeOpen;
+		rtlpriv->securitypriv.ndisauthtype = authmode;
+
+		goto exit;
+	}
+
+	if (key) {
+		if (key > WEP_KEYS)
+			return -EINVAL;
+		key--;
+		keyindex_provided = 1;
+	} else {
+		keyindex_provided = 0;
+		key = rtlpriv->securitypriv.dot11PrivacyKeyIndex;
+		DBG_871X("rtw_wx_set_enc, key=%d\n", key);
+	}
+
+	/* set authentication mode */
+	if (erq->flags & IW_ENCODE_OPEN) {
+		DBG_871X("rtw_wx_set_enc():IW_ENCODE_OPEN\n");
+		rtlpriv->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;/* Ndis802_11EncryptionDisabled; */
+
+		rtlpriv->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_Open;
+
+		rtlpriv->securitypriv.dot11PrivacyAlgrthm = NO_ENCRYPTION;
+		rtlpriv->securitypriv.dot118021XGrpPrivacy = NO_ENCRYPTION;
+		authmode = Ndis802_11AuthModeOpen;
+		rtlpriv->securitypriv.ndisauthtype = authmode;
+	} else if (erq->flags & IW_ENCODE_RESTRICTED) {
+		DBG_871X("rtw_wx_set_enc():IW_ENCODE_RESTRICTED\n");
+		rtlpriv->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;
+
+		rtlpriv->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_Shared;
+
+		rtlpriv->securitypriv.dot11PrivacyAlgrthm = WEP40_ENCRYPTION;
+		rtlpriv->securitypriv.dot118021XGrpPrivacy = WEP40_ENCRYPTION;
+		authmode = Ndis802_11AuthModeShared;
+		rtlpriv->securitypriv.ndisauthtype = authmode;
+	} else {
+		DBG_871X("rtw_wx_set_enc():erq->flags=0x%x\n", erq->flags);
+
+		rtlpriv->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;/* Ndis802_11EncryptionDisabled; */
+		rtlpriv->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_Open; /* open system */
+		rtlpriv->securitypriv.dot11PrivacyAlgrthm = NO_ENCRYPTION;
+		rtlpriv->securitypriv.dot118021XGrpPrivacy = NO_ENCRYPTION;
+		authmode = Ndis802_11AuthModeOpen;
+		rtlpriv->securitypriv.ndisauthtype = authmode;
+	}
+
+	wep.KeyIndex = key;
+	if (erq->length > 0) {
+		wep.KeyLength = erq->length <= 5 ? 5 : 13;
+
+		wep.Length = wep.KeyLength + FIELD_OFFSET(NDIS_802_11_WEP, KeyMaterial);
+	} else {
+		wep.KeyLength = 0 ;
+
+		if (keyindex_provided == 1) {
+			/* set key_id only, no given KeyMaterial(erq->length==0). */
+
+			rtlpriv->securitypriv.dot11PrivacyKeyIndex = key;
+
+			DBG_871X("(keyindex_provided == 1), keyid=%d, key_len=%d\n", key, rtlpriv->securitypriv.dot11DefKeylen[key]);
+
+			switch (rtlpriv->securitypriv.dot11DefKeylen[key]) {
+			case 5:
+				rtlpriv->securitypriv.dot11PrivacyAlgrthm = WEP40_ENCRYPTION;
+				break;
+			case 13:
+				rtlpriv->securitypriv.dot11PrivacyAlgrthm = WEP104_ENCRYPTION;
+				break;
+			default:
+				rtlpriv->securitypriv.dot11PrivacyAlgrthm = NO_ENCRYPTION;
+				break;
+			}
+
+			goto exit;
+
+		}
+
+	}
+
+	wep.KeyIndex |= 0x80000000;
+
+	memcpy(wep.KeyMaterial, keybuf, wep.KeyLength);
+
+	if (rtw_set_802_11_add_wep(rtlpriv, &wep) == false) {
+		if (ERFON == pwrpriv->rf_pwrstate)
+			ret = -EOPNOTSUPP;
+		goto exit;
+	}
+
+exit:
+
+
+
+	return ret;
+
+}
+
+static int rtw_wx_get_enc(struct net_device *ndev,
+			    struct iw_request_info *info,
+			    union iwreq_data *wrqu, char *keybuf)
+{
+	uint key, ret = 0;
+	struct rtl_priv *rtlpriv = rtl_priv(ndev);
+	struct iw_point *erq = &(wrqu->encoding);
+	struct	mlme_priv	*pmlmepriv = &(rtlpriv->mlmepriv);
+
+	if (check_fwstate(pmlmepriv, _FW_LINKED) != true) {
+		if (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) != true)  {
+			erq->length = 0;
+			erq->flags |= IW_ENCODE_DISABLED;
+			return 0;
+		}
+	}
+
+
+	key = erq->flags & IW_ENCODE_INDEX;
+
+	if (key) {
+		if (key > WEP_KEYS)
+			return -EINVAL;
+		key--;
+	} else {
+		key = rtlpriv->securitypriv.dot11PrivacyKeyIndex;
+	}
+
+	erq->flags = key + 1;
+
+	/*
+	 * if (rtlpriv->securitypriv.ndisauthtype == Ndis802_11AuthModeOpen) {
+	 *    	erq->flags |= IW_ENCODE_OPEN;
+	 * }
+	 */
+
+	switch (rtlpriv->securitypriv.ndisencryptstatus) {
+	case Ndis802_11EncryptionNotSupported:
+	case Ndis802_11EncryptionDisabled:
+		erq->length = 0;
+		erq->flags |= IW_ENCODE_DISABLED;
+
+		break;
+
+	case Ndis802_11Encryption1Enabled:
+		erq->length = rtlpriv->securitypriv.dot11DefKeylen[key];
+
+		if (erq->length) {
+			memcpy(keybuf, rtlpriv->securitypriv.dot11DefKey[key].skey, rtlpriv->securitypriv.dot11DefKeylen[key]);
+
+		erq->flags |= IW_ENCODE_ENABLED;
+
+			if (rtlpriv->securitypriv.ndisauthtype == Ndis802_11AuthModeOpen) {
+				erq->flags |= IW_ENCODE_OPEN;
+			} else if (rtlpriv->securitypriv.ndisauthtype == Ndis802_11AuthModeShared) {
+				erq->flags |= IW_ENCODE_RESTRICTED;
+			}
+		} else 	{
+			erq->length = 0;
+			erq->flags |= IW_ENCODE_DISABLED;
+		}
+
+		break;
+
+	case Ndis802_11Encryption2Enabled:
+	case Ndis802_11Encryption3Enabled:
+		erq->length = 16;
+		erq->flags |= (IW_ENCODE_ENABLED | IW_ENCODE_OPEN | IW_ENCODE_NOKEY);
+
+		break;
+
+	default:
+		erq->length = 0;
+		erq->flags |= IW_ENCODE_DISABLED;
+
+		break;
+
+	}
+
+	return ret;
+
+}
+
+static int rtw_wx_get_power(struct net_device *ndev,
+			     struct iw_request_info *info,
+			     union iwreq_data *wrqu, char *extra)
+{
+	/* struct rtl_priv *rtlpriv = rtl_priv(ndev); */
+
+	wrqu->power.value = 0;
+	wrqu->power.fixed = 0;	/* no auto select */
+	wrqu->power.disabled = 1;
+
+	return 0;
+
+}
+
+static int rtw_wx_set_gen_ie(struct net_device *ndev,
+			     struct iw_request_info *info,
+			     union iwreq_data *wrqu, char *extra)
+{
+	int ret;
+	struct rtl_priv *rtlpriv = rtl_priv(ndev);
+
+	ret = rtw_set_wpa_ie(rtlpriv, extra, wrqu->data.length);
+
+	return ret;
+}
+
+static int rtw_wx_set_auth(struct net_device *ndev,
+			     struct iw_request_info *info,
+			     union iwreq_data *wrqu, char *extra)
+{
+	struct rtl_priv *rtlpriv = rtl_priv(ndev);
+	struct iw_param *param = (struct iw_param *) &(wrqu->param);
+	int ret = 0;
+
+	switch (param->flags & IW_AUTH_INDEX) {
+	case IW_AUTH_WPA_VERSION:
+		break;
+	case IW_AUTH_CIPHER_PAIRWISE:
+
+		break;
+	case IW_AUTH_CIPHER_GROUP:
+
+		break;
+	case IW_AUTH_KEY_MGMT:
+		/*
+		 *  ??? does not use these parameters
+		 */
+		break;
+
+	case IW_AUTH_TKIP_COUNTERMEASURES:
+		{
+			if (param->value) {
+				/* wpa_supplicant is enabling the tkip countermeasure. */
+				rtlpriv->securitypriv.btkip_countermeasure = true;
+			} else {
+				/* wpa_supplicant is disabling the tkip countermeasure. */
+				rtlpriv->securitypriv.btkip_countermeasure = false;
+			}
+			break;
+		}
+	case IW_AUTH_DROP_UNENCRYPTED:
+		{
+			/* HACK:
+			 *
+			 * wpa_supplicant calls set_wpa_enabled when the driver
+			 * is loaded and unloaded, regardless of if WPA is being
+			 * used.  No other calls are made which can be used to
+			 * determine if encryption will be used or not prior to
+			 * association being expected.  If encryption is not being
+			 * used, drop_unencrypted is set to false, else true -- we
+			 * can use this to determine if the CAP_PRIVACY_ON bit should
+			 * be set.
+			 */
+
+			if (rtlpriv->securitypriv.ndisencryptstatus == Ndis802_11Encryption1Enabled) {
+				break;	/* it means init value, or using wep, ndisencrypttatus = Ndis802_11Encryption1Enabled, */
+					/* then it needn't reset it; */
+			}
+
+			if (param->value) {
+				rtlpriv->securitypriv.ndisencryptstatus = Ndis802_11EncryptionDisabled;
+				rtlpriv->securitypriv.dot11PrivacyAlgrthm = NO_ENCRYPTION;
+				rtlpriv->securitypriv.dot118021XGrpPrivacy = NO_ENCRYPTION;
+				rtlpriv->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_Open; /* open system */
+				rtlpriv->securitypriv.ndisauthtype = Ndis802_11AuthModeOpen;
+			}
+			break;
+		}
+
+	case IW_AUTH_80211_AUTH_ALG:
+
+		/*
+		 *  It's the starting point of a link layer connection using wpa_supplicant
+		*/
+		if (check_fwstate(&rtlpriv->mlmepriv, _FW_LINKED)) {
+			LeaveAllPowerSaveMode(rtlpriv);
+			rtw_disassoc_cmd(rtlpriv, 500, false);
+			DBG_871X("%s...call rtw_indicate_disconnect\n ", __FUNCTION__);
+			rtw_indicate_disconnect(rtlpriv);
+			rtw_free_assoc_resources(rtlpriv, 1);
+		}
+
+
+		ret = wpa_set_auth_algs(ndev, (u32)param->value);
+
+		break;
+
+	case IW_AUTH_WPA_ENABLED:
+
+		/*
+		 * if (param->value)
+		 * 	rtlpriv->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_8021X; //802.1x
+		 * else
+		 * 	rtlpriv->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_Open;//open system
+		 *
+		 * _disassociate(priv);
+		 */
+
+		break;
+
+	case IW_AUTH_RX_UNENCRYPTED_EAPOL:
+		/* ieee->ieee802_1x = param->value; */
+		break;
+
+	case IW_AUTH_PRIVACY_INVOKED:
+		/* ieee->privacy_invoked = param->value; */
+		break;
+	default:
+		return -EOPNOTSUPP;
+
+	}
+
+	return ret;
+
+}
+
+static int rtw_wx_set_enc_ext(struct net_device *ndev,
+			     struct iw_request_info *info,
+			     union iwreq_data *wrqu, char *extra)
+{
+	char *alg_name;
+	u32 param_len;
+	struct ieee_param *param = NULL;
+	struct iw_point *pencoding = &wrqu->encoding;
+	struct iw_encode_ext *pext = (struct iw_encode_ext *) extra;
+	int ret = 0;
+
+	param_len = sizeof(struct ieee_param) + pext->key_len;
+	param = (struct ieee_param *)rtw_malloc(param_len);
+	if (param == NULL)
+		return -1;
+
+	memset(param, 0, param_len);
+
+	param->cmd = IEEE_CMD_SET_ENCRYPTION;
+	memset(param->sta_addr, 0xff, ETH_ALEN);
+
+
+	switch (pext->alg) {
+	case IW_ENCODE_ALG_NONE:
+		/*
+		 * todo: remove key
+		 * remove = 1;
+		 */
+		alg_name = "none";
+		break;
+	case IW_ENCODE_ALG_WEP:
+		alg_name = "WEP";
+		break;
+	case IW_ENCODE_ALG_TKIP:
+		alg_name = "TKIP";
+		break;
+	case IW_ENCODE_ALG_CCMP:
+		alg_name = "CCMP";
+		break;
+	default:
+		return -1;
+	}
+
+	strncpy((char *)param->u.crypt.alg, alg_name, IEEE_CRYPT_ALG_NAME_LEN);
+
+	if (pext->ext_flags & IW_ENCODE_EXT_SET_TX_KEY) {
+		param->u.crypt.set_tx = 1;
+	}
+
+	/* cliW: WEP does not have group key
+	 * just not checking GROUP key setting
+	 */
+	if ((pext->alg != IW_ENCODE_ALG_WEP) &&
+		(pext->ext_flags & IW_ENCODE_EXT_GROUP_KEY)) {
+		param->u.crypt.set_tx = 0;
+	}
+
+	param->u.crypt.idx = (pencoding->flags&0x00FF) - 1;
+
+	if (pext->ext_flags & IW_ENCODE_EXT_RX_SEQ_VALID) {
+		memcpy(param->u.crypt.seq, pext->rx_seq, 8);
+	}
+
+	if (pext->key_len) {
+		param->u.crypt.key_len = pext->key_len;
+		/* memcpy(param + 1, pext + 1, pext->key_len); */
+		memcpy(param->u.crypt.key, pext + 1, pext->key_len);
+	}
+
+	if (pencoding->flags & IW_ENCODE_DISABLED) {
+		/*
+		 * todo: remove key
+		 * remove = 1;
+		 */
+	}
+
+	ret =  wpa_set_encryption(ndev, param, param_len);
+
+	if (param) {
+		rtw_mfree(param);
+	}
+
+	return ret;
+}
+
+
+static int rtw_wx_get_nick(struct net_device *ndev,
+			     struct iw_request_info *info,
+			     union iwreq_data *wrqu, char *extra)
+{
+	/* struct rtl_priv *rtlpriv = rtl_priv(ndev); */
+	/* struct mlme_priv *pmlmepriv = &(rtlpriv->mlmepriv); */
+	/* struct security_priv *psecuritypriv = &rtlpriv->securitypriv; */
+
+	if (extra) {
+		wrqu->data.length = 14;
+		wrqu->data.flags = 1;
+		memcpy(extra, "<WIFI@REALTEK>", 14);
+	}
+
+
+	/* dump debug info here */
+
+	/*
+	 * DBG_871X("auth_alg=0x%x, enc_alg=0x%x, auth_type=0x%x, enc_type=0x%x\n",
+	 * 		psecuritypriv->dot11AuthAlgrthm, psecuritypriv->dot11PrivacyAlgrthm,
+	 * 		psecuritypriv->ndisauthtype, psecuritypriv->ndisencryptstatus);
+	 */
+
+	/*
+	 * DBG_871X("enc_alg=0x%x\n", psecuritypriv->dot11PrivacyAlgrthm);
+	 * DBG_871X("auth_type=0x%x\n", psecuritypriv->ndisauthtype);
+	 * DBG_871X("enc_type=0x%x\n", psecuritypriv->ndisencryptstatus);
+	 */
+
+
+	return 0;
+
+}
+
+static int rtw_wx_priv_null(struct net_device *ndev, struct iw_request_info *a,
+		 union iwreq_data *wrqu, char *b)
+{
+	return -1;
+}
+
+static int dummy(struct net_device *ndev, struct iw_request_info *a,
+		 union iwreq_data *wrqu, char *b)
+{
+	/* struct rtl_priv *rtlpriv = rtl_priv(ndev); */
+	/* struct mlme_priv *pmlmepriv = &(rtlpriv->mlmepriv); */
+
+	/* DBG_871X("cmd_code=%x, fwstate=0x%x\n", a->cmd, get_fwstate(pmlmepriv)); */
+
+	return -1;
+
+}
+
+
+
+
+static int rtw_cta_test_start(struct net_device *ndev,
+							   struct iw_request_info *info,
+							   union iwreq_data *wrqu, char *extra)
+{
+	int ret = 0;
+	struct rtl_priv	*rtlpriv = rtl_priv(ndev);
+
+	DBG_871X("%s %s\n", __func__, extra);
+
+	if (!strcmp(extra, "1"))
+		rtlpriv->in_cta_test = 1;
+	else
+		rtlpriv->in_cta_test = 0;
+
+	if (rtlpriv->in_cta_test) {
+		u32 v = rtl_read_dword(rtlpriv, REG_RCR);
+		v &= ~(RCR_CBSSID_DATA | RCR_CBSSID_BCN);	/* | RCR_ADF */
+		rtl_write_dword(rtlpriv, REG_RCR, v);
+		DBG_871X("enable RCR_ADF\n");
+	} else {
+		u32 v = rtl_read_dword(rtlpriv, REG_RCR);
+		v |= RCR_CBSSID_DATA | RCR_CBSSID_BCN ;		/* | RCR_ADF */
+		rtl_write_dword(rtlpriv, REG_RCR, v);
+		DBG_871X("disable RCR_ADF\n");
+	}
+	return ret;
+}
+
+
+void mac_reg_dump(struct rtl_priv *rtlpriv)
+{
+	int i, j = 1;
+	printk("\n======= MAC REG =======\n");
+	for (i = 0x0; i < 0x300; i += 4) {
+		if (j % 4 == 1)
+			printk("0x%02x", i);
+		printk(" 0x%08x ", rtl_read_dword(rtlpriv, i));
+		if ((j++) % 4 == 0)
+			printk("\n");
+	}
+	for (i = 0x400; i < 0x800; i += 4) {
+		if (j % 4 == 1)
+			printk("0x%02x", i);
+		printk(" 0x%08x ", rtl_read_dword(rtlpriv, i));
+		if ((j++) % 4 == 0)
+			printk("\n");
+	}
+}
+void bb_reg_dump(struct rtl_priv *rtlpriv)
+{
+	int i, j = 1;
+	printk("\n======= BB REG =======\n");
+	for (i = 0x800; i < 0x1000; i += 4) {
+		if (j % 4 == 1)
+			printk("0x%02x", i);
+
+		printk(" 0x%08x ", rtl_read_dword(rtlpriv, i));
+		if ((j++)%4 == 0)
+			printk("\n");
+	}
+}
+void rf_reg_dump(struct rtl_priv *rtlpriv)
+{
+	int i, j = 1, path;
+	u32 value;
+	uint8_t rf_type, path_nums = 0;
+	rf_type = rtlpriv->phy.rf_type;
+
+	printk("\n======= RF REG =======\n");
+	if ((RF_1T2R == rf_type) || (RF_1T1R == rf_type))
+		path_nums = 1;
+	else
+		path_nums = 2;
+
+	for (path = 0; path < path_nums; path++) {
+		printk("\nRF_Path(%x)\n", path);
+		for (i = 0; i < 0x100; i++) {
+			/* value = rtl_get_rfreg(rtlpriv, path,i, bMaskDWord); */
+			value = rtl_get_rfreg(rtlpriv, path, i, 0xffffffff);
+			if (j % 4 == 1)
+				printk("0x%02x ", i);
+
+			printk(" 0x%08x ", value);
+			if ((j++) % 4 == 0)
+				printk("\n");
+		}
+	}
+}
+
+
+static int wpa_set_param(struct net_device *ndev, uint8_t name, u32 value)
+{
+	uint ret = 0;
+	struct rtl_priv *rtlpriv = rtl_priv(ndev);
+
+	switch (name) {
+	case IEEE_PARAM_WPA_ENABLED:
+		rtlpriv->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_8021X; /* 802.1x */
+
+		/* ret = ieee80211_wpa_enable(ieee, value); */
+
+		switch (value & 0xff) {
+		case 1: /* WPA */
+			rtlpriv->securitypriv.ndisauthtype = Ndis802_11AuthModeWPAPSK; /* WPA_PSK */
+			rtlpriv->securitypriv.ndisencryptstatus = Ndis802_11Encryption2Enabled;
+			break;
+		case 2: /* WPA2 */
+			rtlpriv->securitypriv.ndisauthtype = Ndis802_11AuthModeWPA2PSK; /* WPA2_PSK */
+			rtlpriv->securitypriv.ndisencryptstatus = Ndis802_11Encryption3Enabled;
+			break;
+		}
+
+		break;
+
+	case IEEE_PARAM_TKIP_COUNTERMEASURES:
+		/* ieee->tkip_countermeasures=value; */
+		break;
+
+	case IEEE_PARAM_DROP_UNENCRYPTED:
+		{
+			/* HACK:
+			 *
+			 * wpa_supplicant calls set_wpa_enabled when the driver
+			 * is loaded and unloaded, regardless of if WPA is being
+			 * used.  No other calls are made which can be used to
+			 * determine if encryption will be used or not prior to
+			 * association being expected.  If encryption is not being
+			 * used, drop_unencrypted is set to false, else true -- we
+			 * can use this to determine if the CAP_PRIVACY_ON bit should
+			 * be set.
+			 */
+
+			break;
+
+		}
+	case IEEE_PARAM_PRIVACY_INVOKED:
+		/* ieee->privacy_invoked=value; */
+		break;
+
+	case IEEE_PARAM_AUTH_ALGS:
+		ret = wpa_set_auth_algs(ndev, value);
+		break;
+
+	case IEEE_PARAM_IEEE_802_1X:
+		/* ieee->ieee802_1x=value; */
+		break;
+
+	case IEEE_PARAM_WPAX_SELECT:
+
+		/* added for WPA2 mixed mode
+		 * DBG_871X(KERN_WARNING "------------------------>wpax value = %x\n", value);
+		 */
+		/*
+		spin_lock_irqsave(&ieee->wpax_suitlist_lock,flags);
+		ieee->wpax_type_set = 1;
+		ieee->wpax_type_notify = value;
+		spin_unlock_irqrestore(&ieee->wpax_suitlist_lock,flags);
+		*/
+
+		break;
+
+	default:
+		ret = -EOPNOTSUPP;
+
+		break;
+
+	}
+
+	return ret;
+
+}
+
+static int wpa_mlme(struct net_device *ndev, u32 command, u32 reason)
+{
+	int ret = 0;
+	struct rtl_priv *rtlpriv = rtl_priv(ndev);
+
+	switch (command) {
+	case IEEE_MLME_STA_DEAUTH:
+		if (!rtw_set_802_11_disassociate(rtlpriv))
+			ret = -1;
+
+		break;
+
+	case IEEE_MLME_STA_DISASSOC:
+		if (!rtw_set_802_11_disassociate(rtlpriv))
+			ret = -1;
+
+		break;
+
+	default:
+		ret = -EOPNOTSUPP;
+		break;
+	}
+
+	return ret;
+
+}
+
+static int wpa_supplicant_ioctl(struct net_device *ndev, struct iw_point *p)
+{
+	struct ieee_param *param;
+	uint ret = 0;
+
+	/* down(&ieee->wx_sem); */
+
+	if (p->length < sizeof(struct ieee_param) || !p->pointer) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	param = (struct ieee_param *)rtw_malloc(p->length);
+	if (param == NULL) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	if (copy_from_user(param, p->pointer, p->length)) {
+		rtw_mfree(param);
+		ret = -EFAULT;
+		goto out;
+	}
+
+	switch (param->cmd) {
+	case IEEE_CMD_SET_WPA_PARAM:
+		ret = wpa_set_param(ndev, param->u.wpa_param.name, param->u.wpa_param.value);
+		break;
+
+	case IEEE_CMD_SET_WPA_IE:
+		/* ret = wpa_set_wpa_ie(ndev, param, p->length); */
+		ret =  rtw_set_wpa_ie(rtl_priv(ndev), (char *)param->u.wpa_ie.data, (u16)param->u.wpa_ie.len);
+		break;
+
+	case IEEE_CMD_SET_ENCRYPTION:
+		ret = wpa_set_encryption(ndev, param, p->length);
+		break;
+
+	case IEEE_CMD_MLME:
+		ret = wpa_mlme(ndev, param->u.mlme.command, param->u.mlme.reason_code);
+		break;
+
+	default:
+		DBG_871X("Unknown WPA supplicant request: %d\n", param->cmd);
+		ret = -EOPNOTSUPP;
+		break;
+
+	}
+
+	if (ret == 0 && copy_to_user(p->pointer, param, p->length))
+		ret = -EFAULT;
+
+	rtw_mfree(param);
+
+out:
+
+	/* up(&ieee->wx_sem); */
+
+	return ret;
+
+}
+
+#ifdef CONFIG_AP_MODE
+static int rtw_set_encryption(struct net_device *ndev, struct ieee_param *param, u32 param_len)
+{
+	int ret = 0;
+	u32 wep_key_idx, wep_key_len, wep_total_len;
+	NDIS_802_11_WEP	 *pwep = NULL;
+	struct sta_info *psta = NULL, *pbcmc_sta = NULL;
+	struct rtl_priv *rtlpriv = rtl_priv(ndev);
+	struct mlme_priv 	*pmlmepriv = &rtlpriv->mlmepriv;
+	struct security_priv *psecuritypriv = &(rtlpriv->securitypriv);
+	struct sta_priv *pstapriv = &rtlpriv->stapriv;
+
+	DBG_871X("%s\n", __FUNCTION__);
+
+	param->u.crypt.err = 0;
+	param->u.crypt.alg[IEEE_CRYPT_ALG_NAME_LEN - 1] = '\0';
+
+	/* sizeof(struct ieee_param) = 64 bytes; */
+	/* if (param_len !=  (u32) ((uint8_t *) param->u.crypt.key - (uint8_t *) param) + param->u.crypt.key_len) */
+	if (param_len !=  sizeof(struct ieee_param) + param->u.crypt.key_len) {
+		ret =  -EINVAL;
+		goto exit;
+	}
+
+	if (param->sta_addr[0] == 0xff && param->sta_addr[1] == 0xff &&
+	    param->sta_addr[2] == 0xff && param->sta_addr[3] == 0xff &&
+	    param->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff) {
+		if (param->u.crypt.idx >= WEP_KEYS) {
+			ret = -EINVAL;
+			goto exit;
+		}
+	} else {
+		psta = rtw_get_stainfo(pstapriv, param->sta_addr);
+		if (!psta) {
+			/* ret = -EINVAL; */
+			DBG_871X("rtw_set_encryption(), sta has already been removed or never been added\n");
+			goto exit;
+		}
+	}
+
+	if (strcmp(param->u.crypt.alg, "none") == 0 && (psta == NULL)) {
+		/* todo:clear default encryption keys */
+
+		psecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_Open;
+		psecuritypriv->ndisencryptstatus = Ndis802_11EncryptionDisabled;
+		psecuritypriv->dot11PrivacyAlgrthm = NO_ENCRYPTION;
+		psecuritypriv->dot118021XGrpPrivacy = NO_ENCRYPTION;
+
+		DBG_871X("clear default encryption keys, keyid=%d\n", param->u.crypt.idx);
+
+		goto exit;
+	}
+
+	if (strcmp(param->u.crypt.alg, "WEP") == 0 && (psta == NULL)) {
+		DBG_871X("r871x_set_encryption, crypt.alg = WEP\n");
+
+		wep_key_idx = param->u.crypt.idx;
+		wep_key_len = param->u.crypt.key_len;
+
+		DBG_871X("r871x_set_encryption, wep_key_idx=%d, len=%d\n", wep_key_idx, wep_key_len);
+
+		if ((wep_key_idx >= WEP_KEYS) || (wep_key_len <= 0)) {
+			ret = -EINVAL;
+			goto exit;
+		}
+
+
+		if (wep_key_len > 0) {
+			wep_key_len = wep_key_len <= 5 ? 5 : 13;
+			wep_total_len = wep_key_len + FIELD_OFFSET(NDIS_802_11_WEP, KeyMaterial);
+			pwep = (NDIS_802_11_WEP *)rtw_malloc(wep_total_len);
+			if (pwep == NULL) {
+				DBG_871X(" r871x_set_encryption: pwep allocate fail !!!\n");
+				goto exit;
+			}
+
+			memset(pwep, 0, wep_total_len);
+
+			pwep->KeyLength = wep_key_len;
+			pwep->Length = wep_total_len;
+
+		}
+
+		pwep->KeyIndex = wep_key_idx;
+
+		memcpy(pwep->KeyMaterial,  param->u.crypt.key, pwep->KeyLength);
+
+		if (param->u.crypt.set_tx) {
+			DBG_871X("wep, set_tx=1\n");
+
+			psecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_Auto;
+			psecuritypriv->ndisencryptstatus = Ndis802_11Encryption1Enabled;
+			psecuritypriv->dot11PrivacyAlgrthm = WEP40_ENCRYPTION;
+			psecuritypriv->dot118021XGrpPrivacy = WEP40_ENCRYPTION;
+
+			if (pwep->KeyLength == 13) {
+				psecuritypriv->dot11PrivacyAlgrthm = WEP104_ENCRYPTION;
+				psecuritypriv->dot118021XGrpPrivacy = WEP104_ENCRYPTION;
+			}
+
+
+			psecuritypriv->dot11PrivacyKeyIndex = wep_key_idx;
+
+			memcpy(&(psecuritypriv->dot11DefKey[wep_key_idx].skey[0]), pwep->KeyMaterial, pwep->KeyLength);
+
+			psecuritypriv->dot11DefKeylen[wep_key_idx] = pwep->KeyLength;
+
+			rtw_ap_set_wep_key(rtlpriv, pwep->KeyMaterial, pwep->KeyLength, wep_key_idx, 1);
+				} else 	{
+			DBG_871X("wep, set_tx=0\n");
+
+			/*
+			 * don't update "psecuritypriv->dot11PrivacyAlgrthm" and
+			 * "psecuritypriv->dot11PrivacyKeyIndex=keyid", but can rtw_set_key to cam
+			 */
+
+			memcpy(&(psecuritypriv->dot11DefKey[wep_key_idx].skey[0]), pwep->KeyMaterial, pwep->KeyLength);
+
+			psecuritypriv->dot11DefKeylen[wep_key_idx] = pwep->KeyLength;
+
+			rtw_ap_set_wep_key(rtlpriv, pwep->KeyMaterial, pwep->KeyLength, wep_key_idx, 0);
+		}
+
+		goto exit;
+
+	}
+
+
+	if (!psta && check_fwstate(pmlmepriv, WIFI_AP_STATE)) {
+		/* group key */
+		if (param->u.crypt.set_tx == 1) {
+			if (strcmp(param->u.crypt.alg, "WEP") == 0) {
+				DBG_871X("%s, set group_key, WEP\n", __FUNCTION__);
+
+				memcpy(psecuritypriv->dot118021XGrpKey[param->u.crypt.idx].skey,  param->u.crypt.key, (param->u.crypt.key_len > 16 ? 16 : param->u.crypt.key_len));
+
+				psecuritypriv->dot118021XGrpPrivacy = WEP40_ENCRYPTION;
+				if (param->u.crypt.key_len == 13) {
+						psecuritypriv->dot118021XGrpPrivacy = WEP104_ENCRYPTION;
+				}
+
+			} else if (strcmp(param->u.crypt.alg, "TKIP") == 0) {
+				DBG_871X("%s, set group_key, TKIP\n", __FUNCTION__);
+
+				psecuritypriv->dot118021XGrpPrivacy = TKIP_ENCRYPTION;
+
+				memcpy(psecuritypriv->dot118021XGrpKey[param->u.crypt.idx].skey,  param->u.crypt.key, (param->u.crypt.key_len > 16 ? 16 : param->u.crypt.key_len));
+
+				/*
+				 * DEBUG_ERR("set key length :param->u.crypt.key_len=%d\n", param->u.crypt.key_len);
+				 * set mic key
+				 */
+				memcpy(psecuritypriv->dot118021XGrptxmickey[param->u.crypt.idx].skey, &(param->u.crypt.key[16]), 8);
+				memcpy(psecuritypriv->dot118021XGrprxmickey[param->u.crypt.idx].skey, &(param->u.crypt.key[24]), 8);
+
+				psecuritypriv->busetkipkey = true;
+
+			} else if (strcmp(param->u.crypt.alg, "CCMP") == 0) {
+				DBG_871X("%s, set group_key, CCMP\n", __FUNCTION__);
+
+				psecuritypriv->dot118021XGrpPrivacy = AESCCMP_ENCRYPTION;
+
+				memcpy(psecuritypriv->dot118021XGrpKey[param->u.crypt.idx].skey,  param->u.crypt.key, (param->u.crypt.key_len > 16 ? 16 : param->u.crypt.key_len));
+			} else {
+				DBG_871X("%s, set group_key, none\n", __FUNCTION__);
+
+				psecuritypriv->dot118021XGrpPrivacy = NO_ENCRYPTION;
+			}
+
+			psecuritypriv->dot118021XGrpKeyid = param->u.crypt.idx;
+
+			psecuritypriv->binstallGrpkey = true;
+
+			psecuritypriv->dot11PrivacyAlgrthm = psecuritypriv->dot118021XGrpPrivacy;/* !!! */
+
+			rtw_ap_set_group_key(rtlpriv, param->u.crypt.key, psecuritypriv->dot118021XGrpPrivacy, param->u.crypt.idx);
+
+			pbcmc_sta = rtw_get_bcmc_stainfo(rtlpriv);
+			if (pbcmc_sta) {
+				pbcmc_sta->ieee8021x_blocked = false;
+				pbcmc_sta->dot118021XPrivacy = psecuritypriv->dot118021XGrpPrivacy;/* rx will use bmc_sta's dot118021XPrivacy */
+			}
+
+		}
+
+		goto exit;
+
+	}
+
+	if (psecuritypriv->dot11AuthAlgrthm == dot11AuthAlgrthm_8021X && psta) {	/* psk/802_1x */
+		if (check_fwstate(pmlmepriv, WIFI_AP_STATE)) {
+			if (param->u.crypt.set_tx == 1)	{
+				memcpy(psta->dot118021x_UncstKey.skey,  param->u.crypt.key, (param->u.crypt.key_len > 16 ? 16 : param->u.crypt.key_len));
+
+				if (strcmp(param->u.crypt.alg, "WEP") == 0) {
+					DBG_871X("%s, set pairwise key, WEP\n", __FUNCTION__);
+
+					psta->dot118021XPrivacy = WEP40_ENCRYPTION;
+					if (param->u.crypt.key_len == 13) {
+						psta->dot118021XPrivacy = WEP104_ENCRYPTION;
+					}
+				} else if (strcmp(param->u.crypt.alg, "TKIP") == 0) {
+					DBG_871X("%s, set pairwise key, TKIP\n", __FUNCTION__);
+
+					psta->dot118021XPrivacy = TKIP_ENCRYPTION;
+
+					/*
+					 * DEBUG_ERR("set key length :param->u.crypt.key_len=%d\n", param->u.crypt.key_len);
+					 * set mic key
+					 */
+					memcpy(psta->dot11tkiptxmickey.skey, &(param->u.crypt.key[16]), 8);
+					memcpy(psta->dot11tkiprxmickey.skey, &(param->u.crypt.key[24]), 8);
+
+					psecuritypriv->busetkipkey = true;
+
+				} else if (strcmp(param->u.crypt.alg, "CCMP") == 0) {
+					DBG_871X("%s, set pairwise key, CCMP\n", __FUNCTION__);
+
+					psta->dot118021XPrivacy = AESCCMP_ENCRYPTION;
+				} else {
+					DBG_871X("%s, set pairwise key, none\n", __FUNCTION__);
+
+					psta->dot118021XPrivacy = NO_ENCRYPTION;
+				}
+
+				rtw_ap_set_pairwise_key(rtlpriv, psta);
+
+				psta->ieee8021x_blocked = false;
+
+			} else {
+				/* group key??? */
+				if (strcmp(param->u.crypt.alg, "WEP") == 0) {
+					memcpy(psecuritypriv->dot118021XGrpKey[param->u.crypt.idx].skey,  param->u.crypt.key, (param->u.crypt.key_len > 16 ? 16 : param->u.crypt.key_len));
+
+					psecuritypriv->dot118021XGrpPrivacy = WEP40_ENCRYPTION;
+					if (param->u.crypt.key_len == 13) {
+						psecuritypriv->dot118021XGrpPrivacy = WEP104_ENCRYPTION;
+					}
+				} else if (strcmp(param->u.crypt.alg, "TKIP") == 0) {
+					psecuritypriv->dot118021XGrpPrivacy = TKIP_ENCRYPTION;
+
+					memcpy(psecuritypriv->dot118021XGrpKey[param->u.crypt.idx].skey,  param->u.crypt.key, (param->u.crypt.key_len > 16 ? 16 : param->u.crypt.key_len));
+
+					/*
+					 * DEBUG_ERR("set key length :param->u.crypt.key_len=%d\n", param->u.crypt.key_len);
+					 * set mic key
+					 */
+					memcpy(psecuritypriv->dot118021XGrptxmickey[param->u.crypt.idx].skey, &(param->u.crypt.key[16]), 8);
+					memcpy(psecuritypriv->dot118021XGrprxmickey[param->u.crypt.idx].skey, &(param->u.crypt.key[24]), 8);
+
+					psecuritypriv->busetkipkey = true;
+
+				} else if (strcmp(param->u.crypt.alg, "CCMP") == 0) {
+					psecuritypriv->dot118021XGrpPrivacy = AESCCMP_ENCRYPTION;
+
+					memcpy(psecuritypriv->dot118021XGrpKey[param->u.crypt.idx].skey,  param->u.crypt.key, (param->u.crypt.key_len > 16 ? 16 : param->u.crypt.key_len));
+				} else {
+					psecuritypriv->dot118021XGrpPrivacy = NO_ENCRYPTION;
+				}
+
+				psecuritypriv->dot118021XGrpKeyid = param->u.crypt.idx;
+
+				psecuritypriv->binstallGrpkey = true;
+
+				psecuritypriv->dot11PrivacyAlgrthm = psecuritypriv->dot118021XGrpPrivacy;	/* !!! */
+
+				rtw_ap_set_group_key(rtlpriv, param->u.crypt.key, psecuritypriv->dot118021XGrpPrivacy, param->u.crypt.idx);
+
+				pbcmc_sta = rtw_get_bcmc_stainfo(rtlpriv);
+				if (pbcmc_sta) {
+					pbcmc_sta->ieee8021x_blocked = false;
+					pbcmc_sta->dot118021XPrivacy = psecuritypriv->dot118021XGrpPrivacy;	/* rx will use bmc_sta's dot118021XPrivacy */
+				}
+
+			}
+
+		}
+
+	}
+
+exit:
+
+	if (pwep) {
+		rtw_mfree(pwep);
+	}
+
+	return ret;
+
+}
+
+static int rtw_set_beacon(struct net_device *ndev, struct ieee_param *param, int len)
+{
+	int ret = 0;
+	struct rtl_priv *rtlpriv = rtl_priv(ndev);
+	struct mlme_priv *pmlmepriv = &(rtlpriv->mlmepriv);
+	struct sta_priv *pstapriv = &rtlpriv->stapriv;
+	unsigned char *pbuf = param->u.bcn_ie.buf;
+
+
+	DBG_871X("%s, len=%d\n", __FUNCTION__, len);
+
+	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) != true)
+		return -EINVAL;
+
+	memcpy(&pstapriv->max_num_sta, param->u.bcn_ie.reserved, 2);
+
+	if ((pstapriv->max_num_sta > NUM_STA) || (pstapriv->max_num_sta <= 0))
+		pstapriv->max_num_sta = NUM_STA;
+
+	if (rtw_check_beacon_data(rtlpriv, pbuf,  (len-12-2)) == _SUCCESS)	/* 12 = param header, 2:no packed */
+		ret = 0;
+	else
+		ret = -EINVAL;
+
+	return ret;
+
+}
+
+static int rtw_hostapd_sta_flush(struct net_device *ndev)
+{
+	/*
+	 * _irqL irqL;
+	 * struct list_head	*phead, *plist;
+	 */
+	int ret = 0;
+	/* struct sta_info *psta = NULL; */
+	struct rtl_priv *rtlpriv = rtl_priv(ndev);
+	/* struct sta_priv *pstapriv = &rtlpriv->stapriv; */
+
+	DBG_871X("%s\n", __FUNCTION__);
+
+	flush_all_cam_entry(rtlpriv);	/* clear CAM */
+
+	ret = rtw_sta_flush(rtlpriv);
+
+	return ret;
+
+}
+
+static int rtw_add_sta(struct net_device *ndev, struct ieee_param *param)
+{
+	int ret = 0;
+	struct sta_info *psta = NULL;
+	struct rtl_priv *rtlpriv = rtl_priv(ndev);
+	struct mlme_priv *pmlmepriv = &(rtlpriv->mlmepriv);
+	struct sta_priv *pstapriv = &rtlpriv->stapriv;
+
+	DBG_871X("rtw_add_sta(aid=%d)=" MAC_FMT "\n", param->u.add_sta.aid, MAC_ARG(param->sta_addr));
+
+	if (check_fwstate(pmlmepriv, (_FW_LINKED|WIFI_AP_STATE)) != true) {
+		return -EINVAL;
+	}
+
+	if (param->sta_addr[0] == 0xff && param->sta_addr[1] == 0xff &&
+	    param->sta_addr[2] == 0xff && param->sta_addr[3] == 0xff &&
+	    param->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff) {
+		return -EINVAL;
+	}
+
+/*
+	psta = rtw_get_stainfo(pstapriv, param->sta_addr);
+	if (psta)
+	{
+		DBG_871X("rtw_add_sta(), free has been added psta=%p\n", psta);
+		spin_lock_bh(&(pstapriv->sta_hash_lock), &irqL);
+		rtw_free_stainfo(rtlpriv,  psta);
+		spin_unlock_bh(&(pstapriv->sta_hash_lock), &irqL);
+
+		psta = NULL;
+	}
+*/
+	/* psta = rtw_alloc_stainfo(pstapriv, param->sta_addr); */
+	psta = rtw_get_stainfo(pstapriv, param->sta_addr);
+	if (psta) {
+		int flags = param->u.add_sta.flags;
+
+		/* DBG_871X("rtw_add_sta(), init sta's variables, psta=%p\n", psta); */
+
+		psta->aid = param->u.add_sta.aid;	/* aid=1~2007 */
+
+		memcpy(psta->bssrateset, param->u.add_sta.tx_supp_rates, 16);
+
+
+		/* check wmm cap. */
+		if (WLAN_STA_WME&flags)
+			psta->qos_option = 1;
+		else
+			psta->qos_option = 0;
+
+		if (pmlmepriv->qospriv.qos_option == 0)
+			psta->qos_option = 0;
+
+		/* chec 802.11n ht cap. */
+		if (WLAN_STA_HT&flags) {
+			psta->htpriv.ht_option = true;
+			psta->qos_option = 1;
+			memcpy(&psta->htpriv.ht_cap, &param->u.add_sta.ht_cap, sizeof(struct rtw_ieee80211_ht_cap));
+		} else {
+			psta->htpriv.ht_option = false;
+		}
+
+		if (pmlmepriv->htpriv.ht_option == false)
+			psta->htpriv.ht_option = false;
+
+		update_sta_info_apmode(rtlpriv, psta);
+	} else {
+		ret = -ENOMEM;
+	}
+
+	return ret;
+
+}
+
+static int rtw_del_sta(struct net_device *ndev, struct ieee_param *param)
+{
+	int ret = 0;
+	struct sta_info *psta = NULL;
+	struct rtl_priv *rtlpriv = rtl_priv(ndev);
+	struct mlme_priv *pmlmepriv = &(rtlpriv->mlmepriv);
+	struct sta_priv *pstapriv = &rtlpriv->stapriv;
+
+	DBG_871X("rtw_del_sta=" MAC_FMT "\n", MAC_ARG(param->sta_addr));
+
+	if (check_fwstate(pmlmepriv, (_FW_LINKED|WIFI_AP_STATE)) != true) {
+		return -EINVAL;
+	}
+
+	if (param->sta_addr[0] == 0xff && param->sta_addr[1] == 0xff &&
+	    param->sta_addr[2] == 0xff && param->sta_addr[3] == 0xff &&
+	    param->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff) {
+		return -EINVAL;
+	}
+
+	psta = rtw_get_stainfo(pstapriv, param->sta_addr);
+	if (psta) {
+		uint8_t updated;
+
+		/* DBG_871X("free psta=%p, aid=%d\n", psta, psta->aid); */
+
+		spin_lock_bh(&pstapriv->asoc_list_lock);
+		if (list_empty(&psta->asoc_list) == false) {
+			list_del_init(&psta->asoc_list);
+			pstapriv->asoc_list_cnt--;
+			updated = ap_free_sta(rtlpriv, psta, true, WLAN_REASON_DEAUTH_LEAVING);
+
+		}
+		spin_unlock_bh(&pstapriv->asoc_list_lock);
+
+		associated_clients_update(rtlpriv, updated);
+
+		psta = NULL;
+
+	} else {
+		DBG_871X("rtw_del_sta(), sta has already been removed or never been added\n");
+
+		/* ret = -1; */
+	}
+
+
+	return ret;
+
+}
+
+static int rtw_ioctl_get_sta_data(struct net_device *ndev, struct ieee_param *param, int len)
+{
+	int ret = 0;
+	struct sta_info *psta = NULL;
+	struct rtl_priv *rtlpriv = rtl_priv(ndev);
+	struct mlme_priv *pmlmepriv = &(rtlpriv->mlmepriv);
+	struct sta_priv *pstapriv = &rtlpriv->stapriv;
+	struct ieee_param_ex *param_ex = (struct ieee_param_ex *)param;
+	struct sta_data *psta_data = (struct sta_data *)param_ex->data;
+
+	DBG_871X("rtw_ioctl_get_sta_info, sta_addr: " MAC_FMT "\n", MAC_ARG(param_ex->sta_addr));
+
+	if (check_fwstate(pmlmepriv, (_FW_LINKED|WIFI_AP_STATE)) != true) {
+		return -EINVAL;
+	}
+
+	if (param_ex->sta_addr[0] == 0xff && param_ex->sta_addr[1] == 0xff &&
+	    param_ex->sta_addr[2] == 0xff && param_ex->sta_addr[3] == 0xff &&
+	    param_ex->sta_addr[4] == 0xff && param_ex->sta_addr[5] == 0xff) {
+		return -EINVAL;
+	}
+
+	psta = rtw_get_stainfo(pstapriv, param_ex->sta_addr);
+	if (psta) {
+		psta_data->aid = (u16)psta->aid;
+		psta_data->capability = psta->capability;
+		psta_data->flags = psta->flags;
+
+/*
+		nonerp_set : BIT(0)
+		no_short_slot_time_set : BIT(1)
+		no_short_preamble_set : BIT(2)
+		no_ht_gf_set : BIT(3)
+		no_ht_set : BIT(4)
+		ht_20mhz_set : BIT(5)
+*/
+
+		psta_data->sta_set = ((psta->nonerp_set) |
+							(psta->no_short_slot_time_set << 1) |
+							(psta->no_short_preamble_set << 2) |
+							(psta->no_ht_gf_set << 3) |
+							(psta->no_ht_set << 4) |
+							(psta->ht_20mhz_set << 5));
+
+		psta_data->tx_supp_rates_len =  psta->bssratelen;
+		memcpy(psta_data->tx_supp_rates, psta->bssrateset, psta->bssratelen);
+		memcpy(&psta_data->ht_cap, &psta->htpriv.ht_cap, sizeof(struct rtw_ieee80211_ht_cap));
+		psta_data->rx_pkts = psta->sta_stats.rx_data_pkts;
+		psta_data->rx_bytes = psta->sta_stats.rx_bytes;
+		psta_data->rx_drops = psta->sta_stats.rx_drops;
+
+		psta_data->tx_pkts = psta->sta_stats.tx_pkts;
+		psta_data->tx_bytes = psta->sta_stats.tx_bytes;
+		psta_data->tx_drops = psta->sta_stats.tx_drops;
+
+
+	} else {
+		ret = -1;
+	}
+
+	return ret;
+
+}
+
+static int rtw_get_sta_wpaie(struct net_device *ndev, struct ieee_param *param)
+{
+	int ret = 0;
+	struct sta_info *psta = NULL;
+	struct rtl_priv *rtlpriv = rtl_priv(ndev);
+	struct mlme_priv *pmlmepriv = &(rtlpriv->mlmepriv);
+	struct sta_priv *pstapriv = &rtlpriv->stapriv;
+
+	DBG_871X("rtw_get_sta_wpaie, sta_addr: " MAC_FMT "\n", MAC_ARG(param->sta_addr));
+
+	if (check_fwstate(pmlmepriv, (_FW_LINKED|WIFI_AP_STATE)) != true) {
+		return -EINVAL;
+	}
+
+	if (param->sta_addr[0] == 0xff && param->sta_addr[1] == 0xff &&
+	    param->sta_addr[2] == 0xff && param->sta_addr[3] == 0xff &&
+	    param->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff) {
+		return -EINVAL;
+	}
+
+	psta = rtw_get_stainfo(pstapriv, param->sta_addr);
+	if (psta) {
+		if ((psta->wpa_ie[0] == WLAN_EID_RSN) || (psta->wpa_ie[0] == WLAN_EID_GENERIC)) {
+			int wpa_ie_len;
+			int copy_len;
+
+			wpa_ie_len = psta->wpa_ie[1];
+
+			copy_len = ((wpa_ie_len+2) > sizeof(psta->wpa_ie)) ? (sizeof(psta->wpa_ie)):(wpa_ie_len+2);
+
+			param->u.wpa_ie.len = copy_len;
+
+			memcpy(param->u.wpa_ie.reserved, psta->wpa_ie, copy_len);
+		} else {
+			/* ret = -1; */
+			DBG_871X("sta's wpa_ie is NONE\n");
+		}
+	} else {
+		ret = -1;
+	}
+
+	return ret;
+
+}
+
+static int rtw_set_wps_beacon(struct net_device *ndev, struct ieee_param *param, int len)
+{
+	int ret = 0;
+	unsigned char wps_oui[4] = { 0x0, 0x50, 0xf2, 0x04};
+	struct rtl_priv *rtlpriv = rtl_priv(ndev);
+	struct mlme_priv *pmlmepriv = &(rtlpriv->mlmepriv);
+	struct mlme_ext_priv	*pmlmeext = &(rtlpriv->mlmeextpriv);
+	int ie_len;
+
+	DBG_871X("%s, len=%d\n", __FUNCTION__, len);
+
+	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) != true)
+		return -EINVAL;
+
+	ie_len = len - 12 - 2;	/* 12 = param header, 2:no packed */
+
+	if (pmlmepriv->wps_beacon_ie) {
+		rtw_mfree(pmlmepriv->wps_beacon_ie);
+		pmlmepriv->wps_beacon_ie = NULL;
+	}
+
+	if (ie_len > 0) {
+		pmlmepriv->wps_beacon_ie = rtw_malloc(ie_len);
+		pmlmepriv->wps_beacon_ie_len = ie_len;
+		if (pmlmepriv->wps_beacon_ie == NULL) {
+			DBG_871X("%s()-%d: rtw_malloc() ERROR!\n", __FUNCTION__, __LINE__);
+			return -EINVAL;
+		}
+
+		memcpy(pmlmepriv->wps_beacon_ie, param->u.bcn_ie.buf, ie_len);
+
+		update_beacon(rtlpriv, _VENDOR_SPECIFIC_IE_, wps_oui, true);
+
+		pmlmeext->bstart_bss = true;
+
+	}
+
+	return ret;
+
+}
+
+static int rtw_set_wps_probe_resp(struct net_device *ndev, struct ieee_param *param, int len)
+{
+	int ret = 0;
+	struct rtl_priv *rtlpriv = rtl_priv(ndev);
+	struct mlme_priv *pmlmepriv = &(rtlpriv->mlmepriv);
+	int ie_len;
+
+	DBG_871X("%s, len=%d\n", __FUNCTION__, len);
+
+	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) != true)
+		return -EINVAL;
+
+	ie_len = len - 12 - 2;	/* 12 = param header, 2:no packed */
+
+
+	if (pmlmepriv->wps_probe_resp_ie) {
+		/* ULLI check usage of pmlmepriv->wps_probe_resp_ie_len */
+		rtw_mfree(pmlmepriv->wps_probe_resp_ie);
+		pmlmepriv->wps_probe_resp_ie = NULL;
+	}
+
+	if (ie_len > 0) {
+		pmlmepriv->wps_probe_resp_ie = rtw_malloc(ie_len);
+		pmlmepriv->wps_probe_resp_ie_len = ie_len;
+		if (pmlmepriv->wps_probe_resp_ie == NULL) {
+			DBG_871X("%s()-%d: rtw_malloc() ERROR!\n", __FUNCTION__, __LINE__);
+			return -EINVAL;
+		}
+		memcpy(pmlmepriv->wps_probe_resp_ie, param->u.bcn_ie.buf, ie_len);
+	}
+
+
+	return ret;
+
+}
+
+static int rtw_set_wps_assoc_resp(struct net_device *ndev, struct ieee_param *param, int len)
+{
+	int ret = 0;
+	struct rtl_priv *rtlpriv = rtl_priv(ndev);
+	struct mlme_priv *pmlmepriv = &(rtlpriv->mlmepriv);
+	int ie_len;
+
+	DBG_871X("%s, len=%d\n", __FUNCTION__, len);
+
+	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) != true)
+		return -EINVAL;
+
+	ie_len = len - 12 - 2;	/* 12 = param header, 2:no packed */
+
+
+	if (pmlmepriv->wps_assoc_resp_ie) {
+		/* ULLI check usage of pmlmepriv->wps_assoc_resp_ie_len */
+		rtw_mfree(pmlmepriv->wps_assoc_resp_ie);
+		pmlmepriv->wps_assoc_resp_ie = NULL;
+	}
+
+	if (ie_len > 0) {
+		pmlmepriv->wps_assoc_resp_ie = rtw_malloc(ie_len);
+		pmlmepriv->wps_assoc_resp_ie_len = ie_len;
+		if (pmlmepriv->wps_assoc_resp_ie == NULL) {
+			DBG_871X("%s()-%d: rtw_malloc() ERROR!\n", __FUNCTION__, __LINE__);
+			return -EINVAL;
+		}
+
+		memcpy(pmlmepriv->wps_assoc_resp_ie, param->u.bcn_ie.buf, ie_len);
+	}
+
+
+	return ret;
+
+}
+
+static int rtw_set_hidden_ssid(struct net_device *ndev, struct ieee_param *param, int len)
+{
+	int ret = 0;
+	struct rtl_priv *rtlpriv = rtl_priv(ndev);
+	struct mlme_priv *mlmepriv = &(rtlpriv->mlmepriv);
+	struct mlme_ext_priv	*mlmeext = &(rtlpriv->mlmeextpriv);
+	struct mlme_ext_info	*mlmeinfo = &(mlmeext->mlmext_info);
+	int ie_len;
+	uint8_t *ssid_ie;
+	char ssid[NDIS_802_11_LENGTH_SSID + 1];
+	int ssid_len;
+	uint8_t ignore_broadcast_ssid;
+
+	if (check_fwstate(mlmepriv, WIFI_AP_STATE) != true)
+		return -EPERM;
+
+	if (param->u.bcn_ie.reserved[0] != 0xea)
+		return -EINVAL;
+
+	mlmeinfo->hidden_ssid_mode = ignore_broadcast_ssid = param->u.bcn_ie.reserved[1];
+
+	ie_len = len - 12 - 2;	/* 12 = param header, 2:no packed */
+	ssid_ie = rtw_get_ie(param->u.bcn_ie.buf,  WLAN_EID_SSID, &ssid_len, ie_len);
+
+	if (ssid_ie && ssid_len) {
+		WLAN_BSSID_EX *pbss_network = &mlmepriv->cur_network.network;
+		WLAN_BSSID_EX *pbss_network_ext = &mlmeinfo->network;
+
+		memcpy(ssid, ssid_ie+2, ssid_len);
+		ssid[ssid_len > NDIS_802_11_LENGTH_SSID ? NDIS_802_11_LENGTH_SSID : ssid_len] = 0x0;
+
+		if (0)
+		DBG_871X(FUNC_ADPT_FMT" ssid:(%s,%d), from ie:(%s,%d), (%s,%d)\n", FUNC_ADPT_ARG(rtlpriv),
+			ssid, ssid_len,
+			pbss_network->Ssid.Ssid, pbss_network->Ssid.SsidLength,
+			pbss_network_ext->Ssid.Ssid, pbss_network_ext->Ssid.SsidLength);
+
+		memcpy(pbss_network->Ssid.Ssid, (void *)ssid, ssid_len);
+		pbss_network->Ssid.SsidLength = ssid_len;
+		memcpy(pbss_network_ext->Ssid.Ssid, (void *)ssid, ssid_len);
+		pbss_network_ext->Ssid.SsidLength = ssid_len;
+
+		if (0)
+		DBG_871X(FUNC_ADPT_FMT" after ssid:(%s,%d), (%s,%d)\n", FUNC_ADPT_ARG(rtlpriv),
+			pbss_network->Ssid.Ssid, pbss_network->Ssid.SsidLength,
+			pbss_network_ext->Ssid.Ssid, pbss_network_ext->Ssid.SsidLength);
+	}
+
+	DBG_871X(FUNC_ADPT_FMT" ignore_broadcast_ssid:%d, %s,%d\n", FUNC_ADPT_ARG(rtlpriv),
+		ignore_broadcast_ssid, ssid, ssid_len);
+
+	return ret;
+}
+
+static int rtw_ioctl_acl_remove_sta(struct net_device *ndev, struct ieee_param *param, int len)
+{
+	int ret = 0;
+	struct rtl_priv *rtlpriv = rtl_priv(ndev);
+	struct mlme_priv *pmlmepriv = &(rtlpriv->mlmepriv);
+
+	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) != true)
+		return -EINVAL;
+
+	if (param->sta_addr[0] == 0xff && param->sta_addr[1] == 0xff &&
+	    param->sta_addr[2] == 0xff && param->sta_addr[3] == 0xff &&
+	    param->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff) {
+		return -EINVAL;
+	}
+
+	ret = rtw_acl_remove_sta(rtlpriv, param->sta_addr);
+
+	return ret;
+
+}
+
+static int rtw_ioctl_acl_add_sta(struct net_device *ndev, struct ieee_param *param, int len)
+{
+	int ret = 0;
+	struct rtl_priv *rtlpriv = rtl_priv(ndev);
+	struct mlme_priv *pmlmepriv = &(rtlpriv->mlmepriv);
+
+	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) != true)
+		return -EINVAL;
+
+	if (param->sta_addr[0] == 0xff && param->sta_addr[1] == 0xff &&
+	    param->sta_addr[2] == 0xff && param->sta_addr[3] == 0xff &&
+	    param->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff) {
+		return -EINVAL;
+	}
+
+	ret = rtw_acl_add_sta(rtlpriv, param->sta_addr);
+
+	return ret;
+
+}
+
+static int rtw_ioctl_set_macaddr_acl(struct net_device *ndev, struct ieee_param *param, int len)
+{
+	int ret = 0;
+	struct rtl_priv *rtlpriv = rtl_priv(ndev);
+	struct mlme_priv *pmlmepriv = &(rtlpriv->mlmepriv);
+
+	if (check_fwstate(pmlmepriv, WIFI_AP_STATE) != true)
+		return -EINVAL;
+
+	rtw_set_macaddr_acl(rtlpriv, param->u.mlme.command);
+
+	return ret;
+}
+
+static int rtw_hostapd_ioctl(struct net_device *ndev, struct iw_point *p)
+{
+	struct ieee_param *param;
+	int ret = 0;
+	struct rtl_priv *rtlpriv = rtl_priv(ndev);
+
+	/* DBG_871X("%s\n", __FUNCTION__); */
+
+	/*
+	* this function is expect to call in master mode, which allows no power saving
+	* so, we just check hw_init_completed
+	*/
+
+	if (rtlpriv->hw_init_completed == false) {
+		ret = -EPERM;
+		goto out;
+	}
+
+
+	/* if (p->length < sizeof(struct ieee_param) || !p->pointer){ */
+	if (!p->pointer) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	param = (struct ieee_param *)rtw_malloc(p->length);
+	if (param == NULL) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	if (copy_from_user(param, p->pointer, p->length)) {
+		rtw_mfree(param);
+		ret = -EFAULT;
+		goto out;
+	}
+
+	/* DBG_871X("%s, cmd=%d\n", __FUNCTION__, param->cmd); */
+
+	switch (param->cmd) {
+	case RTL871X_HOSTAPD_FLUSH:
+		ret = rtw_hostapd_sta_flush(ndev);
+		break;
+
+	case RTL871X_HOSTAPD_ADD_STA:
+		ret = rtw_add_sta(ndev, param);
+		break;
+
+	case RTL871X_HOSTAPD_REMOVE_STA:
+		ret = rtw_del_sta(ndev, param);
+		break;
+
+	case RTL871X_HOSTAPD_SET_BEACON:
+		ret = rtw_set_beacon(ndev, param, p->length);
+		break;
+
+	case RTL871X_SET_ENCRYPTION:
+		ret = rtw_set_encryption(ndev, param, p->length);
+		break;
+
+	case RTL871X_HOSTAPD_GET_WPAIE_STA:
+		ret = rtw_get_sta_wpaie(ndev, param);
+		break;
+
+	case RTL871X_HOSTAPD_SET_WPS_BEACON:
+		ret = rtw_set_wps_beacon(ndev, param, p->length);
+		break;
+
+	case RTL871X_HOSTAPD_SET_WPS_PROBE_RESP:
+		ret = rtw_set_wps_probe_resp(ndev, param, p->length);
+		break;
+
+	case RTL871X_HOSTAPD_SET_WPS_ASSOC_RESP:
+		ret = rtw_set_wps_assoc_resp(ndev, param, p->length);
+		break;
+
+	case RTL871X_HOSTAPD_SET_HIDDEN_SSID:
+		ret = rtw_set_hidden_ssid(ndev, param, p->length);
+		break;
+
+	case RTL871X_HOSTAPD_GET_INFO_STA:
+		ret = rtw_ioctl_get_sta_data(ndev, param, p->length);
+		break;
+
+	case RTL871X_HOSTAPD_SET_MACADDR_ACL:
+		ret = rtw_ioctl_set_macaddr_acl(ndev, param, p->length);
+		break;
+
+	case RTL871X_HOSTAPD_ACL_ADD_STA:
+		ret = rtw_ioctl_acl_add_sta(ndev, param, p->length);
+		break;
+
+	case RTL871X_HOSTAPD_ACL_REMOVE_STA:
+		ret = rtw_ioctl_acl_remove_sta(ndev, param, p->length);
+		break;
+
+	default:
+		DBG_871X("Unknown hostapd request: %d\n", param->cmd);
+		ret = -EOPNOTSUPP;
+		break;
+
+	}
+
+	if (ret == 0 && copy_to_user(p->pointer, param, p->length))
+		ret = -EFAULT;
+
+	rtw_mfree(param);
+
+out:
+
+	return ret;
+
+}
+#endif
+
+static int rtw_wx_set_priv(struct net_device *ndev,
+				struct iw_request_info *info,
+				union iwreq_data *awrq,
+				char *extra)
+{
+
+#ifdef CONFIG_DEBUG_RTW_WX_SET_PRIV
+	char *ext_dbg;
+#endif
+
+	int ret = 0;
+	int len = 0;
+	char *ext;
+
+	struct rtl_priv *rtlpriv = rtl_priv(ndev);
+	struct iw_point *dwrq = (struct iw_point *) awrq;
+
+	/* RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_notice_, ("+rtw_wx_set_priv\n")); */
+	if (dwrq->length == 0)
+		return -EFAULT;
+
+	len = dwrq->length;
+	ext = rtw_vmalloc(len);
+	if (!ext)
+		return -ENOMEM;
+
+	if (copy_from_user(ext, dwrq->pointer, len)) {
+		rtw_vmfree(ext);
+		return -EFAULT;
+	}
+
+
+	/*
+	 * RT_TRACE(_module_rtl871x_ioctl_os_c, _drv_notice_,
+	 * 	 ("rtw_wx_set_priv: %s req=%s\n",
+	 * 	  ndev->name, ext));
+	 */
+
+#ifdef CONFIG_DEBUG_RTW_WX_SET_PRIV
+	ext_dbg = rtw_vmalloc(len);
+	if (ext_dbg) {
+		rtw_vmfree(ext);
+		return -ENOMEM;
+	}
+
+	memcpy(ext_dbg, ext, len);
+	#endif
+
+	/* added for wps2.0 @20110524 */
+	if (dwrq->flags == 0x8766 && len > 8) {
+		u32 cp_sz;
+		struct mlme_priv *pmlmepriv = &(rtlpriv->mlmepriv);
+		uint8_t *probereq_wpsie = ext;
+		int probereq_wpsie_len = len;
+		uint8_t wps_oui[4] = { 0x0, 0x50, 0xf2, 0x04};
+
+		if ((_VENDOR_SPECIFIC_IE_ == probereq_wpsie[0]) &&
+		   (_rtw_memcmp(&probereq_wpsie[2], wps_oui, 4) == true)) {
+			cp_sz = probereq_wpsie_len > MAX_WPS_IE_LEN ? MAX_WPS_IE_LEN : probereq_wpsie_len;
+
+			/*
+			 * memcpy(pmlmepriv->probereq_wpsie, probereq_wpsie, cp_sz);
+			 * pmlmepriv->probereq_wpsie_len = cp_sz;
+			 */
+			if (pmlmepriv->wps_probe_req_ie) {
+				pmlmepriv->wps_probe_req_ie_len = 0;
+				rtw_mfree(pmlmepriv->wps_probe_req_ie);
+				pmlmepriv->wps_probe_req_ie = NULL;
+			}
+
+			pmlmepriv->wps_probe_req_ie = rtw_malloc(cp_sz);
+			if (pmlmepriv->wps_probe_req_ie == NULL) {
+				printk("%s()-%d: rtw_malloc() ERROR!\n", __FUNCTION__, __LINE__);
+				ret =  -EINVAL;
+				goto FREE_EXT;
+
+			}
+
+			memcpy(pmlmepriv->wps_probe_req_ie, probereq_wpsie, cp_sz);
+			pmlmepriv->wps_probe_req_ie_len = cp_sz;
+
+		}
+		goto FREE_EXT;
+
+	}
+
+	if (len >= WEXT_CSCAN_HEADER_SIZE &&
+	    _rtw_memcmp(ext, WEXT_CSCAN_HEADER, WEXT_CSCAN_HEADER_SIZE) == true) {
+		ret = rtw_wx_set_scan(ndev, info, awrq, ext);
+		goto FREE_EXT;
+	}
+
+
+
+FREE_EXT:
+	rtw_vmfree(ext);
+	#ifdef CONFIG_DEBUG_RTW_WX_SET_PRIV
+	/* ULLI check usage of len , strange above function with length c++ not in the kernel */
+	rtw_vmfree(ext_dbg, len);
+	#endif
+
+	/*
+	 * DBG_871X("rtw_wx_set_priv: (SIOCSIWPRIV) %s ret=%d\n",
+	 * 		ndev->name, ret);
+	 */
+
+	return ret;
+
+}
+
+static int rtw_pm_set(struct net_device *ndev, struct iw_request_info *info,
+			union iwreq_data *wrqu, char *extra)
+{
+	int ret = 0;
+	unsigned	mode = 0;
+	struct rtl_priv *rtlpriv = rtl_priv(ndev);
+
+	DBG_871X("[%s] extra = %s\n", __FUNCTION__, extra);
+
+	if (_rtw_memcmp(extra, "lps=", 4)) {
+		sscanf(extra+4, "%u", &mode);
+		ret = rtw_pm_set_lps(rtlpriv, mode);
+	} else if (_rtw_memcmp(extra, "ips=", 4)) {
+		sscanf(extra+4, "%u", &mode);
+		ret = rtw_pm_set_ips(rtlpriv, mode);
+	} else {
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+static int rtw_test(
+	struct net_device *ndev,
+	struct iw_request_info *info,
+	union iwreq_data *wrqu, char *extra)
+{
+	u32 len;
+	uint8_t *pbuf, *pch;
+	char *ptmp;
+	uint8_t *delim = ",";
+	struct rtl_priv *rtlpriv = rtl_priv(ndev);
+
+
+	DBG_871X("+%s\n", __func__);
+	len = wrqu->data.length;
+
+	pbuf = (uint8_t *)rtw_zmalloc(len);
+	if (pbuf == NULL) {
+		DBG_871X("%s: no memory!\n", __func__);
+		return -ENOMEM;
+	}
+
+	if (copy_from_user(pbuf, wrqu->data.pointer, len)) {
+		rtw_mfree(pbuf);
+		DBG_871X("%s: copy from user fail!\n", __func__);
+		return -EFAULT;
+	}
+	DBG_871X("%s: string=\"%s\"\n", __func__, pbuf);
+
+	ptmp = (char *) pbuf;
+	pch = strsep(&ptmp, delim);
+	if ((pch == NULL) || (strlen(pch) == 0)) {
+		rtw_mfree(pbuf);
+		DBG_871X("%s: parameter error(level 1)!\n", __func__);
+		return -EFAULT;
+	}
+
+
+	rtw_mfree(pbuf);
+	return 0;
+}
+
+static iw_handler rtw_handlers[] = {
+	NULL,					/* SIOCSIWCOMMIT */
+	rtw_wx_get_name,		/* SIOCGIWNAME */
+	dummy,					/* SIOCSIWNWID */
+	dummy,					/* SIOCGIWNWID */
+	rtw_wx_set_freq,		/* SIOCSIWFREQ */
+	rtw_wx_get_freq,		/* SIOCGIWFREQ */
+	rtw_wx_set_mode,		/* SIOCSIWMODE */
+	rtw_wx_get_mode,		/* SIOCGIWMODE */
+	dummy,					/* SIOCSIWSENS */
+	rtw_wx_get_sens,		/* SIOCGIWSENS */
+	NULL,					/* SIOCSIWRANGE */
+	rtw_wx_get_range,		/* SIOCGIWRANGE */
+	rtw_wx_set_priv,		/* SIOCSIWPRIV */
+	NULL,					/* SIOCGIWPRIV */
+	NULL,					/* SIOCSIWSTATS */
+	NULL,					/* SIOCGIWSTATS */
+	dummy,					/* SIOCSIWSPY */
+	dummy,					/* SIOCGIWSPY */
+	NULL,					/* SIOCGIWTHRSPY */
+	NULL,					/* SIOCWIWTHRSPY */
+	rtw_wx_set_wap,		/* SIOCSIWAP */
+	rtw_wx_get_wap,		/* SIOCGIWAP */
+	rtw_wx_set_mlme,		/* request MLME operation; uses struct iw_mlme */
+	dummy,					/* SIOCGIWAPLIST -- depricated */
+	rtw_wx_set_scan,		/* SIOCSIWSCAN */
+	rtw_wx_get_scan,		/* SIOCGIWSCAN */
+	rtw_wx_set_essid,		/* SIOCSIWESSID */
+	rtw_wx_get_essid,		/* SIOCGIWESSID */
+	dummy,					/* SIOCSIWNICKN */
+	rtw_wx_get_nick,		/* SIOCGIWNICKN */
+	NULL,					/* -- hole -- */
+	NULL,					/* -- hole -- */
+	NULL,				/* SIOCSIWRATE */
+	rtw_wx_get_rate,		/* SIOCGIWRATE */
+	rtw_wx_set_rts,			/* SIOCSIWRTS */
+	rtw_wx_get_rts,			/* SIOCGIWRTS */
+	rtw_wx_set_frag,		/* SIOCSIWFRAG */
+	rtw_wx_get_frag,		/* SIOCGIWFRAG */
+	dummy,					/* SIOCSIWTXPOW */
+	dummy,					/* SIOCGIWTXPOW */
+	dummy,					/* SIOCSIWRETRY */
+	rtw_wx_get_retry,		/* SIOCGIWRETRY */
+	rtw_wx_set_enc,			/* SIOCSIWENCODE */
+	rtw_wx_get_enc,			/* SIOCGIWENCODE */
+	dummy,					/* SIOCSIWPOWER */
+	rtw_wx_get_power,		/* SIOCGIWPOWER */
+	NULL,					/*---hole---*/
+	NULL,					/*---hole---*/
+	rtw_wx_set_gen_ie,		/* SIOCSIWGENIE */
+	NULL,					/* SIOCGWGENIE */
+	rtw_wx_set_auth,		/* SIOCSIWAUTH */
+	NULL,					/* SIOCGIWAUTH */
+	rtw_wx_set_enc_ext,		/* SIOCSIWENCODEEXT */
+	NULL,					/* SIOCGIWENCODEEXT */
+	rtw_wx_set_pmkid,		/* SIOCSIWPMKSA */
+	NULL,					/*---hole---*/
+};
+
+static const struct iw_priv_args rtw_private_args[] = {
+	{
+		SIOCIWFIRSTPRIV + 0x0,
+		IW_PRIV_TYPE_CHAR | 0x7FF, 0, "write"
+	},
+	{
+		SIOCIWFIRSTPRIV + 0x1,
+		IW_PRIV_TYPE_CHAR | 0x7FF,
+		IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_FIXED | IFNAMSIZ, "read"
+	},
+	{
+		SIOCIWFIRSTPRIV + 0x2, 0, 0, "driver_ext"
+	},
+	{
+		SIOCIWFIRSTPRIV + 0x3, 0, 0, "mp_ioctl"
+	},
+	{
+		SIOCIWFIRSTPRIV + 0x4,
+		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "apinfo"
+	},
+	{
+		SIOCIWFIRSTPRIV + 0x5,
+		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 2, 0, "setpid"
+	},
+	{
+		SIOCIWFIRSTPRIV + 0x6,
+		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "wps_start"
+	},
+/* for PLATFORM_MT53XX */
+	{
+		SIOCIWFIRSTPRIV + 0x7,
+		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "get_sensitivity"
+	},
+	{
+		SIOCIWFIRSTPRIV + 0x8,
+		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "wps_prob_req_ie"
+	},
+	{
+		SIOCIWFIRSTPRIV + 0x9,
+		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "wps_assoc_req_ie"
+	},
+
+/* for RTK_DMP_PLATFORM */
+	{
+		SIOCIWFIRSTPRIV + 0xA,
+		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, "channel_plan"
+	},
+
+	{
+		SIOCIWFIRSTPRIV + 0xB,
+		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 2, 0, "dbg"
+	},
+	{
+		SIOCIWFIRSTPRIV + 0xC,
+		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 3, 0, "rfw"
+	},
+	{
+		SIOCIWFIRSTPRIV + 0xD,
+		IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 2, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_FIXED | IFNAMSIZ, "rfr"
+	},
+	{
+		SIOCIWFIRSTPRIV + 0x10,
+		IW_PRIV_TYPE_CHAR | P2P_PRIVATE_IOCTL_SET_LEN, 0, "p2p_set"
+	},
+	{
+		SIOCIWFIRSTPRIV + 0x11,
+		IW_PRIV_TYPE_CHAR | 1024, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK , "p2p_get"
+	},
+	{
+		SIOCIWFIRSTPRIV + 0x12, 0, 0, "NULL"
+	},
+	{
+		SIOCIWFIRSTPRIV + 0x13,
+		IW_PRIV_TYPE_CHAR | 64, IW_PRIV_TYPE_CHAR | 64 , "p2p_get2"
+	},
+	{
+		SIOCIWFIRSTPRIV + 0x14,
+		IW_PRIV_TYPE_CHAR  | 64, 0, "tdls"
+	},
+	{
+		SIOCIWFIRSTPRIV + 0x15,
+		IW_PRIV_TYPE_CHAR | P2P_PRIVATE_IOCTL_SET_LEN, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_FIXED | P2P_PRIVATE_IOCTL_SET_LEN , "tdls_get"
+	},
+	{
+		SIOCIWFIRSTPRIV + 0x16,
+		IW_PRIV_TYPE_CHAR | 64, 0, "pm_set"
+	},
+
+	{SIOCIWFIRSTPRIV + 0x18, IW_PRIV_TYPE_CHAR | IFNAMSIZ , 0 , "rereg_nd_name"},
+
+	{SIOCIWFIRSTPRIV + 0x1A, IW_PRIV_TYPE_CHAR | 1024, 0, "efuse_set"},
+	{SIOCIWFIRSTPRIV + 0x1B, IW_PRIV_TYPE_CHAR | 128, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_MASK, "efuse_get"},
+	{
+		SIOCIWFIRSTPRIV + 0x1D,
+		IW_PRIV_TYPE_CHAR | 40, IW_PRIV_TYPE_CHAR | 0x7FF, "test"
+	},
+
+
+};
+
+
+#if (WIRELESS_EXT >= 17)
+static struct iw_statistics *rtw_get_wireless_stats(struct net_device *ndev)
+{
+	struct rtl_priv *rtlpriv = rtl_priv(ndev);
+	struct iw_statistics *piwstats = &rtlpriv->iwstats;
+	int tmp_level = 0;
+	int tmp_qual = 0;
+	int tmp_noise = 0;
+
+	if (check_fwstate(&rtlpriv->mlmepriv, _FW_LINKED) != true) {
+		piwstats->qual.qual = 0;
+		piwstats->qual.level = 0;
+		piwstats->qual.noise = 0;
+		/* DBG_871X("No link  level:%d, qual:%d, noise:%d\n", tmp_level, tmp_qual, tmp_noise); */
+	} else {
+		tmp_level = rtlpriv->recvpriv.signal_strength;
+
+		tmp_qual = rtlpriv->recvpriv.signal_qual;
+		tmp_noise = rtlpriv->recvpriv.noise;
+		/* DBG_871X("level:%d, qual:%d, noise:%d, rssi (%d)\n", tmp_level, tmp_qual, tmp_noise,rtlpriv->recvpriv.rssi); */
+
+		piwstats->qual.level = tmp_level;
+		piwstats->qual.qual = tmp_qual;
+		piwstats->qual.noise = tmp_noise;
+	}
+	piwstats->qual.updated = IW_QUAL_ALL_UPDATED ;	/* |IW_QUAL_DBM; */
+
+	return &rtlpriv->iwstats;
+}
+#endif
+
+#ifdef CONFIG_WIRELESS_EXT
+struct iw_handler_def rtw_handlers_def = {
+	.standard = rtw_handlers,
+	.num_standard = sizeof(rtw_handlers) / sizeof(iw_handler),
+#if WIRELESS_EXT >= 17
+	.get_wireless_stats = rtw_get_wireless_stats,
+#endif
+};
+#endif
+
+/* copy from net/wireless/wext.c start */
+/* ---------------------------------------------------------------- */
+/*
+ * Calculate size of private arguments
+ */
+static const char iw_priv_type_size[] = {
+	0,                              /* IW_PRIV_TYPE_NONE */
+	1,                              /* IW_PRIV_TYPE_BYTE */
+	1,                              /* IW_PRIV_TYPE_CHAR */
+	0,                              /* Not defined */
+	sizeof(__u32),                  /* IW_PRIV_TYPE_INT */
+	sizeof(struct iw_freq),         /* IW_PRIV_TYPE_FLOAT */
+	sizeof(struct sockaddr),        /* IW_PRIV_TYPE_ADDR */
+	0,                              /* Not defined */
+};
+
+static int get_priv_size(u16 args)
+{
+	int num = args & IW_PRIV_SIZE_MASK;
+	int type = (args & IW_PRIV_TYPE_MASK) >> 12;
+
+	return num * iw_priv_type_size[type];
+}
+/* copy from net/wireless/wext.c end */
+
+int rtw_ioctl(struct net_device *ndev, struct ifreq *rq, int cmd)
+{
+	struct iwreq *wrq = (struct iwreq *)rq;
+	int ret = 0;
+
+	switch (cmd) {
+	case RTL_IOCTL_WPA_SUPPLICANT:
+		ret = wpa_supplicant_ioctl(ndev, &wrq->u.data);
+		break;
+#ifdef CONFIG_AP_MODE
+	case RTL_IOCTL_HOSTAPD:
+		ret = rtw_hostapd_ioctl(ndev, &wrq->u.data);
+		break;
+#endif
+	default:
+		ret = -EOPNOTSUPP;
+		break;
+	}
+
+	return ret;
+}
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/os_dep/mlme_linux.c linux-4.9.8821au/drivers/staging/rtl8821au/os_dep/mlme_linux.c
--- linux-4.9/drivers/staging/rtl8821au/os_dep/mlme_linux.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/os_dep/mlme_linux.c	2016-12-11 19:48:25.176978367 -0600
@@ -0,0 +1,344 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+
+#define _MLME_OSDEP_C_
+
+#include <net/iw_handler.h>
+#include <linux/if_arp.h>
+
+#include <drv_types.h>
+
+#undef DBG_871X
+static inline void DBG_871X(const char *fmt, ...)
+{
+}
+
+/*
+void sitesurvey_ctrl_handler(void *FunctionContext)
+{
+	struct rtl_priv *rtlpriv = (struct rtl_priv *)FunctionContext;
+
+	_sitesurvey_ctrl_handler(rtlpriv);
+
+	_set_timer(&rtlpriv->mlmepriv.sitesurveyctrl.sitesurvey_ctrl_timer, 3000);
+}
+*/
+
+void rtw_join_timeout_handler (void *FunctionContext)
+{
+	struct rtl_priv *rtlpriv = (struct rtl_priv *)FunctionContext;
+	_rtw_join_timeout_handler(rtlpriv);
+}
+
+
+void _rtw_scan_timeout_handler (void *FunctionContext)
+{
+	struct rtl_priv *rtlpriv = (struct rtl_priv *)FunctionContext;
+	rtw_scan_timeout_handler(rtlpriv);
+}
+
+
+void _dynamic_check_timer_handlder (void *FunctionContext)
+{
+	struct rtl_priv *rtlpriv = (struct rtl_priv *)FunctionContext;
+
+	rtw_dynamic_check_timer_handlder(rtlpriv);
+
+	_set_timer(&rtlpriv->mlmepriv.dynamic_chk_timer, 2000);
+}
+
+void rtw_init_mlme_timer(struct rtl_priv *rtlpriv)
+{
+	struct	mlme_priv *pmlmepriv = &rtlpriv->mlmepriv;
+
+	_init_timer(&(pmlmepriv->assoc_timer), rtlpriv->ndev, rtw_join_timeout_handler, rtlpriv);
+	//_init_timer(&(pmlmepriv->sitesurveyctrl.sitesurvey_ctrl_timer), rtlpriv->ndev, sitesurvey_ctrl_handler, rtlpriv);
+	_init_timer(&(pmlmepriv->scan_to_timer), rtlpriv->ndev, _rtw_scan_timeout_handler, rtlpriv);
+
+	_init_timer(&(pmlmepriv->dynamic_chk_timer), rtlpriv->ndev, _dynamic_check_timer_handlder, rtlpriv);
+}
+
+extern void rtw_indicate_wx_assoc_event(struct rtl_priv *rtlpriv);
+extern void rtw_indicate_wx_disassoc_event(struct rtl_priv *rtlpriv);
+
+void rtw_os_indicate_connect(struct rtl_priv *rtlpriv)
+{
+
+
+
+	rtw_indicate_wx_assoc_event(rtlpriv);
+	netif_carrier_on(rtlpriv->ndev);
+
+
+
+}
+
+extern void indicate_wx_scan_complete_event(struct rtl_priv *rtlpriv);
+void rtw_os_indicate_scan_done( struct rtl_priv *rtlpriv, bool aborted)
+{
+	indicate_wx_scan_complete_event(rtlpriv);
+}
+
+static RT_PMKID_LIST   backupPMKIDList[ NUM_PMKID_CACHE ];
+void rtw_reset_securitypriv( struct rtl_priv *rtlpriv )
+{
+	uint8_t	backupPMKIDIndex = 0;
+	uint8_t	backupTKIPCountermeasure = 0x00;
+	u32	backupTKIPcountermeasure_time = 0;
+
+	if(rtlpriv->securitypriv.dot11AuthAlgrthm == dot11AuthAlgrthm_8021X)//802.1x
+	{
+		// Added by Albert 2009/02/18
+		// We have to backup the PMK information for WiFi PMK Caching test item.
+		//
+		// Backup the btkip_countermeasure information.
+		// When the countermeasure is trigger, the driver have to disconnect with AP for 60 seconds.
+
+		memset( &backupPMKIDList[ 0 ], 0x00, sizeof( RT_PMKID_LIST ) * NUM_PMKID_CACHE );
+
+		memcpy( &backupPMKIDList[ 0 ], &rtlpriv->securitypriv.PMKIDList[ 0 ], sizeof( RT_PMKID_LIST ) * NUM_PMKID_CACHE );
+		backupPMKIDIndex = rtlpriv->securitypriv.PMKIDIndex;
+		backupTKIPCountermeasure = rtlpriv->securitypriv.btkip_countermeasure;
+		backupTKIPcountermeasure_time = rtlpriv->securitypriv.btkip_countermeasure_time;
+
+		memset((unsigned char *)&rtlpriv->securitypriv, 0, sizeof (struct security_priv));
+		//_init_timer(&(rtlpriv->securitypriv.tkip_timer),rtlpriv->ndev, rtw_use_tkipkey_handler, rtlpriv);
+
+		// Added by Albert 2009/02/18
+		// Restore the PMK information to securitypriv structure for the following connection.
+		memcpy( &rtlpriv->securitypriv.PMKIDList[ 0 ], &backupPMKIDList[ 0 ], sizeof( RT_PMKID_LIST ) * NUM_PMKID_CACHE );
+		rtlpriv->securitypriv.PMKIDIndex = backupPMKIDIndex;
+		rtlpriv->securitypriv.btkip_countermeasure = backupTKIPCountermeasure;
+		rtlpriv->securitypriv.btkip_countermeasure_time = backupTKIPcountermeasure_time;
+
+		rtlpriv->securitypriv.ndisauthtype = Ndis802_11AuthModeOpen;
+		rtlpriv->securitypriv.ndisencryptstatus = Ndis802_11WEPDisabled;
+
+	}
+	else //reset values in securitypriv
+	{
+		//if(rtlpriv->mlmepriv.fw_state & WIFI_STATION_STATE)
+		//{
+		struct security_priv *psec_priv=&rtlpriv->securitypriv;
+
+		psec_priv->dot11AuthAlgrthm =dot11AuthAlgrthm_Open;  //open system
+		psec_priv->dot11PrivacyAlgrthm = NO_ENCRYPTION;
+		psec_priv->dot11PrivacyKeyIndex = 0;
+
+		psec_priv->dot118021XGrpPrivacy = NO_ENCRYPTION;
+		psec_priv->dot118021XGrpKeyid = 1;
+
+		psec_priv->ndisauthtype = Ndis802_11AuthModeOpen;
+		psec_priv->ndisencryptstatus = Ndis802_11WEPDisabled;
+		//}
+	}
+}
+
+void rtw_os_indicate_disconnect( struct rtl_priv *rtlpriv )
+{
+   //RT_PMKID_LIST   backupPMKIDList[ NUM_PMKID_CACHE ];
+
+
+
+	netif_carrier_off(rtlpriv->ndev); // Do it first for tx broadcast pkt after disconnection issue!
+
+	rtw_indicate_wx_disassoc_event(rtlpriv);
+
+	 rtw_reset_securitypriv( rtlpriv );
+
+
+
+}
+
+void rtw_report_sec_ie(struct rtl_priv *rtlpriv,uint8_t authmode,uint8_t *sec_ie)
+{
+	uint	len;
+	uint8_t	*buff,*p,i;
+	union iwreq_data wrqu;
+
+
+
+	buff = NULL;
+	if(authmode==_WPA_IE_ID_)
+	{
+		buff = rtw_malloc(IW_CUSTOM_MAX);
+
+		memset(buff,0,IW_CUSTOM_MAX);
+
+		p=buff;
+
+		p+=sprintf(p,"ASSOCINFO(ReqIEs=");
+
+		len = sec_ie[1]+2;
+		len =  (len < IW_CUSTOM_MAX) ? len:IW_CUSTOM_MAX;
+
+		for(i=0;i<len;i++){
+			p+=sprintf(p,"%02x",sec_ie[i]);
+		}
+
+		p+=sprintf(p,")");
+
+		memset(&wrqu,0,sizeof(wrqu));
+
+		wrqu.data.length=p-buff;
+
+		wrqu.data.length = (wrqu.data.length<IW_CUSTOM_MAX) ? wrqu.data.length:IW_CUSTOM_MAX;
+
+		wireless_send_event(rtlpriv->ndev,IWEVCUSTOM,&wrqu,buff);
+
+		if(buff)
+		    rtw_mfree(buff);
+
+	}
+
+
+
+}
+
+void _survey_timer_hdl (void *FunctionContext)
+{
+	struct rtl_priv *rtlpriv = (struct rtl_priv *)FunctionContext;
+
+	survey_timer_hdl(rtlpriv);
+}
+
+void _link_timer_hdl (void *FunctionContext)
+{
+	struct rtl_priv *rtlpriv = (struct rtl_priv *)FunctionContext;
+	link_timer_hdl(rtlpriv);
+}
+
+void _addba_timer_hdl(void *FunctionContext)
+{
+	struct sta_info *psta = (struct sta_info *)FunctionContext;
+	addba_timer_hdl(psta);
+}
+
+void init_addba_retry_timer(struct rtl_priv *rtlpriv, struct sta_info *psta)
+{
+
+	_init_timer(&psta->addba_retry_timer, rtlpriv->ndev, _addba_timer_hdl, psta);
+}
+
+/*
+void _reauth_timer_hdl(void *FunctionContext)
+{
+	struct rtl_priv *rtlpriv = (struct rtl_priv *)FunctionContext;
+	reauth_timer_hdl(rtlpriv);
+}
+
+void _reassoc_timer_hdl(void *FunctionContext)
+{
+	struct rtl_priv *rtlpriv = (struct rtl_priv *)FunctionContext;
+	reassoc_timer_hdl(rtlpriv);
+}
+*/
+
+void init_mlme_ext_timer(struct rtl_priv *rtlpriv)
+{
+	struct	mlme_ext_priv *pmlmeext = &rtlpriv->mlmeextpriv;
+
+	_init_timer(&pmlmeext->survey_timer, rtlpriv->ndev, _survey_timer_hdl, rtlpriv);
+	_init_timer(&pmlmeext->link_timer, rtlpriv->ndev, _link_timer_hdl, rtlpriv);
+	//_init_timer(&pmlmeext->ADDBA_timer, rtlpriv->ndev, _addba_timer_hdl, rtlpriv);
+
+	//_init_timer(&pmlmeext->reauth_timer, rtlpriv->ndev, _reauth_timer_hdl, rtlpriv);
+	//_init_timer(&pmlmeext->reassoc_timer, rtlpriv->ndev, _reassoc_timer_hdl, rtlpriv);
+}
+
+uint8_t rtw_handle_tkip_countermeasure(struct rtl_priv* rtlpriv)
+{
+	uint8_t status = _SUCCESS;
+	u32 cur_time = 0;
+
+	if (rtlpriv->securitypriv.btkip_countermeasure == true) {
+		cur_time = jiffies;
+
+		if( (cur_time - rtlpriv->securitypriv.btkip_countermeasure_time) > 60 * HZ )
+		{
+			rtlpriv->securitypriv.btkip_countermeasure = false;
+			rtlpriv->securitypriv.btkip_countermeasure_time = 0;
+		}
+		else
+		{
+			status = _FAIL;
+		}
+	}
+
+	return status;
+
+}
+
+#ifdef CONFIG_AP_MODE
+
+void rtw_indicate_sta_assoc_event(struct rtl_priv *rtlpriv, struct sta_info *psta)
+{
+	union iwreq_data wrqu;
+	struct sta_priv *pstapriv = &rtlpriv->stapriv;
+
+	if(psta==NULL)
+		return;
+
+	if(psta->aid > NUM_STA)
+		return;
+
+	if(pstapriv->sta_aid[psta->aid - 1] != psta)
+		return;
+
+
+	wrqu.addr.sa_family = ARPHRD_ETHER;
+
+	memcpy(wrqu.addr.sa_data, psta->hwaddr, ETH_ALEN);
+
+	DBG_871X("+rtw_indicate_sta_assoc_event\n");
+
+	wireless_send_event(rtlpriv->ndev, IWEVREGISTERED, &wrqu, NULL);
+
+}
+
+void rtw_indicate_sta_disassoc_event(struct rtl_priv *rtlpriv, struct sta_info *psta)
+{
+	union iwreq_data wrqu;
+	struct sta_priv *pstapriv = &rtlpriv->stapriv;
+
+	if(psta==NULL)
+		return;
+
+	if(psta->aid > NUM_STA)
+		return;
+
+	if(pstapriv->sta_aid[psta->aid - 1] != psta)
+		return;
+
+
+	wrqu.addr.sa_family = ARPHRD_ETHER;
+
+	memcpy(wrqu.addr.sa_data, psta->hwaddr, ETH_ALEN);
+
+	DBG_871X("+rtw_indicate_sta_disassoc_event\n");
+
+	wireless_send_event(rtlpriv->ndev, IWEVEXPIRED, &wrqu, NULL);
+
+}
+
+
+#endif
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/os_dep/osdep_service.c linux-4.9.8821au/drivers/staging/rtl8821au/os_dep/osdep_service.c
--- linux-4.9/drivers/staging/rtl8821au/os_dep/osdep_service.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/os_dep/osdep_service.c	2016-12-11 19:48:25.176978367 -0600
@@ -0,0 +1,245 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+
+#define _OSDEP_SERVICE_C_
+
+#include <linux/vmalloc.h>
+#include <drv_types.h>
+
+#undef DBG_871X
+static inline void DBG_871X(const char *fmt, ...)
+{
+}
+
+#define RT_TAG	('1178')
+
+u32 rtw_atoi(u8 *s)
+{
+	int num = 0, flag = 0;
+	int i;
+
+	for (i = 0; i <= strlen(s); i++) {
+		if (s[i] >= '0' && s[i] <= '9')
+			num = num * 10 + s[i] - '0';
+		else if (s[0] == '-' && i == 0)
+			flag = 1;
+		else
+			break;
+	 }
+
+		if (flag == 1)
+			num = num * -1;
+
+	 return num;
+
+}
+
+void *_rtw_vmalloc(u32 sz)
+{
+	u8 	*pbuf;
+	pbuf = vmalloc(sz);
+
+	return pbuf;
+}
+
+void *_rtw_zvmalloc(u32 sz)
+{
+	u8 *pbuf;
+
+	pbuf = _rtw_vmalloc(sz);
+	if (pbuf != NULL)
+		memset(pbuf, 0, sz);
+
+	return pbuf;
+}
+
+inline void _rtw_vmfree(void *pbuf)
+{
+	vfree(pbuf);
+}
+
+void *_rtw_malloc(u32 sz)
+{
+	u8 *pbuf = NULL;
+
+	pbuf = kmalloc(sz, in_interrupt() ? GFP_ATOMIC : GFP_KERNEL);
+
+	return pbuf;
+}
+
+
+void *_rtw_zmalloc(u32 sz)
+{
+	u8 *pbuf = _rtw_malloc(sz);
+
+	if (pbuf != NULL) {
+		memset(pbuf, 0, sz);
+	}
+
+	return pbuf;
+}
+
+void	_rtw_mfree(void *pbuf)
+{
+	kfree(pbuf);
+}
+
+
+void *rtw_malloc2d(int h, int w, int size)
+{
+	int j;
+
+	void **a = (void **) rtw_zmalloc(h*sizeof(void *) + h*w*size);
+
+	if (a == NULL) {
+		DBG_871X("%s: alloc memory fail!\n", __FUNCTION__);
+		return NULL;
+	}
+
+	for (j = 0; j < h; j++)
+		a[j] = ((char *)(a+h)) + j * w * size;
+
+	return a;
+}
+
+void rtw_mfree2d(void *pbuf, int h, int w, int size)
+{
+	rtw_mfree(pbuf);
+}
+
+int _rtw_memcmp(void *dst, void *src, u32 sz)
+{
+	if (!(memcmp(dst, src, sz)))
+		return true;
+	else
+		return false;
+}
+
+void _rtw_init_queue(struct __queue *pqueue)
+{
+
+	INIT_LIST_HEAD(&(pqueue->list));
+
+	spin_lock_init(&(pqueue->lock));
+
+}
+
+u32 rtw_end_of_queue_search(struct list_head *head, struct list_head *plist)
+{
+	if (head == plist)
+		return true;
+	else
+		return false;
+}
+
+inline u32 rtw_systime_to_ms(u32 systime)
+{
+	return systime * 1000 / HZ;
+}
+
+inline u32 rtw_ms_to_systime(u32 ms)
+{
+	return ms * HZ / 1000;
+}
+
+/*
+ *  the input parameter start use the same unit as returned by jiffies
+ */
+inline int32_t rtw_get_passing_time_ms(u32 start)
+{
+	return rtw_systime_to_ms(jiffies-start);
+}
+
+inline int32_t rtw_get_time_interval_ms(u32 start, u32 end)
+{
+	return rtw_systime_to_ms(end-start);
+}
+
+
+void rtw_usleep_os(int us)
+{
+	if (1 < (us/1000))
+		msleep(1);
+	else
+		msleep((us/1000) + 1);
+}
+
+void rtw_yield_os(void)
+{
+	yield();
+}
+
+u64 rtw_modular64(u64 x, u64 y)
+{
+	return do_div(x, y);
+}
+
+void rtw_buf_free(u8 **buf, u32 *buf_len)
+{
+	u32 ori_len;
+
+	if (!buf || !buf_len)
+		return;
+
+	ori_len = *buf_len;
+
+	if (*buf) {
+		*buf_len = 0;
+		_rtw_mfree(*buf);
+		*buf = NULL;
+	}
+}
+
+void rtw_buf_update(u8 **buf, u32 *buf_len, u8 *src, u32 src_len)
+{
+	u32 ori_len = 0, dup_len = 0;
+	u8 *ori = NULL;
+	u8 *dup = NULL;
+
+	if (!buf || !buf_len)
+		return;
+
+	if (!src || !src_len)
+		goto keep_ori;
+
+	/* duplicate src */
+	dup = rtw_malloc(src_len);
+	if (dup) {
+		dup_len = src_len;
+		memcpy(dup, src, dup_len);
+	}
+
+keep_ori:
+	ori = *buf;
+	ori_len = *buf_len;
+
+	/* replace buf with dup */
+	*buf_len = 0;
+	*buf = dup;
+	*buf_len = dup_len;
+
+	/* free ori */
+	if (ori && ori_len > 0) {
+	/* ULLI check usage of param ori_len */
+		_rtw_mfree(ori);
+	}
+}
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/os_dep/os_intfs.c linux-4.9.8821au/drivers/staging/rtl8821au/os_dep/os_intfs.c
--- linux-4.9/drivers/staging/rtl8821au/os_dep/os_intfs.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/os_dep/os_intfs.c	2016-12-11 19:48:25.176978367 -0600
@@ -0,0 +1,291 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#define _OS_INTFS_C_
+
+#include <linux/ip.h>
+#include <linux/kthread.h>
+
+#include <drv_types.h>
+
+/* module param defaults */
+static int rtw_channel = 1;/* ad-hoc support requirement */
+static int rtw_rts_thresh = 2347;
+static int rtw_preamble = PREAMBLE_LONG;	/* long, short, auto */
+static int rtw_adhoc_tx_pwr = 1;
+static int rtw_soft_ap = 0;
+				/* int smart_ps = 1; */
+#ifdef CONFIG_POWER_SAVING
+static int rtw_power_mgnt = 1;
+#else
+static int rtw_power_mgnt = PS_MODE_ACTIVE;
+#endif
+
+static int rtw_smart_ps = 2;
+
+
+static int rtw_long_retry_lmt = 7;
+static int rtw_short_retry_lmt = 7;
+static int rtw_busy_thresh = 40;
+/* int qos_enable = 0; */
+static int rtw_ack_policy = NORMAL_ACK;
+
+static int rtw_acm_method = 0;			/* 0:By SW 1:By HW. */
+
+static int rtw_wmm_enable = 1;		/* default is set to enable the wmm. */
+static int rtw_uapsd_enable = 0;
+
+/*
+ *  0: 20 MHz, 1: 40 MHz, 2: 80 MHz, 3: 160MHz, 4: 80+80MHz
+ *  2.4G use bit 0 ~ 3, 5G use bit 4 ~ 7
+ * 0x21 means enable 2.4G 40MHz & 5G 80MHz
+ */
+static int rtw_rx_stbc = 1;		/* 0: disable, bit(0):enable 2.4g, bit(1):enable 5g, default is set to enable 2.4GHZ for IOT issue with bufflao's AP at 5GHZ */
+
+static int rtw_ampdu_amsdu = 0;/*  0: disabled, 1:enabled, 2:auto */
+/*
+ *  Short GI support Bit Map
+ *  BIT0 - 20MHz, 0: support, 1: non-support
+ *  BIT1 - 40MHz, 0: support, 1: non-support
+ *  BIT2 - 80MHz, 0: support, 1: non-support
+ *  BIT3 - 160MHz, 0: support, 1: non-support
+ */
+
+/*
+ *
+ *  BIT0: Enable VHT LDPC Rx,
+ *  BIT1: Enable VHT LDPC Tx,
+ *  BIT4: Enable HT LDPC Rx,
+ *  BIT5: Enable HT LDPC Tx
+ */
+/*  BIT0: Enable VHT STBC Rx,
+ *  BIT1: Enable VHT STBC Tx,
+ *  BIT4: Enable HT STBC Rx,
+ *  BIT5: Enable HT STBC Tx
+ */
+/*
+ * BIT0: Enable VHT Beamformer,
+ * BIT1: Enable VHT Beamformee,
+ * BIT4: Enable HT Beamformer,
+ * BIT5: Enable HT Beamformee
+ */
+static int rtw_beamform_cap = 0;
+
+static int rtw_low_power = 0;
+
+static int rtw_AcceptAddbaReq = true;/* 0:Reject AP's Add BA req, 1:Accept AP's Add BA req. */
+
+static int rtw_enusbss = 0;	/* 0:disable,1:enable */
+
+static int rtw_hwpdn_mode = 2;	/* 0:disable,1:enable,2: by EFUSE config */
+
+static int rtw_hwpwrp_detect = 0; /* HW power  ping detect 0:disable , 1:enable */
+
+/* ULLI: check var rtw_hw_wps_pbc */
+static int rtw_hw_wps_pbc = 1;
+
+#ifdef CONFIG_TX_MCAST2UNI
+int __rtw_mc2u_disable = 0;
+#endif
+
+char *__rtw_initmac = 0;  /* temp mac address if users want to use instead of the mac address in Efuse */
+
+
+
+module_param(__rtw_initmac, charp, 0644);
+module_param(rtw_channel, int, 0644);
+module_param(rtw_wmm_enable, int, 0644);
+module_param(rtw_busy_thresh, int, 0644);
+
+module_param(rtw_rx_stbc, int, 0644);
+module_param(rtw_ampdu_amsdu, int, 0644);
+
+module_param(rtw_power_mgnt, int, 0644);
+module_param(rtw_smart_ps, int, 0644);
+module_param(rtw_low_power, int, 0644);
+
+module_param(rtw_enusbss, int, 0644);
+module_param(rtw_hwpdn_mode, int, 0644);
+module_param(rtw_hwpwrp_detect, int, 0644);
+
+module_param(rtw_hw_wps_pbc, int, 0644);
+
+#ifdef CONFIG_TX_MCAST2UNI
+module_param(__rtw_mc2u_disable, int, 0644);
+#endif
+
+uint loadparam(struct rtl_priv *rtlpriv, struct net_device *ndev)
+{
+
+	uint status = _SUCCESS;
+	struct registry_priv  *registry_par = &rtlpriv->registrypriv;
+
+	memcpy(registry_par->ssid.Ssid, "ANY", 3);
+	registry_par->ssid.SsidLength = 3;
+
+	registry_par->channel = (uint8_t)rtw_channel;
+
+	if (IsSupported24G(WIRELESS_MODE_MAX) && (!IsSupported5G(WIRELESS_MODE_MAX))
+		&& (registry_par->channel > 14)) {
+		registry_par->channel = 1;
+	} else if (IsSupported5G(WIRELESS_MODE_MAX) && (!IsSupported24G(WIRELESS_MODE_MAX))
+		&& (registry_par->channel <= 14)) {
+		registry_par->channel = 36;
+	}
+
+	registry_par->rts_thresh = (u16)rtw_rts_thresh;
+	registry_par->preamble = (uint8_t)rtw_preamble;
+	registry_par->adhoc_tx_pwr = (uint8_t)rtw_adhoc_tx_pwr;
+	registry_par->soft_ap =  (uint8_t)rtw_soft_ap;
+	registry_par->smart_ps =  (uint8_t)rtw_smart_ps;
+	registry_par->power_mgnt = (uint8_t)rtw_power_mgnt;
+	registry_par->long_retry_lmt = (uint8_t)rtw_long_retry_lmt;
+	registry_par->short_retry_lmt = (uint8_t)rtw_short_retry_lmt;
+	registry_par->busy_thresh = (u16)rtw_busy_thresh;
+	/* registry_par->qos_enable = (uint8_t)rtw_qos_enable; */
+	registry_par->ack_policy = (uint8_t)rtw_ack_policy;
+
+	registry_par->acm_method = (uint8_t)rtw_acm_method;
+
+	 /* UAPSD */
+	registry_par->wmm_enable = (uint8_t)rtw_wmm_enable;
+	registry_par->uapsd_enable = (uint8_t)rtw_uapsd_enable;
+
+	registry_par->rx_stbc = (uint8_t)rtw_rx_stbc;
+	registry_par->ampdu_amsdu = (uint8_t)rtw_ampdu_amsdu;
+
+	registry_par->beamform_cap = (uint8_t)rtw_beamform_cap;
+	registry_par->low_power = (uint8_t)rtw_low_power;
+
+	registry_par->bAcceptAddbaReq = (uint8_t)rtw_AcceptAddbaReq;
+
+#ifdef CONFIG_AUTOSUSPEND
+	registry_par->usbss_enable = (uint8_t)rtw_enusbss;	/* 0:disable,1:enable */
+#endif
+
+	registry_par->hw_wps_pbc = (uint8_t)rtw_hw_wps_pbc;
+
+	return status;
+}
+
+struct net_device_stats *rtw_net_get_stats(struct net_device *ndev)
+{
+	struct rtl_priv *rtlpriv = rtl_priv(ndev);
+	struct xmit_priv *pxmitpriv = &(rtlpriv->xmitpriv);
+	struct recv_priv *precvpriv = &(rtlpriv->recvpriv);
+
+	rtlpriv->stats.tx_packets = pxmitpriv->tx_pkts;	/* pxmitpriv->tx_pkts++; */
+	rtlpriv->stats.rx_packets = precvpriv->rx_pkts;	/* precvpriv->rx_pkts++; */
+	rtlpriv->stats.tx_dropped = pxmitpriv->tx_drop;
+	rtlpriv->stats.rx_dropped = precvpriv->rx_drop;
+	rtlpriv->stats.tx_bytes = pxmitpriv->tx_bytes;
+	rtlpriv->stats.rx_bytes = precvpriv->rx_bytes;
+
+	return &rtlpriv->stats;
+}
+
+/*
+ * AC to queue mapping
+ *
+ * AC_VO -> queue 0
+ * AC_VI -> queue 1
+ * AC_BE -> queue 2
+ * AC_BK -> queue 3
+ */
+static const u16 rtw_1d_to_queue[8] = { 2, 3, 3, 2, 1, 1, 0, 0 };
+
+/* Given a data frame determine the 802.1p/1d tag to use. */
+unsigned int rtw_classify8021d(struct sk_buff *skb)
+{
+	unsigned int dscp;
+
+	/* skb->priority values from 256->263 are magic values to
+	 * directly indicate a specific 802.1d priority.  This is used
+	 * to allow 802.1d priority to be passed directly in from VLAN
+	 * tags, etc.
+	 */
+	if (skb->priority >= 256 && skb->priority <= 263)
+		return skb->priority - 256;
+
+	switch (skb->protocol) {
+	case htons(ETH_P_IP):
+		dscp = ip_hdr(skb)->tos & 0xfc;
+		break;
+	default:
+		return 0;
+	}
+
+	return dscp >> 5;
+}
+
+u16 rtw_recv_select_queue(struct sk_buff *skb)
+{
+	struct iphdr *piphdr;
+	unsigned int dscp;
+	u16	eth_type;
+	u32 priority;
+	uint8_t *pdata = skb->data;
+
+	memcpy(&eth_type, pdata+(ETH_ALEN<<1), 2);
+
+	switch (eth_type) {
+	case htons(ETH_P_IP):
+
+		piphdr = (struct iphdr *)(pdata+ETH_HLEN);
+
+		dscp = piphdr->tos & 0xfc;
+
+		priority = dscp >> 5;
+
+		break;
+	default:
+		priority = 0;
+	}
+
+	return rtw_1d_to_queue[priority];
+
+}
+
+u32 rtw_start_drv_threads(struct rtl_priv *rtlpriv)
+{
+	u32 _status = _SUCCESS;
+	int _unused;
+
+	{
+		rtlpriv->cmdThread = kthread_run(rtw_cmd_thread, rtlpriv, "RTW_CMD_THREAD");
+		if (IS_ERR(rtlpriv->cmdThread))
+			_status = _FAIL;
+		else
+			_unused = down_interruptible(&rtlpriv->cmdpriv.terminate_cmdthread_sema); /* wait for cmd_thread to run */
+	}
+	return _status;
+
+}
+
+void rtw_stop_drv_threads(struct rtl_priv *rtlpriv)
+{
+	int _unused;
+
+	/* Below is to termindate rtw_cmd_thread & event_thread... */
+	up(&rtlpriv->cmdpriv.cmd_queue_sema);
+	/* up(&rtlpriv->cmdpriv.cmd_done_sema); */
+	if (rtlpriv->cmdThread) {
+		_unused = down_interruptible(&rtlpriv->cmdpriv.terminate_cmdthread_sema);
+	}
+}
diff -Naur linux-4.9/drivers/staging/rtl8821au/os_dep/recv_linux.c linux-4.9.8821au/drivers/staging/rtl8821au/os_dep/recv_linux.c
--- linux-4.9/drivers/staging/rtl8821au/os_dep/recv_linux.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/os_dep/recv_linux.c	2016-12-11 19:48:25.176978367 -0600
@@ -0,0 +1,374 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#define _RECV_OSDEP_C_
+
+#include <linux/etherdevice.h>
+#include <net/iw_handler.h>
+#include <linux/if_arp.h>
+
+#include <drv_types.h>
+
+#undef DBG_871X
+static inline void DBG_871X(const char *fmt, ...)
+{
+}
+
+int rtw_os_alloc_recvframe(struct rtl_priv *rtlpriv, struct recv_frame *precvframe, uint8_t *pdata, struct sk_buff *pskb)
+{
+	int res = _SUCCESS;
+	uint8_t	shift_sz = 0;
+	u32	skb_len, alloc_sz;
+	struct sk_buff *pkt_copy = NULL;
+	struct rx_pkt_attrib *pattrib = &precvframe->attrib;
+
+
+	if(pdata == NULL) {
+		precvframe->skb = NULL;
+		res = _FAIL;
+		return res;
+	}
+
+
+	/*
+	 * 	Modified by Albert 20101213
+	 * 	For 8 bytes IP header alignment.
+	 */
+	shift_sz = pattrib->qos ? 6:0;	/* Qos data, wireless lan header length is 26 */
+
+	skb_len = pattrib->pkt_len;
+
+	/*
+	 *  for first fragment packet, driver need allocate 1536+drvinfo_sz+RXDESC_SIZE to defrag packet.
+	 *  modify alloc_sz for recvive crc error packet by thomas 2011-06-02
+	 */
+	if((pattrib->mfrag == 1)&&(pattrib->frag_num == 0)) {
+		/* alloc_sz = 1664;	//1664 is 128 alignment. */
+		alloc_sz = (skb_len <= 1650) ? 1664:(skb_len + 14);
+	} else {
+		alloc_sz = skb_len;
+		/*
+		 * 6 is for IP header 8 bytes alignment in QoS packet case.
+		 * 8 is for skb->data 4 bytes alignment.
+		 */
+		alloc_sz += 14;
+	}
+
+	/* ULLI : why copy skb */
+
+	pkt_copy = netdev_alloc_skb(rtlpriv->ndev, alloc_sz);
+
+	if(pkt_copy) {
+		pkt_copy->dev = rtlpriv->ndev;
+		precvframe->skb = pkt_copy;
+		precvframe->rx_head = pkt_copy->data;
+		precvframe->rx_end = pkt_copy->data + alloc_sz;
+		skb_reserve(pkt_copy, 8 - ((__kernel_size_t)( pkt_copy->data) & 7 ));	/* force pkt_copy->data at 8-byte alignment address */
+		skb_reserve(pkt_copy, shift_sz);				/* force ip_hdr at 8-byte alignment address according to shift_sz. */
+		memcpy(pkt_copy->data, pdata, skb_len);
+		precvframe->rx_data = precvframe->rx_tail = pkt_copy->data;
+	} else 	{
+		if((pattrib->mfrag == 1)&&(pattrib->frag_num == 0)) {
+			DBG_871X("%s: alloc_skb fail , drop frag frame \n", __FUNCTION__);
+			/* rtw_free_recvframe(precvframe, pfree_recv_queue); */
+			res = _FAIL;
+			goto out;
+		}
+
+		if(pskb == NULL) {
+			res = _FAIL;
+			goto out;
+		}
+
+		precvframe->skb = skb_clone(pskb, GFP_ATOMIC);
+		if(precvframe->skb) {
+			precvframe->rx_head = precvframe->rx_data = precvframe->rx_tail = pdata;
+			precvframe->rx_end =  pdata + alloc_sz;
+		} else 	{
+			DBG_871X("%s: skb_clone fail\n", __FUNCTION__);
+			/*
+			 * rtw_free_recvframe(precvframe, pfree_recv_queue);
+			 * goto _exit_recvbuf2recvframe;
+			 */
+			res = _FAIL;
+		}
+	}
+
+out:
+	return res;
+
+}
+
+void rtw_os_free_recvframe(struct recv_frame *precvframe)
+{
+	if(precvframe->skb) {
+		dev_kfree_skb_any(precvframe->skb);	/* free skb by driver */
+
+		precvframe->skb = NULL;
+	}
+}
+
+/* alloc os related resource in struct recv_buf */
+int rtw_os_recvbuf_resource_alloc(struct rtl_priv *rtlpriv, struct recv_buf *precvbuf)
+{
+	int res=_SUCCESS;
+
+	struct rtl_usb *rtlusb = rtl_usbdev(rtlpriv);
+	struct usb_device *pusbd = rtlusb->udev;
+
+	precvbuf->irp_pending = false;
+	precvbuf->purb = usb_alloc_urb(0, GFP_KERNEL);
+	if(precvbuf->purb == NULL){
+		res = _FAIL;
+	}
+
+	precvbuf->skb = NULL;
+
+	precvbuf->reuse = false;
+
+	precvbuf->len = 0;
+
+	return res;
+}
+
+/* free os related resource in struct recv_buf */
+int rtw_os_recvbuf_resource_free(struct rtl_priv *rtlpriv, struct recv_buf *precvbuf)
+{
+	int ret = _SUCCESS;
+
+	if(precvbuf->purb) {
+		/* usb_kill_urb(precvbuf->purb); */
+		usb_free_urb(precvbuf->purb);
+	}
+
+	if(precvbuf->skb)
+		dev_kfree_skb_any(precvbuf->skb);
+
+
+	return ret;
+
+}
+
+struct sk_buff  *rtw_os_alloc_msdu_pkt(struct recv_frame *prframe, u16 nSubframe_Length, uint8_t *pdata)
+{
+	u16	eth_type;
+	uint8_t	*data_ptr;
+	struct sk_buff  *sub_skb;
+	struct rx_pkt_attrib *pattrib;
+
+	pattrib = &prframe->attrib;
+
+#ifdef CONFIG_SKB_COPY
+	sub_skb = dev_alloc_skb(nSubframe_Length + 12);
+	if(sub_skb) {
+		skb_reserve(sub_skb, 12);
+		data_ptr = (uint8_t *)skb_put(sub_skb, nSubframe_Length);
+		memcpy(data_ptr, (pdata + ETH_HLEN), nSubframe_Length);
+	} else
+#endif
+	{
+		/* ULLI : another place who clones skb */
+
+		sub_skb = skb_clone(prframe->skb, GFP_ATOMIC);
+		if(sub_skb) {
+			sub_skb->data = pdata + ETH_HLEN;
+			sub_skb->len = nSubframe_Length;
+			skb_set_tail_pointer(sub_skb, nSubframe_Length);
+		} else 	{
+			DBG_871X("%s(): skb_clone() Fail!!!\n",__FUNCTION__);
+			return NULL;
+		}
+	}
+
+	eth_type = RTW_GET_BE16(&sub_skb->data[6]);
+
+	if (sub_skb->len >= 8 &&
+		((_rtw_memcmp(sub_skb->data, rtw_rfc1042_header, SNAP_SIZE) &&
+		  eth_type != ETH_P_AARP && eth_type != ETH_P_IPX) ||
+		 _rtw_memcmp(sub_skb->data, rtw_bridge_tunnel_header, SNAP_SIZE) )) {
+		/* remove RFC1042 or Bridge-Tunnel encapsulation and replace EtherType */
+		skb_pull(sub_skb, SNAP_SIZE);
+		memcpy(skb_push(sub_skb, ETH_ALEN), pattrib->src, ETH_ALEN);
+		memcpy(skb_push(sub_skb, ETH_ALEN), pattrib->dst, ETH_ALEN);
+	} else {
+		u16 len;
+		/* Leave Ethernet header part of hdr and full payload */
+		len = htons(sub_skb->len);
+		memcpy(skb_push(sub_skb, 2), &len, 2);
+		memcpy(skb_push(sub_skb, ETH_ALEN), pattrib->src, ETH_ALEN);
+		memcpy(skb_push(sub_skb, ETH_ALEN), pattrib->dst, ETH_ALEN);
+	}
+
+	return sub_skb;
+}
+
+void rtw_os_recv_indicate_pkt(struct rtl_priv *rtlpriv, struct sk_buff *skb, struct rx_pkt_attrib *pattrib)
+{
+	struct mlme_priv*pmlmepriv = &rtlpriv->mlmepriv;
+
+	/* Indicat the packets to upper layer */
+	if (skb) {
+		if(check_fwstate(pmlmepriv, WIFI_AP_STATE) == true) {
+			struct sk_buff  *skb_dup = NULL;
+		 	struct sta_info *psta = NULL;
+		 	struct sta_priv *pstapriv = &rtlpriv->stapriv;
+
+			/* DBG_871X("bmcast=%d\n", bmcast); */
+
+			if(_rtw_memcmp(pattrib->dst, rtlpriv->mac80211.mac_addr, ETH_ALEN)==false) {
+				/* DBG_871X("not ap psta=%p, addr=%pM\n", psta, pattrib->dst); */
+
+				if(is_multicast_ether_addr(pattrib->dst)) {
+					psta = rtw_get_bcmc_stainfo(rtlpriv);
+					skb_dup = skb_clone(skb, GFP_ATOMIC);
+				} else {
+					psta = rtw_get_stainfo(pstapriv, pattrib->dst);
+				}
+
+				if(psta) {
+					struct net_device *ndev= (struct net_device*)rtlpriv->ndev;
+
+					/* DBG_871X("directly forwarding to the rtw_xmit_entry\n"); */
+
+					/* skb->ip_summed = CHECKSUM_NONE; */
+					skb->dev = ndev;
+					skb_set_queue_mapping(skb, rtw_recv_select_queue(skb));
+
+					rtw_xmit_entry(skb, ndev);
+
+					if(is_multicast_ether_addr(pattrib->dst) && (skb_dup != NULL) ) {
+						skb = skb_dup;
+					} else {
+						return;
+					}
+				}
+			}
+			else {
+				/* to APself */
+				/* DBG_871X("to APSelf\n"); */
+			}
+		}
+
+		skb->protocol = eth_type_trans(skb, rtlpriv->ndev);
+		skb->dev = rtlpriv->ndev;
+
+		skb->ip_summed = CHECKSUM_NONE;
+		netif_rx(skb);
+	}
+}
+
+void rtw_handle_tkip_mic_err(struct rtl_priv *rtlpriv,uint8_t bgroup)
+{
+	union iwreq_data wrqu;
+	struct iw_michaelmicfailure    ev;
+	struct mlme_priv*              pmlmepriv  = &rtlpriv->mlmepriv;
+	struct security_priv	*psecuritypriv = &rtlpriv->securitypriv;
+	u32 cur_time = 0;
+
+	if (psecuritypriv->last_mic_err_time == 0) {
+		psecuritypriv->last_mic_err_time = jiffies;
+	} else {
+		cur_time = jiffies;
+
+		if(cur_time - psecuritypriv->last_mic_err_time < 60*HZ) {
+			psecuritypriv->btkip_countermeasure = true;
+			psecuritypriv->last_mic_err_time = 0;
+			psecuritypriv->btkip_countermeasure_time = cur_time;
+		} else {
+			psecuritypriv->last_mic_err_time = jiffies;
+		}
+	}
+
+	memset(&ev, 0x00, sizeof(ev));
+	if (bgroup) {
+	    ev.flags |= IW_MICFAILURE_GROUP;
+	} else {
+	    ev.flags |= IW_MICFAILURE_PAIRWISE;
+	}
+
+	ev.src_addr.sa_family = ARPHRD_ETHER;
+	memcpy( ev.src_addr.sa_data, &pmlmepriv->assoc_bssid[ 0 ], ETH_ALEN );
+
+	memset( &wrqu, 0x00, sizeof( wrqu ) );
+	wrqu.data.length = sizeof( ev );
+
+	wireless_send_event( rtlpriv->ndev, IWEVMICHAELMICFAILURE, &wrqu, (char*) &ev );
+}
+
+
+int rtw_recv_indicatepkt(struct rtl_priv *rtlpriv, struct recv_frame *precv_frame)
+{
+	struct recv_priv *precvpriv;
+	struct __queue	*pfree_recv_queue;
+	struct sk_buff  *skb;
+	struct mlme_priv*pmlmepriv = &rtlpriv->mlmepriv;
+	struct rx_pkt_attrib *pattrib = &precv_frame->attrib;
+
+	precvpriv = &(rtlpriv->recvpriv);
+	pfree_recv_queue = &(precvpriv->free_recv_queue);
+
+	skb = precv_frame->skb;
+	if (skb == NULL) {
+		goto _recv_indicatepkt_drop;
+	}
+
+	skb->data = precv_frame->rx_data;
+
+	skb_set_tail_pointer(skb, precv_frame->len);
+
+	skb->len = precv_frame->len;
+
+	rtw_os_recv_indicate_pkt(rtlpriv, skb, pattrib);
+
+_recv_indicatepkt_end:
+
+	precv_frame->skb = NULL; 		/* pointers to NULL before rtw_free_recvframe() */
+
+	rtw_free_recvframe(precv_frame, pfree_recv_queue);
+
+
+        return _SUCCESS;
+
+_recv_indicatepkt_drop:
+
+	 /* enqueue back to free_recv_queue */
+	 if(precv_frame)
+		 rtw_free_recvframe(precv_frame, pfree_recv_queue);
+
+	 return _FAIL;
+
+
+
+}
+
+void _rtw_reordering_ctrl_timeout_handler (void *FunctionContext);
+void _rtw_reordering_ctrl_timeout_handler (void *FunctionContext)
+{
+	struct recv_reorder_ctrl *preorder_ctrl = (struct recv_reorder_ctrl *)FunctionContext;
+	rtw_reordering_ctrl_timeout_handler(preorder_ctrl);
+}
+
+void rtw_init_recv_timer(struct recv_reorder_ctrl *preorder_ctrl)
+{
+	struct rtl_priv *rtlpriv = preorder_ctrl->rtlpriv;
+
+	_init_timer(&(preorder_ctrl->reordering_ctrl_timer), rtlpriv->ndev, _rtw_reordering_ctrl_timeout_handler, preorder_ctrl);
+
+}
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/os_dep/usb_halinit.c linux-4.9.8821au/drivers/staging/rtl8821au/os_dep/usb_halinit.c
--- linux-4.9/drivers/staging/rtl8821au/os_dep/usb_halinit.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/os_dep/usb_halinit.c	2016-12-11 19:48:25.176978367 -0600
@@ -0,0 +1,224 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#define _HCI_HAL_INIT_C_
+
+#include <drv_types.h>
+#include <rtl8812a_hal.h>
+#include <../rtl8821au/phy.h>
+#include <../rtl8821au/reg.h>
+#include <../rtl8821au/trx.h>
+#include <../rtl8821au/hw.h>
+#include <../rtl8821au/fw.h>
+#include <hal_intf.h>
+
+#undef DBG_8192C
+static inline void DBG_8192C(const char *fmt, ...)
+{
+}
+
+static void _dbg_dump_macreg(struct rtl_priv *rtlpriv)
+{
+	uint32_t offset = 0;
+	uint32_t val32 = 0;
+	uint32_t index = 0;
+
+	for (index = 0; index < 64; index++) {
+		offset = index*4;
+		val32 = rtl_read_dword(rtlpriv, offset);
+		DBG_8192C("offset : 0x%02x ,val:0x%08x\n", offset, val32);
+	}
+}
+
+
+
+
+/*
+---------------------------------------------------------------
+
+	MAC init functions
+
+---------------------------------------------------------------
+*/
+
+
+static void _InitHardwareDropIncorrectBulkOut_8812A(struct rtl_priv *rtlpriv)
+{
+	uint32_t value32 = rtl_read_dword(rtlpriv, REG_TXDMA_OFFSET_CHK);
+	value32 |= DROP_DATA_EN;
+	rtl_write_dword(rtlpriv, REG_TXDMA_OFFSET_CHK, value32);
+}
+
+static void _InitRxSetting_8812AU(struct rtl_priv *rtlpriv)
+{
+	rtl_write_dword(rtlpriv, REG_MACID, 0x87654321);
+	/* ULLI unknown register */
+	rtl_write_dword(rtlpriv, 0x0700, 0x87654321);
+}
+
+
+/* Set CCK and OFDM Block "ON" */
+static void _BBTurnOnBlock(struct rtl_priv *rtlpriv)
+{
+	rtl_set_bbreg(rtlpriv, RFPGA0_RFMOD, bCCKEn, 0x1);
+	rtl_set_bbreg(rtlpriv, RFPGA0_RFMOD, bOFDMEn, 0x1);
+}
+
+enum {
+	Antenna_Lfet = 1,
+	Antenna_Right = 2,
+};
+
+
+static void _rtl8821au_poweroff_adapter(struct rtl_priv *rtlpriv)
+{
+	struct rtl_hal *rtlhal = rtl_hal(rtlpriv);
+	uint8_t	u1bTmp;
+	uint8_t 	val8;
+	u16	val16;
+	uint32_t	val32;
+
+	/* DBG_871X("CardDisableRTL8188EU\n"); */
+
+	/* Stop Tx Report Timer. 0x4EC[Bit1]=b'0 */
+	u1bTmp = rtl_read_byte(rtlpriv, REG_TX_RPT_CTRL);
+	rtl_write_byte(rtlpriv, REG_TX_RPT_CTRL, val8&(~BIT(1)));
+
+	/* stop rx */
+	rtl_write_byte(rtlpriv, REG_CR, 0x0);
+
+	/* Run LPS WL RFOFF flow */
+	if (IS_HARDWARE_TYPE_8821U(rtlhal))
+		rtw_hal_pwrseqcmdparsing(rtlpriv, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, Rtl8821A_NIC_LPS_ENTER_FLOW);
+	else
+		rtw_hal_pwrseqcmdparsing(rtlpriv, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, Rtl8812_NIC_LPS_ENTER_FLOW);
+
+	if ((rtl_read_byte(rtlpriv, REG_MCUFWDL)&RAM_DL_SEL) && rtlhal->fw_ready) {
+		  /* 8051 RAM code */
+		rtl8821au_firmware_selfreset(rtlpriv);
+	}
+
+	/* Reset MCU. Suggested by Filen. 2011.01.26. by tynli. */
+	u1bTmp = rtl_read_byte(rtlpriv, REG_SYS_FUNC_EN+1);
+	rtl_write_byte(rtlpriv, REG_SYS_FUNC_EN+1, (u1bTmp&(~BIT(2))));
+
+	/* MCUFWDL 0x80[1:0]=0
+	 * reset MCU ready status
+	 */
+	rtl_write_byte(rtlpriv, REG_MCUFWDL, 0x00);
+
+	/* Card disable power action flow */
+	if (IS_HARDWARE_TYPE_8821U(rtlhal))
+		rtw_hal_pwrseqcmdparsing(rtlpriv, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, Rtl8821A_NIC_DISABLE_FLOW);
+	else
+		rtw_hal_pwrseqcmdparsing(rtlpriv, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, Rtl8812_NIC_DISABLE_FLOW);
+}
+
+#if 0	/* ULLI : we have no HW power down here ->pwrctrlpriv.bHWPowerdown = 0 */
+static void rtl8812au_hw_power_down(struct rtl_priv *rtlpriv)
+{
+	/*
+	 *  2010/-8/09 MH For power down module, we need to enable register block contrl reg at 0x1c.
+	 * Then enable power down control bit of register 0x04 BIT4 and BIT(15) as 1.
+	 */
+
+	/* Enable register area 0x0-0xc. */
+	rtl_write_byte(rtlpriv, REG_RSV_CTRL, 0x0);
+	rtl_write_word(rtlpriv, REG_APS_FSMCO, 0x8812);
+}
+#endif
+uint32_t rtl8812au_hal_deinit(struct rtl_priv *rtlpriv)
+{
+	DBG_8192C("==> %s \n", __FUNCTION__);
+
+	rtl_write_word(rtlpriv, REG_GPIO_MUXCFG, rtl_read_word(rtlpriv, REG_GPIO_MUXCFG)&(~BIT(12)));
+
+	if (IF_RTL8821AU_USB3_MODE(rtlpriv->rtlhal.version) == true) {
+		/*
+		 * set Reg 0xf008[3:4] to 2'11 to eable U1/U2 Mode in USB3.0. added by page, 20120712
+		 */
+		rtl_write_byte(rtlpriv, 0xf008, rtl_read_byte(rtlpriv, 0xf008)|0x18);
+	}
+
+	rtl_write_dword(rtlpriv, REG_HISR0_8812, 0xFFFFFFFF);
+	rtl_write_dword(rtlpriv, REG_HISR1_8812, 0xFFFFFFFF);
+	rtlpriv->cfg->ops->disable_interrupt(rtlpriv);
+	
+	if (rtlpriv->hw_init_completed == true) {
+		_rtl8821au_poweroff_adapter(rtlpriv);
+#if 0	/* ULLI : we have no HW power down here ->pwrctrlpriv.bHWPowerdown = 0 */
+		if ((rtlpriv->pwrctrlpriv.bHWPwrPindetect) && (rtlpriv->pwrctrlpriv.bHWPowerdown))
+			rtl8812au_hw_power_down(rtlpriv);
+#endif
+	}
+	return _SUCCESS;
+}
+
+unsigned int rtl8812au_inirp_deinit(struct rtl_priv *rtlpriv)
+{
+	usb_read_port_cancel(rtlpriv);
+	return _SUCCESS;
+}
+
+/*
+ * -------------------------------------------------------------------
+ *
+ * 	EEPROM/EFUSE Content Parsing
+ *
+ * -------------------------------------------------------------------
+ */
+
+void UpdateInterruptMask8812AU(struct rtl_priv *rtlpriv, uint8_t bHIMR0, uint32_t AddMSR, uint32_t RemoveMSR)
+{
+	struct rtl_usb *rtlusb = rtl_usbdev(rtlpriv);
+
+	uint32_t *himr;
+
+	if (bHIMR0)
+		himr = &(rtlusb->irq_mask[0]);
+	else
+		himr = &(rtlusb->irq_mask[1]);
+
+	if (AddMSR)
+		*himr |= AddMSR;
+
+	if (RemoveMSR)
+		*himr &= (~RemoveMSR);
+
+	if (bHIMR0)
+		rtl_write_dword(rtlpriv, REG_HIMR0_8812, *himr);
+	else
+		rtl_write_dword(rtlpriv, REG_HIMR1_8812, *himr);
+
+}
+
+void _update_response_rate(struct rtl_priv *rtlpriv, unsigned int mask)
+{
+	uint8_t	RateIndex = 0;
+	/* Set RRSR rate table. */
+	rtl_write_byte(rtlpriv, REG_RRSR, mask&0xff);
+	rtl_write_byte(rtlpriv, REG_RRSR+1, (mask>>8)&0xff);
+
+	/* Set RTS initial rate */
+	while (mask > 0x1) {
+		mask = (mask >> 1);
+		RateIndex++;
+	}
+	rtl_write_byte(rtlpriv, REG_INIRTS_RATE_SEL, RateIndex);
+}
diff -Naur linux-4.9/drivers/staging/rtl8821au/os_dep/usb_ops_linux.c linux-4.9.8821au/drivers/staging/rtl8821au/os_dep/usb_ops_linux.c
--- linux-4.9/drivers/staging/rtl8821au/os_dep/usb_ops_linux.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/os_dep/usb_ops_linux.c	2016-12-11 19:48:25.176978367 -0600
@@ -0,0 +1,210 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *******************************************************************************/
+#define _USB_OPS_LINUX_C_
+
+#include <drv_types.h>
+#include <../rtl8821au/trx.h>
+
+#undef DBG_8192C
+static inline void DBG_8192C(const char *fmt, ...)
+{
+}
+
+#undef DBG_871X
+static inline void DBG_871X(const char *fmt, ...)
+{
+}
+
+/* ULLI : move to trx.c ?? */
+
+static int recvbuf2recvframe(struct rtl_priv *rtlpriv, struct sk_buff *pskb)
+{
+	uint8_t	*pbuf;
+	uint8_t	pkt_cnt = 0;
+	uint32_t	pkt_offset;
+	int32_t	transfer_len;
+	uint8_t				*pphy_status = NULL;
+	struct recv_frame	*precvframe = NULL;
+	struct rx_pkt_attrib	*pattrib = NULL;
+	struct recv_priv	*precvpriv = &rtlpriv->recvpriv;
+	struct __queue			*pfree_recv_queue = &precvpriv->free_recv_queue;
+
+	transfer_len = (int32_t)pskb->len;
+	pbuf = pskb->data;
+
+	pkt_cnt = GET_RX_STATUS_DESC_USB_AGG_PKTNUM(pbuf);
+
+	do {
+		precvframe = rtw_alloc_recvframe(pfree_recv_queue);
+		if (precvframe == NULL) {
+			DBG_8192C("%s()-%d: rtw_alloc_recvframe() failed! RX Drop!\n", __FUNCTION__, __LINE__);
+			goto _exit_recvbuf2recvframe;
+		}
+
+		INIT_LIST_HEAD(&precvframe->list);
+		precvframe->precvbuf = NULL;	/* can't access the precvbuf for new arch. */
+		precvframe->len = 0;
+
+		rtl8812_query_rx_desc_status(rtlpriv, &precvframe->attrib, precvframe, pbuf);
+
+		pattrib = &precvframe->attrib;
+
+		if ((pattrib->crc_err) || (pattrib->icv_err)) {
+			DBG_8192C("%s: RX Warning! crc_err=%d icv_err=%d, skip!\n", __FUNCTION__, pattrib->crc_err, pattrib->icv_err);
+
+			rtw_free_recvframe(precvframe, pfree_recv_queue);
+			goto _exit_recvbuf2recvframe;
+		}
+
+		pkt_offset = RXDESC_SIZE + pattrib->drvinfo_sz + pattrib->shift_sz + pattrib->pkt_len;
+
+		if ((pattrib->pkt_len <= 0) || (pkt_offset > transfer_len)) {
+			DBG_8192C("%s()-%d: RX Warning!,pkt_len<=0 or pkt_offset> transfer_len \n", __FUNCTION__, __LINE__);
+			rtw_free_recvframe(precvframe, pfree_recv_queue);
+			goto _exit_recvbuf2recvframe;
+		}
+
+		if (rtw_os_alloc_recvframe(rtlpriv, precvframe,
+		    (pbuf+pattrib->shift_sz + pattrib->drvinfo_sz + RXDESC_SIZE),
+		     pskb) == _FAIL) {
+			rtw_free_recvframe(precvframe, pfree_recv_queue);
+
+			goto _exit_recvbuf2recvframe;
+		}
+
+		recvframe_put(precvframe, pattrib->pkt_len);
+		/* recvframe_pull(precvframe, drvinfo_sz + RXDESC_SIZE); */
+
+		if (pattrib->pkt_rpt_type == NORMAL_RX) {
+			/* Normal rx packet */
+			if (pattrib->physt)
+				pphy_status = (pbuf + RXDESC_OFFSET);
+
+			if (pattrib->physt && pphy_status)
+				rtl8812_query_rx_phy_status(precvframe, pphy_status);
+
+			if (rtw_recv_entry(precvframe) != _SUCCESS) {
+				;
+			}
+
+		} else {
+			/* pkt_rpt_type == TX_REPORT1-CCX, TX_REPORT2-TX RTP,HIS_REPORT-USB HISR RTP */
+
+			if (pattrib->pkt_rpt_type == C2H_PACKET) {
+				/* DBG_8192C("rx C2H_PACKET \n"); */
+				/* C2HPacketHandler_8812A(rtlpriv,precvframe->u.hdr.rx_data,pattrib->pkt_len); */
+			}
+			/* enqueue recvframe to txrtp queue */
+			else if (pattrib->pkt_rpt_type == TX_REPORT1) {
+				DBG_8192C("rx CCX \n");
+			}
+			else if (pattrib->pkt_rpt_type == TX_REPORT2) {
+				/* DBG_8192C("rx TX RPT \n"); */
+			}
+			/*else if(pattrib->pkt_rpt_type == HIS_REPORT)
+			{
+				//DBG_8192C("%s , rx USB HISR \n",__FUNCTION__);
+			}*/
+			rtw_free_recvframe(precvframe, pfree_recv_queue);
+
+		}
+
+		/*  jaguar 8-byte alignment */
+		pkt_offset = (u16)_RND8(pkt_offset);
+		pkt_cnt--;
+		pbuf += pkt_offset;
+		transfer_len -= pkt_offset;
+		precvframe = NULL;
+
+	} while (transfer_len > 0);
+
+_exit_recvbuf2recvframe:
+
+	return _SUCCESS;
+}
+
+void rtl8812au_recv_tasklet(void *priv)
+{
+	struct sk_buff 		*pskb;
+	struct rtl_priv		*rtlpriv = (struct rtl_priv *)priv;
+	struct recv_priv	*precvpriv = &rtlpriv->recvpriv;
+
+	while (NULL != (pskb = skb_dequeue(&precvpriv->rx_skb_queue))) {
+		if ((rtlpriv->bDriverStopped == true)
+		|| (rtlpriv->bSurpriseRemoved == true)) {
+			DBG_8192C("recv_tasklet => bDriverStopped or bSurpriseRemoved \n");
+			dev_kfree_skb_any(pskb);
+			break;
+		}
+
+		recvbuf2recvframe(rtlpriv, pskb);
+
+		skb_reset_tail_pointer(pskb);
+		pskb->len = 0;
+		skb_queue_tail(&precvpriv->free_recv_skb_queue, pskb);
+	}
+
+}
+
+void rtl8812au_xmit_tasklet(void *priv)
+{
+	int ret = false;
+	struct rtl_priv *rtlpriv = (struct rtl_priv *) priv;
+	struct xmit_priv *pxmitpriv = &rtlpriv->xmitpriv;
+
+	if (check_fwstate(&rtlpriv->mlmepriv, _FW_UNDER_SURVEY) == true)
+		return;
+
+	while (1) {
+		if ((rtlpriv->bDriverStopped == true)
+		 || (rtlpriv->bSurpriseRemoved == true)
+		 || (rtlpriv->bWritePortCancel == true)) {
+			DBG_8192C("xmit_tasklet => bDriverStopped or bSurpriseRemoved or bWritePortCancel\n");
+			break;
+		}
+
+		ret = rtl8812au_xmitframe_complete(rtlpriv, pxmitpriv, NULL);
+
+		if (ret == false)
+			break;
+
+	}
+
+}
+
+void usb_read_port_cancel(struct rtl_priv *rtlpriv)
+{
+	int i;
+	struct recv_buf *precvbuf;
+	precvbuf = (struct recv_buf *)rtlpriv->recvpriv.precv_buf;
+
+	DBG_871X("%s\n", __func__);
+
+	rtlpriv->bReadPortCancel = true;
+
+	for (i=0; i < NR_RECVBUFF ; i++) {
+
+		precvbuf->reuse = true;
+		if (precvbuf->purb)	 {
+			/* DBG_8192C("usb_read_port_cancel : usb_kill_urb \n"); */
+			usb_kill_urb(precvbuf->purb);
+		}
+		precvbuf++;
+	}
+}
diff -Naur linux-4.9/drivers/staging/rtl8821au/os_dep/xmit_linux.c linux-4.9.8821au/drivers/staging/rtl8821au/os_dep/xmit_linux.c
--- linux-4.9/drivers/staging/rtl8821au/os_dep/xmit_linux.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/os_dep/xmit_linux.c	2016-12-11 19:48:25.176978367 -0600
@@ -0,0 +1,297 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+#define _XMIT_OSDEP_C_
+
+#include <drv_types.h>
+
+#undef DBG_871X
+static inline void DBG_871X(const char *fmt, ...)
+{
+}
+
+
+
+void rtw_set_tx_chksum_offload(struct sk_buff *pkt, struct tx_pkt_attrib *pattrib)
+{
+
+#ifdef CONFIG_TCP_CSUM_OFFLOAD_TX
+	struct sk_buff *skb = (struct sk_buff *)pkt;
+	pattrib->hw_tcp_csum = 0;
+
+	if (skb->ip_summed == CHECKSUM_PARTIAL) {
+		if (skb_shinfo(skb)->nr_frags == 0) {
+			const struct iphdr *ip = ip_hdr(skb);
+			if (ip->protocol == IPPROTO_TCP) {
+				/* TCP checksum offload by HW */
+				DBG_871X("CHECKSUM_PARTIAL TCP\n");
+				pattrib->hw_tcp_csum = 1;
+				/* skb_checksum_help(skb); */
+			} else if (ip->protocol == IPPROTO_UDP) {
+				/* DBG_871X("CHECKSUM_PARTIAL UDP\n"); */
+#if 1
+				skb_checksum_help(skb);
+#else
+				/* Set UDP checksum = 0 to skip checksum check */
+				struct udphdr *udp = skb_transport_header(skb);
+				udp->check = 0;
+#endif
+			} else {
+				DBG_871X("%s-%d TCP CSUM offload Error!!\n", __FUNCTION__, __LINE__);
+				WARN_ON(1);     /* we need a WARN() */
+			}
+		} else {
+			/* IP fragmentation case */
+			DBG_871X("%s-%d nr_frags != 0, using skb_checksum_help(skb);!!\n", __FUNCTION__, __LINE__);
+                	skb_checksum_help(skb);
+		}
+	}
+#endif
+}
+
+int rtw_os_xmit_resource_alloc(struct rtl_priv *rtlpriv, struct xmit_buf *pxmitbuf, u32 alloc_sz, uint8_t flag)
+{
+	if (alloc_sz > 0) {
+		pxmitbuf->pallocated_buf = rtw_zmalloc(alloc_sz);
+		if (pxmitbuf->pallocated_buf == NULL) {
+			return _FAIL;
+		}
+
+		pxmitbuf->pbuf = (uint8_t *)N_BYTE_ALIGMENT((__kernel_size_t)(pxmitbuf->pallocated_buf), XMITBUF_ALIGN_SZ);
+	}
+
+	if (flag) {
+		int i;
+		for (i = 0; i < 8; i++) {
+			pxmitbuf->pxmit_urb[i] = usb_alloc_urb(0, GFP_KERNEL);
+			if(pxmitbuf->pxmit_urb[i] == NULL) {
+				DBG_871X("pxmitbuf->pxmit_urb[i]==NULL");
+				return _FAIL;
+			}
+		}
+	}
+
+	return _SUCCESS;
+}
+
+void rtw_os_xmit_resource_free(struct rtl_priv *rtlpriv, struct xmit_buf *pxmitbuf,u32 free_sz, uint8_t flag)
+{
+	if (flag) {
+		int i;
+
+		for(i=0; i<8; i++) {
+			if(pxmitbuf->pxmit_urb[i]) {
+				/* usb_kill_urb(pxmitbuf->pxmit_urb[i]); */
+				usb_free_urb(pxmitbuf->pxmit_urb[i]);
+			}
+		}
+	}
+
+	if (free_sz > 0 ) {
+		if(pxmitbuf->pallocated_buf) {
+			rtw_mfree(pxmitbuf->pallocated_buf);
+		}
+	}
+}
+
+#define WMM_XMIT_THRESHOLD	(NR_XMITFRAME*2/5)
+
+void rtw_os_pkt_complete(struct rtl_priv *rtlpriv, struct sk_buff *pkt)
+{
+	u16 queue;
+	struct xmit_priv *pxmitpriv = &rtlpriv->xmitpriv;
+
+	queue = skb_get_queue_mapping(pkt);
+	if(__netif_subqueue_stopped(rtlpriv->ndev, queue))
+		netif_wake_subqueue(rtlpriv->ndev, queue);
+
+	dev_kfree_skb_any(pkt);
+}
+
+void rtw_os_xmit_complete(struct rtl_priv *rtlpriv, struct xmit_frame *pxframe)
+{
+	if(pxframe->skb) {
+		/*
+		 * RT_TRACE(_module_xmit_osdep_c_,_drv_err_,("linux : rtw_os_xmit_complete, dev_kfree_skb()\n"));
+		 *
+		 * dev_kfree_skb_any(pxframe->pkt);
+		 */
+		rtw_os_pkt_complete(rtlpriv, pxframe->skb);
+	}
+
+	pxframe->skb = NULL;
+}
+
+void rtw_os_xmit_schedule(struct rtl_priv *rtlpriv)
+{
+	struct rtl_priv *pri_adapter = rtlpriv;
+
+	struct xmit_priv *pxmitpriv;
+
+	if(!rtlpriv)
+		return;
+
+	pxmitpriv = &rtlpriv->xmitpriv;
+
+	spin_lock_bh(&pxmitpriv->lock);
+
+	if(rtw_txframes_pending(rtlpriv)) {
+		tasklet_hi_schedule(&pxmitpriv->xmit_tasklet);
+	}
+
+	spin_unlock_bh(&pxmitpriv->lock);
+}
+
+static void rtw_check_xmit_resource(struct rtl_priv *rtlpriv, struct sk_buff *pkt)
+{
+	struct xmit_priv *pxmitpriv = &rtlpriv->xmitpriv;
+	u16	queue;
+
+	queue = skb_get_queue_mapping(pkt);
+	if(pxmitpriv->free_xmitframe_cnt<=4) {
+		if (!netif_tx_queue_stopped(netdev_get_tx_queue(rtlpriv->ndev, queue)))
+			netif_stop_subqueue(rtlpriv->ndev, queue);
+	}
+}
+
+#ifdef CONFIG_TX_MCAST2UNI
+int rtw_mlcst2unicst(struct rtl_priv *rtlpriv, struct sk_buff *skb)
+{
+	struct	sta_priv *pstapriv = &rtlpriv->stapriv;
+	struct xmit_priv *pxmitpriv = &rtlpriv->xmitpriv;
+	struct list_head	*phead, *plist;
+	struct sk_buff *newskb;
+	struct sta_info *psta = NULL;
+	uint8_t chk_alive_num = 0;
+	char chk_alive_list[NUM_STA];
+	uint8_t bc_addr[6]={0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
+	uint8_t null_addr[6]={0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
+
+	int i;
+	int32_t	res;
+
+	spin_lock_bh(&pstapriv->asoc_list_lock);
+	phead = &pstapriv->asoc_list;
+	plist = phead->next;
+
+	/* free sta asoc_queue */
+	while ((rtw_end_of_queue_search(phead, plist)) == false) {
+		int stainfo_offset;
+		psta = container_of(plist, struct sta_info, asoc_list);
+		plist = plist->next;
+
+		stainfo_offset = rtw_stainfo_offset(pstapriv, psta);
+		if (stainfo_offset_valid(stainfo_offset)) {
+			chk_alive_list[chk_alive_num++] = stainfo_offset;
+		}
+	}
+	spin_unlock_bh(&pstapriv->asoc_list_lock);
+
+	for (i = 0; i < chk_alive_num; i++) {
+		psta = rtw_get_stainfo_by_offset(pstapriv, chk_alive_list[i]);
+		if(!(psta->state &_FW_LINKED))
+			continue;
+
+		/* avoid come from STA1 and send back STA1 */
+		if (_rtw_memcmp(psta->hwaddr, &skb->data[6], 6) == true
+			|| _rtw_memcmp(psta->hwaddr, null_addr, 6) == true
+			|| _rtw_memcmp(psta->hwaddr, bc_addr, 6) == true
+		)
+			continue;
+
+		newskb = skb_copy(skb, GFP_ATOMIC);
+
+		if (newskb) {
+			memcpy(newskb->data, psta->hwaddr, 6);
+			res = rtw_xmit(rtlpriv, &newskb);
+			if (res < 0) {
+				DBG_871X("%s()-%d: rtw_xmit() return error!\n", __FUNCTION__, __LINE__);
+				pxmitpriv->tx_drop++;
+				dev_kfree_skb_any(newskb);
+			} else
+				pxmitpriv->tx_pkts++;
+		} else {
+			DBG_871X("%s-%d: skb_copy() failed!\n", __FUNCTION__, __LINE__);
+			pxmitpriv->tx_drop++;
+			/* dev_kfree_skb_any(skb); */
+			return false;	/* Caller shall tx this multicast frame via normal way. */
+		}
+	}
+
+	dev_kfree_skb_any(skb);
+	return true;
+}
+#endif
+
+
+int rtw_xmit_entry(struct sk_buff *pkt, struct net_device *ndev)
+{
+	struct rtl_priv *rtlpriv = rtl_priv(ndev);
+	struct xmit_priv *pxmitpriv = &rtlpriv->xmitpriv;
+#ifdef CONFIG_TX_MCAST2UNI
+	struct mlme_priv	*pmlmepriv = &rtlpriv->mlmepriv;
+	extern int __rtw_mc2u_disable;
+#endif
+	int32_t res = 0;
+	u16 queue;
+
+	if (rtw_if_up(rtlpriv) == false) {
+		goto drop_packet;
+	}
+
+	rtw_check_xmit_resource(rtlpriv, pkt);
+
+#ifdef CONFIG_TX_MCAST2UNI
+	if ( !__rtw_mc2u_disable && check_fwstate(pmlmepriv, WIFI_AP_STATE) == true &&
+	   ( IP_MCAST_MAC(pkt->data) || ICMPV6_MCAST_MAC(pkt->data) )
+		)
+	{
+		if ( pxmitpriv->free_xmitframe_cnt > (NR_XMITFRAME/4) ) {
+			res = rtw_mlcst2unicst(rtlpriv, pkt);
+			if (res == true) {
+				goto exit;
+			}
+		} else {
+			/*
+			 * DBG_871X("Stop M2U(%d, %d)! ", pxmitpriv->free_xmitframe_cnt, pxmitpriv->free_xmitbuf_cnt);
+			 * DBG_871X("!m2u );
+			 */
+		}
+	}
+#endif
+
+	res = rtw_xmit(rtlpriv, &pkt);
+	if (res < 0) {
+		goto drop_packet;
+	}
+
+	pxmitpriv->tx_pkts++;
+	goto exit;
+
+drop_packet:
+	pxmitpriv->tx_drop++;
+	dev_kfree_skb_any(pkt);
+
+exit:
+
+
+
+	return 0;
+}
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/ps.c linux-4.9.8821au/drivers/staging/rtl8821au/ps.c
--- linux-4.9/drivers/staging/rtl8821au/ps.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/ps.c	2016-12-11 19:48:25.180311687 -0600
@@ -0,0 +1,1004 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2009-2012  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+
+#include "wifi.h"
+#include "base.h"
+#include "ps.h"
+#include <linux/export.h>
+#include "btcoexist/rtl_btc.h"
+
+bool rtl_ps_enable_nic(struct ieee80211_hw *hw)
+{
+	struct rtl_priv *rtlpriv = rtl_priv(hw);
+	struct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));
+	struct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));
+
+	/*<1> reset trx ring */
+	if (rtlhal->interface == INTF_PCI)
+		rtlpriv->intf_ops->reset_trx_ring(hw);
+
+	if (is_hal_stop(rtlhal))
+		RT_TRACE(rtlpriv, COMP_ERR, DBG_WARNING,
+			 "Driver is already down!\n");
+
+	/*<2> Enable Adapter */
+	if (rtlpriv->cfg->ops->hw_init(hw))
+		return false;
+	RT_CLEAR_PS_LEVEL(ppsc, RT_RF_OFF_LEVL_HALT_NIC);
+
+	/*<3> Enable Interrupt */
+	rtlpriv->cfg->ops->enable_interrupt(hw);
+
+	/*<enable timer> */
+	rtl_watch_dog_timer_callback((unsigned long)hw);
+
+	return true;
+}
+EXPORT_SYMBOL(rtl_ps_enable_nic);
+
+bool rtl_ps_disable_nic(struct ieee80211_hw *hw)
+{
+	struct rtl_priv *rtlpriv = rtl_priv(hw);
+
+	/*<1> Stop all timer */
+	rtl_deinit_deferred_work(hw);
+
+	/*<2> Disable Interrupt */
+	rtlpriv->cfg->ops->disable_interrupt(hw);
+	tasklet_kill(&rtlpriv->works.irq_tasklet);
+
+	/*<3> Disable Adapter */
+	rtlpriv->cfg->ops->hw_disable(hw);
+
+	return true;
+}
+EXPORT_SYMBOL(rtl_ps_disable_nic);
+
+bool rtl_ps_set_rf_state(struct ieee80211_hw *hw,
+			 enum rf_pwrstate state_toset,
+			 u32 changesource, bool protect_or_not)
+{
+	struct rtl_priv *rtlpriv = rtl_priv(hw);
+	struct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));
+	enum rf_pwrstate rtstate;
+	bool actionallowed = false;
+	u16 rfwait_cnt = 0;
+
+	if (protect_or_not)
+		goto no_protect;
+
+	/*Only one thread can change
+	 *the RF state at one time, and others
+	 *should wait to be executed.
+	 */
+	while (true) {
+		spin_lock(&rtlpriv->locks.rf_ps_lock);
+		if (ppsc->rfchange_inprogress) {
+			spin_unlock(&rtlpriv->locks.rf_ps_lock);
+
+			RT_TRACE(rtlpriv, COMP_ERR, DBG_WARNING,
+				 "RF Change in progress! Wait to set..state_toset(%d).\n",
+				  state_toset);
+
+			/* Set RF after the previous action is done.  */
+			while (ppsc->rfchange_inprogress) {
+				rfwait_cnt++;
+				mdelay(1);
+				/*Wait too long, return false to avoid
+				 *to be stuck here.
+				 */
+				if (rfwait_cnt > 100)
+					return false;
+			}
+		} else {
+			ppsc->rfchange_inprogress = true;
+			spin_unlock(&rtlpriv->locks.rf_ps_lock);
+			break;
+		}
+	}
+
+no_protect:
+	rtstate = ppsc->rfpwr_state;
+
+	switch (state_toset) {
+	case ERFON:
+		ppsc->rfoff_reason &= (~changesource);
+
+		if ((changesource == RF_CHANGE_BY_HW) &&
+		    (ppsc->hwradiooff)) {
+			ppsc->hwradiooff = false;
+		}
+
+		if (!ppsc->rfoff_reason) {
+			ppsc->rfoff_reason = 0;
+			actionallowed = true;
+		}
+
+		break;
+
+	case ERFOFF:
+
+		if ((changesource == RF_CHANGE_BY_HW) && !ppsc->hwradiooff) {
+			ppsc->hwradiooff = true;
+		}
+
+		ppsc->rfoff_reason |= changesource;
+		actionallowed = true;
+		break;
+
+	case ERFSLEEP:
+		ppsc->rfoff_reason |= changesource;
+		actionallowed = true;
+		break;
+
+	default:
+		RT_TRACE(rtlpriv, COMP_ERR, DBG_EMERG,
+			 "switch case not processed\n");
+		break;
+	}
+
+	if (actionallowed)
+		rtlpriv->cfg->ops->set_rf_power_state(hw, state_toset);
+
+	if (!protect_or_not) {
+		spin_lock(&rtlpriv->locks.rf_ps_lock);
+		ppsc->rfchange_inprogress = false;
+		spin_unlock(&rtlpriv->locks.rf_ps_lock);
+	}
+
+	return actionallowed;
+}
+EXPORT_SYMBOL(rtl_ps_set_rf_state);
+
+static void _rtl_ps_inactive_ps(struct ieee80211_hw *hw)
+{
+	struct rtl_priv *rtlpriv = rtl_priv(hw);
+	struct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));
+	struct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));
+
+	ppsc->swrf_processing = true;
+
+	if (ppsc->inactive_pwrstate == ERFON &&
+	    rtlhal->interface == INTF_PCI) {
+		if ((ppsc->reg_rfps_level & RT_RF_OFF_LEVL_ASPM) &&
+		    RT_IN_PS_LEVEL(ppsc, RT_PS_LEVEL_ASPM) &&
+		    rtlhal->interface == INTF_PCI) {
+			rtlpriv->intf_ops->disable_aspm(hw);
+			RT_CLEAR_PS_LEVEL(ppsc, RT_PS_LEVEL_ASPM);
+		}
+	}
+
+	rtl_ps_set_rf_state(hw, ppsc->inactive_pwrstate,
+			    RF_CHANGE_BY_IPS, false);
+
+	if (ppsc->inactive_pwrstate == ERFOFF &&
+	    rtlhal->interface == INTF_PCI) {
+		if (ppsc->reg_rfps_level & RT_RF_OFF_LEVL_ASPM &&
+		    !RT_IN_PS_LEVEL(ppsc, RT_PS_LEVEL_ASPM)) {
+			rtlpriv->intf_ops->enable_aspm(hw);
+			RT_SET_PS_LEVEL(ppsc, RT_PS_LEVEL_ASPM);
+		}
+	}
+
+	ppsc->swrf_processing = false;
+}
+
+void rtl_ips_nic_off_wq_callback(void *data)
+{
+	struct rtl_works *rtlworks =
+	    container_of_dwork_rtl(data, struct rtl_works, ips_nic_off_wq);
+	struct ieee80211_hw *hw = rtlworks->hw;
+	struct rtl_priv *rtlpriv = rtl_priv(hw);
+	struct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));
+	struct rtl_mac *mac = rtl_mac(rtl_priv(hw));
+	struct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));
+	enum rf_pwrstate rtstate;
+
+	if (mac->opmode != NL80211_IFTYPE_STATION) {
+		RT_TRACE(rtlpriv, COMP_ERR, DBG_WARNING,
+			 "not station return\n");
+		return;
+	}
+
+	if (mac->p2p_in_use)
+		return;
+
+	if (mac->link_state > MAC80211_NOLINK)
+		return;
+
+	if (is_hal_stop(rtlhal))
+		return;
+
+	if (rtlpriv->sec.being_setkey)
+		return;
+
+	if (rtlpriv->cfg->ops->bt_coex_off_before_lps)
+		rtlpriv->cfg->ops->bt_coex_off_before_lps(hw);
+
+	if (ppsc->inactiveps) {
+		rtstate = ppsc->rfpwr_state;
+
+		/*
+		 *Do not enter IPS in the following conditions:
+		 *(1) RF is already OFF or Sleep
+		 *(2) swrf_processing (indicates the IPS is still under going)
+		 *(3) Connectted (only disconnected can trigger IPS)
+		 *(4) IBSS (send Beacon)
+		 *(5) AP mode (send Beacon)
+		 *(6) monitor mode (rcv packet)
+		 */
+
+		if (rtstate == ERFON &&
+		    !ppsc->swrf_processing &&
+		    (mac->link_state == MAC80211_NOLINK) &&
+		    !mac->act_scanning) {
+			RT_TRACE(rtlpriv, COMP_RF, DBG_TRACE,
+				 "IPSEnter(): Turn off RF\n");
+
+			ppsc->inactive_pwrstate = ERFOFF;
+			ppsc->in_powersavemode = true;
+
+			/* call before RF off */
+			if (rtlpriv->cfg->ops->get_btc_status())
+				rtlpriv->btcoexist.btc_ops->btc_ips_notify(rtlpriv,
+									ppsc->inactive_pwrstate);
+
+			/*rtl_pci_reset_trx_ring(hw); */
+			_rtl_ps_inactive_ps(hw);
+		}
+	}
+}
+
+void rtl_ips_nic_off(struct ieee80211_hw *hw)
+{
+	struct rtl_priv *rtlpriv = rtl_priv(hw);
+
+	/* because when link with ap, mac80211 will ask us
+	 * to disable nic quickly after scan before linking,
+	 * this will cause link failed, so we delay 100ms here
+	 */
+	queue_delayed_work(rtlpriv->works.rtl_wq,
+			   &rtlpriv->works.ips_nic_off_wq, MSECS(100));
+}
+
+/* NOTICE: any opmode should exc nic_on, or disable without
+ * nic_on may something wrong, like adhoc TP
+ */
+void rtl_ips_nic_on(struct ieee80211_hw *hw)
+{
+	struct rtl_priv *rtlpriv = rtl_priv(hw);
+	struct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));
+	enum rf_pwrstate rtstate;
+
+	cancel_delayed_work(&rtlpriv->works.ips_nic_off_wq);
+
+	spin_lock(&rtlpriv->locks.ips_lock);
+	if (ppsc->inactiveps) {
+		rtstate = ppsc->rfpwr_state;
+
+		if (rtstate != ERFON &&
+		    !ppsc->swrf_processing &&
+		    ppsc->rfoff_reason <= RF_CHANGE_BY_IPS) {
+
+			ppsc->inactive_pwrstate = ERFON;
+			ppsc->in_powersavemode = false;
+			_rtl_ps_inactive_ps(hw);
+			/* call after RF on */
+			if (rtlpriv->cfg->ops->get_btc_status())
+				rtlpriv->btcoexist.btc_ops->btc_ips_notify(rtlpriv,
+									ppsc->inactive_pwrstate);
+		}
+	}
+	spin_unlock(&rtlpriv->locks.ips_lock);
+}
+EXPORT_SYMBOL_GPL(rtl_ips_nic_on);
+
+/*for FW LPS*/
+
+/*
+ *Determine if we can set Fw into PS mode
+ *in current condition.Return true if it
+ *can enter PS mode.
+ */
+static bool rtl_get_fwlps_doze(struct ieee80211_hw *hw)
+{
+	struct rtl_priv *rtlpriv = rtl_priv(hw);
+	struct rtl_mac *mac = rtl_mac(rtl_priv(hw));
+	struct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));
+	u32 ps_timediff;
+
+	ps_timediff = jiffies_to_msecs(jiffies -
+				       ppsc->last_delaylps_stamp_jiffies);
+
+	if (ps_timediff < 2000) {
+		RT_TRACE(rtlpriv, COMP_POWER, DBG_LOUD,
+			 "Delay enter Fw LPS for DHCP, ARP, or EAPOL exchanging state\n");
+		return false;
+	}
+
+	if (mac->link_state != MAC80211_LINKED)
+		return false;
+
+	if (mac->opmode == NL80211_IFTYPE_ADHOC)
+		return false;
+
+	return true;
+}
+
+/* Change current and default preamble mode.*/
+void rtl_lps_set_psmode(struct ieee80211_hw *hw, u8 rt_psmode)
+{
+	struct rtl_priv *rtlpriv = rtl_priv(hw);
+	struct rtl_mac *mac = rtl_mac(rtl_priv(hw));
+	struct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));
+	bool enter_fwlps;
+
+	if (mac->opmode == NL80211_IFTYPE_ADHOC)
+		return;
+
+	if (mac->link_state != MAC80211_LINKED)
+		return;
+
+	if (ppsc->dot11_psmode == rt_psmode)
+		return;
+
+	/* Update power save mode configured. */
+	ppsc->dot11_psmode = rt_psmode;
+
+	/*
+	 *<FW control LPS>
+	 *1. Enter PS mode
+	 *   Set RPWM to Fw to turn RF off and send H2C fw_pwrmode
+	 *   cmd to set Fw into PS mode.
+	 *2. Leave PS mode
+	 *   Send H2C fw_pwrmode cmd to Fw to set Fw into Active
+	 *   mode and set RPWM to turn RF on.
+	 */
+
+	if ((ppsc->fwctrl_lps) && ppsc->report_linked) {
+		if (ppsc->dot11_psmode == EACTIVE) {
+			RT_TRACE(rtlpriv, COMP_RF, DBG_DMESG,
+				 "FW LPS leave ps_mode:%x\n",
+				  FW_PS_ACTIVE_MODE);
+			enter_fwlps = false;
+			ppsc->pwr_mode = FW_PS_ACTIVE_MODE;
+			ppsc->smart_ps = 0;
+			rtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_FW_LPS_ACTION,
+						      (u8 *)(&enter_fwlps));
+			if (ppsc->p2p_ps_info.opp_ps)
+				rtl_p2p_ps_cmd(hw , P2P_PS_ENABLE);
+
+			if (rtlpriv->cfg->ops->get_btc_status())
+				rtlpriv->btcoexist.btc_ops->btc_lps_notify(rtlpriv, rt_psmode);
+		} else {
+			if (rtl_get_fwlps_doze(hw)) {
+				RT_TRACE(rtlpriv, COMP_RF, DBG_DMESG,
+					 "FW LPS enter ps_mode:%x\n",
+					 ppsc->fwctrl_psmode);
+				if (rtlpriv->cfg->ops->get_btc_status())
+					rtlpriv->btcoexist.btc_ops->btc_lps_notify(rtlpriv, rt_psmode);
+				enter_fwlps = true;
+				ppsc->pwr_mode = ppsc->fwctrl_psmode;
+				ppsc->smart_ps = 2;
+				rtlpriv->cfg->ops->set_hw_reg(hw,
+							HW_VAR_FW_LPS_ACTION,
+							(u8 *)(&enter_fwlps));
+
+			} else {
+				/* Reset the power save related parameters. */
+				ppsc->dot11_psmode = EACTIVE;
+			}
+		}
+	}
+}
+
+/*Enter the leisure power save mode.*/
+void rtl_lps_enter(struct ieee80211_hw *hw)
+{
+	struct rtl_mac *mac = rtl_mac(rtl_priv(hw));
+	struct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));
+	struct rtl_priv *rtlpriv = rtl_priv(hw);
+	unsigned long flag;
+
+	if (!ppsc->fwctrl_lps)
+		return;
+
+	if (rtlpriv->sec.being_setkey)
+		return;
+
+	if (rtlpriv->link_info.busytraffic)
+		return;
+
+	/*sleep after linked 10s, to let DHCP and 4-way handshake ok enough!! */
+	if (mac->cnt_after_linked < 5)
+		return;
+
+	if (mac->opmode == NL80211_IFTYPE_ADHOC)
+		return;
+
+	if (mac->link_state != MAC80211_LINKED)
+		return;
+
+	spin_lock_irqsave(&rtlpriv->locks.lps_lock, flag);
+
+	/* Idle for a while if we connect to AP a while ago. */
+	if (mac->cnt_after_linked >= 2) {
+		if (ppsc->dot11_psmode == EACTIVE) {
+			RT_TRACE(rtlpriv, COMP_POWER, DBG_LOUD,
+				 "Enter 802.11 power save mode...\n");
+
+			rtl_lps_set_psmode(hw, EAUTOPS);
+		}
+	}
+
+	spin_unlock_irqrestore(&rtlpriv->locks.lps_lock, flag);
+}
+EXPORT_SYMBOL(rtl_lps_enter);
+
+/*Leave the leisure power save mode.*/
+void rtl_lps_leave(struct ieee80211_hw *hw)
+{
+	struct rtl_priv *rtlpriv = rtl_priv(hw);
+	struct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));
+	struct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));
+	unsigned long flag;
+
+	spin_lock_irqsave(&rtlpriv->locks.lps_lock, flag);
+
+	if (ppsc->fwctrl_lps) {
+		if (ppsc->dot11_psmode != EACTIVE) {
+
+			/*FIX ME */
+			/*rtlpriv->cfg->ops->enable_interrupt(hw); */
+
+			if (ppsc->reg_rfps_level & RT_RF_LPS_LEVEL_ASPM &&
+			    RT_IN_PS_LEVEL(ppsc, RT_PS_LEVEL_ASPM) &&
+			    rtlhal->interface == INTF_PCI) {
+				rtlpriv->intf_ops->disable_aspm(hw);
+				RT_CLEAR_PS_LEVEL(ppsc, RT_PS_LEVEL_ASPM);
+			}
+
+			RT_TRACE(rtlpriv, COMP_POWER, DBG_LOUD,
+				 "Busy Traffic,Leave 802.11 power save..\n");
+
+			rtl_lps_set_psmode(hw, EACTIVE);
+		}
+	}
+	spin_unlock_irqrestore(&rtlpriv->locks.lps_lock, flag);
+}
+EXPORT_SYMBOL(rtl_lps_leave);
+
+/* For sw LPS*/
+void rtl_swlps_beacon(struct ieee80211_hw *hw, void *data, unsigned int len)
+{
+	struct rtl_priv *rtlpriv = rtl_priv(hw);
+	struct rtl_mac *mac = rtl_mac(rtl_priv(hw));
+	struct ieee80211_hdr *hdr = data;
+	struct ieee80211_tim_ie *tim_ie;
+	u8 *tim;
+	u8 tim_len;
+	bool u_buffed;
+	bool m_buffed;
+
+	if (mac->opmode != NL80211_IFTYPE_STATION)
+		return;
+
+	if (!rtlpriv->psc.swctrl_lps)
+		return;
+
+	if (rtlpriv->mac80211.link_state != MAC80211_LINKED)
+		return;
+
+	if (!rtlpriv->psc.sw_ps_enabled)
+		return;
+
+	if (rtlpriv->psc.fwctrl_lps)
+		return;
+
+	if (likely(!(hw->conf.flags & IEEE80211_CONF_PS)))
+		return;
+
+	/* check if this really is a beacon */
+	if (!ieee80211_is_beacon(hdr->frame_control))
+		return;
+
+	/* min. beacon length + FCS_LEN */
+	if (len <= 40 + FCS_LEN)
+		return;
+
+	/* and only beacons from the associated BSSID, please */
+	if (!ether_addr_equal_64bits(hdr->addr3, rtlpriv->mac80211.bssid))
+		return;
+
+	rtlpriv->psc.last_beacon = jiffies;
+
+	tim = rtl_find_ie(data, len - FCS_LEN, WLAN_EID_TIM);
+	if (!tim)
+		return;
+
+	if (tim[1] < sizeof(*tim_ie))
+		return;
+
+	tim_len = tim[1];
+	tim_ie = (struct ieee80211_tim_ie *) &tim[2];
+
+	if (!WARN_ON_ONCE(!hw->conf.ps_dtim_period))
+		rtlpriv->psc.dtim_counter = tim_ie->dtim_count;
+
+	/* Check whenever the PHY can be turned off again. */
+
+	/* 1. What about buffered unicast traffic for our AID? */
+	u_buffed = ieee80211_check_tim(tim_ie, tim_len,
+				       rtlpriv->mac80211.assoc_id);
+
+	/* 2. Maybe the AP wants to send multicast/broadcast data? */
+	m_buffed = tim_ie->bitmap_ctrl & 0x01;
+	rtlpriv->psc.multi_buffered = m_buffed;
+
+	/* unicast will process by mac80211 through
+	 * set ~IEEE80211_CONF_PS, So we just check
+	 * multicast frames here */
+	if (!m_buffed) {
+		/* back to low-power land. and delay is
+		 * prevent null power save frame tx fail */
+		queue_delayed_work(rtlpriv->works.rtl_wq,
+				   &rtlpriv->works.ps_work, MSECS(5));
+	} else {
+		RT_TRACE(rtlpriv, COMP_POWER, DBG_DMESG,
+			 "u_bufferd: %x, m_buffered: %x\n", u_buffed, m_buffed);
+	}
+}
+EXPORT_SYMBOL_GPL(rtl_swlps_beacon);
+
+void rtl_swlps_rf_awake(struct ieee80211_hw *hw)
+{
+	struct rtl_priv *rtlpriv = rtl_priv(hw);
+	struct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));
+	struct rtl_mac *mac = rtl_mac(rtl_priv(hw));
+	unsigned long flag;
+
+	if (!rtlpriv->psc.swctrl_lps)
+		return;
+	if (mac->link_state != MAC80211_LINKED)
+		return;
+
+	if (ppsc->reg_rfps_level & RT_RF_LPS_LEVEL_ASPM &&
+	    RT_IN_PS_LEVEL(ppsc, RT_PS_LEVEL_ASPM)) {
+		rtlpriv->intf_ops->disable_aspm(hw);
+		RT_CLEAR_PS_LEVEL(ppsc, RT_PS_LEVEL_ASPM);
+	}
+
+	spin_lock_irqsave(&rtlpriv->locks.lps_lock, flag);
+	rtl_ps_set_rf_state(hw, ERFON, RF_CHANGE_BY_PS, false);
+	spin_unlock_irqrestore(&rtlpriv->locks.lps_lock, flag);
+}
+
+void rtl_swlps_rfon_wq_callback(void *data)
+{
+	struct rtl_works *rtlworks =
+	    container_of_dwork_rtl(data, struct rtl_works, ps_rfon_wq);
+	struct ieee80211_hw *hw = rtlworks->hw;
+
+	rtl_swlps_rf_awake(hw);
+}
+
+void rtl_swlps_rf_sleep(struct ieee80211_hw *hw)
+{
+	struct rtl_priv *rtlpriv = rtl_priv(hw);
+	struct rtl_mac *mac = rtl_mac(rtl_priv(hw));
+	struct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));
+	unsigned long flag;
+	u8 sleep_intv;
+
+	if (!rtlpriv->psc.sw_ps_enabled)
+		return;
+
+	if ((rtlpriv->sec.being_setkey) ||
+	    (mac->opmode == NL80211_IFTYPE_ADHOC))
+		return;
+
+	/*sleep after linked 10s, to let DHCP and 4-way handshake ok enough!! */
+	if ((mac->link_state != MAC80211_LINKED) || (mac->cnt_after_linked < 5))
+		return;
+
+	if (rtlpriv->link_info.busytraffic)
+		return;
+
+	spin_lock(&rtlpriv->locks.rf_ps_lock);
+	if (rtlpriv->psc.rfchange_inprogress) {
+		spin_unlock(&rtlpriv->locks.rf_ps_lock);
+		return;
+	}
+	spin_unlock(&rtlpriv->locks.rf_ps_lock);
+
+	spin_lock_irqsave(&rtlpriv->locks.lps_lock, flag);
+	rtl_ps_set_rf_state(hw, ERFSLEEP, RF_CHANGE_BY_PS , false);
+	spin_unlock_irqrestore(&rtlpriv->locks.lps_lock, flag);
+
+	if (ppsc->reg_rfps_level & RT_RF_OFF_LEVL_ASPM &&
+	    !RT_IN_PS_LEVEL(ppsc, RT_PS_LEVEL_ASPM)) {
+		rtlpriv->intf_ops->enable_aspm(hw);
+		RT_SET_PS_LEVEL(ppsc, RT_PS_LEVEL_ASPM);
+	}
+
+	/* here is power save alg, when this beacon is DTIM
+	 * we will set sleep time to dtim_period * n;
+	 * when this beacon is not DTIM, we will set sleep
+	 * time to sleep_intv = rtlpriv->psc.dtim_counter or
+	 * MAX_SW_LPS_SLEEP_INTV(default set to 5) */
+
+	if (rtlpriv->psc.dtim_counter == 0) {
+		if (hw->conf.ps_dtim_period == 1)
+			sleep_intv = hw->conf.ps_dtim_period * 2;
+		else
+			sleep_intv = hw->conf.ps_dtim_period;
+	} else {
+		sleep_intv = rtlpriv->psc.dtim_counter;
+	}
+
+	if (sleep_intv > MAX_SW_LPS_SLEEP_INTV)
+		sleep_intv = MAX_SW_LPS_SLEEP_INTV;
+
+	/* this print should always be dtim_conter = 0 &
+	 * sleep  = dtim_period, that meaons, we should
+	 * awake before every dtim */
+	RT_TRACE(rtlpriv, COMP_POWER, DBG_DMESG,
+		 "dtim_counter:%x will sleep :%d beacon_intv\n",
+		  rtlpriv->psc.dtim_counter, sleep_intv);
+
+	/* we tested that 40ms is enough for sw & hw sw delay */
+	queue_delayed_work(rtlpriv->works.rtl_wq, &rtlpriv->works.ps_rfon_wq,
+			MSECS(sleep_intv * mac->vif->bss_conf.beacon_int - 40));
+}
+
+void rtl_lps_change_work_callback(struct work_struct *work)
+{
+	struct rtl_works *rtlworks =
+	    container_of(work, struct rtl_works, lps_change_work);
+	struct ieee80211_hw *hw = rtlworks->hw;
+	struct rtl_priv *rtlpriv = rtl_priv(hw);
+
+	if (rtlpriv->enter_ps)
+		rtl_lps_enter(hw);
+	else
+		rtl_lps_leave(hw);
+}
+EXPORT_SYMBOL_GPL(rtl_lps_change_work_callback);
+
+void rtl_swlps_wq_callback(void *data)
+{
+	struct rtl_works *rtlworks = container_of_dwork_rtl(data,
+				     struct rtl_works,
+				     ps_work);
+	struct ieee80211_hw *hw = rtlworks->hw;
+	struct rtl_priv *rtlpriv = rtl_priv(hw);
+	bool ps = false;
+
+	ps = (hw->conf.flags & IEEE80211_CONF_PS);
+
+	/* we can sleep after ps null send ok */
+	if (rtlpriv->psc.state_inap) {
+		rtl_swlps_rf_sleep(hw);
+
+		if (rtlpriv->psc.state && !ps) {
+			rtlpriv->psc.sleep_ms = jiffies_to_msecs(jiffies -
+						 rtlpriv->psc.last_action);
+		}
+
+		if (ps)
+			rtlpriv->psc.last_slept = jiffies;
+
+		rtlpriv->psc.last_action = jiffies;
+		rtlpriv->psc.state = ps;
+	}
+}
+
+static void rtl_p2p_noa_ie(struct ieee80211_hw *hw, void *data,
+			   unsigned int len)
+{
+	struct rtl_priv *rtlpriv = rtl_priv(hw);
+	struct ieee80211_mgmt *mgmt = data;
+	struct rtl_p2p_ps_info *p2pinfo = &(rtlpriv->psc.p2p_ps_info);
+	u8 *pos, *end, *ie;
+	u16 noa_len;
+	static u8 p2p_oui_ie_type[4] = {0x50, 0x6f, 0x9a, 0x09};
+	u8 noa_num, index , i, noa_index = 0;
+	bool find_p2p_ie = false , find_p2p_ps_ie = false;
+	pos = (u8 *)mgmt->u.beacon.variable;
+	end = data + len;
+	ie = NULL;
+
+	while (pos + 1 < end) {
+		if (pos + 2 + pos[1] > end)
+			return;
+
+		if (pos[0] == 221 && pos[1] > 4) {
+			if (memcmp(&pos[2], p2p_oui_ie_type, 4) == 0) {
+				ie = pos + 2+4;
+				break;
+			}
+		}
+		pos += 2 + pos[1];
+	}
+
+	if (ie == NULL)
+		return;
+	find_p2p_ie = true;
+	/*to find noa ie*/
+	while (ie + 1 < end) {
+		noa_len = READEF2BYTE((__le16 *)&ie[1]);
+		if (ie + 3 + ie[1] > end)
+			return;
+
+		if (ie[0] == 12) {
+			find_p2p_ps_ie = true;
+			if ((noa_len - 2) % 13 != 0) {
+				RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,
+					 "P2P notice of absence: invalid length.%d\n",
+					 noa_len);
+				return;
+			} else {
+				noa_num = (noa_len - 2) / 13;
+			}
+			noa_index = ie[3];
+			if (rtlpriv->psc.p2p_ps_info.p2p_ps_mode ==
+			    P2P_PS_NONE || noa_index != p2pinfo->noa_index) {
+				RT_TRACE(rtlpriv, COMP_FW, DBG_LOUD,
+					 "update NOA ie.\n");
+				p2pinfo->noa_index = noa_index;
+				p2pinfo->opp_ps = (ie[4] >> 7);
+				p2pinfo->ctwindow = ie[4] & 0x7F;
+				p2pinfo->noa_num = noa_num;
+				index = 5;
+				for (i = 0; i < noa_num; i++) {
+					p2pinfo->noa_count_type[i] =
+							READEF1BYTE(ie+index);
+					index += 1;
+					p2pinfo->noa_duration[i] =
+						 READEF4BYTE((__le32 *)ie+index);
+					index += 4;
+					p2pinfo->noa_interval[i] =
+						 READEF4BYTE((__le32 *)ie+index);
+					index += 4;
+					p2pinfo->noa_start_time[i] =
+						 READEF4BYTE((__le32 *)ie+index);
+					index += 4;
+				}
+
+				if (p2pinfo->opp_ps == 1) {
+					p2pinfo->p2p_ps_mode = P2P_PS_CTWINDOW;
+					/* Driver should wait LPS entering
+					 * CTWindow
+					 */
+					if (rtlpriv->psc.fw_current_inpsmode)
+						rtl_p2p_ps_cmd(hw,
+							       P2P_PS_ENABLE);
+				} else if (p2pinfo->noa_num > 0) {
+					p2pinfo->p2p_ps_mode = P2P_PS_NOA;
+					rtl_p2p_ps_cmd(hw, P2P_PS_ENABLE);
+				} else if (p2pinfo->p2p_ps_mode > P2P_PS_NONE) {
+					rtl_p2p_ps_cmd(hw, P2P_PS_DISABLE);
+				}
+			}
+			break;
+		}
+		ie += 3 + noa_len;
+	}
+
+	if (find_p2p_ie == true) {
+		if ((p2pinfo->p2p_ps_mode > P2P_PS_NONE) &&
+		    (find_p2p_ps_ie == false))
+			rtl_p2p_ps_cmd(hw, P2P_PS_DISABLE);
+	}
+}
+
+static void rtl_p2p_action_ie(struct ieee80211_hw *hw, void *data,
+			      unsigned int len)
+{
+	struct rtl_priv *rtlpriv = rtl_priv(hw);
+	struct ieee80211_mgmt *mgmt = data;
+	struct rtl_p2p_ps_info *p2pinfo = &(rtlpriv->psc.p2p_ps_info);
+	u8 noa_num, index , i , noa_index = 0;
+	u8 *pos, *end, *ie;
+	u16 noa_len;
+	static u8 p2p_oui_ie_type[4] = {0x50, 0x6f, 0x9a, 0x09};
+
+	pos = (u8 *)&mgmt->u.action.category;
+	end = data + len;
+	ie = NULL;
+
+	if (pos[0] == 0x7f) {
+		if (memcmp(&pos[1], p2p_oui_ie_type, 4) == 0)
+			ie = pos + 3+4;
+	}
+
+	if (ie == NULL)
+		return;
+
+	RT_TRACE(rtlpriv, COMP_FW, DBG_LOUD, "action frame find P2P IE.\n");
+	/*to find noa ie*/
+	while (ie + 1 < end) {
+		noa_len = READEF2BYTE((__le16 *)&ie[1]);
+		if (ie + 3 + ie[1] > end)
+			return;
+
+		if (ie[0] == 12) {
+			RT_TRACE(rtlpriv, COMP_FW, DBG_LOUD, "find NOA IE.\n");
+			RT_PRINT_DATA(rtlpriv, COMP_FW, DBG_LOUD, "noa ie ",
+				      ie, noa_len);
+			if ((noa_len - 2) % 13 != 0) {
+				RT_TRACE(rtlpriv, COMP_FW, DBG_LOUD,
+					 "P2P notice of absence: invalid length.%d\n",
+					 noa_len);
+				return;
+			} else {
+				noa_num = (noa_len - 2) / 13;
+			}
+			noa_index = ie[3];
+			if (rtlpriv->psc.p2p_ps_info.p2p_ps_mode ==
+			    P2P_PS_NONE || noa_index != p2pinfo->noa_index) {
+				p2pinfo->noa_index = noa_index;
+				p2pinfo->opp_ps = (ie[4] >> 7);
+				p2pinfo->ctwindow = ie[4] & 0x7F;
+				p2pinfo->noa_num = noa_num;
+				index = 5;
+				for (i = 0; i < noa_num; i++) {
+					p2pinfo->noa_count_type[i] =
+							READEF1BYTE(ie+index);
+					index += 1;
+					p2pinfo->noa_duration[i] =
+							 READEF4BYTE((__le32 *)ie+index);
+					index += 4;
+					p2pinfo->noa_interval[i] =
+							 READEF4BYTE((__le32 *)ie+index);
+					index += 4;
+					p2pinfo->noa_start_time[i] =
+							 READEF4BYTE((__le32 *)ie+index);
+					index += 4;
+				}
+
+				if (p2pinfo->opp_ps == 1) {
+					p2pinfo->p2p_ps_mode = P2P_PS_CTWINDOW;
+					/* Driver should wait LPS entering
+					 * CTWindow
+					 */
+					if (rtlpriv->psc.fw_current_inpsmode)
+						rtl_p2p_ps_cmd(hw,
+							       P2P_PS_ENABLE);
+				} else if (p2pinfo->noa_num > 0) {
+					p2pinfo->p2p_ps_mode = P2P_PS_NOA;
+					rtl_p2p_ps_cmd(hw, P2P_PS_ENABLE);
+				} else if (p2pinfo->p2p_ps_mode > P2P_PS_NONE) {
+					rtl_p2p_ps_cmd(hw, P2P_PS_DISABLE);
+				}
+			}
+			break;
+		}
+		ie += 3 + noa_len;
+	}
+}
+
+void rtl_p2p_ps_cmd(struct ieee80211_hw *hw , u8 p2p_ps_state)
+{
+	struct rtl_priv *rtlpriv = rtl_priv(hw);
+	struct rtl_ps_ctl *rtlps = rtl_psc(rtl_priv(hw));
+	struct rtl_p2p_ps_info  *p2pinfo = &(rtlpriv->psc.p2p_ps_info);
+
+	RT_TRACE(rtlpriv, COMP_FW, DBG_LOUD, " p2p state %x\n" , p2p_ps_state);
+	switch (p2p_ps_state) {
+	case P2P_PS_DISABLE:
+		p2pinfo->p2p_ps_state = p2p_ps_state;
+		rtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_H2C_FW_P2P_PS_OFFLOAD,
+					      &p2p_ps_state);
+		p2pinfo->noa_index = 0;
+		p2pinfo->ctwindow = 0;
+		p2pinfo->opp_ps = 0;
+		p2pinfo->noa_num = 0;
+		p2pinfo->p2p_ps_mode = P2P_PS_NONE;
+		if (rtlps->fw_current_inpsmode) {
+			if (rtlps->smart_ps == 0) {
+				rtlps->smart_ps = 2;
+				rtlpriv->cfg->ops->set_hw_reg(hw,
+					 HW_VAR_H2C_FW_PWRMODE,
+					 &rtlps->pwr_mode);
+			}
+
+		}
+		break;
+	case P2P_PS_ENABLE:
+		if (p2pinfo->p2p_ps_mode > P2P_PS_NONE) {
+			p2pinfo->p2p_ps_state = p2p_ps_state;
+
+			if (p2pinfo->ctwindow > 0) {
+				if (rtlps->smart_ps != 0) {
+					rtlps->smart_ps = 0;
+					rtlpriv->cfg->ops->set_hw_reg(hw,
+						 HW_VAR_H2C_FW_PWRMODE,
+						 &rtlps->pwr_mode);
+				}
+			}
+			rtlpriv->cfg->ops->set_hw_reg(hw,
+				 HW_VAR_H2C_FW_P2P_PS_OFFLOAD,
+				 &p2p_ps_state);
+
+		}
+		break;
+	case P2P_PS_SCAN:
+	case P2P_PS_SCAN_DONE:
+	case P2P_PS_ALLSTASLEEP:
+		if (p2pinfo->p2p_ps_mode > P2P_PS_NONE) {
+			p2pinfo->p2p_ps_state = p2p_ps_state;
+			rtlpriv->cfg->ops->set_hw_reg(hw,
+				 HW_VAR_H2C_FW_P2P_PS_OFFLOAD,
+				 &p2p_ps_state);
+		}
+		break;
+	default:
+		break;
+	}
+	RT_TRACE(rtlpriv, COMP_FW, DBG_LOUD,
+		 "ctwindow %x oppps %x\n",
+		 p2pinfo->ctwindow , p2pinfo->opp_ps);
+	RT_TRACE(rtlpriv, COMP_FW, DBG_LOUD,
+		 "count %x duration %x index %x interval %x start time %x noa num %x\n",
+		 p2pinfo->noa_count_type[0],
+		 p2pinfo->noa_duration[0],
+		 p2pinfo->noa_index,
+		 p2pinfo->noa_interval[0],
+		 p2pinfo->noa_start_time[0],
+		 p2pinfo->noa_num);
+	RT_TRACE(rtlpriv, COMP_FW, DBG_LOUD, "end\n");
+}
+
+void rtl_p2p_info(struct ieee80211_hw *hw, void *data, unsigned int len)
+{
+	struct rtl_priv *rtlpriv = rtl_priv(hw);
+	struct rtl_mac *mac = rtl_mac(rtl_priv(hw));
+	struct ieee80211_hdr *hdr = data;
+
+	if (!mac->p2p)
+		return;
+	if (mac->link_state != MAC80211_LINKED)
+		return;
+	/* min. beacon length + FCS_LEN */
+	if (len <= 40 + FCS_LEN)
+		return;
+
+	/* and only beacons from the associated BSSID, please */
+	if (!ether_addr_equal_64bits(hdr->addr3, rtlpriv->mac80211.bssid))
+		return;
+
+	/* check if this really is a beacon */
+	if (!(ieee80211_is_beacon(hdr->frame_control) ||
+	      ieee80211_is_probe_resp(hdr->frame_control) ||
+	      ieee80211_is_action(hdr->frame_control)))
+		return;
+
+	if (ieee80211_is_action(hdr->frame_control))
+		rtl_p2p_action_ie(hw , data , len - FCS_LEN);
+	else
+		rtl_p2p_noa_ie(hw , data , len - FCS_LEN);
+}
+EXPORT_SYMBOL_GPL(rtl_p2p_info);
diff -Naur linux-4.9/drivers/staging/rtl8821au/ps.h linux-4.9.8821au/drivers/staging/rtl8821au/ps.h
--- linux-4.9/drivers/staging/rtl8821au/ps.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/ps.h	2016-12-11 19:48:25.180311687 -0600
@@ -0,0 +1,53 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2009-2012  Realtek Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called LICENSE.
+ *
+ * Contact Information:
+ * wlanfae <wlanfae@realtek.com>
+ * Realtek Corporation, No. 2, Innovation Road II, Hsinchu Science Park,
+ * Hsinchu 300, Taiwan.
+ *
+ * Larry Finger <Larry.Finger@lwfinger.net>
+ *
+ *****************************************************************************/
+
+#ifndef __REALTEK_RTL_PCI_PS_H__
+#define __REALTEK_RTL_PCI_PS_H__
+
+#define MAX_SW_LPS_SLEEP_INTV	5
+
+bool rtl_ps_set_rf_state(struct ieee80211_hw *hw,
+			 enum rf_pwrstate state_toset, u32 changesource,
+			 bool protect_or_not);
+bool rtl_ps_enable_nic(struct ieee80211_hw *hw);
+bool rtl_ps_disable_nic(struct ieee80211_hw *hw);
+void rtl_ips_nic_off(struct ieee80211_hw *hw);
+void rtl_ips_nic_on(struct ieee80211_hw *hw);
+void rtl_ips_nic_off_wq_callback(void *data);
+void rtl_lps_enter(struct ieee80211_hw *hw);
+void rtl_lps_leave(struct ieee80211_hw *hw);
+
+void rtl_lps_set_psmode(struct ieee80211_hw *hw, u8 rt_psmode);
+
+void rtl_swlps_beacon(struct ieee80211_hw *hw, void *data, unsigned int len);
+void rtl_swlps_wq_callback(void *data);
+void rtl_swlps_rfon_wq_callback(void *data);
+void rtl_swlps_rf_awake(struct ieee80211_hw *hw);
+void rtl_swlps_rf_sleep(struct ieee80211_hw *hw);
+void rtl_p2p_ps_cmd(struct ieee80211_hw *hw , u8 p2p_ps_state);
+void rtl_p2p_info(struct ieee80211_hw *hw, void *data, unsigned int len);
+void rtl_lps_change_work_callback(struct work_struct *work);
+
+#endif
diff -Naur linux-4.9/drivers/staging/rtl8821au/rtl8821au/def.h linux-4.9.8821au/drivers/staging/rtl8821au/rtl8821au/def.h
--- linux-4.9/drivers/staging/rtl8821au/rtl8821au/def.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/rtl8821au/def.h	2016-12-11 19:48:25.180311687 -0600
@@ -0,0 +1,193 @@
+#ifndef __RTL8821AU_DEF_H__
+#define __RTL8821AU_DEF_H__
+
+#include <linux/types.h>
+#include <linux/bitops.h>
+
+enum MGN_RATE{
+	MGN_1M		= 0x02,
+	MGN_2M		= 0x04,
+	MGN_5_5M 	= 0x0B,
+	MGN_6M	 	= 0x0C,
+	MGN_9M		= 0x12,
+	MGN_11M 	= 0x16,
+	MGN_12M	= 0x18,
+	MGN_18M	= 0x24,
+	MGN_24M	= 0x30,
+	MGN_36M	= 0x48,
+	MGN_48M	= 0x60,
+	MGN_54M	= 0x6C,
+	MGN_MCS32	= 0x7F,
+	MGN_MCS0,
+	MGN_MCS1,
+	MGN_MCS2,
+	MGN_MCS3,
+	MGN_MCS4,
+	MGN_MCS5,
+	MGN_MCS6,
+	MGN_MCS7,
+	MGN_MCS8,
+	MGN_MCS9,
+	MGN_MCS10,
+	MGN_MCS11,
+	MGN_MCS12,
+	MGN_MCS13,
+	MGN_MCS14,
+	MGN_MCS15,
+	MGN_MCS16,
+	MGN_MCS17,
+	MGN_MCS18,
+	MGN_MCS19,
+	MGN_MCS20,
+	MGN_MCS21,
+	MGN_MCS22,
+	MGN_MCS23,
+	MGN_MCS24,
+	MGN_MCS25,
+	MGN_MCS26,
+	MGN_MCS27,
+	MGN_MCS28,
+	MGN_MCS29,
+	MGN_MCS30,
+	MGN_MCS31,
+	MGN_VHT1SS_MCS0,
+	MGN_VHT1SS_MCS1,
+	MGN_VHT1SS_MCS2,
+	MGN_VHT1SS_MCS3,
+	MGN_VHT1SS_MCS4,
+	MGN_VHT1SS_MCS5,
+	MGN_VHT1SS_MCS6,
+	MGN_VHT1SS_MCS7,
+	MGN_VHT1SS_MCS8,
+	MGN_VHT1SS_MCS9,
+	MGN_VHT2SS_MCS0,
+	MGN_VHT2SS_MCS1,
+	MGN_VHT2SS_MCS2,
+	MGN_VHT2SS_MCS3,
+	MGN_VHT2SS_MCS4,
+	MGN_VHT2SS_MCS5,
+	MGN_VHT2SS_MCS6,
+	MGN_VHT2SS_MCS7,
+	MGN_VHT2SS_MCS8,
+	MGN_VHT2SS_MCS9,
+	MGN_VHT3SS_MCS0,
+	MGN_VHT3SS_MCS1,
+	MGN_VHT3SS_MCS2,
+	MGN_VHT3SS_MCS3,
+	MGN_VHT3SS_MCS4,
+	MGN_VHT3SS_MCS5,
+	MGN_VHT3SS_MCS6,
+	MGN_VHT3SS_MCS7,
+	MGN_VHT3SS_MCS8,
+	MGN_VHT3SS_MCS9,
+	MGN_VHT4SS_MCS0,
+	MGN_VHT4SS_MCS1,
+	MGN_VHT4SS_MCS2,
+	MGN_VHT4SS_MCS3,
+	MGN_VHT4SS_MCS4,
+	MGN_VHT4SS_MCS5,
+	MGN_VHT4SS_MCS6,
+	MGN_VHT4SS_MCS7,
+	MGN_VHT4SS_MCS8,
+	MGN_VHT4SS_MCS9,
+	MGN_UNKNOWN
+};
+
+enum rtl_desc_qsel {
+	QSLT_BK = 0x2,
+	QSLT_BE = 0x0,
+	QSLT_VI = 0x5,
+	QSLT_VO = 0x7,
+	QSLT_BEACON = 0x10,
+	QSLT_HIGH = 0x11,
+	QSLT_MGNT = 0x12,
+	QSLT_CMD = 0x13,
+};
+
+//VERSION_8192C			VersionID;
+//HAL_VERSION			VersionID;
+
+enum version_8821au {
+	CHIP_8812 =	BIT(2),
+	CHIP_8821 = 	(BIT(0)|BIT(2)),
+	NORMAL_CHIP =	BIT(3),
+	RF_TYPE_1T1R =	(~(BIT(4)|BIT(5)|BIT(6))),
+	RF_TYPE_1T2R =	BIT(4),
+	RF_TYPE_2T2R =	BIT(5),
+	CHIP_VENDOR_UMC = BIT(7),
+	B_CUT_VERSION =	BIT(12),
+	C_CUT_VERSION = BIT(13),
+	D_CUT_VERSION =	((BIT(12)|BIT(13))),
+	E_CUT_VERSION = BIT(14),
+
+	/* ULLI : our own bitfield, form pHalData->bSupportUSB3 */
+
+	RTL8821AU_USB3_MODE = BIT(15),
+	
+	VERSION_UNKNOWN = 0x0,
+};
+
+#define IF_RTL8821AU_USB3_MODE(version)		((version) & RTL8821AU_USB3_MODE)
+
+
+/* MASK */
+#define IC_TYPE_MASK			(BIT(0)|BIT(1)|BIT(2))
+#define CHIP_TYPE_MASK			BIT(3)
+#define RF_TYPE_MASK			(BIT(4)|BIT(5)|BIT(6))
+#define MANUFACTUER_MASK		BIT(7)
+#define CUT_VERSION_MASK		(BIT(15)|BIT(14)|BIT(13)|BIT(12))
+
+
+// Get element
+#define GET_CVID_IC_TYPE(version)	((version) & IC_TYPE_MASK)
+#define GET_CVID_CHIP_TYPE(version)	((version) & CHIP_TYPE_MASK)
+#define GET_CVID_RF_TYPE(version)	((version) & RF_TYPE_MASK)
+#define GET_CVID_MANUFACTUER(version)	((version) & MANUFACTUER_MASK)
+#define GET_CVID_CUT_VERSION(version)	((version) & CUT_VERSION_MASK)
+#define NUM_CUT_VERSION(version)	(GET_CVID_CUT_VERSION(version) >> 12)
+#define GET_CVID_ROM_VERSION(version)	(((version)) & ROM_VERSION_MASK)
+
+//----------------------------------------------------------------------------
+//Common Macro. --
+//----------------------------------------------------------------------------
+//HAL_VERSION VersionID
+
+// HAL_IC_TYPE_E
+#define IS_8812_SERIES(version)			((GET_CVID_IC_TYPE(version) == CHIP_8812)? true : false)
+#define IS_8821_SERIES(version)			((GET_CVID_IC_TYPE(version) == CHIP_8821)? true : false)
+#define IS_NORMAL_CHIP(version)			((GET_CVID_CHIP_TYPE(version))? true: false)
+
+//HAL_CUT_VERSION_E
+#define IS_B_CUT(version)				((GET_CVID_CUT_VERSION(version) == B_CUT_VERSION) ? true : false)
+
+//HAL_VENDOR_E
+#define IS_CHIP_VENDOR_TSMC(version)	((GET_CVID_MANUFACTUER(version) == CHIP_VENDOR_TSMC)? true: false)
+#define IS_CHIP_VENDOR_UMC(version)	((GET_CVID_MANUFACTUER(version) == CHIP_VENDOR_UMC)? true: false)
+#define IS_CHIP_VENDOR_SMIC(version)	((GET_CVID_MANUFACTUER(version) == CHIP_VENDOR_SMIC)? true: false)
+
+//HAL_RF_TYPE_E
+#define IS_1T1R(version)					((GET_CVID_RF_TYPE(version) == RF_TYPE_1T1R)? true : false )
+#define IS_1T2R(version)					((GET_CVID_RF_TYPE(version) == RF_TYPE_1T2R)? true : false )
+#define IS_2T2R(version)					((GET_CVID_RF_TYPE(version) == RF_TYPE_2T2R)? true : false )
+
+
+//----------------------------------------------------------------------------
+//Chip version Macro. --
+//----------------------------------------------------------------------------
+#define IS_81XXC_TEST_CHIP(version)		((IS_81XXC(version) && (!IS_NORMAL_CHIP(version)))? true: false)
+
+#define IS_92C_SERIAL(version)   					((IS_81XXC(version) && IS_2T2R(version)) ? true : false)
+#define IS_81xxC_VENDOR_UMC_B_CUT(version)	(IS_81XXC(version)?(IS_CHIP_VENDOR_UMC(version) ? (IS_B_CUT(version) ? true : false) : false): false)
+#define IS_81xxC_VENDOR_UMC_C_CUT(version)	(IS_81XXC(version)?(IS_CHIP_VENDOR_UMC(version) ? (IS_C_CUT(version) ? true : false) : false): false)
+
+#define IS_VENDOR_8812A_TEST_CHIP(version)		((IS_8812_SERIES(version)) ? ((IS_NORMAL_CHIP(version)) ? false : true) : false)
+#define IS_VENDOR_8812A_MP_CHIP(version)		((IS_8812_SERIES(version)) ? ((IS_NORMAL_CHIP(version)) ? true : false) : false)
+#define IS_VENDOR_8812A_C_CUT(version)			((IS_8812_SERIES(version)) ? ((GET_CVID_CUT_VERSION(version) == C_CUT_VERSION) ? true : false) : false)
+
+#define IS_VENDOR_8821A_TEST_CHIP(version)	((IS_8821_SERIES(version)) ? ((IS_NORMAL_CHIP(version) ? false : true) : false)
+#define IS_VENDOR_8821A_MP_CHIP(version)		((IS_8821_SERIES(version)) ? ((IS_NORMAL_CHIP(version)) ? true : false) : false)
+
+#define MAX_RX_DMA_BUFFER_SIZE_8821                    0x3E80  // RX 16K
+
+
+#endif
diff -Naur linux-4.9/drivers/staging/rtl8821au/rtl8821au/dm.c linux-4.9.8821au/drivers/staging/rtl8821au/rtl8821au/dm.c
--- linux-4.9/drivers/staging/rtl8821au/rtl8821au/dm.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/rtl8821au/dm.c	2016-12-11 19:48:25.180311687 -0600
@@ -0,0 +1,2409 @@
+#ifdef CONFIG_RTLWIFI
+
+#include <../drivers/net/wireless/realtek/rtlwifi/wifi.h>
+#include <../drivers/net/wireless/realtek/rtlwifi/base.h>
+
+#else
+
+#include <drv_types.h>
+#include "dm.h"
+#include "phy.h"
+#include "reg.h"
+#include "fw.h"
+
+#endif
+
+static const u32 txscalling_tbl[TXSCALE_TABLE_SIZE] = {
+	0x081, /* 0,  -12.0dB */
+	0x088, /* 1,  -11.5dB */
+	0x090, /* 2,  -11.0dB */
+	0x099, /* 3,  -10.5dB */
+	0x0A2, /* 4,  -10.0dB */
+	0x0AC, /* 5,  -9.5dB */
+	0x0B6, /* 6,  -9.0dB */
+	0x0C0, /* 7,  -8.5dB */
+	0x0CC, /* 8,  -8.0dB */
+	0x0D8, /* 9,  -7.5dB */
+	0x0E5, /* 10, -7.0dB */
+	0x0F2, /* 11, -6.5dB */
+	0x101, /* 12, -6.0dB */
+	0x110, /* 13, -5.5dB */
+	0x120, /* 14, -5.0dB */
+	0x131, /* 15, -4.5dB */
+	0x143, /* 16, -4.0dB */
+	0x156, /* 17, -3.5dB */
+	0x16A, /* 18, -3.0dB */
+	0x180, /* 19, -2.5dB */
+	0x197, /* 20, -2.0dB */
+	0x1AF, /* 21, -1.5dB */
+	0x1C8, /* 22, -1.0dB */
+	0x1E3, /* 23, -0.5dB */
+	0x200, /* 24, +0  dB */
+	0x21E, /* 25, +0.5dB */
+	0x23E, /* 26, +1.0dB */
+	0x261, /* 27, +1.5dB */
+	0x285, /* 28, +2.0dB */
+	0x2AB, /* 29, +2.5dB */
+	0x2D3, /* 30, +3.0dB */
+	0x2FE, /* 31, +3.5dB */
+	0x32B, /* 32, +4.0dB */
+	0x35C, /* 33, +4.5dB */
+	0x38E, /* 34, +5.0dB */
+	0x3C4, /* 35, +5.5dB */
+	0x3FE  /* 36, +6.0dB */
+};
+
+static void rtl8821au_dm_dig(struct rtl_priv *rtlpriuv);
+
+static const u32 edca_setting_ul[HT_IOT_PEER_MAX] = {
+	0x5e4322,	/*  0 UNKNOWN */
+	0xa44f,		/*  1 REALTEK_90 */
+	0x5e4322,	/*  2 REALTEK_92SE */
+	0x5ea32b,	/*  3 BROADCOM */
+	0x5ea422,	/*  4 RALINK */
+	0x5ea322,	/*  5 ATHEROS */
+	0x3ea430,	/*  6 CISCO */
+	0x5ea42b,	/*  7 MERU */
+	0x5ea44f,	/*  8 MARVELL */
+	0x5e4322,	/*  9 92U_AP */
+	0x5e4322,	/* 10 SELF_AP(DownLink/Tx) */
+};
+
+
+static const u32 edca_setting_dl[HT_IOT_PEER_MAX] = {
+	0xa44f,		/*  0 UNKNOWN */
+	0x5ea44f,	/*  1 REALTEK_90 */
+	0x5e4322,	/*  2 REALTEK_92SE */
+	0x5ea42b,	/*  3 BROADCOM */
+	0xa44f,		/*  4 RALINK */
+	0xa630,		/*  5 ATHEROS */
+	0x5ea630,	/*  6 CISCO */
+	0x5ea42b,	/*  7 MERU */
+	0xa44f,		/*  8 MARVELL */
+	0xa42b,		/*  9 92U_AP */
+	0xa42b		/* 10 SELF_AP(UpLink/Rx) */
+};
+
+static const u32 edca_setting_gmode[HT_IOT_PEER_MAX] = {
+	0x4322,		/*  0 UNKNOWN */
+	0xa44f,		/*  1 REALTEK_90 */
+	0x5e4322,	/*  2 REALTEK_92SE */
+	0xa42b,		/*  3 BROADCOM */
+	0x5e4322,	/*  4 RALINK */
+	0x4322,		/*  5 ATHEROS */
+	0xa42b,		/*  6 CISCO */
+	0x5ea42b,	/*  7 MERU */
+	0xa44f,		/*  8 MARVELL */
+	0x5e4322,	/*  9 92U_AP */
+	0x5ea42b	/* 10 SELF_AP */
+};
+
+const u8 cckswing_table_ch1ch13_new[CCK_TABLE_SIZE][8] = {
+	{0x09, 0x08, 0x07, 0x06, 0x04, 0x03, 0x01, 0x01},	/*  0, -16.0dB */
+	{0x09, 0x09, 0x08, 0x06, 0x05, 0x03, 0x01, 0x01},	/*  1, -15.5dB */
+	{0x0a, 0x09, 0x08, 0x07, 0x05, 0x03, 0x02, 0x01},	/*  2, -15.0dB */
+	{0x0a, 0x0a, 0x09, 0x07, 0x05, 0x03, 0x02, 0x01},	/*  3, -14.5dB */
+	{0x0b, 0x0a, 0x09, 0x08, 0x06, 0x04, 0x02, 0x01},	/*  4, -14.0dB */
+	{0x0b, 0x0b, 0x0a, 0x08, 0x06, 0x04, 0x02, 0x01},	/*  5, -13.5dB */
+	{0x0c, 0x0c, 0x0a, 0x09, 0x06, 0x04, 0x02, 0x01},	/*  6, -13.0dB */
+	{0x0d, 0x0c, 0x0b, 0x09, 0x07, 0x04, 0x02, 0x01},	/*  7, -12.5dB */
+	{0x0d, 0x0d, 0x0c, 0x0a, 0x07, 0x05, 0x02, 0x01},	/*  8, -12.0dB */
+	{0x0e, 0x0e, 0x0c, 0x0a, 0x08, 0x05, 0x02, 0x01},	/*  9, -11.5dB */
+	{0x0f, 0x0f, 0x0d, 0x0b, 0x08, 0x05, 0x03, 0x01},	/* 10, -11.0dB */
+	{0x10, 0x10, 0x0e, 0x0b, 0x08, 0x05, 0x03, 0x01},	/* 11, -10.5dB */
+	{0x11, 0x11, 0x0f, 0x0c, 0x09, 0x06, 0x03, 0x01},	/* 12, -10.0dB */
+	{0x12, 0x12, 0x0f, 0x0c, 0x09, 0x06, 0x03, 0x01},	/* 13, -9.5dB */
+	{0x13, 0x13, 0x10, 0x0d, 0x0a, 0x06, 0x03, 0x01},	/* 14, -9.0dB */
+	{0x14, 0x14, 0x11, 0x0e, 0x0b, 0x07, 0x03, 0x02},	/* 15, -8.5dB */
+	{0x16, 0x15, 0x12, 0x0f, 0x0b, 0x07, 0x04, 0x01},	/* 16, -8.0dB */
+	{0x17, 0x16, 0x13, 0x10, 0x0c, 0x08, 0x04, 0x02},	/* 17, -7.5dB */
+	{0x18, 0x17, 0x15, 0x11, 0x0c, 0x08, 0x04, 0x02},	/* 18, -7.0dB */
+	{0x1a, 0x19, 0x16, 0x12, 0x0d, 0x09, 0x04, 0x02},	/* 19, -6.5dB */
+	{0x1b, 0x1a, 0x17, 0x13, 0x0e, 0x09, 0x04, 0x02},	/* 20, -6.0dB */
+	{0x1d, 0x1c, 0x18, 0x14, 0x0f, 0x0a, 0x05, 0x02},	/* 21, -5.5dB */
+	{0x1f, 0x1e, 0x1a, 0x15, 0x10, 0x0a, 0x05, 0x02},	/* 22, -5.0dB */
+	{0x20, 0x20, 0x1b, 0x16, 0x11, 0x08, 0x05, 0x02},	/* 23, -4.5dB */
+	{0x22, 0x21, 0x1d, 0x18, 0x11, 0x0b, 0x06, 0x02},	/* 24, -4.0dB */
+	{0x24, 0x23, 0x1f, 0x19, 0x13, 0x0c, 0x06, 0x03},	/* 25, -3.5dB */
+	{0x26, 0x25, 0x21, 0x1b, 0x14, 0x0d, 0x06, 0x03},	/* 26, -3.0dB */
+	{0x28, 0x28, 0x22, 0x1c, 0x15, 0x0d, 0x07, 0x03},	/* 27, -2.5dB */
+	{0x2b, 0x2a, 0x25, 0x1e, 0x16, 0x0e, 0x07, 0x03},	/* 28, -2.0dB */
+	{0x2d, 0x2d, 0x27, 0x1f, 0x18, 0x0f, 0x08, 0x03},	/* 29, -1.5dB */
+	{0x30, 0x2f, 0x29, 0x21, 0x19, 0x10, 0x08, 0x03},	/* 30, -1.0dB */
+	{0x33, 0x32, 0x2b, 0x23, 0x1a, 0x11, 0x08, 0x04},	/* 31, -0.5dB */
+	{0x36, 0x35, 0x2e, 0x25, 0x1c, 0x12, 0x09, 0x04} 	/* 32, +0dB */
+};
+
+const u8 cckswing_table_ch14_new[CCK_TABLE_SIZE][8] = {
+	{0x09, 0x08, 0x07, 0x04, 0x00, 0x00, 0x00, 0x00},	/*  0, -16.0dB */
+	{0x09, 0x09, 0x08, 0x05, 0x00, 0x00, 0x00, 0x00},	/*  1, -15.5dB */
+	{0x0a, 0x09, 0x08, 0x05, 0x00, 0x00, 0x00, 0x00},	/*  2, -15.0dB */
+	{0x0a, 0x0a, 0x09, 0x05, 0x00, 0x00, 0x00, 0x00},	/*  3, -14.5dB */
+	{0x0b, 0x0a, 0x09, 0x05, 0x00, 0x00, 0x00, 0x00},	/*  4, -14.0dB */
+	{0x0b, 0x0b, 0x0a, 0x06, 0x00, 0x00, 0x00, 0x00},	/*  5, -13.5dB */
+	{0x0c, 0x0c, 0x0a, 0x06, 0x00, 0x00, 0x00, 0x00},	/*  6, -13.0dB */
+	{0x0d, 0x0c, 0x0b, 0x06, 0x00, 0x00, 0x00, 0x00},	/*  7, -12.5dB */
+	{0x0d, 0x0d, 0x0c, 0x07, 0x00, 0x00, 0x00, 0x00},	/*  8, -12.0dB */
+	{0x0e, 0x0e, 0x0c, 0x07, 0x00, 0x00, 0x00, 0x00},	/*  9, -11.5dB */
+	{0x0f, 0x0f, 0x0d, 0x08, 0x00, 0x00, 0x00, 0x00},	/* 10, -11.0dB */
+	{0x10, 0x10, 0x0e, 0x08, 0x00, 0x00, 0x00, 0x00},	/* 11, -10.5dB */
+	{0x11, 0x11, 0x0f, 0x09, 0x00, 0x00, 0x00, 0x00},	/* 12, -10.0dB */
+	{0x12, 0x12, 0x0f, 0x09, 0x00, 0x00, 0x00, 0x00},	/* 13, -9.5dB */
+	{0x13, 0x13, 0x10, 0x0a, 0x00, 0x00, 0x00, 0x00},	/* 14, -9.0dB */
+	{0x14, 0x14, 0x11, 0x0a, 0x00, 0x00, 0x00, 0x00},	/* 15, -8.5dB */
+	{0x16, 0x15, 0x12, 0x0b, 0x00, 0x00, 0x00, 0x00},	/* 16, -8.0dB */
+	{0x17, 0x16, 0x13, 0x0b, 0x00, 0x00, 0x00, 0x00},	/* 17, -7.5dB */
+	{0x18, 0x17, 0x15, 0x0c, 0x00, 0x00, 0x00, 0x00},	/* 18, -7.0dB */
+	{0x1a, 0x19, 0x16, 0x0d, 0x00, 0x00, 0x00, 0x00},	/* 19, -6.5dB */
+	{0x1b, 0x1a, 0x17, 0x0e, 0x00, 0x00, 0x00, 0x00},	/* 20, -6.0dB */
+	{0x1d, 0x1c, 0x18, 0x0e, 0x00, 0x00, 0x00, 0x00},	/* 21, -5.5dB */
+	{0x1f, 0x1e, 0x1a, 0x0f, 0x00, 0x00, 0x00, 0x00},	/* 22, -5.0dB */
+	{0x20, 0x20, 0x1b, 0x10, 0x00, 0x00, 0x00, 0x00},	/* 23, -4.5dB */
+	{0x22, 0x21, 0x1d, 0x11, 0x00, 0x00, 0x00, 0x00},	/* 24, -4.0dB */
+	{0x24, 0x23, 0x1f, 0x12, 0x00, 0x00, 0x00, 0x00},	/* 25, -3.5dB */
+	{0x26, 0x25, 0x21, 0x13, 0x00, 0x00, 0x00, 0x00},	/* 26, -3.0dB */
+	{0x28, 0x28, 0x24, 0x14, 0x00, 0x00, 0x00, 0x00},	/* 27, -2.5dB */
+	{0x2b, 0x2a, 0x25, 0x15, 0x00, 0x00, 0x00, 0x00},	/* 28, -2.0dB */
+	{0x2d, 0x2d, 0x17, 0x17, 0x00, 0x00, 0x00, 0x00},	/* 29, -1.5dB */
+	{0x30, 0x2f, 0x29, 0x18, 0x00, 0x00, 0x00, 0x00},	/* 30, -1.0dB */
+	{0x33, 0x32, 0x2b, 0x19, 0x00, 0x00, 0x00, 0x00},	/* 31, -0.5dB */
+	{0x36, 0x35, 0x2e, 0x1b, 0x00, 0x00, 0x00, 0x00} 	/* 32, +0dB */
+};
+
+
+const u8 cckswing_table_ch1ch13[CCK_TABLE_SIZE][8] = {
+	{0x36, 0x35, 0x2e, 0x25, 0x1c, 0x12, 0x09, 0x04},	/* 0, +0dB */
+	{0x33, 0x32, 0x2b, 0x23, 0x1a, 0x11, 0x08, 0x04},	/* 1, -0.5dB */
+	{0x30, 0x2f, 0x29, 0x21, 0x19, 0x10, 0x08, 0x03},	/* 2, -1.0dB */
+	{0x2d, 0x2d, 0x27, 0x1f, 0x18, 0x0f, 0x08, 0x03},	/* 3, -1.5dB */
+	{0x2b, 0x2a, 0x25, 0x1e, 0x16, 0x0e, 0x07, 0x03},	/* 4, -2.0dB */
+	{0x28, 0x28, 0x22, 0x1c, 0x15, 0x0d, 0x07, 0x03},	/* 5, -2.5dB */
+	{0x26, 0x25, 0x21, 0x1b, 0x14, 0x0d, 0x06, 0x03},	/* 6, -3.0dB */
+	{0x24, 0x23, 0x1f, 0x19, 0x13, 0x0c, 0x06, 0x03},	/* 7, -3.5dB */
+	{0x22, 0x21, 0x1d, 0x18, 0x11, 0x0b, 0x06, 0x02},	/* 8, -4.0dB */
+	{0x20, 0x20, 0x1b, 0x16, 0x11, 0x08, 0x05, 0x02},	/* 9, -4.5dB */
+	{0x1f, 0x1e, 0x1a, 0x15, 0x10, 0x0a, 0x05, 0x02},	/* 10, -5.0dB */
+	{0x1d, 0x1c, 0x18, 0x14, 0x0f, 0x0a, 0x05, 0x02},	/* 11, -5.5dB */
+	{0x1b, 0x1a, 0x17, 0x13, 0x0e, 0x09, 0x04, 0x02},	/* 12, -6.0dB <== default */
+	{0x1a, 0x19, 0x16, 0x12, 0x0d, 0x09, 0x04, 0x02},	/* 13, -6.5dB */
+	{0x18, 0x17, 0x15, 0x11, 0x0c, 0x08, 0x04, 0x02},	/* 14, -7.0dB */
+	{0x17, 0x16, 0x13, 0x10, 0x0c, 0x08, 0x04, 0x02},	/* 15, -7.5dB */
+	{0x16, 0x15, 0x12, 0x0f, 0x0b, 0x07, 0x04, 0x01},	/* 16, -8.0dB */
+	{0x14, 0x14, 0x11, 0x0e, 0x0b, 0x07, 0x03, 0x02},	/* 17, -8.5dB */
+	{0x13, 0x13, 0x10, 0x0d, 0x0a, 0x06, 0x03, 0x01},	/* 18, -9.0dB */
+	{0x12, 0x12, 0x0f, 0x0c, 0x09, 0x06, 0x03, 0x01},	/* 19, -9.5dB */
+	{0x11, 0x11, 0x0f, 0x0c, 0x09, 0x06, 0x03, 0x01},	/* 20, -10.0dB */
+	{0x10, 0x10, 0x0e, 0x0b, 0x08, 0x05, 0x03, 0x01},	/* 21, -10.5dB */
+	{0x0f, 0x0f, 0x0d, 0x0b, 0x08, 0x05, 0x03, 0x01},	/* 22, -11.0dB */
+	{0x0e, 0x0e, 0x0c, 0x0a, 0x08, 0x05, 0x02, 0x01},	/* 23, -11.5dB */
+	{0x0d, 0x0d, 0x0c, 0x0a, 0x07, 0x05, 0x02, 0x01},	/* 24, -12.0dB */
+	{0x0d, 0x0c, 0x0b, 0x09, 0x07, 0x04, 0x02, 0x01},	/* 25, -12.5dB */
+	{0x0c, 0x0c, 0x0a, 0x09, 0x06, 0x04, 0x02, 0x01},	/* 26, -13.0dB */
+	{0x0b, 0x0b, 0x0a, 0x08, 0x06, 0x04, 0x02, 0x01},	/* 27, -13.5dB */
+	{0x0b, 0x0a, 0x09, 0x08, 0x06, 0x04, 0x02, 0x01},	/* 28, -14.0dB */
+	{0x0a, 0x0a, 0x09, 0x07, 0x05, 0x03, 0x02, 0x01},	/* 29, -14.5dB */
+	{0x0a, 0x09, 0x08, 0x07, 0x05, 0x03, 0x02, 0x01},	/* 30, -15.0dB */
+	{0x09, 0x09, 0x08, 0x06, 0x05, 0x03, 0x01, 0x01},	/* 31, -15.5dB */
+	{0x09, 0x08, 0x07, 0x06, 0x04, 0x03, 0x01, 0x01}	/* 32, -16.0dB */
+};
+
+
+const u8 cckswing_table_ch14[CCK_TABLE_SIZE][8] = {
+	{0x36, 0x35, 0x2e, 0x1b, 0x00, 0x00, 0x00, 0x00},	/* 0, +0dB */
+	{0x33, 0x32, 0x2b, 0x19, 0x00, 0x00, 0x00, 0x00},	/* 1, -0.5dB */
+	{0x30, 0x2f, 0x29, 0x18, 0x00, 0x00, 0x00, 0x00},	/* 2, -1.0dB */
+	{0x2d, 0x2d, 0x17, 0x17, 0x00, 0x00, 0x00, 0x00},	/* 3, -1.5dB */
+	{0x2b, 0x2a, 0x25, 0x15, 0x00, 0x00, 0x00, 0x00},	/* 4, -2.0dB */
+	{0x28, 0x28, 0x24, 0x14, 0x00, 0x00, 0x00, 0x00},	/* 5, -2.5dB */
+	{0x26, 0x25, 0x21, 0x13, 0x00, 0x00, 0x00, 0x00},	/* 6, -3.0dB */
+	{0x24, 0x23, 0x1f, 0x12, 0x00, 0x00, 0x00, 0x00},	/* 7, -3.5dB */
+	{0x22, 0x21, 0x1d, 0x11, 0x00, 0x00, 0x00, 0x00},	/* 8, -4.0dB */
+	{0x20, 0x20, 0x1b, 0x10, 0x00, 0x00, 0x00, 0x00},	/* 9, -4.5dB */
+	{0x1f, 0x1e, 0x1a, 0x0f, 0x00, 0x00, 0x00, 0x00},	/* 10, -5.0dB */
+	{0x1d, 0x1c, 0x18, 0x0e, 0x00, 0x00, 0x00, 0x00},	/* 11, -5.5dB */
+	{0x1b, 0x1a, 0x17, 0x0e, 0x00, 0x00, 0x00, 0x00},	/* 12, -6.0dB  <== default */
+	{0x1a, 0x19, 0x16, 0x0d, 0x00, 0x00, 0x00, 0x00},	/* 13, -6.5dB */
+	{0x18, 0x17, 0x15, 0x0c, 0x00, 0x00, 0x00, 0x00},	/* 14, -7.0dB */
+	{0x17, 0x16, 0x13, 0x0b, 0x00, 0x00, 0x00, 0x00},	/* 15, -7.5dB */
+	{0x16, 0x15, 0x12, 0x0b, 0x00, 0x00, 0x00, 0x00},	/* 16, -8.0dB */
+	{0x14, 0x14, 0x11, 0x0a, 0x00, 0x00, 0x00, 0x00},	/* 17, -8.5dB */
+	{0x13, 0x13, 0x10, 0x0a, 0x00, 0x00, 0x00, 0x00},	/* 18, -9.0dB */
+	{0x12, 0x12, 0x0f, 0x09, 0x00, 0x00, 0x00, 0x00},	/* 19, -9.5dB */
+	{0x11, 0x11, 0x0f, 0x09, 0x00, 0x00, 0x00, 0x00},	/* 20, -10.0dB */
+	{0x10, 0x10, 0x0e, 0x08, 0x00, 0x00, 0x00, 0x00},	/* 21, -10.5dB */
+	{0x0f, 0x0f, 0x0d, 0x08, 0x00, 0x00, 0x00, 0x00},	/* 22, -11.0dB */
+	{0x0e, 0x0e, 0x0c, 0x07, 0x00, 0x00, 0x00, 0x00},	/* 23, -11.5dB */
+	{0x0d, 0x0d, 0x0c, 0x07, 0x00, 0x00, 0x00, 0x00},	/* 24, -12.0dB */
+	{0x0d, 0x0c, 0x0b, 0x06, 0x00, 0x00, 0x00, 0x00},	/* 25, -12.5dB */
+	{0x0c, 0x0c, 0x0a, 0x06, 0x00, 0x00, 0x00, 0x00},	/* 26, -13.0dB */
+	{0x0b, 0x0b, 0x0a, 0x06, 0x00, 0x00, 0x00, 0x00},	/* 27, -13.5dB */
+	{0x0b, 0x0a, 0x09, 0x05, 0x00, 0x00, 0x00, 0x00},	/* 28, -14.0dB */
+	{0x0a, 0x0a, 0x09, 0x05, 0x00, 0x00, 0x00, 0x00},	/* 29, -14.5dB */
+	{0x0a, 0x09, 0x08, 0x05, 0x00, 0x00, 0x00, 0x00},	/* 30, -15.0dB */
+	{0x09, 0x09, 0x08, 0x05, 0x00, 0x00, 0x00, 0x00},	/* 31, -15.5dB */
+	{0x09, 0x08, 0x07, 0x04, 0x00, 0x00, 0x00, 0x00}	/* 32, -16.0dB */
+};
+
+/*
+ * 2011/09/21 MH Add to describe different team necessary resource allocate??
+ */
+
+static void rtl8821au_cm_common_info_self_update(struct rtl_priv *rtlpriv)
+{
+	struct rtl_phy *rtlphy = &(rtlpriv->phy);
+	u8 tmp;
+
+	rtlphy->cck_high_power = (bool) rtl_get_bbreg(rtlpriv, ODM_REG_CCK_RPT_FORMAT_11AC, ODM_BIT_CCK_RPT_FORMAT_11AC);
+	tmp = (u8) rtl_get_bbreg(rtlpriv, ODM_REG_BB_RX_PATH_11AC,
+				 ODM_BIT_BB_RX_PATH_11AC);
+
+	if (tmp & BIT(0))
+		rtlpriv->dm.rfpath_rxenable[0] = true;
+	if (tmp & BIT(1))
+		rtlpriv->dm.rfpath_rxenable[1] = true;
+}
+
+/* Ulli : check function in rtlwifi/core.c for _rtl_dm_diginit() */
+
+static void _rtl_dm_diginit(struct rtl_priv *rtlpriv)
+{
+	struct rtl_hal	*rtlhal = rtl_hal(rtlpriv);
+	struct dig_t *dm_digtable = &(rtlpriv->dm_digtable);
+
+	/* dm_digtable->Dig_Enable_Flag = true; */
+	/* dm_digtable->Dig_Ext_Port_Stage = DIG_EXT_PORT_STAGE_MAX; */
+	dm_digtable->cur_igvalue = (u8) rtl_get_bbreg(rtlpriv, ODM_REG_IGI_A_11AC, ODM_BIT_IGI_11AC);
+	/* dm_digtable->PreIGValue = 0x0; */
+	/* dm_digtable->CurSTAConnectState = dm_digtable->PreSTAConnectState = DIG_STA_DISCONNECT; */
+	/* dm_digtable->CurMultiSTAConnectState = DIG_MultiSTA_DISCONNECT; */
+	dm_digtable->rssi_lowthresh 	= DM_DIG_THRESH_LOW;
+	dm_digtable->rssi_highthresh	= DM_DIG_THRESH_HIGH;
+	dm_digtable->fa_lowthresh	= DM_FALSEALARM_THRESH_LOW;
+	dm_digtable->fa_highthresh	= DM_FALSEALARM_THRESH_HIGH;
+
+	if (rtlhal->board_type & (ODM_BOARD_EXT_PA|ODM_BOARD_EXT_LNA)) {
+		dm_digtable->rx_gain_max = DM_DIG_MAX_NIC;
+		dm_digtable->rx_gain_min = DM_DIG_MIN_NIC;
+	} else {
+		dm_digtable->rx_gain_max = DM_DIG_MAX_NIC;
+		dm_digtable->rx_gain_min = DM_DIG_MIN_NIC;
+	}
+	dm_digtable->back_val = DM_DIG_BACKOFF_DEFAULT;
+	dm_digtable->back_range_max = DM_DIG_BACKOFF_MAX;
+	dm_digtable->back_range_min = DM_DIG_BACKOFF_MIN;
+	dm_digtable->pre_cck_cca_thres = 0xFF;
+	dm_digtable->cur_cck_cca_thres = 0x83;
+	dm_digtable->forbidden_igi= DM_DIG_MIN_NIC;
+	dm_digtable->large_fa_hit = 0;
+	dm_digtable->recover_cnt = 0;
+	dm_digtable->dig_min_0 = DM_DIG_MIN_NIC;
+	dm_digtable->dig_min_1 = DM_DIG_MIN_NIC;
+	dm_digtable->media_connect_0 = false;
+	dm_digtable->media_connect_1 = false;
+
+	/* To Initi BT30 IGI */
+	dm_digtable->bt30_cur_igi = 0x32;
+
+}
+
+static void odm_AdaptivityInit(struct rtl_priv *rtlpriv)
+{
+	struct _rtw_hal	*pHalData = GET_HAL_DATA(rtlpriv);
+	struct _rtw_dm *pDM_Odm = &pHalData->odmpriv;
+
+	pDM_Odm->TH_H = 0xfa; 		/* -6dB */
+	pDM_Odm->TH_L = 0xfd; 		/* -3dB */
+	pDM_Odm->IGI_Base = 0x32;
+	pDM_Odm->IGI_target = 0x1c;
+	pDM_Odm->ForceEDCCA = 0;
+	pDM_Odm->AdapEn_RSSI = 32;	/* 45; */
+}
+
+static void rtl8821au_dm_init_rate_adaptive_mask(struct rtl_priv *rtlpriv)
+{
+	struct rate_adaptive *p_ra = &(rtlpriv->ra);
+
+	p_ra->ratr_state = DM_RATR_STA_INIT;
+	p_ra->ldpc_thres = 35;
+	p_ra->use_ldpc = false;
+	p_ra->high_rssi_thresh_for_ra = 50;
+	p_ra->low2high_rssi_thresh_for_ra40m = 20;
+}
+
+static void rtl8821au_dm_init_edca_turbo(struct rtl_priv *rtlpriv)
+{
+	rtlpriv->dm.current_turbo_edca = false;
+	rtlpriv->dm.is_cur_rdlstate = false;
+	rtlpriv->dm.is_any_nonbepkts = false;
+
+	RT_TRACE(rtlpriv, COMP_TURBO, DBG_LOUD, "Orginial VO PARAM: 0x%x\n", rtl_read_dword(rtlpriv, ODM_EDCA_VO_PARAM));
+	RT_TRACE(rtlpriv, COMP_TURBO, DBG_LOUD, "Orginial VI PARAM: 0x%x\n", rtl_read_dword(rtlpriv, ODM_EDCA_VI_PARAM));
+	RT_TRACE(rtlpriv, COMP_TURBO, DBG_LOUD, "Orginial BE PARAM: 0x%x\n", rtl_read_dword(rtlpriv, ODM_EDCA_BE_PARAM));
+	RT_TRACE(rtlpriv, COMP_TURBO, DBG_LOUD, "Orginial BK PARAM: 0x%x\n", rtl_read_dword(rtlpriv, ODM_EDCA_BK_PARAM));
+
+
+}
+
+static u8 getSwingIndex(struct rtl_priv *rtlpriv)
+{
+	u8 			i = 0;
+	uint32_t 			bbSwing;
+
+	bbSwing = phy_get_tx_swing_8821au(rtlpriv, rtlpriv->rtlhal.current_bandtype, RF90_PATH_A);
+
+	for (i = 0; i < TXSCALE_TABLE_SIZE; ++i)
+		if (bbSwing == txscalling_tbl[i])
+			break;
+
+	return i;
+}
+
+
+static void rtl8821au_dm_initialize_txpower_tracking_thermalmeter(struct rtl_priv *rtlpriv)
+{
+	u8 		p = 0;
+	struct rtl_dm	*rtldm = rtl_dm(rtlpriv);
+	struct rtl_efuse *efuse = rtl_efuse(rtlpriv);
+
+	rtldm->txpower_tracking = true;
+	rtldm->txpowercount = 0;
+	rtldm->txpower_trackinginit = false;
+	/* #if	(MP_DRIVER != 1) */		/* for mp driver, turn off txpwrtracking as default */
+	/* #endif//#if	(MP_DRIVER != 1) */
+	RT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD, "rtldm->txpower_track_control= %d\n", rtldm->txpower_track_control);
+
+	rtldm->txpower_track_control = true;
+	rtldm->thermalvalue = efuse->eeprom_thermalmeter;
+	rtldm->thermalvalue_iqk = efuse->eeprom_thermalmeter;
+	rtldm->thermalvalue_lck = efuse->eeprom_thermalmeter;
+
+	/* The index of "0 dB" in SwingTable. */
+	{
+		u8 defaultSwingIndex = getSwingIndex(rtlpriv);
+
+
+		rtldm->default_ofdm_index = (defaultSwingIndex == TXSCALE_TABLE_SIZE) ? 24 : defaultSwingIndex;
+		rtldm->default_cck_index = 24;
+	}
+
+	rtldm->swing_idx_cck_base = rtldm->default_cck_index;
+	rtldm->cck_index = rtldm->default_cck_index;
+
+	for (p = RF90_PATH_A; p < MAX_RF_PATH; ++p) {
+		rtldm->swing_idx_ofdm_base[p] = rtldm->default_ofdm_index;
+		rtldm->ofdm_index[p] = rtldm->default_ofdm_index;
+		rtldm->delta_power_index[p] = 0;
+		rtldm->delta_power_index_last[p] = 0;
+		rtldm->power_index_offset[p] = 0;
+	}
+}
+
+void ODM_DMInit(struct rtl_priv *rtlpriv)
+{
+	/* 2012.05.03 Luke: For all IC series */
+	rtl8821au_cm_common_info_self_update(rtlpriv);
+	/* Ulli : check function in rtlwifi/core.c for _rtl_dm_diginit() */
+	_rtl_dm_diginit(rtlpriv);
+	odm_AdaptivityInit(rtlpriv);
+	rtl8821au_dm_init_rate_adaptive_mask(rtlpriv);
+
+	rtl8821au_dm_init_edca_turbo(rtlpriv);
+
+	rtl8821au_dm_initialize_txpower_tracking_thermalmeter(rtlpriv);
+}
+
+/* From hal/OUTSRC/rtl8812a/HalPhyRf_8812A.c */
+
+/*
+ * ============================================================
+ *  Tx Power Tracking
+ * ============================================================
+ */
+/* From hal/OUTSRC/rtl8812a/HalPhyRf_8812A.c, caution function pointer */
+static void rtl8812au_do_iqk(struct rtl_priv *rtlpriv, u8 DeltaThermalIndex,
+	u8 	ThermalValue, u8 Threshold)
+{
+	struct rtl_dm	*rtldm = rtl_dm(rtlpriv);
+
+	rtldm->thermalvalue_iqk = ThermalValue;
+	rtl8812au_phy_iq_calibrate(rtlpriv, false);
+}
+
+/*-----------------------------------------------------------------------------
+ * Function:	odm_TxPwrTrackSetPwr88E()
+ *
+ * Overview:	88E change all channel tx power accordign to flag.
+ *				OFDM & CCK are all different.
+ *
+ * Input:		NONE
+ *
+ * Output:		NONE
+ *
+ * Return:		NONE
+ *
+ * Revised History:
+ *	When		Who		Remark
+ *	04/23/2012	MHC		Create Version 0.
+ *
+ *---------------------------------------------------------------------------*/
+
+static void rtl8812au_dm_pxpwr_track_set_pwr(struct rtl_priv *rtlpriv,
+					     enum pwr_track_control_method Method,
+					     u8 RFPath, u8 ChannelMappedIndex)
+{
+	uint32_t 	finalBbSwingIdx[2];
+
+	struct rtl_dm	*rtldm = rtl_dm(rtlpriv);
+
+	u8 PwrTrackingLimit = 26; /* +1.0dB */
+	u8 TxRate = 0xFF;
+	s8 Final_OFDM_Swing_Index = 0;
+
+	if (TxRate != 0xFF) {
+		/* Ulli better with switch case, see in rtlwifi-lib */
+		/* 2 CCK */
+		if ((TxRate >= MGN_1M) && (TxRate <= MGN_11M))
+			PwrTrackingLimit = 32;				/* +4dB */
+		/* 2 OFDM */
+		else if ((TxRate >= MGN_6M) && (TxRate <= MGN_48M))
+			PwrTrackingLimit = 32;				/* +4dB */
+		else if (TxRate == MGN_54M)
+			PwrTrackingLimit = 30;				/* +3dB */
+
+		/* ULLI 80211n */
+		/* 2 HT */
+		else if ((TxRate >= MGN_MCS0) && (TxRate <= MGN_MCS2))  /* QPSK/BPSK */
+			PwrTrackingLimit = 34;				/* +5dB */
+		else if ((TxRate >= MGN_MCS3) && (TxRate <= MGN_MCS4))  /* 16QAM */
+			PwrTrackingLimit = 32;				/* +4dB */
+		else if ((TxRate >= MGN_MCS5) && (TxRate <= MGN_MCS7))  /* 64QAM */
+			PwrTrackingLimit = 30;				/* +3dB */
+
+		else if ((TxRate >= MGN_MCS8) && (TxRate <= MGN_MCS10)) 	/* QPSK/BPSK */
+			PwrTrackingLimit = 34; 				/* +5dB */
+		else if ((TxRate >= MGN_MCS11) && (TxRate <= MGN_MCS12)) 	/* 16QAM */
+			PwrTrackingLimit = 32; 				/* +4dB */
+		else if ((TxRate >= MGN_MCS13) && (TxRate <= MGN_MCS15)) 	/* 64QAM */
+			PwrTrackingLimit = 30; 				/* +3dB */
+
+		/* Ulli 802.11ac */
+		/* 2 VHT */
+		else if ((TxRate >= MGN_VHT1SS_MCS0) && (TxRate <= MGN_VHT1SS_MCS2))    /* QPSK/BPSK */
+			PwrTrackingLimit = 34;						/* +5dB */
+		else if ((TxRate >= MGN_VHT1SS_MCS3) && (TxRate <= MGN_VHT1SS_MCS4))    /* 16QAM */
+			PwrTrackingLimit = 32;						/* +4dB */
+		else if ((TxRate >= MGN_VHT1SS_MCS5) && (TxRate <= MGN_VHT1SS_MCS6))    /* 64QAM */
+			PwrTrackingLimit = 30;						/* +3dB */
+		else if (TxRate == MGN_VHT1SS_MCS7)					/* 64QAM */
+			PwrTrackingLimit = 28;						/* +2dB */
+		else if (TxRate == MGN_VHT1SS_MCS8)					/* 256QAM */
+			PwrTrackingLimit = 26;						/* +1dB */
+		else if (TxRate == MGN_VHT1SS_MCS9)					/* 256QAM */
+			PwrTrackingLimit = 24;						/* +0dB */
+
+		else if ((TxRate >= MGN_VHT2SS_MCS0) && (TxRate <= MGN_VHT2SS_MCS2)) 	/* QPSK/BPSK */
+			PwrTrackingLimit = 34; 						/* +5dB */
+		else if ((TxRate >= MGN_VHT2SS_MCS3) && (TxRate <= MGN_VHT2SS_MCS4)) 	/* 16QAM */
+			PwrTrackingLimit = 32; 						/* +4dB */
+		else if ((TxRate >= MGN_VHT2SS_MCS5) && (TxRate <= MGN_VHT2SS_MCS6)) 	/* 64QAM */
+			PwrTrackingLimit = 30; 						/* +3dB */
+		else if (TxRate == MGN_VHT2SS_MCS7) 					/* 64QAM */
+			PwrTrackingLimit = 28; 						/* +2dB */
+		else if (TxRate == MGN_VHT2SS_MCS8) 					/* 256QAM */
+			PwrTrackingLimit = 26; 						/* +1dB */
+		else if (TxRate == MGN_VHT2SS_MCS9) 					/* 256QAM */
+			PwrTrackingLimit = 24; 						/* +0dB */
+
+		else
+			PwrTrackingLimit = 24;
+	}
+	RT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD, "TxRate=0x%x, PwrTrackingLimit=%d\n", TxRate, PwrTrackingLimit);
+	if (Method == BBSWING) {
+		RT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD, "===>rtl8812au_dm_pxpwr_track_set_pwr\n");
+		if (RFPath == RF90_PATH_A) {
+			finalBbSwingIdx[RF90_PATH_A] = (rtldm->ofdm_index[RF90_PATH_A] > PwrTrackingLimit) ? PwrTrackingLimit : rtldm->ofdm_index[RF90_PATH_A];
+			RT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD, "pDM_Odm->RFCalibrateInfo.OFDM_index[RF90_PATH_A]=%d, pDM_Odm->RealBbSwingIdx[RF90_PATH_A]=%d\n",
+				rtldm->ofdm_index[RF90_PATH_A], finalBbSwingIdx[RF90_PATH_A]);
+			rtl_set_bbreg(rtlpriv, rA_TxScale_Jaguar, 0xFFE00000, txscalling_tbl[finalBbSwingIdx[RF90_PATH_A]]);
+		} else {
+			finalBbSwingIdx[RF90_PATH_B] = (rtldm->ofdm_index[RF90_PATH_B] > PwrTrackingLimit) ? PwrTrackingLimit : rtldm->ofdm_index[RF90_PATH_B];
+			RT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD, "pDM_Odm->RFCalibrateInfo.OFDM_index[RF90_PATH_B]=%d, pDM_Odm->RealBbSwingIdx[RF90_PATH_B]=%d\n",
+				rtldm->ofdm_index[RF90_PATH_B], finalBbSwingIdx[RF90_PATH_B]);
+			rtl_set_bbreg(rtlpriv, rB_TxScale_Jaguar, 0xFFE00000, txscalling_tbl[finalBbSwingIdx[RF90_PATH_B]]);
+		}
+	} else if (Method == MIX_MODE) {
+			RT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD, "pDM_Odm->DefaultOfdmIndex=%d, pDM_Odm->Aboslute_OFDMSwingIdx[RFPath]=%d, RF_Path = %d\n",
+				rtldm->default_ofdm_index, rtldm->absolute_ofdm_swing_idx[RFPath], RFPath);
+
+			Final_OFDM_Swing_Index = rtldm->default_ofdm_index + rtldm->absolute_ofdm_swing_idx[RFPath];
+
+			if (RFPath == RF90_PATH_A) {
+				if (Final_OFDM_Swing_Index > PwrTrackingLimit) {    /* BBSwing higher then Limit */
+					rtldm->remnant_cck_idx = Final_OFDM_Swing_Index - PwrTrackingLimit;            /*  CCK Follow the same compensate value as Path A */
+					rtldm->remnant_ofdm_swing_idx[RFPath] = Final_OFDM_Swing_Index - PwrTrackingLimit;
+
+					rtl_set_bbreg(rtlpriv, rA_TxScale_Jaguar, 0xFFE00000, txscalling_tbl[PwrTrackingLimit]);
+
+					rtldm->modify_txagc_flag_path_a = true;
+
+					/* et TxAGC Page C{}; */
+					/* rtlpriv->cfg->ops.SetTxPowerLevelHandler(rtlpriv, pHalData->CurrentChannel); */
+					PHY_SetTxPowerLevel8812(rtlpriv, rtlpriv->phy.current_channel);
+					RT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD, "******Path_A Over BBSwing Limit , PwrTrackingLimit = %d , Remnant TxAGC Value = %d \n", PwrTrackingLimit, rtldm->remnant_ofdm_swing_idx[RFPath]);
+				} else if (Final_OFDM_Swing_Index < 0) {
+					rtldm->remnant_cck_idx = Final_OFDM_Swing_Index;            /* CCK Follow the same compensate value as Path A */
+					rtldm->remnant_ofdm_swing_idx[RFPath] = Final_OFDM_Swing_Index;
+
+					rtl_set_bbreg(rtlpriv, rA_TxScale_Jaguar, 0xFFE00000, txscalling_tbl[0]);
+
+					rtldm->modify_txagc_flag_path_a = true;
+
+					/* Set TxAGC Page C{}; */
+					/* rtlpriv->cfg->ops.SetTxPowerLevelHandler(rtlpriv, pHalData->CurrentChannel);*/
+					PHY_SetTxPowerLevel8812(rtlpriv, rtlpriv->phy.current_channel);
+					RT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD, "******Path_A Lower then BBSwing lower bound  0 , Remnant TxAGC Value = %d \n", rtldm->remnant_ofdm_swing_idx[RFPath]);
+				} else 	{
+					rtl_set_bbreg(rtlpriv, rA_TxScale_Jaguar, 0xFFE00000, txscalling_tbl[Final_OFDM_Swing_Index]);
+					RT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD, "******Path_A Compensate with BBSwing , Final_OFDM_Swing_Index = %d \n", Final_OFDM_Swing_Index);
+
+					if (rtldm->modify_txagc_flag_path_a) { /* If TxAGC has changed, reset TxAGC again */
+						rtldm->remnant_cck_idx = 0;
+						rtldm->remnant_ofdm_swing_idx[RFPath] = 0;
+
+						/* Set TxAGC Page C{}; */
+						/* rtlpriv->cfg->ops.SetTxPowerLevelHandler(rtlpriv, pHalData->CurrentChannel); */
+						PHY_SetTxPowerLevel8812(rtlpriv, rtlpriv->phy.current_channel);
+
+						rtldm->modify_txagc_flag_path_a = false;
+						RT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD, "******Path_A pDM_Odm->Modify_TxAGC_Flag = false \n");
+					}
+				}
+			}
+
+			if (RFPath == RF90_PATH_B) {
+				if (Final_OFDM_Swing_Index > PwrTrackingLimit) {			/* BBSwing higher then Limit */
+					rtldm->remnant_ofdm_swing_idx[RFPath] = Final_OFDM_Swing_Index - PwrTrackingLimit;
+
+					rtl_set_bbreg(rtlpriv, rB_TxScale_Jaguar, 0xFFE00000, txscalling_tbl[PwrTrackingLimit]);
+
+					rtldm->modify_txagc_flag_path_b = true;
+
+					/* Set TxAGC Page E{}; */
+					RT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD, "******Path_B Over BBSwing Limit , PwrTrackingLimit = %d , Remnant TxAGC Value = %d \n", PwrTrackingLimit, rtldm->remnant_ofdm_swing_idx[RFPath]);
+				} else if (Final_OFDM_Swing_Index < 0) {
+					rtldm->remnant_ofdm_swing_idx[RFPath] = Final_OFDM_Swing_Index;
+
+					rtl_set_bbreg(rtlpriv, rB_TxScale_Jaguar, 0xFFE00000, txscalling_tbl[0]);
+
+					rtldm->modify_txagc_flag_path_b = true;
+
+					/* Set TxAGC Page E{}; */
+					RT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD, "******Path_B Lower then BBSwing lower bound  0 , Remnant TxAGC Value = %d \n", rtldm->remnant_ofdm_swing_idx[RFPath]);
+				} else {
+					rtl_set_bbreg(rtlpriv, rB_TxScale_Jaguar, 0xFFE00000, txscalling_tbl[Final_OFDM_Swing_Index]);
+					RT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD, "******Path_B Compensate with BBSwing , Final_OFDM_Swing_Index = %d \n", Final_OFDM_Swing_Index);
+					if (rtldm->modify_txagc_flag_path_b) {			/* If TxAGC has changed, reset TxAGC again */
+						rtldm->remnant_cck_idx = 0;
+						rtldm->remnant_ofdm_swing_idx[RFPath] = 0;
+
+						/* Set TxAGC Page E{}; */
+
+						rtldm->modify_txagc_flag_path_b = false;
+						RT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD, "******Path_B pDM_Odm->Modify_TxAGC_Flag = false \n");
+					}
+				}
+			}
+
+	} else {
+		return;
+	}
+}
+
+/* START Copied from hal/OUTSRC/rtl8812a/HalHWImg8812A_RF.c */
+/******************************************************************************
+*                           TxPowerTrack_USB.TXT
+******************************************************************************/
+
+static u8 rtl8818e_delta_swing_table_idx_24gb_p[] = {
+	0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 4,  4,  4,  4,  4,
+	4,  5,  5,  7,  7,  8,  8,  8,  9,  9,  9,  9,  9};
+static u8 rtl8818e_delta_swing_table_idx_24gb_n[] = {
+	0, 0, 0, 2, 2, 3, 3, 4, 4, 4, 4, 5, 5,  6,  6,  7,  7,
+	7,  7,  8,  8,  9,  9, 10, 10, 10, 11, 11, 11, 11};
+
+static u8 rtl8812ae_delta_swing_table_idx_5gb_n[][DELTA_SWINGIDX_SIZE] = {
+	{0, 1, 1, 2, 2, 3, 4, 5, 6,  6,  7,  7,  8,  8,  9,  9,
+	10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 14, 14, 14, 14},
+	{0, 1, 1, 2, 3, 3, 4, 5, 5,  6,  7,  7,  8,  8,  9,  9,
+	10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11},
+	{0, 1, 1, 2, 3, 3, 4, 5, 6,  7,  7,  8,  8,  9,  9, 10,
+	11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11},
+};
+
+static u8 rtl8812ae_delta_swing_table_idx_5gb_p[][DELTA_SWINGIDX_SIZE] = {
+	{0, 1, 1, 2, 2, 3, 3, 4, 5,  6,  7,  7,  8,  8,  9,  9,
+	10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11},
+	{0, 1, 1, 2, 3, 3, 4, 5, 5,  6,  7,  7,  8,  8,  9,  9,
+	10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11},
+	{0, 1, 1, 2, 3, 3, 4, 5, 6,  7,  7,  8,  8,  9,  9, 10,
+	11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11},
+};
+
+static u8 rtl8812ae_delta_swing_table_idx_5ga_n[][DELTA_SWINGIDX_SIZE] = {
+	{0, 1, 1, 2, 2, 3, 4, 5, 6,  6,  7,  7,  8,  8,  9,  9,
+	10, 10, 11, 11, 12, 12, 13, 13, 14, 15, 15, 15, 15, 15},
+	{0, 1, 1, 2, 2, 3, 4, 5, 6,  6,  7,  7,  8,  8,  9,  9,
+	10, 10, 11, 11, 12, 12, 13, 13, 14, 15, 15, 15, 15, 15},
+	{0, 1, 1, 2, 2, 3, 4, 5, 6,  6,  7,  7,  8,  8,  9,  9,
+	10, 10, 11, 11, 12, 12, 13, 13, 14, 15, 15, 15, 15, 15},
+};
+
+static u8 rtl8812ae_delta_swing_table_idx_5ga_p[][DELTA_SWINGIDX_SIZE] = {
+	{0, 1, 1, 2, 2, 3, 4, 5, 6,  7,  7,  8,  8,  9, 10, 11,
+	11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11},
+	{0, 1, 1, 2, 3, 3, 4, 5, 6,  7,  7,  8,  8,  9, 10, 11,
+	11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11},
+	{0, 1, 1, 2, 3, 3, 4, 5, 6,  7,  7,  8,  8,  9, 10, 11,
+	11, 12, 12, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11},
+};
+
+static u8 rtl8812au_delta_swing_table_idx_24gb_n[] = {
+	0, 1, 1, 2, 2, 2, 3, 3, 3,  4,  4,  5,  5,  5,  6,  6,
+	7,  7,  8,  8,  9,  9, 10, 10, 11, 11, 11, 11, 11, 11
+};
+
+static u8 rtl8812au_delta_swing_table_idx_24gb_p[] = {
+	0, 1, 1, 2, 2, 2, 3, 3, 3,  4,  4,  4,  5,  5,  5,  6,
+	6,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7
+};
+
+static u8 rtl8812au_delta_swing_table_idx_24ga_n[] = {
+	0, 1, 1, 2, 2, 2, 3, 3, 3,  4,  4,  4,  5,  5,  5,  6,
+	6,  6,  7,  7,  7,  8,  8,  9, 10, 10, 10, 10, 10, 10
+};
+
+static u8 rtl8812au_delta_swing_table_idx_24ga_p[] = {
+	0, 1, 1, 2, 2, 2, 3, 3, 3,  4,  4,  4,  5,  5,  5,  6,
+	6,  6,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7
+};
+
+static u8 rtl8812au_delta_swing_table_idx_24gcckb_n[] = {
+	0, 1, 1, 2, 2, 2, 3, 3, 3,  4,  4,  5,  5,  5,  6,  6,
+	7,  7,  8,  8,  9,  9, 10, 10, 11, 11, 11, 11, 11, 11
+};
+
+static u8 rtl8812au_delta_swing_table_idx_24gcckb_p[] = {
+	0, 1, 1, 2, 2, 2, 3, 3, 3,  4,  4,  4,  5,  5,  5,  6,
+	6,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7
+};
+
+static u8 rtl8812au_delta_swing_table_idx_24gccka_n[] = {
+	0, 1, 1, 2, 2, 2, 3, 3, 3,  4,  4,  4,  5,  5,  5,  6,
+	6,  6,  7,  7,  7,  8,  8,  9, 10, 10, 10, 10, 10, 10
+};
+
+static u8 rtl8812au_delta_swing_table_idx_24gccka_p[] = {
+	0, 1, 1, 2, 2, 2, 3, 3, 3,  4,  4,  4,  5,  5,  5,  6,
+	6,  6,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7
+};
+
+/******************************************************************************
+*                           TxPowerTrack_USB_RFE3.TXT
+******************************************************************************/
+
+static u8 rtl8812ae_delta_swing_table_idx_5gb_n_rfe3[][DELTA_SWINGIDX_SIZE] = {
+	{0, 1, 1, 2, 3, 3, 4, 5, 5,  6,  7,  7,  8,  8,  9,  9,
+	10, 10, 11, 12, 13, 13, 14, 15, 16, 16, 17, 17, 18, 18},
+	{0, 1, 1, 2, 2, 3, 3, 4, 4,  5,  6,  7,  8,  8,  9,  9,
+	10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11},
+	{0, 1, 1, 2, 2, 3, 3, 4, 4,  5,  6,  6,  7,  7,  8,  9,
+	10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11},
+};
+
+static u8 rtl8812ae_delta_swing_table_idx_5gb_p_rfe3[][DELTA_SWINGIDX_SIZE] = {
+	{0, 1, 1, 2, 3, 3, 4, 5, 6,  7,  7,  8,  9,  9, 10, 10,
+	11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11},
+	{0, 1, 1, 2, 2, 3, 3, 4, 4,  5,  6,  7,  8,  8,  9,  9,
+	10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11},
+	{0, 1, 1, 2, 2, 3, 3, 4, 4,  5,  6,  6,  7,  7,  8,  9,
+	10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11},
+};
+
+static u8 rtl8812ae_delta_swing_table_idx_5ga_n_rfe3[][DELTA_SWINGIDX_SIZE] = {
+	{0, 1, 1, 2, 3, 3, 4, 5, 5,  6,  7,  7,  8,  8,  9,  9,
+	10, 10, 11, 11, 12, 13, 14, 15, 16, 16, 17, 17, 18, 18},
+	{0, 1, 1, 2, 3, 3, 4, 4, 5,  6,  6,  7,  7,  8,  9,  9,
+	10, 10, 11, 11, 12, 12, 13, 13, 14, 15, 16, 16, 17, 17},
+	{0, 1, 1, 2, 3, 3, 4, 4, 5,  6,  7,  7,  8,  8,  9,  9,
+	10, 10, 11, 12, 13, 13, 14, 14, 15, 15, 16, 17, 18, 18},
+};
+
+static u8 rtl8812ae_delta_swing_table_idx_5ga_p_rfe3[][DELTA_SWINGIDX_SIZE] = {
+	{0, 1, 1, 2, 2, 3, 4, 5, 6,  7,  7,  8,  9,  9, 10, 10,
+	11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11},
+	{0, 1, 2, 3, 4, 4, 5, 5, 6,  7,  7,  8,  9,  9, 10, 11,
+	11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11},
+	{0, 1, 2, 3, 4, 4, 5, 5, 6,  7,  7,  8,  9,  9, 10, 11,
+	11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11},
+};
+
+static u8 rtl8812au_delta_swing_table_idx_24gb_n_rfe3[] = {
+	0, 1, 1, 2, 2, 3, 3, 4, 4,  4,  5,  5,  6,  6,  6,  7,
+	7,  7,  8,  8,  9,  9, 10, 11, 12, 12, 13, 14, 15, 15
+};
+
+static u8 rtl8812au_delta_swing_table_idx_24gb_p_rfe3[] = {
+	0, 1, 1, 2, 2, 2, 2, 3, 3,  3,  4,  4,  5,  5,  5,  6,
+	6,  7,  7,  8,  9, 10, 10, 10, 10, 11, 11, 11, 11, 11
+};
+
+static u8 rtl8812au_delta_swing_table_idx_24ga_n_rfe3[] = {
+	0, 1, 1, 2, 2, 3, 4, 5, 6,  6,  6,  7,  7,  8,  8,  9,
+	10, 10, 11, 11, 12, 12, 13, 13, 13, 13, 14, 14, 15, 15
+};
+
+static u8 rtl8812au_delta_swing_table_idx_24ga_p_rfe3[] = {
+	0, 0, 1, 1, 1, 2, 2, 3, 3,  4,  4,  4,  5,  5,  5,  6,
+	6,  7,  7,  8,  8,  9,  9, 10, 10, 11, 11, 11, 11, 11
+};
+
+static u8 rtl8812au_delta_swing_table_idx_24gcckb_n_rfe3[] = {
+	0, 1, 1, 2, 2, 3, 3, 4, 4,  4,  5,  5,  6,  6,  6,  7,
+	7,  7,  8,  8,  9,  9, 10, 11, 12, 12, 13, 14, 15, 15
+};
+
+static u8 rtl8812au_delta_swing_table_idx_24gcckb_p_rfe3[] = {
+	0, 1, 1, 2, 2, 2, 2, 3, 3,  3,  4,  4,  5,  5,  5,  6,
+	6,  7,  7,  8,  9, 10, 10, 10, 10, 11, 11, 11, 11, 11
+};
+
+static u8 rtl8812au_delta_swing_table_idx_24gccka_n_rfe3[] = {
+	0, 1, 1, 2, 2, 3, 4, 5, 6,  6,  6,  7,  7,  8,  8,  9,
+	10, 10, 11, 11, 12, 12, 13, 13, 13, 13, 14, 14, 15, 15
+};
+
+static u8 rtl8812au_delta_swing_table_idx_24gccka_p_rfe3[] = {
+	0, 0, 1, 1, 1, 2, 2, 3, 3,  4,  4,  4,  5,  5,  5,  6,
+	6,  7,  7,  8,  8,  9,  9, 10, 10, 11, 11, 11, 11, 11
+};
+
+/* END Copied from hal/OUTSRC/rtl8812a/HalHWImg8812A_RF.c */
+
+void rtl8812au_get_delta_swing_table(struct rtl_priv *rtlpriv,
+					    u8 **up_a, u8 **down_a,
+					    u8 **up_b, u8 **down_b)
+{
+	struct rtl_hal	*rtlhal = rtl_hal(rtlpriv);
+	struct rtl_phy *rtlphy = &rtlpriv->phy;
+	struct rtl_dm *rtldm = rtl_dm(rtlpriv);
+
+	u8 rate = rtldm->tx_rate;
+	u8 channel = rtlphy->current_channel;
+
+	if (rtlhal->rfe_type == 3 && IS_NORMAL_CHIP(rtlhal->version)) {
+		if (1 <= channel && channel <= 14) {
+			if (IS_CCK_RATE(rate)) {
+				*up_a   = rtl8812au_delta_swing_table_idx_24gccka_p_rfe3;
+				*down_a = rtl8812au_delta_swing_table_idx_24gccka_n_rfe3;
+				*up_b   = rtl8812au_delta_swing_table_idx_24gcckb_p_rfe3;
+				*down_b = rtl8812au_delta_swing_table_idx_24gcckb_n_rfe3;
+			} else {
+				*up_a   = rtl8812au_delta_swing_table_idx_24ga_p_rfe3;
+				*down_a = rtl8812au_delta_swing_table_idx_24ga_n_rfe3;
+				*up_b   = rtl8812au_delta_swing_table_idx_24gb_p_rfe3;
+				*down_b = rtl8812au_delta_swing_table_idx_24gb_n_rfe3;
+			}
+		} else if (36 <= channel && channel <= 64) {
+			*up_a   = rtl8812ae_delta_swing_table_idx_5ga_p_rfe3[0];
+			*down_a = rtl8812ae_delta_swing_table_idx_5ga_n_rfe3[0];
+			*up_b   = rtl8812ae_delta_swing_table_idx_5gb_p_rfe3[0];
+			*down_b = rtl8812ae_delta_swing_table_idx_5gb_n_rfe3[0];
+		} else if (100 <= channel && channel <= 140) {
+			*up_a   = rtl8812ae_delta_swing_table_idx_5ga_p_rfe3[1];
+			*down_a = rtl8812ae_delta_swing_table_idx_5ga_n_rfe3[1];
+			*up_b   = rtl8812ae_delta_swing_table_idx_5gb_p_rfe3[1];
+			*down_b = rtl8812ae_delta_swing_table_idx_5gb_n_rfe3[1];
+		} else if (149 <= channel && channel <= 173) {
+			*up_a   = rtl8812ae_delta_swing_table_idx_5ga_p_rfe3[2];
+			*down_a = rtl8812ae_delta_swing_table_idx_5ga_n_rfe3[2];
+			*up_b   = rtl8812ae_delta_swing_table_idx_5gb_p_rfe3[2];
+			*down_b = rtl8812ae_delta_swing_table_idx_5gb_n_rfe3[2];
+		} else {
+			*up_a   = (u8 *)rtl8818e_delta_swing_table_idx_24gb_p;
+			*down_a = (u8 *)rtl8818e_delta_swing_table_idx_24gb_n;
+			*up_b   = (u8 *)rtl8818e_delta_swing_table_idx_24gb_p;
+			*down_b = (u8 *)rtl8818e_delta_swing_table_idx_24gb_n;
+		}
+	} else {
+		if (1 <= channel && channel <= 14) {
+			if (IS_CCK_RATE(rate)) {
+				*up_a   = rtl8812au_delta_swing_table_idx_24gccka_p;
+				*down_a = rtl8812au_delta_swing_table_idx_24gccka_n;
+				*up_b   = rtl8812au_delta_swing_table_idx_24gcckb_p;
+				*down_b = rtl8812au_delta_swing_table_idx_24gcckb_n;
+			} else {
+				*up_a   = rtl8812au_delta_swing_table_idx_24ga_p;
+				*down_a = rtl8812au_delta_swing_table_idx_24ga_n;
+				*up_b   = rtl8812au_delta_swing_table_idx_24gb_p;
+				*down_b = rtl8812au_delta_swing_table_idx_24gb_n;
+			}
+		} else if (36 <= channel && channel <= 64) {
+			*up_a   = rtl8812ae_delta_swing_table_idx_5ga_p[0];
+			*down_a = rtl8812ae_delta_swing_table_idx_5ga_n[0];
+			*up_b   = rtl8812ae_delta_swing_table_idx_5gb_p[0];
+			*down_b = rtl8812ae_delta_swing_table_idx_5gb_n[0];
+		} else if (100 <= channel && channel <= 140) {
+			*up_a   = rtl8812ae_delta_swing_table_idx_5ga_p[1];
+			*down_a = rtl8812ae_delta_swing_table_idx_5ga_n[1];
+			*up_b   = rtl8812ae_delta_swing_table_idx_5gb_p[1];
+			*down_b = rtl8812ae_delta_swing_table_idx_5gb_n[1];
+		} else if (149 <= channel && channel <= 173) {
+			*up_a   = rtl8812ae_delta_swing_table_idx_5ga_p[2];
+			*down_a = rtl8812ae_delta_swing_table_idx_5ga_n[2];
+			*up_b   = rtl8812ae_delta_swing_table_idx_5gb_p[2];
+			*down_b = rtl8812ae_delta_swing_table_idx_5gb_n[2];
+		} else {
+			*up_a   = (u8 *)rtl8818e_delta_swing_table_idx_24gb_p;
+			*down_a = (u8 *)rtl8818e_delta_swing_table_idx_24gb_n;
+			*up_b   = (u8 *)rtl8818e_delta_swing_table_idx_24gb_p;
+			*down_b = (u8 *)rtl8818e_delta_swing_table_idx_24gb_n;
+		}
+	}
+
+	return;
+}
+
+
+/* From hal/OUTSRC/rtl8821a/HalPhyRf_8821A.c, caution function pointer */
+
+static void rtl8821au_do_iqk(struct rtl_priv *rtlpriv, u8 DeltaThermalIndex,
+	u8 ThermalValue, u8 Threshold)
+{
+	struct rtl_dm	*rtldm = rtl_dm(rtlpriv);
+
+	rtldm->thermalvalue_iqk = ThermalValue;
+	rtl8821au_phy_iq_calibrate(rtlpriv, false);
+}
+
+
+static void rtl8821au_dm_txpwr_track_set_pwr(struct rtl_priv *rtlpriv,
+					     enum pwr_track_control_method Method,
+					     u8 RFPath, u8 ChannelMappedIndex)
+{
+	struct rtl_dm	*rtldm = rtl_dm(rtlpriv);
+
+	u8 PwrTrackingLimit = 26; /* +1.0dB */
+	u8 TxRate = 0xFF;
+	s8 Final_OFDM_Swing_Index = 0;
+	uint32_t finalBbSwingIdx[1];
+
+	RT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD, "===>ODM_TxPwrTrackSetPwr8821A\n");
+	if (TxRate != 0xFF) {
+		/* 2 CCK */
+		if ((TxRate >= MGN_1M) && (TxRate <= MGN_11M))
+			PwrTrackingLimit = 32;				/* +4dB */
+		/* 2 OFDM */
+		else if ((TxRate >= MGN_6M) && (TxRate <= MGN_48M))
+			PwrTrackingLimit = 32;				/* +4dB */
+		else if (TxRate == MGN_54M)
+			PwrTrackingLimit = 30;				/* +3dB */
+		/* 2 HT */
+		else if ((TxRate >= MGN_MCS0) && (TxRate <= MGN_MCS2))  /* QPSK/BPSK */
+			PwrTrackingLimit = 34;				/* +5dB */
+		else if ((TxRate >= MGN_MCS3) && (TxRate <= MGN_MCS4))  /* 16QAM */
+			PwrTrackingLimit = 32;				/* +4dB */
+		else if ((TxRate >= MGN_MCS5) && (TxRate <= MGN_MCS7))  /* 64QAM */
+			PwrTrackingLimit = 30;				/* +3dB */
+		/* 2 VHT */
+		else if ((TxRate >= MGN_VHT1SS_MCS0) && (TxRate <= MGN_VHT1SS_MCS2))    /* QPSK/BPSK */
+			PwrTrackingLimit = 34;						/* +5dB */
+		else if ((TxRate >= MGN_VHT1SS_MCS3) && (TxRate <= MGN_VHT1SS_MCS4))    /* 16QAM */
+			PwrTrackingLimit = 32;						/* +4dB */
+		else if ((TxRate >= MGN_VHT1SS_MCS5) && (TxRate <= MGN_VHT1SS_MCS6))    /* 64QAM */
+			PwrTrackingLimit = 30;						/* +3dB */
+		else if (TxRate == MGN_VHT1SS_MCS7)					/* 64QAM */
+			PwrTrackingLimit = 28;						/* +2dB */
+		else if (TxRate == MGN_VHT1SS_MCS8)					/* 256QAM */
+			PwrTrackingLimit = 26;						/* +1dB */
+		else if (TxRate == MGN_VHT1SS_MCS9)					/* 256QAM */
+			PwrTrackingLimit = 24;						/* +0dB */
+		else
+			PwrTrackingLimit = 24;
+	}
+	RT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD, "TxRate=0x%x, PwrTrackingLimit=%d\n", TxRate, PwrTrackingLimit);
+	if (Method == BBSWING) {
+		if (RFPath == RF90_PATH_A) {
+			finalBbSwingIdx[RF90_PATH_A] = (rtldm->ofdm_index[RF90_PATH_A] > PwrTrackingLimit) ? PwrTrackingLimit : rtldm->ofdm_index[RF90_PATH_A];
+			RT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD, "pDM_Odm->RFCalibrateInfo.OFDM_index[RF90_PATH_A]=%d, pDM_Odm->RealBbSwingIdx[RF90_PATH_A]=%d\n",
+				rtldm->ofdm_index[RF90_PATH_A], finalBbSwingIdx[RF90_PATH_A]);
+			rtl_set_bbreg(rtlpriv, rA_TxScale_Jaguar, 0xFFE00000, txscalling_tbl[finalBbSwingIdx[RF90_PATH_A]]);
+		}
+	} else if (Method == MIX_MODE) {
+			RT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD, "pDM_Odm->DefaultOfdmIndex=%d, pDM_Odm->Aboslute_OFDMSwingIdx[RFPath]=%d, RF_Path = %d\n",
+				rtldm->default_ofdm_index, rtldm->absolute_ofdm_swing_idx[RFPath], RFPath);
+
+			Final_OFDM_Swing_Index = rtldm->default_ofdm_index + rtldm->absolute_ofdm_swing_idx[RFPath];
+
+			if (RFPath == RF90_PATH_A) {
+				if (Final_OFDM_Swing_Index > PwrTrackingLimit) {
+					/* BBSwing higher then Limit */
+					rtldm->remnant_cck_idx = Final_OFDM_Swing_Index - PwrTrackingLimit;            /* CCK Follow the same compensate value as Path A */
+					rtldm->remnant_ofdm_swing_idx[RFPath] = Final_OFDM_Swing_Index - PwrTrackingLimit;
+
+					rtl_set_bbreg(rtlpriv, rA_TxScale_Jaguar, 0xFFE00000, txscalling_tbl[PwrTrackingLimit]);
+
+					rtldm->modify_txagc_flag_path_a = true;
+
+					/* Set TxAGC Page C{}; */
+					/* rtlpriv->cfg->ops.SetTxPowerLevelHandler(rtlpriv, pHalData->CurrentChannel); */
+					PHY_SetTxPowerLevel8812(rtlpriv, rtlpriv->phy.current_channel);
+					RT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD, "******Path_A Over BBSwing Limit , PwrTrackingLimit = %d , Remnant TxAGC Value = %d \n", PwrTrackingLimit, rtldm->remnant_ofdm_swing_idx[RFPath]);
+				} else if (Final_OFDM_Swing_Index < 0) {
+					rtldm->remnant_cck_idx = Final_OFDM_Swing_Index;            /* CCK Follow the same compensate value as Path A */
+					rtldm->remnant_ofdm_swing_idx[RFPath] = Final_OFDM_Swing_Index;
+
+					rtl_set_bbreg(rtlpriv, rA_TxScale_Jaguar, 0xFFE00000, txscalling_tbl[0]);
+
+					rtldm->modify_txagc_flag_path_a = true;
+
+					/* Set TxAGC Page C{}; */
+					/* rtlpriv->cfg->ops.SetTxPowerLevelHandler(rtlpriv, pHalData->CurrentChannel); */
+					PHY_SetTxPowerLevel8812(rtlpriv, rtlpriv->phy.current_channel);
+					RT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD, "******Path_A Lower then BBSwing lower bound  0 , Remnant TxAGC Value = %d \n", rtldm->remnant_ofdm_swing_idx[RFPath]);
+				} else {
+					rtl_set_bbreg(rtlpriv, rA_TxScale_Jaguar, 0xFFE00000, txscalling_tbl[Final_OFDM_Swing_Index]);
+					RT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD, "******Path_A Compensate with BBSwing , Final_OFDM_Swing_Index = %d \n", Final_OFDM_Swing_Index);
+					if (rtldm->modify_txagc_flag_path_a) {
+						/* If TxAGC has changed, reset TxAGC again */
+						rtldm->remnant_cck_idx = 0;
+						rtldm->remnant_ofdm_swing_idx[RFPath] = 0;
+
+						/* Set TxAGC Page C{}; */
+						/* rtlpriv->cfg->ops.SetTxPowerLevelHandler(rtlpriv, pHalData->CurrentChannel); */
+						PHY_SetTxPowerLevel8812(rtlpriv, rtlpriv->phy.current_channel);
+
+						rtldm->modify_txagc_flag_path_a = false;
+						RT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD, "******Path_A pDM_Odm->Modify_TxAGC_Flag = false \n");
+					}
+				}
+			}
+
+	} else {
+		return;
+	}
+}
+/* START Copied from hal/OUTSRC/rtl8821a/HalHWImg8821A_RF.c */
+
+/******************************************************************************
+*                           TxPowerTrack_USB.TXT
+******************************************************************************/
+
+static u8 rtl8821au_delta_swing_table_idx_5gb_n[][DELTA_SWINGIDX_SIZE] = {
+	{0, 1, 1, 2, 2, 3, 4, 5, 6,  6,  7,  7,  8,  8,  9,  9,
+	10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 14, 14, 14, 14},
+	{0, 1, 1, 2, 3, 3, 4, 5, 5,  6,  7,  7,  8,  8,  9,  9,
+	10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11},
+	{0, 1, 1, 2, 3, 3, 4, 5, 6,  7,  7,  8,  8,  9,  9, 10,
+	11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11},
+};
+
+static u8 rtl8821au_delta_swing_table_idx_5gb_p[][DELTA_SWINGIDX_SIZE] = {
+	{0, 1, 1, 2, 2, 3, 3, 4, 5,  6,  7,  7,  8,  8,  9,  9,
+	10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11},
+	{0, 1, 1, 2, 3, 3, 4, 5, 5,  6,  7,  7,  8,  8,  9,  9,
+	10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11},
+	{0, 1, 1, 2, 3, 3, 4, 5, 6,  7,  7,  8,  8,  9,  9, 10,
+	11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11},
+};
+
+static u8 rtl8821au_delta_swing_table_idx_5ga_n[][DELTA_SWINGIDX_SIZE] = {
+	{0, 0, 0, 1, 2, 2, 3, 4, 5, 6,  6,  7,  7,  8,  8,  9,
+	9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 15, 15, 15, 15},
+	{0, 0, 0, 1, 2, 2, 3, 4, 5, 6,  6,  7,  7,  8,  8,  9,
+	9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 15, 15, 15, 15},
+	{0, 0, 0, 1, 2, 2, 3, 4, 5, 6,  6,  7,  7,  8,  8,  9,
+	9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 15, 15, 15, 15},
+};
+
+static u8 rtl8821au_delta_swing_table_idx_5ga_p[][DELTA_SWINGIDX_SIZE] = {
+	{1, 2, 3, 4, 5, 6, 7, 8, 9,  10, 11, 12,  13,  14, 15, 16,
+	16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16},
+	{1, 2, 3, 4, 5, 6, 7, 8, 9,  10, 11, 12,  13,  14, 15, 16,
+	16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16},
+	{1, 2, 3, 4, 5, 6, 7, 8, 9,  10, 11, 12,  13,  14, 15, 16,
+	16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16},
+};
+
+static u8 rtl8821au_delta_swing_table_idx_24gb_n[]    = {
+	0, 1, 1, 2, 2, 2, 3, 3, 3,  4,  4,  5,  5,  5,  6,  6,
+	7,  7,  8,  8,  9,  9, 10, 10, 11, 11, 11, 11, 11, 11
+};
+
+static u8 rtl8821au_delta_swing_table_idx_24gb_p[]    = {
+	0, 1, 1, 2, 2, 2, 3, 3, 3,  4,  4,  4,  5,  5,  5,  6,
+	6,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7
+};
+
+static u8 rtl8821au_delta_swing_table_idx_24ga_n[]    = {
+	0, 1, 1, 2, 2, 2, 3, 3, 3,  4,  4,  4,  5,  5,  5,  6,
+	6,  6,  7,  7,  7,  8,  8,  9, 10, 10, 10, 10, 10, 10
+};
+
+static u8 rtl8821au_delta_swing_table_idx_24ga_p[]    = {
+	0, 1, 1, 2, 2, 2, 3, 3, 3,  4,  4,  4,  5,  5,  5,  6,
+	6,  6,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7
+};
+
+static u8 rtl8821au_delta_swing_table_idx_24gcckb_n[] = {
+	0, 1, 1, 2, 2, 2, 3, 3, 3,  4,  4,  5,  5,  5,  6,  6,
+	7,  7,  8,  8,  9,  9, 10, 10, 11, 11, 11, 11, 11, 11
+};
+
+static u8 rtl8821au_delta_swing_table_idx_24gcckb_p[] = {
+	0, 1, 1, 2, 2, 2, 3, 3, 3,  4,  4,  4,  5,  5,  5,  6,
+	6,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7
+};
+
+static u8 rtl8821au_delta_swing_table_idx_24gccka_n[] = {
+	0, 1, 1, 2, 2, 2, 3, 3, 3,  4,  4,  4,  5,  5,  5,  6,
+	6,  6,  7,  7,  7,  8,  8,  9, 10, 10, 10, 10, 10, 10
+};
+
+static u8 rtl8821au_delta_swing_table_idx_24gccka_p[] = {
+	0, 1, 1, 2, 2, 2, 3, 3, 3,  4,  4,  4,  5,  5,  5,  6,
+	6,  6,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7
+};
+
+
+/* END Copied from hal/OUTSRC/rtl8821a/HalHWImg8821A_RF.c */
+
+void rtl8821au_get_delta_swing_table(struct rtl_priv *rtlpriv,
+	u8 **up_a, u8 **down_a,
+	u8 **up_b, u8 **down_b)
+{
+	/* u16     rate = pMgntInfo->ForcedDataRate; */
+	u16	rate = 0;
+	u8         	channel   		 = rtlpriv->phy.current_channel;
+
+	if (1 <= channel && channel <= 14) {
+		if (IS_CCK_RATE(rate)) {
+			*up_a   = rtl8821au_delta_swing_table_idx_24gccka_p;
+			*down_a = rtl8821au_delta_swing_table_idx_24gccka_n;
+			*up_b   = rtl8821au_delta_swing_table_idx_24gcckb_p;
+			*down_b = rtl8821au_delta_swing_table_idx_24gcckb_n;
+		} else {
+			*up_a   = rtl8821au_delta_swing_table_idx_24ga_p;
+			*down_a = rtl8821au_delta_swing_table_idx_24ga_n;
+			*up_b   = rtl8821au_delta_swing_table_idx_24gb_p;
+			*down_b = rtl8821au_delta_swing_table_idx_24gb_n;
+		}
+	} else if (36 <= channel && channel <= 64) {
+		*up_a   = rtl8821au_delta_swing_table_idx_5ga_p[0];
+		*down_a = rtl8821au_delta_swing_table_idx_5ga_n[0];
+		*up_b   = rtl8821au_delta_swing_table_idx_5gb_p[0];
+		*down_b = rtl8821au_delta_swing_table_idx_5gb_n[0];
+	} else if (100 <= channel && channel <= 140) {
+		*up_a   = rtl8821au_delta_swing_table_idx_5ga_p[1];
+		*down_a = rtl8821au_delta_swing_table_idx_5ga_n[1];
+		*up_b   = rtl8821au_delta_swing_table_idx_5gb_p[1];
+		*down_b = rtl8821au_delta_swing_table_idx_5gb_n[1];
+	} else if (149 <= channel && channel <= 173) {
+		*up_a   = rtl8821au_delta_swing_table_idx_5ga_p[2];
+		*down_a = rtl8821au_delta_swing_table_idx_5ga_n[2];
+		*up_b   = rtl8821au_delta_swing_table_idx_5gb_p[2];
+		*down_b = rtl8821au_delta_swing_table_idx_5gb_n[2];
+	} else {
+		*up_a   = (u8 *)rtl8818e_delta_swing_table_idx_24gb_p;
+		*down_a = (u8 *)rtl8818e_delta_swing_table_idx_24gb_n;
+		*up_b   = (u8 *)rtl8818e_delta_swing_table_idx_24gb_p;
+		*down_b = (u8 *)rtl8818e_delta_swing_table_idx_24gb_n;
+	}
+
+	return;
+}
+
+static void rtl8812au_phy_lc_calibrate(struct rtl_priv *rtlpriv)
+{
+	uint32_t	/*RF_Amode=0, RF_Bmode=0,*/ LC_Cal = 0, tmp = 0;
+
+	/* Check continuous TX and Packet TX */
+	uint32_t	reg0x914 = rtl_read_dword(rtlpriv, rSingleTone_ContTx_Jaguar);;
+
+	/* Backup RF reg18. */
+	LC_Cal = rtl_get_rfreg(rtlpriv, RF90_PATH_A, RF_CHNLBW, bRFRegOffsetMask);
+
+	if ((reg0x914 & 0x70000) != 0)	/* If contTx, disable all continuous TX. 0x914[18:16] */
+		/*
+		 *  <20121121, Kordan> A workaround: If we set 0x914[18:16] as zero, BB turns off ContTx
+		 *  until another packet comes in. To avoid ContTx being turned off, we skip this step.
+		 * ODM_Write4Byte(pDM_Odm, rSingleTone_ContTx_Jaguar, reg0x914 & (~0x70000));
+		 */
+
+		;
+	else		/* If packet Tx-ing, pause Tx. */
+		rtl_write_byte(rtlpriv, REG_TXPAUSE, 0xFF);
+
+
+/*
+	//3 1. Read original RF mode
+	RF_Amode = rtl_get_rfreg(pDM_Odm->rtlpriv, RF90_PATH_A, RF_AC, bRFRegOffsetMask);
+	if(is2T)
+		RF_Bmode = rtl_get_rfreg(pDM_Odm->rtlpriv, RF90_PATH_B, RF_AC, bRFRegOffsetMask);
+
+
+	//3 2. Set RF mode = standby mode
+	rtl_set_rfreg(pDM_Odm->rtlpriv, RF90_PATH_A, RF_AC, bRFRegOffsetMask, (RF_Amode&0x8FFFF)|0x10000);
+	if(is2T)
+		rtl_set_rfreg(pDM_Odm->rtlpriv, RF90_PATH_B, RF_AC, bRFRegOffsetMask, (RF_Bmode&0x8FFFF)|0x10000);
+*/
+
+	/* Enter LCK mode */
+	tmp = rtl_get_rfreg(rtlpriv, RF90_PATH_A, RF_LCK, bRFRegOffsetMask);
+	rtl_set_rfreg(rtlpriv, RF90_PATH_A, RF_LCK, bRFRegOffsetMask, tmp | BIT(14));
+
+	/* 3 3. Read RF reg18 */
+	LC_Cal = rtl_get_rfreg(rtlpriv, RF90_PATH_A, RF_CHNLBW, bRFRegOffsetMask);
+
+	/* 3 4. Set LC calibration begin BIT(15) */
+	rtl_set_rfreg(rtlpriv, RF90_PATH_A, RF_CHNLBW, bRFRegOffsetMask, LC_Cal|0x08000);
+
+	/* Leave LCK mode */
+	tmp = rtl_get_rfreg(rtlpriv, RF90_PATH_A, RF_LCK, bRFRegOffsetMask);
+	rtl_set_rfreg(rtlpriv, RF90_PATH_A, RF_LCK, bRFRegOffsetMask, tmp & ~BIT(14));
+
+	mdelay(100);
+
+	/* 3 Restore original situation */
+	if ((reg0x914 & 70000) != 0) {	/* Deal with contisuous TX case, 0x914[18:16] */
+		/*
+		 * <20121121, Kordan> A workaround: If we set 0x914[18:16] as zero, BB turns off ContTx
+		 * until another packet comes in. To avoid ContTx being turned off, we skip this step.
+		 * ODM_Write4Byte(pDM_Odm, rSingleTone_ContTx_Jaguar, reg0x914);
+		 */
+		;
+	} else {
+		/* Deal with Packet TX case */
+		rtl_write_byte(rtlpriv, REG_TXPAUSE, 0x00);
+	}
+
+	/* Recover channel number */
+	rtl_set_rfreg(rtlpriv, RF90_PATH_A, RF_CHNLBW, bRFRegOffsetMask, LC_Cal);
+
+	/*
+	rtl_set_rfreg(pDM_Odm->rtlpriv, RF90_PATH_A, RF_AC, bRFRegOffsetMask, RF_Amode);
+	if(is2T)
+		rtl_set_rfreg(pDM_Odm->rtlpriv, RF90_PATH_B, RF_AC, bRFRegOffsetMask, RF_Bmode);
+		*/
+}
+
+static void rtl8812au_dm_txpower_tracking_callback_thermalmeter(struct rtl_priv *rtlpriv)
+{
+	struct rtl_efuse *efuse = rtl_efuse(rtlpriv);
+	struct rtl_dm	*rtldm = rtl_dm(rtlpriv);
+
+	u8 thermal_value = 0, delta, delta_lck, delta_iqk, p = 0, i = 0;
+	u8 thermal_value_avg_count = 0;
+	u32 thermal_value_avg = 0;
+
+	u8 ofdm_min_index = 0;		/* OFDM BB Swing should be less than +if (.0dB, which is required by Arthur */
+	u8 index_for_channel = 0;	/* GetRightChnlPlaceforIQK(pHalData->CurrentChannel) */
+
+	/* 4 1. The following TWO tables decide the final index of OFDM/CCK swing table. */
+	u8 *up_a, *down_a, *up_b, *down_b;
+
+	/* 4 2. Initilization ( 7 steps in total ) */
+
+	rtl8812au_get_delta_swing_table(rtlpriv, (u8 **)&up_a, (u8 **)&down_a,
+					 (u8 **)&up_b, (u8 **)&down_b);
+
+#if 0		/* ULLI : only writing, no use */
+#endif
+	rtldm->txpower_trackinginit = true;
+
+	RT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD,
+		"===>ODM_TXPowerTrackingCallback_ThermalMeter, \n rtldm->BbSwingIdxCckBase: %d, rtldm->BbSwingIdxOfdmBase[A]: %d, rtldm->DefaultOfdmIndex: %d\n",
+		rtldm->swing_idx_cck_base, rtldm->swing_idx_ofdm_base[RF90_PATH_A],
+		rtldm->default_ofdm_index);
+
+	thermal_value = (u8)rtl_get_rfreg(rtlpriv, RF90_PATH_A, RF_T_METER_8812A, 0xfc00);	/* 0x42: RF Reg[15:10] 88E */
+	if (!rtldm->txpower_track_control
+	 || efuse->eeprom_thermalmeter == 0
+	 || efuse->eeprom_thermalmeter == 0xFF)
+		return;
+
+	/* 4 if (. Initialize ThermalValues of RFCalibrateInfo */
+
+	/* 4 4. Calculate average thermal meter */
+
+	rtldm->thermalvalue_avg[rtldm->thermalvalue_avg_index] = thermal_value;
+	rtldm->thermalvalue_avg_index++;
+	if (rtldm->thermalvalue_avg_index == AVG_THERMAL_NUM_8812A)   /* Average times =  c.AverageThermalNum */
+		rtldm->thermalvalue_avg_index = 0;
+
+	for (i = 0; i < AVG_THERMAL_NUM_8812A; i++) {
+		if (rtldm->thermalvalue_avg[i]) {
+			thermal_value_avg += rtldm->thermalvalue_avg[i];
+			thermal_value_avg_count++;
+		}
+	}
+
+	if (thermal_value_avg_count) {               /* Calculate Average ThermalValue after average enough times */
+		thermal_value = (u8)(thermal_value_avg / thermal_value_avg_count);
+		RT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD, "AVG Thermal Meter = 0x%X, EFUSE Thermal Base = 0x%X\n", thermal_value, efuse->eeprom_thermalmeter);
+	}
+
+	/* 4 5. Calculate delta, delta_LCK, delta_IQK. */
+
+	/* "delta" here is used to determine whether thermal value changes or not. */
+	delta 	  = (thermal_value > rtldm->thermalvalue)?(thermal_value - rtldm->thermalvalue):(rtldm->thermalvalue - thermal_value);
+	delta_lck = (thermal_value > rtldm->thermalvalue_lck)?(thermal_value - rtldm->thermalvalue_lck):(rtldm->thermalvalue_lck - thermal_value);
+	delta_iqk = (thermal_value > rtldm->thermalvalue_iqk)?(thermal_value - rtldm->thermalvalue_iqk):(rtldm->thermalvalue_iqk - thermal_value);
+
+	RT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD, "(delta, delta_LCK, delta_IQK) = (%d, %d, %d)\n", delta, delta_lck, delta_iqk);
+
+	/* 4 6. If necessary, do LCK. */
+
+	if ((delta_lck >= IQK_THRESHOLD)) {	/* Delta temperature is equal to or larger than 20 centigrade. */
+		RT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD, "delta_LCK(%d) >= Threshold_IQK(%d)\n", delta_lck, IQK_THRESHOLD);
+		rtldm->thermalvalue_lck = thermal_value;
+		rtl8812au_phy_lc_calibrate(rtlpriv);
+	}
+
+	/* if ( 7. If necessary, move the index of swing table to adjust Tx power. */
+
+	if (delta > 0 && rtldm->txpower_track_control) {
+		/* "delta" here is used to record the absolute value of differrence. */
+	    delta = thermal_value > efuse->eeprom_thermalmeter?(thermal_value - efuse->eeprom_thermalmeter):(efuse->eeprom_thermalmeter - thermal_value);
+		if (delta >= TXSCALE_TABLE_SIZE)
+			delta = TXSCALE_TABLE_SIZE - 1;
+
+		/* 4 7.1 The Final Power Index = BaseIndex + PowerIndexOffset */
+
+		if (thermal_value > efuse->eeprom_thermalmeter) {
+			RT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD, "deltaSwingTableIdx_TUP_A[%d] = %d\n", delta, up_a[delta]);
+			rtldm->delta_power_index_last[RF90_PATH_A] = rtldm->delta_power_index[RF90_PATH_A];
+			rtldm->delta_power_index[RF90_PATH_A] = up_a[delta];
+
+			rtldm->absolute_ofdm_swing_idx[RF90_PATH_A] =  up_a[delta];        /* Record delta swing for mix mode power tracking */
+
+			RT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD, "******Temp is higher and rtldm->Aboslute_OFDMSwingIdx[RF90_PATH_A] = %d\n", rtldm->absolute_ofdm_swing_idx[RF90_PATH_A]);
+
+			RT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD, "deltaSwingTableIdx_TUP_B[%d] = %d\n", delta, up_b[delta]);
+			rtldm->delta_power_index_last[RF90_PATH_B] = rtldm->delta_power_index[RF90_PATH_B];
+			rtldm->delta_power_index[RF90_PATH_B] = up_b[delta];
+
+			rtldm->absolute_ofdm_swing_idx[RF90_PATH_B] =  up_a[delta];       /* Record delta swing for mix mode power tracking */
+
+			RT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD, "******Temp is higher and rtldm->Aboslute_OFDMSwingIdx[RF90_PATH_B] = %d\n", rtldm->absolute_ofdm_swing_idx[RF90_PATH_B]);
+
+		} else {
+			RT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD, "deltaSwingTableIdx_TDOWN_A[%d] = %d\n", delta, down_a[delta]);
+
+			rtldm->delta_power_index_last[RF90_PATH_A] = rtldm->delta_power_index[RF90_PATH_A];
+			rtldm->delta_power_index[RF90_PATH_A] = -1 * down_a[delta];
+
+			rtldm->absolute_ofdm_swing_idx[RF90_PATH_A] =  -1 * down_a[delta];        /* Record delta swing for mix mode power tracking */
+
+			RT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD, "******Temp is lower and rtldm->Aboslute_OFDMSwingIdx[RF90_PATH_A] = %d\n", rtldm->absolute_ofdm_swing_idx[RF90_PATH_A]);
+
+			RT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD, "deltaSwingTableIdx_TDOWN_B[%d] = %d\n", delta, down_b[delta]);
+
+			rtldm->delta_power_index_last[RF90_PATH_B] = rtldm->delta_power_index[RF90_PATH_B];
+			rtldm->delta_power_index[RF90_PATH_B] = -1 * down_b[delta];
+
+			rtldm->absolute_ofdm_swing_idx[RF90_PATH_B] =  -1 * down_b[delta];       /* Record delta swing for mix mode power tracking */
+
+			RT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD, "******Temp is lower and rtldm->Aboslute_OFDMSwingIdx[RF90_PATH_B] = %d\n", rtldm->absolute_ofdm_swing_idx[RF90_PATH_B]);
+		}
+
+	    for (p = RF90_PATH_A; p < MAX_PATH_NUM_8812A; p++) {
+			RT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD, "\n\n================================ [Path-%c] Calculating PowerIndexOffset ================================\n", (p == RF90_PATH_A ? 'A' : 'B'));
+			if (rtldm->delta_power_index[p] == rtldm->delta_power_index_last[p])         /* If Thermal value changes but lookup table value still the same */
+				rtldm->power_index_offset[p] = 0;
+			else
+				rtldm->power_index_offset[p] = rtldm->delta_power_index[p] - rtldm->delta_power_index_last[p];      /* Power Index Diff between 2 times Power Tracking */
+
+			RT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD, "[Path-%c] PowerIndexOffset(%d) = DeltaPowerIndex(%d) - DeltaPowerIndexLast(%d)\n", (p == RF90_PATH_A ? 'A' : 'B'), rtldm->power_index_offset[p], rtldm->delta_power_index[p],
+			rtldm->delta_power_index_last[p]);
+
+			rtldm->ofdm_index[p] = rtldm->swing_idx_ofdm_base[p] + rtldm->power_index_offset[p];
+			rtldm->cck_index = rtldm->swing_idx_cck_base + rtldm->power_index_offset[p];
+
+			rtldm->swing_idx_cck = rtldm->cck_index;
+			rtldm->swing_idx_ofdm[p] = rtldm->ofdm_index[p];
+
+	       /* *************Print BB Swing Base and Index Offset************* */
+
+			RT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD, "The 'CCK' final index(%d) = BaseIndex(%d) + PowerIndexOffset(%d)\n",  rtldm->swing_idx_cck, rtldm->swing_idx_cck_base, rtldm->power_index_offset[p]);
+			RT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD, "The 'OFDM' final index(%d) = BaseIndex[%c](%d) + PowerIndexOffset(%d)\n", rtldm->swing_idx_ofdm[p], (p == RF90_PATH_A ? 'A' : 'B'), rtldm->swing_idx_ofdm_base[p], rtldm->power_index_offset[p]);
+
+		    /* 4 7.1 Handle boundary conditions of index. */
+
+			if (rtldm->ofdm_index[p] > TXSCALE_TABLE_SIZE-1) {
+				rtldm->ofdm_index[p] = TXSCALE_TABLE_SIZE-1;
+			} else if (rtldm->ofdm_index[p] < ofdm_min_index) {
+				rtldm->ofdm_index[p] = ofdm_min_index;
+			}
+		}
+		RT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD, "\n\n========================================================================================================\n");
+		if (rtldm->cck_index > TXSCALE_TABLE_SIZE-1)
+			rtldm->cck_index = TXSCALE_TABLE_SIZE-1;
+	} else {
+		RT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD, "The thermal meter is unchanged or TxPowerTracking OFF(%d): ThermalValue: %d , rtldm->RFCalibrateInfo.ThermalValue: %d\n", rtldm->txpower_track_control, thermal_value, rtldm->thermalvalue);
+
+		for (p = RF90_PATH_A; p < MAX_PATH_NUM_8812A; p++)
+			rtldm->power_index_offset[p] = 0;
+	}
+	RT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD, "TxPowerTracking: [CCK] Swing Current Index: %d, Swing Base Index: %d\n", rtldm->cck_index, rtldm->swing_idx_cck_base);       /* Print Swing base & current */
+	for (p = RF90_PATH_A; p < MAX_PATH_NUM_8812A; p++) {
+		RT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD, "TxPowerTracking: [OFDM] Swing Current Index: %d, Swing Base Index[%c]: %d\n", rtldm->ofdm_index[p], (p == RF90_PATH_A ? 'A' : 'B'), rtldm->swing_idx_ofdm_base[p]);
+	}
+
+	if ((rtldm->power_index_offset[RF90_PATH_A] != 0 ||  rtldm->power_index_offset[RF90_PATH_B] != 0)
+	 && rtldm->txpower_track_control) {
+		/* 4 7.2 Configure the Swing Table to adjust Tx Power. */
+#if 0		/* ULLI : only writing, no use */
+		rtldm->bTxPowerChanged = true; /* Always true after Tx Power is adjusted by power tracking. */
+#endif
+		/*
+		 *  2012/04/2if ( MH According to Luke's suggestion, we can not write BB digital
+		 *  to increase TX power. Otherwise, EVM will be bad.
+		 *
+		 *  2012/04/25 MH Add for tx power tracking to set tx power in tx agc for 88E.
+		 */
+		if (thermal_value > rtldm->thermalvalue) {
+			RT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD, "Temperature Increasing(A): delta_pi: %d , delta_t: %d, Now_t: %d, EFUSE_t: %d, Last_t: %d\n", rtldm->power_index_offset[RF90_PATH_A], delta, thermal_value, efuse->eeprom_thermalmeter, rtldm->thermalvalue);
+			RT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD, "Temperature Increasing(B): delta_pi: %d , delta_t: %d, Now_t: %d, EFUSE_t: %d, Last_t: %d\n", rtldm->power_index_offset[RF90_PATH_B], delta, thermal_value, efuse->eeprom_thermalmeter, rtldm->thermalvalue);
+
+			} else if (thermal_value < rtldm->thermalvalue) { /* Low temperature */
+				RT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD, "Temperature Decreasing(A): delta_pi: %d , delta_t: %d, Now_t: %d, EFUSE_t: %d, Last_t: %d\n", rtldm->power_index_offset[RF90_PATH_A], delta, thermal_value, efuse->eeprom_thermalmeter, rtldm->thermalvalue);
+				RT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD, "Temperature Decreasing(B): delta_pi: %d , delta_t: %d, Now_t: %d, EFUSE_t: %d, Last_t: %d\n", rtldm->power_index_offset[RF90_PATH_B], delta, thermal_value, efuse->eeprom_thermalmeter, rtldm->thermalvalue);
+
+			}
+			if (thermal_value > efuse->eeprom_thermalmeter) {
+				RT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD, "Temperature(%d) higher than PG value(%d)\n", thermal_value, efuse->eeprom_thermalmeter);
+
+				for (p = RF90_PATH_A; p < MAX_PATH_NUM_8812A; p++)
+					rtl8812au_dm_pxpwr_track_set_pwr(rtlpriv, BBSWING, p, index_for_channel);
+			} else {
+				RT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD, "Temperature(%d) lower than PG value(%d)\n", thermal_value, efuse->eeprom_thermalmeter);
+
+				for (p = RF90_PATH_A; p < MAX_PATH_NUM_8812A; p++)
+					rtl8812au_dm_pxpwr_track_set_pwr(rtlpriv, BBSWING, p, index_for_channel);
+			}
+
+			rtldm->swing_idx_cck_base = rtldm->swing_idx_cck;  	/* Record last time Power Tracking result as base. */
+			for (p = RF90_PATH_A; p < MAX_PATH_NUM_8812A; p++)	/* ULLI huh ?? */
+				rtldm->swing_idx_ofdm_base[p] = rtldm->swing_idx_ofdm[p];
+
+			RT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD,  "rtldm->RFCalibrateInfo.ThermalValue = %d ThermalValue= %d\n", rtldm->thermalvalue, thermal_value);
+
+			rtldm->thermalvalue = thermal_value;     /* Record last Power Tracking Thermal Value */
+
+	}
+	if ((delta_iqk >= IQK_THRESHOLD))	/* Delta temperature is equal to or larger than 20 centigrade (When threshold is 8). */
+		rtl8812au_do_iqk(rtlpriv, delta_iqk, thermal_value, 8);
+
+	RT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD, "<===ODM_TXPowerTrackingCallback_ThermalMeter\n");
+
+	rtldm->txpowercount = 0;
+}
+
+
+static void rtl8821au_dm_txpower_tracking_callback_thermalmeter(struct rtl_priv *rtlpriv)
+{
+	struct rtl_efuse *efuse = rtl_efuse(rtlpriv);
+	struct rtl_dm	*rtldm = rtl_dm(rtlpriv);
+
+	u8 thermal_value = 0, delta, delta_lck, delta_iqk, p = 0, i = 0;
+	u8 thermal_value_avg_count = 0;
+	u32 thermal_value_avg = 0;
+
+	u8 ofdm_min_index = 0;  /* OFDM BB Swing should be less than +if (.0dB, which is required by Arthur */
+	u8 index_for_channel = 0;	/* GetRightChnlPlaceforIQK(pHalData->CurrentChannel) */
+
+	/* 4 1. The following TWO tables decide the final index of OFDM/CCK swing table. */
+	u8 *up_a, *down_a, *up_b, *down_b;
+
+	/* 4 2. Initilization ( 7 steps in total ) */
+
+	rtl8821au_get_delta_swing_table(rtlpriv, (u8 **)&up_a, (u8 **)&down_a,
+					 (u8 **)&up_b, (u8 **)&down_b);
+
+	RT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD, "===>ODM_TXPowerTrackingCallback_ThermalMeter, \n rtldm->BbSwingIdxCckBase: %d, rtldm->BbSwingIdxOfdmBase[A]: %d, rtldm->DefaultOfdmIndex: %d\n", rtldm->swing_idx_cck_base, rtldm->swing_idx_ofdm_base[RF90_PATH_A], rtldm->default_ofdm_index);
+
+	thermal_value = (u8)rtl_get_rfreg(rtlpriv, RF90_PATH_A, RF_T_METER_8812A, 0xfc00);	/* 0x42: RF Reg[15:10] 88E */
+	if (!rtldm->txpower_track_control
+	 || efuse->eeprom_thermalmeter == 0
+	 || efuse->eeprom_thermalmeter == 0xFF)
+		return;
+
+	/* 4 if (. Initialize ThermalValues of RFCalibrateInfo */
+
+	/* 4 4. Calculate average thermal meter */
+
+	rtldm->thermalvalue_avg[rtldm->thermalvalue_avg_index] = thermal_value;
+	rtldm->thermalvalue_avg_index++;
+	if (rtldm->thermalvalue_avg_index == AVG_THERMAL_NUM_8812A)   /* Average times =  c.AverageThermalNum */
+		rtldm->thermalvalue_avg_index = 0;
+
+	for (i = 0; i < AVG_THERMAL_NUM_8812A; i++) {
+		if (rtldm->thermalvalue_avg[i]) {
+			thermal_value_avg += rtldm->thermalvalue_avg[i];
+			thermal_value_avg_count++;
+		}
+	}
+
+	if (thermal_value_avg_count) {               /* Calculate Average ThermalValue after average enough times */
+		thermal_value = (u8)(thermal_value_avg / thermal_value_avg_count);
+		RT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD, "AVG Thermal Meter = 0x%X, EFUSE Thermal Base = 0x%X\n", thermal_value, efuse->eeprom_thermalmeter);
+	}
+
+	/* 4 5. Calculate delta, delta_LCK, delta_IQK. */
+
+	/* "delta" here is used to determine whether thermal value changes or not. */
+	delta 	  = (thermal_value > rtldm->thermalvalue)?(thermal_value - rtldm->thermalvalue):(rtldm->thermalvalue - thermal_value);
+	delta_lck = (thermal_value > rtldm->thermalvalue_lck)?(thermal_value - rtldm->thermalvalue_lck):(rtldm->thermalvalue_lck - thermal_value);
+	delta_iqk = (thermal_value > rtldm->thermalvalue_iqk)?(thermal_value - rtldm->thermalvalue_iqk):(rtldm->thermalvalue_iqk - thermal_value);
+
+	RT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD, "(delta, delta_LCK, delta_IQK) = (%d, %d, %d)\n", delta, delta_lck, delta_iqk);
+
+	/* 4 6. If necessary, do LCK. */
+
+	if ((delta_lck >= IQK_THRESHOLD)) {	/* Delta temperature is equal to or larger than 20 centigrade. */
+		RT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD, "delta_LCK(%d) >= Threshold_IQK(%d)\n", delta_lck, IQK_THRESHOLD);
+		rtldm->thermalvalue_lck = thermal_value;
+		rtl8812au_phy_lc_calibrate(rtlpriv);
+	}
+
+	/* if ( 7. If necessary, move the index of swing table to adjust Tx power. */
+
+	if (delta > 0 && rtldm->txpower_track_control) {
+		/* "delta" here is used to record the absolute value of differrence. */
+	    delta = thermal_value > efuse->eeprom_thermalmeter?(thermal_value - efuse->eeprom_thermalmeter):(efuse->eeprom_thermalmeter - thermal_value);
+		if (delta >= TXSCALE_TABLE_SIZE)
+			delta = TXSCALE_TABLE_SIZE - 1;
+
+		/* 4 7.1 The Final Power Index = BaseIndex + PowerIndexOffset */
+
+		if (thermal_value > efuse->eeprom_thermalmeter) {
+			RT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD, "deltaSwingTableIdx_TUP_A[%d] = %d\n", delta, up_a[delta]);
+			rtldm->delta_power_index_last[RF90_PATH_A] = rtldm->delta_power_index[RF90_PATH_A];
+			rtldm->delta_power_index[RF90_PATH_A] = up_a[delta];
+
+			rtldm->absolute_ofdm_swing_idx[RF90_PATH_A] =  up_a[delta];        /* Record delta swing for mix mode power tracking */
+
+			RT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD, "******Temp is higher and rtldm->Aboslute_OFDMSwingIdx[RF90_PATH_A] = %d\n", rtldm->absolute_ofdm_swing_idx[RF90_PATH_A]);
+		} else {
+			RT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD, "deltaSwingTableIdx_TDOWN_A[%d] = %d\n", delta, down_a[delta]);
+
+			rtldm->delta_power_index_last[RF90_PATH_A] = rtldm->delta_power_index[RF90_PATH_A];
+			rtldm->delta_power_index[RF90_PATH_A] = -1 * down_a[delta];
+
+			rtldm->absolute_ofdm_swing_idx[RF90_PATH_A] =  -1 * down_a[delta];        /* Record delta swing for mix mode power tracking */
+
+			RT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD, "******Temp is lower and rtldm->Aboslute_OFDMSwingIdx[RF90_PATH_A] = %d\n", rtldm->absolute_ofdm_swing_idx[RF90_PATH_A]);
+		}
+
+	    for (p = RF90_PATH_A; p < MAX_PATH_NUM_8821A; p++) {
+			RT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD, "\n\n================================ [Path-%c] Calculating PowerIndexOffset ================================\n", (p == RF90_PATH_A ? 'A' : 'B'));
+			if (rtldm->delta_power_index[p] == rtldm->delta_power_index_last[p])         /* If Thermal value changes but lookup table value still the same */
+				rtldm->power_index_offset[p] = 0;
+			else
+				rtldm->power_index_offset[p] = rtldm->delta_power_index[p] - rtldm->delta_power_index_last[p];      /* Power Index Diff between 2 times Power Tracking */
+
+			RT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD, "[Path-%c] PowerIndexOffset(%d) = DeltaPowerIndex(%d) - DeltaPowerIndexLast(%d)\n", (p == RF90_PATH_A ? 'A' : 'B'), rtldm->power_index_offset[p], rtldm->delta_power_index[p], rtldm->delta_power_index_last[p]);
+
+			rtldm->ofdm_index[p] = rtldm->swing_idx_ofdm_base[p] + rtldm->power_index_offset[p];
+			rtldm->cck_index = rtldm->swing_idx_cck_base + rtldm->power_index_offset[p];
+
+			rtldm->swing_idx_cck = rtldm->cck_index;
+			rtldm->swing_idx_ofdm[p] = rtldm->ofdm_index[p];
+
+	       /* *************Print BB Swing Base and Index Offset************* */
+
+			RT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD, "The 'CCK' final index(%d) = BaseIndex(%d) + PowerIndexOffset(%d)\n", rtldm->swing_idx_cck, rtldm->swing_idx_cck_base, rtldm->power_index_offset[p]);
+			RT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD, "The 'OFDM' final index(%d) = BaseIndex[%c](%d) + PowerIndexOffset(%d)\n", rtldm->swing_idx_ofdm[p], (p == RF90_PATH_A ? 'A' : 'B'), rtldm->swing_idx_ofdm_base[p], rtldm->power_index_offset[p]);
+
+		    /* 4 7.1 Handle boundary conditions of index. */
+
+			if (rtldm->ofdm_index[p] > TXSCALE_TABLE_SIZE-1) {
+				rtldm->ofdm_index[p] = TXSCALE_TABLE_SIZE-1;
+			} else if (rtldm->ofdm_index[p] < ofdm_min_index) {
+				rtldm->ofdm_index[p] = ofdm_min_index;
+			}
+		}
+		RT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD, "\n\n========================================================================================================\n");
+		if (rtldm->cck_index > TXSCALE_TABLE_SIZE-1)
+			rtldm->cck_index = TXSCALE_TABLE_SIZE-1;
+	} else {
+		RT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD, "The thermal meter is unchanged or TxPowerTracking OFF(%d): ThermalValue: %d , rtldm->RFCalibrateInfo.ThermalValue: %d\n", rtldm->txpower_track_control, thermal_value, rtldm->thermalvalue);
+
+		for (p = RF90_PATH_A; p < MAX_PATH_NUM_8821A; p++)
+			rtldm->power_index_offset[p] = 0;
+	}
+	RT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD, "TxPowerTracking: [CCK] Swing Current Index: %d, Swing Base Index: %d\n", rtldm->cck_index, rtldm->swing_idx_cck_base);       /* Print Swing base & current */
+	for (p = RF90_PATH_A; p < MAX_PATH_NUM_8821A; p++) {
+		RT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD, "TxPowerTracking: [OFDM] Swing Current Index: %d, Swing Base Index[%c]: %d\n", rtldm->ofdm_index[p], (p == RF90_PATH_A ? 'A' : 'B'), rtldm->swing_idx_ofdm_base[p]);
+	}
+
+	if ((rtldm->power_index_offset[RF90_PATH_A] != 0 ||  rtldm->power_index_offset[RF90_PATH_B] != 0)
+	 && rtldm->txpower_track_control) {
+		/* 4 7.2 Configure the Swing Table to adjust Tx Power. */
+#if 0		/* ULLI : only writing, no use */
+		rtldm->bTxPowerChanged = true; /* Always true after Tx Power is adjusted by power tracking. */
+#endif
+		/*
+		 *  2012/04/2if ( MH According to Luke's suggestion, we can not write BB digital
+		 *  to increase TX power. Otherwise, EVM will be bad.
+		 *
+		 *  2012/04/25 MH Add for tx power tracking to set tx power in tx agc for 88E.
+		 */
+		if (thermal_value > rtldm->thermalvalue) {
+			RT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD, "Temperature Increasing(A): delta_pi: %d , delta_t: %d, Now_t: %d, EFUSE_t: %d, Last_t: %d\n", rtldm->power_index_offset[RF90_PATH_A], delta, thermal_value, efuse->eeprom_thermalmeter, rtldm->thermalvalue);
+
+			} else if (thermal_value < rtldm->thermalvalue) { /* Low temperature */
+				RT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD, "Temperature Decreasing(A): delta_pi: %d , delta_t: %d, Now_t: %d, EFUSE_t: %d, Last_t: %d\n", rtldm->power_index_offset[RF90_PATH_A], delta, thermal_value, efuse->eeprom_thermalmeter, rtldm->thermalvalue);
+
+			}
+			if (thermal_value > efuse->eeprom_thermalmeter) {
+				RT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD, "Temperature(%d) higher than PG value(%d)\n", thermal_value, efuse->eeprom_thermalmeter);
+
+				RT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD, "**********Enter POWER Tracking MIX_MODE**********\n");
+				for (p = RF90_PATH_A; p < MAX_PATH_NUM_8821A; p++)
+					rtl8821au_dm_txpwr_track_set_pwr(rtlpriv, MIX_MODE, p, index_for_channel);
+			} else {
+				RT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD, "Temperature(%d) lower than PG value(%d)\n", thermal_value, efuse->eeprom_thermalmeter);
+
+				RT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD, "**********Enter POWER Tracking MIX_MODE**********\n");
+				for (p = RF90_PATH_A; p < MAX_PATH_NUM_8821A; p++)
+					rtl8821au_dm_txpwr_track_set_pwr(rtlpriv, MIX_MODE, p, index_for_channel);
+			}
+
+			rtldm->swing_idx_cck_base = rtldm->swing_idx_cck;  	/* Record last time Power Tracking result as base. */
+			for (p = RF90_PATH_A; p < MAX_PATH_NUM_8821A; p++)
+				rtldm->swing_idx_ofdm_base[p] = rtldm->swing_idx_ofdm[p];
+
+			RT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD,  "rtldm->RFCalibrateInfo.ThermalValue = %d ThermalValue= %d\n", rtldm->thermalvalue, thermal_value);
+
+			rtldm->thermalvalue = thermal_value;     /* Record last Power Tracking Thermal Value */
+
+	}
+	if ((delta_iqk >= IQK_THRESHOLD))	/* Delta temperature is equal to or larger than 20 centigrade (When threshold is 8). */
+		rtl8821au_do_iqk(rtlpriv, delta_iqk, thermal_value, 8);
+
+	RT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD, "<===ODM_TXPowerTrackingCallback_ThermalMeter\n");
+
+	rtldm->txpowercount = 0;
+}
+
+static void rtl8821au_check_tx_power_tracking_thermalmeter(struct rtl_priv *rtlpriv)
+{
+	struct rtl_hal *rtlhal = rtl_hal(rtlpriv);
+	struct rtl_dm *rtldm = rtl_dm(rtlpriv);
+
+	if ( rtldm->tm_trigger) {		/* at least delay 1 sec */
+		/* pHalData->TxPowerCheckCnt++;	//cosa add for debug */
+		rtl_set_rfreg(rtlpriv, RF90_PATH_A, RF_T_METER_NEW, (BIT(17) | BIT(16)), 0x03);
+
+		/* DBG_871X("Trigger Thermal Meter!!\n"); */
+
+		 rtldm->tm_trigger = 1;
+		return;
+	} else {
+		/* DBG_871X("Schedule TxPowerTracking direct call!!\n"); */
+		if (IS_HARDWARE_TYPE_8812AU(rtlhal))
+			rtl8812au_dm_txpower_tracking_callback_thermalmeter(rtlpriv);
+		if (IS_HARDWARE_TYPE_8821U(rtlhal))
+			rtl8821au_dm_txpower_tracking_callback_thermalmeter(rtlpriv);
+		 rtldm->tm_trigger = 0;
+	}
+
+}
+
+
+
+/*
+ * 3============================================================
+ * 3 FASLE ALARM CHECK
+ * 3============================================================
+ */
+
+static void rtl8821au_dm_false_alarm_counter_statistics(struct rtl_priv *rtlpriv)
+{
+	struct false_alarm_statistics *FalseAlmCnt = &(rtlpriv->falsealm_cnt);
+	uint32_t CCKenable;
+	/* read OFDM FA counter */
+	FalseAlmCnt->cnt_ofdm_fail = rtl_get_bbreg(rtlpriv, ODM_REG_OFDM_FA_11AC, bMaskLWord);
+	FalseAlmCnt->cnt_cck_fail = rtl_get_bbreg(rtlpriv, ODM_REG_CCK_FA_11AC, bMaskLWord);
+
+	CCKenable =  rtl_get_bbreg(rtlpriv, ODM_REG_BB_RX_PATH_11AC, BIT(28));
+	if (CCKenable)		/* if (*pDM_Odm->pBandType == ODM_BAND_2_4G) */
+		FalseAlmCnt->cnt_all = FalseAlmCnt->cnt_ofdm_fail + FalseAlmCnt->cnt_cck_fail;
+	else
+		FalseAlmCnt->cnt_all = FalseAlmCnt->cnt_ofdm_fail;
+
+	/* reset OFDM FA coutner */
+	rtl_set_bbreg(rtlpriv, ODM_REG_OFDM_FA_RST_11AC, BIT(17), 1);
+	rtl_set_bbreg(rtlpriv, ODM_REG_OFDM_FA_RST_11AC, BIT(17), 0);
+	/* reset CCK FA counter */
+	rtl_set_bbreg(rtlpriv, ODM_REG_CCK_FA_RST_11AC, BIT(15), 0);
+	rtl_set_bbreg(rtlpriv, ODM_REG_CCK_FA_RST_11AC, BIT(15), 1);
+
+	RT_TRACE(rtlpriv, COMP_DIG, DBG_TRACE, "Cnt_Cck_fail=%d\n", FalseAlmCnt->cnt_cck_fail);
+	RT_TRACE(rtlpriv, COMP_DIG, DBG_TRACE, "Cnt_Ofdm_fail=%d\n", FalseAlmCnt->cnt_ofdm_fail);
+	RT_TRACE(rtlpriv, COMP_DIG, DBG_TRACE, "Total false Alarm=%d\n", FalseAlmCnt->cnt_all);
+}
+
+
+/*
+ * 3============================================================
+ * 3 RSSI Monitor
+ * 3============================================================
+ */
+
+
+static void FindMinimumRSSI(struct rtl_priv *rtlpriv)
+{
+	struct dig_t *rtl_dm_dig = &rtlpriv->dm_digtable;
+
+	/* 1 1.Determine the minimum RSSI */
+
+	if (rtlpriv->mac80211.link_state < MAC80211_LINKED && (rtlpriv->dm.entry_min_undec_sm_pwdb == 0)) {
+		rtl_dm_dig->min_undec_pwdb_for_dm = 0;
+		/* RT_TRACE(rtlrpiv,COMP_BB_POWERSAVING, DBG_LOUD, ("Not connected to any \n")); */
+	} else {
+		rtl_dm_dig->min_undec_pwdb_for_dm = rtlpriv->dm.entry_min_undec_sm_pwdb;
+	}
+
+	/* DBG_8192C("%s=>MinUndecoratedPWDBForDM(%d)\n",__FUNCTION__,pdmpriv->MinUndecoratedPWDBForDM); */
+	/* RT_TRACE(rtlrpiv,COMP_DIG, DBG_LOUD, ("MinUndecoratedPWDBForDM =%d\n",pHalData->MinUndecoratedPWDBForDM)); */
+}
+
+static void rtl8821au_dm_check_rssi_monitor(struct rtl_priv *rtlpriv)
+{
+	struct dig_t *rtl_dm_dig = &rtlpriv->dm_digtable;
+	int	i;
+	int	tmpEntryMaxPWDB = 0, tmpEntryMinPWDB = 0xff;
+	u8 	sta_cnt = 0;
+	u8	UL_DL_STATE = 0;			/*  for 8812 use */
+	uint32_t PWDB_rssi[NUM_STA] = { 0 };		/* [0~15]:MACID, [16~31]:PWDB_rssi */
+
+	if (rtlpriv->mac80211.link_state < MAC80211_LINKED)
+		return;
+
+	if (1) {
+		u64	curTxOkCnt = rtlpriv->xmitpriv.tx_bytes - rtlpriv->xmitpriv.last_tx_bytes;
+		u64	curRxOkCnt = rtlpriv->recvpriv.rx_bytes - rtlpriv->recvpriv.last_rx_bytes;
+
+		if (curRxOkCnt > (curTxOkCnt*6))
+			UL_DL_STATE = 1;
+		else
+			UL_DL_STATE = 0;
+	}
+
+
+	/* if (check_fwstate(&rtlpriv->mlmepriv, WIFI_AP_STATE|WIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE) == true) */
+	{
+#if 1
+		/* ULLI : This will go away in rtlwifi-lib */
+		struct sta_info *psta;
+		struct rtl_dm *rtldm = rtl_dm(rtlpriv);
+		struct _rtw_hal *pHalData = GET_HAL_DATA(rtlpriv);
+
+
+		for (i = 0; i < ODM_ASSOCIATE_ENTRY_NUM; i++) {
+			psta = rtldm->pODM_StaInfo[i];
+			if (IS_STA_VALID(psta)) {
+				if (psta->rssi_stat.UndecoratedSmoothedPWDB < tmpEntryMinPWDB)
+					tmpEntryMinPWDB = psta->rssi_stat.UndecoratedSmoothedPWDB;
+
+				if (psta->rssi_stat.UndecoratedSmoothedPWDB > tmpEntryMaxPWDB)
+					tmpEntryMaxPWDB = psta->rssi_stat.UndecoratedSmoothedPWDB;
+
+				if (psta->rssi_stat.UndecoratedSmoothedPWDB != (-1)) {
+					if (1)
+						PWDB_rssi[sta_cnt++] = (((u8)(psta->mac_id&0xFF)) | ((psta->rssi_stat.UndecoratedSmoothedPWDB&0x7F)<<16));
+					else
+						PWDB_rssi[sta_cnt++] = (psta->mac_id | (psta->rssi_stat.UndecoratedSmoothedPWDB<<16));
+
+				}
+			}
+		}
+#else
+		_irqL irqL;
+		struct list_head	*plist, *phead;
+		struct sta_info *psta;
+		struct sta_priv *pstapriv = &rtlpriv->stapriv;
+		u8 bcast_addr[ETH_ALEN] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
+
+		spin_lock_bh(&pstapriv->sta_hash_lock, &irqL);
+
+		for (i = 0; i < NUM_STA; i++) {
+			phead = &(pstapriv->sta_hash[i]);
+			plist = get_next(phead);
+
+			while ((rtw_end_of_queue_search(phead, plist)) == false) {
+				psta = container_of(plist, struct sta_info, hash_list);
+
+				plist = get_next(plist);
+
+				if (memcmp(psta->hwaddr, bcast_addr, ETH_ALEN) == 0
+				 || memcmp(psta->hwaddr, myid(&rtlpriv->eeprompriv), ETH_ALEN) == 0)
+					continue;
+
+				if (psta->state & WIFI_ASOC_STATE) {
+					if (psta->rssi_stat.UndecoratedSmoothedPWDB < tmpEntryMinPWDB)
+						tmpEntryMinPWDB = psta->rssi_stat.UndecoratedSmoothedPWDB;
+
+					if (psta->rssi_stat.UndecoratedSmoothedPWDB > tmpEntryMaxPWDB)
+						tmpEntryMaxPWDB = psta->rssi_stat.UndecoratedSmoothedPWDB;
+
+					if (psta->rssi_stat.UndecoratedSmoothedPWDB != (-1)) {
+						/* printk("%s==> mac_id(%d),rssi(%d)\n",__FUNCTION__,psta->mac_id,psta->rssi_stat.UndecoratedSmoothedPWDB); */
+						PWDB_rssi[sta_cnt++] = (psta->mac_id | (psta->rssi_stat.UndecoratedSmoothedPWDB<<16));
+					}
+				}
+
+			}
+
+		}
+
+		spin_unlock_bh(&pstapriv->sta_hash_lock, &irqL);
+#endif
+
+		/* printk("%s==> sta_cnt(%d)\n",__FUNCTION__,sta_cnt); */
+
+		for (i = 0; i < sta_cnt; i++) {
+			if (PWDB_rssi[i] != (0)) {
+				if (pHalData->fw_ractrl == true) {	/* Report every sta's RSSI to FW */
+					PWDB_rssi[i] |= (UL_DL_STATE << 24);
+					rtl8812_set_rssi_cmd(rtlpriv, (u8 *)(&PWDB_rssi[i]));
+				} else {
+				}
+			}
+		}
+	}
+
+
+
+	if (tmpEntryMaxPWDB != 0) {	/* If associated entry is found */
+		rtlpriv->dm.entry_max_undec_sm_pwdb = tmpEntryMaxPWDB;
+	} else {
+		rtlpriv->dm.entry_max_undec_sm_pwdb = 0;
+	}
+
+	if (tmpEntryMinPWDB != 0xff) {	/* If associated entry is found */
+		rtlpriv->dm.entry_min_undec_sm_pwdb = tmpEntryMinPWDB;
+	} else {
+		rtlpriv->dm.entry_min_undec_sm_pwdb = 0;
+	}
+
+	FindMinimumRSSI(rtlpriv);	/* get pdmpriv->MinUndecoratedPWDBForDM */
+
+	rtl_dm_dig->rssi_val_min = rtl_dm_dig->min_undec_pwdb_for_dm;
+}
+
+
+/*
+ * ============================================================
+ * EDCA Turbo
+ * ============================================================
+ */
+
+static void rtl8821au_dm_check_edca_turbo(struct rtl_priv *rtlpriv)
+{
+	struct rtl_hal *rtlhal =&(rtlpriv->rtlhal);
+	
+	u64		cur_tx_bytes = 0;
+	u64		cur_rx_bytes = 0;
+	uint32_t	EDCA_BE_UL = 0x5ea42b;	/* Parameter suggested by Scott  */	/* edca_setting_UL[pMgntInfo->IOTPeer]; */
+	uint32_t	EDCA_BE_DL = 0x5ea42b;	/* Parameter suggested by Scott  */	/* edca_setting_DL[pMgntInfo->IOTPeer]; */
+	uint32_t	IOTPeer = 0;
+	
+	
+	
+	struct _rtw_hal *pHalData = GET_HAL_DATA(rtlpriv);
+	struct _rtw_dm *pDM_Odm = &(pHalData->odmpriv);
+	uint32_t 	trafficIndex;
+	uint32_t	edca_param;
+	u8		bbtchange = false;
+	struct xmit_priv		*pxmitpriv = &(rtlpriv->xmitpriv);
+	struct recv_priv		*precvpriv = &(rtlpriv->recvpriv);
+	struct mlme_ext_priv	*pmlmeext = &(rtlpriv->mlmeextpriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	/*
+	 * For AP/ADSL use prtl8192cd_priv
+	 * For CE/NIC use _ADAPTER
+	 */
+
+	/*
+	 *
+	 * 2011/09/29 MH In HW integration first stage, we provide 4 different handle to operate
+	 * at the same time. In the stage2/3, we need to prive universal interface and merge all
+	 * HW dynamic mechanism.
+	 */
+
+	IOTPeer = pmlmeinfo->assoc_AP_vendor;
+
+	if (IOTPeer >=  HT_IOT_PEER_MAX) {
+		goto dm_CheckEdcaTurbo_EXIT;
+	}
+
+	/* Check if the status needs to be changed. */
+	if ((bbtchange) || (!rtlpriv->dm.is_any_nonbepkts)) {
+		cur_tx_bytes = pxmitpriv->tx_bytes - pxmitpriv->last_tx_bytes;
+		cur_rx_bytes = precvpriv->rx_bytes - precvpriv->last_rx_bytes;
+
+		/* traffic, TX or RX */
+		if ((IOTPeer == HT_IOT_PEER_RALINK) || (IOTPeer == HT_IOT_PEER_ATHEROS)) {
+			if (cur_tx_bytes > (cur_rx_bytes << 2)) {
+				/* Uplink TP is present. */
+				trafficIndex = UP_LINK;
+			} else {
+				/* Balance TP is present. */
+				trafficIndex = DOWN_LINK;
+			}
+		} else {
+			if (cur_rx_bytes > (cur_tx_bytes << 2)) {
+				/* Downlink TP is present. */
+				trafficIndex = DOWN_LINK;
+			} else {
+				/* Balance TP is present. */
+				trafficIndex = UP_LINK;
+			}
+		}
+
+		if ((pDM_Odm->DM_EDCA_Table.prv_traffic_idx != trafficIndex) || (!rtlpriv->dm.current_turbo_edca)) {
+			/* merge from 92s_92c_merge temp brunch v2445    20120215 */
+			if ((IOTPeer == HT_IOT_PEER_CISCO)) {
+				EDCA_BE_DL = edca_setting_gmode[IOTPeer];
+			} else if ((IOTPeer == HT_IOT_PEER_AIRGO)) {
+					EDCA_BE_DL = 0xa630;
+			} else if (IOTPeer == HT_IOT_PEER_MARVELL) {
+				EDCA_BE_DL = edca_setting_dl[IOTPeer];
+				EDCA_BE_UL = edca_setting_ul[IOTPeer];
+			} else if (IOTPeer == HT_IOT_PEER_ATHEROS) {
+				/* Set DL EDCA for Atheros peer to 0x3ea42b. Suggested by SD3 Wilson for ASUS TP issue. */
+				EDCA_BE_DL = edca_setting_dl[IOTPeer];
+			}
+
+			if ((IS_HARDWARE_TYPE_8811AU(rtlhal))) {		/* add 8812AU/8812AE */
+				EDCA_BE_UL = 0x5ea42b;
+				EDCA_BE_DL = 0x5ea42b;
+				RT_TRACE(rtlpriv, COMP_TURBO, DBG_LOUD, "8812A: EDCA_BE_UL=0x%x EDCA_BE_DL =0x%x", EDCA_BE_UL, EDCA_BE_DL);
+			}
+
+			if (trafficIndex == DOWN_LINK)
+				edca_param = EDCA_BE_DL;
+			else
+				edca_param = EDCA_BE_UL;
+
+			rtl_write_dword(rtlpriv, REG_EDCA_BE_PARAM, edca_param);
+
+			pDM_Odm->DM_EDCA_Table.prv_traffic_idx = trafficIndex;
+		}
+
+		rtlpriv->dm.current_turbo_edca = true;
+	} else {
+		/*
+		 * Turn Off EDCA turbo here.
+		 * Restore original EDCA according to the declaration of AP.
+		 */
+		if (rtlpriv->dm.current_turbo_edca) {
+			rtl_write_dword(rtlpriv, REG_EDCA_BE_PARAM, pHalData->AcParam_BE);
+			rtlpriv->dm.current_turbo_edca = false;
+		}
+	}
+
+dm_CheckEdcaTurbo_EXIT:
+	/* Set variables for next time. */
+	rtlpriv->dm.is_any_nonbepkts = false;
+	pxmitpriv->last_tx_bytes = pxmitpriv->tx_bytes;
+	precvpriv->last_rx_bytes = precvpriv->rx_bytes;
+}
+
+static void dm_CheckPbcGPIO(struct rtl_priv *rtlpriv)
+{
+	struct rtl_hal *rtlhal = rtl_hal(rtlpriv);
+	uint8_t	tmp1byte;
+	uint8_t	bPbcPressed = false;
+
+	if(!rtlpriv->registrypriv.hw_wps_pbc)
+		return;
+
+	if (IS_HARDWARE_TYPE_8812(rtlhal)) {
+		tmp1byte = rtl_read_byte(rtlpriv, GPIO_IO_SEL);
+		tmp1byte |= (HAL_8192C_HW_GPIO_WPS_BIT);
+		rtl_write_byte(rtlpriv, GPIO_IO_SEL, tmp1byte);	/* enable GPIO[2] as output mode */
+
+		tmp1byte &= ~(HAL_8192C_HW_GPIO_WPS_BIT);
+		rtl_write_byte(rtlpriv,  GPIO_IN, tmp1byte);	/* reset the floating voltage level */
+
+		tmp1byte = rtl_read_byte(rtlpriv, GPIO_IO_SEL);
+		tmp1byte &= ~(HAL_8192C_HW_GPIO_WPS_BIT);
+		rtl_write_byte(rtlpriv, GPIO_IO_SEL, tmp1byte);	/* enable GPIO[2] as input mode */
+
+		tmp1byte =rtl_read_byte(rtlpriv, GPIO_IN);
+
+		if (tmp1byte == 0xff)
+			return ;
+
+		if (tmp1byte&HAL_8192C_HW_GPIO_WPS_BIT) {
+			bPbcPressed = true;
+		}
+	} else if (IS_HARDWARE_TYPE_8821(rtlhal)) {
+		tmp1byte = rtl_read_byte(rtlpriv, GPIO_IO_SEL_8811A);
+		tmp1byte |= (BIT(4));
+		rtl_write_byte(rtlpriv, GPIO_IO_SEL_8811A, tmp1byte);	/* enable GPIO[2] as output mode */
+
+		tmp1byte &= ~(BIT(4));
+		rtl_write_byte(rtlpriv,  GPIO_IN_8811A, tmp1byte);		/* reset the floating voltage level */
+
+		tmp1byte = rtl_read_byte(rtlpriv, GPIO_IO_SEL_8811A);
+		tmp1byte &= ~(BIT(4));
+		rtl_write_byte(rtlpriv, GPIO_IO_SEL_8811A, tmp1byte);	/* enable GPIO[2] as input mode */
+
+		tmp1byte =rtl_read_byte(rtlpriv, GPIO_IN_8811A);
+
+		if (tmp1byte == 0xff)
+			return ;
+
+		if (tmp1byte&BIT(4)) {
+			bPbcPressed = true;
+		}
+	}
+	if( true == bPbcPressed) {
+		/*
+		 * Here we only set bPbcPressed to true
+		 * After trigger PBC, the variable will be set to false
+		 */
+		printk("rtl8821au:CheckPbcGPIO - PBC is pressed\n");
+	}
+}
+
+
+static void rtl8821au_dm_common_info_self_update(struct rtl_priv *rtlpriv)
+{
+	struct rtl_dm *rtldm = rtl_dm(rtlpriv);
+	u8	EntryCnt = 0;
+	u8	i;
+	struct sta_info *pEntry;
+
+	for (i = 0; i < ODM_ASSOCIATE_ENTRY_NUM; i++) {
+		pEntry = rtldm->pODM_StaInfo[i];
+		if (IS_STA_VALID(pEntry))
+			EntryCnt++;
+	}
+
+	if (EntryCnt == 1)
+		rtldm->bOneEntryOnly = true;
+	else
+		rtldm->bOneEntryOnly = false;
+}
+
+static void rtl8821au_dm_cck_packet_detection_thresh(struct rtl_priv *rtlpriv)
+{
+	struct dig_t *dm_digtable = &(rtlpriv->dm_digtable);
+	struct rtl_hal *rtlhal = rtl_hal(rtlpriv);
+
+	u8	CurCCK_CCAThres;
+	struct false_alarm_statistics *FalseAlmCnt = &(rtlpriv->falsealm_cnt);
+
+	if (rtlhal->external_lna_2g)
+		return;
+
+	if (rtlpriv->mac80211.link_state >= MAC80211_LINKED) {
+		if (dm_digtable->rssi_val_min > 25)
+			CurCCK_CCAThres = 0xcd;
+		else if ((dm_digtable->rssi_val_min <= 25) && (dm_digtable->rssi_val_min > 10))
+			CurCCK_CCAThres = 0x83;
+		else {
+			if (FalseAlmCnt->cnt_cck_fail > 1000)
+				CurCCK_CCAThres = 0x83;
+			else
+				CurCCK_CCAThres = 0x40;
+		}
+	} else {
+		if (FalseAlmCnt->cnt_cck_fail > 1000)
+			CurCCK_CCAThres = 0x83;
+		else
+			CurCCK_CCAThres = 0x40;
+	}
+
+		ODM_Write_CCK_CCA_Thres(rtlpriv, CurCCK_CCAThres);
+}
+
+void rtl8821au_dm_watchdog(struct rtl_priv *rtlpriv)
+{
+	struct dig_t *dm_digtable = &(rtlpriv->dm_digtable);
+	bool fw_current_inpsmode = false;
+	bool fw_ps_awake = true;
+	uint8_t hw_init_completed = false;
+
+	struct _rtw_hal *pHalData = GET_HAL_DATA(rtlpriv);
+	struct _rtw_dm *pDM_Odm = &(pHalData->odmpriv);
+
+	if (hw_init_completed == false)
+		goto skip_dm;
+
+	fw_current_inpsmode = rtlpriv->pwrctrlpriv.fw_current_inpsmode;
+	rtlpriv->cfg->ops->get_hw_reg(rtlpriv, HW_VAR_FWLPS_RF_ON, (uint8_t *)(&fw_ps_awake));
+
+	/* ODM */
+	if (rtlpriv->hw_init_completed == true) {
+		if(rtw_linked_check(rtlpriv))
+			rtlpriv->mac80211.link_state = MAC80211_LINKED;
+		else
+			rtlpriv->mac80211.link_state = MAC80211_NOLINK;
+
+		/*
+		 * 2011/09/20 MH This is the entry pointer for all team to execute HW out source DM.
+		 * You can not add any dummy function here, be care, you can only use DM structure
+		 * to perform any new ODM_DM.
+		 */
+
+		rtl8821au_dm_common_info_self_update(rtlpriv);
+		rtl8821au_dm_false_alarm_counter_statistics(rtlpriv);
+		RT_TRACE(rtlpriv, COMP_DIG, DBG_LOUD, "odm_DIG(): RSSI=0x%x\n", dm_digtable->rssi_val_min);
+
+		rtl8821au_dm_check_rssi_monitor(rtlpriv);
+
+		rtl8821au_dm_dig(rtlpriv);
+
+		odm_Adaptivity(rtlpriv, dm_digtable->cur_igvalue);
+
+		rtl8821au_dm_cck_packet_detection_thresh(rtlpriv);
+
+		if (rtlpriv->pwrctrlpriv.bpower_saving == true)
+			return;
+
+		odm_RefreshRateAdaptiveMask(rtlpriv);
+		rtl8821au_dm_check_edca_turbo(rtlpriv);
+
+		rtl8821au_check_tx_power_tracking_thermalmeter(rtlpriv);
+
+		rtlpriv->dm.dbginfo.num_qry_beacon_pkt = 0;
+	}
+
+skip_dm:
+
+	/*
+	 * Check GPIO to determine current RF on/off and Pbc status.
+	 * Check Hardware Radio ON/OFF or not
+	 */
+
+	/* temp removed */
+	/* ULLI : for WPS Button */
+	dm_CheckPbcGPIO(rtlpriv);
+
+	return;
+}
+
+static void rtl8821au_dm_dig(struct rtl_priv *rtlpriv)
+{
+	struct rtl_hal *rtlhal = rtl_hal(rtlpriv);
+	struct dig_t *dm_digtable = &(rtlpriv->dm_digtable);
+	struct rtl_mac *mac = rtl_mac(rtlpriv);
+	struct false_alarm_statistics *FalseAlmCnt = &(rtlpriv->falsealm_cnt);
+	u8 dig_dynamic_min, dig_maxofmin;
+	bool						FirstConnect, FirstDisConnect;
+	u8						dm_dig_max, dm_dig_min, offset;
+	u8 current_igi = dm_digtable->cur_igvalue;
+
+	struct _rtw_hal *pHalData = GET_HAL_DATA(rtlpriv);
+	struct _rtw_dm *pDM_Odm = &(pHalData->odmpriv);
+
+	RT_TRACE(rtlpriv, COMP_DIG, DBG_LOUD, "odm_DIG()==>\n");
+
+	if (mac->act_scanning) {
+		RT_TRACE(rtlpriv, COMP_DIG, DBG_LOUD, "odm_DIG() Return: In Scan Progress \n");
+		return;
+	}
+
+	/* add by Neil Chen to avoid PSD is processing */
+	dig_dynamic_min = dm_digtable->dig_min_0;
+	FirstConnect = (rtlpriv->mac80211.link_state >= MAC80211_LINKED)  &&
+		       (dm_digtable->media_connect_0 == false);
+	FirstDisConnect = (rtlpriv->mac80211.link_state < MAC80211_LINKED) &&
+			   (dm_digtable->media_connect_0 == true);
+
+
+	/* 1 Boundary Decision */
+	dm_dig_max = DM_DIG_MAX_NIC;
+
+	if (IS_HARDWARE_TYPE_8821U(rtlhal))
+		dm_dig_min = DM_DIG_MIN_NIC;
+	else
+		dm_dig_min = 0x1C;
+
+	dig_maxofmin = DM_DIG_MAX_AP;
+
+	if (rtlpriv->mac80211.link_state >= MAC80211_LINKED) {
+		/* 2 Modify DIG upper bound */
+		/* 2013.03.19 Luke: Modified upper bound for Netgear rental house test */
+		if (IS_HARDWARE_TYPE_8821U(rtlhal))
+			offset = 20;
+		else
+			offset = 10;
+
+		if ((dm_digtable->rssi_val_min + offset) > dm_dig_max)
+			dm_digtable->rx_gain_max = dm_dig_max;
+		else if ((dm_digtable->rssi_val_min + offset) < dm_dig_min)
+			dm_digtable->rx_gain_max = dm_dig_min;
+		else
+			dm_digtable->rx_gain_max = dm_digtable->rssi_val_min + offset;
+
+
+		/* 2 Modify DIG lower bound */
+		/*
+		if ((pFalseAlmCnt->Cnt_all > 500)&&(DIG_Dynamic_MIN < 0x25))
+			DIG_Dynamic_MIN++;
+		else if (((pFalseAlmCnt->Cnt_all < 500)||(pDM_Odm->rssi_val_min < 8))&&(DIG_Dynamic_MIN > dm_dig_min))
+			DIG_Dynamic_MIN--;
+		*/
+		if (pDM_Odm->bOneEntryOnly) {
+			if (dm_digtable->rssi_val_min < dm_dig_min)
+				dig_dynamic_min = dm_dig_min;
+			else if (dm_digtable->rssi_val_min > dig_maxofmin)
+				dig_dynamic_min = dig_maxofmin;
+			else
+				dig_dynamic_min = dm_digtable->rssi_val_min;
+			RT_TRACE(rtlpriv, COMP_DIG, DBG_LOUD, "odm_DIG() : bOneEntryOnly=true,  DIG_Dynamic_MIN=0x%x\n", dig_dynamic_min);
+			RT_TRACE(rtlpriv, COMP_DIG, DBG_LOUD, "odm_DIG() : pDM_Odm->rssi_val_min=%d\n", dm_digtable->rssi_val_min);
+		} else {
+			/* 1 Lower Bound for 88E AntDiv */
+			dig_dynamic_min = dm_dig_min;
+		}
+	} else {
+		dm_digtable->rx_gain_max = dm_dig_max;
+		dig_dynamic_min = dm_dig_min;
+		RT_TRACE(rtlpriv, COMP_DIG, DBG_LOUD, "odm_DIG() : No Link\n");
+	}
+
+	/* 1 Modify DIG lower bound, deal with abnorally large false alarm */
+	if (FalseAlmCnt->cnt_all > 10000) {
+		RT_TRACE(rtlpriv, COMP_DIG, DBG_LOUD, "dm_DIG(): Abnornally false alarm case. \n");
+
+		if (dm_digtable->large_fa_hit != 3)
+			dm_digtable->large_fa_hit++;
+		if (dm_digtable->forbidden_igi < current_igi) {			/* if (dm_digtable->ForbiddenIGI < dm_digtable->CurIGValue) */
+			dm_digtable->forbidden_igi = (u8)current_igi;	/* dm_digtable->ForbiddenIGI = dm_digtable->CurIGValue; */
+			dm_digtable->large_fa_hit = 1;
+		}
+
+		if (dm_digtable->large_fa_hit >= 3) {
+			if ((dm_digtable->forbidden_igi+1) > dm_digtable->rx_gain_max)
+				dm_digtable->rx_gain_min = dm_digtable->rx_gain_max;
+			else
+				dm_digtable->rx_gain_min = (dm_digtable->forbidden_igi + 1);
+			dm_digtable->recover_cnt = 3600; 	/* 3600=2hr */
+		}
+
+	} else {
+		/* Recovery mechanism for IGI lower bound */
+		if (dm_digtable->recover_cnt != 0)
+			dm_digtable->recover_cnt--;
+		else {
+			if (dm_digtable->large_fa_hit < 3) {
+				if ((dm_digtable->forbidden_igi-1) < dig_dynamic_min) {		/* DM_DIG_MIN)  */
+					dm_digtable->forbidden_igi = dig_dynamic_min;		/* DM_DIG_MIN; */
+					dm_digtable->rx_gain_min = dig_dynamic_min;	/* DM_DIG_MIN; */
+					RT_TRACE(rtlpriv, COMP_DIG, DBG_LOUD, "odm_DIG(): Normal Case: At Lower Bound\n");
+				} else {
+					dm_digtable->forbidden_igi--;
+					dm_digtable->rx_gain_min = (dm_digtable->forbidden_igi+ 1);
+					RT_TRACE(rtlpriv, COMP_DIG, DBG_LOUD, "odm_DIG(): Normal Case: Approach Lower Bound\n");
+				}
+			} else {
+				dm_digtable->large_fa_hit = 0;
+			}
+		}
+	}
+	RT_TRACE(rtlpriv, COMP_DIG, DBG_LOUD, "odm_DIG(): dm_digtable->LargeFAHit=%d\n", dm_digtable->large_fa_hit);
+
+	if (rtlpriv->dm.dbginfo.num_qry_beacon_pkt < 10)
+		dm_digtable->rx_gain_min = dm_dig_min;
+
+	if (dm_digtable->rx_gain_min > dm_digtable->rx_gain_max)
+		dm_digtable->rx_gain_min = dm_digtable->rx_gain_max;
+
+	/* 1 Adjust initial gain by false alarm */
+	if (rtlpriv->mac80211.link_state >= MAC80211_LINKED) {
+		RT_TRACE(rtlpriv, COMP_DIG, DBG_LOUD, "odm_DIG(): DIG AfterLink\n");
+		if (FirstConnect) {
+			if (dm_digtable->rssi_val_min <= dig_maxofmin)
+			    current_igi = dm_digtable->rssi_val_min;
+			else
+			    current_igi = dig_maxofmin;
+			RT_TRACE(rtlpriv,	COMP_DIG, DBG_LOUD, "DIG: First Connect\n");
+		} else 	{
+			/* FA for Combo IC--NeilChen--2012--09--28 */
+			if (FalseAlmCnt->cnt_all > DM_DIG_FA_TH2)
+				current_igi = current_igi + 4;	/* dm_digtable->CurIGValue = dm_digtable->PreIGValue+2; */
+			else if (FalseAlmCnt->cnt_all > DM_DIG_FA_TH1)
+				current_igi = current_igi + 2;	/* dm_digtable->CurIGValue = dm_digtable->PreIGValue+1; */
+			else if (FalseAlmCnt->cnt_all < DM_DIG_FA_TH0)
+				current_igi = current_igi - 2;	/* dm_digtable->CurIGValue =dm_digtable->PreIGValue-1; */
+
+			if ((rtlpriv->dm.dbginfo.num_qry_beacon_pkt < 10)
+			 && (FalseAlmCnt->cnt_all < DM_DIG_FA_TH1))
+				current_igi = dm_digtable->rx_gain_min;
+		}
+	} else {
+		/* current_igi = dm_digtable->rx_gain_range_min; */	/* dm_digtable->CurIGValue = dm_digtable->rx_gain_range_min */
+		RT_TRACE(rtlpriv, COMP_DIG, DBG_LOUD, "odm_DIG(): DIG BeforeLink\n");
+		if (FirstDisConnect) {
+			current_igi = dm_digtable->rx_gain_min;
+			RT_TRACE(rtlpriv, COMP_DIG, DBG_LOUD, "odm_DIG(): First DisConnect \n");
+		} else {
+			/* 2012.03.30 LukeLee: enable DIG before link but with very high thresholds */
+			if (FalseAlmCnt->cnt_all > 10000)
+				current_igi = current_igi + 4;
+			else if (FalseAlmCnt->cnt_all > 8000)
+				current_igi = current_igi + 2;
+			else if (FalseAlmCnt->cnt_all < 500)
+				current_igi = current_igi - 2;
+			RT_TRACE(rtlpriv, COMP_DIG, DBG_LOUD, "odm_DIG(): England DIG \n");
+		}
+	}
+	RT_TRACE(rtlpriv, COMP_DIG, DBG_LOUD, "odm_DIG(): DIG End Adjust IGI\n");
+	/* 1 Check initial gain by upper/lower bound */
+
+	if (current_igi > dm_digtable->rx_gain_max)
+		current_igi = dm_digtable->rx_gain_max;
+	if (current_igi < dm_digtable->rx_gain_min)
+		current_igi = dm_digtable->rx_gain_min;
+
+	if (current_igi > (pDM_Odm->IGI_target + 4))
+		current_igi = (u8)pDM_Odm->IGI_target + 4;
+
+	RT_TRACE(rtlpriv, COMP_DIG, DBG_LOUD, "odm_DIG(): rx_gain_range_max=0x%x, rx_gain_range_min=0x%x\n",
+		dm_digtable->rx_gain_max, dm_digtable->rx_gain_min);
+	RT_TRACE(rtlpriv, COMP_DIG, DBG_LOUD, "odm_DIG(): TotalFA=%d\n", FalseAlmCnt->cnt_all);
+	RT_TRACE(rtlpriv, COMP_DIG, DBG_LOUD, "odm_DIG(): CurIGValue=0x%x\n", current_igi);
+
+	/* 2 High power RSSI threshold */
+
+	rtl8821au_dm_write_dig(rtlpriv, current_igi);	/* ODM_Write_DIG(pDM_Odm, dm_digtable->CurIGValue); */
+	dm_digtable->media_connect_0 =
+		(rtlpriv->mac80211.link_state >= MAC80211_LINKED) ? 1 : 0;
+		dm_digtable->dig_min_0 = dig_dynamic_min;
+}
+
+void rtl8821au_dm_clean_txpower_tracking_state(struct rtl_priv *rtlpriv)
+{
+	struct rtl_efuse *efuse = rtl_efuse(rtlpriv);
+	struct rtl_dm	*rtldm = rtl_dm(rtlpriv);
+	u8 p = 0;
+
+	rtldm->swing_idx_cck_base = rtldm->default_cck_index;
+	rtldm->swing_idx_cck = rtldm->default_cck_index;
+	rtldm->cck_index;	/* ULLI BUG ?? */
+
+	for (p = RF90_PATH_A; p < MAX_RF_PATH; ++p) {
+		rtldm->swing_idx_ofdm_base[p] = rtldm->default_ofdm_index;
+		rtldm->swing_idx_ofdm[p] = rtldm->default_ofdm_index;
+		rtldm->ofdm_index[p] = rtldm->default_ofdm_index;
+
+		rtldm->power_index_offset[p] = 0;
+		rtldm->delta_power_index[p] = 0;
+		rtldm->delta_power_index_last[p] = 0;
+		rtldm->power_index_offset[p] = 0;	/* ULLI Huh */
+
+		rtldm->absolute_ofdm_swing_idx[p] = 0;    /* Initial Mix mode power tracking */
+		rtldm->remnant_ofdm_swing_idx[p] = 0;
+	}
+
+	rtldm->modify_txagc_flag_path_a = false;       /* Initial at Modify Tx Scaling Mode */
+	rtldm->modify_txagc_flag_path_b = false;       /* Initial at Modify Tx Scaling Mode */
+	rtldm->remnant_cck_idx = 0;
+	rtldm->thermalvalue = efuse->eeprom_thermalmeter;
+	rtldm->thermalvalue_iqk = efuse->eeprom_thermalmeter;
+	rtldm->thermalvalue_lck = efuse->eeprom_thermalmeter;
+}
+
+static void rtl8821_dm_init_gpio_setting(struct rtl_priv *rtlpriv)
+{
+	uint8_t	tmp1byte;
+
+	tmp1byte = rtl_read_byte(rtlpriv, REG_GPIO_MUXCFG);
+	tmp1byte &= (GPIOSEL_GPIO | ~GPIOSEL_ENBT);
+
+	rtl_write_byte(rtlpriv, REG_GPIO_MUXCFG, tmp1byte);
+
+}
+
+static void Update_ODM_ComInfo_8812(struct rtl_priv *rtlpriv)
+{
+	struct rtl_dm *rtldm = rtl_dm(rtlpriv);
+
+	struct mlme_priv	*pmlmepriv = &rtlpriv->mlmepriv;
+	struct pwrctrl_priv *pwrctrlpriv = &rtlpriv->pwrctrlpriv;
+	struct _rtw_hal *pHalData = GET_HAL_DATA(rtlpriv);
+	struct _rtw_dm *	pDM_Odm = &(pHalData->odmpriv);
+
+	int i;
+	
+	ODM_CmnInfoHook(pDM_Odm,ODM_CMNINFO_SCAN,&(pmlmepriv->bScanInProcess));
+
+	for (i = 0; i < NUM_STA; i++) {
+		rtldm->pODM_StaInfo[i] = NULL;
+		/* pDM_Odm->pODM_StaInfo[i] = NULL; */
+	}
+}
+
+
+void rtl8812_dm_init(struct rtl_priv *rtlpriv)
+{
+	rtl8821_dm_init_gpio_setting(rtlpriv);
+
+	rtlpriv->dm.dm_type = DM_Type_ByDriver;
+	rtlpriv->dm.dm_flag = 0;
+
+	Update_ODM_ComInfo_8812(rtlpriv);
+	ODM_DMInit(rtlpriv);
+
+	rtlpriv->fix_rate = 0xFF;
+}
+
+void rtl8821au_dm_write_dig(struct rtl_priv *rtlpriv, u8 current_igi)
+{
+	struct dig_t *dm_digtable = &(rtlpriv->dm_digtable);
+
+	if (dm_digtable->stop_dig)
+		return;
+
+	if (dm_digtable->cur_igvalue != current_igi) {	/*if (pDM_DigTable->PreIGValue != current_igi) */
+		rtl_set_bbreg(rtlpriv, ODM_REG_IGI_A_11AC, ODM_BIT_IGI_11AC, current_igi);
+		if (rtlpriv->phy.rf_type != ODM_1T1R)
+			rtl_set_bbreg(rtlpriv, ODM_REG_IGI_B_11AC, ODM_BIT_IGI_11AC, current_igi);
+
+		RT_TRACE(rtlpriv, COMP_DIG, DBG_LOUD, "current_igi(0x%02x). \n", current_igi);
+		/* pDM_DigTable->PreIGValue = pDM_DigTable->CurIGValue; */
+		dm_digtable->cur_igvalue = current_igi;
+	}
+}
+
+/* ULLI : From RTL8821AE */
+
+void rtl8821au_dm_update_init_rate(struct rtl_priv *rtlpriv, u8 rate)
+{
+	struct rtl_dm *rtldm = rtl_dm(rtlpriv);
+	u8 p = 0;
+
+	RT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD,
+		 "Get C2H Command! Rate=0x%x\n", rate);
+
+	rtldm->tx_rate = rate;
+
+#if 0	/* ULLI : Must check */
+	if (rtlhal->hw_type == HARDWARE_TYPE_RTL8821AE) {
+		rtl8821ae_dm_txpwr_track_set_pwr(hw, MIX_MODE, RF90_PATH_A, 0);
+	} else {
+		for (p = RF90_PATH_A; p < MAX_PATH_NUM_8812A; p++)
+			rtl8812ae_dm_txpwr_track_set_pwr(hw, MIX_MODE, p, 0);
+	}
+#endif
+}
diff -Naur linux-4.9/drivers/staging/rtl8821au/rtl8821au/dm.h linux-4.9.8821au/drivers/staging/rtl8821au/rtl8821au/dm.h
--- linux-4.9/drivers/staging/rtl8821au/rtl8821au/dm.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/rtl8821au/dm.h	2016-12-11 19:48:25.180311687 -0600
@@ -0,0 +1,162 @@
+#ifndef	__RTL8821AU_DM_H__
+#define __RTL8821AU_DM_H__
+
+#include <odm_types.h>
+#include <odm.h>
+
+
+//3===========================================================
+//3 Dynamic Tx Power
+//3===========================================================
+//Dynamic Tx Power Control Threshold
+#define		TX_POWER_NEAR_FIELD_THRESH_LVL2	74
+#define		TX_POWER_NEAR_FIELD_THRESH_LVL1	67
+#define		TX_POWER_NEAR_FIELD_THRESH_AP		0x3F
+
+#define		TxHighPwrLevel_Normal		0
+#define		TxHighPwrLevel_Level1		1
+#define		TxHighPwrLevel_Level2		2
+#define		TxHighPwrLevel_BT1			3
+#define		TxHighPwrLevel_BT2			4
+#define		TxHighPwrLevel_15			5
+#define		TxHighPwrLevel_35			6
+#define		TxHighPwrLevel_50			7
+#define		TxHighPwrLevel_70			8
+#define		TxHighPwrLevel_100			9
+
+
+
+#define CCK_TABLE_SIZE				33
+
+void rtl8812au_get_delta_swing_table(struct rtl_priv *rtlpriv,
+					    u8 **up_a, u8 **down_a,
+					    u8 **up_b, u8 **down_b);
+void rtl8821au_get_delta_swing_table(struct rtl_priv *rtlpriv,
+					    u8 **up_a, u8 **down_a,
+					    u8 **up_b, u8 **down_b);
+void rtl8821au_dm_watchdog(struct rtl_priv *rtlpriv);
+void rtl8821au_dm_clean_txpower_tracking_state(struct rtl_priv *rtlpriv);
+void rtl8812_dm_init(struct rtl_priv *rtlpriv);
+
+/* Old prototypes */
+
+void odm_Adaptivity(struct rtl_priv *rtlpriv, u8 IGI);
+void odm_RefreshRateAdaptiveMask(struct rtl_priv *rtlpriv);
+
+/*  ULLI : from odm_RegDefine11AC.h */
+
+//2 BB REG LIST
+//PAGE 8
+#define	ODM_REG_CCK_RPT_FORMAT_11AC	0x804
+#define	ODM_REG_BB_RX_PATH_11AC			0x808
+//PAGE 9
+#define	ODM_REG_OFDM_FA_RST_11AC		0x9A4
+//PAGE A
+#define	ODM_REG_CCK_CCA_11AC			0xA0A
+#define	ODM_REG_CCK_FA_RST_11AC			0xA2C
+#define	ODM_REG_CCK_FA_11AC				0xA5C
+//PAGE C
+#define	ODM_REG_IGI_A_11AC				0xC50
+//PAGE E
+#define	ODM_REG_IGI_B_11AC				0xE50
+//PAGE F
+#define	ODM_REG_OFDM_FA_11AC			0xF48
+
+
+//2 MAC REG LIST
+
+
+
+
+//DIG Related
+#define	ODM_BIT_IGI_11AC					0xFFFFFFFF
+#define	ODM_BIT_CCK_RPT_FORMAT_11AC		BIT(16)
+#define	ODM_BIT_BB_RX_PATH_11AC			0xF
+
+/* ULLI : From odm_reg.h */
+//MAC REG
+#define	ODM_BB_RESET					0x002
+#define	ODM_DUMMY					0x4fe
+#define	RF_T_METER_OLD				0x24
+#define	RF_T_METER_NEW				0x42
+
+#define	ODM_EDCA_VO_PARAM			0x500
+#define	ODM_EDCA_VI_PARAM			0x504
+#define	ODM_EDCA_BE_PARAM			0x508
+#define	ODM_EDCA_BK_PARAM			0x50C
+#define	ODM_TXPAUSE					0x522
+
+//BB REG
+#define	ODM_FPGA_PHY0_PAGE8			0x800
+#define	ODM_PSD_SETTING				0x808
+#define	ODM_AFE_SETTING				0x818
+#define	ODM_TXAGC_B_6_18				0x830
+#define	ODM_TXAGC_B_24_54			0x834
+#define	ODM_TXAGC_B_MCS32_5			0x838
+#define	ODM_TXAGC_B_MCS0_MCS3		0x83c
+#define	ODM_TXAGC_B_MCS4_MCS7		0x848
+#define	ODM_TXAGC_B_MCS8_MCS11		0x84c
+#define	ODM_ANALOG_REGISTER			0x85c
+#define	ODM_RF_INTERFACE_OUTPUT		0x860
+#define	ODM_TXAGC_B_MCS12_MCS15	0x868
+#define	ODM_TXAGC_B_11_A_2_11		0x86c
+#define	ODM_AD_DA_LSB_MASK			0x874
+#define	ODM_ENABLE_3_WIRE			0x88c
+#define	ODM_PSD_REPORT				0x8b4
+#define	ODM_R_ANT_SELECT				0x90c
+#define	ODM_CCK_ANT_SELECT			0xa07
+#define	ODM_CCK_PD_THRESH			0xa0a
+#define	ODM_CCK_RF_REG1				0xa11
+#define	ODM_CCK_MATCH_FILTER			0xa20
+#define	ODM_CCK_RAKE_MAC				0xa2e
+#define	ODM_CCK_CNT_RESET			0xa2d
+#define	ODM_CCK_TX_DIVERSITY			0xa2f
+#define	ODM_CCK_FA_CNT_MSB			0xa5b
+#define	ODM_CCK_FA_CNT_LSB			0xa5c
+#define	ODM_CCK_NEW_FUNCTION		0xa75
+#define	ODM_OFDM_PHY0_PAGE_C		0xc00
+#define	ODM_OFDM_RX_ANT				0xc04
+#define	ODM_R_A_RXIQI					0xc14
+#define	ODM_R_A_AGC_CORE1			0xc50
+#define	ODM_R_A_AGC_CORE2			0xc54
+#define	ODM_R_B_AGC_CORE1			0xc58
+#define	ODM_R_AGC_PAR					0xc70
+#define	ODM_R_HTSTF_AGC_PAR			0xc7c
+#define	ODM_TX_PWR_TRAINING_A		0xc90
+#define	ODM_TX_PWR_TRAINING_B		0xc98
+#define	ODM_OFDM_FA_CNT1				0xcf0
+#define	ODM_OFDM_PHY0_PAGE_D		0xd00
+#define	ODM_OFDM_FA_CNT2				0xda0
+#define	ODM_OFDM_FA_CNT3				0xda4
+#define	ODM_OFDM_FA_CNT4				0xda8
+#define	ODM_TXAGC_A_6_18				0xe00
+#define	ODM_TXAGC_A_24_54			0xe04
+#define	ODM_TXAGC_A_1_MCS32			0xe08
+#define	ODM_TXAGC_A_MCS0_MCS3		0xe10
+#define	ODM_TXAGC_A_MCS4_MCS7		0xe14
+#define	ODM_TXAGC_A_MCS8_MCS11		0xe18
+#define	ODM_TXAGC_A_MCS12_MCS15		0xe1c
+
+//RF REG
+#define	ODM_GAIN_SETTING				0x00
+#define	ODM_CHANNEL					0x18
+
+//Ant Detect Reg
+#define	ODM_DPDT						0x300
+
+//PSD Init
+#define	ODM_PSDREG					0x808
+
+//92D Path Div
+#define	PATHDIV_REG					0xB30
+#define	PATHDIV_TRI					0xBA0
+
+enum pwr_track_control_method {
+	BBSWING,
+	TXAGC,
+	MIX_MODE
+};
+
+void rtl8821au_dm_write_dig(struct rtl_priv *rtlpriv, u8 current_igi);
+
+#endif
diff -Naur linux-4.9/drivers/staging/rtl8821au/rtl8821au/fw.c linux-4.9.8821au/drivers/staging/rtl8821au/rtl8821au/fw.c
--- linux-4.9/drivers/staging/rtl8821au/rtl8821au/fw.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/rtl8821au/fw.c	2016-12-11 19:48:25.180311687 -0600
@@ -0,0 +1,1271 @@
+#ifdef CONFIG_RTLWIFI
+
+#error "NO RTLWIFI DEFINED"
+
+#else
+
+#include <drv_types.h>
+#include "fw.h"
+#include <linux/firmware.h>
+
+#endif
+
+#define CONFIG_H2C_EF
+
+#define RTL8812_MAX_H2C_BOX_NUMS	4
+#define RTL8812_MAX_CMD_LEN	7
+#define RTL8812_MESSAGE_BOX_SIZE		4
+#define RTL8812_EX_MESSAGE_BOX_SIZE	4
+
+void rtl8821au_firmware_selfreset(struct rtl_priv *rtlpriv)
+{
+	struct rtl_hal *rtlhal = rtl_hal(rtlpriv);
+	uint8_t u1bTmp, u1bTmp2;
+
+	/* Reset MCU IO Wrapper- sugggest by SD1-Gimmy */
+	if (IS_HARDWARE_TYPE_8812(rtlhal)) {
+		u1bTmp2 = rtl_read_byte(rtlpriv, REG_RSV_CTRL+1);
+		rtl_write_byte(rtlpriv, REG_RSV_CTRL + 1, u1bTmp2&(~BIT(3)));
+	} else if (IS_HARDWARE_TYPE_8821(rtlhal)) {
+		u1bTmp2 = rtl_read_byte(rtlpriv, REG_RSV_CTRL+1);
+		rtl_write_byte(rtlpriv, REG_RSV_CTRL + 1, u1bTmp2&(~BIT(0)));
+	}
+
+	u1bTmp = rtl_read_byte(rtlpriv, REG_SYS_FUNC_EN+1);
+	rtl_write_byte(rtlpriv, REG_SYS_FUNC_EN+1, u1bTmp&(~BIT(2)));
+
+	/* Enable MCU IO Wrapper */
+	if (IS_HARDWARE_TYPE_8812(rtlhal)) {
+		u1bTmp2 = rtl_read_byte(rtlpriv, REG_RSV_CTRL+1);
+		rtl_write_byte(rtlpriv, REG_RSV_CTRL + 1, u1bTmp2 | (BIT(3)));
+	} else if (IS_HARDWARE_TYPE_8821(rtlhal)) {
+		u1bTmp2 = rtl_read_byte(rtlpriv, REG_RSV_CTRL+1);
+		rtl_write_byte(rtlpriv, REG_RSV_CTRL + 1, u1bTmp2 | (BIT(0)));
+	}
+
+	rtl_write_byte(rtlpriv, REG_SYS_FUNC_EN+1, u1bTmp|(BIT(2)));
+
+	RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD, " _8051Reset8812(): 8051 reset success .\n");
+}
+
+static bool Get_RA_ShortGI(struct rtl_priv *rtlpriv, struct sta_info	*psta,
+	uint8_t	shortGIrate)
+{
+	bool		bShortGI;
+	struct mlme_ext_priv	*pmlmeext = &rtlpriv->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	bShortGI = shortGIrate;
+
+	if (bShortGI && IsSupportedVHT(psta->wireless_mode)
+	 && (pmlmeinfo->assoc_AP_vendor == HT_IOT_PEER_REALTEK_JAGUAR_CCUTAP)
+	 && TEST_FLAG(psta->vhtpriv.ldpc_cap, LDPC_VHT_ENABLE_TX)) {
+		if (psta->vhtpriv.vht_highest_rate >= MGN_VHT2SS_MCS8)
+			bShortGI = false;
+	}
+
+	return bShortGI;
+}
+
+static uint8_t _is_fw_read_cmd_down(struct rtl_priv *rtlpriv, uint8_t msgbox_num)
+{
+	uint8_t	read_down = false;
+	int 	retry_cnts = 100;
+
+	uint8_t valid;
+
+	/* DBG_8192C(" _is_fw_read_cmd_down ,reg_1cc(%x),msg_box(%d)...\n",rtl_read_byte(rtlpriv,REG_HMETFR),msgbox_num); */
+
+	do {
+		valid = rtl_read_byte(rtlpriv, REG_HMETFR) & BIT(msgbox_num);
+		if (0 == valid) {
+			read_down = true;
+		}
+	} while ((!read_down) && (retry_cnts--));
+
+	return read_down;
+}
+
+
+
+
+/*****************************************
+* H2C Msg format :
+* 0x1DF - 0x1D0
+*| 31 - 8	| 7-5 	 4 - 0	|
+*| h2c_msg 	|Class_ID CMD_ID	|
+*
+* Extend 0x1FF - 0x1F0
+*|31 - 0	  |
+*|ext_msg|
+******************************************/
+static void _rtl8821au_fill_h2c_cmd(struct rtl_priv *rtlpriv, 
+					u8 element_id, u32 cmd_len, 
+					u8 *cmdbuffer)
+{
+	struct rtl_hal *rtlhal = rtl_hal(rtlpriv);
+	uint8_t bcmd_down = false;
+	int32_t retry_cnts = 100;
+	uint8_t h2c_box_num;
+	uint32_t msgbox_addr;
+	uint32_t msgbox_ex_addr;
+	uint8_t cmd_idx, ext_cmd_len;
+	uint32_t h2c_cmd = 0;
+	uint32_t h2c_cmd_ex = 0;
+	int _unused;
+
+	_unused = mutex_lock_interruptible(&(rtl_usbdev(rtlpriv)->h2c_fwcmd_mutex));
+
+	if (!cmdbuffer) {
+		goto exit;
+	}
+	if (cmd_len > RTL8812_MAX_CMD_LEN) {
+		goto exit;
+	}
+
+	if (rtlpriv->bSurpriseRemoved == true)
+		goto exit;
+
+	/* pay attention to if  race condition happened in  H2C cmd setting. */
+	do {
+		h2c_box_num = rtlhal->last_hmeboxnum;
+
+		if (!_is_fw_read_cmd_down(rtlpriv, h2c_box_num)) {
+			RT_TRACE(rtlpriv, COMP_FW, DBG_LOUD, " fw read cmd failed...\n");
+			goto exit;
+		}
+
+		*(uint8_t *)(&h2c_cmd) = element_id;
+
+		if (cmd_len <= 3) {
+			memcpy((uint8_t *)(&h2c_cmd)+1, cmdbuffer, cmd_len);
+		} else {
+			memcpy((uint8_t *)(&h2c_cmd)+1, cmdbuffer, 3);
+			ext_cmd_len = cmd_len-3;
+			memcpy((uint8_t *)(&h2c_cmd_ex), cmdbuffer+3, ext_cmd_len);
+
+			/* Write Ext command */
+			msgbox_ex_addr = REG_HMEBOX_EXT0_8812 + (h2c_box_num * RTL8812_EX_MESSAGE_BOX_SIZE);
+#ifdef CONFIG_H2C_EF
+			for (cmd_idx = 0; cmd_idx < ext_cmd_len; cmd_idx++) {
+				rtl_write_byte(rtlpriv, msgbox_ex_addr+cmd_idx, *((uint8_t *)(&h2c_cmd_ex)+cmd_idx));
+			}
+#else
+			h2c_cmd_ex = le32_to_cpu(h2c_cmd_ex);
+			rtl_write_dword(rtlpriv, msgbox_ex_addr, h2c_cmd_ex);
+#endif
+		}
+		/* Write command */
+		msgbox_addr = REG_HMEBOX_0 + (h2c_box_num * RTL8812_MESSAGE_BOX_SIZE);
+#ifdef CONFIG_H2C_EF
+		for (cmd_idx = 0; cmd_idx < RTL8812_MESSAGE_BOX_SIZE; cmd_idx++) {
+			rtl_write_byte(rtlpriv, msgbox_addr+cmd_idx, *((uint8_t *)(&h2c_cmd)+cmd_idx));
+		}
+#else
+		h2c_cmd = le32_to_cpu(h2c_cmd);
+		rtl_write_dword(rtlpriv, msgbox_addr, h2c_cmd);
+#endif
+
+		bcmd_down = true;
+
+	/*
+	 * 	DBG_8192C("MSG_BOX:%d,CmdLen(%d), reg:0x%x =>h2c_cmd:0x%x, reg:0x%x =>h2c_cmd_ex:0x%x ..\n"
+	 * 	 	,pHalData->LastHMEBoxNum ,CmdLen,msgbox_addr,h2c_cmd,msgbox_ex_addr,h2c_cmd_ex);
+	 */
+
+		rtlhal->last_hmeboxnum = (h2c_box_num+1) % RTL8812_MAX_H2C_BOX_NUMS;
+
+	} while ((!bcmd_down) && (retry_cnts--));
+
+exit:
+
+	mutex_unlock(&(rtl_usbdev(rtlpriv)->h2c_fwcmd_mutex));
+}
+
+void rtl8821au_fill_h2c_cmd(struct rtl_priv *rtlpriv, 
+					u8 element_id, u32 cmd_len, 
+					u8 *cmdbuffer)
+{
+	struct rtl_hal *rtlhal = rtl_hal(rtlpriv);
+	u32 tmp_cmdbuf[2];
+
+	if (rtlhal->fw_ready == false) {
+		RT_ASSERT(false,
+			  "return H2C cmd because of Fw download fail!!!\n");
+		return;
+	}
+
+	memset(tmp_cmdbuf, 0, 8);
+	memcpy(tmp_cmdbuf, cmdbuffer, cmd_len);
+	_rtl8821au_fill_h2c_cmd(rtlpriv, element_id, cmd_len, (u8 *)&tmp_cmdbuf);
+}
+
+uint8_t rtl8812_set_rssi_cmd(struct rtl_priv *rtlpriv, uint8_t *param)
+{
+	uint8_t	res = _SUCCESS;
+
+	*((u32 *) param) = cpu_to_le32(*((u32 *) param));
+
+	rtl8821au_fill_h2c_cmd(rtlpriv, H2C_8812_RSSI_REPORT, 4, param);
+
+
+	return res;
+}
+
+uint8_t	Get_VHT_ENI(uint32_t IOTAction, uint32_t WirelessMode, uint32_t	ratr_bitmap)
+{
+	uint8_t	Ret = 0;
+
+	/* ULLI huh ?? 2.4GHz AC wireless ?? */
+
+	if (WirelessMode == WIRELESS_11_24AC) {
+		if (ratr_bitmap & 0xfff00000)	/* Mix , 2SS */
+			Ret = 3;
+		else 				/* Mix, 1SS */
+			Ret = 2;
+	} else if (WirelessMode == WIRELESS_11_5AC) {
+		Ret = 1;			/* VHT */
+	}
+
+	return (Ret << 4);
+}
+
+
+void Set_RA_LDPC_8812(struct sta_info *psta, bool bLDPC)
+{
+	if (psta == NULL)
+		return;
+
+	if (psta->wireless_mode == WIRELESS_11_5AC) {
+		if (bLDPC && TEST_FLAG(psta->vhtpriv.ldpc_cap, LDPC_VHT_CAP_TX))
+			SET_FLAG(psta->vhtpriv.ldpc_cap, LDPC_VHT_ENABLE_TX);
+		else
+			CLEAR_FLAG(psta->vhtpriv.ldpc_cap, LDPC_VHT_ENABLE_TX);
+	} else
+		if (IsSupportedTxHT(psta->wireless_mode) || IsSupportedVHT(psta->wireless_mode)) {
+			if (bLDPC && TEST_FLAG(psta->htpriv.ldpc_cap, LDPC_HT_CAP_TX))
+				SET_FLAG(psta->htpriv.ldpc_cap, LDPC_HT_ENABLE_TX);
+			else
+				CLEAR_FLAG(psta->htpriv.ldpc_cap, LDPC_HT_ENABLE_TX);
+		}
+
+	/* DBG_871X("MacId %d bLDPC %d\n", psta->mac_id, bLDPC); */
+}
+
+u8 Get_RA_LDPC_8812(struct sta_info *psta)
+{
+	uint8_t	bLDPC = 0;
+
+	if (psta->mac_id == 1)
+		bLDPC = 0;
+	else
+		if (psta != NULL) {
+			if (IsSupportedVHT(psta->wireless_mode)) {
+				if (TEST_FLAG(psta->vhtpriv.ldpc_cap, LDPC_VHT_CAP_TX))
+					bLDPC = 1;
+				else
+					bLDPC = 0;
+			} else
+				if (IsSupportedTxHT(psta->wireless_mode)) {
+					if (TEST_FLAG(psta->htpriv.ldpc_cap, LDPC_HT_CAP_TX))
+						bLDPC = 1;
+					else
+						bLDPC = 0;
+				} else
+				bLDPC = 0;
+	}
+
+	return (bLDPC << 2);
+}
+
+
+
+void rtl8812_set_raid_cmd(struct rtl_priv *rtlpriv, uint32_t bitmap, uint8_t *arg)
+{
+	struct _rtw_hal	*pHalData = GET_HAL_DATA(rtlpriv);
+	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
+	struct mlme_ext_priv	*pmlmeext = &rtlpriv->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct sta_info	*psta;
+	uint8_t macid, init_rate, raid, shortGIrate = false;
+
+	macid = arg[0];
+	raid = arg[1];
+	shortGIrate = arg[2];
+	init_rate = arg[3];
+
+	psta = pmlmeinfo->FW_sta_info[macid].psta;
+	if (psta == NULL) {
+		return;
+	}
+
+	if (pHalData->fw_ractrl == true) {
+		uint8_t	H2CCommand[7] = {0};
+
+		shortGIrate = Get_RA_ShortGI(rtlpriv, psta, shortGIrate);
+
+		H2CCommand[0] = macid;
+		H2CCommand[1] = (raid & 0x1F) | (shortGIrate?0x80:0x00) ;
+		H2CCommand[2] = (pmlmeext->cur_bwmode & 0x3) | Get_RA_LDPC_8812(psta) | Get_VHT_ENI(0, psta->wireless_mode, bitmap);
+
+		H2CCommand[3] = (uint8_t)(bitmap & 0x000000ff);
+		H2CCommand[4] = (uint8_t)((bitmap & 0x0000ff00) >> 8);
+		H2CCommand[5] = (uint8_t)((bitmap & 0x00ff0000) >> 16);
+		H2CCommand[6] = (uint8_t)((bitmap & 0xff000000) >> 24);
+
+		RT_TRACE(rtlpriv, COMP_FW, DBG_LOUD, "rtl8812_set_raid_cmd, bitmap=0x%x, mac_id=0x%x, raid=0x%x, shortGIrate=%x\n", bitmap, macid, raid, shortGIrate);
+
+		rtl8821au_fill_h2c_cmd(rtlpriv, H2C_8812_RA_MASK, 7, H2CCommand);
+	}
+
+	if (shortGIrate == true)
+		init_rate |= BIT(7);
+
+	pdmpriv->INIDATA_RATE[macid] = init_rate;
+
+}
+
+
+/*
+ * Description: Get the reserved page number in Tx packet buffer.
+ * Retrun value: the page number.
+ * 2012.08.09, by tynli.
+ */
+u8 GetTxBufferRsvdPageNum8812(struct rtl_priv *rtlpriv)
+{
+	struct rtl_hal *rtlhal = rtl_hal(rtlpriv);
+	uint8_t	RsvdPageNum = 0;
+	uint8_t	TxPageBndy = LAST_ENTRY_OF_TX_PKT_BUFFER_8812; /* default reseved 1 page for the IC type which is undefined. */
+
+	if (IS_HARDWARE_TYPE_8812(rtlhal))
+		TxPageBndy = TX_PAGE_BOUNDARY_8812;
+	else
+		TxPageBndy = TX_PAGE_BOUNDARY_8821;
+
+	RsvdPageNum = LAST_ENTRY_OF_TX_PKT_BUFFER_8812 - TxPageBndy + 1;
+
+	return RsvdPageNum;
+}
+
+void ConstructBeacon(struct rtl_priv *rtlpriv, uint8_t *pframe, uint32_t *pLength)
+{
+	struct rtw_ieee80211_hdr	*pwlanhdr;
+	u16	*fctrl;
+	uint32_t					rate_len, pktlen;
+	struct mlme_ext_priv	*pmlmeext = &(rtlpriv->mlmeextpriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	WLAN_BSSID_EX 		*cur_network = &(pmlmeinfo->network);
+	uint8_t	bc_addr[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
+
+
+	/* DBG_871X("%s\n", __FUNCTION__); */
+
+	pwlanhdr = (struct rtw_ieee80211_hdr *)pframe;
+
+	fctrl = &(pwlanhdr->frame_ctl);
+	*(fctrl) = 0;
+
+	memcpy(pwlanhdr->addr1, bc_addr, ETH_ALEN);
+	memcpy(pwlanhdr->addr2, rtlpriv->mac80211.mac_addr, ETH_ALEN);
+	memcpy(pwlanhdr->addr3, get_my_bssid(cur_network), ETH_ALEN);
+
+	SetSeqNum(pwlanhdr, 0/*pmlmeext->mgnt_seq*/);
+	/* pmlmeext->mgnt_seq++; */
+	SetFrameSubType(pframe, WIFI_BEACON);
+
+	pframe += sizeof(struct rtw_ieee80211_hdr_3addr);
+	pktlen = sizeof (struct rtw_ieee80211_hdr_3addr);
+
+	/* timestamp will be inserted by hardware */
+	pframe += 8;
+	pktlen += 8;
+
+	/* beacon interval: 2 bytes */
+	memcpy(pframe, (unsigned char *)(rtw_get_beacon_interval_from_ie(cur_network->IEs)), 2);
+
+	pframe += 2;
+	pktlen += 2;
+
+	/* capability info: 2 bytes */
+	memcpy(pframe, (unsigned char *)(rtw_get_capability_from_ie(cur_network->IEs)), 2);
+
+	pframe += 2;
+	pktlen += 2;
+
+	if ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE) {
+		/* DBG_871X("ie len=%d\n", cur_network->IELength); */
+		pktlen += cur_network->IELength - sizeof(NDIS_802_11_FIXED_IEs);
+		memcpy(pframe, cur_network->IEs+sizeof(NDIS_802_11_FIXED_IEs), pktlen);
+
+		goto _ConstructBeacon;
+	}
+
+	/* below for ad-hoc mode */
+
+	/* SSID */
+	pframe = rtw_set_ie(pframe, _SSID_IE_, cur_network->Ssid.SsidLength, cur_network->Ssid.Ssid, &pktlen);
+
+	/* supported rates... */
+	rate_len = rtw_get_rateset_len(cur_network->SupportedRates);
+	pframe = rtw_set_ie(pframe, _SUPPORTEDRATES_IE_, ((rate_len > 8) ? 8 : rate_len), cur_network->SupportedRates, &pktlen);
+
+	/* DS parameter set */
+	pframe = rtw_set_ie(pframe, _DSSET_IE_, 1, (unsigned char *)&(cur_network->Configuration.DSConfig), &pktlen);
+
+	if ((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE) {
+		uint32_t ATIMWindow;
+		/*
+		 * IBSS Parameter Set...
+		 * ATIMWindow = cur->Configuration.ATIMWindow;
+		 */
+		ATIMWindow = 0;
+		pframe = rtw_set_ie(pframe, _IBSS_PARA_IE_, 2, (unsigned char *)(&ATIMWindow), &pktlen);
+	}
+
+
+	/* todo: ERP IE */
+
+
+	/* EXTERNDED SUPPORTED RATE */
+	if (rate_len > 8) {
+		pframe = rtw_set_ie(pframe, _EXT_SUPPORTEDRATES_IE_, (rate_len - 8), (cur_network->SupportedRates + 8), &pktlen);
+	}
+
+
+	/* todo:HT for adhoc */
+
+_ConstructBeacon:
+
+	if ((pktlen + TXDESC_SIZE) > 512) {
+		RT_TRACE(rtlpriv, COMP_FW, DBG_LOUD, "beacon frame too large\n");
+		return;
+	}
+
+	*pLength = pktlen;
+
+	/* DBG_871X("%s bcn_sz=%d\n", __FUNCTION__, pktlen); */
+
+}
+
+void ConstructPSPoll(struct rtl_priv *rtlpriv, uint8_t *pframe, uint32_t *pLength)
+{
+	struct rtw_ieee80211_hdr	*pwlanhdr;
+	u16					*fctrl;
+	struct mlme_ext_priv	*pmlmeext = &(rtlpriv->mlmeextpriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	/* DBG_871X("%s\n", __FUNCTION__); */
+
+	pwlanhdr = (struct rtw_ieee80211_hdr *)pframe;
+
+	/* Frame control. */
+	fctrl = &(pwlanhdr->frame_ctl);
+	*(fctrl) = 0;
+	SetPwrMgt(fctrl);
+	SetFrameSubType(pframe, WIFI_PSPOLL);
+
+	/* AID. */
+	SetDuration(pframe, (pmlmeinfo->aid | 0xc000));
+
+	/* BSSID. */
+	memcpy(pwlanhdr->addr1, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);
+
+	/* TA. */
+	memcpy(pwlanhdr->addr2, rtlpriv->mac80211.mac_addr, ETH_ALEN);
+
+	*pLength = 16;
+}
+
+void ConstructNullFunctionData(
+	struct rtl_priv *rtlpriv,
+	uint8_t		*pframe,
+	uint32_t		*pLength,
+	uint8_t		*StaAddr,
+	uint8_t		bQoS,
+	uint8_t		AC,
+	uint8_t		bEosp,
+	uint8_t		bForcePowerSave)
+{
+	struct rtw_ieee80211_hdr	*pwlanhdr;
+	u16						*fctrl;
+	uint32_t						pktlen;
+	struct mlme_priv		*pmlmepriv = &rtlpriv->mlmepriv;
+	struct wlan_network		*cur_network = &pmlmepriv->cur_network;
+	struct mlme_ext_priv	*pmlmeext = &(rtlpriv->mlmeextpriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+
+	/* DBG_871X("%s:%d\n", __FUNCTION__, bForcePowerSave); */
+
+	pwlanhdr = (struct rtw_ieee80211_hdr *)pframe;
+
+	fctrl = &pwlanhdr->frame_ctl;
+	*(fctrl) = 0;
+	if (bForcePowerSave) {
+		SetPwrMgt(fctrl);
+	}
+
+	switch (cur_network->network.InfrastructureMode) {
+	case Ndis802_11Infrastructure:
+		SetToDs(fctrl);
+		memcpy(pwlanhdr->addr1, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);
+		memcpy(pwlanhdr->addr2, rtlpriv->mac80211.mac_addr, ETH_ALEN);
+		memcpy(pwlanhdr->addr3, StaAddr, ETH_ALEN);
+		break;
+	case Ndis802_11APMode:
+		SetFrDs(fctrl);
+		memcpy(pwlanhdr->addr1, StaAddr, ETH_ALEN);
+		memcpy(pwlanhdr->addr2, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);
+		memcpy(pwlanhdr->addr3, rtlpriv->mac80211.mac_addr, ETH_ALEN);
+		break;
+	case Ndis802_11IBSS:
+	default:
+		memcpy(pwlanhdr->addr1, StaAddr, ETH_ALEN);
+		memcpy(pwlanhdr->addr2, rtlpriv->mac80211.mac_addr, ETH_ALEN);
+		memcpy(pwlanhdr->addr3, get_my_bssid(&(pmlmeinfo->network)), ETH_ALEN);
+		break;
+	}
+
+	SetSeqNum(pwlanhdr, 0);
+
+	if (bQoS == true) {
+		struct rtw_ieee80211_hdr_3addr_qos *pwlanqoshdr;
+
+		SetFrameSubType(pframe, WIFI_QOS_DATA_NULL);
+
+		pwlanqoshdr = (struct rtw_ieee80211_hdr_3addr_qos *) pframe;
+		SetPriority(&pwlanqoshdr->qc, AC);
+		SetEOSP(&pwlanqoshdr->qc, bEosp);
+
+		pktlen = sizeof(struct rtw_ieee80211_hdr_3addr_qos);
+	} else {
+		SetFrameSubType(pframe, WIFI_DATA_NULL);
+
+		pktlen = sizeof(struct rtw_ieee80211_hdr_3addr);
+	}
+
+	*pLength = pktlen;
+}
+
+
+/*
+ * Description: Fill the reserved packets that FW will use to RSVD page.
+ * 			Now we just send 4 types packet to rsvd page.
+ * 			(1)Beacon, (2)Ps-poll, (3)Null data, (4)ProbeRsp.
+ * 	Input:
+ * 	    bDLFinished - false: At the first time we will send all the packets as a large packet to Hw,
+ * 				 		so we need to set the packet length to total lengh.
+ * 			      true: At the second time, we should send the first packet (default:beacon)
+ * 						to Hw again and set the lengh in descriptor to the real beacon lengh.
+ *  2009.10.15 by tynli.
+ */
+static void SetFwRsvdPagePkt_8812(struct rtl_priv *rtlpriv, bool bDLFinished)
+{
+	struct rtl_hal *rtlhal = rtl_hal(rtlpriv);
+	struct _rtw_hal *pHalData;
+	struct xmit_frame	*pcmdframe;
+	struct tx_pkt_attrib	*pattrib;
+	struct xmit_priv	*pxmitpriv;
+	struct mlme_ext_priv	*pmlmeext;
+	struct mlme_ext_info	*pmlmeinfo;
+	uint32_t	PSPollLength, NullFunctionDataLength, QosNullLength;
+	uint32_t	BcnLen;
+	uint8_t	TotalPageNum = 0, CurtPktPageNum = 0, TxDescLen = 0, RsvdPageNum = 0;
+	uint8_t	*ReservedPagePacket;
+	uint8_t	RsvdPageLoc[5] = {0};
+	u16	BufIndex = 0, PageSize = 256;
+	uint32_t TotalPacketLen, MaxRsvdPageBufSize = 0;;
+
+
+	/* DBG_871X("%s\n", __FUNCTION__); */
+
+	pHalData = GET_HAL_DATA(rtlpriv);
+	pxmitpriv = &rtlpriv->xmitpriv;
+	pmlmeext = &rtlpriv->mlmeextpriv;
+	pmlmeinfo = &pmlmeext->mlmext_info;
+
+	if (IS_HARDWARE_TYPE_8812(rtlhal))
+		PageSize = 512;
+	else if (IS_HARDWARE_TYPE_8821(rtlhal))
+		PageSize = PAGE_SIZE_TX_8821A;
+
+	/*
+	 *  <tynli_note> The function SetFwRsvdPagePkt_8812() input must be added a value "bDLWholePackets" to
+	 *  decide if download wowlan packets, and use "bDLWholePackets" to be GetTxBufferRsvdPageNum8812() 2nd input value.
+	 */
+	RsvdPageNum = GetTxBufferRsvdPageNum8812(rtlpriv);
+	MaxRsvdPageBufSize = RsvdPageNum*PageSize;
+
+	pcmdframe = rtw_alloc_cmdxmitframe(pxmitpriv, MaxRsvdPageBufSize);
+	if (pcmdframe == NULL) {
+		return;
+	}
+
+	ReservedPagePacket = pcmdframe->buf_addr;
+
+	TxDescLen = TXDESC_SIZE;	/* The desc lengh in Tx packet buffer of 8812A is 40 bytes. */
+
+	/* (1) beacon */
+	BufIndex = TXDESC_OFFSET;
+	ConstructBeacon(rtlpriv, &ReservedPagePacket[BufIndex], &BcnLen);
+
+	/*
+	 *  When we count the first page size, we need to reserve description size for the RSVD
+	 *  packet, it will be filled in front of the packet in TXPKTBUF.
+	 */
+	CurtPktPageNum = (uint8_t)PageNum(BcnLen+TxDescLen, PageSize);
+
+	if (bDLFinished) {
+		TotalPageNum += CurtPktPageNum;
+		TotalPacketLen = (TotalPageNum*PageSize);
+		RT_TRACE(rtlpriv, COMP_FW, DBG_LOUD, "%s(): Beacon page size = %d\n", __FUNCTION__, TotalPageNum);
+	} else {
+		TotalPageNum += CurtPktPageNum;
+
+		pHalData->FwRsvdPageStartOffset = TotalPageNum;
+
+		BufIndex += (CurtPktPageNum*PageSize);
+
+		if (BufIndex > MaxRsvdPageBufSize) {
+			RT_TRACE(rtlpriv, COMP_FW, DBG_LOUD, "%s(): Beacon: The rsvd page size is not enough!!BufIndex %d, MaxRsvdPageBufSize %d\n", __FUNCTION__,
+				BufIndex, MaxRsvdPageBufSize);
+			goto error;
+		}
+
+		/* (2) ps-poll */
+		ConstructPSPoll(rtlpriv, &ReservedPagePacket[BufIndex], &PSPollLength);
+		rtw_hal_fill_fake_txdesc(rtlpriv, &ReservedPagePacket[BufIndex-TxDescLen], PSPollLength, true, false);
+
+		SET_8812_H2CCMD_RSVDPAGE_LOC_PSPOLL(RsvdPageLoc, TotalPageNum);
+
+		/*
+		 * DBG_871X("SetFwRsvdPagePkt_8812(): HW_VAR_SET_TX_CMD: PS-POLL %p %d\n",
+		 * 	&ReservedPagePacket[BufIndex-TxDescLen], (PSPollLength+TxDescLen));
+		 */
+
+		CurtPktPageNum = (uint8_t)PageNum(PSPollLength+TxDescLen, PageSize);
+
+		BufIndex += (CurtPktPageNum*PageSize);
+
+		TotalPageNum += CurtPktPageNum;
+
+		if (BufIndex > MaxRsvdPageBufSize) {
+			RT_TRACE(rtlpriv, COMP_FW, DBG_LOUD, "%s(): ps-poll: The rsvd page size is not enough!!BufIndex %d, MaxRsvdPageBufSize %d\n", __FUNCTION__,
+				BufIndex, MaxRsvdPageBufSize);
+			goto error;
+		}
+
+		/* (3) null data */
+		ConstructNullFunctionData(
+			rtlpriv,
+			&ReservedPagePacket[BufIndex],
+			&NullFunctionDataLength,
+			get_my_bssid(&pmlmeinfo->network),
+			false, 0, 0, false);
+		rtw_hal_fill_fake_txdesc(rtlpriv, &ReservedPagePacket[BufIndex-TxDescLen], NullFunctionDataLength, false, false);
+
+		SET_8812_H2CCMD_RSVDPAGE_LOC_NULL_DATA(RsvdPageLoc, TotalPageNum);
+
+		/*
+		 * DBG_871X("SetFwRsvdPagePkt_8812(): HW_VAR_SET_TX_CMD: NULL DATA %p %d\n",
+		 * 	&ReservedPagePacket[BufIndex-TxDescLen], (NullFunctionDataLength+TxDescLen));
+		 */
+
+		CurtPktPageNum = (uint8_t)PageNum(NullFunctionDataLength+TxDescLen, PageSize);
+
+		BufIndex += (CurtPktPageNum*PageSize);
+
+		TotalPageNum += CurtPktPageNum;
+
+		if (BufIndex > MaxRsvdPageBufSize) {
+			RT_TRACE(rtlpriv, COMP_FW, DBG_LOUD, "%s(): Null-data: The rsvd page size is not enough!!BufIndex %d, MaxRsvdPageBufSize %d\n", __FUNCTION__,
+				BufIndex, MaxRsvdPageBufSize);
+			goto error;
+		}
+
+		/* (5) Qos null data */
+		ConstructNullFunctionData(
+			rtlpriv,
+			&ReservedPagePacket[BufIndex],
+			&QosNullLength,
+			get_my_bssid(&pmlmeinfo->network),
+			true, 0, 0, false);
+		rtw_hal_fill_fake_txdesc(rtlpriv, &ReservedPagePacket[BufIndex-TxDescLen], QosNullLength, false, false);
+
+		SET_8812_H2CCMD_RSVDPAGE_LOC_QOS_NULL_DATA(RsvdPageLoc, TotalPageNum);
+
+		/*
+		 * DBG_871X("SetFwRsvdPagePkt_8812(): HW_VAR_SET_TX_CMD: QOS NULL DATA %p %d\n",
+		 * 	&ReservedPagePacket[BufIndex-TxDescLen], (QosNullLength+TxDescLen));
+		 */
+
+		CurtPktPageNum = (uint8_t)PageNum(QosNullLength+TxDescLen, PageSize);
+
+		BufIndex += (CurtPktPageNum*PageSize);
+
+		TotalPageNum += CurtPktPageNum;
+
+		TotalPacketLen = (TotalPageNum * PageSize);
+	}
+
+
+	if (TotalPacketLen > MaxRsvdPageBufSize) {
+		RT_TRACE(rtlpriv, COMP_FW, DBG_LOUD, "%s(): ERROR: The rsvd page size is not enough!!TotalPacketLen %d, MaxRsvdPageBufSize %d\n", __FUNCTION__,
+			TotalPacketLen, MaxRsvdPageBufSize);
+		goto error;
+	} else {
+		/* update attribute */
+		pattrib = &pcmdframe->tx_attrib;
+		update_mgntframe_attrib(rtlpriv, pattrib);
+		pattrib->tx_qsel = 0x10;
+		pattrib->pktlen = pattrib->last_txcmdsz = TotalPacketLen - TxDescLen;
+
+		dump_mgntframe_and_wait(rtlpriv, pcmdframe, 100);
+	}
+
+	if (!bDLFinished) {
+		RT_TRACE(rtlpriv, COMP_FW, DBG_LOUD, "%s: Set RSVD page location to Fw ,TotalPacketLen(%d), TotalPageNum(%d)\n", __FUNCTION__, TotalPacketLen, TotalPageNum);
+		rtl8821au_fill_h2c_cmd(rtlpriv, H2C_8812_RSVDPAGE, 5, RsvdPageLoc);
+	}
+
+	rtw_free_cmd_xmitbuf(pxmitpriv);
+
+	return;
+
+error:
+	rtw_free_cmdxmitframe(pxmitpriv, pcmdframe);
+}
+
+void rtl8821au_set_fw_joinbss_report_cmd(struct rtl_priv *rtlpriv, uint8_t mstatus)
+{
+	 struct _rtw_hal	*pHalData = GET_HAL_DATA(rtlpriv);
+	struct mlme_ext_priv	*pmlmeext = &(rtlpriv->mlmeextpriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	bool		bSendBeacon = false;
+	bool		bcn_valid = false;
+	uint8_t	DLBcnCount = 0;
+	uint32_t poll = 0;
+
+	RT_TRACE(rtlpriv, COMP_FW, DBG_LOUD, "%s mstatus(%x)\n", __FUNCTION__, mstatus);
+
+	if (mstatus == 1) {
+		/*
+		 *  We should set AID, correct TSF, HW seq enable before set JoinBssReport to Fw in 88/92C.
+		 *  Suggested by filen. Added by tynli.
+		 */
+		rtl_write_word(rtlpriv, REG_BCN_PSR_RPT, (0xC000|pmlmeinfo->aid));
+		/*
+		 *  Do not set TSF again here or vWiFi beacon DMA INT will not work.
+		 *  correct_TSF(rtlpriv, pmlmeext);
+		 *  Hw sequende enable by dedault. 2010.06.23. by tynli.
+		 * rtl_write_word(rtlpriv, REG_NQOS_SEQ, ((pmlmeext->mgnt_seq+100)&0xFFF));
+		 * rtl_write_byte(rtlpriv, REG_HWSEQ_CTRL, 0xFF);
+		 */
+
+		/* Set REG_CR bit 8. DMA beacon by SW. */
+		pHalData->RegCR_1 |= BIT(0);
+		rtl_write_byte(rtlpriv,  REG_CR+1, pHalData->RegCR_1);
+
+		/*
+		 * Disable Hw protection for a time which revserd for Hw sending beacon.
+		 * Fix download reserved page packet fail that access collision with the protection time.
+		 * 2010.05.11. Added by tynli.
+		 * SetBcnCtrlReg(rtlpriv, 0, BIT(3));
+		 * SetBcnCtrlReg(rtlpriv, BIT(4), 0);
+		 */
+		rtl_write_byte(rtlpriv, REG_BCN_CTRL, rtl_read_byte(rtlpriv, REG_BCN_CTRL)&(~BIT(3)));
+		rtl_write_byte(rtlpriv, REG_BCN_CTRL, rtl_read_byte(rtlpriv, REG_BCN_CTRL)|BIT(4));
+
+		if (pHalData->RegFwHwTxQCtrl&BIT(6)) {
+			RT_TRACE(rtlpriv, COMP_FW, DBG_LOUD, "HalDownloadRSVDPage(): There is an rtlpriv is sending beacon.\n");
+			bSendBeacon = true;
+		}
+
+		/* Set FWHW_TXQ_CTRL 0x422[6]=0 to tell Hw the packet is not a real beacon frame. */
+		rtl_write_byte(rtlpriv, REG_FWHW_TXQ_CTRL+2, (pHalData->RegFwHwTxQCtrl&(~BIT(6))));
+		pHalData->RegFwHwTxQCtrl &= (~BIT(6));
+
+		/* Clear beacon valid check bit. */
+		rtlpriv->cfg->ops->set_hw_reg(rtlpriv, HW_VAR_BCN_VALID, NULL);
+		DLBcnCount = 0;
+		poll = 0;
+
+		do {
+			/* download rsvd page. */
+			SetFwRsvdPagePkt_8812(rtlpriv, false);
+			DLBcnCount++;
+			do {
+				rtw_yield_os();
+				/*
+				 * rtw_mdelay_os(10);
+				 * check rsvd page download OK.
+				 */
+				rtlpriv->cfg->ops->get_hw_reg(rtlpriv, HW_VAR_BCN_VALID, (uint8_t *)(&bcn_valid));
+				poll++;
+			} while (!bcn_valid && (poll%10) != 0 && !rtlpriv->bSurpriseRemoved && !rtlpriv->bDriverStopped);
+
+		} while (!bcn_valid && DLBcnCount <= 100 && !rtlpriv->bSurpriseRemoved && !rtlpriv->bDriverStopped);
+
+		/* RT_ASSERT(bcn_valid, ("HalDownloadRSVDPage88ES(): 1 Download RSVD page failed!\n")); */
+		if (rtlpriv->bSurpriseRemoved || rtlpriv->bDriverStopped) {
+		} else if (!bcn_valid)
+			RT_TRACE(rtlpriv, COMP_FW, DBG_LOUD, "%s: 1 Download RSVD page failed! DLBcnCount:%u, poll:%u\n", __FUNCTION__ , DLBcnCount, poll);
+		else
+			RT_TRACE(rtlpriv, COMP_FW, DBG_LOUD, "%s: 1 Download RSVD success! DLBcnCount:%u, poll:%u\n", __FUNCTION__, DLBcnCount, poll);
+		/*
+		 * We just can send the reserved page twice during the time that Tx thread is stopped (e.g. pnpsetpower)
+		 * becuase we need to free the Tx BCN Desc which is used by the first reserved page packet.
+		 * At run time, we cannot get the Tx Desc until it is released in TxHandleInterrupt() so we will return
+		 * the beacon TCB in the following code. 2011.11.23. by tynli.
+		 */
+
+		/* if (bcn_valid && rtlpriv->bEnterPnpSleep) */
+		if (0) {
+			if (bSendBeacon) {
+				rtlpriv->cfg->ops->set_hw_reg(rtlpriv, HW_VAR_BCN_VALID, NULL);
+				DLBcnCount = 0;
+				poll = 0;
+				do {
+					SetFwRsvdPagePkt_8812(rtlpriv, true);
+					DLBcnCount++;
+
+					do {
+						rtw_yield_os();
+						/*
+						 * rtw_mdelay_os(10);
+						 * check rsvd page download OK.
+						 */
+						rtlpriv->cfg->ops->get_hw_reg(rtlpriv, HW_VAR_BCN_VALID, (uint8_t *)(&bcn_valid));
+						poll++;
+					} while (!bcn_valid && (poll%10) != 0 && !rtlpriv->bSurpriseRemoved && !rtlpriv->bDriverStopped);
+				} while (!bcn_valid && DLBcnCount <= 100 && !rtlpriv->bSurpriseRemoved && !rtlpriv->bDriverStopped);
+
+				/* RT_ASSERT(bcn_valid, ("HalDownloadRSVDPage(): 2 Download RSVD page failed!\n")); */
+				if (rtlpriv->bSurpriseRemoved || rtlpriv->bDriverStopped) {
+				} else if (!bcn_valid)
+					RT_TRACE(rtlpriv, COMP_FW, DBG_LOUD, "%s: 2 Download RSVD page failed! DLBcnCount:%u, poll:%u\n", __FUNCTION__ , DLBcnCount, poll);
+				else
+					RT_TRACE(rtlpriv, COMP_FW, DBG_LOUD, "%s: 2 Download RSVD success! DLBcnCount:%u, poll:%u\n", __FUNCTION__, DLBcnCount, poll);
+			}
+		}
+
+		/* Enable Bcn */
+		/* SetBcnCtrlReg(rtlpriv, BIT(3), 0); */
+		/* SetBcnCtrlReg(rtlpriv, 0, BIT(4)); */
+		rtl_write_byte(rtlpriv, REG_BCN_CTRL, rtl_read_byte(rtlpriv, REG_BCN_CTRL)|BIT(3));
+		rtl_write_byte(rtlpriv, REG_BCN_CTRL, rtl_read_byte(rtlpriv, REG_BCN_CTRL)&(~BIT(4)));
+
+		/*
+		 * To make sure that if there exists an rtlpriv which would like to send beacon.
+		 * If exists, the origianl value of 0x422[6] will be 1, we should check this to
+		 * prevent from setting 0x422[6] to 0 after download reserved page, or it will cause
+		 * the beacon cannot be sent by HW.
+		 * 2010.06.23. Added by tynli.
+		 */
+
+		if (bSendBeacon) {
+			rtl_write_byte(rtlpriv, REG_FWHW_TXQ_CTRL+2, (pHalData->RegFwHwTxQCtrl|BIT(6)));
+			pHalData->RegFwHwTxQCtrl |= BIT(6);
+		}
+
+		/*
+		 * Update RSVD page location H2C to Fw.
+		 */
+
+		if (bcn_valid) {
+			rtlpriv->cfg->ops->set_hw_reg(rtlpriv, HW_VAR_BCN_VALID, NULL);
+			RT_TRACE(rtlpriv, COMP_FW, DBG_LOUD, "Set RSVD page location to Fw.\n");
+			/* FillH2CCmd88E(rtlpriv, H2C_88E_RSVDPAGE, H2C_RSVDPAGE_LOC_LENGTH, pMgntInfo->u1RsvdPageLoc); */
+		}
+
+		/*  Do not enable HW DMA BCN or it will cause Pcie interface hang by timing issue. 2011.11.24. by tynli. */
+		/* if (!rtlpriv->bEnterPnpSleep) */
+		{
+			/* Clear CR[8] or beacon packet will not be send to TxBuf anymore. */
+			pHalData->RegCR_1 &= (~BIT(0));
+			rtl_write_byte(rtlpriv,  REG_CR+1, pHalData->RegCR_1);
+		}
+	}
+
+}
+
+
+
+void rtl8812_set_FwMediaStatus_cmd(struct rtl_priv *rtlpriv, u16 mstatus_rpt)
+{
+	uint8_t	u1JoinBssRptParm[3] = {0};
+	uint8_t	mstatus, macId, macId_Ind = 0, macId_End = 0;
+
+	mstatus = (uint8_t) (mstatus_rpt & 0xFF);
+	macId = (uint8_t)(mstatus_rpt >> 8)  ;
+
+	SET_8812_H2CCMD_MSRRPT_PARM_OPMODE(u1JoinBssRptParm, mstatus);
+	SET_8812_H2CCMD_MSRRPT_PARM_MACID_IND(u1JoinBssRptParm, macId_Ind);
+
+	SET_8812_H2CCMD_MSRRPT_PARM_MACID(u1JoinBssRptParm, macId);
+	SET_8812_H2CCMD_MSRRPT_PARM_MACID_END(u1JoinBssRptParm, macId_End);
+
+	RT_TRACE(rtlpriv, COMP_FW, DBG_LOUD, "[MacId],  Set MacId Ctrl(original) = 0x%x \n", u1JoinBssRptParm[0]<<16|u1JoinBssRptParm[1]<<8|u1JoinBssRptParm[2]);
+
+	rtl8821au_fill_h2c_cmd(rtlpriv, H2C_8812_MSRRPT, 3, u1JoinBssRptParm);
+}
+
+
+void rtl8812au_set_fw_pwrmode_cmd(struct rtl_priv *rtlpriv, uint8_t PSMode)
+{
+	uint8_t	u1H2CSetPwrMode[5] = {0};
+	struct pwrctrl_priv *pwrpriv = &rtlpriv->pwrctrlpriv;
+	uint8_t	Mode = 0, RLBM = 0, PowerState = 0, LPSAwakeIntvl = 1;
+
+	PSMode = PS_MODE_MIN;		/* ULLI: fix for powermode on low bitrate streaming */
+
+	RT_TRACE(rtlpriv, COMP_FW, DBG_LOUD, "%s: Mode=%d SmartPS=%d UAPSD=%d\n", __FUNCTION__,
+			PSMode, pwrpriv->smart_ps, rtlpriv->registrypriv.uapsd_enable);
+
+	switch (PSMode) {
+	case PS_MODE_ACTIVE:
+		Mode = 0;
+		break;
+	case PS_MODE_MIN:
+		Mode = 1;
+		break;
+	case PS_MODE_MAX:
+		RLBM = 1;
+		Mode = 1;
+		break;
+	case PS_MODE_DTIM:
+		RLBM = 2;
+		Mode = 1;
+		break;
+	case PS_MODE_UAPSD_WMM:
+		Mode = 2;
+		break;
+	default:
+		Mode = 0;
+		break;
+	}
+
+	if (Mode > PS_MODE_ACTIVE) {
+		PowerState = 0x00;	/* AllON(0x0C), RFON(0x04), RFOFF(0x00) */
+	} else {
+		PowerState = 0x0C;	/* AllON(0x0C), RFON(0x04), RFOFF(0x00) */
+	}
+
+	/* 0: Active, 1: LPS, 2: WMMPS */
+	SET_8812_H2CCMD_PWRMODE_PARM_MODE(u1H2CSetPwrMode, Mode);
+
+	/* 0:Min, 1:Max , 2:User define */
+	SET_8812_H2CCMD_PWRMODE_PARM_RLBM(u1H2CSetPwrMode, RLBM);
+
+	/* (LPS) smart_ps:  0: PS_Poll, 1: PS_Poll , 2: NullData */
+	/* (WMM)smart_ps: 0:PS_Poll, 1:NullData */
+	SET_8812_H2CCMD_PWRMODE_PARM_SMART_PS(u1H2CSetPwrMode, pwrpriv->smart_ps);
+
+	/* AwakeInterval: Unit is beacon interval, this field is only valid in PS_DTIM mode */
+	SET_8812_H2CCMD_PWRMODE_PARM_BCN_PASS_TIME(u1H2CSetPwrMode, LPSAwakeIntvl);
+
+	/* (WMM only)bAllQueueUAPSD */
+	SET_8812_H2CCMD_PWRMODE_PARM_ALL_QUEUE_UAPSD(u1H2CSetPwrMode, rtlpriv->registrypriv.uapsd_enable);
+
+	/* AllON(0x0C), RFON(0x04), RFOFF(0x00) */
+	SET_8812_H2CCMD_PWRMODE_PARM_PWR_STATE(u1H2CSetPwrMode, PowerState);
+
+	rtl8821au_fill_h2c_cmd(rtlpriv, H2C_8812_SETPWRMODE, sizeof(u1H2CSetPwrMode), (uint8_t *)&u1H2CSetPwrMode);
+}
+
+
+static void _rtl8821ae_enable_fw_download(struct rtl_priv *rtlpriv, bool enable)
+{
+	uint8_t	tmp;
+
+	if (enable) {
+		/* MCU firmware download enable. */
+		tmp = rtl_read_byte(rtlpriv, REG_MCUFWDL);
+		rtl_write_byte(rtlpriv, REG_MCUFWDL, tmp|0x01);
+
+		/* 8051 reset */
+		tmp = rtl_read_byte(rtlpriv, REG_MCUFWDL+2);
+		rtl_write_byte(rtlpriv, REG_MCUFWDL+2, tmp&0xf7);
+	} else {
+
+		/* MCU firmware download disable. */
+		tmp = rtl_read_byte(rtlpriv, REG_MCUFWDL);
+		rtl_write_byte(rtlpriv, REG_MCUFWDL, tmp&0xfe);
+	}
+}
+
+
+
+#define MAX_REG_BOLCK_SIZE	196
+
+static int _BlockWrite_8812(struct rtl_priv *rtlpriv, void *buffer, uint32_t buffSize)
+{
+	int ret = _SUCCESS;
+
+	uint32_t blockSize_p1 = 4;	/* (Default) Phase #1 : PCI muse use 4-byte write to download FW */
+	uint32_t blockSize_p2 = 8;	/* Phase #2 : Use 8-byte, if Phase#1 use big size to write FW. */
+	uint32_t blockSize_p3 = 1;	/* Phase #3 : Use 1-byte, the remnant of FW image. */
+	uint32_t blockCount_p1 = 0, blockCount_p2 = 0, blockCount_p3 = 0;
+	uint32_t remainSize_p1 = 0, remainSize_p2 = 0;
+	uint8_t	 *bufferPtr	= (uint8_t *)buffer;
+	uint32_t i = 0, offset = 0;
+
+	blockSize_p1 = MAX_REG_BOLCK_SIZE;
+
+	/* 3 Phase #1 */
+	blockCount_p1 = buffSize / blockSize_p1;
+	remainSize_p1 = buffSize % blockSize_p1;
+
+	if (blockCount_p1) {
+		;
+	}
+
+	for (i = 0; i < blockCount_p1; i++) {
+		rtl_writeN(rtlpriv, (FW_8821AU_START_ADDRESS + i * blockSize_p1), (bufferPtr + i * blockSize_p1), blockSize_p1);
+	}
+
+
+	/* 3 Phase #2 */
+	if (remainSize_p1) {
+		offset = blockCount_p1 * blockSize_p1;
+
+		blockCount_p2 = remainSize_p1/blockSize_p2;
+		remainSize_p2 = remainSize_p1%blockSize_p2;
+
+		if (blockCount_p2) {
+			;
+		}
+
+		for (i = 0; i < blockCount_p2; i++) {
+			rtl_writeN(rtlpriv, (FW_8821AU_START_ADDRESS + offset + i*blockSize_p2), (bufferPtr + offset + i*blockSize_p2), blockSize_p2);
+		}
+	}
+
+	/* 3 Phase #3 */
+	if (remainSize_p2) {
+		offset = (blockCount_p1 * blockSize_p1) + (blockCount_p2 * blockSize_p2);
+
+		blockCount_p3 = remainSize_p2 / blockSize_p3;
+
+		for (i = 0 ; i < blockCount_p3; i++) {
+			rtl_write_byte(rtlpriv, (FW_8821AU_START_ADDRESS + offset + i), *(bufferPtr + offset + i));
+		}
+	}
+
+exit:
+	return ret;
+}
+
+
+
+static int _PageWrite_8812(struct rtl_priv *rtlpriv, uint32_t page,
+	void *buffer, uint32_t size)
+{
+	uint8_t value8;
+	uint8_t u8Page = (uint8_t) (page & 0x07) ;
+
+	value8 = (rtl_read_byte(rtlpriv, REG_MCUFWDL+2) & 0xF8) | u8Page ;
+	rtl_write_byte(rtlpriv, REG_MCUFWDL+2, value8);
+
+	return _BlockWrite_8812(rtlpriv, buffer, size);
+}
+
+
+static int _WriteFW_8812(struct rtl_priv *rtlpriv, void *buffer, uint32_t size)
+{
+	/*
+	 * Since we need dynamic decide method of dwonload fw, so we call this function to get chip version.
+	 * We can remove _ReadChipVersion from ReadpadapterInfo8192C later.
+	 */
+
+	int	ret = _SUCCESS;
+	uint32_t pageNums, remainSize;
+	uint32_t page, offset;
+	uint8_t	*bufferPtr = (uint8_t *)buffer;
+
+	pageNums = size / MAX_DLFW_PAGE_SIZE ;
+	/*
+	 * RT_ASSERT((pageNums <= 4), ("Page numbers should not greater then 4 \n"));
+	 */
+
+	remainSize = size % MAX_DLFW_PAGE_SIZE;
+
+	for (page = 0; page < pageNums; page++) {
+		offset = page * MAX_DLFW_PAGE_SIZE;
+		ret = _PageWrite_8812(rtlpriv, page, bufferPtr+offset, MAX_DLFW_PAGE_SIZE);
+
+		if (ret == _FAIL)
+			goto exit;
+	}
+	if (remainSize) {
+		offset = pageNums * MAX_DLFW_PAGE_SIZE;
+		page = pageNums;
+		ret = _PageWrite_8812(rtlpriv, page, bufferPtr+offset, remainSize);
+
+		if (ret == _FAIL)
+			goto exit;
+
+	}
+
+exit:
+	return ret;
+}
+
+static int32_t _rtl8821au_fw_free_to_go(struct rtl_priv *rtlpriv)
+{
+	uint32_t	counter = 0;
+	uint32_t	value32;
+
+	/* polling CheckSum report */
+	do {
+		value32 = rtl_read_dword(rtlpriv, REG_MCUFWDL);
+		if (value32 & FWDL_ChkSum_rpt)
+			break;
+	} while (counter++ < 6000);
+
+	if (counter >= 6000) {
+		RT_TRACE(rtlpriv, COMP_ERR, DBG_LOUD,
+			 "%s: chksum report fail! REG_MCUFWDL:0x%08x\n", __FUNCTION__, value32);
+		return _FAIL;
+	}
+	RT_TRACE(rtlpriv, COMP_ERR, DBG_LOUD,
+		 "%s: Checksum report OK! REG_MCUFWDL:0x%08x\n", __FUNCTION__, value32);
+
+	value32 = rtl_read_dword(rtlpriv, REG_MCUFWDL);
+	value32 |= MCUFWDL_RDY;
+	value32 &= ~WINTINI_RDY;
+	rtl_write_dword(rtlpriv, REG_MCUFWDL, value32);
+
+	rtl8821au_firmware_selfreset(rtlpriv);
+
+	/* polling for FW ready */
+	counter = 0;
+	do {
+		value32 = rtl_read_dword(rtlpriv, REG_MCUFWDL);
+		if (value32 & WINTINI_RDY) {
+			RT_TRACE(rtlpriv, COMP_ERR, DBG_LOUD,
+				 "%s: Polling FW ready success!! REG_MCUFWDL:0x%08x\n", __FUNCTION__, value32);
+			return _SUCCESS;
+		}
+		udelay(5);
+	} while (counter++ < 6000);
+
+	RT_TRACE(rtlpriv, COMP_ERR, DBG_LOUD,
+		 "%s: Polling FW ready fail!! REG_MCUFWDL:0x%08x\n", __FUNCTION__, value32);
+	return _FAIL;
+}
+
+int32_t rtl8821au_download_fw(struct rtl_priv *rtlpriv, bool bUsedWoWLANFw)
+{
+	struct rtl_hal *rtlhal = rtl_hal(rtlpriv);
+	struct rtl_usb *rtlusb = rtl_usbdev(rtlpriv);
+	struct device *device = dvobj_to_dev(rtlusb);
+	const struct firmware *fw;
+	char *fw_name;
+	u8 *pfwdata;
+
+	int32_t	rtStatus = _SUCCESS;
+	uint8_t	writeFW_retry = 0;
+	uint32_t fwdl_start_time;
+	struct _rtw_hal *pHalData = GET_HAL_DATA(rtlpriv);
+	struct _rtw_dm *	pDM_Odm;
+	uint8_t				*pFwHdr = NULL;
+
+	pDM_Odm = &pHalData->odmpriv;
+
+	if (IS_HARDWARE_TYPE_8812AU(rtlhal)) 
+		fw_name = "rtlwifi/rtl8812aufw.bin";
+
+	if (IS_HARDWARE_TYPE_8821U(rtlhal))
+		fw_name = "rtlwifi/rtl8821aufw.bin";
+
+	pr_info("Loading firmware %s\n", fw_name);
+
+	if (request_firmware(&fw, fw_name, device)) {
+		RT_TRACE(rtlpriv, COMP_FW, DBG_EMERG, "Firmware %s not available\n", fw_name);
+		return -ENOENT;
+	}
+
+
+	RT_TRACE(rtlpriv, COMP_FW, DBG_LOUD, "Normal Firmware SIZE %d\n", rtlhal->fwsize);
+
+	if (rtlhal->fwsize > FW_SIZE_8812) {
+			rtStatus = _FAIL;
+			goto Exit;
+		}
+
+
+	pfwdata = kzalloc(FW_SIZE_8812, GFP_KERNEL);
+	if (!pfwdata)
+		return -ENOMEM;
+
+	rtlhal->pfirmware = pfwdata;
+	memcpy(rtlhal->pfirmware, fw->data, fw->size);
+	rtlhal->fwsize = fw->size;
+	release_firmware(fw);
+
+	/* To Check Fw header. Added by tynli. 2009.12.04. */
+	pFwHdr = (uint8_t *) rtlhal->pfirmware;
+
+	rtlhal->fw_version =  (u16)GET_FIRMWARE_HDR_VERSION_8812(pFwHdr);
+	rtlhal->fw_subversion = (u16)GET_FIRMWARE_HDR_SUB_VER_8812(pFwHdr);
+/*	
+	pHalData->FirmwareSignature = (u16)GET_FIRMWARE_HDR_SIGNATURE_8812(pFwHdr);
+
+	DBG_871X ("%s: fw_ver=%d fw_subver=%d sig=0x%x\n",
+		  __FUNCTION__, pHalData->FirmwareVersion, pHalData->FirmwareSubVersion, pHalData->FirmwareSignature);
+*/
+	RT_TRACE(rtlpriv, COMP_FW, DBG_DMESG, "%s: fw_ver=%d fw_subver=%d\n",
+		  __FUNCTION__, rtlhal->fw_version, rtlhal->fw_subversion);
+
+
+	if (IS_FW_HEADER_EXIST_8812(pFwHdr) || IS_FW_HEADER_EXIST_8821(pFwHdr)) {
+		/* Shift 32 bytes for FW header */
+		rtlhal->pfirmware += 32;
+		rtlhal->fwsize -= 32;
+	}
+
+	/*
+	 * Suggested by Filen. If 8051 is running in RAM code, driver should inform Fw to reset by itself,
+	 * or it will cause download Fw fail. 2010.02.01. by tynli.
+	 */
+	if (rtl_read_byte(rtlpriv, REG_MCUFWDL) & BIT(7)) { /* 8051 RAM code */
+		rtl_write_byte(rtlpriv, REG_MCUFWDL, 0x00);
+		rtl8821au_firmware_selfreset(rtlpriv);
+	}
+
+	_rtl8821ae_enable_fw_download(rtlpriv, true);
+	fwdl_start_time = jiffies;
+	while (1) {
+		/* reset the FWDL chksum */
+		rtl_write_byte(rtlpriv, REG_MCUFWDL, rtl_read_byte(rtlpriv, REG_MCUFWDL)|FWDL_ChkSum_rpt);
+
+		rtStatus = _WriteFW_8812(rtlpriv, rtlhal->pfirmware, rtlhal->fwsize);
+
+		if (rtStatus == _SUCCESS
+		   || (rtw_get_passing_time_ms(fwdl_start_time) > 500 && writeFW_retry++ >= 3))
+			break;
+
+		RT_TRACE(rtlpriv, COMP_FW, DBG_LOUD, "%s writeFW_retry:%u, time after fwdl_start_time:%ums\n", __FUNCTION__
+			, writeFW_retry, rtw_get_passing_time_ms(fwdl_start_time)
+		);
+	}
+	_rtl8821ae_enable_fw_download(rtlpriv, false);
+	if (_SUCCESS != rtStatus) {
+		RT_TRACE(rtlpriv, COMP_FW, DBG_LOUD, "DL Firmware failed!\n");
+		goto Exit;
+	}
+
+	rtStatus = _rtl8821au_fw_free_to_go(rtlpriv);
+	if (_SUCCESS != rtStatus) {
+		RT_TRACE(rtlpriv, COMP_FW, DBG_LOUD, "DL Firmware failed!\n");
+		goto Exit;
+	}
+
+
+Exit:
+
+	RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD, " <=== FirmwareDownload91C()\n");
+	
+	return rtStatus;
+}
diff -Naur linux-4.9/drivers/staging/rtl8821au/rtl8821au/fw.h linux-4.9.8821au/drivers/staging/rtl8821au/rtl8821au/fw.h
--- linux-4.9/drivers/staging/rtl8821au/rtl8821au/fw.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/rtl8821au/fw.h	2016-12-11 19:48:25.180311687 -0600
@@ -0,0 +1,88 @@
+#ifndef __RTL8821AU_FW_H__
+#define __RTL8821AU_FW_H__
+
+#include <rtl8812a_hal.h>
+#include "../wifi.h"
+
+
+//_RSVDPAGE_LOC_CMD0
+#define SET_8812_H2CCMD_RSVDPAGE_LOC_PROBE_RSP(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
+#define SET_8812_H2CCMD_RSVDPAGE_LOC_PSPOLL(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 8, __Value)
+#define SET_8812_H2CCMD_RSVDPAGE_LOC_NULL_DATA(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 8, __Value)
+#define SET_8812_H2CCMD_RSVDPAGE_LOC_QOS_NULL_DATA(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 0, 8, __Value)
+#define SET_8812_H2CCMD_RSVDPAGE_LOC_BT_QOS_NULL_DATA(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+4, 0, 8, __Value)
+
+//_MEDIA_STATUS_RPT_PARM_CMD1
+#define SET_8812_H2CCMD_MSRRPT_PARM_OPMODE(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 1, __Value)
+#define SET_8812_H2CCMD_MSRRPT_PARM_MACID_IND(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 1, 1, __Value)
+#define SET_8812_H2CCMD_MSRRPT_PARM_MACID(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd+1, 0, 8, __Value)
+#define SET_8812_H2CCMD_MSRRPT_PARM_MACID_END(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd+2, 0, 8, __Value)
+
+//_SETPWRMODE_PARM
+#define SET_8812_H2CCMD_PWRMODE_PARM_MODE(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 8, __Value)
+#define SET_8812_H2CCMD_PWRMODE_PARM_RLBM(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 0, 4, __Value)
+#define SET_8812_H2CCMD_PWRMODE_PARM_SMART_PS(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE((__pH2CCmd)+1, 4, 4, __Value)
+#define SET_8812_H2CCMD_PWRMODE_PARM_BCN_PASS_TIME(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+2, 0, 8, __Value)
+#define SET_8812_H2CCMD_PWRMODE_PARM_ALL_QUEUE_UAPSD(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+3, 0, 8, __Value)
+#define SET_8812_H2CCMD_PWRMODE_PARM_PWR_STATE(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE((__pH2CCmd)+4, 0, 8, __Value)
+
+#define GET_8812_H2CCMD_PWRMODE_PARM_MODE(__pH2CCmd)					LE_BITS_TO_1BYTE(__pH2CCmd, 0, 8)
+
+//_P2P_PS_OFFLOAD
+#define SET_8812_H2CCMD_P2P_PS_OFFLOAD_ENABLE(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 0, 1, __Value)
+#define SET_8812_H2CCMD_P2P_PS_OFFLOAD_ROLE(__pH2CCmd, __Value)			SET_BITS_TO_LE_1BYTE(__pH2CCmd, 1, 1, __Value)
+#define SET_8812_H2CCMD_P2P_PS_OFFLOAD_CTWINDOW_EN(__pH2CCmd, __Value)		SET_BITS_TO_LE_1BYTE(__pH2CCmd, 2, 1, __Value)
+#define SET_8812_H2CCMD_P2P_PS_OFFLOAD_NOA0_EN(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 3, 1, __Value)
+#define SET_8812_H2CCMD_P2P_PS_OFFLOAD_NOA1_EN(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 4, 1, __Value)
+#define SET_8812_H2CCMD_P2P_PS_OFFLOAD_ALLSTASLEEP(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 5, 1, __Value)
+#define SET_8812_H2CCMD_P2P_PS_OFFLOAD_DISCOVERY(__pH2CCmd, __Value)	SET_BITS_TO_LE_1BYTE(__pH2CCmd, 6, 1, __Value)
+
+
+void rtl8812au_set_fw_pwrmode_cmd(struct rtl_priv *rtlpriv, uint8_t PSMode);
+int32_t rtl8821au_download_fw(struct rtl_priv *rtlpriv, bool bUsedWoWLANFw);
+void rtl8821au_firmware_selfreset(struct rtl_priv *rtlpriv);
+void rtl8821au_fill_h2c_cmd(struct rtl_priv *rtlpriv, u8 element_id, 
+			   u32 cmd_len, u8 *cmdbuffer);
+uint8_t rtl8812_set_rssi_cmd(struct rtl_priv *rtlpriv, uint8_t *param);
+void rtl8821au_set_fw_joinbss_report_cmd(struct rtl_priv *rtlpriv, uint8_t mstatus);
+
+#define FW_8821AU_START_ADDRESS    	0x1000
+#define FW_8821AU_END_ADDRESS         	0x5FFF
+#define FW_SIZE_8812			0x8000 // Compatible with RTL8723 Maximal RAM code size 24K.   modified to 32k, TO compatible with 92d maximal fw size 32k
+
+//
+// This structure must be cared byte-ordering
+//
+// Added by tynli. 2009.12.04.
+#define IS_FW_HEADER_EXIST_8812(_pFwHdr)	((GET_FIRMWARE_HDR_SIGNATURE_8812(_pFwHdr) &0xFFF0) ==  0x9500)
+
+#define IS_FW_HEADER_EXIST_8821(_pFwHdr)	((GET_FIRMWARE_HDR_SIGNATURE_8812(_pFwHdr) &0xFFF0) ==  0x2100)
+//=====================================================
+//					Firmware Header(8-byte alinment required)
+//=====================================================
+//--- LONG WORD 0 ----
+#define GET_FIRMWARE_HDR_SIGNATURE_8812(__FwHdr)		LE_BITS_TO_4BYTE(__FwHdr, 0, 16) // 92C0: test chip; 92C, 88C0: test chip; 88C1: MP A-cut; 92C1: MP A-cut
+#define GET_FIRMWARE_HDR_CATEGORY_8812(__FwHdr)		LE_BITS_TO_4BYTE(__FwHdr, 16, 8) // AP/NIC and USB/PCI
+#define GET_FIRMWARE_HDR_FUNCTION_8812(__FwHdr)		LE_BITS_TO_4BYTE(__FwHdr, 24, 8) // Reserved for different FW function indcation, for further use when driver needs to download different FW in different conditions
+#define GET_FIRMWARE_HDR_VERSION_8812(__FwHdr)		LE_BITS_TO_4BYTE(__FwHdr+4, 0, 16)// FW Version
+#define GET_FIRMWARE_HDR_SUB_VER_8812(__FwHdr)		LE_BITS_TO_4BYTE(__FwHdr+4, 16, 8) // FW Subversion, default 0x00
+#define GET_FIRMWARE_HDR_RSVD1_8812(__FwHdr)			LE_BITS_TO_4BYTE(__FwHdr+4, 24, 8)
+
+//--- LONG WORD 1 ----
+#define GET_FIRMWARE_HDR_MONTH_8812(__FwHdr)			LE_BITS_TO_4BYTE(__FwHdr+8, 0, 8) // Release time Month field
+#define GET_FIRMWARE_HDR_DATE_8812(__FwHdr)			LE_BITS_TO_4BYTE(__FwHdr+8, 8, 8) // Release time Date field
+#define GET_FIRMWARE_HDR_HOUR_8812(__FwHdr)			LE_BITS_TO_4BYTE(__FwHdr+8, 16, 8)// Release time Hour field
+#define GET_FIRMWARE_HDR_MINUTE_8812(__FwHdr)		LE_BITS_TO_4BYTE(__FwHdr+8, 24, 8)// Release time Minute field
+#define GET_FIRMWARE_HDR_ROMCODE_SIZE_8812(__FwHdr)	LE_BITS_TO_4BYTE(__FwHdr+12, 0, 16)// The size of RAM code
+#define GET_FIRMWARE_HDR_RSVD2_8812(__FwHdr)			LE_BITS_TO_4BYTE(__FwHdr+12, 16, 16)
+
+//--- LONG WORD 2 ----
+#define GET_FIRMWARE_HDR_SVN_IDX_8812(__FwHdr)		LE_BITS_TO_4BYTE(__FwHdr+16, 0, 32)// The SVN entry index
+#define GET_FIRMWARE_HDR_RSVD3_8812(__FwHdr)			LE_BITS_TO_4BYTE(__FwHdr+20, 0, 32)
+
+//--- LONG WORD 3 ----
+#define GET_FIRMWARE_HDR_RSVD4_8812(__FwHdr)			LE_BITS_TO_4BYTE(__FwHdr+24, 0, 32)
+#define GET_FIRMWARE_HDR_RSVD5_8812(__FwHdr)			LE_BITS_TO_4BYTE(__FwHdr+28, 0, 32)
+
+
+#endif
diff -Naur linux-4.9/drivers/staging/rtl8821au/rtl8821au/hw.c linux-4.9.8821au/drivers/staging/rtl8821au/rtl8821au/hw.c
--- linux-4.9/drivers/staging/rtl8821au/rtl8821au/hw.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/rtl8821au/hw.c	2016-12-11 19:48:25.180311687 -0600
@@ -0,0 +1,2846 @@
+#ifdef CONFIG_RTLWIFI
+
+#include <../drivers/net/wireless/realtek/rtlwifi/wifi.h>
+#include <../drivers/net/wireless/realtek/rtlwifi/core.h>
+#include <../drivers/net/wireless/realtek/rtlwifi/use.h>
+#include <../drivers/net/wireless/realtek/rtlwifi/efuse.h>
+#include <../drivers/net/wireless/realtek/rtlwifi/base.h>
+
+#else
+
+#include <drv_types.h>
+#include "hw.h"
+#include "reg.h"
+#include "fw.h"
+#include "rf.h"
+#include "phy.h"
+#include "def.h"
+#include "dm.h"
+#include "../cam.h"
+#include <usb_ops.h>
+
+#endif
+
+void rtl8821au_init_beacon_parameters(struct rtl_priv *rtlpriv)
+{
+	struct rtl_usb *rtlusb = rtl_usbdev(rtlpriv);
+	 struct _rtw_hal	*pHalData = GET_HAL_DATA(rtlpriv);
+
+	rtl_write_word(rtlpriv, REG_BCN_CTRL, 0x1010);
+
+	/* TODO: Remove these magic number */
+	rtl_write_word(rtlpriv, REG_TBTT_PROHIBIT, 0x6404);		/* ms */
+	rtl_write_byte(rtlpriv, REG_DRVERLYINT, DRIVER_EARLY_INT_TIME_8812);	/* 5ms */
+	rtl_write_byte(rtlpriv, REG_BCNDMATIM, BCN_DMA_ATIME_INT_TIME_8812); 	/* 2ms */
+
+	/*
+	 *  Suggested by designer timchen. Change beacon AIFS to the largest number
+	 *  beacause test chip does not contension before sending beacon. by tynli. 2009.11.03
+	 */
+	rtl_write_word(rtlpriv, REG_BCNTCFG, 0x660F);
+
+	rtlusb->reg_bcn_ctrl_val = rtl_read_byte(rtlpriv, REG_BCN_CTRL);
+	pHalData->RegTxPause = rtl_read_byte(rtlpriv, REG_TXPAUSE);
+	pHalData->RegFwHwTxQCtrl = rtl_read_byte(rtlpriv, REG_FWHW_TXQ_CTRL+2);
+	pHalData->RegReg542 = rtl_read_byte(rtlpriv, REG_TBTT_PROHIBIT+2);
+	pHalData->RegCR_1 = rtl_read_byte(rtlpriv, REG_CR+1);
+}
+
+static void _rtl8821au_stop_tx_beacon(struct rtl_priv *rtlpriv)
+{
+	 struct _rtw_hal *pHalData = GET_HAL_DATA(rtlpriv);
+
+	rtl_write_byte(rtlpriv, REG_FWHW_TXQ_CTRL+2, (pHalData->RegFwHwTxQCtrl) & (~BIT(6)));
+	pHalData->RegFwHwTxQCtrl &= (~BIT(6));
+	rtl_write_byte(rtlpriv, REG_TBTT_PROHIBIT+1, 0x64);
+	pHalData->RegReg542 &= ~(BIT(0));
+	rtl_write_byte(rtlpriv, REG_TBTT_PROHIBIT+2, pHalData->RegReg542);
+
+	 /* todo: CheckFwRsvdPageContent(rtlpriv);  // 2010.06.23. Added by tynli. */
+}
+
+static void  _rtl8821au_resume_tx_beacon(struct rtl_priv *rtlpriv)
+{
+	 struct _rtw_hal *pHalData = GET_HAL_DATA(rtlpriv);
+
+	/*
+	 * 2010.03.01. Marked by tynli. No need to call workitem beacause we record the value
+	 * which should be read from register to a global variable.
+	 */
+
+	rtl_write_byte(rtlpriv, REG_FWHW_TXQ_CTRL+2, (pHalData->RegFwHwTxQCtrl) | BIT(6));
+	pHalData->RegFwHwTxQCtrl |= BIT(6);
+	rtl_write_byte(rtlpriv, REG_TBTT_PROHIBIT+1, 0xff);
+	pHalData->RegReg542 |= BIT(0);
+	rtl_write_byte(rtlpriv, REG_TBTT_PROHIBIT+2, pHalData->RegReg542);
+}
+
+static void _BeaconFunctionEnable(struct rtl_priv *rtlpriv, bool Enable,
+	bool	Linked)
+{
+	rtl_write_byte(rtlpriv, REG_BCN_CTRL, (BIT(4) | BIT(3) | BIT(1)));
+	/*
+	 * SetBcnCtrlReg(rtlpriv, (BIT(4) | BIT(3) | BIT(1)), 0x00);
+	 * RT_TRACE(COMP_BEACON, DBG_LOUD, ("_BeaconFunctionEnable 0x550 0x%x\n", rtl_read_byte(rtlpriv, 0x550)));
+	 */
+
+	rtl_write_byte(rtlpriv, REG_RD_CTRL+1, 0x6F);
+}
+
+void rtl8821au_set_beacon_related_registers(struct rtl_priv *rtlpriv)
+{
+	struct rtl_mac *mac = rtl_mac(rtlpriv);
+	uint32_t	value32;
+	/* reset TSF, enable update TSF, correcting TSF On Beacon */
+
+	/*
+	 * REG_BCN_INTERVAL
+	 * REG_BCNDMATIM
+	 * REG_ATIMWND
+	 * REG_TBTT_PROHIBIT
+	 * REG_DRVERLYINT
+	 * REG_BCN_MAX_ERR
+	 * REG_BCNTCFG //(0x510)
+	 * REG_DUAL_TSF_RST
+	 * REG_BCN_CTRL //(0x550)
+	 */
+
+	/* BCN interval */
+	rtl_write_word(rtlpriv, REG_BCN_INTERVAL, mac->beacon_interval);
+	rtl_write_byte(rtlpriv, REG_ATIMWND, 0x02);	/* 2ms */
+
+	rtl8821au_init_beacon_parameters(rtlpriv);
+
+	rtl_write_byte(rtlpriv, REG_SLOT, 0x09);
+
+	value32 = rtl_read_dword(rtlpriv, REG_TCR);
+	value32 &= ~TSFRST;
+	rtl_write_dword(rtlpriv,  REG_TCR, value32);
+
+	value32 |= TSFRST;
+	rtl_write_dword(rtlpriv, REG_TCR, value32);
+
+	/* NOTE: Fix test chip's bug (about contention windows's randomness) */
+	rtl_write_byte(rtlpriv,  REG_RXTSF_OFFSET_CCK, 0x50);
+	rtl_write_byte(rtlpriv, REG_RXTSF_OFFSET_OFDM, 0x50);
+
+	_BeaconFunctionEnable(rtlpriv, true, true);
+
+	_rtl8821au_resume_tx_beacon(rtlpriv);
+
+	/* rtl_write_byte(rtlpriv, 0x422, rtl_read_byte(rtlpriv, 0x422)|BIT(6)); */
+
+	/* rtl_write_byte(rtlpriv, 0x541, 0xff); */
+
+	/* rtl_write_byte(rtlpriv, 0x542, rtl_read_byte(rtlpriv, 0x541)|BIT(0)); */
+
+	rtl_write_byte(rtlpriv, REG_BCN_CTRL, rtl_read_byte(rtlpriv, REG_BCN_CTRL)|BIT(1));
+
+}
+
+int rtl8821au_set_network_type(struct rtl_priv *rtlpriv, uint8_t mode)
+{
+	struct rtl_hal *rtlhal = rtl_hal(rtlpriv);
+	uint8_t	val8;
+
+	{
+		/* disable Port0 TSF update */
+		rtl_write_byte(rtlpriv, REG_BCN_CTRL, rtl_read_byte(rtlpriv, REG_BCN_CTRL)|DIS_TSF_UDT);
+
+		/*  set net_type */
+		val8 = rtl_read_byte(rtlpriv, MSR)&0x0c;
+		val8 |= mode;
+		rtl_write_byte(rtlpriv, MSR, val8);
+
+		RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD, "%s()-%d mode = %d\n", __FUNCTION__, __LINE__, mode);
+
+		if ((mode == _HW_STATE_STATION_) || (mode == _HW_STATE_NOLINK_)) {
+			_rtl8821au_stop_tx_beacon(rtlpriv);
+
+			rtl_write_byte(rtlpriv, REG_BCN_CTRL, 0x19);		/* disable atim wnd */
+			/* rtl_write_byte(rtlpriv,REG_BCN_CTRL, 0x18); */
+		} else if ((mode == _HW_STATE_ADHOC_) /*|| (mode == _HW_STATE_AP_)*/ ) {
+			_rtl8821au_resume_tx_beacon(rtlpriv);
+			rtl_write_byte(rtlpriv, REG_BCN_CTRL, 0x1a);
+		} else if (mode == _HW_STATE_AP_) {
+			_rtl8821au_resume_tx_beacon(rtlpriv);
+
+			rtl_write_byte(rtlpriv, REG_BCN_CTRL, 0x12);
+
+			/* Set RCR */
+			rtl_write_dword(rtlpriv, REG_RCR, 0x7000208e);	/* CBSSID_DATA must set to 0,reject ICV_ERR packet */
+			/* enable to rx data frame */
+			rtl_write_word(rtlpriv, REG_RXFLTMAP2, 0xFFFF);
+			/* enable to rx ps-poll */
+			rtl_write_word(rtlpriv, REG_RXFLTMAP1, 0x0400);
+
+			/* Beacon Control related register for first time */
+			rtl_write_byte(rtlpriv, REG_BCNDMATIM, 0x02); /* 2ms */
+
+			/* rtl_write_byte(rtlpriv, REG_BCN_MAX_ERR, 0xFF); */
+			rtl_write_byte(rtlpriv, REG_ATIMWND, 0x0a); 	/* 10ms */
+			rtl_write_word(rtlpriv, REG_BCNTCFG, 0x00);
+			rtl_write_word(rtlpriv, REG_TBTT_PROHIBIT, 0xff04);
+			rtl_write_word(rtlpriv, REG_TSFTR_SYN_OFFSET, 0x7fff);	/* +32767 (~32ms) */
+
+			/* reset TSF */
+			rtl_write_byte(rtlpriv, REG_DUAL_TSF_RST, BIT(0));
+
+			/*
+			 * enable BCN0 Function for if1
+			 * don't enable update TSF0 for if1 (due to TSF update when beacon/probe rsp are received)
+			 */
+			rtl_write_byte(rtlpriv, REG_BCN_CTRL, (DIS_TSF_UDT|EN_BCN_FUNCTION | EN_TXBCN_RPT|DIS_BCNQ_SUB));
+
+			if (IS_HARDWARE_TYPE_8821(rtlhal)) {
+				/*  select BCN on port 0 */
+				rtl_write_byte(rtlpriv, REG_CCK_CHECK_8812,	rtl_read_byte(rtlpriv, REG_CCK_CHECK_8812)&(~BIT(5)));
+			}
+
+
+			/* dis BCN1 ATIM  WND if if2 is station */
+			rtl_write_byte(rtlpriv, REG_BCN_CTRL_1, rtl_read_byte(rtlpriv, REG_BCN_CTRL_1)|DIS_ATIM);
+		}
+	}
+	return 0;
+}
+
+static void hw_var_set_bcn_func(struct rtl_priv *rtlpriv, uint8_t variable, uint8_t *val)
+{
+	if (*((uint8_t *) val))
+		rtl_write_byte(rtlpriv, REG_BCN_CTRL, (EN_BCN_FUNCTION | EN_TXBCN_RPT));
+	else {
+		u8 tmp;
+
+		tmp = rtl_read_byte(rtlpriv, REG_BCN_CTRL);
+		tmp &= (~(EN_BCN_FUNCTION | EN_TXBCN_RPT));
+		rtl_write_byte(rtlpriv, REG_BCN_CTRL, tmp);
+	}
+}
+
+static void hw_var_set_mlme_sitesurvey(struct rtl_priv *rtlpriv, uint8_t variable, uint8_t *val)
+{
+	uint32_t value_rcr, rcr_clear_bit, reg_bcn_ctl;
+	u16 value_rxfltmap2;
+	 struct _rtw_hal *pHalData = GET_HAL_DATA(rtlpriv);
+	struct mlme_priv *pmlmepriv = &(rtlpriv->mlmepriv);
+
+		reg_bcn_ctl = REG_BCN_CTRL;
+
+	rcr_clear_bit = RCR_CBSSID_BCN;
+
+	/* config RCR to receive different BSSID & not to receive data frame */
+	value_rxfltmap2 = 0;
+
+	if ((check_fwstate(pmlmepriv, WIFI_AP_STATE) == true)) {
+		rcr_clear_bit = RCR_CBSSID_BCN;
+	}
+
+	value_rcr = rtl_read_dword(rtlpriv, REG_RCR);
+
+	if (*((uint8_t *) val)) {
+		/* under sitesurvey */
+
+		value_rcr &= ~(rcr_clear_bit);
+		rtl_write_dword(rtlpriv, REG_RCR, value_rcr);
+
+		rtl_write_word(rtlpriv, REG_RXFLTMAP2, value_rxfltmap2);
+
+		if (check_fwstate(pmlmepriv, WIFI_STATION_STATE | WIFI_ADHOC_STATE | WIFI_ADHOC_MASTER_STATE)) {
+			/* disable update TSF */
+			rtl_write_byte(rtlpriv, reg_bcn_ctl, rtl_read_byte(rtlpriv, reg_bcn_ctl)|DIS_TSF_UDT);
+		}
+
+		/* Save orignal RRSR setting. */
+		pHalData->RegRRSR = rtl_read_word(rtlpriv, REG_RRSR);
+
+	} else {
+		/* sitesurvey done */
+
+		if (check_fwstate(pmlmepriv, (_FW_LINKED | WIFI_AP_STATE))) {
+			/* enable to rx data frame */
+			rtl_write_word(rtlpriv, REG_RXFLTMAP2, 0xFFFF);
+		}
+
+		if (check_fwstate(pmlmepriv, WIFI_STATION_STATE | WIFI_ADHOC_STATE | WIFI_ADHOC_MASTER_STATE)) {
+			/* enable update TSF */
+			rtl_write_byte(rtlpriv, reg_bcn_ctl, rtl_read_byte(rtlpriv, reg_bcn_ctl)&(~(DIS_TSF_UDT)));
+		}
+
+		value_rcr |= rcr_clear_bit;
+		rtl_write_dword(rtlpriv, REG_RCR, value_rcr);
+
+		/* Restore orignal RRSR setting. */
+		rtl_write_word(rtlpriv, REG_RRSR, pHalData->RegRRSR);
+
+	}
+}
+
+static void Hal_PatchwithJaguar_8812(struct rtl_priv *rtlpriv, RT_MEDIA_STATUS	MediaStatus)
+{
+	struct mlme_ext_priv	*pmlmeext = &(rtlpriv->mlmeextpriv);
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	if ((MediaStatus == RT_MEDIA_CONNECT)
+	  && (pmlmeinfo->assoc_AP_vendor == HT_IOT_PEER_REALTEK_JAGUAR_BCUTAP)) {
+		rtl_write_byte(rtlpriv, rVhtlen_Use_Lsig_Jaguar, 0x1);
+		rtl_write_byte(rtlpriv, REG_TCR+3, BIT(2));
+	} else {
+		rtl_write_byte(rtlpriv, rVhtlen_Use_Lsig_Jaguar, 0x3F);
+		rtl_write_byte(rtlpriv, REG_TCR+3, BIT(0)|BIT(1)|BIT(2));
+	}
+
+
+	if ((MediaStatus == RT_MEDIA_CONNECT)
+	   && ((pmlmeinfo->assoc_AP_vendor == HT_IOT_PEER_REALTEK_JAGUAR_BCUTAP)
+	      || (pmlmeinfo->assoc_AP_vendor == HT_IOT_PEER_REALTEK_JAGUAR_CCUTAP))) {
+		rtlpriv->phy.reg_837 |= BIT(2);
+		rtl_write_byte(rtlpriv, rBWIndication_Jaguar+3, rtlpriv->phy.reg_837);
+	} else {
+		rtlpriv->phy.reg_837 &= (~BIT(2));
+		rtl_write_byte(rtlpriv, rBWIndication_Jaguar+3, rtlpriv->phy.reg_837);
+	}
+}
+
+void rtl8821au_set_hw_reg(struct rtl_priv *rtlpriv, u8 variable, u8 *pval)
+{
+	struct rtl_phy *rtlphy = &(rtlpriv->phy);
+	struct rtl_mac *mac = rtl_mac(rtlpriv);
+	struct rtl_hal *rtlhal = rtl_hal(rtlpriv);
+	struct rtl_efuse *rtlefuse =  rtl_efuse(rtlpriv);
+	struct _rtw_hal *pHalData;
+	struct dm_priv *pdmpriv;
+	struct _rtw_dm *podmpriv;
+	uint8_t val8;
+	u16 val16;
+	uint32_t val32;
+	u8 idx;
+
+	pHalData = GET_HAL_DATA(rtlpriv);
+	pdmpriv = &pHalData->dmpriv;
+	podmpriv = &pHalData->odmpriv;
+
+	switch (variable) {
+	case HW_VAR_ETHER_ADDR:
+		for (idx = 0 ; idx < 6; idx++) {
+			rtl_write_byte(rtlpriv, (REG_MACID + idx), pval[idx]);
+		}
+		break;
+
+	/* ULLI : old Hw vars */
+
+
+
+	case HW_VAR_RXDMA_AGG_PG_TH:
+		{
+			/*uint8_t	threshold = *((uint8_t *)val);
+			if ( threshold == 0)
+			{
+				threshold = pHalData->UsbRxAggPageCount;
+			}
+			rtl_write_byte(rtlpriv, REG_RXDMA_AGG_PG_TH, threshold);*/
+		}
+		break;
+	case HW_VAR_MEDIA_STATUS:
+		val8 = rtl_read_byte(rtlpriv, MSR) & 0x0c;
+		val8 |= *pval;
+		rtl_write_byte(rtlpriv, MSR, val8);
+		break;
+
+	case HW_VAR_MEDIA_STATUS1:
+		val8 = rtl_read_byte(rtlpriv, MSR) & 0x03;
+		val8 |= *pval << 2;
+		rtl_write_byte(rtlpriv, MSR, val8);
+		break;
+
+	case HW_VAR_BSSID:
+		for (idx = 0 ; idx < 6; idx++) {
+			rtl_write_byte(rtlpriv, (REG_BSSID + idx), pval[idx]);
+		}
+		break;
+
+	case HW_VAR_BASIC_RATE:
+		{
+			u16 BrateCfg = 0;
+			uint8_t RateIndex = 0;
+
+			/*
+			 * 2007.01.16, by Emily
+			 * Select RRSR (in Legacy-OFDM and CCK)
+			 * For 8190, we select only 24M, 12M, 6M, 11M, 5.5M, 2M, and 1M from the Basic rate.
+			 * We do not use other rates.
+			 */
+			HalSetBrateCfg(rtlpriv, pval, &BrateCfg);
+
+			if (rtlhal->current_bandtype == BAND_ON_2_4G) {
+				/*
+				 * CCK 2M ACK should be disabled for some BCM and Atheros AP IOT
+				 * because CCK 2M has poor TXEVM
+				 * CCK 5.5M & 11M ACK should be enabled for better performance
+				 */
+				BrateCfg = (BrateCfg | 0xd) & 0x15d;
+				BrateCfg |= 0x01; /* default enable 1M ACK rate */
+			} else { /* 5G */
+				BrateCfg |= 0x10; /* default enable 6M ACK rate */
+			}
+			/*
+			 * DBG_8192C("HW_VAR_BASIC_RATE: BrateCfg(%#x)\n", BrateCfg);
+			 */
+
+			/* Set RRSR rate table. */
+			rtl_write_byte(rtlpriv, REG_RRSR, BrateCfg&0xff);
+			rtl_write_byte(rtlpriv, REG_RRSR+1, (BrateCfg>>8)&0xff);
+			rtl_write_byte(rtlpriv, REG_RRSR+2, rtl_read_byte(rtlpriv, REG_RRSR+2)&0xf0);
+		}
+		break;
+
+	case HW_VAR_TXPAUSE:
+		rtl_write_byte(rtlpriv, REG_TXPAUSE, *pval);
+		break;
+
+	case HW_VAR_BCN_FUNC:
+		hw_var_set_bcn_func(rtlpriv, variable, pval);
+		break;
+
+	case HW_VAR_CORRECT_TSF:
+		{
+			u64	tsf;
+			struct mlme_ext_priv	*pmlmeext = &rtlpriv->mlmeextpriv;
+			struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+			/*
+			 * tsf = pmlmeext->TSFValue - ((u32)pmlmeext->TSFValue % (pmlmeinfo->bcn_interval*1024)) -1024; //us
+			 */
+			tsf = pmlmeext->TSFValue - rtw_modular64(pmlmeext->TSFValue, (mac->beacon_interval*1024)) - 1024; /* us */
+
+			if (((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE)
+			   || ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE)) {
+				/*
+				 * pHalData->RegTxPause |= STOP_BCNQ;BIT(6)
+				 * rtl_write_byte(rtlpriv, REG_TXPAUSE, (rtl_read_byte(rtlpriv, REG_TXPAUSE)|BIT(6)));
+				 */
+				_rtl8821au_stop_tx_beacon(rtlpriv);
+			}
+
+			/* disable related TSF function */
+			rtl_write_byte(rtlpriv, REG_BCN_CTRL, rtl_read_byte(rtlpriv, REG_BCN_CTRL)&(~BIT(3)));
+
+			rtl_write_dword(rtlpriv, REG_TSFTR, tsf);
+			rtl_write_dword(rtlpriv, REG_TSFTR+4, tsf>>32);
+
+			/* enable related TSF function */
+			rtl_write_byte(rtlpriv, REG_BCN_CTRL, rtl_read_byte(rtlpriv, REG_BCN_CTRL)|BIT(3));
+
+
+			if (((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE)
+			   || ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE)) {
+				/*
+				 * pHalData->RegTxPause  &= (~STOP_BCNQ);
+				 * rtl_write_byte(rtlpriv, REG_TXPAUSE, (rtl_read_byte(rtlpriv, REG_TXPAUSE)&(~BIT(6))));
+				 */
+				_rtl8821au_resume_tx_beacon(rtlpriv);
+			}
+		}
+		break;
+
+	case HW_VAR_CHECK_BSSID:
+		val32 = rtl_read_dword(rtlpriv, REG_RCR);
+		if (*pval)
+			val32 |= RCR_CBSSID_DATA|RCR_CBSSID_BCN;
+		else
+			val32 &= ~(RCR_CBSSID_DATA|RCR_CBSSID_BCN);
+		rtl_write_dword(rtlpriv, REG_RCR, val32);
+		break;
+
+	case HW_VAR_MLME_DISCONNECT:
+		{
+			/* Set RCR to not to receive data frame when NO LINK state
+			 * val32 = rtl_read_dword(rtlpriv, REG_RCR);
+			 * val32 &= ~RCR_ADF;
+			 * rtl_write_dword(rtlpriv, REG_RCR, val32);
+			 */
+
+			 /* reject all data frames */
+			rtl_write_word(rtlpriv, REG_RXFLTMAP2, 0x00);
+
+			/* reset TSF */
+			val8 = BIT(0) | BIT(1);
+			rtl_write_byte(rtlpriv, REG_DUAL_TSF_RST, val8);
+
+			/* disable update TSF */
+			val8 = rtl_read_byte(rtlpriv, REG_BCN_CTRL);
+			val8 |= BIT(4);
+			rtl_write_byte(rtlpriv, REG_BCN_CTRL, val8);
+		}
+		break;
+
+	case HW_VAR_MLME_SITESURVEY:
+		hw_var_set_mlme_sitesurvey(rtlpriv, variable,  pval);
+
+		break;
+
+	case HW_VAR_MLME_JOIN:
+		{
+			uint8_t RetryLimit = 0x30;
+			uint8_t type = *(uint8_t *)pval;
+
+			struct mlme_priv *pmlmepriv = &rtlpriv->mlmepriv;
+
+			if (type == 0) { 	/* prepare to join  */
+				/*
+				 * enable to rx data frame.Accept all data frame
+				 * rtl_write_dword(rtlpriv, REG_RCR, rtl_read_dword(rtlpriv, REG_RCR)|RCR_ADF);
+				 */
+				rtl_write_word(rtlpriv, REG_RXFLTMAP2, 0xFFFF);
+
+				val32 = rtl_read_dword(rtlpriv, REG_RCR);
+				if (rtlpriv->in_cta_test)
+					val32 &= ~(RCR_CBSSID_DATA | RCR_CBSSID_BCN);/* | RCR_ADF */
+				else
+					val32 |= RCR_CBSSID_DATA|RCR_CBSSID_BCN;
+				rtl_write_dword(rtlpriv, REG_RCR, val32);
+
+				if (check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true) {
+					/* ULLI removed
+					 * RetryLimit = (pEEPROM->CustomerID == RT_CID_CCX) ? 7 : 48;
+					 */
+
+					RetryLimit = 48;
+				} else { /* Ad-hoc Mode */
+					RetryLimit = 0x7;
+				}
+
+				rtlphy->need_iqk = true;
+			} else if (type == 1) { /* joinbss_event call back when join res < 0  */
+
+				rtl_write_word(rtlpriv, REG_RXFLTMAP2, 0x00);
+			} else if (type == 2) { /* sta add event call back */
+				/* enable update TSF */
+				val8 = rtl_read_byte(rtlpriv, REG_BCN_CTRL);
+				val8 &= ~BIT(4);
+				rtl_write_byte(rtlpriv, REG_BCN_CTRL, val8);
+
+				if (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE)) {
+					RetryLimit = 0x7;
+				}
+			}
+
+			val16 = RetryLimit << RETRY_LIMIT_SHORT_SHIFT | RetryLimit << RETRY_LIMIT_LONG_SHIFT;
+			rtl_write_word(rtlpriv, REG_RL, val16);
+		}
+
+		break;
+
+	case HW_VAR_ON_RCR_AM:
+		val32 = rtl_read_dword(rtlpriv, REG_RCR);
+		val32 |= RCR_AM;
+		rtl_write_dword(rtlpriv, REG_RCR, val32);
+		RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD, "%s, %d, RCR= %x\n", __FUNCTION__, __LINE__, rtl_read_dword(rtlpriv, REG_RCR));
+		break;
+
+	case HW_VAR_OFF_RCR_AM:
+		val32 = rtl_read_dword(rtlpriv, REG_RCR);
+		val32 &= ~RCR_AM;
+		rtl_write_dword(rtlpriv, REG_RCR, val32);
+		RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,  "%s, %d, RCR= %x\n", __FUNCTION__, __LINE__, rtl_read_dword(rtlpriv, REG_RCR));
+		break;
+
+	case HW_VAR_BEACON_INTERVAL:
+		rtl_write_word(rtlpriv, REG_BCN_INTERVAL, *(u16 *)pval);
+		break;
+
+	case HW_VAR_SLOT_TIME:
+		rtl_write_byte(rtlpriv, REG_SLOT, *pval);
+		break;
+
+	case HW_VAR_RESP_SIFS:
+		/*
+		 * SIFS_Timer = 0x0a0a0808;
+		 * RESP_SIFS for CCK
+		 */
+		rtl_write_byte(rtlpriv, REG_RESP_SIFS_CCK, pval[0]); 	/* SIFS_T2T_CCK (0x08) */
+		rtl_write_byte(rtlpriv, REG_RESP_SIFS_CCK+1, pval[1]); 	/* SIFS_R2T_CCK(0x08) */
+		/*  RESP_SIFS for OFDM */
+		rtl_write_byte(rtlpriv, REG_RESP_SIFS_OFDM, pval[2]); 	/* SIFS_T2T_OFDM (0x0a) */
+		rtl_write_byte(rtlpriv, REG_RESP_SIFS_OFDM+1, pval[3]); 	/* SIFS_R2T_OFDM(0x0a) */
+		break;
+
+	case HW_VAR_ACK_PREAMBLE:
+		{
+			uint8_t bShortPreamble = *pval;
+
+			/*  Joseph marked out for Netgear 3500 TKIP channel 7 issue.(Temporarily) */
+			val8 = (rtlpriv->mac80211.cur_40_prime_sc) << 5;
+			if (bShortPreamble)
+				val8 |= 0x80;
+			rtl_write_byte(rtlpriv, REG_RRSR+2, val8);
+		}
+		break;
+
+	case HW_VAR_SEC_CFG:
+		val8 = *pval;
+		rtl_write_byte(rtlpriv, REG_SECCFG, val8);
+		break;
+
+	case HW_VAR_CAM_WRITE:
+		{
+			uint32_t cmd;
+			uint32_t *cam_val = (u32 *)pval;
+
+			rtl_write_dword(rtlpriv, WCAMI, cam_val[0]);
+
+			cmd = CAM_POLLINIG | CAM_WRITE | cam_val[1];
+			rtl_write_dword(rtlpriv, RWCAM, cmd);
+		}
+		break;
+
+	case HW_VAR_CAM_READ:
+		break;
+
+	case HW_VAR_AC_PARAM_VO:
+		rtl_write_dword(rtlpriv, REG_EDCA_VO_PARAM, *(u32 *)pval);
+		break;
+
+	case HW_VAR_AC_PARAM_VI:
+		rtl_write_dword(rtlpriv, REG_EDCA_VI_PARAM, *(u32 *)pval);
+		break;
+
+	case HW_VAR_AC_PARAM_BE:
+		pHalData->AcParam_BE = *(u32 *)pval;
+		rtl_write_dword(rtlpriv, REG_EDCA_BE_PARAM, *(u32 *)pval);
+		break;
+
+	case HW_VAR_AC_PARAM_BK:
+		rtl_write_dword(rtlpriv, REG_EDCA_BK_PARAM, *(u32 *)pval);
+		break;
+
+	case HW_VAR_ACM_CTRL:
+		{
+			uint8_t acm_ctrl;
+			uint8_t AcmCtrl;
+
+			acm_ctrl = *(uint8_t *)pval;
+			AcmCtrl = rtl_read_byte(rtlpriv, REG_ACMHWCTRL);
+
+			if (acm_ctrl > 1)
+				AcmCtrl = AcmCtrl | 0x1;
+
+			if (acm_ctrl & BIT(3))
+				AcmCtrl |= AcmHw_VoqEn;
+			else
+				AcmCtrl &= (~AcmHw_VoqEn);
+
+			if (acm_ctrl & BIT(2))
+				AcmCtrl |= AcmHw_ViqEn;
+			else
+				AcmCtrl &= (~AcmHw_ViqEn);
+
+			if (acm_ctrl & BIT(1))
+				AcmCtrl |= AcmHw_BeqEn;
+			else
+				AcmCtrl &= (~AcmHw_BeqEn);
+
+			RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD, "[HW_VAR_ACM_CTRL] Write 0x%X\n", AcmCtrl);
+			rtl_write_byte(rtlpriv, REG_ACMHWCTRL, AcmCtrl);
+		}
+		break;
+
+	case HW_VAR_AMPDU_MIN_SPACE:
+		pHalData->AMPDUDensity = *(uint8_t *)pval;
+		break;
+
+	case HW_VAR_AMPDU_FACTOR:
+		{
+			uint32_t	AMPDULen = *(uint8_t *)pval;
+
+			if (IS_HARDWARE_TYPE_8812(rtlhal)) {
+				if (AMPDULen < VHT_AGG_SIZE_128K)
+					AMPDULen = (0x2000 << *(uint8_t *)pval) - 1;
+				else
+					AMPDULen = 0x1ffff;
+			} else if (IS_HARDWARE_TYPE_8821(rtlhal)) {
+				if (AMPDULen < HT_AGG_SIZE_64K)
+					AMPDULen = (0x2000 << *(uint8_t *)pval) - 1;
+				else
+					AMPDULen = 0xffff;
+			}
+			AMPDULen |= BIT(31);
+			rtl_write_dword(rtlpriv, REG_AMPDU_MAX_LENGTH_8812, AMPDULen);
+		}
+		break;
+	case HW_VAR_H2C_FW_PWRMODE:
+		{
+			uint8_t psmode = *pval;
+
+			/*
+			 * Forece leave RF low power mode for 1T1R to prevent conficting setting in Fw power
+			 * saving sequence. 2010.06.07. Added by tynli. Suggested by SD3 yschang.
+			 */
+			rtl8812au_set_fw_pwrmode_cmd(rtlpriv, psmode);
+		}
+		break;
+
+	case HW_VAR_H2C_FW_JOINBSSRPT:
+		rtl8821au_set_fw_joinbss_report_cmd(rtlpriv, *pval);
+		break;
+
+	case HW_VAR_INITIAL_GAIN:	/* ULLI not in rtlwifi */
+		{
+			struct dig_t *dm_digtable = &(rtlpriv->dm_digtable);
+			uint32_t rx_gain = *(u32 *)pval;
+
+			if (rx_gain == 0xff) {		/* restore rx gain */
+				rtl8821au_dm_write_dig(rtlpriv, dm_digtable->BackupIGValue);
+			} else {
+				dm_digtable->BackupIGValue = dm_digtable->cur_igvalue;
+				rtl8821au_dm_write_dig(rtlpriv, rx_gain);
+			}
+		}
+		break;
+
+
+#if (RATE_ADAPTIVE_SUPPORT == 1)
+	case HW_VAR_RPT_TIMER_SETTING:
+		{
+			val16 = *(u16 *)pval;
+			ODM_RA_Set_TxRPT_Time(podmpriv, val16);
+		}
+		break;
+#endif
+
+	case HW_VAR_EFUSE_USAGE:
+		rtlefuse->efuse_usedpercentage = *pval;
+		break;
+
+	case HW_VAR_EFUSE_BYTES:
+		rtlefuse->efuse_usedbytes = *(u16 *)pval;
+		break;
+	case HW_VAR_FIFO_CLEARN_UP:
+		{
+			struct pwrctrl_priv *pwrpriv;
+			uint8_t trycnt = 100;
+
+			pwrpriv = &rtlpriv->pwrctrlpriv;
+
+			/* pause tx */
+			rtl_write_byte(rtlpriv, REG_TXPAUSE, 0xff);
+
+			/* keep sn */
+			rtlpriv->xmitpriv.nqos_ssn = rtl_read_word(rtlpriv, REG_NQOS_SEQ);
+
+			{
+				/* RX DMA stop */
+				val32 = rtl_read_dword(rtlpriv, REG_RXPKT_NUM);
+				val32 |= RW_RELEASE_EN;
+				rtl_write_dword(rtlpriv, REG_RXPKT_NUM, val32);
+				do {
+					val32 = rtl_read_dword(rtlpriv, REG_RXPKT_NUM);
+					val32 &= RXDMA_IDLE;
+					if (!val32)
+						break;
+				} while (trycnt--);
+				if (trycnt == 0) {
+					RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD, "[HW_VAR_FIFO_CLEARN_UP] Stop RX DMA failed......\n");
+				}
+
+				/* RQPN Load 0 */
+				rtl_write_word(rtlpriv, REG_RQPN_NPQ, 0x0);
+				rtl_write_dword(rtlpriv, REG_RQPN, 0x80000000);
+				mdelay(10);
+			}
+		}
+		break;
+
+
+#if (RATE_ADAPTIVE_SUPPORT == 1)
+	case HW_VAR_TX_RPT_MAX_MACID:
+		{
+			uint8_t maxMacid = *pval;
+			RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD, "### MacID(%d),Set Max Tx RPT MID(%d)\n", maxMacid, maxMacid+1);
+			rtl_write_byte(rtlpriv, REG_TX_RPT_CTRL+1, maxMacid+1);
+		}
+		break;
+#endif
+
+	case HW_VAR_H2C_MEDIA_STATUS_RPT:
+		{
+			struct mlme_priv *pmlmepriv = &rtlpriv->mlmepriv;
+			RT_MEDIA_STATUS	mstatus = *(u16 *)pval & 0xFF;
+
+			rtl8812_set_FwMediaStatus_cmd(rtlpriv, *(u16 *)pval);
+
+			if (check_fwstate(pmlmepriv, WIFI_STATION_STATE))
+				Hal_PatchwithJaguar_8812(rtlpriv, mstatus);
+		}
+		break;
+
+	case HW_VAR_NAV_UPPER:
+		{
+			uint32_t usNavUpper = *((u32 *)pval);
+
+			if (usNavUpper > HAL_NAV_UPPER_UNIT * 0xFF) {
+				RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD, "%s: [HW_VAR_NAV_UPPER] set value(0x%08X us) is larger than (%d * 0xFF)!\n",
+					__FUNCTION__, usNavUpper, HAL_NAV_UPPER_UNIT);
+				break;
+			}
+
+			/*
+			 *  The value of ((usNavUpper + HAL_NAV_UPPER_UNIT - 1) / HAL_NAV_UPPER_UNIT)
+			 * is getting the upper integer.
+			 */
+			usNavUpper = (usNavUpper + HAL_NAV_UPPER_UNIT - 1) / HAL_NAV_UPPER_UNIT;
+			rtl_write_byte(rtlpriv, REG_NAV_UPPER, (uint8_t)usNavUpper);
+		}
+		break;
+
+	case HW_VAR_BCN_VALID:
+		{
+			/*
+			 * BCN_VALID, BIT(16) of REG_TDECTRL = BIT(0) of REG_TDECTRL+2, write 1 to clear, Clear by sw
+			 */
+			val8 = rtl_read_byte(rtlpriv, REG_TDECTRL+2);
+			val8 |= BIT(0);
+			rtl_write_byte(rtlpriv, REG_TDECTRL+2, val8);
+		}
+		break;
+
+	case HW_VAR_DL_BCN_SEL:
+		{
+			/* SW_BCN_SEL - Port0 */
+			val8 = rtl_read_byte(rtlpriv, REG_TDECTRL1_8812+2);
+			val8 &= ~BIT(4);
+			rtl_write_byte(rtlpriv, REG_TDECTRL1_8812+2, val8);
+		}
+		break;
+
+	case HW_VAR_WIRELESS_MODE:
+		{
+			uint8_t	R2T_SIFS = 0, SIFS_Timer = 0;
+			uint8_t	wireless_mode = *pval;
+
+			if ((wireless_mode == WIRELESS_11BG) || (wireless_mode == WIRELESS_11G))
+				SIFS_Timer = 0xa;
+			else
+				SIFS_Timer = 0xe;
+
+			/* SIFS for OFDM Data ACK */
+			rtl_write_byte(rtlpriv, REG_SIFS_CTX+1, SIFS_Timer);
+			/* SIFS for OFDM consecutive tx like CTS data! */
+			rtl_write_byte(rtlpriv, REG_SIFS_TRX+1, SIFS_Timer);
+
+			rtl_write_byte(rtlpriv, REG_SPEC_SIFS+1, SIFS_Timer);
+			rtl_write_byte(rtlpriv, REG_MAC_SPEC_SIFS+1, SIFS_Timer);
+
+			/* 20100719 Joseph: Revise SIFS setting due to Hardware register definition change. */
+			rtl_write_byte(rtlpriv, REG_RESP_SIFS_OFDM+1, SIFS_Timer);
+			rtl_write_byte(rtlpriv, REG_RESP_SIFS_OFDM, SIFS_Timer);
+
+			/*
+			 * Adjust R2T SIFS for IOT issue. Add by hpfan 2013.01.25
+			 * Set R2T SIFS to 0x0a for Atheros IOT. Add by hpfan 2013.02.22
+			 *
+			 * Mac has 10 us delay so use 0xa value is enough.
+			 */
+			R2T_SIFS = 0xa;
+
+			rtl_write_byte(rtlpriv, REG_RESP_SIFS_OFDM+1, R2T_SIFS);
+		}
+		break;
+
+	default:
+		RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD, "%s: [WARNNING] variable(%d) not defined!\n", __FUNCTION__, variable);
+		break;
+	}
+}
+
+
+void rtl8821au_get_hw_reg(struct rtl_priv *rtlpriv, u8 variable,u8 *pval)
+{
+	struct rtl_efuse *rtlefuse =  rtl_efuse(rtlpriv);
+	struct _rtw_hal *pHalData;
+	struct _rtw_dm *podmpriv;
+	uint8_t val8;
+	u16 val16;
+
+	pHalData = GET_HAL_DATA(rtlpriv);
+	podmpriv = &pHalData->odmpriv;
+
+	switch (variable) {
+	case HW_VAR_TXPAUSE:
+		*pval = rtl_read_byte(rtlpriv, REG_TXPAUSE);
+		break;
+
+	case HW_VAR_BCN_VALID:
+		{
+			/* BCN_VALID, BIT(16) of REG_TDECTRL = BIT(0) of REG_TDECTRL+2 */
+			val8 = rtl_read_byte(rtlpriv, REG_TDECTRL+2);
+			*pval = (BIT(0) & val8) ? true:false;
+		}
+		break;
+
+	case HW_VAR_FWLPS_RF_ON:
+		/* When we halt NIC, we should check if FW LPS is leave. */
+		if (rtlpriv->pwrctrlpriv.rf_pwrstate == ERFOFF) {
+			/*
+			 *  If it is in HW/SW Radio OFF or IPS state, we do not check Fw LPS Leave,
+			 *  because Fw is unload.
+			 */
+			*pval = true;
+		} else {
+			uint32_t valRCR;
+			valRCR = rtl_read_dword(rtlpriv, REG_RCR);
+			valRCR &= 0x00070000;
+			if (valRCR)
+				*pval = false;
+			else
+				*pval = true;
+		}
+
+		break;
+
+	case HW_VAR_EFUSE_BYTES: /*  To get EFUE total used bytes, added by Roger, 2008.12.22. */
+		*(u16 *)pval = rtlefuse->efuse_usedbytes;
+		break;
+
+	case HW_VAR_CHK_HI_QUEUE_EMPTY:
+		val16 = rtl_read_word(rtlpriv, REG_TXPKT_EMPTY);
+		*pval = (val16 & BIT(10)) ? true:false;
+		break;
+
+	default:
+		RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD, "%s: [WARNNING] variable(%d) not defined!\n", __FUNCTION__, variable);
+		break;
+	}
+}
+
+/*
+ * These functions sets the media type register
+ * AP, STA, ADHOC
+ */
+
+void Set_MSR(struct rtl_priv *rtlpriv, uint8_t type)
+{
+	rtlpriv->cfg->ops->set_hw_reg(rtlpriv, HW_VAR_MEDIA_STATUS, (uint8_t *)(&type));
+}
+
+void rtl8821au_read_chip_version(struct rtl_priv *rtlpriv)
+{
+	uint32_t	value32;
+	enum version_8821au chip_version = VERSION_UNKNOWN;
+	struct rtl_hal *rtlhal = rtl_hal(rtlpriv);
+
+	value32 = rtl_read_dword(rtlpriv, REG_SYS_CFG);
+	RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD, "%s SYS_CFG(0x%X)=0x%08x \n", __FUNCTION__, REG_SYS_CFG, value32);
+
+	if (IS_HARDWARE_TYPE_8812(rtlhal))
+		chip_version = CHIP_8812;
+	else
+		chip_version = CHIP_8821;
+
+	chip_version |= ((value32 & RTL_ID) ? 0 : NORMAL_CHIP);
+
+	if (IS_HARDWARE_TYPE_8812(rtlhal))
+		chip_version |= RF_TYPE_2T2R;	/* RF_2T2R; */
+	else
+		chip_version |= RF_TYPE_1T1R;	/*RF_1T1R; */
+
+	if (IS_HARDWARE_TYPE_8812(rtlhal))
+		chip_version |= ((value32 & VENDOR_ID) ? CHIP_VENDOR_UMC : 0);
+	else {
+		uint32_t vendor;
+
+		vendor = (value32 & EXT_VENDOR_ID) >> EXT_VENDOR_ID_SHIFT;
+		switch (vendor) {
+		case 2:
+			chip_version |= CHIP_VENDOR_UMC;
+			break;
+		}
+	}
+	
+	if (IS_HARDWARE_TYPE_8812(rtlhal)) {
+		u32 rtl_id = ((value32 & CHIP_VER_RTL_MASK) >> CHIP_VER_RTL_SHIFT) + 1;
+		
+		chip_version = (enum version_8821au) (chip_version | (rtl_id << 12));
+	} else {
+		u32 rtl_id = ((value32 & CHIP_VER_RTL_MASK) >> CHIP_VER_RTL_SHIFT);
+		
+		chip_version = (enum version_8821au) (chip_version | (rtl_id << 12));
+	}
+	
+#if 0	
+	/* value32 = rtl_read_dword(rtlpriv, REG_GPIO_OUTSTS); */
+	ChipVersion.ROMVer = 0;	/* ROM code version. */
+#endif
+	/* For multi-function consideration. Added by Roger, 2010.10.06. */
+	value32 = rtl_read_dword(rtlpriv, REG_MULTI_FUNC_CTRL);
+	rtlpriv->phy.polarity_ctl = ((value32 & WL_HWPDN_SL) ? RT_POLARITY_HIGH_ACT : RT_POLARITY_LOW_ACT);
+
+	if (IS_1T2R(chip_version)) {
+		rtlpriv->phy.rf_type = RF_1T2R;
+		 rtlpriv->phy.num_total_rfpath = 2;
+		RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD, "==> RF_Type : 1T2R\n");
+	} else if (IS_2T2R(chip_version)) {
+		rtlpriv->phy.rf_type = RF_2T2R;
+		 rtlpriv->phy.num_total_rfpath = 2;
+		RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD, "==> RF_Type : 2T2R\n");
+	} else {
+		rtlpriv->phy.rf_type = RF_1T1R;
+		 rtlpriv->phy.num_total_rfpath = 1;
+		RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD, "==> RF_Type 1T1R\n");
+	}
+
+	RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD, "RF_Type is %x!!\n", rtlpriv->phy.rf_type);
+}
+
+
+static int32_t _rtl8821au_llt_write(struct rtl_priv *rtlpriv, uint32_t address, uint32_t data)
+{
+	bool status = true;
+	int32_t	count = 0;
+	uint32_t value = _LLT_INIT_ADDR(address) | _LLT_INIT_DATA(data) |
+			 _LLT_OP(_LLT_WRITE_ACCESS);
+
+	rtl_write_dword(rtlpriv, REG_LLT_INIT, value);
+
+	/* polling */
+	do {
+		value = rtl_read_dword(rtlpriv, REG_LLT_INIT);
+		if (_LLT_NO_ACTIVE == _LLT_OP_VALUE(value)) {
+			break;
+		}
+
+		if (count > POLLING_LLT_THRESHOLD) {
+			status = false;
+			break;
+		}
+	} while (count++);
+
+	return status;
+}
+
+int32_t  _rtl8821au_llt_table_init(struct rtl_priv *rtlpriv, uint8_t txpktbuf_bndy)
+{
+	bool status;
+	uint32_t i;
+	uint32_t Last_Entry_Of_TxPktBuf = LAST_ENTRY_OF_TX_PKT_BUFFER_8812;
+
+	for (i = 0; i < (txpktbuf_bndy - 1); i++) {
+		status = _rtl8821au_llt_write(rtlpriv, i, i + 1);
+		if (!status)
+			return status;
+	}
+
+	/* end of list */
+	status = _rtl8821au_llt_write(rtlpriv, (txpktbuf_bndy - 1), 0xFF);
+	if (_SUCCESS != status) {
+		return status;
+	}
+
+	/*
+	 * Make the other pages as ring buffer
+	 * This ring buffer is used as beacon buffer if we config this MAC as two MAC transfer.
+	 * Otherwise used as local loopback buffer.
+	 */
+	for (i = txpktbuf_bndy; i < Last_Entry_Of_TxPktBuf; i++) {
+		status = _rtl8821au_llt_write(rtlpriv, i, (i + 1));
+		if (!status)
+			return status;
+	}
+
+	/*  Let last entry point to the start entry of ring buffer */
+	status = _rtl8821au_llt_write(rtlpriv, Last_Entry_Of_TxPktBuf, txpktbuf_bndy);
+	if (!status)
+		return status;
+
+	return true;
+}
+
+static void _rtl8812au_read_rfe_type(struct rtl_priv *rtlpriv, u8 *hwinfo,
+		bool autoload_fail)
+{
+	struct rtl_hal *rtlhal = rtl_hal(rtlpriv);
+
+	if (!autoload_fail) {
+		if (hwinfo[EEPROM_RFE_OPTION_8812] & BIT(7)) {
+			if (rtlhal->external_lna_5g) {
+				if (rtlhal->external_pa_5g) {
+					if (rtlhal->external_lna_2g && rtlhal->external_pa_2g)
+						rtlhal->rfe_type = 3;
+					else
+						rtlhal->rfe_type = 0;
+				} else
+					rtlhal->rfe_type = 2;
+			} else
+				rtlhal->rfe_type = 4;
+		} else {
+			rtlhal->rfe_type= hwinfo[EEPROM_RFE_OPTION_8812]&0x3F;
+
+			/*
+			 * 2013/03/19 MH Due to othe customer already use incorrect EFUSE map
+			 * to for their product. We need to add workaround to prevent to modify
+			 * spec and notify all customer to revise the IC 0xca content. After
+			 * discussing with Willis an YN, revise driver code to prevent.
+			 */
+			if (rtlhal->rfe_type == 4 &&
+			   (rtlhal->external_pa_5g == true || rtlhal->external_pa_2g == true ||
+			    rtlhal->external_lna_5g == true || rtlhal->external_lna_2g == true)) {
+				if (IS_HARDWARE_TYPE_8812AU(rtlhal))
+					rtlhal->rfe_type = 0;
+			}
+		}
+	} else {
+		rtlhal->rfe_type = EEPROM_DEFAULT_RFE_OPTION;
+	}
+#if 0
+	DBG_871X("RFE Type: 0x%2x\n", rtlhal->rfe_type);
+#endif	
+}
+
+static void _rtl8812au_read_pa_type(struct rtl_priv *rtlpriv, u8 *hwinfo,
+				    bool autoload_fail);
+
+static void _rtl8821au_read_pa_type(struct rtl_priv *rtlpriv, u8 *hwinfo,
+				    bool autoload_fail);
+
+static void _rtl88au_read_txpower_info_from_hwpg(struct rtl_priv *rtlpriv, u8 *hwinfo,
+	bool autoload_fail);
+
+
+/* ULLI : refractoring this into one function _read_adapter_info() */
+
+static void Hal_ReadChannelPlan8812A(struct rtl_priv *rtlpriv, uint8_t *hwinfo,
+	bool	AutoLoadFail)
+{
+	rtlpriv->mlmepriv.ChannelPlan = hal_com_get_channel_plan(
+		rtlpriv
+		, hwinfo?hwinfo[EEPROM_ChannelPlan_8812]:0xFF
+		,  RT_CHANNEL_DOMAIN_MAX
+		, RT_CHANNEL_DOMAIN_REALTEK_DEFINE
+		, AutoLoadFail
+	);
+
+	RT_TRACE(rtlpriv, COMP_EFUSE, DBG_LOUD, "mlmepriv.ChannelPlan = 0x%02x\n", rtlpriv->mlmepriv.ChannelPlan);
+}
+
+void _rtl8821au_read_adapter_info(struct rtl_priv *rtlpriv)
+{
+	struct rtl_efuse *rtlefuse = rtl_efuse(rtlpriv);
+	struct rtl_hal *rtlhal = rtl_hal(rtlpriv);
+	struct rtl_usb_priv *usbpriv = rtl_usbpriv(rtlpriv);
+	struct rtl_led_ctl *pledpriv = &(usbpriv->ledpriv);
+	uint8_t	tmp_u1b;
+	u8 hwinfo[HWSET_MAX_SIZE_JAGUAR];
+	u16 EEPROMId;
+
+	/* Read all content in Efuse/EEPROM. */
+
+	/* check system boot selection */
+	tmp_u1b = rtl_read_byte(rtlpriv, REG_9346CR);
+	if (tmp_u1b & BIT(4)) {
+		RT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG, "Boot from EEPROM\n");
+		rtlefuse->epromtype = EEPROM_93C46;
+	} else {
+		RT_TRACE(rtlpriv, COMP_INIT, DBG_DMESG, "Boot from EFUSE\n");
+		rtlefuse->epromtype = EEPROM_BOOT_EFUSE;
+	}
+
+	if (tmp_u1b & EEPROM_EN) {
+		RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD, "Autoload OK\n");
+		rtlefuse->autoload_failflag = false;
+	} else {
+		RT_TRACE(rtlpriv, COMP_ERR, DBG_EMERG, "Autoload ERR!!\n");
+		/* ULLI : not in rtlwifi, maybe autoload_failflag to set to true */
+		rtlefuse->autoload_failflag = false;
+
+	}
+
+	/* pHalData->EEType = IS_BOOT_FROM_EEPROM(rtlpriv) ? EEPROM_93C46 : EEPROM_BOOT_EFUSE; */
+
+	if (rtlefuse->autoload_failflag == false) { /* autoload OK. */
+		rtw_efuse_shadow_map_update(rtlpriv);
+		memcpy(hwinfo, &rtlefuse->efuse_map[EFUSE_INIT_MAP][0],
+		       HWSET_MAX_SIZE_JAGUAR);
+	} else {	/* autoload fail */
+		/*
+		 * pHalData->AutoloadFailFlag = true;
+		 * update to default value 0xFF
+		 */
+		if (rtlefuse->epromtype == EEPROM_BOOT_EFUSE) {
+			rtw_efuse_shadow_map_update(rtlpriv);
+			memcpy(hwinfo, &rtlefuse->efuse_map[EFUSE_INIT_MAP][0],
+			       HWSET_MAX_SIZE_JAGUAR);
+		}
+
+	}
+
+	/*  Checl 0x8129 again for making sure autoload status!! */
+	EEPROMId = le16_to_cpu(*((u16 *)hwinfo));
+	if (EEPROMId != RTL_EEPROM_ID) {
+		RT_TRACE(rtlpriv, COMP_EFUSE, DBG_LOUD, "EEPROM ID(%#x) is invalid!!\n", EEPROMId);
+		rtlefuse->autoload_failflag = true;
+	} else {
+		rtlefuse->autoload_failflag = false;
+	}
+
+	if (rtlefuse->autoload_failflag) {
+		rtlefuse->eeprom_version = EEPROM_Default_Version;
+	} else{
+		rtlefuse->eeprom_version = hwinfo[EEPROM_VERSION_8812];
+		if (rtlefuse->eeprom_version == 0xFF)
+			rtlefuse->eeprom_version = EEPROM_Default_Version;
+	}
+
+	if (!rtlefuse->autoload_failflag) {
+		/* VID, PID */
+		if (IS_HARDWARE_TYPE_8812AU(rtlhal)) {
+			rtlefuse->eeprom_vid = *((u16 *) &hwinfo[EEPROM_VID_8812AU]);
+			rtlefuse->eeprom_did = *((u16 *) &hwinfo[EEPROM_PID_8812AU]);
+		} else if (IS_HARDWARE_TYPE_8821U(rtlhal)) {
+			rtlefuse->eeprom_vid = *((u16 *) &hwinfo[EEPROM_VID_8821AU]);
+			rtlefuse->eeprom_did = *((u16 *) &hwinfo[EEPROM_PID_8821AU]);
+		}
+
+		/* Customer ID, 0x00 and 0xff are reserved for Realtek. */
+		rtlefuse->eeprom_oemid = hwinfo[EEPROM_CustomID_8812];
+/* ULLI : rot in rtlwifi
+ *		efuse->EEPROMSubCustomerID = EEPROM_Default_SubCustomerID;
+ */
+
+	} else {
+		rtlefuse->eeprom_vid = EEPROM_Default_VID;
+		rtlefuse->eeprom_did = EEPROM_Default_PID;
+
+		/* Customer ID, 0x00 and 0xff are reserved for Realtek. */
+		rtlefuse->eeprom_oemid		= EEPROM_Default_CustomerID;
+/* ULLI : rot in rtlwifi
+ * 		efuse->EEPROMSubCustomerID	= EEPROM_Default_SubCustomerID;
+ */
+	}
+
+	if (!rtlefuse->autoload_failflag) {
+		if (IS_HARDWARE_TYPE_8812AU(rtlhal)) {
+			/* Read Permanent MAC address and set value to hardware */
+			memcpy(rtlpriv->mac80211.mac_addr, &hwinfo[EEPROM_MAC_ADDR_8812AU], ETH_ALEN);
+		} else if (IS_HARDWARE_TYPE_8821U(rtlhal)) {
+			/*  Read Permanent MAC address and set value to hardware */
+			memcpy(rtlpriv->mac80211.mac_addr, &hwinfo[EEPROM_MAC_ADDR_8821AU], ETH_ALEN);
+		}
+	} else {
+		/* Random assigh MAC address */
+		u8 sMacAddr[ETH_ALEN] = {0x00, 0xE0, 0x4C, 0x88, 0x12, 0x00};
+		/* sMacAddr[5] = (u8)GetRandomNumber(1, 254); */
+		memcpy(rtlpriv->mac80211.mac_addr, sMacAddr, ETH_ALEN);
+	}
+
+	_rtl88au_read_txpower_info_from_hwpg(rtlpriv, &rtlefuse->efuse_map[0][0], rtlefuse->autoload_failflag);
+	
+
+#if 0	/* ULLI check this in old source, may be vendor specific ?? */
+	/* ULLI from Hal_ReadBoardType8812A() */
+	if (!autoload_fail) {
+		pHalData->InterfaceSel = (hwinfo[EEPROM_RF_BOARD_OPTION_8812]&0xE0)>>5;
+		if (hwinfo[EEPROM_RF_BOARD_OPTION_8812] == 0xFF)
+			pHalData->InterfaceSel = (EEPROM_DEFAULT_BOARD_OPTION&0xE0)>>5;
+	} else {
+		pHalData->InterfaceSel = 0;
+	}
+	RT_TRACE(rtlpriv, COMP_EFUSE, DBG_LOUD, "Board Type: 0x%2x\n", pHalData->InterfaceSel);
+#endif
+
+	/*
+	 * Read Bluetooth co-exist and initialize
+	 */
+
+	Hal_ReadChannelPlan8812A(rtlpriv, &rtlefuse->efuse_map[0][0], rtlefuse->autoload_failflag);
+
+	if (!rtlefuse->autoload_failflag) {
+		rtlefuse->crystalcap = hwinfo[EEPROM_XTAL_8812];
+		if (rtlefuse->crystalcap == 0xFF)
+			rtlefuse->crystalcap = EEPROM_Default_CrystalCap_8812;	 /* what value should 8812 set? */
+	} else {
+		rtlefuse->crystalcap = EEPROM_Default_CrystalCap_8812;
+	}
+
+
+	if (!rtlefuse->autoload_failflag)
+		rtlefuse->eeprom_thermalmeter = hwinfo[EEPROM_THERMAL_METER_8812];
+	else
+		rtlefuse->eeprom_thermalmeter = EEPROM_Default_ThermalMeter_8812;
+	/* pHalData->EEPROMThermalMeter = (tempval&0x1f);	//[4:0] */
+
+	if (rtlefuse->eeprom_thermalmeter == 0xff || rtlefuse->autoload_failflag) {
+		rtlefuse->apk_thermalmeterignore = true;
+		rtlefuse->eeprom_thermalmeter = 0xFF;
+	}
+
+	if (!rtlefuse->autoload_failflag) {
+		u8 tmp;
+		
+		tmp = hwinfo[EEPROM_RF_BOARD_OPTION_8812];
+		
+		/*  Antenna Diversity setting. */
+		rtlefuse->antenna_div_cfg = (tmp & 0x18) >>3;
+		if (tmp == 0xFF)
+			rtlefuse->antenna_div_cfg = (EEPROM_DEFAULT_BOARD_OPTION & 0x18) >> 3;;
+	} else {
+		rtlefuse->antenna_div_cfg = 0;
+	}
+
+	if (IS_HARDWARE_TYPE_8821U(rtlhal)) {
+		_rtl8821au_read_pa_type(rtlpriv, &rtlefuse->efuse_map[0][0], rtlefuse->autoload_failflag);
+	} else {
+		_rtl8812au_read_pa_type(rtlpriv, &rtlefuse->efuse_map[0][0], rtlefuse->autoload_failflag);
+		_rtl8812au_read_rfe_type(rtlpriv, &rtlefuse->efuse_map[0][0], rtlefuse->autoload_failflag);
+	}
+
+	/* For customized behavior. */
+
+	if ((rtlefuse->eeprom_vid == 0x050D) && (rtlefuse->eeprom_did == 0x1106))		/* SerComm for Belkin. */
+		rtlhal->oem_id = RT_CID_Sercomm_Belkin;	/* ULLI : RTL8812 */
+	else if ((rtlefuse->eeprom_vid == 0x0846) && (rtlefuse->eeprom_did == 0x9052))	/* SerComm for Netgear. */
+		rtlhal->oem_id = RT_CID_Sercomm_Netgear;	/* ULLI :  posible typo for pid maybe 0x9052 */
+	else if ((rtlefuse->eeprom_vid == 0x2001) && (rtlefuse->eeprom_did == 0x330e))	/* add by ylb 20121012 for customer led for alpha */
+		rtlhal->oem_id = RT_CID_ALPHA_Dlink;	/* ULLI : RTL8812 */
+	else if ((rtlefuse->eeprom_vid == 0x0B05) && (rtlefuse->eeprom_did == 0x17D2))	/* Edimax for ASUS */
+		rtlhal->oem_id = RT_CID_Edimax_ASUS;	/* ULLI : RTL8812 */
+
+	/* Decide CustomerID according to VID/DID or EEPROM */
+	switch (rtlefuse->eeprom_oemid) {
+	case EEPROM_CID_DEFAULT:
+		if ((rtlefuse->eeprom_vid == 0x0846) && (rtlefuse->eeprom_did == 0x9052))
+			rtlhal->oem_id = RT_CID_NETGEAR;		/* ULLI : RTL8821 */
+		break;
+	default:
+		rtlhal->oem_id = RT_CID_DEFAULT;
+		break;
+
+	}
+
+	pledpriv->led_opendrain = true;	/* Support Open-drain arrangement for controlling the LED. Added by Roger, 2009.10.16. */
+
+#if 0	/* ULLI check this in old source, may be vendor specific ?? */
+	if(pHalData->InterfaceSel == INTF_SEL1_USB_High_Power) 	{
+		rtlhal->external_pa_2g = 1;
+		rtlhal->external_lna_2g = 1;
+	} else {
+		rtlhal->external_lna_2g = 0;
+	}
+#endif
+	rtlefuse->board_type = ODM_BOARD_DEFAULT;
+	if (rtlhal->external_lna_2g != 0) {
+		rtlefuse->board_type |= ODM_BOARD_EXT_LNA;
+	}
+	if (rtlhal->external_lna_5g != 0) {
+		rtlefuse->board_type |= ODM_BOARD_EXT_LNA_5G;
+	}
+	if (rtlhal->external_pa_2g != 0) {
+		rtlefuse->board_type |= ODM_BOARD_EXT_PA;
+	}
+	if (rtlhal->external_pa_5g != 0) {
+		rtlefuse->board_type |= ODM_BOARD_EXT_PA_5G;
+	}
+
+	rtlhal->board_type = rtlefuse->board_type;
+
+}
+
+bool rtl8821au_gpio_radio_on_off_checking(struct rtl_priv *rtlpriv, u8 *valid)
+{
+	uint8_t	val8;
+	enum rf_pwrstate rfpowerstate = ERFOFF;
+
+	{ /* rf on/off */
+		rtl_write_byte(rtlpriv, REG_MAC_PINMUX_CFG, rtl_read_byte(rtlpriv, REG_MAC_PINMUX_CFG)&~(BIT(3)));
+		val8 = rtl_read_byte(rtlpriv, REG_GPIO_IO_SEL);
+#if 0		
+		DBG_8192C("GPIO_IN=%02x\n", val8);
+#endif		
+		rfpowerstate = (val8 & BIT(3)) ? ERFON : ERFOFF;
+	}
+	return rfpowerstate;
+}
+
+
+static void _InitBurstPktLen(struct rtl_priv *rtlpriv)
+{
+	struct rtl_usb	*rtlusb = rtl_usbdev(rtlpriv);
+	struct rtl_hal *rtlhal = rtl_hal(rtlpriv);
+	u8 speedvalue, provalue, temp;
+ 	struct _rtw_hal	*pHalData = GET_HAL_DATA(rtlpriv);
+
+	/*
+	 * rtl_write_word(rtlpriv, REG_TRXDMA_CTRL_8195, 0xf5b0);
+	 * rtl_write_word(rtlpriv, REG_TRXDMA_CTRL_8812, 0xf5b4);
+	 */
+	rtl_write_byte(rtlpriv, 0xf050, 0x01);		/* usb3 rx interval */
+	rtl_write_word(rtlpriv, REG_RXDMA_STATUS, 0x7400);	/* burset lenght=4, set 0x3400 for burset length=2 */
+	rtl_write_byte(rtlpriv, 0x289, 0xf5);		/* for rxdma control */
+	/* rtl_write_byte(rtlpriv, 0x3a, 0x46); */
+
+	/*  0x456 = 0x70, sugguested by Zhilin */
+	rtl_write_byte(rtlpriv, REG_AMPDU_MAX_TIME_8812, 0x70);
+
+	rtl_write_dword(rtlpriv, 0x458, 0xffffffff);
+	rtl_write_byte(rtlpriv, REG_USTIME_TSF, 0x50);
+	rtl_write_byte(rtlpriv, REG_USTIME_EDCA, 0x50);
+
+	if (IS_HARDWARE_TYPE_8821U(rtlhal))
+		speedvalue = BIT(7);
+	else
+		speedvalue = rtl_read_byte(rtlpriv, 0xff); /* check device operation speed: SS 0xff BIT(7) */
+
+	if (speedvalue & BIT(7)) {		/* USB2/1.1 Mode */
+		temp = rtl_read_byte(rtlpriv, 0xfe17);
+		if (((temp >> 4) & 0x03) == 0) {
+			rtlusb->max_bulk_out_size = USB_HIGH_SPEED_BULK_SIZE;
+			provalue = rtl_read_byte(rtlpriv, REG_RXDMA_PRO_8812);
+			rtl_write_byte(rtlpriv, REG_RXDMA_PRO_8812, ((provalue|BIT(4))&(~BIT(5)))); /* set burst pkt len=512B */
+			rtl_write_word(rtlpriv, REG_RXDMA_PRO_8812, 0x1e);
+		} else {
+			rtlusb->max_bulk_out_size = USB_FULL_SPEED_BULK_SIZE;
+			provalue = rtl_read_byte(rtlpriv, REG_RXDMA_PRO_8812);
+			rtl_write_byte(rtlpriv, REG_RXDMA_PRO_8812, ((provalue|BIT(5))&(~BIT(4)))); /* set burst pkt len=64B */
+		}
+
+		rtl_write_word(rtlpriv, REG_RXDMA_AGG_PG_TH, 0x2005); /* dmc agg th 20K */
+
+		/*
+		 * rtl_write_byte(rtlpriv, 0x10c, 0xb4);
+		 * hal_UphyUpdate8812AU(rtlpriv);
+		 */
+
+		rtlpriv->rtlhal.version |= ~RTL8821AU_USB3_MODE;
+	} else {		/* USB3 Mode */
+		rtlusb->max_bulk_out_size = USB_SUPER_SPEED_BULK_SIZE;
+		provalue = rtl_read_byte(rtlpriv, REG_RXDMA_PRO_8812);
+		rtl_write_byte(rtlpriv, REG_RXDMA_PRO_8812, provalue&(~(BIT(5)|BIT(4)))); /* set burst pkt len=1k */
+		rtl_write_word(rtlpriv, REG_RXDMA_PRO_8812, 0x0e);
+		rtlpriv->rtlhal.version |= ~RTL8821AU_USB3_MODE;
+
+		/*  set Reg 0xf008[3:4] to 2'00 to disable U1/U2 Mode to avoid 2.5G spur in USB3.0. added by page, 20120712 */
+		rtl_write_byte(rtlpriv, 0xf008, rtl_read_byte(rtlpriv, 0xf008)&0xE7);
+	}
+
+#if 0
+	/* ULLI disabled through CONFIG_USB_TX_AGGREGATION is in use */
+	rtl_write_byte(rtlpriv, REG_TDECTRL, 0x10);
+#endif
+	temp = rtl_read_byte(rtlpriv, REG_SYS_FUNC_EN);
+	rtl_write_byte(rtlpriv, REG_SYS_FUNC_EN, temp&(~BIT(10))); 	/* reset 8051 */
+
+	rtl_write_byte(rtlpriv, REG_HT_SINGLE_AMPDU_8812, rtl_read_byte(rtlpriv, REG_HT_SINGLE_AMPDU_8812)|BIT(7));	/* enable single pkt ampdu */
+	rtl_write_byte(rtlpriv, REG_RX_PKT_LIMIT, 0x18);		/* for VHT packet length 11K */
+
+	rtl_write_byte(rtlpriv, REG_PIFS, 0x00);
+
+	/* Suggention by SD1 Jong and Pisa, by Maddest 20130107. */
+	if (IS_HARDWARE_TYPE_8821U(rtlhal)) {
+		rtl_write_word(rtlpriv, REG_MAX_AGGR_NUM, 0x0a0a);
+		rtl_write_byte(rtlpriv, REG_FWHW_TXQ_CTRL, 0x80);
+		rtl_write_byte(rtlpriv, REG_AMPDU_MAX_TIME_8812, 0x5e);
+		rtl_write_dword(rtlpriv, REG_FAST_EDCA_CTRL, 0x03087777);
+	} else {
+		rtl_write_byte(rtlpriv, REG_MAX_AGGR_NUM, 0x1f);
+		rtl_write_byte(rtlpriv, REG_FWHW_TXQ_CTRL, rtl_read_byte(rtlpriv, REG_FWHW_TXQ_CTRL)&(~BIT(7)));
+	}
+
+	if (pHalData->AMPDUBurstMode)
+		rtl_write_byte(rtlpriv, REG_AMPDU_BURST_MODE_8812, 0x5F);
+
+	rtl_write_byte(rtlpriv, 0x1c, rtl_read_byte(rtlpriv, 0x1c) | BIT(5) | BIT(6));  /* to prevent mac is reseted by bus. 20111208, by Page */
+
+	/* ARFB table 9 for 11ac 5G 2SS */
+	rtl_write_dword(rtlpriv, REG_ARFR0, 0x00000010);
+	if (IS_NORMAL_CHIP(rtlhal->version))
+		rtl_write_dword(rtlpriv, REG_ARFR0+4, 0xfffff000);
+	else
+		rtl_write_dword(rtlpriv, REG_ARFR0+4, 0x3e0ff000);
+
+	/* ARFB table 10 for 11ac 5G 1SS */
+	rtl_write_dword(rtlpriv, REG_ARFR1, 0x00000010);
+	if (IS_VENDOR_8812A_TEST_CHIP(rtlhal->version))
+		rtl_write_dword(rtlpriv, REG_ARFR1_8812+4, 0x000ff000);
+	else
+		rtl_write_dword(rtlpriv, REG_ARFR1_8812+4, 0x003ff000);
+
+}
+
+static uint32_t _InitPowerOn8812AU(struct rtl_priv *rtlpriv)
+{
+	u16	u2btmp = 0;
+	uint8_t	u1btmp = 0;
+	struct rtl_hal *rtlhal = rtl_hal(rtlpriv);
+
+	if (IS_VENDOR_8821A_MP_CHIP(rtlhal->version)) {
+		/* HW Power on sequence */
+		if (!rtw_hal_pwrseqcmdparsing(rtlpriv, PWR_CUT_A_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, Rtl8821A_NIC_ENABLE_FLOW)) {
+			RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD, "%s: run power on flow fail\n", __func__);
+			return _FAIL;
+		}
+	} else if (IS_HARDWARE_TYPE_8821U(rtlhal)) {
+		if (!rtw_hal_pwrseqcmdparsing(rtlpriv, PWR_CUT_TESTCHIP_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, Rtl8821A_NIC_ENABLE_FLOW)) {
+			RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD, "%s: run power on flow fail\n", __func__);
+			return _FAIL;
+		}
+	} else {
+		if (!rtw_hal_pwrseqcmdparsing(rtlpriv, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK, Rtl8812_NIC_ENABLE_FLOW)) {
+			RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD, "%s: run power on flow fail\n", __func__);
+			return _FAIL;
+		}
+	}
+
+	/*
+	 *  Enable MAC DMA/WMAC/SCHEDULE/SEC block
+	 * Set CR BIT(10) to enable 32k calibration. Suggested by SD1 Gimmy. Added by tynli. 2011.08.31.
+	 */
+	rtl_write_word(rtlpriv, REG_CR, 0x00); 	/* suggseted by zhouzhou, by page, 20111230 */
+	u2btmp = rtl_read_word(rtlpriv, REG_CR);
+	u2btmp |= (HCI_TXDMA_EN | HCI_RXDMA_EN | TXDMA_EN | RXDMA_EN
+				| PROTOCOL_EN | SCHEDULE_EN | ENSEC | CALTMR_EN);
+	rtl_write_word(rtlpriv, REG_CR, u2btmp);
+
+	/*
+	 * Need remove below furture, suggest by Jackie.
+	 * if 0xF0[24] =1 (LDO), need to set the 0x7C[6] to 1.
+	 */
+	if (IS_HARDWARE_TYPE_8821U(rtlhal)) {
+		u1btmp = rtl_read_byte(rtlpriv, REG_SYS_CFG+3);
+		if (u1btmp & BIT(0)) { 	/* LDO mode. */
+			u1btmp = rtl_read_byte(rtlpriv, 0x7c);
+			/* ULLI unknown register */
+			rtl_write_byte(rtlpriv, 0x7c, u1btmp | BIT(6));
+		}
+	}
+
+	return _SUCCESS;
+}
+
+/* Shall USB interface init this? */
+void rtl8821au_enable_interrupt(struct rtl_priv *rtlpriv)
+{
+	struct rtl_usb *rtlusb = rtl_usbdev(rtlpriv);
+
+	/* HIMR */
+	rtl_write_dword(rtlpriv, REG_HIMR0_8812, rtlusb->irq_mask[0]&0xFFFFFFFF);
+	rtl_write_dword(rtlpriv, REG_HIMR1_8812, rtlusb->irq_mask[1]&0xFFFFFFFF);
+}
+
+void rtl8821au_disable_interrupt(struct rtl_priv *rtlpriv)
+{
+	rtl_write_dword(rtlpriv, REG_HIMR0_8812, IMR_DISABLED_8812);
+	rtl_write_dword(rtlpriv, REG_HIMR1_8812, IMR_DISABLED_8812);
+}
+static void _InitQueueReservedPage_8821AUsb(struct rtl_priv *rtlpriv)
+{
+	struct rtl_usb  *rtlusb = rtl_usbdev(rtlpriv);
+	uint32_t numHQ = 0;
+	uint32_t numLQ = 0;
+	uint32_t numNQ = 0;
+	uint32_t numPubQ = 0;
+	uint32_t value32;
+	uint8_t	 value8;
+
+	numPubQ = NORMAL_PAGE_NUM_PUBQ_8821;
+
+	if (rtlusb->out_queue_sel & TX_SELE_HQ)
+		numHQ = NORMAL_PAGE_NUM_HPQ_8821;
+
+	if (rtlusb->out_queue_sel & TX_SELE_LQ)
+		numLQ = NORMAL_PAGE_NUM_LPQ_8821;
+
+	/* NOTE: This step shall be proceed before writting REG_RQPN. */
+	if (rtlusb->out_queue_sel & TX_SELE_NQ)
+		numNQ = NORMAL_PAGE_NUM_NPQ_8821;
+
+
+	value8 = (u8)_NPQ(numNQ);
+	rtl_write_byte(rtlpriv, REG_RQPN_NPQ, value8);
+
+	/* TX DMA */
+	value32 = _HPQ(numHQ) | _LPQ(numLQ) | _PUBQ(numPubQ) | LD_RQPN;
+	rtl_write_dword(rtlpriv, REG_RQPN, value32);
+}
+
+static void _InitQueueReservedPage_8812AUsb(struct rtl_priv *rtlpriv)
+{
+	struct rtl_usb  *rtlusb = rtl_usbdev(rtlpriv);
+	uint32_t numHQ		= 0;
+	uint32_t numLQ		= 0;
+	uint32_t numNQ		= 0;
+	uint32_t numPubQ	= 0;
+	uint32_t value32;
+	uint8_t	value8;
+
+	numPubQ = NORMAL_PAGE_NUM_PUBQ_8812;
+
+	if (rtlusb->out_queue_sel & TX_SELE_HQ)
+		numHQ = NORMAL_PAGE_NUM_HPQ_8812;
+
+	if (rtlusb->out_queue_sel & TX_SELE_LQ)
+		numLQ = NORMAL_PAGE_NUM_LPQ_8812;
+
+	/* NOTE: This step shall be proceed before writting REG_RQPN. */
+	if (rtlusb->out_queue_sel & TX_SELE_NQ)
+		numNQ = NORMAL_PAGE_NUM_NPQ_8812;
+
+	value8 = (u8)_NPQ(numNQ);
+	rtl_write_byte(rtlpriv, REG_RQPN_NPQ, value8);
+
+	/* TX DMA */
+	value32 = _HPQ(numHQ) | _LPQ(numLQ) | _PUBQ(numPubQ) | LD_RQPN;
+	rtl_write_dword(rtlpriv, REG_RQPN, value32);
+}
+
+static void _InitTxBufferBoundary_8821AUsb(struct rtl_priv *rtlpriv)
+{
+	uint8_t	txpktbuf_bndy;
+
+	txpktbuf_bndy = TX_PAGE_BOUNDARY_8821;
+
+	rtl_write_byte(rtlpriv, REG_BCNQ_BDNY, txpktbuf_bndy);
+	rtl_write_byte(rtlpriv, REG_MGQ_BDNY, txpktbuf_bndy);
+	rtl_write_byte(rtlpriv, REG_WMAC_LBK_BF_HD, txpktbuf_bndy);
+	rtl_write_byte(rtlpriv, REG_TRXFF_BNDY, txpktbuf_bndy);
+	rtl_write_byte(rtlpriv, REG_TDECTRL+1, txpktbuf_bndy);
+}
+
+static void _InitTxBufferBoundary_8812AUsb(struct rtl_priv *rtlpriv)
+{
+	uint8_t	txpktbuf_bndy;
+
+	txpktbuf_bndy = TX_PAGE_BOUNDARY_8812;
+
+	rtl_write_byte(rtlpriv, REG_BCNQ_BDNY, txpktbuf_bndy);
+	rtl_write_byte(rtlpriv, REG_MGQ_BDNY, txpktbuf_bndy);
+	rtl_write_byte(rtlpriv, REG_WMAC_LBK_BF_HD, txpktbuf_bndy);
+	rtl_write_byte(rtlpriv, REG_TRXFF_BNDY, txpktbuf_bndy);
+	rtl_write_byte(rtlpriv, REG_TDECTRL+1, txpktbuf_bndy);
+}
+
+static void _InitPageBoundary_8812AUsb(struct rtl_priv *rtlpriv)
+{
+	/*
+	 * u16 			rxff_bndy;
+	 * u16			Offset;
+	 * bool			bSupportRemoteWakeUp;
+	 */
+
+	/*
+	 * rtlpriv->cfg->ops.GetHalDefVarHandler(rtlpriv, HAL_DEF_WOWLAN , &bSupportRemoteWakeUp);
+	 * RX Page Boundary
+	 * srand(static_cast<unsigned int>(time(NULL)) );
+	 */
+
+	/*
+	 * Offset = MAX_RX_DMA_BUFFER_SIZE_8812/256;
+	 * rxff_bndy = (Offset*256)-1;
+	 */
+
+	rtl_write_word(rtlpriv, (REG_TRXFF_BNDY + 2), MAX_RX_DMA_BUFFER_SIZE_8821-1);
+
+}
+
+static void _InitRDGSetting_8812A(struct rtl_priv *rtlpriv)
+{
+	rtl_write_byte(rtlpriv, REG_RD_CTRL, 0xFF);
+	rtl_write_word(rtlpriv, REG_RD_NAV_NXT, 0x200);
+	rtl_write_byte(rtlpriv, REG_RD_RESP_PKT_TH, 0x05);
+}
+
+
+static void _rtl8821au_init_chipN_reg_priority(struct rtl_priv *rtlpriv,
+	u16 beQ, u16 bkQ, u16 viQ,
+	u16 voQ, u16 mgtQ, u16 hiQ)
+{
+	u16 value16 = (rtl_read_word(rtlpriv, REG_TRXDMA_CTRL) & 0x7);
+
+	value16 |= _TXDMA_BEQ_MAP(beQ) 	| _TXDMA_BKQ_MAP(bkQ) |
+		   _TXDMA_VIQ_MAP(viQ) 	| _TXDMA_VOQ_MAP(voQ) |
+		   _TXDMA_MGQ_MAP(mgtQ) | _TXDMA_HIQ_MAP(hiQ);
+
+	rtl_write_word(rtlpriv, REG_TRXDMA_CTRL, value16);
+}
+
+static void _rtl8821au_init_chipN_two_ep_priority(struct rtl_priv *rtlpriv)
+{
+	struct rtl_usb  *rtlusb = rtl_usbdev(rtlpriv);
+	u16	beQ, bkQ, viQ, voQ, mgtQ, hiQ;
+
+	u16	valueHi = 0;
+	u16	valueLow = 0;
+
+	switch (rtlusb->out_queue_sel) {
+	case (TX_SELE_HQ | TX_SELE_LQ):
+		valueHi = QUEUE_HIGH;
+		valueLow = QUEUE_LOW;
+		break;
+	case (TX_SELE_NQ | TX_SELE_LQ):
+		valueHi = QUEUE_NORMAL;
+		valueLow = QUEUE_LOW;
+		break;
+	case (TX_SELE_HQ | TX_SELE_NQ):
+		valueHi = QUEUE_HIGH;
+		valueLow = QUEUE_NORMAL;
+		break;
+	default:
+		valueHi = QUEUE_HIGH;
+		valueLow = QUEUE_NORMAL;
+		break;
+	}
+
+		beQ	= valueLow;
+		bkQ	= valueLow;
+		viQ	= valueHi;
+		voQ	= valueHi;
+		mgtQ	= valueHi;
+		hiQ	= valueHi;
+
+	_rtl8821au_init_chipN_reg_priority(rtlpriv, beQ, bkQ, viQ, voQ, mgtQ, hiQ);
+
+}
+
+static void _rtl8821au_init_chipN_three_ep_priority(struct rtl_priv *rtlpriv)
+{
+	u16	beQ, bkQ, viQ, voQ, mgtQ, hiQ;
+
+		beQ	= QUEUE_LOW;
+		bkQ	= QUEUE_LOW;
+		viQ	= QUEUE_NORMAL;
+		voQ	= QUEUE_HIGH;
+		mgtQ 	= QUEUE_HIGH;
+		hiQ	= QUEUE_HIGH;
+
+	_rtl8821au_init_chipN_reg_priority(rtlpriv, beQ, bkQ, viQ, voQ, mgtQ, hiQ);
+}
+
+static void _rtl8821au_init_chipN_queue_priority(struct rtl_priv *rtlpriv)
+{
+	struct rtl_usb	*rtlusb = rtl_usbdev(rtlpriv);
+
+	switch (rtlusb->RtNumOutPipes) {
+	case 2:
+		_rtl8821au_init_chipN_two_ep_priority(rtlpriv);
+		break;
+	case 3:
+	case 4:
+		_rtl8821au_init_chipN_three_ep_priority(rtlpriv);
+		break;
+	default:
+		RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD, "_InitQueuePriority_8812AUsb(): Shall not reach here!\n");
+		break;
+	}
+}
+
+static void _InitTransferPageSize_8812AUsb(struct rtl_priv *rtlpriv)
+{
+	uint8_t	value8;
+	value8 = _PSTX(PBP_512);
+
+	rtl_write_byte(rtlpriv, REG_PBP, value8);
+}
+
+static void _InitDriverInfoSize_8812A(struct rtl_priv *rtlpriv, uint8_t	drvInfoSize)
+{
+	rtl_write_byte(rtlpriv, REG_RX_DRVINFO_SZ, drvInfoSize);
+}
+
+
+static void _InitNetworkType_8812A(struct rtl_priv *rtlpriv)
+{
+	uint32_t	value32;
+
+	value32 = rtl_read_dword(rtlpriv, REG_CR);
+	/*  TODO: use the other function to set network type */
+	value32 = (value32 & ~MASK_NETTYPE) | _NETTYPE(NT_LINK_AP);
+
+	rtl_write_dword(rtlpriv, REG_CR, value32);
+}
+
+
+static void _InitEDCA_8812AUsb(struct rtl_priv *rtlpriv)
+{
+	/* Set Spec SIFS (used in NAV) */
+	rtl_write_word(rtlpriv, REG_SPEC_SIFS, 0x100a);
+	rtl_write_word(rtlpriv, REG_MAC_SPEC_SIFS, 0x100a);
+
+	/* Set SIFS for CCK */
+	rtl_write_word(rtlpriv, REG_SIFS_CTX, 0x100a);
+
+	/* Set SIFS for OFDM */
+	rtl_write_word(rtlpriv, REG_SIFS_TRX, 0x100a);
+
+	/* TXOP */
+	rtl_write_dword(rtlpriv, REG_EDCA_BE_PARAM, 0x005EA42B);
+	rtl_write_dword(rtlpriv, REG_EDCA_BK_PARAM, 0x0000A44F);
+	rtl_write_dword(rtlpriv, REG_EDCA_VI_PARAM, 0x005EA324);
+	rtl_write_dword(rtlpriv, REG_EDCA_VO_PARAM, 0x002FA226);
+
+	/* 0x50 for 80MHz clock */
+	rtl_write_byte(rtlpriv, REG_USTIME_TSF, 0x50);
+	rtl_write_byte(rtlpriv, REG_USTIME_EDCA, 0x50);
+}
+
+static void _InitRetryFunction_8812A(struct rtl_priv *rtlpriv)
+{
+	uint8_t	value8;
+
+	value8 = rtl_read_byte(rtlpriv, REG_FWHW_TXQ_CTRL);
+	value8 |= EN_AMPDU_RTY_NEW;
+	rtl_write_byte(rtlpriv, REG_FWHW_TXQ_CTRL, value8);
+
+	/*
+	 * Set ACK timeout
+	 * rtl_write_byte(rtlpriv, REG_ACKTO, 0x40);  //masked by page for BCM IOT issue temporally
+	 */
+	rtl_write_byte(rtlpriv, REG_ACKTO, 0x80);
+}
+
+static void _InitWMACSetting_8812A(struct rtl_priv *rtlpriv)
+{
+	/* uint32_t			value32; */
+	/* u16			value16; */
+	 struct _rtw_hal	*pHalData = GET_HAL_DATA(rtlpriv);
+
+	/*
+	 * pHalData->ReceiveConfig = AAP | APM | AM | AB | APP_ICV | ADF | AMF | APP_FCS | HTC_LOC_CTRL | APP_MIC | APP_PHYSTS;
+	 */
+	pHalData->ReceiveConfig = RCR_APM | RCR_AM | RCR_AB | RCR_CBSSID_DATA
+				| RCR_CBSSID_BCN | RCR_APP_ICV | RCR_AMF
+				| RCR_HTC_LOC_CTRL | RCR_APP_MIC
+				| RCR_APP_PHYST_RXFF;
+
+#if (1 == RTL8812A_RX_PACKET_INCLUDE_CRC)
+	pHalData->ReceiveConfig |= ACRC32;
+#endif
+
+	pHalData->ReceiveConfig |= FORCEACK;
+
+	/*
+	 *  some REG_RCR will be modified later by phy_ConfigMACWithHeaderFile()
+	 */
+	rtl_write_dword(rtlpriv, REG_RCR, pHalData->ReceiveConfig);
+
+	/* Accept all multicast address */
+	rtl_write_dword(rtlpriv, REG_MAR, 0xFFFFFFFF);
+	rtl_write_dword(rtlpriv, REG_MAR + 4, 0xFFFFFFFF);
+
+
+	/*
+	 *  Accept all data frames
+	 * value16 = 0xFFFF;
+	 * rtl_write_word(rtlpriv, REG_RXFLTMAP2, value16);
+	 */
+
+	/*
+	 * 2010.09.08 hpfan
+	 * Since ADF is removed from RCR, ps-poll will not be indicate to driver,
+	 * RxFilterMap should mask ps-poll to gurantee AP mode can rx ps-poll.
+	 * value16 = 0x400;
+	 * rtl_write_word(rtlpriv, REG_RXFLTMAP1, value16);
+	 */
+
+	/*
+	 *  Accept all management frames
+	 * value16 = 0xFFFF;
+	 * rtl_write_word(rtlpriv, REG_RXFLTMAP0, value16);
+	 */
+
+	/*
+	 * enable RX_SHIFT bits
+	 * rtl_write_byte(rtlpriv, REG_TRXDMA_CTRL, rtl_read_byte(rtlpriv, REG_TRXDMA_CTRL)|BIT(1));
+	 */
+
+}
+
+static void _InitAdaptiveCtrl_8812AUsb(struct rtl_priv *rtlpriv)
+{
+	u16	value16;
+	uint32_t	value32;
+
+	/* Response Rate Set */
+	value32 = rtl_read_dword(rtlpriv, REG_RRSR);
+	value32 &= ~RATE_BITMAP_ALL;
+
+	/* ULLI : maybe WIRELESS_MODE_MAX from ieee80211.h is meant ?? */
+
+	if (WIRELESS_MODE_MAX & WIRELESS_11B)
+		value32 |= RATE_RRSR_CCK_ONLY_1M;
+	else
+		value32 |= RATE_RRSR_WITHOUT_CCK;
+
+	value32 |= RATE_RRSR_CCK_ONLY_1M;
+	rtl_write_dword(rtlpriv, REG_RRSR, value32);
+
+	/*
+	 * CF-END Threshold
+	 * m_spIoBase->rtl_write_byte(REG_CFEND_TH, 0x1);
+	 */
+
+	/* SIFS (used in NAV) */
+	value16 = _SPEC_SIFS_CCK(0x10) | _SPEC_SIFS_OFDM(0x10);
+	rtl_write_word(rtlpriv, REG_SPEC_SIFS, value16);
+
+	/* Retry Limit */
+	value16 = _LRL(0x30) | _SRL(0x30);
+	rtl_write_word(rtlpriv, REG_RL, value16);
+
+}
+
+
+static void _InitBeaconMaxError_8812A(struct rtl_priv *rtlpriv, bool	InfraMode)
+{
+	/* ULLI: looks here is some hacking done, wrong nams ?? */
+#ifdef RTL8192CU_ADHOC_WORKAROUND_SETTING
+	rtl_write_byte(rtlpriv, REG_BCN_MAX_ERR, 0xFF);
+#else
+	/* rtl_write_byte(rtlpriv, REG_BCN_MAX_ERR, (InfraMode ? 0xFF : 0x10)); */
+#endif
+}
+
+/*-----------------------------------------------------------------------------
+ * Function:	usb_AggSettingTxUpdate()
+ *
+ * Overview:	Seperate TX/RX parameters update independent for TP detection and
+ *			dynamic TX/RX aggreagtion parameters update.
+ *
+ * Input:			_ADAPTER
+ *
+ * Output/Return:	NONE
+ *
+ * Revised History:
+ *	When		Who		Remark
+ *	12/10/2010	MHC		Seperate to smaller function.
+ *
+ *---------------------------------------------------------------------------*/
+static void usb_AggSettingTxUpdate_8812A(struct rtl_priv *rtlpriv)
+{
+	 struct _rtw_hal	*pHalData = GET_HAL_DATA(rtlpriv);
+	uint32_t			value32;
+
+		value32 = rtl_read_dword(rtlpriv, REG_TDECTRL);
+		value32 = value32 & ~(BLK_DESC_NUM_MASK << BLK_DESC_NUM_SHIFT);
+		value32 |= ((pHalData->UsbTxAggDescNum & BLK_DESC_NUM_MASK) << BLK_DESC_NUM_SHIFT);
+
+		rtl_write_dword(rtlpriv, REG_TDECTRL, value32);
+
+}
+
+
+/*-----------------------------------------------------------------------------
+ * Function:	usb_AggSettingRxUpdate()
+ *
+ * Overview:	Seperate TX/RX parameters update independent for TP detection and
+ *			dynamic TX/RX aggreagtion parameters update.
+ *
+ * Input:			_ADAPTER
+ *
+ * Output/Return:	NONE
+ *
+ * Revised History:
+ *	When		Who		Remark
+ *	12/10/2010	MHC		Seperate to smaller function.
+ *
+ *---------------------------------------------------------------------------*/
+static void usb_AggSettingRxUpdate_8812A(struct rtl_priv *rtlpriv)
+{
+	 struct _rtw_hal	*pHalData = GET_HAL_DATA(rtlpriv);
+	uint8_t			valueDMA;
+
+	valueDMA = rtl_read_byte(rtlpriv, REG_TRXDMA_CTRL);
+
+	valueDMA |= RXDMA_AGG_EN;
+
+	/* rtl_write_byte(rtlpriv, REG_RXDMA_AGG_PG_TH, 0x05); //dma agg mode, 20k
+	 *
+	 * 2012/10/26 MH For TX throught start rate temp fix.
+	 */
+	{
+		u16			temp;
+
+		/* ULLI DMA on USB Device WTF ??? */
+		/* Adjust DMA page and thresh. */
+		temp = pHalData->RegAcUsbDmaSize | (pHalData->RegAcUsbDmaTime<<8);
+		rtl_write_word(rtlpriv, REG_RXDMA_AGG_PG_TH, temp);
+	}
+
+	rtl_write_byte(rtlpriv, REG_TRXDMA_CTRL, valueDMA);
+}
+static void init_UsbAggregationSetting_8812A(struct rtl_priv *rtlpriv)
+{
+	 struct _rtw_hal	*pHalData = GET_HAL_DATA(rtlpriv);
+
+	/* Tx aggregation setting */
+	usb_AggSettingTxUpdate_8812A(rtlpriv);
+
+	/* Rx aggregation setting */
+	usb_AggSettingRxUpdate_8812A(rtlpriv);
+
+	/* 201/12/10 MH Add for USB agg mode dynamic switch. */
+	pHalData->UsbRxHighSpeedMode = false;
+}
+
+static void _InitAntenna_Selection_8812A(struct rtl_priv *rtlpriv)
+{
+	 struct _rtw_hal	*pHalData	= GET_HAL_DATA(rtlpriv);
+
+	if (pHalData->AntDivCfg == 0)
+		return;
+
+	rtl_write_byte(rtlpriv, REG_LEDCFG2, 0x82);
+
+	rtl_set_bbreg(rtlpriv, RFPGA0_XAB_RFPARAMETER, BIT(13), 0x01);
+
+	if (rtl_get_bbreg(rtlpriv, rFPGA0_XA_RFInterfaceOE, 0x300) == MAIN_ANT)
+		pHalData->CurAntenna = MAIN_ANT;
+	else
+		pHalData->CurAntenna = AUX_ANT;
+}
+
+static void _rtl8812au_bb8812_config_1t(struct rtl_priv *rtlpriv)
+{
+	/* BB OFDM RX Path_A */
+	rtl_set_bbreg(rtlpriv, rRxPath_Jaguar, bRxPath_Jaguar, 0x11);
+	/* BB OFDM TX Path_A */
+	rtl_set_bbreg(rtlpriv, rTxPath_Jaguar, bMaskLWord, 0x1111);
+	/* BB CCK R/Rx Path_A */
+	rtl_set_bbreg(rtlpriv, rCCK_RX_Jaguar, bCCK_RX_Jaguar, 0x0);
+	/* MCS support */
+	rtl_set_bbreg(rtlpriv, 0x8bc, 0xc0000060, 0x4);
+	/* RF Path_B HSSI OFF */
+	rtl_set_bbreg(rtlpriv, 0xe00, 0xf, 0x4);
+	/* RF Path_B Power Down */
+	rtl_set_bbreg(rtlpriv, 0xe90, bMaskDWord, 0);
+	/* ADDA Path_B OFF */
+	rtl_set_bbreg(rtlpriv, 0xe60, bMaskDWord, 0);
+	rtl_set_bbreg(rtlpriv, 0xe64, bMaskDWord, 0);
+}
+
+
+
+static int PHY_RFConfig8812(struct rtl_priv *rtlpriv)
+{
+	int rtStatus = _SUCCESS;
+
+	if (rtlpriv->bSurpriseRemoved)
+		return _FAIL;
+
+	rtStatus = rtl8821au_phy_rf6052_config(rtlpriv);
+
+	return rtStatus;
+}
+
+uint32_t rtl8812au_hw_init(struct rtl_priv *rtlpriv)
+{
+	struct rtl_phy *rtlphy = &(rtlpriv->phy);
+	struct rtl_hal *rtlhal = rtl_hal(rtlpriv);
+	struct rtl_mac *mac = rtl_mac(rtlpriv);
+	uint8_t	value8 = 0, u1bRegCR;
+	uint8_t	txpktbuf_bndy;
+	uint32_t	status = _SUCCESS;
+
+	/* ULLI : for debuging USB3 issue, getting USB ID during hw init */
+	struct rtl_usb_priv *usbpriv = rtl_usbpriv(rtlpriv);
+	struct usb_device *udev = usbpriv->dev.udev;
+	char *speed;
+
+	 struct _rtw_hal *pHalData = GET_HAL_DATA(rtlpriv);
+	struct pwrctrl_priv *pwrctrlpriv = &rtlpriv->pwrctrlpriv;
+	enum rf_pwrstate eRfPowerStateToSet;
+	uint32_t init_start_time = jiffies;
+
+	switch (udev->speed) {
+		case USB_SPEED_LOW :	speed = "LOW";
+					break;
+		case USB_SPEED_FULL :	speed = "FULL";
+					break;
+		case USB_SPEED_HIGH :	speed = "HIGH";
+					break;
+		case USB_SPEED_SUPER :	speed = "HIGH";
+					break;
+		default :		speed = "UNKNOWN";
+					break;
+	}
+
+	dev_info(&udev->dev, "rtl8821au: hw_init USB-ID %04x:%04x %s %s %s-SPEED \n",
+		udev->descriptor.idVendor, udev->descriptor.idProduct,
+		udev->product, udev->manufacturer, speed);
+
+	/* Check if MAC has already power on. by tynli. 2011.05.27. */
+	value8 = rtl_read_byte(rtlpriv, REG_SYS_CLKR+1);
+	u1bRegCR = rtl_read_byte(rtlpriv, REG_CR);
+	RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD, " power-on :REG_SYS_CLKR 0x09=0x%02x. REG_CR 0x100=0x%02x.\n", value8, u1bRegCR);
+	if ((value8&BIT(3))  && (u1bRegCR != 0 && u1bRegCR != 0xEA)) {
+		/* pHalData->bMACFuncEnable = true; */
+		RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD, " MAC has already power on.\n");
+	} else {
+		/*
+		 * pHalData->bMACFuncEnable = false;
+		 * Set FwPSState to ALL_ON mode to prevent from the I/O be return because of 32k
+		 * state which is set before sleep under wowlan mode. 2012.01.04. by tynli.
+		 * pHalData->FwPSState = FW_PS_STATE_ALL_ON_88E;
+		 */
+		RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD, " MAC has not been powered on yet.\n");
+	}
+
+	/*
+	 * 2012/11/13 MH Revise for U2/U3 switch we can not update RF-A/B reset.
+	 * After discuss with BB team YN, reset after MAC power on to prevent RF
+	 * R/W error. Is it a right method?
+	 */
+	if (!IS_HARDWARE_TYPE_8821(rtlhal)) {
+		rtl_write_byte(rtlpriv, REG_RF_CTRL, 5);
+		rtl_write_byte(rtlpriv, REG_RF_CTRL, 7);
+		rtl_write_byte(rtlpriv, REG_RF_B_CTRL_8812, 5);
+		rtl_write_byte(rtlpriv, REG_RF_B_CTRL_8812, 7);
+	}
+
+	status = _InitPowerOn8812AU(rtlpriv);
+	if (status == _FAIL) {
+		goto exit;
+	}
+
+		if (IS_HARDWARE_TYPE_8812(rtlhal))
+			txpktbuf_bndy = TX_PAGE_BOUNDARY_8812;
+		else
+			txpktbuf_bndy = TX_PAGE_BOUNDARY_8821;
+
+	status =  _rtl8821au_llt_table_init(rtlpriv, txpktbuf_bndy);
+	if (status == _FAIL) {
+		goto exit;
+	}
+
+#if ENABLE_USB_DROP_INCORRECT_OUT
+	_InitHardwareDropIncorrectBulkOut_8812A(rtlpriv);
+#endif
+
+	if (pHalData->bRDGEnable)
+		_InitRDGSetting_8812A(rtlpriv);
+
+	status = rtl8821au_download_fw(rtlpriv, false);
+	if (status != _SUCCESS) {
+		RT_TRACE(rtlpriv, COMP_FW, DBG_LOUD, "%s: Download Firmware failed!!\n", __FUNCTION__);
+		rtlhal->fw_ready = false;
+		pHalData->fw_ractrl = false;
+		/* return status; */
+	} else {
+		RT_TRACE(rtlpriv, COMP_FW, DBG_LOUD, "%s: Download Firmware Success!!\n", __FUNCTION__);
+		rtlhal->fw_ready = true;
+		pHalData->fw_ractrl = true;
+	}
+
+	InitializeFirmwareVars8812(rtlpriv);
+
+	if (pwrctrlpriv->reg_rfoff == true)
+		pwrctrlpriv->rf_pwrstate = ERFOFF;
+
+	/*
+	 * 2010/08/09 MH We need to check if we need to turnon or off RF after detecting
+	 * HW GPIO pin. Before PHY_RFConfig8192C.
+	 * HalDetectPwrDownMode(rtlpriv);
+	 * 2010/08/26 MH If Efuse does not support sective suspend then disable the function.
+	 * HalDetectSelectiveSuspendMode(rtlpriv);
+	 */
+
+	/*
+	 * Save target channel
+	 * <Roger_Notes> Current Channel will be updated again later.
+	 */
+	rtlpriv->phy.current_channel = 0;	/* set 0 to trigger switch correct channel */
+
+	 _rtl8821au_phy_config_mac_with_headerfile(rtlpriv);
+
+	if (IS_HARDWARE_TYPE_8812(rtlhal)) {
+		_InitQueueReservedPage_8812AUsb(rtlpriv);
+		_InitTxBufferBoundary_8812AUsb(rtlpriv);
+	} else if (IS_HARDWARE_TYPE_8821(rtlhal)) {
+		_InitQueueReservedPage_8821AUsb(rtlpriv);
+		_InitTxBufferBoundary_8821AUsb(rtlpriv);
+	}
+
+	_rtl8821au_init_chipN_queue_priority(rtlpriv);
+	_InitPageBoundary_8812AUsb(rtlpriv);
+
+	if (IS_HARDWARE_TYPE_8812(rtlhal))
+		_InitTransferPageSize_8812AUsb(rtlpriv);
+
+	/* Get Rx PHY status in order to report RSSI and others. */
+	_InitDriverInfoSize_8812A(rtlpriv, DRVINFO_SZ);
+
+	rtlpriv->cfg->ops->enable_interrupt(rtlpriv);
+
+	rtlpriv->cfg->ops->set_hw_reg(rtlpriv, HW_VAR_ETHER_ADDR, mac->mac_addr);
+
+	_InitNetworkType_8812A(rtlpriv);	/* set msr */
+	_InitWMACSetting_8812A(rtlpriv);
+	_InitAdaptiveCtrl_8812AUsb(rtlpriv);
+	_InitEDCA_8812AUsb(rtlpriv);
+
+	_InitRetryFunction_8812A(rtlpriv);
+	init_UsbAggregationSetting_8812A(rtlpriv);
+	rtl8821au_init_beacon_parameters(rtlpriv);
+	_InitBeaconMaxError_8812A(rtlpriv, true);
+
+	_InitBurstPktLen(rtlpriv);  /* added by page. 20110919 */
+
+	/*
+	 * Init CR MACTXEN, MACRXEN after setting RxFF boundary REG_TRXFF_BNDY to patch
+	 * Hw bug which Hw initials RxFF boundry size to a value which is larger than the real Rx buffer size in 88E.
+	 * 2011.08.05. by tynli.
+	 */
+	value8 = rtl_read_byte(rtlpriv, REG_CR);
+	rtl_write_byte(rtlpriv, REG_CR, (value8|MACTXEN|MACRXEN));
+
+#if defined(CONFIG_TX_MCAST2UNI)
+
+#ifdef CONFIG_TX_MCAST2UNI
+	rtl_write_word(rtlpriv, REG_PKT_VO_VI_LIFE_TIME, 0x0400);	/* unit: 256us. 256ms */
+	rtl_write_word(rtlpriv, REG_PKT_BE_BK_LIFE_TIME, 0x0400);	/* unit: 256us. 256ms */
+#else
+	rtl_write_word(rtlpriv, REG_PKT_VO_VI_LIFE_TIME, 0x3000);	/* unit: 256us. 3s */
+	rtl_write_word(rtlpriv, REG_PKT_BE_BK_LIFE_TIME, 0x3000);	/* unit: 256us. 3s */
+#endif
+#endif
+
+	/*
+	 * d. Initialize BB related configurations.
+	 */
+
+
+	status = rtl8821au_phy_bb_config(rtlpriv);
+
+	if (status == _FAIL)
+		goto exit;
+
+	/*
+	 * 92CU use 3-wire to r/w RF
+	 * pHalData->Rf_Mode = RF_OP_By_SW_3wire;
+	 */
+
+	status = PHY_RFConfig8812(rtlpriv);
+	if (status == _FAIL)
+		goto exit;
+
+	if (rtlpriv->phy.rf_type == RF_1T1R && IS_HARDWARE_TYPE_8812AU(rtlhal))
+		_rtl8812au_bb8812_config_1t(rtlpriv);
+
+	if (rtlpriv->registrypriv.channel <= 14)
+		rtl8821au_phy_switch_wirelessband(rtlpriv, BAND_ON_2_4G);
+	else
+		rtl8821au_phy_switch_wirelessband(rtlpriv, BAND_ON_5G);
+
+	rtlpriv->cfg->ops->set_chnl_bw_handler(rtlpriv, rtlpriv->registrypriv.channel,
+					       CHANNEL_WIDTH_20, 
+					       HAL_PRIME_CHNL_OFFSET_DONT_CARE, 
+					       HAL_PRIME_CHNL_OFFSET_DONT_CARE);
+
+	rtw_cam_reset_all_entry(rtlpriv);
+
+	_InitAntenna_Selection_8812A(rtlpriv);
+
+	/*
+	 * HW SEQ CTRL
+	 * set 0x0 to 0xFF by tynli. Default enable HW SEQ NUM.
+	 */
+	rtl_write_byte(rtlpriv, REG_HWSEQ_CTRL, 0xFF);
+
+	/*
+	 * Disable BAR, suggested by Scott
+	 * 2010.04.09 add by hpfan
+	 */
+	rtl_write_dword(rtlpriv, REG_BAR_MODE_CTRL, 0x0201ffff);
+
+	/* Nav limit , suggest by scott */
+	rtl_write_byte(rtlpriv, 0x652, 0x0);
+
+	rtl8812_dm_init(rtlpriv);
+
+	/*
+	 * 2010/08/11 MH Merge from 8192SE for Minicard init. We need to confirm current radio status
+	 * and then decide to enable RF or not.!!!??? For Selective suspend mode. We may not
+	 * call initstruct rtl_priv. May cause some problem??
+	 *
+	 * Fix the bug that Hw/Sw radio off before S3/S4, the RF off action will not be executed
+	 * in MgntActSet_RF_State() after wake up, because the value of pHalData->eRFPowerState
+	 * is the same as eRfOff, we should change it to eRfOn after we config RF parameters.
+	 * Added by tynli. 2010.03.30.
+	 */
+	pwrctrlpriv->rf_pwrstate = ERFON;
+
+	/*
+	 * 0x4c6[3] 1: RTS BW = Data BW
+	 * 0: RTS BW depends on CCA / secondary CCA result.
+	 */
+	rtl_write_byte(rtlpriv, REG_QUEUE_CTRL, rtl_read_byte(rtlpriv, REG_QUEUE_CTRL)&0xF7);
+
+	/* enable Tx report. */
+	rtl_write_byte(rtlpriv,  REG_FWHW_TXQ_CTRL+1, 0x0F);
+
+	/* Suggested by SD1 pisa. Added by tynli. 2011.10.21. */
+	rtl_write_byte(rtlpriv, REG_EARLY_MODE_CONTROL_8812+3, 0x01);/* Pretx_en, for WEP/TKIP SEC */
+
+	/* tynli_test_tx_report. */
+	rtl_write_word(rtlpriv, REG_TX_RPT_TIME, 0x3DF0);
+
+	/* Reset USB mode switch setting */
+	rtl_write_byte(rtlpriv, REG_SDIO_CTRL_8812, 0x0);
+	rtl_write_byte(rtlpriv, REG_ACLK_MON, 0x0);
+
+	/*
+	 * RT_TRACE(COMP_INIT, DBG_TRACE, ("InitializeAdapter8188EUsb() <====\n"));
+	 */
+
+	/* 2010/08/26 MH Merge from 8192CE. */
+	if (pwrctrlpriv->rf_pwrstate == ERFON) {
+		if (IS_HARDWARE_TYPE_8812AU(rtlhal)) {
+			rtlphy->need_iqk = true;
+			if (rtlphy->iqk_initialized)
+				rtl8812au_phy_iq_calibrate(rtlpriv, true);
+			else {
+				rtl8812au_phy_iq_calibrate(rtlpriv, false);
+				rtlphy->iqk_initialized = true;
+			}
+		}
+
+
+		/* rtl8812au_phy_lc_calibrate(rtlpriv); */
+	}
+
+	/* HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_INIT_PABIAS);
+	 * _InitPABias(rtlpriv);
+	 */
+
+	/*
+	 *  2010/08/23 MH According to Alfred's suggestion, we need to to prevent HW enter
+	 *  suspend mode automatically.
+	 * HwSuspendModeEnable92Cu(rtlpriv, false);
+	 */
+
+
+	rtl_write_byte(rtlpriv, REG_USB_HRPWM, 0);
+
+	/* misc */
+	{
+		/* ULLI reading MAC address again ?? */
+		int i;
+		uint8_t mac_addr[6];
+		for (i = 0; i < 6; i++) {
+			mac_addr[i] = rtl_read_byte(rtlpriv, REG_MACID+i);
+		}
+
+		RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD, "MAC Address from REG_MACID = "MAC_FMT"\n", MAC_ARG(mac_addr));
+	}
+
+exit:
+
+	RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD, "%s in %dms\n", __FUNCTION__, rtw_get_passing_time_ms(init_start_time));
+
+	return status;
+}
+
+static void _rtl8812au_read_pa_type(struct rtl_priv *rtlpriv, uint8_t *hwinfo,
+			     bool autoload_fail)
+{
+	struct rtl_hal *rtlhal = rtl_hal(rtlpriv);
+
+	if (!autoload_fail) {
+		rtlhal->pa_type_2g = hwinfo[EEPROM_PA_TYPE_8812AU];
+		rtlhal->lna_type_2g = hwinfo[EEPROM_LNA_TYPE_2G_8812AU];
+
+		if (rtlhal->pa_type_2g == 0xFF && rtlhal->lna_type_2g == 0xFF) {
+			rtlhal->pa_type_2g = 0;
+			rtlhal->lna_type_2g = 0;
+		}
+
+		rtlhal->external_pa_2g = ((rtlhal->pa_type_2g & BIT(5)) &&
+					  (rtlhal->pa_type_2g & BIT(4))) ? 1 : 0;
+		rtlhal->external_lna_2g = ((rtlhal->lna_type_2g & BIT(7)) &&
+					   (rtlhal->lna_type_2g & BIT(3))) ? 1 : 0;
+
+		rtlhal->pa_type_5g = hwinfo[EEPROM_PA_TYPE_8812AU];
+		rtlhal->lna_type_5g = hwinfo[EEPROM_LNA_TYPE_5G_8812AU];
+
+		if (rtlhal->pa_type_5g == 0xFF && rtlhal->lna_type_5g == 0xFF) {
+			rtlhal->pa_type_5g = 0;
+			rtlhal->lna_type_5g = 0;
+		}
+
+		rtlhal->external_pa_5g = ((rtlhal->pa_type_5g & BIT(1)) &&
+					  (rtlhal->pa_type_5g & BIT(0))) ? 1 : 0;
+		rtlhal->external_lna_5g = ((rtlhal->lna_type_5g & BIT(7)) &&
+					   (rtlhal->lna_type_5g & BIT(3))) ? 1 : 0;
+
+	} else {
+		rtlhal->external_pa_2g  = EEPROM_Default_PAType;
+		rtlhal->external_pa_5g  = 0xFF;
+		rtlhal->external_lna_2g = EEPROM_Default_LNAType;
+		rtlhal->external_lna_5g = 0xFF;
+
+		rtlhal->external_pa_2g  = 0;
+		rtlhal->external_lna_2g = 0;
+
+		rtlhal->external_pa_5g  = 0;
+		rtlhal->external_lna_5g = 0;
+	}
+	RT_TRACE(rtlpriv, COMP_EFUSE, DBG_LOUD, "pHalData->PAType_2G is 0x%x, pHalData->ExternalPA_2G = %d\n", rtlhal->pa_type_2g, rtlhal->external_pa_2g);
+	RT_TRACE(rtlpriv, COMP_EFUSE, DBG_LOUD, "pHalData->PAType_5G is 0x%x, pHalData->ExternalPA_5G = %d\n", rtlhal->pa_type_5g, rtlhal->external_pa_5g);
+	RT_TRACE(rtlpriv, COMP_EFUSE, DBG_LOUD, "pHalData->LNAType_2G is 0x%x, pHalData->ExternalLNA_2G = %d\n", rtlhal->lna_type_2g, rtlhal->external_lna_2g);
+	RT_TRACE(rtlpriv, COMP_EFUSE, DBG_LOUD, "pHalData->LNAType_5G is 0x%x, pHalData->ExternalLNA_5G = %d\n", rtlhal->lna_type_5g, rtlhal->external_lna_5g);
+}
+
+static void _rtl8821au_read_pa_type(struct rtl_priv *rtlpriv, u8 *hwinfo,
+				    bool autoload_fail)
+{
+	struct rtl_hal *rtlhal = rtl_hal(rtlpriv);
+
+	if (!autoload_fail) {
+		rtlhal->pa_type_2g = hwinfo[EEPROM_PA_TYPE_8812AU];
+		rtlhal->lna_type_2g = hwinfo[EEPROM_LNA_TYPE_2G_8812AU];
+		if (rtlhal->pa_type_2g == 0xFF && rtlhal->lna_type_2g == 0xFF) {
+			rtlhal->pa_type_2g = 0;
+			rtlhal->lna_type_2g = 0;
+		}
+		rtlhal->external_pa_2g = (rtlhal->pa_type_2g & BIT(4)) ? 1 : 0;
+		rtlhal->external_lna_2g = (rtlhal->lna_type_2g & BIT(3)) ? 1 : 0;
+
+		rtlhal->pa_type_5g = hwinfo[EEPROM_PA_TYPE_8812AU];
+		rtlhal->lna_type_5g = hwinfo[EEPROM_LNA_TYPE_5G_8812AU];
+		if (rtlhal->pa_type_5g == 0xFF && rtlhal->lna_type_5g == 0xFF) {
+			rtlhal->pa_type_5g = 0;
+			rtlhal->lna_type_5g = 0;
+		}
+		rtlhal->external_pa_5g = (rtlhal->pa_type_5g & BIT(0)) ? 1 : 0;
+		rtlhal->external_lna_5g = (rtlhal->lna_type_5g & BIT(3)) ? 1 : 0;
+	} else {
+		rtlhal->external_pa_2g  = EEPROM_Default_PAType;
+		rtlhal->external_pa_5g  = 0xFF;
+		rtlhal->external_lna_2g = EEPROM_Default_LNAType;
+		rtlhal->external_lna_5g = 0xFF;
+
+		rtlhal->external_pa_2g  = 0;
+		rtlhal->external_lna_2g = 0;
+
+		rtlhal->external_pa_5g  = 0;
+		rtlhal->external_lna_5g = 0;
+	}
+	RT_TRACE(rtlpriv, COMP_EFUSE, DBG_LOUD, "pHalData->PAType_2G is 0x%x, pHalData->ExternalPA_2G = %d\n", rtlhal->pa_type_2g, rtlhal->external_pa_2g);
+	RT_TRACE(rtlpriv, COMP_EFUSE, DBG_LOUD, "pHalData->PAType_5G is 0x%x, pHalData->ExternalPA_5G = %d\n", rtlhal->pa_type_5g, rtlhal->external_pa_5g);
+	RT_TRACE(rtlpriv, COMP_EFUSE, DBG_LOUD, "pHalData->LNAType_2G is 0x%x, pHalData->ExternalLNA_2G = %d\n", rtlhal->lna_type_2g, rtlhal->external_lna_2g);
+	RT_TRACE(rtlpriv, COMP_EFUSE, DBG_LOUD, "pHalData->LNAType_5G is 0x%x, pHalData->ExternalLNA_5G = %d\n", rtlhal->lna_type_5g, rtlhal->external_lna_5g);
+}
+
+static void _rtl8821au_read_power_value_fromprom(struct rtl_priv *rtlpriv,
+	struct txpower_info_2g *pwrinfo24g,
+	struct txpower_info_5g *pwrinfo5g,
+	u8 *hwinfo,
+	bool autoload_fail)
+{
+	 struct _rtw_hal	*pHalData = GET_HAL_DATA(rtlpriv);
+	uint32_t rfPath, eeAddr = EEPROM_TX_PWR_INX_8812, group, TxCount = 0;
+
+	memset(pwrinfo24g, 0, sizeof(*pwrinfo24g));
+	memset(pwrinfo5g, 0, sizeof(*pwrinfo5g));
+
+	/* DBG_871X("hal_ReadPowerValueFromPROM8812A(): PROMContent[0x%x]=0x%x\n", (eeAddr+1), PROMContent[eeAddr+1]); */
+	if (0xFF == hwinfo[eeAddr+1])  /* YJ,add,120316 */
+		autoload_fail = true;
+
+	if (autoload_fail) {
+		RT_TRACE(rtlpriv, COMP_POWER, DBG_LOUD, "hal_ReadPowerValueFromPROM8812A(): Use Default value!\n");
+		for (rfPath = 0 ; rfPath < MAX_RF_PATH ; rfPath++) {
+			/*  2.4G default value */
+			for (group = 0 ; group < MAX_CHNL_GROUP_24G; group++) {
+				pwrinfo24g->index_cck_base[rfPath][group] = EEPROM_DEFAULT_24G_INDEX;
+				pwrinfo24g->index_bw40_base[rfPath][group] = EEPROM_DEFAULT_24G_INDEX;
+			}
+			for (TxCount = 0; TxCount < MAX_TX_COUNT; TxCount++) {
+				if (TxCount == 0) {
+					pwrinfo24g->bw20_diff[rfPath][0] = EEPROM_DEFAULT_24G_HT20_DIFF;
+					pwrinfo24g->ofdm_diff[rfPath][0] = EEPROM_DEFAULT_24G_OFDM_DIFF;
+				} else {
+					pwrinfo24g->bw20_diff[rfPath][TxCount] = EEPROM_DEFAULT_DIFF;
+					pwrinfo24g->bw40_diff[rfPath][TxCount] = EEPROM_DEFAULT_DIFF;
+					pwrinfo24g->cck_diff[rfPath][TxCount] =	EEPROM_DEFAULT_DIFF;
+					pwrinfo24g->ofdm_diff[rfPath][TxCount] = EEPROM_DEFAULT_DIFF;
+				}
+			}
+
+			/* 5G default value */
+			for (group = 0 ; group < MAX_CHNL_GROUP_5G; group++)
+				pwrinfo5g->index_bw40_base[rfPath][group] = EEPROM_DEFAULT_5G_INDEX;
+
+			for (TxCount = 0; TxCount < MAX_TX_COUNT; TxCount++) {
+				if (TxCount == 0) {
+					pwrinfo5g->ofdm_diff[rfPath][0] = EEPROM_DEFAULT_5G_OFDM_DIFF;
+					pwrinfo5g->bw20_diff[rfPath][0] = EEPROM_DEFAULT_5G_HT20_DIFF;
+					pwrinfo5g->bw80_diff[rfPath][0] = EEPROM_DEFAULT_DIFF;
+					pwrinfo5g->bw160_diff[rfPath][0] = EEPROM_DEFAULT_DIFF;
+				} else {
+					/* ULLI check for-loop in _rtl8821ae_read_power_fromprom() */
+					pwrinfo5g->ofdm_diff[rfPath][TxCount] =	EEPROM_DEFAULT_DIFF;
+					pwrinfo5g->bw20_diff[rfPath][TxCount] =	EEPROM_DEFAULT_DIFF;
+					pwrinfo5g->bw40_diff[rfPath][TxCount] =	EEPROM_DEFAULT_DIFF;
+					pwrinfo5g->bw80_diff[rfPath][TxCount] =	EEPROM_DEFAULT_DIFF;
+					pwrinfo5g->bw160_diff[rfPath][TxCount] = EEPROM_DEFAULT_DIFF;
+
+				}
+			}
+
+		}
+
+		/* pHalData->bNOPG = true; */
+		return;
+	}
+
+	pHalData->bTXPowerDataReadFromEEPORM = true;		/* YJ,move,120316 */
+
+	for (rfPath = 0; rfPath < MAX_RF_PATH; rfPath++) {
+		/*  2.4G default value */
+		for (group = 0; group < MAX_CHNL_GROUP_24G; group++) {
+			pwrinfo24g->index_cck_base[rfPath][group] = hwinfo[eeAddr++];
+			if (pwrinfo24g->index_cck_base[rfPath][group] == 0xFF) {
+				pwrinfo24g->index_cck_base[rfPath][group] = EEPROM_DEFAULT_24G_INDEX;
+				/* pHalData->bNOPG = true; */
+			}
+			/*
+			 * DBG_871X("8812-2G RF-%d-G-%d CCK-Addr-%x BASE=%x\n",
+			 * rfPath, group, eeAddr-1, pwrInfo24G->IndexCCK_Base[rfPath][group]);
+			 */
+		}
+
+		for (group = 0; group < MAX_CHNL_GROUP_24G-1; group++) {
+			pwrinfo24g->index_bw40_base[rfPath][group] = hwinfo[eeAddr++];
+			if (pwrinfo24g->index_bw40_base[rfPath][group] == 0xFF)
+				pwrinfo24g->index_bw40_base[rfPath][group] = EEPROM_DEFAULT_24G_INDEX;
+			/*
+			 * DBG_871X("8812-2G RF-%d-G-%d BW40-Addr-%x BASE=%x\n",
+			 * rfPath, group, eeAddr-1, pwrInfo24G->IndexBW40_Base[rfPath][group]);
+			 */
+		}
+
+		for (TxCount = 0; TxCount < MAX_TX_COUNT; TxCount++) {
+			if (TxCount == 0) {
+				pwrinfo24g->bw40_diff[rfPath][TxCount] = 0;
+
+				pwrinfo24g->bw20_diff[rfPath][TxCount] = (hwinfo[eeAddr] & 0xf0) >> 4;
+				if (pwrinfo24g->bw20_diff[rfPath][TxCount] & BIT(3))		/* 4bit sign number to 8 bit sign number */
+					pwrinfo24g->bw20_diff[rfPath][TxCount] |= 0xF0;
+
+				/*
+				 * DBG_871X("8812-2G RF-%d-SS-%d BW20-Addr-%x DIFF=%d\n",
+				 * rfPath, TxCount, eeAddr, pwrInfo24G->BW20_Diff[rfPath][TxCount]);
+				 */
+
+				pwrinfo24g->ofdm_diff[rfPath][TxCount] =	(hwinfo[eeAddr]&0x0f);
+				if (pwrinfo24g->ofdm_diff[rfPath][TxCount] & BIT(3))		/* 4bit sign number to 8 bit sign number */
+					pwrinfo24g->ofdm_diff[rfPath][TxCount] |= 0xF0;
+
+				/*
+				 * DBG_871X("8812-2G RF-%d-SS-%d LGOD-Addr-%x DIFF=%d\n",
+				 * rfPath, TxCount, eeAddr, pwrInfo24G->OFDM_Diff[rfPath][TxCount]);
+				 */
+
+				pwrinfo24g->cck_diff[rfPath][TxCount] = 0;
+				eeAddr++;
+			} else {
+				pwrinfo24g->bw40_diff[rfPath][TxCount] =	(hwinfo[eeAddr]&0xf0)>>4;
+				if (pwrinfo24g->bw40_diff[rfPath][TxCount] & BIT(3))		/* 4bit sign number to 8 bit sign number */
+					pwrinfo24g->bw40_diff[rfPath][TxCount] |= 0xF0;
+
+				/*
+				 * DBG_871X("8812-2G RF-%d-SS-%d BW40-Addr-%x DIFF=%d\n",
+				 * rfPath, TxCount, eeAddr, pwrInfo24G->BW40_Diff[rfPath][TxCount]);
+				 */
+
+				pwrinfo24g->bw20_diff[rfPath][TxCount] =	(hwinfo[eeAddr]&0x0f);
+				if (pwrinfo24g->bw20_diff[rfPath][TxCount] & BIT(3))		/* 4bit sign number to 8 bit sign number */
+					pwrinfo24g->bw20_diff[rfPath][TxCount] |= 0xF0;
+
+				/*
+				 * DBG_871X("8812-2G RF-%d-SS-%d BW20-Addr-%x DIFF=%d\n",
+				 * rfPath, TxCount, eeAddr, pwrInfo24G->BW20_Diff[rfPath][TxCount]);
+				 */
+
+				eeAddr++;
+
+
+				pwrinfo24g->ofdm_diff[rfPath][TxCount] =	(hwinfo[eeAddr]&0xf0)>>4;
+				if (pwrinfo24g->ofdm_diff[rfPath][TxCount] & BIT(3))		/* 4bit sign number to 8 bit sign number */
+					pwrinfo24g->ofdm_diff[rfPath][TxCount] |= 0xF0;
+
+				/*
+				 * DBG_871X("8812-2G RF-%d-SS-%d LGOD-Addr-%x DIFF=%d\n",
+				 * rfPath, TxCount, eeAddr, pwrInfo24G->BW20_Diff[rfPath][TxCount]);
+				 */
+
+				pwrinfo24g->cck_diff[rfPath][TxCount] =	(hwinfo[eeAddr]&0x0f);
+				if (pwrinfo24g->cck_diff[rfPath][TxCount] & BIT(3))		/* 4bit sign number to 8 bit sign number */
+					pwrinfo24g->cck_diff[rfPath][TxCount] |= 0xF0;
+				/*
+				 * DBG_871X("8812-2G RF-%d-SS-%d CCK-Addr-%x DIFF=%d\n",
+				 * rfPath, TxCount, eeAddr, pwrInfo24G->CCK_Diff[rfPath][TxCount]);
+				 */
+
+				eeAddr++;
+			}
+		}
+
+		/* 5G default value */
+		for (group = 0 ; group < MAX_CHNL_GROUP_5G; group++) {
+			pwrinfo5g->index_bw40_base[rfPath][group] =		hwinfo[eeAddr++];
+			if (pwrinfo5g->index_bw40_base[rfPath][group] == 0xFF)
+				pwrinfo5g->index_bw40_base[rfPath][group] = EEPROM_DEFAULT_DIFF;
+
+			/*
+			 * DBG_871X("8812-5G RF-%d-G-%d BW40-Addr-%x BASE=%x\n",
+			 * rfPath, TxCount, eeAddr-1, pwrInfo5G->IndexBW40_Base[rfPath][group]);
+			 */
+		}
+
+		for (TxCount = 0; TxCount < MAX_TX_COUNT; TxCount++) {
+			if (TxCount == 0) {
+				pwrinfo5g->bw40_diff[rfPath][TxCount] = 0;
+				pwrinfo5g->bw20_diff[rfPath][0] = (hwinfo[eeAddr] & 0xf0) >> 4;
+				if (pwrinfo5g->bw20_diff[rfPath][TxCount] & BIT(3))		/* 4bit sign number to 8 bit sign number */
+					pwrinfo5g->bw20_diff[rfPath][TxCount] |= 0xF0;
+				/*
+				 * DBG_871X("8812-5G RF-%d-SS-%d BW20-Addr-%x DIFF=%d\n",
+				 * rfPath, TxCount, eeAddr, pwrInfo5G->BW20_Diff[rfPath][TxCount]);
+				 */
+				pwrinfo5g->ofdm_diff[rfPath][0] = (hwinfo[eeAddr] & 0x0f);
+				if (pwrinfo5g->ofdm_diff[rfPath][TxCount] & BIT(3))		/* 4bit sign number to 8 bit sign number */
+					pwrinfo5g->ofdm_diff[rfPath][TxCount] |= 0xF0;
+				/*
+				 * DBG_871X("8812-5G RF-%d-SS-%d LGOD-Addr-%x DIFF=%d\n",
+				 * rfPath, TxCount, eeAddr, pwrInfo5G->OFDM_Diff[rfPath][TxCount]);
+				 */
+
+				eeAddr++;
+			} else {
+				pwrinfo5g->bw40_diff[rfPath][TxCount] = (hwinfo[eeAddr] & 0xf0) >> 4;
+				if (pwrinfo5g->bw40_diff[rfPath][TxCount] & BIT(3))		/* 4bit sign number to 8 bit sign number */
+					pwrinfo5g->bw40_diff[rfPath][TxCount] |= 0xF0;
+				/*
+				 * DBG_871X("8812-5G RF-%d-SS-%d BW40-Addr-%x DIFF=%d\n",
+				 * rfPath, TxCount, eeAddr, pwrInfo5G->BW40_Diff[rfPath][TxCount]);
+				 */
+
+				pwrinfo5g->bw20_diff[rfPath][TxCount] = (hwinfo[eeAddr] & 0x0f);
+				if (pwrinfo5g->bw20_diff[rfPath][TxCount] & BIT(3))		/* 4bit sign number to 8 bit sign number */
+					pwrinfo5g->bw20_diff[rfPath][TxCount] |= 0xF0;
+				/*
+				 * DBG_871X("8812-5G RF-%d-SS-%d BW20-Addr-%x DIFF=%d\n",
+				 * rfPath, TxCount, eeAddr, pwrInfo5G->BW20_Diff[rfPath][TxCount]);
+				 */
+
+				eeAddr++;
+			}
+		}
+
+
+		pwrinfo5g->ofdm_diff[rfPath][1] =	(hwinfo[eeAddr] & 0xf0) >> 4;
+		pwrinfo5g->ofdm_diff[rfPath][2] =	(hwinfo[eeAddr] & 0x0f);
+		/*
+		 * DBG_871X("8812-5G RF-%d-SS-%d LGOD-Addr-%x DIFF=%d\n",
+		 * rfPath, 2, eeAddr, pwrInfo5G->OFDM_Diff[rfPath][2]);
+		 */
+		eeAddr++;
+
+		pwrinfo5g->ofdm_diff[rfPath][3] =	(hwinfo[eeAddr] & 0x0f);
+		/*
+		 * DBG_871X("8812-5G RF-%d-SS-%d LGOD-Addr-%x DIFF=%d\n",
+		 * rfPath, 3, eeAddr, pwrInfo5G->OFDM_Diff[rfPath][3]);
+		 */
+		eeAddr++;
+
+		for (TxCount = 1; TxCount < MAX_TX_COUNT; TxCount++) {
+			if (pwrinfo5g->ofdm_diff[rfPath][TxCount] & BIT(3))		/* 4bit sign number to 8 bit sign number */
+				pwrinfo5g->ofdm_diff[rfPath][TxCount] |= 0xF0;
+
+			/*
+			 * DBG_871X("8812-5G RF-%d-SS-%d LGOD-Addr-%x DIFF=%d\n",
+			 * rfPath, TxCount, eeAddr, pwrInfo5G->OFDM_Diff[rfPath][TxCount]);
+			 */
+		}
+
+		for (TxCount = 0; TxCount < MAX_TX_COUNT; TxCount++) {
+			pwrinfo5g->bw80_diff[rfPath][TxCount] =	(hwinfo[eeAddr] & 0xf0) >> 4;
+			if (pwrinfo5g->bw80_diff[rfPath][TxCount] & BIT(3))		/* 4bit sign number to 8 bit sign number */
+				pwrinfo5g->bw80_diff[rfPath][TxCount] |= 0xF0;
+			/*
+			 * DBG_871X("8812-5G RF-%d-SS-%d BW80-Addr-%x DIFF=%d\n",
+			 * rfPath, TxCount, eeAddr, pwrInfo5G->BW80_Diff[rfPath][TxCount]);
+			 */
+			pwrinfo5g->bw160_diff[rfPath][TxCount] =	(hwinfo[eeAddr] & 0x0f);
+			if (pwrinfo5g->bw160_diff[rfPath][TxCount] & BIT(3))		/* 4bit sign number to 8 bit sign number */
+				pwrinfo5g->bw160_diff[rfPath][TxCount] |= 0xF0;
+			/*
+			 * DBG_871X("8812-5G RF-%d-SS-%d BW160-Addr-%x DIFF=%d\n",
+			 * rfPath, TxCount, eeAddr, pwrInfo5G->BW160_Diff[rfPath][TxCount]);
+			 */
+			eeAddr++;
+		}
+	}
+
+}
+
+static u8 _rtl8821au_get_chnl_group(u8 chnl)
+{
+	u8 group = 0;
+
+	if (chnl <= 14) {
+		if (1 <= chnl && chnl <= 2)
+			group = 0;
+		else if (3  <= chnl && chnl <= 5)
+			group = 1;
+		else if (6  <= chnl && chnl <= 8)
+			group = 2;
+		else if (9  <= chnl && chnl <= 11)
+			group = 3;
+		else if (12 <= chnl && chnl <= 14)
+			group = 4;
+#if 0
+		else {
+			DBG_871X("==>mpt_GetChnlGroup8812A in 2.4 G, but chnl %d in Group not found \n", chnl);
+		}
+#endif
+	} else {
+		if      (36   <= chnl && chnl <=  42)
+			group = 0;
+		else if (44   <= chnl && chnl <=  48)
+			group = 1;
+		else if (50   <= chnl && chnl <=  58)
+			group = 2;
+		else if (60   <= chnl && chnl <=  64)
+			group = 3;
+		else if (100  <= chnl && chnl <= 106)
+			group = 4;
+		else if (108  <= chnl && chnl <= 114)
+			group = 5;
+		else if (116  <= chnl && chnl <= 122)
+			group = 6;
+		else if (124  <= chnl && chnl <= 130)
+			group = 7;
+		else if (132  <= chnl && chnl <= 138)
+			group = 8;
+		else if (140  <= chnl && chnl <= 144)
+			group = 9;
+		else if (149  <= chnl && chnl <= 155)
+			group = 10;
+		else if (157  <= chnl && chnl <= 161)
+			group = 11;
+		else if (165  <= chnl && chnl <= 171)
+			group = 12;
+		else if (173  <= chnl && chnl <= 177)
+			group = 13;
+#if 0
+		else {
+			DBG_871X("==>mpt_GetChnlGroup8812A in 5G, but chnl %d in Group not found \n", chnl);
+		}
+#endif
+
+	}
+	/* DBG_871X("<==mpt_GetChnlGroup8812A,  (%s) Channel = %d, Group =%d,\n", (bIn24G) ? "2.4G" : "5G", Channel, *pGroup); */
+
+	return group;
+}
+
+static void _rtl88au_read_txpower_info_from_hwpg(struct rtl_priv *rtlpriv, u8 *hwinfo,
+	bool autoload_fail)
+{
+	struct rtl_efuse *efuse = rtl_efuse(rtlpriv);
+	struct txpower_info_2g pwrInfo24G;
+	struct txpower_info_5g pwrInfo5G;
+	uint8_t	rfPath, ch, group, TxCount;
+	uint8_t	channel5G[CHANNEL_MAX_NUMBER_5G] = {
+		 36,  38,  40,  42,  44,  46,  48,  50,  52,  54,  56,  58,
+		 60,  62,  64, 100, 102, 104, 106, 108, 110, 112, 114, 116,
+		118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140,
+		142, 144, 149, 151, 153, 155, 157, 159, 161, 163, 165, 167,
+		168, 169, 171, 173, 175, 177 };
+
+	uint8_t	channel5G_80M[CHANNEL_MAX_NUMBER_5G_80M] = {
+		42, 58, 106, 122, 138, 155, 171};
+
+	_rtl8821au_read_power_value_fromprom(rtlpriv, &pwrInfo24G, &pwrInfo5G, hwinfo, autoload_fail);
+
+	/*
+	 * if(!AutoLoadFail)
+	 * 	pHalData->bTXPowerDataReadFromEEPORM = true;
+	 */
+
+	for (rfPath = 0; rfPath < MAX_RF_PATH; rfPath++) {
+		for (ch = 0 ; ch < CHANNEL_MAX_NUMBER_2G; ch++) {
+			group = _rtl8821au_get_chnl_group(ch+1);
+
+			if (ch == (CHANNEL_MAX_NUMBER_2G-1)) {
+				efuse->txpwrlevel_cck[rfPath][ch] =
+					pwrInfo24G.index_cck_base[rfPath][5];
+				efuse->txpwrlevel_ht40_1s[rfPath][ch] =
+					pwrInfo24G.index_bw40_base[rfPath][group];
+			} else {
+				efuse->txpwrlevel_cck[rfPath][ch] =
+					pwrInfo24G.index_cck_base[rfPath][group];
+				efuse->txpwrlevel_ht40_1s[rfPath][ch] =
+					pwrInfo24G.index_bw40_base[rfPath][group];
+			}
+
+			/*
+			 * DBG_871X("======= Path %d, ChannelIndex %d, Group %d=======\n",rfPath,ch, group);
+			 * DBG_871X("Index24G_CCK_Base[%d][%d] = 0x%x\n",rfPath,ch ,pHalData->Index24G_CCK_Base[rfPath][ch]);
+			 * DBG_871X("Index24G_BW40_Base[%d][%d] = 0x%x\n",rfPath,ch,pHalData->Index24G_BW40_Base[rfPath][ch]);
+			 */
+		}
+
+		for (ch = 0 ; ch < CHANNEL_MAX_NUMBER_5G; ch++) {
+			group = _rtl8821au_get_chnl_group(channel5G[ch]);
+
+			efuse->txpwr_5g_bw40base[rfPath][ch] = pwrInfo5G.index_bw40_base[rfPath][group];
+
+			/*
+			 * DBG_871X("======= Path %d, ChannelIndex %d, Group %d=======\n",rfPath,ch, group);
+			 * DBG_871X("Index5G_BW40_Base[%d][%d] = 0x%x\n",rfPath,ch,pHalData->Index5G_BW40_Base[rfPath][ch]);
+			 */
+		}
+		for (ch = 0 ; ch < CHANNEL_MAX_NUMBER_5G_80M; ch++) {
+			uint8_t	upper, lower;
+
+			group = _rtl8821au_get_chnl_group(channel5G_80M[ch]);
+			upper = pwrInfo5G.index_bw40_base[rfPath][group];
+			lower = pwrInfo5G.index_bw40_base[rfPath][group+1];
+
+			efuse->txpwr_5g_bw80base[rfPath][ch] = (upper + lower) / 2;
+
+			/*
+			 * DBG_871X("======= Path %d, ChannelIndex %d, Group %d=======\n",rfPath,ch, group);
+			 * DBG_871X("Index5G_BW80_Base[%d][%d] = 0x%x\n",rfPath,ch,pHalData->Index5G_BW80_Base[rfPath][ch]);
+			 */
+		}
+
+		for (TxCount = 0; TxCount < MAX_TX_COUNT; TxCount++) {
+			efuse->txpwr_cckdiff[rfPath][TxCount]  = pwrInfo24G.cck_diff[rfPath][TxCount];
+			efuse->txpwr_legacyhtdiff[rfPath][TxCount] = pwrInfo24G.ofdm_diff[rfPath][TxCount];
+			efuse->txpwr_ht20diff[rfPath][TxCount] = pwrInfo24G.bw20_diff[rfPath][TxCount];
+			efuse->txpwr_ht40diff[rfPath][TxCount] = pwrInfo24G.bw40_diff[rfPath][TxCount];
+
+			efuse->txpwr_5g_ofdmdiff[rfPath][TxCount] = pwrInfo5G.ofdm_diff[rfPath][TxCount];
+			efuse->txpwr_5g_bw20diff[rfPath][TxCount] = pwrInfo5G.bw20_diff[rfPath][TxCount];
+			efuse->txpwr_5g_bw40diff[rfPath][TxCount] = pwrInfo5G.bw40_diff[rfPath][TxCount];
+			efuse->txpwr_5g_bw80diff[rfPath][TxCount] = pwrInfo5G.bw80_diff[rfPath][TxCount];
+/* #if DBG */
+		}
+	}
+
+
+	/* 2010/10/19 MH Add Regulator recognize for CU. */
+	if (!autoload_fail) {
+		if (hwinfo[EEPROM_RF_BOARD_OPTION_8812] == 0xFF)
+			efuse->eeprom_regulatory = (EEPROM_DEFAULT_BOARD_OPTION&0x7);	/* BIT(0)~2 */
+		else
+			efuse->eeprom_regulatory = (hwinfo[EEPROM_RF_BOARD_OPTION_8812]&0x7);	/* BIT(0)~2 */
+
+	} else {
+		efuse->eeprom_regulatory = 0;
+	}
+	RT_TRACE(rtlpriv, COMP_EFUSE, DBG_LOUD, "EEPROMRegulatory = 0x%x\n", efuse->eeprom_regulatory);
+
+}
diff -Naur linux-4.9/drivers/staging/rtl8821au/rtl8821au/hw.h linux-4.9.8821au/drivers/staging/rtl8821au/rtl8821au/hw.h
--- linux-4.9/drivers/staging/rtl8821au/rtl8821au/hw.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/rtl8821au/hw.h	2016-12-11 19:48:25.180311687 -0600
@@ -0,0 +1,24 @@
+#ifndef __RTL8821AU_HW_H__
+#define __RTL8821AU_HW_H__
+
+
+#include <rtl8812a_hal.h>
+
+void rtl8821au_read_chip_version(struct rtl_priv *rtlpriv);
+void rtl8821au_set_hw_reg(struct rtl_priv *rtlpriv, u8 variable,u8 *val);
+void rtl8821au_get_hw_reg(struct rtl_priv *rtlpriv, u8 variable,u8 *val);
+
+void rtl8821au_set_beacon_related_registers(struct rtl_priv *rtlpriv);
+uint32_t rtl8812au_hw_init(struct rtl_priv *rtlpriv);
+void rtl8821au_init_beacon_parameters(struct rtl_priv *rtlpriv);
+int32_t	 _rtl8821au_llt_table_init(struct rtl_priv *rtlpriv, uint8_t txpktbuf_bndy);
+void rtl8821au_enable_interrupt(struct rtl_priv *rtlpriv);
+void rtl8821au_disable_interrupt(struct rtl_priv *rtlpriv);
+
+/* temporaly prototypes for transition */
+
+void Set_MSR(struct rtl_priv *rtlpriv, uint8_t type);
+bool rtl8821au_gpio_radio_on_off_checking(struct rtl_priv *rtlpriv, u8 *valid);
+int rtl8821au_set_network_type(struct rtl_priv *rtlpriv, uint8_t mode);
+
+#endif
diff -Naur linux-4.9/drivers/staging/rtl8821au/rtl8821au/led.c linux-4.9.8821au/drivers/staging/rtl8821au/rtl8821au/led.c
--- linux-4.9/drivers/staging/rtl8821au/rtl8821au/led.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/rtl8821au/led.c	2016-12-11 19:48:25.180311687 -0600
@@ -0,0 +1,293 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2012 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+#ifdef CONFIG_RTLWIFI
+
+#include <../drivers/net/wireless/realtek/rtlwifi/wifi.h>
+#include <../drivers/net/wireless/realtek/rtlwifi/use.h>
+
+#else
+
+#include <drv_types.h>
+
+#endif
+
+/*
+ * ULLI led.c is a mess, we have two different paths for
+ * rtl8812au and rtl8821au why ??
+ *
+ * And up too three leds ...
+ */
+
+/* for RTL8812AU */
+/* TP-LINK : LED_PIN_LED0 */
+/* LINKSYS : LED_PIN_LED0 -> traffic */
+/* LINKSYS : LED_PIN_LED2 -> WPS ?? or whatever */
+
+/* for RTL8821AU see LED PATH for HW info */
+/* For Digitus Wireless AC433 */
+/* DLINK DWA */
+
+/* 
+ * Better rewrite the mess for rtlwifi
+ * rtlwifi has (currently) no timer for the led blinkinbg thing
+ * only static on/off switching.
+ * For secure led :
+ * We *must* check ieee80211 for secure connection,
+ * but we can spoof user(space) width this. The other issue is, if 
+ * somebody changes the PCB layout. tought.
+ * Secure led is *currently* disabled
+ */
+
+static void _rtl8821au_init_led(struct rtl_priv *rtlpriv, 
+				struct rtl_led *pled, enum rtl_led_pin ledpin)
+{
+	pled->rtlpriv = rtlpriv;
+	pled->LedPin = ledpin;
+	pled->bLedOn = false;
+}
+
+static void _rtl8821au_deinit_led(struct rtl_led *pled)
+{
+}
+
+static void rtl8812au_sw_led_off(struct rtl_priv *rtlpriv, struct rtl_led *pLed)
+{
+	struct rtl_usb_priv *usbpriv = rtl_usbpriv(rtlpriv);
+	struct rtl_led_ctl *pledpriv = &(usbpriv->ledpriv);
+
+	uint8_t	LedCfg;
+	 struct _rtw_hal	*pHalData = GET_HAL_DATA(rtlpriv);
+
+	if (rtlpriv->bSurpriseRemoved == true) {
+		return;
+	}
+
+	{
+		switch (pLed->LedPin) {
+		case LED_PIN_GPIO0:
+			break;
+
+		case LED_PIN_LED0:
+			 if (pHalData->AntDivCfg == 0) {
+				LedCfg = rtl_read_byte(rtlpriv, REG_LEDCFG0);
+				LedCfg &= 0x70; 	/* Set to software control. */
+				rtl_write_byte(rtlpriv, REG_LEDCFG0, (LedCfg|BIT(3)|BIT(5)));
+			} else {
+				LedCfg = rtl_read_byte(rtlpriv, REG_LEDCFG2);
+				LedCfg &= 0xe0; 	/* Set to software control. */
+				rtl_write_byte(rtlpriv, REG_LEDCFG2, (LedCfg|BIT(3)|BIT(7)|BIT(6)|BIT(5)));
+			}
+			break;
+
+		case LED_PIN_LED1:
+			LedCfg = rtl_read_byte(rtlpriv, REG_LEDCFG1);
+			LedCfg &= 0x70; 	/* Set to software control. */
+			rtl_write_byte(rtlpriv, REG_LEDCFG1, (LedCfg|BIT(3)|BIT(5)));
+			break;
+
+		case LED_PIN_LED2:
+			LedCfg = rtl_read_byte(rtlpriv, REG_LEDCFG2);
+			LedCfg &= 0x70; 	/* Set to software control. */
+			rtl_write_byte(rtlpriv, REG_LEDCFG2, (LedCfg|BIT(3)|BIT(5)));
+			break;
+
+		default:
+			break;
+		}
+	}
+
+	pLed->bLedOn = false;
+}
+
+static void rtl8821au_sw_led_off(struct rtl_priv *rtlpriv, struct rtl_led *pLed)
+{
+	struct rtl_usb_priv *usbpriv = rtl_usbpriv(rtlpriv);
+	struct rtl_led_ctl *pledpriv = &(usbpriv->ledpriv);
+
+	struct rtl_hal *rtlhal = rtl_hal(rtlpriv);
+	struct _rtw_hal *pHalData = GET_HAL_DATA(rtlpriv);
+	uint8_t	LedCfg;
+
+	if (rtlpriv->bSurpriseRemoved == true) {
+		return;
+	}
+
+	{
+		switch (pLed->LedPin) {
+		case LED_PIN_GPIO0:
+			break;
+
+		case LED_PIN_LED0:
+		case LED_PIN_LED1:
+		case LED_PIN_LED2:
+			 if (IS_HARDWARE_TYPE_8821U(rtlhal)) {
+				LedCfg = rtl_read_byte(rtlpriv, REG_LEDCFG2);
+				LedCfg &= 0x20; 	/* Set to software control. */
+				rtl_write_byte(rtlpriv, REG_LEDCFG2, (LedCfg|BIT(3)|BIT(5)));
+			 }
+
+			break;
+
+
+		default:
+			break;
+		}
+	}
+
+	pLed->bLedOn = false;
+}
+
+static void rtl8812au_sw_led_on(struct rtl_priv *rtlpriv, struct rtl_led *pLed)
+{
+	uint8_t	LedCfg;
+	 struct _rtw_hal	*pHalData = GET_HAL_DATA(rtlpriv);
+
+	if ((rtlpriv->bSurpriseRemoved == true) || (rtlpriv->bDriverStopped == true)) {
+		return;
+	}
+
+	{
+		switch (pLed->LedPin) {
+		case LED_PIN_GPIO0:
+			break;
+
+		case LED_PIN_LED0:
+			if (pHalData->AntDivCfg == 0) {
+				LedCfg = rtl_read_byte(rtlpriv, REG_LEDCFG0);
+				rtl_write_byte(rtlpriv, REG_LEDCFG0, (LedCfg&0x70)|BIT(5)); /* SW control led0 on. */
+			} else {
+				LedCfg = rtl_read_byte(rtlpriv, REG_LEDCFG2);
+				rtl_write_byte(rtlpriv, REG_LEDCFG2, (LedCfg&0xe0)|BIT(7)|BIT(6)|BIT(5)); /* SW control led0 on. */
+			}
+			break;
+
+		case LED_PIN_LED1:
+			LedCfg = rtl_read_byte(rtlpriv, (REG_LEDCFG1));
+			rtl_write_byte(rtlpriv, (REG_LEDCFG1), (LedCfg&0x70)|BIT(5)); /* SW control led1 on. */
+			break;
+
+		case LED_PIN_LED2:
+			LedCfg = rtl_read_byte(rtlpriv, (REG_LEDCFG2));
+			rtl_write_byte(rtlpriv, (REG_LEDCFG2), (LedCfg&0x70)|BIT(5)); /* SW control led1 on. */
+			break;
+
+		default:
+			break;
+		}
+	}
+
+	pLed->bLedOn = true;
+}
+
+static void rtl8821au_sw_led_on(struct rtl_priv *rtlpriv, struct rtl_led *pLed)
+{
+	uint8_t	LedCfg;
+	struct rtl_hal *rtlhal = rtl_hal(rtlpriv);
+
+	if ((rtlpriv->bSurpriseRemoved == true) || (rtlpriv->bDriverStopped == true)) {
+		return;
+	}
+
+	 {
+		switch (pLed->LedPin) {
+		case LED_PIN_GPIO0:
+			break;
+
+		case LED_PIN_LED0:
+		case LED_PIN_LED1:
+		case LED_PIN_LED2:
+			if (IS_HARDWARE_TYPE_8821U(rtlhal)) {
+				LedCfg = rtl_read_byte(rtlpriv, REG_LEDCFG2);
+				rtl_write_byte(rtlpriv, REG_LEDCFG2, ((LedCfg&0x20) & (~BIT(3)))|BIT(5)); /* SW control led0 on. */
+			}
+
+			break;
+
+		default:
+			break;
+		}
+	}
+	pLed->bLedOn = true;
+}
+
+void rtl8821au_init_sw_leds(struct rtl_priv *rtlpriv)
+{
+	struct rtl_usb_priv *usbpriv = rtl_usbpriv(rtlpriv);
+		
+	_rtl8821au_init_led(rtlpriv, &(usbpriv->ledpriv.SwLed0), LED_PIN_LED0);
+	_rtl8821au_init_led(rtlpriv, &(usbpriv->ledpriv.SwLed1), LED_PIN_LED1);
+}
+
+void rtl8821au_deinit_sw_leds(struct rtl_priv *rtlpriv)
+{
+	struct rtl_usb_priv *usbpriv = rtl_usbpriv(rtlpriv);
+
+	_rtl8821au_deinit_led(&(usbpriv->ledpriv.SwLed0));
+	_rtl8821au_deinit_led(&(usbpriv->ledpriv.SwLed1));
+
+}
+
+static void _rtl8821au_sw_led_control(struct rtl_priv *rtlpriv,
+				      enum led_ctl_mode ledaction)
+{
+	struct rtl_hal *rtlhal = rtl_hal(rtlpriv);
+	struct rtl_usb_priv *usbpriv = rtl_usbpriv(rtlpriv);
+	
+	if (ledaction == LED_CTL_TX ||
+	    ledaction == LED_CTL_RX ||
+	    ledaction == LED_CTL_SITE_SURVEY ||
+	    ledaction == LED_CTL_LINK ||
+	    ledaction == LED_CTL_NO_LINK ||
+	    ledaction == LED_CTL_START_TO_LINK ||
+	    ledaction == LED_CTL_POWER_ON) {
+		if (IS_HARDWARE_TYPE_8812(rtlhal))
+			rtl8812au_sw_led_on(rtlpriv, &(usbpriv->ledpriv.SwLed0));
+		else
+			rtl8821au_sw_led_on(rtlpriv, &(usbpriv->ledpriv.SwLed0));
+	} else {
+		if (IS_HARDWARE_TYPE_8812(rtlhal))
+			rtl8812au_sw_led_off(rtlpriv, &(usbpriv->ledpriv.SwLed0));
+		else
+			rtl8821au_sw_led_off(rtlpriv, &(usbpriv->ledpriv.SwLed0));
+	}
+}
+
+void rtl8821au_led_control(struct rtl_priv *rtlpriv,
+			   enum led_ctl_mode ledaction)
+{
+#if 0	/* currently no power saving */	
+	struct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));
+
+	if ((ppsc->rfoff_reason > RF_CHANGE_BY_PS) &&
+	    (ledaction == LED_CTL_TX ||
+	     ledaction == LED_CTL_RX ||
+	     ledaction == LED_CTL_SITE_SURVEY ||
+	     ledaction == LED_CTL_LINK ||
+	     ledaction == LED_CTL_NO_LINK ||
+	     ledaction == LED_CTL_START_TO_LINK ||
+	     ledaction == LED_CTL_POWER_ON)) {
+		return;
+	}
+#endif	
+	RT_TRACE(rtlpriv, COMP_LED, DBG_LOUD, "ledaction %d\n", ledaction);
+	_rtl8821au_sw_led_control(rtlpriv, ledaction);
+}
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/rtl8821au/led.h linux-4.9.8821au/drivers/staging/rtl8821au/rtl8821au/led.h
--- linux-4.9/drivers/staging/rtl8821au/rtl8821au/led.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/rtl8821au/led.h	2016-12-11 19:48:25.180311687 -0600
@@ -0,0 +1,120 @@
+/******************************************************************************
+ *
+ * Copyright(c) 2007 - 2011 Realtek Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA
+ *
+ *
+ ******************************************************************************/
+
+#ifndef __RTL8821AU_LED_H__
+#define __RTL8821AU_LED_H__
+
+//================================================================================
+//	LED Behavior Constant.
+//================================================================================
+// Default LED behavior.
+//
+#define LED_BLINK_NORMAL_INTERVAL	100
+#define LED_BLINK_SLOWLY_INTERVAL	200
+#define LED_BLINK_LONG_INTERVAL	400
+#define LED_INITIAL_INTERVAL		1800
+
+// LED Customerization
+
+//ALPHA
+#define LED_BLINK_NO_LINK_INTERVAL_ALPHA	1000
+#define LED_BLINK_NO_LINK_INTERVAL_ALPHA_500MS 500 //add by ylb 20121012 for customer led for alpha
+#define LED_BLINK_LINK_INTERVAL_ALPHA		500	//500
+#define LED_BLINK_SCAN_INTERVAL_ALPHA		180 	//150
+#define LED_BLINK_FASTER_INTERVAL_ALPHA		50
+#define LED_BLINK_WPS_SUCESS_INTERVAL_ALPHA	5000
+
+// 111122 by hpfan: Customized for Xavi
+#define LED_CM11_BLINK_INTERVAL			300
+#define LED_CM11_LINK_ON_INTERVEL		3000
+
+//Netgear
+#define LED_BLINK_LINK_INTERVAL_NETGEAR		500
+#define LED_BLINK_LINK_SLOWLY_INTERVAL_NETGEAR		1000
+
+#define LED_WPS_BLINK_OFF_INTERVAL_NETGEAR		100
+#define LED_WPS_BLINK_ON_INTERVAL_NETGEAR		500
+
+//Belkin AC950
+#define LED_BLINK_LINK_INTERVAL_ON_BELKIN		200
+#define LED_BLINK_LINK_INTERVAL_OFF_BELKIN		100
+#define LED_BLINK_ERROR_INTERVAL_BELKIN		100
+
+//================================================================================
+// LED object.
+//================================================================================
+
+enum led_ctl_mode {
+	LED_CTL_POWER_ON = 1,
+	LED_CTL_LINK = 2,
+	LED_CTL_NO_LINK = 3,
+	LED_CTL_TX = 4,
+	LED_CTL_RX = 5,
+	LED_CTL_SITE_SURVEY = 6,
+	LED_CTL_POWER_OFF = 7,
+	LED_CTL_START_TO_LINK = 8,
+	LED_CTL_START_WPS = 9,
+	LED_CTL_STOP_WPS = 10,
+};
+
+enum rtl_led_pin {
+	LED_PIN_GPIO0,
+	LED_PIN_LED0,
+	LED_PIN_LED1,
+	LED_PIN_LED2
+};
+
+
+//================================================================================
+// PCIE LED Definition.
+//================================================================================
+
+struct rtl_led {
+	struct rtl_priv *		rtlpriv;
+
+	enum rtl_led_pin		LedPin;	// Identify how to implement this SW led.
+
+	bool				bLedOn; // true if LED is ON, false if LED is OFF.
+
+	bool				bSWLedCtrl;
+};
+
+struct rtl_led_ctl {
+	/* add for led controll */
+	bool led_opendrain;
+	struct rtl_led SwLed0;
+	struct rtl_led SwLed1;
+	struct rtl_led SwLed2;
+	void (*SwLedOn)(struct rtl_priv *rtlpriv, struct rtl_led *pLed);
+	void (*SwLedOff)(struct rtl_priv *rtlpriv, struct rtl_led *pLed);
+	/* add for led controll */
+};
+
+//hal...
+
+//================================================================================
+// Interface to manipulate LED objects.
+//================================================================================
+
+void rtl8821au_init_sw_leds(struct rtl_priv *rtlpriv);
+void rtl8821au_deinit_sw_leds(struct rtl_priv *rtlpriv);
+void rtl8821au_led_control(struct rtl_priv *rtlpriv, enum led_ctl_mode LedAction);
+
+#endif
diff -Naur linux-4.9/drivers/staging/rtl8821au/rtl8821au/phy.c linux-4.9.8821au/drivers/staging/rtl8821au/rtl8821au/phy.c
--- linux-4.9/drivers/staging/rtl8821au/rtl8821au/phy.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/rtl8821au/phy.c	2016-12-11 19:48:25.183645006 -0600
@@ -0,0 +1,6592 @@
+#ifdef CONFIG_RTLWIFI
+
+#include <../drivers/net/wireless/realtek/rtlwifi/wifi.h>
+#include <../drivers/net/wireless/realtek/rtlwifi/ps.h>
+#include <../drivers/net/wireless/realtek/rtlwifi/base.h>
+
+#else
+
+#include <drv_types.h>
+#include <rtl8812a_hal.h>
+#include "phy.h"
+#include "dm.h"
+#include "table.h"
+#include "rf.h"
+#include "def.h"
+#include "reg.h"
+
+#endif
+
+/*
+ * 1. BB register R/W API
+ */
+
+#define TX_PWR_BY_RATE_NUM_RATE			84
+
+u8 _rtl8821au_get_txpower_index_base(struct rtl_priv *rtlpriv,
+				     u8 RFPath, u8 Rate,
+				     enum CHANNEL_WIDTH Bandwidth,
+				     u8 Channel,
+				     bool *bIn24G);
+
+static u8 _rtl8821au_phy_get_txpower_by_rate_base(struct rtl_priv *rtlpriv,
+					     u8 band,
+					     u8 path,
+					     u8 txnum, u8 rate_section);
+					     
+static s8 _rtl8821au_phy_get_txpower_by_rate(struct rtl_priv *rtlpriv,
+					     u8 Band, u8 RFPath,
+					     u8 TxNum, u8 Rate);
+
+static bool CheckPositive(struct rtl_priv *rtlpriv,
+			  uint32_t Condition1, uint32_t Condition2)
+{
+	struct rtl_hal *rtlhal = rtl_hal(rtlpriv);
+
+	u8 _BoardType = ((rtlhal->board_type & ODM_BOARD_EXT_LNA) ? 0x01 : 0) |
+			((rtlhal->board_type & ODM_BOARD_EXT_PA) ?  0x02 : 0) |
+			((rtlhal->board_type & ODM_BOARD_EXT_LNA_5G) ? 0x04 : 0) |
+			((rtlhal->board_type & ODM_BOARD_EXT_PA_5G) ? 0x10 : 0) |
+			/* ULLI : would be zero, but curently here for consistence */
+			((rtlhal->board_type & ODM_BOARD_BT) ? 0x10 : 0);
+#if 0
+	/* ULLI : From AWUSB driver
+	 * pDM_Odm->SupportInterface : RTW_USB 	 BIT(1),
+	 * pDM_Odm->SupportPlatform  : ODM_CE     0x04
+	 */
+#endif
+	uint32_t cond1   = Condition1, cond2 = Condition2;
+	uint32_t driver1 = NUM_CUT_VERSION(rtlhal->version) << 24 |
+		           ODM_CE << 16 |
+		           /* ULLI : pDM_Odm->PackageType      << 12 |  is zero */
+		           RTW_USB << 8  |
+		           _BoardType;
+	uint32_t driver2 = rtlhal->lna_type_2g <<  0 |
+		           rtlhal->pa_type_2g  <<  8 |
+		           rtlhal->lna_type_5g << 16 |
+		           rtlhal->lna_type_5g  << 24;
+
+	/*
+	 * ============== Value Defined Check ===============
+	 * QFN Type [15:12] and Cut Version [27:24] need to do value check
+	 */
+
+	if (((cond1 & 0x0000F000) != 0) &&
+	    ((cond1 & 0x0000F000) != (driver1 & 0x0000F000)))
+		return false;
+		
+	if (((cond1 & 0x0F000000) != 0) &&
+	    ((cond1 & 0x0F000000) != (driver1 & 0x0F000000)))
+		return false;
+
+	/*
+	 * =============== Bit Defined Check ================
+	 * We don't care [31:28] and [23:20]
+	 */
+
+	cond1   &= 0x000F0FFF;
+	driver1 &= 0x000F0FFF;
+
+	if ((cond1 & driver1) == cond1) {
+		uint32_t bitMask = 0;
+		if ((cond1 & 0x0F) == 0) /* BoardType is DONTCARE */
+			return true;
+
+		if ((cond1 & BIT(0)) != 0) /* GLNA */
+			bitMask |= 0x000000FF;
+		if ((cond1 & BIT(1)) != 0) /* GPA */
+			bitMask |= 0x0000FF00;
+		if ((cond1 & BIT(2)) != 0) /* ALNA */
+			bitMask |= 0x00FF0000;
+		if ((cond1 & BIT(3)) != 0) /* APA */
+			bitMask |= 0xFF000000;
+
+		if ((cond2 & bitMask) == (driver2 & bitMask)) /* BoardType of each RF path is matched */
+			return false;
+		else
+			return false;
+	} else {
+		return false;
+	}
+
+	return false;
+}
+
+#define READ_NEXT_PAIR(array_table, v1, v2, i) \
+	do { \
+		i += 2; \
+		v1 = array_table[i]; \
+		v2 = array_table[i+1]; \
+	} while (0)
+
+static u32 _rtl8821au_phy_calculate_bit_shift(uint32_t BitMask)
+{
+	uint32_t i;
+
+	for (i = 0; i <= 31; i++) {
+		if (((BitMask >> i) & 0x1) == 1)
+			break;
+	}
+
+	return i;
+}
+
+u32 rtl8821au_phy_query_bb_reg(struct rtl_priv *rtlpriv, uint32_t RegAddr, uint32_t BitMask)
+{
+	uint32_t ReturnValue = 0, OriginalValue, BitShift;
+
+	/* DBG_871X("--->PHY_QueryBBReg8812(): RegAddr(%#x), BitMask(%#x)\n", RegAddr, BitMask); */
+
+
+	OriginalValue = rtl_read_dword(rtlpriv, RegAddr);
+	BitShift = _rtl8821au_phy_calculate_bit_shift(BitMask);
+	ReturnValue = (OriginalValue & BitMask) >> BitShift;
+
+	/* DBG_871X("BBR MASK=0x%x Addr[0x%x]=0x%x\n", BitMask, RegAddr, OriginalValue); */
+	return ReturnValue;
+}
+
+
+void rtl8821au_phy_set_bb_reg(struct rtl_priv *rtlpriv, u32 RegAddr, u32 BitMask, u32 Data)
+{
+	uint32_t OriginalValue, BitShift;
+
+	if (BitMask != bMaskDWord) {	/* if not "double word" write */
+		OriginalValue = rtl_read_dword(rtlpriv, RegAddr);
+		BitShift = _rtl8821au_phy_calculate_bit_shift(BitMask);
+		Data = ((OriginalValue) & (~BitMask)) | (((Data << BitShift)) & BitMask);
+	}
+
+	rtl_write_dword(rtlpriv, RegAddr, Data);
+
+	/* DBG_871X("BBW MASK=0x%x Addr[0x%x]=0x%x\n", BitMask, RegAddr, Data); */
+}
+
+static u32 _rtl8821au_phy_rf_serial_read(struct rtl_priv *rtlpriv, uint8_t eRFPath,
+	uint32_t Offset)
+{
+	struct rtl_hal *rtlhal = rtl_hal(rtlpriv);
+	struct bb_reg_def *pphyreg = &(rtlpriv->phy.phyreg_def[eRFPath]);
+
+	uint32_t			retValue = 0;
+	bool				bIsPIMode = false;
+
+
+	/*
+	 * 2009/06/17 MH We can not execute IO for power save or other accident mode.
+	 * if(RT_CANNOT_IO(rtlpriv)) {
+	 * 	RT_DISP(FPHY, PHY_RFR, ("phy_RFSerialRead return all one\n"));
+	 * 	return	0xFFFFFFFF;
+	 * }
+	 */
+
+	/* <20120809, Kordan> CCA OFF(when entering), asked by James to avoid reading the wrong value. */
+	/* <20120828, Kordan> Toggling CCA would affect RF 0x0, skip it! */
+	if (Offset != 0x0 &&  !(IS_VENDOR_8812A_C_CUT(rtlhal->version) || IS_HARDWARE_TYPE_8821(rtlhal)))
+		rtl_set_bbreg(rtlpriv, rCCAonSec_Jaguar, 0x8, 1);
+
+	Offset &= 0xff;
+
+	if (eRFPath == RF90_PATH_A)
+		bIsPIMode = (bool)rtl_get_bbreg(rtlpriv, 0xC00, 0x4);
+	else if (eRFPath == RF90_PATH_B)
+		bIsPIMode = (bool)rtl_get_bbreg(rtlpriv, 0xE00, 0x4);
+
+	if (IS_VENDOR_8812A_TEST_CHIP(rtlhal->version))
+		rtl_set_bbreg(rtlpriv, pphyreg->rfhssi_para2, bMaskDWord, 0);
+
+	rtl_set_bbreg(rtlpriv, pphyreg->rfhssi_para2, bHSSIRead_addr_Jaguar, Offset);
+
+	if (IS_VENDOR_8812A_TEST_CHIP(rtlhal->version) )
+		rtl_set_bbreg(rtlpriv, pphyreg->rfhssi_para2, bMaskDWord, Offset|BIT(8));
+
+	if (IS_VENDOR_8812A_C_CUT(rtlhal->version) || IS_HARDWARE_TYPE_8821(rtlhal))
+		udelay(20);
+
+	if (bIsPIMode) {
+		retValue = rtl_get_bbreg(rtlpriv, pphyreg->rf_rbpi, rRead_data_Jaguar);
+		/* DBG_871X("[PI mode] RFR-%d Addr[0x%x]=0x%x\n", eRFPath, pPhyReg->rfLSSIReadBackPi, retValue); */
+	} else {
+		retValue = rtl_get_bbreg(rtlpriv, pphyreg->rf_rb, rRead_data_Jaguar);
+		/* DBG_871X("[SI mode] RFR-%d Addr[0x%x]=0x%x\n", eRFPath, pPhyReg->rfLSSIReadBack, retValue); */
+	}
+
+	/* <20120809, Kordan> CCA ON(when exiting), asked by James to avoid reading the wrong value. */
+	/* <20120828, Kordan> Toggling CCA would affect RF 0x0, skip it! */
+	if (Offset != 0x0 &&  ! (IS_VENDOR_8812A_C_CUT(rtlhal->version) || IS_HARDWARE_TYPE_8821(rtlhal)))
+		rtl_set_bbreg(rtlpriv, rCCAonSec_Jaguar, 0x8, 0);
+
+	return retValue;
+}
+
+static void _rtl8821au_phy_rf_serial_write(struct rtl_priv *rtlpriv, uint8_t eRFPath,
+	uint32_t Offset, uint32_t Data)
+{
+	struct rtl_hal *rtlhal = rtl_hal(rtlpriv);
+	struct bb_reg_def *pphyreg = &(rtlpriv->phy.phyreg_def[eRFPath]);
+	uint32_t		DataAndAddr = 0;
+
+	/*
+	 * 2009/06/17 MH We can not execute IO for power save or other accident mode.
+	 * if(RT_CANNOT_IO(rtlpriv)) {
+	 * 	RTPRINT(FPHY, PHY_RFW, ("phy_RFSerialWrite stop\n"));
+	 * 	return;
+	 * }
+	 */
+
+	Offset &= 0xff;
+
+	// Shadow Update
+	//PHY_RFShadowWrite(rtlpriv, eRFPath, Offset, Data);
+
+	// Put write addr in [27:20]  and write data in [19:00]
+	DataAndAddr = ((Offset<<20) | (Data&0x000fffff)) & 0x0fffffff;
+
+	/*
+	 * 3 <Note> This is a workaround for 8812A test chips.
+	 * <20120427, Kordan> MAC first moves lower 16 bits and then upper 16 bits of a 32-bit data.
+	 * BaseBand doesn't know the two actions is actually only one action to access 32-bit data,
+	 * so that the lower 16 bits is overwritten by the upper 16 bits. (Asked by ynlin.)
+	 * (Unfortunately, the protection mechanism has not been implemented in 8812A yet.)
+	 * 2012/10/26 MH Revise V3236 Lanhsin check in, if we do not enable the function
+	 * for 8821, then it can not scan.
+	 */
+	if ((!IF_RTL8821AU_USB3_MODE(rtlpriv->rtlhal.version)) &&
+	    (!IS_NORMAL_CHIP(rtlhal->version))) {	/* USB 2.0 or older */
+		/* if (IS_VENDOR_8812A_TEST_CHIP(rtlpriv) || IS_HARDWARE_TYPE_8821(rtlpriv) is) */
+		{
+			rtl_write_dword(rtlpriv, 0x1EC, DataAndAddr);
+			if (eRFPath == RF90_PATH_A)
+				rtl_write_dword(rtlpriv, 0x1E8, 0x4000F000|0xC90);
+			else
+				rtl_write_dword(rtlpriv, 0x1E8, 0x4000F000|0xE90);
+		}
+	} else {
+		/* USB 3.0 */
+		/* Write Operation */
+		/* TODO: Dynamically determine whether using PI or SI to write RF registers. */
+		rtl_set_bbreg(rtlpriv, pphyreg->rf3wire_offset, bMaskDWord, DataAndAddr);
+		/* DBG_871X("RFW-%d Addr[0x%x]=0x%x\n", eRFPath, pPhyReg->rf3wireOffset, DataAndAddr); */
+	}
+
+}
+
+
+void rtl8821au_phy_set_rf_reg(struct rtl_priv *rtlpriv, u32 eRFPath, u32 RegAddr,
+	u32 BitMask, u32 Data)
+{
+	if (BitMask == 0)
+		return;
+
+	/* RF data is 20 bits only */
+	if (BitMask != bLSSIWrite_data_Jaguar) {
+		uint32_t	Original_Value, BitShift;
+		Original_Value =  _rtl8821au_phy_rf_serial_read(rtlpriv, eRFPath, RegAddr);
+		BitShift =  _rtl8821au_phy_calculate_bit_shift(BitMask);
+		Data = ((Original_Value) & (~BitMask)) | (Data<< BitShift);
+	}
+
+	 _rtl8821au_phy_rf_serial_write(rtlpriv, eRFPath, RegAddr, Data);
+
+}
+
+u32 rtl8821au_phy_query_rf_reg(struct rtl_priv *rtlpriv, u32 eRFPath, u32 RegAddr,
+	u32 BitMask)
+{
+	u32 Original_Value, Readback_Value, BitShift;
+
+	Original_Value =  _rtl8821au_phy_rf_serial_read(rtlpriv, eRFPath, RegAddr);
+
+	BitShift =  _rtl8821au_phy_calculate_bit_shift(BitMask);
+	Readback_Value = (Original_Value & BitMask) >> BitShift;
+
+	return (Readback_Value);
+}
+
+/* ****************************************************************************** */
+/*									*/
+/*  from HalPhyRf_8812A.c						*/
+/*									*/
+/* ****************************************************************************** */
+
+static void _rtl8812au_iqk_rx_fill_iqc(struct rtl_priv *rtlpriv, enum radio_path Path,
+	unsigned int RX_X, unsigned int RX_Y)
+{
+	switch (Path) {
+	case RF90_PATH_A:
+		rtl_set_bbreg(rtlpriv, 0x82c, BIT(31), 0x0); /* [31] = 0 --> Page C */
+		if (RX_X>>1 == 0x112 || RX_Y>>1 == 0x3ee) {
+			rtl_set_bbreg(rtlpriv, 0xc10, 0x000003ff, 0x100);
+			rtl_set_bbreg(rtlpriv, 0xc10, 0x03ff0000, 0);
+			RT_TRACE(rtlpriv, COMP_IQK, DBG_LOUD, "RX_X = %x;;RX_Y = %x ====>fill to IQC\n", RX_X>>1&0x000003ff, RX_Y>>1&0x000003ff);
+		} else {
+			rtl_set_bbreg(rtlpriv, 0xc10, 0x000003ff, RX_X>>1);
+			rtl_set_bbreg(rtlpriv, 0xc10, 0x03ff0000, RX_Y>>1);
+			RT_TRACE(rtlpriv, COMP_IQK, DBG_LOUD, "RX_X = %x;;RX_Y = %x ====>fill to IQC\n", RX_X>>1&0x000003ff, RX_Y>>1&0x000003ff);
+			RT_TRACE(rtlpriv, COMP_IQK, DBG_LOUD, "0xc10 = %x ====>fill to IQC\n", rtl_read_dword(rtlpriv, 0xc10));
+		}
+		break;
+	case RF90_PATH_B:
+			rtl_set_bbreg(rtlpriv, 0x82c, BIT(31), 0x0); /*  [31] = 0 --> Page C */
+			if (RX_X>>1 == 0x112 || RX_Y>>1 == 0x3ee) {
+				rtl_set_bbreg(rtlpriv, 0xe10, 0x000003ff, 0x100);
+				rtl_set_bbreg(rtlpriv, 0xe10, 0x03ff0000, 0);
+				RT_TRACE(rtlpriv, COMP_IQK, DBG_LOUD, "RX_X = %x;;RX_Y = %x ====>fill to IQC\n", RX_X>>1&0x000003ff, RX_Y>>1&0x000003ff);
+			} else {
+				rtl_set_bbreg(rtlpriv, 0xe10, 0x000003ff, RX_X>>1);
+				rtl_set_bbreg(rtlpriv, 0xe10, 0x03ff0000, RX_Y>>1);
+				RT_TRACE(rtlpriv, COMP_IQK, DBG_LOUD, "RX_X = %x;;RX_Y = %x====>fill to IQC\n ", RX_X>>1&0x000003ff, RX_Y>>1&0x000003ff);
+				RT_TRACE(rtlpriv, COMP_IQK, DBG_LOUD, "0xe10 = %x====>fill to IQC\n", rtl_read_dword(rtlpriv, 0xe10));
+			}
+		break;
+	default:
+		break;
+	};
+}
+
+static void _rtl8821au_iqk_rx_fill_iqc(struct rtl_priv *rtlpriv, enum radio_path Path,
+	unsigned int RX_X, unsigned int RX_Y)
+{
+	switch (Path) {
+	case RF90_PATH_A:
+		rtl_set_bbreg(rtlpriv, 0x82c, BIT(31), 0x0); /* [31] = 0 --> Page C */
+		rtl_set_bbreg(rtlpriv, 0xc10, 0x000003ff, RX_X>>1);
+		rtl_set_bbreg(rtlpriv, 0xc10, 0x03ff0000, RX_Y>>1);
+		RT_TRACE(rtlpriv, COMP_IQK, DBG_LOUD, "RX_X = %x;;RX_Y = %x ====>fill to IQC\n", RX_X>>1, RX_Y>>1);
+		RT_TRACE(rtlpriv, COMP_IQK, DBG_LOUD, "0xc10 = %x ====>fill to IQC\n", rtl_read_dword(rtlpriv, 0xc10));
+		break;
+	default:
+		break;
+	};
+}
+
+static void _rtl8812au_iqk_tx_fill_iqc(struct rtl_priv *rtlpriv, enum radio_path  Path,
+	unsigned int TX_X, unsigned int TX_Y)
+{
+	switch (Path) {
+	case RF90_PATH_A:
+		rtl_set_bbreg(rtlpriv, 0x82c, BIT(31), 0x1); /* [31] = 1 --> Page C1 */
+		rtl_write_dword(rtlpriv, 0xc90, 0x00000080);
+		rtl_write_dword(rtlpriv, 0xcc4, 0x20040000);
+		rtl_write_dword(rtlpriv, 0xcc8, 0x20000000);
+		rtl_set_bbreg(rtlpriv, 0xccc, 0x000007ff, TX_Y);
+		rtl_set_bbreg(rtlpriv, 0xcd4, 0x000007ff, TX_X);
+		RT_TRACE(rtlpriv, COMP_IQK, DBG_LOUD, "TX_X = %x;;TX_Y = %x =====> fill to IQC\n", TX_X&0x000007ff, TX_Y&0x000007ff);
+		RT_TRACE(rtlpriv, COMP_IQK, DBG_LOUD, "0xcd4 = %x;;0xccc = %x ====>fill to IQC\n", rtl_get_bbreg(rtlpriv, 0xcd4, 0x000007ff), rtl_get_bbreg(rtlpriv, 0xccc, 0x000007ff));
+		break;
+	case RF90_PATH_B:
+		rtl_set_bbreg(rtlpriv, 0x82c, BIT(31), 0x1); /* [31] = 1 --> Page C1 */
+		rtl_write_dword(rtlpriv, 0xe90, 0x00000080);
+		rtl_write_dword(rtlpriv, 0xec4, 0x20040000);
+		rtl_write_dword(rtlpriv, 0xec8, 0x20000000);
+		rtl_set_bbreg(rtlpriv, 0xecc, 0x000007ff, TX_Y);
+		rtl_set_bbreg(rtlpriv, 0xed4, 0x000007ff, TX_X);
+		RT_TRACE(rtlpriv, COMP_IQK, DBG_LOUD, "TX_X = %x;;TX_Y = %x =====> fill to IQC\n", TX_X&0x000007ff, TX_Y&0x000007ff);
+		RT_TRACE(rtlpriv, COMP_IQK, DBG_LOUD, "0xed4 = %x;;0xecc = %x ====>fill to IQC\n", rtl_get_bbreg(rtlpriv, 0xed4, 0x000007ff), rtl_get_bbreg(rtlpriv, 0xecc, 0x000007ff));
+		break;
+	default:
+		break;
+	};
+}
+
+static void _rtl8821au_iqk_tx_fill_iqc(struct rtl_priv *rtlpriv, enum radio_path Path,
+	unsigned int TX_X, unsigned int TX_Y)
+{
+	switch (Path) {
+	case RF90_PATH_A:
+		rtl_set_bbreg(rtlpriv, 0x82c, BIT(31), 0x1); /* [31] = 1 --> Page C1 */
+		rtl_write_dword(rtlpriv, 0xc90, 0x00000080);
+		rtl_write_dword(rtlpriv, 0xcc4, 0x20040000);
+		rtl_write_dword(rtlpriv, 0xcc8, 0x20000000);
+		rtl_set_bbreg(rtlpriv, 0xccc, 0x000007ff, TX_Y);
+		rtl_set_bbreg(rtlpriv, 0xcd4, 0x000007ff, TX_X);
+		RT_TRACE(rtlpriv, COMP_IQK, DBG_LOUD, "TX_X = %x;;TX_Y = %x =====> fill to IQC\n", TX_X, TX_Y);
+		RT_TRACE(rtlpriv, COMP_IQK, DBG_LOUD, "0xcd4 = %x;;0xccc = %x ====>fill to IQC\n", rtl_get_bbreg(rtlpriv, 0xcd4, 0x000007ff), rtl_get_bbreg(rtlpriv, 0xccc, 0x000007ff));
+		break;
+	default:
+		break;
+	};
+}
+
+#define cal_num 3
+
+/* ULLI this function needs a complete rewrite (or we cantake code form rtlwifi-lib */
+
+static void _rtl8812au_iqk_tx(struct rtl_priv *rtlpriv, enum radio_path Path)
+{
+	struct rtl_hal	*rtlhal = rtl_hal(rtlpriv);
+
+	uint32_t 	TX_fail, RX_fail, delay_count, IQK_ready, cal_retry, cal = 0, temp_reg65;
+	int		TX_X = 0, TX_Y = 0, RX_X = 0, RX_Y = 0, TX_Average = 0, RX_Average = 0;
+	int 		TX_X0[cal_num], TX_Y0[cal_num], RX_X0[cal_num], RX_Y0[cal_num];
+	bool 	TX0IQKOK = false, RX0IQKOK = false;
+	int 		TX_X1[cal_num], TX_Y1[cal_num], RX_X1[cal_num], RX_Y1[cal_num];
+	bool  	TX1IQKOK = false, RX1IQKOK = false, VDF_enable = false;
+	int 			i, k, VDF_Y[3], VDF_X[3], Tx_dt[3], Rx_dt[3], ii, dx = 0, dy = 0, TX_finish = 0, RX_finish = 0, dt = 0;
+
+	RT_TRACE(rtlpriv, COMP_IQK, DBG_LOUD, "BandWidth = %d, ExtPA5G = %d, ExtPA2G = %d\n", rtlpriv->phy.current_chan_bw, rtlhal->external_pa_5g, rtlhal->external_pa_2g);
+	if (rtlpriv->phy.current_chan_bw == 2) {
+		VDF_enable = true;
+	}
+	VDF_enable = false;
+	temp_reg65 = rtl_get_rfreg(rtlpriv, Path, 0x65, bMaskDWord);
+
+	switch (Path) {
+	case RF90_PATH_A:
+		rtl_set_bbreg(rtlpriv, 0x82c, BIT(31), 0x0);	/* [31] = 0 --> Page C */
+		/*  ========Path-A AFE all on======== */
+		/* Port 0 DAC/ADC on */
+		rtl_write_dword(rtlpriv, 0xc60, 0x77777777);
+		rtl_write_dword(rtlpriv, 0xc64, 0x77777777);
+
+		/* Port 1 DAC/ADC off */
+		rtl_write_dword(rtlpriv, 0xe60, 0x00000000);
+		rtl_write_dword(rtlpriv, 0xe64, 0x00000000);
+
+		rtl_write_dword(rtlpriv, 0xc68, 0x19791979);
+
+		rtl_set_bbreg(rtlpriv, 0xc00, 0xf, 0x4);		/* hardware 3-wire off */
+
+		/* DAC/ADC sampling rate (160 MHz) */
+		rtl_set_bbreg(rtlpriv, 0xc5c, BIT(26)|BIT(25)|BIT(24), 0x7);
+		rtl_set_bbreg(rtlpriv, 0x8c4, BIT(30), 0x1);
+		/* rtl_set_bbreg(rtlpriv, 0xcb0, 0x00ff0000, 0x77); */
+		/* rtl_set_bbreg(rtlpriv, 0xcb4, 0x03000000, 0x0); */
+		break;
+	case RF90_PATH_B:
+		rtl_set_bbreg(rtlpriv, 0x82c, BIT(31), 0x0); /* [31] = 0 --> Page C */
+		/* ========Path-B AFE all on======== */
+		/* Port 0 DAC/ADC off */
+		rtl_write_dword(rtlpriv, 0xc60, 0x00000000);
+		rtl_write_dword(rtlpriv, 0xc64, 0x00000000);
+
+		/* Port 1 DAC/ADC on */
+		rtl_write_dword(rtlpriv, 0xe60, 0x77777777);
+		rtl_write_dword(rtlpriv, 0xe64, 0x77777777);
+
+		rtl_write_dword(rtlpriv, 0xe68, 0x19791979);
+
+		rtl_set_bbreg(rtlpriv, 0xe00, 0xf, 0x4);		/* hardware 3-wire off */
+
+		/* DAC/ADC sampling rate (160 MHz) */
+		rtl_set_bbreg(rtlpriv, 0xe5c, BIT(26)|BIT(25)|BIT(24), 0x7);
+		rtl_set_bbreg(rtlpriv, 0x8c4, BIT(30), 0x1);
+		/* rtl_set_bbreg(rtlpriv, 0xeb0, 0x00ff0000, 0x77); */
+		/* rtl_set_bbreg(rtlpriv, 0xeb4, 0x03000000, 0x0); */
+		break;
+	default:
+		break;
+	}
+
+	switch (Path) {
+	case RF90_PATH_A:
+	    {
+		/* ====== TX IQK ====== */
+		rtl_set_bbreg(rtlpriv, 0x82c, BIT(31), 0x0); /*  [31] = 0 --> Page C */
+		rtl_set_rfreg(rtlpriv, Path, 0xef, bRFRegOffsetMask, 0x80002);
+		rtl_set_rfreg(rtlpriv, Path, 0x30, bRFRegOffsetMask, 0x20000);
+		rtl_set_rfreg(rtlpriv, Path, 0x31, bRFRegOffsetMask, 0x3fffd);
+		rtl_set_rfreg(rtlpriv, Path, 0x32, bRFRegOffsetMask, 0xfe83f);
+		rtl_set_rfreg(rtlpriv, Path, 0x65, bRFRegOffsetMask, 0x931d5);
+		rtl_set_rfreg(rtlpriv, Path, 0x8f, bRFRegOffsetMask, 0x8a001);
+		rtl_write_dword(rtlpriv, 0x90c, 0x00008000);
+		rtl_write_dword(rtlpriv, 0xb00, 0x03000100);
+		rtl_set_bbreg(rtlpriv, 0xc94, BIT(0), 0x1);
+		rtl_write_dword(rtlpriv, 0x978, 0x29002000);	/* TX (X,Y) */
+		rtl_write_dword(rtlpriv, 0x97c, 0xa9002000);	/* RX (X,Y) */
+		rtl_write_dword(rtlpriv, 0x984, 0x00462910);	/* [0]:AGC_en, [15]:idac_K_Mask */
+
+		rtl_set_bbreg(rtlpriv, 0x82c, BIT(31), 0x1);	/* [31] = 1 --> Page C1 */
+
+		if (rtlhal->external_pa_5g)
+			rtl_write_dword(rtlpriv, 0xc88, 0x821403f7);
+		else
+			rtl_write_dword(rtlpriv, 0xc88, 0x821403f1);
+
+		if (rtlhal->current_bandtype)
+			rtl_write_dword(rtlpriv, 0xc8c, 0x68163e96);
+		else {
+			rtl_write_dword(rtlpriv, 0xc8c, 0x28163e96);
+			if (rtlhal->rfe_type == 3) {
+				if (rtlhal->external_pa_2g)
+					rtl_write_dword(rtlpriv, 0xc88, 0x821403e3);
+				else
+					rtl_write_dword(rtlpriv, 0xc88, 0x821403f7);
+			}
+
+		}
+
+		if (VDF_enable == 1) {
+			RT_TRACE(rtlpriv, COMP_IQK, DBG_LOUD, "TXVDF Start\n");
+			for (k = 0; k <= 2; k++) {
+				switch (k) {
+				case 0:
+					rtl_write_dword(rtlpriv, 0xc80, 0x18008c38);	/* TX_Tone_idx[9:0], TxK_Mask[29] TX_Tone = 16 */
+					rtl_write_dword(rtlpriv, 0xc84, 0x38008c38);	/* RX_Tone_idx[9:0], RxK_Mask[29] */
+					rtl_write_dword(rtlpriv, 0x984, 0x00462910);	/* [0]:AGC_en, [15]:idac_K_Mask */
+					rtl_set_bbreg(rtlpriv, 0xce8, BIT(31), 0x0);
+					break;
+				case 1:
+					rtl_set_bbreg(rtlpriv, 0xc80, BIT(28), 0x0);
+					rtl_set_bbreg(rtlpriv, 0xc84, BIT(28), 0x0);
+					rtl_write_dword(rtlpriv, 0x984, 0x0046a910);	/* [0]:AGC_en, [15]:idac_K_Mask */
+					break;
+				case 2:
+					RT_TRACE(rtlpriv, COMP_IQK, DBG_LOUD, "VDF_Y[1] = %x;;;VDF_Y[0] = %x\n", VDF_Y[1]>>21 & 0x00007ff, VDF_Y[0]>>21 & 0x00007ff);
+					RT_TRACE(rtlpriv, COMP_IQK, DBG_LOUD, "VDF_X[1] = %x;;;VDF_X[0] = %x\n", VDF_X[1]>>21 & 0x00007ff, VDF_X[0]>>21 & 0x00007ff);
+					Tx_dt[cal] = (VDF_Y[1]>>20)-(VDF_Y[0]>>20);
+					RT_TRACE(rtlpriv, COMP_IQK, DBG_LOUD, "Tx_dt = %d\n", Tx_dt[cal]);
+					Tx_dt[cal] = ((16*Tx_dt[cal])*10000/15708);
+					Tx_dt[cal] = (Tx_dt[cal] >> 1) + (Tx_dt[cal] & BIT(0));
+					rtl_write_dword(rtlpriv, 0xc80, 0x18008c20);	/* TX_Tone_idx[9:0], TxK_Mask[29] TX_Tone = 16 */
+					rtl_write_dword(rtlpriv, 0xc84, 0x38008c20);	/* RX_Tone_idx[9:0], RxK_Mask[29] */
+					rtl_set_bbreg(rtlpriv, 0xce8, BIT(31), 0x1);
+					rtl_set_bbreg(rtlpriv, 0xce8, 0x3fff0000, Tx_dt[cal] & 0x00003fff);
+					break;
+				default:
+					break;
+				}
+				rtl_write_dword(rtlpriv, 0xcb8, 0x00100000);		/* cb8[20] N SI/PI v iqk_dpk module */
+				cal_retry = 0;
+				while (1) {
+					/* one shot */
+					rtl_write_dword(rtlpriv, 0x980, 0xfa000000);
+					rtl_write_dword(rtlpriv, 0x980, 0xf8000000);
+
+					mdelay(10); /* Delay 10ms */
+					rtl_write_dword(rtlpriv, 0xcb8, 0x00000000);
+					delay_count = 0;
+					while (1) {
+						IQK_ready = rtl_get_bbreg(rtlpriv, 0xd00, BIT(10));
+						if ((IQK_ready) || (delay_count > 20)) {
+							break;
+						} else {
+							mdelay(1);
+							delay_count++;
+						}
+					}
+
+					if (delay_count < 20) {							/* If 20ms No Result, then cal_retry++ */
+						/* ============TXIQK Check============== */
+						TX_fail = rtl_get_bbreg(rtlpriv, 0xd00, BIT(12));
+
+						if (~TX_fail) {
+							rtl_write_dword(rtlpriv, 0xcb8, 0x02000000);
+							VDF_X[k] = rtl_get_bbreg(rtlpriv, 0xd00, 0x07ff0000)<<21;
+							rtl_write_dword(rtlpriv, 0xcb8, 0x04000000);
+							VDF_Y[k] = rtl_get_bbreg(rtlpriv, 0xd00, 0x07ff0000)<<21;
+							TX0IQKOK = true;
+							break;
+						} else {
+							TX0IQKOK = false;
+							cal_retry++;
+							if (cal_retry == 10) {
+								break;
+							}
+						}
+					} else {
+						TX0IQKOK = false;
+						cal_retry++;
+						if (cal_retry == 10) {
+							break;
+						}
+					}
+				}
+			}
+			RT_TRACE(rtlpriv, COMP_IQK, DBG_LOUD, "TXA_VDF_cal_retry = %d\n", cal_retry);
+			TX_X0[cal] = VDF_X[k-1] ;
+			TX_Y0[cal] = VDF_Y[k-1];
+		} else {
+			rtl_write_dword(rtlpriv, 0xc80, 0x18008c10);	/* TX_Tone_idx[9:0], TxK_Mask[29] TX_Tone = 16 */
+			rtl_write_dword(rtlpriv, 0xc84, 0x38008c10);	/* RX_Tone_idx[9:0], RxK_Mask[29] */
+			rtl_write_dword(rtlpriv, 0xce8, 0x00000000);
+
+			for (cal = 0; cal < cal_num; cal++) {
+				cal_retry = 0;
+				while (1) {
+					/* one shot */
+					rtl_write_dword(rtlpriv, 0xcb8, 0x00100000);	/* cb8[20] N SI/PI v iqk_dpk module */
+					rtl_write_dword(rtlpriv, 0x980, 0xfa000000);
+					rtl_write_dword(rtlpriv, 0x980, 0xf8000000);
+
+					mdelay(10); 				/* Delay 25ms */
+					rtl_write_dword(rtlpriv, 0xcb8, 0x00000000);
+					delay_count = 0;
+					while (1) {
+						IQK_ready = rtl_get_bbreg(rtlpriv, 0xd00, BIT(10));
+						if ((IQK_ready) || (delay_count > 20)) {
+							break;
+						} else {
+							mdelay(1);
+							delay_count++;
+						}
+					}
+
+					if (delay_count < 20) {				/* If 20ms No Result, then cal_retry++ */
+						/* ============TXIQK Check============== */
+						TX_fail = rtl_get_bbreg(rtlpriv, 0xd00, BIT(12));
+
+						if (~TX_fail) {
+							rtl_write_dword(rtlpriv, 0xcb8, 0x02000000);
+							TX_X0[cal] = rtl_get_bbreg(rtlpriv, 0xd00, 0x07ff0000)<<21;
+							rtl_write_dword(rtlpriv, 0xcb8, 0x04000000);
+							TX_Y0[cal] = rtl_get_bbreg(rtlpriv, 0xd00, 0x07ff0000)<<21;
+							TX0IQKOK = true;
+							/*
+							rtl_write_dword(rtlpriv, 0xcb8, 0x01000000);
+							reg1 = rtl_get_bbreg(rtlpriv, 0xd00, 0xffffffff);
+							rtl_write_dword(rtlpriv, 0xcb8, 0x02000000);
+							reg2 = rtl_get_bbreg(rtlpriv, 0xd00, 0x0000001f);
+							Image_Power = (reg2<<32)+reg1;
+							DbgPrint("Before PW = %d\n", Image_Power);
+							rtl_write_dword(rtlpriv, 0xcb8, 0x03000000);
+							reg1 = rtl_get_bbreg(rtlpriv, 0xd00, 0xffffffff);
+							rtl_write_dword(rtlpriv, 0xcb8, 0x04000000);
+							reg2 = rtl_get_bbreg(rtlpriv, 0xd00, 0x0000001f);
+							Image_Power = (reg2<<32)+reg1;
+							DbgPrint("After PW = %d\n", Image_Power);
+							*/
+							break;
+						} else {
+							TX0IQKOK = false;
+							cal_retry++;
+							if (cal_retry == 10) {
+								break;
+							}
+						}
+					} else {
+						TX0IQKOK = false;
+						cal_retry++;
+						if (cal_retry == 10)
+							break;
+					}
+				}
+				RT_TRACE(rtlpriv, COMP_IQK, DBG_LOUD, "TXA_cal_retry = %d\n", cal_retry);
+				if (TX0IQKOK)
+					TX_Average++;
+			}
+		}
+
+		rtl_set_bbreg(rtlpriv, 0x82c, BIT(31), 0x0); /* [31] = 0 --> Page C */
+		rtl_set_rfreg(rtlpriv, Path, 0x58, 0x7fe00, rtl_get_rfreg(rtlpriv, Path, 0x8, 0xffc00)); /* Load LOK */
+		rtl_set_bbreg(rtlpriv, 0x82c, BIT(31), 0x1); /* [31] = 1 --> Page C1 */
+
+		if (TX0IQKOK == false)
+			break;				/* TXK fail, Don't do RXK */
+
+		if (VDF_enable == 1) {
+			rtl_set_bbreg(rtlpriv, 0xce8, BIT(31), 0x0);    /*  TX VDF Disable */
+			RT_TRACE(rtlpriv, COMP_IQK, DBG_LOUD, "RXVDF Start\n");
+
+			/* ====== RX IQK ====== */
+			rtl_set_bbreg(rtlpriv, 0x82c, BIT(31), 0x0); /* [31] = 0 --> Page C */
+			rtl_set_rfreg(rtlpriv, Path, 0xef, bRFRegOffsetMask, 0x80000);
+			rtl_set_rfreg(rtlpriv, Path, 0x30, bRFRegOffsetMask, 0x30000);
+			rtl_set_rfreg(rtlpriv, Path, 0x31, bRFRegOffsetMask, 0x3f7ff);
+			rtl_set_rfreg(rtlpriv, Path, 0x32, bRFRegOffsetMask, 0xfe7bf);
+			rtl_set_rfreg(rtlpriv, Path, 0x8f, bRFRegOffsetMask, 0x88001);
+			rtl_set_rfreg(rtlpriv, Path, 0x65, bRFRegOffsetMask, 0x931d0);
+			rtl_set_rfreg(rtlpriv, Path, 0xef, bRFRegOffsetMask, 0x00000);
+			rtl_set_bbreg(rtlpriv, 0x978, BIT(31), 0x1);
+			rtl_set_bbreg(rtlpriv, 0x97c, BIT(31), 0x0);
+			rtl_write_dword(rtlpriv, 0x984, 0x0046a911);
+
+			rtl_set_bbreg(rtlpriv, 0x82c, BIT(31), 0x1); /* [31] = 1 --> Page C1 */
+			rtl_write_dword(rtlpriv, 0xc88, 0x02140119);
+			rtl_write_dword(rtlpriv, 0xc8c, 0x28161420);
+
+			for (k = 0; k <= 2; k++) {
+				rtl_set_bbreg(rtlpriv, 0x82c, BIT(31), 0x0); 	/* [31] = 0 --> Page C */
+				rtl_set_bbreg(rtlpriv, 0x978, 0x03FF8000, (VDF_X[k])>>21&0x000007ff);
+				rtl_set_bbreg(rtlpriv, 0x978, 0x000007FF, (VDF_Y[k])>>21&0x000007ff);
+
+				rtl_set_bbreg(rtlpriv, 0x82c, BIT(31), 0x1); 	/* [31] = 1 --> Page C1 */
+				switch (k) {
+				case 0:
+					rtl_write_dword(rtlpriv, 0xc80, 0x38008c38);	/* TX_Tone_idx[9:0], TxK_Mask[29] TX_Tone = 16 */
+					rtl_write_dword(rtlpriv, 0xc84, 0x18008c38);	/* RX_Tone_idx[9:0], RxK_Mask[29] */
+					rtl_set_bbreg(rtlpriv, 0xce8, BIT(30), 0x0);
+					break;
+				case 1:
+					rtl_write_dword(rtlpriv, 0xc80, 0x28008c38);	/* TX_Tone_idx[9:0], TxK_Mask[29] TX_Tone = 16 */
+					rtl_write_dword(rtlpriv, 0xc84, 0x08008c38);	/* RX_Tone_idx[9:0], RxK_Mask[29] */
+					break;
+				case 2:
+					RT_TRACE(rtlpriv, COMP_IQK, DBG_LOUD, "VDF_Y[1] = %x;;;VDF_Y[0] = %x\n", VDF_Y[1]>>21 & 0x00007ff, VDF_Y[0]>>21 & 0x00007ff);
+					RT_TRACE(rtlpriv, COMP_IQK, DBG_LOUD, "VDF_X[1] = %x;;;VDF_X[0] = %x\n", VDF_X[1]>>21 & 0x00007ff, VDF_X[0]>>21 & 0x00007ff);
+					Rx_dt[cal] = (VDF_Y[1]>>20)-(VDF_Y[0]>>20);
+					RT_TRACE(rtlpriv, COMP_IQK, DBG_LOUD, "Rx_dt = %d\n", Rx_dt[cal]);
+					Rx_dt[cal] = ((16*Rx_dt[cal])*10000/13823);
+					Rx_dt[cal] = (Rx_dt[cal] >> 1) + (Rx_dt[cal] & BIT(0));
+					rtl_write_dword(rtlpriv, 0xc80, 0x38008c20);	/* TX_Tone_idx[9:0], TxK_Mask[29] TX_Tone = 16 */
+					rtl_write_dword(rtlpriv, 0xc84, 0x18008c20);	/* RX_Tone_idx[9:0], RxK_Mask[29] */
+					rtl_set_bbreg(rtlpriv, 0xce8, 0x00003fff, Rx_dt[cal] & 0x00003fff);
+					break;
+				default:
+					break;
+				}
+
+
+				if (k == 2) {
+					rtl_set_bbreg(rtlpriv, 0xce8, BIT(30), 0x1);  /* RX VDF Enable */
+				}
+				rtl_write_dword(rtlpriv, 0xcb8, 0x00100000);/* cb8[20] N SI/PI v iqk_dpk module */
+
+				cal_retry = 0;
+				while (1) {
+					/* one shot */
+					rtl_write_dword(rtlpriv, 0x980, 0xfa000000);
+					rtl_write_dword(rtlpriv, 0x980, 0xf8000000);
+
+					mdelay(10); /* Delay 10ms */
+					rtl_write_dword(rtlpriv, 0xcb8, 0x00000000);
+					delay_count = 0;
+
+					while (1) {
+						IQK_ready = rtl_get_bbreg(rtlpriv, 0xd00, BIT(10));
+						if ((IQK_ready) || (delay_count > 20)) {
+							break;
+						} else {
+							mdelay(1);
+							delay_count++;
+						}
+					}
+
+					if (delay_count < 20) {	/* If 20ms No Result, then cal_retry++ */
+						/* ============RXIQK Check============== */
+						RX_fail = rtl_get_bbreg(rtlpriv, 0xd00, BIT(11));
+						if (RX_fail == 0) {
+							rtl_write_dword(rtlpriv, 0xcb8, 0x06000000);
+							VDF_X[k] = rtl_get_bbreg(rtlpriv, 0xd00, 0x07ff0000)<<21;
+							rtl_write_dword(rtlpriv, 0xcb8, 0x08000000);
+							VDF_Y[k] = rtl_get_bbreg(rtlpriv, 0xd00, 0x07ff0000)<<21;
+							RX0IQKOK = true;
+							break;
+						} else {
+							rtl_set_bbreg(rtlpriv, 0xc10, 0x000003ff, 0x200>>1);
+							rtl_set_bbreg(rtlpriv, 0xc10, 0x03ff0000, 0x0>>1);
+							RX0IQKOK = false;
+							cal_retry++;
+							if (cal_retry == 10)
+								break;
+						}
+					} else {
+						RX0IQKOK = false;
+						cal_retry++;
+						if (cal_retry == 10)
+							break;
+					}
+				}
+			}
+			RT_TRACE(rtlpriv, COMP_IQK, DBG_LOUD, "RXA_VDF_cal_retry = %d\n", cal_retry);
+			RX_X0[cal] = VDF_X[k-1] ;
+			RX_Y0[cal] = VDF_Y[k-1];
+			rtl_set_bbreg(rtlpriv, 0xce8, BIT(31), 0x1);    /* TX VDF Enable */
+		} else {
+			/* ====== RX IQK ====== */
+			rtl_set_bbreg(rtlpriv, 0x82c, BIT(31), 0x0); /* [31] = 0 --> Page C */
+			/*  1. RX RF Setting */
+			rtl_set_rfreg(rtlpriv, Path, 0xef, bRFRegOffsetMask, 0x80000);
+			rtl_set_rfreg(rtlpriv, Path, 0x30, bRFRegOffsetMask, 0x30000);
+			rtl_set_rfreg(rtlpriv, Path, 0x31, bRFRegOffsetMask, 0x3f7ff);
+			rtl_set_rfreg(rtlpriv, Path, 0x32, bRFRegOffsetMask, 0xfe7bf);
+			rtl_set_rfreg(rtlpriv, Path, 0x8f, bRFRegOffsetMask, 0x88001);
+			rtl_set_rfreg(rtlpriv, Path, 0x65, bRFRegOffsetMask, 0x931d0);
+			rtl_set_rfreg(rtlpriv, Path, 0xef, bRFRegOffsetMask, 0x00000);
+
+			rtl_set_bbreg(rtlpriv, 0x978, BIT(31), 0x1);
+			rtl_set_bbreg(rtlpriv, 0x97c, BIT(31), 0x0);
+			rtl_write_dword(rtlpriv, 0x90c, 0x00008000);
+			/* rtl_write_dword(rtlpriv, 0x984, 0x0046a911); */
+			rtl_write_dword(rtlpriv, 0x984, 0x0046a891);
+
+			rtl_set_bbreg(rtlpriv, 0x82c, BIT(31), 0x1); 	/* [31] = 1 --> Page C1 */
+			rtl_write_dword(rtlpriv, 0xc80, 0x38008c10);	/* TX_Tone_idx[9:0], TxK_Mask[29] TX_Tone = 16 */
+			rtl_write_dword(rtlpriv, 0xc84, 0x18008c10);	/* RX_Tone_idx[9:0], RxK_Mask[29] */
+			rtl_write_dword(rtlpriv, 0xc88, 0x02140119);
+			rtl_write_dword(rtlpriv, 0xc8c, 0x28160d40);
+
+			for (cal = 0; cal < cal_num; cal++) {
+				rtl_set_bbreg(rtlpriv, 0x82c, BIT(31), 0x0);		/* [31] = 0 --> Page C */
+				rtl_set_bbreg(rtlpriv, 0x978, 0x03FF8000, (TX_X0[cal])>>21&0x000007ff);
+				rtl_set_bbreg(rtlpriv, 0x978, 0x000007FF, (TX_Y0[cal])>>21&0x000007ff);
+				rtl_set_bbreg(rtlpriv, 0x82c, BIT(31), 0x1);		/* [31] = 1 --> Page C1 */
+				cal_retry = 0;
+				while (1) {
+					/*  one shot */
+					rtl_write_dword(rtlpriv, 0xcb8, 0x00100000);/* cb8[20] N SI/PI v iqk_dpk module */
+					rtl_write_dword(rtlpriv, 0x980, 0xfa000000);
+					rtl_write_dword(rtlpriv, 0x980, 0xf8000000);
+
+					mdelay(10);			/* Delay 10ms */
+					rtl_write_dword(rtlpriv, 0xcb8, 0x00000000);
+					delay_count = 0;
+					while (1) {
+						IQK_ready = rtl_get_bbreg(rtlpriv, 0xd00, BIT(10));
+						if ((IQK_ready) || (delay_count > 20)) {
+							break;
+						} else {
+							mdelay(1);
+							delay_count++;
+						}
+					}
+
+				if (delay_count < 20) {	/* If 20ms No Result, then cal_retry++ */
+					/* ============RXIQK Check============== */
+					RX_fail = rtl_get_bbreg(rtlpriv, 0xd00, BIT(11));
+					if (RX_fail == 0) {
+						rtl_write_dword(rtlpriv, 0xcb8, 0x06000000);
+						RX_X0[cal] = rtl_get_bbreg(rtlpriv, 0xd00, 0x07ff0000)<<21;
+						rtl_write_dword(rtlpriv, 0xcb8, 0x08000000);
+						RX_Y0[cal] = rtl_get_bbreg(rtlpriv, 0xd00, 0x07ff0000)<<21;
+						RX0IQKOK = true;
+						/*
+						rtl_write_dword(rtlpriv, 0xcb8, 0x05000000);
+						reg1 = rtl_get_bbreg(rtlpriv, 0xd00, 0xffffffff);
+						rtl_write_dword(rtlpriv, 0xcb8, 0x06000000);
+						reg2 = rtl_get_bbreg(rtlpriv, 0xd00, 0x0000001f);
+						DbgPrint("reg1 = %d, reg2 = %d", reg1, reg2);
+						Image_Power = (reg2<<32)+reg1;
+						DbgPrint("Before PW = %d\n", Image_Power);
+						rtl_write_dword(rtlpriv, 0xcb8, 0x07000000);
+						reg1 = rtl_get_bbreg(rtlpriv, 0xd00, 0xffffffff);
+						rtl_write_dword(rtlpriv, 0xcb8, 0x08000000);
+						reg2 = rtl_get_bbreg(rtlpriv, 0xd00, 0x0000001f);
+						Image_Power = (reg2<<32)+reg1;
+						DbgPrint("After PW = %d\n", Image_Power);
+						*/
+
+						break;
+					} else {
+						rtl_set_bbreg(rtlpriv, 0xc10, 0x000003ff, 0x200>>1);
+						rtl_set_bbreg(rtlpriv, 0xc10, 0x03ff0000, 0x0>>1);
+						RX0IQKOK = false;
+						cal_retry++;
+						if (cal_retry == 10)
+						break;
+					}
+				} else {
+					RX0IQKOK = false;
+					cal_retry++;
+					if (cal_retry == 10)
+						break;
+					}
+				}
+			RT_TRACE(rtlpriv, COMP_IQK, DBG_LOUD, "RXA_cal_retry = %d\n", cal_retry);
+			if (RX0IQKOK)
+				RX_Average++;
+			}
+		}
+	    }
+		break; /* MARK */
+	case RF90_PATH_B:
+	    {
+		/* Path-B TX/RX IQK */
+		rtl_set_bbreg(rtlpriv, 0x82c, BIT(31), 0x0);		/* [31] = 0 --> Page C */
+		rtl_set_rfreg(rtlpriv, Path, 0xef, bRFRegOffsetMask, 0x80002);
+		rtl_set_rfreg(rtlpriv, Path, 0x30, bRFRegOffsetMask, 0x20000);
+		rtl_set_rfreg(rtlpriv, Path, 0x31, bRFRegOffsetMask, 0x3fffd);
+		rtl_set_rfreg(rtlpriv, Path, 0x32, bRFRegOffsetMask, 0xfe83f);
+		rtl_set_rfreg(rtlpriv, Path, 0x65, bRFRegOffsetMask, 0x931d5);
+		rtl_set_rfreg(rtlpriv, Path, 0x8f, bRFRegOffsetMask, 0x8a001);
+		rtl_write_dword(rtlpriv, 0x90c, 0x00008000);
+		rtl_write_dword(rtlpriv, 0xb00, 0x03000100);
+		rtl_set_bbreg(rtlpriv, 0xe94, BIT(0), 0x1);
+		rtl_write_dword(rtlpriv, 0x978, 0x29002000);		/* TX (X,Y) */
+		rtl_write_dword(rtlpriv, 0x97c, 0xa9002000);		/* RX (X,Y) */
+		rtl_write_dword(rtlpriv, 0x984, 0x00462910);		/* [0]:AGC_en, [15]:idac_K_Mask */
+
+		rtl_set_bbreg(rtlpriv, 0x82c, BIT(31), 0x1);		/* [31] = 1 --> Page C1 */
+
+		if (rtlhal->external_pa_5g)
+			rtl_write_dword(rtlpriv, 0xe88, 0x821403f7);
+		else
+			rtl_write_dword(rtlpriv, 0xe88, 0x821403f1);
+
+		if (rtlhal->current_bandtype)
+			rtl_write_dword(rtlpriv, 0xe8c, 0x68163e96);
+		else
+			rtl_write_dword(rtlpriv, 0xe8c, 0x28163e96);
+
+		if (VDF_enable == 1) {
+			for (k = 0; k <= 2; k++) {
+				switch (k) {
+				case 0:
+					rtl_write_dword(rtlpriv, 0xe80, 0x18008c38);	/* TX_Tone_idx[9:0], TxK_Mask[29] TX_Tone = 16 */
+					rtl_write_dword(rtlpriv, 0xe84, 0x38008c38);	/* RX_Tone_idx[9:0], RxK_Mask[29] */
+					rtl_write_dword(rtlpriv, 0x984, 0x00462910);
+					rtl_set_bbreg(rtlpriv, 0xee8, BIT(31), 0x0);
+					break;
+				case 1:
+					rtl_set_bbreg(rtlpriv, 0xe80, BIT(28), 0x0);
+					rtl_set_bbreg(rtlpriv, 0xe84, BIT(28), 0x0);
+					rtl_write_dword(rtlpriv, 0x984, 0x0046a910);
+					rtl_set_bbreg(rtlpriv, 0xee8, BIT(31), 0x0);
+					break;
+				case 2:
+					RT_TRACE(rtlpriv, COMP_IQK, DBG_LOUD, "VDF_Y[1] = %x;;;VDF_Y[0] = %x\n", VDF_Y[1]>>21 & 0x00007ff, VDF_Y[0]>>21 & 0x00007ff);
+					RT_TRACE(rtlpriv, COMP_IQK, DBG_LOUD, "VDF_X[1] = %x;;;VDF_X[0] = %x\n", VDF_X[1]>>21 & 0x00007ff, VDF_X[0]>>21 & 0x00007ff);
+					Tx_dt[cal] = (VDF_Y[1]>>20)-(VDF_Y[0]>>20);
+					RT_TRACE(rtlpriv, COMP_IQK, DBG_LOUD, "Tx_dt = %d\n", Tx_dt[cal]);
+					Tx_dt[cal] = ((16*Tx_dt[cal])*10000/15708);
+					Tx_dt[cal] = (Tx_dt[cal] >> 1) + (Tx_dt[cal] & BIT(0));
+					rtl_write_dword(rtlpriv, 0xe80, 0x18008c20);	/* TX_Tone_idx[9:0], TxK_Mask[29] TX_Tone = 16 */
+					rtl_write_dword(rtlpriv, 0xe84, 0x38008c20);	/* RX_Tone_idx[9:0], RxK_Mask[29] */
+					rtl_set_bbreg(rtlpriv, 0xee8, BIT(31), 0x1);
+					rtl_set_bbreg(rtlpriv, 0xee8, 0x3fff0000, Tx_dt[cal] & 0x00003fff);
+					break;
+				default:
+					break;
+				}
+
+
+				rtl_write_dword(rtlpriv, 0xeb8, 0x00100000);/* cb8[20] N SI/PI v iqk_dpk module */
+				cal_retry = 0;
+				while (1) {
+					/*  one shot */
+					rtl_write_dword(rtlpriv, 0x980, 0xfa000000);
+					rtl_write_dword(rtlpriv, 0x980, 0xf8000000);
+
+					mdelay(10); /* Delay 10ms */
+					rtl_write_dword(rtlpriv, 0xeb8, 0x00000000);
+					delay_count = 0;
+					while (1) {
+						IQK_ready = rtl_get_bbreg(rtlpriv, 0xd40, BIT(10));
+						if ((IQK_ready) || (delay_count > 20)) {
+							break;
+						} else {
+							mdelay(1);
+							delay_count++;
+						}
+					}
+
+					if (delay_count < 20) {		/* If 20ms No Result, then cal_retry++ */
+						/* ============TXIQK Check============== */
+						TX_fail = rtl_get_bbreg(rtlpriv, 0xd40, BIT(12));
+
+						if (~TX_fail) {
+							rtl_write_dword(rtlpriv, 0xeb8, 0x02000000);
+							VDF_X[k] = rtl_get_bbreg(rtlpriv, 0xd40, 0x07ff0000)<<21;
+							rtl_write_dword(rtlpriv, 0xeb8, 0x04000000);
+							VDF_Y[k] = rtl_get_bbreg(rtlpriv, 0xd40, 0x07ff0000)<<21;
+							TX1IQKOK = true;
+							break;
+						} else {
+							TX1IQKOK = false;
+							cal_retry++;
+							if (cal_retry == 10) {
+								break;
+							}
+						}
+					} else {
+						TX1IQKOK = false;
+						cal_retry++;
+						if (cal_retry == 10) {
+							break;
+						}
+					}
+				}
+			}
+			RT_TRACE(rtlpriv, COMP_IQK, DBG_LOUD, "TXB_VDF_cal_retry = %d\n", cal_retry);
+			TX_X1[cal] = VDF_X[k-1] ;
+			TX_Y1[cal] = VDF_Y[k-1];
+		} else {
+			rtl_write_dword(rtlpriv, 0xe80, 0x18008c10);	/* TX_Tone_idx[9:0], TxK_Mask[29] TX_Tone = 16 */
+			rtl_write_dword(rtlpriv, 0xe84, 0x38008c10);	/* RX_Tone_idx[9:0], RxK_Mask[29] */
+			rtl_write_dword(rtlpriv, 0xee8, 0x00000000);
+
+			for (cal = 0; cal < cal_num; cal++) {
+				cal_retry = 0;
+
+				while (1) {
+					/* one shot */
+					rtl_write_dword(rtlpriv, 0xeb8, 0x00100000);/*  cb8[20] N SI/PI v iqk_dpk module */
+					rtl_write_dword(rtlpriv, 0x980, 0xfa000000);
+					rtl_write_dword(rtlpriv, 0x980, 0xf8000000);
+
+					mdelay(10); /* Delay 25ms */
+					rtl_write_dword(rtlpriv, 0xeb8, 0x00000000);
+					delay_count = 0;
+					while (1) {
+						IQK_ready = rtl_get_bbreg(rtlpriv, 0xd40, BIT(10));
+						if ((IQK_ready) || (delay_count > 20)) {
+							break;
+						} else {
+							mdelay(1);
+							delay_count++;
+						}
+					}
+
+					if (delay_count < 20) {							/* If 20ms No Result, then cal_retry++ */
+						/* ============TXIQK Check============== */
+						TX_fail = rtl_get_bbreg(rtlpriv, 0xd40, BIT(12));
+						if (~TX_fail) {
+							rtl_write_dword(rtlpriv, 0xeb8, 0x02000000);
+							TX_X1[cal] = rtl_get_bbreg(rtlpriv, 0xd40, 0x07ff0000)<<21;
+							rtl_write_dword(rtlpriv, 0xeb8, 0x04000000);
+							TX_Y1[cal] = rtl_get_bbreg(rtlpriv, 0xd40, 0x07ff0000)<<21;
+							TX1IQKOK = true;
+							/*
+							int			reg1 = 0, reg2 = 0, Image_Power = 0;
+							rtl_write_dword(rtlpriv, 0xeb8, 0x01000000);
+							reg1 = rtl_get_bbreg(rtlpriv, 0xd40, 0xffffffff);
+							rtl_write_dword(rtlpriv, 0xeb8, 0x02000000);
+							reg2 = rtl_get_bbreg(rtlpriv, 0xd40, 0x0000001f);
+							Image_Power = (reg2<<32)+reg1;
+							DbgPrint("Before PW = %d\n", Image_Power);
+							rtl_write_dword(rtlpriv, 0xeb8, 0x03000000);
+							reg1 = rtl_get_bbreg(rtlpriv, 0xd40, 0xffffffff);
+							rtl_write_dword(rtlpriv, 0xeb8, 0x04000000);
+							reg2 = rtl_get_bbreg(rtlpriv, 0xd40, 0x0000001f);
+							Image_Power = (reg2<<32)+reg1;
+							DbgPrint("After PW = %d\n", Image_Power);
+							*/
+							break;
+						} else {
+							TX1IQKOK = false;
+							cal_retry++;
+							if (cal_retry == 10) {
+								break;
+							}
+						}
+					}  else {
+						TX1IQKOK = false;
+						cal_retry++;
+						if (cal_retry == 10) {
+							break;
+						}
+					}
+				}
+				RT_TRACE(rtlpriv, COMP_IQK, DBG_LOUD, "TXB_cal_retry = %d\n", cal_retry);
+				if (TX1IQKOK)
+					TX_Average++;
+			}
+		}
+
+		rtl_set_bbreg(rtlpriv, 0x82c, BIT(31), 0x0);		/* [31] = 0 --> Page C */
+		rtl_set_rfreg(rtlpriv, Path, 0x58, 0x7fe00, rtl_get_rfreg(rtlpriv, Path, 0x8, 0xffc00));	/* Load LOK */
+		rtl_set_bbreg(rtlpriv, 0x82c, BIT(31), 0x1);		/* [31] = 1 --> Page C1 */
+
+		if (TX1IQKOK == false)
+			break;				/* TXK fail, Don't do RXK */
+
+		if (VDF_enable == 1) {
+			rtl_set_bbreg(rtlpriv, 0xee8, BIT(31), 0x0);    /* TX VDF Disable */
+			RT_TRACE(rtlpriv, COMP_IQK, DBG_LOUD, "RXVDF Start\n");
+
+			/* ====== RX IQK ====== */
+			rtl_set_bbreg(rtlpriv, 0x82c, BIT(31), 0x0);		/* [31] = 0 --> Page C */
+			rtl_set_rfreg(rtlpriv, Path, 0xef, bRFRegOffsetMask, 0x80000);
+			rtl_set_rfreg(rtlpriv, Path, 0x30, bRFRegOffsetMask, 0x30000);
+			rtl_set_rfreg(rtlpriv, Path, 0x31, bRFRegOffsetMask, 0x3f7ff);
+			rtl_set_rfreg(rtlpriv, Path, 0x32, bRFRegOffsetMask, 0xfe7bf);
+			rtl_set_rfreg(rtlpriv, Path, 0x8f, bRFRegOffsetMask, 0x88001);
+			rtl_set_rfreg(rtlpriv, Path, 0x65, bRFRegOffsetMask, 0x931d0);
+			rtl_set_rfreg(rtlpriv, Path, 0xef, bRFRegOffsetMask, 0x00000);
+
+			rtl_set_bbreg(rtlpriv, 0x978, BIT(31), 0x1);
+			rtl_set_bbreg(rtlpriv, 0x97c, BIT(31), 0x0);
+			rtl_write_dword(rtlpriv, 0x984, 0x0046a911);
+			rtl_set_bbreg(rtlpriv, 0x82c, BIT(31), 0x1);		/* [31] = 1 --> Page C1 */
+			rtl_write_dword(rtlpriv, 0xe88, 0x02140119);
+			rtl_write_dword(rtlpriv, 0xe8c, 0x28161420);
+
+			for (k = 0; k <= 2; k++) {
+				rtl_set_bbreg(rtlpriv, 0x82c, BIT(31), 0x0);		/* [31] = 0 --> Page C */
+				rtl_set_bbreg(rtlpriv, 0x978, 0x03FF8000, (VDF_X[k])>>21&0x000007ff);
+				rtl_set_bbreg(rtlpriv, 0x978, 0x000007FF, (VDF_Y[k])>>21&0x000007ff);
+				rtl_set_bbreg(rtlpriv, 0x82c, BIT(31), 0x1);		/* [31] = 1 --> Page C1 */
+
+				switch (k) {
+				case 0:
+					rtl_write_dword(rtlpriv, 0xe80, 0x38008c38);	/* TX_Tone_idx[9:0], TxK_Mask[29] TX_Tone = 16 */
+					rtl_write_dword(rtlpriv, 0xe84, 0x18008c38);	/* RX_Tone_idx[9:0], RxK_Mask[29] */
+					rtl_set_bbreg(rtlpriv, 0xee8, BIT(30), 0x0);
+					break;
+				case 1:
+					rtl_write_dword(rtlpriv, 0xe80, 0x28008c38);	/* TX_Tone_idx[9:0], TxK_Mask[29] TX_Tone = 16 */
+					rtl_write_dword(rtlpriv, 0xe84, 0x08008c38);	/* RX_Tone_idx[9:0], RxK_Mask[29] */
+					rtl_set_bbreg(rtlpriv, 0xee8, BIT(30), 0x0);
+					break;
+				case 2:
+					RT_TRACE(rtlpriv, COMP_IQK, DBG_LOUD, "VDF_Y[1] = %x;;;VDF_Y[0] = %x\n", VDF_Y[1]>>21 & 0x00007ff, VDF_Y[0]>>21 & 0x00007ff);
+					RT_TRACE(rtlpriv, COMP_IQK, DBG_LOUD, "VDF_X[1] = %x;;;VDF_X[0] = %x\n", VDF_X[1]>>21 & 0x00007ff, VDF_X[0]>>21 & 0x00007ff);
+					Rx_dt[cal] = (VDF_Y[1]>>20)-(VDF_Y[0]>>20);
+					RT_TRACE(rtlpriv, COMP_IQK, DBG_LOUD, "Rx_dt = %d\n", Rx_dt[cal]);
+					Rx_dt[cal] = ((16*Rx_dt[cal])*10000/13823);
+					Rx_dt[cal] = (Rx_dt[cal] >> 1) + (Rx_dt[cal] & BIT(0));
+					rtl_write_dword(rtlpriv, 0xe80, 0x38008c20);	/* TX_Tone_idx[9:0], TxK_Mask[29] TX_Tone = 16 */
+					rtl_write_dword(rtlpriv, 0xe84, 0x18008c20);	/* RX_Tone_idx[9:0], RxK_Mask[29] */
+					rtl_set_bbreg(rtlpriv, 0xee8, 0x00003fff, Rx_dt[cal] & 0x00003fff);
+					break;
+				default:
+					break;
+				}
+
+
+				if (k == 2) {
+					rtl_set_bbreg(rtlpriv, 0xee8, BIT(30), 0x1);	/* RX VDF Enable */
+				}
+
+				rtl_write_dword(rtlpriv, 0xeb8, 0x00100000);		/* cb8[20] N SI/PI v iqk_dpk module */
+
+				cal_retry = 0;
+
+				while (1) {
+					/* one shot */
+					rtl_write_dword(rtlpriv, 0x980, 0xfa000000);
+					rtl_write_dword(rtlpriv, 0x980, 0xf8000000);
+
+					mdelay(10); /* Delay 10ms */
+					rtl_write_dword(rtlpriv, 0xeb8, 0x00000000);
+					delay_count = 0;
+					while (1) {
+						IQK_ready = rtl_get_bbreg(rtlpriv, 0xd40, BIT(10));
+						if ((IQK_ready) || (delay_count > 20)) {
+							break;
+						} else {
+							mdelay(1);
+							delay_count++;
+						}
+					}
+
+					if (delay_count < 20) {	/* If 20ms No Result, then cal_retry++ */
+						/* ============RXIQK Check============== */
+						RX_fail = rtl_get_bbreg(rtlpriv, 0xd40, BIT(11));
+						if (RX_fail == 0) {
+							rtl_write_dword(rtlpriv, 0xeb8, 0x06000000);
+							VDF_X[k] = rtl_get_bbreg(rtlpriv, 0xd40, 0x07ff0000)<<21;
+							rtl_write_dword(rtlpriv, 0xeb8, 0x08000000);
+							VDF_Y[k] = rtl_get_bbreg(rtlpriv, 0xd40, 0x07ff0000)<<21;
+							RX1IQKOK = true;
+							break;
+						} else {
+							rtl_set_bbreg(rtlpriv, 0xe10, 0x000003ff, 0x200>>1);
+							rtl_set_bbreg(rtlpriv, 0xe10, 0x03ff0000, 0x0>>1);
+							RX1IQKOK = false;
+							cal_retry++;
+							if (cal_retry == 10)
+								break;
+
+						}
+					} else {
+						RX1IQKOK = false;
+						cal_retry++;
+						if (cal_retry == 10)
+							break;
+					}
+				}
+			}
+
+
+			RT_TRACE(rtlpriv, COMP_IQK, DBG_LOUD, "RXB_VDF_cal_retry = %d\n", cal_retry);
+			RX_X1[cal] = VDF_X[k-1] ;
+			RX_Y1[cal] = VDF_Y[k-1];
+			rtl_set_bbreg(rtlpriv, 0xee8, BIT(31), 0x1);	/* TX VDF Enable */
+		} else {
+			/* ====== RX IQK ====== */
+			rtl_set_bbreg(rtlpriv, 0x82c, BIT(31), 0x0); /* [31] = 0 --> Page C */
+			rtl_set_rfreg(rtlpriv, Path, 0xef, bRFRegOffsetMask, 0x80000);
+			rtl_set_rfreg(rtlpriv, Path, 0x30, bRFRegOffsetMask, 0x30000);
+			rtl_set_rfreg(rtlpriv, Path, 0x31, bRFRegOffsetMask, 0x3f7ff);
+			rtl_set_rfreg(rtlpriv, Path, 0x32, bRFRegOffsetMask, 0xfe7bf);
+			rtl_set_rfreg(rtlpriv, Path, 0x8f, bRFRegOffsetMask, 0x88001);
+			rtl_set_rfreg(rtlpriv, Path, 0x65, bRFRegOffsetMask, 0x931d0);
+			rtl_set_rfreg(rtlpriv, Path, 0xef, bRFRegOffsetMask, 0x00000);
+
+			rtl_set_bbreg(rtlpriv, 0x978, BIT(31), 0x1);
+			rtl_set_bbreg(rtlpriv, 0x97c, BIT(31), 0x0);
+			rtl_write_dword(rtlpriv, 0x90c, 0x00008000);
+			/* rtl_write_dword(rtlpriv, 0x984, 0x0046a911); */
+			rtl_write_dword(rtlpriv, 0x984, 0x0046a891);
+
+			rtl_set_bbreg(rtlpriv, 0x82c, BIT(31), 0x1);	/* [31] = 1 --> Page C1 */
+			rtl_write_dword(rtlpriv, 0xe80, 0x38008c10);	/* TX_Tone_idx[9:0], TxK_Mask[29] TX_Tone = 16 */
+			rtl_write_dword(rtlpriv, 0xe84, 0x18008c10);	/* RX_Tone_idx[9:0], RxK_Mask[29] */
+			rtl_write_dword(rtlpriv, 0xe88, 0x02140119);
+			rtl_write_dword(rtlpriv, 0xe8c, 0x28161180);
+
+			for (cal = 0; cal < cal_num; cal++) {
+				rtl_set_bbreg(rtlpriv, 0x82c, BIT(31), 0x0);		/* [31] = 0 --> Page C */
+				rtl_set_bbreg(rtlpriv, 0x978, 0x03FF8000, (TX_X1[cal])>>21&0x000007ff);
+				rtl_set_bbreg(rtlpriv, 0x978, 0x000007FF, (TX_Y1[cal])>>21&0x000007ff);
+				rtl_set_bbreg(rtlpriv, 0x82c, BIT(31), 0x1);		/* [31] = 1 --> Page C1 */
+				cal_retry = 0;
+
+				while (1) {
+					/* one shot */
+					rtl_write_dword(rtlpriv, 0xeb8, 0x00100000);	/* cb8[20] N SI/PI v iqk_dpk module */
+					rtl_write_dword(rtlpriv, 0x980, 0xfa000000);
+					rtl_write_dword(rtlpriv, 0x980, 0xf8000000);
+
+					mdelay(10);	/*Delay 10ms */
+					rtl_write_dword(rtlpriv, 0xeb8, 0x00000000);
+					delay_count = 0;
+
+					while (1) {
+						IQK_ready = rtl_get_bbreg(rtlpriv, 0xd40, BIT(10));
+						if ((IQK_ready) || (delay_count > 20)) {
+							break;
+						} else {
+							mdelay(1);
+							delay_count++;
+						}
+					}
+
+					if (delay_count < 20) {				/* If 20ms No Result, then cal_retry++ */
+						/* ============RXIQK Check============== */
+						RX_fail = rtl_get_bbreg(rtlpriv, 0xd40, BIT(11));
+						if (RX_fail == 0) {
+							rtl_write_dword(rtlpriv, 0xeb8, 0x06000000);
+							RX_X1[cal] = rtl_get_bbreg(rtlpriv, 0xd40, 0x07ff0000)<<21;
+							rtl_write_dword(rtlpriv, 0xeb8, 0x08000000);
+							RX_Y1[cal] = rtl_get_bbreg(rtlpriv, 0xd40, 0x07ff0000)<<21;
+							RX1IQKOK = true;
+							/*
+							rtl_write_dword(rtlpriv, 0xeb8, 0x05000000);
+							reg1 = rtl_get_bbreg(rtlpriv, 0xd40, 0xffffffff);
+							rtl_write_dword(rtlpriv, 0xeb8, 0x06000000);
+							reg2 = rtl_get_bbreg(rtlpriv, 0xd40, 0x0000001f);
+							DbgPrint("reg1 = %d, reg2 = %d", reg1, reg2);
+							Image_Power = (reg2<<32)+reg1;
+							DbgPrint("Before PW = %d\n", Image_Power);
+							rtl_write_dword(rtlpriv, 0xeb8, 0x07000000);
+							reg1 = rtl_get_bbreg(rtlpriv, 0xd40, 0xffffffff);
+							rtl_write_dword(rtlpriv, 0xeb8, 0x08000000);
+							reg2 = rtl_get_bbreg(rtlpriv, 0xd40, 0x0000001f);
+							Image_Power = (reg2<<32)+reg1;
+							DbgPrint("After PW = %d\n", Image_Power);
+							*/
+							break;
+						} else {
+							rtl_set_bbreg(rtlpriv, 0xe10, 0x000003ff, 0x200>>1);
+							rtl_set_bbreg(rtlpriv, 0xe10, 0x03ff0000, 0x0>>1);
+							RX1IQKOK = false;
+							cal_retry++;
+							if (cal_retry == 10)
+								break;
+						}
+					} else {
+						RX1IQKOK = false;
+						cal_retry++;
+						if (cal_retry == 10)
+							break;
+					}
+
+				}
+
+			RT_TRACE(rtlpriv, COMP_IQK, DBG_LOUD, "RXB_cal_retry = %d\n", cal_retry);
+			if (RX1IQKOK)
+				RX_Average++;
+			}
+		}
+	    }
+		break;
+	default:
+		break;
+	}
+
+	/* FillIQK Result */
+	switch (Path) {
+	case RF90_PATH_A:
+	    {
+		RT_TRACE(rtlpriv, COMP_IQK, DBG_LOUD, "========Path_A =======\n");
+		if (TX_Average == 0) {
+			_rtl8812au_iqk_tx_fill_iqc(rtlpriv, Path, 0x200, 0x0);
+			break;
+		}
+		for (i = 0; i < TX_Average; i++) {
+			RT_TRACE(rtlpriv, COMP_IQK, DBG_LOUD, "TX_X0[%d] = %x ;; TX_Y0[%d] = %x\n", i, (TX_X0[i])>>21&0x000007ff, i, (TX_Y0[i])>>21&0x000007ff);
+		}
+
+		for (i = 0; i < TX_Average; i++) {
+			for (ii = i+1; ii < TX_Average; ii++) {
+				dx = (TX_X0[i]>>21) - (TX_X0[ii]>>21);
+				if (dx < 4 && dx > -4) {
+					dy = (TX_Y0[i]>>21) - (TX_Y0[ii]>>21);
+					if (dy < 4 && dy > -4) {
+						TX_X = ((TX_X0[i]>>21) + (TX_X0[ii]>>21))/2;
+						TX_Y = ((TX_Y0[i]>>21) + (TX_Y0[ii]>>21))/2;
+						if (rtlpriv->phy.current_chan_bw == 2) {
+							Tx_dt[0] = (Tx_dt[i] + Tx_dt[ii])/2;
+						}
+						TX_finish = 1;
+						break;
+					}
+				}
+			}
+			if (TX_finish == 1)
+				break;
+		}
+
+		if (rtlpriv->phy.current_chan_bw == 2) {
+			rtl_set_bbreg(rtlpriv, 0x82c, BIT(31), 0x1);		/* [31] = 0 --> Page C */
+			rtl_set_bbreg(rtlpriv, 0xce8, 0x3fff0000, Tx_dt[0] & 0x00003fff);
+			rtl_set_bbreg(rtlpriv, 0x82c, BIT(31), 0x0);		/* [31] = 0 --> Page C */
+		}
+
+		if (TX_finish == 1) {
+			_rtl8812au_iqk_tx_fill_iqc(rtlpriv, Path, TX_X, TX_Y);
+		} else {
+			_rtl8812au_iqk_tx_fill_iqc(rtlpriv, Path, 0x200, 0x0);
+		}
+
+		if (RX_Average == 0) {
+			_rtl8812au_iqk_rx_fill_iqc(rtlpriv, Path, 0x200, 0x0);
+			break;
+		}
+
+		for (i = 0; i < RX_Average; i++) {
+			RT_TRACE(rtlpriv, COMP_IQK, DBG_LOUD, "RX_X0[%d] = %x ;; RX_Y0[%d] = %x\n", i, (RX_X0[i])>>21&0x000007ff, i, (RX_Y0[i])>>21&0x000007ff);
+		}
+
+		for (i = 0; i < RX_Average; i++) {
+			for (ii = i+1; ii < RX_Average; ii++) {
+				dx = (RX_X0[i]>>21) - (RX_X0[ii]>>21);
+				if (dx < 4 && dx > -4) {
+					dy = (RX_Y0[i]>>21) - (RX_Y0[ii]>>21);
+					if (dy < 4 && dy > -4) {
+						RX_X = ((RX_X0[i]>>21) + (RX_X0[ii]>>21))/2;
+						RX_Y = ((RX_Y0[i]>>21) + (RX_Y0[ii]>>21))/2;
+						if (rtlpriv->phy.current_chan_bw == 2) {
+							Rx_dt[0] = (Rx_dt[i] + Rx_dt[ii])/2;
+						}
+						RX_finish = 1;
+						break;
+					}
+				}
+			}
+			if (RX_finish == 1)
+				break;
+		}
+
+		if (rtlpriv->phy.current_chan_bw == 2) {
+			rtl_set_bbreg(rtlpriv, 0x82c, BIT(31), 0x1); /* [31] = 0 --> Page C */
+			rtl_set_bbreg(rtlpriv, 0xce8, 0x00003fff, Rx_dt[0] & 0x00003fff);
+			rtl_set_bbreg(rtlpriv, 0x82c, BIT(31), 0x0); /* [31] = 0 --> Page C */
+		}
+
+		if (RX_finish == 1) {
+			_rtl8812au_iqk_rx_fill_iqc(rtlpriv, Path, RX_X, RX_Y);
+		} else {
+			_rtl8812au_iqk_rx_fill_iqc(rtlpriv, Path, 0x200, 0x0);
+		}
+
+		/*
+		 * ULLI check with rtl8821ae source, if we can remove this
+		 * look as the commit 5856f7384c22bf6364ecb77635e95b4858567080
+		 * from #if 1
+		 */
+#if 1
+		if (TX_finish && RX_finish) {
+			rtlpriv->phy.need_iqk = false;
+
+			if (rtlpriv->phy.current_chan_bw == 2) {
+				rtl_set_bbreg(rtlpriv, 0x82c, BIT(31), 0x1); /* [31] = 0 --> Page C */
+				rtl_set_bbreg(rtlpriv, 0x82c, BIT(31), 0x0); /* [31] = 0 --> Page C */
+			}
+		}
+#endif
+
+	    }
+		break;
+	case RF90_PATH_B:
+	    {
+		RT_TRACE(rtlpriv, COMP_IQK, DBG_LOUD, "========Path_B =======\n");
+		if (TX_Average == 0) {
+			_rtl8812au_iqk_tx_fill_iqc(rtlpriv, Path, 0x200, 0x0);
+			break;
+		}
+
+		for (i = 0; i < TX_Average; i++) {
+			RT_TRACE(rtlpriv, COMP_IQK, DBG_LOUD, "TX_X1[%d] = %x ;; TX_Y1[%d] = %x\n", i, (TX_X1[i])>>21&0x000007ff, i, (TX_Y1[i])>>21&0x000007ff);
+		}
+
+		for (i = 0; i < TX_Average; i++) {
+			for (ii = i+1; ii < TX_Average; ii++) {
+				dx = (TX_X1[i]>>21) - (TX_X1[ii]>>21);
+				if (dx < 4 && dx > -4) {
+					dy = (TX_Y1[i]>>21) - (TX_Y1[ii]>>21);
+					if (dy < 4 && dy > -4) {
+						TX_X = ((TX_X1[i]>>21) + (TX_X1[ii]>>21))/2;
+						TX_Y = ((TX_Y1[i]>>21) + (TX_Y1[ii]>>21))/2;
+						if (rtlpriv->phy.current_chan_bw == 2) {
+							Tx_dt[0] = (Tx_dt[i] + Tx_dt[ii])/2;
+						}
+						TX_finish = 1;
+						break;
+					}
+				}
+			}
+			if (TX_finish == 1)
+				break;
+		}
+
+		if (rtlpriv->phy.current_chan_bw == 2) {
+			rtl_set_bbreg(rtlpriv, 0x82c, BIT(31), 0x1); /* [31] = 0 --> Page C */
+			rtl_set_bbreg(rtlpriv, 0xee8, 0x3fff0000, Tx_dt[0] & 0x00003fff);
+			rtl_set_bbreg(rtlpriv, 0x82c, BIT(31), 0x0); /* [31] = 0 --> Page C */
+		}
+		if (TX_finish == 1) {
+			_rtl8812au_iqk_tx_fill_iqc(rtlpriv, Path, TX_X, TX_Y);
+		} else {
+			_rtl8812au_iqk_tx_fill_iqc(rtlpriv, Path, 0x200, 0x0);
+		}
+
+		if (RX_Average == 0) {
+			_rtl8812au_iqk_rx_fill_iqc(rtlpriv, Path, 0x200, 0x0);
+			break;
+		}
+
+		for (i = 0; i < RX_Average; i++) {
+			RT_TRACE(rtlpriv, COMP_IQK, DBG_LOUD, "RX_X1[%d] = %x ;; RX_Y1[%d] = %x\n", i, (RX_X1[i])>>21&0x000007ff, i, (RX_Y1[i])>>21&0x000007ff);
+		}
+
+		for (i = 0; i < RX_Average; i++) {
+			for (ii = i+1; ii < RX_Average; ii++) {
+				dx = (RX_X1[i]>>21) - (RX_X1[ii]>>21);
+				if (dx < 4 && dx > -4) {
+					dy = (RX_Y1[i]>>21) - (RX_Y1[ii]>>21);
+					if (dy < 4 && dy > -4) {
+						RX_X = ((RX_X1[i]>>21) + (RX_X1[ii]>>21))/2;
+						RX_Y = ((RX_Y1[i]>>21) + (RX_Y1[ii]>>21))/2;
+						if (rtlpriv->phy.current_chan_bw == 2) {
+							Rx_dt[0] = (Rx_dt[i] + Rx_dt[ii])/2;
+						}
+						RX_finish = 1;
+						break;
+					}
+				}
+			}
+			if (RX_finish == 1)
+				break;
+		}
+
+		if (rtlpriv->phy.current_chan_bw == 2) {
+			rtl_set_bbreg(rtlpriv, 0x82c, BIT(31), 0x1); /* [31] = 0 --> Page C */
+			rtl_set_bbreg(rtlpriv, 0xee8, 0x00003fff, Rx_dt[0] & 0x00003fff);
+			rtl_set_bbreg(rtlpriv, 0x82c, BIT(31), 0x0); /* [31] = 0 --> Page C */
+		}
+
+		if (RX_finish == 1) {
+			_rtl8812au_iqk_rx_fill_iqc(rtlpriv, Path, RX_X, RX_Y);
+		} else{
+			_rtl8812au_iqk_rx_fill_iqc(rtlpriv, Path, 0x200, 0x0);
+		}
+
+
+		/*
+		 * ULLI check with rtl8821ae source, if we can remove this
+		 * look as the commit 5856f7384c22bf6364ecb77635e95b4858567080
+		 * from #if 1
+		 */
+#if 1
+		if (TX_finish && RX_finish) {
+/* pRFCalibrateInfo->IQKMatrixRegSetting[chnlIdx].bIQKDone= true; */
+			rtlpriv->phy.need_iqk = false;
+
+			if (rtlpriv->phy.current_chan_bw == 2) {
+				rtl_set_bbreg(rtlpriv, 0x82c, BIT(31), 0x1); /* [31] = 0 --> Page C */
+				rtl_set_bbreg(rtlpriv, 0x82c, BIT(31), 0x0); /* [31] = 0 --> Page C */
+			}
+		}
+#endif
+
+	    }
+		break;
+	default:
+		break;
+	}
+}
+
+
+
+static void _rtl8812au_iqk_backup_macbb(struct rtl_priv *rtlpriv,
+					u32 *macbb_backup,
+					u32 *backup_macbb_reg, u32 mac_bb_num)
+{
+	u32 i;
+
+	rtl_set_bbreg(rtlpriv, 0x82c, BIT(31), 0x0); /* [31] = 0 --> Page C */
+	/* save MACBB default value */
+	for (i = 0; i < mac_bb_num; i++) {
+		macbb_backup[i] = rtl_read_dword(rtlpriv, backup_macbb_reg[i]);
+	}
+
+	RT_TRACE(rtlpriv, COMP_IQK, DBG_LOUD, "BackupMacBB Success!!!!\n");
+}
+
+static void _rtl8821au_iqk_backup_macbb(struct rtl_priv *rtlpriv,
+					u32 *macbb_backup,
+					u32 *backup_macbb_reg, u32 mac_bb_num)
+{
+	u32 i;
+
+	rtl_set_bbreg(rtlpriv, 0x82c, BIT(31), 0x0); /* [31] = 0 --> Page C */
+	/* save MACBB default value */
+	for (i = 0; i < mac_bb_num; i++) {
+		macbb_backup[i] = rtl_read_dword(rtlpriv, backup_macbb_reg[i]);
+	}
+
+	RT_TRACE(rtlpriv, COMP_IQK, DBG_LOUD, "BackupMacBB Success!!!!\n");
+}
+
+static void _rtl8812au_iqk_backup_rf(struct rtl_priv *rtlpriv,
+	uint32_t *RFA_backup, uint32_t *RFB_backup,
+	uint32_t *Backup_RF_REG, uint32_t RF_NUM)
+{
+	uint32_t i;
+
+	rtl_set_bbreg(rtlpriv, 0x82c, BIT(31), 0x0); /* [31] = 0 --> Page C */
+	/* Save RF Parameters */
+	for (i = 0; i < RF_NUM; i++) {
+		RFA_backup[i] = rtl_get_rfreg(rtlpriv, RF90_PATH_A, Backup_RF_REG[i], bMaskDWord);
+		RFB_backup[i] = rtl_get_rfreg(rtlpriv, RF90_PATH_B, Backup_RF_REG[i], bMaskDWord);
+	}
+	RT_TRACE(rtlpriv, COMP_IQK, DBG_LOUD, "BackupRF Success!!!!\n");
+}
+
+static void _rtl8821au_iqk_backup_rf(struct rtl_priv *rtlpriv, u32 *rfa_backup,
+				     u32 *rfb_backup, u32 *backup_rf_reg,
+				     u32 rf_num)
+{
+	u32 i;
+
+	rtl_set_bbreg(rtlpriv, 0x82c, BIT(31), 0x0); /* [31] = 0 --> Page C */
+	/* Save RF Parameters */
+	for (i = 0; i < rf_num; i++) {
+		rfa_backup[i] = rtl_get_rfreg(rtlpriv, RF90_PATH_A, backup_rf_reg[i], bMaskDWord);
+	}
+
+	RT_TRACE(rtlpriv, COMP_IQK, DBG_LOUD, "BackupRF Success!!!!\n");
+}
+
+static void _rtl8812au_iqk_backup_afe(struct rtl_priv *rtlpriv,
+	uint32_t *AFE_backup, uint32_t *Backup_AFE_REG, uint32_t AFE_NUM)
+{
+	uint32_t i;
+
+	rtl_set_bbreg(rtlpriv, 0x82c, BIT(31), 0x0); /* [31] = 0 --> Page C */
+	/* Save AFE Parameters */
+	for (i = 0; i < AFE_NUM; i++) {
+		AFE_backup[i] = rtl_read_dword(rtlpriv, Backup_AFE_REG[i]);
+	}
+	RT_TRACE(rtlpriv, COMP_IQK, DBG_LOUD, "BackupAFE Success!!!!\n");
+}
+
+static void _rtl8821au_iqk_backup_afe(struct rtl_priv *rtlpriv, u32 *afe_backup,
+				      u32 *backup_afe_REG, u32 afe_num)
+{
+	u32  i;
+
+	rtl_set_bbreg(rtlpriv, 0x82c, BIT(31), 0x0); /* [31] = 0 --> Page C */
+	/* Save AFE Parameters */
+	for (i = 0; i < afe_num; i++) {
+		afe_backup[i] = rtl_read_dword(rtlpriv, backup_afe_REG[i]);
+	}
+	RT_TRACE(rtlpriv, COMP_IQK, DBG_LOUD, "BackupAFE Success!!!!\n");
+}
+
+static void _rtl8812au_iqk_restore_macbb(struct rtl_priv *rtlpriv,
+	uint32_t *MACBB_backup, uint32_t *Backup_MACBB_REG, uint32_t MACBB_NUM)
+{
+	uint32_t i;
+	rtl_set_bbreg(rtlpriv, 0x82c, BIT(31), 0x0);     /* [31] = 0 --> Page C */
+	/* Reload MacBB Parameters */
+	for (i = 0; i < MACBB_NUM; i++) {
+		rtl_write_dword(rtlpriv, Backup_MACBB_REG[i], MACBB_backup[i]);
+	}
+	RT_TRACE(rtlpriv, COMP_IQK, DBG_LOUD, "RestoreMacBB Success!!!!\n");
+}
+
+static void _rtl8821au_iqk_restore_macbb(struct rtl_priv *rtlpriv,
+					 u32 *macbb_backup,
+					 u32 *backup_macbb_reg,
+					 u32 macbb_num)
+{
+	u32 i;
+
+	rtl_set_bbreg(rtlpriv, 0x82c, BIT(31), 0x0);     /* [31] = 0 --> Page C */
+	/* Reload MacBB Parameters */
+	for (i = 0; i < macbb_num; i++) {
+		rtl_write_dword(rtlpriv, backup_macbb_reg[i], macbb_backup[i]);
+	}
+	RT_TRACE(rtlpriv, COMP_IQK, DBG_LOUD, "RestoreMacBB Success!!!!\n");
+}
+
+static void _rtl8812au_iqk_restore_rf(struct rtl_priv *rtlpriv,
+	enum radio_path Path, uint32_t *Backup_RF_REG, uint32_t *RF_backup, uint32_t RF_REG_NUM)
+{
+	uint32_t i;
+
+	rtl_set_bbreg(rtlpriv, 0x82c, BIT(31), 0x0); /*  [31] = 0 --> Page C */
+	for (i = 0; i < RF_REG_NUM; i++)
+		rtl_set_rfreg(rtlpriv, Path, Backup_RF_REG[i], bRFRegOffsetMask, RF_backup[i]);
+
+	rtl_set_rfreg(rtlpriv, Path, 0xef, bRFRegOffsetMask, 0x0);
+
+	switch (Path) {
+	case RF90_PATH_A:
+		RT_TRACE(rtlpriv, COMP_IQK, DBG_LOUD, "RestoreRF Path A Success!!!!\n");
+		break;
+	case RF90_PATH_B:
+		RT_TRACE(rtlpriv, COMP_IQK, DBG_LOUD, "RestoreRF Path B Success!!!!\n");
+		break;
+	default:
+		break;
+	}
+}
+
+static void _rtl8821au_iqk_restore_rf(struct rtl_priv *rtlpriv,
+				      enum radio_path Path,
+				      u32 *backup_rf_reg,
+				      u32 *rf_backup, u32 rf_reg_num)
+{
+	u32 i;
+
+	rtl_set_bbreg(rtlpriv, 0x82c, BIT(31), 0x0); /*  [31] = 0 --> Page C */
+	for (i = 0; i < rf_reg_num; i++)
+		rtl_set_rfreg(rtlpriv, Path, backup_rf_reg[i], bRFRegOffsetMask, rf_backup[i]);
+
+	switch (Path) {
+	case RF90_PATH_A:
+		RT_TRACE(rtlpriv, COMP_IQK, DBG_LOUD, "RestoreRF Path A Success!!!!\n");
+		break;
+	default:
+		break;
+	}
+}
+
+static void _rtl8812au_iqk_restore_afe(struct rtl_priv *rtlpriv, uint32_t *AFE_backup,
+	uint32_t *Backup_AFE_REG, uint32_t AFE_NUM)
+{
+	uint32_t i;
+
+	rtl_set_bbreg(rtlpriv, 0x82c, BIT(31), 0x0); /* [31] = 0 --> Page C */
+	/* Reload AFE Parameters */
+	for (i = 0; i < AFE_NUM; i++) {
+		rtl_write_dword(rtlpriv, Backup_AFE_REG[i], AFE_backup[i]);
+	}
+	rtl_set_bbreg(rtlpriv, 0x82c, BIT(31), 0x1); /*  [31] = 1 --> Page C1 */
+	rtl_write_dword(rtlpriv, 0xc80, 0x0);
+	rtl_write_dword(rtlpriv, 0xc84, 0x0);
+	rtl_write_dword(rtlpriv, 0xc88, 0x0);
+	rtl_write_dword(rtlpriv, 0xc8c, 0x3c000000);
+	rtl_write_dword(rtlpriv, 0xcb8, 0x0);
+	rtl_write_dword(rtlpriv, 0xe80, 0x0);
+	rtl_write_dword(rtlpriv, 0xe84, 0x0);
+	rtl_write_dword(rtlpriv, 0xe88, 0x0);
+	rtl_write_dword(rtlpriv, 0xe8c, 0x3c000000);
+	rtl_write_dword(rtlpriv, 0xeb8, 0x0);
+	RT_TRACE(rtlpriv, COMP_IQK, DBG_LOUD, "RestoreAFE Success!!!!\n");
+}
+
+static void _rtl8821au_iqk_restore_afe(struct rtl_priv *rtlpriv,
+				       u32 *afe_backup, u32 *backup_afe_reg,
+				       u32 afe_num)
+{
+	uint32_t i;
+	rtl_set_bbreg(rtlpriv, 0x82c, BIT(31), 0x0); /* [31] = 0 --> Page C */
+	/* Reload AFE Parameters */
+	for (i = 0; i < afe_num; i++) {
+		rtl_write_dword(rtlpriv, backup_afe_reg[i], afe_backup[i]);
+	}
+	rtl_set_bbreg(rtlpriv, 0x82c, BIT(31), 0x1); /* [31] = 1 --> Page C1 */
+	rtl_write_dword(rtlpriv, 0xc80, 0x0);
+	rtl_write_dword(rtlpriv, 0xc84, 0x0);
+	rtl_write_dword(rtlpriv, 0xc88, 0x0);
+	rtl_write_dword(rtlpriv, 0xc8c, 0x3c000000);
+	rtl_write_dword(rtlpriv, 0xcb8, 0x0);
+	RT_TRACE(rtlpriv, COMP_IQK, DBG_LOUD, "RestoreAFE Success!!!!\n");
+}
+
+
+static void _rtl8812au_iqk_configure_mac(struct rtl_priv *rtlpriv)
+{
+	/* ========MAC register setting======== */
+	rtl_set_bbreg(rtlpriv, 0x82c, BIT(31), 0x0); 	/* [31] = 0 --> Page C */
+	rtl_write_byte(rtlpriv, 0x522, 0x3f);
+	rtl_set_bbreg(rtlpriv, 0x550, BIT(11)|BIT(3), 0x0);
+	rtl_set_bbreg(rtlpriv, 0x808, BIT(28), 0x0);	/* CCK Off */
+	rtl_write_byte(rtlpriv, 0x808, 0x00);		/* RX ante off */
+	rtl_set_bbreg(rtlpriv, 0x838, 0xf, 0xc);		/* CCA off */
+}
+
+static void _rtl8821au_iqk_configure_mac(struct rtl_priv *rtlpriv)
+{
+	/* ========MAC register setting======== */
+	rtl_set_bbreg(rtlpriv, 0x82c, BIT(31), 0x0); /* [31] = 0 --> Page C */
+	rtl_write_byte(rtlpriv, 0x522, 0x3f);
+	rtl_set_bbreg(rtlpriv, 0x550, BIT(3), 0x0);
+	rtl_set_bbreg(rtlpriv, 0x551, BIT(3), 0x0);
+	rtl_set_bbreg(rtlpriv, 0x808, BIT(28), 0x0);	/* CCK Off */
+	rtl_write_byte(rtlpriv, 0x808, 0x00);		/* RX ante off */
+	rtl_set_bbreg(rtlpriv, 0x838, 0xf, 0xc);		/* CCA off */
+}
+
+
+#undef MACBB_REG_NUM
+#undef AFE_REG_NUM
+#undef RF_REG_NUM
+#define MACBB_REG_NUM 10
+#define AFE_REG_NUM 14
+#define RF_REG_NUM 3
+
+
+/* Maintained by BB James. */
+static void _rtl8812au_phy_iq_calibrate(struct rtl_priv *rtlpriv)
+{
+	uint32_t MACBB_backup[MACBB_REG_NUM], AFE_backup[AFE_REG_NUM], RFA_backup[RF_REG_NUM], RFB_backup[RF_REG_NUM];
+	uint32_t Backup_MACBB_REG[MACBB_REG_NUM] = { 0xb00, 0x520, 0x550, 0x808, 0x90c, 0xc00, 0xe00, 0x8c4, 0x838, 0x82c };
+	uint32_t Backup_AFE_REG[AFE_REG_NUM] = { 0xc5c, 0xc60, 0xc64, 0xc68, 0xcb8, 0xcb0, 0xcb4,
+						 0xe5c, 0xe60, 0xe64, 0xe68, 0xeb8, 0xeb0, 0xeb4 };
+	uint32_t Backup_RF_REG[RF_REG_NUM] = { 0x65, 0x8f, 0x0 };
+
+
+	_rtl8812au_iqk_backup_macbb(rtlpriv, MACBB_backup, Backup_MACBB_REG, MACBB_REG_NUM);
+	_rtl8812au_iqk_backup_afe(rtlpriv, AFE_backup, Backup_AFE_REG, AFE_REG_NUM);
+	_rtl8812au_iqk_backup_rf(rtlpriv, RFA_backup, RFB_backup, Backup_RF_REG, RF_REG_NUM);
+
+	_rtl8812au_iqk_configure_mac(rtlpriv);
+	_rtl8812au_iqk_tx(rtlpriv, RF90_PATH_A);
+	_rtl8812au_iqk_restore_rf(rtlpriv, RF90_PATH_A, Backup_RF_REG, RFA_backup, RF_REG_NUM);
+
+	_rtl8812au_iqk_tx(rtlpriv, RF90_PATH_B);
+	_rtl8812au_iqk_restore_rf(rtlpriv, RF90_PATH_B, Backup_RF_REG, RFB_backup, RF_REG_NUM);
+
+	_rtl8812au_iqk_restore_afe(rtlpriv, AFE_backup, Backup_AFE_REG, AFE_REG_NUM);
+	_rtl8812au_iqk_restore_macbb(rtlpriv, MACBB_backup, Backup_MACBB_REG, MACBB_REG_NUM);
+}
+
+
+
+void rtl8812au_phy_iq_calibrate(struct rtl_priv *rtlpriv, bool bReCovery)
+{
+	_rtl8812au_phy_iq_calibrate(rtlpriv);
+}
+
+
+
+/* ****************************************************************************** */
+/*									*/
+/*  from HalPhyRf_8821A.c						*/
+/*									*/
+/* ****************************************************************************** */
+
+
+
+
+
+
+
+
+#define cal_num 3
+
+static void _rtl8821au_iqk_tx(struct rtl_priv *rtlpriv, enum radio_path Path)
+{
+	struct rtl_hal	*rtlhal = rtl_hal(rtlpriv);
+
+	uint32_t TX_fail, RX_fail, delay_count, IQK_ready, cal_retry, cal = 0, temp_reg65;
+	int 	TX_X = 0, TX_Y = 0, RX_X = 0, RX_Y = 0, TX_Average = 0, RX_Average = 0;
+	int 	TX_X0[cal_num], TX_Y0[cal_num], TX_X0_RXK[cal_num], TX_Y0_RXK[cal_num], RX_X0[cal_num], RX_Y0[cal_num];
+	bool TX0IQKOK = false, RX0IQKOK = false;
+	bool VDF_enable = false;
+	int 	i, k, VDF_Y[3], VDF_X[3], Tx_dt[3], Rx_dt[3], ii, dx = 0, dy = 0, TX_finish = 0, RX_finish = 0;
+
+	RT_TRACE(rtlpriv, COMP_IQK, DBG_LOUD, "BandWidth = %d\n", rtlpriv->phy.current_chan_bw);
+	if (rtlpriv->phy.current_chan_bw == 2) {
+		VDF_enable = true;
+	}
+
+	while (cal < cal_num) {
+		switch (Path) {
+		case RF90_PATH_A:
+		    {
+			temp_reg65 = rtl_get_rfreg(rtlpriv, Path, 0x65, bMaskDWord);
+
+			if (rtlhal->external_pa_2g) {
+				rtl_set_bbreg(rtlpriv, 0x82c, BIT(31), 0x0); /* [31] = 0 --> Page C */
+				rtl_set_rfreg(rtlpriv, Path, 0x65, bRFRegOffsetMask, 0x931d5);
+			}
+
+			/* Path-A LOK */
+			rtl_set_bbreg(rtlpriv, 0x82c, BIT(31), 0x0); /* [31] = 0 --> Page C */
+			/* ========Path-A AFE all on======== */
+			/* Port 0 DAC/ADC on */
+			rtl_write_dword(rtlpriv, 0xc60, 0x77777777);
+			rtl_write_dword(rtlpriv, 0xc64, 0x77777777);
+
+			rtl_write_dword(rtlpriv, 0xc68, 0x19791979);
+			rtl_write_dword(rtlpriv, 0xc6c, 0x19791979);
+			rtl_write_dword(rtlpriv, 0xc70, 0x19791979);
+			rtl_write_dword(rtlpriv, 0xc74, 0x19791979);
+			rtl_write_dword(rtlpriv, 0xc78, 0x19791979);
+			rtl_write_dword(rtlpriv, 0xc7c, 0x19791979);
+			rtl_write_dword(rtlpriv, 0xc80, 0x19791979);
+			rtl_write_dword(rtlpriv, 0xc84, 0x19791979);
+
+			rtl_set_bbreg(rtlpriv, 0xc00, 0xf, 0x4);	/* 	hardware 3-wire off */
+
+			/* LOK Setting */
+			/* ====== LOK ====== */
+			/* 1. DAC/ADC sampling rate (160 MHz) */
+			rtl_set_bbreg(rtlpriv, 0xc5c, BIT(26)|BIT(25)|BIT(24), 0x7);
+
+			/* 2. LoK RF Setting (at BW = 20M) */
+			rtl_set_rfreg(rtlpriv, Path, 0xef, bRFRegOffsetMask, 0x80002);
+			rtl_set_rfreg(rtlpriv, Path, 0x18, 0x00c00, 0x3);     /* BW 20M */
+			rtl_set_rfreg(rtlpriv, Path, 0x30, bRFRegOffsetMask, 0x20000);
+			rtl_set_rfreg(rtlpriv, Path, 0x31, bRFRegOffsetMask, 0x0003f);
+			rtl_set_rfreg(rtlpriv, Path, 0x32, bRFRegOffsetMask, 0xf3fc3);
+			rtl_set_rfreg(rtlpriv, Path, 0x65, bRFRegOffsetMask, 0x931d5);
+			rtl_set_rfreg(rtlpriv, Path, 0x8f, bRFRegOffsetMask, 0x8a001);
+			rtl_set_bbreg(rtlpriv, 0xcb8, 0xf, 0xd);
+			rtl_write_dword(rtlpriv, 0x90c, 0x00008000);
+			rtl_write_dword(rtlpriv, 0xb00, 0x03000100);
+			rtl_set_bbreg(rtlpriv, 0xc94, BIT(0), 0x1);
+			rtl_write_dword(rtlpriv, 0x978, 0x29002000);	/* TX (X,Y) */
+			rtl_write_dword(rtlpriv, 0x97c, 0xa9002000);	/* RX (X,Y) */
+			rtl_write_dword(rtlpriv, 0x984, 0x00462910);	/* [0]:AGC_en, [15]:idac_K_Mask */
+
+			rtl_set_bbreg(rtlpriv, 0x82c, BIT(31), 0x1); 	/* [31] = 1 --> Page C1 */
+
+			if (rtlhal->external_pa_2g)
+				rtl_write_dword(rtlpriv, 0xc88, 0x821403f7);
+			else
+				rtl_write_dword(rtlpriv, 0xc88, 0x821403f4);
+
+			if (rtlhal->current_bandtype)
+				rtl_write_dword(rtlpriv, 0xc8c, 0x68163e96);
+			else
+				rtl_write_dword(rtlpriv, 0xc8c, 0x28163e96);
+
+			rtl_write_dword(rtlpriv, 0xc80, 0x18008c10);/* TX_Tone_idx[9:0], TxK_Mask[29] TX_Tone = 16 */
+			rtl_write_dword(rtlpriv, 0xc84, 0x38008c10);/* RX_Tone_idx[9:0], RxK_Mask[29] */
+			rtl_write_dword(rtlpriv, 0xcb8, 0x00100000);/* cb8[20] N SI/PI v iqk_dpk module */
+			rtl_write_dword(rtlpriv, 0x980, 0xfa000000);
+			rtl_write_dword(rtlpriv, 0x980, 0xf8000000);
+
+			mdelay(10); /* Delay 10ms */
+			rtl_write_dword(rtlpriv, 0xcb8, 0x00000000);
+
+			rtl_set_bbreg(rtlpriv, 0x82c, BIT(31), 0x0); /* [31] = 0 --> Page C */
+			rtl_set_rfreg(rtlpriv, Path, 0x58, 0x7fe00, rtl_get_rfreg(rtlpriv, Path, 0x8, 0xffc00)); /* Load LOK */
+			switch (rtlpriv->phy.current_chan_bw) {
+			case 1:
+				rtl_set_rfreg(rtlpriv, Path, 0x18, 0x00c00, 0x1);
+				break;
+			case 2:
+				rtl_set_rfreg(rtlpriv, Path, 0x18, 0x00c00, 0x0);
+				break;
+			default:
+				break;
+			}
+			rtl_set_bbreg(rtlpriv, 0x82c, BIT(31), 0x1); /* [31] = 1 --> Page C1 */
+
+			/* 3. TX RF Setting */
+			rtl_set_bbreg(rtlpriv, 0x82c, BIT(31), 0x0); /* [31] = 0 --> Page C */
+			rtl_set_rfreg(rtlpriv, Path, 0xef, bRFRegOffsetMask, 0x80000);
+			rtl_set_rfreg(rtlpriv, Path, 0x30, bRFRegOffsetMask, 0x20000);
+			rtl_set_rfreg(rtlpriv, Path, 0x31, bRFRegOffsetMask, 0x0003f);
+			rtl_set_rfreg(rtlpriv, Path, 0x32, bRFRegOffsetMask, 0xf3fc3);
+			rtl_set_rfreg(rtlpriv, Path, 0x65, bRFRegOffsetMask, 0x931d5);
+			rtl_set_rfreg(rtlpriv, Path, 0x8f, bRFRegOffsetMask, 0x8a001);
+			rtl_set_rfreg(rtlpriv, Path, 0xef, bRFRegOffsetMask, 0x00000);
+			rtl_set_bbreg(rtlpriv, 0xcb8, 0xf, 0xd);
+			rtl_write_dword(rtlpriv, 0x90c, 0x00008000);
+			rtl_write_dword(rtlpriv, 0xb00, 0x03000100);
+			rtl_set_bbreg(rtlpriv, 0xc94, BIT(0), 0x1);
+			rtl_write_dword(rtlpriv, 0x978, 0x29002000);/* TX (X,Y) */
+			rtl_write_dword(rtlpriv, 0x97c, 0xa9002000);/* RX (X,Y) */
+			rtl_write_dword(rtlpriv, 0x984, 0x0046a910);/* [0]:AGC_en, [15]:idac_K_Mask */
+
+			rtl_set_bbreg(rtlpriv, 0x82c, BIT(31), 0x1); /* [31] = 1 --> Page C1 */
+
+			if (rtlhal->external_pa_2g)
+				rtl_write_dword(rtlpriv, 0xc88, 0x821403f7);
+			else
+				rtl_write_dword(rtlpriv, 0xc88, 0x821403f1);
+
+			if (rtlhal->current_bandtype)
+				rtl_write_dword(rtlpriv, 0xc8c, 0x40163e96);
+			else
+				rtl_write_dword(rtlpriv, 0xc8c, 0x00163e96);
+
+			if (VDF_enable == 1) {
+				RT_TRACE(rtlpriv, COMP_IQK, DBG_LOUD, "VDF_enable\n");
+				for (k = 0; k <= 2; k++) {
+					switch (k) {
+					case 0:
+						rtl_write_dword(rtlpriv, 0xc80, 0x18008c38);/* TX_Tone_idx[9:0], TxK_Mask[29] TX_Tone = 16 */
+						rtl_write_dword(rtlpriv, 0xc84, 0x38008c38);/* RX_Tone_idx[9:0], RxK_Mask[29] */
+						rtl_set_bbreg(rtlpriv, 0xce8, BIT(31), 0x0);
+						break;
+					case 1:
+						rtl_set_bbreg(rtlpriv, 0xc80, BIT(28), 0x0);
+						rtl_set_bbreg(rtlpriv, 0xc84, BIT(28), 0x0);
+						rtl_set_bbreg(rtlpriv, 0xce8, BIT(31), 0x0);
+						break;
+					case 2:
+						RT_TRACE(rtlpriv, COMP_IQK, DBG_LOUD, "VDF_Y[1] = %x;;;VDF_Y[0] = %x\n", VDF_Y[1]>>21 & 0x00007ff, VDF_Y[0]>>21 & 0x00007ff);
+						RT_TRACE(rtlpriv, COMP_IQK, DBG_LOUD, "VDF_X[1] = %x;;;VDF_X[0] = %x\n", VDF_X[1]>>21 & 0x00007ff, VDF_X[0]>>21 & 0x00007ff);
+						Tx_dt[cal] = (VDF_Y[1]>>20)-(VDF_Y[0]>>20);
+						Tx_dt[cal] = ((16*Tx_dt[cal])*10000/15708);
+						Tx_dt[cal] = (Tx_dt[cal] >> 1)+(Tx_dt[cal] & BIT(0));
+						rtl_write_dword(rtlpriv, 0xc80, 0x18008c20);/* TX_Tone_idx[9:0], TxK_Mask[29] TX_Tone = 16 */
+						rtl_write_dword(rtlpriv, 0xc84, 0x38008c20);/* RX_Tone_idx[9:0], RxK_Mask[29] */
+						rtl_set_bbreg(rtlpriv, 0xce8, BIT(31), 0x1);
+						rtl_set_bbreg(rtlpriv, 0xce8, 0x3fff0000, Tx_dt[cal] & 0x00003fff);
+						break;
+					default:
+						break;
+					}
+					rtl_write_dword(rtlpriv, 0xcb8, 0x00100000);	/* cb8[20] N SI/PI v iqk_dpk module */
+					cal_retry = 0;
+					while (1) {
+						/* one shot */
+						rtl_write_dword(rtlpriv, 0x980, 0xfa000000);
+						rtl_write_dword(rtlpriv, 0x980, 0xf8000000);
+
+						mdelay(10); 	/* Delay 10ms */
+						rtl_write_dword(rtlpriv, 0xcb8, 0x00000000);
+						delay_count = 0;
+						while (1) {
+							IQK_ready = rtl_get_bbreg(rtlpriv, 0xd00, BIT(10));
+							if ((~IQK_ready) || (delay_count > 20)) {
+								break;
+							} else {
+								mdelay(1);
+								delay_count++;
+							}
+						}
+
+						if (delay_count < 20) {			/* If 20ms No Result, then cal_retry++ */
+						/* ============TXIQK Check============== */
+							TX_fail = rtl_get_bbreg(rtlpriv, 0xd00, BIT(12));
+
+							if (~TX_fail) {
+								rtl_write_dword(rtlpriv, 0xcb8, 0x02000000);
+								VDF_X[k] = rtl_get_bbreg(rtlpriv, 0xd00, 0x07ff0000)<<21;
+								rtl_write_dword(rtlpriv, 0xcb8, 0x04000000);
+								VDF_Y[k] = rtl_get_bbreg(rtlpriv, 0xd00, 0x07ff0000)<<21;
+								TX0IQKOK = true;
+								break;
+							} else {
+								rtl_set_bbreg(rtlpriv, 0xccc, 0x000007ff, 0x0);
+								rtl_set_bbreg(rtlpriv, 0xcd4, 0x000007ff, 0x200);
+								TX0IQKOK = false;
+								cal_retry++;
+								if (cal_retry == 10) {
+									break;
+								}
+							}
+						} else {
+							TX0IQKOK = false;
+							cal_retry++;
+							if (cal_retry == 10) {
+								break;
+							}
+						}
+					}
+				}
+
+				if (k == 3) {
+					TX_X0[cal] = VDF_X[k-1] ;
+					TX_Y0[cal] = VDF_Y[k-1];
+				}
+			} else {
+				rtl_write_dword(rtlpriv, 0xc80, 0x18008c10);	/* TX_Tone_idx[9:0], TxK_Mask[29] TX_Tone = 16 */
+				rtl_write_dword(rtlpriv, 0xc84, 0x38008c10);	/* RX_Tone_idx[9:0], RxK_Mask[29]  */
+				rtl_write_dword(rtlpriv, 0xcb8, 0x00100000);	/* cb8[20] N SI/PI v iqk_dpk module */
+				cal_retry = 0;
+				while (1) {
+					/* one shot */
+					rtl_write_dword(rtlpriv, 0x980, 0xfa000000);
+					rtl_write_dword(rtlpriv, 0x980, 0xf8000000);
+
+					mdelay(10); /*  Delay 10ms */
+					rtl_write_dword(rtlpriv, 0xcb8, 0x00000000);
+					delay_count = 0;
+					while (1) {
+						IQK_ready = rtl_get_bbreg(rtlpriv, 0xd00, BIT(10));
+						if ((~IQK_ready) || (delay_count > 20)) {
+							break;
+						} else {
+							mdelay(1);
+							delay_count++;
+						}
+					}
+
+					if (delay_count < 20) {		/* If 20ms No Result, then cal_retry++ */
+						/* ============TXIQK Check============== */
+						TX_fail = rtl_get_bbreg(rtlpriv, 0xd00, BIT(12));
+						if (~TX_fail) {
+							rtl_write_dword(rtlpriv, 0xcb8, 0x02000000);
+							TX_X0[cal] = rtl_get_bbreg(rtlpriv, 0xd00, 0x07ff0000)<<21;
+							rtl_write_dword(rtlpriv, 0xcb8, 0x04000000);
+							TX_Y0[cal] = rtl_get_bbreg(rtlpriv, 0xd00, 0x07ff0000)<<21;
+							TX0IQKOK = true;
+							break;
+						} else {
+							rtl_set_bbreg(rtlpriv, 0xccc, 0x000007ff, 0x0);
+							rtl_set_bbreg(rtlpriv, 0xcd4, 0x000007ff, 0x200);
+							TX0IQKOK = false;
+							cal_retry++;
+							if (cal_retry == 10) {
+								break;
+							}
+						}
+					} else {
+						TX0IQKOK = false;
+						cal_retry++;
+						if (cal_retry == 10)
+							break;
+					}
+				}
+			}
+
+			if (TX0IQKOK == false)
+				break;					/* TXK fail, Don't do RXK */
+
+			if (VDF_enable == 1) {
+				rtl_set_bbreg(rtlpriv, 0xce8, BIT(31), 0x0);    /* TX VDF Disable */
+				RT_TRACE(rtlpriv, COMP_IQK, DBG_LOUD, "RXVDF Start\n");
+				for (k = 0; k <= 2; k++) {
+					/* ====== RX mode TXK (RXK Step 1) ====== */
+					rtl_set_bbreg(rtlpriv, 0x82c, BIT(31), 0x0); /* [31] = 0 --> Page C */
+					/*  1. TX RF Setting */
+					rtl_set_rfreg(rtlpriv, Path, 0xef, bRFRegOffsetMask, 0x80000);
+					rtl_set_rfreg(rtlpriv, Path, 0x30, bRFRegOffsetMask, 0x30000);
+					rtl_set_rfreg(rtlpriv, Path, 0x31, bRFRegOffsetMask, 0x00029);
+					rtl_set_rfreg(rtlpriv, Path, 0x32, bRFRegOffsetMask, 0xd7ffb);
+					rtl_set_rfreg(rtlpriv, Path, 0x65, bRFRegOffsetMask, temp_reg65);
+					rtl_set_rfreg(rtlpriv, Path, 0x8f, bRFRegOffsetMask, 0x8a001);
+					rtl_set_rfreg(rtlpriv, Path, 0xef, bRFRegOffsetMask, 0x00000);
+
+					rtl_set_bbreg(rtlpriv, 0xcb8, 0xf, 0xd);
+					rtl_write_dword(rtlpriv, 0x978, 0x29002000);/* TX (X,Y) */
+					rtl_write_dword(rtlpriv, 0x97c, 0xa9002000);/* RX (X,Y) */
+					rtl_write_dword(rtlpriv, 0x984, 0x0046a910);/* [0]:AGC_en, [15]:idac_K_Mask */
+					rtl_write_dword(rtlpriv, 0x90c, 0x00008000);
+					rtl_write_dword(rtlpriv, 0xb00, 0x03000100);
+					rtl_set_bbreg(rtlpriv, 0x82c, BIT(31), 0x1); /* [31] = 1 --> Page C1 */
+					switch (k) {
+					case 0:
+						rtl_write_dword(rtlpriv, 0xc80, 0x18008c38);	/* TX_Tone_idx[9:0], TxK_Mask[29] TX_Tone = 16 */
+						rtl_write_dword(rtlpriv, 0xc84, 0x38008c38);	/* RX_Tone_idx[9:0], RxK_Mask[29] */
+						rtl_set_bbreg(rtlpriv, 0xce8, BIT(30), 0x0);
+						break;
+					case 1:
+						rtl_write_dword(rtlpriv, 0xc80, 0x08008c38);	/* TX_Tone_idx[9:0], TxK_Mask[29] TX_Tone = 16 */
+						rtl_write_dword(rtlpriv, 0xc84, 0x28008c38);	/* RX_Tone_idx[9:0], RxK_Mask[29] */
+						rtl_set_bbreg(rtlpriv, 0xce8, BIT(30), 0x0);
+						break;
+					case 2:
+						RT_TRACE(rtlpriv, COMP_IQK, DBG_LOUD, "VDF_Y[1] = %x;;;VDF_Y[0] = %x\n", VDF_Y[1]>>21 & 0x00007ff, VDF_Y[0]>>21 & 0x00007ff);
+						RT_TRACE(rtlpriv, COMP_IQK, DBG_LOUD, "VDF_X[1] = %x;;;VDF_X[0] = %x\n", VDF_X[1]>>21 & 0x00007ff, VDF_X[0]>>21 & 0x00007ff);
+						Rx_dt[cal] = (VDF_Y[1]>>20)-(VDF_Y[0]>>20);
+						RT_TRACE(rtlpriv, COMP_IQK, DBG_LOUD, "Rx_dt = %d\n", Rx_dt[cal]);
+						Rx_dt[cal] = ((16*Rx_dt[cal])*10000/13823);
+						Rx_dt[cal] = (Rx_dt[cal] >> 1)+(Rx_dt[cal] & BIT(0));
+						rtl_write_dword(rtlpriv, 0xc80, 0x18008c20);	/* TX_Tone_idx[9:0], TxK_Mask[29] TX_Tone = 16 */
+						rtl_write_dword(rtlpriv, 0xc84, 0x38008c20);	/* RX_Tone_idx[9:0], RxK_Mask[29] */
+						rtl_set_bbreg(rtlpriv, 0xce8, 0x00003fff, Rx_dt[cal] & 0x00003fff);
+						break;
+					default:
+						break;
+					}
+
+					rtl_write_dword(rtlpriv, 0xc88, 0x821603e0);
+					rtl_write_dword(rtlpriv, 0xc8c, 0x68163e96);
+					rtl_write_dword(rtlpriv, 0xcb8, 0x00100000);	/* cb8[20] N SI/PI v iqk_dpk module */
+					cal_retry = 0;
+					while (1) {
+						/* one shot */
+						rtl_write_dword(rtlpriv, 0x980, 0xfa000000);
+						rtl_write_dword(rtlpriv, 0x980, 0xf8000000);
+
+						mdelay(10); 	/* Delay 10ms */
+						rtl_write_dword(rtlpriv, 0xcb8, 0x00000000);
+						delay_count = 0;
+						while (1) {
+							IQK_ready = rtl_get_bbreg(rtlpriv, 0xd00, BIT(10));
+							if ((~IQK_ready) || (delay_count > 20)) {
+								break;
+							} else {
+								mdelay(1);
+								delay_count++;
+							}
+						}
+
+						if (delay_count < 20) {		/* If 20ms No Result, then cal_retry++ */
+							/* ============TXIQK Check============== */
+							TX_fail = rtl_get_bbreg(rtlpriv, 0xd00, BIT(12));
+
+							if (~TX_fail) {
+								rtl_write_dword(rtlpriv, 0xcb8, 0x02000000);
+								TX_X0_RXK[cal] = rtl_get_bbreg(rtlpriv, 0xd00, 0x07ff0000)<<21;
+								rtl_write_dword(rtlpriv, 0xcb8, 0x04000000);
+								TX_Y0_RXK[cal] = rtl_get_bbreg(rtlpriv, 0xd00, 0x07ff0000)<<21;
+								TX0IQKOK = true;
+								break;
+							} else {
+								TX0IQKOK = false;
+								cal_retry++;
+								if (cal_retry == 10)
+									break;
+							}
+						} else {
+							TX0IQKOK = false;
+							cal_retry++;
+							if (cal_retry == 10)
+								break;
+						}
+					}
+
+					if (TX0IQKOK == false) {   /* If RX mode TXK fail, then take TXK Result */
+						TX_X0_RXK[cal] = TX_X0[cal];
+						TX_Y0_RXK[cal] = TX_Y0[cal];
+						TX0IQKOK = true;
+						RT_TRACE(rtlpriv, COMP_IQK, DBG_LOUD, "RXK Step 1 fail\n");
+					}
+
+					/* ====== RX IQK ====== */
+					rtl_set_bbreg(rtlpriv, 0x82c, BIT(31), 0x0); /* [31] = 0 --> Page C */
+					/* 1. RX RF Setting */
+					rtl_set_rfreg(rtlpriv, Path, 0xef, bRFRegOffsetMask, 0x80000);
+					rtl_set_rfreg(rtlpriv, Path, 0x30, bRFRegOffsetMask, 0x30000);
+					rtl_set_rfreg(rtlpriv, Path, 0x31, bRFRegOffsetMask, 0x0002f);
+					rtl_set_rfreg(rtlpriv, Path, 0x32, bRFRegOffsetMask, 0xfffbb);
+					rtl_set_rfreg(rtlpriv, Path, 0x8f, bRFRegOffsetMask, 0x88001);
+					rtl_set_rfreg(rtlpriv, Path, 0x65, bRFRegOffsetMask, 0x931d8);
+					rtl_set_rfreg(rtlpriv, Path, 0xef, bRFRegOffsetMask, 0x00000);
+
+					rtl_set_bbreg(rtlpriv, 0x978, 0x03FF8000, (TX_X0_RXK[cal])>>21&0x000007ff);
+					rtl_set_bbreg(rtlpriv, 0x978, 0x000007FF, (TX_Y0_RXK[cal])>>21&0x000007ff);
+					rtl_set_bbreg(rtlpriv, 0x978, BIT(31), 0x1);
+					rtl_set_bbreg(rtlpriv, 0x97c, BIT(31), 0x0);
+					rtl_set_bbreg(rtlpriv, 0xcb8, 0xF, 0xe);
+					rtl_write_dword(rtlpriv, 0x90c, 0x00008000);
+					rtl_write_dword(rtlpriv, 0x984, 0x0046a911);
+
+					rtl_set_bbreg(rtlpriv, 0x82c, BIT(31), 0x1); /* [31] = 1 --> Page C1 */
+					rtl_set_bbreg(rtlpriv, 0xc80, BIT(29), 0x1);
+					rtl_set_bbreg(rtlpriv, 0xc84, BIT(29), 0x0);
+					rtl_write_dword(rtlpriv, 0xc88, 0x02140119);
+					rtl_write_dword(rtlpriv, 0xc8c, 0x28161420);
+
+					if (k == 2) {
+						rtl_set_bbreg(rtlpriv, 0xce8, BIT(30), 0x1);  /* RX VDF Enable */
+					}
+					rtl_write_dword(rtlpriv, 0xcb8, 0x00100000);	/* cb8[20] N SI/PI v iqk_dpk module */
+
+					cal_retry = 0;
+					while (1) {
+						/* one shot */
+						rtl_write_dword(rtlpriv, 0x980, 0xfa000000);
+						rtl_write_dword(rtlpriv, 0x980, 0xf8000000);
+
+						mdelay(10); /* Delay 10ms */
+						rtl_write_dword(rtlpriv, 0xcb8, 0x00000000);
+						delay_count = 0;
+						while (1) {
+							IQK_ready = rtl_get_bbreg(rtlpriv, 0xd00, BIT(10));
+							if ((~IQK_ready) || (delay_count > 20)) {
+								break;
+							} else {
+								mdelay(1);
+								delay_count++;
+							}
+						}
+
+						if (delay_count < 20) {	/* If 20ms No Result, then cal_retry++ */
+							/* ============RXIQK Check============== */
+							RX_fail = rtl_get_bbreg(rtlpriv, 0xd00, BIT(11));
+							if (RX_fail == 0) {
+								rtl_write_dword(rtlpriv, 0xcb8, 0x06000000);
+								VDF_X[k] = rtl_get_bbreg(rtlpriv, 0xd00, 0x07ff0000)<<21;
+								rtl_write_dword(rtlpriv, 0xcb8, 0x08000000);
+								VDF_Y[k] = rtl_get_bbreg(rtlpriv, 0xd00, 0x07ff0000)<<21;
+								RX0IQKOK = true;
+								break;
+							} else {
+								rtl_set_bbreg(rtlpriv, 0xc10, 0x000003ff, 0x200>>1);
+								rtl_set_bbreg(rtlpriv, 0xc10, 0x03ff0000, 0x0>>1);
+								RX0IQKOK = false;
+								cal_retry++;
+								if (cal_retry == 10)
+									break;
+							}
+						} else {
+							RX0IQKOK = false;
+							cal_retry++;
+							if (cal_retry == 10)
+								break;
+						}
+					}
+				}
+
+				if (k == 3) {
+					RX_X0[cal] = VDF_X[k-1] ;
+					RX_Y0[cal] = VDF_Y[k-1];
+				}
+
+				rtl_set_bbreg(rtlpriv, 0xce8, BIT(31), 0x1);    /* TX VDF Enable */
+			} else {
+				/* ====== RX mode TXK (RXK Step 1) ====== */
+				rtl_set_bbreg(rtlpriv, 0x82c, BIT(31), 0x0); /* [31] = 0 --> Page C */
+				/* 1. TX RF Setting */
+				rtl_set_rfreg(rtlpriv, Path, 0xef, bRFRegOffsetMask, 0x80000);
+				rtl_set_rfreg(rtlpriv, Path, 0x30, bRFRegOffsetMask, 0x30000);
+				rtl_set_rfreg(rtlpriv, Path, 0x31, bRFRegOffsetMask, 0x00029);
+				rtl_set_rfreg(rtlpriv, Path, 0x32, bRFRegOffsetMask, 0xd7ffb);
+				rtl_set_rfreg(rtlpriv, Path, 0x65, bRFRegOffsetMask, temp_reg65);
+				rtl_set_rfreg(rtlpriv, Path, 0x8f, bRFRegOffsetMask, 0x8a001);
+				rtl_set_rfreg(rtlpriv, Path, 0xef, bRFRegOffsetMask, 0x00000);
+				rtl_write_dword(rtlpriv, 0x90c, 0x00008000);
+				rtl_write_dword(rtlpriv, 0xb00, 0x03000100);
+				rtl_write_dword(rtlpriv, 0x984, 0x0046a910);/* [0]:AGC_en, [15]:idac_K_Mask */
+
+				rtl_set_bbreg(rtlpriv, 0x82c, BIT(31), 0x1);	/* [31] = 1 --> Page C1 */
+				rtl_write_dword(rtlpriv, 0xc80, 0x18008c10);	/* TX_Tone_idx[9:0], TxK_Mask[29] TX_Tone = 16 */
+				rtl_write_dword(rtlpriv, 0xc84, 0x38008c10);	/* RX_Tone_idx[9:0], RxK_Mask[29] */
+				rtl_write_dword(rtlpriv, 0xc88, 0x821603e0);
+				/* rtl_write_dword(rtlpriv, 0xc8c, 0x68163e96); */
+				rtl_write_dword(rtlpriv, 0xcb8, 0x00100000);/* cb8[20] N SI/PI v iqk_dpk module */
+				cal_retry = 0;
+				while (1) {
+					/* one shot */
+					rtl_write_dword(rtlpriv, 0x980, 0xfa000000);
+					rtl_write_dword(rtlpriv, 0x980, 0xf8000000);
+
+					mdelay(10); 	/* Delay 10ms */
+					rtl_write_dword(rtlpriv, 0xcb8, 0x00000000);
+					delay_count = 0;
+					while (1) {
+						IQK_ready = rtl_get_bbreg(rtlpriv, 0xd00, BIT(10));
+						if ((~IQK_ready) || (delay_count > 20)) {
+							break;
+						} else {
+							mdelay(1);
+							delay_count++;
+						}
+					}
+
+					if (delay_count < 20) {							/* If 20ms No Result, then cal_retry++ */
+						/* ============TXIQK Check============== */
+						TX_fail = rtl_get_bbreg(rtlpriv, 0xd00, BIT(12));
+
+						if (~TX_fail) {
+							rtl_write_dword(rtlpriv, 0xcb8, 0x02000000);
+							TX_X0_RXK[cal] = rtl_get_bbreg(rtlpriv, 0xd00, 0x07ff0000)<<21;
+							rtl_write_dword(rtlpriv, 0xcb8, 0x04000000);
+							TX_Y0_RXK[cal] = rtl_get_bbreg(rtlpriv, 0xd00, 0x07ff0000)<<21;
+							TX0IQKOK = true;
+							break;
+						} else {
+							TX0IQKOK = false;
+							cal_retry++;
+							if (cal_retry == 10)
+								break;
+						}
+					} else {
+						TX0IQKOK = false;
+						cal_retry++;
+						if (cal_retry == 10)
+							break;
+					}
+				}
+
+				if (TX0IQKOK == false) {	/* If RX mode TXK fail, then take TXK Result */
+					TX_X0_RXK[cal] = TX_X0[cal];
+					TX_Y0_RXK[cal] = TX_Y0[cal];
+					TX0IQKOK = true;
+					RT_TRACE(rtlpriv, COMP_IQK, DBG_LOUD, "1");
+				}
+
+				/* ====== RX IQK ====== */
+				rtl_set_bbreg(rtlpriv, 0x82c, BIT(31), 0x0); /* [31] = 0 --> Page C */
+				/* 1. RX RF Setting */
+				rtl_set_rfreg(rtlpriv, Path, 0xef, bRFRegOffsetMask, 0x80000);
+				rtl_set_rfreg(rtlpriv, Path, 0x30, bRFRegOffsetMask, 0x30000);
+				rtl_set_rfreg(rtlpriv, Path, 0x31, bRFRegOffsetMask, 0x0002f);
+				rtl_set_rfreg(rtlpriv, Path, 0x32, bRFRegOffsetMask, 0xfffbb);
+				rtl_set_rfreg(rtlpriv, Path, 0x8f, bRFRegOffsetMask, 0x88001);
+				rtl_set_rfreg(rtlpriv, Path, 0x65, bRFRegOffsetMask, 0x931d8);
+				rtl_set_rfreg(rtlpriv, Path, 0xef, bRFRegOffsetMask, 0x00000);
+
+				rtl_set_bbreg(rtlpriv, 0x978, 0x03FF8000, (TX_X0_RXK[cal])>>21&0x000007ff);
+				rtl_set_bbreg(rtlpriv, 0x978, 0x000007FF, (TX_Y0_RXK[cal])>>21&0x000007ff);
+				rtl_set_bbreg(rtlpriv, 0x978, BIT(31), 0x1);
+				rtl_set_bbreg(rtlpriv, 0x97c, BIT(31), 0x0);
+				rtl_set_bbreg(rtlpriv, 0xcb8, 0xF, 0xe);
+				rtl_write_dword(rtlpriv, 0x90c, 0x00008000);
+				rtl_write_dword(rtlpriv, 0x984, 0x0046a911);
+
+				rtl_set_bbreg(rtlpriv, 0x82c, BIT(31), 0x1); 	/* [31] = 1 --> Page C1 */
+				rtl_write_dword(rtlpriv, 0xc80, 0x38008c10);	/* TX_Tone_idx[9:0], TxK_Mask[29] TX_Tone = 16 */
+				rtl_write_dword(rtlpriv, 0xc84, 0x18008c10);	/* RX_Tone_idx[9:0], RxK_Mask[29] */
+				rtl_write_dword(rtlpriv, 0xc88, 0x02140119);
+				rtl_write_dword(rtlpriv, 0xc8c, 0x28161440);
+				rtl_write_dword(rtlpriv, 0xcb8, 0x00100000);	/* cb8[20] N SI/PI v iqk_dpk module */
+
+				cal_retry = 0;
+				while (1) {
+					/* one shot */
+					rtl_write_dword(rtlpriv, 0x980, 0xfa000000);
+					rtl_write_dword(rtlpriv, 0x980, 0xf8000000);
+
+					mdelay(10); /* Delay 10ms */
+					rtl_write_dword(rtlpriv, 0xcb8, 0x00000000);
+					delay_count = 0;
+					while (1) {
+						IQK_ready = rtl_get_bbreg(rtlpriv, 0xd00, BIT(10));
+						if ((~IQK_ready) || (delay_count > 20)) {
+							break;
+						} else {
+							mdelay(1);
+							delay_count++;
+						}
+					}
+
+					if (delay_count < 20) {	/* If 20ms No Result, then cal_retry++ */
+						/* ============RXIQK Check============== */
+						RX_fail = rtl_get_bbreg(rtlpriv, 0xd00, BIT(11));
+						if (RX_fail == 0) {
+							rtl_write_dword(rtlpriv, 0xcb8, 0x06000000);
+							RX_X0[cal] = rtl_get_bbreg(rtlpriv, 0xd00, 0x07ff0000)<<21;
+							rtl_write_dword(rtlpriv, 0xcb8, 0x08000000);
+							RX_Y0[cal] = rtl_get_bbreg(rtlpriv, 0xd00, 0x07ff0000)<<21;
+							RX0IQKOK = true;
+							break;
+						} else {
+							rtl_set_bbreg(rtlpriv, 0xc10, 0x000003ff, 0x200>>1);
+							rtl_set_bbreg(rtlpriv, 0xc10, 0x03ff0000, 0x0>>1);
+							RX0IQKOK = false;
+							cal_retry++;
+							if (cal_retry == 10)
+								break;
+
+						}
+					} else {
+						RX0IQKOK = false;
+						cal_retry++;
+						if (cal_retry == 10)
+							break;
+					}
+				}
+			}
+			if (TX0IQKOK)
+				TX_Average++;
+			if (RX0IQKOK)
+				RX_Average++;
+			rtl_set_bbreg(rtlpriv, 0x82c, BIT(31), 0x0); 	/* [31] = 0 --> Page C */
+			rtl_set_rfreg(rtlpriv, Path, 0x65, bRFRegOffsetMask, temp_reg65);
+		    }
+			break;
+		default:
+			break;
+		}
+		cal++;
+	}
+	/* FillIQK Result */
+	switch (Path) {
+	case RF90_PATH_A:
+	    {
+		RT_TRACE(rtlpriv, COMP_IQK, DBG_LOUD, "========Path_A =======\n");
+		if (TX_Average == 0)
+			break;
+
+		for (i = 0; i < TX_Average; i++) {
+			RT_TRACE(rtlpriv, COMP_IQK, DBG_LOUD, " TX_X0_RXK[%d] = %x ;; TX_Y0_RXK[%d] = %x\n", i, (TX_X0_RXK[i])>>21&0x000007ff, i, (TX_Y0_RXK[i])>>21&0x000007ff);
+			RT_TRACE(rtlpriv, COMP_IQK, DBG_LOUD, "TX_X0[%d] = %x ;; TX_Y0[%d] = %x\n", i, (TX_X0[i])>>21&0x000007ff, i, (TX_Y0[i])>>21&0x000007ff);
+		}
+
+		for (i = 0; i < TX_Average; i++) {
+			for (ii = i+1; ii < TX_Average; ii++) {
+				dx = (TX_X0[i]>>21) - (TX_X0[ii]>>21);
+				if (dx < 3 && dx > -3) {
+					dy = (TX_Y0[i]>>21) - (TX_Y0[ii]>>21);
+					if (dy < 3 && dy > -3) {
+						TX_X = ((TX_X0[i]>>21) + (TX_X0[ii]>>21))/2;
+						TX_Y = ((TX_Y0[i]>>21) + (TX_Y0[ii]>>21))/2;
+						TX_finish = 1;
+						break;
+					}
+				}
+			}
+			if (TX_finish == 1)
+				break;
+		}
+
+		if (TX_finish == 1) {
+			_rtl8821au_iqk_tx_fill_iqc(rtlpriv, Path, TX_X, TX_Y);
+		} else {
+			_rtl8821au_iqk_tx_fill_iqc(rtlpriv, Path, 0x200, 0x0);
+		}
+
+		if (RX_Average == 0)
+			break;
+
+		for (i = 0; i < RX_Average; i++) {
+			RT_TRACE(rtlpriv, COMP_IQK, DBG_LOUD, "RX_X0[%d] = %x ;; RX_Y0[%d] = %x\n", i, (RX_X0[i])>>21&0x000007ff, i, (RX_Y0[i])>>21&0x000007ff);
+		}
+
+		for (i = 0; i < RX_Average; i++) {
+			for (ii = i+1; ii < RX_Average; ii++) {
+				dx = (RX_X0[i]>>21) - (RX_X0[ii]>>21);
+				if (dx < 3 && dx > -3) {
+					dy = (RX_Y0[i]>>21) - (RX_Y0[ii]>>21);
+					if (dy < 3 && dy > -3) {
+						RX_X = ((RX_X0[i]>>21) + (RX_X0[ii]>>21))/2;
+						RX_Y = ((RX_Y0[i]>>21) + (RX_Y0[ii]>>21))/2;
+						RX_finish = 1;
+						break;
+					}
+				}
+			}
+			if (RX_finish == 1)
+				break;
+		}
+
+		if (RX_finish == 1) {
+			 _rtl8821au_iqk_rx_fill_iqc(rtlpriv, Path, RX_X, RX_Y);
+		} else {
+			 _rtl8821au_iqk_rx_fill_iqc(rtlpriv, Path, 0x200, 0x0);
+		}
+	    }
+		break;
+	default:
+		break;
+	}
+}
+
+#undef MACBB_REG_NUM
+#undef AFE_REG_NUM
+#undef RF_REG_NUM
+#define MACBB_REG_NUM 11
+#define AFE_REG_NUM 12
+#define RF_REG_NUM 3
+
+
+static void _rtl8821au_phy_iq_calibrate(struct rtl_priv *rtlpriv)
+{
+	u32 macbb_backup[MACBB_REG_NUM];
+	u32 afe_backup[AFE_REG_NUM];
+	u32 rfa_backup[RF_REG_NUM];
+	u32 rfb_backup[RF_REG_NUM];
+	u32 backup_macbb_reg[MACBB_REG_NUM] = {
+		0xb00, 0x520, 0x550, 0x808, 0x90c, 0xc00, 0xc50,
+		0xe00, 0xe50, 0x838, 0x82c
+	};
+	u32 backup_afe_reg[AFE_REG_NUM] = {
+		0xc5c, 0xc60, 0xc64, 0xc68, 0xc6c, 0xc70, 0xc74,
+		0xc78, 0xc7c, 0xc80, 0xc84, 0xcb8
+	};
+	u32 backup_rf_reg[RF_REG_NUM] = { 0x65, 0x8f, 0x0 };
+
+	_rtl8821au_iqk_backup_macbb(rtlpriv, macbb_backup, backup_macbb_reg,
+				    MACBB_REG_NUM);
+	_rtl8821au_iqk_backup_afe(rtlpriv, afe_backup, backup_afe_reg, AFE_REG_NUM);
+	_rtl8821au_iqk_backup_rf(rtlpriv, rfa_backup, rfb_backup, backup_rf_reg,
+				 RF_REG_NUM);
+
+	_rtl8821au_iqk_configure_mac(rtlpriv);
+	_rtl8821au_iqk_tx(rtlpriv, RF90_PATH_A);
+	_rtl8821au_iqk_restore_rf(rtlpriv, RF90_PATH_A, backup_rf_reg, rfa_backup,
+				 RF_REG_NUM);
+
+	_rtl8821au_iqk_restore_afe(rtlpriv, afe_backup, backup_afe_reg, AFE_REG_NUM);
+	_rtl8821au_iqk_restore_macbb(rtlpriv, macbb_backup, backup_macbb_reg,
+				     MACBB_REG_NUM);
+
+	/* _IQK_Exit_8821A(pDM_Odm); */
+	/* _IQK_TX_CheckResult_8821A */
+}
+
+void rtl8821au_phy_iq_calibrate(struct rtl_priv *rtlpriv, bool bReCovery)
+{
+	_rtl8821au_phy_iq_calibrate(rtlpriv);
+}
+
+
+/* ********************************************************** */
+
+/* OLD functions need complete ? rewrite */
+bool Getu8IntegerFromStringInDecimal(s8 *Str, uint8_t *pInt)
+{
+	u16 i = 0;
+	*pInt = 0;
+
+	while (Str[i] != '\0') {
+		if (Str[i] >= '0' && Str[i] <= '9') {
+			*pInt *= 10;
+			*pInt += (Str[i] - '0');
+		} else {
+			return false;
+		}
+		++i;
+	}
+
+	return true;
+}
+
+
+static bool eqNByte(uint8_t *str1, uint8_t *str2, uint32_t num)
+{
+	if (num == 0)
+		return false;
+
+	while (num > 0) {
+		num--;
+		if (str1[num] != str2[num])
+			return false;
+	}
+
+	return true;
+}
+
+
+static s8 phy_GetChannelGroup(struct rtl_priv *rtlpriv, enum band_type Band, uint8_t Channel)
+{
+	s8 channelGroup = -1;
+
+	if (Channel <= 14 && Band == BAND_ON_2_4G) {
+		if (1 <= Channel && Channel <= 2)
+			channelGroup = 0;
+		else if (3  <= Channel && Channel <= 5)
+			channelGroup = 1;
+		else if (6  <= Channel && Channel <= 8)
+			channelGroup = 2;
+		else if (9  <= Channel && Channel <= 11)
+			channelGroup = 3;
+		else if (12 <= Channel && Channel <= 14)
+			channelGroup = 4;
+		else {
+			RT_TRACE(rtlpriv, COMP_EFUSE, DBG_LOUD, "==> phy_GetChannelGroup() in 2.4 G, but Channel %d in Group not found \n", Channel);
+			channelGroup = -1;
+		}
+	} else if (Band == BAND_ON_5G) {
+		if (36 <= Channel && Channel <=  42)
+			channelGroup = 0;
+		else if (44 <= Channel && Channel <= 48)
+			channelGroup = 1;
+		else if (50 <= Channel && Channel <= 58)
+			channelGroup = 2;
+		else if (60 <= Channel && Channel <= 64)
+			channelGroup = 3;
+		else if (100 <= Channel && Channel <= 106)
+			channelGroup = 4;
+		else if (108 <= Channel && Channel <= 114)
+			channelGroup = 5;
+		else if (116 <= Channel && Channel <= 122)
+			channelGroup = 6;
+		else if (124 <= Channel && Channel <= 130)
+			channelGroup = 7;
+		else if (132 <= Channel && Channel <= 138)
+			channelGroup = 8;
+		else if (140 <= Channel && Channel <= 144)
+			channelGroup = 9;
+		else if (149 <= Channel && Channel <= 155)
+			channelGroup = 10;
+		else if (157 <= Channel && Channel <= 161)
+			channelGroup = 11;
+		else if (165 <= Channel && Channel <= 171)
+			channelGroup = 12;
+		else if (173 <= Channel && Channel <= 177)
+			channelGroup = 13;
+		else {
+			RT_TRACE(rtlpriv, COMP_EFUSE, DBG_LOUD, "==>phy_GetChannelGroup() in 5G, but Channel %d in Group not found \n", Channel);
+			channelGroup = -1;
+		}
+	} else {
+		RT_TRACE(rtlpriv, COMP_EFUSE, DBG_LOUD, "==>phy_GetChannelGroup() in unsupported band %d\n", Band);
+		channelGroup = -1;
+	}
+
+	return channelGroup;
+}
+
+s8 phy_GetWorldWideLimit(s8* LimitTable)
+{
+	s8	min = LimitTable[0];
+	u8	i = 0;
+	
+	for (i = 0; i < MAX_REGULATION_NUM; ++i) {
+		if (LimitTable[i] < min)
+			min = LimitTable[i];
+	}
+
+	return min;
+}
+
+static char _rtl8821au_get_chnl_idx_of_txpwr_limit(struct rtl_priv *rtlpriv,
+				     u8 Band, u8 Channel)
+{
+	s8 channelIndex = -1;
+	u8 channel5G[CHANNEL_MAX_NUMBER_5G] =
+				 {36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,100,102,104,106,108,110,112,
+				114,116,118,120,122,124,126,128,130,132,134,136,138,140,142,144,149,151,
+				153,155,157,159,161,163,165,167,168,169,171,173,175,177};
+	u8 i = 0;
+	if (Band == BAND_ON_2_4G) {
+		channelIndex = Channel - 1;
+	} else if ( Band == BAND_ON_5G ) {
+		for ( i = 0; i < sizeof(channel5G)/sizeof(u8); ++i ) {
+			if ( channel5G[i] == Channel )
+				channelIndex = i;
+		}
+	} else {
+		RT_TRACE(rtlpriv, COMP_POWER, DBG_LOUD, "Invalid Band %d in %s",
+			 Band, __func__);
+	}
+
+	if (channelIndex == -1)
+		RT_TRACE(rtlpriv, COMP_POWER, DBG_LOUD, "Invalid Channel %d of Band %d in %s",
+			 Channel, Band, __func__);
+
+	return channelIndex;
+}
+
+static char _rtl8821au_phy_get_txpower_limit(struct rtl_priv *rtlpriv,
+		       enum band_type band,
+		       enum CHANNEL_WIDTH bandwidth,
+		       enum radio_path rf_path,
+		       u8 rate, u8 channel)
+{
+	struct rtl_phy *rtlphy = rtl_phy(rtlpriv);
+	struct rtl_efuse *rtlefuse = rtl_efuse(rtlpriv);
+
+	short band_temp = -1, regulation = -1, bandwidth_temp = -1,
+		rate_section = -1, channel_temp = 0-1;
+	char powerLimit = MAX_POWER_INDEX;
+
+	/* ULLI : I'm lazy taken form rtl8821ae driver */
+	
+	if (rtlefuse->eeprom_regulatory == 2)
+		return MAX_POWER_INDEX;
+
+	regulation = TXPWR_LMT_WW;
+
+	//DBG_871X("pMgntInfo->RegPwrTblSel %d, final regulation %d\n", Adapter->registrypriv.RegPwrTblSel, regulation );
+
+
+	if (band == BAND_ON_2_4G)
+		band_temp = 0;
+	else if (band == BAND_ON_5G)
+		band_temp = 1;
+
+	if (bandwidth == CHANNEL_WIDTH_20)
+		bandwidth_temp = 0;
+	else if (bandwidth == CHANNEL_WIDTH_40)
+		bandwidth_temp = 1;
+	else if (bandwidth == CHANNEL_WIDTH_80)
+		bandwidth_temp = 2;
+	else if (bandwidth == CHANNEL_WIDTH_160)
+		bandwidth_temp = 3;
+
+	switch (rate) {
+	case MGN_1M:
+	case MGN_2M:
+	case MGN_5_5M:
+	case MGN_11M:
+		rate_section = 0;
+		break;
+
+	case MGN_6M:
+	case MGN_9M:
+	case MGN_12M:
+	case MGN_18M:
+	case MGN_24M:
+	case MGN_36M:
+	case MGN_48M:
+	case MGN_54M:
+		rate_section = 1;
+		break;
+
+	case MGN_MCS0:
+	case MGN_MCS1:
+	case MGN_MCS2:
+	case MGN_MCS3:
+	case MGN_MCS4:
+	case MGN_MCS5:
+	case MGN_MCS6:
+	case MGN_MCS7:
+		rate_section = 2;
+		break;
+
+	case MGN_MCS8:
+	case MGN_MCS9:
+	case MGN_MCS10:
+	case MGN_MCS11:
+	case MGN_MCS12:
+	case MGN_MCS13:
+	case MGN_MCS14:
+	case MGN_MCS15:
+		rate_section = 3;
+		break;
+
+	case MGN_MCS16:
+	case MGN_MCS17:
+	case MGN_MCS18:
+	case MGN_MCS19:
+	case MGN_MCS20:
+	case MGN_MCS21:
+	case MGN_MCS22:
+	case MGN_MCS23:
+		rate_section = 4;
+		break;
+
+	case MGN_MCS24:
+	case MGN_MCS25:
+	case MGN_MCS26:
+	case MGN_MCS27:
+	case MGN_MCS28:
+	case MGN_MCS29:
+	case MGN_MCS30:
+	case MGN_MCS31:
+		rate_section = 5;
+		break;
+
+	case MGN_VHT1SS_MCS0:
+	case MGN_VHT1SS_MCS1:
+	case MGN_VHT1SS_MCS2:
+	case MGN_VHT1SS_MCS3:
+	case MGN_VHT1SS_MCS4:
+	case MGN_VHT1SS_MCS5:
+	case MGN_VHT1SS_MCS6:
+	case MGN_VHT1SS_MCS7:
+	case MGN_VHT1SS_MCS8:
+	case MGN_VHT1SS_MCS9:
+		rate_section = 6;
+		break;
+
+	case MGN_VHT2SS_MCS0:
+	case MGN_VHT2SS_MCS1:
+	case MGN_VHT2SS_MCS2:
+	case MGN_VHT2SS_MCS3:
+	case MGN_VHT2SS_MCS4:
+	case MGN_VHT2SS_MCS5:
+	case MGN_VHT2SS_MCS6:
+	case MGN_VHT2SS_MCS7:
+	case MGN_VHT2SS_MCS8:
+	case MGN_VHT2SS_MCS9:
+		rate_section = 7;
+		break;
+
+	case MGN_VHT3SS_MCS0:
+	case MGN_VHT3SS_MCS1:
+	case MGN_VHT3SS_MCS2:
+	case MGN_VHT3SS_MCS3:
+	case MGN_VHT3SS_MCS4:
+	case MGN_VHT3SS_MCS5:
+	case MGN_VHT3SS_MCS6:
+	case MGN_VHT3SS_MCS7:
+	case MGN_VHT3SS_MCS8:
+	case MGN_VHT3SS_MCS9:
+		rate_section = 8;
+		break;
+
+	case MGN_VHT4SS_MCS0:
+	case MGN_VHT4SS_MCS1:
+	case MGN_VHT4SS_MCS2:
+	case MGN_VHT4SS_MCS3:
+	case MGN_VHT4SS_MCS4:
+	case MGN_VHT4SS_MCS5:
+	case MGN_VHT4SS_MCS6:
+	case MGN_VHT4SS_MCS7:
+	case MGN_VHT4SS_MCS8:
+	case MGN_VHT4SS_MCS9:
+		rate_section = 9;
+		break;
+
+	default:
+		RT_TRACE(rtlpriv, COMP_POWER, DBG_LOUD, 
+			 "Wrong rate 0x%x\n", rate );
+		break;
+	}
+
+	if (band == BAND_ON_5G  && rate_section == 0)
+		RT_TRACE(rtlpriv, COMP_POWER, DBG_LOUD, 
+			 "Wrong rate 0x%x: No CCK in 5G Band\n", rate);
+
+	// workaround for wrong index combination to obtain tx power limit, 
+	// OFDM only exists in BW 20M
+	if (rate_section == 1 )
+		bandwidth_temp = 0;
+
+	// workaround for wrong index combination to obtain tx power limit, 
+	// CCK table will only be given in BW 20M
+	if (rate_section == 0)
+		bandwidth_temp = 0;
+
+	// workaround for wrong indxe combination to obtain tx power limit, 
+	// HT on 80M will reference to HT on 40M
+	if ((rate_section == 2 || rate_section == 3) && band == BAND_ON_5G && bandwidth_temp == 2 ) {
+		bandwidth_temp = 1;
+	}
+	
+	if (band == BAND_ON_2_4G)
+		channel_temp = 
+			_rtl8821au_get_chnl_idx_of_txpwr_limit(rtlpriv,
+							       BAND_ON_2_4G,
+							       channel);
+	else if (band == BAND_ON_5G)
+		channel_temp = 
+			_rtl8821au_get_chnl_idx_of_txpwr_limit(rtlpriv,
+							       BAND_ON_5G,
+							       channel);
+	else if (band == BAND_ON_BOTH) {
+		// BAND_ON_BOTH don't care temporarily 
+	}
+	
+	if (band_temp == -1 || regulation == -1 || bandwidth_temp == -1 || 
+	     rate_section == -1 || channel_temp == -1 ) {
+		//DBG_871X("Wrong index value to access power limit table [band %d][regulation %d][bandwidth %d][rf_path %d][rate_section %d][chnlGroup %d]\n",
+		//	  band, regulation, bandwidth, RfPath, rateSection, channelGroup );
+
+		return MAX_POWER_INDEX;
+	}
+
+	if (band == BAND_ON_2_4G) {
+		s8 limits[10] = {0}; u8 i = 0;
+		for (i = 0; i < MAX_REGULATION_NUM; ++i)
+			limits[i] = rtlphy->txpwr_limit_2_4g[i][bandwidth_temp]
+					[rate_section][channel_temp][rf_path];
+
+		powerLimit = (regulation == TXPWR_LMT_WW) ?
+			phy_GetWorldWideLimit(limits) :
+			rtlphy->txpwr_limit_2_4g[regulation][bandwidth_temp]
+					[rate_section][channel_temp][rf_path];
+
+	} else if (band == BAND_ON_5G) {
+		s8 limits[10] = {0}; u8 i = 0;
+		for (i = 0; i < MAX_REGULATION_NUM; ++i)
+			limits[i] = rtlphy->txpwr_limit_5g[i][bandwidth_temp]
+					[rate_section][channel_temp][rf_path];
+		
+		powerLimit = (regulation == TXPWR_LMT_WW) ? 
+			phy_GetWorldWideLimit(limits) :
+			rtlphy->txpwr_limit_5g[regulation][bandwidth_temp]
+					[rate_section][channel_temp][rf_path];
+	} else
+		RT_TRACE(rtlpriv, COMP_POWER, DBG_LOUD, 
+			 "No power limit table of the specified band\n");
+
+	// combine 5G VHT & HT rate
+	// 5G 20M and 40M HT and VHT can cross reference
+	/*
+	if ( Band == BAND_ON_5G && powerLimit == MAX_POWER_INDEX ) {
+		if ( bandwidth == 0 || bandwidth == 1 ) { 
+			RT_TRACE( COMP_INIT, DBG_LOUD, ( "No power limit table of the specified band %d, bandwidth %d, ratesection %d, rf path %d\n", 
+					  band, bandwidth, rateSection, RfPath ) );
+			if ( rateSection == 2 )
+				powerLimit = pHalData->TxPwrLimit_5G[regulation]
+										[bandwidth][4][channelGroup][RfPath];
+			else if ( rateSection == 4 )
+				powerLimit = pHalData->TxPwrLimit_5G[regulation]
+										[bandwidth][2][channelGroup][RfPath];
+			else if ( rateSection == 3 )
+				powerLimit = pHalData->TxPwrLimit_5G[regulation]
+										[bandwidth][5][channelGroup][RfPath];
+			else if ( rateSection == 5 )
+				powerLimit = pHalData->TxPwrLimit_5G[regulation]
+										[bandwidth][3][channelGroup][RfPath];
+		}
+	}
+	*/
+	//DBG_871X("TxPwrLmt[Regulation %d][Band %d][BW %d][RFPath %d][Rate 0x%x][Chnl %d] = %d\n", 
+	//		regulation, pHalData->CurrentBandType, Bandwidth, RfPath, DataRate, Channel, powerLimit);
+	return powerLimit;
+}
+
+static bool _rtl8821au_phy_get_chnl_index(uint8_t Channel, uint8_t *ChannelIdx)
+{
+	uint8_t channel5G[CHANNEL_MAX_NUMBER_5G] = {
+		36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64,
+		100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120,
+		122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142,
+		144, 149, 151, 153, 155, 157, 159, 161, 163, 165, 167,
+		168, 169, 171, 173, 175, 177
+		};
+	uint8_t	i = 0;
+	bool bIn24G = true;
+
+	if (Channel <= 14) {
+		bIn24G = true;
+		*ChannelIdx = Channel - 1;
+	} else {
+		bIn24G = false;
+
+		for (i = 0; i < sizeof(channel5G)/sizeof(uint8_t); ++i) {
+			if (channel5G[i] == Channel) {
+				*ChannelIdx = i;
+				return bIn24G;
+			}
+		}
+	}
+	return bIn24G;
+
+}
+
+/*
+ * For VHT series, we will use a new TX pwr by rate array to meet new spec.
+ */
+ 
+u8 _rtl8821au_get_txpower_index_base(struct rtl_priv *rtlpriv,
+				     u8 RFPath, u8 Rate,
+				     enum CHANNEL_WIDTH BandWidth,
+				     u8 Channel,
+				     bool *bIn24G)
+{
+	struct rtl_efuse *rtlefuse = rtl_efuse(rtlpriv);
+
+	u8					i = 0;	//default set to 1S
+	u8					txPower = 0;
+	u8					chnlIdx = (Channel-1);
+
+	*bIn24G = _rtl8821au_phy_get_chnl_index(Channel, &chnlIdx);
+
+	//DBG_871X("[%s] Channel Index: %d\n", (*bIn24G?"2.4G":"5G"), chnlIdx);
+
+	if (*bIn24G) { //3 ============================== 2.4 G ==============================
+		if (IS_CCK_RATE(Rate)) {
+			txPower = rtlefuse->txpwrlevel_cck[RFPath][chnlIdx];
+		} else if (MGN_6M <= Rate) {
+			txPower = rtlefuse->txpwrlevel_ht40_1s[RFPath][chnlIdx];
+		} else {
+			RT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_WARNING,
+				 "INVALID Rate.\n");
+		}
+
+		//DBG_871X("Base Tx power(RF-%c, Rate #%d, Channel Index %d) = 0x%X\n", 
+		//		((RFPath==0)?'A':'B'), Rate, chnlIdx, txPower);
+		
+		// OFDM-1T
+		if ((MGN_6M <= Rate && Rate <= MGN_54M) && ! IS_CCK_RATE(Rate)) {
+			txPower += rtlefuse->txpwr_legacyhtdiff[RFPath][TX_1S];
+			//DBG_871X("+PowerDiff 2.4G (RF-%c): (OFDM-1T) = (%d)\n", ((RFPath==0)?'A':'B'), pHalData->OFDM_24G_Diff[RFPath][TX_1S]);
+		}
+
+		if (BandWidth == CHANNEL_WIDTH_20) {		// BW20-1S, BW20-2S
+			if ((MGN_MCS0 <= Rate && Rate <= MGN_MCS31) ||
+			    (MGN_VHT1SS_MCS0 <= Rate && Rate <= MGN_VHT4SS_MCS9))
+				txPower += rtlefuse->txpwr_ht20diff[RFPath][TX_1S];
+			if ((MGN_MCS8 <= Rate && Rate <= MGN_MCS31) ||
+			    (MGN_VHT2SS_MCS0 <= Rate && Rate <= MGN_VHT4SS_MCS9))
+				txPower += rtlefuse->txpwr_ht20diff[RFPath][TX_2S];
+			if ((MGN_MCS16 <= Rate && Rate <= MGN_MCS31) ||
+			    (MGN_VHT3SS_MCS0 <= Rate && Rate <= MGN_VHT4SS_MCS9))
+				txPower += rtlefuse->txpwr_ht20diff[RFPath][TX_3S];
+			if ((MGN_MCS24 <= Rate && Rate <= MGN_MCS31) ||
+			    (MGN_VHT4SS_MCS0 <= Rate && Rate <= MGN_VHT4SS_MCS9))
+				txPower += rtlefuse->txpwr_ht20diff[RFPath][TX_4S];
+
+			//DBG_871X("+PowerDiff 2.4G (RF-%c): (BW20-1S, BW20-2S, BW20-3S, BW20-4S) = (%d, %d, %d, %d)\n", ((RFPath==0)?'A':(RFPath==1)?'B':(RFPath==2)?'C':'D'), 
+			//	pHalData->BW20_24G_Diff[RFPath][TX_1S], pHalData->BW20_24G_Diff[RFPath][TX_2S], 
+			//	pHalData->BW20_24G_Diff[RFPath][TX_3S], pHalData->BW20_24G_Diff[RFPath][TX_4S]);
+		} else if (BandWidth == CHANNEL_WIDTH_40) {	// BW40-1S, BW40-2S
+			if ((MGN_MCS0 <= Rate && Rate <= MGN_MCS31) ||
+			    (MGN_VHT1SS_MCS0 <= Rate && Rate <= MGN_VHT4SS_MCS9))
+				txPower += rtlefuse->txpwr_ht40diff[RFPath][TX_1S];
+			if ((MGN_MCS8 <= Rate && Rate <= MGN_MCS31) ||
+			    (MGN_VHT2SS_MCS0 <= Rate && Rate <= MGN_VHT4SS_MCS9))
+				txPower += rtlefuse->txpwr_ht40diff[RFPath][TX_2S];
+			if ((MGN_MCS16 <= Rate && Rate <= MGN_MCS31) ||
+			    (MGN_VHT3SS_MCS0 <= Rate && Rate <= MGN_VHT4SS_MCS9))
+				txPower += rtlefuse->txpwr_ht40diff[RFPath][TX_3S];
+			if ((MGN_MCS24 <= Rate && Rate <= MGN_MCS31) ||
+			    (MGN_VHT4SS_MCS0 <= Rate && Rate <= MGN_VHT4SS_MCS9))
+				txPower += rtlefuse->txpwr_ht40diff[RFPath][TX_4S];
+
+			//DBG_871X("+PowerDiff 2.4G (RF-%c): (BW40-1S, BW40-2S, BW40-3S, BW40-4S) = (%d, %d, %d, %d)\n", ((RFPath==0)?'A':(RFPath==1)?'B':(RFPath==2)?'C':'D'), 
+			//	pHalData->BW40_24G_Diff[RFPath][TX_1S], pHalData->BW40_24G_Diff[RFPath][TX_2S],
+			//	pHalData->BW40_24G_Diff[RFPath][TX_3S], pHalData->BW40_24G_Diff[RFPath][TX_4S]);
+		} else if (BandWidth == CHANNEL_WIDTH_80) {	// Willis suggest adopt BW 40M power index while in BW 80 mode
+			if ((MGN_MCS0 <= Rate && Rate <= MGN_MCS31) ||
+			    (MGN_VHT1SS_MCS0 <= Rate && Rate <= MGN_VHT4SS_MCS9))
+				txPower += rtlefuse->txpwr_ht40diff[RFPath][TX_1S];
+			if ((MGN_MCS8 <= Rate && Rate <= MGN_MCS31) ||
+			    (MGN_VHT2SS_MCS0 <= Rate && Rate <= MGN_VHT4SS_MCS9))
+				txPower += rtlefuse->txpwr_ht40diff[RFPath][TX_2S];
+			if ((MGN_MCS16 <= Rate && Rate <= MGN_MCS31) ||
+			    (MGN_VHT3SS_MCS0 <= Rate && Rate <= MGN_VHT4SS_MCS9))
+				txPower += rtlefuse->txpwr_ht40diff[RFPath][TX_3S];
+			if ((MGN_MCS24 <= Rate && Rate <= MGN_MCS31) ||
+			    (MGN_VHT4SS_MCS0 <= Rate && Rate <= MGN_VHT4SS_MCS9))
+				txPower += rtlefuse->txpwr_ht40diff[RFPath][TX_4S];
+
+			//DBG_871X("+PowerDiff 2.4G (RF-%c): (BW40-1S, BW40-2S, BW40-3S, BW40-4T) = (%d, %d, %d, %d) P.S. Current is in BW 80MHz\n", ((RFPath==0)?'A':(RFPath==1)?'B':(RFPath==2)?'C':'D'), 
+			//	pHalData->BW40_24G_Diff[RFPath][TX_1S], pHalData->BW40_24G_Diff[RFPath][TX_2S],
+			//	pHalData->BW40_24G_Diff[RFPath][TX_3S], pHalData->BW40_24G_Diff[RFPath][TX_4S]);
+		}
+	} else { //3 ============================== 5 G ==============================
+		if (MGN_6M <= Rate) {				
+			txPower = rtlefuse->txpwr_5g_bw40base[RFPath][chnlIdx];
+		} else {
+			RT_TRACE(rtlpriv, COMP_POWER_TRACKING, DBG_WARNING,
+				 "INVALID Rate.\n");
+		}
+
+		//DBG_871X("Base Tx power(RF-%c, Rate #%d, Channel Index %d) = 0x%X\n", 
+		//	((RFPath==0)?'A':'B'), Rate, chnlIdx, txPower);
+
+		// OFDM-1T
+		if ((MGN_6M <= Rate && Rate <= MGN_54M) && ! IS_CCK_RATE(Rate)) {
+			txPower += rtlefuse->txpwr_5g_ofdmdiff[RFPath][TX_1S];
+			//DBG_871X("+PowerDiff 5G (RF-%c): (OFDM-1T) = (%d)\n", ((RFPath==0)?'A':'B'), pHalData->OFDM_5G_Diff[RFPath][TX_1S]);
+		}
+		
+		if (BandWidth == CHANNEL_WIDTH_20) {		// BW20-1S, BW20-2S
+			if ((MGN_MCS0 <= Rate && Rate <= MGN_MCS31)  ||
+			    (MGN_VHT1SS_MCS0 <= Rate && Rate <= MGN_VHT4SS_MCS9))
+				txPower += rtlefuse->txpwr_5g_bw20diff[RFPath][TX_1S];
+			if ((MGN_MCS8 <= Rate && Rate <= MGN_MCS31) ||
+			    (MGN_VHT2SS_MCS0 <= Rate && Rate <= MGN_VHT4SS_MCS9))
+				txPower += rtlefuse->txpwr_5g_bw20diff[RFPath][TX_2S];
+			if ((MGN_MCS16 <= Rate && Rate <= MGN_MCS31) ||
+			    (MGN_VHT3SS_MCS0 <= Rate && Rate <= MGN_VHT4SS_MCS9))
+				txPower += rtlefuse->txpwr_5g_bw20diff[RFPath][TX_3S];
+			if ((MGN_MCS24 <= Rate && Rate <= MGN_MCS31) ||
+			    (MGN_VHT4SS_MCS0 <= Rate && Rate <= MGN_VHT4SS_MCS9))
+				txPower += rtlefuse->txpwr_5g_bw20diff[RFPath][TX_4S];
+
+			//DBG_871X("+PowerDiff 5G (RF-%c): (BW20-1S, BW20-2S, BW20-3S, BW20-4S) = (%d, %d, %d, %d)\n", ((RFPath==0)?'A':(RFPath==1)?'B':(RFPath==2)?'C':'D'), 
+			//	pHalData->BW20_5G_Diff[RFPath][TX_1S], pHalData->BW20_5G_Diff[RFPath][TX_2S],
+			//	pHalData->BW20_5G_Diff[RFPath][TX_3S], pHalData->BW20_5G_Diff[RFPath][TX_4S]);
+		} else if (BandWidth == CHANNEL_WIDTH_40) {	// BW40-1S, BW40-2S
+			if ((MGN_MCS0 <= Rate && Rate <= MGN_MCS31)  ||
+			    (MGN_VHT1SS_MCS0 <= Rate && Rate <= MGN_VHT4SS_MCS9))
+				txPower += rtlefuse->txpwr_5g_bw40diff[RFPath][TX_1S];
+			if ((MGN_MCS8 <= Rate && Rate <= MGN_MCS31) ||
+			    (MGN_VHT2SS_MCS0 <= Rate && Rate <= MGN_VHT4SS_MCS9))
+				txPower += rtlefuse->txpwr_5g_bw40diff[RFPath][TX_2S];
+			if ((MGN_MCS16 <= Rate && Rate <= MGN_MCS31) ||
+			    (MGN_VHT3SS_MCS0 <= Rate && Rate <= MGN_VHT4SS_MCS9))
+				txPower += rtlefuse->txpwr_5g_bw40diff[RFPath][TX_3S];
+			if ((MGN_MCS24 <= Rate && Rate <= MGN_MCS31) ||
+			    (MGN_VHT4SS_MCS0 <= Rate && Rate <= MGN_VHT4SS_MCS9))
+				txPower += rtlefuse->txpwr_5g_bw40diff[RFPath][TX_4S];
+
+			//DBG_871X("+PowerDiff 5G(RF-%c): (BW40-1S, BW40-2S) = (%d, %d, %d, %d)\n", ((RFPath==0)?'A':(RFPath==1)?'B':(RFPath==2)?'C':'D'), 
+			//	pHalData->BW40_5G_Diff[RFPath][TX_1S], pHalData->BW40_5G_Diff[RFPath][TX_2S],
+			//	pHalData->BW40_5G_Diff[RFPath][TX_3S], pHalData->BW40_5G_Diff[RFPath][TX_4S]);
+		} else if (BandWidth== CHANNEL_WIDTH_80) {	// BW80-1S, BW80-2S
+			// <20121220, Kordan> Get the index of array "Index5G_BW80_Base".
+			u8	channel5G_80M[CHANNEL_MAX_NUMBER_5G_80M] = {42, 58, 106, 122, 138, 155, 171};
+			for (i = 0; i < sizeof(channel5G_80M)/sizeof(u8); ++i)
+				if ( channel5G_80M[i] == Channel) 
+					chnlIdx = i;
+
+			txPower = rtlefuse->txpwr_5g_bw80base[RFPath][chnlIdx];
+
+			if ((MGN_MCS0 <= Rate && Rate <= MGN_MCS31)  ||
+			    (MGN_VHT1SS_MCS0 <= Rate && Rate <= MGN_VHT4SS_MCS9))
+				txPower += + rtlefuse->txpwr_5g_bw80diff[RFPath][TX_1S];
+			if ((MGN_MCS8 <= Rate && Rate <= MGN_MCS31) ||
+			    (MGN_VHT2SS_MCS0 <= Rate && Rate <= MGN_VHT4SS_MCS9))
+				txPower += rtlefuse->txpwr_5g_bw80diff[RFPath][TX_2S];
+			if ((MGN_MCS16 <= Rate && Rate <= MGN_MCS31) ||
+			    (MGN_VHT3SS_MCS0 <= Rate && Rate <= MGN_VHT4SS_MCS9))
+				txPower += rtlefuse->txpwr_5g_bw80diff[RFPath][TX_3S];
+			if ((MGN_MCS23 <= Rate && Rate <= MGN_MCS31) ||
+			    (MGN_VHT4SS_MCS0 <= Rate && Rate <= MGN_VHT4SS_MCS9))
+				txPower += rtlefuse->txpwr_5g_bw80diff[RFPath][TX_4S];
+
+			//DBG_871X("+PowerDiff 5G(RF-%c): (BW80-1S, BW80-2S, BW80-3S, BW80-4S) = (%d, %d, %d, %d)\n",((RFPath==0)?'A':(RFPath==1)?'B':(RFPath==2)?'C':'D'), 
+			//	pHalData->BW80_5G_Diff[RFPath][TX_1S], pHalData->BW80_5G_Diff[RFPath][TX_2S],
+			//	pHalData->BW80_5G_Diff[RFPath][TX_3S], pHalData->BW80_5G_Diff[RFPath][TX_4S]);
+		}
+	}
+
+	return txPower;	
+}
+
+u8 phy_GetCurrentTxNum_8812A(struct rtl_priv *rtlpriv, u8 Rate)
+{
+	u8	tx_num = 0;
+	
+	if ((Rate >= MGN_MCS8 && Rate <= MGN_MCS15) || 
+		 (Rate >= MGN_VHT2SS_MCS0 && Rate <= MGN_VHT2SS_MCS9))
+		tx_num = RF_2TX;
+	else
+		tx_num = RF_1TX;
+		
+	return tx_num;
+}
+
+static u8 PHY_GetRateIndexOfTxPowerByRate(u8 Rate)
+{
+	u8 index = 0;
+	switch (Rate) {
+	case MGN_1M:
+		index = 0;
+		break;
+	case MGN_2M:
+		index = 1;
+		break;
+	case MGN_5_5M:
+		index = 2;
+		break;
+	case MGN_11M:
+		index = 3;
+		break;
+	case MGN_6M:
+		index = 4;
+		break;
+	case MGN_9M:
+		index = 5;
+		break;
+	case MGN_12M:
+		index = 6;
+		break;
+	case MGN_18M:
+		index = 7;
+		break;
+	case MGN_24M:
+		index = 8;
+		break;
+	case MGN_36M:
+		index = 9;
+		break;
+	case MGN_48M:
+		index = 10;
+		break;
+	case MGN_54M:
+		index = 11;
+		break;
+	case MGN_MCS0:
+		index = 12;
+		break;
+	case MGN_MCS1:
+		index = 13;
+		break;
+	case MGN_MCS2:
+		index = 14;
+		break;
+	case MGN_MCS3:
+		index = 15;
+		break;
+	case MGN_MCS4:
+		index = 16;
+		break;
+	case MGN_MCS5:
+		index = 17;
+		break;
+	case MGN_MCS6:
+		index = 18;
+		break;
+	case MGN_MCS7:
+		index = 19;
+		break;
+	case MGN_MCS8:
+		index = 20;
+		break;
+	case MGN_MCS9:
+		index = 21;
+		break;
+	case MGN_MCS10:
+		index = 22;
+		break;
+	case MGN_MCS11:
+		index = 23;
+		break;
+	case MGN_MCS12:
+		index = 24;
+		break;
+	case MGN_MCS13:
+		index = 25;
+		break;
+	case MGN_MCS14:
+		index = 26;
+		break;
+	case MGN_MCS15:
+		index = 27;
+		break;
+	case MGN_MCS16:
+		index = 28;
+		break;
+	case MGN_MCS17:
+		index = 29;
+		break;
+	case MGN_MCS18:
+		index = 30;
+		break;
+	case MGN_MCS19:
+		index = 31;
+		break;
+	case MGN_MCS20:
+		index = 32;
+		break;
+	case MGN_MCS21:
+		index = 33;
+		break;
+	case MGN_MCS22:
+		index = 34;
+		break;
+	case MGN_MCS23:
+		index = 35;
+		break;
+	case MGN_MCS24:
+		index = 36;
+		break;
+	case MGN_MCS25:
+		index = 37;
+		break;
+	case MGN_MCS26:
+		index = 38;
+		break;
+	case MGN_MCS27:
+		index = 39;
+		break;
+	case MGN_MCS28:
+		index = 40;
+		break;
+	case MGN_MCS29:
+		index = 41;
+		break;
+	case MGN_MCS30:
+		index = 42;
+		break;
+	case MGN_MCS31:
+		index = 43;
+		break;
+	case MGN_VHT1SS_MCS0:
+		index = 44;
+		break;
+	case MGN_VHT1SS_MCS1:
+		index = 45;
+		break;
+	case MGN_VHT1SS_MCS2:
+		index = 46;
+		break;
+	case MGN_VHT1SS_MCS3:
+		index = 47;
+		break;
+	case MGN_VHT1SS_MCS4:
+		index = 48;
+		break;
+	case MGN_VHT1SS_MCS5:
+		index = 49;
+		break;
+	case MGN_VHT1SS_MCS6:
+		index = 50;
+		break;
+	case MGN_VHT1SS_MCS7:
+		index = 51;
+		break;
+	case MGN_VHT1SS_MCS8:
+		index = 52;
+		break;
+	case MGN_VHT1SS_MCS9:
+		index = 53;
+		break;
+	case MGN_VHT2SS_MCS0:
+		index = 54;
+		break;
+	case MGN_VHT2SS_MCS1:
+		index = 55;
+		break;
+	case MGN_VHT2SS_MCS2:
+		index = 56;
+		break;
+	case MGN_VHT2SS_MCS3:
+		index = 57;
+		break;
+	case MGN_VHT2SS_MCS4:
+		index = 58;
+		break;
+	case MGN_VHT2SS_MCS5:
+		index = 59;
+		break;
+	case MGN_VHT2SS_MCS6:
+		index = 60;
+		break;
+	case MGN_VHT2SS_MCS7:
+		index = 61;
+		break;
+	case MGN_VHT2SS_MCS8:
+		index = 62;
+		break;
+	case MGN_VHT2SS_MCS9:
+		index = 63;
+		break;
+	case MGN_VHT3SS_MCS0:
+		index = 64;
+		break;
+	case MGN_VHT3SS_MCS1:
+		index = 65;
+		break;
+	case MGN_VHT3SS_MCS2:
+		index = 66;
+		break;
+	case MGN_VHT3SS_MCS3:
+		index = 67;
+		break;
+	case MGN_VHT3SS_MCS4:
+		index = 68;
+		break;
+	case MGN_VHT3SS_MCS5:
+		index = 69;
+		break;
+	case MGN_VHT3SS_MCS6:
+		index = 70;
+		break;
+	case MGN_VHT3SS_MCS7:
+		index = 71;
+		break;
+	case MGN_VHT3SS_MCS8:
+		index = 72;
+		break;
+	case MGN_VHT3SS_MCS9:
+		index = 73;
+		break;
+	case MGN_VHT4SS_MCS0:
+		index = 74;
+		break;
+	case MGN_VHT4SS_MCS1:
+		index = 75;
+		break;
+	case MGN_VHT4SS_MCS2:
+		index = 76;
+		break;
+	case MGN_VHT4SS_MCS3:
+		index = 77;
+		break;
+	case MGN_VHT4SS_MCS4:
+		index = 78;
+		break;
+	case MGN_VHT4SS_MCS5:
+		index = 79;
+		break;
+	case MGN_VHT4SS_MCS6:
+		index = 80;
+		break;
+	case MGN_VHT4SS_MCS7:
+		index = 81;
+		break;
+	case MGN_VHT4SS_MCS8:
+		index = 82;
+		break;
+	case MGN_VHT4SS_MCS9:
+		index = 83;
+		break;
+
+	default:
+#if 0	
+		DBG_871X("Invalid rate 0x%x in %s\n", Rate, __FUNCTION__ );
+#endif		
+		break;
+	};
+
+	return index;
+}
+
+static s8 _rtl8821au_phy_get_txpower_tracking_offset(struct rtl_priv *rtlpriv,
+						     u8 rfpath, u8 rate)
+{
+	struct rtl_dm *rtldm = rtl_dm(rtlpriv);
+	s8 offset = 0;
+	
+	if( rtldm->txpower_track_control  == false)
+		return offset;
+	
+	if ((rate == MGN_1M) || (rate == MGN_2M) ||
+	    (rate == MGN_5_5M)||(rate == MGN_11M)) {
+		offset = rtldm->remnant_cck_idx;
+		//DBG_871X("+Remnant_CCKSwingIdx = 0x%x\n", RFPath, Rate, pDM_Odm->Remnant_CCKSwingIdx);
+	} else {
+		offset = rtldm->remnant_ofdm_swing_idx[rfpath];
+		//DBG_871X("+Remanant_OFDMSwingIdx[RFPath %u][Rate 0x%x] = 0x%x\n", RFPath, Rate, pDM_Odm->Remnant_OFDMSwingIdx[RFPath]);		
+		
+	}
+
+	return offset;
+}
+
+static u8 _rtl8821au_get_txpower_index(struct rtl_priv *rtlpriv, u8 RFPath,
+			       u8 Rate, enum CHANNEL_WIDTH BandWidth,
+			       u8 Channel)
+{
+	struct rtl_hal *rtlhal = rtl_hal(rtlpriv);
+
+	s8 txpower = 0, limit = 0;
+	bool in_24g = false;
+	s8 powerdiff_byrate = 0;
+
+	u8 tx_num = phy_GetCurrentTxNum_8812A(rtlpriv, Rate);
+
+	//DBG_871X("===> PHY_GetTxPowerIndex_8812A\n");
+
+	txpower = (s8) _rtl8821au_get_txpower_index_base(rtlpriv, RFPath, Rate, 
+							  BandWidth, Channel, &in_24g);
+
+	powerdiff_byrate = _rtl8821au_phy_get_txpower_by_rate(rtlpriv, (u8)(!in_24g), RFPath, tx_num, Rate );
+
+	limit = _rtl8821au_phy_get_txpower_limit(rtlpriv, (u8)(!in_24g),
+						 rtlpriv->phy.current_chan_bw,
+						 RFPath, Rate,
+						 rtlpriv->phy.current_channel);
+
+	powerdiff_byrate = (powerdiff_byrate > limit) ? limit : powerdiff_byrate;
+	//DBG_871X("Rate-0x%x: (TxPower, PowerDiffByRate Path-%c) = (0x%X, %d)\n", Rate, ((RFPath==0)?'A':'B'), txPower, powerDiffByRate);
+
+	// We need to reduce power index for VHT MCS 8 & 9.
+	if (Rate == MGN_VHT1SS_MCS8 || Rate == MGN_VHT1SS_MCS9 ||
+		Rate == MGN_VHT2SS_MCS8 || Rate == MGN_VHT2SS_MCS9) {
+		txpower += powerdiff_byrate;
+	} else {
+#ifdef CONFIG_USB_HCI
+		//
+		// 2013/01/29 MH For preventing VHT rate of 8812AU to be used in USB 2.0 mode
+		// and the current will be more than 500mA and card disappear. We need to limit 
+		// TX power with any power by rate for VHT in U2.
+		// 2013/01/30 MH According to power current test compare with BCM AC NIC, we
+		// decide to use host hub = 2.0 mode to enable tx power limit behavior.
+		//
+		if (adapter_to_dvobj(pAdapter)->usb_speed == RTW_USB_SPEED_2 && IS_HARDWARE_TYPE_8812AU(pAdapter))
+		{
+			powerdiff_byrate = 0;
+		}
+#endif
+		txpower += powerdiff_byrate;
+#if 0
+		//
+		// 2013/02/06 MH Add for ASUS requiremen for adjusting TX power limit.
+		// This is a temporarily dirty fix for asus , neeed to revise later!
+		// 2013/03/07 MH Asus add more request.
+		// 2013/03/14 MH Asus add one more request for the power control.
+		//
+		if (Channel >= 36) {			
+			txPower += pMgntInfo->RegTPCLvl5g;
+
+			if (txPower > pMgntInfo->RegTPCLvl5gD)
+				txPower -= pMgntInfo->RegTPCLvl5gD;
+		} else {		
+			txPower += pMgntInfo->RegTPCLvl;
+
+			if (txPower > pMgntInfo->RegTPCLvlD)
+				txPower -= pMgntInfo->RegTPCLvlD;
+		}
+#endif
+	}	
+	
+	txpower += _rtl8821au_phy_get_txpower_tracking_offset(rtlpriv, RFPath, Rate );
+	
+	// 2012/09/26 MH We need to take care high power device limiation to prevent destroy EXT_PA.
+	// This case had ever happened in CU/SU high power module. THe limitation = 0x20.
+	// But for 8812, we still not know the value.
+#if 0	
+	phy_TxPwrAdjInPercentage(pAdapter, (u8 *)&txPower);
+#endif	
+
+	if(txpower > MAX_POWER_INDEX)
+		txpower = MAX_POWER_INDEX;
+
+	if ( txpower % 2 == 1 && !IS_NORMAL_CHIP(rtlhal->version))
+		--txpower;
+
+	//DBG_871X("Final Tx Power(RF-%c, Channel: %d) = %d(0x%X)\n", ((RFPath==0)?'A':'B'), Channel,txPower, txPower);
+
+	return (u8) txpower;
+}
+
+static void PHY_SetPowerLimitTableValue(struct rtl_priv *rtlpriv,
+	s8 *Regulation, s8 *Band, s8 *Bandwidth, s8 *RateSection,
+	s8 *RfPath, s8 *Channel, s8 *PowerLimit)
+{
+	struct rtl_phy *rtlphy = rtl_phy(rtlpriv);
+	uint8_t		regulation = 0, bandwidth = 0, rateSection = 0,
+			channel, powerLimit, channelGroup;
+
+	RT_TRACE(rtlpriv, COMP_POWER, DBG_LOUD, "Index of power limit table \
+		  [band %s][regulation %s][bw %s][rate section %s][rf path %s][chnl %s][val %s]\n",
+		  Band, Regulation, Bandwidth, RateSection, RfPath, Channel, PowerLimit);
+
+	if (!Getu8IntegerFromStringInDecimal(Channel, &channel) ||
+		 !Getu8IntegerFromStringInDecimal(PowerLimit, &powerLimit)) {
+		RT_TRACE(rtlpriv, COMP_POWER, DBG_LOUD, "Illegal index of power limit table [chnl %s][val %s]\n", Channel, PowerLimit);
+	}
+
+	powerLimit = powerLimit > MAX_POWER_INDEX ? MAX_POWER_INDEX : powerLimit;
+
+	if (eqNByte(Regulation, "FCC", 3))
+		regulation = 0;
+	else if (eqNByte(Regulation, "MKK", 3))
+		regulation = 1;
+	else if (eqNByte(Regulation, "ETSI", 4))
+		regulation = 2;
+
+	if (eqNByte(RateSection, "CCK", 3))
+		rateSection = 0;
+	else if (eqNByte(RateSection, "OFDM", 4))
+		rateSection = 1;
+	else if (eqNByte(RateSection, "HT", 2) && eqNByte(RfPath, "1T", 2))
+		rateSection = 2;
+	else if (eqNByte(RateSection, "HT", 2) && eqNByte(RfPath, "2T", 2))
+		rateSection = 3;
+	else if (eqNByte(RateSection, "VHT", 3) && eqNByte(RfPath, "1T", 2))
+		rateSection = 4;
+	else if (eqNByte(RateSection, "VHT", 3) && eqNByte(RfPath, "2T", 2))
+		rateSection = 5;
+
+
+	if (eqNByte(Bandwidth, "20M", 3))
+		bandwidth = 0;
+	else if (eqNByte(Bandwidth, "40M", 3))
+		bandwidth = 1;
+	else if (eqNByte(Bandwidth, "80M", 3))
+		bandwidth = 2;
+	else if (eqNByte(Bandwidth, "160M", 4))
+		bandwidth = 3;
+
+	if (eqNByte(Band, "2.4G", 4)) {
+		RT_TRACE(rtlpriv, COMP_POWER, DBG_LOUD, "2.4G Band value : [regulation %d][bw %d][rate_section %d][chnl %d][val %d]\n",
+			regulation, bandwidth, rateSection, channel, powerLimit);
+
+		channelGroup = phy_GetChannelGroup(rtlpriv, BAND_ON_2_4G, channel);
+		rtlphy->txpwr_limit_2_4g[regulation][bandwidth][rateSection][channelGroup][RF90_PATH_A] = powerLimit;
+	} else if (eqNByte(Band, "5G", 2)) {
+		RT_TRACE(rtlpriv, COMP_POWER, DBG_LOUD, "5G Band value : [regulation %d][bw %d][rate_section %d][chnl %d][val %d]\n",
+			  regulation, bandwidth, rateSection, channel, powerLimit);
+
+		channelGroup = phy_GetChannelGroup(rtlpriv, BAND_ON_5G, channel);
+		rtlphy->txpwr_limit_5g[regulation][bandwidth][rateSection][channelGroup][RF90_PATH_A] = powerLimit;
+	} else {
+		RT_TRACE(rtlpriv, COMP_POWER, DBG_LOUD, "Cannot recognize the band info in %s\n", Band);
+		return;
+	}
+}
+
+static void odm_ConfigBB_TXPWR_LMT_8821A(struct rtl_priv *rtlpriv,
+	u8 *Regulation, u8 *Band, u8 *Bandwidth,
+	u8 * RateSection, u8 *RfPath, u8 *Channel,
+	u8 *PowerLimit
+    )
+{
+	PHY_SetPowerLimitTableValue(rtlpriv, Regulation, Band,
+		Bandwidth, RateSection, RfPath, Channel, PowerLimit);
+}
+
+static void _rtl8821au_phy_set_txpower_limit(struct rtl_priv *rtlpriv,
+	s8 *Regulation, s8 *Band, s8 *Bandwidth, s8 *RateSection,
+	s8 *RfPath, s8 *Channel, s8 *PowerLimit)
+{
+	struct rtl_phy *rtlphy = rtl_phy(rtlpriv);
+	uint8_t		regulation = 0, bandwidth = 0, rateSection = 0,
+			channel, powerLimit, channelGroup;
+
+	RT_TRACE(rtlpriv, COMP_POWER, DBG_LOUD, "Index of power limit table \
+		  [band %s][regulation %s][bw %s][rate section %s][rf path %s][chnl %s][val %s]\n",
+		  Band, Regulation, Bandwidth, RateSection, RfPath, Channel, PowerLimit);
+
+	if (!Getu8IntegerFromStringInDecimal(Channel, &channel) ||
+		 !Getu8IntegerFromStringInDecimal(PowerLimit, &powerLimit)) {
+		RT_TRACE(rtlpriv, COMP_POWER, DBG_LOUD, "Illegal index of power limit table [chnl %s][val %s]\n", Channel, PowerLimit);
+	}
+
+	powerLimit = powerLimit > MAX_POWER_INDEX ? MAX_POWER_INDEX : powerLimit;
+
+	if (eqNByte(Regulation, "FCC", 3))
+		regulation = 0;
+	else if (eqNByte(Regulation, "MKK", 3))
+		regulation = 1;
+	else if (eqNByte(Regulation, "ETSI", 4))
+		regulation = 2;
+
+	if (eqNByte(RateSection, "CCK", 3))
+		rateSection = 0;
+	else if (eqNByte(RateSection, "OFDM", 4))
+		rateSection = 1;
+	else if (eqNByte(RateSection, "HT", 2) && eqNByte(RfPath, "1T", 2))
+		rateSection = 2;
+	else if (eqNByte(RateSection, "HT", 2) && eqNByte(RfPath, "2T", 2))
+		rateSection = 3;
+	else if (eqNByte(RateSection, "VHT", 3) && eqNByte(RfPath, "1T", 2))
+		rateSection = 4;
+	else if (eqNByte(RateSection, "VHT", 3) && eqNByte(RfPath, "2T", 2))
+		rateSection = 5;
+
+
+	if (eqNByte(Bandwidth, "20M", 3))
+		bandwidth = 0;
+	else if (eqNByte(Bandwidth, "40M", 3))
+		bandwidth = 1;
+	else if (eqNByte(Bandwidth, "80M", 3))
+		bandwidth = 2;
+	else if (eqNByte(Bandwidth, "160M", 4))
+		bandwidth = 3;
+
+	if (eqNByte(Band, "2.4G", 4)) {
+		RT_TRACE(rtlpriv, COMP_POWER, DBG_LOUD, "2.4G Band value : [regulation %d][bw %d][rate_section %d][chnl %d][val %d]\n",
+			regulation, bandwidth, rateSection, channel, powerLimit);
+
+		channelGroup = phy_GetChannelGroup(rtlpriv, BAND_ON_2_4G, channel);
+		rtlphy->txpwr_limit_2_4g[regulation][bandwidth][rateSection][channelGroup][RF90_PATH_A] = powerLimit;
+	} else if (eqNByte(Band, "5G", 2)) {
+		RT_TRACE(rtlpriv, COMP_POWER, DBG_LOUD, "5G Band value : [regulation %d][bw %d][rate_section %d][chnl %d][val %d]\n",
+			  regulation, bandwidth, rateSection, channel, powerLimit);
+
+		channelGroup = phy_GetChannelGroup(rtlpriv, BAND_ON_5G, channel);
+		rtlphy->txpwr_limit_5g[regulation][bandwidth][rateSection][channelGroup][RF90_PATH_A] = powerLimit;
+	} else {
+		RT_TRACE(rtlpriv, COMP_POWER, DBG_LOUD, "Cannot recognize the band info in %s\n", Band);
+		return;
+	}
+}
+
+static void _rtl8821au_phy_config_bb_txpwr_lmt(struct rtl_priv *rtlpriv,
+					       u8 *regulation, u8 *band,
+					       u8 *bandwidth, u8 *rate_selection,
+					       u8 *rf_path, u8 *channel,
+					       u8 *power_limit)
+{
+	_rtl8821au_phy_set_txpower_limit(rtlpriv, regulation, band, bandwidth,
+					 rate_selection, rf_path, channel,
+					 power_limit);
+}
+
+static void _rtl8821au_phy_read_and_config_txpwr_lmt(struct rtl_priv *rtlpriv)
+{
+	struct rtl_hal	*rtlhal = rtl_hal(rtlpriv);
+	uint32_t i		= 0;
+	uint32_t ArrayLen       = RTL8821AU_TXPWR_LMT_ARRAY_LEN;
+	u8 **Array		= RTL8821AU_TXPWR_LMT;
+
+	if (IS_HARDWARE_TYPE_8812AU(rtlhal)) {
+		ArrayLen = RTL8821AU_TXPWR_LMT_ARRAY_LEN;
+		Array = RTL8812AU_TXPWR_LMT;
+	} else {
+		ArrayLen = RTL8821AU_TXPWR_LMT_ARRAY_LEN;
+		Array = RTL8821AU_TXPWR_LMT;
+
+	}
+
+	for (i = 0; i < ArrayLen; i += 7) {
+		u8 *regulation = Array[i];
+		u8 *band = Array[i+1];
+		u8 *bandwidth = Array[i+2];
+		u8 *rate = Array[i+3];
+		u8 *rf_path = Array[i+4];
+		u8 *chnl = Array[i+5];
+		u8 *val = Array[i+6];
+
+		_rtl8821au_phy_config_bb_txpwr_lmt(rtlpriv, regulation, band,
+						   bandwidth, rate, rf_path,
+						   chnl, val);
+	}
+
+}
+
+static bool CheckCondition(const uint32_t  Condition, const uint32_t  Hex)
+{
+	uint32_t _board     = (Hex & 0x000000FF);
+	uint32_t _interface = (Hex & 0x0000FF00) >> 8;
+	uint32_t _platform  = (Hex & 0x00FF0000) >> 16;
+	uint32_t cond = Condition;
+
+	if (Condition == 0xCDCDCDCD)
+		return true;
+
+	cond = Condition & 0x000000FF;
+	if ((_board != cond) && (cond != 0xFF))
+		return false;
+
+	cond = Condition & 0x0000FF00;
+	cond = cond >> 8;
+	if (((_interface & cond) == 0) && (cond != 0x07))
+		return false;
+
+	cond = Condition & 0x00FF0000;
+	cond = cond >> 16;
+	if (((_platform & cond) == 0) && (cond != 0x0F))
+		return false;
+
+	return true;
+}
+
+
+void _rtl8821au_phy_config_mac_with_headerfile(struct rtl_priv *rtlpriv)
+{
+	struct rtl_hal	*rtlhal = rtl_hal(rtlpriv);
+
+	uint32_t     hex         = 0;
+	uint32_t     i           = 0;
+
+	/* ULLI : fixed values ?? */
+	u8  platform = ODM_CE;
+	u8 _interface = RTW_USB;
+	u8 board = rtlhal->board_type;
+	uint32_t ArrayLen;
+	uint32_t *Array;
+
+	if (IS_HARDWARE_TYPE_8812AU(rtlhal)) {
+		ArrayLen    = RTL8812AUMAC_1T_ARRAYLEN;
+		Array       = RTL8812AU_MAC_REG_ARRAY;
+	} else {
+		ArrayLen    = RTL8821AUMAC_1T_ARRAYLEN;
+		Array       = RTL8821AU_MAC_REG_ARRAY;
+	}
+
+	hex += board;
+	hex += _interface << 8;
+	hex += platform << 16;
+	hex += 0xFF000000;
+
+	RT_TRACE(rtlpriv, COMP_INIT, DBG_TRACE, "===> ODM_ReadAndConfig_MP_8821A_MAC_REG, hex = 0x%X\n", hex);
+
+	for (i = 0; i < ArrayLen; i += 2) {
+		uint32_t v1 = Array[i];
+		uint32_t v2 = Array[i+1];
+
+		/* This (offset, data) pair meets the condition. */
+		if (v1 < 0xCDCDCDC) {
+			rtl_write_byte(rtlpriv, v1, (u8)v2);
+			continue;
+		} else {
+			/* This line is the start line of branch. */
+			if (!CheckCondition(Array[i], hex)) {
+				/* Discard the following (offset, data) pairs. */
+				READ_NEXT_PAIR(Array, v1, v2, i);
+				while (v2 != 0xDEAD &&
+					v2 != 0xCDEF &&
+					v2 != 0xCDCD && i < ArrayLen - 2) {
+						READ_NEXT_PAIR(Array, v1, v2, i);
+				}
+				i -= 2; /* prevent from for-loop += 2 */
+			} else {
+				/* Configure matched pairs and skip to end of if-else. */
+				READ_NEXT_PAIR(Array, v1, v2, i);
+				while (v2 != 0xDEAD &&
+					v2 != 0xCDEF &&
+					v2 != 0xCDCD && i < ArrayLen - 2) {
+						rtl_write_byte(rtlpriv, v1, (u8)v2);
+						READ_NEXT_PAIR(Array, v1, v2, i);
+				}
+
+				while (v2 != 0xDEAD && i < ArrayLen - 2) {
+					READ_NEXT_PAIR(Array, v1, v2, i);
+				}
+
+			}
+		}
+	}
+
+}
+
+/* *****  */
+
+/******************************************************************************
+*                           RadioA.TXT
+******************************************************************************/
+static void _rtl8821au_config_rf_reg(struct rtl_priv *rtlpriv, uint32_t Addr,
+	uint32_t Data, enum radio_path path, uint32_t RegAddr)
+{
+	if (Addr == 0xfe || Addr == 0xffe) {
+		msleep(50);
+	} else {
+		rtl_set_rfreg(rtlpriv, path, RegAddr, bRFRegOffsetMask, Data);
+		/* Add 1us delay between BB/RF register setting. */
+		udelay(1);
+	}
+}
+
+static void _rtl8821au_config_rf_radio_a(struct rtl_priv *rtlpriv, uint32_t Addr,
+	uint32_t Data)
+{
+	uint32_t content = 0x1000;		/* RF_Content: radioa_txt */
+	uint32_t maskforPhySet = (uint32_t)(content&0xE000);
+
+	_rtl8821au_config_rf_reg(rtlpriv, Addr, Data, RF90_PATH_A, Addr|maskforPhySet);
+
+	RT_TRACE(rtlpriv, COMP_INIT, DBG_TRACE, "===> ODM_ConfigRFWithHeaderFile: [RadioA] %08X %08X\n", Addr, Data);
+}
+
+static void _rtl8821au_config_rf_radio_b(struct rtl_priv *rtlpriv, uint32_t Addr,
+	uint32_t Data)
+{
+	uint32_t  content = 0x1001;		/* RF_Content: radiob_txt */
+	uint32_t maskforPhySet = (uint32_t)(content&0xE000);
+
+	_rtl8821au_config_rf_reg(rtlpriv, Addr, Data, RF90_PATH_B, Addr|maskforPhySet);
+
+	RT_TRACE(rtlpriv, COMP_INIT, DBG_TRACE, "===> ODM_ConfigRFWithHeaderFile: [RadioB] %08X %08X\n", Addr, Data);
+}
+
+
+
+bool rtl8812au_phy_config_rf_with_headerfile(struct rtl_priv *rtlpriv,
+				enum radio_path eRFPath)
+{
+	struct rtl_hal	*rtlhal = rtl_hal(rtlpriv);
+
+	int i;
+	bool rtstatus = true;
+	u32 *radioa_array_table_a, *radioa_array_table_b;
+	u16 radioa_arraylen_a, radioa_arraylen_b;
+	u32 v1 = 0, v2 = 0;
+
+	uint32_t	hex         = 0;
+	u16	count       = 0;
+	uint32_t	*ptr_array   = NULL;
+
+	/* ULLI : fixed values ?? */
+	u8  platform = ODM_CE;
+	u8 _interface = RTW_USB;
+	u8 board = rtlhal->board_type;
+
+	radioa_arraylen_a = RTL8812AU_RADIOA_1TARRAYLEN;
+	radioa_array_table_a = RTL8812AU_RADIOA_ARRAY;
+	radioa_arraylen_b = RTL8812AU_RADIOB_1TARRAYLEN;
+	radioa_array_table_b = RTL8812AU_RADIOB_ARRAY;
+	/*
+
+	RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,
+		 "Radio_A:RTL8821AE_RADIOA_ARRAY %d\n", radioa_arraylen_a);
+	RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD, "Radio No %x\n", rfpath);
+	*/
+	rtstatus = true;
+	switch (eRFPath) {
+	case RF90_PATH_A:
+		hex += board;
+		hex += _interface << 8;
+		hex += platform << 16;
+		hex += 0xFF000000;
+		RT_TRACE(rtlpriv, COMP_INIT, DBG_TRACE, "===> ODM_ReadAndConfig_MP_8821A_RadioA, hex = 0x%X\n", hex);
+
+		for (i = 0; i < radioa_arraylen_a; i += 2) {
+			uint32_t v1 = radioa_array_table_a[i];
+			uint32_t v2 = radioa_array_table_a[i+1];
+
+			/* This (offset, data) pair meets the condition. */
+			if (v1 < 0xCDCDCDCD) {
+				_rtl8821au_config_rf_radio_a(rtlpriv, v1, v2);
+				continue;
+			} else {
+				/* This line is the start line of branch. */
+				if (!CheckCondition(radioa_array_table_a[i], hex)) {
+					/* Discard the following (offset, data) pairs. */
+					READ_NEXT_PAIR(radioa_array_table_a, v1, v2, i);
+					while (v2 != 0xDEAD &&
+					    v2 != 0xCDEF &&
+					    v2 != 0xCDCD && i < radioa_arraylen_a-2) {
+						READ_NEXT_PAIR(radioa_array_table_a, v1, v2, i);
+					}
+					i -= 2; /* prevent from for-loop += 2 */
+				} else {
+					/* Configure matched pairs and skip to end of if-else. */
+					READ_NEXT_PAIR(radioa_array_table_a, v1, v2, i);
+					while (v2 != 0xDEAD &&
+					    v2 != 0xCDEF &&
+					    v2 != 0xCDCD && i < radioa_arraylen_a-2) {
+						_rtl8821au_config_rf_radio_a(rtlpriv, v1, v2);
+						READ_NEXT_PAIR(radioa_array_table_a, v1, v2, i);
+					}
+
+					while (v2 != 0xDEAD && i < radioa_arraylen_a-2) {
+						READ_NEXT_PAIR(radioa_array_table_a, v1, v2, i);
+					}
+				}
+			}
+		}
+		break;
+	case RF90_PATH_B:
+		hex += board;
+		hex += _interface << 8;
+		hex += platform << 16;
+		hex += 0xFF000000;
+		RT_TRACE(rtlpriv, COMP_INIT, DBG_TRACE, "===> ODM_ReadAndConfig_MP_8812A_RadioB, hex = 0x%X\n", hex);
+
+		for (i = 0; i < radioa_arraylen_b; i += 2) {
+			uint32_t v1 = radioa_array_table_b[i];
+			uint32_t v2 = radioa_array_table_b[i+1];
+
+			/* This (offset, data) pair meets the condition. */
+			if (v1 < 0xCDCDCDCD) {
+				_rtl8821au_config_rf_radio_b(rtlpriv, v1, v2);
+				continue;
+			} else {
+				/* This line is the start line of branch. */
+				if (!CheckCondition(radioa_array_table_b[i], hex)) {
+					/* Discard the following (offset, data) pairs. */
+					READ_NEXT_PAIR(radioa_array_table_b, v1, v2, i);
+					while (v2 != 0xDEAD &&
+					    v2 != 0xCDEF &&
+					    v2 != 0xCDCD && i < radioa_arraylen_b-2) {
+						READ_NEXT_PAIR(radioa_array_table_b, v1, v2, i);
+					}
+					i -= 2; /* prevent from for-loop += 2 */
+				} else {
+					/* Configure matched pairs and skip to end of if-else. */
+					READ_NEXT_PAIR(radioa_array_table_b, v1, v2, i);
+					while (v2 != 0xDEAD &&
+					    v2 != 0xCDEF &&
+					    v2 != 0xCDCD && i < radioa_arraylen_b-2) {
+						_rtl8821au_config_rf_radio_b(rtlpriv, v1, v2);
+						READ_NEXT_PAIR(radioa_array_table_b, v1, v2, i);
+					}
+
+					while (v2 != 0xDEAD && i < radioa_arraylen_b-2) {
+						READ_NEXT_PAIR(radioa_array_table_b, v1, v2, i);
+					}
+				}
+			}
+		}
+
+	case RF90_PATH_C:
+		RT_TRACE(rtlpriv, COMP_ERR, DBG_EMERG,
+			 "switch case not process\n");
+		break;
+	case RF90_PATH_D:
+		RT_TRACE(rtlpriv, COMP_ERR, DBG_EMERG, 
+			 "switch case not process\n");
+		break;
+	}
+
+	return rtstatus;
+}
+
+
+/******************************************************************************
+*                           RadioA.TXT
+******************************************************************************/
+
+bool rtl8821au_phy_config_rf_with_headerfile(struct rtl_priv *rtlpriv, enum radio_path eRFPath)
+{
+	struct rtl_hal	*rtlhal = rtl_hal(rtlpriv);
+
+	uint32_t	hex         = 0;
+	uint32_t	i           = 0;
+	bool rtstatus = true;
+	u16	count       = 0;
+	uint32_t	*ptr_array   = NULL;
+
+	/* ULLI : fixed values ?? */
+	u8  platform = ODM_CE;
+	u8 _interface = RTW_USB;
+	u8 board = rtlhal->board_type;
+
+	uint32_t	ArrayLen    =  RTL8821AU_RADIOA_1TARRAYLEN;
+	uint32_t	*Array       = RTL8821AU_RADIOA_ARRAY;
+
+
+	hex += board;
+	hex += _interface << 8;
+	hex += platform << 16;
+	hex += 0xFF000000;
+	RT_TRACE(rtlpriv, COMP_INIT, DBG_TRACE, "===> ODM_ReadAndConfig_MP_8821A_RadioA, hex = 0x%X\n", hex);
+
+	for (i = 0; i < ArrayLen; i += 2) {
+		uint32_t v1 = Array[i];
+		uint32_t v2 = Array[i+1];
+
+		/* This (offset, data) pair meets the condition. */
+		if (v1 < 0xCDCDCDCD) {
+			_rtl8821au_config_rf_radio_a(rtlpriv, v1, v2);
+			continue;
+		} else {
+			/* This line is the start line of branch. */
+			if (!CheckCondition(Array[i], hex)) {
+				/* Discard the following (offset, data) pairs. */
+				READ_NEXT_PAIR(Array, v1, v2, i);
+				while (v2 != 0xDEAD &&
+				    v2 != 0xCDEF &&
+				    v2 != 0xCDCD && i < ArrayLen-2) {
+					READ_NEXT_PAIR(Array, v1, v2, i);
+				}
+				i -= 2; /* prevent from for-loop += 2 */
+			} else {
+				/* Configure matched pairs and skip to end of if-else. */
+				READ_NEXT_PAIR(Array, v1, v2, i);
+				while (v2 != 0xDEAD &&
+				    v2 != 0xCDEF &&
+				    v2 != 0xCDCD && i < ArrayLen-2) {
+					_rtl8821au_config_rf_radio_a(rtlpriv, v1, v2);
+					READ_NEXT_PAIR(Array, v1, v2, i);
+				}
+
+				while (v2 != 0xDEAD && i < ArrayLen-2) {
+					READ_NEXT_PAIR(Array, v1, v2, i);
+				}
+			}
+		}
+	}
+
+	return rtstatus;
+}
+
+static void _rtl8821au_phy_set_reg_bw(struct rtl_priv *rtlpriv, enum CHANNEL_WIDTH bw)
+{
+	u16 reg_rf_mode_bw, tmp = 0;
+
+	reg_rf_mode_bw = rtl_read_word(rtlpriv, REG_WMAC_TRXPTCL_CTL);
+	switch (bw) {
+	case CHANNEL_WIDTH_20:
+		rtl_write_word(rtlpriv, REG_WMAC_TRXPTCL_CTL, reg_rf_mode_bw & 0xFE7F);
+		break;
+	case CHANNEL_WIDTH_40:
+		tmp = reg_rf_mode_bw | BIT(7);
+		rtl_write_word(rtlpriv, REG_WMAC_TRXPTCL_CTL, tmp & 0xFEFF);
+		break;
+	case CHANNEL_WIDTH_80:
+		tmp = reg_rf_mode_bw | BIT(8);
+		rtl_write_word(rtlpriv, REG_WMAC_TRXPTCL_CTL, tmp & 0xFF7F);
+		break;
+	default:
+		RT_TRACE(rtlpriv, COMP_POWER, DBG_LOUD, "phy_PostSetBWMode8812():	unknown Bandwidth: %#X\n", bw);
+		break;
+	}
+}
+
+void rtl8812au_fixspur(struct rtl_priv *rtlpriv, enum CHANNEL_WIDTH Bandwidth,
+	u8 Channel)
+{
+	struct rtl_hal *rtlhal = rtl_hal(rtlpriv);
+
+	/* C cut Item12 ADC FIFO CLOCK */
+	if(IS_VENDOR_8812A_C_CUT(rtlhal->version)) {
+		if(Bandwidth == CHANNEL_WIDTH_40 && Channel == 11)
+			rtl_set_bbreg(rtlpriv, rRFMOD_Jaguar, 0xC00, 0x3);		/* 0x8AC[11:10] = 2'b11 */
+		else
+			rtl_set_bbreg(rtlpriv, rRFMOD_Jaguar, 0xC00, 0x2);		/* 0x8AC[11:10] = 2'b10 */
+
+		/*
+		 *  <20120914, Kordan> A workarould to resolve 2480Mhz spur by setting ADC clock as 160M. (Asked by Binson)
+		 */
+		if (Bandwidth == CHANNEL_WIDTH_20 && (Channel == 13 || Channel == 14)) {
+			rtl_set_bbreg(rtlpriv, rRFMOD_Jaguar, 0x300, 0x3);  		/* 0x8AC[9:8] = 2'b11 */
+			rtl_set_bbreg(rtlpriv, rADC_Buf_Clk_Jaguar, BIT(30), 1);  	/* 0x8C4[30] = 1 */
+		} else if (Bandwidth == CHANNEL_WIDTH_40 && Channel == 11) {
+			rtl_set_bbreg(rtlpriv, rADC_Buf_Clk_Jaguar, BIT(30), 1);  	/* 0x8C4[30] = 1 */
+		} else if (Bandwidth != CHANNEL_WIDTH_80) {
+			rtl_set_bbreg(rtlpriv, rRFMOD_Jaguar, 0x300, 0x2);  		/* 0x8AC[9:8] = 2'b10 */
+			rtl_set_bbreg(rtlpriv, rADC_Buf_Clk_Jaguar, BIT(30), 0);  	/* 0x8C4[30] = 0 */
+
+		}
+	} else if (IS_HARDWARE_TYPE_8812(rtlhal)) {
+		/* <20120914, Kordan> A workarould to resolve 2480Mhz spur by setting ADC clock as 160M. (Asked by Binson) */
+		if (Bandwidth == CHANNEL_WIDTH_20 && (Channel == 13 || Channel == 14))
+			rtl_set_bbreg(rtlpriv, rRFMOD_Jaguar, 0x300, 0x3);  /* 0x8AC[9:8] = 11 */
+		else if (Channel <= 14) /* 2.4G only */
+			rtl_set_bbreg(rtlpriv, rRFMOD_Jaguar, 0x300, 0x2);  /* 0x8AC[9:8] = 10 */
+	}
+
+}
+static u8 _rtl8821au_phy_get_secondary_chnl(struct rtl_priv *rtlpriv)
+{
+	struct rtl_mac *mac = &(rtlpriv->mac80211);
+	uint8_t	SCSettingOf40 = 0, SCSettingOf20 = 0;
+
+	/*
+	 * DBG_871X("SCMapping: VHT Case: pHalData->CurrentChannelBW %d, pHalData->nCur80MhzPrimeSC %d, pHalData->nCur40MhzPrimeSC %d \n",pHalData->CurrentChannelBW,pHalData->nCur80MhzPrimeSC,pHalData->nCur40MhzPrimeSC);
+	 */
+	if(rtlpriv->phy.current_chan_bw== CHANNEL_WIDTH_80) {
+		if(mac->cur_80_prime_sc == HAL_PRIME_CHNL_OFFSET_LOWER)
+			SCSettingOf40 = VHT_DATA_SC_40_LOWER_OF_80MHZ;
+		else if(mac->cur_80_prime_sc == HAL_PRIME_CHNL_OFFSET_UPPER)
+			SCSettingOf40 = VHT_DATA_SC_40_UPPER_OF_80MHZ;
+		else
+			RT_TRACE(rtlpriv, COMP_POWER, DBG_LOUD, "SCMapping: Not Correct Primary40MHz Setting \n");
+
+		if((mac->cur_40_prime_sc == HAL_PRIME_CHNL_OFFSET_LOWER) && (mac->cur_80_prime_sc == HAL_PRIME_CHNL_OFFSET_LOWER))
+			SCSettingOf20 = VHT_DATA_SC_20_LOWEST_OF_80MHZ;
+		else if((mac->cur_40_prime_sc == HAL_PRIME_CHNL_OFFSET_UPPER) && (mac->cur_80_prime_sc == HAL_PRIME_CHNL_OFFSET_LOWER))
+			SCSettingOf20 = VHT_DATA_SC_20_LOWER_OF_80MHZ;
+		else if((mac->cur_40_prime_sc == HAL_PRIME_CHNL_OFFSET_LOWER) && (mac->cur_80_prime_sc == HAL_PRIME_CHNL_OFFSET_UPPER))
+			SCSettingOf20 = VHT_DATA_SC_20_UPPER_OF_80MHZ;
+		else if((mac->cur_40_prime_sc == HAL_PRIME_CHNL_OFFSET_UPPER) && (mac->cur_80_prime_sc == HAL_PRIME_CHNL_OFFSET_UPPER))
+			SCSettingOf20 = VHT_DATA_SC_20_UPPERST_OF_80MHZ;
+		else
+			RT_TRACE(rtlpriv, COMP_POWER, DBG_LOUD, "SCMapping: Not Correct Primary40MHz Setting \n");
+	} else if(rtlpriv->phy.current_chan_bw == CHANNEL_WIDTH_40) {
+		/*
+		 * DBG_871X("SCMapping: VHT Case: pHalData->CurrentChannelBW %d, pHalData->nCur40MhzPrimeSC %d \n",pHalData->CurrentChannelBW,pHalData->nCur40MhzPrimeSC);
+		 */
+
+		if(mac->cur_40_prime_sc == HAL_PRIME_CHNL_OFFSET_UPPER)
+			SCSettingOf20 = VHT_DATA_SC_20_UPPER_OF_80MHZ;
+		else if(mac->cur_40_prime_sc == HAL_PRIME_CHNL_OFFSET_LOWER)
+			SCSettingOf20 = VHT_DATA_SC_20_LOWER_OF_80MHZ;
+		else
+			RT_TRACE(rtlpriv, COMP_POWER, DBG_LOUD, "SCMapping: Not Correct Primary40MHz Setting \n");
+	}
+
+	/*
+	 * DBG_871X("SCMapping: SC Value %x \n", ( (SCSettingOf40 << 4) | SCSettingOf20));
+	 */
+	return  ( (SCSettingOf40 << 4) | SCSettingOf20);
+}
+
+
+void rtl8821au_phy_set_bw_mode_callback(struct rtl_priv *rtlpriv)
+{
+	uint8_t			SubChnlNum = 0;
+	uint8_t			L1pkVal = 0;
+
+	/* 3 Set Reg668 Reg440 BW */
+	_rtl8821au_phy_set_reg_bw(rtlpriv, rtlpriv->phy.current_chan_bw);
+
+	/* 3 Set Reg483 */
+	SubChnlNum = _rtl8821au_phy_get_secondary_chnl(rtlpriv);
+	rtl_write_byte(rtlpriv, REG_DATA_SC_8812, SubChnlNum);
+
+	/* DBG_871X("[BW:CHNL], phy_PostSetBwMode8812(), set BW=%s !!\n", GLBwSrc[pHalData->CurrentChannelBW]); */
+
+	/* 3 Set Reg848 Reg864 Reg8AC Reg8C4 RegA00 */
+	switch (rtlpriv->phy.current_chan_bw) {
+	case CHANNEL_WIDTH_20:
+		rtl_set_bbreg(rtlpriv, rRFMOD_Jaguar, 0x003003C3, 0x00300200); /* 0x8ac[21,20,9:6,1,0]=8'b11100000 */
+		rtl_set_bbreg(rtlpriv, rADC_Buf_Clk_Jaguar, BIT(30), 0);			// 0x8c4[30] = 1'b0
+
+		rtl_set_bbreg(rtlpriv, rFPGA0_XB_RFInterfaceOE, 0x001C0000, 4);	/* 0x864[20:18] = 3'b4 */
+
+		if(rtlpriv->phy.rf_type == RF_2T2R)
+			rtl_set_bbreg(rtlpriv, rL1PeakTH_Jaguar, 0x03C00000, 7);	/* 2R 0x848[25:22] = 0x7 */
+		else
+			rtl_set_bbreg(rtlpriv, rL1PeakTH_Jaguar, 0x03C00000, 8);	/* 1R 0x848[25:22] = 0x8 */
+
+		break;
+
+	case CHANNEL_WIDTH_40:
+		rtl_set_bbreg(rtlpriv, rRFMOD_Jaguar, 0x003003C3, 0x00300201);	/* 0x8ac[21,20,9:6,1,0]=8'b11100000 */
+		rtl_set_bbreg(rtlpriv, rADC_Buf_Clk_Jaguar, BIT(30), 0);		/* 0x8c4[30] = 1'b0 */
+		rtl_set_bbreg(rtlpriv, rRFMOD_Jaguar, 0x3C, SubChnlNum);
+		rtl_set_bbreg(rtlpriv, rCCAonSec_Jaguar, 0xf0000000, SubChnlNum);
+
+		rtl_set_bbreg(rtlpriv, rFPGA0_XB_RFInterfaceOE, 0x001C0000, 2);	/* 0x864[20:18] = 3'b2 */
+
+		if(rtlpriv->phy.reg_837 & BIT(2))
+			L1pkVal = 6;
+		else {
+			if(rtlpriv->phy.rf_type == RF_2T2R)
+				L1pkVal = 7;
+			else
+				L1pkVal = 8;
+		}
+
+		rtl_set_bbreg(rtlpriv, rL1PeakTH_Jaguar, 0x03C00000, L1pkVal);	/* 0x848[25:22] = 0x6 */
+
+		if(SubChnlNum == VHT_DATA_SC_20_UPPER_OF_80MHZ)
+			rtl_set_bbreg(rtlpriv, rCCK_System_Jaguar, bCCK_System_Jaguar, 1);
+		else
+			rtl_set_bbreg(rtlpriv, rCCK_System_Jaguar, bCCK_System_Jaguar, 0);
+		break;
+
+	case CHANNEL_WIDTH_80:
+		rtl_set_bbreg(rtlpriv, rRFMOD_Jaguar, 0x003003C3, 0x00300202);	/* 0x8ac[21,20,9:6,1,0]=8'b11100010 */
+		rtl_set_bbreg(rtlpriv, rADC_Buf_Clk_Jaguar, BIT(30), 1);		/* 0x8c4[30] = 1 */
+		rtl_set_bbreg(rtlpriv, rRFMOD_Jaguar, 0x3C, SubChnlNum);
+		rtl_set_bbreg(rtlpriv, rCCAonSec_Jaguar, 0xf0000000, SubChnlNum);
+
+		rtl_set_bbreg(rtlpriv, rFPGA0_XB_RFInterfaceOE, 0x001C0000, 2);	/* 0x864[20:18] = 3'b2 */
+
+		if(rtlpriv->phy.reg_837 & BIT(2))
+			L1pkVal = 5;
+		else {
+			if(rtlpriv->phy.rf_type == RF_2T2R)
+				L1pkVal = 6;
+			else
+				L1pkVal = 7;
+		}
+		rtl_set_bbreg(rtlpriv, rL1PeakTH_Jaguar, 0x03C00000, L1pkVal);	/* 0x848[25:22] = 0x5 */
+
+		break;
+
+	default:
+		RT_TRACE(rtlpriv, COMP_POWER, DBG_LOUD, "phy_PostSetBWMode8812():	unknown Bandwidth: %#X\n",rtlpriv->phy.current_chan_bw);
+		break;
+	}
+
+	/* <20121109, Kordan> A workaround for 8812A only. */
+	rtl8812au_fixspur(rtlpriv, rtlpriv->phy.current_chan_bw, rtlpriv->phy.current_channel);
+
+	/*
+	 * DBG_871X("phy_PostSetBwMode8812(): Reg483: %x\n", rtl_read_byte(rtlpriv, 0x483));
+	 * DBG_871X("phy_PostSetBwMode8812(): Reg668: %x\n", rtl_read_dword(rtlpriv, 0x668));
+	 * DBG_871X("phy_PostSetBwMode8812(): Reg8AC: %x\n", rtl_get_bbreg(rtlpriv, rRFMOD_Jaguar, 0xffffffff));
+	 */
+
+	/* 3 Set RF related register */
+	rtl8821au_phy_rf6052_set_bandwidth(rtlpriv, rtlpriv->phy.current_chan_bw);
+}
+
+uint32_t phy_get_tx_swing_8821au(struct rtl_priv *rtlpriv, enum band_type Band,
+	uint8_t	RFPath)
+{
+	struct rtl_dm *rtldm = &(rtlpriv->dm);
+	struct rtl_hal *rtlhal = rtl_hal(rtlpriv);
+	struct rtl_efuse *efuse = rtl_efuse(rtlpriv);
+	char reg_swing_2g = -1;	/* 0xff */
+	char reg_swing_5g = -1;	/* 0xff */
+	char swing_2g = -1 * reg_swing_2g;
+	char swing_5g = -1 * reg_swing_5g;
+	uint32_t	out = 0x200;
+	const char auto_temp = -1;
+
+
+	if (efuse->autoload_failflag) {
+		if (Band == BAND_ON_2_4G) {
+			rtldm->swing_diff_2g = swing_2g;
+			if      (swing_2g == 0)
+				out = 0x200; /*  0 dB */
+		        else if (swing_2g == -3)
+				out = 0x16A; /* -3 dB */
+		        else if (swing_2g == -6)
+				out = 0x101; /* -6 dB */
+		        else if (swing_2g == -9)
+				out = 0x0B6; /* -9 dB */
+		        else {
+				if (rtlhal->external_pa_2g) {
+					rtldm->swing_diff_2g = -3;
+					out = 0x16A;
+				} else  {
+					rtldm->swing_diff_2g = 0;
+					out = 0x200;
+				}
+			}
+		} else if (Band == BAND_ON_5G) {
+			rtldm->swing_diff_5g = swing_5g;
+			if      (swing_5g == 0)
+				out = 0x200; /*  0 dB */
+			else if (swing_5g == -3)
+				out = 0x16A; /* -3 dB */
+			else if (swing_5g == -6)
+				out = 0x101; /* -6 dB */
+			else if (swing_5g == -9)
+				out = 0x0B6; /* -9 dB */
+			else {
+				if (rtlhal->external_pa_5g) {
+					rtldm->swing_diff_5g = -3;
+					out = 0x16A;
+				} else  {
+					rtldm->swing_diff_5g = 0;
+					out = 0x200;
+				}
+			}
+		} else  {
+			rtldm->swing_diff_2g = -3;
+			rtldm->swing_diff_5g = -3;
+			out = 0x16A; /* -3 dB */
+		}
+	} else {
+		uint32_t swing = 0, swingA = 0, swingB = 0;
+
+		if (Band == BAND_ON_2_4G) {
+			if (reg_swing_2g == auto_temp) {
+				EFUSE_ShadowRead(rtlpriv, 1, EEPROM_TX_BBSWING_2G_8812, (uint32_t *)&swing);
+				swing = (swing == 0xFF) ? 0x00 : swing;
+			} else if (swing_2g ==  0)
+				swing = 0x00; /*  0 dB */
+			else if (swing_2g == -3)
+				swing = 0x05; /* -3 dB */
+			else if (swing_2g == -6)
+				swing = 0x0A; // -6 dB */
+			else if (swing_2g == -9)
+				swing = 0xFF; // -9 dB */
+			else swing = 0x00;
+		} else {
+			if (reg_swing_5g == auto_temp) {
+				EFUSE_ShadowRead(rtlpriv, 1, EEPROM_TX_BBSWING_5G_8812, (uint32_t *)&swing);
+				swing = (swing == 0xFF) ? 0x00 : swing;
+			} else if (swing_5g ==  0)
+				swing = 0x00; /*  0 dB */
+			else if (swing_5g == -3)
+				swing = 0x05; /* -3 dB */
+			else if (swing_5g == -6)
+				swing = 0x0A; /* -6 dB */
+			else if (swing_5g == -9)
+				swing = 0xFF; /* -9 dB */
+			else swing = 0x00;
+		}
+
+		swingA = (swing & 0x3) >> 0; /* 0xC6/C7[1:0] */
+		swingB = (swing & 0xC) >> 2; /* 0xC6/C7[3:2] */
+
+		/* DBG_871X("===> PHY_GetTxBBSwing_8812A, swingA: 0x%X, swingB: 0x%X\n", swingA, swingB); */
+
+		/* 3 Path-A */
+		if (swingA == 0x00) {
+			if (Band == BAND_ON_2_4G)
+				rtldm->swing_diff_2g = 0;
+			else
+				rtldm->swing_diff_5g = 0;
+			out = 0x200; /* 0 dB */
+		} else if (swingA == 0x01) {
+			if (Band == BAND_ON_2_4G)
+				rtldm->swing_diff_2g = -3;
+			else
+				rtldm->swing_diff_5g = -3;
+			out = 0x16A; /*  -3 dB */
+		} else if (swingA == 0x10) {
+			if (Band == BAND_ON_2_4G)
+				rtldm->swing_diff_2g = -6;
+			else
+				rtldm->swing_diff_5g = -6;
+			out = 0x101; /* -6 dB */
+		} else if (swingA == 0x11) {
+			if (Band == BAND_ON_2_4G)
+				rtldm->swing_diff_2g = -9;
+			else
+				rtldm->swing_diff_5g = -9;
+			out = 0x0B6; /* -9 dB */
+		}
+
+		/* 3 Path-B */
+		if (swingB == 0x00) {
+			if (Band == BAND_ON_2_4G)
+				rtldm->swing_diff_2g = 0;
+			else
+				rtldm->swing_diff_5g = 0;
+			out = 0x200; /* 0 dB */
+		} else if (swingB == 0x01) {
+			if (Band == BAND_ON_2_4G)
+				rtldm->swing_diff_2g = -3;
+			else
+				rtldm->swing_diff_5g = -3;
+			out = 0x16A; /* -3 dB */
+		} else if (swingB == 0x10) {
+			if (Band == BAND_ON_2_4G)
+				rtldm->swing_diff_2g = -6;
+			else
+				rtldm->swing_diff_5g = -6;
+			out = 0x101; /* -6 dB */
+		} else if (swingB == 0x11) {
+			if (Band == BAND_ON_2_4G)
+				rtldm->swing_diff_2g = -9;
+			else
+				rtldm->swing_diff_5g = -9;
+			out = 0x0B6; /* -9 dB */
+		}
+	}
+
+	/* DBG_871X("<=== PHY_GetTxBBSwing_8812A, out = 0x%X\n", out); */
+
+	return out;
+}
+
+
+/*
+ * ULLI : in rtlwifi check is needed for swithing band
+ * ULLI : is in rtl8821au_phy_switch_wirelessband()
+ * */
+
+bool phy_SwBand8812(struct rtl_priv *rtlpriv, uint8_t channelToSW)
+{
+	uint8_t			u1Btmp;
+	bool		ret_value = true;
+	uint8_t			Band = BAND_ON_5G, BandToSW;
+
+	u1Btmp = rtl_read_byte(rtlpriv, REG_CCK_CHECK_8812);
+	if(u1Btmp & BIT(7))
+		Band = BAND_ON_5G;
+	else
+		Band = BAND_ON_2_4G;
+
+	/* Use current channel to judge Band Type and switch Band if need. */
+	if(channelToSW > 14) {
+		BandToSW = BAND_ON_5G;
+	} else {
+		BandToSW = BAND_ON_2_4G;
+	}
+
+	if(BandToSW != Band)
+		rtl8821au_phy_switch_wirelessband(rtlpriv,BandToSW);
+
+	return ret_value;
+}
+static void phy_SetRFEReg8812(struct rtl_priv *rtlpriv,uint8_t Band)
+{
+	struct rtl_hal *rtlhal = rtl_hal(rtlpriv);
+	u8			u1tmp = 0;
+
+	if(Band == BAND_ON_2_4G) {
+		switch(rtlhal->rfe_type){
+		case 0: case 1: case 2:
+			rtl_set_bbreg(rtlpriv, rA_RFE_Pinmux_Jaguar,bMaskDWord, 0x77777777);
+			rtl_set_bbreg(rtlpriv, rB_RFE_Pinmux_Jaguar,bMaskDWord, 0x77777777);
+			rtl_set_bbreg(rtlpriv, rA_RFE_Inv_Jaguar,bMask_RFEInv_Jaguar, 0x000);
+			rtl_set_bbreg(rtlpriv, rB_RFE_Inv_Jaguar,bMask_RFEInv_Jaguar, 0x000);
+			break;
+		case 3:
+			rtl_set_bbreg(rtlpriv, rA_RFE_Pinmux_Jaguar,bMaskDWord, 0x54337770);
+			rtl_set_bbreg(rtlpriv, rB_RFE_Pinmux_Jaguar,bMaskDWord, 0x54337770);
+			rtl_set_bbreg(rtlpriv, rA_RFE_Inv_Jaguar,bMask_RFEInv_Jaguar, 0x010);
+			rtl_set_bbreg(rtlpriv, rB_RFE_Inv_Jaguar,bMask_RFEInv_Jaguar, 0x010);
+			rtl_set_bbreg(rtlpriv, r_ANTSEL_SW_Jaguar,0x00000303, 0x1);
+			break;
+		case 4:
+			rtl_set_bbreg(rtlpriv, rA_RFE_Pinmux_Jaguar,bMaskDWord, 0x77777777);
+			rtl_set_bbreg(rtlpriv, rB_RFE_Pinmux_Jaguar,bMaskDWord, 0x77777777);
+			rtl_set_bbreg(rtlpriv, rA_RFE_Inv_Jaguar,bMask_RFEInv_Jaguar, 0x001);
+			rtl_set_bbreg(rtlpriv, rB_RFE_Inv_Jaguar,bMask_RFEInv_Jaguar, 0x001);
+			break;
+		case 5:
+			/* if(BT_IsBtExist(rtlpriv)) */
+			{
+				/* rtl_write_word(rtlpriv, rA_RFE_Pinmux_Jaguar, 0x7777); */
+				rtl_write_byte(rtlpriv, rA_RFE_Pinmux_Jaguar+2, 0x77);
+			}
+			/* else */
+				/* rtl_set_bbreg(rtlpriv, rA_RFE_Pinmux_Jaguar,bMaskDWord, 0x77777777); */
+
+			rtl_set_bbreg(rtlpriv, rB_RFE_Pinmux_Jaguar,bMaskDWord, 0x77777777);
+
+			/* if(BT_IsBtExist(rtlpriv)) */
+			{
+				/*
+				 * u1tmp = rtl_read_byte(rtlpriv, rA_RFE_Inv_Jaguar+2);
+				 * rtl_write_byte(rtlpriv, rA_RFE_Inv_Jaguar+2,  (u1tmp &0x0f));
+				 */
+				u1tmp = rtl_read_byte(rtlpriv, rA_RFE_Inv_Jaguar+3);
+				rtl_write_byte(rtlpriv, rA_RFE_Inv_Jaguar+3,  (u1tmp &= ~BIT(0)));
+			}
+			/* else */
+				/* rtl_set_bbreg(rtlpriv, rA_RFE_Inv_Jaguar, bMask_RFEInv_Jaguar, 0x000); */
+
+			rtl_set_bbreg(rtlpriv, rB_RFE_Inv_Jaguar, bMask_RFEInv_Jaguar, 0x000);
+			break;
+		default:
+			break;
+		}
+	} else {
+		switch(rtlhal->rfe_type){
+		case 0:
+			rtl_set_bbreg(rtlpriv, rA_RFE_Pinmux_Jaguar,bMaskDWord, 0x77337717);
+			rtl_set_bbreg(rtlpriv, rB_RFE_Pinmux_Jaguar,bMaskDWord, 0x77337717);
+			rtl_set_bbreg(rtlpriv, rA_RFE_Inv_Jaguar,bMask_RFEInv_Jaguar, 0x010);
+			rtl_set_bbreg(rtlpriv, rB_RFE_Inv_Jaguar,bMask_RFEInv_Jaguar, 0x010);
+			break;
+		case 1:
+			rtl_set_bbreg(rtlpriv, rA_RFE_Pinmux_Jaguar,bMaskDWord, 0x77337717);
+			rtl_set_bbreg(rtlpriv, rB_RFE_Pinmux_Jaguar,bMaskDWord, 0x77337717);
+			rtl_set_bbreg(rtlpriv, rA_RFE_Inv_Jaguar,bMask_RFEInv_Jaguar, 0x000);
+			rtl_set_bbreg(rtlpriv, rB_RFE_Inv_Jaguar,bMask_RFEInv_Jaguar, 0x000);
+			break;
+		case 2: case 4:
+			rtl_set_bbreg(rtlpriv, rA_RFE_Pinmux_Jaguar,bMaskDWord, 0x77337777);
+			rtl_set_bbreg(rtlpriv, rB_RFE_Pinmux_Jaguar,bMaskDWord, 0x77337777);
+			rtl_set_bbreg(rtlpriv, rA_RFE_Inv_Jaguar,bMask_RFEInv_Jaguar, 0x010);
+			rtl_set_bbreg(rtlpriv, rB_RFE_Inv_Jaguar,bMask_RFEInv_Jaguar, 0x010);
+			break;
+		case 3:
+			rtl_set_bbreg(rtlpriv, rA_RFE_Pinmux_Jaguar,bMaskDWord, 0x54337717);
+			rtl_set_bbreg(rtlpriv, rB_RFE_Pinmux_Jaguar,bMaskDWord, 0x54337717);
+			rtl_set_bbreg(rtlpriv, rA_RFE_Inv_Jaguar,bMask_RFEInv_Jaguar, 0x010);
+			rtl_set_bbreg(rtlpriv, rB_RFE_Inv_Jaguar,bMask_RFEInv_Jaguar, 0x010);
+			rtl_set_bbreg(rtlpriv, r_ANTSEL_SW_Jaguar,0x00000303, 0x1);
+			break;
+		case 5:
+			//if(BT_IsBtExist(rtlpriv))
+			{
+				//rtl_write_word(rtlpriv, rA_RFE_Pinmux_Jaguar, 0x7777);
+				if(rtlhal->external_pa_5g)
+					rtl_write_byte(rtlpriv, rA_RFE_Pinmux_Jaguar+2, 0x33);
+				else
+					rtl_write_byte(rtlpriv, rA_RFE_Pinmux_Jaguar+2, 0x73);
+			}
+#if 0
+			else
+			{
+				if (rtlhal->external_pa_5g)
+					rtl_set_bbreg(rtlpriv, rA_RFE_Pinmux_Jaguar,bMaskDWord, 0x77337777);
+				else
+					rtl_set_bbreg(rtlpriv, rA_RFE_Pinmux_Jaguar,bMaskDWord, 0x77737777);
+			}
+#endif
+
+			if (rtlhal->external_pa_5g)
+				rtl_set_bbreg(rtlpriv, rB_RFE_Pinmux_Jaguar,bMaskDWord, 0x77337777);
+			else
+				rtl_set_bbreg(rtlpriv, rB_RFE_Pinmux_Jaguar,bMaskDWord, 0x77737777);
+
+			/* if(BT_IsBtExist(rtlpriv)) */
+			{
+				/*
+				 * u1tmp = rtl_read_byte(rtlpriv, rA_RFE_Inv_Jaguar+2);
+				 * rtl_write_byte(rtlpriv, rA_RFE_Inv_Jaguar+2,  (u1tmp &0x0f));
+				 */
+				u1tmp = rtl_read_byte(rtlpriv, rA_RFE_Inv_Jaguar+3);
+				rtl_write_byte(rtlpriv, rA_RFE_Inv_Jaguar+3,  (u1tmp |= BIT(0)));
+			}
+			/* else */
+				/* rtl_set_bbreg(rtlpriv, rA_RFE_Inv_Jaguar, bMask_RFEInv_Jaguar, 0x010); */
+
+			rtl_set_bbreg(rtlpriv, rB_RFE_Inv_Jaguar, bMask_RFEInv_Jaguar, 0x010);
+			break;
+		default:
+			break;
+		}
+	}
+}
+
+void rtl8821au_phy_switch_wirelessband(struct rtl_priv *rtlpriv, u8 Band)
+{
+	struct rtl_hal *rtlhal = rtl_hal(rtlpriv);
+	uint8_t				currentBand = rtlhal->current_bandtype;
+
+	/* DBG_871X("==>rtl8821au_phy_switch_wirelessband() %s\n", ((Band==0)?"2.4G":"5G")); */
+
+	rtlhal->current_bandtype =(enum band_type)Band;
+
+	if(Band == BAND_ON_2_4G) {	/* 2.4G band */
+
+		/* STOP Tx/Rx */
+		rtl_set_bbreg(rtlpriv, rOFDMCCKEN_Jaguar, bOFDMEN_Jaguar|bCCKEN_Jaguar, 0x00);
+
+		if (IS_HARDWARE_TYPE_8821(rtlhal)) {
+			/* Turn off RF PA and LNA */
+			rtl_set_bbreg(rtlpriv, rA_RFE_Pinmux_Jaguar, 0xF000, 0x7);	/* 0xCB0[15:12] = 0x7 (LNA_On) */
+			rtl_set_bbreg(rtlpriv, rA_RFE_Pinmux_Jaguar, 0xF0, 0x7);	/* 0xCB0[7:4] = 0x7 (PAPE_A) */
+		}
+
+		/* AGC table select */
+		if(IS_VENDOR_8821A_MP_CHIP(rtlhal->version))
+			rtl_set_bbreg(rtlpriv, rA_TxScale_Jaguar, 0xF00, 0); // 0xC1C[11:8] = 0
+		else
+			rtl_set_bbreg(rtlpriv, rAGC_table_Jaguar, 0x3, 0);
+
+		if(IS_VENDOR_8812A_TEST_CHIP(rtlhal->version)) {
+			/* r_select_5G for path_A/B */
+			rtl_set_bbreg(rtlpriv, rA_RFE_Jaguar, BIT(12), 0x0);
+			rtl_set_bbreg(rtlpriv, rB_RFE_Jaguar, BIT(12), 0x0);
+
+			/* LANON (5G uses external LNA) */
+			rtl_set_bbreg(rtlpriv, rA_RFE_Jaguar, BIT(15), 0x1);
+			rtl_set_bbreg(rtlpriv, rB_RFE_Jaguar, BIT(15), 0x1);
+		} else if(IS_VENDOR_8812A_MP_CHIP(rtlhal->version)) {
+			if(0 /* GetRegbENRFEType(rtlpriv) */)
+			
+				phy_SetRFEReg8812(rtlpriv, Band);
+			else {
+				/* PAPE_A (bypass RFE module in 2G) */
+				rtl_set_bbreg(rtlpriv, rA_RFE_Pinmux_Jaguar, 0x000000F0, 0x7);
+				rtl_set_bbreg(rtlpriv, rB_RFE_Pinmux_Jaguar, 0x000000F0, 0x7);
+
+				/* PAPE_G (bypass RFE module in 5G) */
+				if (rtlhal->external_pa_2g) {
+					rtl_set_bbreg(rtlpriv, rA_RFE_Pinmux_Jaguar, 0x0000000F, 0x0);
+					rtl_set_bbreg(rtlpriv, rB_RFE_Pinmux_Jaguar, 0x0000000F, 0x0);
+				} else {
+					rtl_set_bbreg(rtlpriv, rA_RFE_Pinmux_Jaguar, 0x0000000F, 0x7);
+					rtl_set_bbreg(rtlpriv, rB_RFE_Pinmux_Jaguar, 0x0000000F, 0x7);
+				}
+
+				/* TRSW bypass RFE moudle in 2G */
+				if (rtlhal->external_lna_2g) {
+					rtl_set_bbreg(rtlpriv, rA_RFE_Pinmux_Jaguar, MASKBYTE2, 0x54);
+					rtl_set_bbreg(rtlpriv, rB_RFE_Pinmux_Jaguar, MASKBYTE2, 0x54);
+				} else {
+					rtl_set_bbreg(rtlpriv, rA_RFE_Pinmux_Jaguar, MASKBYTE2, 0x77);
+					rtl_set_bbreg(rtlpriv, rB_RFE_Pinmux_Jaguar, MASKBYTE2, 0x77);
+				}
+			}
+		}
+
+		update_tx_basic_rate(rtlpriv, WIRELESS_11BG);
+
+		/* cck_enable */
+		rtl_set_bbreg(rtlpriv, rOFDMCCKEN_Jaguar, bOFDMEN_Jaguar|bCCKEN_Jaguar, 0x3);
+
+		/* SYN Setting */
+		if(IS_VENDOR_8812A_TEST_CHIP(rtlhal->version)) 	{
+			rtl_set_rfreg(rtlpriv, RF90_PATH_A, 0xEF, bLSSIWrite_data_Jaguar, 0x40000);
+			rtl_set_rfreg(rtlpriv, RF90_PATH_A, 0x3E, bLSSIWrite_data_Jaguar, 0x00000);
+			rtl_set_rfreg(rtlpriv, RF90_PATH_A, 0x3F, bLSSIWrite_data_Jaguar, 0x0001c);
+			rtl_set_rfreg(rtlpriv, RF90_PATH_A, 0xEF, bLSSIWrite_data_Jaguar, 0x00000);
+			rtl_set_rfreg(rtlpriv, RF90_PATH_A, 0xB5, bLSSIWrite_data_Jaguar, 0x16BFF);
+		}
+
+		/* CCK_CHECK_en */
+		rtl_write_byte(rtlpriv, REG_CCK_CHECK_8812, 0x0);
+	} else {		/* 5G band */
+		u16	count = 0, reg41A = 0;
+
+		if (IS_HARDWARE_TYPE_8821(rtlhal)) {
+			rtl_set_bbreg(rtlpriv, rA_RFE_Pinmux_Jaguar, 0xF000, 0x5);	/* 0xCB0[15:12] = 0x5 (LNA_On) */
+			rtl_set_bbreg(rtlpriv, rA_RFE_Pinmux_Jaguar, 0xF0, 0x4);	/* 0xCB0[7:4] = 0x4 (PAPE_A) */
+		}
+
+		/* CCK_CHECK_en */
+		rtl_write_byte(rtlpriv, REG_CCK_CHECK_8812, 0x80);
+
+		count = 0;
+		reg41A = rtl_read_word(rtlpriv, REG_TXPKT_EMPTY);
+		/* DBG_871X("Reg41A value %d", reg41A); */
+		reg41A &= 0x30;
+		while((reg41A!= 0x30) && (count < 50)) {
+			udelay(50);
+			/* DBG_871X("Delay 50us \n"); */
+
+			reg41A = rtl_read_word(rtlpriv, REG_TXPKT_EMPTY);
+			reg41A &= 0x30;
+			count++;
+			/* DBG_871X("Reg41A value %d", reg41A); */
+		}
+		if(count != 0)
+			RT_TRACE(rtlpriv, COMP_POWER, DBG_LOUD, "rtl8821au_phy_switch_wirelessband(): Switch to 5G Band. Count = %d reg41A=0x%x\n", count, reg41A);
+
+		/* STOP Tx/Rx */
+		rtl_set_bbreg(rtlpriv, rOFDMCCKEN_Jaguar, bOFDMEN_Jaguar|bCCKEN_Jaguar, 0x00);
+
+		/* AGC table select */
+		if (IS_VENDOR_8821A_MP_CHIP(rtlhal->version))
+			rtl_set_bbreg(rtlpriv, rA_TxScale_Jaguar, 0xF00, 1); /* 0xC1C[11:8] = 1 */
+		else
+			rtl_set_bbreg(rtlpriv, rAGC_table_Jaguar, 0x3, 1);
+
+		if(IS_VENDOR_8812A_TEST_CHIP(rtlhal->version)) 	{
+			/* r_select_5G for path_A/B */
+			rtl_set_bbreg(rtlpriv, rA_RFE_Jaguar, BIT(12), 0x1);
+			rtl_set_bbreg(rtlpriv, rB_RFE_Jaguar, BIT(12), 0x1);
+
+			/* LANON (5G uses external LNA) */
+			rtl_set_bbreg(rtlpriv, rA_RFE_Jaguar, BIT(15), 0x0);
+			rtl_set_bbreg(rtlpriv, rB_RFE_Jaguar, BIT(15), 0x0);
+		} else if(IS_VENDOR_8812A_MP_CHIP(rtlhal->version)) {
+			if(0 /* GetRegbENRFEType(rtlpriv) */)
+				phy_SetRFEReg8812(rtlpriv, Band);
+			else {
+				/* PAPE_A (bypass RFE module in 2G) */
+				if (rtlhal->external_pa_5g) {
+					rtl_set_bbreg(rtlpriv, rA_RFE_Pinmux_Jaguar, 0x000000F0, 0x1);
+					rtl_set_bbreg(rtlpriv, rB_RFE_Pinmux_Jaguar, 0x000000F0, 0x1);
+				} else {
+					rtl_set_bbreg(rtlpriv, rA_RFE_Pinmux_Jaguar, 0x000000F0, 0x0);
+					rtl_set_bbreg(rtlpriv, rB_RFE_Pinmux_Jaguar, 0x000000F0, 0x0);
+				}
+
+				/* PAPE_G (bypass RFE module in 5G) */
+				rtl_set_bbreg(rtlpriv, rA_RFE_Pinmux_Jaguar, 0x0000000F, 0x7);
+				rtl_set_bbreg(rtlpriv, rB_RFE_Pinmux_Jaguar, 0x0000000F, 0x7);
+
+				/* TRSW bypass RFE moudle in 2G */
+				if (rtlhal->external_lna_5g) {
+					rtl_set_bbreg(rtlpriv, rA_RFE_Pinmux_Jaguar, MASKBYTE2, 0x54);
+					rtl_set_bbreg(rtlpriv, rB_RFE_Pinmux_Jaguar, MASKBYTE2, 0x54);
+				} else {
+					rtl_set_bbreg(rtlpriv, rA_RFE_Pinmux_Jaguar, MASKBYTE2, 0x77);
+					rtl_set_bbreg(rtlpriv, rB_RFE_Pinmux_Jaguar, MASKBYTE2, 0x77);
+				}
+			}
+		}
+
+		/*
+		 * avoid using cck rate in 5G band
+		 * Set RRSR rate table.
+		 */
+		update_tx_basic_rate(rtlpriv, WIRELESS_11A);
+
+		/* cck_enable */
+		rtl_set_bbreg(rtlpriv, rOFDMCCKEN_Jaguar, bOFDMEN_Jaguar|bCCKEN_Jaguar, 0x2);
+
+		/* SYN Setting */
+		if(IS_VENDOR_8812A_TEST_CHIP(rtlhal->version)) 	{
+			rtl_set_rfreg(rtlpriv, RF90_PATH_A, 0xEF, bLSSIWrite_data_Jaguar, 0x40000);
+			rtl_set_rfreg(rtlpriv, RF90_PATH_A, 0x3E, bLSSIWrite_data_Jaguar, 0x00000);
+			rtl_set_rfreg(rtlpriv, RF90_PATH_A, 0x3F, bLSSIWrite_data_Jaguar, 0x00017);
+			rtl_set_rfreg(rtlpriv, RF90_PATH_A, 0xEF, bLSSIWrite_data_Jaguar, 0x00000);
+			rtl_set_rfreg(rtlpriv, RF90_PATH_A, 0xB5, bLSSIWrite_data_Jaguar, 0x04BFF);
+		}
+
+		/* DBG_871X("==>rtl8821au_phy_switch_wirelessband() BAND_ON_5G settings OFDM index 0x%x\n", pHalData->OFDM_index[RF90_PATH_A]); */
+	}
+
+	/* <20120903, Kordan> Tx BB swing setting for RL6286, asked by Ynlin. */
+	if (IS_NORMAL_CHIP(rtlhal->version) || IS_HARDWARE_TYPE_8821(rtlhal)) {
+		s8	BBDiffBetweenBand = 0;
+		struct rtl_dm	*rtldm = rtl_dm(rtlpriv);
+
+		rtl_set_bbreg(rtlpriv, rA_TxScale_Jaguar, 0xFFE00000,
+					 phy_get_tx_swing_8821au(rtlpriv, (enum band_type)Band, RF90_PATH_A)); // 0xC1C[31:21]
+		rtl_set_bbreg(rtlpriv, rB_TxScale_Jaguar, 0xFFE00000,
+					 phy_get_tx_swing_8821au(rtlpriv, (enum band_type)Band, RF90_PATH_B)); // 0xE1C[31:21]
+
+		/*
+		 *  <20121005, Kordan> When TxPowerTrack is ON, we should take care of the change of BB swing.
+		 *  That is, reset all info to trigger Tx power tracking.
+		 */
+		{
+			if (Band != currentBand) {
+				BBDiffBetweenBand = (rtldm->swing_diff_2g - rtldm->swing_diff_5g);
+				BBDiffBetweenBand = (Band == BAND_ON_2_4G) ? BBDiffBetweenBand : (-1 * BBDiffBetweenBand);
+				rtldm->default_ofdm_index += BBDiffBetweenBand*2;
+			}
+
+			rtl8821au_dm_clean_txpower_tracking_state(rtlpriv);
+		}
+	}
+
+	/* DBG_871X("<==rtl8821au_phy_switch_wirelessband():Switch Band OK.\n"); */
+}
+
+static void _rtl8821au_phy_set_txpower_index(struct rtl_priv *rtlpriv, uint32_t power_index,
+	u8 path, u8 rate)
+{
+	struct rtl_hal *rtlhal = rtl_hal(rtlpriv);
+
+	/*
+	 *  <20120928, Kordan> A workaround in 8812A/8821A testchip, to fix the bug of odd Tx power indexes.
+	 */
+	if ((power_index % 2 == 1) && !IS_NORMAL_CHIP(rtlhal->version))
+		power_index -= 1;
+
+	/* ULLI check register names as in rtlwifi-lib */
+
+	if (path == RF90_PATH_A) {
+		switch (rate) {
+		case MGN_1M:
+			rtl_set_bbreg(rtlpriv, RTXAGC_A_CCK11_CCK1, MASKBYTE0, power_index);
+			break;
+		case MGN_2M:
+			rtl_set_bbreg(rtlpriv, RTXAGC_A_CCK11_CCK1, MASKBYTE1, power_index);
+			break;
+		case MGN_5_5M:
+			rtl_set_bbreg(rtlpriv, RTXAGC_A_CCK11_CCK1, MASKBYTE2, power_index);
+			break;
+		case MGN_11M:
+			rtl_set_bbreg(rtlpriv, RTXAGC_A_CCK11_CCK1, MASKBYTE3, power_index);
+			break;
+
+		case MGN_6M:
+			rtl_set_bbreg(rtlpriv, RTXAGC_A_OFDM18_OFDM6, MASKBYTE0, power_index);
+			break;
+		case MGN_9M:
+			rtl_set_bbreg(rtlpriv, RTXAGC_A_OFDM18_OFDM6, MASKBYTE1, power_index);
+			break;
+		case MGN_12M:
+			rtl_set_bbreg(rtlpriv, RTXAGC_A_OFDM18_OFDM6, MASKBYTE2, power_index);
+			break;
+		case MGN_18M:
+			rtl_set_bbreg(rtlpriv, RTXAGC_A_OFDM18_OFDM6, MASKBYTE3, power_index);
+			break;
+
+		case MGN_24M:
+			rtl_set_bbreg(rtlpriv, RTXAGC_A_OFDM54_OFDM24, MASKBYTE0, power_index);
+			break;
+		case MGN_36M:
+			rtl_set_bbreg(rtlpriv, RTXAGC_A_OFDM54_OFDM24, MASKBYTE1, power_index);
+			break;
+		case MGN_48M:
+			rtl_set_bbreg(rtlpriv, RTXAGC_A_OFDM54_OFDM24, MASKBYTE2, power_index);
+			break;
+		case MGN_54M:
+			rtl_set_bbreg(rtlpriv, RTXAGC_A_OFDM54_OFDM24, MASKBYTE3, power_index);
+			break;
+
+		case MGN_MCS0:
+			rtl_set_bbreg(rtlpriv, RTXAGC_A_MCS03_MCS00, MASKBYTE0, power_index);
+			break;
+		case MGN_MCS1:
+			rtl_set_bbreg(rtlpriv, RTXAGC_A_MCS03_MCS00, MASKBYTE1, power_index);
+			break;
+		case MGN_MCS2:
+			rtl_set_bbreg(rtlpriv, RTXAGC_A_MCS03_MCS00, MASKBYTE2, power_index);
+			break;
+		case MGN_MCS3:
+			rtl_set_bbreg(rtlpriv, RTXAGC_A_MCS03_MCS00, MASKBYTE3, power_index);
+			break;
+
+		case MGN_MCS4:
+			rtl_set_bbreg(rtlpriv, RTXAGC_A_MCS07_MCS04, MASKBYTE0, power_index);
+			break;
+		case MGN_MCS5:
+			rtl_set_bbreg(rtlpriv, RTXAGC_A_MCS07_MCS04, MASKBYTE1, power_index);
+			break;
+		case MGN_MCS6:
+			rtl_set_bbreg(rtlpriv, RTXAGC_A_MCS07_MCS04, MASKBYTE2, power_index);
+			break;
+		case MGN_MCS7:
+			rtl_set_bbreg(rtlpriv, RTXAGC_A_MCS07_MCS04, MASKBYTE3, power_index);
+			break;
+
+		case MGN_MCS8:
+			rtl_set_bbreg(rtlpriv, RTXAGC_A_MCS11_MCS08, MASKBYTE0, power_index);
+			break;
+		case MGN_MCS9:
+			rtl_set_bbreg(rtlpriv, RTXAGC_A_MCS11_MCS08, MASKBYTE1, power_index);
+			break;
+		case MGN_MCS10:
+			rtl_set_bbreg(rtlpriv, RTXAGC_A_MCS11_MCS08, MASKBYTE2, power_index);
+			break;
+		case MGN_MCS11:
+			rtl_set_bbreg(rtlpriv, RTXAGC_A_MCS11_MCS08, MASKBYTE3, power_index);
+			break;
+
+		case MGN_MCS12:
+			rtl_set_bbreg(rtlpriv, RTXAGC_A_MCS15_MCS12, MASKBYTE0, power_index);
+			break;
+		case MGN_MCS13:
+			rtl_set_bbreg(rtlpriv, RTXAGC_A_MCS15_MCS12, MASKBYTE1, power_index);
+			break;
+		case MGN_MCS14:
+			rtl_set_bbreg(rtlpriv, RTXAGC_A_MCS15_MCS12, MASKBYTE2, power_index);
+			break;
+		case MGN_MCS15:
+			rtl_set_bbreg(rtlpriv, RTXAGC_A_MCS15_MCS12, MASKBYTE3, power_index);
+			break;
+
+		case MGN_VHT1SS_MCS0:
+			rtl_set_bbreg(rtlpriv, RTXAGC_A_NSS1INDEX3_NSS1INDEX0, MASKBYTE0, power_index);
+			break;
+		case MGN_VHT1SS_MCS1:
+			rtl_set_bbreg(rtlpriv, RTXAGC_A_NSS1INDEX3_NSS1INDEX0, MASKBYTE1, power_index);
+			break;
+		case MGN_VHT1SS_MCS2:
+			rtl_set_bbreg(rtlpriv, RTXAGC_A_NSS1INDEX3_NSS1INDEX0, MASKBYTE2, power_index);
+			break;
+		case MGN_VHT1SS_MCS3:
+			rtl_set_bbreg(rtlpriv, RTXAGC_A_NSS1INDEX3_NSS1INDEX0, MASKBYTE3, power_index);
+			break;
+
+		case MGN_VHT1SS_MCS4:
+			rtl_set_bbreg(rtlpriv, RTXAGC_A_NSS1INDEX7_NSS1INDEX4, MASKBYTE0, power_index);
+			break;
+		case MGN_VHT1SS_MCS5:
+			rtl_set_bbreg(rtlpriv, RTXAGC_A_NSS1INDEX7_NSS1INDEX4, MASKBYTE1, power_index);
+			break;
+		case MGN_VHT1SS_MCS6:
+			rtl_set_bbreg(rtlpriv, RTXAGC_A_NSS1INDEX7_NSS1INDEX4, MASKBYTE2, power_index);
+			break;
+		case MGN_VHT1SS_MCS7:
+			rtl_set_bbreg(rtlpriv, RTXAGC_A_NSS1INDEX7_NSS1INDEX4, MASKBYTE3, power_index);
+			break;
+
+		case MGN_VHT1SS_MCS8:
+			rtl_set_bbreg(rtlpriv, RTXAGC_A_NSS2INDEX1_NSS1INDEX8, MASKBYTE0, power_index);
+			break;
+		case MGN_VHT1SS_MCS9:
+			rtl_set_bbreg(rtlpriv, RTXAGC_A_NSS2INDEX1_NSS1INDEX8, MASKBYTE1, power_index);
+			break;
+		case MGN_VHT2SS_MCS0:
+			rtl_set_bbreg(rtlpriv, RTXAGC_A_NSS2INDEX1_NSS1INDEX8, MASKBYTE2, power_index);
+			break;
+		case MGN_VHT2SS_MCS1:
+			rtl_set_bbreg(rtlpriv, RTXAGC_A_NSS2INDEX1_NSS1INDEX8, MASKBYTE3, power_index);
+			break;
+
+		case MGN_VHT2SS_MCS2:
+			rtl_set_bbreg(rtlpriv, RTXAGC_A_NSS2INDEX5_NSS2INDEX2, MASKBYTE0, power_index);
+			break;
+		case MGN_VHT2SS_MCS3:
+			rtl_set_bbreg(rtlpriv, RTXAGC_A_NSS2INDEX5_NSS2INDEX2, MASKBYTE1, power_index);
+			break;
+		case MGN_VHT2SS_MCS4:
+			rtl_set_bbreg(rtlpriv, RTXAGC_A_NSS2INDEX5_NSS2INDEX2, MASKBYTE2, power_index);
+			break;
+		case MGN_VHT2SS_MCS5:
+			rtl_set_bbreg(rtlpriv, RTXAGC_A_NSS2INDEX5_NSS2INDEX2, MASKBYTE3, power_index);
+			break;
+
+		case MGN_VHT2SS_MCS6:
+			rtl_set_bbreg(rtlpriv, RTXAGC_A_NSS2INDEX9_NSS2INDEX6, MASKBYTE0, power_index);
+			break;
+		case MGN_VHT2SS_MCS7:
+			rtl_set_bbreg(rtlpriv, RTXAGC_A_NSS2INDEX9_NSS2INDEX6, MASKBYTE1, power_index);
+			break;
+		case MGN_VHT2SS_MCS8:
+			rtl_set_bbreg(rtlpriv, RTXAGC_A_NSS2INDEX9_NSS2INDEX6, MASKBYTE2, power_index);
+			break;
+		case MGN_VHT2SS_MCS9:
+			rtl_set_bbreg(rtlpriv, RTXAGC_A_NSS2INDEX9_NSS2INDEX6, MASKBYTE3, power_index);
+			break;
+
+		default:
+			RT_TRACE(rtlpriv, COMP_POWER, DBG_LOUD, "Invalid Rate!!\n");
+			break;
+		}
+	} else if (path == RF90_PATH_B) {
+		switch (rate) {
+		case MGN_1M:
+			rtl_set_bbreg(rtlpriv, RTXAGC_B_CCK11_CCK1, MASKBYTE0, power_index);
+			break;
+		case MGN_2M:
+			rtl_set_bbreg(rtlpriv, RTXAGC_B_CCK11_CCK1, MASKBYTE1, power_index);
+			break;
+		case MGN_5_5M:
+			rtl_set_bbreg(rtlpriv, RTXAGC_B_CCK11_CCK1, MASKBYTE2, power_index);
+			break;
+		case MGN_11M:
+			rtl_set_bbreg(rtlpriv, RTXAGC_B_CCK11_CCK1, MASKBYTE3, power_index);
+			break;
+
+		case MGN_6M:
+			rtl_set_bbreg(rtlpriv, RTXAGC_B_OFDM18_OFDM6, MASKBYTE0, power_index);
+			break;
+		case MGN_9M:
+			rtl_set_bbreg(rtlpriv, RTXAGC_B_OFDM18_OFDM6, MASKBYTE1, power_index);
+			break;
+		case MGN_12M:
+			rtl_set_bbreg(rtlpriv, RTXAGC_B_OFDM18_OFDM6, MASKBYTE2, power_index);
+			break;
+		case MGN_18M:
+			rtl_set_bbreg(rtlpriv, RTXAGC_B_OFDM18_OFDM6, MASKBYTE3, power_index);
+			break;
+
+		case MGN_24M:
+			rtl_set_bbreg(rtlpriv, RTXAGC_B_OFDM54_OFDM24, MASKBYTE0, power_index);
+			break;
+		case MGN_36M:
+			rtl_set_bbreg(rtlpriv, RTXAGC_B_OFDM54_OFDM24, MASKBYTE1, power_index);
+			break;
+		case MGN_48M:
+			rtl_set_bbreg(rtlpriv, RTXAGC_B_OFDM54_OFDM24, MASKBYTE2, power_index);
+			break;
+		case MGN_54M:
+			rtl_set_bbreg(rtlpriv, RTXAGC_B_OFDM54_OFDM24, MASKBYTE3, power_index);
+			break;
+
+		case MGN_MCS0:
+			rtl_set_bbreg(rtlpriv, RTXAGC_B_MCS03_MCS00, MASKBYTE0, power_index);
+			break;
+		case MGN_MCS1:
+			rtl_set_bbreg(rtlpriv, RTXAGC_B_MCS03_MCS00, MASKBYTE1, power_index);
+			break;
+		case MGN_MCS2:
+			rtl_set_bbreg(rtlpriv, RTXAGC_B_MCS03_MCS00, MASKBYTE2, power_index);
+			break;
+		case MGN_MCS3:
+			rtl_set_bbreg(rtlpriv, RTXAGC_B_MCS03_MCS00, MASKBYTE3, power_index);
+			break;
+
+		case MGN_MCS4:
+			rtl_set_bbreg(rtlpriv, RTXAGC_B_MCS07_MCS04, MASKBYTE0, power_index);
+			break;
+		case MGN_MCS5:
+			rtl_set_bbreg(rtlpriv, RTXAGC_B_MCS07_MCS04, MASKBYTE1, power_index);
+			break;
+		case MGN_MCS6:
+			rtl_set_bbreg(rtlpriv, RTXAGC_B_MCS07_MCS04, MASKBYTE2, power_index);
+			break;
+		case MGN_MCS7:
+			rtl_set_bbreg(rtlpriv, RTXAGC_B_MCS07_MCS04, MASKBYTE3, power_index);
+			break;
+
+		case MGN_MCS8:
+			rtl_set_bbreg(rtlpriv, RTXAGC_B_MCS11_MCS08, MASKBYTE0, power_index);
+			break;
+		case MGN_MCS9:
+			rtl_set_bbreg(rtlpriv, RTXAGC_B_MCS11_MCS08, MASKBYTE1, power_index);
+			break;
+		case MGN_MCS10:
+			rtl_set_bbreg(rtlpriv, RTXAGC_B_MCS11_MCS08, MASKBYTE2, power_index);
+			break;
+		case MGN_MCS11:
+			rtl_set_bbreg(rtlpriv, RTXAGC_B_MCS11_MCS08, MASKBYTE3, power_index);
+			break;
+
+		case MGN_MCS12:
+			rtl_set_bbreg(rtlpriv, RTXAGC_B_MCS15_MCS12, MASKBYTE0, power_index);
+			break;
+		case MGN_MCS13:
+			rtl_set_bbreg(rtlpriv, RTXAGC_B_MCS15_MCS12, MASKBYTE1, power_index);
+			break;
+		case MGN_MCS14:
+			rtl_set_bbreg(rtlpriv, RTXAGC_B_MCS15_MCS12, MASKBYTE2, power_index);
+			break;
+		case MGN_MCS15:
+			rtl_set_bbreg(rtlpriv, RTXAGC_B_MCS15_MCS12, MASKBYTE3, power_index);
+			break;
+
+		case MGN_VHT1SS_MCS0:
+			rtl_set_bbreg(rtlpriv, RTXAGC_B_NSS1INDEX3_NSS1INDEX0, MASKBYTE0, power_index);
+			break;
+		case MGN_VHT1SS_MCS1:
+			rtl_set_bbreg(rtlpriv, RTXAGC_B_NSS1INDEX3_NSS1INDEX0, MASKBYTE1, power_index);
+			break;
+		case MGN_VHT1SS_MCS2:
+			rtl_set_bbreg(rtlpriv, RTXAGC_B_NSS1INDEX3_NSS1INDEX0, MASKBYTE2, power_index);
+			break;
+		case MGN_VHT1SS_MCS3:
+			rtl_set_bbreg(rtlpriv, RTXAGC_B_NSS1INDEX3_NSS1INDEX0, MASKBYTE3, power_index);
+			break;
+
+		case MGN_VHT1SS_MCS4:
+			rtl_set_bbreg(rtlpriv, RTXAGC_B_NSS1INDEX7_NSS1INDEX4, MASKBYTE0, power_index);
+			break;
+		case MGN_VHT1SS_MCS5:
+			rtl_set_bbreg(rtlpriv, RTXAGC_B_NSS1INDEX7_NSS1INDEX4, MASKBYTE1, power_index);
+			break;
+		case MGN_VHT1SS_MCS6:
+			rtl_set_bbreg(rtlpriv, RTXAGC_B_NSS1INDEX7_NSS1INDEX4, MASKBYTE2, power_index);
+			break;
+		case MGN_VHT1SS_MCS7:
+			rtl_set_bbreg(rtlpriv, RTXAGC_B_NSS1INDEX7_NSS1INDEX4, MASKBYTE3, power_index);
+			break;
+
+		case MGN_VHT1SS_MCS8:
+			rtl_set_bbreg(rtlpriv, RTXAGC_B_NSS2INDEX1_NSS1INDEX8, MASKBYTE0, power_index);
+			break;
+		case MGN_VHT1SS_MCS9:
+			rtl_set_bbreg(rtlpriv, RTXAGC_B_NSS2INDEX1_NSS1INDEX8, MASKBYTE1, power_index);
+			break;
+		case MGN_VHT2SS_MCS0:
+			rtl_set_bbreg(rtlpriv, RTXAGC_B_NSS2INDEX1_NSS1INDEX8, MASKBYTE2, power_index);
+			break;
+		case MGN_VHT2SS_MCS1:
+			rtl_set_bbreg(rtlpriv, RTXAGC_B_NSS2INDEX1_NSS1INDEX8, MASKBYTE3, power_index);
+			break;
+
+		case MGN_VHT2SS_MCS2:
+			rtl_set_bbreg(rtlpriv, RTXAGC_B_NSS2INDEX5_NSS2INDEX2, MASKBYTE0, power_index);
+			break;
+		case MGN_VHT2SS_MCS3:
+			rtl_set_bbreg(rtlpriv, RTXAGC_B_NSS2INDEX5_NSS2INDEX2, MASKBYTE1, power_index);
+			break;
+		case MGN_VHT2SS_MCS4:
+			rtl_set_bbreg(rtlpriv, RTXAGC_B_NSS2INDEX5_NSS2INDEX2, MASKBYTE2, power_index);
+			break;
+		case MGN_VHT2SS_MCS5:
+			rtl_set_bbreg(rtlpriv, RTXAGC_B_NSS2INDEX5_NSS2INDEX2, MASKBYTE3, power_index);
+			break;
+
+		case MGN_VHT2SS_MCS6:
+			rtl_set_bbreg(rtlpriv, RTXAGC_B_NSS2INDEX9_NSS2INDEX6, MASKBYTE0, power_index);
+			break;
+		case MGN_VHT2SS_MCS7:
+			rtl_set_bbreg(rtlpriv, RTXAGC_B_NSS2INDEX9_NSS2INDEX6, MASKBYTE1, power_index);
+			break;
+		case MGN_VHT2SS_MCS8:
+			rtl_set_bbreg(rtlpriv, RTXAGC_B_NSS2INDEX9_NSS2INDEX6, MASKBYTE2, power_index);
+			break;
+		case MGN_VHT2SS_MCS9:
+			rtl_set_bbreg(rtlpriv, RTXAGC_B_NSS2INDEX9_NSS2INDEX6, MASKBYTE3, power_index);
+			break;
+
+		default:
+			RT_TRACE(rtlpriv, COMP_POWER, DBG_LOUD, "Invalid Rate!!\n");
+			break;
+		}
+	} else {
+		RT_TRACE(rtlpriv, COMP_POWER, DBG_LOUD, "Invalid RFPath!!\n");
+	}
+}
+
+static void _rtl8821au_phy_set_txpower_level_by_path(struct rtl_priv *rtlpriv, uint8_t RFPath,
+	enum CHANNEL_WIDTH BandWidth, uint8_t Channel, uint8_t *Rates,
+	uint8_t	RateArraySize)
+{
+	uint32_t power_index = 0;
+	int	i = 0;
+
+	for (i = 0; i < RateArraySize; ++i) {
+		power_index = _rtl8821au_get_txpower_index(rtlpriv, RFPath, Rates[i], BandWidth, Channel);
+		_rtl8821au_phy_set_txpower_index(rtlpriv, power_index, RFPath, Rates[i]);
+	}
+
+}
+static void _rtl8821au_phy_txpower_training_by_path(struct rtl_priv *rtlpriv,
+	enum CHANNEL_WIDTH BandWidth, uint8_t Channel, uint8_t RfPath)
+{
+	uint8_t	i;
+	uint32_t	PowerLevel, writeData, writeOffset;
+
+	if(RfPath >=  rtlpriv->phy.num_total_rfpath)
+		return;
+
+	writeData = 0;
+
+	if (RfPath == RF90_PATH_A) {
+		PowerLevel = _rtl8821au_get_txpower_index(rtlpriv, RF90_PATH_A, MGN_MCS7, BandWidth, Channel);
+		writeOffset =  rA_TxPwrTraing_Jaguar;
+	} else {
+		PowerLevel = _rtl8821au_get_txpower_index(rtlpriv, RF90_PATH_B, MGN_MCS7, BandWidth, Channel);
+		writeOffset =  rB_TxPwrTraing_Jaguar;
+	}
+
+	for (i = 0; i < 3; i++) {
+		if(i == 0)
+			PowerLevel = PowerLevel - 10;
+		else if(i == 1)
+			PowerLevel = PowerLevel - 8;
+		else
+			PowerLevel = PowerLevel - 6;
+
+		writeData |= (((PowerLevel > 2)?(PowerLevel):2) << (i * 8));
+	}
+
+	rtl_set_bbreg(rtlpriv, writeOffset, 0xffffff, writeData);
+}
+
+
+static void rtl8821au_phy_set_txpower_level_by_path(struct rtl_priv *rtlpriv,
+	uint8_t	channel, uint8_t path)
+{
+	uint8_t	cckRates[]   = {MGN_1M, MGN_2M, MGN_5_5M, MGN_11M};
+	uint8_t	ofdmRates[]  = {MGN_6M, MGN_9M, MGN_12M, MGN_18M, MGN_24M, MGN_36M, MGN_48M, MGN_54M};
+	uint8_t	htRates1T[]  = {MGN_MCS0, MGN_MCS1, MGN_MCS2, MGN_MCS3, MGN_MCS4, MGN_MCS5, MGN_MCS6, MGN_MCS7};
+	uint8_t	htRates2T[]  = {MGN_MCS8, MGN_MCS9, MGN_MCS10, MGN_MCS11, MGN_MCS12, MGN_MCS13, MGN_MCS14, MGN_MCS15};
+	uint8_t	vhtRates1T[] = {MGN_VHT1SS_MCS0, MGN_VHT1SS_MCS1, MGN_VHT1SS_MCS2, MGN_VHT1SS_MCS3, MGN_VHT1SS_MCS4,
+				MGN_VHT1SS_MCS5, MGN_VHT1SS_MCS6, MGN_VHT1SS_MCS7, MGN_VHT1SS_MCS8, MGN_VHT1SS_MCS9};
+	uint8_t	vhtRates2T[] = {MGN_VHT2SS_MCS0, MGN_VHT2SS_MCS1, MGN_VHT2SS_MCS2, MGN_VHT2SS_MCS3, MGN_VHT2SS_MCS4,
+				MGN_VHT2SS_MCS5, MGN_VHT2SS_MCS6, MGN_VHT2SS_MCS7, MGN_VHT2SS_MCS8, MGN_VHT2SS_MCS9};
+
+	//DBG_871X("==>PHY_SetTxPowerLevelByPath8812()\n");
+
+	//if(pMgntInfo->RegNByteAccess == 0)
+	if(rtlpriv->rtlhal.current_bandtype == BAND_ON_2_4G)
+		_rtl8821au_phy_set_txpower_level_by_path(rtlpriv, path, rtlpriv->phy.current_chan_bw, channel,
+								  cckRates, sizeof(cckRates)/sizeof(u8));
+
+	_rtl8821au_phy_set_txpower_level_by_path(rtlpriv, path, rtlpriv->phy.current_chan_bw, channel,
+								  ofdmRates, sizeof(ofdmRates)/sizeof(u8));
+	_rtl8821au_phy_set_txpower_level_by_path(rtlpriv, path, rtlpriv->phy.current_chan_bw, channel,
+								  htRates1T, sizeof(htRates1T)/sizeof(u8));
+	_rtl8821au_phy_set_txpower_level_by_path(rtlpriv, path, rtlpriv->phy.current_chan_bw, channel,
+							  	  vhtRates1T, sizeof(vhtRates1T)/sizeof(u8));
+
+	if ( rtlpriv->phy.num_total_rfpath >= 2) {
+		_rtl8821au_phy_set_txpower_level_by_path(rtlpriv, path, rtlpriv->phy.current_chan_bw, channel,
+							  htRates2T, sizeof(htRates2T)/sizeof(u8));
+		_rtl8821au_phy_set_txpower_level_by_path(rtlpriv, path, rtlpriv->phy.current_chan_bw, channel,
+							  vhtRates2T, sizeof(vhtRates2T)/sizeof(u8));
+	}
+
+	_rtl8821au_phy_txpower_training_by_path(rtlpriv, rtlpriv->phy.current_chan_bw, channel, path);
+
+	/* DBG_871X("<==PHY_SetTxPowerLevelByPath8812()\n"); */
+}
+
+
+
+void PHY_SetTxPowerLevel8812(struct rtl_priv *rtlpriv, uint8_t	Channel)
+{
+	uint8_t	path = 0;
+
+	/* DBG_871X("==>PHY_SetTxPowerLevel8812()\n"); */
+
+	for (path = RF90_PATH_A; path < rtlpriv->phy.num_total_rfpath; ++path) {
+		rtl8821au_phy_set_txpower_level_by_path(rtlpriv, Channel, path);
+	}
+
+	/* DBG_871X("<==PHY_SetTxPowerLevel8812()\n"); */
+}
+
+#undef READ_NEXT_PAIR
+#define READ_NEXT_PAIR(v1, v2, i) do { i += 2; v1 = Array[i]; v2 = Array[i+1]; } while(0)
+
+
+static void _rtl8821au_config_bb_reg(struct rtl_priv *rtlpriv, uint32_t Addr,
+	uint32_t Bitmask, uint32_t Data)
+{
+	if (Addr == 0xfe)
+		msleep(50);
+	else if (Addr == 0xfd)
+		mdelay(5);
+	else if (Addr == 0xfc)
+		mdelay(1);
+	else if (Addr == 0xfb)
+		udelay(50);
+	else if (Addr == 0xfa)
+		udelay(5);
+	else if (Addr == 0xf9)
+		udelay(1);
+
+	rtl_set_bbreg(rtlpriv, Addr, Bitmask, Data);
+
+	/* Add 1us delay between BB/RF register setting. */
+	udelay(1);
+	RT_TRACE(rtlpriv, COMP_INIT, DBG_TRACE, "===> ODM_ConfigBBWithHeaderFile: [PHY_REG] %08X %08X\n", Addr, Data);
+}
+
+
+/******************** */
+
+
+static void _phy_convert_txpower_dbm_to_relative_value(u32 *data, u8 start,
+						       u8 end, u8 base_val)
+{
+	s8 i = 0;
+	u8 temp_value = 0;
+	u32 temp_data = 0;
+
+	/* BaseValue = ( BaseValue & 0xf ) + ( ( BaseValue >> 4 ) & 0xf ) * 10; */
+	/* RT_TRACE(COMP_INIT, DBG_LOUD, ("Corrected BaseValue %u\n", BaseValue ) ); */
+
+	for (i = 3; i >= 0; --i) {
+		if (i >= start && i <= end) {
+			/* Get the exact value */
+			temp_value = (u8) (*data >> (i * 8) ) & 0xF;
+			temp_value += (( u8) (( *data >> (i * 8 + 4)) & 0xF)) * 10;
+
+			/* Change the value to a relative value */
+			temp_value = (temp_value > base_val) ?
+				(temp_value - base_val) :
+				(base_val - temp_value);
+		} else {
+			temp_value = (u8) (*data >> (i * 8)) & 0xFF;
+		}
+
+		temp_data <<= 8;
+		temp_data |= temp_value;
+	}
+
+	*data = temp_data;
+}
+
+/*
+ * 2012/10/18
+ */
+ 
+static s8 _rtl8821au_phy_get_txpower_by_rate(struct rtl_priv *rtlpriv,
+					     u8 Band, u8 RFPath,
+					     u8 TxNum, u8 Rate)
+{
+	struct rtl_phy *rtlphy = rtl_phy(rtlpriv);
+	s8 			value = 0, limit = 0;
+	u8			rateIndex = PHY_GetRateIndexOfTxPowerByRate( Rate );
+
+#if 0
+	if ( ( pAdapter->registrypriv.RegEnableTxPowerByRate == 2 && pHalData->EEPROMRegulatory == 2 ) ||
+		   pAdapter->registrypriv.RegEnableTxPowerByRate == 0 )
+		return 0;
+#endif
+	if (Band != BAND_ON_2_4G && Band != BAND_ON_5G ) {
+		RT_TRACE(rtlpriv, COMP_IQK, DBG_LOUD, "Invalid band %d in %s\n", Band, __func__);
+		return value;
+	}
+	if (RFPath > RF90_PATH_D) {
+		RT_TRACE(rtlpriv, COMP_IQK, DBG_LOUD, "Invalid RfPath %d in %s\n", RFPath, __func__);
+		return value;
+	}
+	if (TxNum >= RF_MAX_TX_NUM) {
+		RT_TRACE(rtlpriv, COMP_IQK, DBG_LOUD, "Invalid TxNum %d in %s\n", TxNum, __func__);
+		return value;
+	}
+	if (rateIndex >= TX_PWR_BY_RATE_NUM_RATE) {
+		RT_TRACE(rtlpriv, COMP_IQK, DBG_LOUD, "Invalid RateIndex %d in %s\n", rateIndex, __func__);
+		return value;
+	}
+
+	value = rtlphy->tx_power_by_rate_offset[Band][RFPath][TxNum][rateIndex];
+
+	return value;
+
+}
+
+
+static u8 _rtl8821au_phy_get_txpower_by_rate_base(struct rtl_priv *rtlpriv,
+					     u8 band,
+					     u8 path,
+					     u8 txnum, u8 rate_section)
+{
+	struct rtl_phy *rtlphy = rtl_phy(rtlpriv);
+	u8 value = 0;
+
+	if (path > RF90_PATH_D) {
+		RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,
+			 "Invalid Rf Path %d in PHY_GetTxPowerByRateBase()\n", path);
+		return 0;
+	}
+
+	if (band == BAND_ON_2_4G) {
+		switch (rate_section) {
+		case CCK:
+			value = rtlphy->txpwr_by_rate_base_24g[path][txnum][0];
+			break;
+		case OFDM:
+			value = rtlphy->txpwr_by_rate_base_24g[path][txnum][1];
+			break;
+		case HT_MCS0_MCS7:
+			value = rtlphy->txpwr_by_rate_base_24g[path][txnum][2];
+			break;
+		case HT_MCS8_MCS15:
+			value = rtlphy->txpwr_by_rate_base_24g[path][txnum][3];
+			break;
+		case HT_MCS16_MCS23:
+			value = rtlphy->txpwr_by_rate_base_24g[path][txnum][4];
+			break;
+		case HT_MCS24_MCS31:
+			value = rtlphy->txpwr_by_rate_base_24g[path][txnum][5];
+			break;
+		case VHT_1SSMCS0_1SSMCS9:
+			value = rtlphy->txpwr_by_rate_base_24g[path][txnum][6];
+			break;
+		case VHT_2SSMCS0_2SSMCS9:
+			value = rtlphy->txpwr_by_rate_base_24g[path][txnum][7];
+			break;
+		case VHT_3SSMCS0_3SSMCS9:
+			value = rtlphy->txpwr_by_rate_base_24g[path][txnum][8];
+			break;
+		case VHT_4SSMCS0_4SSMCS9:
+			value = rtlphy->txpwr_by_rate_base_24g[path][txnum][9];
+			break;
+		default:
+			RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,
+				 "Invalid RateSection %d in Band 2.4G, Rf Path %d, %dTx in PHY_GetTxPowerByRateBase()\n",
+				 rate_section, path, txnum);
+			break;
+		};
+	} else if (band == BAND_ON_5G) {
+		switch (rate_section) {
+		case OFDM:
+			value = rtlphy->txpwr_by_rate_base_5g[path][txnum][0];
+			break;
+		case HT_MCS0_MCS7:
+			value = rtlphy->txpwr_by_rate_base_5g[path][txnum][1];
+			break;
+		case HT_MCS8_MCS15:
+			value = rtlphy->txpwr_by_rate_base_5g[path][txnum][2];
+			break;
+		case HT_MCS16_MCS23:
+			value = rtlphy->txpwr_by_rate_base_5g[path][txnum][3];
+			break;
+		case HT_MCS24_MCS31:
+			value = rtlphy->txpwr_by_rate_base_5g[path][txnum][4];
+			break;
+		case VHT_1SSMCS0_1SSMCS9:
+			value = rtlphy->txpwr_by_rate_base_5g[path][txnum][5];
+			break;
+		case VHT_2SSMCS0_2SSMCS9:
+			value = rtlphy->txpwr_by_rate_base_5g[path][txnum][6];
+			break;
+		case VHT_3SSMCS0_3SSMCS9:
+			value = rtlphy->txpwr_by_rate_base_5g[path][txnum][7];
+			break;
+		case VHT_4SSMCS0_4SSMCS9:
+			value = rtlphy->txpwr_by_rate_base_5g[path][txnum][8];
+			break;
+		default:
+			RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,
+				 "Invalid RateSection %d in Band 5G, Rf Path %d, %dTx in PHY_GetTxPowerByRateBase()\n",
+				 rate_section, path, txnum );
+			break;
+		};
+	} else {
+		RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,
+			 "Invalid Band %d in PHY_GetTxPowerByRateBase()\n",
+			 band);
+	}
+
+	return value;
+}
+
+static void _rtl8821au_phy_set_txpower_by_rate_base(struct rtl_priv *rtlpriv,
+						    u8 band, u8 path, 
+						    u8 rate_section,
+						    u8 txnum, u8 value)
+{
+	struct rtl_phy *rtlphy = rtl_phy(rtlpriv);
+
+	if (path > RF90_PATH_D) {
+		RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,
+			 "Invalid Rf Path %d in phy_SetTxPowerByRatBase()\n",
+			 path);
+		return;
+	}
+
+	if (band == BAND_ON_2_4G) {
+		switch (rate_section) {
+		case CCK:
+			rtlphy->txpwr_by_rate_base_24g[path][txnum][0] = value;
+			break;
+		case OFDM:
+			rtlphy->txpwr_by_rate_base_24g[path][txnum][1] = value;
+			break;
+		case HT_MCS0_MCS7:
+			rtlphy->txpwr_by_rate_base_24g[path][txnum][2] = value;
+			break;
+		case HT_MCS8_MCS15:
+			rtlphy->txpwr_by_rate_base_24g[path][txnum][3] = value;
+			break;
+		case HT_MCS16_MCS23:
+			rtlphy->txpwr_by_rate_base_24g[path][txnum][4] = value;
+			break;
+		case HT_MCS24_MCS31:
+			rtlphy->txpwr_by_rate_base_24g[path][txnum][5] = value;
+			break;
+		case VHT_1SSMCS0_1SSMCS9:
+			rtlphy->txpwr_by_rate_base_24g[path][txnum][6] = value;
+			break;
+		case VHT_2SSMCS0_2SSMCS9:
+			rtlphy->txpwr_by_rate_base_24g[path][txnum][7] = value;
+			break;
+		case VHT_3SSMCS0_3SSMCS9:
+			rtlphy->txpwr_by_rate_base_24g[path][txnum][8] = value;
+			break;
+		case VHT_4SSMCS0_4SSMCS9:
+			rtlphy->txpwr_by_rate_base_24g[path][txnum][9] = value;
+			break;
+		default:
+			RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,
+				 "Invalid RateSection %d in Band 2.4G, Rf Path %d, %dTx in phy_SetTxPowerByRateBase()\n",
+				 rate_section, path, txnum );
+			break;
+		};
+	} else if (band == BAND_ON_5G) {
+		switch (rate_section) {
+		case OFDM:
+			rtlphy->txpwr_by_rate_base_5g[path][txnum][0] = value;
+			break;
+		case HT_MCS0_MCS7:
+			rtlphy->txpwr_by_rate_base_5g[path][txnum][1] = value;
+			break;
+		case HT_MCS8_MCS15:
+			rtlphy->txpwr_by_rate_base_5g[path][txnum][2] = value;
+			break;
+		case HT_MCS16_MCS23:
+			rtlphy->txpwr_by_rate_base_5g[path][txnum][3] = value;
+			break;
+		case HT_MCS24_MCS31:
+			rtlphy->txpwr_by_rate_base_5g[path][txnum][4] = value;
+			break;
+		case VHT_1SSMCS0_1SSMCS9:
+			rtlphy->txpwr_by_rate_base_5g[path][txnum][5] = value;
+			break;
+		case VHT_2SSMCS0_2SSMCS9:
+			rtlphy->txpwr_by_rate_base_5g[path][txnum][6] = value;
+			break;
+		case VHT_3SSMCS0_3SSMCS9:
+			rtlphy->txpwr_by_rate_base_5g[path][txnum][7] = value;
+			break;
+		case VHT_4SSMCS0_4SSMCS9:
+			rtlphy->txpwr_by_rate_base_5g[path][txnum][8] = value;
+			break;
+		default:
+			RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,
+				 "Invalid RateSection %d in Band 5G, Rf Path %d, %dTx in phy_SetTxPowerByRateBase()\n",
+				 rate_section, path, txnum);
+			break;
+		};
+	} else {
+		RT_TRACE(rtlpriv, COMP_INIT, DBG_LOUD,
+			 "Invalid Band %d in phy_SetTxPowerByRateBase()\n",
+			 band);
+	}
+}
+
+static void _rtl8821au_get_values_of_txpwr_by_rate(struct rtl_priv *rtlpriv,
+						   u32 RegAddr, u32 BitMask,
+						   u32 Value, u8 *rate_idx,
+						   s8 *PwrByRateVal, u8 *RateNum)
+{
+	u8 index = 0, i;
+
+	switch (RegAddr) {
+	case rTxAGC_A_Rate18_06:
+	case rTxAGC_B_Rate18_06:
+		rate_idx[0] = PHY_GetRateIndexOfTxPowerByRate(MGN_6M);
+		rate_idx[1] = PHY_GetRateIndexOfTxPowerByRate(MGN_9M);
+		rate_idx[2] = PHY_GetRateIndexOfTxPowerByRate(MGN_12M);
+		rate_idx[3] = PHY_GetRateIndexOfTxPowerByRate(MGN_18M);
+		for (i = 0; i < 4; ++ i ) {
+			PwrByRateVal[i] = (s8)
+					  ((((Value >> (i * 8 + 4)) & 0xF)) * 10 +
+					   ((Value >> (i * 8)) & 0xF ));
+		}
+		*RateNum = 4;
+		break;
+
+	case rTxAGC_A_Rate54_24:
+	case rTxAGC_B_Rate54_24:
+		rate_idx[0] = PHY_GetRateIndexOfTxPowerByRate(MGN_24M);
+		rate_idx[1] = PHY_GetRateIndexOfTxPowerByRate(MGN_36M);
+		rate_idx[2] = PHY_GetRateIndexOfTxPowerByRate(MGN_48M);
+		rate_idx[3] = PHY_GetRateIndexOfTxPowerByRate(MGN_54M);
+		for ( i = 0; i < 4; ++ i ) {
+			PwrByRateVal[i] = (s8)
+					  ((((Value >> (i * 8 + 4)) & 0xF)) * 10 +
+					   ((Value >> (i * 8)) & 0xF ));
+		}
+		*RateNum = 4;
+		break;
+
+	case rTxAGC_A_CCK1_Mcs32:
+		rate_idx[0] = PHY_GetRateIndexOfTxPowerByRate(MGN_1M);
+		PwrByRateVal[0] = (s8) ((((Value >> (8 + 4)) & 0xF)) * 10 +
+					(( Value >> 8 ) & 0xF));
+		*RateNum = 1;
+		break;
+
+	case rTxAGC_B_CCK11_A_CCK2_11:
+		if (BitMask == 0xffffff00) {
+			rate_idx[0] = PHY_GetRateIndexOfTxPowerByRate(MGN_2M);
+			rate_idx[1] = PHY_GetRateIndexOfTxPowerByRate(MGN_5_5M);
+			rate_idx[2] = PHY_GetRateIndexOfTxPowerByRate(MGN_11M);
+			for (i = 1; i < 4; ++ i) {
+				PwrByRateVal[i - 1] = (s8)
+						      ((((Value >> (i * 8 + 4)) & 0xF)) * 10 +
+						       (( Value >> (i * 8)) & 0xF ));
+			}
+			*RateNum = 3;
+		} else if ( BitMask == 0x000000ff ) {
+			rate_idx[0] = PHY_GetRateIndexOfTxPowerByRate(MGN_11M);
+			PwrByRateVal[0] = (s8) ((((Value >> 4 ) & 0xF )) * 10 +
+						(Value & 0xF));
+			*RateNum = 1;
+		}
+		break;
+
+	case rTxAGC_A_Mcs03_Mcs00:
+	case rTxAGC_B_Mcs03_Mcs00:
+		rate_idx[0] = PHY_GetRateIndexOfTxPowerByRate(MGN_MCS0);
+		rate_idx[1] = PHY_GetRateIndexOfTxPowerByRate(MGN_MCS1);
+		rate_idx[2] = PHY_GetRateIndexOfTxPowerByRate(MGN_MCS2);
+		rate_idx[3] = PHY_GetRateIndexOfTxPowerByRate(MGN_MCS3);
+		for (i = 0; i < 4; ++ i) {
+			PwrByRateVal[i] = (s8)
+					  ((((Value >> (i * 8 + 4)) & 0xF)) * 10 +
+					   (( Value >> (i * 8)) & 0xF ));
+		}
+		*RateNum = 4;
+		break;
+
+	case rTxAGC_A_Mcs07_Mcs04:
+	case rTxAGC_B_Mcs07_Mcs04:
+		rate_idx[0] = PHY_GetRateIndexOfTxPowerByRate(MGN_MCS4);
+		rate_idx[1] = PHY_GetRateIndexOfTxPowerByRate(MGN_MCS5);
+		rate_idx[2] = PHY_GetRateIndexOfTxPowerByRate(MGN_MCS6);
+		rate_idx[3] = PHY_GetRateIndexOfTxPowerByRate(MGN_MCS7);
+		for (i = 0; i < 4; ++ i) {
+			PwrByRateVal[i] = (s8)
+					  ((((Value >> (i * 8 + 4)) & 0xF)) * 10 +
+					   ((Value >> (i * 8)) & 0xF));
+		}
+		*RateNum = 4;
+		break;
+
+	case rTxAGC_A_Mcs11_Mcs08:
+	case rTxAGC_B_Mcs11_Mcs08:
+		rate_idx[0] = PHY_GetRateIndexOfTxPowerByRate(MGN_MCS8);
+		rate_idx[1] = PHY_GetRateIndexOfTxPowerByRate(MGN_MCS9);
+		rate_idx[2] = PHY_GetRateIndexOfTxPowerByRate(MGN_MCS10);
+		rate_idx[3] = PHY_GetRateIndexOfTxPowerByRate(MGN_MCS11);
+		for (i = 0; i < 4; ++ i) {
+			PwrByRateVal[i] = (s8)
+					  ((((Value >> (i * 8 + 4)) & 0xF)) * 10 +
+					   ((Value >> (i * 8)) & 0xF));
+		}
+		*RateNum = 4;
+		break;
+
+	case rTxAGC_A_Mcs15_Mcs12:
+	case rTxAGC_B_Mcs15_Mcs12:
+		rate_idx[0] = PHY_GetRateIndexOfTxPowerByRate(MGN_MCS12);
+		rate_idx[1] = PHY_GetRateIndexOfTxPowerByRate(MGN_MCS13);
+		rate_idx[2] = PHY_GetRateIndexOfTxPowerByRate(MGN_MCS14);
+		rate_idx[3] = PHY_GetRateIndexOfTxPowerByRate(MGN_MCS15);
+		for (i = 0; i < 4; ++ i) {
+			PwrByRateVal[i] = (s8) ((((Value >> (i * 8 + 4)) & 0xF)) * 10 +
+						((Value >> (i * 8)) & 0xF));
+		}
+		*RateNum = 4;
+		break;
+
+	case rTxAGC_B_CCK1_55_Mcs32:
+		rate_idx[0] = PHY_GetRateIndexOfTxPowerByRate(MGN_1M);
+		rate_idx[1] = PHY_GetRateIndexOfTxPowerByRate(MGN_2M);
+		rate_idx[2] = PHY_GetRateIndexOfTxPowerByRate(MGN_5_5M);
+		for (i = 1; i < 4; ++ i) {
+			PwrByRateVal[i - 1] = (s8)
+					      ((((Value >> (i * 8 + 4)) & 0xF )) * 10 +
+					       (( Value >> ( i * 8) ) & 0xF ) );
+		}
+		*RateNum = 3;
+		break;
+
+	case 0xC20:
+	case 0xE20:
+	case 0x1820:
+	case 0x1a20:
+		rate_idx[0] = PHY_GetRateIndexOfTxPowerByRate(MGN_1M);
+		rate_idx[1] = PHY_GetRateIndexOfTxPowerByRate(MGN_2M);
+		rate_idx[2] = PHY_GetRateIndexOfTxPowerByRate(MGN_5_5M);
+		rate_idx[3] = PHY_GetRateIndexOfTxPowerByRate(MGN_11M);
+		for (i = 0; i < 4; ++ i) {
+			PwrByRateVal[i] = (s8)
+					  ((((Value >> (i * 8 + 4)) & 0xF)) * 10 +
+					   (( Value >> (i * 8)) & 0xF ));
+		}
+		*RateNum = 4;
+		break;
+
+	case 0xC24:
+	case 0xE24:
+	case 0x1824:
+	case 0x1a24:
+		rate_idx[0] = PHY_GetRateIndexOfTxPowerByRate(MGN_6M);
+		rate_idx[1] = PHY_GetRateIndexOfTxPowerByRate(MGN_9M);
+		rate_idx[2] = PHY_GetRateIndexOfTxPowerByRate(MGN_12M);
+		rate_idx[3] = PHY_GetRateIndexOfTxPowerByRate(MGN_18M);
+		for (i = 0; i < 4; ++ i) {
+			PwrByRateVal[i] = (s8)
+					  ((((Value >> (i * 8 + 4)) & 0xF)) * 10 +
+					   ((Value >> (i * 8)) & 0xF));
+		}
+		*RateNum = 4;
+		break;
+
+	case 0xC28:
+	case 0xE28:
+	case 0x1828:
+	case 0x1a28:
+		rate_idx[0] = PHY_GetRateIndexOfTxPowerByRate(MGN_24M);
+		rate_idx[1] = PHY_GetRateIndexOfTxPowerByRate(MGN_36M);
+		rate_idx[2] = PHY_GetRateIndexOfTxPowerByRate(MGN_48M);
+		rate_idx[3] = PHY_GetRateIndexOfTxPowerByRate(MGN_54M);
+		for (i = 0; i < 4; ++ i) {
+			PwrByRateVal[i] = (s8)
+					  ((((Value >> (i * 8 + 4)) & 0xF)) * 10 +
+					   (( Value >> (i * 8)) & 0xF ));
+		}
+		*RateNum = 4;
+		break;
+
+	case 0xC2C:
+	case 0xE2C:
+	case 0x182C:
+	case 0x1a2C:
+		rate_idx[0] = PHY_GetRateIndexOfTxPowerByRate(MGN_MCS0);
+		rate_idx[1] = PHY_GetRateIndexOfTxPowerByRate(MGN_MCS1);
+		rate_idx[2] = PHY_GetRateIndexOfTxPowerByRate(MGN_MCS2);
+		rate_idx[3] = PHY_GetRateIndexOfTxPowerByRate(MGN_MCS3);
+		for (i = 0; i < 4; ++ i) {
+			PwrByRateVal[i] = (s8)
+					  ((((Value >> (i * 8 + 4)) & 0xF)) * 10 +
+					   ((Value >> (i * 8)) & 0xF ));
+		}
+		*RateNum = 4;
+		break;
+
+	case 0xC30:
+	case 0xE30:
+	case 0x1830:
+	case 0x1a30:
+		rate_idx[0] = PHY_GetRateIndexOfTxPowerByRate(MGN_MCS4);
+		rate_idx[1] = PHY_GetRateIndexOfTxPowerByRate(MGN_MCS5);
+		rate_idx[2] = PHY_GetRateIndexOfTxPowerByRate(MGN_MCS6);
+		rate_idx[3] = PHY_GetRateIndexOfTxPowerByRate(MGN_MCS7);
+		for (i = 0; i < 4; ++ i) {
+			PwrByRateVal[i] = (s8)
+					  ((((Value >> (i * 8 + 4)) & 0xF)) * 10 +
+					   ((Value >> (i * 8)) & 0xF));
+		}
+		*RateNum = 4;
+		break;
+
+	case 0xC34:
+	case 0xE34:
+	case 0x1834:
+	case 0x1a34:
+		rate_idx[0] = PHY_GetRateIndexOfTxPowerByRate(MGN_MCS8);
+		rate_idx[1] = PHY_GetRateIndexOfTxPowerByRate(MGN_MCS9);
+		rate_idx[2] = PHY_GetRateIndexOfTxPowerByRate(MGN_MCS10);
+		rate_idx[3] = PHY_GetRateIndexOfTxPowerByRate(MGN_MCS11);
+		for (i = 0; i < 4; ++ i) {
+			PwrByRateVal[i] = (s8)
+					  ((((Value >> (i * 8 + 4)) & 0xF)) * 10 +
+					   ((Value >> (i * 8)) & 0xF));
+		}
+		*RateNum = 4;
+		break;
+
+	case 0xC38:
+	case 0xE38:
+	case 0x1838:
+	case 0x1a38:
+		rate_idx[0] = PHY_GetRateIndexOfTxPowerByRate(MGN_MCS12);
+		rate_idx[1] = PHY_GetRateIndexOfTxPowerByRate(MGN_MCS13);
+		rate_idx[2] = PHY_GetRateIndexOfTxPowerByRate(MGN_MCS14);
+		rate_idx[3] = PHY_GetRateIndexOfTxPowerByRate(MGN_MCS15);
+		for (i = 0; i < 4; ++ i) {
+			PwrByRateVal[i] = (s8)
+					  ((((Value >> (i * 8 + 4)) & 0xF)) * 10 +
+					   ((Value >> (i * 8)) & 0xF));
+		}
+		*RateNum = 4;
+		break;
+
+	case 0xC3C:
+	case 0xE3C:
+	case 0x183C:
+	case 0x1a3C:
+		rate_idx[0] = PHY_GetRateIndexOfTxPowerByRate(MGN_VHT1SS_MCS0);
+		rate_idx[1] = PHY_GetRateIndexOfTxPowerByRate(MGN_VHT1SS_MCS1);
+		rate_idx[2] = PHY_GetRateIndexOfTxPowerByRate(MGN_VHT1SS_MCS2);
+		rate_idx[3] = PHY_GetRateIndexOfTxPowerByRate(MGN_VHT1SS_MCS3);
+		for (i = 0; i < 4; ++ i) {
+			PwrByRateVal[i] = (s8)
+					  ((((Value >> (i * 8 + 4)) & 0xF)) * 10 +
+					   ((Value >> (i * 8)) & 0xF));
+		}
+		*RateNum = 4;
+		break;
+
+	case 0xC40:
+	case 0xE40:
+	case 0x1840:
+	case 0x1a40:
+		rate_idx[0] = PHY_GetRateIndexOfTxPowerByRate(MGN_VHT1SS_MCS4);
+		rate_idx[1] = PHY_GetRateIndexOfTxPowerByRate(MGN_VHT1SS_MCS5);
+		rate_idx[2] = PHY_GetRateIndexOfTxPowerByRate(MGN_VHT1SS_MCS6);
+		rate_idx[3] = PHY_GetRateIndexOfTxPowerByRate(MGN_VHT1SS_MCS7);
+		for (i = 0; i < 4; ++ i) {
+			PwrByRateVal[i] = (s8)
+					  ((((Value >> (i * 8 + 4)) & 0xF)) * 10 +
+					   ((Value >> (i * 8)) & 0xF ));
+		}
+		*RateNum = 4;
+		break;
+
+	case 0xC44:
+	case 0xE44:
+	case 0x1844:
+	case 0x1a44:
+		rate_idx[0] = PHY_GetRateIndexOfTxPowerByRate(MGN_VHT1SS_MCS8);
+		rate_idx[1] = PHY_GetRateIndexOfTxPowerByRate(MGN_VHT1SS_MCS9);
+		rate_idx[2] = PHY_GetRateIndexOfTxPowerByRate(MGN_VHT2SS_MCS0);
+		rate_idx[3] = PHY_GetRateIndexOfTxPowerByRate(MGN_VHT2SS_MCS1);
+		for (i = 0; i < 4; ++ i) {
+			PwrByRateVal[i] = (s8)
+					  ((((Value >> (i * 8 + 4)) & 0xF )) * 10 +
+					   (( Value >> (i * 8)) & 0xF));
+		}
+		*RateNum = 4;
+		break;
+
+	case 0xC48:
+	case 0xE48:
+	case 0x1848:
+	case 0x1a48:
+		rate_idx[0] = PHY_GetRateIndexOfTxPowerByRate(MGN_VHT2SS_MCS2);
+		rate_idx[1] = PHY_GetRateIndexOfTxPowerByRate(MGN_VHT2SS_MCS3);
+		rate_idx[2] = PHY_GetRateIndexOfTxPowerByRate(MGN_VHT2SS_MCS4);
+		rate_idx[3] = PHY_GetRateIndexOfTxPowerByRate(MGN_VHT2SS_MCS5);
+		for (i = 0; i < 4; ++ i) {
+			PwrByRateVal[i] = (s8)
+					  ((((Value >> (i * 8 + 4)) & 0xF)) * 10 +
+					   ((Value >> (i * 8)) & 0xF ));
+		}
+		*RateNum = 4;
+		break;
+
+	case 0xC4C:
+	case 0xE4C:
+	case 0x184C:
+	case 0x1a4C:
+		rate_idx[0] = PHY_GetRateIndexOfTxPowerByRate(MGN_VHT2SS_MCS6);
+		rate_idx[1] = PHY_GetRateIndexOfTxPowerByRate(MGN_VHT2SS_MCS7);
+		rate_idx[2] = PHY_GetRateIndexOfTxPowerByRate(MGN_VHT2SS_MCS8);
+		rate_idx[3] = PHY_GetRateIndexOfTxPowerByRate(MGN_VHT2SS_MCS9);
+		for ( i = 0; i < 4; ++ i ) {
+			PwrByRateVal[i] = (s8)
+					  (((( Value >> (i * 8 + 4)) & 0xF)) * 10 +
+					   (( Value >> (i * 8)) & 0xF));
+		}
+		*RateNum = 4;
+		break;
+
+	case 0xCD8:
+	case 0xED8:
+	case 0x18D8:
+	case 0x1aD8:
+		rate_idx[0] = PHY_GetRateIndexOfTxPowerByRate(MGN_MCS16);
+		rate_idx[1] = PHY_GetRateIndexOfTxPowerByRate(MGN_MCS17);
+		rate_idx[2] = PHY_GetRateIndexOfTxPowerByRate(MGN_MCS18);
+		rate_idx[3] = PHY_GetRateIndexOfTxPowerByRate(MGN_MCS19);
+		for ( i = 0; i < 4; ++ i ) {
+			PwrByRateVal[i] = (s8)
+					  ((((Value >> (i * 8 + 4)) & 0xF )) * 10 +
+					   ((Value >> (i * 8)) & 0xF ));
+		}
+		*RateNum = 4;
+		break;
+
+	case 0xCDC:
+	case 0xEDC:
+	case 0x18DC:
+	case 0x1aDC:
+		rate_idx[0] = PHY_GetRateIndexOfTxPowerByRate(MGN_MCS20);
+		rate_idx[1] = PHY_GetRateIndexOfTxPowerByRate(MGN_MCS21);
+		rate_idx[2] = PHY_GetRateIndexOfTxPowerByRate(MGN_MCS22);
+		rate_idx[3] = PHY_GetRateIndexOfTxPowerByRate(MGN_MCS23);
+		for ( i = 0; i < 4; ++ i ) {
+			PwrByRateVal[i] = (s8)
+					  ((((Value >> (i * 8 + 4)) & 0xF)) * 10 +
+					   ((Value >> (i * 8)) & 0xF));
+		}
+		*RateNum = 4;
+		break;
+
+	case 0xCE0:
+	case 0xEE0:
+	case 0x18E0:
+	case 0x1aE0:
+		rate_idx[0] = PHY_GetRateIndexOfTxPowerByRate(MGN_VHT3SS_MCS0);
+		rate_idx[1] = PHY_GetRateIndexOfTxPowerByRate(MGN_VHT3SS_MCS1);
+		rate_idx[2] = PHY_GetRateIndexOfTxPowerByRate(MGN_VHT3SS_MCS2);
+		rate_idx[3] = PHY_GetRateIndexOfTxPowerByRate(MGN_VHT3SS_MCS3);
+		for ( i = 0; i < 4; ++ i ) {
+			PwrByRateVal[i] = (s8)
+					  ((((Value >> (i * 8 + 4)) & 0xF)) * 10 +
+					   ((Value >> (i * 8)) & 0xF ));
+		}
+		*RateNum = 4;
+		break;
+
+	case 0xCE4:
+	case 0xEE4:
+	case 0x18E4:
+	case 0x1aE4:
+		rate_idx[0] = PHY_GetRateIndexOfTxPowerByRate(MGN_VHT3SS_MCS4);
+		rate_idx[1] = PHY_GetRateIndexOfTxPowerByRate(MGN_VHT3SS_MCS5);
+		rate_idx[2] = PHY_GetRateIndexOfTxPowerByRate(MGN_VHT3SS_MCS6);
+		rate_idx[3] = PHY_GetRateIndexOfTxPowerByRate(MGN_VHT3SS_MCS7);
+		for ( i = 0; i < 4; ++ i ) {
+			PwrByRateVal[i] = (s8)
+					  ((((Value >> (i * 8 + 4)) & 0xF )) * 10 +
+					   (( Value >> (i * 8)) & 0xF ));
+		}
+		*RateNum = 4;
+		break;
+
+	case 0xCE8:
+	case 0xEE8:
+	case 0x18E8:
+	case 0x1aE8:
+		rate_idx[0] = PHY_GetRateIndexOfTxPowerByRate(MGN_VHT3SS_MCS8);
+		rate_idx[1] = PHY_GetRateIndexOfTxPowerByRate(MGN_VHT3SS_MCS9);
+		for ( i = 0; i < 2; ++ i ) {
+			PwrByRateVal[i] = (s8)
+					  ((((Value >> (i * 8 + 4)) & 0xF )) * 10 +
+					   (( Value >> (i * 8)) & 0xF ));
+		}
+		*RateNum = 4;
+		break;
+
+	default:
+		RT_TRACE(rtlpriv, COMP_POWER, DBG_LOUD,
+			 "Invalid RegAddr 0x%x in %s()\n", RegAddr, __FUNCTION__);
+		break;
+	};
+}
+
+void _rtl8821au_phy_init_tx_power(struct rtl_priv *rtlpriv)
+{
+	struct rtl_phy *rtlphy = rtl_phy(rtlpriv);
+	u8 band, rfpath, txnum = 0, rate_section;
+
+	for (band = BAND_ON_2_4G; band <= BAND_ON_5G; ++band)
+		for (rfpath = 0; rfpath < TX_PWR_BY_RATE_NUM_RF; ++rfpath)
+			for (txnum = 0; txnum < TX_PWR_BY_RATE_NUM_RF; ++txnum)
+				for (rate_section = 0;
+				     rate_section < TX_PWR_BY_RATE_NUM_RATE;
+				     ++rate_section)
+					rtlphy->tx_power_by_rate_offset[band]
+					   [rfpath][txnum][rate_section] = 0;
+
+}
+
+static void _rtl8821au_store_tx_power_by_rate(struct rtl_priv *rtlpriv, 
+					      u32 band, u32 rfpath, u32 txnum,
+					      u32 regaddr, u32 bitmask, u32 data)
+{
+	struct rtl_phy *rtlphy = rtl_phy(rtlpriv);
+
+	u8 i, rate_idx[4], rate_num = 0;
+	s8 pwr_by_rate_val[4];
+
+	_rtl8821au_get_values_of_txpwr_by_rate(rtlpriv, regaddr, bitmask,
+					       data, rate_idx, 
+					       pwr_by_rate_val,
+					       &rate_num);
+
+	if (band != BAND_ON_2_4G && band != BAND_ON_5G ) {
+		RT_TRACE(rtlpriv, COMP_POWER, DBG_LOUD, "Invalid RFPath %d\n", band);
+		return;
+	}
+
+	if (rfpath > RF90_PATH_D) {
+		RT_TRACE(rtlpriv, COMP_POWER, DBG_LOUD, "Invalid RFPath %d\n", rfpath);
+		return;
+	}
+
+	if (txnum > RF90_PATH_D) {
+		RT_TRACE(rtlpriv, COMP_POWER, DBG_LOUD, "Invalid RFPath %d\n", txnum);
+		return;
+	}
+
+	for (i = 0; i < rate_num; ++i) {
+		if (rate_idx[i] == PHY_GetRateIndexOfTxPowerByRate( MGN_VHT2SS_MCS0) ||
+			 rate_idx[i] == PHY_GetRateIndexOfTxPowerByRate( MGN_VHT2SS_MCS1)) {
+			txnum = RF_2TX;
+		}
+		rtlphy->tx_power_by_rate_offset[band][rfpath][txnum][rate_idx[i]] = 
+				pwr_by_rate_val[i];
+	}
+}
+
+bool _rtl8821au_phy_config_bb_with_pgheaderfile(struct rtl_priv *rtlpriv,
+							u8 configtype)
+{
+	struct rtl_hal	*rtlhal = rtl_hal(rtlpriv);
+
+	uint32_t hex = 0;
+	uint32_t i = 0;
+	u16 count = 0;
+	uint32_t    *ptr_array   = NULL;
+
+	/* ULLI : fixed values ?? */
+	u8  platform = ODM_CE;
+	u8 _interface = RTW_USB;
+	u8 board = rtlhal->board_type;
+
+	uint32_t ArrayLen;
+	uint32_t *Array;
+	uint32_t v1 ,v2 ,v3 , v4, v5, v6;
+
+	if (IS_HARDWARE_TYPE_8812AU(rtlhal)) {
+		if (rtlhal->rfe_type == 3 && IS_NORMAL_CHIP(rtlhal->version)) {
+			ArrayLen = RTL8812AU_PHY_REG_PG_ASUS_ARRAY_LEN;
+			Array = RTL8812AU_PHY_REG_PG_ASUS_ARRAY;
+		} else {
+			ArrayLen = RTL8812AU_PHY_REG_PG_ARRAY_LEN;
+			Array = RTL8812AU_PHY_REG_PG_ARRAY;
+		}
+	} else {
+		ArrayLen = RTL8821AU_PHY_REG_PG_ARRAY_LEN;
+		Array = RTL8821AU_PHY_REG_PG_ARRAY;
+	}
+
+	if (configtype != BASEBAND_CONFIG_PHY_REG) {
+		RT_TRACE(rtlpriv, COMP_SEND, DBG_TRACE,
+			 "configtype != BaseBand_Config_PHY_REG\n");
+		return true;
+	}
+	
+	for (i = 0; i < ArrayLen; i += 6 ) {
+		v1 = Array[i];
+		v2 = Array[i+1];
+		v3 = Array[i+2];
+		v4 = Array[i+3];
+		v5 = Array[i+4];
+		v6 = Array[i+5];
+
+		if (v4 == 0xfe)
+			mdelay(50);
+		else if (v4 == 0xfd)
+			mdelay(5);
+		else if (v4 == 0xfc)
+			mdelay(1);
+		else if (v4 == 0xfb)
+			udelay(50);
+		else if (v4 == 0xfa)
+			udelay(5);
+		else if (v4 == 0xf9)
+			udelay(1);
+
+		_rtl8821au_store_tx_power_by_rate(rtlpriv, v1, v2, v3, v4, v5, v6);
+	}
+	return true;
+}
+
+/* **************** */
+
+static void _rtl8821au_phy_init_txpower_limit(struct rtl_priv *rtlpriv)
+{
+	struct rtl_phy *rtlphy = rtl_phy(rtlpriv);
+	uint8_t		i, j, k, l, m;
+
+	/* DBG_871X( "=====> PHY_InitPowerLimitTable()!\n" ); */
+
+	for (i = 0; i < MAX_REGULATION_NUM; ++i) {
+		for (j = 0; j < MAX_2_4G_BANDWITH_NUM; ++j)
+			for (k = 0; k < MAX_2_4G_RATE_SECTION_NUM; ++k)
+				for (m = 0; m < MAX_2_4G_CHANNEL_NUM; ++m)
+					for (l = 0; l <  rtlpriv->phy.num_total_rfpath ;++l)
+						rtlphy->txpwr_limit_2_4g[i][j][k][m][l] = MAX_POWER_INDEX;
+	}
+
+	for (i = 0; i < MAX_REGULATION_NUM; ++i) {
+		for (j = 0; j < MAX_5G_BANDWITH_NUM; ++j)
+			for (k = 0; k < MAX_5G_RATE_SECTION_NUM; ++k)
+				for (m = 0; m < MAX_5G_CHANNEL_NUM; ++m)
+					for (l = 0; l <   rtlpriv->phy.num_total_rfpath ; ++l)
+						rtlphy->txpwr_limit_5g[i][j][k][m][l] = MAX_POWER_INDEX;
+	}
+
+	/* DBG_871X("<===== PHY_InitPowerLimitTable()!\n" ); */
+}
+static u8 _rtl8812au_phy_get_txpower_by_rate_base_index(struct rtl_priv *rtlpriv, enum band_type Band, uint8_t Rate)
+{
+	uint8_t	index = 0;
+	if (Band == BAND_ON_2_4G) {
+		switch (Rate) {
+		case MGN_1M:
+		case MGN_2M:
+		case MGN_5_5M:
+		case MGN_11M:
+			index = 0;
+			break;
+
+		case MGN_6M:
+		case MGN_9M:
+		case MGN_12M:
+		case MGN_18M:
+		case MGN_24M:
+		case MGN_36M:
+		case MGN_48M:
+		case MGN_54M:
+			index = 1;
+			break;
+
+		case MGN_MCS0:
+		case MGN_MCS1:
+		case MGN_MCS2:
+		case MGN_MCS3:
+		case MGN_MCS4:
+		case MGN_MCS5:
+		case MGN_MCS6:
+		case MGN_MCS7:
+			index = 2;
+			break;
+
+		case MGN_MCS8:
+		case MGN_MCS9:
+		case MGN_MCS10:
+		case MGN_MCS11:
+		case MGN_MCS12:
+		case MGN_MCS13:
+		case MGN_MCS14:
+		case MGN_MCS15:
+			index = 3;
+			break;
+
+		default:
+			RT_TRACE(rtlpriv, COMP_POWER, DBG_LOUD, "Wrong rate 0x%x to obtain index in 2.4G in phy_getPowerByRateBaseIndex()\n", Rate );
+			break;
+		}
+	} else if (Band == BAND_ON_5G) {
+		switch (Rate) {
+		case MGN_6M:
+		case MGN_9M:
+		case MGN_12M:
+		case MGN_18M:
+		case MGN_24M:
+		case MGN_36M:
+		case MGN_48M:
+		case MGN_54M:
+			index = 0;
+			break;
+
+		case MGN_MCS0:
+		case MGN_MCS1:
+		case MGN_MCS2:
+		case MGN_MCS3:
+		case MGN_MCS4:
+		case MGN_MCS5:
+		case MGN_MCS6:
+		case MGN_MCS7:
+			index = 1;
+			break;
+
+		case MGN_MCS8:
+		case MGN_MCS9:
+		case MGN_MCS10:
+		case MGN_MCS11:
+		case MGN_MCS12:
+		case MGN_MCS13:
+		case MGN_MCS14:
+		case MGN_MCS15:
+			index = 2;
+			break;
+
+		case MGN_VHT1SS_MCS0:
+		case MGN_VHT1SS_MCS1:
+		case MGN_VHT1SS_MCS2:
+		case MGN_VHT1SS_MCS3:
+		case MGN_VHT1SS_MCS4:
+		case MGN_VHT1SS_MCS5:
+		case MGN_VHT1SS_MCS6:
+		case MGN_VHT1SS_MCS7:
+		case MGN_VHT1SS_MCS8:
+		case MGN_VHT1SS_MCS9:
+			index = 3;
+			break;
+
+		case MGN_VHT2SS_MCS0:
+		case MGN_VHT2SS_MCS1:
+		case MGN_VHT2SS_MCS2:
+		case MGN_VHT2SS_MCS3:
+		case MGN_VHT2SS_MCS4:
+		case MGN_VHT2SS_MCS5:
+		case MGN_VHT2SS_MCS6:
+		case MGN_VHT2SS_MCS7:
+		case MGN_VHT2SS_MCS8:
+		case MGN_VHT2SS_MCS9:
+			index = 4;
+			break;
+
+		default:
+			RT_TRACE(rtlpriv, COMP_POWER, DBG_LOUD, "Wrong rate 0x%x to obtain index in 5G in phy_getPowerByRateBaseIndex()\n", Rate );
+			break;
+		}
+	}
+
+	return index;
+}
+
+void _rtl8812au_phy_cross_reference_ht_and_vht_txpower_limit(struct rtl_priv *rtlpriv)
+{
+	struct rtl_phy *rtlphy = rtl_phy(rtlpriv);
+	u8 regulation, bw, channel, rateSection;
+	s8 tempPwrLmt = 0;
+	
+	for (regulation = 0; regulation < MAX_REGULATION_NUM; ++regulation) {
+		for (bw = 0; bw < MAX_5G_BANDWITH_NUM; ++bw) {
+			for (channel = 0; channel < CHANNEL_MAX_NUMBER_5G; ++channel) {
+				for (rateSection = 0; rateSection < MAX_RATE_SECTION_NUM; ++rateSection) {
+					tempPwrLmt = rtlphy->txpwr_limit_5g[regulation][bw][rateSection][channel][RF90_PATH_A];
+					if (tempPwrLmt == MAX_POWER_INDEX ) {
+						u8	baseSection = 2, refSection = 6;
+						if (bw == 0 || bw == 1) { // 5G 20M 40M VHT and HT can cross reference
+							//DBG_871X("No power limit table of the specified band %d, bandwidth %d, ratesection %d, channel %d, rf path %d\n",
+							//			1, bw, rateSection, channel, ODM_RF_PATH_A );
+							if (rateSection >= 2 && rateSection <= 9) {
+								if (rateSection == 2) {
+									baseSection = 2;
+									refSection = 6;
+								} else if (rateSection == 3) {
+									baseSection = 3;
+									refSection = 7;
+								} else if (rateSection == 4) {
+									baseSection = 4;
+									refSection = 8;
+								} else if (rateSection == 5) {
+									baseSection = 5;
+									refSection = 9;
+								} else if (rateSection == 6) {
+									baseSection = 6;
+									refSection = 2;
+								} else if (rateSection == 7) {
+									baseSection = 7;
+									refSection = 3;
+								} else if (rateSection == 8) {
+									baseSection = 8;
+									refSection = 4;
+								} else if (rateSection == 9) {
+									baseSection = 9;
+									refSection = 5;
+								}
+								rtlphy->txpwr_limit_5g[regulation][bw][baseSection][channel][RF90_PATH_A] = 
+									rtlphy->txpwr_limit_5g[regulation][bw][refSection][channel][RF90_PATH_A];
+							}
+
+							//DBG_871X("use other value %d", tempPwrLmt );
+						}
+					}
+				}
+			}
+		}
+	}
+}
+
+static void _rtl8821au_phy_convert_txpower_limit_to_power_index(struct rtl_priv *rtlpriv)
+{
+	struct rtl_phy *rtlphy = rtl_phy(rtlpriv);
+	u8 BW40PwrBasedBm2_4G = 0x2E, BW40PwrBasedBm5G = 0x2E;
+	u8 regulation, bw, channel, rateSection;	
+	u8 baseIndex2_4G;
+	u8 baseIndex5G;
+	s8 tempValue = 0, tempPwrLmt = 0;
+	u8 rf_path = 0;
+
+	//DBG_871X("=====> PHY_ConvertTxPowerLimitToPowerIndex()\n" );
+
+	_rtl8812au_phy_cross_reference_ht_and_vht_txpower_limit(rtlpriv);
+
+	for (regulation = 0; regulation < MAX_REGULATION_NUM; ++regulation) {
+		for (bw = 0; bw < MAX_2_4G_BANDWITH_NUM; ++bw) {
+			for (channel = 0; channel < CHANNEL_MAX_NUMBER_2G; ++channel) {
+				for (rateSection = 0; rateSection < MAX_RATE_SECTION_NUM; ++rateSection) {
+					tempPwrLmt = rtlphy->txpwr_limit_2_4g[regulation][bw][rateSection][channel][RF90_PATH_A];
+
+					for (rf_path = RF90_PATH_A; rf_path < MAX_RF_PATH_NUM; ++rf_path) {
+						if (rateSection == 5) // HT 4T
+							BW40PwrBasedBm2_4G = _rtl8821au_phy_get_txpower_by_rate_base(rtlpriv, BAND_ON_2_4G, rf_path, RF_4TX, HT_MCS24_MCS31 );
+						else if (rateSection == 4) // HT 3T
+							BW40PwrBasedBm2_4G = _rtl8821au_phy_get_txpower_by_rate_base(rtlpriv, BAND_ON_2_4G, rf_path, RF_3TX, HT_MCS16_MCS23 );
+						else if (rateSection == 3) // HT 2T
+							BW40PwrBasedBm2_4G = _rtl8821au_phy_get_txpower_by_rate_base(rtlpriv, BAND_ON_2_4G, rf_path, RF_2TX, HT_MCS8_MCS15 );
+						else if (rateSection == 2) // HT 1T
+							BW40PwrBasedBm2_4G = _rtl8821au_phy_get_txpower_by_rate_base(rtlpriv, BAND_ON_2_4G, rf_path, RF_1TX, HT_MCS0_MCS7 );
+						else if (rateSection == 1) // OFDM
+							BW40PwrBasedBm2_4G = _rtl8821au_phy_get_txpower_by_rate_base(rtlpriv, BAND_ON_2_4G, rf_path, RF_1TX, OFDM );
+						else if (rateSection == 0 ) // CCK
+							BW40PwrBasedBm2_4G = _rtl8821au_phy_get_txpower_by_rate_base(rtlpriv, BAND_ON_2_4G, rf_path, RF_1TX, CCK );
+
+						if (tempPwrLmt != MAX_POWER_INDEX) {
+							tempValue = tempPwrLmt - BW40PwrBasedBm2_4G;
+							rtlphy->txpwr_limit_2_4g[regulation][bw][rateSection][channel][rf_path] = tempValue;
+						}
+					}
+				}
+			}
+		}
+	}
+	
+	for (regulation = 0; regulation < MAX_REGULATION_NUM; ++regulation) {
+		for (bw = 0; bw < MAX_5G_BANDWITH_NUM; ++bw) {
+			for (channel = 0; channel < CHANNEL_MAX_NUMBER_5G; ++channel) {
+				for (rateSection = 0; rateSection < MAX_RATE_SECTION_NUM; ++rateSection) {	
+					tempPwrLmt = rtlphy->txpwr_limit_5g[regulation][bw][rateSection][channel][RF90_PATH_A];
+
+					for (rf_path = RF90_PATH_A; rf_path < MAX_RF_PATH_NUM; ++rf_path) {
+						if ( rateSection == 9 ) // VHT 4SS
+							BW40PwrBasedBm5G = _rtl8821au_phy_get_txpower_by_rate_base(rtlpriv, BAND_ON_2_4G, rf_path, RF_4TX, VHT_4SSMCS0_4SSMCS9);
+						else if ( rateSection == 8 ) // VHT 3SS
+							BW40PwrBasedBm5G = _rtl8821au_phy_get_txpower_by_rate_base(rtlpriv, BAND_ON_2_4G, rf_path, RF_3TX, VHT_3SSMCS0_3SSMCS9 );
+						else if ( rateSection == 7 ) // VHT 2SS
+							BW40PwrBasedBm5G = _rtl8821au_phy_get_txpower_by_rate_base(rtlpriv, BAND_ON_2_4G, rf_path, RF_2TX, VHT_2SSMCS0_2SSMCS9 );
+						else if ( rateSection == 6 ) // VHT 1SS
+							BW40PwrBasedBm5G = _rtl8821au_phy_get_txpower_by_rate_base(rtlpriv, BAND_ON_2_4G, rf_path, RF_1TX, VHT_1SSMCS0_1SSMCS9 );
+						else if ( rateSection == 5 ) // HT 4T
+							BW40PwrBasedBm5G = _rtl8821au_phy_get_txpower_by_rate_base(rtlpriv, BAND_ON_2_4G, rf_path, RF_4TX, HT_MCS24_MCS31 );
+						else if ( rateSection == 4 ) // HT 3T
+							BW40PwrBasedBm5G = _rtl8821au_phy_get_txpower_by_rate_base(rtlpriv, BAND_ON_2_4G, rf_path, RF_3TX, HT_MCS16_MCS23 );
+						else if ( rateSection == 3 ) // HT 2T
+							BW40PwrBasedBm5G = _rtl8821au_phy_get_txpower_by_rate_base(rtlpriv, BAND_ON_2_4G, rf_path, RF_2TX, HT_MCS8_MCS15 );
+						else if ( rateSection == 2 ) // HT 1T
+							BW40PwrBasedBm5G = _rtl8821au_phy_get_txpower_by_rate_base(rtlpriv, BAND_ON_2_4G, rf_path, RF_1TX, HT_MCS0_MCS7 );
+						else if ( rateSection == 1 ) // OFDM 
+							BW40PwrBasedBm5G = _rtl8821au_phy_get_txpower_by_rate_base(rtlpriv, BAND_ON_2_4G, rf_path, RF_1TX, OFDM );
+
+						if (tempPwrLmt != MAX_POWER_INDEX) {
+							tempValue = tempPwrLmt - BW40PwrBasedBm5G;
+							rtlphy->txpwr_limit_5g[regulation][bw][rateSection][channel][rf_path] = tempValue;
+						}
+					}
+				}
+			}
+		}
+	}
+	//DBG_871X("<===== PHY_ConvertTxPowerLimitToPowerIndex()\n" );
+}
+
+static void phy_InitBBRFRegisterDefinition(struct rtl_priv *rtlpriv)
+{
+	struct rtl_phy *rtlphy = &(rtlpriv->phy);
+
+	/* RF Interface Sowrtware Control */
+	rtlphy->phyreg_def[RF90_PATH_A].rfintfs = rFPGA0_XAB_RFInterfaceSW;	/* 16 LSBs if read 32-bit from 0x870 */
+	rtlphy->phyreg_def[RF90_PATH_B].rfintfs = rFPGA0_XAB_RFInterfaceSW;	/* 16 MSBs if read 32-bit from 0x870 (16-bit for 0x872) */
+
+	/* RF Interface Output (and Enable) */
+	rtlphy->phyreg_def[RF90_PATH_A].rfintfo = rFPGA0_XA_RFInterfaceOE;	/* 16 LSBs if read 32-bit from 0x860 */
+	rtlphy->phyreg_def[RF90_PATH_B].rfintfo = rFPGA0_XB_RFInterfaceOE;	/* 16 LSBs if read 32-bit from 0x864 */
+
+	/* RF Interface (Output and)  Enable */
+	rtlphy->phyreg_def[RF90_PATH_A].rfintfe = rFPGA0_XA_RFInterfaceOE;	/* 16 MSBs if read 32-bit from 0x860 (16-bit for 0x862) */
+	rtlphy->phyreg_def[RF90_PATH_B].rfintfe = rFPGA0_XB_RFInterfaceOE; 	/* 16 MSBs if read 32-bit from 0x864 (16-bit for 0x866) */
+
+	rtlphy->phyreg_def[RF90_PATH_A].rf3wire_offset = rA_LSSIWrite_Jaguar; 	/* LSSI Parameter */
+	rtlphy->phyreg_def[RF90_PATH_B].rf3wire_offset = rB_LSSIWrite_Jaguar;
+
+	rtlphy->phyreg_def[RF90_PATH_A].rfhssi_para2 = rHSSIRead_Jaguar;		/* wire control parameter2 */
+	rtlphy->phyreg_def[RF90_PATH_B].rfhssi_para2 = rHSSIRead_Jaguar;		/* wire control parameter2 */
+
+	/* Tranceiver Readback LSSI/HSPI mode */
+	rtlphy->phyreg_def[RF90_PATH_A].rf_rb = rA_SIRead_Jaguar;
+	rtlphy->phyreg_def[RF90_PATH_B].rf_rb = rB_SIRead_Jaguar;
+	rtlphy->phyreg_def[RF90_PATH_A].rf_rbpi = rA_PIRead_Jaguar;
+	rtlphy->phyreg_def[RF90_PATH_B].rf_rbpi = rB_PIRead_Jaguar;
+
+	/* pHalData->bPhyValueInitReady=true; */
+}
+
+
+/* ULLI : check with _rtl8821ae_phy_config_bb_with_headerfile () */
+
+bool _rtl8821au_phy_config_bb_with_headerfile(struct rtl_priv *rtlpriv,
+						       u8 configtype)
+{
+	struct rtl_hal	*rtlhal = rtl_hal(rtlpriv);
+
+	#define READ_NEXT_PAIR(v1, v2, i) do { i += 2; v1 = Array[i]; v2 = Array[i+1]; } while(0)
+
+	uint32_t     hex         = 0;
+	uint32_t     i           = 0;
+
+	/* ULLI : fixed values ?? */
+	u8  platform = ODM_CE;
+	u8 _interface = RTW_USB;
+	u8 board = rtlhal->board_type;
+
+	uint32_t ArrayLen;
+	uint32_t *Array;
+
+	if (configtype == BASEBAND_CONFIG_PHY_REG) {
+		if (IS_HARDWARE_TYPE_8812AU(rtlhal)) {
+			ArrayLen = RTL8812AU_PHY_REG_ARRAY_LEN;
+			Array = RTL8812AU_PHY_REG_ARRAY;
+		} else {
+			ArrayLen = RTL8821AU_PHY_REG_ARRAY_LEN;
+			Array = RTL8821AU_PHY_REG_ARRAY;
+		}
+
+		hex += board;
+		hex += _interface << 8;
+		hex += platform << 16;
+		hex += 0xFF000000;
+		RT_TRACE(rtlpriv, COMP_INIT, DBG_TRACE, "===> ODM_ReadAndConfig_MP_8821A_PHY_REG, hex = 0x%X\n", hex);
+
+		for (i = 0; i < ArrayLen; i += 2) {
+			uint32_t v1 = Array[i];
+			uint32_t v2 = Array[i+1];
+
+			// This (offset, data) pair meets the condition.
+			if (v1 < 0xCDCDCDCD) {
+				_rtl8821au_config_bb_reg(rtlpriv, v1, bMaskDWord, v2);
+				continue;
+			} else {
+				// This line is the start line of branch.
+				if (!CheckCondition(Array[i], hex)) {
+					// Discard the following (offset, data) pairs.
+					READ_NEXT_PAIR(v1, v2, i);
+				        while (v2 != 0xDEAD && v2 != 0xCDEF &&
+				               v2 != 0xCDCD && i < ArrayLen -2) {
+							READ_NEXT_PAIR(v1, v2, i);
+					}
+					i -= 2; // prevent from for-loop += 2
+				} else {
+					// Configure matched pairs and skip to end of if-else.
+				        READ_NEXT_PAIR(v1, v2, i);
+				        while (v2 != 0xDEAD && v2 != 0xCDEF &&
+				               v2 != 0xCDCD && i < ArrayLen -2) {
+							_rtl8821au_config_bb_reg(rtlpriv, v1, bMaskDWord, v2);
+							READ_NEXT_PAIR(v1, v2, i);
+				        }
+
+				        while (v2 != 0xDEAD && i < ArrayLen -2) {
+						READ_NEXT_PAIR(v1, v2, i);
+				        }
+				}
+			}
+		}
+	} else if (configtype == BASEBAND_CONFIG_AGC_TAB) {
+		struct rtl_hal	*rtlhal = rtl_hal(rtlpriv);
+
+		uint32_t hex = 0;
+		uint32_t i = 0;
+
+		/* ULLI : fixed values ?? */
+		u8  platform = ODM_CE;
+		u8 _interface = RTW_USB;
+		u8 board = rtlhal->board_type;
+
+		uint32_t ArrayLen;
+		uint32_t *Array;
+
+		if (IS_HARDWARE_TYPE_8812AU(rtlhal)) {
+			ArrayLen = RTL8812AU_AGC_TAB_ARRAY_LEN;
+			Array = RTL8812AU_AGC_TAB_ARRAY;
+		} else {
+			ArrayLen = RTL8821AU_AGC_TAB_ARRAY_LEN;
+			Array = RTL8821AU_AGC_TAB_ARRAY;
+		}
+
+		hex += board;
+		hex += _interface << 8;
+		hex += platform << 16;
+		hex += 0xFF000000;
+
+		RT_TRACE(rtlpriv, COMP_INIT, DBG_TRACE, "===> ODM_ReadAndConfig_MP_8821A_AGC_TAB, hex = 0x%X\n", hex);
+
+		for (i = 0; i < ArrayLen; i += 2) {
+			uint32_t v1 = Array[i];
+			uint32_t v2 = Array[i+1];
+
+			// This (offset, data) pair meets the condition.
+			if (v1 < 0xCDCDCDCD ) {
+				rtl_set_bbreg(rtlpriv, v1, bMaskDWord, v2);
+				/* Add 1us delay between BB/RF register setting. */
+				udelay(1);
+
+				continue;
+			} else {
+				// This line is the start line of branch.
+				if (!CheckCondition(Array[i], hex)) {
+					// Discard the following (offset, data) pairs.
+					READ_NEXT_PAIR(v1, v2, i);
+					while (v2 != 0xDEAD && v2 != 0xCDEF &&
+						v2 != 0xCDCD && i < ArrayLen -2) {
+							READ_NEXT_PAIR(v1, v2, i);
+					}
+					i -= 2; // prevent from for-loop += 2
+				} else {
+					// Configure matched pairs and skip to end of if-else.
+					READ_NEXT_PAIR(v1, v2, i);
+					while (v2 != 0xDEAD && v2 != 0xCDEF &&
+						v2 != 0xCDCD && i < ArrayLen -2) {
+							rtl_set_bbreg(rtlpriv, v1, bMaskDWord, v2);
+							/* Add 1us delay between BB/RF register setting. */
+							udelay(1);
+
+							READ_NEXT_PAIR(v1, v2, i);
+					}
+
+					while (v2 != 0xDEAD && i < ArrayLen -2) {
+						READ_NEXT_PAIR(v1, v2, i);
+					}
+				}
+			}
+		}
+	}
+
+	return true;
+}
+
+static int _rtl8821au_phy_bb_with_headerfile(struct rtl_priv *rtlpriv)
+{
+	struct rtl_phy *rtlphy = &(rtlpriv->phy);
+	struct rtl_efuse *efuse = rtl_efuse(rtlpriv);
+	int			rtStatus = _SUCCESS;
+
+	/* DBG_871X("==>phy_BB8812_Config_ParaFile\n"); */
+
+	RT_TRACE(rtlpriv, COMP_POWER, DBG_LOUD, "===> phy_BB8812_Config_ParaFile() EEPROMRegulatory %d\n", efuse->eeprom_regulatory);
+
+	_rtl8821au_phy_init_txpower_limit(rtlpriv);
+
+	if (efuse->eeprom_regulatory == 1) {
+		_rtl8821au_phy_read_and_config_txpwr_lmt(rtlpriv);
+	}
+
+	/* Read PHY_REG.TXT BB INIT!! */
+	rtlpriv->cfg->ops->config_bb_with_headerfile(rtlpriv,
+						     BASEBAND_CONFIG_PHY_REG);
+
+	/* If EEPROM or EFUSE autoload OK, We must config by PHY_REG_PG.txt */
+	/* 1 TODO */
+	if (efuse->autoload_failflag == false) {
+		rtlphy->pwrgroup_cnt = 0;
+
+		rtlpriv->cfg->ops->config_bb_with_pgheaderfile(rtlpriv,
+							       BASEBAND_CONFIG_PHY_REG);
+
+		if (efuse->eeprom_regulatory == 1 )
+			_rtl8821au_phy_convert_txpower_limit_to_power_index(rtlpriv);
+	}
+
+
+	/* BB AGC table Initialization */
+	rtlpriv->cfg->ops->config_bb_with_headerfile(rtlpriv,
+						     BASEBAND_CONFIG_AGC_TAB);
+	return rtStatus;
+}
+
+int rtl8821au_phy_bb_config(struct rtl_priv *rtlpriv)
+{
+	struct rtl_hal *rtlhal = rtl_hal(rtlpriv);
+	struct rtl_efuse *rtlefuse = rtl_efuse(rtlpriv);
+	int	rtStatus = _SUCCESS;
+	uint8_t	TmpU1B=0;
+	uint8_t	crystal_cap;
+
+	phy_InitBBRFRegisterDefinition(rtlpriv);
+
+    	/* tangw check start 20120412 */
+	/* . APLL_EN,,APLL_320_GATEB,APLL_320BIAS,  auto config by hw fsm after pfsm_go (0x4 bit 8) set */
+	TmpU1B = rtl_read_byte(rtlpriv, REG_SYS_FUNC_EN);
+
+	/* ULLI some PCIe code ?? */
+
+	TmpU1B |= FEN_USBA;
+
+	rtl_write_byte(rtlpriv, REG_SYS_FUNC_EN, TmpU1B);
+
+	rtl_write_byte(rtlpriv, REG_SYS_FUNC_EN, (TmpU1B|FEN_BB_GLB_RSTn|FEN_BBRSTB));	/* same with 8812 */
+	/* 6. 0x1f[7:0] = 0x07 PathA RF Power On */
+	rtl_write_byte(rtlpriv, REG_RF_CTRL, 0x07);		/* RF_SDMRSTB,RF_RSTB,RF_EN same with 8723a */
+	/* 7.  PathB RF Power On */
+	rtl_write_byte(rtlpriv, REG_OPT_CTRL_8812+2, 0x7);	/* RF_SDMRSTB,RF_RSTB,RF_EN same with 8723a */
+	/* tangw check end 20120412 */
+
+	/*
+	 * Config BB and AGC
+	 */
+	rtStatus = _rtl8821au_phy_bb_with_headerfile(rtlpriv);
+
+	if (IS_HARDWARE_TYPE_8812(rtlhal)) {
+		/* write 0x2C[30:25] = 0x2C[24:19] = CrystalCap */
+		crystal_cap = rtlefuse->crystalcap & 0x3F;
+		rtl_set_bbreg(rtlpriv, REG_MAC_PHY_CTRL, 0x7FF80000, (crystal_cap | (crystal_cap << 6)));
+	} else if (IS_HARDWARE_TYPE_8821(rtlhal)) {
+		/* 0x2C[23:18] = 0x2C[17:12] = CrystalCap */
+		crystal_cap = rtlefuse->crystalcap & 0x3F;
+		rtl_set_bbreg(rtlpriv, REG_MAC_PHY_CTRL, 0xFFF000, (crystal_cap | (crystal_cap << 6)));
+	}
+
+	rtlpriv->phy.reg_837 = rtl_read_byte(rtlpriv, 0x837);
+
+	return rtStatus;
+
+}
+
+void rtl8821au_phy_sw_chnl_callback(struct rtl_priv *rtlpriv)
+{
+	struct rtl_hal *rtlhal = rtl_hal(rtlpriv);
+
+	uint8_t	path = 0;
+	uint8_t	channel = rtlpriv->phy.current_channel;
+	u32 data;
+
+	if(phy_SwBand8812(rtlpriv, channel) == false)
+		RT_TRACE(rtlpriv, COMP_ERR, DBG_LOUD, "error Chnl %d !\n", channel);
+
+	/* DBG_871X("[BW:CHNL], phy_SwChnl8812(), switch to channel %d !!\n", channel); */
+
+	/* fc_area */
+	if (36 <= channel && channel <= 48)
+		data = 0x494;
+	else if (50 <= channel && channel <= 64)
+		data = 0x453;
+	else if (100 <= channel && channel <= 116)
+		data = 0x452;
+	else if (118 <= channel)
+		data = 0x412;
+	else
+		data = 0x96a;
+
+	rtl_set_bbreg(rtlpriv, rFc_area_Jaguar, 0x1ffe0000, data);
+
+	for (path = 0; path <  rtlpriv->phy.num_total_rfpath; path++) {
+		/* [2.4G] LC Tank */
+		if (IS_VENDOR_8812A_TEST_CHIP(rtlhal->version)) {
+			if (1 <= channel && channel <= 7)
+				rtl_set_rfreg(rtlpriv, path, RF_TxLCTank_Jaguar, bLSSIWrite_data_Jaguar, 0x0017e);
+			else if (8 <= channel && channel <= 14)
+				rtl_set_rfreg(rtlpriv, path, RF_TxLCTank_Jaguar, bLSSIWrite_data_Jaguar, 0x0013e);
+		}
+
+		/* RF_MOD_AG */
+		if (36 <= channel && channel <= 64)
+			data = 0x101; //5'b00101);
+		else if (100 <= channel && channel <= 140)
+			data = 0x301; //5'b01101);
+		else if (140 < channel)
+			data = 0x501; //5'b10101);
+		else
+			data = 0x000; //5'b00000);
+
+		rtl_set_rfreg(rtlpriv, path, RF_CHNLBW_Jaguar,
+			      BIT(18)|BIT(17)|BIT(16)|BIT(9)|BIT(8), data);
+
+		/* <20121109, Kordan> A workaround for 8812A only. */
+		rtl8812au_fixspur(rtlpriv, rtlpriv->phy.current_chan_bw, channel);
+
+		rtl_set_rfreg(rtlpriv, path, RF_CHNLBW_Jaguar, MASKBYTE0, channel);
+
+		/* <20130104, Kordan> APK for MP chip is done on initialization from folder. */
+		if (IS_HARDWARE_TYPE_8811AU(rtlhal) &&
+		    (!IS_NORMAL_CHIP(rtlhal->version)) && channel > 14 ) {
+			/* <20121116, Kordan> For better result of APK. Asked by AlexWang. */
+			if (36 <= channel && channel <= 64)
+				rtl_set_rfreg(rtlpriv, path, RF_APK_Jaguar, bRFRegOffsetMask, 0x710E7);
+			else if (100 <= channel && channel <= 140)
+				rtl_set_rfreg(rtlpriv, path, RF_APK_Jaguar, bRFRegOffsetMask, 0x716E9);
+			else
+				rtl_set_rfreg(rtlpriv, path, RF_APK_Jaguar, bRFRegOffsetMask, 0x714E9);
+		}
+	}
+}
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/rtl8821au/phy.h linux-4.9.8821au/drivers/staging/rtl8821au/rtl8821au/phy.h
--- linux-4.9/drivers/staging/rtl8821au/rtl8821au/phy.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/rtl8821au/phy.h	2016-12-11 19:48:25.183645006 -0600
@@ -0,0 +1,52 @@
+#ifndef __RTL8821AU_PHY_H__
+#define __RTL8821AU_PHY_H__
+
+u32 rtl8821au_phy_query_bb_reg(struct rtl_priv *rtlpriv, u32 RegAddr, u32 BitMask);
+void rtl8821au_phy_set_bb_reg(struct rtl_priv *	rtlpriv, u32 RegAddr, u32 BitMask, u32 Data);
+u32 rtl8821au_phy_query_rf_reg(struct rtl_priv *rtlpriv, u32 eRFPath, u32 RegAddr, u32 BitMask);
+void rtl8821au_phy_set_rf_reg(struct rtl_priv *rtlpriv, u32 eRFPath, u32 RegAddr, 
+	u32 BitMask, u32 Data);
+bool _rtl8821au_phy_config_bb_with_headerfile(struct rtl_priv *rtlpriv,
+						       u8 configtype);
+bool _rtl8821au_phy_config_bb_with_pgheaderfile(struct rtl_priv *rtlpriv,
+							u8 configtype);
+void rtl8821au_phy_set_bw_mode_callback(struct rtl_priv *rtlpriv);
+void rtl8812au_phy_iq_calibrate(struct rtl_priv *rtlpriv, bool bReCovery);
+
+							
+void rtl8821au_phy_iq_calibrate(struct rtl_priv *rtlpriv, bool bReCovery);
+
+
+void _rtl8821au_phy_config_mac_with_headerfile(struct rtl_priv *rtlpriv);
+
+bool rtl8821au_phy_config_rf_with_headerfile(struct rtl_priv *rtlpriv, enum radio_path eRFPath);
+bool rtl8812au_phy_config_rf_with_headerfile(struct rtl_priv *rtlpriv, enum radio_path eRFPath);
+void rtl8821au_phy_switch_wirelessband(struct rtl_priv *rtlpriv, u8 Band);
+void rtl8821au_phy_sw_chnl_callback(struct rtl_priv *rtlpriv);
+int rtl8821au_phy_bb_config(struct rtl_priv *rtlpriv);
+
+
+uint32_t phy_get_tx_swing_8821au(struct rtl_priv *rtlpriv, enum band_type Band,
+	uint8_t	RFPath);
+	
+enum _ANT_DIV_TYPE {
+	NO_ANTDIV		= 0xFF,
+	CG_TRX_HW_ANTDIV	= 0x01,
+	CGCS_RX_HW_ANTDIV 	= 0x02,
+	FIXED_HW_ANTDIV		= 0x03,
+	CG_TRX_SMART_ANTDIV	= 0x04,
+	CGCS_RX_SW_ANTDIV	= 0x05,
+	S0S1_HW_ANTDIV          = 0x06, //8723B intrnal switch S0 S1
+};
+
+enum baseband_config_type {
+	BASEBAND_CONFIG_PHY_REG = 0,
+	BASEBAND_CONFIG_AGC_TAB = 1,
+};
+	
+/* Not in rtlwifi */
+
+void	PHY_SetTxPowerLevel8812(struct rtl_priv *rtlpriv, uint8_t Channel);
+bool phy_SwBand8812(struct rtl_priv *rtlpriv, uint8_t channelToSW);
+
+#endif
diff -Naur linux-4.9/drivers/staging/rtl8821au/rtl8821au/quirks.c linux-4.9.8821au/drivers/staging/rtl8821au/rtl8821au/quirks.c
--- linux-4.9/drivers/staging/rtl8821au/rtl8821au/quirks.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/rtl8821au/quirks.c	2016-12-11 19:48:25.183645006 -0600
@@ -0,0 +1,104 @@
+/*
+ * RTL8821AU quirks
+ *
+ * stupipity found around the USB3 issue
+ *
+ * So USB3 on RTL8821AU  is only for *power* ??
+ *
+ */
+
+/*
+ * Found on a MT7612U device
+ * this is a 'true' USB3 wifi device
+ * plugged in a USB2 HUB/Port
+
+Binary Object Store Descriptor:
+  bLength                 5
+  bDescriptorType        15
+  wTotalLength           22
+  bNumDeviceCaps          2
+  USB 2.0 Extension Device Capability:
+    bLength                 7
+    bDescriptorType        16
+    bDevCapabilityType      2
+    bmAttributes   0x0000f41e
+      BESL Link Power Management (LPM) Supported
+    BESL value     1024 us 
+    Deep BESL value    61440 us 
+  SuperSpeed USB Device Capability:
+    bLength                10
+    bDescriptorType        16
+    bDevCapabilityType      3
+    bmAttributes         0x00
+    wSpeedsSupported   0x000e
+      Device can operate at Full Speed (12Mbps)
+      Device can operate at High Speed (480Mbps)
+      Device can operate at SuperSpeed (5Gbps)
+    bFunctionalitySupport   1
+      Lowest fully-functional device speed is Full Speed (12Mbps)
+    bU1DevExitLat          10 micro seconds
+    bU2DevExitLat         180 micro seconds
+can't get debug descriptor: Resource temporarily unavailable
+ */
+ 
+/*
+ * This is the *only* thing I get from the RTL8821AU devices
+ * which are supposed to be USB3
+
+Device Qualifier (for other device speed):
+  bLength                10
+  bDescriptorType         6
+  bcdUSB               2.00
+  bDeviceClass            0 
+  bDeviceSubClass         0 
+  bDeviceProtocol         0 
+  bMaxPacketSize0        64
+  bNumConfigurations      1
+
+*/
+
+#ifdef CONFIG_RTLWIFI
+
+#include <../drivers/net/wireless/realtek/rtlwifi/wifi.h>
+#include <../drivers/net/wireless/realtek/rtlwifi/base.h>
+
+#else
+
+#include <drv_types.h>
+#include "dm.h"
+#include "phy.h"
+#include "reg.h"
+#include "fw.h"
+#include "quirks.h"
+
+#endif
+
+#define IS_HIGH_SPEED_USB(udev) \
+		((USB_SPEED_HIGH == (udev)->usb_speed) ? true : false)
+
+#define IS_SUPER_SPEED_USB(udev) \
+		((USB_SPEED_SUPER == (udev)->usb_speed) ? true : false)
+
+
+bool usb_reprobe_to_usb3(struct rtl_priv *rtlpriv)
+{
+	struct rtl_usb *rtlusb = rtl_usbdev(rtlpriv);
+	int ret = false;
+
+	if (IS_HIGH_SPEED_USB(rtlusb)) {
+		if ((rtl_read_byte(rtlpriv, 0x74) & (BIT(2)|BIT(3))) != BIT(3)) {
+			rtl_write_byte(rtlpriv, 0x74, 0x8);
+			rtl_write_byte(rtlpriv, 0x70, 0x2);
+			rtl_write_byte(rtlpriv, 0x3e, 0x1);
+			rtl_write_byte(rtlpriv, 0x3d, 0x3);
+			/* usb disconnect */
+			rtl_write_byte(rtlpriv, 0x5, 0x80);
+			ret = true;
+		}
+	} else if (IS_SUPER_SPEED_USB(rtlusb))	{
+		rtl_write_byte(rtlpriv, 0x70, rtl_read_byte(rtlpriv, 0x70) & (~BIT(1)));
+		rtl_write_byte(rtlpriv, 0x3e, rtl_read_byte(rtlpriv, 0x3e) & (~BIT(0)));
+	}
+
+	return ret;
+}
diff -Naur linux-4.9/drivers/staging/rtl8821au/rtl8821au/quirks.h linux-4.9.8821au/drivers/staging/rtl8821au/rtl8821au/quirks.h
--- linux-4.9/drivers/staging/rtl8821au/rtl8821au/quirks.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/rtl8821au/quirks.h	2016-12-11 19:48:25.183645006 -0600
@@ -0,0 +1,6 @@
+#ifndef __RTL8821AU_QUIRKS_H__
+#define __RTL8821AU_QUIRKS_H__
+
+bool usb_reprobe_to_usb3(struct rtl_priv *rtlpriv);
+
+#endif
diff -Naur linux-4.9/drivers/staging/rtl8821au/rtl8821au/reg.h linux-4.9.8821au/drivers/staging/rtl8821au/rtl8821au/reg.h
--- linux-4.9/drivers/staging/rtl8821au/rtl8821au/reg.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/rtl8821au/reg.h	2016-12-11 19:48:25.183645006 -0600
@@ -0,0 +1,495 @@
+#ifndef __RTL8821AU_REG_H__
+#define __RTL8821AU_REG_H__
+
+/* ULLI : look in wifi.h -> MASKLWORD */
+
+
+//for PutRegsetting & GetRegSetting BitMask
+#define bMaskHWord                	0xffff0000
+#define bMaskLWord                	0x0000ffff
+#define bMaskDWord                	0xffffffff
+#define bMask12Bits			0xfff
+#define bMaskH4Bits			0xf0000000
+#define bMaskOFDM_D			0xffc00000
+#define bMaskCCK			0x3f3f3f3f
+
+
+
+//
+// 3. Page8(0x800)
+//
+#define RFPGA0_RFMOD			0x800
+
+#define RFPGA0_TXINFO			0x804
+#define RFPGA0_PSDFUNCTION		0x808
+
+#define RFPGA0_TXGAINSTAGE		0x80c
+
+#define RFPGA0_XA_HSSIPARAMETER1	0x820
+#define RFPGA0_XA_HSSIPARAMETER2	0x824
+#define RFPGA0_XB_HSSIPARAMETER1	0x828
+#define RFPGA0_XB_HSSIPARAMETER2	0x82c
+
+#define RFPGA0_XAB_SWITCHCONTROL	0x858
+#define RFPGA0_XCD_SWITCHCONTROL	0x85c
+
+#define RFPGA0_XAB_RFPARAMETER		0x878	// RF Parameter
+#define RFPGA0_XCD_RFPARAMETER		0x87c
+
+#define RFPGA0_ANALOGPARAMETER1		0x880	// Crystal cap setting RF-R/W protection for parameter4??
+#define RFPGA0_ANALOGPARAMETER2		0x884
+#define RFPGA0_ANALOGPARAMETER3		0x888
+#define rFPGA0_AdDaClockEn		0x888	// enable ad/da clock1 for dual-phy
+#define RFPGA0_ANALOGPARAMETER4		0x88c
+#define rFPGA0_XB_LSSIReadBack		0x8a4
+//
+// 4. Page9(0x900)
+//
+#define RFPGA1_RFMOD			0x900	//RF mode & OFDM TxSC // RF BW Setting??
+
+#define RFPGA1_TXBLOCK			0x904	// Useless now
+#define RFPGA1_DEBUGSELECT		0x908	// Useless now
+#define RFPGA1_TXINFO			0x90c	// Useless now // Status report??
+
+//
+// PageA(0xA00)
+//
+#define rCCK0_System			0xa00
+#define rCCK0_AFESetting		0xa04	// Disable init gain now // Select RX path by RSSI
+#define rCCK0_TxFilter1			0xa20
+#define rCCK0_TxFilter2			0xa24
+#define rCCK0_DebugPort			0xa28	//debug port and Tx filter3
+
+//
+// PageB(0xB00)
+//
+#define RPDP_ANTA      			0xb00  
+#define RPDP_ANTA_4    			0xb04
+#define rConfig_Pmpd_AntA 		0xb28
+#define rConfig_AntA 			0xb68
+#define rConfig_AntB 			0xb6c
+#define RPDP_ANTB 			0xb70
+#define RPDP_ANTB_4 			0xb74
+#define rConfig_Pmpd_AntB		0xb98
+#define rAPK				0xbd8
+
+
+//
+// 6. PageC(0xC00)
+//
+#define ROFDM0_LSTF				0xc00
+
+#define ROFDM0_TRXPATHENABLE			0xc04
+#define ROFDM0_TRMUXPAR				0xc08
+#define ROFDM0_TRSWISOLATION			0xc0c
+
+#define ROFDM0_XARXAFE				0xc10  //RxIQ DC offset, Rx digital filter, DC notch filter
+#define ROFDM0_XARXIQIMBALANCE    		0xc14  //RxIQ imblance matrix
+#define ROFDM0_XBRXAFE            		0xc18
+#define ROFDM0_XBRXIQIMBALANCE    		0xc1c
+#define ROFDM0_XCRXAFE            		0xc20
+#define ROFDM0_XCRXIQIMBALANCE    		0xc24			/* ULLI Typo in rtl8821ae */
+#define ROFDM0_XDRXAFE            		0xc28
+#define ROFDM0_XDRXIQIMBALANCE    		0xc2c
+
+#define ROFDM0_RXDETECTOR1			0xc30  //PD,BW & SBD	// DM tune init gain
+#define ROFDM0_RXDETECTOR2			0xc34  //SBD & Fame Sync. 
+#define ROFDM0_RXDETECTOR3			0xc38  //Frame Sync.
+#define ROFDM0_RXDETECTOR4			0xc3c  //PD, SBD, Frame Sync & Short-GI
+
+#define rOFDM0_RxDSP				0xc40  //Rx Sync Path
+#define rOFDM0_CFOandDAGC			0xc44  //CFO & DAGC
+#define rOFDM0_CCADropThreshold	0xc48 //CCA Drop threshold
+#define rOFDM0_ECCAThreshold		0xc4c // energy CCA
+
+#define rOFDM0_XAAGCCore1			0xc50	// DIG
+#define rOFDM0_XAAGCCore2			0xc54
+#define rOFDM0_XBAGCCore1			0xc58
+#define rOFDM0_XBAGCCore2			0xc5c
+#define rOFDM0_XCAGCCore1			0xc60
+#define rOFDM0_XCAGCCore2			0xc64
+#define rOFDM0_XDAGCCore1			0xc68
+#define rOFDM0_XDAGCCore2			0xc6c
+
+#define ROFDM0_AGCPARAMETER1		0xc70
+#define ROFDM0_AGCPARAMETER2		0xc74
+#define rOFDM0_AGCRSSITable		0xc78
+#define rOFDM0_HTSTFAGC			0xc7c
+
+#define rOFDM0_XATxIQImbalance		0xc80	// TX PWR TRACK and DIG
+#define rOFDM0_XATxAFE				0xc84
+#define rOFDM0_XBTxIQImbalance		0xc88
+#define rOFDM0_XBTxAFE				0xc8c
+#define rOFDM0_XCTxIQImbalance		0xc90
+#define rOFDM0_XCTxAFE            		0xc94
+#define rOFDM0_XDTxIQImbalance		0xc98
+#define rOFDM0_XDTxAFE				0xc9c
+
+#define rOFDM0_RxIQExtAnta			0xca0
+#define ROFDM0_TXCOEFF1				0xca4
+#define ROFDM0_TXCOEFF2				0xca8
+#define ROFDM0_TXCOEFF3				0xcac
+#define ROFDM0_TXCOEFF4				0xcb0
+#define ROFDM0_TXCOEFF5				0xcb4
+#define ROFDM0_TXCOEFF6				0xcb8
+#define rOFDM0_RxHPParameter		0xce0
+#define rOFDM0_TxPseudoNoiseWgt	0xce4
+#define rOFDM0_FrameSync			0xcf0
+#define rOFDM0_DFSReport			0xcf4
+
+//
+// 7. PageD(0xD00)
+//
+#define rOFDM1_LSTF					0xd00
+#define rOFDM1_TRxPathEnable		0xd04
+
+//
+// 8. PageE(0xE00)
+//
+#define rTxAGC_A_Rate18_06			0xe00
+#define rTxAGC_A_Rate54_24			0xe04
+#define rTxAGC_A_CCK1_Mcs32		0xe08
+#define rTxAGC_A_Mcs03_Mcs00		0xe10
+#define rTxAGC_A_Mcs07_Mcs04		0xe14
+#define rTxAGC_A_Mcs11_Mcs08		0xe18
+#define rTxAGC_A_Mcs15_Mcs12		0xe1c
+
+#define rTxAGC_B_Rate18_06			0x830
+#define rTxAGC_B_Rate54_24			0x834
+#define rTxAGC_B_CCK1_55_Mcs32	0x838
+#define rTxAGC_B_Mcs03_Mcs00		0x83c
+#define rTxAGC_B_Mcs07_Mcs04		0x848
+#define rTxAGC_B_Mcs11_Mcs08		0x84c
+#define rTxAGC_B_Mcs15_Mcs12		0x868
+#define rTxAGC_B_CCK11_A_CCK2_11	0x86c
+
+#define rFPGA0_IQK					0xe28
+#define rTx_IQK_Tone_A				0xe30
+#define rRx_IQK_Tone_A				0xe34
+#define rTx_IQK_PI_A				0xe38
+#define rRx_IQK_PI_A				0xe3c
+
+#define rTx_IQK 						0xe40
+#define rRx_IQK						0xe44
+#define rIQK_AGC_Pts					0xe48
+#define rIQK_AGC_Rsp				0xe4c
+#define rTx_IQK_Tone_B				0xe50
+#define rRx_IQK_Tone_B				0xe54
+#define rTx_IQK_PI_B					0xe58
+#define rRx_IQK_PI_B					0xe5c
+#define rIQK_AGC_Cont				0xe60
+
+#define rBlue_Tooth					0xe6c
+#define rRx_Wait_CCA				0xe70
+#define rTx_CCK_RFON				0xe74
+#define rTx_CCK_BBON				0xe78
+#define rTx_OFDM_RFON				0xe7c
+#define rTx_OFDM_BBON				0xe80
+#define rTx_To_Rx					0xe84
+#define rTx_To_Tx					0xe88
+#define rRx_CCK						0xe8c
+
+#define RTX_POWER_BEFORE_IQK_A		0xe94
+#define RTX_POWER_AFTER_IQK_A		0xe9c
+
+#define RRX_POWER_BEFORE_IQK_A		0xea0
+#define RRX_POWER_BEFORE_IQK_A_2	0xea4
+#define RRX_POWER_AFTER_IQK_A		0xea8
+#define RRX_POWER_AFTER_IQK_A_2		0xeac
+
+#define RTX_POWER_BEFORE_IQK_B		0xeb4
+#define RTX_POWER_AFTER_IQK_B		0xebc
+
+#define RRX_POWER_BEFORE_IQK_B		0xec0
+#define RRX_POWER_BEFORE_IQK_B_2	0xec4
+#define RRX_POWER_AFTER_IQK_B		0xec8
+#define RRX_POWER_AFTER_IQK_B_2		0xecc
+
+#define rRx_OFDM				0xed0
+#define rRx_Wait_RIFS 				0xed4
+#define rRx_TO_Rx 				0xed8
+#define rStandby 				0xedc
+#define rSleep 					0xee0
+#define rPMPD_ANAEN				0xeec
+
+
+
+// TX AGC 
+#define RTXAGC_A_CCK11_CCK1			0xc20
+#define RTXAGC_A_OFDM18_OFDM6			0xc24
+#define RTXAGC_A_OFDM54_OFDM24			0xc28
+#define RTXAGC_A_MCS03_MCS00			0xc2c
+#define RTXAGC_A_MCS07_MCS04			0xc30
+#define RTXAGC_A_MCS11_MCS08			0xc34
+#define RTXAGC_A_MCS15_MCS12			0xc38
+#define RTXAGC_A_NSS1INDEX3_NSS1INDEX0		0xc3c
+#define RTXAGC_A_NSS1INDEX7_NSS1INDEX4		0xc40
+#define RTXAGC_A_NSS2INDEX1_NSS1INDEX8		0xc44
+#define RTXAGC_A_NSS2INDEX5_NSS2INDEX2		0xc48
+#define RTXAGC_A_NSS2INDEX9_NSS2INDEX6		0xc4c
+
+
+#define RTXAGC_B_CCK11_CCK1			0xe20
+#define RTXAGC_B_OFDM18_OFDM6			0xe24
+#define RTXAGC_B_OFDM54_OFDM24			0xe28
+#define RTXAGC_B_MCS03_MCS00			0xe2c
+#define RTXAGC_B_MCS07_MCS04			0xe30
+#define RTXAGC_B_MCS11_MCS08			0xe34
+#define RTXAGC_B_MCS15_MCS12			0xe38
+#define RTXAGC_B_NSS1INDEX3_NSS1INDEX0		0xe3c
+#define RTXAGC_B_NSS1INDEX7_NSS1INDEX4		0xe40
+#define RTXAGC_B_NSS2INDEX1_NSS1INDEX8		0xe44
+#define RTXAGC_B_NSS2INDEX5_NSS2INDEX2		0xe48
+#define RTXAGC_B_NSS2INDEX9_NSS2INDEX6		0xe4c
+
+#define MASKBYTE0                		0xff	// Reg 0xc50 rOFDM0_XAAGCCore~0xC6f
+#define MASKBYTE1                		0xff00
+#define MASKBYTE2                		0xff0000
+#define MASKBYTE3                		0xff000000
+
+#define bTxAGC_byte0_Jaguar							0xff
+#define bTxAGC_byte1_Jaguar							0xff00
+#define bTxAGC_byte2_Jaguar							0xff0000
+#define bTxAGC_byte3_Jaguar							0xff000000
+
+#define RF_T_METER_8812A 		0x42
+
+// RXIQC
+#define rA_RxIQC_AB_Jaguar    	0xc10  //RxIQ imblance matrix coeff. A & B
+#define rA_RxIQC_CD_Jaguar    	0xc14  //RxIQ imblance matrix coeff. C & D
+#define rA_TxScale_Jaguar 		0xc1c  // Pah_A TX scaling factor
+#define rB_TxScale_Jaguar 		0xe1c  // Path_B TX scaling factor
+#define rB_RxIQC_AB_Jaguar    	0xe10  //RxIQ imblance matrix coeff. A & B
+#define rB_RxIQC_CD_Jaguar    	0xe14  //RxIQ imblance matrix coeff. C & D
+#define b_RxIQC_AC_Jaguar		0x02ff  // bit mask for IQC matrix element A & C
+#define b_RxIQC_BD_Jaguar		0x02ff0000 // bit mask for IQC matrix element A & C
+
+// Misc functions
+#define rEDCCA_Jaguar				0x8a4 // EDCCA
+#define bEDCCA_Jaguar				0xffff
+#define rAGC_table_Jaguar			0x82c   // AGC tabel select
+#define bAGC_table_Jaguar			0x3
+#define b_sel5g_Jaguar    				0x1000 // sel5g
+#define b_LNA_sw_Jaguar				0x8000 // HW/WS control for LNA
+#define rFc_area_Jaguar				0x860   // fc_area 
+#define bFc_area_Jaguar				0x1ffe000
+#define rSingleTone_ContTx_Jaguar	0x914
+
+
+// AFE-related
+#define rA_AFEPwr1_Jaguar					0xc60 // dynamic AFE power control
+#define rA_AFEPwr2_Jaguar					0xc64 // dynamic AFE power control
+#define rA_Rx_WaitCCA_Tx_CCKRFON_Jaguar	0xc68
+#define rA_Tx_CCKBBON_OFDMRFON_Jaguar	0xc6c
+#define rA_Tx_OFDMBBON_Tx2Rx_Jaguar		0xc70
+#define rA_Tx2Tx_RXCCK_Jaguar				0xc74
+#define rA_Rx_OFDM_WaitRIFS_Jaguar			0xc78
+#define rA_Rx2Rx_BT_Jaguar					0xc7c
+#define rA_sleep_nav_Jaguar 					0xc80
+#define rA_pmpd_Jaguar 						0xc84
+#define rB_AFEPwr1_Jaguar					0xe60 // dynamic AFE power control
+#define rB_AFEPwr2_Jaguar					0xe64 // dynamic AFE power control
+#define rB_Rx_WaitCCA_Tx_CCKRFON_Jaguar	0xe68
+#define rB_Tx_CCKBBON_OFDMRFON_Jaguar	0xe6c
+#define rB_Tx_OFDMBBON_Tx2Rx_Jaguar		0xe70
+#define rB_Tx2Tx_RXCCK_Jaguar				0xe74
+#define rB_Rx_OFDM_WaitRIFS_Jaguar			0xe78
+#define rB_Rx2Rx_BT_Jaguar					0xe7c
+#define rB_sleep_nav_Jaguar 					0xe80
+#define rB_pmpd_Jaguar 						0xe84
+
+// RSSI Dump
+#define rA_RSSIDump_Jaguar 			0xBF0
+#define rB_RSSIDump_Jaguar 			0xBF1
+#define rS1_RXevmDump_Jaguar		0xBF4 
+#define rS2_RXevmDump_Jaguar 		0xBF5
+#define rA_RXsnrDump_Jaguar		0xBF6
+#define rB_RXsnrDump_Jaguar		0xBF7
+#define rA_CfoShortDump_Jaguar		0xBF8 
+#define rB_CfoShortDump_Jaguar		0xBFA
+#define rA_CfoLongDump_Jaguar		0xBEC
+#define rB_CfoLongDump_Jaguar		0xBEE
+ 
+
+// RF Register
+//
+#define RF_AC_Jaguar				0x00	// 
+#define RF_RF_Top_Jaguar			0x07	// 
+#define RF_TXLOK_Jaguar				0x08	// 
+#define RF_TXAPK_Jaguar				0x0B
+#define RF_CHNLBW_Jaguar 			0x18	// RF channel and BW switch
+#define RF_TxLCTank_Jaguar          	0x54
+#define RF_APK_Jaguar				0x63
+#define bRF_CHNLBW_MOD_AG_Jaguar	0x70300
+#define bRF_CHNLBW_BW 				0xc00
+#define RF_RCK1_Jaguar				0x1c	// 
+#define RF_RCK2_Jaguar				0x1d
+#define RF_RCK3_Jaguar   			0x1e
+#define RF_LCK						0xB4
+
+
+//
+// RL6052 Register definition
+//
+#define RF_AC						0x00	// 
+#define RF_IPA_A					0x0C	// 
+#define RF_TXBIAS_A					0x0D
+#define RF_BS_PA_APSET_G9_G11		0x0E
+#define RF_MODE1					0x10	// 
+#define RF_MODE2					0x11	// 
+#define RF_CHNLBW					0x18	// RF channel and BW switch
+#define RF_RCK_OS					0x30	// RF TX PA control
+#define RF_TXPA_G1					0x31	// RF TX PA control
+#define RF_TXPA_G2					0x32	// RF TX PA control
+#define RF_TXPA_G3					0x33	// RF TX PA control
+#define RF_0x52 						0x52
+#define RF_WE_LUT					0xEF
+
+// Security
+#define REG_CAMCMD						0x0670
+#define REG_CAMWRITE					0x0674
+#define REG_CAMREAD					0x0678
+#define REG_CAMDBG						0x067C
+#define REG_SECCFG						0x0680
+
+//----------------------------------------------------------------------------
+//       CAM Config Setting (offset 0x680, 1 byte)
+//----------------------------------------------------------------------------
+#define CAM_NOTVALID			0x0000
+#define CAM_USEDK				BIT5
+
+#define CAM_CONTENT_COUNT 	8
+
+#define CAM_NONE				0x0
+#define CAM_WEP40				0x01
+#define CAM_TKIP				0x02
+#define CAM_AES					0x04
+#define CAM_WEP104				0x05
+
+#define HALF_CAM_ENTRY			16
+
+#define CAM_CONFIG_USEDK		true
+#define CAM_CONFIG_NO_USEDK	false
+
+#define CAM_READ				0x00000000
+
+#define SCR_UseDK				0x01
+#define SCR_TxSecEnable			0x02
+#define SCR_RxSecEnable			0x04
+
+
+//====================================================
+//			EEPROM/Efuse PG Offset for 8812AE/8812AU/8812AS
+//====================================================
+// 0x10 ~ 0x63 = TX power area.
+#define EEPROM_USB_MODE_8812					0x08
+#define EEPROM_TX_PWR_INX_8812				0x10
+
+#define EEPROM_ChannelPlan_8812				0xB8
+#define EEPROM_XTAL_8812						0xB9
+#define EEPROM_THERMAL_METER_8812			0xBA
+#define EEPROM_IQK_LCK_8812					0xBB
+#define EEPROM_2G_5G_PA_TYPE_8812			0xBC
+#define EEPROM_2G_LNA_TYPE_GAIN_SEL_8812	0xBD
+#define EEPROM_5G_LNA_TYPE_GAIN_SEL_8812	0xBF
+
+#define EEPROM_RF_BOARD_OPTION_8812			0xC1
+#define EEPROM_RF_FEATURE_OPTION_8812		0xC2
+#define EEPROM_RF_BT_SETTING_8812				0xC3
+#define EEPROM_VERSION_8812					0xC4
+#define EEPROM_CustomID_8812					0xC5
+#define EEPROM_TX_BBSWING_2G_8812			0xC6
+#define EEPROM_TX_BBSWING_5G_8812			0xC7
+#define EEPROM_TX_PWR_CALIBRATE_RATE_8812	0xC8
+#define EEPROM_RF_ANTENNA_OPT_8812			0xC9
+#define EEPROM_RFE_OPTION_8812				0xCA
+
+// RTL8812AE
+#define EEPROM_MAC_ADDR_8812AE				0xD0
+#define EEPROM_VID_8812AE						0xD6
+#define EEPROM_DID_8812AE						0xD8
+#define EEPROM_SVID_8812AE						0xDA
+#define EEPROM_SMID_8812AE					0xDC
+
+//RTL8812AU
+#define EEPROM_MAC_ADDR_8812AU				0xD7
+#define EEPROM_VID_8812AU						0xD0
+#define EEPROM_PID_8812AU						0xD2
+#define EEPROM_PA_TYPE_8812AU					0xBC
+#define EEPROM_LNA_TYPE_2G_8812AU			0xBD
+#define EEPROM_LNA_TYPE_5G_8812AU			0xBF
+
+//====================================================
+//			EEPROM/Efuse PG Offset for 8821AE/8821AU/8821AS
+//====================================================
+#define EEPROM_TX_PWR_INX_8821				0x10
+
+#define EEPROM_ChannelPlan_8821				0xB8
+#define EEPROM_XTAL_8821						0xB9
+#define EEPROM_THERMAL_METER_8821			0xBA
+#define EEPROM_IQK_LCK_8821					0xBB
+
+
+#define EEPROM_RF_BOARD_OPTION_8821			0xC1
+#define EEPROM_RF_FEATURE_OPTION_8821		0xC2
+#define EEPROM_RF_BT_SETTING_8821				0xC3
+#define EEPROM_VERSION_8821					0xC4
+#define EEPROM_CustomID_8821					0xC5
+#define EEPROM_RF_ANTENNA_OPT_8821			0xC9
+
+// RTL8821AE
+#define EEPROM_MAC_ADDR_8821AE				0xD0
+#define EEPROM_VID_8821AE						0xD6
+#define EEPROM_DID_8821AE						0xD8
+#define EEPROM_SVID_8821AE						0xDA
+#define EEPROM_SMID_8821AE					0xDC
+
+//RTL8821AU
+#define EEPROM_PA_TYPE_8821AU					0xBC
+#define EEPROM_LNA_TYPE_8821AU				0xBF
+
+// RTL8821AS
+#define EEPROM_MAC_ADDR_8821AS				0x11A
+
+//RTL8821AU
+#define EEPROM_MAC_ADDR_8821AU				0x107
+#define EEPROM_VID_8821AU						0x100
+#define EEPROM_PID_8821AU						0x102
+
+#define EEPROM_Default_PID						0x1234
+#define EEPROM_Default_VID						0x5678
+#define EEPROM_Default_CustomerID				0xAB
+#define EEPROM_Default_CustomerID_8188E		0x00
+#define EEPROM_Default_SubCustomerID			0xCD
+#define EEPROM_Default_Version					0
+
+#define EEPROM_Default_CrystalCap_8812			0x20
+
+//New EFUSE deafult value
+#define EEPROM_DEFAULT_24G_INDEX			0x2A
+#define EEPROM_DEFAULT_24G_HT20_DIFF		0X02
+#define EEPROM_DEFAULT_24G_OFDM_DIFF		0X04
+
+#define EEPROM_DEFAULT_5G_INDEX			0X2A
+#define EEPROM_DEFAULT_5G_HT20_DIFF		0X00
+#define EEPROM_DEFAULT_5G_OFDM_DIFF		0X04
+
+#define EEPROM_DEFAULT_DIFF				0XFE
+#define EEPROM_DEFAULT_CHANNEL_PLAN		0x7F
+#define EEPROM_DEFAULT_BOARD_OPTION		0x00
+#define EEPROM_DEFAULT_RFE_OPTION		0x04
+#define EEPROM_DEFAULT_FEATURE_OPTION	0x00
+#define EEPROM_DEFAULT_BT_OPTION			0x10
+
+#define EEPROM_Default_ThermalMeter_8812		0x18
+
+#define EEPROM_Default_PAType						0
+#define EEPROM_Default_LNAType						0
+
+#define RTL_EEPROM_ID							0x8129
+
+#define EEPROM_CID_DEFAULT					0x0
+
+
+
+#endif
diff -Naur linux-4.9/drivers/staging/rtl8821au/rtl8821au/rf.c linux-4.9.8821au/drivers/staging/rtl8821au/rtl8821au/rf.c
--- linux-4.9/drivers/staging/rtl8821au/rtl8821au/rf.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/rtl8821au/rf.c	2016-12-11 19:48:25.183645006 -0600
@@ -0,0 +1,396 @@
+#ifdef CONFIG_RTLWIFI
+
+#include <../drivers/net/wireless/realtek/rtlwifi/wifi.h>
+
+#else
+
+#include <drv_types.h>
+#include <rtl8812a_hal.h>
+#include "rf.h"
+#include "reg.h"
+#include "phy.h"
+#include "dm.h"
+
+#endif
+
+void rtl8821au_phy_rf6052_set_bandwidth(struct rtl_priv *rtlpriv, enum CHANNEL_WIDTH	Bandwidth)	/* 20M or 40M */
+{
+	switch (Bandwidth) {
+	case CHANNEL_WIDTH_20:
+		rtl_set_rfreg(rtlpriv, RF90_PATH_A, RF_CHNLBW_Jaguar, BIT(11)|BIT(10), 3);
+		rtl_set_rfreg(rtlpriv, RF90_PATH_B, RF_CHNLBW_Jaguar, BIT(11)|BIT(10), 3);
+		break;
+	case CHANNEL_WIDTH_40:
+		rtl_set_rfreg(rtlpriv, RF90_PATH_A, RF_CHNLBW_Jaguar, BIT(11)|BIT(10), 1);
+		rtl_set_rfreg(rtlpriv, RF90_PATH_B, RF_CHNLBW_Jaguar, BIT(11)|BIT(10), 1);
+		break;
+
+	case CHANNEL_WIDTH_80:
+		rtl_set_rfreg(rtlpriv, RF90_PATH_A, RF_CHNLBW_Jaguar, BIT(11)|BIT(10), 0);
+		rtl_set_rfreg(rtlpriv, RF90_PATH_B, RF_CHNLBW_Jaguar, BIT(11)|BIT(10), 0);
+		break;
+
+	default:
+		RT_TRACE(rtlpriv, COMP_ERR, DBG_LOUD, "rtl8821au_phy_rf6052_set_bandwidth(): unknown Bandwidth: %#X\n", Bandwidth);
+		break;
+	}
+}
+
+static void writeOFDMPowerReg8812(struct rtl_priv *rtlpriv, uint8_t index,
+	u32 *pValue)
+{
+	u16 RegOffset_A[6] = {
+		RTXAGC_A_OFDM18_OFDM6,
+		RTXAGC_A_OFDM54_OFDM24,
+		RTXAGC_A_MCS03_MCS00,
+		RTXAGC_A_MCS07_MCS04,
+		RTXAGC_A_MCS11_MCS08,
+		RTXAGC_A_MCS15_MCS12
+	};
+	u16 RegOffset_B[6] = {
+		RTXAGC_B_OFDM18_OFDM6,
+		RTXAGC_B_OFDM54_OFDM24,
+		RTXAGC_B_MCS03_MCS00,
+		RTXAGC_B_MCS07_MCS04,
+		RTXAGC_B_MCS11_MCS08,
+		RTXAGC_B_MCS15_MCS12
+	};
+
+	uint8_t	i, rf, pwr_val[4];
+	uint32_t	writeVal;
+	u16	RegOffset;
+
+	for(rf = 0; rf < 2; rf++) {
+		writeVal = pValue[rf];
+		for(i = 0; i < RF_PATH_MAX_92C_88E; i++) {	/* ULLI BUG wrong path */
+			pwr_val[i] = (uint8_t)((writeVal & (0x7f<<(i*8)))>>(i*8));
+			if (pwr_val[i]  > RF6052_MAX_TX_PWR)
+				pwr_val[i]  = RF6052_MAX_TX_PWR;
+		}
+		writeVal = (pwr_val[3]<<24) | (pwr_val[2]<<16) |(pwr_val[1]<<8) |pwr_val[0];
+
+		if(rf == 0)
+			RegOffset = RegOffset_A[index];
+		else
+			RegOffset = RegOffset_B[index];
+		rtl_set_bbreg(rtlpriv, RegOffset, bMaskDWord, writeVal);
+		//RTPRINT(FPHY, PHY_TXPWR, ("Set 0x%x = %08x\n", RegOffset, writeVal));
+	}
+}
+
+//
+// powerbase0 for OFDM rates
+// powerbase1 for HT MCS rates
+//
+void getPowerBase8812(struct rtl_priv *rtlpriv, uint8_t *pPowerLevelOFDM,
+	uint8_t *pPowerLevelBW20, uint8_t *pPowerLevelBW40, uint8_t Channel,
+	u32 *OfdmBase, u32 *MCSBase)
+{
+	uint32_t			powerBase0, powerBase1;
+	uint8_t			i, powerlevel[2];
+
+	for (i = 0; i < 2; i++) {
+		powerBase0 = pPowerLevelOFDM[i];
+
+		powerBase0 = (powerBase0<<24) | (powerBase0<<16) |(powerBase0<<8) |powerBase0;
+		*(OfdmBase+i) = powerBase0;
+		//DBG_871X(" [OFDM power base index rf(%c) = 0x%x]\n", ((i==0)?'A':'B'), *(OfdmBase+i));
+	}
+
+	for (i = 0; i < rtlpriv->phy.num_total_rfpath; i++) {
+		//Check HT20 to HT40 diff
+		if(rtlpriv->phy.current_chan_bw == CHANNEL_WIDTH_20)
+			powerlevel[i] = pPowerLevelBW20[i];
+		else
+			powerlevel[i] = pPowerLevelBW40[i];
+
+		powerBase1 = powerlevel[i];
+		powerBase1 = (powerBase1<<24) | (powerBase1<<16) |(powerBase1<<8) |powerBase1;
+		*(MCSBase+i) = powerBase1;
+		//DBG_871X(" [MCS power base index rf(%c) = 0x%x]\n", ((i==0)?'A':'B'), *(MCSBase+i));
+	}
+}
+
+void getTxPowerWriteValByRegulatory8812(struct rtl_priv *rtlpriv, 
+	uint8_t	Channel, uint8_t index, u32 *powerBase0, u32 *powerBase1,
+	u32 *pOutWriteVal)
+{
+	struct rtl_phy *rtlphy = &(rtlpriv->phy);
+	struct rtl_efuse *efuse = rtl_efuse(rtlpriv);
+	uint8_t	chnlGroup=0;
+	uint32_t writeVal, rf;
+	uint8_t	Regulatory = efuse->eeprom_regulatory;
+
+	//
+	// Index 0 & 1= legacy OFDM, 2-5=HT_MCS rate
+	//
+
+	for (rf = 0; rf < 2; rf++) {
+		switch(Regulatory) {
+		case 0:	// Realtek better performance
+				// increase power diff defined by Realtek for large power
+			chnlGroup = 0;
+			//RTPRINT(FPHY, PHY_TXPWR, ("MCSTxPowerLevelOriginalOffset[%d][%d] = 0x%x\n",
+			//	chnlGroup, index, pHalData->MCSTxPowerLevelOriginalOffset[chnlGroup][index+(rf?8:0)]));
+			writeVal = rtlphy->mcs_txpwrlevel_origoffset[chnlGroup][index+(rf?8:0)] +
+				((index<2)?powerBase0[rf]:powerBase1[rf]);
+			//RTPRINT(FPHY, PHY_TXPWR, ("RTK better performance, writeVal(%c) = 0x%x\n", ((rf==0)?'A':'B'), writeVal));
+			break;
+		case 1:	// Realtek regulatory
+				// increase power diff defined by Realtek for regulatory
+			{
+				if(rtlphy->pwrgroup_cnt == 1)
+					chnlGroup = 0;
+				//if(rtlphy->pwrgroup_cnt >= MAX_PG_GROUP)
+				{
+					if (Channel < 3)			// Chanel 1-2
+						chnlGroup = 0;
+					else if (Channel < 6)		// Channel 3-5
+						chnlGroup = 1;
+					else	 if(Channel <9)		// Channel 6-8
+						chnlGroup = 2;
+					else if(Channel <12)		// Channel 9-11
+						chnlGroup = 3;
+					else if(Channel <14)		// Channel 12-13
+						chnlGroup = 4;
+					else if(Channel ==14)		// Channel 14
+						chnlGroup = 5;
+
+/*
+					if(Channel <= 3)
+						chnlGroup = 0;
+					else if(Channel >= 4 && Channel <= 9)
+						chnlGroup = 1;
+					else if(Channel > 9)
+						chnlGroup = 2;
+
+
+					if(pHalData->CurrentChannelBW == CHANNEL_WIDTH_20)
+						chnlGroup++;
+					else
+						chnlGroup+=4;
+*/
+				}
+				//RTPRINT(FPHY, PHY_TXPWR, ("MCSTxPowerLevelOriginalOffset[%d][%d] = 0x%x\n",
+				//chnlGroup, index, pHalData->MCSTxPowerLevelOriginalOffset[chnlGroup][index+(rf?8:0)]));
+				writeVal = rtlphy->mcs_txpwrlevel_origoffset[chnlGroup][index+(rf?8:0)] +
+						((index<2)?powerBase0[rf]:powerBase1[rf]);
+				//RTPRINT(FPHY, PHY_TXPWR, ("Realtek regulatory, 20MHz, writeVal(%c) = 0x%x\n", ((rf==0)?'A':'B'), writeVal));
+			}
+			break;
+		case 2:	// Better regulatory
+				// don't increase any power diff
+			writeVal = ((index<2)?powerBase0[rf]:powerBase1[rf]);
+			//RTPRINT(FPHY, PHY_TXPWR, ("Better regulatory, writeVal(%c) = 0x%x\n", ((rf==0)?'A':'B'), writeVal));
+			break;
+		default:
+			chnlGroup = 0;
+			writeVal = rtlphy->mcs_txpwrlevel_origoffset[chnlGroup][index+(rf?8:0)] +
+					((index<2)?powerBase0[rf]:powerBase1[rf]);
+			//RTPRINT(FPHY, PHY_TXPWR, ("RTK better performance, writeVal rf(%c) = 0x%x\n", ((rf==0)?'A':'B'), writeVal));
+			break;
+		}
+
+// 20100427 Joseph: Driver dynamic Tx power shall not affect Tx power. It shall be determined by power training mechanism.
+// Currently, we cannot fully disable driver dynamic tx power mechanism because it is referenced by BT coexist mechanism.
+// In the future, two mechanism shall be separated from each other and maintained independantly. Thanks for Lanhsin's reminder.
+		//92d do not need this
+		if (rtlpriv->dm.dynamic_txhighpower_lvl == TxHighPwrLevel_Level1)
+			writeVal = 0x14141414;
+		else if (rtlpriv->dm.dynamic_txhighpower_lvl == TxHighPwrLevel_Level2)
+			writeVal = 0x00000000;
+
+		// 20100628 Joseph: High power mode for BT-Coexist mechanism.
+		// This mechanism is only applied when Driver-Highpower-Mechanism is OFF.
+		if (rtlpriv->dm.dynamic_txhighpower_lvl == TxHighPwrLevel_BT1) {
+			//RTPRINT(FBT, BT_TRACE, ("Tx Power (-6)\n"));
+			writeVal = writeVal - 0x06060606;
+		} else if(rtlpriv->dm.dynamic_txhighpower_lvl == TxHighPwrLevel_BT2) {
+			//RTPRINT(FBT, BT_TRACE, ("Tx Power (-0)\n"));
+			writeVal = writeVal ;
+		}
+		/*
+		if(pMgntInfo->bDisableTXPowerByRate) {
+		// add for  OID_RT_11N_TX_POWER_BY_RATE ,disable tx powre change by rate
+			writeVal = 0x2c2c2c2c;
+		}
+		*/
+		*(pOutWriteVal+rf) = writeVal;
+	}
+}
+
+void rtl8821au_phy_rf6052_set_ofdm_txpower(struct rtl_priv *rtlpriv,
+	uint8_t *pPowerLevelOFDM, uint8_t *pPowerLevelBW20,
+	uint8_t *pPowerLevelBW40, uint8_t Channel)
+{
+	uint32_t writeVal[2], powerBase0[2], powerBase1[2];
+	uint8_t index = 0;
+
+
+	//DBG_871X("PHY_RF6052SetOFDMTxPower, channel(%d) \n", Channel);
+
+	getPowerBase8812(rtlpriv, pPowerLevelOFDM,pPowerLevelBW20,pPowerLevelBW40, Channel, &powerBase0[0], &powerBase1[0]);
+
+	for(index = 0; index < 6; index++) {
+		getTxPowerWriteValByRegulatory8812(rtlpriv, Channel, index,
+			&powerBase0[0], &powerBase1[0], &writeVal[0]);
+
+		writeOFDMPowerReg8812(rtlpriv, index, &writeVal[0]);
+	}
+}
+
+static bool _rtl8821au_phy_rf6052_config_parafile(struct rtl_priv *rtlpriv)
+{
+	struct rtl_hal *rtlhal = rtl_hal(rtlpriv);
+	u8 rfpath;
+	bool rtstatus = true;
+
+	for (rfpath = 0; rfpath < rtlpriv->phy.num_total_rfpath; rfpath++) {
+		switch (rfpath) {
+		case RF90_PATH_A :
+			if (rtlhal->hw_type == HARDWARE_TYPE_RTL8812AU)
+				rtstatus =
+				  rtl8812au_phy_config_rf_with_headerfile(rtlpriv,
+						(enum radio_path) rfpath);
+			else
+				rtstatus =
+				  rtl8821au_phy_config_rf_with_headerfile(rtlpriv,
+						(enum radio_path) rfpath);
+
+			break;
+		case RF90_PATH_B :
+			if (rtlhal->hw_type == HARDWARE_TYPE_RTL8812AU)
+				rtstatus =
+				  rtl8812au_phy_config_rf_with_headerfile(rtlpriv,
+						(enum radio_path) rfpath);
+			else
+				rtstatus =
+				  rtl8821au_phy_config_rf_with_headerfile(rtlpriv,
+						(enum radio_path) rfpath);
+
+		case RF90_PATH_C :
+			break;
+		case RF90_PATH_D :
+			break;
+
+		}
+		if (!rtstatus) {
+			RT_TRACE(rtlpriv, COMP_INIT, DBG_TRACE,
+				 "Radio[%d] Fail!!", rfpath);
+			return false;
+		}
+	}
+
+	/*put arrays in dm.c*/
+	RT_TRACE(rtlpriv, COMP_INIT, DBG_TRACE, "\n");
+
+	return rtstatus;
+}
+
+bool rtl8821au_phy_rf6052_config(struct rtl_priv *rtlpriv)
+{
+	/* Initialize general global value */
+	if (rtlpriv->phy.rf_type == RF_1T1R)
+		rtlpriv->phy.num_total_rfpath = 1;
+	else
+		rtlpriv->phy.num_total_rfpath = 2;
+
+	/*
+	 * Config BB and RF
+	 */
+
+	return _rtl8821au_phy_rf6052_config_parafile(rtlpriv);
+}
+
+/* currently noz used, as in rtl8821ae */
+
+void rtl8821au_phy_rf6052_set_cck_txpower(struct rtl_priv *rtlpriv, uint8_t *pPowerlevel)
+{
+	struct rtl_phy *rtlphy = &(rtlpriv->phy);
+	struct rtl_efuse *efuse = rtl_efuse(rtlpriv);
+	struct rtl_hal *rtlhal = rtl_hal(rtlpriv);
+	struct mlme_ext_priv 	*pmlmeext = &rtlpriv->mlmeextpriv;
+	uint32_t		TxAGC[2] = {0, 0},	/* ULLI : change for 4 tx ?? */
+				tmpval = 0;
+	bool	TurboScanOff = false;
+	uint8_t	idx1, idx2;
+	uint8_t *ptr;
+
+	/* FOR CE ,must disable turbo scan */
+	TurboScanOff = true;
+
+	if (pmlmeext->sitesurvey_res.state == SCAN_PROCESS) {
+		TxAGC[RF90_PATH_A] = 0x3f3f3f3f;
+		TxAGC[RF90_PATH_B] = 0x3f3f3f3f;
+
+		TurboScanOff = true;	/* disable turbo scan */
+
+		if (TurboScanOff) {
+			for (idx1 = RF90_PATH_A; idx1 <= RF90_PATH_B; idx1++) {
+				TxAGC[idx1] =
+					pPowerlevel[idx1] | (pPowerlevel[idx1]<<8) |
+					(pPowerlevel[idx1]<<16) | (pPowerlevel[idx1]<<24);
+				/* 2010/10/18 MH For external PA module. We need to limit power index to be less than 0x20. */
+				if (TxAGC[idx1] > 0x20 && rtlhal->external_pa_5g)
+					TxAGC[idx1] = 0x20;
+			}
+		}
+	} else {
+/*
+ * 20100427 Joseph: Driver dynamic Tx power shall not affect Tx power. It shall be determined by power training mechanism.
+ * Currently, we cannot fully disable driver dynamic tx power mechanism because it is referenced by BT coexist mechanism.
+ * In the future, two mechanism shall be separated from each other and maintained independantly. Thanks for Lanhsin's reminder.
+ */
+		if (rtlpriv->dm.dynamic_txhighpower_lvl == TxHighPwrLevel_Level1) {
+			TxAGC[RF90_PATH_A] = 0x10101010;
+			TxAGC[RF90_PATH_B] = 0x10101010;
+		} else if (rtlpriv->dm.dynamic_txhighpower_lvl == TxHighPwrLevel_Level2) {
+			TxAGC[RF90_PATH_A] = 0x00000000;
+			TxAGC[RF90_PATH_B] = 0x00000000;
+		} else {
+			for (idx1 = RF90_PATH_A; idx1 <= RF90_PATH_B; idx1++) {
+				TxAGC[idx1] =
+					pPowerlevel[idx1] | (pPowerlevel[idx1]<<8) |
+					(pPowerlevel[idx1]<<16) | (pPowerlevel[idx1]<<24);
+			}
+
+			if (efuse->eeprom_regulatory == 0) {
+				tmpval = (rtlphy->mcs_txpwrlevel_origoffset[0][6]) +
+						(rtlphy->mcs_txpwrlevel_origoffset[0][7]<<8);
+				TxAGC[RF90_PATH_A] += tmpval;
+
+				tmpval = (rtlphy->mcs_txpwrlevel_origoffset[0][14]) +
+						(rtlphy->mcs_txpwrlevel_origoffset[0][15]<<24);
+				TxAGC[RF90_PATH_B] += tmpval;
+			}
+		}
+	}
+
+	for (idx1 = RF90_PATH_A; idx1 <= RF90_PATH_B; idx1++) {
+		ptr = (uint8_t *)(&(TxAGC[idx1]));
+		for (idx2 = 0; idx2 < 4; idx2++) {
+			if (*ptr > RF6052_MAX_TX_PWR)
+				*ptr = RF6052_MAX_TX_PWR;
+			ptr++;
+		}
+	}
+
+	/* rf-A cck tx power */
+	tmpval = TxAGC[RF90_PATH_A]&0xff;
+	rtl_set_bbreg(rtlpriv, RTXAGC_A_CCK11_CCK1, MASKBYTE1, tmpval);
+	/* RT_DISP(FPHY, PHY_TXPWR, ("CCK PWR 1M (rf-A) = 0x%x (reg 0x%x)\n", tmpval, rTxAGC_A_CCK1_Mcs32)); */
+	tmpval = TxAGC[RF90_PATH_A]>>8;
+	rtl_set_bbreg(rtlpriv, RTXAGC_A_CCK11_CCK1, 0xffffff00, tmpval);
+	/* RT_DISP(FPHY, PHY_TXPWR, ("CCK PWR 2~11M (rf-A) = 0x%x (reg 0x%x)\n", tmpval, rTxAGC_B_CCK11_A_CCK2_11)); */
+
+	/* rf-B cck tx power */
+	tmpval = TxAGC[RF90_PATH_B]>>24;
+	rtl_set_bbreg(rtlpriv, RTXAGC_B_CCK11_CCK1, MASKBYTE0, tmpval);
+	/* RT_DISP(FPHY, PHY_TXPWR, ("CCK PWR 11M (rf-B) = 0x%x (reg 0x%x)\n", tmpval, rTxAGC_B_CCK11_A_CCK2_11)); */
+	tmpval = TxAGC[RF90_PATH_B]&0x00ffffff;
+	rtl_set_bbreg(rtlpriv, RTXAGC_B_CCK11_CCK1, 0xffffff00, tmpval);
+	/* RT_DISP(FPHY, PHY_TXPWR, ("CCK PWR 1~5.5M (rf-B) = 0x%x (reg 0x%x)\n", tmpval, rTxAGC_B_CCK1_55_Mcs32)); */
+
+}	/* PHY_RF6052SetCckTxPower */
+
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/rtl8821au/rf.h linux-4.9.8821au/drivers/staging/rtl8821au/rtl8821au/rf.h
--- linux-4.9/drivers/staging/rtl8821au/rtl8821au/rf.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/rtl8821au/rf.h	2016-12-11 19:48:25.183645006 -0600
@@ -0,0 +1,11 @@
+#ifndef __RTL8821AU_PR_H__
+#define __RTL8821AU_PR_H__
+
+void rtl8821au_phy_rf6052_set_bandwidth(struct rtl_priv *rtlpriv, enum CHANNEL_WIDTH	Bandwidth);
+bool rtl8821au_phy_rf6052_config(struct rtl_priv *rtlpriv);
+void rtl8821au_phy_rf6052_set_cck_txpower(struct rtl_priv *rtlpriv, uint8_t *pPowerlevel);
+
+void rtl8821au_phy_rf6052_set_ofdm_txpower(struct rtl_priv *rtlpriv, uint8_t *pPowerLevelOFDM,
+	uint8_t *pPowerLevelBW20, uint8_t *pPowerLevelBW40, uint8_t Channel);
+
+#endif
diff -Naur linux-4.9/drivers/staging/rtl8821au/rtl8821au/sw.c linux-4.9.8821au/drivers/staging/rtl8821au/rtl8821au/sw.c
--- linux-4.9/drivers/staging/rtl8821au/rtl8821au/sw.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/rtl8821au/sw.c	2016-12-11 19:48:25.183645006 -0600
@@ -0,0 +1,850 @@
+#ifdef CONFIG_RTLWIFI
+
+#include <../drivers/net/wireless/realtek/rtlwifi/wifi.h>
+#include <../drivers/net/wireless/realtek/rtlwifi/core.h>
+#include <../drivers/net/wireless/realtek/rtlwifi/use.h>
+#include <../drivers/net/wireless/realtek/rtlwifi/efuse.h>
+#include <../drivers/net/wireless/realtek/rtlwifi/base.h>
+
+#else
+
+#include <drv_types.h>
+#include "sw.h"
+#include "dm.h"
+#include "phy.h"
+#include "reg.h"
+#include "rf.h"
+#include "trx.h"
+#include "hw.h"
+#include "led.h"
+#include "fw.h"
+
+#include <rtl8812a_hal.h>
+
+#include "../debug.h"
+
+#endif
+
+#include <linux/spinlock.h>
+
+#define RTL8821AU_DRIVER_NAME		"rtl8821au"
+
+void rtl8812_free_hal_data(struct rtl_priv *rtlpriv);
+
+static uint8_t rtw_init_default_value(struct rtl_priv *rtlpriv)
+{
+	struct rtl_hal_cfg *cfg = rtlpriv->cfg;
+	uint8_t ret  = _SUCCESS;
+	struct registry_priv *pregistrypriv = &rtlpriv->registrypriv;
+	struct xmit_priv *pxmitpriv = &rtlpriv->xmitpriv;
+	struct mlme_priv *pmlmepriv = &rtlpriv->mlmepriv;
+	struct security_priv *psecuritypriv = &rtlpriv->securitypriv;
+
+	/* xmit_priv */
+	pxmitpriv->vcs_setting = AUTO_VCS;
+	pxmitpriv->vcs = RTS_CTS;
+	pxmitpriv->vcs_type = RTS_CTS;
+	/* pxmitpriv->rts_thresh = pregistrypriv->rts_thresh; */
+	pxmitpriv->frag_len = 2346;
+
+	/* recv_priv */
+
+	/* mlme_priv */
+	pmlmepriv->scan_interval = SCAN_INTERVAL;	/* 30*2 sec = 60sec */
+	pmlmepriv->scan_mode = SCAN_ACTIVE;
+
+	/*
+	 * qos_priv
+	 * pmlmepriv->qospriv.qos_option = pregistrypriv->wmm_enable;
+	 */
+
+	/* ht_priv */
+	pmlmepriv->htpriv.ampdu_enable = false; /* set to disabled */
+
+	/* security_priv */
+	/* rtw_get_encrypt_decrypt_from_registrypriv(rtlpriv); */
+	psecuritypriv->binstallGrpkey = _FAIL;
+	psecuritypriv->sw_encrypt = cfg->mod_params->sw_crypto;
+	psecuritypriv->sw_decrypt = cfg->mod_params->sw_crypto;
+
+	psecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_Open; /* open system */
+	psecuritypriv->dot11PrivacyAlgrthm = NO_ENCRYPTION;
+
+	psecuritypriv->dot11PrivacyKeyIndex = 0;
+
+	psecuritypriv->dot118021XGrpPrivacy = NO_ENCRYPTION;
+	psecuritypriv->dot118021XGrpKeyid = 1;
+
+	psecuritypriv->ndisauthtype = Ndis802_11AuthModeOpen;
+	psecuritypriv->ndisencryptstatus = Ndis802_11WEPDisabled;
+
+
+	/* pwrctrl_priv */
+
+
+	/* registry_priv */
+	rtw_init_registrypriv_dev_network(rtlpriv);
+	rtw_update_registrypriv_dev_network(rtlpriv);
+
+
+	/* hal_priv */
+	rtlpriv->cfg->ops->init_default_value(rtlpriv);
+
+	/* misc. */
+	rtlpriv->bReadPortCancel = false;
+	rtlpriv->bWritePortCancel = false;
+	rtlpriv->bNotifyChannelChange = 0;
+
+	return ret;
+}
+
+/* ULLI : temporaly used here, to get right vars for init_sw_vars */
+
+void rtw_vht_use_default_setting(struct rtl_priv *rtlpriv)
+{
+	struct rtl_hal *rtlhal = rtl_hal(rtlpriv);
+	
+	struct mlme_priv *pmlmepriv = &rtlpriv->mlmepriv;
+	struct vht_priv *pvhtpriv = &pmlmepriv->vhtpriv;
+	struct registry_priv *pregistrypriv = &rtlpriv->registrypriv;
+	bool	bHwLDPCSupport = false, bHwSTBCSupport = false;
+	uint8_t	rf_type = 0;
+
+	pvhtpriv->vht_bwmode = (0x21 & 0xF0) >> 4;
+	if (pvhtpriv->vht_bwmode > CHANNEL_WIDTH_80)
+		pvhtpriv->sgi = TEST_FLAG(0xf, BIT(3)) ? true : false;
+	else
+		pvhtpriv->sgi = TEST_FLAG(0xf, BIT(2)) ? true : false;
+
+	/*
+	 * LDPC support
+	 */
+
+	if (IS_VENDOR_8812A_C_CUT(rtlhal->version))
+		bHwLDPCSupport = true;
+	else if (IS_HARDWARE_TYPE_8821(rtlhal))
+		bHwLDPCSupport = false;
+	else
+		bHwLDPCSupport = false;
+
+
+	CLEAR_FLAGS(pvhtpriv->ldpc_cap);
+
+	if (bHwLDPCSupport) {
+		if (TEST_FLAG(0x33, BIT(0)))
+			SET_FLAG(pvhtpriv->ldpc_cap, LDPC_VHT_ENABLE_RX);
+		if (TEST_FLAG(0x33, BIT(1)))
+			SET_FLAG(pvhtpriv->ldpc_cap, LDPC_VHT_ENABLE_TX);
+#if 0
+		DBG_871X("[VHT] Support LDPC = 0x%02X\n", pvhtpriv->ldpc_cap);
+#endif
+	}
+
+	/*
+	 *  STBC
+	 */
+
+	if (rtlpriv->phy.rf_type == RF_2T2R)
+		bHwSTBCSupport = 1;
+	else
+		bHwSTBCSupport = 0;
+
+	CLEAR_FLAGS(pvhtpriv->stbc_cap);
+
+	if (bHwSTBCSupport) {
+		if (TEST_FLAG(0x3, BIT(1)))
+			SET_FLAG(pvhtpriv->stbc_cap, STBC_VHT_ENABLE_TX);
+	}
+
+	bHwSTBCSupport = 1;
+
+	if (bHwSTBCSupport) {
+		if (TEST_FLAG(0x3, BIT(0)))
+			SET_FLAG(pvhtpriv->stbc_cap, STBC_VHT_ENABLE_RX);
+	}
+
+#if 0
+	DBG_871X("[VHT] Support STBC = 0x%02X\n", pvhtpriv->stbc_cap);
+#endif
+
+	pvhtpriv->ampdu_len = 7;
+
+	rf_type = rtlpriv->phy.rf_type;
+
+	if (rf_type == RF_1T1R)
+		pvhtpriv->vht_mcs_map[0] = 0xfe;	/* Only support 1SS MCS 0~9; */
+	else
+		pvhtpriv->vht_mcs_map[0] = 0xfa;	/* support 1SS MCS 0~9 2SS MCS 0~9 */
+	pvhtpriv->vht_mcs_map[1] = 0xff;
+
+	pvhtpriv->vht_highest_rate = rtw_get_vht_highest_rate(rtlpriv, pvhtpriv->vht_mcs_map);
+}
+
+#if 0
+static int rtw_ampdu_factor = 7;
+static int rtw_vht_rate_sel = 0;
+/*
+ *
+ *  BIT(0): Enable VHT LDPC Rx,
+ *  BIT(1): Enable VHT LDPC Tx,
+ *  BIT(4): Enable HT LDPC Rx,
+ *  BIT(5): Enable HT LDPC Tx
+ */
+static int rtw_ldpc_cap = 0x33;
+/*  BIT(0): Enable VHT STBC Rx,
+ *  BIT(1): Enable VHT STBC Tx,
+ *  BIT(4): Enable HT STBC Rx,
+ *  BIT(5): Enable HT STBC Tx
+ */
+static int rtw_stbc_cap = 0x3;
+/*
+ * BIT(0): Enable VHT Beamformer,
+ * BIT(1): Enable VHT Beamformee,
+ * BIT(4): Enable HT Beamformer,
+ * BIT(5): Enable HT Beamformee
+ */
+static int rtw_beamform_cap = 0;
+#endif
+
+
+
+void rtl8812au_init_default_value(struct rtl_priv *rtlpriv)
+{
+	struct rtl_usb *rtlusb = rtl_usbdev(rtlpriv);
+	struct rtl_dm *rtldm = rtl_dm(rtlpriv);
+	struct rtl_phy *rtlphy = &(rtlpriv->phy);
+	struct rtl_hal *rtlhal = rtl_hal(rtlpriv);
+	struct _rtw_hal *pHalData;
+	struct pwrctrl_priv *pwrctrlpriv;
+	struct dm_priv *pdmpriv;
+
+	pHalData = GET_HAL_DATA(rtlpriv);
+	pwrctrlpriv = &rtlpriv->pwrctrlpriv;
+	pdmpriv = &pHalData->dmpriv;
+
+
+	/* init default value */
+	pHalData->fw_ractrl = false;
+	rtlhal->last_hmeboxnum = 0;
+
+	/* init dm default value */
+	pHalData->bChnlBWInitialzed = false;
+	rtlphy->iqk_initialized = false;
+	rtldm->tm_trigger = 0;/* for IQK */
+	rtlphy->pwrgroup_cnt = 0;
+
+	rtlusb->irq_mask[0]	= (u32)(	\
+/*
+					IMR_ROK 		|
+					IMR_RDU		|
+					IMR_VODOK		|
+					IMR_VIDOK		|
+					IMR_BEDOK		|
+					IMR_BKDOK		|
+					IMR_MGNTDOK		|
+					IMR_HIGHDOK		|
+					IMR_CPWM		|
+					IMR_CPWM2		|
+					IMR_C2HCMD		|
+					IMR_HISR1_IND_INT	|
+					IMR_ATIMEND		|
+					IMR_BCNDMAINT_E	|
+					IMR_HSISR_IND_ON_INT	|
+					IMR_BCNDOK0		|
+					IMR_BCNDMAINT0	|
+					IMR_TSF_BIT32_TOGGLE	|
+					IMR_TXBCN0OK	|
+					IMR_TXBCN0ERR	|
+					IMR_GTINT3		|
+					IMR_GTINT4		|
+					IMR_TXCCK		|
+ */
+					0);
+
+	rtlusb->irq_mask[1] 	= (u32)(	\
+/*
+					IMR_RXFOVW		|
+					IMR_TXFOVW		|
+					IMR_RXERR		|
+					IMR_TXERR		|
+					IMR_ATIMEND_E	|
+					IMR_BCNDOK1		|
+					IMR_BCNDOK2		|
+					IMR_BCNDOK3		|
+					IMR_BCNDOK4		|
+					IMR_BCNDOK5		|
+					IMR_BCNDOK6		|
+					IMR_BCNDOK7		|
+					IMR_BCNDMAINT1	|
+					IMR_BCNDMAINT2	|
+					IMR_BCNDMAINT3	|
+					IMR_BCNDMAINT4	|
+					IMR_BCNDMAINT5	|
+					IMR_BCNDMAINT6	|
+					IMR_BCNDMAINT7	|
+ */
+					0);
+}
+
+
+
+static int rtl8821au_init_sw_vars(struct rtl_priv *rtlpriv)
+{
+	struct rtl_mac *mac = rtl_mac(rtlpriv);
+	uint8_t	ret8 = _SUCCESS;
+
+	/* for debug level */
+	rtlpriv->dbg.global_debuglevel = rtlpriv->cfg->mod_params->debug;
+
+	/* ULLI : needed for rtlwifi-lib to init core , from rtl8821ae */
+
+	mac->ht_enable = true;
+	mac->ht_cur_stbc = 0;
+	mac->ht_stbc_cap = 0;
+	mac->vht_cur_ldpc = 0;
+	mac->vht_ldpc_cap = 0;
+	mac->vht_cur_stbc = 0;
+	mac->vht_stbc_cap = 0;
+
+	rtlpriv->rtlhal.current_bandtype = BAND_ON_2_4G;
+	rtlpriv->rtlhal.bandset = BAND_ON_BOTH;
+
+	/* ULLI : Border for old init_sw_vars */
+
+	ret8 = rtw_init_default_value(rtlpriv);
+
+	if ((rtw_init_cmd_priv(&rtlpriv->cmdpriv)) == _FAIL) {
+		ret8 = _FAIL;
+		goto exit;
+	}
+
+	rtlpriv->cmdpriv.rtlpriv = rtlpriv;
+
+	if ((rtw_init_evt_priv(&rtlpriv->evtpriv)) == _FAIL) {
+		ret8 = _FAIL;
+		goto exit;
+	}
+
+
+	if (rtw_init_mlme_priv(rtlpriv) == _FAIL) {
+		ret8 = _FAIL;
+		goto exit;
+	}
+
+	if (init_mlme_ext_priv(rtlpriv) == _FAIL) {
+		ret8 = _FAIL;
+		goto exit;
+	}
+
+	if (_rtw_init_xmit_priv(&rtlpriv->xmitpriv, rtlpriv) == _FAIL) 	{
+		printk("rtl8821au: Can't _rtw_init_xmit_priv\n");
+		ret8 = _FAIL;
+		goto exit;
+	}
+
+	if (_rtw_init_recv_priv(&rtlpriv->recvpriv, rtlpriv) == _FAIL) {
+		printk("rtl8821au: Can't _rtw_init_recv_priv\n");
+		ret8 = _FAIL;
+		goto exit;
+	}
+
+	/*
+	 * We don't need to memset rtlpriv->XXX to zero, because rtlpriv is allocated by rtw_zvmalloc().
+	 * memset((unsigned char *)&rtlpriv->securitypriv, 0, sizeof (struct security_priv));
+	 */
+
+	/* _init_timer(&(rtlpriv->securitypriv.tkip_timer), rtlpriv->pifp, rtw_use_tkipkey_handler, rtlpriv); */
+
+	if (_rtw_init_sta_priv(&rtlpriv->stapriv) == _FAIL) {
+		printk("rtl8821au: Can't _rtw_init_sta_priv\n");
+		ret8 = _FAIL;
+		goto exit;
+	}
+
+	rtlpriv->stapriv.rtlpriv = rtlpriv;
+	rtlpriv->setband = GHZ24_50;
+	rtw_init_bcmc_stainfo(rtlpriv);
+
+	rtw_init_pwrctrl_priv(rtlpriv);
+
+	/* memset((uint8_t *)&rtlpriv->qospriv, 0, sizeof (struct qos_priv));//move to mlme_priv */
+
+
+	rtlpriv->cfg->ops->dm_init(rtlpriv);
+	rtlpriv->cfg->ops->init_sw_leds(rtlpriv);
+
+exit:
+
+	return ret8;
+
+}
+
+static void rtl8821au_deinit_sw_vars(struct rtl_priv *rtlpriv)
+{
+	kfree(rtlpriv->rtlhal.pfirmware);
+	rtlpriv->rtlhal.pfirmware = NULL;
+}
+
+/* get bt coexist status */
+static bool rtl8821au_get_btc_status(void)
+{
+	return false;
+}
+
+static struct rtl_hal_ops rtl8821au_hal_ops = {
+	/*
+	 * New HAL functions with struct net_device  as first param
+	 * this can be (hopefully)switched to struct ieee80211_hw
+	 */
+	 
+	 /* ULLI : API table stolen form rtl8192cu */
+
+	.init_sw_vars	= rtl8821au_init_sw_vars,
+	.deinit_sw_vars	= rtl8821au_deinit_sw_vars,
+
+	/* ULLI : must check API here */
+	.read_chip_version =	rtl8821au_read_chip_version,
+	/* ULLI : somewhere in the source, nanme ?? ... */
+
+#if 0	/* ULLI : _rtl8821au_read_adapter_info(), maybe */
+	.read_eeprom_info = rtl8821au_read_eeprom_info,
+#endif
+
+	.enable_interrupt = rtl8821au_enable_interrupt,
+	.disable_interrupt = rtl8821au_disable_interrupt,
+
+	.hw_init =	 	rtl8812au_hw_init,
+
+#if 0	
+	.hw_disable = rtl8821au_card_disable,
+#endif	
+
+	.set_network_type = rtl8821au_set_network_type,
+
+#if 0
+	.set_chk_bssid = rtl8821au_set_check_bssid,
+	.set_qos = rtl8821au_set_qos,
+	.set_bcn_reg = rtl8821au_set_beacon_related_registers,
+	.set_bcn_intv = rtl8821au_set_beacon_interval,
+	.update_interrupt_mask = rtl8821_update_interrupt_mask,
+#endif	
+
+	/* ULLI : check API */
+	.set_hw_reg =	 	rtl8821au_set_hw_reg,
+	.get_hw_reg = 		rtl8821au_get_hw_reg,
+	
+#if 0	/* ULLI : currently not known */
+	.update_rate_tbl = rtl8821_update_hal_rate_tbl,
+#endif	
+
+#if 0	/* ULLI : somewhere in the tx path mess */
+	.fill_tx_desc = rtl8821au_tx_fill_desc,
+#endif
+	/* ULLI : maybe wrong API */
+	.fill_fake_txdesc	= rtl8821au_fill_fake_txdesc,
+	
+#if 0	/* ULLI : somewhere in the tx path mess */
+	.fill_tx_cmdesc = rtl8821au_tx_fill_cmddesc,
+#endif
+
+#if 0	/* ULLI : somewhere in the rx path mess */
+	.query_rx_desc = rtl8821au_rx_query_desc,
+#endif
+
+#if 0	/* ULLI : currently not known */
+	.set_channel_access = rtl8821au_update_channel_access_setting,
+#endif
+	/* ULLI : check params */
+	.radio_onoff_checking = rtl8821au_gpio_radio_on_off_checking,
+
+#if 0	/* ULLI : maybe in old HAL ops */
+	.set_bw_mode = rtl8821au_phy_set_bw_mode,
+	.switch_channel = rtl8821au_phy_sw_chanl,
+#endif
+	.dm_watchdog = rtl8821au_dm_watchdog,
+
+#if 0
+	/* ULLI : rtlwifi function here ? */
+	.scan_operation_backup = rtl_phy_scan_operation_backup,
+#endif
+
+#if 0	/* ULLI : currently not known */
+	.set_rf_power_state = rtl8821au_phy_set_rf_power_state,
+#endif
+
+	.led_control	= rtl8821au_led_control,
+
+#if 0	/* ULLI : hmm, see in cam.c of rtlwifi ?? */
+	.enable_hw_sec = rtl8821au_enable_hw_security_setup,
+	.set_key = rtl8821au_set_key,
+#endif
+
+	.init_sw_leds = rtl8821au_init_sw_leds,
+	.deinit_sw_leds = rtl8821au_deinit_sw_leds,
+
+	.get_bbreg = 	rtl8821au_phy_query_bb_reg,
+	.set_bbreg = 	rtl8821au_phy_set_bb_reg,
+	.get_rfreg = 	rtl8821au_phy_query_rf_reg,
+	.set_rfreg = 	rtl8821au_phy_set_rf_reg,
+
+	/* ULLI : need to check params herer */
+	.phy_rf6052_config = rtl8821au_phy_rf6052_config,
+	.phy_rf6052_set_cck_txpower = rtl8821au_phy_rf6052_set_cck_txpower,
+	.phy_rf6052_set_ofdm_txpower = rtl8821au_phy_rf6052_set_ofdm_txpower,
+	.config_bb_with_headerfile = _rtl8821au_phy_config_bb_with_headerfile,
+	.config_bb_with_pgheaderfile = _rtl8821au_phy_config_bb_with_pgheaderfile,
+#if 0
+	.phy_lc_calibrate = rtl8821au_phy_lc_calibrate,
+#endif
+	.phy_set_bw_mode_callback = rtl8821au_phy_set_bw_mode_callback,
+#if 0
+	.dm_dynamic_txpower = rtl8821au_dm_dynamic_txpower,
+#endif
+	.fill_h2c_cmd = rtl8821au_fill_h2c_cmd,
+	.get_btc_status = rtl8821au_get_btc_status,
+	.set_bcn_reg = 	rtl8821au_set_beacon_related_registers,
+
+	/** ** */
+
+	/* Old HAL functions */
+
+	.hal_deinit = 		rtl8812au_hal_deinit,
+
+	/* .free_hal_data = rtl8192c_free_hal_data, */
+
+	.inirp_deinit =		rtl8812au_inirp_deinit,
+
+	.init_recv_priv =	rtl8812au_init_recv_priv,
+	.free_recv_priv =	rtl8812au_free_recv_priv,
+	.init_default_value =	rtl8812au_init_default_value,
+	.read_adapter_info =	_rtl8821au_read_adapter_info,
+
+	/* .set_bwmode_handler = 	PHY_SetBWMode8192C; */
+	/* .set_channel_handler = 	PHY_SwChnl8192C; */
+
+	/* .Add_RateATid = &rtl8192c_Add_RateATid, */
+
+	.hal_xmit = 		rtl8812au_hal_xmit,
+	.mgnt_xmit = 		rtl8812au_mgnt_xmit,
+	.hal_xmitframe_enqueue = 	rtl8812au_hal_xmitframe_enqueue,
+
+	.free_hal_data =	rtl8812_free_hal_data,
+
+	.dm_init =		rtl8812_init_dm_priv,
+
+
+	.set_bwmode_handler =	PHY_SetBWMode8812,
+	.set_channel_handler =	PHY_SwChnl8812,
+	.set_chnl_bw_handler =	PHY_SetSwChnlBWMode8812,
+
+	.Add_RateATid =		rtl8812_Add_RateATid,
+};
+
+static struct rtl_hal_usbint_cfg rtl8821au_interface_cfg = {
+#if 0
+	/* rx */
+	.in_ep_num = RTL92C_USB_BULK_IN_NUM,
+	.rx_urb_num = RTL92C_NUM_RX_URBS,
+	.rx_max_size = RTL92C_SIZE_MAX_RX_BUFFER,
+	.usb_rx_hdl = rtl8192cu_rx_hdl,
+	.usb_rx_segregate_hdl = NULL, /* rtl8192c_rx_segregate_hdl; */
+	/* tx */
+	.usb_tx_cleanup = rtl8192c_tx_cleanup,
+	.usb_tx_post_hdl = rtl8192c_tx_post_hdl,
+	.usb_tx_aggregate_hdl = rtl8192c_tx_aggregate_hdl,
+	/* endpoint mapping */
+#endif
+	.usb_endpoint_mapping = rtl8821au_endpoint_mapping,
+#if 0
+	.usb_mq_to_hwq = rtl8192cu_mq_to_hwq,
+#endif	
+};
+
+/* ULLI : shamelessly copied from rtlwifi */
+
+static struct rtl_mod_params rtl8821au_mod_params = {
+	.sw_crypto = false,
+	.inactiveps = true,
+	.swctrl_lps = false,
+	.fwctrl_lps = true,
+	.msi_support = true,
+	.debug = DBG_EMERG,
+	.disable_watchdog = 0,
+};
+
+static struct rtl_hal_cfg rtl8821au_hal_cfg = {
+	.name = "rtl8821au",
+	.fw_name = "rtlwifi/rtl8821aufw.bin",	/* ULLI note two files */
+	.ops = &rtl8821au_hal_ops,
+	.mod_params = &rtl8821au_mod_params,
+	.usb_interface_cfg = &rtl8821au_interface_cfg,
+
+	.maps[SYS_ISO_CTRL] = REG_SYS_ISO_CTRL,
+#if 0
+	.maps[SYS_FUNC_EN] = REG_SYS_FUNC_EN,
+	.maps[SYS_CLK] = REG_SYS_CLKR,
+	.maps[MAC_RCR_AM] = AM,
+	.maps[MAC_RCR_AB] = AB,
+	.maps[MAC_RCR_ACRC32] = ACRC32,
+	.maps[MAC_RCR_ACF] = ACF,
+	.maps[MAC_RCR_AAP] = AAP,
+#endif
+	.maps[EFUSE_TEST] = REG_EFUSE_TEST,
+	.maps[EFUSE_CTRL] = REG_EFUSE_CTRL,
+	.maps[EFUSE_CLK] = 0,
+	.maps[EFUSE_CLK_CTRL] = REG_EFUSE_CTRL,
+	.maps[EFUSE_PWC_EV12V] = PWC_EV12V,
+	.maps[EFUSE_FEN_ELDR] = FEN_ELDR,
+	.maps[EFUSE_LOADER_CLK_EN] = LOADER_CLK_EN,
+	.maps[EFUSE_ANA8M] = ANA8M,
+	.maps[EFUSE_HWSET_MAX_SIZE] = EFUSE_MAP_LEN_JAGUAR,	/* ULLI : or HWSET_MAX_SIZE */
+	.maps[EFUSE_MAX_SECTION_MAP] = EFUSE_MAX_SECTION_JAGUAR,	/* ULLI : or EFUSE_MAX_SECTION */
+	.maps[EFUSE_REAL_CONTENT_SIZE] =  EFUSE_REAL_CONTENT_LEN_JAGUAR,	/* ULLI : EFUSE_REAL_CONTENT_LEN */
+	.maps[EFUSE_OOB_PROTECT_BYTES_LEN] = EFUSE_OOB_PROTECT_BYTES_JAGUAR,	/* ULLI : EFUSE_OOB_PROTECT_BYTES */
+	.maps[EFUSE_ACCESS] = REG_EFUSE_BURN_GNT_8812, /* ULLI : or REG_EFUSE_ACCESS as in rtlwifi */
+
+	.maps[RWCAM] = REG_CAMCMD,
+	.maps[WCAMI] = REG_CAMWRITE,
+	.maps[RCAMO] = REG_CAMREAD,
+	.maps[CAMDBG] = REG_CAMDBG,
+	.maps[SECR] = REG_SECCFG,
+	.maps[SEC_CAM_NONE] = CAM_NONE,
+	.maps[SEC_CAM_WEP40] = CAM_WEP40,
+	.maps[SEC_CAM_TKIP] = CAM_TKIP,
+	.maps[SEC_CAM_AES] = CAM_AES,
+	.maps[SEC_CAM_WEP104] = CAM_WEP104,
+#if 0
+	.maps[RTL_IMR_BCNDMAINT6] = IMR_BCNDMAINT6,
+	.maps[RTL_IMR_BCNDMAINT5] = IMR_BCNDMAINT5,
+	.maps[RTL_IMR_BCNDMAINT4] = IMR_BCNDMAINT4,
+	.maps[RTL_IMR_BCNDMAINT3] = IMR_BCNDMAINT3,
+	.maps[RTL_IMR_BCNDMAINT2] = IMR_BCNDMAINT2,
+	.maps[RTL_IMR_BCNDMAINT1] = IMR_BCNDMAINT1,
+/*	.maps[RTL_IMR_BCNDOK8] = IMR_BCNDOK8,     */   /*need check*/
+	.maps[RTL_IMR_BCNDOK7] = IMR_BCNDOK7,
+	.maps[RTL_IMR_BCNDOK6] = IMR_BCNDOK6,
+	.maps[RTL_IMR_BCNDOK5] = IMR_BCNDOK5,
+	.maps[RTL_IMR_BCNDOK4] = IMR_BCNDOK4,
+	.maps[RTL_IMR_BCNDOK3] = IMR_BCNDOK3,
+	.maps[RTL_IMR_BCNDOK2] = IMR_BCNDOK2,
+	.maps[RTL_IMR_BCNDOK1] = IMR_BCNDOK1,
+/*	.maps[RTL_IMR_TIMEOUT2] = IMR_TIMEOUT2,*/
+/*	.maps[RTL_IMR_TIMEOUT1] = IMR_TIMEOUT1,*/
+
+	.maps[RTL_IMR_TXFOVW] = IMR_TXFOVW,
+	.maps[RTL_IMR_PSTIMEOUT] = IMR_PSTIMEOUT,
+	.maps[RTL_IMR_BCNINT] = IMR_BCNDMAINT0,
+	.maps[RTL_IMR_RXFOVW] = IMR_RXFOVW,
+	.maps[RTL_IMR_RDU] = IMR_RDU,
+	.maps[RTL_IMR_ATIMEND] = IMR_ATIMEND,
+	.maps[RTL_IMR_BDOK] = IMR_BCNDOK0,
+	.maps[RTL_IMR_MGNTDOK] = IMR_MGNTDOK,
+	.maps[RTL_IMR_TBDER] = IMR_TBDER,
+	.maps[RTL_IMR_HIGHDOK] = IMR_HIGHDOK,
+	.maps[RTL_IMR_TBDOK] = IMR_TBDOK,
+	.maps[RTL_IMR_BKDOK] = IMR_BKDOK,
+	.maps[RTL_IMR_BEDOK] = IMR_BEDOK,
+	.maps[RTL_IMR_VIDOK] = IMR_VIDOK,
+	.maps[RTL_IMR_VODOK] = IMR_VODOK,
+	.maps[RTL_IMR_ROK] = IMR_ROK,
+	.maps[RTL_IBSS_INT_MASKS] = (IMR_BCNDMAINT0 | IMR_TBDOK | IMR_TBDER),
+#endif
+	/* Ths is for the core of rtlwifi */
+	.maps[RTL_RC_CCK_RATE1M] = DESC_RATE1M,
+	.maps[RTL_RC_CCK_RATE2M] =  DESC_RATE2M,
+	.maps[RTL_RC_CCK_RATE5_5M] =  DESC_RATE5_5M,
+	.maps[RTL_RC_CCK_RATE11M] =  DESC_RATE11M,
+	.maps[RTL_RC_OFDM_RATE6M] =  DESC_RATE6M,
+	.maps[RTL_RC_OFDM_RATE9M] =  DESC_RATE9M,
+	.maps[RTL_RC_OFDM_RATE12M] =  DESC_RATE12M,
+	.maps[RTL_RC_OFDM_RATE18M] =  DESC_RATE18M,
+	.maps[RTL_RC_OFDM_RATE24M] =  DESC_RATE24M,
+	.maps[RTL_RC_OFDM_RATE36M] =  DESC_RATE36M,
+	.maps[RTL_RC_OFDM_RATE48M] =  DESC_RATE48M,
+	.maps[RTL_RC_OFDM_RATE54M] =  DESC_RATE54M,
+
+	.maps[RTL_RC_HT_RATEMCS7] =  DESC_RATEMCS7,
+	.maps[RTL_RC_HT_RATEMCS15] =  DESC_RATEMCS15,
+
+	/*VHT hightest rate*/
+	.maps[RTL_RC_VHT_RATE_1SS_MCS7] = DESC_RATEVHT1SS_MCS7,
+	.maps[RTL_RC_VHT_RATE_1SS_MCS8] = DESC_RATEVHT1SS_MCS8,
+	.maps[RTL_RC_VHT_RATE_1SS_MCS9] = DESC_RATEVHT1SS_MCS9,
+	
+	/* ULLI : VHT rates for 2SS are decided in base.c of rtlwifi */
+	
+	.maps[RTL_RC_VHT_RATE_2SS_MCS7] = DESC_RATEVHT2SS_MCS7,
+	.maps[RTL_RC_VHT_RATE_2SS_MCS8] = DESC_RATEVHT2SS_MCS8,
+	.maps[RTL_RC_VHT_RATE_2SS_MCS9] = DESC_RATEVHT2SS_MCS9,
+};
+
+
+
+extern int rtw_bw_mode;
+
+static int rtw_drv_init(struct usb_interface *pusb_intf,const struct usb_device_id *pdid);
+static void rtw_dev_remove(struct usb_interface *pusb_intf);
+
+#define USB_VENDER_ID_REALTEK		0x0BDA
+
+
+/* DID_USB_v916_20130116 */
+static struct usb_device_id rtw_usb_id_tbl[] ={
+	/* RTL8812AU */
+	/*=== Realtek demoboard ===*/
+	{USB_DEVICE(USB_VENDER_ID_REALTEK, 0x8812),.driver_info = RTL8812},/* Default ID */
+	{USB_DEVICE(USB_VENDER_ID_REALTEK, 0x881A),.driver_info = RTL8812},/* Default ID */
+	{USB_DEVICE(USB_VENDER_ID_REALTEK, 0x881B),.driver_info = RTL8812},/* Default ID */
+	{USB_DEVICE(USB_VENDER_ID_REALTEK, 0x881C),.driver_info = RTL8812},/* Default ID */
+	/*=== Customer ID ===*/
+	{USB_DEVICE(0x050D, 0x1109),.driver_info = RTL8812}, /* Belkin F9L1109 - SerComm */
+	{USB_DEVICE(0x2001, 0x330E),.driver_info = RTL8812}, /* D-Link - ALPHA */
+	{USB_DEVICE(0x7392, 0xA822),.driver_info = RTL8812}, /* Edimax - Edimax */
+	{USB_DEVICE(0x0DF6, 0x0074),.driver_info = RTL8812}, /* Sitecom - Edimax */
+	{USB_DEVICE(0x04BB, 0x0952),.driver_info = RTL8812}, /* I-O DATA - Edimax */
+	{USB_DEVICE(0x0789, 0x016E),.driver_info = RTL8812}, /* Logitec - Edimax */
+	{USB_DEVICE(0x0409, 0x0408),.driver_info = RTL8812}, /* NEC - */
+	{USB_DEVICE(0x0B05, 0x17D2),.driver_info = RTL8812}, /* ASUS - Edimax */
+	{USB_DEVICE(0x0E66, 0x0022),.driver_info = RTL8812}, /* HAWKING - Edimax */
+	{USB_DEVICE(0x0586, 0x3426),.driver_info = RTL8812}, /* ZyXEL - */
+	{USB_DEVICE(0x2001, 0x3313),.driver_info = RTL8812}, /* D-Link - ALPHA */
+	{USB_DEVICE(0x1058, 0x0632),.driver_info = RTL8812}, /* WD - Cybertan*/
+	{USB_DEVICE(0x1740, 0x0100),.driver_info = RTL8812}, /* EnGenius - EnGenius */
+	{USB_DEVICE(0x2019, 0xAB30),.driver_info = RTL8812}, /* Planex - Abocom */
+	{USB_DEVICE(0x07B8, 0x8812),.driver_info = RTL8812}, /* Abocom - Abocom */
+	{USB_DEVICE(0x2001, 0x3315),.driver_info = RTL8812}, /* D-Link - Cameo */
+	{USB_DEVICE(0x2001, 0x3316),.driver_info = RTL8812}, /* D-Link - Cameo */
+	{USB_DEVICE(0x20F4, 0x805B),.driver_info = RTL8812}, /* TRENDnet - Cameo */
+	{USB_DEVICE(0x13B1, 0x003F),.driver_info = RTL8812}, /* Linksys - SerComm */
+	{USB_DEVICE(0x2357, 0x0101),.driver_info = RTL8812}, /* TP-Link - T4U */
+	{USB_DEVICE(0x0BDA, 0x8812),.driver_info = RTL8812}, /* Alfa AWUS036AC */
+
+	/* RTL8821AU */
+        /*=== Realtek demoboard ===*/
+	{USB_DEVICE(USB_VENDER_ID_REALTEK, 0x0811),.driver_info = RTL8821},/* Default ID */
+	{USB_DEVICE(USB_VENDER_ID_REALTEK, 0x0821),.driver_info = RTL8821},/* Default ID */
+	{USB_DEVICE(USB_VENDER_ID_REALTEK, 0x8822),.driver_info = RTL8821},/* Default ID */
+	/*=== Customer ID ===*/
+	{USB_DEVICE(0x7392, 0xA811),.driver_info = RTL8821}, /* Edimax - Edimax */
+	{USB_DEVICE(0x0BDA, 0xA811),.driver_info = RTL8821}, /* OUTLINK - Edimax */
+	{USB_DEVICE(0x7392, 0xA812),.driver_info = RTL8821}, /* Edimax - Edimax */
+	{USB_DEVICE(0x2001, 0x3314),.driver_info = RTL8821}, /* D-Link - Cameo */
+	{USB_DEVICE(0x0846, 0x9052),.driver_info = RTL8821}, /* Netgear - A6100 */
+	{USB_DEVICE(0x0411, 0x0242),.driver_info = RTL8821}, /* BUFFALO - Edimax */
+	{}	/* Terminating entry */
+};
+
+MODULE_DEVICE_TABLE(usb, rtw_usb_id_tbl);
+
+/*
+ *
+ * ULLI : We can only track rtl8821au devices via MAC Addr.
+ * ULLI : For every device we need an entry for MAC, USB Speed index and
+ * ULLI : last seen
+ *
+ * ULLI : Note about this hack ...
+ * ULLI : switch UBS3 capable device to superspeed mode
+ * ULLI : Note about device behind a USB2 HUB and/or User (re)plugs device
+ * ULLI : we need a simple byteswise read/write to track the device.
+ * ULLI : This must be done before registering this device as ethernet or
+ * ULLI : ieee80211 hw.
+ *
+ */
+
+struct rtl8821au_probed_devices {
+	struct list_head list;
+	uint8_t mac[ETH_ALEN];
+	int speed;
+	unsigned long jiffies;
+};
+
+static LIST_HEAD(rtl8821_devices);
+spinlock_t rtl8821au_devices_lock;
+
+static int rtl8821au_probe(struct usb_interface *pusb_intf, const struct usb_device_id *pdid)
+{
+	struct usb_device *udev;
+	char *speed;
+	char *driver_info;
+
+	udev = interface_to_usbdev(pusb_intf);
+	switch (udev->speed) {
+		case USB_SPEED_LOW :	speed = "LOW";
+					break;
+		case USB_SPEED_FULL :	speed = "FULL";
+					break;
+		case USB_SPEED_HIGH :	speed = "HIGH";
+					break;
+		case USB_SPEED_SUPER :	speed = "HIGH";
+					break;
+		default :		speed = "UNKNOWN";
+					break;
+	}
+
+	switch (pdid->driver_info) {
+		case RTL8812 :	driver_info ="RTL8812";
+				break;
+
+		case RTL8821 :	driver_info ="RTL8821";
+				break;
+	}
+
+#if 0
+	dev_info(&pusb_intf->dev, "Register : %s USB-ID %04x:%04x as %s Speed\n",
+		driver_info, pdid->idVendor, pdid->idProduct, speed);
+#endif
+	return rtw_usb_probe(pusb_intf, pdid, &rtl8821au_hal_cfg);
+}
+
+
+static struct usb_driver rtl8821au_usb_drv = {
+	.name = RTL8821AU_DRIVER_NAME,
+	.probe = rtl8821au_probe,
+	.disconnect = rtw_usb_disconnect,
+	.id_table = rtw_usb_id_tbl,
+#if 0
+	.suspend =  rtl8821au_suspend,
+	.resume = rtl8821au_resume,
+  	.reset_resume   = rtl8821au_resume,
+#endif
+#ifdef CONFIG_AUTOSUSPEND
+	.supports_autosuspend = 1,
+#endif
+
+};
+
+static int __init rtl8821au_module_init(void)
+{
+	int res;
+
+	res = usb_register(&rtl8821au_usb_drv);
+	if (res < 0)
+		pr_err(RTL8821AU_DRIVER_NAME ": usb_register() failed (%i)\n", res);
+
+	spin_lock_init(&rtl8821au_devices_lock);
+
+	return res;
+}
+
+static void __exit rtl8821au_module_exit(void)
+{
+	usb_deregister(&rtl8821au_usb_drv);
+}
+
+MODULE_DEVICE_TABLE(usb, rtw_usb_id_tbl);
+
+module_init(rtl8821au_module_init);
+module_exit(rtl8821au_module_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Realtek Wireless Lan Driver");
+MODULE_AUTHOR("Hans Ulli Kroll <ulli.kroll@googlemail.com>");
+MODULE_VERSION("git. based on v4.2.2_7502.20130517");
+
+module_param_named(swenc, rtl8821au_mod_params.sw_crypto, bool, 0444);
+module_param_named(ips, rtl8821au_mod_params.inactiveps, bool, 0444);
+module_param_named(debug, rtl8821au_mod_params.debug, int, 0444);
+
+MODULE_PARM_DESC(swenc, "Set to 1 for software crypto (default 0)\n");
+MODULE_PARM_DESC(ips, "Set to 0 to not use link power save (default 1)\n");
+MODULE_PARM_DESC(debug, "Set debug level (0-5) (default 0)");
diff -Naur linux-4.9/drivers/staging/rtl8821au/rtl8821au/sw.h linux-4.9.8821au/drivers/staging/rtl8821au/rtl8821au/sw.h
--- linux-4.9/drivers/staging/rtl8821au/rtl8821au/sw.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/rtl8821au/sw.h	2016-12-11 19:48:25.183645006 -0600
@@ -0,0 +1,6 @@
+#ifndef __RTL8821AU_SW_H__
+#define __RTL8821AU_SW_H__
+
+#include <rtl8812a_hal.h>
+
+#endif
diff -Naur linux-4.9/drivers/staging/rtl8821au/rtl8821au/table.c linux-4.9.8821au/drivers/staging/rtl8821au/rtl8821au/table.c
--- linux-4.9/drivers/staging/rtl8821au/rtl8821au/table.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/rtl8821au/table.c	2016-12-11 19:48:25.186978326 -0600
@@ -0,0 +1,4031 @@
+#include "table.h"
+
+u32 RTL8812AU_RADIOA_ARRAY[] = {
+		0x000, 0x00010000,
+		0x018, 0x0001712A,
+		0x056, 0x00051CF2,
+		0x066, 0x00040000,
+		0x01E, 0x00080000,
+		0x089, 0x00000080,
+	0xFF0F0740, 0xABCD,
+		0x086, 0x00014B38,
+	0xFF0F07C0, 0xCDEF,
+		0x086, 0x00014B38,
+	0xFF0F07D8, 0xCDEF,
+		0x086, 0x00014B3C,
+	0xCDCDCDCD, 0xCDCD,
+		0x086, 0x00014B38,
+	0xFF0F0740, 0xDEAD,
+		0x0B1, 0x0001FC1A,
+		0x0B3, 0x000F0810,
+		0x0B4, 0x0001A78D,
+		0x0BA, 0x00086180,
+		0x018, 0x00000006,
+		0x0EF, 0x00002000,
+		0x03B, 0x00038A58,
+		0x03B, 0x00037A58,
+		0x03B, 0x0002A590,
+		0x03B, 0x00027A50,
+		0x03B, 0x00018248,
+		0x03B, 0x00010240,
+		0x03B, 0x00008240,
+		0x03B, 0x00000240,
+		0x0EF, 0x00000100,
+	0xFF0F07D8, 0xABCD,
+		0x034, 0x0000A4EE,
+		0x034, 0x00009076,
+		0x034, 0x00008073,
+		0x034, 0x00007070,
+		0x034, 0x0000606D,
+		0x034, 0x0000506A,
+		0x034, 0x00004049,
+		0x034, 0x00003046,
+		0x034, 0x00002028,
+		0x034, 0x00001025,
+		0x034, 0x00000022,
+	0xCDCDCDCD, 0xCDCD,
+		0x034, 0x0000ADF4,
+		0x034, 0x00009DF1,
+		0x034, 0x00008DEE,
+		0x034, 0x00007DEB,
+		0x034, 0x00006DE8,
+		0x034, 0x00005CEC,
+		0x034, 0x00004CE9,
+		0x034, 0x000034EA,
+		0x034, 0x000024E7,
+		0x034, 0x0000146B,
+		0x034, 0x0000006D,
+	0xFF0F07D8, 0xDEAD,
+		0x0EF, 0x00000000,
+		0x0EF, 0x000020A2,
+		0x0DF, 0x00000080,
+		0x035, 0x00000192,
+		0x035, 0x00008192,
+		0x035, 0x00010192,
+		0x036, 0x00000024,
+		0x036, 0x00008024,
+		0x036, 0x00010024,
+		0x036, 0x00018024,
+		0x0EF, 0x00000000,
+		0x051, 0x00000C21,
+		0x052, 0x000006D9,
+		0x053, 0x000FC649,
+		0x054, 0x0000017E,
+		0x0EF, 0x00000002,
+		0x008, 0x00008400,
+		0x018, 0x0001712A,
+		0x0EF, 0x00001000,
+		0x03A, 0x00000080,
+		0x03B, 0x0003A02C,
+		0x03C, 0x00004000,
+		0x03A, 0x00000400,
+		0x03B, 0x0003202C,
+		0x03C, 0x00010000,
+		0x03A, 0x000000A0,
+		0x03B, 0x0002B064,
+		0x03C, 0x00004000,
+		0x03A, 0x000000D8,
+		0x03B, 0x00023070,
+		0x03C, 0x00004000,
+		0x03A, 0x00000468,
+		0x03B, 0x0001B870,
+		0x03C, 0x00010000,
+		0x03A, 0x00000098,
+		0x03B, 0x00012085,
+		0x03C, 0x000E4000,
+		0x03A, 0x00000418,
+		0x03B, 0x0000A080,
+		0x03C, 0x000F0000,
+		0x03A, 0x00000418,
+		0x03B, 0x00002080,
+		0x03C, 0x00010000,
+		0x03A, 0x00000080,
+		0x03B, 0x0007A02C,
+		0x03C, 0x00004000,
+		0x03A, 0x00000400,
+		0x03B, 0x0007202C,
+		0x03C, 0x00010000,
+		0x03A, 0x000000A0,
+		0x03B, 0x0006B064,
+		0x03C, 0x00004000,
+		0x03A, 0x000000D8,
+		0x03B, 0x00023070,
+		0x03C, 0x00004000,
+		0x03A, 0x00000468,
+		0x03B, 0x0005B870,
+		0x03C, 0x00010000,
+		0x03A, 0x00000098,
+		0x03B, 0x00052085,
+		0x03C, 0x000E4000,
+		0x03A, 0x00000418,
+		0x03B, 0x0004A080,
+		0x03C, 0x000F0000,
+		0x03A, 0x00000418,
+		0x03B, 0x00042080,
+		0x03C, 0x00010000,
+		0x03A, 0x00000080,
+		0x03B, 0x000BA02C,
+		0x03C, 0x00004000,
+		0x03A, 0x00000400,
+		0x03B, 0x000B202C,
+		0x03C, 0x00010000,
+		0x03A, 0x000000A0,
+		0x03B, 0x000AB064,
+		0x03C, 0x00004000,
+		0x03A, 0x000000D8,
+		0x03B, 0x000A3070,
+		0x03C, 0x00004000,
+		0x03A, 0x00000468,
+		0x03B, 0x0009B870,
+		0x03C, 0x00010000,
+		0x03A, 0x00000098,
+		0x03B, 0x00092085,
+		0x03C, 0x000E4000,
+		0x03A, 0x00000418,
+		0x03B, 0x0008A080,
+		0x03C, 0x000F0000,
+		0x03A, 0x00000418,
+		0x03B, 0x00082080,
+		0x03C, 0x00010000,
+		0x0EF, 0x00001100,
+	0xFF0F0740, 0xABCD,
+		0x034, 0x0004A0B2,
+		0x034, 0x000490AF,
+		0x034, 0x00048070,
+		0x034, 0x0004706D,
+		0x034, 0x00046050,
+		0x034, 0x0004504D,
+		0x034, 0x0004404A,
+		0x034, 0x00043047,
+		0x034, 0x0004200A,
+		0x034, 0x00041007,
+		0x034, 0x00040004,
+	0xFF0F07C0, 0xCDEF,
+		0x034, 0x0004A0B2,
+		0x034, 0x000490AF,
+		0x034, 0x00048070,
+		0x034, 0x0004706D,
+		0x034, 0x00046050,
+		0x034, 0x0004504D,
+		0x034, 0x0004404A,
+		0x034, 0x00043047,
+		0x034, 0x0004200A,
+		0x034, 0x00041007,
+		0x034, 0x00040004,
+	0xFF0F07D8, 0xCDEF,
+		0x034, 0x0004A0B2,
+		0x034, 0x000490AF,
+		0x034, 0x00048070,
+		0x034, 0x0004706D,
+		0x034, 0x00046050,
+		0x034, 0x0004504D,
+		0x034, 0x0004404A,
+		0x034, 0x00043047,
+		0x034, 0x0004200A,
+		0x034, 0x00041007,
+		0x034, 0x00040004,
+	0xCDCDCDCD, 0xCDCD,
+		0x034, 0x0004ADF5,
+		0x034, 0x00049DF2,
+		0x034, 0x00048DEF,
+		0x034, 0x00047DEC,
+		0x034, 0x00046DE9,
+		0x034, 0x00045DC9,
+		0x034, 0x00044CE8,
+		0x034, 0x000438CA,
+		0x034, 0x00042889,
+		0x034, 0x0004184A,
+		0x034, 0x0004044A,
+	0xFF0F0740, 0xDEAD,
+	0xFF0F0740, 0xABCD,
+		0x034, 0x0002A0B2,
+		0x034, 0x000290AF,
+		0x034, 0x00028070,
+		0x034, 0x0002706D,
+		0x034, 0x00026050,
+		0x034, 0x0002504D,
+		0x034, 0x0002404A,
+		0x034, 0x00023047,
+		0x034, 0x0002200A,
+		0x034, 0x00021007,
+		0x034, 0x00020004,
+	0xFF0F07C0, 0xCDEF,
+		0x034, 0x0002A0B2,
+		0x034, 0x000290AF,
+		0x034, 0x00028070,
+		0x034, 0x0002706D,
+		0x034, 0x00026050,
+		0x034, 0x0002504D,
+		0x034, 0x0002404A,
+		0x034, 0x00023047,
+		0x034, 0x0002200A,
+		0x034, 0x00021007,
+		0x034, 0x00020004,
+	0xFF0F07D8, 0xCDEF,
+		0x034, 0x0002A0B2,
+		0x034, 0x000290AF,
+		0x034, 0x00028070,
+		0x034, 0x0002706D,
+		0x034, 0x00026050,
+		0x034, 0x0002504D,
+		0x034, 0x0002404A,
+		0x034, 0x00023047,
+		0x034, 0x0002200A,
+		0x034, 0x00021007,
+		0x034, 0x00020004,
+	0xCDCDCDCD, 0xCDCD,
+		0x034, 0x0002ADF5,
+		0x034, 0x00029DF2,
+		0x034, 0x00028DEF,
+		0x034, 0x00027DEC,
+		0x034, 0x00026DE9,
+		0x034, 0x00025DC9,
+		0x034, 0x00024CE8,
+		0x034, 0x000238CA,
+		0x034, 0x00022889,
+		0x034, 0x0002184A,
+		0x034, 0x0002044A,
+	0xFF0F0740, 0xDEAD,
+	0xFF0F0740, 0xABCD,
+		0x034, 0x0000A0B2,
+		0x034, 0x000090AF,
+		0x034, 0x00008070,
+		0x034, 0x0000706D,
+		0x034, 0x00006050,
+		0x034, 0x0000504D,
+		0x034, 0x0000404A,
+		0x034, 0x00003047,
+		0x034, 0x0000200A,
+		0x034, 0x00001007,
+		0x034, 0x00000004,
+	0xFF0F07C0, 0xCDEF,
+		0x034, 0x0000A0B2,
+		0x034, 0x000090AF,
+		0x034, 0x00008070,
+		0x034, 0x0000706D,
+		0x034, 0x00006050,
+		0x034, 0x0000504D,
+		0x034, 0x0000404A,
+		0x034, 0x00003047,
+		0x034, 0x0000200A,
+		0x034, 0x00001007,
+		0x034, 0x00000004,
+	0xFF0F07D8, 0xCDEF,
+		0x034, 0x0000A0B2,
+		0x034, 0x000090AF,
+		0x034, 0x00008070,
+		0x034, 0x0000706D,
+		0x034, 0x00006050,
+		0x034, 0x0000504D,
+		0x034, 0x0000404A,
+		0x034, 0x00003047,
+		0x034, 0x0000200A,
+		0x034, 0x00001007,
+		0x034, 0x00000004,
+	0xCDCDCDCD, 0xCDCD,
+		0x034, 0x0000AFF7,
+		0x034, 0x00009DF7,
+		0x034, 0x00008DF4,
+		0x034, 0x00007DF1,
+		0x034, 0x00006DEE,
+		0x034, 0x00005DCD,
+		0x034, 0x00004CEB,
+		0x034, 0x000038CC,
+		0x034, 0x0000288B,
+		0x034, 0x0000184C,
+		0x034, 0x0000044C,
+	0xFF0F0740, 0xDEAD,
+		0x0EF, 0x00000000,
+	0xFF0F0740, 0xABCD,
+		0x018, 0x0001712A,
+		0x0EF, 0x00000040,
+		0x035, 0x000001D4,
+		0x035, 0x000081D4,
+		0x035, 0x000101D4,
+		0x035, 0x000201B4,
+		0x035, 0x000281B4,
+		0x035, 0x000301B4,
+		0x035, 0x000401B4,
+		0x035, 0x000481B4,
+		0x035, 0x000501B4,
+	0xFF0F07C0, 0xCDEF,
+		0x018, 0x0001712A,
+		0x0EF, 0x00000040,
+		0x035, 0x000001D4,
+		0x035, 0x000081D4,
+		0x035, 0x000101D4,
+		0x035, 0x000201B4,
+		0x035, 0x000281B4,
+		0x035, 0x000301B4,
+		0x035, 0x000401B4,
+		0x035, 0x000481B4,
+		0x035, 0x000501B4,
+	0xFF0F07D8, 0xCDEF,
+		0x018, 0x0001712A,
+		0x0EF, 0x00000040,
+		0x035, 0x000001D4,
+		0x035, 0x000081D4,
+		0x035, 0x000101D4,
+		0x035, 0x000201B4,
+		0x035, 0x000281B4,
+		0x035, 0x000301B4,
+		0x035, 0x000401B4,
+		0x035, 0x000481B4,
+		0x035, 0x000501B4,
+	0xCDCDCDCD, 0xCDCD,
+		0x018, 0x0001712A,
+		0x0EF, 0x00000040,
+		0x035, 0x00000188,
+		0x035, 0x00008188,
+		0x035, 0x00010185,
+		0x035, 0x000201D7,
+		0x035, 0x000281D7,
+		0x035, 0x000301D5,
+		0x035, 0x000401D8,
+		0x035, 0x000481D8,
+		0x035, 0x000501D5,
+	0xFF0F0740, 0xDEAD,
+		0x0EF, 0x00000000,
+	0xFF0F0740, 0xABCD,
+		0x018, 0x0001712A,
+		0x0EF, 0x00000010,
+		0x036, 0x00004BFB,
+		0x036, 0x0000CBFB,
+		0x036, 0x00014BFB,
+		0x036, 0x0001CBFB,
+		0x036, 0x00024F4B,
+		0x036, 0x0002CF4B,
+		0x036, 0x00034F4B,
+		0x036, 0x0003CF4B,
+		0x036, 0x00044F4B,
+		0x036, 0x0004CF4B,
+		0x036, 0x00054F4B,
+		0x036, 0x0005CF4B,
+	0xFF0F07C0, 0xCDEF,
+		0x018, 0x0001712A,
+		0x0EF, 0x00000010,
+		0x036, 0x00004BFB,
+		0x036, 0x0000CBFB,
+		0x036, 0x00014BFB,
+		0x036, 0x0001CBFB,
+		0x036, 0x00024F4B,
+		0x036, 0x0002CF4B,
+		0x036, 0x00034F4B,
+		0x036, 0x0003CF4B,
+		0x036, 0x00044F4B,
+		0x036, 0x0004CF4B,
+		0x036, 0x00054F4B,
+		0x036, 0x0005CF4B,
+	0xFF0F07D8, 0xCDEF,
+		0x018, 0x0001712A,
+		0x0EF, 0x00000010,
+		0x036, 0x00004BFB,
+		0x036, 0x0000CBFB,
+		0x036, 0x00014BFB,
+		0x036, 0x0001CBFB,
+		0x036, 0x00024F4B,
+		0x036, 0x0002CF4B,
+		0x036, 0x00034F4B,
+		0x036, 0x0003CF4B,
+		0x036, 0x00044F4B,
+		0x036, 0x0004CF4B,
+		0x036, 0x00054F4B,
+		0x036, 0x0005CF4B,
+	0xCDCDCDCD, 0xCDCD,
+		0x018, 0x0001712A,
+		0x0EF, 0x00000010,
+		0x036, 0x00084EB4,
+		0x036, 0x0008C9B4,
+		0x036, 0x000949B4,
+		0x036, 0x0009C9B4,
+		0x036, 0x000A4935,
+		0x036, 0x000AC935,
+		0x036, 0x000B4935,
+		0x036, 0x000BC935,
+		0x036, 0x000C4EB4,
+		0x036, 0x000CCEB4,
+		0x036, 0x000D4EB4,
+		0x036, 0x000DCEB4,
+	0xFF0F0740, 0xDEAD,
+		0x0EF, 0x00000000,
+		0x0EF, 0x00000008,
+	0xFF0F0740, 0xABCD,
+		0x03C, 0x000002CC,
+		0x03C, 0x00000522,
+		0x03C, 0x00000902,
+	0xFF0F07C0, 0xCDEF,
+		0x03C, 0x000002CC,
+		0x03C, 0x00000522,
+		0x03C, 0x00000902,
+	0xFF0F07D8, 0xCDEF,
+		0x03C, 0x000002CC,
+		0x03C, 0x00000522,
+		0x03C, 0x00000902,
+	0xCDCDCDCD, 0xCDCD,
+		0x03C, 0x000002AA,
+		0x03C, 0x000005A2,
+		0x03C, 0x00000880,
+	0xFF0F0740, 0xDEAD,
+		0x0EF, 0x00000000,
+		0x018, 0x0001712A,
+		0x0EF, 0x00000002,
+		0x0DF, 0x00000080,
+		0x01F, 0x00040064,
+	0xFF0F0740, 0xABCD,
+		0x061, 0x000FDD43,
+		0x062, 0x00038F4B,
+		0x063, 0x00032117,
+		0x064, 0x000194AC,
+		0x065, 0x000931D1,
+	0xFF0F07C0, 0xCDEF,
+		0x061, 0x000FDD43,
+		0x062, 0x00038F4B,
+		0x063, 0x00032117,
+		0x064, 0x000194AC,
+		0x065, 0x000931D1,
+	0xFF0F07D8, 0xCDEF,
+		0x061, 0x000FDD43,
+		0x062, 0x00038F4B,
+		0x063, 0x00032117,
+		0x064, 0x000194AC,
+		0x065, 0x000931D1,
+	0xCDCDCDCD, 0xCDCD,
+		0x061, 0x000E5D53,
+		0x062, 0x00038FCD,
+		0x063, 0x000314EB,
+		0x064, 0x000196AC,
+		0x065, 0x000931D7,
+	0xFF0F0740, 0xDEAD,
+		0x008, 0x00008400,
+		0x01C, 0x000739D2,
+		0x0B4, 0x0001E78D,
+		0x018, 0x0001F12A,
+		0x0FE, 0x00000000,
+		0x0FE, 0x00000000,
+		0x0FE, 0x00000000,
+		0x0FE, 0x00000000,
+		0x0B4, 0x0001A78D,
+		0x018, 0x0001712A,
+
+};
+
+u32 RTL8812AU_RADIOB_ARRAY[] = {
+		0x056, 0x00051CF2,
+		0x066, 0x00040000,
+		0x089, 0x00000080,
+	0xFF0F0740, 0xABCD,
+		0x086, 0x00014B38,
+	0xFF0F07C0, 0xCDEF,
+		0x086, 0x00014B38,
+	0xFF0F07D8, 0xCDEF,
+		0x086, 0x00014B3C,
+	0xCDCDCDCD, 0xCDCD,
+		0x086, 0x00014B38,
+	0xFF0F0740, 0xDEAD,
+		0x018, 0x00000006,
+		0x0EF, 0x00002000,
+		0x03B, 0x00038A58,
+		0x03B, 0x00037A58,
+		0x03B, 0x0002A590,
+		0x03B, 0x00027A50,
+		0x03B, 0x00018248,
+		0x03B, 0x00010240,
+		0x03B, 0x00008240,
+		0x03B, 0x00000240,
+		0x0EF, 0x00000100,
+	0xFF0F07D8, 0xABCD,
+		0x034, 0x0000A4EE,
+		0x034, 0x00009076,
+		0x034, 0x00008073,
+		0x034, 0x00007070,
+		0x034, 0x0000606D,
+		0x034, 0x0000506A,
+		0x034, 0x00004049,
+		0x034, 0x00003046,
+		0x034, 0x00002028,
+		0x034, 0x00001025,
+		0x034, 0x00000022,
+	0xCDCDCDCD, 0xCDCD,
+		0x034, 0x0000ADF4,
+		0x034, 0x00009DF1,
+		0x034, 0x00008DEE,
+		0x034, 0x00007DEB,
+		0x034, 0x00006DE8,
+		0x034, 0x00005CEC,
+		0x034, 0x00004CE9,
+		0x034, 0x000034EA,
+		0x034, 0x000024E7,
+		0x034, 0x0000146B,
+		0x034, 0x0000006D,
+	0xFF0F07D8, 0xDEAD,
+		0x0EF, 0x00000000,
+		0x0EF, 0x000020A2,
+		0x0DF, 0x00000080,
+		0x035, 0x00000192,
+		0x035, 0x00008192,
+		0x035, 0x00010192,
+		0x036, 0x00000024,
+		0x036, 0x00008024,
+		0x036, 0x00010024,
+		0x036, 0x00018024,
+		0x0EF, 0x00000000,
+		0x051, 0x00000C21,
+		0x052, 0x000006D9,
+		0x053, 0x000FC649,
+		0x054, 0x0000017E,
+		0x0EF, 0x00000002,
+		0x008, 0x00008400,
+		0x018, 0x0001712A,
+		0x0EF, 0x00001000,
+		0x03A, 0x00000080,
+		0x03B, 0x0003A02C,
+		0x03C, 0x00004000,
+		0x03A, 0x00000400,
+		0x03B, 0x0003202C,
+		0x03C, 0x00010000,
+		0x03A, 0x000000A0,
+		0x03B, 0x0002B064,
+		0x03C, 0x00004000,
+		0x03A, 0x000000D8,
+		0x03B, 0x00023070,
+		0x03C, 0x00004000,
+		0x03A, 0x00000468,
+		0x03B, 0x0001B870,
+		0x03C, 0x00010000,
+		0x03A, 0x00000098,
+		0x03B, 0x00012085,
+		0x03C, 0x000E4000,
+		0x03A, 0x00000418,
+		0x03B, 0x0000A080,
+		0x03C, 0x000F0000,
+		0x03A, 0x00000418,
+		0x03B, 0x00002080,
+		0x03C, 0x00010000,
+		0x03A, 0x00000080,
+		0x03B, 0x0007A02C,
+		0x03C, 0x00004000,
+		0x03A, 0x00000400,
+		0x03B, 0x0007202C,
+		0x03C, 0x00010000,
+		0x03A, 0x000000A0,
+		0x03B, 0x0006B064,
+		0x03C, 0x00004000,
+		0x03A, 0x000000D8,
+		0x03B, 0x00063070,
+		0x03C, 0x00004000,
+		0x03A, 0x00000468,
+		0x03B, 0x0005B870,
+		0x03C, 0x00010000,
+		0x03A, 0x00000098,
+		0x03B, 0x00052085,
+		0x03C, 0x000E4000,
+		0x03A, 0x00000418,
+		0x03B, 0x0004A080,
+		0x03C, 0x000F0000,
+		0x03A, 0x00000418,
+		0x03B, 0x00042080,
+		0x03C, 0x00010000,
+		0x03A, 0x00000080,
+		0x03B, 0x000BA02C,
+		0x03C, 0x00004000,
+		0x03A, 0x00000400,
+		0x03B, 0x000B202C,
+		0x03C, 0x00010000,
+		0x03A, 0x000000A0,
+		0x03B, 0x000AB064,
+		0x03C, 0x00004000,
+		0x03A, 0x000000D8,
+		0x03B, 0x000A3070,
+		0x03C, 0x00004000,
+		0x03A, 0x00000468,
+		0x03B, 0x0009B870,
+		0x03C, 0x00010000,
+		0x03A, 0x00000098,
+		0x03B, 0x00092085,
+		0x03C, 0x000E4000,
+		0x03A, 0x00000418,
+		0x03B, 0x0008A080,
+		0x03C, 0x000F0000,
+		0x03A, 0x00000418,
+		0x03B, 0x00082080,
+		0x03C, 0x00010000,
+		0x0EF, 0x00001100,
+	0xFF0F0740, 0xABCD,
+		0x034, 0x0004A0B2,
+		0x034, 0x000490AF,
+		0x034, 0x00048070,
+		0x034, 0x0004706D,
+		0x034, 0x00046050,
+		0x034, 0x0004504D,
+		0x034, 0x0004404A,
+		0x034, 0x00043047,
+		0x034, 0x0004200A,
+		0x034, 0x00041007,
+		0x034, 0x00040004,
+	0xFF0F07C0, 0xCDEF,
+		0x034, 0x0004A0B2,
+		0x034, 0x000490AF,
+		0x034, 0x00048070,
+		0x034, 0x0004706D,
+		0x034, 0x00046050,
+		0x034, 0x0004504D,
+		0x034, 0x0004404A,
+		0x034, 0x00043047,
+		0x034, 0x0004200A,
+		0x034, 0x00041007,
+		0x034, 0x00040004,
+	0xFF0F07D8, 0xCDEF,
+		0x034, 0x0004A0B2,
+		0x034, 0x000490AF,
+		0x034, 0x00048070,
+		0x034, 0x0004706D,
+		0x034, 0x00046050,
+		0x034, 0x0004504D,
+		0x034, 0x0004404A,
+		0x034, 0x00043047,
+		0x034, 0x0004200A,
+		0x034, 0x00041007,
+		0x034, 0x00040004,
+	0xCDCDCDCD, 0xCDCD,
+		0x034, 0x0004ADF5,
+		0x034, 0x00049DF2,
+		0x034, 0x00048DEF,
+		0x034, 0x00047DEC,
+		0x034, 0x00046DE9,
+		0x034, 0x00045DC9,
+		0x034, 0x00044CE8,
+		0x034, 0x000438CA,
+		0x034, 0x00042889,
+		0x034, 0x0004184A,
+		0x034, 0x0004044A,
+	0xFF0F0740, 0xDEAD,
+	0xFF0F0740, 0xABCD,
+		0x034, 0x0002A0B2,
+		0x034, 0x000290AF,
+		0x034, 0x00028070,
+		0x034, 0x0002706D,
+		0x034, 0x00026050,
+		0x034, 0x0002504D,
+		0x034, 0x0002404A,
+		0x034, 0x00023047,
+		0x034, 0x0002200A,
+		0x034, 0x00021007,
+		0x034, 0x00020004,
+	0xFF0F07C0, 0xCDEF,
+		0x034, 0x0002A0B2,
+		0x034, 0x000290AF,
+		0x034, 0x00028070,
+		0x034, 0x0002706D,
+		0x034, 0x00026050,
+		0x034, 0x0002504D,
+		0x034, 0x0002404A,
+		0x034, 0x00023047,
+		0x034, 0x0002200A,
+		0x034, 0x00021007,
+		0x034, 0x00020004,
+	0xFF0F07D8, 0xCDEF,
+		0x034, 0x0002A0B2,
+		0x034, 0x000290AF,
+		0x034, 0x00028070,
+		0x034, 0x0002706D,
+		0x034, 0x00026050,
+		0x034, 0x0002504D,
+		0x034, 0x0002404A,
+		0x034, 0x00023047,
+		0x034, 0x0002200A,
+		0x034, 0x00021007,
+		0x034, 0x00020004,
+	0xCDCDCDCD, 0xCDCD,
+		0x034, 0x0002ADF5,
+		0x034, 0x00029DF2,
+		0x034, 0x00028DEF,
+		0x034, 0x00027DEC,
+		0x034, 0x00026DE9,
+		0x034, 0x00025DC9,
+		0x034, 0x00024CE8,
+		0x034, 0x000238CA,
+		0x034, 0x00022889,
+		0x034, 0x0002184A,
+		0x034, 0x0002044A,
+	0xFF0F0740, 0xDEAD,
+	0xFF0F0740, 0xABCD,
+		0x034, 0x0000A0B2,
+		0x034, 0x000090AF,
+		0x034, 0x00008070,
+		0x034, 0x0000706D,
+		0x034, 0x00006050,
+		0x034, 0x0000504D,
+		0x034, 0x0000404A,
+		0x034, 0x00003047,
+		0x034, 0x0000200A,
+		0x034, 0x00001007,
+		0x034, 0x00000004,
+	0xFF0F07C0, 0xCDEF,
+		0x034, 0x0000A0B2,
+		0x034, 0x000090AF,
+		0x034, 0x00008070,
+		0x034, 0x0000706D,
+		0x034, 0x00006050,
+		0x034, 0x0000504D,
+		0x034, 0x0000404A,
+		0x034, 0x00003047,
+		0x034, 0x0000200A,
+		0x034, 0x00001007,
+		0x034, 0x00000004,
+	0xFF0F07D8, 0xCDEF,
+		0x034, 0x0000A0B2,
+		0x034, 0x000090AF,
+		0x034, 0x00008070,
+		0x034, 0x0000706D,
+		0x034, 0x00006050,
+		0x034, 0x0000504D,
+		0x034, 0x0000404A,
+		0x034, 0x00003047,
+		0x034, 0x0000200A,
+		0x034, 0x00001007,
+		0x034, 0x00000004,
+	0xCDCDCDCD, 0xCDCD,
+		0x034, 0x0000AFF7,
+		0x034, 0x00009DF7,
+		0x034, 0x00008DF4,
+		0x034, 0x00007DF1,
+		0x034, 0x00006DEE,
+		0x034, 0x00005DCD,
+		0x034, 0x00004CEB,
+		0x034, 0x000038CC,
+		0x034, 0x0000288B,
+		0x034, 0x0000184C,
+		0x034, 0x0000044C,
+	0xFF0F0740, 0xDEAD,
+		0x0EF, 0x00000000,
+	0xFF0F0740, 0xABCD,
+		0x018, 0x0001712A,
+		0x0EF, 0x00000040,
+		0x035, 0x000001C5,
+		0x035, 0x000081C5,
+		0x035, 0x000101C5,
+		0x035, 0x00020174,
+		0x035, 0x00028174,
+		0x035, 0x00030174,
+		0x035, 0x00040185,
+		0x035, 0x00048185,
+		0x035, 0x00050185,
+		0x0EF, 0x00000000,
+	0xFF0F07C0, 0xCDEF,
+		0x018, 0x0001712A,
+		0x0EF, 0x00000040,
+		0x035, 0x000001C5,
+		0x035, 0x000081C5,
+		0x035, 0x000101C5,
+		0x035, 0x00020174,
+		0x035, 0x00028174,
+		0x035, 0x00030174,
+		0x035, 0x00040185,
+		0x035, 0x00048185,
+		0x035, 0x00050185,
+		0x0EF, 0x00000000,
+	0xFF0F07D8, 0xCDEF,
+		0x018, 0x0001712A,
+		0x0EF, 0x00000040,
+		0x035, 0x000001C5,
+		0x035, 0x000081C5,
+		0x035, 0x000101C5,
+		0x035, 0x00020174,
+		0x035, 0x00028174,
+		0x035, 0x00030174,
+		0x035, 0x00040185,
+		0x035, 0x00048185,
+		0x035, 0x00050185,
+		0x0EF, 0x00000000,
+	0xCDCDCDCD, 0xCDCD,
+		0x018, 0x0001712A,
+		0x0EF, 0x00000040,
+		0x035, 0x00000186,
+		0x035, 0x00008186,
+		0x035, 0x00010185,
+		0x035, 0x000201D5,
+		0x035, 0x000281D5,
+		0x035, 0x000301D5,
+		0x035, 0x000401D5,
+		0x035, 0x000481D5,
+		0x035, 0x000501D5,
+		0x0EF, 0x00000000,
+	0xFF0F0740, 0xDEAD,
+	0xFF0F0740, 0xABCD,
+		0x018, 0x0001712A,
+		0x0EF, 0x00000010,
+		0x036, 0x00005B8B,
+		0x036, 0x0000DB8B,
+		0x036, 0x00015B8B,
+		0x036, 0x0001DB8B,
+		0x036, 0x000262DB,
+		0x036, 0x0002E2DB,
+		0x036, 0x000362DB,
+		0x036, 0x0003E2DB,
+		0x036, 0x0004553B,
+		0x036, 0x0004D53B,
+		0x036, 0x0005553B,
+		0x036, 0x0005D53B,
+	0xFF0F07C0, 0xCDEF,
+		0x018, 0x0001712A,
+		0x0EF, 0x00000010,
+		0x036, 0x00005B8B,
+		0x036, 0x0000DB8B,
+		0x036, 0x00015B8B,
+		0x036, 0x0001DB8B,
+		0x036, 0x000262DB,
+		0x036, 0x0002E2DB,
+		0x036, 0x000362DB,
+		0x036, 0x0003E2DB,
+		0x036, 0x0004553B,
+		0x036, 0x0004D53B,
+		0x036, 0x0005553B,
+		0x036, 0x0005D53B,
+	0xFF0F07D8, 0xCDEF,
+		0x018, 0x0001712A,
+		0x0EF, 0x00000010,
+		0x036, 0x00005B8B,
+		0x036, 0x0000DB8B,
+		0x036, 0x00015B8B,
+		0x036, 0x0001DB8B,
+		0x036, 0x000262DB,
+		0x036, 0x0002E2DB,
+		0x036, 0x000362DB,
+		0x036, 0x0003E2DB,
+		0x036, 0x0004553B,
+		0x036, 0x0004D53B,
+		0x036, 0x0005553B,
+		0x036, 0x0005D53B,
+	0xCDCDCDCD, 0xCDCD,
+		0x018, 0x0001712A,
+		0x0EF, 0x00000010,
+		0x036, 0x00084EB4,
+		0x036, 0x0008C9B4,
+		0x036, 0x000949B4,
+		0x036, 0x0009C9B4,
+		0x036, 0x000A4935,
+		0x036, 0x000AC935,
+		0x036, 0x000B4935,
+		0x036, 0x000BC935,
+		0x036, 0x000C4EB4,
+		0x036, 0x000CCEB4,
+		0x036, 0x000D4EB4,
+		0x036, 0x000DCEB4,
+	0xFF0F0740, 0xDEAD,
+		0x0EF, 0x00000000,
+		0x0EF, 0x00000008,
+	0xFF0F0740, 0xABCD,
+		0x03C, 0x000002DC,
+		0x03C, 0x00000524,
+		0x03C, 0x00000902,
+	0xFF0F07C0, 0xCDEF,
+		0x03C, 0x000002DC,
+		0x03C, 0x00000524,
+		0x03C, 0x00000902,
+	0xFF0F07D8, 0xCDEF,
+		0x03C, 0x000002DC,
+		0x03C, 0x00000524,
+		0x03C, 0x00000902,
+	0xCDCDCDCD, 0xCDCD,
+		0x03C, 0x000002AA,
+		0x03C, 0x000005A2,
+		0x03C, 0x00000880,
+	0xFF0F0740, 0xDEAD,
+		0x0EF, 0x00000000,
+		0x018, 0x0001712A,
+		0x0EF, 0x00000002,
+		0x0DF, 0x00000080,
+	0xFF0F0740, 0xABCD,
+		0x061, 0x000EAC43,
+		0x062, 0x00038F47,
+		0x063, 0x00031157,
+		0x064, 0x0001C4AC,
+		0x065, 0x000931D1,
+	0xFF0F07C0, 0xCDEF,
+		0x061, 0x000EAC43,
+		0x062, 0x00038F47,
+		0x063, 0x00031157,
+		0x064, 0x0001C4AC,
+		0x065, 0x000931D1,
+	0xFF0F07D8, 0xCDEF,
+		0x061, 0x000EAC43,
+		0x062, 0x00038F47,
+		0x063, 0x00031157,
+		0x064, 0x0001C4AC,
+		0x065, 0x000931D1,
+	0xCDCDCDCD, 0xCDCD,
+		0x061, 0x000E5D53,
+		0x062, 0x00038FCD,
+		0x063, 0x000314EB,
+		0x064, 0x000196AC,
+		0x065, 0x000931D7,
+	0xFF0F0740, 0xDEAD,
+		0x008, 0x00008400,
+
+};
+
+u32 RTL8821AU_RADIOA_ARRAY[] = {
+		0x018, 0x0001712A,
+		0x056, 0x00051CF2,
+		0x066, 0x00040000,
+		0x000, 0x00010000,
+		0x01E, 0x00080000,
+		0x082, 0x00000830,
+		0x083, 0x00021800,
+		0x084, 0x00028000,
+		0x085, 0x00048000,
+		0x086, 0x00094838,
+		0x087, 0x00044980,
+		0x088, 0x00048000,
+		0x089, 0x0000D480,
+		0x08A, 0x00042240,
+		0x08B, 0x000F0380,
+		0x08C, 0x00090000,
+		0x08D, 0x00022852,
+		0x08E, 0x00065540,
+		0x08F, 0x00088001,
+		0x0EF, 0x00020000,
+		0x03E, 0x00000380,
+		0x03F, 0x00090018,
+		0x03E, 0x00020380,
+		0x03F, 0x000A0018,
+		0x03E, 0x00040308,
+		0x03F, 0x000A0018,
+		0x03E, 0x00060018,
+		0x03F, 0x000A0018,
+		0x0EF, 0x00000000,
+		0x018, 0x0001712A,
+		0x089, 0x00000080,
+		0x08B, 0x00080180,
+		0x0EF, 0x00001000,
+		0x03A, 0x00000244,
+		0x03B, 0x00038027,
+		0x03C, 0x00082000,
+		0x03A, 0x00000244,
+		0x03B, 0x00030113,
+		0x03C, 0x00082000,
+		0x03A, 0x0000014C,
+		0x03B, 0x00028027,
+		0x03C, 0x00082000,
+		0x03A, 0x000000CC,
+		0x03B, 0x00027027,
+		0x03C, 0x00042000,
+		0x03A, 0x0000014C,
+		0x03B, 0x0001F913,
+		0x03C, 0x00042000,
+		0x03A, 0x0000010C,
+		0x03B, 0x00017F10,
+		0x03C, 0x00012000,
+		0x03A, 0x000000D0,
+		0x03B, 0x00008027,
+		0x03C, 0x000CA000,
+		0x03A, 0x00000244,
+		0x03B, 0x00078027,
+		0x03C, 0x00082000,
+		0x03A, 0x00000244,
+		0x03B, 0x00070113,
+		0x03C, 0x00082000,
+		0x03A, 0x0000014C,
+		0x03B, 0x00068027,
+		0x03C, 0x00082000,
+		0x03A, 0x000000CC,
+		0x03B, 0x00067027,
+		0x03C, 0x00042000,
+		0x03A, 0x0000014C,
+		0x03B, 0x0005F913,
+		0x03C, 0x00042000,
+		0x03A, 0x0000010C,
+		0x03B, 0x00057F10,
+		0x03C, 0x00012000,
+		0x03A, 0x000000D0,
+		0x03B, 0x00048027,
+		0x03C, 0x000CA000,
+		0x03A, 0x00000244,
+		0x03B, 0x000B8027,
+		0x03C, 0x00082000,
+		0x03A, 0x00000244,
+		0x03B, 0x000B0113,
+		0x03C, 0x00082000,
+		0x03A, 0x0000014C,
+		0x03B, 0x000A8027,
+		0x03C, 0x00082000,
+		0x03A, 0x000000CC,
+		0x03B, 0x000A7027,
+		0x03C, 0x00042000,
+		0x03A, 0x0000014C,
+		0x03B, 0x0009F913,
+		0x03C, 0x00042000,
+		0x03A, 0x0000010C,
+		0x03B, 0x00097F10,
+		0x03C, 0x00012000,
+		0x03A, 0x000000D0,
+		0x03B, 0x00088027,
+		0x03C, 0x000CA000,
+		0x0EF, 0x00000000,
+		0x0EF, 0x00001100,
+	0xFF0F0104, 0xABCD,
+		0x034, 0x0004ADF3,
+		0x034, 0x00049DF0,
+	0xFF0F0204, 0xCDEF,
+		0x034, 0x0004ADF3,
+		0x034, 0x00049DF0,
+	0xFF0F0404, 0xCDEF,
+		0x034, 0x0004ADF3,
+		0x034, 0x00049DF0,
+	0xFF0F0200, 0xCDEF,
+		0x034, 0x0004ADF5,
+		0x034, 0x00049DF2,
+	0xFF0F02C0, 0xCDEF,
+		0x034, 0x0004A0F3,
+		0x034, 0x000490B1,
+	0xCDCDCDCD, 0xCDCD,
+		0x034, 0x0004ADF7,
+		0x034, 0x00049DF3,
+	0xFF0F0104, 0xDEAD,
+	0xFF0F0104, 0xABCD,
+		0x034, 0x00048DED,
+		0x034, 0x00047DEA,
+		0x034, 0x00046DE7,
+		0x034, 0x00045CE9,
+		0x034, 0x00044CE6,
+		0x034, 0x000438C6,
+		0x034, 0x00042886,
+		0x034, 0x00041486,
+		0x034, 0x00040447,
+	0xFF0F0204, 0xCDEF,
+		0x034, 0x00048DED,
+		0x034, 0x00047DEA,
+		0x034, 0x00046DE7,
+		0x034, 0x00045CE9,
+		0x034, 0x00044CE6,
+		0x034, 0x000438C6,
+		0x034, 0x00042886,
+		0x034, 0x00041486,
+		0x034, 0x00040447,
+	0xFF0F0404, 0xCDEF,
+		0x034, 0x00048DED,
+		0x034, 0x00047DEA,
+		0x034, 0x00046DE7,
+		0x034, 0x00045CE9,
+		0x034, 0x00044CE6,
+		0x034, 0x000438C6,
+		0x034, 0x00042886,
+		0x034, 0x00041486,
+		0x034, 0x00040447,
+	0xFF0F02C0, 0xCDEF,
+		0x034, 0x000480AE,
+		0x034, 0x000470AB,
+		0x034, 0x0004608B,
+		0x034, 0x00045069,
+		0x034, 0x00044048,
+		0x034, 0x00043045,
+		0x034, 0x00042026,
+		0x034, 0x00041023,
+		0x034, 0x00040002,
+	0xCDCDCDCD, 0xCDCD,
+		0x034, 0x00048DEF,
+		0x034, 0x00047DEC,
+		0x034, 0x00046DE9,
+		0x034, 0x00045CCB,
+		0x034, 0x0004488D,
+		0x034, 0x0004348D,
+		0x034, 0x0004248A,
+		0x034, 0x0004108D,
+		0x034, 0x0004008A,
+	0xFF0F0104, 0xDEAD,
+	0xFF0F0200, 0xABCD,
+		0x034, 0x0002ADF4,
+	0xFF0F02C0, 0xCDEF,
+		0x034, 0x0002A0F3,
+	0xCDCDCDCD, 0xCDCD,
+		0x034, 0x0002ADF7,
+	0xFF0F0200, 0xDEAD,
+	0xFF0F0104, 0xABCD,
+		0x034, 0x00029DF4,
+	0xFF0F0204, 0xCDEF,
+		0x034, 0x00029DF4,
+	0xFF0F0404, 0xCDEF,
+		0x034, 0x00029DF4,
+	0xFF0F0200, 0xCDEF,
+		0x034, 0x00029DF1,
+	0xFF0F02C0, 0xCDEF,
+		0x034, 0x000290F0,
+	0xCDCDCDCD, 0xCDCD,
+		0x034, 0x00029DF2,
+	0xFF0F0104, 0xDEAD,
+	0xFF0F0104, 0xABCD,
+		0x034, 0x00028DF1,
+		0x034, 0x00027DEE,
+		0x034, 0x00026DEB,
+		0x034, 0x00025CEC,
+		0x034, 0x00024CE9,
+		0x034, 0x000238CA,
+		0x034, 0x00022889,
+		0x034, 0x00021489,
+		0x034, 0x0002044A,
+	0xFF0F0204, 0xCDEF,
+		0x034, 0x00028DF1,
+		0x034, 0x00027DEE,
+		0x034, 0x00026DEB,
+		0x034, 0x00025CEC,
+		0x034, 0x00024CE9,
+		0x034, 0x000238CA,
+		0x034, 0x00022889,
+		0x034, 0x00021489,
+		0x034, 0x0002044A,
+	0xFF0F0404, 0xCDEF,
+		0x034, 0x00028DF1,
+		0x034, 0x00027DEE,
+		0x034, 0x00026DEB,
+		0x034, 0x00025CEC,
+		0x034, 0x00024CE9,
+		0x034, 0x000238CA,
+		0x034, 0x00022889,
+		0x034, 0x00021489,
+		0x034, 0x0002044A,
+	0xFF0F02C0, 0xCDEF,
+		0x034, 0x000280AF,
+		0x034, 0x000270AC,
+		0x034, 0x0002608B,
+		0x034, 0x00025069,
+		0x034, 0x00024048,
+		0x034, 0x00023045,
+		0x034, 0x00022026,
+		0x034, 0x00021023,
+		0x034, 0x00020002,
+	0xCDCDCDCD, 0xCDCD,
+		0x034, 0x00028DEE,
+		0x034, 0x00027DEB,
+		0x034, 0x00026CCD,
+		0x034, 0x00025CCA,
+		0x034, 0x0002488C,
+		0x034, 0x0002384C,
+		0x034, 0x00022849,
+		0x034, 0x00021449,
+		0x034, 0x0002004D,
+	0xFF0F0104, 0xDEAD,
+	0xFF0F02C0, 0xABCD,
+		0x034, 0x0000A0D7,
+		0x034, 0x000090D3,
+		0x034, 0x000080B1,
+		0x034, 0x000070AE,
+	0xCDCDCDCD, 0xCDCD,
+		0x034, 0x0000ADF7,
+		0x034, 0x00009DF4,
+		0x034, 0x00008DF1,
+		0x034, 0x00007DEE,
+	0xFF0F02C0, 0xDEAD,
+	0xFF0F0104, 0xABCD,
+		0x034, 0x00006DEB,
+		0x034, 0x00005CEC,
+		0x034, 0x00004CE9,
+		0x034, 0x000038CA,
+		0x034, 0x00002889,
+		0x034, 0x00001489,
+		0x034, 0x0000044A,
+	0xFF0F0204, 0xCDEF,
+		0x034, 0x00006DEB,
+		0x034, 0x00005CEC,
+		0x034, 0x00004CE9,
+		0x034, 0x000038CA,
+		0x034, 0x00002889,
+		0x034, 0x00001489,
+		0x034, 0x0000044A,
+	0xFF0F0404, 0xCDEF,
+		0x034, 0x00006DEB,
+		0x034, 0x00005CEC,
+		0x034, 0x00004CE9,
+		0x034, 0x000038CA,
+		0x034, 0x00002889,
+		0x034, 0x00001489,
+		0x034, 0x0000044A,
+	0xFF0F02C0, 0xCDEF,
+		0x034, 0x0000608D,
+		0x034, 0x0000506B,
+		0x034, 0x0000404A,
+		0x034, 0x00003047,
+		0x034, 0x00002044,
+		0x034, 0x00001025,
+		0x034, 0x00000004,
+	0xCDCDCDCD, 0xCDCD,
+		0x034, 0x00006DCD,
+		0x034, 0x00005CCD,
+		0x034, 0x00004CCA,
+		0x034, 0x0000388C,
+		0x034, 0x00002888,
+		0x034, 0x00001488,
+		0x034, 0x00000486,
+	0xFF0F0104, 0xDEAD,
+		0x0EF, 0x00000000,
+		0x018, 0x0001712A,
+		0x0EF, 0x00000040,
+	0xFF0F0104, 0xABCD,
+		0x035, 0x00000187,
+		0x035, 0x00008187,
+		0x035, 0x00010187,
+		0x035, 0x00020188,
+		0x035, 0x00028188,
+		0x035, 0x00030188,
+		0x035, 0x00040188,
+		0x035, 0x00048188,
+		0x035, 0x00050188,
+	0xFF0F0204, 0xCDEF,
+		0x035, 0x00000187,
+		0x035, 0x00008187,
+		0x035, 0x00010187,
+		0x035, 0x00020188,
+		0x035, 0x00028188,
+		0x035, 0x00030188,
+		0x035, 0x00040188,
+		0x035, 0x00048188,
+		0x035, 0x00050188,
+	0xFF0F0404, 0xCDEF,
+		0x035, 0x00000187,
+		0x035, 0x00008187,
+		0x035, 0x00010187,
+		0x035, 0x00020188,
+		0x035, 0x00028188,
+		0x035, 0x00030188,
+		0x035, 0x00040188,
+		0x035, 0x00048188,
+		0x035, 0x00050188,
+	0xCDCDCDCD, 0xCDCD,
+		0x035, 0x00000145,
+		0x035, 0x00008145,
+		0x035, 0x00010145,
+		0x035, 0x00020196,
+		0x035, 0x00028196,
+		0x035, 0x00030196,
+		0x035, 0x000401C7,
+		0x035, 0x000481C7,
+		0x035, 0x000501C7,
+	0xFF0F0104, 0xDEAD,
+		0x0EF, 0x00000000,
+		0x018, 0x0001712A,
+		0x0EF, 0x00000010,
+	0xFF0F0104, 0xABCD,
+		0x036, 0x00085733,
+		0x036, 0x0008D733,
+		0x036, 0x00095733,
+		0x036, 0x0009D733,
+		0x036, 0x000A64B4,
+		0x036, 0x000AE4B4,
+		0x036, 0x000B64B4,
+		0x036, 0x000BE4B4,
+		0x036, 0x000C64B4,
+		0x036, 0x000CE4B4,
+		0x036, 0x000D64B4,
+		0x036, 0x000DE4B4,
+	0xFF0F0204, 0xCDEF,
+		0x036, 0x00085733,
+		0x036, 0x0008D733,
+		0x036, 0x00095733,
+		0x036, 0x0009D733,
+		0x036, 0x000A64B4,
+		0x036, 0x000AE4B4,
+		0x036, 0x000B64B4,
+		0x036, 0x000BE4B4,
+		0x036, 0x000C64B4,
+		0x036, 0x000CE4B4,
+		0x036, 0x000D64B4,
+		0x036, 0x000DE4B4,
+	0xFF0F0404, 0xCDEF,
+		0x036, 0x00085733,
+		0x036, 0x0008D733,
+		0x036, 0x00095733,
+		0x036, 0x0009D733,
+		0x036, 0x000A64B4,
+		0x036, 0x000AE4B4,
+		0x036, 0x000B64B4,
+		0x036, 0x000BE4B4,
+		0x036, 0x000C64B4,
+		0x036, 0x000CE4B4,
+		0x036, 0x000D64B4,
+		0x036, 0x000DE4B4,
+	0xCDCDCDCD, 0xCDCD,
+		0x036, 0x000056B3,
+		0x036, 0x0000D6B3,
+		0x036, 0x000156B3,
+		0x036, 0x0001D6B3,
+		0x036, 0x00026634,
+		0x036, 0x0002E634,
+		0x036, 0x00036634,
+		0x036, 0x0003E634,
+		0x036, 0x000467B4,
+		0x036, 0x0004E7B4,
+		0x036, 0x000567B4,
+		0x036, 0x0005E7B4,
+	0xFF0F0104, 0xDEAD,
+		0x0EF, 0x00000000,
+		0x0EF, 0x00000008,
+	0xFF0F0104, 0xABCD,
+		0x03C, 0x000001C8,
+		0x03C, 0x00000492,
+	0xFF0F0204, 0xCDEF,
+		0x03C, 0x000001C8,
+		0x03C, 0x00000492,
+	0xFF0F0404, 0xCDEF,
+		0x03C, 0x000001C8,
+		0x03C, 0x00000492,
+	0xCDCDCDCD, 0xCDCD,
+		0x03C, 0x0000022A,
+		0x03C, 0x00000594,
+	0xFF0F0104, 0xDEAD,
+	0xFF0F0104, 0xABCD,
+		0x03C, 0x00000800,
+	0xFF0F0204, 0xCDEF,
+		0x03C, 0x00000800,
+	0xFF0F0404, 0xCDEF,
+		0x03C, 0x00000800,
+	0xFF0F02C0, 0xCDEF,
+		0x03C, 0x00000820,
+	0xCDCDCDCD, 0xCDCD,
+		0x03C, 0x00000900,
+	0xFF0F0104, 0xDEAD,
+		0x0EF, 0x00000000,
+		0x018, 0x0001712A,
+		0x0EF, 0x00000002,
+	0xFF0F0104, 0xABCD,
+		0x008, 0x0004E400,
+	0xFF0F0204, 0xCDEF,
+		0x008, 0x0004E400,
+	0xFF0F0404, 0xCDEF,
+		0x008, 0x0004E400,
+	0xCDCDCDCD, 0xCDCD,
+		0x008, 0x00002000,
+	0xFF0F0104, 0xDEAD,
+		0x0EF, 0x00000000,
+		0x0DF, 0x000000C0,
+		0x01F, 0x00040064,
+	0xFF0F0104, 0xABCD,
+		0x058, 0x000A7284,
+		0x059, 0x000600EC,
+	0xFF0F0204, 0xCDEF,
+		0x058, 0x000A7284,
+		0x059, 0x000600EC,
+	0xFF0F0404, 0xCDEF,
+		0x058, 0x000A7284,
+		0x059, 0x000600EC,
+	0xCDCDCDCD, 0xCDCD,
+		0x058, 0x00081184,
+		0x059, 0x0006016C,
+	0xFF0F0104, 0xDEAD,
+	0xFF0F0104, 0xABCD,
+		0x061, 0x000E8D73,
+		0x062, 0x00093FC5,
+	0xFF0F0204, 0xCDEF,
+		0x061, 0x000E8D73,
+		0x062, 0x00093FC5,
+	0xFF0F0404, 0xCDEF,
+		0x061, 0x000E8D73,
+		0x062, 0x00093FC5,
+	0xCDCDCDCD, 0xCDCD,
+		0x061, 0x000EAD53,
+		0x062, 0x00093BC4,
+	0xFF0F0104, 0xDEAD,
+	0xFF0F0104, 0xABCD,
+		0x063, 0x000110E9,
+	0xFF0F0204, 0xCDEF,
+		0x063, 0x000110E9,
+	0xFF0F0404, 0xCDEF,
+		0x063, 0x000110E9,
+	0xFF0F0200, 0xCDEF,
+		0x063, 0x000710E9,
+	0xFF0F02C0, 0xCDEF,
+		0x063, 0x000110E9,
+	0xCDCDCDCD, 0xCDCD,
+		0x063, 0x000714E9,
+	0xFF0F0104, 0xDEAD,
+	0xFF0F0104, 0xABCD,
+		0x064, 0x0001C27C,
+	0xFF0F0204, 0xCDEF,
+		0x064, 0x0001C27C,
+	0xFF0F0404, 0xCDEF,
+		0x064, 0x0001C27C,
+	0xCDCDCDCD, 0xCDCD,
+		0x064, 0x0001C67C,
+	0xFF0F0104, 0xDEAD,
+	0xFF0F0200, 0xABCD,
+		0x065, 0x00093016,
+	0xFF0F02C0, 0xCDEF,
+		0x065, 0x00093015,
+	0xCDCDCDCD, 0xCDCD,
+		0x065, 0x00091016,
+	0xFF0F0200, 0xDEAD,
+		0x018, 0x00000006,
+		0x0EF, 0x00002000,
+		0x03B, 0x0003824B,
+		0x03B, 0x0003024B,
+		0x03B, 0x0002884B,
+		0x03B, 0x00020F4B,
+		0x03B, 0x00018F4B,
+		0x03B, 0x000104B2,
+		0x03B, 0x00008049,
+		0x03B, 0x00000148,
+		0x03B, 0x0007824B,
+		0x03B, 0x0007024B,
+		0x03B, 0x0006824B,
+		0x03B, 0x00060F4B,
+		0x03B, 0x00058F4B,
+		0x03B, 0x000504B2,
+		0x03B, 0x00048049,
+		0x03B, 0x00040148,
+		0x0EF, 0x00000000,
+		0x0EF, 0x00000100,
+		0x034, 0x0000ADF2,
+		0x035, 0x00004800,
+		0x034, 0x00009DEF,
+		0x035, 0x00003C00,
+		0x034, 0x00008DEC,
+		0x035, 0x00003000,
+		0x034, 0x00007DE9,
+		0x035, 0x00002400,
+		0x034, 0x00006CEC,
+		0x035, 0x00003000,
+		0x034, 0x00005CE9,
+		0x035, 0x00002400,
+		0x034, 0x000044EC,
+		0x035, 0x00003000,
+		0x034, 0x000034E9,
+		0x035, 0x00002400,
+		0x034, 0x0000246C,
+		0x035, 0x00003000,
+		0x034, 0x00001469,
+		0x035, 0x00002400,
+		0x034, 0x0000006C,
+		0x035, 0x00003000,
+		0x0EF, 0x00000000,
+		0x0ED, 0x00000010,
+		0x044, 0x0000ADF2,
+		0x044, 0x00009DEF,
+		0x044, 0x00008DEC,
+		0x044, 0x00007DE9,
+		0x044, 0x00006CEC,
+		0x044, 0x00005CE9,
+		0x044, 0x000044EC,
+		0x044, 0x000034E9,
+		0x044, 0x0000246C,
+		0x044, 0x00001469,
+		0x044, 0x0000006C,
+		0x0ED, 0x00000000,
+		0x0ED, 0x00000001,
+		0x040, 0x00038DA7,
+		0x040, 0x000300C2,
+		0x040, 0x000288E2,
+		0x040, 0x000200B8,
+		0x040, 0x000188A5,
+		0x040, 0x00010FBC,
+		0x040, 0x00008F71,
+		0x040, 0x00000240,
+		0x0ED, 0x00000000,
+		0x0EF, 0x000020A2,
+		0x0DF, 0x00000080,
+		0x035, 0x00000120,
+		0x035, 0x00008120,
+		0x035, 0x00010120,
+		0x036, 0x00000085,
+		0x036, 0x00008085,
+		0x036, 0x00010085,
+		0x036, 0x00018085,
+		0x0EF, 0x00000000,
+		0x051, 0x00000C31,
+		0x052, 0x00000622,
+		0x053, 0x000FC70B,
+		0x054, 0x0000017E,
+		0x056, 0x00051DF3,
+		0x051, 0x00000C01,
+		0x052, 0x000006D6,
+		0x053, 0x000FC649,
+		0x070, 0x00049661,
+		0x071, 0x0007843E,
+		0x072, 0x00000382,
+		0x074, 0x00051400,
+		0x035, 0x00000160,
+		0x035, 0x00008160,
+		0x035, 0x00010160,
+		0x036, 0x00000124,
+		0x036, 0x00008124,
+		0x036, 0x00010124,
+		0x036, 0x00018124,
+		0x0ED, 0x0000000C,
+		0x045, 0x00000140,
+		0x045, 0x00008140,
+		0x045, 0x00010140,
+		0x046, 0x00000124,
+		0x046, 0x00008124,
+		0x046, 0x00010124,
+		0x046, 0x00018124,
+		0x0DF, 0x00000088,
+		0x0B3, 0x000F0E18,
+		0x0B4, 0x0001214C,
+		0x0B7, 0x0003000C,
+		0x01C, 0x000539D2,
+		0x018, 0x0001F12A,
+		0x0FE, 0x00000000,
+		0x0FE, 0x00000000,
+		0x018, 0x0001712A,
+
+};
+
+u32 RTL8812AU_MAC_REG_ARRAY[] = {
+		0x010, 0x0000000C,
+		0x072, 0x00000000,
+		0x428, 0x0000000A,
+		0x429, 0x00000010,
+		0x430, 0x00000000,
+		0x431, 0x00000000,
+		0x432, 0x00000000,
+		0x433, 0x00000001,
+		0x434, 0x00000004,
+		0x435, 0x00000005,
+		0x436, 0x00000007,
+		0x437, 0x00000008,
+		0x43C, 0x00000004,
+		0x43D, 0x00000005,
+		0x43E, 0x00000007,
+		0x43F, 0x00000008,
+		0x440, 0x0000005D,
+		0x441, 0x00000001,
+		0x442, 0x00000000,
+		0x444, 0x00000010,
+		0x445, 0x00000000,
+		0x446, 0x00000000,
+		0x447, 0x00000000,
+		0x448, 0x00000000,
+		0x449, 0x000000F0,
+		0x44A, 0x0000000F,
+		0x44B, 0x0000003E,
+		0x44C, 0x00000010,
+		0x44D, 0x00000000,
+		0x44E, 0x00000000,
+		0x44F, 0x00000000,
+		0x450, 0x00000000,
+		0x451, 0x000000F0,
+		0x452, 0x0000000F,
+		0x453, 0x00000000,
+		0x45B, 0x00000080,
+		0x460, 0x00000066,
+		0x461, 0x00000066,
+		0x4C8, 0x000000FF,
+		0x4C9, 0x00000008,
+		0x4CC, 0x000000FF,
+		0x4CD, 0x000000FF,
+		0x4CE, 0x00000001,
+		0x500, 0x00000026,
+		0x501, 0x000000A2,
+		0x502, 0x0000002F,
+		0x503, 0x00000000,
+		0x504, 0x00000028,
+		0x505, 0x000000A3,
+		0x506, 0x0000005E,
+		0x507, 0x00000000,
+		0x508, 0x0000002B,
+		0x509, 0x000000A4,
+		0x50A, 0x0000005E,
+		0x50B, 0x00000000,
+		0x50C, 0x0000004F,
+		0x50D, 0x000000A4,
+		0x50E, 0x00000000,
+		0x50F, 0x00000000,
+		0x512, 0x0000001C,
+		0x514, 0x0000000A,
+		0x516, 0x0000000A,
+		0x525, 0x0000004F,
+		0x550, 0x00000010,
+		0x551, 0x00000010,
+		0x559, 0x00000002,
+		0x55C, 0x00000050,
+		0x55D, 0x000000FF,
+		0x604, 0x00000009,
+		0x605, 0x00000030,
+		0x607, 0x00000007,
+		0x608, 0x0000000E,
+		0x609, 0x0000002A,
+		0x620, 0x000000FF,
+		0x621, 0x000000FF,
+		0x622, 0x000000FF,
+		0x623, 0x000000FF,
+		0x624, 0x000000FF,
+		0x625, 0x000000FF,
+		0x626, 0x000000FF,
+		0x627, 0x000000FF,
+		0x638, 0x00000050,
+		0x63C, 0x0000000A,
+		0x63D, 0x0000000A,
+		0x63E, 0x0000000E,
+		0x63F, 0x0000000E,
+		0x640, 0x00000040,
+		0x642, 0x00000040,
+		0x643, 0x00000000,
+		0x66E, 0x00000005,
+		0x700, 0x00000021,
+		0x701, 0x00000043,
+		0x702, 0x00000065,
+		0x703, 0x00000087,
+		0x708, 0x00000021,
+		0x709, 0x00000043,
+		0x70A, 0x00000065,
+		0x70B, 0x00000087,
+		0x718, 0x00000040,
+
+};
+
+u32 RTL8821AU_MAC_REG_ARRAY[] = {
+		0x428, 0x0000000A,
+		0x429, 0x00000010,
+		0x430, 0x00000000,
+		0x431, 0x00000000,
+		0x432, 0x00000000,
+		0x433, 0x00000001,
+		0x434, 0x00000004,
+		0x435, 0x00000005,
+		0x436, 0x00000007,
+		0x437, 0x00000008,
+		0x43C, 0x00000004,
+		0x43D, 0x00000005,
+		0x43E, 0x00000007,
+		0x43F, 0x00000008,
+		0x440, 0x0000005D,
+		0x441, 0x00000001,
+		0x442, 0x00000000,
+		0x444, 0x00000010,
+		0x445, 0x00000000,
+		0x446, 0x00000000,
+		0x447, 0x00000000,
+		0x448, 0x00000000,
+		0x449, 0x000000F0,
+		0x44A, 0x0000000F,
+		0x44B, 0x0000003E,
+		0x44C, 0x00000010,
+		0x44D, 0x00000000,
+		0x44E, 0x00000000,
+		0x44F, 0x00000000,
+		0x450, 0x00000000,
+		0x451, 0x000000F0,
+		0x452, 0x0000000F,
+		0x453, 0x00000000,
+		0x456, 0x0000005E,
+		0x460, 0x00000066,
+		0x461, 0x00000066,
+		0x4C8, 0x000000FF,
+		0x4C9, 0x00000008,
+		0x4CC, 0x000000FF,
+		0x4CD, 0x000000FF,
+		0x4CE, 0x00000001,
+		0x500, 0x00000026,
+		0x501, 0x000000A2,
+		0x502, 0x0000002F,
+		0x503, 0x00000000,
+		0x504, 0x00000028,
+		0x505, 0x000000A3,
+		0x506, 0x0000005E,
+		0x507, 0x00000000,
+		0x508, 0x0000002B,
+		0x509, 0x000000A4,
+		0x50A, 0x0000005E,
+		0x50B, 0x00000000,
+		0x50C, 0x0000004F,
+		0x50D, 0x000000A4,
+		0x50E, 0x00000000,
+		0x50F, 0x00000000,
+		0x512, 0x0000001C,
+		0x514, 0x0000000A,
+		0x516, 0x0000000A,
+		0x525, 0x0000004F,
+		0x550, 0x00000010,
+		0x551, 0x00000010,
+		0x559, 0x00000002,
+		0x55C, 0x00000050,
+		0x55D, 0x000000FF,
+		0x605, 0x00000030,
+		0x607, 0x00000007,
+		0x608, 0x0000000E,
+		0x609, 0x0000002A,
+		0x620, 0x000000FF,
+		0x621, 0x000000FF,
+		0x622, 0x000000FF,
+		0x623, 0x000000FF,
+		0x624, 0x000000FF,
+		0x625, 0x000000FF,
+		0x626, 0x000000FF,
+		0x627, 0x000000FF,
+		0x638, 0x00000050,
+		0x63C, 0x0000000A,
+		0x63D, 0x0000000A,
+		0x63E, 0x0000000E,
+		0x63F, 0x0000000E,
+		0x640, 0x00000040,
+		0x642, 0x00000040,
+		0x643, 0x00000000,
+		0x66E, 0x00000005,
+		0x700, 0x00000021,
+		0x701, 0x00000043,
+		0x702, 0x00000065,
+		0x703, 0x00000087,
+		0x708, 0x00000021,
+		0x709, 0x00000043,
+		0x70A, 0x00000065,
+		0x70B, 0x00000087,
+		0x718, 0x00000040,
+
+};
+
+
+u8 *RTL8812AU_TXPWR_LMT[] = {
+	"FCC", "2.4G", "20M", "CCK", "1T", "01", "36",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "01", "32",
+	"MKK", "2.4G", "20M", "CCK", "1T", "01", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "02", "36",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "02", "32",
+	"MKK", "2.4G", "20M", "CCK", "1T", "02", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "03", "36",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "03", "32",
+	"MKK", "2.4G", "20M", "CCK", "1T", "03", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "04", "36",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "04", "32",
+	"MKK", "2.4G", "20M", "CCK", "1T", "04", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "05", "36",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "05", "32",
+	"MKK", "2.4G", "20M", "CCK", "1T", "05", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "06", "36",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "06", "32",
+	"MKK", "2.4G", "20M", "CCK", "1T", "06", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "07", "36",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "07", "32",
+	"MKK", "2.4G", "20M", "CCK", "1T", "07", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "08", "36",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "08", "32",
+	"MKK", "2.4G", "20M", "CCK", "1T", "08", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "09", "36",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "09", "32",
+	"MKK", "2.4G", "20M", "CCK", "1T", "09", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "10", "36",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "10", "32",
+	"MKK", "2.4G", "20M", "CCK", "1T", "10", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "11", "36",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "11", "32",
+	"MKK", "2.4G", "20M", "CCK", "1T", "11", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "12", "63",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "12", "32",
+	"MKK", "2.4G", "20M", "CCK", "1T", "12", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "13", "63",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "13", "32",
+	"MKK", "2.4G", "20M", "CCK", "1T", "13", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "14", "63",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "14", "63",
+	"MKK", "2.4G", "20M", "CCK", "1T", "14", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "01", "34",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "01", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "01", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "02", "36",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "02", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "02", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "03", "36",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "03", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "03", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "04", "36",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "04", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "04", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "05", "36",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "05", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "05", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "06", "36",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "06", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "06", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "07", "36",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "07", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "07", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "08", "36",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "08", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "08", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "09", "36",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "09", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "09", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "10", "36",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "10", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "10", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "11", "32",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "11", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "11", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "12", "63",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "12", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "12", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "13", "63",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "13", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "13", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "14", "63",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "14", "63",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "14", "63",
+	"FCC", "2.4G", "20M", "HT", "1T", "01", "34",
+	"ETSI", "2.4G", "20M", "HT", "1T", "01", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "01", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "02", "36",
+	"ETSI", "2.4G", "20M", "HT", "1T", "02", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "02", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "03", "36",
+	"ETSI", "2.4G", "20M", "HT", "1T", "03", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "03", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "04", "36",
+	"ETSI", "2.4G", "20M", "HT", "1T", "04", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "04", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "05", "36",
+	"ETSI", "2.4G", "20M", "HT", "1T", "05", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "05", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "06", "36",
+	"ETSI", "2.4G", "20M", "HT", "1T", "06", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "06", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "07", "36",
+	"ETSI", "2.4G", "20M", "HT", "1T", "07", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "07", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "08", "36",
+	"ETSI", "2.4G", "20M", "HT", "1T", "08", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "08", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "09", "36",
+	"ETSI", "2.4G", "20M", "HT", "1T", "09", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "09", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "10", "36",
+	"ETSI", "2.4G", "20M", "HT", "1T", "10", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "10", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "11", "32",
+	"ETSI", "2.4G", "20M", "HT", "1T", "11", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "11", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "12", "63",
+	"ETSI", "2.4G", "20M", "HT", "1T", "12", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "12", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "13", "63",
+	"ETSI", "2.4G", "20M", "HT", "1T", "13", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "13", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "14", "63",
+	"ETSI", "2.4G", "20M", "HT", "1T", "14", "63",
+	"MKK", "2.4G", "20M", "HT", "1T", "14", "63",
+	"FCC", "2.4G", "20M", "HT", "2T", "01", "32",
+	"ETSI", "2.4G", "20M", "HT", "2T", "01", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "01", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "02", "34",
+	"ETSI", "2.4G", "20M", "HT", "2T", "02", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "02", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "03", "34",
+	"ETSI", "2.4G", "20M", "HT", "2T", "03", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "03", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "04", "34",
+	"ETSI", "2.4G", "20M", "HT", "2T", "04", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "04", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "05", "34",
+	"ETSI", "2.4G", "20M", "HT", "2T", "05", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "05", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "06", "34",
+	"ETSI", "2.4G", "20M", "HT", "2T", "06", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "06", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "07", "34",
+	"ETSI", "2.4G", "20M", "HT", "2T", "07", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "07", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "08", "34",
+	"ETSI", "2.4G", "20M", "HT", "2T", "08", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "08", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "09", "34",
+	"ETSI", "2.4G", "20M", "HT", "2T", "09", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "09", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "10", "34",
+	"ETSI", "2.4G", "20M", "HT", "2T", "10", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "10", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "11", "30",
+	"ETSI", "2.4G", "20M", "HT", "2T", "11", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "11", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "12", "63",
+	"ETSI", "2.4G", "20M", "HT", "2T", "12", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "12", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "13", "63",
+	"ETSI", "2.4G", "20M", "HT", "2T", "13", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "13", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "14", "63",
+	"ETSI", "2.4G", "20M", "HT", "2T", "14", "63",
+	"MKK", "2.4G", "20M", "HT", "2T", "14", "63",
+	"FCC", "2.4G", "40M", "HT", "1T", "01", "63",
+	"ETSI", "2.4G", "40M", "HT", "1T", "01", "63",
+	"MKK", "2.4G", "40M", "HT", "1T", "01", "63",
+	"FCC", "2.4G", "40M", "HT", "1T", "02", "63",
+	"ETSI", "2.4G", "40M", "HT", "1T", "02", "63",
+	"MKK", "2.4G", "40M", "HT", "1T", "02", "63",
+	"FCC", "2.4G", "40M", "HT", "1T", "03", "32",
+	"ETSI", "2.4G", "40M", "HT", "1T", "03", "32",
+	"MKK", "2.4G", "40M", "HT", "1T", "03", "32",
+	"FCC", "2.4G", "40M", "HT", "1T", "04", "36",
+	"ETSI", "2.4G", "40M", "HT", "1T", "04", "32",
+	"MKK", "2.4G", "40M", "HT", "1T", "04", "32",
+	"FCC", "2.4G", "40M", "HT", "1T", "05", "36",
+	"ETSI", "2.4G", "40M", "HT", "1T", "05", "32",
+	"MKK", "2.4G", "40M", "HT", "1T", "05", "32",
+	"FCC", "2.4G", "40M", "HT", "1T", "06", "36",
+	"ETSI", "2.4G", "40M", "HT", "1T", "06", "32",
+	"MKK", "2.4G", "40M", "HT", "1T", "06", "32",
+	"FCC", "2.4G", "40M", "HT", "1T", "07", "36",
+	"ETSI", "2.4G", "40M", "HT", "1T", "07", "32",
+	"MKK", "2.4G", "40M", "HT", "1T", "07", "32",
+	"FCC", "2.4G", "40M", "HT", "1T", "08", "36",
+	"ETSI", "2.4G", "40M", "HT", "1T", "08", "32",
+	"MKK", "2.4G", "40M", "HT", "1T", "08", "32",
+	"FCC", "2.4G", "40M", "HT", "1T", "09", "36",
+	"ETSI", "2.4G", "40M", "HT", "1T", "09", "32",
+	"MKK", "2.4G", "40M", "HT", "1T", "09", "32",
+	"FCC", "2.4G", "40M", "HT", "1T", "10", "36",
+	"ETSI", "2.4G", "40M", "HT", "1T", "10", "32",
+	"MKK", "2.4G", "40M", "HT", "1T", "10", "32",
+	"FCC", "2.4G", "40M", "HT", "1T", "11", "32",
+	"ETSI", "2.4G", "40M", "HT", "1T", "11", "32",
+	"MKK", "2.4G", "40M", "HT", "1T", "11", "32",
+	"FCC", "2.4G", "40M", "HT", "1T", "12", "63",
+	"ETSI", "2.4G", "40M", "HT", "1T", "12", "32",
+	"MKK", "2.4G", "40M", "HT", "1T", "12", "32",
+	"FCC", "2.4G", "40M", "HT", "1T", "13", "63",
+	"ETSI", "2.4G", "40M", "HT", "1T", "13", "32",
+	"MKK", "2.4G", "40M", "HT", "1T", "13", "32",
+	"FCC", "2.4G", "40M", "HT", "1T", "14", "63",
+	"ETSI", "2.4G", "40M", "HT", "1T", "14", "63",
+	"MKK", "2.4G", "40M", "HT", "1T", "14", "63",
+	"FCC", "2.4G", "40M", "HT", "2T", "01", "63",
+	"ETSI", "2.4G", "40M", "HT", "2T", "01", "63",
+	"MKK", "2.4G", "40M", "HT", "2T", "01", "63",
+	"FCC", "2.4G", "40M", "HT", "2T", "02", "63",
+	"ETSI", "2.4G", "40M", "HT", "2T", "02", "63",
+	"MKK", "2.4G", "40M", "HT", "2T", "02", "63",
+	"FCC", "2.4G", "40M", "HT", "2T", "03", "30",
+	"ETSI", "2.4G", "40M", "HT", "2T", "03", "30",
+	"MKK", "2.4G", "40M", "HT", "2T", "03", "30",
+	"FCC", "2.4G", "40M", "HT", "2T", "04", "34",
+	"ETSI", "2.4G", "40M", "HT", "2T", "04", "30",
+	"MKK", "2.4G", "40M", "HT", "2T", "04", "30",
+	"FCC", "2.4G", "40M", "HT", "2T", "05", "34",
+	"ETSI", "2.4G", "40M", "HT", "2T", "05", "30",
+	"MKK", "2.4G", "40M", "HT", "2T", "05", "30",
+	"FCC", "2.4G", "40M", "HT", "2T", "06", "34",
+	"ETSI", "2.4G", "40M", "HT", "2T", "06", "30",
+	"MKK", "2.4G", "40M", "HT", "2T", "06", "30",
+	"FCC", "2.4G", "40M", "HT", "2T", "07", "34",
+	"ETSI", "2.4G", "40M", "HT", "2T", "07", "30",
+	"MKK", "2.4G", "40M", "HT", "2T", "07", "30",
+	"FCC", "2.4G", "40M", "HT", "2T", "08", "34",
+	"ETSI", "2.4G", "40M", "HT", "2T", "08", "30",
+	"MKK", "2.4G", "40M", "HT", "2T", "08", "30",
+	"FCC", "2.4G", "40M", "HT", "2T", "09", "34",
+	"ETSI", "2.4G", "40M", "HT", "2T", "09", "30",
+	"MKK", "2.4G", "40M", "HT", "2T", "09", "30",
+	"FCC", "2.4G", "40M", "HT", "2T", "10", "34",
+	"ETSI", "2.4G", "40M", "HT", "2T", "10", "30",
+	"MKK", "2.4G", "40M", "HT", "2T", "10", "30",
+	"FCC", "2.4G", "40M", "HT", "2T", "11", "30",
+	"ETSI", "2.4G", "40M", "HT", "2T", "11", "30",
+	"MKK", "2.4G", "40M", "HT", "2T", "11", "30",
+	"FCC", "2.4G", "40M", "HT", "2T", "12", "63",
+	"ETSI", "2.4G", "40M", "HT", "2T", "12", "32",
+	"MKK", "2.4G", "40M", "HT", "2T", "12", "32",
+	"FCC", "2.4G", "40M", "HT", "2T", "13", "63",
+	"ETSI", "2.4G", "40M", "HT", "2T", "13", "32",
+	"MKK", "2.4G", "40M", "HT", "2T", "13", "32",
+	"FCC", "2.4G", "40M", "HT", "2T", "14", "63",
+	"ETSI", "2.4G", "40M", "HT", "2T", "14", "63",
+	"MKK", "2.4G", "40M", "HT", "2T", "14", "63",
+	"FCC", "5G", "20M", "OFDM", "1T", "36", "30",
+	"ETSI", "5G", "20M", "OFDM", "1T", "36", "32",
+	"MKK", "5G", "20M", "OFDM", "1T", "36", "32",
+	"FCC", "5G", "20M", "OFDM", "1T", "40", "30",
+	"ETSI", "5G", "20M", "OFDM", "1T", "40", "32",
+	"MKK", "5G", "20M", "OFDM", "1T", "40", "32",
+	"FCC", "5G", "20M", "OFDM", "1T", "44", "30",
+	"ETSI", "5G", "20M", "OFDM", "1T", "44", "32",
+	"MKK", "5G", "20M", "OFDM", "1T", "44", "32",
+	"FCC", "5G", "20M", "OFDM", "1T", "48", "30",
+	"ETSI", "5G", "20M", "OFDM", "1T", "48", "32",
+	"MKK", "5G", "20M", "OFDM", "1T", "48", "32",
+	"FCC", "5G", "20M", "OFDM", "1T", "52", "36",
+	"ETSI", "5G", "20M", "OFDM", "1T", "52", "32",
+	"MKK", "5G", "20M", "OFDM", "1T", "52", "32",
+	"FCC", "5G", "20M", "OFDM", "1T", "56", "34",
+	"ETSI", "5G", "20M", "OFDM", "1T", "56", "32",
+	"MKK", "5G", "20M", "OFDM", "1T", "56", "32",
+	"FCC", "5G", "20M", "OFDM", "1T", "60", "32",
+	"ETSI", "5G", "20M", "OFDM", "1T", "60", "32",
+	"MKK", "5G", "20M", "OFDM", "1T", "60", "32",
+	"FCC", "5G", "20M", "OFDM", "1T", "64", "28",
+	"ETSI", "5G", "20M", "OFDM", "1T", "64", "32",
+	"MKK", "5G", "20M", "OFDM", "1T", "64", "32",
+	"FCC", "5G", "20M", "OFDM", "1T", "100", "30",
+	"ETSI", "5G", "20M", "OFDM", "1T", "100", "32",
+	"MKK", "5G", "20M", "OFDM", "1T", "100", "32",
+	"FCC", "5G", "20M", "OFDM", "1T", "114", "30",
+	"ETSI", "5G", "20M", "OFDM", "1T", "114", "32",
+	"MKK", "5G", "20M", "OFDM", "1T", "114", "32",
+	"FCC", "5G", "20M", "OFDM", "1T", "108", "32",
+	"ETSI", "5G", "20M", "OFDM", "1T", "108", "32",
+	"MKK", "5G", "20M", "OFDM", "1T", "108", "32",
+	"FCC", "5G", "20M", "OFDM", "1T", "112", "34",
+	"ETSI", "5G", "20M", "OFDM", "1T", "112", "32",
+	"MKK", "5G", "20M", "OFDM", "1T", "112", "32",
+	"FCC", "5G", "20M", "OFDM", "1T", "116", "34",
+	"ETSI", "5G", "20M", "OFDM", "1T", "116", "32",
+	"MKK", "5G", "20M", "OFDM", "1T", "116", "32",
+	"FCC", "5G", "20M", "OFDM", "1T", "120", "36",
+	"ETSI", "5G", "20M", "OFDM", "1T", "120", "32",
+	"MKK", "5G", "20M", "OFDM", "1T", "120", "32",
+	"FCC", "5G", "20M", "OFDM", "1T", "124", "34",
+	"ETSI", "5G", "20M", "OFDM", "1T", "124", "32",
+	"MKK", "5G", "20M", "OFDM", "1T", "124", "32",
+	"FCC", "5G", "20M", "OFDM", "1T", "128", "32",
+	"ETSI", "5G", "20M", "OFDM", "1T", "128", "32",
+	"MKK", "5G", "20M", "OFDM", "1T", "128", "32",
+	"FCC", "5G", "20M", "OFDM", "1T", "132", "30",
+	"ETSI", "5G", "20M", "OFDM", "1T", "132", "32",
+	"MKK", "5G", "20M", "OFDM", "1T", "132", "32",
+	"FCC", "5G", "20M", "OFDM", "1T", "136", "30",
+	"ETSI", "5G", "20M", "OFDM", "1T", "136", "32",
+	"MKK", "5G", "20M", "OFDM", "1T", "136", "32",
+	"FCC", "5G", "20M", "OFDM", "1T", "140", "28",
+	"ETSI", "5G", "20M", "OFDM", "1T", "140", "32",
+	"MKK", "5G", "20M", "OFDM", "1T", "140", "32",
+	"FCC", "5G", "20M", "OFDM", "1T", "149", "36",
+	"ETSI", "5G", "20M", "OFDM", "1T", "149", "32",
+	"MKK", "5G", "20M", "OFDM", "1T", "149", "63",
+	"FCC", "5G", "20M", "OFDM", "1T", "153", "36",
+	"ETSI", "5G", "20M", "OFDM", "1T", "153", "32",
+	"MKK", "5G", "20M", "OFDM", "1T", "153", "63",
+	"FCC", "5G", "20M", "OFDM", "1T", "157", "36",
+	"ETSI", "5G", "20M", "OFDM", "1T", "157", "32",
+	"MKK", "5G", "20M", "OFDM", "1T", "157", "63",
+	"FCC", "5G", "20M", "OFDM", "1T", "161", "36",
+	"ETSI", "5G", "20M", "OFDM", "1T", "161", "32",
+	"MKK", "5G", "20M", "OFDM", "1T", "161", "63",
+	"FCC", "5G", "20M", "OFDM", "1T", "165", "36",
+	"ETSI", "5G", "20M", "OFDM", "1T", "165", "32",
+	"MKK", "5G", "20M", "OFDM", "1T", "165", "63",
+	"FCC", "5G", "20M", "HT", "1T", "36", "30",
+	"ETSI", "5G", "20M", "HT", "1T", "36", "32",
+	"MKK", "5G", "20M", "HT", "1T", "36", "32",
+	"FCC", "5G", "20M", "HT", "1T", "40", "30",
+	"ETSI", "5G", "20M", "HT", "1T", "40", "32",
+	"MKK", "5G", "20M", "HT", "1T", "40", "32",
+	"FCC", "5G", "20M", "HT", "1T", "44", "30",
+	"ETSI", "5G", "20M", "HT", "1T", "44", "32",
+	"MKK", "5G", "20M", "HT", "1T", "44", "32",
+	"FCC", "5G", "20M", "HT", "1T", "48", "30",
+	"ETSI", "5G", "20M", "HT", "1T", "48", "32",
+	"MKK", "5G", "20M", "HT", "1T", "48", "32",
+	"FCC", "5G", "20M", "HT", "1T", "52", "36",
+	"ETSI", "5G", "20M", "HT", "1T", "52", "32",
+	"MKK", "5G", "20M", "HT", "1T", "52", "32",
+	"FCC", "5G", "20M", "HT", "1T", "56", "34",
+	"ETSI", "5G", "20M", "HT", "1T", "56", "32",
+	"MKK", "5G", "20M", "HT", "1T", "56", "32",
+	"FCC", "5G", "20M", "HT", "1T", "60", "32",
+	"ETSI", "5G", "20M", "HT", "1T", "60", "32",
+	"MKK", "5G", "20M", "HT", "1T", "60", "32",
+	"FCC", "5G", "20M", "HT", "1T", "64", "28",
+	"ETSI", "5G", "20M", "HT", "1T", "64", "32",
+	"MKK", "5G", "20M", "HT", "1T", "64", "32",
+	"FCC", "5G", "20M", "HT", "1T", "100", "30",
+	"ETSI", "5G", "20M", "HT", "1T", "100", "32",
+	"MKK", "5G", "20M", "HT", "1T", "100", "32",
+	"FCC", "5G", "20M", "HT", "1T", "114", "30",
+	"ETSI", "5G", "20M", "HT", "1T", "114", "32",
+	"MKK", "5G", "20M", "HT", "1T", "114", "32",
+	"FCC", "5G", "20M", "HT", "1T", "108", "32",
+	"ETSI", "5G", "20M", "HT", "1T", "108", "32",
+	"MKK", "5G", "20M", "HT", "1T", "108", "32",
+	"FCC", "5G", "20M", "HT", "1T", "112", "34",
+	"ETSI", "5G", "20M", "HT", "1T", "112", "32",
+	"MKK", "5G", "20M", "HT", "1T", "112", "32",
+	"FCC", "5G", "20M", "HT", "1T", "116", "34",
+	"ETSI", "5G", "20M", "HT", "1T", "116", "32",
+	"MKK", "5G", "20M", "HT", "1T", "116", "32",
+	"FCC", "5G", "20M", "HT", "1T", "120", "36",
+	"ETSI", "5G", "20M", "HT", "1T", "120", "32",
+	"MKK", "5G", "20M", "HT", "1T", "120", "32",
+	"FCC", "5G", "20M", "HT", "1T", "124", "34",
+	"ETSI", "5G", "20M", "HT", "1T", "124", "32",
+	"MKK", "5G", "20M", "HT", "1T", "124", "32",
+	"FCC", "5G", "20M", "HT", "1T", "128", "32",
+	"ETSI", "5G", "20M", "HT", "1T", "128", "32",
+	"MKK", "5G", "20M", "HT", "1T", "128", "32",
+	"FCC", "5G", "20M", "HT", "1T", "132", "30",
+	"ETSI", "5G", "20M", "HT", "1T", "132", "32",
+	"MKK", "5G", "20M", "HT", "1T", "132", "32",
+	"FCC", "5G", "20M", "HT", "1T", "136", "30",
+	"ETSI", "5G", "20M", "HT", "1T", "136", "32",
+	"MKK", "5G", "20M", "HT", "1T", "136", "32",
+	"FCC", "5G", "20M", "HT", "1T", "140", "28",
+	"ETSI", "5G", "20M", "HT", "1T", "140", "32",
+	"MKK", "5G", "20M", "HT", "1T", "140", "32",
+	"FCC", "5G", "20M", "HT", "1T", "149", "36",
+	"ETSI", "5G", "20M", "HT", "1T", "149", "32",
+	"MKK", "5G", "20M", "HT", "1T", "149", "63",
+	"FCC", "5G", "20M", "HT", "1T", "153", "36",
+	"ETSI", "5G", "20M", "HT", "1T", "153", "32",
+	"MKK", "5G", "20M", "HT", "1T", "153", "63",
+	"FCC", "5G", "20M", "HT", "1T", "157", "36",
+	"ETSI", "5G", "20M", "HT", "1T", "157", "32",
+	"MKK", "5G", "20M", "HT", "1T", "157", "63",
+	"FCC", "5G", "20M", "HT", "1T", "161", "36",
+	"ETSI", "5G", "20M", "HT", "1T", "161", "32",
+	"MKK", "5G", "20M", "HT", "1T", "161", "63",
+	"FCC", "5G", "20M", "HT", "1T", "165", "36",
+	"ETSI", "5G", "20M", "HT", "1T", "165", "32",
+	"MKK", "5G", "20M", "HT", "1T", "165", "63",
+	"FCC", "5G", "20M", "HT", "2T", "36", "28",
+	"ETSI", "5G", "20M", "HT", "2T", "36", "30",
+	"MKK", "5G", "20M", "HT", "2T", "36", "30",
+	"FCC", "5G", "20M", "HT", "2T", "40", "28",
+	"ETSI", "5G", "20M", "HT", "2T", "40", "30",
+	"MKK", "5G", "20M", "HT", "2T", "40", "30",
+	"FCC", "5G", "20M", "HT", "2T", "44", "28",
+	"ETSI", "5G", "20M", "HT", "2T", "44", "30",
+	"MKK", "5G", "20M", "HT", "2T", "44", "30",
+	"FCC", "5G", "20M", "HT", "2T", "48", "28",
+	"ETSI", "5G", "20M", "HT", "2T", "48", "30",
+	"MKK", "5G", "20M", "HT", "2T", "48", "30",
+	"FCC", "5G", "20M", "HT", "2T", "52", "34",
+	"ETSI", "5G", "20M", "HT", "2T", "52", "30",
+	"MKK", "5G", "20M", "HT", "2T", "52", "30",
+	"FCC", "5G", "20M", "HT", "2T", "56", "32",
+	"ETSI", "5G", "20M", "HT", "2T", "56", "30",
+	"MKK", "5G", "20M", "HT", "2T", "56", "30",
+	"FCC", "5G", "20M", "HT", "2T", "60", "30",
+	"ETSI", "5G", "20M", "HT", "2T", "60", "30",
+	"MKK", "5G", "20M", "HT", "2T", "60", "30",
+	"FCC", "5G", "20M", "HT", "2T", "64", "26",
+	"ETSI", "5G", "20M", "HT", "2T", "64", "30",
+	"MKK", "5G", "20M", "HT", "2T", "64", "30",
+	"FCC", "5G", "20M", "HT", "2T", "100", "28",
+	"ETSI", "5G", "20M", "HT", "2T", "100", "30",
+	"MKK", "5G", "20M", "HT", "2T", "100", "30",
+	"FCC", "5G", "20M", "HT", "2T", "114", "28",
+	"ETSI", "5G", "20M", "HT", "2T", "114", "30",
+	"MKK", "5G", "20M", "HT", "2T", "114", "30",
+	"FCC", "5G", "20M", "HT", "2T", "108", "30",
+	"ETSI", "5G", "20M", "HT", "2T", "108", "30",
+	"MKK", "5G", "20M", "HT", "2T", "108", "30",
+	"FCC", "5G", "20M", "HT", "2T", "112", "32",
+	"ETSI", "5G", "20M", "HT", "2T", "112", "30",
+	"MKK", "5G", "20M", "HT", "2T", "112", "30",
+	"FCC", "5G", "20M", "HT", "2T", "116", "32",
+	"ETSI", "5G", "20M", "HT", "2T", "116", "30",
+	"MKK", "5G", "20M", "HT", "2T", "116", "30",
+	"FCC", "5G", "20M", "HT", "2T", "120", "34",
+	"ETSI", "5G", "20M", "HT", "2T", "120", "30",
+	"MKK", "5G", "20M", "HT", "2T", "120", "30",
+	"FCC", "5G", "20M", "HT", "2T", "124", "32",
+	"ETSI", "5G", "20M", "HT", "2T", "124", "30",
+	"MKK", "5G", "20M", "HT", "2T", "124", "30",
+	"FCC", "5G", "20M", "HT", "2T", "128", "30",
+	"ETSI", "5G", "20M", "HT", "2T", "128", "30",
+	"MKK", "5G", "20M", "HT", "2T", "128", "30",
+	"FCC", "5G", "20M", "HT", "2T", "132", "28",
+	"ETSI", "5G", "20M", "HT", "2T", "132", "30",
+	"MKK", "5G", "20M", "HT", "2T", "132", "30",
+	"FCC", "5G", "20M", "HT", "2T", "136", "28",
+	"ETSI", "5G", "20M", "HT", "2T", "136", "30",
+	"MKK", "5G", "20M", "HT", "2T", "136", "30",
+	"FCC", "5G", "20M", "HT", "2T", "140", "26",
+	"ETSI", "5G", "20M", "HT", "2T", "140", "30",
+	"MKK", "5G", "20M", "HT", "2T", "140", "30",
+	"FCC", "5G", "20M", "HT", "2T", "149", "34",
+	"ETSI", "5G", "20M", "HT", "2T", "149", "30",
+	"MKK", "5G", "20M", "HT", "2T", "149", "63",
+	"FCC", "5G", "20M", "HT", "2T", "153", "34",
+	"ETSI", "5G", "20M", "HT", "2T", "153", "30",
+	"MKK", "5G", "20M", "HT", "2T", "153", "63",
+	"FCC", "5G", "20M", "HT", "2T", "157", "34",
+	"ETSI", "5G", "20M", "HT", "2T", "157", "30",
+	"MKK", "5G", "20M", "HT", "2T", "157", "63",
+	"FCC", "5G", "20M", "HT", "2T", "161", "34",
+	"ETSI", "5G", "20M", "HT", "2T", "161", "30",
+	"MKK", "5G", "20M", "HT", "2T", "161", "63",
+	"FCC", "5G", "20M", "HT", "2T", "165", "34",
+	"ETSI", "5G", "20M", "HT", "2T", "165", "30",
+	"MKK", "5G", "20M", "HT", "2T", "165", "63",
+	"FCC", "5G", "40M", "HT", "1T", "38", "30",
+	"ETSI", "5G", "40M", "HT", "1T", "38", "32",
+	"MKK", "5G", "40M", "HT", "1T", "38", "32",
+	"FCC", "5G", "40M", "HT", "1T", "46", "30",
+	"ETSI", "5G", "40M", "HT", "1T", "46", "32",
+	"MKK", "5G", "40M", "HT", "1T", "46", "32",
+	"FCC", "5G", "40M", "HT", "1T", "54", "32",
+	"ETSI", "5G", "40M", "HT", "1T", "54", "32",
+	"MKK", "5G", "40M", "HT", "1T", "54", "32",
+	"FCC", "5G", "40M", "HT", "1T", "62", "32",
+	"ETSI", "5G", "40M", "HT", "1T", "62", "32",
+	"MKK", "5G", "40M", "HT", "1T", "62", "32",
+	"FCC", "5G", "40M", "HT", "1T", "102", "28",
+	"ETSI", "5G", "40M", "HT", "1T", "102", "32",
+	"MKK", "5G", "40M", "HT", "1T", "102", "32",
+	"FCC", "5G", "40M", "HT", "1T", "110", "32",
+	"ETSI", "5G", "40M", "HT", "1T", "110", "32",
+	"MKK", "5G", "40M", "HT", "1T", "110", "32",
+	"FCC", "5G", "40M", "HT", "1T", "118", "36",
+	"ETSI", "5G", "40M", "HT", "1T", "118", "32",
+	"MKK", "5G", "40M", "HT", "1T", "118", "32",
+	"FCC", "5G", "40M", "HT", "1T", "126", "34",
+	"ETSI", "5G", "40M", "HT", "1T", "126", "32",
+	"MKK", "5G", "40M", "HT", "1T", "126", "32",
+	"FCC", "5G", "40M", "HT", "1T", "134", "32",
+	"ETSI", "5G", "40M", "HT", "1T", "134", "32",
+	"MKK", "5G", "40M", "HT", "1T", "134", "32",
+	"FCC", "5G", "40M", "HT", "1T", "151", "36",
+	"ETSI", "5G", "40M", "HT", "1T", "151", "32",
+	"MKK", "5G", "40M", "HT", "1T", "151", "63",
+	"FCC", "5G", "40M", "HT", "1T", "159", "36",
+	"ETSI", "5G", "40M", "HT", "1T", "159", "32",
+	"MKK", "5G", "40M", "HT", "1T", "159", "63",
+	"FCC", "5G", "40M", "HT", "2T", "38", "28",
+	"ETSI", "5G", "40M", "HT", "2T", "38", "30",
+	"MKK", "5G", "40M", "HT", "2T", "38", "30",
+	"FCC", "5G", "40M", "HT", "2T", "46", "28",
+	"ETSI", "5G", "40M", "HT", "2T", "46", "30",
+	"MKK", "5G", "40M", "HT", "2T", "46", "30",
+	"FCC", "5G", "40M", "HT", "2T", "54", "30",
+	"ETSI", "5G", "40M", "HT", "2T", "54", "30",
+	"MKK", "5G", "40M", "HT", "2T", "54", "30",
+	"FCC", "5G", "40M", "HT", "2T", "62", "30",
+	"ETSI", "5G", "40M", "HT", "2T", "62", "30",
+	"MKK", "5G", "40M", "HT", "2T", "62", "30",
+	"FCC", "5G", "40M", "HT", "2T", "102", "26",
+	"ETSI", "5G", "40M", "HT", "2T", "102", "30",
+	"MKK", "5G", "40M", "HT", "2T", "102", "30",
+	"FCC", "5G", "40M", "HT", "2T", "110", "30",
+	"ETSI", "5G", "40M", "HT", "2T", "110", "30",
+	"MKK", "5G", "40M", "HT", "2T", "110", "30",
+	"FCC", "5G", "40M", "HT", "2T", "118", "34",
+	"ETSI", "5G", "40M", "HT", "2T", "118", "30",
+	"MKK", "5G", "40M", "HT", "2T", "118", "30",
+	"FCC", "5G", "40M", "HT", "2T", "126", "32",
+	"ETSI", "5G", "40M", "HT", "2T", "126", "30",
+	"MKK", "5G", "40M", "HT", "2T", "126", "30",
+	"FCC", "5G", "40M", "HT", "2T", "134", "30",
+	"ETSI", "5G", "40M", "HT", "2T", "134", "30",
+	"MKK", "5G", "40M", "HT", "2T", "134", "30",
+	"FCC", "5G", "40M", "HT", "2T", "151", "34",
+	"ETSI", "5G", "40M", "HT", "2T", "151", "30",
+	"MKK", "5G", "40M", "HT", "2T", "151", "63",
+	"FCC", "5G", "40M", "HT", "2T", "159", "34",
+	"ETSI", "5G", "40M", "HT", "2T", "159", "30",
+	"MKK", "5G", "40M", "HT", "2T", "159", "63",
+	"FCC", "5G", "80M", "VHT", "1T", "42", "30",
+	"ETSI", "5G", "80M", "VHT", "1T", "42", "32",
+	"MKK", "5G", "80M", "VHT", "1T", "42", "32",
+	"FCC", "5G", "80M", "VHT", "1T", "58", "28",
+	"ETSI", "5G", "80M", "VHT", "1T", "58", "32",
+	"MKK", "5G", "80M", "VHT", "1T", "58", "32",
+	"FCC", "5G", "80M", "VHT", "1T", "106", "30",
+	"ETSI", "5G", "80M", "VHT", "1T", "106", "32",
+	"MKK", "5G", "80M", "VHT", "1T", "106", "32",
+	"FCC", "5G", "80M", "VHT", "1T", "122", "34",
+	"ETSI", "5G", "80M", "VHT", "1T", "122", "32",
+	"MKK", "5G", "80M", "VHT", "1T", "122", "32",
+	"FCC", "5G", "80M", "VHT", "1T", "155", "36",
+	"ETSI", "5G", "80M", "VHT", "1T", "155", "32",
+	"MKK", "5G", "80M", "VHT", "1T", "155", "63",
+	"FCC", "5G", "80M", "VHT", "2T", "42", "28",
+	"ETSI", "5G", "80M", "VHT", "2T", "42", "30",
+	"MKK", "5G", "80M", "VHT", "2T", "42", "30",
+	"FCC", "5G", "80M", "VHT", "2T", "58", "26",
+	"ETSI", "5G", "80M", "VHT", "2T", "58", "30",
+	"MKK", "5G", "80M", "VHT", "2T", "58", "30",
+	"FCC", "5G", "80M", "VHT", "2T", "106", "28",
+	"ETSI", "5G", "80M", "VHT", "2T", "106", "30",
+	"MKK", "5G", "80M", "VHT", "2T", "106", "30",
+	"FCC", "5G", "80M", "VHT", "2T", "122", "32",
+	"ETSI", "5G", "80M", "VHT", "2T", "122", "30",
+	"MKK", "5G", "80M", "VHT", "2T", "122", "30",
+	"FCC", "5G", "80M", "VHT", "2T", "155", "34",
+	"ETSI", "5G", "80M", "VHT", "2T", "155", "30",
+	"MKK", "5G", "80M", "VHT", "2T", "155", "63"
+};
+
+u8 *RTL8821AU_TXPWR_LMT[] = {
+	"FCC", "2.4G", "20M", "CCK", "1T", "01", "34",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "01", "32",
+	"MKK", "2.4G", "20M", "CCK", "1T", "01", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "02", "34",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "02", "32",
+	"MKK", "2.4G", "20M", "CCK", "1T", "02", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "03", "34",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "03", "32",
+	"MKK", "2.4G", "20M", "CCK", "1T", "03", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "04", "34",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "04", "32",
+	"MKK", "2.4G", "20M", "CCK", "1T", "04", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "05", "34",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "05", "32",
+	"MKK", "2.4G", "20M", "CCK", "1T", "05", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "06", "34",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "06", "32",
+	"MKK", "2.4G", "20M", "CCK", "1T", "06", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "07", "34",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "07", "32",
+	"MKK", "2.4G", "20M", "CCK", "1T", "07", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "08", "34",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "08", "32",
+	"MKK", "2.4G", "20M", "CCK", "1T", "08", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "09", "34",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "09", "32",
+	"MKK", "2.4G", "20M", "CCK", "1T", "09", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "10", "34",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "10", "32",
+	"MKK", "2.4G", "20M", "CCK", "1T", "10", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "11", "34",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "11", "32",
+	"MKK", "2.4G", "20M", "CCK", "1T", "11", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "12", "63",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "12", "32",
+	"MKK", "2.4G", "20M", "CCK", "1T", "12", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "13", "63",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "13", "32",
+	"MKK", "2.4G", "20M", "CCK", "1T", "13", "32",
+	"FCC", "2.4G", "20M", "CCK", "1T", "14", "63",
+	"ETSI", "2.4G", "20M", "CCK", "1T", "14", "63",
+	"MKK", "2.4G", "20M", "CCK", "1T", "14", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "01", "32",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "01", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "01", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "02", "34",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "02", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "02", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "03", "34",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "03", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "03", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "04", "34",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "04", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "04", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "05", "34",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "05", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "05", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "06", "34",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "06", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "06", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "07", "34",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "07", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "07", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "08", "34",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "08", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "08", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "09", "34",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "09", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "09", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "10", "34",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "10", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "10", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "11", "32",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "11", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "11", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "12", "63",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "12", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "12", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "13", "63",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "13", "32",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "13", "32",
+	"FCC", "2.4G", "20M", "OFDM", "1T", "14", "63",
+	"ETSI", "2.4G", "20M", "OFDM", "1T", "14", "63",
+	"MKK", "2.4G", "20M", "OFDM", "1T", "14", "63",
+	"FCC", "2.4G", "20M", "HT", "1T", "01", "32",
+	"ETSI", "2.4G", "20M", "HT", "1T", "01", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "01", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "02", "34",
+	"ETSI", "2.4G", "20M", "HT", "1T", "02", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "02", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "03", "34",
+	"ETSI", "2.4G", "20M", "HT", "1T", "03", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "03", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "04", "34",
+	"ETSI", "2.4G", "20M", "HT", "1T", "04", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "04", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "05", "34",
+	"ETSI", "2.4G", "20M", "HT", "1T", "05", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "05", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "06", "34",
+	"ETSI", "2.4G", "20M", "HT", "1T", "06", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "06", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "07", "34",
+	"ETSI", "2.4G", "20M", "HT", "1T", "07", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "07", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "08", "34",
+	"ETSI", "2.4G", "20M", "HT", "1T", "08", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "08", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "09", "34",
+	"ETSI", "2.4G", "20M", "HT", "1T", "09", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "09", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "10", "34",
+	"ETSI", "2.4G", "20M", "HT", "1T", "10", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "10", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "11", "32",
+	"ETSI", "2.4G", "20M", "HT", "1T", "11", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "11", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "12", "63",
+	"ETSI", "2.4G", "20M", "HT", "1T", "12", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "12", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "13", "63",
+	"ETSI", "2.4G", "20M", "HT", "1T", "13", "32",
+	"MKK", "2.4G", "20M", "HT", "1T", "13", "32",
+	"FCC", "2.4G", "20M", "HT", "1T", "14", "63",
+	"ETSI", "2.4G", "20M", "HT", "1T", "14", "63",
+	"MKK", "2.4G", "20M", "HT", "1T", "14", "63",
+	"FCC", "2.4G", "20M", "HT", "2T", "01", "30",
+	"ETSI", "2.4G", "20M", "HT", "2T", "01", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "01", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "02", "32",
+	"ETSI", "2.4G", "20M", "HT", "2T", "02", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "02", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "03", "32",
+	"ETSI", "2.4G", "20M", "HT", "2T", "03", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "03", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "04", "32",
+	"ETSI", "2.4G", "20M", "HT", "2T", "04", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "04", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "05", "32",
+	"ETSI", "2.4G", "20M", "HT", "2T", "05", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "05", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "06", "32",
+	"ETSI", "2.4G", "20M", "HT", "2T", "06", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "06", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "07", "32",
+	"ETSI", "2.4G", "20M", "HT", "2T", "07", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "07", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "08", "32",
+	"ETSI", "2.4G", "20M", "HT", "2T", "08", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "08", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "09", "32",
+	"ETSI", "2.4G", "20M", "HT", "2T", "09", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "09", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "10", "32",
+	"ETSI", "2.4G", "20M", "HT", "2T", "10", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "10", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "11", "30",
+	"ETSI", "2.4G", "20M", "HT", "2T", "11", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "11", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "12", "63",
+	"ETSI", "2.4G", "20M", "HT", "2T", "12", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "12", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "13", "63",
+	"ETSI", "2.4G", "20M", "HT", "2T", "13", "32",
+	"MKK", "2.4G", "20M", "HT", "2T", "13", "32",
+	"FCC", "2.4G", "20M", "HT", "2T", "14", "63",
+	"ETSI", "2.4G", "20M", "HT", "2T", "14", "63",
+	"MKK", "2.4G", "20M", "HT", "2T", "14", "63",
+	"FCC", "2.4G", "40M", "HT", "1T", "01", "63",
+	"ETSI", "2.4G", "40M", "HT", "1T", "01", "63",
+	"MKK", "2.4G", "40M", "HT", "1T", "01", "63",
+	"FCC", "2.4G", "40M", "HT", "1T", "02", "63",
+	"ETSI", "2.4G", "40M", "HT", "1T", "02", "63",
+	"MKK", "2.4G", "40M", "HT", "1T", "02", "63",
+	"FCC", "2.4G", "40M", "HT", "1T", "03", "32",
+	"ETSI", "2.4G", "40M", "HT", "1T", "03", "32",
+	"MKK", "2.4G", "40M", "HT", "1T", "03", "32",
+	"FCC", "2.4G", "40M", "HT", "1T", "04", "34",
+	"ETSI", "2.4G", "40M", "HT", "1T", "04", "32",
+	"MKK", "2.4G", "40M", "HT", "1T", "04", "32",
+	"FCC", "2.4G", "40M", "HT", "1T", "05", "34",
+	"ETSI", "2.4G", "40M", "HT", "1T", "05", "32",
+	"MKK", "2.4G", "40M", "HT", "1T", "05", "32",
+	"FCC", "2.4G", "40M", "HT", "1T", "06", "34",
+	"ETSI", "2.4G", "40M", "HT", "1T", "06", "32",
+	"MKK", "2.4G", "40M", "HT", "1T", "06", "32",
+	"FCC", "2.4G", "40M", "HT", "1T", "07", "34",
+	"ETSI", "2.4G", "40M", "HT", "1T", "07", "32",
+	"MKK", "2.4G", "40M", "HT", "1T", "07", "32",
+	"FCC", "2.4G", "40M", "HT", "1T", "08", "34",
+	"ETSI", "2.4G", "40M", "HT", "1T", "08", "32",
+	"MKK", "2.4G", "40M", "HT", "1T", "08", "32",
+	"FCC", "2.4G", "40M", "HT", "1T", "09", "34",
+	"ETSI", "2.4G", "40M", "HT", "1T", "09", "32",
+	"MKK", "2.4G", "40M", "HT", "1T", "09", "32",
+	"FCC", "2.4G", "40M", "HT", "1T", "10", "34",
+	"ETSI", "2.4G", "40M", "HT", "1T", "10", "32",
+	"MKK", "2.4G", "40M", "HT", "1T", "10", "32",
+	"FCC", "2.4G", "40M", "HT", "1T", "11", "32",
+	"ETSI", "2.4G", "40M", "HT", "1T", "11", "32",
+	"MKK", "2.4G", "40M", "HT", "1T", "11", "32",
+	"FCC", "2.4G", "40M", "HT", "1T", "12", "63",
+	"ETSI", "2.4G", "40M", "HT", "1T", "12", "32",
+	"MKK", "2.4G", "40M", "HT", "1T", "12", "32",
+	"FCC", "2.4G", "40M", "HT", "1T", "13", "63",
+	"ETSI", "2.4G", "40M", "HT", "1T", "13", "32",
+	"MKK", "2.4G", "40M", "HT", "1T", "13", "32",
+	"FCC", "2.4G", "40M", "HT", "1T", "14", "63",
+	"ETSI", "2.4G", "40M", "HT", "1T", "14", "63",
+	"MKK", "2.4G", "40M", "HT", "1T", "14", "63",
+	"FCC", "2.4G", "40M", "HT", "2T", "01", "63",
+	"ETSI", "2.4G", "40M", "HT", "2T", "01", "63",
+	"MKK", "2.4G", "40M", "HT", "2T", "01", "63",
+	"FCC", "2.4G", "40M", "HT", "2T", "02", "63",
+	"ETSI", "2.4G", "40M", "HT", "2T", "02", "63",
+	"MKK", "2.4G", "40M", "HT", "2T", "02", "63",
+	"FCC", "2.4G", "40M", "HT", "2T", "03", "30",
+	"ETSI", "2.4G", "40M", "HT", "2T", "03", "30",
+	"MKK", "2.4G", "40M", "HT", "2T", "03", "30",
+	"FCC", "2.4G", "40M", "HT", "2T", "04", "32",
+	"ETSI", "2.4G", "40M", "HT", "2T", "04", "30",
+	"MKK", "2.4G", "40M", "HT", "2T", "04", "30",
+	"FCC", "2.4G", "40M", "HT", "2T", "05", "32",
+	"ETSI", "2.4G", "40M", "HT", "2T", "05", "30",
+	"MKK", "2.4G", "40M", "HT", "2T", "05", "30",
+	"FCC", "2.4G", "40M", "HT", "2T", "06", "32",
+	"ETSI", "2.4G", "40M", "HT", "2T", "06", "30",
+	"MKK", "2.4G", "40M", "HT", "2T", "06", "30",
+	"FCC", "2.4G", "40M", "HT", "2T", "07", "32",
+	"ETSI", "2.4G", "40M", "HT", "2T", "07", "30",
+	"MKK", "2.4G", "40M", "HT", "2T", "07", "30",
+	"FCC", "2.4G", "40M", "HT", "2T", "08", "32",
+	"ETSI", "2.4G", "40M", "HT", "2T", "08", "30",
+	"MKK", "2.4G", "40M", "HT", "2T", "08", "30",
+	"FCC", "2.4G", "40M", "HT", "2T", "09", "32",
+	"ETSI", "2.4G", "40M", "HT", "2T", "09", "30",
+	"MKK", "2.4G", "40M", "HT", "2T", "09", "30",
+	"FCC", "2.4G", "40M", "HT", "2T", "10", "32",
+	"ETSI", "2.4G", "40M", "HT", "2T", "10", "30",
+	"MKK", "2.4G", "40M", "HT", "2T", "10", "30",
+	"FCC", "2.4G", "40M", "HT", "2T", "11", "30",
+	"ETSI", "2.4G", "40M", "HT", "2T", "11", "30",
+	"MKK", "2.4G", "40M", "HT", "2T", "11", "30",
+	"FCC", "2.4G", "40M", "HT", "2T", "12", "63",
+	"ETSI", "2.4G", "40M", "HT", "2T", "12", "32",
+	"MKK", "2.4G", "40M", "HT", "2T", "12", "32",
+	"FCC", "2.4G", "40M", "HT", "2T", "13", "63",
+	"ETSI", "2.4G", "40M", "HT", "2T", "13", "32",
+	"MKK", "2.4G", "40M", "HT", "2T", "13", "32",
+	"FCC", "2.4G", "40M", "HT", "2T", "14", "63",
+	"ETSI", "2.4G", "40M", "HT", "2T", "14", "63",
+	"MKK", "2.4G", "40M", "HT", "2T", "14", "63",
+	"FCC", "5G", "20M", "OFDM", "1T", "36", "30",
+	"ETSI", "5G", "20M", "OFDM", "1T", "36", "32",
+	"MKK", "5G", "20M", "OFDM", "1T", "36", "32",
+	"FCC", "5G", "20M", "OFDM", "1T", "40", "30",
+	"ETSI", "5G", "20M", "OFDM", "1T", "40", "32",
+	"MKK", "5G", "20M", "OFDM", "1T", "40", "32",
+	"FCC", "5G", "20M", "OFDM", "1T", "44", "30",
+	"ETSI", "5G", "20M", "OFDM", "1T", "44", "32",
+	"MKK", "5G", "20M", "OFDM", "1T", "44", "32",
+	"FCC", "5G", "20M", "OFDM", "1T", "48", "30",
+	"ETSI", "5G", "20M", "OFDM", "1T", "48", "32",
+	"MKK", "5G", "20M", "OFDM", "1T", "48", "32",
+	"FCC", "5G", "20M", "OFDM", "1T", "52", "34",
+	"ETSI", "5G", "20M", "OFDM", "1T", "52", "32",
+	"MKK", "5G", "20M", "OFDM", "1T", "52", "32",
+	"FCC", "5G", "20M", "OFDM", "1T", "56", "34",
+	"ETSI", "5G", "20M", "OFDM", "1T", "56", "32",
+	"MKK", "5G", "20M", "OFDM", "1T", "56", "32",
+	"FCC", "5G", "20M", "OFDM", "1T", "60", "32",
+	"ETSI", "5G", "20M", "OFDM", "1T", "60", "32",
+	"MKK", "5G", "20M", "OFDM", "1T", "60", "32",
+	"FCC", "5G", "20M", "OFDM", "1T", "64", "28",
+	"ETSI", "5G", "20M", "OFDM", "1T", "64", "32",
+	"MKK", "5G", "20M", "OFDM", "1T", "64", "32",
+	"FCC", "5G", "20M", "OFDM", "1T", "100", "30",
+	"ETSI", "5G", "20M", "OFDM", "1T", "100", "32",
+	"MKK", "5G", "20M", "OFDM", "1T", "100", "32",
+	"FCC", "5G", "20M", "OFDM", "1T", "114", "30",
+	"ETSI", "5G", "20M", "OFDM", "1T", "114", "32",
+	"MKK", "5G", "20M", "OFDM", "1T", "114", "32",
+	"FCC", "5G", "20M", "OFDM", "1T", "108", "32",
+	"ETSI", "5G", "20M", "OFDM", "1T", "108", "32",
+	"MKK", "5G", "20M", "OFDM", "1T", "108", "32",
+	"FCC", "5G", "20M", "OFDM", "1T", "112", "34",
+	"ETSI", "5G", "20M", "OFDM", "1T", "112", "32",
+	"MKK", "5G", "20M", "OFDM", "1T", "112", "32",
+	"FCC", "5G", "20M", "OFDM", "1T", "116", "34",
+	"ETSI", "5G", "20M", "OFDM", "1T", "116", "32",
+	"MKK", "5G", "20M", "OFDM", "1T", "116", "32",
+	"FCC", "5G", "20M", "OFDM", "1T", "120", "34",
+	"ETSI", "5G", "20M", "OFDM", "1T", "120", "32",
+	"MKK", "5G", "20M", "OFDM", "1T", "120", "32",
+	"FCC", "5G", "20M", "OFDM", "1T", "124", "34",
+	"ETSI", "5G", "20M", "OFDM", "1T", "124", "32",
+	"MKK", "5G", "20M", "OFDM", "1T", "124", "32",
+	"FCC", "5G", "20M", "OFDM", "1T", "128", "32",
+	"ETSI", "5G", "20M", "OFDM", "1T", "128", "32",
+	"MKK", "5G", "20M", "OFDM", "1T", "128", "32",
+	"FCC", "5G", "20M", "OFDM", "1T", "132", "30",
+	"ETSI", "5G", "20M", "OFDM", "1T", "132", "32",
+	"MKK", "5G", "20M", "OFDM", "1T", "132", "32",
+	"FCC", "5G", "20M", "OFDM", "1T", "136", "30",
+	"ETSI", "5G", "20M", "OFDM", "1T", "136", "32",
+	"MKK", "5G", "20M", "OFDM", "1T", "136", "32",
+	"FCC", "5G", "20M", "OFDM", "1T", "140", "28",
+	"ETSI", "5G", "20M", "OFDM", "1T", "140", "32",
+	"MKK", "5G", "20M", "OFDM", "1T", "140", "32",
+	"FCC", "5G", "20M", "OFDM", "1T", "149", "34",
+	"ETSI", "5G", "20M", "OFDM", "1T", "149", "32",
+	"MKK", "5G", "20M", "OFDM", "1T", "149", "63",
+	"FCC", "5G", "20M", "OFDM", "1T", "153", "34",
+	"ETSI", "5G", "20M", "OFDM", "1T", "153", "32",
+	"MKK", "5G", "20M", "OFDM", "1T", "153", "63",
+	"FCC", "5G", "20M", "OFDM", "1T", "157", "34",
+	"ETSI", "5G", "20M", "OFDM", "1T", "157", "32",
+	"MKK", "5G", "20M", "OFDM", "1T", "157", "63",
+	"FCC", "5G", "20M", "OFDM", "1T", "161", "34",
+	"ETSI", "5G", "20M", "OFDM", "1T", "161", "32",
+	"MKK", "5G", "20M", "OFDM", "1T", "161", "63",
+	"FCC", "5G", "20M", "OFDM", "1T", "165", "34",
+	"ETSI", "5G", "20M", "OFDM", "1T", "165", "32",
+	"MKK", "5G", "20M", "OFDM", "1T", "165", "63",
+	"FCC", "5G", "20M", "HT", "1T", "36", "30",
+	"ETSI", "5G", "20M", "HT", "1T", "36", "32",
+	"MKK", "5G", "20M", "HT", "1T", "36", "32",
+	"FCC", "5G", "20M", "HT", "1T", "40", "30",
+	"ETSI", "5G", "20M", "HT", "1T", "40", "32",
+	"MKK", "5G", "20M", "HT", "1T", "40", "32",
+	"FCC", "5G", "20M", "HT", "1T", "44", "30",
+	"ETSI", "5G", "20M", "HT", "1T", "44", "32",
+	"MKK", "5G", "20M", "HT", "1T", "44", "32",
+	"FCC", "5G", "20M", "HT", "1T", "48", "30",
+	"ETSI", "5G", "20M", "HT", "1T", "48", "32",
+	"MKK", "5G", "20M", "HT", "1T", "48", "32",
+	"FCC", "5G", "20M", "HT", "1T", "52", "34",
+	"ETSI", "5G", "20M", "HT", "1T", "52", "32",
+	"MKK", "5G", "20M", "HT", "1T", "52", "32",
+	"FCC", "5G", "20M", "HT", "1T", "56", "34",
+	"ETSI", "5G", "20M", "HT", "1T", "56", "32",
+	"MKK", "5G", "20M", "HT", "1T", "56", "32",
+	"FCC", "5G", "20M", "HT", "1T", "60", "32",
+	"ETSI", "5G", "20M", "HT", "1T", "60", "32",
+	"MKK", "5G", "20M", "HT", "1T", "60", "32",
+	"FCC", "5G", "20M", "HT", "1T", "64", "28",
+	"ETSI", "5G", "20M", "HT", "1T", "64", "32",
+	"MKK", "5G", "20M", "HT", "1T", "64", "32",
+	"FCC", "5G", "20M", "HT", "1T", "100", "30",
+	"ETSI", "5G", "20M", "HT", "1T", "100", "32",
+	"MKK", "5G", "20M", "HT", "1T", "100", "32",
+	"FCC", "5G", "20M", "HT", "1T", "114", "30",
+	"ETSI", "5G", "20M", "HT", "1T", "114", "32",
+	"MKK", "5G", "20M", "HT", "1T", "114", "32",
+	"FCC", "5G", "20M", "HT", "1T", "108", "32",
+	"ETSI", "5G", "20M", "HT", "1T", "108", "32",
+	"MKK", "5G", "20M", "HT", "1T", "108", "32",
+	"FCC", "5G", "20M", "HT", "1T", "112", "34",
+	"ETSI", "5G", "20M", "HT", "1T", "112", "32",
+	"MKK", "5G", "20M", "HT", "1T", "112", "32",
+	"FCC", "5G", "20M", "HT", "1T", "116", "34",
+	"ETSI", "5G", "20M", "HT", "1T", "116", "32",
+	"MKK", "5G", "20M", "HT", "1T", "116", "32",
+	"FCC", "5G", "20M", "HT", "1T", "120", "34",
+	"ETSI", "5G", "20M", "HT", "1T", "120", "32",
+	"MKK", "5G", "20M", "HT", "1T", "120", "32",
+	"FCC", "5G", "20M", "HT", "1T", "124", "34",
+	"ETSI", "5G", "20M", "HT", "1T", "124", "32",
+	"MKK", "5G", "20M", "HT", "1T", "124", "32",
+	"FCC", "5G", "20M", "HT", "1T", "128", "32",
+	"ETSI", "5G", "20M", "HT", "1T", "128", "32",
+	"MKK", "5G", "20M", "HT", "1T", "128", "32",
+	"FCC", "5G", "20M", "HT", "1T", "132", "30",
+	"ETSI", "5G", "20M", "HT", "1T", "132", "32",
+	"MKK", "5G", "20M", "HT", "1T", "132", "32",
+	"FCC", "5G", "20M", "HT", "1T", "136", "30",
+	"ETSI", "5G", "20M", "HT", "1T", "136", "32",
+	"MKK", "5G", "20M", "HT", "1T", "136", "32",
+	"FCC", "5G", "20M", "HT", "1T", "140", "28",
+	"ETSI", "5G", "20M", "HT", "1T", "140", "32",
+	"MKK", "5G", "20M", "HT", "1T", "140", "32",
+	"FCC", "5G", "20M", "HT", "1T", "149", "34",
+	"ETSI", "5G", "20M", "HT", "1T", "149", "32",
+	"MKK", "5G", "20M", "HT", "1T", "149", "63",
+	"FCC", "5G", "20M", "HT", "1T", "153", "34",
+	"ETSI", "5G", "20M", "HT", "1T", "153", "32",
+	"MKK", "5G", "20M", "HT", "1T", "153", "63",
+	"FCC", "5G", "20M", "HT", "1T", "157", "34",
+	"ETSI", "5G", "20M", "HT", "1T", "157", "32",
+	"MKK", "5G", "20M", "HT", "1T", "157", "63",
+	"FCC", "5G", "20M", "HT", "1T", "161", "34",
+	"ETSI", "5G", "20M", "HT", "1T", "161", "32",
+	"MKK", "5G", "20M", "HT", "1T", "161", "63",
+	"FCC", "5G", "20M", "HT", "1T", "165", "34",
+	"ETSI", "5G", "20M", "HT", "1T", "165", "32",
+	"MKK", "5G", "20M", "HT", "1T", "165", "63",
+	"FCC", "5G", "20M", "HT", "2T", "36", "28",
+	"ETSI", "5G", "20M", "HT", "2T", "36", "30",
+	"MKK", "5G", "20M", "HT", "2T", "36", "30",
+	"FCC", "5G", "20M", "HT", "2T", "40", "28",
+	"ETSI", "5G", "20M", "HT", "2T", "40", "30",
+	"MKK", "5G", "20M", "HT", "2T", "40", "30",
+	"FCC", "5G", "20M", "HT", "2T", "44", "28",
+	"ETSI", "5G", "20M", "HT", "2T", "44", "30",
+	"MKK", "5G", "20M", "HT", "2T", "44", "30",
+	"FCC", "5G", "20M", "HT", "2T", "48", "28",
+	"ETSI", "5G", "20M", "HT", "2T", "48", "30",
+	"MKK", "5G", "20M", "HT", "2T", "48", "30",
+	"FCC", "5G", "20M", "HT", "2T", "52", "34",
+	"ETSI", "5G", "20M", "HT", "2T", "52", "30",
+	"MKK", "5G", "20M", "HT", "2T", "52", "30",
+	"FCC", "5G", "20M", "HT", "2T", "56", "32",
+	"ETSI", "5G", "20M", "HT", "2T", "56", "30",
+	"MKK", "5G", "20M", "HT", "2T", "56", "30",
+	"FCC", "5G", "20M", "HT", "2T", "60", "30",
+	"ETSI", "5G", "20M", "HT", "2T", "60", "30",
+	"MKK", "5G", "20M", "HT", "2T", "60", "30",
+	"FCC", "5G", "20M", "HT", "2T", "64", "26",
+	"ETSI", "5G", "20M", "HT", "2T", "64", "30",
+	"MKK", "5G", "20M", "HT", "2T", "64", "30",
+	"FCC", "5G", "20M", "HT", "2T", "100", "28",
+	"ETSI", "5G", "20M", "HT", "2T", "100", "30",
+	"MKK", "5G", "20M", "HT", "2T", "100", "30",
+	"FCC", "5G", "20M", "HT", "2T", "114", "28",
+	"ETSI", "5G", "20M", "HT", "2T", "114", "30",
+	"MKK", "5G", "20M", "HT", "2T", "114", "30",
+	"FCC", "5G", "20M", "HT", "2T", "108", "30",
+	"ETSI", "5G", "20M", "HT", "2T", "108", "30",
+	"MKK", "5G", "20M", "HT", "2T", "108", "30",
+	"FCC", "5G", "20M", "HT", "2T", "112", "32",
+	"ETSI", "5G", "20M", "HT", "2T", "112", "30",
+	"MKK", "5G", "20M", "HT", "2T", "112", "30",
+	"FCC", "5G", "20M", "HT", "2T", "116", "32",
+	"ETSI", "5G", "20M", "HT", "2T", "116", "30",
+	"MKK", "5G", "20M", "HT", "2T", "116", "30",
+	"FCC", "5G", "20M", "HT", "2T", "120", "34",
+	"ETSI", "5G", "20M", "HT", "2T", "120", "30",
+	"MKK", "5G", "20M", "HT", "2T", "120", "30",
+	"FCC", "5G", "20M", "HT", "2T", "124", "32",
+	"ETSI", "5G", "20M", "HT", "2T", "124", "30",
+	"MKK", "5G", "20M", "HT", "2T", "124", "30",
+	"FCC", "5G", "20M", "HT", "2T", "128", "30",
+	"ETSI", "5G", "20M", "HT", "2T", "128", "30",
+	"MKK", "5G", "20M", "HT", "2T", "128", "30",
+	"FCC", "5G", "20M", "HT", "2T", "132", "28",
+	"ETSI", "5G", "20M", "HT", "2T", "132", "30",
+	"MKK", "5G", "20M", "HT", "2T", "132", "30",
+	"FCC", "5G", "20M", "HT", "2T", "136", "28",
+	"ETSI", "5G", "20M", "HT", "2T", "136", "30",
+	"MKK", "5G", "20M", "HT", "2T", "136", "30",
+	"FCC", "5G", "20M", "HT", "2T", "140", "26",
+	"ETSI", "5G", "20M", "HT", "2T", "140", "30",
+	"MKK", "5G", "20M", "HT", "2T", "140", "30",
+	"FCC", "5G", "20M", "HT", "2T", "149", "34",
+	"ETSI", "5G", "20M", "HT", "2T", "149", "30",
+	"MKK", "5G", "20M", "HT", "2T", "149", "63",
+	"FCC", "5G", "20M", "HT", "2T", "153", "34",
+	"ETSI", "5G", "20M", "HT", "2T", "153", "30",
+	"MKK", "5G", "20M", "HT", "2T", "153", "63",
+	"FCC", "5G", "20M", "HT", "2T", "157", "34",
+	"ETSI", "5G", "20M", "HT", "2T", "157", "30",
+	"MKK", "5G", "20M", "HT", "2T", "157", "63",
+	"FCC", "5G", "20M", "HT", "2T", "161", "34",
+	"ETSI", "5G", "20M", "HT", "2T", "161", "30",
+	"MKK", "5G", "20M", "HT", "2T", "161", "63",
+	"FCC", "5G", "20M", "HT", "2T", "165", "34",
+	"ETSI", "5G", "20M", "HT", "2T", "165", "30",
+	"MKK", "5G", "20M", "HT", "2T", "165", "63",
+	"FCC", "5G", "40M", "HT", "1T", "38", "30",
+	"ETSI", "5G", "40M", "HT", "1T", "38", "32",
+	"MKK", "5G", "40M", "HT", "1T", "38", "32",
+	"FCC", "5G", "40M", "HT", "1T", "46", "30",
+	"ETSI", "5G", "40M", "HT", "1T", "46", "32",
+	"MKK", "5G", "40M", "HT", "1T", "46", "32",
+	"FCC", "5G", "40M", "HT", "1T", "54", "32",
+	"ETSI", "5G", "40M", "HT", "1T", "54", "32",
+	"MKK", "5G", "40M", "HT", "1T", "54", "32",
+	"FCC", "5G", "40M", "HT", "1T", "62", "32",
+	"ETSI", "5G", "40M", "HT", "1T", "62", "32",
+	"MKK", "5G", "40M", "HT", "1T", "62", "32",
+	"FCC", "5G", "40M", "HT", "1T", "102", "28",
+	"ETSI", "5G", "40M", "HT", "1T", "102", "32",
+	"MKK", "5G", "40M", "HT", "1T", "102", "32",
+	"FCC", "5G", "40M", "HT", "1T", "110", "32",
+	"ETSI", "5G", "40M", "HT", "1T", "110", "32",
+	"MKK", "5G", "40M", "HT", "1T", "110", "32",
+	"FCC", "5G", "40M", "HT", "1T", "118", "34",
+	"ETSI", "5G", "40M", "HT", "1T", "118", "32",
+	"MKK", "5G", "40M", "HT", "1T", "118", "32",
+	"FCC", "5G", "40M", "HT", "1T", "126", "34",
+	"ETSI", "5G", "40M", "HT", "1T", "126", "32",
+	"MKK", "5G", "40M", "HT", "1T", "126", "32",
+	"FCC", "5G", "40M", "HT", "1T", "134", "32",
+	"ETSI", "5G", "40M", "HT", "1T", "134", "32",
+	"MKK", "5G", "40M", "HT", "1T", "134", "32",
+	"FCC", "5G", "40M", "HT", "1T", "151", "34",
+	"ETSI", "5G", "40M", "HT", "1T", "151", "32",
+	"MKK", "5G", "40M", "HT", "1T", "151", "63",
+	"FCC", "5G", "40M", "HT", "1T", "159", "34",
+	"ETSI", "5G", "40M", "HT", "1T", "159", "32",
+	"MKK", "5G", "40M", "HT", "1T", "159", "63",
+	"FCC", "5G", "40M", "HT", "2T", "38", "28",
+	"ETSI", "5G", "40M", "HT", "2T", "38", "30",
+	"MKK", "5G", "40M", "HT", "2T", "38", "30",
+	"FCC", "5G", "40M", "HT", "2T", "46", "28",
+	"ETSI", "5G", "40M", "HT", "2T", "46", "30",
+	"MKK", "5G", "40M", "HT", "2T", "46", "30",
+	"FCC", "5G", "40M", "HT", "2T", "54", "30",
+	"ETSI", "5G", "40M", "HT", "2T", "54", "30",
+	"MKK", "5G", "40M", "HT", "2T", "54", "30",
+	"FCC", "5G", "40M", "HT", "2T", "62", "30",
+	"ETSI", "5G", "40M", "HT", "2T", "62", "30",
+	"MKK", "5G", "40M", "HT", "2T", "62", "30",
+	"FCC", "5G", "40M", "HT", "2T", "102", "26",
+	"ETSI", "5G", "40M", "HT", "2T", "102", "30",
+	"MKK", "5G", "40M", "HT", "2T", "102", "30",
+	"FCC", "5G", "40M", "HT", "2T", "110", "30",
+	"ETSI", "5G", "40M", "HT", "2T", "110", "30",
+	"MKK", "5G", "40M", "HT", "2T", "110", "30",
+	"FCC", "5G", "40M", "HT", "2T", "118", "34",
+	"ETSI", "5G", "40M", "HT", "2T", "118", "30",
+	"MKK", "5G", "40M", "HT", "2T", "118", "30",
+	"FCC", "5G", "40M", "HT", "2T", "126", "32",
+	"ETSI", "5G", "40M", "HT", "2T", "126", "30",
+	"MKK", "5G", "40M", "HT", "2T", "126", "30",
+	"FCC", "5G", "40M", "HT", "2T", "134", "30",
+	"ETSI", "5G", "40M", "HT", "2T", "134", "30",
+	"MKK", "5G", "40M", "HT", "2T", "134", "30",
+	"FCC", "5G", "40M", "HT", "2T", "151", "34",
+	"ETSI", "5G", "40M", "HT", "2T", "151", "30",
+	"MKK", "5G", "40M", "HT", "2T", "151", "63",
+	"FCC", "5G", "40M", "HT", "2T", "159", "34",
+	"ETSI", "5G", "40M", "HT", "2T", "159", "30",
+	"MKK", "5G", "40M", "HT", "2T", "159", "63",
+	"FCC", "5G", "80M", "VHT", "1T", "42", "30",
+	"ETSI", "5G", "80M", "VHT", "1T", "42", "32",
+	"MKK", "5G", "80M", "VHT", "1T", "42", "32",
+	"FCC", "5G", "80M", "VHT", "1T", "58", "28",
+	"ETSI", "5G", "80M", "VHT", "1T", "58", "32",
+	"MKK", "5G", "80M", "VHT", "1T", "58", "32",
+	"FCC", "5G", "80M", "VHT", "1T", "106", "30",
+	"ETSI", "5G", "80M", "VHT", "1T", "106", "32",
+	"MKK", "5G", "80M", "VHT", "1T", "106", "32",
+	"FCC", "5G", "80M", "VHT", "1T", "122", "34",
+	"ETSI", "5G", "80M", "VHT", "1T", "122", "32",
+	"MKK", "5G", "80M", "VHT", "1T", "122", "32",
+	"FCC", "5G", "80M", "VHT", "1T", "155", "34",
+	"ETSI", "5G", "80M", "VHT", "1T", "155", "32",
+	"MKK", "5G", "80M", "VHT", "1T", "155", "63",
+	"FCC", "5G", "80M", "VHT", "2T", "42", "28",
+	"ETSI", "5G", "80M", "VHT", "2T", "42", "30",
+	"MKK", "5G", "80M", "VHT", "2T", "42", "30",
+	"FCC", "5G", "80M", "VHT", "2T", "58", "26",
+	"ETSI", "5G", "80M", "VHT", "2T", "58", "30",
+	"MKK", "5G", "80M", "VHT", "2T", "58", "30",
+	"FCC", "5G", "80M", "VHT", "2T", "106", "28",
+	"ETSI", "5G", "80M", "VHT", "2T", "106", "30",
+	"MKK", "5G", "80M", "VHT", "2T", "106", "30",
+	"FCC", "5G", "80M", "VHT", "2T", "122", "32",
+	"ETSI", "5G", "80M", "VHT", "2T", "122", "30",
+	"MKK", "5G", "80M", "VHT", "2T", "122", "30",
+	"FCC", "5G", "80M", "VHT", "2T", "155", "34",
+	"ETSI", "5G", "80M", "VHT", "2T", "155", "30",
+	"MKK", "5G", "80M", "VHT", "2T", "155", "63"
+};
+
+uint32_t RTL8812AU_AGC_TAB_ARRAY[] = {
+	0xFF0F07D8, 0xABCD,
+		0x81C, 0xFF000001,
+		0x81C, 0xFF020001,
+		0x81C, 0xFF040001,
+		0x81C, 0xFE060001,
+		0x81C, 0xFD080001,
+		0x81C, 0xFC0A0001,
+		0x81C, 0xFB0C0001,
+		0x81C, 0xFA0E0001,
+		0x81C, 0xF9100001,
+		0x81C, 0xF8120001,
+		0x81C, 0xF7140001,
+		0x81C, 0xF6160001,
+		0x81C, 0xF5180001,
+		0x81C, 0xF41A0001,
+		0x81C, 0xF31C0001,
+		0x81C, 0xF21E0001,
+		0x81C, 0xF1200001,
+		0x81C, 0xF0220001,
+		0x81C, 0xEF240001,
+		0x81C, 0xEE260001,
+		0x81C, 0xED280001,
+		0x81C, 0xEC2A0001,
+		0x81C, 0xEB2C0001,
+		0x81C, 0xEA2E0001,
+		0x81C, 0xE9300001,
+		0x81C, 0xE8320001,
+		0x81C, 0xC7340001,
+		0x81C, 0xC6360001,
+		0x81C, 0xC5380001,
+		0x81C, 0xC43A0001,
+		0x81C, 0xC33C0001,
+		0x81C, 0xC23E0001,
+		0x81C, 0xC1400001,
+		0x81C, 0xA6420001,
+		0x81C, 0xA5440001,
+		0x81C, 0xA4460001,
+		0x81C, 0x69480001,
+		0x81C, 0x684A0001,
+		0x81C, 0x674C0001,
+		0x81C, 0x664E0001,
+		0x81C, 0x65500001,
+		0x81C, 0x64520001,
+		0x81C, 0x63540001,
+		0x81C, 0x62560001,
+		0x81C, 0x48580001,
+		0x81C, 0x475A0001,
+		0x81C, 0x465C0001,
+		0x81C, 0x455E0001,
+		0x81C, 0x44600001,
+		0x81C, 0x43620001,
+		0x81C, 0x42640001,
+		0x81C, 0x41660001,
+		0x81C, 0x41680001,
+		0x81C, 0x416A0001,
+		0x81C, 0x416C0001,
+		0x81C, 0x416E0001,
+		0x81C, 0x41700001,
+		0x81C, 0x41720001,
+		0x81C, 0x41740001,
+		0x81C, 0x41760001,
+		0x81C, 0x41780001,
+		0x81C, 0x417A0001,
+		0x81C, 0x417C0001,
+		0x81C, 0x417E0001,
+	0xCDCDCDCD, 0xCDCD,
+		0x81C, 0xFF000001,
+		0x81C, 0xFF020001,
+		0x81C, 0xFF040001,
+		0x81C, 0xFF060001,
+		0x81C, 0xFF080001,
+		0x81C, 0xFE0A0001,
+		0x81C, 0xFD0C0001,
+		0x81C, 0xFC0E0001,
+		0x81C, 0xFB100001,
+		0x81C, 0xFA120001,
+		0x81C, 0xF9140001,
+		0x81C, 0xF8160001,
+		0x81C, 0xF7180001,
+		0x81C, 0xF61A0001,
+		0x81C, 0xF51C0001,
+		0x81C, 0xF41E0001,
+		0x81C, 0xF3200001,
+		0x81C, 0xF2220001,
+		0x81C, 0xF1240001,
+		0x81C, 0xF0260001,
+		0x81C, 0xEF280001,
+		0x81C, 0xEE2A0001,
+		0x81C, 0xED2C0001,
+		0x81C, 0xEC2E0001,
+		0x81C, 0xEB300001,
+		0x81C, 0xEA320001,
+		0x81C, 0xE9340001,
+		0x81C, 0xE8360001,
+		0x81C, 0xE7380001,
+		0x81C, 0xE63A0001,
+		0x81C, 0xE53C0001,
+		0x81C, 0xC73E0001,
+		0x81C, 0xC6400001,
+		0x81C, 0xC5420001,
+		0x81C, 0xC4440001,
+		0x81C, 0xC3460001,
+		0x81C, 0xC2480001,
+		0x81C, 0xC14A0001,
+		0x81C, 0xA74C0001,
+		0x81C, 0xA64E0001,
+		0x81C, 0xA5500001,
+		0x81C, 0xA4520001,
+		0x81C, 0xA3540001,
+		0x81C, 0xA2560001,
+		0x81C, 0xA1580001,
+		0x81C, 0x675A0001,
+		0x81C, 0x665C0001,
+		0x81C, 0x655E0001,
+		0x81C, 0x64600001,
+		0x81C, 0x63620001,
+		0x81C, 0x48640001,
+		0x81C, 0x47660001,
+		0x81C, 0x46680001,
+		0x81C, 0x456A0001,
+		0x81C, 0x446C0001,
+		0x81C, 0x436E0001,
+		0x81C, 0x42700001,
+		0x81C, 0x41720001,
+		0x81C, 0x41740001,
+		0x81C, 0x41760001,
+		0x81C, 0x41780001,
+		0x81C, 0x417A0001,
+		0x81C, 0x417C0001,
+		0x81C, 0x417E0001,
+	0xFF0F07D8, 0xDEAD,
+	0xFF0F0780, 0xABCD,
+		0x81C, 0xFC800001,
+		0x81C, 0xFB820001,
+		0x81C, 0xFA840001,
+		0x81C, 0xF9860001,
+		0x81C, 0xF8880001,
+		0x81C, 0xF78A0001,
+		0x81C, 0xF68C0001,
+		0x81C, 0xF58E0001,
+		0x81C, 0xF4900001,
+		0x81C, 0xF3920001,
+		0x81C, 0xF2940001,
+		0x81C, 0xF1960001,
+		0x81C, 0xF0980001,
+		0x81C, 0xEF9A0001,
+		0x81C, 0xEE9C0001,
+		0x81C, 0xED9E0001,
+		0x81C, 0xECA00001,
+		0x81C, 0xEBA20001,
+		0x81C, 0xEAA40001,
+		0x81C, 0xE9A60001,
+		0x81C, 0xE8A80001,
+		0x81C, 0xE7AA0001,
+		0x81C, 0xE6AC0001,
+		0x81C, 0xE5AE0001,
+		0x81C, 0xE4B00001,
+		0x81C, 0xE3B20001,
+		0x81C, 0xA8B40001,
+		0x81C, 0xA7B60001,
+		0x81C, 0xA6B80001,
+		0x81C, 0xA5BA0001,
+		0x81C, 0xA4BC0001,
+		0x81C, 0xA3BE0001,
+		0x81C, 0xA2C00001,
+		0x81C, 0xA1C20001,
+		0x81C, 0x68C40001,
+		0x81C, 0x67C60001,
+		0x81C, 0x66C80001,
+		0x81C, 0x65CA0001,
+		0x81C, 0x64CC0001,
+		0x81C, 0x47CE0001,
+		0x81C, 0x46D00001,
+		0x81C, 0x45D20001,
+		0x81C, 0x44D40001,
+		0x81C, 0x43D60001,
+		0x81C, 0x42D80001,
+		0x81C, 0x08DA0001,
+		0x81C, 0x07DC0001,
+		0x81C, 0x06DE0001,
+		0x81C, 0x05E00001,
+		0x81C, 0x04E20001,
+		0x81C, 0x03E40001,
+		0x81C, 0x02E60001,
+		0x81C, 0x01E80001,
+		0x81C, 0x01EA0001,
+		0x81C, 0x01EC0001,
+		0x81C, 0x01EE0001,
+		0x81C, 0x01F00001,
+		0x81C, 0x01F20001,
+		0x81C, 0x01F40001,
+		0x81C, 0x01F60001,
+		0x81C, 0x01F80001,
+		0x81C, 0x01FA0001,
+		0x81C, 0x01FC0001,
+		0x81C, 0x01FE0001,
+	0xFF0F07C0, 0xCDEF,
+		0x81C, 0xFC800001,
+		0x81C, 0xFB820001,
+		0x81C, 0xFA840001,
+		0x81C, 0xF9860001,
+		0x81C, 0xF8880001,
+		0x81C, 0xF78A0001,
+		0x81C, 0xF68C0001,
+		0x81C, 0xF58E0001,
+		0x81C, 0xF4900001,
+		0x81C, 0xF3920001,
+		0x81C, 0xF2940001,
+		0x81C, 0xF1960001,
+		0x81C, 0xF0980001,
+		0x81C, 0xEF9A0001,
+		0x81C, 0xEE9C0001,
+		0x81C, 0xED9E0001,
+		0x81C, 0xECA00001,
+		0x81C, 0xEBA20001,
+		0x81C, 0xEAA40001,
+		0x81C, 0xE9A60001,
+		0x81C, 0xE8A80001,
+		0x81C, 0xE7AA0001,
+		0x81C, 0xE6AC0001,
+		0x81C, 0xE5AE0001,
+		0x81C, 0xE4B00001,
+		0x81C, 0xE3B20001,
+		0x81C, 0xA8B40001,
+		0x81C, 0xA7B60001,
+		0x81C, 0xA6B80001,
+		0x81C, 0xA5BA0001,
+		0x81C, 0xA4BC0001,
+		0x81C, 0xA3BE0001,
+		0x81C, 0xA2C00001,
+		0x81C, 0xA1C20001,
+		0x81C, 0x68C40001,
+		0x81C, 0x67C60001,
+		0x81C, 0x66C80001,
+		0x81C, 0x65CA0001,
+		0x81C, 0x64CC0001,
+		0x81C, 0x47CE0001,
+		0x81C, 0x46D00001,
+		0x81C, 0x45D20001,
+		0x81C, 0x44D40001,
+		0x81C, 0x43D60001,
+		0x81C, 0x42D80001,
+		0x81C, 0x08DA0001,
+		0x81C, 0x07DC0001,
+		0x81C, 0x06DE0001,
+		0x81C, 0x05E00001,
+		0x81C, 0x04E20001,
+		0x81C, 0x03E40001,
+		0x81C, 0x02E60001,
+		0x81C, 0x01E80001,
+		0x81C, 0x01EA0001,
+		0x81C, 0x01EC0001,
+		0x81C, 0x01EE0001,
+		0x81C, 0x01F00001,
+		0x81C, 0x01F20001,
+		0x81C, 0x01F40001,
+		0x81C, 0x01F60001,
+		0x81C, 0x01F80001,
+		0x81C, 0x01FA0001,
+		0x81C, 0x01FC0001,
+		0x81C, 0x01FE0001,
+	0xFF0F07D8, 0xCDEF,
+		0x81C, 0xFC800001,
+		0x81C, 0xFB820001,
+		0x81C, 0xFA840001,
+		0x81C, 0xF9860001,
+		0x81C, 0xF8880001,
+		0x81C, 0xF78A0001,
+		0x81C, 0xF68C0001,
+		0x81C, 0xF58E0001,
+		0x81C, 0xF4900001,
+		0x81C, 0xF3920001,
+		0x81C, 0xF2940001,
+		0x81C, 0xF1960001,
+		0x81C, 0xF0980001,
+		0x81C, 0xEF9A0001,
+		0x81C, 0xEE9C0001,
+		0x81C, 0xED9E0001,
+		0x81C, 0xECA00001,
+		0x81C, 0xEBA20001,
+		0x81C, 0xEAA40001,
+		0x81C, 0xE9A60001,
+		0x81C, 0xE8A80001,
+		0x81C, 0xE7AA0001,
+		0x81C, 0xE6AC0001,
+		0x81C, 0xE5AE0001,
+		0x81C, 0xE4B00001,
+		0x81C, 0xE3B20001,
+		0x81C, 0xA8B40001,
+		0x81C, 0xA7B60001,
+		0x81C, 0xA6B80001,
+		0x81C, 0xA5BA0001,
+		0x81C, 0xA4BC0001,
+		0x81C, 0xA3BE0001,
+		0x81C, 0xA2C00001,
+		0x81C, 0xA1C20001,
+		0x81C, 0x68C40001,
+		0x81C, 0x67C60001,
+		0x81C, 0x66C80001,
+		0x81C, 0x65CA0001,
+		0x81C, 0x64CC0001,
+		0x81C, 0x47CE0001,
+		0x81C, 0x46D00001,
+		0x81C, 0x45D20001,
+		0x81C, 0x44D40001,
+		0x81C, 0x43D60001,
+		0x81C, 0x42D80001,
+		0x81C, 0x08DA0001,
+		0x81C, 0x07DC0001,
+		0x81C, 0x06DE0001,
+		0x81C, 0x05E00001,
+		0x81C, 0x04E20001,
+		0x81C, 0x03E40001,
+		0x81C, 0x02E60001,
+		0x81C, 0x01E80001,
+		0x81C, 0x01EA0001,
+		0x81C, 0x01EC0001,
+		0x81C, 0x01EE0001,
+		0x81C, 0x01F00001,
+		0x81C, 0x01F20001,
+		0x81C, 0x01F40001,
+		0x81C, 0x01F60001,
+		0x81C, 0x01F80001,
+		0x81C, 0x01FA0001,
+		0x81C, 0x01FC0001,
+		0x81C, 0x01FE0001,
+	0xCDCDCDCD, 0xCDCD,
+		0x81C, 0xFF800001,
+		0x81C, 0xFF820001,
+		0x81C, 0xFF840001,
+		0x81C, 0xFE860001,
+		0x81C, 0xFD880001,
+		0x81C, 0xFC8A0001,
+		0x81C, 0xFB8C0001,
+		0x81C, 0xFA8E0001,
+		0x81C, 0xF9900001,
+		0x81C, 0xF8920001,
+		0x81C, 0xF7940001,
+		0x81C, 0xF6960001,
+		0x81C, 0xF5980001,
+		0x81C, 0xF49A0001,
+		0x81C, 0xF39C0001,
+		0x81C, 0xF29E0001,
+		0x81C, 0xF1A00001,
+		0x81C, 0xF0A20001,
+		0x81C, 0xEFA40001,
+		0x81C, 0xEEA60001,
+		0x81C, 0xEDA80001,
+		0x81C, 0xECAA0001,
+		0x81C, 0xEBAC0001,
+		0x81C, 0xEAAE0001,
+		0x81C, 0xE9B00001,
+		0x81C, 0xE8B20001,
+		0x81C, 0xE7B40001,
+		0x81C, 0xE6B60001,
+		0x81C, 0xE5B80001,
+		0x81C, 0xE4BA0001,
+		0x81C, 0xE3BC0001,
+		0x81C, 0xA8BE0001,
+		0x81C, 0xA7C00001,
+		0x81C, 0xA6C20001,
+		0x81C, 0xA5C40001,
+		0x81C, 0xA4C60001,
+		0x81C, 0xA3C80001,
+		0x81C, 0xA2CA0001,
+		0x81C, 0xA1CC0001,
+		0x81C, 0x68CE0001,
+		0x81C, 0x67D00001,
+		0x81C, 0x66D20001,
+		0x81C, 0x65D40001,
+		0x81C, 0x64D60001,
+		0x81C, 0x47D80001,
+		0x81C, 0x46DA0001,
+		0x81C, 0x45DC0001,
+		0x81C, 0x44DE0001,
+		0x81C, 0x43E00001,
+		0x81C, 0x42E20001,
+		0x81C, 0x08E40001,
+		0x81C, 0x07E60001,
+		0x81C, 0x06E80001,
+		0x81C, 0x05EA0001,
+		0x81C, 0x04EC0001,
+		0x81C, 0x03EE0001,
+		0x81C, 0x02F00001,
+		0x81C, 0x01F20001,
+		0x81C, 0x01F40001,
+		0x81C, 0x01F60001,
+		0x81C, 0x01F80001,
+		0x81C, 0x01FA0001,
+		0x81C, 0x01FC0001,
+		0x81C, 0x01FE0001,
+	0xFF0F0780, 0xDEAD,
+		0xC50, 0x00000022,
+		0xC50, 0x00000020,
+		0xE50, 0x00000022,
+		0xE50, 0x00000020,
+
+};
+
+uint32_t RTL8812AU_PHY_REG_ARRAY[] = {
+		0x800, 0x8020D010,
+		0x804, 0x080112E0,
+		0x808, 0x0E028233,
+		0x80C, 0x12131113,
+		0x810, 0x20101263,
+		0x814, 0x020C3D10,
+		0x818, 0x03A00385,
+		0x820, 0x00000000,
+		0x824, 0x00030FE0,
+		0x828, 0x00000000,
+		0x82C, 0x002083DD,
+		0x830, 0x2AAA6C86,
+		0x834, 0x0037A706,
+		0x838, 0x06C89B44,
+		0x83C, 0x0000095B,
+		0x840, 0xC0000001,
+		0x844, 0x40003CDE,
+		0x848, 0x6210FF8B,
+		0x84C, 0x6CFDFFB8,
+		0x850, 0x28874706,
+		0x854, 0x0001520C,
+		0x858, 0x8060E000,
+		0x85C, 0x74210168,
+		0x860, 0x6929C321,
+		0x864, 0x796A7432,
+		0x868, 0x8CA7A314,
+		0x86C, 0x338C2878,
+		0x870, 0x03333333,
+		0x874, 0x31602C2E,
+		0x878, 0x00003152,
+		0x87C, 0x000FC000,
+		0x8A0, 0x00000013,
+		0x8A4, 0x7F7F7F7F,
+		0x8A8, 0xA202033E,
+		0x8AC, 0x0FF0FA0A,
+		0x8B0, 0x00000600,
+		0x8B4, 0x000FC080,
+		0x8B8, 0x7C0057FF,
+		0x8BC, 0x4CA520A3,
+		0x8C0, 0x27F00020,
+		0x8C4, 0x00000000,
+		0x8C8, 0x00013169,
+		0x8CC, 0x08248492,
+		0x8D0, 0x0000B800,
+		0x8DC, 0x00000000,
+		0x8D4, 0x940008A0,
+		0x8D8, 0x290B1612,
+		0x8F8, 0x400002C0,
+		0x8FC, 0x00000000,
+	0xFF0F07D8, 0xABCD,
+		0x900, 0x00000701,
+	0xCDCDCDCD, 0xCDCD,
+		0x900, 0x00000700,
+	0xFF0F07D8, 0xDEAD,
+		0x90C, 0x00000000,
+		0x910, 0x0000FC00,
+		0x914, 0x00000404,
+		0x918, 0x1C1028C0,
+		0x91C, 0x64B11A1C,
+		0x920, 0xE0767233,
+		0x924, 0x055AA500,
+		0x928, 0x00000004,
+		0x92C, 0xFFFE0000,
+		0x930, 0xFFFFFFFE,
+		0x934, 0x001FFFFF,
+		0x960, 0x00000000,
+		0x964, 0x00000000,
+		0x968, 0x00000000,
+		0x96C, 0x00000000,
+		0x970, 0x801FFFFF,
+		0x978, 0x00000000,
+		0x97C, 0x00000000,
+		0x980, 0x00000000,
+		0x984, 0x00000000,
+		0x988, 0x00000000,
+		0x9A4, 0x00080080,
+		0x9A8, 0x00000000,
+		0x9AC, 0x00000000,
+		0x9B0, 0x01081008,
+		0x9B4, 0x00000000,
+		0x9B8, 0x01081008,
+		0x9BC, 0x01081008,
+		0x9D0, 0x00000000,
+		0x9D4, 0x00000000,
+		0x9D8, 0x00000000,
+		0x9DC, 0x00000000,
+		0x9E4, 0x00000002,
+		0x9E8, 0x000002D4,
+		0xA00, 0x00D047C8,
+		0xA04, 0x01FF000C,
+		0xA08, 0x8C8A8300,
+		0xA0C, 0x2E7F000F,
+		0xA10, 0x9500BB78,
+		0xA14, 0x11144028,
+		0xA18, 0x00881117,
+		0xA1C, 0x89140F00,
+		0xA20, 0x1A1B0000,
+		0xA24, 0x090E1317,
+		0xA28, 0x00000204,
+		0xA2C, 0x00900000,
+		0xA70, 0x101FFF00,
+		0xA74, 0x00000008,
+		0xA78, 0x00000900,
+		0xA7C, 0x225B0606,
+		0xA80, 0x218075B2,
+		0xA84, 0x001F8C80,
+		0xB00, 0x03100000,
+		0xB04, 0x0000B000,
+		0xB08, 0xAE0201EB,
+		0xB0C, 0x01003207,
+		0xB10, 0x00009807,
+		0xB14, 0x01000000,
+		0xB18, 0x00000002,
+		0xB1C, 0x00000002,
+		0xB20, 0x0000001F,
+		0xB24, 0x03020100,
+		0xB28, 0x07060504,
+		0xB2C, 0x0B0A0908,
+		0xB30, 0x0F0E0D0C,
+		0xB34, 0x13121110,
+		0xB38, 0x17161514,
+		0xB3C, 0x0000003A,
+		0xB40, 0x00000000,
+		0xB44, 0x00000000,
+		0xB48, 0x13000032,
+		0xB4C, 0x48080000,
+		0xB50, 0x00000000,
+		0xB54, 0x00000000,
+		0xB58, 0x00000000,
+		0xB5C, 0x00000000,
+		0xC00, 0x00000007,
+		0xC04, 0x00042020,
+		0xC08, 0x80410231,
+		0xC0C, 0x00000000,
+		0xC10, 0x00000100,
+		0xC14, 0x01000000,
+		0xC1C, 0x40000003,
+		0xC20, 0x12121212,
+		0xC24, 0x12121212,
+		0xC28, 0x12121212,
+		0xC2C, 0x12121212,
+		0xC30, 0x12121212,
+		0xC34, 0x12121212,
+		0xC38, 0x12121212,
+		0xC3C, 0x12121212,
+		0xC40, 0x12121212,
+		0xC44, 0x12121212,
+		0xC48, 0x12121212,
+		0xC4C, 0x12121212,
+		0xC50, 0x00000020,
+		0xC54, 0x0008121C,
+		0xC58, 0x30000C1C,
+		0xC5C, 0x00000058,
+		0xC60, 0x34344443,
+		0xC64, 0x07003333,
+		0xC68, 0x59791979,
+		0xC6C, 0x59795979,
+		0xC70, 0x19795979,
+		0xC74, 0x19795979,
+		0xC78, 0x19791979,
+		0xC7C, 0x19791979,
+		0xC80, 0x19791979,
+		0xC84, 0x19791979,
+		0xC94, 0x0100005C,
+		0xC98, 0x00000000,
+		0xC9C, 0x00000000,
+		0xCA0, 0x00000029,
+		0xCA4, 0x08040201,
+		0xCA8, 0x80402010,
+	0xFF0F0740, 0xABCD,
+		0xCB0, 0x77547717,
+	0xFF0F07C0, 0xCDEF,
+		0xCB0, 0x77547717,
+	0xFF0F07D8, 0xCDEF,
+		0xCB0, 0x54547710,
+	0xCDCDCDCD, 0xCDCD,
+		0xCB0, 0x77547777,
+	0xFF0F0740, 0xDEAD,
+		0xCB4, 0x00000077,
+		0xCB8, 0x00508242,
+		0xE00, 0x00000007,
+		0xE04, 0x00042020,
+		0xE08, 0x80410231,
+		0xE0C, 0x00000000,
+		0xE10, 0x00000100,
+		0xE14, 0x01000000,
+		0xE1C, 0x40000003,
+		0xE20, 0x12121212,
+		0xE24, 0x12121212,
+		0xE28, 0x12121212,
+		0xE2C, 0x12121212,
+		0xE30, 0x12121212,
+		0xE34, 0x12121212,
+		0xE38, 0x12121212,
+		0xE3C, 0x12121212,
+		0xE40, 0x12121212,
+		0xE44, 0x12121212,
+		0xE48, 0x12121212,
+		0xE4C, 0x12121212,
+		0xE50, 0x00000020,
+		0xE54, 0x0008121C,
+		0xE58, 0x30000C1C,
+		0xE5C, 0x00000058,
+		0xE60, 0x34344443,
+		0xE64, 0x07003333,
+		0xE68, 0x59791979,
+		0xE6C, 0x59795979,
+		0xE70, 0x19795979,
+		0xE74, 0x19795979,
+		0xE78, 0x19791979,
+		0xE7C, 0x19791979,
+		0xE80, 0x19791979,
+		0xE84, 0x19791979,
+		0xE94, 0x0100005C,
+		0xE98, 0x00000000,
+		0xE9C, 0x00000000,
+		0xEA0, 0x00000029,
+		0xEA4, 0x08040201,
+		0xEA8, 0x80402010,
+	0xFF0F0740, 0xABCD,
+		0xEB0, 0x77547717,
+	0xFF0F07C0, 0xCDEF,
+		0xEB0, 0x77547717,
+	0xFF0F07D8, 0xCDEF,
+		0xEB0, 0x54547710,
+	0xCDCDCDCD, 0xCDCD,
+		0xEB0, 0x77547777,
+	0xFF0F0740, 0xDEAD,
+		0xEB4, 0x00000077,
+		0xEB8, 0x00508242,
+
+};
+
+uint32_t RTL8812AU_PHY_REG_PG_ARRAY[] = {
+	0, 0, 0, 0x00000c20, 0xffffffff, 0x34363840,
+	0, 0, 0, 0x00000c24, 0xffffffff, 0x42424444,
+	0, 0, 0, 0x00000c28, 0xffffffff, 0x30323638,
+	0, 0, 0, 0x00000c2c, 0xffffffff, 0x40424444,
+	0, 0, 0, 0x00000c30, 0xffffffff, 0x28303236,
+	0, 0, 1, 0x00000c34, 0xffffffff, 0x38404242,
+	0, 0, 1, 0x00000c38, 0xffffffff, 0x26283034,
+	0, 0, 0, 0x00000c3c, 0xffffffff, 0x40424444,
+	0, 0, 0, 0x00000c40, 0xffffffff, 0x28303236,
+	0, 0, 0, 0x00000c44, 0xffffffff, 0x42422426,
+	0, 0, 1, 0x00000c48, 0xffffffff, 0x30343840,
+	0, 0, 1, 0x00000c4c, 0xffffffff, 0x22242628,
+	0, 1, 0, 0x00000e20, 0xffffffff, 0x34363840,
+	0, 1, 0, 0x00000e24, 0xffffffff, 0x42424444,
+	0, 1, 0, 0x00000e28, 0xffffffff, 0x30323638,
+	0, 1, 0, 0x00000e2c, 0xffffffff, 0x40424444,
+	0, 1, 0, 0x00000e30, 0xffffffff, 0x28303236,
+	0, 1, 1, 0x00000e34, 0xffffffff, 0x38404242,
+	0, 1, 1, 0x00000e38, 0xffffffff, 0x26283034,
+	0, 1, 0, 0x00000e3c, 0xffffffff, 0x40424444,
+	0, 1, 0, 0x00000e40, 0xffffffff, 0x28303236,
+	0, 1, 0, 0x00000e44, 0xffffffff, 0x42422426,
+	0, 1, 1, 0x00000e48, 0xffffffff, 0x30343840,
+	0, 1, 1, 0x00000e4c, 0xffffffff, 0x22242628,
+	1, 0, 0, 0x00000c24, 0xffffffff, 0x42424444,
+	1, 0, 0, 0x00000c28, 0xffffffff, 0x30323640,
+	1, 0, 0, 0x00000c2c, 0xffffffff, 0x40424444,
+	1, 0, 0, 0x00000c30, 0xffffffff, 0x28303236,
+	1, 0, 1, 0x00000c34, 0xffffffff, 0x38404242,
+	1, 0, 1, 0x00000c38, 0xffffffff, 0x26283034,
+	1, 0, 0, 0x00000c3c, 0xffffffff, 0x40424444,
+	1, 0, 0, 0x00000c40, 0xffffffff, 0x28303236,
+	1, 0, 0, 0x00000c44, 0xffffffff, 0x42422426,
+	1, 0, 1, 0x00000c48, 0xffffffff, 0x30343840,
+	1, 0, 1, 0x00000c4c, 0xffffffff, 0x22242628,
+	1, 1, 0, 0x00000e24, 0xffffffff, 0x42424444,
+	1, 1, 0, 0x00000e28, 0xffffffff, 0x30323640,
+	1, 1, 0, 0x00000e2c, 0xffffffff, 0x40424444,
+	1, 1, 0, 0x00000e30, 0xffffffff, 0x28303236,
+	1, 1, 1, 0x00000e34, 0xffffffff, 0x38404242,
+	1, 1, 1, 0x00000e38, 0xffffffff, 0x26283034,
+	1, 1, 0, 0x00000e3c, 0xffffffff, 0x40424444,
+	1, 1, 0, 0x00000e40, 0xffffffff, 0x28303236,
+	1, 1, 0, 0x00000e44, 0xffffffff, 0x42422426,
+	1, 1, 1, 0x00000e48, 0xffffffff, 0x30343840,
+	1, 1, 1, 0x00000e4c, 0xffffffff, 0x22242628
+};
+
+uint32_t RTL8812AU_PHY_REG_PG_ASUS_ARRAY[] = {
+	0, 0, 0, 0x00000c20, 0xffffffff, 0x34343434,
+	0, 0, 0, 0x00000c24, 0xffffffff, 0x32323232,
+	0, 0, 0, 0x00000c28, 0xffffffff, 0x28303232,
+	0, 0, 0, 0x00000c2c, 0xffffffff, 0x32323232,
+	0, 0, 0, 0x00000c30, 0xffffffff, 0x28303232,
+	0, 0, 1, 0x00000c34, 0xffffffff, 0x32323232,
+	0, 0, 1, 0x00000c38, 0xffffffff, 0x26283032,
+	0, 0, 0, 0x00000c3c, 0xffffffff, 0x32323232,
+	0, 0, 0, 0x00000c40, 0xffffffff, 0x28303232,
+	0, 0, 0, 0x00000c44, 0xffffffff, 0x32322426,
+	0, 0, 1, 0x00000c48, 0xffffffff, 0x32323232,
+	0, 0, 1, 0x00000c4c, 0xffffffff, 0x24262830,
+	0, 1, 0, 0x00000e20, 0xffffffff, 0x34343434,
+	0, 1, 0, 0x00000e24, 0xffffffff, 0x32323232,
+	0, 1, 0, 0x00000e28, 0xffffffff, 0x28303232,
+	0, 1, 0, 0x00000e2c, 0xffffffff, 0x32323232,
+	0, 1, 0, 0x00000e30, 0xffffffff, 0x28303232,
+	0, 1, 1, 0x00000e34, 0xffffffff, 0x32323232,
+	0, 1, 1, 0x00000e38, 0xffffffff, 0x26283032,
+	0, 1, 0, 0x00000e3c, 0xffffffff, 0x32323232,
+	0, 1, 0, 0x00000e40, 0xffffffff, 0x28303232,
+	0, 1, 0, 0x00000e44, 0xffffffff, 0x32322426,
+	0, 1, 1, 0x00000e48, 0xffffffff, 0x32323232,
+	0, 1, 1, 0x00000e4c, 0xffffffff, 0x24262830,
+	1, 0, 0, 0x00000c24, 0xffffffff, 0x32323232,
+	1, 0, 0, 0x00000c28, 0xffffffff, 0x28303232,
+	1, 0, 0, 0x00000c2c, 0xffffffff, 0x32323232,
+	1, 0, 0, 0x00000c30, 0xffffffff, 0x24262830,
+	1, 0, 1, 0x00000c34, 0xffffffff, 0x32323232,
+	1, 0, 1, 0x00000c38, 0xffffffff, 0x24262830,
+	1, 0, 0, 0x00000c3c, 0xffffffff, 0x32323232,
+	1, 0, 0, 0x00000c40, 0xffffffff, 0x24262830,
+	1, 0, 0, 0x00000c44, 0xffffffff, 0x32322222,
+	1, 0, 1, 0x00000c48, 0xffffffff, 0x28303232,
+	1, 0, 1, 0x00000c4c, 0xffffffff, 0x22222426,
+	1, 1, 0, 0x00000e24, 0xffffffff, 0x32323232,
+	1, 1, 0, 0x00000e28, 0xffffffff, 0x28303232,
+	1, 1, 0, 0x00000e2c, 0xffffffff, 0x32323232,
+	1, 1, 0, 0x00000e30, 0xffffffff, 0x24262830,
+	1, 1, 1, 0x00000e34, 0xffffffff, 0x32323232,
+	1, 1, 1, 0x00000e38, 0xffffffff, 0x24262830,
+	1, 1, 0, 0x00000e3c, 0xffffffff, 0x32323232,
+	1, 1, 0, 0x00000e40, 0xffffffff, 0x24262830,
+	1, 1, 0, 0x00000e44, 0xffffffff, 0x32322222,
+	1, 1, 1, 0x00000e48, 0xffffffff, 0x28303232,
+	1, 1, 1, 0x00000e4c, 0xffffffff, 0x22222426
+};
+
+uint32_t RTL8812AU_PHY_REG_PG_NEC_ARRAY[]=  {
+	0, 0, 0, 0x00000c20, 0xffffffff, 0x32323232,
+	0, 0, 0, 0x00000c24, 0xffffffff, 0x32343434,
+	0, 0, 0, 0x00000c28, 0xffffffff, 0x24262830,
+	0, 0, 0, 0x00000c2c, 0xffffffff, 0x32343434,
+	0, 0, 0, 0x00000c30, 0xffffffff, 0x24262830,
+	0, 0, 1, 0x00000c34, 0xffffffff, 0x32343434,
+	0, 0, 1, 0x00000c38, 0xffffffff, 0x24262830,
+	0, 0, 0, 0x00000c3c, 0xffffffff, 0x32343434,
+	0, 0, 0, 0x00000c40, 0xffffffff, 0x24262830,
+	0, 0, 0, 0x00000c44, 0xffffffff, 0x34342022,
+	0, 0, 1, 0x00000c48, 0xffffffff, 0x28303234,
+	0, 0, 1, 0x00000c4c, 0xffffffff, 0x20222426,
+	0, 1, 0, 0x00000e20, 0xffffffff, 0x32323232,
+	0, 1, 0, 0x00000e24, 0xffffffff, 0x32343434,
+	0, 1, 0, 0x00000e28, 0xffffffff, 0x24262830,
+	0, 1, 0, 0x00000e2c, 0xffffffff, 0x32343434,
+	0, 1, 0, 0x00000e30, 0xffffffff, 0x24262830,
+	0, 1, 1, 0x00000e34, 0xffffffff, 0x32343434,
+	0, 1, 1, 0x00000e38, 0xffffffff, 0x24262830,
+	0, 1, 0, 0x00000e3c, 0xffffffff, 0x32343434,
+	0, 1, 0, 0x00000e40, 0xffffffff, 0x24262830,
+	0, 1, 0, 0x00000e44, 0xffffffff, 0x34342022,
+	0, 1, 1, 0x00000e48, 0xffffffff, 0x28303234,
+	0, 1, 1, 0x00000e4c, 0xffffffff, 0x20222426,
+	1, 0, 0, 0x00000c24, 0xffffffff, 0x32343434,
+	1, 0, 0, 0x00000c28, 0xffffffff, 0x24262830,
+	1, 0, 0, 0x00000c2c, 0xffffffff, 0x32343434,
+	1, 0, 0, 0x00000c30, 0xffffffff, 0x24262830,
+	1, 0, 1, 0x00000c34, 0xffffffff, 0x28282828,
+	1, 0, 1, 0x00000c38, 0xffffffff, 0x24262828,
+	1, 0, 0, 0x00000c3c, 0xffffffff, 0x32343434,
+	1, 0, 0, 0x00000c40, 0xffffffff, 0x24262830,
+	1, 0, 0, 0x00000c44, 0xffffffff, 0x28282022,
+	1, 0, 1, 0x00000c48, 0xffffffff, 0x28282828,
+	1, 0, 1, 0x00000c4c, 0xffffffff, 0x20222426,
+	1, 1, 0, 0x00000e24, 0xffffffff, 0x32343434,
+	1, 1, 0, 0x00000e28, 0xffffffff, 0x24262830,
+	1, 1, 0, 0x00000e2c, 0xffffffff, 0x32343434,
+	1, 1, 0, 0x00000e30, 0xffffffff, 0x24262830,
+	1, 1, 1, 0x00000e34, 0xffffffff, 0x28282828,
+	1, 1, 1, 0x00000e38, 0xffffffff, 0x24262828,
+	1, 1, 0, 0x00000e3c, 0xffffffff, 0x32343434,
+	1, 1, 0, 0x00000e40, 0xffffffff, 0x24262830,
+	1, 1, 0, 0x00000e44, 0xffffffff, 0x28282022,
+	1, 1, 1, 0x00000e48, 0xffffffff, 0x28282828,
+	1, 1, 1, 0x00000e4c, 0xffffffff, 0x20222426
+};
+
+uint32_t RTL8821AU_AGC_TAB_ARRAY[] = {
+		0x81C, 0xBF000001,
+		0x81C, 0xBF020001,
+		0x81C, 0xBF040001,
+		0x81C, 0xBF060001,
+		0x81C, 0xBE080001,
+		0x81C, 0xBD0A0001,
+		0x81C, 0xBC0C0001,
+		0x81C, 0xBA0E0001,
+		0x81C, 0xB9100001,
+		0x81C, 0xB8120001,
+		0x81C, 0xB7140001,
+		0x81C, 0xB6160001,
+		0x81C, 0xB5180001,
+		0x81C, 0xB41A0001,
+		0x81C, 0xB31C0001,
+		0x81C, 0xB21E0001,
+		0x81C, 0xB1200001,
+		0x81C, 0xB0220001,
+		0x81C, 0xAF240001,
+		0x81C, 0xAE260001,
+		0x81C, 0xAD280001,
+		0x81C, 0xAC2A0001,
+		0x81C, 0xAB2C0001,
+		0x81C, 0xAA2E0001,
+		0x81C, 0xA9300001,
+		0x81C, 0xA8320001,
+		0x81C, 0xA7340001,
+		0x81C, 0xA6360001,
+		0x81C, 0xA5380001,
+		0x81C, 0xA43A0001,
+		0x81C, 0xA33C0001,
+		0x81C, 0x673E0001,
+		0x81C, 0x66400001,
+		0x81C, 0x65420001,
+		0x81C, 0x64440001,
+		0x81C, 0x63460001,
+		0x81C, 0x62480001,
+		0x81C, 0x614A0001,
+		0x81C, 0x474C0001,
+		0x81C, 0x464E0001,
+		0x81C, 0x45500001,
+		0x81C, 0x44520001,
+		0x81C, 0x43540001,
+		0x81C, 0x42560001,
+		0x81C, 0x41580001,
+		0x81C, 0x285A0001,
+		0x81C, 0x275C0001,
+		0x81C, 0x265E0001,
+		0x81C, 0x25600001,
+		0x81C, 0x24620001,
+		0x81C, 0x0A640001,
+		0x81C, 0x09660001,
+		0x81C, 0x08680001,
+		0x81C, 0x076A0001,
+		0x81C, 0x066C0001,
+		0x81C, 0x056E0001,
+		0x81C, 0x04700001,
+		0x81C, 0x03720001,
+		0x81C, 0x02740001,
+		0x81C, 0x01760001,
+		0x81C, 0x01780001,
+		0x81C, 0x017A0001,
+		0x81C, 0x017C0001,
+		0x81C, 0x017E0001,
+	0xFF0F02C0, 0xABCD,
+		0x81C, 0xFB000101,
+		0x81C, 0xFA020101,
+		0x81C, 0xF9040101,
+		0x81C, 0xF8060101,
+		0x81C, 0xF7080101,
+		0x81C, 0xF60A0101,
+		0x81C, 0xF50C0101,
+		0x81C, 0xF40E0101,
+		0x81C, 0xF3100101,
+		0x81C, 0xF2120101,
+		0x81C, 0xF1140101,
+		0x81C, 0xF0160101,
+		0x81C, 0xEF180101,
+		0x81C, 0xEE1A0101,
+		0x81C, 0xED1C0101,
+		0x81C, 0xEC1E0101,
+		0x81C, 0xEB200101,
+		0x81C, 0xEA220101,
+		0x81C, 0xE9240101,
+		0x81C, 0xE8260101,
+		0x81C, 0xE7280101,
+		0x81C, 0xE62A0101,
+		0x81C, 0xE52C0101,
+		0x81C, 0xE42E0101,
+		0x81C, 0xE3300101,
+		0x81C, 0xA5320101,
+		0x81C, 0xA4340101,
+		0x81C, 0xA3360101,
+		0x81C, 0x87380101,
+		0x81C, 0x863A0101,
+		0x81C, 0x853C0101,
+		0x81C, 0x843E0101,
+		0x81C, 0x69400101,
+		0x81C, 0x68420101,
+		0x81C, 0x67440101,
+		0x81C, 0x66460101,
+		0x81C, 0x49480101,
+		0x81C, 0x484A0101,
+		0x81C, 0x474C0101,
+		0x81C, 0x2A4E0101,
+		0x81C, 0x29500101,
+		0x81C, 0x28520101,
+		0x81C, 0x27540101,
+		0x81C, 0x26560101,
+		0x81C, 0x25580101,
+		0x81C, 0x245A0101,
+		0x81C, 0x235C0101,
+		0x81C, 0x055E0101,
+		0x81C, 0x04600101,
+		0x81C, 0x03620101,
+		0x81C, 0x02640101,
+		0x81C, 0x01660101,
+		0x81C, 0x01680101,
+		0x81C, 0x016A0101,
+		0x81C, 0x016C0101,
+		0x81C, 0x016E0101,
+		0x81C, 0x01700101,
+		0x81C, 0x01720101,
+	0xCDCDCDCD, 0xCDCD,
+		0x81C, 0xFF000101,
+		0x81C, 0xFF020101,
+		0x81C, 0xFE040101,
+		0x81C, 0xFD060101,
+		0x81C, 0xFC080101,
+		0x81C, 0xFD0A0101,
+		0x81C, 0xFC0C0101,
+		0x81C, 0xFB0E0101,
+		0x81C, 0xFA100101,
+		0x81C, 0xF9120101,
+		0x81C, 0xF8140101,
+		0x81C, 0xF7160101,
+		0x81C, 0xF6180101,
+		0x81C, 0xF51A0101,
+		0x81C, 0xF41C0101,
+		0x81C, 0xF31E0101,
+		0x81C, 0xF2200101,
+		0x81C, 0xF1220101,
+		0x81C, 0xF0240101,
+		0x81C, 0xEF260101,
+		0x81C, 0xEE280101,
+		0x81C, 0xED2A0101,
+		0x81C, 0xEC2C0101,
+		0x81C, 0xEB2E0101,
+		0x81C, 0xEA300101,
+		0x81C, 0xE9320101,
+		0x81C, 0xE8340101,
+		0x81C, 0xE7360101,
+		0x81C, 0xE6380101,
+		0x81C, 0xE53A0101,
+		0x81C, 0xE43C0101,
+		0x81C, 0xE33E0101,
+		0x81C, 0xA5400101,
+		0x81C, 0xA4420101,
+		0x81C, 0xA3440101,
+		0x81C, 0x87460101,
+		0x81C, 0x86480101,
+		0x81C, 0x854A0101,
+		0x81C, 0x844C0101,
+		0x81C, 0x694E0101,
+		0x81C, 0x68500101,
+		0x81C, 0x67520101,
+		0x81C, 0x66540101,
+		0x81C, 0x49560101,
+		0x81C, 0x48580101,
+		0x81C, 0x475A0101,
+		0x81C, 0x2A5C0101,
+		0x81C, 0x295E0101,
+		0x81C, 0x28600101,
+		0x81C, 0x27620101,
+		0x81C, 0x26640101,
+		0x81C, 0x25660101,
+		0x81C, 0x24680101,
+		0x81C, 0x236A0101,
+		0x81C, 0x056C0101,
+		0x81C, 0x046E0101,
+		0x81C, 0x03700101,
+		0x81C, 0x02720101,
+	0xFF0F02C0, 0xDEAD,
+		0x81C, 0x01740101,
+		0x81C, 0x01760101,
+		0x81C, 0x01780101,
+		0x81C, 0x017A0101,
+		0x81C, 0x017C0101,
+		0x81C, 0x017E0101,
+		0xC50, 0x00000022,
+		0xC50, 0x00000020,
+
+};
+
+uint32_t RTL8821AU_PHY_REG_ARRAY[] = {
+		0x800, 0x0020D090,
+		0x804, 0x080112E0,
+		0x808, 0x0E028211,
+		0x80C, 0x92131111,
+		0x810, 0x20101261,
+		0x814, 0x020C3D10,
+		0x818, 0x03A00385,
+		0x820, 0x00000000,
+		0x824, 0x00030FE0,
+		0x828, 0x00000000,
+		0x82C, 0x002081DD,
+		0x830, 0x2AAA8E24,
+		0x834, 0x0037A706,
+		0x838, 0x06489B44,
+		0x83C, 0x0000095B,
+		0x840, 0xC0000001,
+		0x844, 0x40003CDE,
+		0x848, 0x62103F8B,
+		0x84C, 0x6CFDFFB8,
+		0x850, 0x28874706,
+		0x854, 0x0001520C,
+		0x858, 0x8060E000,
+		0x85C, 0x74210168,
+		0x860, 0x6929C321,
+		0x864, 0x79727432,
+		0x868, 0x8CA7A314,
+		0x86C, 0x888C2878,
+		0x870, 0x08888888,
+		0x874, 0x31612C2E,
+		0x878, 0x00000152,
+		0x87C, 0x000FD000,
+		0x8A0, 0x00000013,
+		0x8A4, 0x7F7F7F7F,
+		0x8A8, 0xA2000338,
+		0x8AC, 0x0FF0FA0A,
+		0x8B4, 0x000FC080,
+		0x8B8, 0x7C0057FF,
+		0x8BC, 0x0CA52090,
+		0x8C0, 0x1BF00020,
+		0x8C4, 0x00000000,
+		0x8C8, 0x00013169,
+		0x8CC, 0x08248492,
+		0x8D4, 0x940008A0,
+		0x8D8, 0x290B5612,
+		0x8F8, 0x400002C0,
+		0x8FC, 0x00000000,
+		0x900, 0x00000700,
+		0x90C, 0x00000000,
+		0x910, 0x0000FC00,
+		0x914, 0x00000404,
+		0x918, 0x1C1028C0,
+		0x91C, 0x64B11A1C,
+		0x920, 0xE0767233,
+		0x924, 0x055AA500,
+		0x928, 0x00000004,
+		0x92C, 0xFFFE0000,
+		0x930, 0xFFFFFFFE,
+		0x934, 0x001FFFFF,
+		0x960, 0x00000000,
+		0x964, 0x00000000,
+		0x968, 0x00000000,
+		0x96C, 0x00000000,
+		0x970, 0x801FFFFF,
+		0x974, 0x000003FF,
+		0x978, 0x00000000,
+		0x97C, 0x00000000,
+		0x980, 0x00000000,
+		0x984, 0x00000000,
+		0x988, 0x00000000,
+		0x9A4, 0x00480080,
+		0x9A8, 0x00000000,
+		0x9AC, 0x00000000,
+		0x9B0, 0x81081008,
+		0x9B4, 0x01081008,
+		0x9B8, 0x01081008,
+		0x9BC, 0x01081008,
+		0x9D0, 0x00000000,
+		0x9D4, 0x00000000,
+		0x9D8, 0x00000000,
+		0x9DC, 0x00000000,
+		0x9E0, 0x00005D00,
+		0x9E4, 0x00000002,
+		0x9E8, 0x00000000,
+		0xA00, 0x00D047C8,
+		0xA04, 0x01FF000C,
+		0xA08, 0x8C8A8300,
+		0xA0C, 0x2E68000F,
+		0xA10, 0x9500BB78,
+		0xA14, 0x11144028,
+		0xA18, 0x00881117,
+		0xA1C, 0x89140F00,
+		0xA20, 0x1A1B0000,
+		0xA24, 0x090E1317,
+		0xA28, 0x00000204,
+		0xA2C, 0x00900000,
+		0xA70, 0x101FFF00,
+		0xA74, 0x00000008,
+		0xA78, 0x00000900,
+		0xA7C, 0x225B0606,
+		0xA80, 0x21805490,
+		0xA84, 0x001F0000,
+		0xB00, 0x03100040,
+		0xB04, 0x0000B000,
+		0xB08, 0xAE0201EB,
+		0xB0C, 0x01003207,
+		0xB10, 0x00009807,
+		0xB14, 0x01000000,
+		0xB18, 0x00000002,
+		0xB1C, 0x00000002,
+		0xB20, 0x0000001F,
+		0xB24, 0x03020100,
+		0xB28, 0x07060504,
+		0xB2C, 0x0B0A0908,
+		0xB30, 0x0F0E0D0C,
+		0xB34, 0x13121110,
+		0xB38, 0x17161514,
+		0xB3C, 0x0000003A,
+		0xB40, 0x00000000,
+		0xB44, 0x00000000,
+		0xB48, 0x13000032,
+		0xB4C, 0x48080000,
+		0xB50, 0x00000000,
+		0xB54, 0x00000000,
+		0xB58, 0x00000000,
+		0xB5C, 0x00000000,
+		0xC00, 0x00000007,
+		0xC04, 0x00042020,
+		0xC08, 0x80410231,
+		0xC0C, 0x00000000,
+		0xC10, 0x00000100,
+		0xC14, 0x01000000,
+		0xC1C, 0x40000003,
+		0xC20, 0x2C2C2C2C,
+		0xC24, 0x30303030,
+		0xC28, 0x30303030,
+		0xC2C, 0x2C2C2C2C,
+		0xC30, 0x2C2C2C2C,
+		0xC34, 0x2C2C2C2C,
+		0xC38, 0x2C2C2C2C,
+		0xC3C, 0x2A2A2A2A,
+		0xC40, 0x2A2A2A2A,
+		0xC44, 0x2A2A2A2A,
+		0xC48, 0x2A2A2A2A,
+		0xC4C, 0x2A2A2A2A,
+		0xC50, 0x00000020,
+		0xC54, 0x001C1208,
+		0xC58, 0x30000C1C,
+		0xC5C, 0x00000058,
+		0xC60, 0x34344443,
+		0xC64, 0x07003333,
+		0xC68, 0x19791979,
+		0xC6C, 0x19791979,
+		0xC70, 0x19791979,
+		0xC74, 0x19791979,
+		0xC78, 0x19791979,
+		0xC7C, 0x19791979,
+		0xC80, 0x19791979,
+		0xC84, 0x19791979,
+		0xC94, 0x0100005C,
+		0xC98, 0x00000000,
+		0xC9C, 0x00000000,
+		0xCA0, 0x00000029,
+		0xCA4, 0x08040201,
+		0xCA8, 0x80402010,
+		0xCB0, 0x77775747,
+		0xCB4, 0x10000077,
+		0xCB8, 0x00508240,
+
+};
+
+uint32_t RTL8821AU_PHY_REG_PG_ARRAY[] = {
+	0, 0, 0, 0x00000c20, 0xffffffff, 0x32343638,
+	0, 0, 0, 0x00000c24, 0xffffffff, 0x36363838,
+	0, 0, 0, 0x00000c28, 0xffffffff, 0x28303234,
+	0, 0, 0, 0x00000c2c, 0xffffffff, 0x34363838,
+	0, 0, 0, 0x00000c30, 0xffffffff, 0x26283032,
+	0, 0, 0, 0x00000c3c, 0xffffffff, 0x32343636,
+	0, 0, 0, 0x00000c40, 0xffffffff, 0x24262830,
+	0, 0, 0, 0x00000c44, 0x0000ffff, 0x00002022,
+	1, 0, 0, 0x00000c24, 0xffffffff, 0x34343636,
+	1, 0, 0, 0x00000c28, 0xffffffff, 0x26283032,
+	1, 0, 0, 0x00000c2c, 0xffffffff, 0x32343636,
+	1, 0, 0, 0x00000c30, 0xffffffff, 0x24262830,
+	1, 0, 0, 0x00000c3c, 0xffffffff, 0x32343636,
+	1, 0, 0, 0x00000c40, 0xffffffff, 0x24262830,
+	1, 0, 0, 0x00000c44, 0x0000ffff, 0x00002022
+};
diff -Naur linux-4.9/drivers/staging/rtl8821au/rtl8821au/table.h linux-4.9.8821au/drivers/staging/rtl8821au/rtl8821au/table.h
--- linux-4.9/drivers/staging/rtl8821au/rtl8821au/table.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/rtl8821au/table.h	2016-12-11 19:48:25.186978326 -0600
@@ -0,0 +1,44 @@
+#ifndef __RTL8821AU_TABLE__H_
+#define __RTL8821AU_TABLE__H_
+
+#include <linux/types.h>
+
+#define RTL8812AU_RADIOA_1TARRAYLEN		930
+extern u32 RTL8812AU_RADIOA_ARRAY[];
+#define RTL8812AU_RADIOB_1TARRAYLEN		902
+extern u32 RTL8812AU_RADIOB_ARRAY[];
+
+#define RTL8821AU_RADIOA_1TARRAYLEN		1198
+extern u32 RTL8821AU_RADIOA_ARRAY[];
+
+#define RTL8812AUMAC_1T_ARRAYLEN		198
+extern u32 RTL8812AU_MAC_REG_ARRAY[];
+#define RTL8821AUMAC_1T_ARRAYLEN		192
+extern u32 RTL8821AU_MAC_REG_ARRAY[];
+
+
+#define RTL8812AU_TXPWR_LMT_ARRAY_LEN		3948
+extern u8 *RTL8812AU_TXPWR_LMT[];
+#define RTL8821AU_TXPWR_LMT_ARRAY_LEN		3948
+extern u8 *RTL8821AU_TXPWR_LMT[];
+
+#define RTL8812AU_AGC_TAB_ARRAY_LEN		792
+extern u32 RTL8812AU_AGC_TAB_ARRAY[];
+#define RTL8812AU_PHY_REG_ARRAY_LEN		460
+extern u32 RTL8812AU_PHY_REG_ARRAY[];
+
+#define RTL8812AU_PHY_REG_PG_ARRAY_LEN		276
+extern u32 RTL8812AU_PHY_REG_PG_ARRAY[];
+#define RTL8812AU_PHY_REG_PG_ASUS_ARRAY_LEN	276
+extern u32 RTL8812AU_PHY_REG_PG_ASUS_ARRAY[];
+#define RTL8812AU_PHY_REG_PG_NEC_ARRAY_LEN	276
+extern u32 RTL8812AU_PHY_REG_PG_NEC_ARRAY[];
+
+#define RTL8821AU_AGC_TAB_ARRAY_LEN		382	
+extern u32 RTL8821AU_AGC_TAB_ARRAY[];
+#define RTL8821AU_PHY_REG_ARRAY_LEN		334
+extern u32 RTL8821AU_PHY_REG_ARRAY[];
+
+#define RTL8821AU_PHY_REG_PG_ARRAY_LEN		90
+extern u32 RTL8821AU_PHY_REG_PG_ARRAY[];
+#endif
diff -Naur linux-4.9/drivers/staging/rtl8821au/rtl8821au/trx.c linux-4.9.8821au/drivers/staging/rtl8821au/rtl8821au/trx.c
--- linux-4.9/drivers/staging/rtl8821au/rtl8821au/trx.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/rtl8821au/trx.c	2016-12-11 19:48:25.186978326 -0600
@@ -0,0 +1,2035 @@
+#ifdef CONFIG_RTLWIFI
+
+#include <../drivers/net/wireless/realtek/rtlwifi/wifi.h>
+#include <../drivers/net/wireless/realtek/rtlwifi/core.h>
+#include <../drivers/net/wireless/realtek/rtlwifi/ps.h>
+#include <../drivers/net/wireless/realtek/rtlwifi/base.h>
+
+#else
+
+#include <drv_types.h>
+#include <linux/etherdevice.h>
+#include <rtl8812a_hal.h>
+#include "trx.h"
+#include "def.h"
+#include <usb_ops.h>
+
+#endif
+
+/* ULLI : reference -> u16 rtl8192cu_mq_to_hwq() */
+/* ULLI : for rtl_hal_usbint_cfg ->usb_mq_to_hwq */
+
+static uint32_t rtw_get_ff_hwaddr(struct xmit_frame *pxmitframe)
+{
+	uint32_t	 addr;
+	struct tx_pkt_attrib *pattrib = &pxmitframe->tx_attrib;
+
+	switch (pattrib->tx_qsel) {
+	case 0:
+	case 3:
+		addr = RTL_TXQ_BE;
+		break;
+	case 1:
+	case 2:
+		addr = RTL_TXQ_BK;
+		break;
+	case 4:
+	case 5:
+		addr = RTL_TXQ_VI;
+		break;
+	case 6:
+	case 7:
+		addr = RTL_TXQ_VO;
+		break;
+	case 0x10:
+		addr = RTL_TXQ_BCN;
+		break;
+	case 0x11:	/* BC/MC in PS (HIQ) */
+		addr = RTL_TXQ_HI;
+		break;
+	case 0x12:
+	default:
+		addr = RTL_TXQ_MGT;
+		break;
+
+	}
+
+	return addr;
+
+}
+
+static void rtl8812a_cal_txdesc_chksum(uint8_t *ptxdesc)
+{
+	u16 *usPtr;
+	uint32_t count;
+	uint32_t index;
+	u16 checksum = 0;
+
+	usPtr = (u16 *)ptxdesc;
+	/*
+	 * checksume is always calculated by first 32 bytes,
+	 * and it doesn't depend on TX DESC length.
+	 * Thomas,Lucas@SD4,20130515
+	 */
+	count = 16;
+
+	/* Clear first */
+	SET_TX_DESC_TX_DESC_CHECKSUM(ptxdesc, 0);
+
+	for (index = 0; index < count; index++) {
+		checksum = checksum ^ le16_to_cpu(*(usPtr + index));
+	}
+
+	SET_TX_DESC_TX_DESC_CHECKSUM(ptxdesc, checksum);
+}
+
+
+static uint8_t	MRateToHwRate(uint8_t rate)
+{
+	uint8_t	ret = DESC_RATE1M;
+
+	switch(rate)
+	{
+		// CCK and OFDM non-HT rates
+	case IEEE80211_CCK_RATE_1MB:	ret = DESC_RATE1M;	break;
+	case IEEE80211_CCK_RATE_2MB:	ret = DESC_RATE2M;	break;
+	case IEEE80211_CCK_RATE_5MB:	ret = DESC_RATE5_5M;	break;
+	case IEEE80211_CCK_RATE_11MB:	ret = DESC_RATE11M;	break;
+	case IEEE80211_OFDM_RATE_6MB:	ret = DESC_RATE6M;	break;
+	case IEEE80211_OFDM_RATE_9MB:	ret = DESC_RATE9M;	break;
+	case IEEE80211_OFDM_RATE_12MB:	ret = DESC_RATE12M;	break;
+	case IEEE80211_OFDM_RATE_18MB:	ret = DESC_RATE18M;	break;
+	case IEEE80211_OFDM_RATE_24MB:	ret = DESC_RATE24M;	break;
+	case IEEE80211_OFDM_RATE_36MB:	ret = DESC_RATE36M;	break;
+	case IEEE80211_OFDM_RATE_48MB:	ret = DESC_RATE48M;	break;
+	case IEEE80211_OFDM_RATE_54MB:	ret = DESC_RATE54M;	break;
+
+		// HT rates since here
+	//case MGN_MCS0:		ret = DESC_RATEMCS0;	break;
+	//case MGN_MCS1:		ret = DESC_RATEMCS1;	break;
+	//case MGN_MCS2:		ret = DESC_RATEMCS2;	break;
+	//case MGN_MCS3:		ret = DESC_RATEMCS3;	break;
+	//case MGN_MCS4:		ret = DESC_RATEMCS4;	break;
+	//case MGN_MCS5:		ret = DESC_RATEMCS5;	break;
+	//case MGN_MCS6:		ret = DESC_RATEMCS6;	break;
+	//case MGN_MCS7:		ret = DESC_RATEMCS7;	break;
+
+	default:		break;
+	}
+
+	return ret;
+}
+
+
+void rtl8821au_fill_fake_txdesc(struct rtl_priv *rtlpriv, uint8_t *pDesc,
+	uint32_t BufferLen, uint8_t IsPsPoll, uint8_t IsBTQosNull)
+{
+	struct mlme_ext_priv	*pmlmeext = &rtlpriv->mlmeextpriv;
+
+	/* Clear all status */
+	memset(pDesc, 0, TXDESC_SIZE);
+
+	SET_TX_DESC_FIRST_SEG(pDesc, 1);
+	SET_TX_DESC_LAST_SEG(pDesc, 1);
+
+	SET_TX_DESC_OFFSET(pDesc, TXDESC_SIZE);
+
+	SET_TX_DESC_PKT_SIZE(pDesc, BufferLen);
+
+	SET_TX_DESC_QUEUE_SEL(pDesc,  QSLT_MGNT);
+
+	if (pmlmeext->cur_wireless_mode & WIRELESS_11B) {
+		SET_TX_DESC_RATE_ID(pDesc, RATEID_IDX_B);
+	} else {
+		SET_TX_DESC_RATE_ID(pDesc, RATEID_IDX_G);
+	}
+
+	/*
+	 * Set NAVUSEHDR to prevent Ps-poll AId filed to be changed to error vlaue by Hw.
+	 */
+	if (IsPsPoll) {
+		SET_TX_DESC_NAV_USE_HDR(pDesc, 1);
+	} else {
+		SET_TX_DESC_HWSEQ_EN(pDesc, 1); // Hw set sequence number
+	}
+
+	if (IsBTQosNull) {
+		SET_TX_DESC_BT_INT(pDesc, 1);
+	}
+
+	SET_TX_DESC_USE_RATE(pDesc, 1);
+	SET_TX_DESC_OWN(pDesc, 1);
+
+	SET_TX_DESC_TX_RATE(pDesc, MRateToHwRate(pmlmeext->tx_rate));
+
+	// USB interface drop packet if the checksum of descriptor isn't correct.
+	// Using this checksum can let hardware recovery from packet bulk out error (e.g. Cancel URC, Bulk out error.).
+	rtl8812a_cal_txdesc_chksum(pDesc);
+}
+
+/* ULLI TX DESC */
+/*
+ * Description: In normal chip, we should send some packet to Hw which will be used by Fw
+ * in FW LPS mode. The function is to fill the Tx descriptor of this packets, then
+ * Fw can tell Hw to send these packet derectly.
+ *
+*/
+static void rtl8812a_fill_txdesc_sectype(struct tx_pkt_attrib *pattrib, uint8_t *ptxdesc)
+{
+	if ((pattrib->encrypt > 0) && !pattrib->bswenc) {
+		switch (pattrib->encrypt) {
+		/* SEC_TYPE : 0:NO_ENC,1:WEP40/TKIP,2:WAPI,3:AES */
+		case WEP40_ENCRYPTION:
+		case WEP104_ENCRYPTION:
+		case TKIP_ENCRYPTION:
+		case RSERVED_ENCRYPTION:
+			SET_TX_DESC_SEC_TYPE(ptxdesc, 0x1);
+			break;
+		case AESCCMP_ENCRYPTION:
+			SET_TX_DESC_SEC_TYPE(ptxdesc, 0x3);
+			break;
+		case NO_ENCRYPTION:
+		default:
+			SET_TX_DESC_SEC_TYPE(ptxdesc, 0x0);
+			break;
+
+		}
+
+	}
+
+}
+
+
+static void rtl8812a_fill_txdesc_phy(struct rtl_priv *rtlpriv, struct tx_pkt_attrib *pattrib, uint8_t *ptxdesc)
+{
+	/* DBG_8192C("bwmode=%d, ch_off=%d\n", pattrib->bwmode, pattrib->ch_offset); */
+
+	if (pattrib->ht_en) {
+		/*  Set Bandwidth and sub-channel settings. */
+		SET_TX_DESC_DATA_BW(ptxdesc, BWMapping_8812(rtlpriv,pattrib));
+		/* SET_TX_DESC_DATA_SC(ptxdesc, SCMapping_8812(rtlpriv,pattrib)); */
+	}
+}
+
+static void rtl8812a_fill_txdesc_vcs(struct rtl_priv *rtlpriv, struct tx_pkt_attrib *pattrib, uint8_t *ptxdesc)
+{
+	struct mlme_ext_priv	*pmlmeext = &rtlpriv->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+
+	//DBG_8192C("vcs_mode=%d\n", pattrib->vcs_mode);
+
+	if (pattrib->vcs_mode) {
+		switch(pattrib->vcs_mode) {
+		case RTS_CTS:
+			SET_TX_DESC_RTS_ENABLE(ptxdesc, 1);
+			break;
+		case CTS_TO_SELF:
+			SET_TX_DESC_CTS2SELF(ptxdesc, 1);
+			break;
+		case NONE_VCS:
+		default:
+			break;
+		}
+		if (pmlmeinfo->preamble_mode == PREAMBLE_SHORT)
+			SET_TX_DESC_RTS_SHORT(ptxdesc, 1);
+
+		SET_TX_DESC_RTS_RATE(ptxdesc, 0x8);	/*RTS Rate=24M */
+
+		SET_TX_DESC_RTS_RATE_FB_LIMIT(ptxdesc, 0xf);
+
+		/*
+		 * Enable HW RTS
+		 * SET_TX_DESC_HW_RTS_ENABLE(ptxdesc, 1);
+		 */
+	}
+}
+
+static inline uint8_t rtw_usb_bulk_size_boundary(struct rtl_priv * rtlpriv,int buf_len)
+{
+	uint8_t rst = true;
+
+	if (IS_SUPER_SPEED_USB(rtlpriv))
+		rst = (0 == (buf_len) % USB_SUPER_SPEED_BULK_SIZE)?true:false;
+	if (IS_HIGH_SPEED_USB(rtlpriv))
+		rst = (0 == (buf_len) % USB_HIGH_SPEED_BULK_SIZE)?true:false;
+	else
+		rst = (0 == (buf_len) % USB_FULL_SPEED_BULK_SIZE)?true:false;
+	return rst;
+}
+
+static int32_t update_txdesc(struct xmit_frame *pxmitframe, uint8_t *pmem, int32_t sz , uint8_t bagg_pkt)
+{
+	int	pull = 0;
+	uint8_t offset;
+	struct rtl_priv *rtlpriv = pxmitframe->rtlpriv;
+	struct rtl_hal *rtlhal = rtl_hal(rtlpriv);
+	struct tx_pkt_attrib	*pattrib = &pxmitframe->tx_attrib;
+	 struct _rtw_hal	*pHalData = GET_HAL_DATA(rtlpriv);
+	struct dm_priv	*pdmpriv = &pHalData->dmpriv;
+	uint8_t	*ptxdesc =  pmem;
+	struct mlme_ext_priv	*pmlmeext = &rtlpriv->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	int	bmcst = is_multicast_ether_addr(pattrib->ra);
+
+	if ((!bagg_pkt) && (rtw_usb_bulk_size_boundary(rtlpriv, TXDESC_SIZE+sz) == false)) {
+		ptxdesc = (pmem+PACKET_OFFSET_SZ);
+		/* DBG_8192C("==> non-agg-pkt,shift pointer...\n"); */
+		pull = 1;
+	}
+
+	memset(ptxdesc, 0, TXDESC_SIZE);
+
+	/* 4 offset 0 */
+	SET_TX_DESC_FIRST_SEG(ptxdesc, 1);
+	SET_TX_DESC_LAST_SEG(ptxdesc, 1);
+	SET_TX_DESC_OWN(ptxdesc, 1);
+
+	/* DBG_8192C("%s==> pkt_len=%d,bagg_pkt=%02x\n",__FUNCTION__,sz,bagg_pkt); */
+	SET_TX_DESC_PKT_SIZE(ptxdesc, sz);
+
+	offset = TXDESC_SIZE + OFFSET_SZ;
+
+	/* DBG_8192C("%s==>offset(0x%02x)  \n",__FUNCTION__,offset); */
+	SET_TX_DESC_OFFSET(ptxdesc, offset);
+
+	if (bmcst) {
+		SET_TX_DESC_BMC(ptxdesc, 1);
+	}
+
+	if (!bagg_pkt) {
+		if ((pull) && (pxmitframe->pkt_offset > 0)) {
+			pxmitframe->pkt_offset = pxmitframe->pkt_offset - 1;
+		}
+	}
+
+	/*
+	 * DBG_8192C("%s, pkt_offset=0x%02x\n",__FUNCTION__,pxmitframe->pkt_offset);
+	 * pkt_offset, unit:8 bytes padding
+	 */
+	if (pxmitframe->pkt_offset > 0) {
+		SET_TX_DESC_PKT_OFFSET(ptxdesc, pxmitframe->pkt_offset);
+	}
+
+	SET_TX_DESC_MACID(ptxdesc, pattrib->mac_id);
+	SET_TX_DESC_RATE_ID(ptxdesc, pattrib->raid);
+
+	SET_TX_DESC_QUEUE_SEL(ptxdesc,  pattrib->tx_qsel);
+
+	/* offset 12 */
+
+	if (!pattrib->qos_en) {
+		SET_TX_DESC_HWSEQ_EN(ptxdesc, 1); /* Hw set sequence number */
+	} else {
+		SET_TX_DESC_SEQ(ptxdesc, pattrib->seqnum);
+	}
+
+	if ((pxmitframe->frame_tag&0x0f) == DATA_FRAMETAG) {
+		/* DBG_8192C("pxmitframe->frame_tag == DATA_FRAMETAG\n"); */
+
+		rtl8812a_fill_txdesc_sectype(pattrib, ptxdesc);
+
+		/* offset 20 */
+		if (pxmitframe->agg_num > 1) {
+			/* DBG_8192C("%s agg_num:%d\n",__FUNCTION__,pxmitframe->agg_num ); */
+			SET_TX_DESC_USB_TXAGG_NUM(ptxdesc, pxmitframe->agg_num);
+		}
+
+		rtl8812a_fill_txdesc_vcs(rtlpriv, pattrib, ptxdesc);
+
+		if ((pattrib->ether_type != 0x888e) &&
+		    (pattrib->ether_type != 0x0806) &&
+		    (pattrib->ether_type != 0x88b4) &&
+		    (pattrib->dhcp_pkt != 1)) {
+			/* Non EAP & ARP & DHCP type data packet */
+
+			if (pattrib->ampdu_en == true) {
+				SET_TX_DESC_AGG_ENABLE(ptxdesc, 1);
+				SET_TX_DESC_MAX_AGG_NUM(ptxdesc, 0x1f);
+				/* Set A-MPDU aggregation. */
+				SET_TX_DESC_AMPDU_DENSITY(ptxdesc, pHalData->AMPDUDensity);
+			} else {
+				SET_TX_DESC_AGG_BREAK(ptxdesc, 1);
+			}
+
+			rtl8812a_fill_txdesc_phy(rtlpriv, pattrib, ptxdesc);
+
+			/* DATA  Rate FB LMT */
+			SET_TX_DESC_DATA_RATE_FB_LIMIT(ptxdesc, 0x1f);
+
+			if (pHalData->fw_ractrl == false) {
+				SET_TX_DESC_USE_RATE(ptxdesc, 1);
+
+				if (pdmpriv->INIDATA_RATE[pattrib->mac_id] & BIT(7))
+					SET_TX_DESC_DATA_SHORT(ptxdesc, 	1);
+
+				SET_TX_DESC_TX_RATE(ptxdesc, (pdmpriv->INIDATA_RATE[pattrib->mac_id] & 0x7F));
+			}
+
+			if (rtlpriv->fix_rate != 0xFF) { 	/* modify data rate by iwpriv */
+				SET_TX_DESC_USE_RATE(ptxdesc, 1);
+				if (rtlpriv->fix_rate & BIT(7))
+					SET_TX_DESC_DATA_SHORT(ptxdesc, 	1);
+
+				SET_TX_DESC_TX_RATE(ptxdesc, (rtlpriv->fix_rate & 0x7F));
+			}
+
+			if (pattrib->ldpc)
+				SET_TX_DESC_DATA_LDPC(ptxdesc, 1);
+			if (pattrib->stbc)
+				SET_TX_DESC_DATA_STBC(ptxdesc, 1);
+		} else {
+			/*
+			 *  EAP data packet and ARP packet and DHCP.
+			 *  Use the 1M data rate to send the EAP/ARP packet.
+			 *  This will maybe make the handshake smooth.
+			 */
+
+			SET_TX_DESC_USE_RATE(ptxdesc, 1);
+			SET_TX_DESC_AGG_BREAK(ptxdesc, 1);
+
+			/* HW will ignore this setting if the transmission rate is legacy OFDM. */
+			if (pmlmeinfo->preamble_mode == PREAMBLE_SHORT) {
+				SET_TX_DESC_DATA_SHORT(ptxdesc, 1);
+			}
+
+			SET_TX_DESC_TX_RATE(ptxdesc, MRateToHwRate(pmlmeext->tx_rate));
+		}
+	} else if ((pxmitframe->frame_tag&0x0f) == MGNT_FRAMETAG) {
+		/* DBG_8192C("pxmitframe->frame_tag == MGNT_FRAMETAG\n"); */
+
+		if (IS_HARDWARE_TYPE_8821(rtlhal))
+			SET_TX_DESC_MBSSID_8821(ptxdesc, pattrib->mbssid);
+
+		/* offset 20 */
+		SET_TX_DESC_RETRY_LIMIT_ENABLE(ptxdesc, 1);
+
+		if (pattrib->retry_ctrl == true) {
+			SET_TX_DESC_DATA_RETRY_LIMIT(ptxdesc, 6);
+		} else {
+			SET_TX_DESC_DATA_RETRY_LIMIT(ptxdesc, 12);
+		}
+
+		SET_TX_DESC_USE_RATE(ptxdesc, 1);
+		{
+			SET_TX_DESC_TX_RATE(ptxdesc, MRateToHwRate(pmlmeext->tx_rate));
+		}
+	} else if ((pxmitframe->frame_tag&0x0f) == TXAGG_FRAMETAG) {
+		dev_dbg(&(rtlpriv->ndev->dev), "pxmitframe->frame_tag == TXAGG_FRAMETAG\n");
+	} else {
+		dev_dbg(&(rtlpriv->ndev->dev), "pxmitframe->frame_tag = %d\n", pxmitframe->frame_tag);
+
+		SET_TX_DESC_USE_RATE(ptxdesc, 1);
+		SET_TX_DESC_TX_RATE(ptxdesc, MRateToHwRate(pmlmeext->tx_rate));
+	}
+
+	rtl8812a_cal_txdesc_chksum(ptxdesc);
+	_dbg_dump_tx_info(rtlpriv, pxmitframe->frame_tag, ptxdesc);
+	return pull;
+}
+
+
+
+
+/* for non-agg data frame or  management frame */
+static int32_t rtw_dump_xframe(struct rtl_priv *rtlpriv, struct xmit_frame *pxmitframe)
+{
+	int32_t ret = _SUCCESS;
+	int32_t inner_ret = _SUCCESS;
+	int t, sz, w_sz, pull = 0;
+	uint8_t *mem_addr;
+	uint32_t ff_hwaddr;
+	struct xmit_buf *pxmitbuf = pxmitframe->pxmitbuf;
+	struct tx_pkt_attrib *pattrib = &pxmitframe->tx_attrib;
+	struct xmit_priv *pxmitpriv = &rtlpriv->xmitpriv;
+	struct security_priv *psecuritypriv = &rtlpriv->securitypriv;
+	if ((pxmitframe->frame_tag == DATA_FRAMETAG) &&
+	    (pxmitframe->tx_attrib.ether_type != 0x0806) &&
+	    (pxmitframe->tx_attrib.ether_type != 0x888e) &&
+	    (pxmitframe->tx_attrib.ether_type != 0x88b4) &&
+	    (pxmitframe->tx_attrib.dhcp_pkt != 1)) {
+		rtw_issue_addbareq_cmd(rtlpriv, pxmitframe);
+	}
+	mem_addr = pxmitframe->buf_addr;
+
+	for (t = 0; t < pattrib->nr_frags; t++) {
+		if (inner_ret != _SUCCESS && ret == _SUCCESS)
+			ret = _FAIL;
+
+		if (t != (pattrib->nr_frags - 1)) {
+			sz = pxmitpriv->frag_len;
+			sz = sz - 4 - (psecuritypriv->sw_encrypt ? 0 : pattrib->icv_len);
+		} else {
+			/* no frag */
+			sz = pattrib->last_txcmdsz;
+		}
+
+		pull = update_txdesc(pxmitframe, mem_addr, sz, false);
+
+		if (pull) {
+			mem_addr += PACKET_OFFSET_SZ; /* pull txdesc head */
+
+			/* pxmitbuf ->pbuf = mem_addr; */
+			pxmitframe->buf_addr = mem_addr;
+
+			w_sz = sz + TXDESC_SIZE;
+		} else 	{
+			w_sz = sz + TXDESC_SIZE + PACKET_OFFSET_SZ;
+		}
+
+		ff_hwaddr = rtw_get_ff_hwaddr(pxmitframe);
+
+		inner_ret =  _rtlw_usb_transmit(rtlpriv, ff_hwaddr, w_sz, pxmitbuf);
+
+		rtw_count_tx_stats(rtlpriv, pxmitframe, sz);
+
+		/* DBG_8192C("rtw_write_port, w_sz=%d, sz=%d, txdesc_sz=%d, tid=%d\n", w_sz, sz, w_sz-sz, pattrib->priority); */
+
+		mem_addr += w_sz;
+
+		mem_addr = (uint8_t *)RND4(((__kernel_size_t)(mem_addr)));
+
+	}
+
+	rtw_free_xmitframe(pxmitpriv, pxmitframe);
+
+	if  (ret != _SUCCESS)
+		rtw_sctx_done_err(&pxmitbuf->sctx, RTW_SCTX_DONE_UNKNOWN);
+
+	return ret;
+}
+
+static uint32_t xmitframe_need_length(struct xmit_frame *pxmitframe)
+{
+	struct tx_pkt_attrib *pattrib = &pxmitframe->tx_attrib;
+
+	uint32_t	len = 0;
+
+	/* no consider fragement */
+	len = pattrib->hdrlen + pattrib->iv_len +
+		SNAP_SIZE + sizeof(u16) +
+		pattrib->pktlen +
+		((pattrib->bswenc) ? pattrib->icv_len : 0);
+
+	if (pattrib->encrypt == TKIP_ENCRYPTION)
+		len += 8;
+
+	return len;
+}
+
+#define IDEA_CONDITION 1	/* check all packets before enqueue */
+int32_t rtl8812au_xmitframe_complete(struct rtl_priv *rtlpriv,
+				     struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf)
+{
+	 struct _rtw_hal	*pHalData = GET_HAL_DATA(rtlpriv);
+	struct xmit_frame *pxmitframe = NULL;
+	struct xmit_frame *pfirstframe = NULL;
+
+	/* aggregate variable */
+	struct hw_xmit *phwxmit;
+	struct sta_info *psta = NULL;
+	struct tx_servq *ptxservq = NULL;
+
+	struct list_head *item;
+
+	uint32_t	pbuf;		/* next pkt address */
+	uint32_t	pbuf_tail;	/* last pkt tail */
+	uint32_t	len;		/* packet length, except TXDESC_SIZE and PKT_OFFSET */
+
+	uint32_t	bulkSize = rtl_usbdev(rtlpriv)->max_bulk_out_size;
+	uint8_t	descCount;
+	uint32_t	bulkPtr;
+
+	/* dump frame variable */
+	uint32_t ff_hwaddr;
+
+#ifndef IDEA_CONDITION
+	int res = _SUCCESS;
+#endif
+
+	/* check xmitbuffer is ok */
+	if (pxmitbuf == NULL) {
+		pxmitbuf = rtw_alloc_xmitbuf(pxmitpriv);
+		if (pxmitbuf == NULL) {
+			/* DBG_871X("%s #1, connot alloc xmitbuf!!!! \n",__FUNCTION__); */
+			return false;
+		}
+	}
+
+/* DBG_8192C("%s ===================================== \n",__FUNCTION__); */
+	/* 3 1. pick up first frame */
+	do {
+		rtw_free_xmitframe(pxmitpriv, pxmitframe);
+
+		pxmitframe = rtw_dequeue_xframe(pxmitpriv, pxmitpriv->hwxmits);
+		if (pxmitframe == NULL) {
+			/*
+			 * no more xmit frame, release xmit buffer
+			 * DBG_8192C("no more xmit frame ,return\n");
+			 */
+			rtw_free_xmitbuf(pxmitpriv, pxmitbuf);
+			return false;
+		}
+
+#ifndef IDEA_CONDITION
+		if (pxmitframe->frame_tag != DATA_FRAMETAG) {
+			/* rtw_free_xmitframe(pxmitpriv, pxmitframe); */
+			continue;
+		}
+
+		/* TID 0~15 */
+		if ((pxmitframe->attrib.tx_priority < 0) ||
+		    (pxmitframe->attrib.tx_priority > 15)) {
+			/* rtw_free_xmitframe(pxmitpriv, pxmitframe); */
+			continue;
+		}
+#endif
+		/* DBG_8192C("==> pxmitframe->attrib.priority:%d\n",pxmitframe->attrib.priority); */
+		pxmitframe->pxmitbuf = pxmitbuf;
+		pxmitframe->buf_addr = pxmitbuf->pbuf;
+		pxmitbuf->priv_data = pxmitframe;
+
+		pxmitframe->agg_num = 1; 	/* alloc xmitframe should assign to 1. */
+		pxmitframe->pkt_offset = 1; 	/* first frame of aggregation, reserve offset */
+
+		if (rtw_xmitframe_coalesce(rtlpriv, pxmitframe->skb, pxmitframe) == false) {
+			dev_dbg(&(rtlpriv->ndev->dev), "%s coalesce 1st xmitframe failed \n", __FUNCTION__);
+			continue;
+		}
+
+
+		/* always return ndis_packet after rtw_xmitframe_coalesce */
+		rtw_os_xmit_complete(rtlpriv, pxmitframe);
+
+		break;
+	} while (1);
+
+	/* 3 2. aggregate same priority and same DA(AP or STA) frames */
+	pfirstframe = pxmitframe;
+	len = xmitframe_need_length(pfirstframe) + TXDESC_SIZE+(pfirstframe->pkt_offset*PACKET_OFFSET_SZ);
+	pbuf_tail = len;
+	pbuf = _RND8(pbuf_tail);
+
+	/* check pkt amount in one bulk */
+	descCount = 0;
+	bulkPtr = bulkSize;
+	if (pbuf < bulkPtr)
+		descCount++;
+	else {
+		descCount = 0;
+		bulkPtr = ((pbuf / bulkSize) + 1) * bulkSize; /* round to next bulkSize */
+	}
+
+	/* ULLI sta enqueue code into tx queue */
+
+	/* dequeue same priority packet from station tx queue */
+	psta = pfirstframe->tx_attrib.psta;
+	switch (pfirstframe->tx_attrib.tx_priority) {
+	case 1:
+	case 2:
+		ptxservq = &(psta->sta_xmitpriv.bk_q);
+		phwxmit = &pxmitpriv->hwxmits[3];
+		break;
+
+	case 4:
+	case 5:
+		ptxservq = &(psta->sta_xmitpriv.vi_q);
+		phwxmit = &pxmitpriv->hwxmits[1];
+		break;
+
+	case 6:
+	case 7:
+		ptxservq = &(psta->sta_xmitpriv.vo_q);
+		phwxmit = &pxmitpriv->hwxmits[0];
+		break;
+
+	case 0:
+	case 3:
+	default:
+		ptxservq = &(psta->sta_xmitpriv.be_q);
+		phwxmit = &pxmitpriv->hwxmits[2];
+		break;
+	}
+/*
+ * DBG_8192C("==> pkt_no=%d,pkt_len=%d,len=%d,RND8_LEN=%d,pkt_offset=0x%02x\n",
+ * 	pxmitframe->agg_num,pxmitframe->attrib.last_txcmdsz,len,pbuf,pxmitframe->pkt_offset );
+ */
+
+	spin_lock_bh(&pxmitpriv->lock);
+
+	list_for_each(item, get_list_head(&ptxservq->sta_pending)) {
+		pxmitframe = list_entry(item, struct xmit_frame, list);
+
+		pxmitframe->agg_num = 0; 	/* not first frame of aggregation */
+		pxmitframe->pkt_offset = 0; 	/* not first frame of aggregation, no need to reserve offset */
+
+		len = xmitframe_need_length(pxmitframe) + TXDESC_SIZE + (pxmitframe->pkt_offset*PACKET_OFFSET_SZ);
+
+		if (_RND8(pbuf + len) > MAX_XMITBUF_SZ) {
+		/* if (_RND8(pbuf + len) > (MAX_XMITBUF_SZ/2))//to do : for TX TP finial tune , Georgia 2012-0323 */
+
+			/* DBG_8192C("%s....len> MAX_XMITBUF_SZ\n",__FUNCTION__); */
+			pxmitframe->agg_num = 1;
+			pxmitframe->pkt_offset = 1;
+			break;
+		}
+		list_del_init(&pxmitframe->list);
+
+#ifndef IDEA_CONDITION
+		/*  suppose only data frames would be in queue */
+		if (pxmitframe->frame_tag != DATA_FRAMETAG) {
+			rtw_free_xmitframe(pxmitpriv, pxmitframe);
+			continue;
+		}
+
+		/* TID 0~15 */
+		if ((pxmitframe->attrib.priority < 0) ||
+		    (pxmitframe->attrib.priority > 15)) {
+			rtw_free_xmitframe(pxmitpriv, pxmitframe);
+			continue;
+		}
+#endif
+
+		/* pxmitframe->pxmitbuf = pxmitbuf; */
+		pxmitframe->buf_addr = pxmitbuf->pbuf + pbuf;
+
+		if (rtw_xmitframe_coalesce(rtlpriv, pxmitframe->skb, pxmitframe) == false) {
+			dev_dbg(&(rtlpriv->ndev->dev), "%s coalesce failed \n", __FUNCTION__);
+			rtw_free_xmitframe(pxmitpriv, pxmitframe);
+			continue;
+		}
+
+		/*
+		 * DBG_8192C("==> pxmitframe->attrib.priority:%d\n",pxmitframe->attrib.priority);
+		 * always return ndis_packet after rtw_xmitframe_coalesce
+		 */
+		rtw_os_xmit_complete(rtlpriv, pxmitframe);
+
+		/* (len - TXDESC_SIZE) == pxmitframe->attrib.last_txcmdsz */
+		update_txdesc(pxmitframe, pxmitframe->buf_addr, pxmitframe->tx_attrib.last_txcmdsz, true);
+
+		/* don't need xmitframe any more */
+		rtw_free_xmitframe(pxmitpriv, pxmitframe);
+
+		/* handle pointer and stop condition */
+		pbuf_tail = pbuf + len;
+		pbuf = _RND8(pbuf_tail);
+
+
+		pfirstframe->agg_num++;
+		if (MAX_TX_AGG_PACKET_NUMBER == pfirstframe->agg_num)
+			break;
+
+		if (pbuf < bulkPtr) {
+			descCount++;
+			if (descCount == pHalData->UsbTxAggDescNum)
+				break;
+		} else {
+			descCount = 0;
+			bulkPtr = ((pbuf / bulkSize) + 1) * bulkSize;
+		}
+	}	/* end while( aggregate same priority and same DA(AP or STA) frames) */
+
+
+	/* ULLI : Huh ???, must follow this ... */
+
+	if (list_empty(&ptxservq->sta_pending.list))
+		list_del_init(&ptxservq->tx_pending);
+
+	spin_unlock_bh(&pxmitpriv->lock);
+	if ((pfirstframe->tx_attrib.ether_type != 0x0806) &&
+	    (pfirstframe->tx_attrib.ether_type != 0x888e) &&
+	    (pfirstframe->tx_attrib.ether_type != 0x88b4) &&
+	    (pfirstframe->tx_attrib.dhcp_pkt != 1)) {
+		rtw_issue_addbareq_cmd(rtlpriv, pfirstframe);
+	}
+	/* 3 3. update first frame txdesc */
+	if ((pbuf_tail % bulkSize) == 0) {
+		/* remove pkt_offset */
+		pbuf_tail -= PACKET_OFFSET_SZ;
+		pfirstframe->buf_addr += PACKET_OFFSET_SZ;
+		pfirstframe->pkt_offset--;
+		/* DBG_8192C("$$$$$ buf size equal to USB block size $$$$$$\n"); */
+	}
+
+	update_txdesc(pfirstframe, pfirstframe->buf_addr, pfirstframe->tx_attrib.last_txcmdsz, true);
+
+	/* 3 4. write xmit buffer to USB FIFO */
+	ff_hwaddr = rtw_get_ff_hwaddr(pfirstframe);
+/* DBG_8192C("%s ===================================== write port,buf_size(%d) \n",__FUNCTION__,pbuf_tail); */
+	/* xmit address == ((xmit_frame*)pxmitbuf->priv_data)->buf_addr */
+	 _rtlw_usb_transmit(rtlpriv, ff_hwaddr, pbuf_tail, pxmitbuf);
+
+
+	/* 3 5. update statisitc */
+	pbuf_tail -= (pfirstframe->agg_num * TXDESC_SIZE);
+	pbuf_tail -= (pfirstframe->pkt_offset * PACKET_OFFSET_SZ);
+
+
+	rtw_count_tx_stats(rtlpriv, pfirstframe, pbuf_tail);
+
+	rtw_free_xmitframe(pxmitpriv, pfirstframe);
+
+	return true;
+}
+
+static int32_t xmitframe_direct(struct rtl_priv *rtlpriv, struct xmit_frame *pxmitframe)
+{
+	int32_t res = _SUCCESS;
+	/* DBG_8192C("==> %s \n",__FUNCTION__); */
+
+	res = rtw_xmitframe_coalesce(rtlpriv, pxmitframe->skb, pxmitframe);
+	if (res == _SUCCESS) {
+		rtw_dump_xframe(rtlpriv, pxmitframe);
+	} else {
+		dev_dbg(&(rtlpriv->ndev->dev), "==> %s xmitframe_coalsece failed\n", __FUNCTION__);
+	}
+
+	return res;
+}
+
+/*
+ * Return
+ *	true	dump packet directly
+ *	false	enqueue packet
+ */
+static int32_t pre_xmitframe(struct rtl_priv *rtlpriv, struct xmit_frame *pxmitframe)
+{
+	int32_t res;
+	struct xmit_buf *pxmitbuf = NULL;
+	struct xmit_priv *pxmitpriv = &rtlpriv->xmitpriv;
+	struct tx_pkt_attrib *pattrib = &pxmitframe->tx_attrib;
+	struct mlme_priv *pmlmepriv = &rtlpriv->mlmepriv;
+
+	spin_lock_bh(&pxmitpriv->lock);
+
+	/* DBG_8192C("==> %s \n",__FUNCTION__); */
+
+	if (rtw_txframes_sta_ac_pending(rtlpriv, pattrib)) {
+		/* DBG_8192C("enqueue AC(%d)\n",pattrib->priority); */
+		goto enqueue;
+	}
+
+
+	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY|_FW_UNDER_LINKING) == true)
+		goto enqueue;
+
+	pxmitbuf = rtw_alloc_xmitbuf(pxmitpriv);
+	if (pxmitbuf == NULL)
+		goto enqueue;
+
+	spin_unlock_bh(&pxmitpriv->lock);
+
+	pxmitframe->pxmitbuf = pxmitbuf;
+	pxmitframe->buf_addr = pxmitbuf->pbuf;
+	pxmitbuf->priv_data = pxmitframe;
+
+	if (xmitframe_direct(rtlpriv, pxmitframe) != _SUCCESS) {
+		rtw_free_xmitbuf(pxmitpriv, pxmitbuf);
+		rtw_free_xmitframe(pxmitpriv, pxmitframe);
+	}
+
+	return true;
+
+enqueue:
+	res = rtw_xmitframe_enqueue(rtlpriv, pxmitframe);
+	spin_unlock_bh(&pxmitpriv->lock);
+
+	if (res != _SUCCESS) {
+		rtw_free_xmitframe(pxmitpriv, pxmitframe);
+
+		/* Trick, make the statistics correct */
+		pxmitpriv->tx_pkts--;
+		pxmitpriv->tx_drop++;
+		return true;
+	}
+
+	return false;
+}
+
+int32_t rtl8812au_mgnt_xmit(struct rtl_priv *rtlpriv, struct xmit_frame *pmgntframe)
+{
+	return rtw_dump_xframe(rtlpriv, pmgntframe);
+}
+
+/*
+ * Return
+ *	true	dump packet directly ok
+ *	false	temporary can't transmit packets to hardware
+ */
+int32_t rtl8812au_hal_xmit(struct rtl_priv *rtlpriv, struct xmit_frame *pxmitframe)
+{
+	return pre_xmitframe(rtlpriv, pxmitframe);
+}
+
+int32_t	 rtl8812au_hal_xmitframe_enqueue(struct rtl_priv *rtlpriv, struct xmit_frame *pxmitframe)
+{
+	struct xmit_priv 	*pxmitpriv = &rtlpriv->xmitpriv;
+	int32_t err;
+
+	err = rtw_xmitframe_enqueue(rtlpriv, pxmitframe);
+	if (err != _SUCCESS) {
+		rtw_free_xmitframe(pxmitpriv, pxmitframe);
+
+		/* Trick, make the statistics correct */
+		pxmitpriv->tx_pkts--;
+		pxmitpriv->tx_drop++;
+	} else {
+		tasklet_hi_schedule(&pxmitpriv->xmit_tasklet);
+	}
+
+	return err;
+
+}
+
+void _dbg_dump_tx_info(struct rtl_priv	*rtlpriv,int frame_tag, uint8_t *ptxdesc)
+{
+}
+
+/*
+ * Description:
+ *	Aggregation packets and send to hardware
+ *
+ * Return:
+ *	0	Success
+ *	-1	Hardware resource(TX FIFO) not ready
+ *	-2	Software resource(xmitbuf) not ready
+ */
+
+
+
+u8 BWMapping_8812(struct rtl_priv *rtlpriv, struct tx_pkt_attrib *pattrib)
+{
+	uint8_t	BWSettingOfDesc = 0;
+
+	/*
+	 * DBG_871X("BWMapping pHalData->CurrentChannelBW %d, pattrib->bwmode %d \n",pHalData->CurrentChannelBW,pattrib->bwmode);
+	 */
+
+	if (rtlpriv->phy.current_chan_bw == CHANNEL_WIDTH_80) {
+		if (pattrib->bwmode == CHANNEL_WIDTH_80)
+			BWSettingOfDesc= 2;
+		else if (pattrib->bwmode == CHANNEL_WIDTH_40)
+			BWSettingOfDesc = 1;
+		else
+			BWSettingOfDesc = 0;
+	} else if(rtlpriv->phy.current_chan_bw == CHANNEL_WIDTH_40) {
+		if((pattrib->bwmode == CHANNEL_WIDTH_40) || (pattrib->bwmode == CHANNEL_WIDTH_80))
+			BWSettingOfDesc = 1;
+		else
+			BWSettingOfDesc = 0;
+	} else
+		BWSettingOfDesc = 0;
+
+	return BWSettingOfDesc;
+}
+
+/* ULLI check secondary channel mappen */
+
+u8 SCMapping_8812(struct rtl_priv *rtlpriv, struct tx_pkt_attrib *pattrib)
+{
+	uint8_t	SCSettingOfDesc = 0;
+	struct rtl_mac *mac = &(rtlpriv->mac80211);
+
+	/*
+	 * DBG_871X("SCMapping: pHalData->CurrentChannelBW %d, pHalData->nCur80MhzPrimeSC %d, pHalData->nCur40MhzPrimeSC %d \n",pHalData->CurrentChannelBW,pHalData->nCur80MhzPrimeSC,pHalData->nCur40MhzPrimeSC);
+	 */
+
+	if (rtlpriv->phy.current_chan_bw == CHANNEL_WIDTH_80) {
+		if(pattrib->bwmode == CHANNEL_WIDTH_80) {
+			SCSettingOfDesc = VHT_DATA_SC_DONOT_CARE;
+		} else if(pattrib->bwmode == CHANNEL_WIDTH_40) {
+			if(mac->cur_80_prime_sc == HAL_PRIME_CHNL_OFFSET_LOWER)
+				SCSettingOfDesc = VHT_DATA_SC_40_LOWER_OF_80MHZ;
+			else if(mac->cur_80_prime_sc == HAL_PRIME_CHNL_OFFSET_UPPER)
+				SCSettingOfDesc = VHT_DATA_SC_40_UPPER_OF_80MHZ;
+			else
+				RT_TRACE(rtlpriv, COMP_ERR, DBG_LOUD, "SCMapping: Not Correct Primary40MHz Setting \n");
+		} else {
+			if((mac->cur_40_prime_sc == HAL_PRIME_CHNL_OFFSET_LOWER) && (mac->cur_80_prime_sc == HAL_PRIME_CHNL_OFFSET_LOWER))
+				SCSettingOfDesc = VHT_DATA_SC_20_LOWEST_OF_80MHZ;
+			else if((mac->cur_40_prime_sc == HAL_PRIME_CHNL_OFFSET_UPPER) && (mac->cur_80_prime_sc == HAL_PRIME_CHNL_OFFSET_LOWER))
+				SCSettingOfDesc = VHT_DATA_SC_20_LOWER_OF_80MHZ;
+			else if((mac->cur_40_prime_sc == HAL_PRIME_CHNL_OFFSET_LOWER) && (mac->cur_80_prime_sc == HAL_PRIME_CHNL_OFFSET_UPPER))
+				SCSettingOfDesc = VHT_DATA_SC_20_UPPER_OF_80MHZ;
+			else if((mac->cur_40_prime_sc == HAL_PRIME_CHNL_OFFSET_UPPER) && (mac->cur_80_prime_sc == HAL_PRIME_CHNL_OFFSET_UPPER))
+				SCSettingOfDesc = VHT_DATA_SC_20_UPPERST_OF_80MHZ;
+			else
+				RT_TRACE(rtlpriv, COMP_ERR, DBG_LOUD, "SCMapping: Not Correct Primary40MHz Setting \n");
+		}
+	} else if(rtlpriv->phy.current_chan_bw== CHANNEL_WIDTH_40) {
+		/*
+		 * DBG_871X("SCMapping: HT Case: pHalData->CurrentChannelBW %d, pHalData->nCur40MhzPrimeSC %d \n",pHalData->CurrentChannelBW,pHalData->nCur40MhzPrimeSC);
+		 */
+
+		if(pattrib->bwmode == CHANNEL_WIDTH_40) {
+			SCSettingOfDesc = VHT_DATA_SC_DONOT_CARE;
+		} else if(pattrib->bwmode == CHANNEL_WIDTH_20) {
+			if(mac->cur_40_prime_sc == HAL_PRIME_CHNL_OFFSET_UPPER) {
+				SCSettingOfDesc = VHT_DATA_SC_20_UPPER_OF_80MHZ;
+			} else if(mac->cur_40_prime_sc == HAL_PRIME_CHNL_OFFSET_LOWER) {
+				SCSettingOfDesc = VHT_DATA_SC_20_LOWER_OF_80MHZ;
+			} else 		{
+				SCSettingOfDesc = VHT_DATA_SC_DONOT_CARE;
+			}
+
+		}
+	} else {
+		SCSettingOfDesc = VHT_DATA_SC_DONOT_CARE;
+	}
+
+	return SCSettingOfDesc;
+}
+
+/** RX */
+
+
+static u8 odm_QueryRxPwrPercentage(s8 AntPower)
+{
+	if ((AntPower <= -100) || (AntPower >= 20)) {
+		return	0;
+	} else if (AntPower >= 0) {
+		return	100;
+	} else {
+		return	(100+AntPower);
+	}
+
+}
+
+/*
+ * 2012/01/12 MH MOve some signal strength smooth method to MP HAL layer.
+ * IF other SW team do not support the feature, remove this section.??
+ */
+
+/*
+ * ULLI : this function is in rtlwifi
+ * ULLI : but with other values
+ */
+static long rtl_signal_scale_mapping(struct rtl_priv *rtlpriv, int32_t CurrSig)
+{
+	int32_t RetSig;
+
+	if (CurrSig >= 51 && CurrSig <= 100) {
+		RetSig = 100;
+	} else if (CurrSig >= 41 && CurrSig <= 50) {
+		RetSig = 80 + ((CurrSig - 40)*2);
+	} else if (CurrSig >= 31 && CurrSig <= 40) {
+		RetSig = 66 + (CurrSig - 30);
+	} else if (CurrSig >= 21 && CurrSig <= 30) {
+		RetSig = 54 + (CurrSig - 20);
+	} else if (CurrSig >= 10 && CurrSig <= 20) {
+		RetSig = 42 + (((CurrSig - 10) * 2) / 3);
+	} else if (CurrSig >= 5 && CurrSig <= 9) {
+		RetSig = 22 + (((CurrSig - 5) * 3) / 2);
+	} else if (CurrSig >= 1 && CurrSig <= 4) {
+		RetSig = 6 + (((CurrSig - 1) * 3) / 2);
+	} else {
+		RetSig = CurrSig;
+	}
+
+	return RetSig;
+}
+
+static u8 odm_EVMdbToPercentage(s8 Value)
+{
+	/*
+	 *  -33dB~0dB to 0%~99%
+	 */
+	s8 ret_val;
+
+	ret_val = Value;
+	/* ret_val /= 2; */
+
+	/* ODM_RT_DISP(FRX, RX_PHY_SQ, ("EVMdbToPercentage92C Value=%d / %x \n", ret_val, ret_val)); */
+
+	if (ret_val >= 0)
+		ret_val = 0;
+	if (ret_val <= -33)
+		ret_val = -33;
+
+	ret_val = 0 - ret_val;
+	ret_val *= 3;
+
+	if (ret_val == 99)
+		ret_val = 100;
+
+	return ret_val;
+}
+
+static u8 odm_EVMdbm_JaguarSeries(s8 Value)
+{
+	s8 ret_val = Value;
+
+	/* -33dB~0dB to 33dB ~ 0dB */
+	if (ret_val == -128)
+		ret_val = 127;
+	else if (ret_val < 0)
+		ret_val = 0 - ret_val;
+
+	ret_val  = ret_val >> 1;
+	return ret_val;
+}
+
+static u16 odm_Cfo(s8 Value)
+{
+	s16  ret_val;
+
+	if (Value < 0) {
+		ret_val = 0 - Value;
+		ret_val = (ret_val << 1) + (ret_val >> 1);	/*  *2.5~=312.5/2^7 */
+		ret_val = ret_val | BIT(12);  			/* set BIT(12) as 1 for negative cfo */
+	} else {
+		ret_val = Value;
+		ret_val = (ret_val << 1) + (ret_val>>1);	/*  *2.5~=312.5/2^7 */
+	}
+	return ret_val;
+}
+
+
+/*
+ * Endianness before calling this API
+ */
+
+static void odm_Process_RSSIForDM(struct _rtw_dm *pDM_Odm, struct _ODM_Phy_Status_Info_ *pPhyInfo,
+	struct _ODM_Per_Pkt_Info_ *pPktinfo);
+
+static void query_rxphystatus(struct _rtw_dm *	pDM_Odm, struct _ODM_Phy_Status_Info_ *pPhyInfo,
+	u8 *pPhyStatus, struct _ODM_Per_Pkt_Info_ *pPktinfo)
+{
+	struct rtl_priv *rtlpriv = pDM_Odm->rtlpriv;
+	struct rtl_dm *rtldm = rtl_dm(rtlpriv);
+	struct rtl_hal *rtlhal = rtl_hal(rtlpriv);
+	u8	i, Max_spatial_stream;
+	s8	rx_pwr[4], rx_pwr_all = 0;
+	u8	EVM, EVMdbm, PWDB_ALL = 0, PWDB_ALL_BT;
+	u8	RSSI, total_rssi = 0;
+	u8	isCCKrate = 0;
+	u8	rf_rx_num = 0;
+	u8	cck_highpwr = 0;
+	u8	LNA_idx, VGA_idx;
+
+	struct rw_fwinfo_8821au *pPhyStaRpt = (struct rw_fwinfo_8821au *) pPhyStatus;
+
+	if (pPktinfo->DataRate <= DESC_RATE54M) {
+		switch (pPhyStaRpt->r_RFMOD) {
+		case 1:
+			if (pPhyStaRpt->sub_chnl == 0)
+				pPhyInfo->BandWidth = 1;
+			else
+				pPhyInfo->BandWidth = 0;
+			break;
+
+		case 2:
+			if (pPhyStaRpt->sub_chnl == 0)
+				pPhyInfo->BandWidth = 2;
+			else if (pPhyStaRpt->sub_chnl == 9 || pPhyStaRpt->sub_chnl == 10)
+				pPhyInfo->BandWidth = 1;
+			else
+				pPhyInfo->BandWidth = 0;
+			break;
+
+		default:
+		case 0:
+			pPhyInfo->BandWidth = 0;
+			break;
+		}
+	}
+
+	if (pPktinfo->DataRate <= DESC_RATE11M)
+		isCCKrate = true;
+	else
+		isCCKrate = false;
+
+	pPhyInfo->RxMIMOSignalQuality[RF90_PATH_A] = -1;
+	pPhyInfo->RxMIMOSignalQuality[RF90_PATH_B] = -1;
+
+	if (isCCKrate) {
+		u8 cck_agc_rpt;
+
+		/*
+		 *  (1)Hardware does not provide RSSI for CCK
+		 *  (2)PWDB, Average PWDB cacluated by hardware (for rate adaptive)
+		 */
+
+		/* if (pHalData->eRFPowerState == eRfOn) */
+			cck_highpwr = rtlpriv->phy.cck_high_power;
+		/*
+		 * else
+		 * 	cck_highpwr = false;
+		 */
+
+		cck_agc_rpt =  pPhyStaRpt->cfosho[0] ;
+
+		LNA_idx = ((cck_agc_rpt & 0xE0) >> 5);
+		VGA_idx = (cck_agc_rpt & 0x1F);
+		if (IS_HARDWARE_TYPE_8812AU(rtlhal)) {
+			switch (LNA_idx) {
+			case 7:
+				if (VGA_idx <= 27)
+					rx_pwr_all = -100 + 2*(27-VGA_idx);	/* VGA_idx = 27~2 */
+				else
+					rx_pwr_all = -100;
+				break;
+
+			case 6:
+				rx_pwr_all = -48 + 2*(2-VGA_idx);	/* VGA_idx = 2~0 */
+				break;
+
+			case 5:
+				rx_pwr_all = -42 + 2*(7-VGA_idx);	/* VGA_idx = 7~5 */
+				break;
+
+			case 4:
+				rx_pwr_all = -36 + 2*(7-VGA_idx);	/* VGA_idx = 7~4 */
+				break;
+
+			case 3:
+				/* rx_pwr_all = -28 + 2*(7-VGA_idx); */	/* VGA_idx = 7~0 */
+				rx_pwr_all = -24 + 2*(7-VGA_idx); 	/* VGA_idx = 7~0 */
+				break;
+
+			case 2:
+				if (cck_highpwr)
+					rx_pwr_all = -12 + 2*(5-VGA_idx);	/* VGA_idx = 5~0 */
+				else
+					rx_pwr_all = -6 + 2*(5-VGA_idx);
+				break;
+			case 1:
+				rx_pwr_all = 8-2*VGA_idx;
+				break;
+			case 0:
+				rx_pwr_all = 14-2*VGA_idx;
+				break;
+			default:
+				/* DbgPrint("CCK Exception default\n"); */
+				break;
+			}
+			rx_pwr_all += 6;
+			PWDB_ALL = odm_QueryRxPwrPercentage(rx_pwr_all);
+			if (cck_highpwr == false) {
+				if (PWDB_ALL >= 80)
+					PWDB_ALL = ((PWDB_ALL-80)<<1)+((PWDB_ALL-80)>>1)+80;
+				else if ((PWDB_ALL <= 78) && (PWDB_ALL >= 20))
+					PWDB_ALL += 3;
+
+				if (PWDB_ALL > 100)
+					PWDB_ALL = 100;
+			}
+		} else if (IS_HARDWARE_TYPE_8821U(rtlhal)) {
+			s8 Pout = -6;
+
+			switch (LNA_idx) {
+			case 5:
+				rx_pwr_all = Pout - 32 - (2*VGA_idx);
+				break;
+			case 4:
+				rx_pwr_all = Pout - 24 - (2*VGA_idx);
+				break;
+			case 2:
+				rx_pwr_all = Pout - 11 - (2*VGA_idx);
+				break;
+			case 1:
+				rx_pwr_all = Pout + 5 - (2*VGA_idx);
+				break;
+			case 0:
+				rx_pwr_all = Pout + 21 - (2*VGA_idx);
+				break;
+			}
+			PWDB_ALL = odm_QueryRxPwrPercentage(rx_pwr_all);
+		}
+
+		pPhyInfo->RxPWDBAll = PWDB_ALL;
+		/*
+		 * if (pPktinfo->StationID == 0) {
+		 * 	DbgPrint("CCK: LNA_idx = %d, VGA_idx = %d, pPhyInfo->RxPWDBAll = %d\n",
+		 * 		LNA_idx, VGA_idx, pPhyInfo->RxPWDBAll);
+		 * }
+		 */
+		pPhyInfo->BTRxRSSIPercentage = PWDB_ALL;
+		pPhyInfo->RecvSignalPower = rx_pwr_all;
+		/*
+		 * (3) Get Signal Quality (EVM)
+		 */
+
+		if (pPktinfo->bPacketMatchBSSID) {
+			u8	SQ, SQ_rpt;
+
+			if (pPhyInfo->RxPWDBAll > 40) {
+				SQ = 100;
+			} else {
+				SQ_rpt = pPhyStaRpt->pwdb_all;
+
+				if (SQ_rpt > 64)
+					SQ = 0;
+				else if (SQ_rpt < 20)
+					SQ = 100;
+				else
+					SQ = ((64-SQ_rpt) * 100) / 44;
+
+			}
+
+			/* DbgPrint("cck SQ = %d\n", SQ); */
+			pPhyInfo->SignalQuality = SQ;
+			pPhyInfo->RxMIMOSignalQuality[RF90_PATH_A] = SQ;
+			pPhyInfo->RxMIMOSignalQuality[RF90_PATH_B] = -1;
+		}
+	} else {
+		/* is OFDM rate */
+
+		/*
+		 * (1)Get RSSI for OFDM rate
+		 */
+
+		for (i = RF90_PATH_A; i < ODM_RF_PATH_MAX; i++) {
+			/*
+			 *  2008/01/30 MH we will judge RF RX path now.
+			 * DbgPrint("pDM_Odm->RFPathRxEnable = %x\n", pDM_Odm->RFPathRxEnable);
+			 */
+			if (rtlpriv->dm.rfpath_rxenable[i]) {
+				rf_rx_num++;
+			}
+			/*
+			 * else
+			 * 	continue;
+			 */
+
+			/*
+			 * 2012.05.25 LukeLee: Testchip AGC report is wrong, it should be restored back to old formula in MP chip
+			 * if ((pDM_Odm->SupportICType & (ODM_RTL8812|ODM_RTL8821)) && (!pDM_Odm->bIsMPChip))
+			 */
+
+			 rx_pwr[i] = (pPhyStaRpt->gain_trsw[i]&0x7F) - 110;
+
+			/*
+			 * else
+			 * 	rx_pwr[i] = ((pPhyStaRpt->gain_trsw[i]& 0x3F)*2) - 110;  //OLD FORMULA
+			 */
+
+			pPhyInfo->RxPwr[i] = rx_pwr[i];
+
+			/* Translate DBM to percentage. */
+			RSSI = odm_QueryRxPwrPercentage(rx_pwr[i]);
+
+			total_rssi += RSSI;
+			/* RT_DISP(FRX, RX_PHY_SS, ("RF-%d RXPWR=%x RSSI=%d\n", i, rx_pwr[i], RSSI)); */
+
+
+
+			pPhyInfo->RxMIMOSignalStrength[i] = (u8) RSSI;
+
+			/* Get Rx snr value in DB */
+			pPhyInfo->RxSNR[i] = pPhyStaRpt->rxsnr[i]/2;
+
+			/*
+			 *  (2) CFO_short  & CFO_tail
+			 */
+
+			pPhyInfo->Cfo_short[i] = odm_Cfo((pPhyStaRpt->cfosho[i]));
+			pPhyInfo->Cfo_tail[i] = odm_Cfo((pPhyStaRpt->cfotail[i]));
+
+			/* Record Signal Strength for next packet */
+			if (pPktinfo->bPacketMatchBSSID) {
+				;
+			}
+		}
+
+
+		/*
+		 *  (3)PWDB, Average PWDB cacluated by hardware (for rate adaptive)
+		 *
+		 * 2012.05.25 LukeLee: Testchip AGC report is wrong, it should be restored back to old formula in MP chip
+		 */
+		if ((!IS_NORMAL_CHIP(rtlhal->version)))
+			rx_pwr_all = (pPhyStaRpt->pwdb_all & 0x7f) - 110;
+		else
+			rx_pwr_all = (((pPhyStaRpt->pwdb_all) >> 1) & 0x7f) - 110;	 /* OLD FORMULA */
+
+		PWDB_ALL_BT = PWDB_ALL = odm_QueryRxPwrPercentage(rx_pwr_all);
+
+
+		pPhyInfo->RxPWDBAll = PWDB_ALL;
+#if 0		/* Currently no value in rtlwifi for this */
+		RT_TRACE(rtlpriv, COMP_RSSI_MONITOR, DBG_LOUD, "ODM OFDM RSSI=%d\n",pPhyInfo->RxPWDBAll);
+#endif
+		pPhyInfo->BTRxRSSIPercentage = PWDB_ALL_BT;
+		pPhyInfo->RxPower = rx_pwr_all;
+		pPhyInfo->RecvSignalPower = rx_pwr_all;
+
+		/*
+		 * DbgPrint("OFDM: pPhyInfo->RxPWDBAll = %d, pPhyInfo->RxMIMOSignalStrength[0] = %d, pPhyInfo->RxMIMOSignalStrength[1] = %d\n",
+		 *	pPhyInfo->RxPWDBAll, pPhyInfo->RxMIMOSignalStrength[0], pPhyInfo->RxMIMOSignalStrength[1]);
+		 */
+
+
+		{	/* pMgntInfo->CustomerID != RT_CID_819x_Lenovo */
+			/*
+			 * (4)EVM of OFDM rate
+			 */
+
+			if ((pPktinfo->DataRate >= DESC_RATEMCS8)
+			 && (pPktinfo->DataRate <= DESC_RATEMCS15))
+				Max_spatial_stream = 2;
+			else if ((pPktinfo->DataRate >= DESC_RATEVHT2SS_MCS0)
+			      && (pPktinfo->DataRate <= DESC_RATEVHT2SS_MCS9))
+				Max_spatial_stream = 2;
+			else
+				Max_spatial_stream = 1;
+
+			for (i = 0; i < Max_spatial_stream; i++) {
+				/*
+				 *  Do not use shift operation like "rx_evmX >>= 1" because the compilor of free build environment
+				 *  fill most significant bit to "zero" when doing shifting operation which may change a negative
+				 *  value to positive one, then the dbm value (which is supposed to be negative)  is not correct anymore.
+				 */
+				EVM = odm_EVMdbToPercentage((pPhyStaRpt->rxevm[i]));	/* dbm */
+				EVMdbm = odm_EVMdbm_JaguarSeries(pPhyStaRpt->rxevm[i]);
+				/*
+				 * RT_DISP(FRX, RX_PHY_SQ, ("RXRATE=%x RXEVM=%x EVM=%s%d\n",
+				 * pPktinfo->DataRate, pPhyStaRpt->rxevm[i], "%", EVM));
+				 */
+
+				if (pPktinfo->bPacketMatchBSSID) {
+					if (i == RF90_PATH_A) {	/* Fill value in RFD, Get the first spatial stream only */
+						pPhyInfo->SignalQuality = EVM;
+					}
+					pPhyInfo->RxMIMOSignalQuality[i] = EVM;
+					pPhyInfo->RxMIMOEVMdbm[i] = EVMdbm;
+				}
+			}
+		}
+		/* 2 For dynamic ATC switch */
+			if (pPktinfo->bPacketMatchBSSID) {
+				/* 3 Update CFO report for path-A & path-B */
+				for (i = RF90_PATH_A; i < ODM_RF_PATH_MAX; i++) {
+					pDM_Odm->CFO_tail[i] = (int)pPhyStaRpt->cfotail[i];
+				}
+
+				/* 3 Update packet counter */
+				if (pDM_Odm->packetCount == 0xffffffff)
+					pDM_Odm->packetCount = 0;
+				else
+					pDM_Odm->packetCount++;
+
+				/*
+				 * ODM_RT_TRACE(pDM_Odm, ODM_COMP_DYNAMIC_ATC, DBG_LOUD,
+				 * 	("pPhyStaRpt->path_cfotail[i] = 0x%x, pDM_Odm->CFO_tail[i] = 0x%x\n", pPhyStaRpt->path_cfotail[0], pDM_Odm->CFO_tail[1]));
+				 */
+			}
+	}
+	/* DbgPrint("isCCKrate= %d, pPhyInfo->SignalStrength=%d % PWDB_AL=%d rf_rx_num=%d\n", isCCKrate, pPhyInfo->SignalStrength, PWDB_ALL, rf_rx_num); */
+
+	/*
+	 * UI BSS List signal strength(in percentage), make it good looking, from 0~100.
+	 * It is assigned to the BSS List in GetValueFromBeaconOrProbeRsp().
+	 */
+	if (isCCKrate) {
+		pPhyInfo->SignalStrength = (u8)(rtl_signal_scale_mapping(rtlpriv, PWDB_ALL));	/* PWDB_ALL; */
+	} else {
+		if (rf_rx_num != 0) {
+			/* ULLI crap inside this call */
+			pPhyInfo->SignalStrength = (u8)(rtl_signal_scale_mapping(rtlpriv, total_rssi /= rf_rx_num));
+		}
+	}
+	pDM_Odm->RxPWDBAve = pDM_Odm->RxPWDBAve + pPhyInfo->RxPWDBAll;
+
+	rtldm->fat_table.antsel_rx_keep_0 = pPhyStaRpt->antidx_anta;
+
+	/*
+	 * DbgPrint("pPhyStaRpt->antidx_anta = %d, pPhyStaRpt->antidx_antb = %d, pPhyStaRpt->resvd_1 = %d",
+	 * 	pPhyStaRpt->antidx_anta, pPhyStaRpt->antidx_antb, pPhyStaRpt->resvd_1);
+	 */
+
+	/*
+	 * DbgPrint("----------------------------\n");
+	 * DbgPrint("pPktinfo->StationID=%d, pPktinfo->DataRate=0x%x\n",pPktinfo->StationID, pPktinfo->DataRate);
+	 * DbgPrint("pPhyStaRpt->gain_trsw[0]=0x%x, pPhyStaRpt->gain_trsw[1]=0x%x, pPhyStaRpt->pwdb_all=0x%x\n",
+	 *	pPhyStaRpt->gain_trsw[0],pPhyStaRpt->gain_trsw[1], pPhyStaRpt->pwdb_all);
+	 * DbgPrint("pPhyInfo->RxMIMOSignalStrength[0]=%d, pPhyInfo->RxMIMOSignalStrength[1]=%d, RxPWDBAll=%d\n",
+	 *	pPhyInfo->RxMIMOSignalStrength[0], pPhyInfo->RxMIMOSignalStrength[1], pPhyInfo->RxPWDBAll);
+	 */
+	odm_Process_RSSIForDM(pDM_Odm, pPhyInfo, pPktinfo);
+}
+
+
+static void odm_Process_RSSIForDM(struct _rtw_dm *pDM_Odm, struct _ODM_Phy_Status_Info_ *pPhyInfo,
+	struct _ODM_Per_Pkt_Info_ *pPktinfo)
+{
+	struct rtl_priv *rtlpriv = pDM_Odm->rtlpriv;
+	struct rtl_dm *rtldm = rtl_dm(rtlpriv);
+	int32_t		UndecoratedSmoothedPWDB, UndecoratedSmoothedCCK, UndecoratedSmoothedOFDM, RSSI_Ave;
+	u8		isCCKrate = 0;
+	u8		RSSI_max, RSSI_min, i;
+	uint32_t	OFDM_pkt = 0;
+	uint32_t	Weighting = 0;
+
+	struct sta_info *pEntry;
+
+	if (pPktinfo->StationID == 0xFF)
+		return;
+
+	pEntry = rtldm->pODM_StaInfo[pPktinfo->StationID];
+
+	if (!IS_STA_VALID(pEntry)) {
+		return;
+	}
+	if ((!pPktinfo->bPacketMatchBSSID)) {
+		return;
+	}
+
+	if (pPktinfo->bPacketBeacon)
+		rtlpriv->dm.dbginfo.num_qry_beacon_pkt++;
+	isCCKrate = (pPktinfo->DataRate <= DESC_RATE11M) ? true : false;
+	pDM_Odm->RxRate = pPktinfo->DataRate;
+	/*
+	if (!isCCKrate)
+	{
+		DbgPrint("OFDM: pPktinfo->StationID=%d, isCCKrate=%d, pPhyInfo->RxPWDBAll=%d\n",
+			pPktinfo->StationID, isCCKrate, pPhyInfo->RxPWDBAll);
+	}
+	*/
+/*
+	if (pDM_Odm->SupportICType == ODM_RTL8812)
+	{
+		pPATHDIV_T	pDM_PathDiv = &pDM_Odm->DM_PathDiv;
+		if (pPktinfo->bPacketToSelf || pPktinfo->bPacketMatchBSSID)
+		{
+			if (pPktinfo->DataRate > DESC8812_RATE11M)
+				ODM_PathStatistics_8812A(pDM_Odm, pPktinfo->StationID,
+				pPhyInfo->RxMIMOSignalStrength[RF90_PATH_A], pPhyInfo->RxMIMOSignalStrength[RF90_PATH_B]);
+		}
+	}
+*/
+	/* -----------------Smart Antenna Debug Message------------------ */
+
+	UndecoratedSmoothedCCK =  pEntry->rssi_stat.UndecoratedSmoothedCCK;
+	UndecoratedSmoothedOFDM = pEntry->rssi_stat.UndecoratedSmoothedOFDM;
+	UndecoratedSmoothedPWDB = pEntry->rssi_stat.UndecoratedSmoothedPWDB;
+
+	if (pPktinfo->bPacketToSelf || pPktinfo->bPacketBeacon) {
+		if (!isCCKrate) {	/* ofdm rate */
+			if (pPhyInfo->RxMIMOSignalStrength[RF90_PATH_B] == 0) {
+				RSSI_Ave = pPhyInfo->RxMIMOSignalStrength[RF90_PATH_A];
+				pDM_Odm->RSSI_A = pPhyInfo->RxMIMOSignalStrength[RF90_PATH_A];
+				pDM_Odm->RSSI_B = 0;
+			} else{
+				/*
+				 * DbgPrint("pRfd->Status.RxMIMOSignalStrength[0] = %d, pRfd->Status.RxMIMOSignalStrength[1] = %d \n",
+				 * 	pRfd->Status.RxMIMOSignalStrength[0], pRfd->Status.RxMIMOSignalStrength[1]);
+				 */
+				pDM_Odm->RSSI_A =  pPhyInfo->RxMIMOSignalStrength[RF90_PATH_A];
+				pDM_Odm->RSSI_B = pPhyInfo->RxMIMOSignalStrength[RF90_PATH_B];
+
+				if (pPhyInfo->RxMIMOSignalStrength[RF90_PATH_A] > pPhyInfo->RxMIMOSignalStrength[RF90_PATH_B]) {
+					RSSI_max = pPhyInfo->RxMIMOSignalStrength[RF90_PATH_A];
+					RSSI_min = pPhyInfo->RxMIMOSignalStrength[RF90_PATH_B];
+				} else {
+					RSSI_max = pPhyInfo->RxMIMOSignalStrength[RF90_PATH_B];
+					RSSI_min = pPhyInfo->RxMIMOSignalStrength[RF90_PATH_A];
+				}
+
+				if ((RSSI_max - RSSI_min) < 3)
+					RSSI_Ave = RSSI_max;
+				else if ((RSSI_max - RSSI_min) < 6)
+					RSSI_Ave = RSSI_max - 1;
+				else if ((RSSI_max - RSSI_min) < 10)
+					RSSI_Ave = RSSI_max - 2;
+				else
+					RSSI_Ave = RSSI_max - 3;
+			}
+
+			/* 1 Process OFDM RSSI */
+			if (UndecoratedSmoothedOFDM <= 0) {
+				/* initialize */
+				UndecoratedSmoothedOFDM = pPhyInfo->RxPWDBAll;
+			} else {
+				if (pPhyInfo->RxPWDBAll > (uint32_t)UndecoratedSmoothedOFDM) {
+					UndecoratedSmoothedOFDM =
+						(((UndecoratedSmoothedOFDM)*(Rx_Smooth_Factor-1))
+						+ (RSSI_Ave)) / (Rx_Smooth_Factor);
+					UndecoratedSmoothedOFDM = UndecoratedSmoothedOFDM + 1;
+				} else {
+					UndecoratedSmoothedOFDM =
+						(((UndecoratedSmoothedOFDM)*(Rx_Smooth_Factor-1))
+						+ (RSSI_Ave)) / (Rx_Smooth_Factor);
+				}
+			}
+
+			pEntry->rssi_stat.PacketMap = (pEntry->rssi_stat.PacketMap<<1) | BIT(0);
+		} else {
+			RSSI_Ave = pPhyInfo->RxPWDBAll;
+			pDM_Odm->RSSI_A = (u8) pPhyInfo->RxPWDBAll;
+			pDM_Odm->RSSI_B = 0xFF;
+
+			/* 1 Process CCK RSSI */
+			if (UndecoratedSmoothedCCK <= 0)	{	/*  initialize */
+				UndecoratedSmoothedCCK = pPhyInfo->RxPWDBAll;
+			} else 	{
+				if (pPhyInfo->RxPWDBAll > (uint32_t)UndecoratedSmoothedCCK) {
+					UndecoratedSmoothedCCK =
+						(((UndecoratedSmoothedCCK)*(Rx_Smooth_Factor-1))
+						+ (pPhyInfo->RxPWDBAll)) / (Rx_Smooth_Factor);
+					UndecoratedSmoothedCCK = UndecoratedSmoothedCCK + 1;
+				} else {
+					UndecoratedSmoothedCCK =
+						(((UndecoratedSmoothedCCK)*(Rx_Smooth_Factor-1))
+						+ (pPhyInfo->RxPWDBAll)) / (Rx_Smooth_Factor);
+				}
+			}
+			pEntry->rssi_stat.PacketMap = pEntry->rssi_stat.PacketMap<<1;
+		}
+
+		/* if (pEntry) */
+		{
+			/* 2011.07.28 LukeLee: modified to prevent unstable CCK RSSI */
+			if (pEntry->rssi_stat.ValidBit >= 64)
+				pEntry->rssi_stat.ValidBit = 64;
+			else
+				pEntry->rssi_stat.ValidBit++;
+
+			for (i = 0; i < pEntry->rssi_stat.ValidBit; i++)
+				OFDM_pkt += (u8)(pEntry->rssi_stat.PacketMap>>i)&BIT(0);
+
+			if (pEntry->rssi_stat.ValidBit == 64) {
+				Weighting = ((OFDM_pkt<<4) > 64)?64:(OFDM_pkt<<4);
+				UndecoratedSmoothedPWDB = (Weighting*UndecoratedSmoothedOFDM+(64-Weighting)*UndecoratedSmoothedCCK)>>6;
+			} else {
+				if (pEntry->rssi_stat.ValidBit != 0)
+					UndecoratedSmoothedPWDB = (OFDM_pkt*UndecoratedSmoothedOFDM+(pEntry->rssi_stat.ValidBit-OFDM_pkt)*UndecoratedSmoothedCCK)/pEntry->rssi_stat.ValidBit;
+				else
+					UndecoratedSmoothedPWDB = 0;
+			}
+
+			pEntry->rssi_stat.UndecoratedSmoothedCCK = UndecoratedSmoothedCCK;
+			pEntry->rssi_stat.UndecoratedSmoothedOFDM = UndecoratedSmoothedOFDM;
+			pEntry->rssi_stat.UndecoratedSmoothedPWDB = UndecoratedSmoothedPWDB;
+
+			/*
+			 * DbgPrint("OFDM_pkt=%d, Weighting=%d\n", OFDM_pkt, Weighting);
+			 * DbgPrint("UndecoratedSmoothedOFDM=%d, UndecoratedSmoothedPWDB=%d, UndecoratedSmoothedCCK=%d\n",
+			 * 	UndecoratedSmoothedOFDM, UndecoratedSmoothedPWDB, UndecoratedSmoothedCCK);
+			 */
+
+		}
+
+	}
+}
+
+static int32_t  translate2dbm(uint8_t signal_strength_idx)
+{
+	int32_t	signal_power; // in dBm.
+
+
+	// Translate to dBm (x=0.5y-95).
+	signal_power = (int32_t)((signal_strength_idx + 1) >> 1);
+	signal_power -= 95;
+
+	return signal_power;
+}
+
+
+static void process_rssi(struct rtl_priv *rtlpriv,struct recv_frame *prframe)
+{
+	struct rx_pkt_attrib *pattrib = &prframe->attrib;
+#ifdef CONFIG_NEW_SIGNAL_STAT_PROCESS
+	struct signal_stat * signal_stat = &rtlpriv->recvpriv.signal_strength_data;
+#endif //CONFIG_NEW_SIGNAL_STAT_PROCESS
+
+	//DBG_8192C("process_rssi=> pattrib->rssil(%d) signal_strength(%d)\n ",pattrib->RecvSignalPower,pattrib->signal_strength);
+	//if(pRfd->Status.bPacketToSelf || pRfd->Status.bPacketBeacon)
+	{
+
+	#ifdef CONFIG_NEW_SIGNAL_STAT_PROCESS
+		if(signal_stat->update_req) {
+			signal_stat->total_num = 0;
+			signal_stat->total_val = 0;
+			signal_stat->update_req = 0;
+		}
+
+		signal_stat->total_num++;
+		signal_stat->total_val  += pattrib->phy_info.SignalStrength;
+		signal_stat->avg_val = signal_stat->total_val / signal_stat->total_num;
+	#else //CONFIG_NEW_SIGNAL_STAT_PROCESS
+
+		//rtlpriv->RxStats.RssiCalculateCnt++;	//For antenna Test
+		if(rtlpriv->recvpriv.signal_strength_data.total_num++ >= PHY_RSSI_SLID_WIN_MAX)
+		{
+			rtlpriv->recvpriv.signal_strength_data.total_num = PHY_RSSI_SLID_WIN_MAX;
+			last_rssi = rtlpriv->recvpriv.signal_strength_data.elements[rtlpriv->recvpriv.signal_strength_data.index];
+			rtlpriv->recvpriv.signal_strength_data.total_val -= last_rssi;
+		}
+		rtlpriv->recvpriv.signal_strength_data.total_val  +=pattrib->phy_info.SignalStrength;
+
+		rtlpriv->recvpriv.signal_strength_data.elements[rtlpriv->recvpriv.signal_strength_data.index++] = pattrib->phy_info.SignalStrength;
+		if(rtlpriv->recvpriv.signal_strength_data.index >= PHY_RSSI_SLID_WIN_MAX)
+			rtlpriv->recvpriv.signal_strength_data.index = 0;
+
+
+		tmp_val = rtlpriv->recvpriv.signal_strength_data.total_val/rtlpriv->recvpriv.signal_strength_data.total_num;
+
+		if(rtlpriv->recvpriv.is_signal_dbg) {
+			rtlpriv->recvpriv.signal_strength= rtlpriv->recvpriv.signal_strength_dbg;
+			rtlpriv->recvpriv.rssi=(s8)translate2dbm((uint8_t)rtlpriv->recvpriv.signal_strength_dbg);
+		} else {
+			rtlpriv->recvpriv.signal_strength= tmp_val;
+			rtlpriv->recvpriv.rssi=(s8)translate2dbm((uint8_t)tmp_val);
+		}
+
+		RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("UI RSSI = %d, ui_rssi.TotalVal = %d, ui_rssi.TotalNum = %d\n", tmp_val, rtlpriv->recvpriv.signal_strength_data.total_val,rtlpriv->recvpriv.signal_strength_data.total_num));
+	#endif //CONFIG_NEW_SIGNAL_STAT_PROCESS
+	}
+
+}// Process_UI_RSSI_8192C
+
+
+
+static void process_link_qual(struct rtl_priv *rtlpriv,struct recv_frame *prframe)
+{
+ 	struct rx_pkt_attrib *pattrib;
+#ifdef CONFIG_NEW_SIGNAL_STAT_PROCESS
+	struct signal_stat * signal_stat;
+#endif //CONFIG_NEW_SIGNAL_STAT_PROCESS
+
+	if(prframe == NULL || rtlpriv==NULL){
+		return;
+	}
+
+	pattrib = &prframe->attrib;
+#ifdef CONFIG_NEW_SIGNAL_STAT_PROCESS
+	signal_stat = &rtlpriv->recvpriv.signal_qual_data;
+#endif //CONFIG_NEW_SIGNAL_STAT_PROCESS
+
+	//DBG_8192C("process_link_qual=> pattrib->signal_qual(%d)\n ",pattrib->signal_qual);
+
+#ifdef CONFIG_NEW_SIGNAL_STAT_PROCESS
+	if(signal_stat->update_req) {
+		signal_stat->total_num = 0;
+		signal_stat->total_val = 0;
+		signal_stat->update_req = 0;
+	}
+
+	signal_stat->total_num++;
+	signal_stat->total_val  += pattrib->phy_info.SignalQuality;
+	signal_stat->avg_val = signal_stat->total_val / signal_stat->total_num;
+
+#else //CONFIG_NEW_SIGNAL_STAT_PROCESS
+	if(pattrib->phy_info.SignalQuality != 0)
+	{
+			//
+			// 1. Record the general EVM to the sliding window.
+			//
+			if(rtlpriv->recvpriv.signal_qual_data.total_num++ >= PHY_LINKQUALITY_SLID_WIN_MAX)
+			{
+				rtlpriv->recvpriv.signal_qual_data.total_num = PHY_LINKQUALITY_SLID_WIN_MAX;
+				last_evm = rtlpriv->recvpriv.signal_qual_data.elements[rtlpriv->recvpriv.signal_qual_data.index];
+				rtlpriv->recvpriv.signal_qual_data.total_val -= last_evm;
+			}
+			rtlpriv->recvpriv.signal_qual_data.total_val += pattrib->phy_info.SignalQuality;
+
+			rtlpriv->recvpriv.signal_qual_data.elements[rtlpriv->recvpriv.signal_qual_data.index++] = pattrib->phy_info.SignalQuality;
+			if(rtlpriv->recvpriv.signal_qual_data.index >= PHY_LINKQUALITY_SLID_WIN_MAX)
+				rtlpriv->recvpriv.signal_qual_data.index = 0;
+
+			RT_TRACE(_module_rtl871x_recv_c_,_drv_info_,("Total SQ=%d  pattrib->signal_qual= %d\n", rtlpriv->recvpriv.signal_qual_data.total_val, pattrib->phy_info.SignalQuality));
+
+			// <1> Showed on UI for user, in percentage.
+			tmpVal = rtlpriv->recvpriv.signal_qual_data.total_val/rtlpriv->recvpriv.signal_qual_data.total_num;
+			rtlpriv->recvpriv.signal_qual=(uint8_t)tmpVal;
+
+	}
+	else
+	{
+		RT_TRACE(_module_rtl871x_recv_c_,_drv_err_,(" pattrib->signal_qual =%d\n", pattrib->phy_info.SignalQuality));
+	}
+#endif //CONFIG_NEW_SIGNAL_STAT_PROCESS
+
+}
+
+static void process_phy_info(struct rtl_priv *rtlpriv, struct recv_frame *precvframe)
+{
+
+	//
+	// Check RSSI
+	//
+	process_rssi(rtlpriv, precvframe);
+	//
+	// Check PWDB.
+	//
+	//process_PWDB(rtlpriv, precvframe);
+
+	//UpdateRxSignalStatistics8192C(rtlpriv, pRfd);
+	//
+	// Check EVM
+	//
+	process_link_qual(rtlpriv,  precvframe);
+
+}
+
+void rtl8812_query_rx_desc_status(struct rtl_priv *rtlpriv,
+				   struct rx_pkt_attrib	*pattrib,
+				   struct recv_frame *precvframe, uint8_t *pdesc)
+{
+	memset(pattrib, 0, sizeof(struct rx_pkt_attrib));
+
+	//Offset 0
+	pattrib->pkt_len = (u16)GET_RX_STATUS_DESC_PKT_LEN(pdesc);//(le32_to_cpu(pdesc->rxdw0)&0x00003fff)
+	pattrib->crc_err = (uint8_t)GET_RX_STATUS_DESC_CRC32(pdesc);//((le32_to_cpu(pdesc->rxdw0) >> 14) & 0x1);
+	pattrib->icv_err = (uint8_t)GET_RX_STATUS_DESC_ICV(pdesc);//((le32_to_cpu(pdesc->rxdw0) >> 15) & 0x1);
+	pattrib->drvinfo_sz = (uint8_t)GET_RX_STATUS_DESC_DRVINFO_SIZE(pdesc) * 8;//((le32_to_cpu(pdesc->rxdw0) >> 16) & 0xf) * 8;//uint 2^3 = 8 bytes
+	pattrib->encrypt = (uint8_t)GET_RX_STATUS_DESC_SECURITY(pdesc);//((le32_to_cpu(pdesc->rxdw0) >> 20) & 0x7);
+	pattrib->qos = (uint8_t)GET_RX_STATUS_DESC_QOS(pdesc);//(( le32_to_cpu( pdesc->rxdw0 ) >> 23) & 0x1);// Qos data, wireless lan header length is 26
+	pattrib->shift_sz = (uint8_t)GET_RX_STATUS_DESC_SHIFT(pdesc);//((le32_to_cpu(pdesc->rxdw0) >> 24) & 0x3);
+	pattrib->physt = (uint8_t)GET_RX_STATUS_DESC_PHY_STATUS(pdesc);//((le32_to_cpu(pdesc->rxdw0) >> 26) & 0x1);
+	pattrib->bdecrypted = !GET_RX_STATUS_DESC_SWDEC(pdesc);//(le32_to_cpu(pdesc->rxdw0) & BIT(27))? 0:1;
+
+	//Offset 4
+	pattrib->priority = (uint8_t)GET_RX_STATUS_DESC_TID(pdesc);//((le32_to_cpu(pdesc->rxdw1) >> 8) & 0xf);
+	pattrib->mdata = (uint8_t)GET_RX_STATUS_DESC_MORE_DATA(pdesc);//((le32_to_cpu(pdesc->rxdw1) >> 26) & 0x1);
+	pattrib->mfrag = (uint8_t)GET_RX_STATUS_DESC_MORE_FRAG(pdesc);//((le32_to_cpu(pdesc->rxdw1) >> 27) & 0x1);//more fragment bit
+
+	//Offset 8
+	pattrib->seq_num = (u16)GET_RX_STATUS_DESC_SEQ(pdesc);//(le32_to_cpu(pdesc->rxdw2) & 0x00000fff);
+	pattrib->frag_num = (uint8_t)GET_RX_STATUS_DESC_FRAG(pdesc);//((le32_to_cpu(pdesc->rxdw2) >> 12) & 0xf);//fragmentation number
+
+	if (GET_RX_STATUS_DESC_RPT_SEL(pdesc))
+		pattrib->pkt_rpt_type = C2H_PACKET;
+	else
+		pattrib->pkt_rpt_type = NORMAL_RX;
+
+	//Offset 12
+	pattrib->data_rate=(uint8_t)GET_RX_STATUS_DESC_RX_RATE(pdesc);//((le32_to_cpu(pdesc->rxdw3))&0x7f);
+
+	//Offset 16
+	//Offset 20
+
+}
+
+
+/*
+ * Notice:
+ *	Before calling this function,
+ *	precvframe->u.hdr.rx_data should be ready!
+ */
+void rtl8812_query_rx_phy_status(
+	struct recv_frame	*precvframe,
+	uint8_t 				*pphy_status)
+{
+	struct rtl_priv *			rtlpriv = precvframe->rtlpriv;
+	struct rx_pkt_attrib	*pattrib = &precvframe->attrib;
+	 struct _rtw_hal		*pHalData = GET_HAL_DATA(rtlpriv);
+	struct _ODM_Phy_Status_Info_ *pPHYInfo  = (struct _ODM_Phy_Status_Info_ *) (&pattrib->phy_info);
+	uint8_t					*wlanhdr;
+	struct _ODM_Per_Pkt_Info_ pkt_info;
+	uint8_t *sa;
+	struct sta_priv *pstapriv;
+	struct sta_info *psta;
+	//_irqL		irqL;
+
+	pkt_info.bPacketMatchBSSID =false;
+	pkt_info.bPacketToSelf = false;
+	pkt_info.bPacketBeacon = false;
+
+	wlanhdr = get_recvframe_data(precvframe);
+
+	pkt_info.bPacketMatchBSSID = ((!IsFrameTypeCtrl(wlanhdr)) &&
+		!pattrib->icv_err && !pattrib->crc_err &&
+		memcmp(get_hdr_bssid(wlanhdr), get_bssid(&rtlpriv->mlmepriv), ETH_ALEN) == 0);
+
+	pkt_info.bPacketToSelf = pkt_info.bPacketMatchBSSID &&
+				(memcmp(get_da(wlanhdr), rtlpriv->mac80211.mac_addr, ETH_ALEN) == 0);
+
+	pkt_info.bPacketBeacon = pkt_info.bPacketMatchBSSID && (GetFrameSubType(wlanhdr) == WIFI_BEACON);
+
+	if(pkt_info.bPacketBeacon){
+		if(check_fwstate(&rtlpriv->mlmepriv, WIFI_STATION_STATE) == true){
+			sa = rtlpriv->mlmepriv.cur_network.network.MacAddress;
+			#if 0
+			{
+				DBG_8192C("==> rx beacon from AP[%02x:%02x:%02x:%02x:%02x:%02x]\n",
+					sa[0],sa[1],sa[2],sa[3],sa[4],sa[5]);
+			}
+			#endif
+		}
+		//to do Ad-hoc
+	}
+	else{
+		sa = get_sa(wlanhdr);
+	}
+
+	pstapriv = &rtlpriv->stapriv;
+	pkt_info.StationID = 0xFF;
+	psta = rtw_get_stainfo(pstapriv, sa);
+	if (psta)
+	{
+		pkt_info.StationID = psta->mac_id;
+		//DBG_8192C("%s ==> StationID(%d)\n",__FUNCTION__,pkt_info.StationID);
+	}
+	pkt_info.DataRate = pattrib->data_rate;
+	//rtl8188e_query_rx_phy_status(precvframe, pphy_status);
+
+	//spin_lock_bh(&pHalData->odm_stainfo_lock, &irqL);
+	query_rxphystatus(&pHalData->odmpriv,pPHYInfo,pphy_status,&(pkt_info));
+	//spin_unlock_bh(&pHalData->odm_stainfo_lock, &irqL);
+
+	precvframe->psta = NULL;
+	if (pkt_info.bPacketMatchBSSID &&
+		(check_fwstate(&rtlpriv->mlmepriv, WIFI_AP_STATE) == true))
+	{
+		if (psta)
+		{
+			precvframe->psta = psta;
+			process_phy_info(rtlpriv, precvframe);
+
+		}
+	}
+	else if (pkt_info.bPacketToSelf || pkt_info.bPacketBeacon)
+	{
+		if (check_fwstate(&rtlpriv->mlmepriv, WIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE) == true)
+		{
+			if (psta)
+			{
+				precvframe->psta = psta;
+			}
+		}
+		process_phy_info(rtlpriv, precvframe);
+	}
+}
+
+
+
+static void _ConfigChipOutEP_8812(struct rtl_priv *rtlpriv, uint8_t NumOutPipe)
+{
+	struct rtl_usb  *rtlusb = rtl_usbdev(rtlpriv);
+
+	rtlusb->out_queue_sel = 0;
+
+	switch (NumOutPipe) {
+	case 	4:
+		rtlusb->out_queue_sel = TX_SELE_HQ | TX_SELE_LQ | TX_SELE_NQ;
+		break;
+	case 	3:
+		rtlusb->out_queue_sel = TX_SELE_HQ | TX_SELE_LQ | TX_SELE_NQ;
+		break;
+	case 	2:
+		rtlusb->out_queue_sel = TX_SELE_HQ | TX_SELE_NQ;
+		break;
+	case 	1:
+		rtlusb->out_queue_sel = TX_SELE_HQ;
+		break;
+	default:
+		break;
+
+	}
+	RT_TRACE(rtlpriv, COMP_INIT, DBG_EMERG, "Tx queue select :0x%02x..\n",
+		 rtlusb->out_queue_sel);
+}
+
+
+/* endpoint mapping */
+
+static void _OneOutEpMapping(struct rtl_ep_map *ep_map)
+{
+	/* typical setting */
+
+	ep_map->ep_mapping[RTL_TXQ_BE]	= 2;
+	ep_map->ep_mapping[RTL_TXQ_BK]	= 2;
+	ep_map->ep_mapping[RTL_TXQ_VI]	= 2;
+	ep_map->ep_mapping[RTL_TXQ_VO] = 2;
+	ep_map->ep_mapping[RTL_TXQ_MGT] = 2;
+	ep_map->ep_mapping[RTL_TXQ_BCN] = 2;
+	ep_map->ep_mapping[RTL_TXQ_HI]	= 2;
+}
+
+static void _TwoOutEpMapping(struct rtl_ep_map *ep_map)
+{
+	/* typical setting */
+
+	ep_map->ep_mapping[RTL_TXQ_BE]	= 3;
+	ep_map->ep_mapping[RTL_TXQ_BK]	= 3;
+	ep_map->ep_mapping[RTL_TXQ_VI]	= 2;
+	ep_map->ep_mapping[RTL_TXQ_VO]	= 2;
+	ep_map->ep_mapping[RTL_TXQ_MGT] = 2;
+	ep_map->ep_mapping[RTL_TXQ_BCN] = 2;
+	ep_map->ep_mapping[RTL_TXQ_HI]	= 2;
+}
+
+static void _ThreeOutEpMapping(struct rtl_ep_map *ep_map)
+{
+	/* typical setting */
+
+	ep_map->ep_mapping[RTL_TXQ_BE]	= 4;
+	ep_map->ep_mapping[RTL_TXQ_BK]	= 4;
+	ep_map->ep_mapping[RTL_TXQ_VI]	= 3;
+	ep_map->ep_mapping[RTL_TXQ_VO]	= 2;
+	ep_map->ep_mapping[RTL_TXQ_MGT] = 2;
+	ep_map->ep_mapping[RTL_TXQ_BCN] = 2;
+	ep_map->ep_mapping[RTL_TXQ_HI]	= 2;
+}
+
+static void _FourOutEpMapping(struct rtl_ep_map *ep_map)
+{
+	/* typical setting */
+
+	ep_map->ep_mapping[RTL_TXQ_BE]	= 8;
+	ep_map->ep_mapping[RTL_TXQ_BK]	= 8;
+	ep_map->ep_mapping[RTL_TXQ_VI]	= 6;
+	ep_map->ep_mapping[RTL_TXQ_VO]	= 5;
+	ep_map->ep_mapping[RTL_TXQ_MGT] = 5;
+	ep_map->ep_mapping[RTL_TXQ_BCN] = 5;
+	ep_map->ep_mapping[RTL_TXQ_HI]	= 5;
+}
+
+static bool Hal_MappingOutPipe(struct rtl_priv *rtlpriv, uint8_t NumOutPipe)
+{
+	struct rtl_usb *rtlusb = rtl_usbdev(rtlpriv);
+	struct rtl_ep_map *ep_map = &(rtlusb->ep_map);
+	bool result = true;
+
+	switch(NumOutPipe) {
+	case 2:
+		_TwoOutEpMapping(ep_map);
+		break;
+	case 3:
+		_ThreeOutEpMapping(ep_map);
+		break;
+	case 4:
+		_FourOutEpMapping(ep_map);
+		break;
+	case 1:
+		_OneOutEpMapping(ep_map);
+		break;
+	default:
+		result = false;
+		break;
+	}
+
+	return result;
+
+}
+
+
+int rtl8821au_endpoint_mapping(struct rtl_priv *rtlpriv)
+{
+	struct rtl_usb	*rtlusb = rtl_usbdev(rtlpriv);
+	bool		result		= false;
+
+	_ConfigChipOutEP_8812(rtlpriv, rtlusb->RtNumOutPipes);
+
+	/* Normal chip with one IN and one OUT doesn't have interrupt IN EP. */
+	if (1 == rtlusb->RtNumOutPipes) {
+		if (1 != rtlusb->RtNumInPipes) {
+			return result;
+		}
+	}
+
+	/*
+	 * All config other than above support one Bulk IN and one Interrupt IN.
+	 * if (2 != NumInPipe){
+	 * 	return result;
+	 * }
+	 */
+
+	result = Hal_MappingOutPipe(rtlpriv, rtlusb->RtNumOutPipes);
+
+	return result;
+
+}
+
diff -Naur linux-4.9/drivers/staging/rtl8821au/rtl8821au/trx.h linux-4.9.8821au/drivers/staging/rtl8821au/rtl8821au/trx.h
--- linux-4.9/drivers/staging/rtl8821au/rtl8821au/trx.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/rtl8821au/trx.h	2016-12-11 19:48:25.186978326 -0600
@@ -0,0 +1,477 @@
+#ifndef __RTL8821AU_TRX_H__
+#define __RTL8821AU_TRX_H__
+
+void rtl8821au_fill_fake_txdesc(struct rtl_priv *rtlpriv, uint8_t *pDesc,
+	uint32_t BufferLen, uint8_t IsPsPoll, uint8_t IsBTQosNull);
+
+int32_t rtl8812au_mgnt_xmit(struct rtl_priv *rtlpriv, struct xmit_frame *pmgntframe);
+int32_t rtl8812au_hal_xmit(struct rtl_priv *rtlpriv, struct xmit_frame *pxmitframe);
+int32_t	 rtl8812au_hal_xmitframe_enqueue(struct rtl_priv *rtlpriv, struct xmit_frame *pxmitframe);
+int32_t rtl8812au_xmitframe_complete(struct rtl_priv *rtlpriv, struct xmit_priv *pxmitpriv, struct xmit_buf *pxmitbuf);
+
+void rtl8812_query_rx_desc_status(struct rtl_priv *rtlpriv,
+				   struct rx_pkt_attrib	*pattrib,
+				   struct recv_frame *precvframe, uint8_t *pdesc);
+void rtl8812_query_rx_phy_status(struct recv_frame *prframe, uint8_t *pphy_stat);
+int rtl8821au_endpoint_mapping(struct rtl_priv *rtlpriv);
+void _dbg_dump_tx_info(struct rtl_priv	*rtlpriv,int frame_tag,u8 *ptxdesc);
+
+
+/* TX desc macros */
+
+// Dword 0
+#define GET_TX_DESC_OWN(__pdesc)				\
+	LE_BITS_TO_4BYTE(__pdesc, 31, 1)
+#define SET_TX_DESC_PKT_SIZE(__pdesc, __Value) 		\
+	SET_BITS_TO_LE_4BYTE(__pdesc, 0, 16, __Value)
+#define SET_TX_DESC_OFFSET(__pdesc, __Value) 		\
+	SET_BITS_TO_LE_4BYTE(__pdesc, 16, 8, __Value)
+#define SET_TX_DESC_BMC(__pdesc, __Value) 		\
+	SET_BITS_TO_LE_4BYTE(__pdesc, 24, 1, __Value)
+#define SET_TX_DESC_HTC(__pdesc, __Value) 		\
+	SET_BITS_TO_LE_4BYTE(__pdesc, 25, 1, __Value)
+#define SET_TX_DESC_LAST_SEG(__pdesc, __Value) 		\
+	SET_BITS_TO_LE_4BYTE(__pdesc, 26, 1, __Value)
+#define SET_TX_DESC_FIRST_SEG(__pdesc, __Value) 		\
+	SET_BITS_TO_LE_4BYTE(__pdesc, 27, 1, __Value)
+#define SET_TX_DESC_LINIP(__pdesc, __Value) 		\
+	SET_BITS_TO_LE_4BYTE(__pdesc, 28, 1, __Value)
+#define SET_TX_DESC_NO_ACM(__pdesc, __Value) 		\
+	SET_BITS_TO_LE_4BYTE(__pdesc, 29, 1, __Value)
+#define SET_TX_DESC_GF(__pdesc, __Value) 		\
+	SET_BITS_TO_LE_4BYTE(__pdesc, 30, 1, __Value)
+#define SET_TX_DESC_OWN(__pdesc, __Value) 		\
+	SET_BITS_TO_LE_4BYTE(__pdesc, 31, 1, __Value)
+
+// Dword 1
+#define SET_TX_DESC_MACID(__pdesc, __Value) 		\
+	SET_BITS_TO_LE_4BYTE(__pdesc+4, 0, 7, __Value)
+#define SET_TX_DESC_QUEUE_SEL(__pdesc, __Value) 		\
+	SET_BITS_TO_LE_4BYTE(__pdesc+4, 8, 5, __Value)
+#define SET_TX_DESC_RDG_NAV_EXT(__pdesc, __Value) 	\
+	SET_BITS_TO_LE_4BYTE(__pdesc+4, 13, 1, __Value)
+#define SET_TX_DESC_LSIG_TXOP_EN(__pdesc, __Value) 	\
+	SET_BITS_TO_LE_4BYTE(__pdesc+4, 14, 1, __Value)
+#define SET_TX_DESC_PIFS(__pdesc, __Value) 		\
+	SET_BITS_TO_LE_4BYTE(__pdesc+4, 15, 1, __Value)
+#define SET_TX_DESC_RATE_ID(__pdesc, __Value) 		\
+	SET_BITS_TO_LE_4BYTE(__pdesc+4, 16, 5, __Value)
+#define SET_TX_DESC_EN_DESC_ID(__pdesc, __Value) 	\
+	SET_BITS_TO_LE_4BYTE(__pdesc+4, 21, 1, __Value)
+#define SET_TX_DESC_SEC_TYPE(__pdesc, __Value) 		\
+	SET_BITS_TO_LE_4BYTE(__pdesc+4, 22, 2, __Value)
+#define SET_TX_DESC_PKT_OFFSET(__pdesc, __Value) 	\
+	SET_BITS_TO_LE_4BYTE(__pdesc+4, 24, 5, __Value)
+
+// Dword 2
+#define SET_TX_DESC_PAID(__pdesc, __Value) 		\
+	SET_BITS_TO_LE_4BYTE(__pdesc+8, 0,  9, __Value)
+#define SET_TX_DESC_CCA_RTS(__pdesc, __Value) 		\
+	SET_BITS_TO_LE_4BYTE(__pdesc+8, 10, 2, __Value)
+#define SET_TX_DESC_AGG_ENABLE(__pdesc, __Value)		\
+	SET_BITS_TO_LE_4BYTE(__pdesc+8, 12, 1, __Value)
+#define SET_TX_DESC_RDG_ENABLE(__pdesc, __Value) 	\
+	SET_BITS_TO_LE_4BYTE(__pdesc+8, 13, 1, __Value)
+#define SET_TX_DESC_AGG_BREAK(__pdesc, __Value)		\
+	SET_BITS_TO_LE_4BYTE(__pdesc+8, 16, 1, __Value)
+#define SET_TX_DESC_MORE_FRAG(__pdesc, __Value) 		\
+	SET_BITS_TO_LE_4BYTE(__pdesc+8, 17, 1, __Value)
+#define SET_TX_DESC_RAW(__pdesc, __Value) 		\
+	SET_BITS_TO_LE_4BYTE(__pdesc+8, 18, 1, __Value)
+#define SET_TX_DESC_SPE_RPT(__pdesc, __Value) 		\
+	SET_BITS_TO_LE_4BYTE(__pdesc+8, 19, 1, __Value)
+#define SET_TX_DESC_AMPDU_DENSITY(__pdesc, __Value) 	\
+	SET_BITS_TO_LE_4BYTE(__pdesc+8, 20, 3, __Value)
+#define SET_TX_DESC_BT_INT(__pdesc, __Value) 		\
+	SET_BITS_TO_LE_4BYTE(__pdesc+8, 23, 1, __Value)
+#define SET_TX_DESC_GID(__pdesc, __Value) 		\
+	SET_BITS_TO_LE_4BYTE(__pdesc+8, 24, 6, __Value)
+
+// Dword 3
+#define SET_TX_DESC_WHEADER_LEN(__pdesc, __Value) 	\
+	SET_BITS_TO_LE_4BYTE(__pdesc+12, 0, 4, __Value)
+#define SET_TX_DESC_CHK_EN(__pdesc, __Value) 		\
+	SET_BITS_TO_LE_4BYTE(__pdesc+12, 4, 1, __Value)
+#define SET_TX_DESC_EARLY_MODE(__pdesc, __Value) 	\
+	SET_BITS_TO_LE_4BYTE(__pdesc+12, 5, 1, __Value)
+#define SET_TX_DESC_HWSEQ_SEL(__pdesc, __Value) 		\
+	SET_BITS_TO_LE_4BYTE(__pdesc+12, 6, 2, __Value)
+#define SET_TX_DESC_USE_RATE(__pdesc, __Value) 		\
+	SET_BITS_TO_LE_4BYTE(__pdesc+12, 8, 1, __Value)
+#define SET_TX_DESC_DISABLE_RTS_FB(__pdesc, __Value)	\
+	SET_BITS_TO_LE_4BYTE(__pdesc+12, 9, 1, __Value)
+#define SET_TX_DESC_DISABLE_FB(__pdesc, __Value)		\
+	SET_BITS_TO_LE_4BYTE(__pdesc+12, 10, 1, __Value)
+#define SET_TX_DESC_CTS2SELF(__pdesc, __Value) 		\
+	SET_BITS_TO_LE_4BYTE(__pdesc+12, 11, 1, __Value)
+#define SET_TX_DESC_RTS_ENABLE(__pdesc, __Value) 	\
+	SET_BITS_TO_LE_4BYTE(__pdesc+12, 12, 1, __Value)
+#define SET_TX_DESC_HW_RTS_ENABLE(__pdesc, __Value) 	\
+	SET_BITS_TO_LE_4BYTE(__pdesc+12, 13, 1, __Value)
+#define SET_TX_DESC_NAV_USE_HDR(__pdesc, __Value) 	\
+	SET_BITS_TO_LE_4BYTE(__pdesc+12, 15, 1, __Value)
+#define SET_TX_DESC_USE_MAX_LEN(__pdesc, __Value) 	\
+	SET_BITS_TO_LE_4BYTE(__pdesc+12, 16, 1, __Value)
+#define SET_TX_DESC_MAX_AGG_NUM(__pdesc, __Value) 	\
+	SET_BITS_TO_LE_4BYTE(__pdesc+12, 17, 5, __Value)
+#define SET_TX_DESC_NDPA(__pdesc, __Value) 		\
+	SET_BITS_TO_LE_4BYTE(__pdesc+12, 22, 2, __Value)
+#define SET_TX_DESC_AMPDU_MAX_TIME(__pdesc, __Value)	\
+	SET_BITS_TO_LE_4BYTE(__pdesc+12, 24, 8, __Value)
+
+// Dword 4
+#define SET_TX_DESC_TX_RATE(__pdesc, __Value) 		\
+	SET_BITS_TO_LE_4BYTE(__pdesc+16, 0, 7, __Value)
+#define SET_TX_DESC_DATA_RATE_FB_LIMIT(__pdesc, __Value) \
+	SET_BITS_TO_LE_4BYTE(__pdesc+16, 8, 5, __Value)
+#define SET_TX_DESC_RTS_RATE_FB_LIMIT(__pdesc, __Value) 	\
+	SET_BITS_TO_LE_4BYTE(__pdesc+16, 13, 4, __Value)
+#define SET_TX_DESC_RETRY_LIMIT_ENABLE(__pdesc, __Value) 	\
+	SET_BITS_TO_LE_4BYTE(__pdesc+16, 17, 1, __Value)
+#define SET_TX_DESC_DATA_RETRY_LIMIT(__pdesc, __Value) 	\
+	SET_BITS_TO_LE_4BYTE(__pdesc+16, 18, 6, __Value)
+#define SET_TX_DESC_RTS_RATE(__pdesc, __Value) 		\
+	SET_BITS_TO_LE_4BYTE(__pdesc+16, 24, 5, __Value)
+
+// Dword 5
+#define SET_TX_DESC_DATA_SC(__pdesc, __Value) 		\
+	SET_BITS_TO_LE_4BYTE(__pdesc+20, 0, 4, __Value)
+#define SET_TX_DESC_DATA_SHORT(__pdesc, __Value) 	\
+	SET_BITS_TO_LE_4BYTE(__pdesc+20, 4, 1, __Value)
+#define SET_TX_DESC_DATA_BW(__pdesc, __Value) 		\
+	SET_BITS_TO_LE_4BYTE(__pdesc+20, 5, 2, __Value)
+#define SET_TX_DESC_DATA_LDPC(__pdesc, __Value) 		\
+	SET_BITS_TO_LE_4BYTE(__pdesc+20, 7, 1, __Value)
+#define SET_TX_DESC_DATA_STBC(__pdesc, __Value) 		\
+	SET_BITS_TO_LE_4BYTE(__pdesc+20, 8, 2, __Value)
+#define SET_TX_DESC_CTROL_STBC(__pdesc, __Value) 	\
+	SET_BITS_TO_LE_4BYTE(__pdesc+20, 10, 2, __Value)
+#define SET_TX_DESC_RTS_SHORT(__pdesc, __Value) 		\
+	SET_BITS_TO_LE_4BYTE(__pdesc+20, 12, 1, __Value)
+#define SET_TX_DESC_RTS_SC(__pdesc, __Value) 		\
+	SET_BITS_TO_LE_4BYTE(__pdesc+20, 13, 4, __Value)
+
+// Dword 6
+#define SET_TX_DESC_MBSSID_8821(__pdesc, __Value) 		\
+	SET_BITS_TO_LE_4BYTE(__pdesc+24, 12, 4, __Value)
+
+// Dword 7
+#define SET_TX_DESC_TX_BUFFER_SIZE(__pdesc, __Value) 	\
+	SET_BITS_TO_LE_4BYTE(__pdesc+28, 0, 16, __Value)
+#define SET_TX_DESC_TX_DESC_CHECKSUM(__pdesc, __Value) 	\
+	SET_BITS_TO_LE_4BYTE(__pdesc+28, 0, 16, __Value)
+#define SET_TX_DESC_USB_TXAGG_NUM(__pdesc, __Value) 	\
+	SET_BITS_TO_LE_4BYTE(__pdesc+28, 24, 8, __Value)
+
+// Dword 8
+#define SET_TX_DESC_HWSEQ_EN(__pdesc, __Value) 		\
+	SET_BITS_TO_LE_4BYTE(__pdesc+32, 15, 1, __Value)
+
+// Dword 9
+#define SET_TX_DESC_SEQ(__pdesc, __Value) 		\
+	SET_BITS_TO_LE_4BYTE(__pdesc+36, 12, 12, __Value)
+
+// Dword 10
+#define SET_TX_DESC_TX_BUFFER_ADDRESS(__pdesc, __Value) 	\
+	SET_BITS_TO_LE_4BYTE(__pdesc+40, 0, 32, __Value)
+
+// Dword 11
+#define SET_TX_DESC_NEXT_DESC_ADDRESS(__pdesc, __Value) 	\
+	SET_BITS_TO_LE_4BYTE(__pdesc+48, 0, 32, __Value)
+
+/* RX desc macros */
+
+
+//DWORD 0
+#define SET_RX_STATUS_DESC_PKT_LEN(__pdesc, __Value)	\
+	SET_BITS_TO_LE_4BYTE( __pdesc, 0, 14, __Value)
+#define SET_RX_STATUS_DESC_EOR(__pdesc, __Value)	\
+	SET_BITS_TO_LE_4BYTE( __pdesc, 30, 1, __Value)
+#define SET_RX_STATUS_DESC_OWN(__pdesc, __Value)	\
+	SET_BITS_TO_LE_4BYTE( __pdesc, 31, 1, __Value)
+
+#define GET_RX_STATUS_DESC_PKT_LEN(__pdesc)	\
+	LE_BITS_TO_4BYTE( __pdesc, 0, 14)
+#define GET_RX_STATUS_DESC_CRC32(__pdesc)		\
+	LE_BITS_TO_4BYTE( __pdesc, 14, 1)
+#define GET_RX_STATUS_DESC_ICV(__pdesc)		\
+	LE_BITS_TO_4BYTE( __pdesc, 15, 1)
+#define GET_RX_STATUS_DESC_DRVINFO_SIZE(__pdesc)	\
+	LE_BITS_TO_4BYTE( __pdesc, 16, 4)
+#define GET_RX_STATUS_DESC_SECURITY(__pdesc)	\
+	LE_BITS_TO_4BYTE( __pdesc, 20, 3)
+#define GET_RX_STATUS_DESC_QOS(__pdesc)		\
+	LE_BITS_TO_4BYTE( __pdesc, 23, 1)
+#define GET_RX_STATUS_DESC_SHIFT(__pdesc)		\
+	LE_BITS_TO_4BYTE( __pdesc, 24, 2)
+#define GET_RX_STATUS_DESC_PHY_STATUS(__pdesc)	\
+	LE_BITS_TO_4BYTE( __pdesc, 26, 1)
+#define GET_RX_STATUS_DESC_SWDEC(__pdesc)		\
+	LE_BITS_TO_4BYTE( __pdesc, 27, 1)
+#define GET_RX_STATUS_DESC_LAST_SEG(__pdesc)	\
+	LE_BITS_TO_4BYTE( __pdesc, 28, 1)
+#define GET_RX_STATUS_DESC_FIRST_SEG(__pdesc)	\
+	LE_BITS_TO_4BYTE( __pdesc, 29, 1)
+#define GET_RX_STATUS_DESC_EOR(__pdesc)		\
+	LE_BITS_TO_4BYTE( __pdesc, 30, 1)
+#define GET_RX_STATUS_DESC_OWN(__pdesc)		\
+	LE_BITS_TO_4BYTE( __pdesc, 31, 1)
+
+//DWORD 1
+#define GET_RX_STATUS_DESC_MACID(__pdesc) 		\
+	LE_BITS_TO_4BYTE(__pdesc+4, 0, 7)
+#define GET_RX_STATUS_DESC_TID(__pdesc) 			\
+	LE_BITS_TO_4BYTE(__pdesc+4, 8, 4)
+#define GET_RX_STATUS_DESC_AMSDU(__pdesc) 		\
+	LE_BITS_TO_4BYTE(__pdesc+4, 13, 1)
+#define GET_RX_STATUS_DESC_RXID_MATCH(__pdesc)		\
+	LE_BITS_TO_4BYTE( __pdesc+4, 14, 1)
+#define GET_RX_STATUS_DESC_PAGGR(__pdesc)		\
+	LE_BITS_TO_4BYTE( __pdesc+4, 15, 1)
+#define GET_RX_STATUS_DESC_A1_FIT(__pdesc)		\
+	LE_BITS_TO_4BYTE( __pdesc+4, 16, 4)
+#define GET_RX_STATUS_DESC_CHKERR(__pdesc)		\
+	LE_BITS_TO_4BYTE( __pdesc+4, 20, 1)
+#define GET_RX_STATUS_DESC_IPVER(__pdesc)		\
+	LE_BITS_TO_4BYTE(__pdesc+4, 21, 1)
+#define GET_RX_STATUS_DESC_IS_TCPUDP_(__pdesc)		\
+	LE_BITS_TO_4BYTE(__pdesc+4, 22, 1)
+#define GET_RX_STATUS_DESC_CHK_VLD(__pdesc)		\
+	LE_BITS_TO_4BYTE(__pdesc+4, 23, 1)
+#define GET_RX_STATUS_DESC_PAM(__pdesc)			\
+	LE_BITS_TO_4BYTE( __pdesc+4, 24, 1)
+#define GET_RX_STATUS_DESC_PWR(__pdesc)			\
+	LE_BITS_TO_4BYTE( __pdesc+4, 25, 1)
+#define GET_RX_STATUS_DESC_MORE_DATA(__pdesc)		\
+	LE_BITS_TO_4BYTE( __pdesc+4, 26, 1)
+#define GET_RX_STATUS_DESC_MORE_FRAG(__pdesc)		\
+	LE_BITS_TO_4BYTE( __pdesc+4, 27, 1)
+#define GET_RX_STATUS_DESC_TYPE(__pdesc)			\
+	LE_BITS_TO_4BYTE( __pdesc+4, 28, 2)
+#define GET_RX_STATUS_DESC_MC(__pdesc)			\
+	LE_BITS_TO_4BYTE( __pdesc+4, 30, 1)
+#define GET_RX_STATUS_DESC_BC(__pdesc)			\
+	LE_BITS_TO_4BYTE( __pdesc+4, 31, 1)
+
+//DWORD 2
+#define GET_RX_STATUS_DESC_SEQ(__pdesc)		\
+	LE_BITS_TO_4BYTE( __pdesc+8, 0, 12)
+#define GET_RX_STATUS_DESC_FRAG(__pdesc)		\
+	LE_BITS_TO_4BYTE( __pdesc+8, 12, 4)
+#define GET_RX_STATUS_DESC_RX_IS_QOS(__pdesc)	\
+	LE_BITS_TO_4BYTE( __pdesc+8, 16, 1)
+#define GET_RX_STATUS_DESC_WLANHD_IV_LEN(__pdesc)	\
+	LE_BITS_TO_4BYTE( __pdesc+8, 18, 6)
+#define GET_RX_STATUS_DESC_RPT_SEL(__pdesc)	\
+	LE_BITS_TO_4BYTE( __pdesc+8, 28, 1)
+
+//DWORD 3
+#define GET_RX_STATUS_DESC_RX_RATE(__pdesc)	\
+	LE_BITS_TO_4BYTE( __pdesc+12, 0, 7)
+#define GET_RX_STATUS_DESC_HTC(__pdesc)		\
+	LE_BITS_TO_4BYTE( __pdesc+12, 10, 1)
+#define GET_RX_STATUS_DESC_EOSP(__pdesc)		\
+	LE_BITS_TO_4BYTE( __pdesc+12, 11, 1)
+#define GET_RX_STATUS_DESC_BSSID_FIT(__pdesc)	\
+	LE_BITS_TO_4BYTE( __pdesc+12, 12, 2)
+#define GET_RX_STATUS_DESC_USB_AGG_PKTNUM(__pdesc)	\
+	LE_BITS_TO_4BYTE( __pdesc+12, 16, 8)
+#define GET_RX_STATUS_DESC_PATTERN_MATCH(__pdesc)	\
+	LE_BITS_TO_4BYTE( __pdesc+12, 29, 1)
+#define GET_RX_STATUS_DESC_UNICAST_MATCH(__pdesc)	\
+	LE_BITS_TO_4BYTE( __pdesc+12, 30, 1)
+#define GET_RX_STATUS_DESC_MAGIC_MATCH(__pdesc)		\
+	LE_BITS_TO_4BYTE( __pdesc+12, 31, 1)
+
+//DWORD 6
+#define GET_RX_STATUS_DESC_SPLCP(__pdesc)		\
+	LE_BITS_TO_4BYTE( __pdesc+16, 0, 1)
+#define GET_RX_STATUS_DESC_LDPC(__pdesc)			\
+	LE_BITS_TO_4BYTE( __pdesc+16, 1, 1)
+#define GET_RX_STATUS_DESC_STBC(__pdesc)			\
+	LE_BITS_TO_4BYTE( __pdesc+16, 2, 1)
+#define GET_RX_STATUS_DESC_BW(__pdesc)			\
+	LE_BITS_TO_4BYTE( __pdesc+16, 4, 2)
+
+//DWORD 5
+#define GET_RX_STATUS_DESC_TSFL(__pdesc)		\
+	LE_BITS_TO_4BYTE( __pdesc+20, 0, 32)
+#define GET_RX_STATUS_DESC_BUFF_ADDR(__pdesc) 		\
+	LE_BITS_TO_4BYTE(__pdesc+24, 0, 32)
+#define GET_RX_STATUS_DESC_BUFF_ADDR64(__pdesc) 		\
+	LE_BITS_TO_4BYTE(__pdesc+28, 0, 32)
+#define SET_RX_STATUS_DESC_BUFF_ADDR(__pdesc, __Value) 	\
+	SET_BITS_TO_LE_4BYTE(__pdesc+24, 0, 32, __Value)
+
+
+
+
+
+
+#define SET_EARLYMODE_PKTNUM(__pAddr, __Value)		\
+	SET_BITS_TO_LE_4BYTE(__pAddr, 0, 4, __Value)
+#define SET_EARLYMODE_LEN0(__pAddr, __Value) 		\
+	SET_BITS_TO_LE_4BYTE(__pAddr, 4, 15, __Value)
+#define SET_EARLYMODE_LEN1_1(__pAddr, __Value) 		\
+	SET_BITS_TO_LE_4BYTE(__pAddr, 19, 13, __Value)
+#define SET_EARLYMODE_LEN1_2(__pAddr, __Value) 		\
+	SET_BITS_TO_LE_4BYTE(__pAddr+4, 0, 2, __Value)
+#define SET_EARLYMODE_LEN2(__pAddr, __Value) 		\
+	SET_BITS_TO_LE_4BYTE(__pAddr+4, 2, 15,  __Value)
+#define SET_EARLYMODE_LEN3(__pAddr, __Value) 		\
+	SET_BITS_TO_LE_4BYTE(__pAddr+4, 17, 15, __Value)
+
+
+struct tx_desc_8821au {
+	// Offset 0
+	u32 pktlen:16;
+	u32 offset:8;
+	u32 bmc:1;
+	u32 htc:1;
+	u32 ls:1;
+	u32 fs:1;
+	u32 linip:1;
+	u32 noacm:1;
+	u32 gf:1;
+	u32 own:1;
+
+	// Offset 4
+	u32 macid:6;
+	u32 rsvd0406:2;
+	u32 qsel:5;
+	u32 rd_nav_ext:1;
+	u32 lsig_txop_en:1;
+	u32 pifs:1;
+	u32 rate_id:4;
+	u32 navusehdr:1;
+	u32 en_desc_id:1;
+	u32 sectype:2;
+	u32 rsvd0424:2;
+	u32 pkt_offset:5;	// unit: 8 bytes
+	u32 rsvd0431:1;
+
+	// Offset 8
+	u32 rts_rc:6;
+	u32 data_rc:6;
+	u32 agg_en:1;
+	u32 rd_en:1;
+	u32 bar_rty_th:2;
+	u32 bk:1;
+	u32 morefrag:1;
+	u32 raw:1;
+	u32 ccx:1;
+	u32 ampdu_density:3;
+	u32 bt_null:1;
+	u32 ant_sel_a:1;
+	u32 ant_sel_b:1;
+	u32 tx_ant_cck:2;
+	u32 tx_antl:2;
+	u32 tx_ant_ht:2;
+
+	// Offset 12
+	u32 nextheadpage:8;
+	u32 tailpage:8;
+	u32 seq:12;
+	u32 cpu_handle:1;
+	u32 tag1:1;
+	u32 trigger_int:1;
+	u32 hwseq_en:1;
+
+	// Offset 16
+	u32 rtsrate:5;
+	u32 ap_dcfe:1;
+	u32 hwseq_sel:2;
+	u32 userate:1;
+	u32 disrtsfb:1;
+	u32 disdatafb:1;
+	u32 cts2self:1;
+	u32 rtsen:1;
+	u32 hw_rts_en:1;
+	u32 port_id:1;
+	u32 pwr_status:3;
+	u32 wait_dcts:1;
+	u32 cts2ap_en:1;
+	u32 data_sc:2;
+	u32 data_stbc:2;
+	u32 data_short:1;
+	u32 data_bw:1;
+	u32 rts_short:1;
+	u32 rts_bw:1;
+	u32 rts_sc:2;
+	u32 vcs_stbc:2;
+
+	// Offset 20
+	u32 datarate:6;
+	u32 sgi:1;
+	u32 try_rate:1;
+	u32 data_ratefb_lmt:5;
+	u32 rts_ratefb_lmt:4;
+	u32 rty_lmt_en:1;
+	u32 data_rt_lmt:6;
+	u32 usb_txagg_num:8;
+
+	// Offset 24
+	u32 txagg_a:5;
+	u32 txagg_b:5;
+	u32 use_max_len:1;
+	u32 max_agg_num:5;
+	u32 mcsg1_max_len:4;
+	u32 mcsg2_max_len:4;
+	u32 mcsg3_max_len:4;
+	u32 mcs7_sgi_max_len:4;
+
+	// Offset 28
+	u32 checksum:16;	// TxBuffSize(PCIe)/CheckSum(USB)
+	u32 mcsg4_max_len:4;
+	u32 mcsg5_max_len:4;
+	u32 mcsg6_max_len:4;
+	u32 mcs15_sgi_max_len:4;
+
+	// Offset 32
+	u32 rsvd32;
+
+	// Offset 36
+	u32 rsvd36;
+};
+
+
+
+struct rw_fwinfo_8821au {
+	//2012.05.24 LukeLee: This structure should take big/little endian in consideration later.....
+
+	//DWORD 0
+	u8			gain_trsw[2];
+	u16			chl_num:10;
+	u16			sub_chnl:4;
+	u16			r_RFMOD:2;
+
+	//DWORD 1
+	u8			pwdb_all;
+	u8			cfosho[4];	// DW 1 byte 1 DW 2 byte 0
+
+	//DWORD 2
+	s8			cfotail[4];	// DW 2 byte 1 DW 3 byte 0
+
+	//DWORD 3
+	s8			rxevm[2];	// DW 3 byte 1 DW 3 byte 2
+	s8			rxsnr[2];	// DW 3 byte 3 DW 4 byte 0
+
+	//DWORD 4
+	u8			PCTS_MSK_RPT[2];
+	u8			pdsnr[2];	// DW 4 byte 3 DW 5 Byte 0
+
+	//DWORD 5
+	u8			csi_current[2];
+	u8			rx_gain_c;
+
+	//DWORD 6
+	u8			rx_gain_d;
+	u8			sigevm;
+	u8			resvd_0;
+	u8			antidx_anta:3;
+	u8			antidx_antb:3;
+	u8			resvd_1:2;
+} __packed;
+
+
+#endif
diff -Naur linux-4.9/drivers/staging/rtl8821au/usb.c linux-4.9.8821au/drivers/staging/rtl8821au/usb.c
--- linux-4.9/drivers/staging/rtl8821au/usb.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/usb.c	2016-12-11 19:48:25.186978326 -0600
@@ -0,0 +1,2209 @@
+#include <linux/etherdevice.h>
+
+#include <drv_types.h>
+#include <usb_ops.h>
+#include <rtw_ap.h>
+#include <rtl8812a_recv.h>
+#include <../rtl8821au/trx.h>
+#include <../rtl8821au/fw.h>
+#include "debug.h"
+
+#undef DBG_871X
+static inline void DBG_871X(const char *fmt, ...)
+{
+}
+
+#undef DBG_8192C
+static inline void DBG_8192C(const char *fmt, ...)
+{
+}
+
+/*
+* Increase and check if the continual_urb_error of this @param dvobjprive is larger than MAX_CONTINUAL_URB_ERR
+* @return true:
+* @return false:
+*/
+
+/* ULLI : currently wrong functions for this prototypes, we change this (maybe) later */
+
+static uint32_t _rtl_usb_receive(struct rtl_priv *rtlpriv, uint32_t cnt, uint8_t *rmem);
+
+
+
+static inline int rtw_inc_and_chk_continual_urb_error(struct rtl_usb *dvobj)
+{
+	int ret = false;
+	int value;
+	if( (value=atomic_inc_return(&dvobj->continual_urb_error)) > MAX_CONTINUAL_URB_ERR) {
+		DBG_871X("[dvobj:%p][ERROR] continual_urb_error:%d > %d\n", dvobj, value, MAX_CONTINUAL_URB_ERR);
+		ret = true;
+	} else {
+		//DBG_871X("[dvobj:%p] continual_urb_error:%d\n", dvobj, value);
+	}
+	return ret;
+}
+
+int rtw_resume_process(struct rtl_priv *rtlpriv);
+
+static int usbctrl_vendorreq(struct rtl_priv *rtlpriv, uint8_t request, u16 value, u16 index, void *pdata, u16 len, uint8_t requesttype)
+{
+	struct rtl_usb *rtlusb = rtl_usbdev(rtlpriv);
+	struct usb_device *udev = rtlusb->udev;
+	int _unused;
+
+	unsigned int pipe;
+	int status = 0;
+	u32 tmp_buflen=0;
+	uint8_t reqtype;
+	uint8_t *pIo_buf;
+	int vendorreq_times = 0;
+
+	uint8_t tmp_buf[MAX_USB_IO_CTL_SIZE];
+
+	/* DBG_871X("%s %s:%d\n",__FUNCTION__, current->comm, current->pid); */
+
+	if((rtlpriv->bSurpriseRemoved) ||(rtlpriv->pwrctrlpriv.pnp_bstop_trx)){
+		status = -EPERM;
+		goto exit;
+	}
+
+	if(len>MAX_VENDOR_REQ_CMD_SIZE){
+		RT_TRACE(rtlpriv, COMP_USB, DBG_LOUD, "[%s] Buffer len error ,vendor request failed\n", __FUNCTION__ );
+		status = -EINVAL;
+		goto exit;
+	}
+
+#ifdef CONFIG_USB_VENDOR_REQ_MUTEX
+	_unused = mutex_lock_interruptible(&rtlusb->usb_vendor_req_mutex);
+#endif
+
+
+	/* Acquire IO memory for vendorreq */
+#ifdef CONFIG_USB_VENDOR_REQ_BUFFER_PREALLOC
+	pIo_buf = rtlusb->usb_vendor_req_buf;
+#else
+	tmp_buflen = MAX_USB_IO_CTL_SIZE;
+
+	/*
+	 * Added by Albert 2010/02/09
+	 * For mstar platform, mstar suggests the address for USB IO should be 16 bytes alignment.
+	 * Trying to fix it here.
+	 */
+	pIo_buf = (tmp_buf==NULL)?NULL:tmp_buf + ALIGNMENT_UNIT -((__kernel_size_t)(tmp_buf) & 0x0f );
+#endif
+
+	if ( pIo_buf== NULL) {
+		RT_TRACE(rtlpriv, COMP_USB, DBG_LOUD, "[%s] pIo_buf == NULL \n", __FUNCTION__ );
+		status = -ENOMEM;
+		goto release_mutex;
+	}
+
+	while (++vendorreq_times<= MAX_USBCTRL_VENDORREQ_TIMES) {
+		memset(pIo_buf, 0, len);
+
+		if (requesttype == 0x01) {
+			pipe = usb_rcvctrlpipe(udev, 0);	/* read_in */
+			reqtype =  REALTEK_USB_VENQT_READ;
+		} else {
+			pipe = usb_sndctrlpipe(udev, 0);	/* write_out */
+			reqtype =  REALTEK_USB_VENQT_WRITE;
+			memcpy( pIo_buf, pdata, len);
+		}
+
+		status = usb_control_msg(udev, pipe, request, reqtype, value, index, pIo_buf, len, RTW_USB_CONTROL_MSG_TIMEOUT);
+
+		if (status == len) {   // Success this control transfer. */
+			rtw_reset_continual_urb_error(rtlusb);
+			if (requesttype == 0x01) {
+				/* For Control read transfer, we have to copy the read data from pIo_buf to pdata. */
+				memcpy(pdata, pIo_buf,  len);
+			}
+		} else {
+			/* error cases */
+			RT_TRACE(rtlpriv, COMP_USB, DBG_LOUD, "reg 0x%x, usb %s %u fail, status:%d value=0x%x, vendorreq_times:%d\n"
+				, value,(requesttype == 0x01)?"read":"write" , len, status, *(u32*)pdata, vendorreq_times);
+
+			if (status < 0) {
+				if(status == (-ESHUTDOWN) || status == -ENODEV) {
+					rtlpriv->bSurpriseRemoved = true;
+				} else {
+					;
+				}
+			} else {
+				/* status != len && status >= 0 */
+
+				if(status > 0) {
+					if ( requesttype == 0x01 ) {
+						/* For Control read transfer, we have to copy the read data from pIo_buf to pdata. */
+						memcpy( pdata, pIo_buf,  len );
+					}
+				}
+			}
+
+			if(rtw_inc_and_chk_continual_urb_error(rtlusb) == true ){
+				rtlpriv->bSurpriseRemoved = true;
+				break;
+			}
+
+		}
+
+		/* firmware download is checksumed, don't retry */
+		if( (value >= FW_8821AU_START_ADDRESS ) || status == len )
+			break;
+
+	}
+
+	/* release IO memory used by vendorreq */
+
+release_mutex:
+#ifdef CONFIG_USB_VENDOR_REQ_MUTEX
+	mutex_unlock(&rtlusb->usb_vendor_req_mutex);
+#endif
+exit:
+	return status;
+
+}
+
+
+
+static uint8_t usb_read8(struct rtl_priv *rtlpriv, uint32_t addr)
+{
+	uint8_t request;
+	uint8_t requesttype;
+	u16 wvalue;
+	u16 index;
+	u16 len;
+	uint8_t data = 0;
+
+	request = 0x05;
+	requesttype = 0x01;	/* read_in */
+	index = 0;		/* n/a */
+
+	wvalue = (u16) (addr&0x0000ffff);
+	len = 1;
+
+	usbctrl_vendorreq(rtlpriv, request, wvalue, index, &data, len, requesttype);
+
+	return data;
+
+}
+
+static u16 usb_read16(struct rtl_priv *rtlpriv, uint32_t addr)
+{
+	uint8_t request;
+	uint8_t requesttype;
+	u16 wvalue;
+	u16 index;
+	u16 len;
+	u16 data = 0;
+
+	request = 0x05;
+	requesttype = 0x01;	/* read_in */
+	index = 0;		/* n/a */
+
+	wvalue = (u16)(addr&0x0000ffff);
+	len = 2;
+
+	usbctrl_vendorreq(rtlpriv, request, wvalue, index, &data, len, requesttype);
+
+	return data;
+
+}
+
+static uint32_t usb_read32(struct rtl_priv *rtlpriv, uint32_t addr)
+{
+	uint8_t request;
+	uint8_t requesttype;
+	u16 wvalue;
+	u16 index;
+	u16 len;
+	uint32_t data = 0;
+
+	request = 0x05;
+	requesttype = 0x01;	/* read_in */
+	index = 0;		/* n/a */
+
+	wvalue = (u16)(addr&0x0000ffff);
+	len = 4;
+
+	usbctrl_vendorreq(rtlpriv, request, wvalue, index, &data, len, requesttype);
+
+
+	return data;
+
+}
+
+static void usb_write8(struct rtl_priv *rtlpriv, uint32_t addr, uint8_t val)
+{
+	uint8_t request;
+	uint8_t requesttype;
+	u16 wvalue;
+	u16 index;
+	u16 len;
+	uint8_t data;
+
+	request = 0x05;
+	requesttype = 0x00;		/* write_out */
+	index = 0;			/* n/a */
+
+	wvalue = (u16)(addr&0x0000ffff);
+	len = 1;
+
+	data = val;
+
+	usbctrl_vendorreq(rtlpriv, request, wvalue, index, &data, len, requesttype);
+}
+
+static void usb_write16(struct rtl_priv *rtlpriv, uint32_t addr, u16 val)
+{
+	uint8_t request;
+	uint8_t requesttype;
+	u16 wvalue;
+	u16 index;
+	u16 len;
+	u16 data;
+
+	request = 0x05;
+	requesttype = 0x00;	/* write_out */
+	index = 0;		/* n/a */
+
+	wvalue = (u16)(addr&0x0000ffff);
+	len = 2;
+
+	data = val;
+
+	usbctrl_vendorreq(rtlpriv, request, wvalue, index, &data, len, requesttype);
+}
+
+static void usb_write32(struct rtl_priv *rtlpriv, uint32_t addr, uint32_t val)
+{
+	uint8_t request;
+	uint8_t requesttype;
+	u16 wvalue;
+	u16 index;
+	u16 len;
+	uint32_t data;
+
+	request = 0x05;
+	requesttype = 0x00;	/* write_out */
+	index = 0;		/* n/a */
+
+	wvalue = (u16)(addr&0x0000ffff);
+	len = 4;
+	data = val;
+
+	usbctrl_vendorreq(rtlpriv, request, wvalue, index, &data, len, requesttype);
+}
+
+static void usb_writeN(struct rtl_priv *rtlpriv, uint32_t addr, void *pdata, u16 length)
+{
+	uint8_t request;
+	uint8_t requesttype;
+	u16 wvalue;
+	u16 index;
+	u16 len;
+	uint8_t buf[VENDOR_CMD_MAX_DATA_LEN] = {0};
+
+	request = 0x05;
+	requesttype = 0x00;	/* write_out */
+	index = 0;		/* n/a */
+
+	wvalue = (u16)(addr&0x0000ffff);
+	len = length;
+	memcpy(buf, pdata, len);
+
+	usbctrl_vendorreq(rtlpriv, request, wvalue, index, buf, len, requesttype);
+}
+
+static void _rtl_usb_io_handler_init(struct device *dev,
+				     struct rtl_priv *rtlpriv)
+{
+	rtlpriv->io.dev = dev;
+	mutex_init(&rtlpriv->io.bb_mutex);
+	rtlpriv->io.write8_async	= usb_write8;
+	rtlpriv->io.write16_async	= usb_write16;
+	rtlpriv->io.write32_async	= usb_write32;
+	rtlpriv->io.read8_sync		= usb_read8;
+	rtlpriv->io.read16_sync		= usb_read16;
+	rtlpriv->io.read32_sync		= usb_read32;
+	rtlpriv->io.writeN_sync		= usb_writeN;
+}
+
+static void _rtl_usb_io_handler_release(struct rtl_priv *rtlpriv)
+{
+	mutex_destroy(&rtlpriv->io.bb_mutex);
+}
+
+
+static void _rtl_tx_complete(struct urb *purb)
+{
+	unsigned long flags;
+	int i;
+	struct xmit_buf *pxmitbuf = (struct xmit_buf *)purb->context;
+	/* struct xmit_frame *pxmitframe = (struct xmit_frame *)pxmitbuf->priv_data; */
+	/* struct rtl_priv			*rtlpriv = pxmitframe->rtlpriv; */
+	struct rtl_priv	*rtlpriv = pxmitbuf->rtlpriv;
+	struct xmit_priv	*pxmitpriv = &rtlpriv->xmitpriv;
+	/* struct pkt_attrib *pattrib = &pxmitframe->attrib; */
+
+	switch(pxmitbuf->flags) {
+		case RTL_TXQ_VO:
+			break;
+		case RTL_TXQ_VI:
+			break;
+		case RTL_TXQ_BE:
+			break;
+		case RTL_TXQ_BK:
+			break;
+		case RTL_TXQ_HI:
+#ifdef CONFIG_AP_MODE
+			rtw_chk_hi_queue_cmd(rtlpriv);
+#endif
+			break;
+		default:
+			break;
+	}
+
+
+        /* rtw_free_xmitframe(pxmitpriv, pxmitframe); */
+
+	if (rtlpriv->bSurpriseRemoved || rtlpriv->bDriverStopped ||rtlpriv->bWritePortCancel) {
+		RT_TRACE(rtlpriv, COMP_USB, DBG_LOUD, "%s(): TX Warning! bDriverStopped(%d) OR bSurpriseRemoved(%d) bWritePortCancel(%d) pxmitbuf->buf_tag(%x) \n",
+		__FUNCTION__,rtlpriv->bDriverStopped, rtlpriv->bSurpriseRemoved,rtlpriv->bReadPortCancel,pxmitbuf->buf_tag);
+
+		goto check_completion;
+	}
+
+
+	if (purb->status==0) {
+
+	} else {
+		RT_TRACE(rtlpriv, COMP_USB, DBG_LOUD,  "###=> urb_write_port_complete status(%d)\n",purb->status);
+		if((purb->status==-EPIPE)||(purb->status==-EPROTO)) {
+			/*
+			 * usb_clear_halt(pusbdev, purb->pipe);
+			 * msleep(10);
+			 */
+		} else if (purb->status == -EINPROGRESS) {
+			goto check_completion;
+
+		} else if (purb->status == -ENOENT) {
+			RT_TRACE(rtlpriv, COMP_USB, DBG_LOUD, "%s: -ENOENT\n", __func__);
+			goto check_completion;
+
+		} else if (purb->status == -ECONNRESET) {
+			RT_TRACE(rtlpriv, COMP_USB, DBG_LOUD,  "%s: -ECONNRESET\n", __func__);
+			goto check_completion;
+
+		} else if (purb->status == -ESHUTDOWN) {
+			rtlpriv->bDriverStopped=true;
+
+			goto check_completion;
+		} else 	{
+			rtlpriv->bSurpriseRemoved=true;
+			RT_TRACE(rtlpriv, COMP_USB, DBG_LOUD,  "bSurpriseRemoved=true\n");
+			/* rtl8192cu_trigger_gpio_0(rtlpriv); */
+
+			goto check_completion;
+		}
+	}
+
+check_completion:
+	spin_lock_irqsave(&pxmitpriv->lock_sctx, flags);
+	rtw_sctx_done_err(&pxmitbuf->sctx,
+		purb->status ? RTW_SCTX_DONE_WRITE_PORT_ERR : RTW_SCTX_DONE_SUCCESS);
+	spin_unlock_irqrestore(&pxmitpriv->lock_sctx, flags);
+
+	rtw_free_xmitbuf(pxmitpriv, pxmitbuf);
+
+	/* if(rtw_txframes_pending(rtlpriv)) */
+	{
+		tasklet_hi_schedule(&pxmitpriv->xmit_tasklet);
+	}
+}
+
+
+/* ULLI : _rtlw* prefix because of rtlwifi namespace issues */
+
+u32 _rtlw_usb_transmit(struct rtl_priv *rtlpriv, u32 queue_idx, u32 cnt, struct xmit_buf *pxmitbuf)
+{
+	u32 ep_num;
+
+	unsigned long flags;
+	unsigned int pipe;
+	int status;
+	u32 ret = _FAIL, bwritezero = false;
+	struct urb *purb = NULL;
+	struct rtl_usb	*rtlusb = rtl_usbdev(rtlpriv);
+	struct xmit_priv *pxmitpriv = &rtlpriv->xmitpriv;
+	struct xmit_frame *pxmitframe = (struct xmit_frame *)pxmitbuf->priv_data;
+	struct usb_device *pusbd = rtlusb->udev;
+	struct tx_pkt_attrib *pattrib = &pxmitframe->tx_attrib;
+
+	if ((rtlpriv->bDriverStopped) || (rtlpriv->bSurpriseRemoved) ||(rtlpriv->pwrctrlpriv.pnp_bstop_trx)) {
+		#ifdef DBG_TX
+		DBG_871X(" DBG_TX %s:%d bDriverStopped%d, bSurpriseRemoved:%d, pnp_bstop_trx:%d\n",__FUNCTION__, __LINE__
+			,rtlpriv->bDriverStopped, rtlpriv->bSurpriseRemoved, rtlpriv->pwrctrlpriv.pnp_bstop_trx );
+		#endif
+		rtw_sctx_done_err(&pxmitbuf->sctx, RTW_SCTX_DONE_TX_DENY);
+		goto exit;
+	}
+
+	spin_lock_irqsave(&pxmitpriv->lock, flags);
+
+	switch(queue_idx) {
+		case RTL_TXQ_VO:
+			pxmitbuf->flags = RTL_TXQ_VO;
+			break;
+		case RTL_TXQ_VI:
+			pxmitbuf->flags = RTL_TXQ_VI;
+			break;
+		case RTL_TXQ_BE:
+			pxmitbuf->flags = RTL_TXQ_BE;
+			break;
+		case RTL_TXQ_BK:
+			pxmitbuf->flags = RTL_TXQ_BK;
+			break;
+		case RTL_TXQ_HI:
+			pxmitbuf->flags = RTL_TXQ_HI;
+			break;
+		default:
+			pxmitbuf->flags = RTL_TXQ_MGT;
+			break;
+	}
+
+	spin_unlock_irqrestore(&pxmitpriv->lock, flags);
+
+	purb	= pxmitbuf->pxmit_urb[0];
+
+	/* translate DMA FIFO addr to pipehandle */
+	ep_num = rtlusb->ep_map.ep_mapping[queue_idx];
+	pipe = usb_sndbulkpipe(pusbd, ep_num);
+
+#ifdef CONFIG_REDUCE_USB_TX_INT
+	if ((pxmitpriv->free_xmitbuf_cnt%NR_XMITBUFF == 0) ||
+	   (pxmitbuf->buf_tag > XMITBUF_DATA)) {
+		purb->transfer_flags  &=  (~URB_NO_INTERRUPT);
+	} else {
+		purb->transfer_flags  |=  URB_NO_INTERRUPT;
+		/* DBG_8192C("URB_NO_INTERRUPT "); */
+	}
+#endif
+
+	usb_fill_bulk_urb(purb, pusbd, pipe,
+       				pxmitframe->buf_addr, 	/* = pxmitbuf->pbuf */
+              			cnt,
+              			_rtl_tx_complete,
+              			pxmitbuf);		/* context is pxmitbuf */
+#if 0
+	if (bwritezero) {
+            purb->transfer_flags |= URB_ZERO_PACKET;
+        }
+#endif
+
+	status = usb_submit_urb(purb, GFP_ATOMIC);
+	if (!status) {
+	} else {
+		rtw_sctx_done_err(&pxmitbuf->sctx, RTW_SCTX_DONE_WRITE_PORT_ERR);
+		RT_TRACE(rtlpriv, COMP_USB, DBG_LOUD, " _rtlw_usb_transmit, status=%d\n", status);
+		switch (status) {
+		case -ENODEV:
+			rtlpriv->bDriverStopped=true;
+			break;
+		default:
+			break;
+		}
+		goto exit;
+	}
+
+	ret= _SUCCESS;
+
+/*
+ *  Commented by Albert 2009/10/13
+ *  We add the URB_ZERO_PACKET flag to urb so that the host will send the zero packet automatically.
+ */
+/*
+	if(bwritezero == true)
+	{
+		usb_bulkout_zero(pintfhdl, addr);
+	}
+*/
+
+exit:
+	if (ret != _SUCCESS)
+		rtw_free_xmitbuf(pxmitpriv, pxmitbuf);
+
+	return ret;
+}
+
+void usb_write_port_cancel(struct rtl_priv *rtlpriv)
+{
+	int i, j;
+	struct xmit_buf *pxmitbuf = (struct xmit_buf *)rtlpriv->xmitpriv.pxmitbuf;
+
+	rtlpriv->bWritePortCancel = true;
+
+	for (i=0; i<NR_XMITBUFF; i++) {
+		for (j=0; j<8; j++) {
+			if (pxmitbuf->pxmit_urb[j]) {
+				usb_kill_urb(pxmitbuf->pxmit_urb[j]);
+			}
+		}
+		pxmitbuf++;
+	}
+
+	pxmitbuf = (struct xmit_buf*)rtlpriv->xmitpriv.pxmit_extbuf;
+	for (i = 0; i < NR_XMIT_EXTBUFF; i++) {
+		for (j=0; j<8; j++) {
+			if(pxmitbuf->pxmit_urb[j]) {
+				usb_kill_urb(pxmitbuf->pxmit_urb[j]);
+			}
+		}
+		pxmitbuf++;
+	}
+}
+
+static void _rtl_rx_complete(struct urb *purb)
+{
+	uint isevt, *pbuf;
+	struct recv_buf	*precvbuf = (struct recv_buf *) purb->context;
+	struct rtl_priv 		*rtlpriv = (struct rtl_priv *) precvbuf->rtlpriv;
+	struct recv_priv	*precvpriv = &rtlpriv->recvpriv;
+
+	/*
+	 * spin_lock_irqsave(&precvpriv->lock, &irqL);
+	 * precvbuf->irp_pending=false;
+	 * precvpriv->rx_pending_cnt --;
+	 * spin_unlock_irqrestore(&precvpriv->lock, &irqL);
+	 */
+
+	precvpriv->rx_pending_cnt--;
+
+	/*
+	 * if(precvpriv->rx_pending_cnt== 0) {
+	 * 	RT_TRACE(_module_hci_ops_os_c_,_drv_err_,("usb_read_port_complete: rx_pending_cnt== 0, set allrxreturnevt!\n"));
+	 * 	up(&precvpriv->allrxreturnevt);
+	 * }
+	 */
+
+	if (rtlpriv->bSurpriseRemoved || rtlpriv->bDriverStopped
+	|| rtlpriv->bReadPortCancel) {
+		precvbuf->reuse = true;
+		DBG_8192C("%s() RX Warning! bDriverStopped(%d) OR bSurpriseRemoved(%d) bReadPortCancel(%d)\n",
+		__FUNCTION__, rtlpriv->bDriverStopped, rtlpriv->bSurpriseRemoved, rtlpriv->bReadPortCancel);
+		goto exit;
+	}
+
+	if (purb->status == 0) {
+		/* SUCCESS */
+		if ((purb->actual_length > MAX_RECVBUF_SZ)
+		 || (purb->actual_length < RXDESC_SIZE)) {
+			precvbuf->reuse = true;
+			_rtl_usb_receive(rtlpriv, 0, (unsigned char *)precvbuf);
+			DBG_8192C("%s()-%d: RX Warning!\n", __FUNCTION__, __LINE__);
+		} else {
+			rtw_reset_continual_urb_error(rtl_usbdev(rtlpriv));
+
+			skb_put(precvbuf->skb, purb->actual_length);
+			skb_queue_tail(&precvpriv->rx_skb_queue, precvbuf->skb);
+
+			if (skb_queue_len(&precvpriv->rx_skb_queue) <= 1)
+				tasklet_schedule(&precvpriv->recv_tasklet);
+
+			precvbuf->skb = NULL;
+			precvbuf->reuse = false;
+			_rtl_usb_receive(rtlpriv, 0, (unsigned char *)precvbuf);
+		}
+	} else {
+		DBG_8192C("###=> usb_read_port_complete => urb status(%d)\n", purb->status);
+
+		if (rtw_inc_and_chk_continual_urb_error(rtl_usbdev(rtlpriv)) == true) {
+			rtlpriv->bSurpriseRemoved = true;
+		}
+
+		switch (purb->status) {
+		case -EINVAL:
+		case -EPIPE:
+		case -ENODEV:
+		case -ESHUTDOWN:
+			/* rtlpriv->bSurpriseRemoved=true; */
+		case -ENOENT:
+			rtlpriv->bDriverStopped = true;
+			break;
+		case -EPROTO:
+		case -EILSEQ:
+		case -ETIME:
+		case -ECOMM:
+		case -EOVERFLOW:
+			precvbuf->reuse = true;
+			_rtl_usb_receive(rtlpriv, 0, (unsigned char *)precvbuf);
+			break;
+		case -EINPROGRESS:
+			DBG_8192C("ERROR: URB IS IN PROGRESS!/n");
+			break;
+		default:
+			break;
+		}
+
+	}
+
+exit:
+	;
+}
+
+void rtw_os_read_port(struct rtl_priv *rtlpriv, struct recv_buf *precvbuf)
+{
+	struct recv_priv *precvpriv = &rtlpriv->recvpriv;
+
+	precvbuf->ref_cnt--;
+
+	/* free skb in recv_buf */
+	dev_kfree_skb_any(precvbuf->skb);
+
+	precvbuf->skb = NULL;
+	precvbuf->reuse = false;
+
+	if (precvbuf->irp_pending == false) {
+		_rtl_usb_receive(rtlpriv, 0, (unsigned char *)precvbuf);
+	}
+
+
+
+}
+
+static uint32_t _rtl_usb_receive (struct rtl_priv *rtlpriv, uint32_t cnt, uint8_t *rmem)
+{
+	int err;
+	unsigned int pipe;
+	__kernel_size_t tmpaddr = 0;
+	__kernel_size_t alignment = 0;
+	uint32_t ret = _SUCCESS;
+	struct urb *purb = NULL;
+	struct recv_buf	*precvbuf = (struct recv_buf *) rmem;
+	struct rtl_usb	*rtlusb = rtl_usbdev(rtlpriv);
+	struct recv_priv	*precvpriv = &rtlpriv->recvpriv;
+	struct usb_device	*pusbd = rtlusb->udev;
+	uint32_t addr = RECV_BULK_IN_ADDR;
+
+	if (rtlpriv->bDriverStopped || rtlpriv->bSurpriseRemoved
+	 || rtlpriv->pwrctrlpriv.pnp_bstop_trx) {
+		return _FAIL;
+	}
+
+	if ((precvbuf->reuse == false) || (precvbuf->skb == NULL)) {
+		precvbuf->skb = skb_dequeue(&precvpriv->free_recv_skb_queue);
+		if (precvbuf->skb != NULL) {
+			precvbuf->reuse = true;
+		}
+	}
+
+	if (precvbuf != NULL) {
+		precvbuf->len = 0;
+		precvbuf->ref_cnt = 0;
+
+		/* re-assign for linux based on skb */
+		if ((precvbuf->reuse == false) || (precvbuf->skb == NULL)) {
+			/* precvbuf->pskb = alloc_skb(MAX_RECVBUF_SZ, GFP_ATOMIC);//don't use this after v2.6.25 */
+			precvbuf->skb = netdev_alloc_skb(rtlpriv->ndev, MAX_RECVBUF_SZ + RECVBUFF_ALIGN_SZ);
+			if (precvbuf->skb == NULL) {
+				DBG_8192C("#### usb_read_port() alloc_skb fail!#####\n");
+				return _FAIL;
+			}
+
+			tmpaddr = (__kernel_size_t) precvbuf->skb->data;
+			alignment = tmpaddr & (RECVBUFF_ALIGN_SZ-1);
+			skb_reserve(precvbuf->skb, (RECVBUFF_ALIGN_SZ - alignment));
+
+		} else {
+			/* reuse skb */
+
+			precvbuf->reuse = false;
+		}
+
+		/*
+		 * spin_lock_irqsave(&precvpriv->lock, &irqL);
+		 * precvpriv->rx_pending_cnt++;
+		 * precvbuf->irp_pending = true;
+		 * spin_unlock_irqrestore(&precvpriv->lock, &irqL);
+		 */
+		precvpriv->rx_pending_cnt++;
+
+		purb = precvbuf->purb;
+
+		/* translate DMA FIFO addr to pipehandle */
+		pipe = usb_rcvbulkpipe(pusbd, rtlusb->RtInPipe[0]);
+
+		usb_fill_bulk_urb(purb, pusbd, pipe,
+						precvbuf->skb->data,
+						MAX_RECVBUF_SZ,
+						_rtl_rx_complete,
+						precvbuf);	/* context is precvbuf */
+
+		err = usb_submit_urb(purb, GFP_ATOMIC);
+		if ((err) && (err != (-EPERM))) {
+			DBG_8192C("cannot submit rx in-token(err = 0x%08x),urb_status = %d\n", err, purb->status);
+			ret = _FAIL;
+		}
+	} else {
+		ret = _FAIL;
+	}
+
+	return ret;
+}
+
+
+static inline int RT_usb_endpoint_dir_in(const struct usb_endpoint_descriptor *epd)
+{
+	return ((epd->bEndpointAddress & USB_ENDPOINT_DIR_MASK) == USB_DIR_IN);
+}
+
+static inline int RT_usb_endpoint_dir_out(const struct usb_endpoint_descriptor *epd)
+{
+	return ((epd->bEndpointAddress & USB_ENDPOINT_DIR_MASK) == USB_DIR_OUT);
+}
+
+static inline int RT_usb_endpoint_xfer_int(const struct usb_endpoint_descriptor *epd)
+{
+	return ((epd->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) == USB_ENDPOINT_XFER_INT);
+}
+
+static inline int RT_usb_endpoint_xfer_bulk(const struct usb_endpoint_descriptor *epd)
+{
+ 	return ((epd->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) == USB_ENDPOINT_XFER_BULK);
+}
+
+static inline int RT_usb_endpoint_is_bulk_in(const struct usb_endpoint_descriptor *epd)
+{
+	return (RT_usb_endpoint_xfer_bulk(epd) && RT_usb_endpoint_dir_in(epd));
+}
+
+static inline int RT_usb_endpoint_is_bulk_out(const struct usb_endpoint_descriptor *epd)
+{
+	return (RT_usb_endpoint_xfer_bulk(epd) && RT_usb_endpoint_dir_out(epd));
+}
+
+static inline int RT_usb_endpoint_num(const struct usb_endpoint_descriptor *epd)
+{
+	return epd->bEndpointAddress & USB_ENDPOINT_NUMBER_MASK;
+}
+
+static uint8_t rtw_init_intf_priv(struct rtl_usb *dvobj)
+{
+	uint8_t rst = _SUCCESS;
+
+#ifdef CONFIG_USB_VENDOR_REQ_MUTEX
+	mutex_init(&dvobj->usb_vendor_req_mutex);
+#endif
+
+
+#ifdef CONFIG_USB_VENDOR_REQ_BUFFER_PREALLOC
+	dvobj->usb_alloc_vendor_req_buf = rtw_zmalloc(MAX_USB_IO_CTL_SIZE);
+	if (dvobj->usb_alloc_vendor_req_buf == NULL) {
+		DBG_871X("alloc usb_vendor_req_buf failed... /n");
+		rst = _FAIL;
+		goto exit;
+	}
+	dvobj->usb_vendor_req_buf  =
+		(uint8_t *)N_BYTE_ALIGMENT((__kernel_size_t)(dvobj->usb_alloc_vendor_req_buf ), ALIGNMENT_UNIT);
+exit:
+#endif
+
+	return rst;
+
+}
+
+static uint8_t rtw_deinit_intf_priv(struct rtl_usb *dvobj)
+{
+	uint8_t rst = _SUCCESS;
+
+#ifdef CONFIG_USB_VENDOR_REQ_BUFFER_PREALLOC
+	if(dvobj->usb_vendor_req_buf)
+		rtw_mfree(dvobj->usb_alloc_vendor_req_buf);
+#endif
+
+#ifdef CONFIG_USB_VENDOR_REQ_MUTEX
+	mutex_destroy(&dvobj->usb_vendor_req_mutex);
+#endif
+
+	return rst;
+}
+
+static struct rtl_usb *usb_dvobj_init(struct usb_interface *usb_intf, struct rtl_usb *rtlusb)
+{
+	int	i;
+	uint8_t	val8;
+	int	status = _FAIL;
+	struct usb_device_descriptor 	*pdev_desc;
+	struct usb_host_config		*phost_conf;
+	struct usb_config_descriptor	*pconf_desc;
+	struct usb_host_interface	*phost_iface;
+	struct usb_interface_descriptor	*piface_desc;
+	struct usb_host_endpoint	*phost_endp;
+	struct usb_endpoint_descriptor	*pendp_desc;
+	struct usb_device			*pusbd;
+
+	mutex_init(&rtlusb->hw_init_mutex);
+	mutex_init(&rtlusb->h2c_fwcmd_mutex);
+	mutex_init(&rtlusb->setch_mutex);
+	mutex_init(&rtlusb->setbw_mutex);
+
+	spin_lock_init(&rtlusb->lock);
+
+	rtlusb->macid[1] = true; 	/* macid=1 for bc/mc stainfo */
+
+
+	rtlusb->intf = usb_intf ;
+	pusbd = rtlusb->udev = interface_to_usbdev(usb_intf);
+	usb_set_intfdata(usb_intf, rtlusb);
+
+	rtlusb->RtNumInPipes = 0;
+	rtlusb->RtNumOutPipes = 0;
+
+	/*
+	 * rtlpriv->EepromAddressSize = 6;
+	 * rtlusb->nr_endpoint = 6;
+	 */
+
+	pdev_desc = &pusbd->descriptor;
+
+
+	phost_conf = pusbd->actconfig;
+	pconf_desc = &phost_conf->desc;
+
+
+	/*
+	 * DBG_871X("\n****** num of altsetting = (%d) ******\n", pusb_interface->num_altsetting);
+	 */
+
+
+	phost_iface = &usb_intf->altsetting[0];
+	piface_desc = &phost_iface->desc;
+
+
+	rtlusb->nr_endpoint = piface_desc->bNumEndpoints;
+
+	/* DBG_871X("\ndump usb_endpoint_descriptor:\n"); */
+
+	for (i = 0; i < rtlusb->nr_endpoint; i++) {
+		phost_endp = phost_iface->endpoint + i;
+		if (phost_endp) 		{
+			pendp_desc = &phost_endp->desc;
+
+			DBG_871X("\nusb_endpoint_descriptor(%d):\n", i);
+			DBG_871X("bLength=%x\n",pendp_desc->bLength);
+			DBG_871X("bDescriptorType=%x\n",pendp_desc->bDescriptorType);
+			DBG_871X("bEndpointAddress=%x\n",pendp_desc->bEndpointAddress);
+			/* DBG_871X("bmAttributes=%x\n",pendp_desc->bmAttributes); */
+			DBG_871X("wMaxPacketSize=%d\n",le16_to_cpu(pendp_desc->wMaxPacketSize));
+			DBG_871X("bInterval=%x\n",pendp_desc->bInterval);
+			/* DBG_871X("bRefresh=%x\n",pendp_desc->bRefresh); */
+			/* DBG_871X("bSynchAddress=%x\n",pendp_desc->bSynchAddress); */
+
+			if (RT_usb_endpoint_is_bulk_in(pendp_desc)) {
+				DBG_871X("RT_usb_endpoint_is_bulk_in = %x\n", RT_usb_endpoint_num(pendp_desc));
+				rtlusb->RtInPipe[rtlusb->RtNumInPipes] = RT_usb_endpoint_num(pendp_desc);
+				rtlusb->RtNumInPipes++;
+			} else if (RT_usb_endpoint_is_bulk_out(pendp_desc)) {
+				DBG_871X("RT_usb_endpoint_is_bulk_out = %x\n", RT_usb_endpoint_num(pendp_desc));
+				rtlusb->RtNumOutPipes++;
+			}
+			rtlusb->ep_num[i] = RT_usb_endpoint_num(pendp_desc);
+		}
+	}
+
+	DBG_871X("nr_endpoint=%d, in_num=%d, out_num=%d\n\n", rtlusb->nr_endpoint, rtlusb->RtNumInPipes, rtlusb->RtNumOutPipes);
+
+	switch(pusbd->speed) {
+	case USB_SPEED_LOW:
+		DBG_871X("USB_SPEED_LOW\n");
+		rtlusb->usb_speed = RTW_USB_SPEED_1_1;
+		break;
+	case USB_SPEED_FULL:
+		DBG_871X("USB_SPEED_FULL\n");
+		rtlusb->usb_speed = RTW_USB_SPEED_1_1;
+		break;
+	case USB_SPEED_HIGH:
+		DBG_871X("USB_SPEED_HIGH\n");
+		rtlusb->usb_speed = RTW_USB_SPEED_2;
+		break;
+	case USB_SPEED_SUPER:
+		DBG_871X("USB_SPEED_SUPER\n");
+		rtlusb->usb_speed = RTW_USB_SPEED_3;
+		break;
+	default:
+		DBG_871X("USB_SPEED_UNKNOWN(%x)\n",pusbd->speed);
+		rtlusb->usb_speed = RTW_USB_SPEED_UNKNOWN;
+		break;
+	}
+
+	if (rtlusb->usb_speed == RTW_USB_SPEED_UNKNOWN) {
+		DBG_871X("UNKNOWN USB SPEED MODE, ERROR !!!\n");
+		goto free_dvobj;
+	}
+
+	if (rtw_init_intf_priv(rtlusb) == _FAIL) {
+		goto free_dvobj;
+	}
+
+	/* .3 misc */
+	rtw_reset_continual_urb_error(rtlusb);
+
+	usb_get_dev(pusbd);
+
+	status = _SUCCESS;
+
+free_dvobj:
+	if (status != _SUCCESS && rtlusb) {
+		usb_set_intfdata(usb_intf, NULL);
+		mutex_destroy(&rtlusb->hw_init_mutex);
+		mutex_destroy(&rtlusb->h2c_fwcmd_mutex);
+		mutex_destroy(&rtlusb->setch_mutex);
+		mutex_destroy(&rtlusb->setbw_mutex);
+		rtlusb = NULL;
+	}
+exit:
+	return rtlusb;
+}
+
+void usb_dvobj_deinit(struct usb_interface *usb_intf)
+{
+	struct rtl_usb *rtlusb = usb_get_intfdata(usb_intf);
+
+	usb_set_intfdata(usb_intf, NULL);
+	if (rtlusb) {
+		if (interface_to_usbdev(usb_intf)->state != USB_STATE_NOTATTACHED) {
+			/*
+			 * If we didn't unplug usb dongle and remove/insert modlue, driver fails on sitesurvey for the first time when device is up .
+			 * Reset usb port for sitesurvey fail issue. 2009.8.13, by Thomas
+			 */
+			DBG_871X("usb attached..., try to reset usb device\n");
+			usb_reset_device(interface_to_usbdev(usb_intf));
+		}
+		rtw_deinit_intf_priv(rtlusb);
+		mutex_destroy(&rtlusb->hw_init_mutex);
+		mutex_destroy(&rtlusb->h2c_fwcmd_mutex);
+		mutex_destroy(&rtlusb->setch_mutex);
+		mutex_destroy(&rtlusb->setbw_mutex);
+	}
+
+	/* DBG_871X("%s %d\n", __func__, atomic_read(&usb_intf->dev.kobj.kref.refcount)); */
+	usb_put_dev(interface_to_usbdev(usb_intf));
+
+
+}
+
+
+
+void usb_intf_start(struct rtl_priv *rtlpriv)
+{
+	uint8_t i;
+	struct recv_buf *precvbuf;
+	uint	status;
+	struct rtl_usb *rtlusb = rtl_usbdev(rtlpriv);
+	struct recv_priv *precvpriv = &(rtlpriv->recvpriv);
+
+	status = _SUCCESS;
+
+	/* issue Rx irp to receive data */
+	precvbuf = (struct recv_buf *)precvpriv->precv_buf;
+	for (i = 0; i < NR_RECVBUFF; i++) {
+		if (_rtl_usb_receive(rtlpriv, 0, (unsigned char *) precvbuf) == false) {
+			status = _FAIL;
+			goto exit;
+		}
+
+		precvbuf++;
+		precvpriv->free_recv_buf_queue_cnt--;
+	}
+
+exit:
+	;
+}
+
+void usb_intf_stop(struct rtl_priv *rtlpriv)
+{
+	/* disabel_hw_interrupt */
+	if (rtlpriv->bSurpriseRemoved == false) {
+		/* device still exists, so driver can do i/o operation */
+		/* TODO: */
+	}
+
+	/* cancel in irp */
+	rtlpriv->cfg->ops->inirp_deinit(rtlpriv);
+
+	/* cancel out irp */
+	usb_write_port_cancel(rtlpriv);
+
+	/* todo:cancel other irps */
+
+}
+
+static void rtw_dev_unload(struct rtl_priv *rtlpriv)
+{
+	struct net_device *ndev= (struct net_device*)rtlpriv->ndev;
+	uint8_t val8;
+
+	if (rtlpriv->initialized == true) {
+		RT_TRACE(rtlpriv, COMP_USB, DBG_LOUD, "===> rtw_dev_unload\n");
+
+		rtlpriv->bDriverStopped = true;
+		/* s3. */
+		usb_intf_stop(rtlpriv);
+
+		/* s4. */
+		if(!rtlpriv->pwrctrlpriv.bInternalAutoSuspend )
+		rtw_stop_drv_threads(rtlpriv);
+
+
+		/* s5. */
+		if(rtlpriv->bSurpriseRemoved == false) {
+			rtw_hal_deinit(rtlpriv);
+			rtlpriv->bSurpriseRemoved = true;
+		}
+
+		rtlpriv->initialized = false;
+	} else {
+		;
+	}
+
+	RT_TRACE(rtlpriv, COMP_USB, DBG_LOUD, "<=== rtw_dev_unload\n");
+}
+
+static void rtw_cancel_all_timer(struct rtl_priv *rtlpriv)
+{
+	del_timer_sync_ex(&rtlpriv->mlmepriv.assoc_timer);
+
+	/*
+	 * del_timer_sync_ex(&rtlpriv->securitypriv.tkip_timer);
+	 * RT_TRACE(_module_os_intfs_c_,_drv_info_,("rtw_cancel_all_timer:cancel tkip_timer! \n"));
+	 */
+
+	del_timer_sync_ex(&rtlpriv->mlmepriv.scan_to_timer);
+	del_timer_sync_ex(&rtlpriv->mlmepriv.dynamic_chk_timer);
+
+	/* cancel sw led timer */
+	rtlpriv->cfg->ops->deinit_sw_leds(rtlpriv);
+
+	del_timer_sync_ex(&rtlpriv->pwrctrlpriv.pwr_state_check_timer);
+
+
+#ifdef CONFIG_NEW_SIGNAL_STAT_PROCESS
+	del_timer_sync_ex(&rtlpriv->recvpriv.signal_stat_timer);
+#endif
+}
+
+static int rtl8821au_suspend(struct usb_interface *pusb_intf, pm_message_t message)
+{
+	struct rtl_usb *rtlusb = usb_get_intfdata(pusb_intf);
+	struct rtl_priv *rtlpriv = rtlusb->rtlpriv;
+	struct net_device *ndev = rtlpriv->ndev;
+	struct mlme_priv *pmlmepriv = &rtlpriv->mlmepriv;
+	struct pwrctrl_priv *pwrpriv = &rtlpriv->pwrctrlpriv;
+	struct usb_device *usb_dev = interface_to_usbdev(pusb_intf);
+
+	int ret = 0;
+	u32 start_time = jiffies;
+
+	DBG_871X("==> %s (%s:%d)\n",__FUNCTION__, current->comm, current->pid);
+
+	if((!rtlpriv->initialized) || (rtlpriv->bDriverStopped)||(rtlpriv->bSurpriseRemoved)) {
+		DBG_871X("rtlpriv->initialized=%d bDriverStopped=%d bSurpriseRemoved = %d\n",
+			rtlpriv->initialized, rtlpriv->bDriverStopped,rtlpriv->bSurpriseRemoved);
+		goto exit;
+	}
+
+	if(pwrpriv->bInternalAutoSuspend )
+	{
+	}
+	pwrpriv->bInSuspend = true;
+	rtw_cancel_all_timer(rtlpriv);
+	LeaveAllPowerSaveMode(rtlpriv);
+
+	down(&pwrpriv->lock);
+	/*
+	 * rtlpriv->net_closed = true;
+	 * s1.
+	 */
+	if (ndev) {
+		netif_carrier_off(ndev);
+		netif_tx_stop_all_queues(ndev);
+	}
+
+	/* s2. */
+	rtw_disassoc_cmd(rtlpriv, 0, false);
+
+	/* s2-2.  indicate disconnect to os */
+	rtw_indicate_disconnect(rtlpriv);
+	/* s2-3. */
+	rtw_free_assoc_resources(rtlpriv, 1);
+#ifdef CONFIG_AUTOSUSPEND
+	if(!pwrpriv->bInternalAutoSuspend )
+#endif
+	/* s2-4. */
+	rtw_free_network_queue(rtlpriv, true);
+
+	rtw_dev_unload(rtlpriv);
+#ifdef CONFIG_AUTOSUSPEND
+	pwrpriv->rf_pwrstate = ERFOFF;
+	pwrpriv->bips_processing = false;
+#endif
+	up(&pwrpriv->lock);
+
+	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY))
+		rtw_indicate_scan_done(rtlpriv, 1);
+
+	if (check_fwstate(pmlmepriv, _FW_UNDER_LINKING))
+		rtw_indicate_disconnect(rtlpriv);
+
+exit:
+	DBG_871X("<===  %s return %d.............. in %dms\n", __FUNCTION__
+		, ret, rtw_get_passing_time_ms(start_time));
+
+	return ret;
+}
+
+static int rtl8821au_resume(struct usb_interface *pusb_intf)
+{
+	struct rtl_usb *rtlusb = usb_get_intfdata(pusb_intf);
+	struct rtl_priv *rtlpriv = rtlusb->rtlpriv;
+
+	return rtw_resume_process(rtlpriv);
+}
+
+
+int _netdev_open(struct net_device *ndev)
+{
+	uint status;
+	struct rtl_priv *rtlpriv =  rtl_priv(ndev);
+	struct pwrctrl_priv *pwrctrlpriv = &rtlpriv->pwrctrlpriv;
+
+	DBG_871X("+871x_drv - drv_open, bup=%d\n", rtlpriv->initialized);
+
+	if (pwrctrlpriv->ps_flag == true) {
+		rtlpriv->net_closed = false;
+		goto netdev_open_normal_process;
+	}
+
+	if (rtlpriv->initialized == false) {
+		rtlpriv->bDriverStopped = false;
+		rtlpriv->bSurpriseRemoved = false;
+		rtlpriv->bCardDisableWOHSM = false;
+
+		status = rtw_hal_init(rtlpriv);
+		if (status == _FAIL) {
+			goto netdev_open_error;
+		}
+
+		DBG_871X("MAC Address = "MAC_FMT"\n", MAC_ARG(ndev->dev_addr));
+
+		status = rtw_start_drv_threads(rtlpriv);
+		if (status == _FAIL) {
+			DBG_871X("Initialize driver software resource Failed!\n");
+			goto netdev_open_error;
+		}
+
+		if (init_hw_mlme_ext(rtlpriv) == _FAIL) {
+			DBG_871X("can't init mlme_ext_priv\n");
+			goto netdev_open_error;
+		}
+
+		usb_intf_start(rtlpriv);
+
+		rtlpriv->initialized = true;
+	}
+	rtlpriv->cfg->ops->led_control(rtlpriv, LED_CTL_POWER_ON);
+	rtlpriv->net_closed = false;
+
+	_set_timer(&rtlpriv->mlmepriv.dynamic_chk_timer, 2000);
+
+	rtlpriv->pwrctrlpriv.bips_processing = false;
+	rtw_set_pwr_state_check_timer(&rtlpriv->pwrctrlpriv);
+
+	/*
+	 * netif_carrier_on(ndev);//call this func when rtw_joinbss_event_callback return success
+	 */
+	if (!rtw_netif_queue_stopped(ndev))
+		netif_tx_start_all_queues(ndev);
+	else
+		netif_tx_wake_all_queues(ndev);
+
+netdev_open_normal_process:
+
+	DBG_871X("-871x_drv - drv_open, initialized=%d\n", rtlpriv->initialized);
+
+	return 0;
+
+netdev_open_error:
+
+	rtlpriv->initialized = false;
+
+	netif_carrier_off(ndev);
+	netif_tx_stop_all_queues(ndev);
+
+	DBG_871X("-871x_drv - drv_open fail, initialized=%d\n", rtlpriv->initialized);
+
+	return (-1);
+
+}
+
+static int netdev_open(struct net_device *ndev)
+{
+	int ret;
+	int _unused;
+
+	struct rtl_priv *rtlpriv =  rtl_priv(ndev);
+
+	/* ULLI: orignal driver doesn't use the return value */
+	_unused = mutex_lock_interruptible(&(rtl_usbdev(rtlpriv)->hw_init_mutex));
+	ret = _netdev_open(ndev);
+	mutex_unlock(&(rtl_usbdev(rtlpriv)->hw_init_mutex));
+
+	return ret;
+}
+
+int  ips_netdrv_open(struct rtl_priv *rtlpriv)
+{
+	int status = _SUCCESS;
+	rtlpriv->net_closed = false;
+
+	DBG_871X("===> %s.........\n", __FUNCTION__);
+
+	rtlpriv->bDriverStopped = false;
+	rtlpriv->bSurpriseRemoved = false;
+	rtlpriv->bCardDisableWOHSM = false;
+	/* rtlpriv->bup = true; */
+
+	status = rtw_hal_init(rtlpriv);
+	if (status == _FAIL) {
+		goto netdev_open_error;
+	}
+
+	usb_intf_start(rtlpriv);
+
+	rtw_set_pwr_state_check_timer(&rtlpriv->pwrctrlpriv);
+	_set_timer(&rtlpriv->mlmepriv.dynamic_chk_timer, 5000);
+
+	 return _SUCCESS;
+
+netdev_open_error:
+	/* rtlpriv->bup = false; */
+	DBG_871X("-ips_netdrv_open - drv_open failure, initialized=%d\n", rtlpriv->initialized);
+
+	return _FAIL;
+}
+
+static uint8_t rtw_reset_drv_sw(struct rtl_priv *rtlpriv)
+{
+	uint8_t	ret8 = _SUCCESS;
+	struct mlme_priv *pmlmepriv = &rtlpriv->mlmepriv;
+	struct pwrctrl_priv *pwrctrlpriv = &rtlpriv->pwrctrlpriv;
+
+	/* hal_priv */
+	rtlpriv->cfg->ops->init_default_value(rtlpriv);
+	rtlpriv->bReadPortCancel = false;
+	rtlpriv->bWritePortCancel = false;
+	pmlmepriv->scan_interval = SCAN_INTERVAL;	/* 30*2 sec = 60sec */
+
+	rtlpriv->xmitpriv.tx_pkts = 0;
+	rtlpriv->recvpriv.rx_pkts = 0;
+
+	pmlmepriv->LinkDetectInfo.bBusyTraffic = false;
+
+	_clr_fwstate_(pmlmepriv, _FW_UNDER_SURVEY | _FW_UNDER_LINKING);
+
+#ifdef CONFIG_AUTOSUSPEND
+#endif
+
+	pwrctrlpriv->pwr_state_check_cnts = 0;
+
+	/* mlmeextpriv */
+	rtlpriv->mlmeextpriv.sitesurvey_res.state = SCAN_DISABLE;
+
+#ifdef CONFIG_NEW_SIGNAL_STAT_PROCESS
+	rtw_set_signal_stat_timer(&rtlpriv->recvpriv);
+#endif
+
+	return ret8;
+}
+
+int rtw_ips_pwr_up(struct rtl_priv *rtlpriv)
+{
+	int result;
+	u32 start_time = jiffies;
+
+	RT_TRACE(rtlpriv, COMP_USB, DBG_LOUD, "===>  rtw_ips_pwr_up..............\n");
+	rtw_reset_drv_sw(rtlpriv);
+
+	result = ips_netdrv_open(rtlpriv);
+
+	rtlpriv->cfg->ops->led_control(rtlpriv, LED_CTL_NO_LINK);
+
+	RT_TRACE(rtlpriv, COMP_USB, DBG_LOUD, "<===  rtw_ips_pwr_up.............. in %dms\n", rtw_get_passing_time_ms(start_time));
+	return result;
+
+}
+
+void rtw_ips_pwr_down(struct rtl_priv *rtlpriv)
+{
+	u32 start_time = jiffies;
+
+	RT_TRACE(rtlpriv, COMP_USB, DBG_LOUD, "===> rtw_ips_pwr_down...................\n");
+
+	rtlpriv->bCardDisableWOHSM = true;
+	rtlpriv->net_closed = true;
+
+	rtw_ips_dev_unload(rtlpriv);
+	rtlpriv->bCardDisableWOHSM = false;
+	RT_TRACE(rtlpriv, COMP_USB, DBG_LOUD, "<=== rtw_ips_pwr_down..................... in %dms\n", rtw_get_passing_time_ms(start_time));
+}
+void rtw_ips_dev_unload(struct rtl_priv *rtlpriv)
+{
+	struct net_device *ndev = (struct net_device *) rtlpriv->ndev;
+	struct xmit_priv	*pxmitpriv = &(rtlpriv->xmitpriv);
+
+	RT_TRACE(rtlpriv, COMP_USB, DBG_LOUD, "====> %s...\n", __FUNCTION__);
+
+	rtlpriv->cfg->ops->set_hw_reg(rtlpriv, HW_VAR_FIFO_CLEARN_UP, 0);
+
+	usb_intf_stop(rtlpriv);
+
+	/* s5. */
+	if (rtlpriv->bSurpriseRemoved == false) {
+		rtw_hal_deinit(rtlpriv);
+	}
+
+}
+
+static int netdev_close(struct net_device *ndev)
+{
+	struct rtl_priv *rtlpriv = rtl_priv(ndev);
+	struct rtl_hal *rtlhal = rtl_hal(rtlpriv);
+
+	if (rtlpriv->pwrctrlpriv.bInternalAutoSuspend == true) {
+		/*rtw_pwr_wakeup(rtlpriv); */
+		if (rtlpriv->pwrctrlpriv.rf_pwrstate == ERFOFF)
+			rtlpriv->pwrctrlpriv.ps_flag = true;
+	}
+	rtlpriv->net_closed = true;
+
+/*	if (!rtlpriv->hw_init_completed)
+	{
+		DBG_871X("(1)871x_drv - drv_close, bup=%d, hw_init_completed=%d\n", rtlpriv->bup, rtlpriv->hw_init_completed);
+
+		rtlpriv->bDriverStopped = true;
+
+		rtw_dev_unload(rtlpriv);
+	}
+	else*/
+	if (rtlpriv->pwrctrlpriv.rf_pwrstate == ERFON) {
+		RT_TRACE(rtlpriv, COMP_USB, DBG_LOUD, "(2)871x_drv - drv_close, initialized=%d, hw_init_completed=%d\n", rtlpriv->initialized, rtlpriv->hw_init_completed);
+
+		/* s1. */
+		if (ndev) {
+			if (!rtw_netif_queue_stopped(ndev))
+				netif_tx_stop_all_queues(ndev);
+		}
+
+		/* s2. */
+		LeaveAllPowerSaveMode(rtlpriv);
+		rtw_disassoc_cmd(rtlpriv, 500, false);
+		/* s2-2.  indicate disconnect to os */
+		rtw_indicate_disconnect(rtlpriv);
+		/* s2-3. */
+		rtw_free_assoc_resources(rtlpriv, 1);
+		/* s2-4. */
+		rtw_free_network_queue(rtlpriv, true);
+		/* Close LED */
+	}
+	rtlpriv->cfg->ops->led_control(rtlpriv, LED_CTL_POWER_OFF);
+	rtlpriv->cfg->ops->deinit_sw_vars(rtlpriv);
+
+	RT_TRACE(rtlpriv, COMP_USB, DBG_LOUD, "-871x_drv - drv_close, initialized=%d\n", rtlpriv->initialized);
+
+	return 0;
+
+}
+
+void rtw_ndev_destructor(struct net_device *ndev)
+{
+	DBG_871X(FUNC_NDEV_FMT"\n", FUNC_NDEV_ARG(ndev));
+
+	free_netdev(ndev);
+}
+
+
+static int pm_netdev_open(struct net_device *ndev, uint8_t bnormal)
+{
+	int status;
+
+	if (true == bnormal)
+		status = netdev_open(ndev);
+	else
+		status =  (_SUCCESS == ips_netdrv_open(rtl_priv(ndev)))?(0):(-1);
+
+	return status;
+}
+
+int rtw_resume_process(struct rtl_priv *rtlpriv)
+{
+	struct net_device *ndev;
+	struct pwrctrl_priv *pwrpriv;
+	int ret = -1;
+	u32 start_time = jiffies;
+
+	RT_TRACE(rtlpriv, COMP_USB, DBG_LOUD, "==> %s (%s:%d)\n",__FUNCTION__, current->comm, current->pid);
+
+	if(rtlpriv) {
+		ndev= rtlpriv->ndev;
+		pwrpriv = &rtlpriv->pwrctrlpriv;
+	} else
+		goto exit;
+
+	down(&pwrpriv->lock);
+	rtw_reset_drv_sw(rtlpriv);
+
+	if(pm_netdev_open(ndev,true) != 0){
+		up(&pwrpriv->lock);
+		goto exit;
+	}
+
+	netif_device_attach(ndev);
+	netif_carrier_on(ndev);
+
+#ifdef CONFIG_AUTOSUSPEND
+	if (pwrpriv->bInternalAutoSuspend) {
+		pwrpriv->bInternalAutoSuspend = false;
+		pwrpriv->brfoffbyhw = false;
+		RT_TRACE(rtlpriv, COMP_USB, DBG_LOUD, "enc_algorithm(%x),wepkeymask(%x)\n",
+			rtlpriv->securitypriv.dot11PrivacyAlgrthm,pwrpriv->wepkeymask);
+		if  ((WEP40_ENCRYPTION == rtlpriv->securitypriv.dot11PrivacyAlgrthm) ||
+			(WEP104_ENCRYPTION == rtlpriv->securitypriv.dot11PrivacyAlgrthm)) {
+			int keyid;
+
+			for (keyid = 0; keyid < 4; keyid++) {
+				if (pwrpriv->wepkeymask & BIT(keyid)) {
+					if (keyid == rtlpriv->securitypriv.dot11PrivacyKeyIndex)
+						rtw_set_key(rtlpriv,&rtlpriv->securitypriv, keyid, 1);
+					else
+						rtw_set_key(rtlpriv,&rtlpriv->securitypriv, keyid, 0);
+				}
+			}
+		}
+	}
+#endif
+	up(&pwrpriv->lock);
+
+	ret = 0;
+exit:
+	pwrpriv->bInSuspend = false;
+	RT_TRACE(rtlpriv, COMP_USB, DBG_LOUD, "<===  %s return %d.............. in %dms\n", __FUNCTION__
+		, ret, rtw_get_passing_time_ms(start_time));
+
+	return ret;
+}
+
+#ifdef CONFIG_AUTOSUSPEND
+void autosuspend_enter(struct rtl_priv* rtlpriv)
+{
+	struct pwrctrl_priv *pwrpriv = &rtlpriv->pwrctrlpriv;
+	struct rtl_usb *rtlusb = rtl_usbdev(rtlpriv);
+
+	RT_TRACE(rtlpriv, COMP_USB, DBG_LOUD, "==>autosuspend_enter...........\n");
+
+	pwrpriv->bInternalAutoSuspend = true;
+	pwrpriv->bips_processing = true;
+
+	if (ERFOFF == pwrpriv->change_rfpwrstate) {
+		usb_enable_autosuspend(dvobj->pusbdev);
+
+			usb_autopm_put_interface(dvobj->pusbintf);
+	}
+	RT_TRACE(rtlpriv, COMP_USB, DBG_DMESG, "...pm_usage_cnt(%d).....\n", atomic_read(&(dvobj->pusbintf->pm_usage_cnt)));
+
+}
+
+int autoresume_enter(struct rtl_priv* rtlpriv)
+{
+	int result = _SUCCESS;
+	struct pwrctrl_priv *pwrpriv = &rtlpriv->pwrctrlpriv;
+	struct security_priv* psecuritypriv=&(rtlpriv->securitypriv);
+	struct mlme_ext_priv	*pmlmeext = &rtlpriv->mlmeextpriv;
+	struct mlme_ext_info	*pmlmeinfo = &(pmlmeext->mlmext_info);
+	struct rtl_usb *rtlusb = rtl_usbdev(rtlpriv);
+
+	RT_TRACE(rtlpriv, COMP_USB, DBG_DMESG, "====> autoresume_enter \n");
+
+	if (ERFOFF == pwrpriv->rf_pwrstate) {
+		pwrpriv->ps_flag = false;
+			if (usb_autopm_get_interface(dvobj->pusbintf) < 0) {
+				RT_TRACE(rtlpriv, COMP_USB, DBG_DMESG,  "can't get autopm: %d\n", result);
+				result = _FAIL;
+				goto error_exit;
+			}
+
+		RT_TRACE(rtlpriv, COMP_USB, DBG_DMESG, "...pm_usage_cnt(%d).....\n", atomic_read(&(dvobj->pusbintf->pm_usage_cnt)));
+	}
+	RT_TRACE(rtlpriv, COMP_USB, DBG_DMESG, "<==== autoresume_enter \n");
+error_exit:
+
+	return result;
+}
+#endif
+
+
+static int rtw_net_set_mac_address(struct net_device *ndev, void *p)
+{
+	struct rtl_priv *rtlpriv = rtl_priv(ndev);
+	struct sockaddr *addr = p;
+
+	if (rtlpriv->initialized == false) {
+		/*
+		 * DBG_871X("r8711_net_set_mac_address(), MAC=%x:%x:%x:%x:%x:%x\n", addr->sa_data[0], addr->sa_data[1], addr->sa_data[2], addr->sa_data[3],
+		 * addr->sa_data[4], addr->sa_data[5]);
+		 */
+		memcpy(rtlpriv->mac80211.mac_addr, addr->sa_data, ETH_ALEN);
+		/*
+		 * memcpy(ndev->dev_addr, addr->sa_data, ETH_ALEN);
+		 * rtlpriv->bset_hwaddr = true;
+		 */
+	}
+
+	return 0;
+}
+
+/*
+ * ULLI messy but needed
+ */
+
+struct net_device_stats *rtw_net_get_stats(struct net_device *ndev);
+uint loadparam(struct rtl_priv *rtlpriv, struct net_device *ndev);
+
+static const struct net_device_ops rtw_netdev_ops = {
+	.ndo_open = netdev_open,
+	.ndo_stop = netdev_close,
+	.ndo_start_xmit = rtw_xmit_entry,
+	.ndo_set_mac_address = rtw_net_set_mac_address,
+	.ndo_get_stats = rtw_net_get_stats,
+	.ndo_do_ioctl = rtw_ioctl,
+};
+
+
+/*
+ * drv_init() - a device potentially for us
+ *
+ * notes: drv_init() is called when the bus driver has located a card for us to support.
+ *        We accept the new device by returning 0.
+*/
+
+struct rtl_priv  *rtw_sw_export = NULL;
+
+static char *ifname = "wlan%d";
+
+static int rtw_init_netdev_name(struct net_device *ndev, const char *ifname)
+{
+	if (dev_alloc_name(ndev, ifname) < 0)
+		/*
+		 * RT_TRACE(_module_os_intfs_c_, _drv_err_, ("dev_alloc_name, fail!\n"));
+		 */
+
+	netif_carrier_off(ndev);
+	return 0;
+}
+
+
+static void _rtl_usb_init_tx(struct rtl_priv *rtlpriv)
+{
+	struct rtl_usb *rtlusb = rtl_usbdev(rtlpriv);
+	struct rtl_hal *rtlhal = rtl_hal(rtlpriv);
+	struct _rtw_hal	*pHalData	= GET_HAL_DATA(rtlpriv);
+
+	if (IS_SUPER_SPEED_USB(rtlpriv))
+		rtlusb->max_bulk_out_size = USB_SUPER_SPEED_BULK_SIZE;	/* 1024 bytes */
+	else if (IS_HIGH_SPEED_USB(rtlpriv))
+		rtlusb->max_bulk_out_size = USB_HIGH_SPEED_BULK_SIZE;	/* 512 bytes */
+	else
+		rtlusb->max_bulk_out_size = USB_FULL_SPEED_BULK_SIZE; 	/*64 bytes */
+
+	pHalData->UsbTxAggDescNum	= 6;	/* only 4 bits */
+
+	if (IS_HARDWARE_TYPE_8812AU(rtlhal))	/* page added for Jaguar */
+		pHalData->UsbTxAggDescNum = 3;
+}
+
+static void _rtl_usb_init_rx(struct rtl_priv *rtlpriv)
+{
+	struct _rtw_hal	*pHalData	= GET_HAL_DATA(rtlpriv);
+	struct rtl_usb	*rtlusb = rtl_usbdev(rtlpriv);
+
+	pHalData->UsbRxAggBlockCount	= 8; 			/* unit : 512b */
+	pHalData->UsbRxAggBlockTimeout	= 0x6;
+	pHalData->UsbRxAggPageCount	= 16; 			/* uint :128 b //0x0A;	// 10 = MAX_RX_DMA_BUFFER_SIZE/2/pHalData->UsbBulkOutSize */
+	pHalData->UsbRxAggPageTimeout = 0x6; 			/* 6, absolute time = 34ms/(2^6) */
+
+	pHalData->RegAcUsbDmaSize = 4;
+	pHalData->RegAcUsbDmaTime = 8;
+
+	rtlpriv->cfg->usb_interface_cfg->usb_endpoint_mapping(rtlpriv);
+}
+
+/* ULLI : ugly but currently we do this here */
+
+/***************************************************/
+
+static void _rtl_init_deferred_work(struct rtl_priv *rtlpriv)
+{
+#if 0
+	/* <1> timer */
+	setup_timer(&rtlpriv->works.watchdog_timer,
+		    rtl_watch_dog_timer_callback, (unsigned long)hw);
+	setup_timer(&rtlpriv->works.dualmac_easyconcurrent_retrytimer,
+		    rtl_easy_concurrent_retrytimer_callback, (unsigned long)hw);
+	/* <2> work queue */
+	rtlpriv->works.hw = hw;
+	rtlpriv->works.rtl_wq = alloc_workqueue("%s", 0, 0, rtlpriv->cfg->name);
+	INIT_DELAYED_WORK(&rtlpriv->works.watchdog_wq,
+			  (void *)rtl_watchdog_wq_callback);
+	INIT_DELAYED_WORK(&rtlpriv->works.ips_nic_off_wq,
+			  (void *)rtl_ips_nic_off_wq_callback);
+	INIT_DELAYED_WORK(&rtlpriv->works.ps_work,
+			  (void *)rtl_swlps_wq_callback);
+	INIT_DELAYED_WORK(&rtlpriv->works.ps_rfon_wq,
+			  (void *)rtl_swlps_rfon_wq_callback);
+	INIT_DELAYED_WORK(&rtlpriv->works.fwevt_wq,
+			  (void *)rtl_fwevt_wq_callback);
+#endif
+}
+
+static void rtl_deinit_deferred_work(struct rtl_priv *rtlpriv)
+{
+#if 0
+	del_timer_sync(&rtlpriv->works.watchdog_timer);
+
+	cancel_delayed_work(&rtlpriv->works.watchdog_wq);
+	cancel_delayed_work(&rtlpriv->works.ips_nic_off_wq);
+	cancel_delayed_work(&rtlpriv->works.ps_work);
+	cancel_delayed_work(&rtlpriv->works.ps_rfon_wq);
+	cancel_delayed_work(&rtlpriv->works.fwevt_wq);
+#endif
+}
+
+static int rtl_init_core(struct rtl_priv *rtlpriv)
+{
+	struct rtl_mac *rtlmac = rtl_mac(rtlpriv);
+
+	/* <1> init mac80211 */
+#if 0
+	_rtl_init_mac80211(hw);
+	rtlmac->hw = hw;
+
+	/* <2> rate control register */
+	hw->rate_control_algorithm = "rtl_rc";
+
+	/*
+	 * <3> init CRDA must come after init
+	 * mac80211 hw  in _rtl_init_mac80211.
+	 */
+	if (rtl_regd_init(hw, rtl_reg_notifier)) {
+		RT_TRACE(rtlpriv, COMP_ERR, DBG_EMERG, "REGD init failed\n");
+		return 1;
+	}
+#endif
+	/* <4> locks */
+#if 0
+	mutex_init(&rtlpriv->locks.conf_mutex);
+	spin_lock_init(&rtlpriv->locks.ips_lock);
+	spin_lock_init(&rtlpriv->locks.irq_th_lock);
+	spin_lock_init(&rtlpriv->locks.h2c_lock);
+	spin_lock_init(&rtlpriv->locks.rf_ps_lock);
+	spin_lock_init(&rtlpriv->locks.rf_lock);
+	spin_lock_init(&rtlpriv->locks.waitq_lock);
+	spin_lock_init(&rtlpriv->locks.entry_list_lock);
+	spin_lock_init(&rtlpriv->locks.cck_and_rw_pagea_lock);
+	spin_lock_init(&rtlpriv->locks.check_sendpkt_lock);
+	spin_lock_init(&rtlpriv->locks.fw_ps_lock);
+	spin_lock_init(&rtlpriv->locks.lps_lock);
+	spin_lock_init(&rtlpriv->locks.iqk_lock);
+	/* <5> init list */
+	INIT_LIST_HEAD(&rtlpriv->entry_list);
+#endif
+	rtlmac->link_state = MAC80211_NOLINK;
+
+	/* <6> init deferred work */
+	_rtl_init_deferred_work(rtlpriv);
+
+	return 0;
+}
+
+/***************************************************/
+
+
+
+
+
+int rtw_usb_probe(struct usb_interface *pusb_intf, const struct usb_device_id *pdid,
+	struct rtl_hal_cfg *rtl_hal_cfg)
+{
+	struct rtl_usb *rtlusb;
+	struct usb_device *udev;
+	struct rtl_priv *rtlpriv = NULL;
+	struct net_device *ndev = NULL;
+	int status = _FAIL;
+
+	ndev = alloc_etherdev_mq(sizeof(*rtlpriv), 4);
+	if (!ndev)
+		goto exit;
+
+	rtlpriv = netdev_priv(ndev);
+	rtlusb = rtl_usbdev(rtlpriv);
+	usb_dvobj_init(pusb_intf, rtlusb);
+
+	rtlpriv = netdev_priv(ndev);
+	rtlpriv->ndev = ndev;
+
+	rtlusb->rtlpriv = rtlpriv;
+	udev = rtlusb->udev;
+
+	/* this spin lock must be initialized early */
+	spin_lock_init(&rtlpriv->locks.usb_lock);
+#if 0
+	INIT_WORK(&rtlpriv->works.fill_h2c_cmd,
+		  rtl_fill_h2c_cmd_work_callback);
+	INIT_WORK(&rtlpriv->works.lps_change_work,
+		  rtl_lps_change_work_callback);
+#endif
+
+
+	/* ULLI must clean/reorder this mess */
+
+	rtw_dbgp_flag_init(rtlpriv);
+
+	/* ULLI: Init IO handler */
+	_rtl_usb_io_handler_init(&udev->dev, rtlpriv);
+
+	rtlpriv->bDriverStopped=true;
+
+	rtlpriv->rtlhal.interface = INTF_USB;
+
+	if (pdid->driver_info == RTL8812) {
+		rtlpriv->rtlhal.hw_type = HARDWARE_TYPE_RTL8812AU;
+		RT_TRACE(rtlpriv, COMP_USB, DBG_LOUD, "CHIP TYPE: RTL8812\n");
+	} else if (pdid->driver_info == RTL8821) {
+		/* rtlpriv->HardwareType = HARDWARE_TYPE_RTL8811AU; */
+		rtlpriv->rtlhal.hw_type = HARDWARE_TYPE_RTL8821U;
+		RT_TRACE(rtlpriv, COMP_USB, DBG_LOUD, "CHIP TYPE: RTL8811AU or RTL8821U\n");
+	}
+
+	/* ndev->init = NULL; */
+
+	RT_TRACE(rtlpriv, COMP_USB, DBG_LOUD, "register rtw_netdev_ops to netdev_ops\n");
+	ndev->netdev_ops = &rtw_netdev_ops;
+
+#ifdef CONFIG_TCP_CSUM_OFFLOAD_TX
+	ndev->features |= NETIF_F_IP_CSUM;
+#endif
+	/* ndev->tx_timeout = NULL; */
+	ndev->watchdog_timeo = HZ*3; /* 3 second timeout */
+#ifdef CONFIG_WIRELESS_EXT
+	ndev->wireless_handlers = (struct iw_handler_def *)&rtw_handlers_def;
+#endif
+
+
+	/* step 2. */
+	loadparam(rtlpriv, ndev);
+
+	SET_NETDEV_DEV(ndev, dvobj_to_dev(rtlusb));
+	rtlpriv = rtl_priv(ndev);
+
+	/* step 2. hook cfg->ops, allocate HalData */
+	/* hal_set_hal_ops(rtlpriv); */
+	rtlpriv->HalData = rtw_zmalloc(sizeof( struct _rtw_hal));
+	if (rtlpriv->HalData == NULL) {
+		RT_TRACE(rtlpriv, COMP_USB, DBG_LOUD, "cant not alloc memory for HAL DATA \n");
+	}
+
+	rtlpriv->cfg = rtl_hal_cfg;
+
+	/* step read_chip_version */
+	rtlpriv->cfg->ops->read_chip_version(rtlpriv);
+
+	/* step usb endpoint mapping */
+	 _rtl_usb_init_tx(rtlpriv);
+	 _rtl_usb_init_rx(rtlpriv);
+
+	/* step read efuse/eeprom data and get mac_addr */
+	rtlpriv->cfg->ops->read_adapter_info(rtlpriv);
+
+	/* step 5. */
+	if(rtlpriv->cfg->ops->init_sw_vars(rtlpriv) ==_FAIL) {
+		goto free_hal_data;
+	}
+
+#ifdef CONFIG_PM
+	if (rtlpriv->pwrctrlpriv.bSupportRemoteWakeup) {
+		rtlusb->udev->do_remote_wakeup=1;
+		pusb_intf->needs_remote_wakeup = 1;
+		device_init_wakeup(&pusb_intf->dev, 1);
+		RT_TRACE(rtlpriv, COMP_USB, DBG_LOUD, "\n  rtlpriv->pwrctrlpriv.bSupportRemoteWakeup~~~~~~\n");
+		RT_TRACE(rtlpriv, COMP_USB, DBG_LOUD, "\n  rtlpriv->pwrctrlpriv.bSupportRemoteWakeup~~~[%d]~~~\n",device_may_wakeup(&pusb_intf->dev));
+	}
+#endif
+
+#ifdef CONFIG_AUTOSUSPEND
+	if (rtlpriv->registrypriv.power_mgnt != PS_MODE_ACTIVE) {
+		if(rtlpriv->registrypriv.usbss_enable ){ 	/* autosuspend (2s delay) */
+			dvobj->pusbdev->dev.power.autosuspend_delay = 0 * HZ;//15 * HZ; idle-delay time
+
+			usb_enable_autosuspend(dvobj->pusbdev);
+
+			/* usb_autopm_get_interface(rtl_usbdev(rtlpriv)->pusbintf );//init pm_usage_cnt ,let it start from 1 */
+
+			RT_TRACE(rtlpriv, COMP_USB, DBG_LOUD, "%s...pm_usage_cnt(%d).....\n",__FUNCTION__,atomic_read(&(dvobj->pusbintf ->pm_usage_cnt)));
+		}
+	}
+#endif
+	/* 2012-07-11 Move here to prevent the 8723AS-VAU BT auto suspend influence */
+	if (usb_autopm_get_interface(pusb_intf) < 0) {
+		RT_TRACE(rtlpriv, COMP_USB, DBG_LOUD,  "can't get autopm: \n");
+	}
+
+	/*  set mac addr */
+	rtw_init_netdev_name(ndev, ifname);
+	rtw_macaddr_cfg(rtlpriv->mac80211.mac_addr);
+
+	RT_TRACE(rtlpriv, COMP_USB, DBG_LOUD, "bDriverStopped:%d, bSurpriseRemoved:%d, initialized:%d, hw_init_completed:%d\n"
+		, rtlpriv->bDriverStopped
+		, rtlpriv->bSurpriseRemoved
+		, rtlpriv->initialized
+		, rtlpriv->hw_init_completed
+	);
+
+	status = _SUCCESS;
+
+	netif_carrier_off(rtlpriv->ndev);
+	/* rtw_netif_stop_queue(ndev); */
+
+/*
+ * 	ULLI : for support older kernel < 3.14,
+ *	ether_addr_copy(ndev->dev_addr, rtlpriv->eeprompriv.mac_addr);
+ */
+	memcpy(ndev->dev_addr, rtlpriv->mac80211.mac_addr, ETH_ALEN);
+
+	/* Tell the network stack we exist */
+	if (register_netdev(rtlpriv->ndev) != 0) {
+		RT_TRACE(rtlpriv, COMP_USB, DBG_LOUD, "register_netdev failed\n");
+		status = _FAIL;
+		goto free_hal_data;
+	}
+
+
+	return 0;
+
+free_dvobj:
+	usb_dvobj_deinit(pusb_intf);
+
+free_hal_data:
+	if (status != _SUCCESS && rtlpriv->HalData)
+		rtw_mfree(rtlpriv->HalData);
+
+free_adapter:
+	if (status != _SUCCESS) {
+		if (ndev)
+			free_netdev(ndev);
+
+		rtlpriv = NULL;
+	}
+exit:
+	return -ENODEV;
+}
+
+
+static uint8_t rtw_free_drv_sw(struct rtl_priv *rtlpriv)
+{
+	struct net_device *ndev = (struct net_device *)rtlpriv->ndev;
+
+	/*
+	 * we can call rtw_p2p_enable here, but:
+	 * 1. rtw_p2p_enable may have IO operation
+	 * 2. rtw_p2p_enable is bundled with wext interface
+	 */
+
+	free_mlme_ext_priv(&rtlpriv->mlmeextpriv);
+
+
+	rtw_free_cmd_priv(&rtlpriv->cmdpriv);
+
+	rtw_free_evt_priv(&rtlpriv->evtpriv);
+
+	rtw_free_mlme_priv(&rtlpriv->mlmepriv);
+
+	/* free_io_queue(rtlpriv); */
+
+	_rtw_free_xmit_priv(&rtlpriv->xmitpriv);
+
+	_rtw_free_sta_priv(&rtlpriv->stapriv); /* will free bcmc_stainfo here */
+
+	_rtw_free_recv_priv(&rtlpriv->recvpriv);
+
+	/* rtw_mfree(rtlpriv); */
+
+	rtlpriv->cfg->ops->free_hal_data(rtlpriv);
+
+	return _SUCCESS;
+
+}
+
+void rtw_usb_if1_deinit(struct rtl_priv *rtlpriv)
+{
+	struct net_device *ndev = rtlpriv->ndev;
+	struct mlme_priv *pmlmepriv= &rtlpriv->mlmepriv;
+
+	if(check_fwstate(pmlmepriv, _FW_LINKED))
+		rtw_disassoc_cmd(rtlpriv, 0, false);
+
+
+#ifdef CONFIG_AP_MODE
+	free_mlme_ap_info(rtlpriv);
+#endif
+
+	if (ndev) {
+		unregister_netdev(ndev); /* will call netdev_close() */
+	}
+
+	rtw_cancel_all_timer(rtlpriv);
+	rtw_dev_unload(rtlpriv);
+
+	RT_TRACE(rtlpriv, COMP_USB, DBG_LOUD,  "+r871xu_dev_remove, hw_init_completed=%d\n", rtlpriv->hw_init_completed);
+
+	rtw_free_drv_sw(rtlpriv);
+
+	if(ndev)
+		free_netdev(ndev);
+}
+
+
+static void dump_usb_interface(struct usb_interface *usb_intf)
+{
+	int	i;
+	uint8_t	val8;
+
+	struct usb_device				*udev = interface_to_usbdev(usb_intf);
+	struct usb_device_descriptor 	*dev_desc = &udev->descriptor;
+
+	struct usb_host_config			*act_conf = udev->actconfig;
+	struct usb_config_descriptor	*act_conf_desc = &act_conf->desc;
+
+	struct usb_host_interface		*host_iface;
+	struct usb_interface_descriptor	*iface_desc;
+	struct usb_host_endpoint		*host_endp;
+	struct usb_endpoint_descriptor	*endp_desc;
+
+#if 1 /* The usb device this usb interface belongs to */
+	DBG_871X("usb_interface:%p, usb_device:%p(num:%d, path:%s), usb_device_descriptor:%p\n", usb_intf, udev, udev->devnum, udev->devpath, dev_desc);
+	DBG_871X("bLength:%u\n", dev_desc->bLength);
+	DBG_871X("bDescriptorType:0x%02x\n", dev_desc->bDescriptorType);
+	DBG_871X("bcdUSB:0x%04x\n", le16_to_cpu(dev_desc->bcdUSB));
+	DBG_871X("bDeviceClass:0x%02x\n", dev_desc->bDeviceClass);
+	DBG_871X("bDeviceSubClass:0x%02x\n", dev_desc->bDeviceSubClass);
+	DBG_871X("bDeviceProtocol:0x%02x\n", dev_desc->bDeviceProtocol);
+	DBG_871X("bMaxPacketSize0:%u\n", dev_desc->bMaxPacketSize0);
+	DBG_871X("idVendor:0x%04x\n", le16_to_cpu(dev_desc->idVendor));
+	DBG_871X("idProduct:0x%04x\n", le16_to_cpu(dev_desc->idProduct));
+	DBG_871X("bcdDevice:0x%04x\n", le16_to_cpu(dev_desc->bcdDevice));
+	DBG_871X("iManufacturer:0x02%x\n", dev_desc->iManufacturer);
+	DBG_871X("iProduct:0x%02x\n", dev_desc->iProduct);
+	DBG_871X("iSerialNumber:0x%02x\n", dev_desc->iSerialNumber);
+	DBG_871X("bNumConfigurations:%u\n", dev_desc->bNumConfigurations);
+#endif
+
+
+#if 1 /* The acting usb_config_descriptor */
+	DBG_871X("\nact_conf_desc:%p\n", act_conf_desc);
+	DBG_871X("bLength:%u\n", act_conf_desc->bLength);
+	DBG_871X("bDescriptorType:0x%02x\n", act_conf_desc->bDescriptorType);
+	DBG_871X("wTotalLength:%u\n", le16_to_cpu(act_conf_desc->wTotalLength));
+	DBG_871X("bNumInterfaces:%u\n", act_conf_desc->bNumInterfaces);
+	DBG_871X("bConfigurationValue:0x%02x\n", act_conf_desc->bConfigurationValue);
+	DBG_871X("iConfiguration:0x%02x\n", act_conf_desc->iConfiguration);
+	DBG_871X("bmAttributes:0x%02x\n", act_conf_desc->bmAttributes);
+	DBG_871X("bMaxPower=%u\n", act_conf_desc->bMaxPower);
+#endif
+
+
+	DBG_871X("****** num of altsetting = (%d) ******/\n", usb_intf->num_altsetting);
+	/* Get he host side alternate setting (the current alternate setting) for this interface*/
+	host_iface = usb_intf->cur_altsetting;
+	iface_desc = &host_iface->desc;
+
+#if 1 /* The current alternate setting*/
+	DBG_871X("\nusb_interface_descriptor:%p:\n", iface_desc);
+	DBG_871X("bLength:%u\n", iface_desc->bLength);
+	DBG_871X("bDescriptorType:0x%02x\n", iface_desc->bDescriptorType);
+	DBG_871X("bInterfaceNumber:0x%02x\n", iface_desc->bInterfaceNumber);
+	DBG_871X("bAlternateSetting=%x\n", iface_desc->bAlternateSetting);
+	DBG_871X("bNumEndpoints=%x\n", iface_desc->bNumEndpoints);
+	DBG_871X("bInterfaceClass=%x\n", iface_desc->bInterfaceClass);
+	DBG_871X("bInterfaceSubClass=%x\n", iface_desc->bInterfaceSubClass);
+	DBG_871X("bInterfaceProtocol=%x\n", iface_desc->bInterfaceProtocol);
+	DBG_871X("iInterface=%x\n", iface_desc->iInterface);
+#endif
+
+
+#if 1
+	/* DBG_871X("\ndump usb_endpoint_descriptor:\n"); */
+
+	for (i = 0; i < iface_desc->bNumEndpoints; i++) {
+		host_endp = host_iface->endpoint + i;
+		if (host_endp) {
+			endp_desc = &host_endp->desc;
+
+			DBG_871X("\nusb_endpoint_descriptor(%d):\n", i);
+			DBG_871X("bLength=%x\n",endp_desc->bLength);
+			DBG_871X("bDescriptorType=%x\n",endp_desc->bDescriptorType);
+			DBG_871X("bEndpointAddress=%x\n",endp_desc->bEndpointAddress);
+			DBG_871X("bmAttributes=%x\n",endp_desc->bmAttributes);
+			DBG_871X("wMaxPacketSize=%x\n",endp_desc->wMaxPacketSize);
+			DBG_871X("wMaxPacketSize=%x\n",le16_to_cpu(endp_desc->wMaxPacketSize));
+			DBG_871X("bInterval=%x\n",endp_desc->bInterval);
+			/* DBG_871X("bRefresh=%x\n",pendp_desc->bRefresh); */
+			/* DBG_871X("bSynchAddress=%x\n",pendp_desc->bSynchAddress); */
+
+			if (RT_usb_endpoint_is_bulk_in(endp_desc)) {
+				DBG_871X("RT_usb_endpoint_is_bulk_in = %x\n", RT_usb_endpoint_num(endp_desc));
+				/* rtlusb->RtNumInPipes++; */
+			} else if (RT_usb_endpoint_is_bulk_out(endp_desc)) {
+				DBG_871X("RT_usb_endpoint_is_bulk_out = %x\n", RT_usb_endpoint_num(endp_desc));
+				/* rtlusb->RtNumOutPipes++; */
+			}
+			/* rtlusb->ep_num[i] = RT_usb_endpoint_num(pendp_desc); */
+		}
+	}
+
+	/*
+	 * DBG_871X("nr_endpoint=%d, in_num=%d, out_num=%d\n\n", rtlusb->nr_endpoint, rtlusb->RtNumInPipes, rtlusb->RtNumOutPipes);
+	 */
+#endif
+
+	if (udev->speed == USB_SPEED_HIGH)
+		DBG_871X("USB_SPEED_HIGH\n");
+	else
+		DBG_871X("NON USB_SPEED_HIGH\n");
+
+}
+
+/*
+ * dev_remove() - our device is being removed
+*/
+/*
+ * rmmod module & unplug(SurpriseRemoved) will call r871xu_dev_remove() => how to recognize both
+ */
+void rtw_usb_disconnect(struct usb_interface *pusb_intf)
+{
+	struct rtl_usb *rtlusb = usb_get_intfdata(pusb_intf);
+	struct rtl_priv *rtlpriv = rtlusb->rtlpriv;
+	struct net_device *ndev = rtlpriv->ndev;
+	struct mlme_priv *pmlmepriv= &rtlpriv->mlmepriv;
+
+	DBG_871X("+rtw_dev_remove\n");
+
+	rtw_pm_set_ips(rtlpriv, IPS_NONE);
+	rtw_pm_set_lps(rtlpriv, PS_MODE_ACTIVE);
+
+	LeaveAllPowerSaveMode(rtlpriv);
+
+	rtw_usb_if1_deinit(rtlpriv);
+
+	usb_dvobj_deinit(pusb_intf);
+
+	DBG_871X("-r871xu_dev_remove, done\n");
+
+	return;
+}
+
+/*  11/16/2008 MH Read one byte from real Efuse. */
+uint8_t
+efuse_OneByteRead(
+		struct rtl_priv *rtlpriv,
+		u16			addr,
+		uint8_t			*data)
+{
+	uint8_t	tmpidx = 0;
+	uint8_t	bResult;
+
+	//DBG_871X("===> EFUSE_OneByteRead(), addr = %x\n", addr);
+	//DBG_871X("===> EFUSE_OneByteRead() start, 0x34 = 0x%X\n", rtl_read_dword(rtlpriv, EFUSE_TEST));
+
+	// -----------------e-fuse reg ctrl ---------------------------------
+	//address
+	rtl_write_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL]+1, (uint8_t)(addr&0xff));
+	rtl_write_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL]+2, ((uint8_t)((addr>>8) &0x03) ) |
+	(rtl_read_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL]+2)&0xFC ));
+
+	rtl_write_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL]+3,  0x72);//read cmd
+
+	while(!(0x80 &rtl_read_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL]+3))&&(tmpidx<1000))
+	{
+		mdelay(1);
+		tmpidx++;
+	}
+	if(tmpidx<1000)
+	{
+		*data=rtl_read_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL]);
+		bResult = true;
+	}
+	else
+	{
+		*data = 0xff;
+		bResult = 0;
+	}
+
+	return bResult;
+}
+
+
+/*
+ * ULLI need this for rtlwifi-lib
+ * void efuse_write_1byte(struct ieee80211_hw *hw, u16 address, u8 value)
+ */
+/*  11/16/2008 MH Write one byte to reald Efuse. */
+uint8_t
+efuse_OneByteWrite(
+		struct rtl_priv *rtlpriv,
+		u16			addr,
+		uint8_t			data)
+{
+	uint8_t	tmpidx = 0;
+	uint8_t	bResult= 0;
+	uint32_t efuseValue = 0;
+
+	//DBG_871X("===> EFUSE_OneByteWrite(), addr = %x data=%x\n", addr, data);
+	//DBG_871X("===> EFUSE_OneByteWrite() start, 0x34 = 0x%X\n", rtl_read_dword(rtlpriv, EFUSE_TEST));
+
+	// -----------------e-fuse reg ctrl ---------------------------------
+	//address
+
+
+	efuseValue = rtl_read_dword(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL]);
+	efuseValue |= (BIT(21)|BIT(31));
+	efuseValue &= ~(0x3FFFF);
+	efuseValue |= ((addr<<8 | data) & 0x3FFFF);
+
+	{
+		rtl_write_dword(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL], efuseValue);
+	}
+
+	while((0x80 &  rtl_read_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL]+3)) && (tmpidx<100) ){
+		mdelay(1);
+		tmpidx++;
+	}
+
+	if(tmpidx<100)
+	{
+		bResult = true;
+	}
+	else
+	{
+		bResult = 0;
+	}
+
+	return bResult;
+}
diff -Naur linux-4.9/drivers/staging/rtl8821au/usb.h linux-4.9.8821au/drivers/staging/rtl8821au/usb.h
--- linux-4.9/drivers/staging/rtl8821au/usb.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/usb.h	2016-12-11 19:48:25.186978326 -0600
@@ -0,0 +1,171 @@
+#ifndef __RTL_USB_H__
+#define __RTL_USB_H__
+
+#include <linux/usb.h>
+
+enum rtl_txq {
+	/* These definitions shall be consistent with value
+	 * returned by skb_get_queue_mapping
+	 *------------------------------------*/
+	RTL_TXQ_BK,
+	RTL_TXQ_BE,
+	RTL_TXQ_VI,
+	RTL_TXQ_VO,
+	/*------------------------------------*/
+	RTL_TXQ_BCN,
+	RTL_TXQ_MGT,
+	RTL_TXQ_HI,
+
+	/* Must be last */
+	__RTL_TXQ_NUM,
+};
+
+struct rtl_ep_map {
+	u32 ep_mapping[__RTL_TXQ_NUM];
+};
+
+/*  Add suspend/resume later */
+enum rtl_usb_state {
+	USB_STATE_STOP	= 0,
+	USB_STATE_START	= 1,
+};
+
+struct rtl_usb {
+	struct usb_device *udev;
+	struct usb_interface *intf;
+	enum rtl_usb_state state;
+
+	/* Bcn control register setting */
+	u32 reg_bcn_ctrl_val;
+	/* for 88/92cu card disable */
+	u8	disableHWSM;
+#if 0	/* ULLI : currently not defined */	
+	/*QOS & EDCA */
+	enum acm_method acm_method;
+#endif	
+	/* irq  . HIMR,HIMR_EX */
+	u32 irq_mask[2];
+	bool irq_enabled;
+
+	u16 (*usb_mq_to_hwq)(__le16 fc, u16 mac80211_queue_index);
+
+	/* Tx */
+	u8 out_ep_nums ;
+	u8 out_queue_sel;
+	struct rtl_ep_map ep_map;
+
+	u32 max_bulk_out_size;
+	u32 tx_submitted_urbs;
+#if 0	/* ULLI : currently not defined */	
+	struct sk_buff_head tx_skb_queue[RTL_USB_MAX_EP_NUM];
+	struct usb_anchor tx_pending[RTL_USB_MAX_EP_NUM];
+	struct usb_anchor tx_submitted;
+
+	struct sk_buff *(*usb_tx_aggregate_hdl)(struct ieee80211_hw *,
+						struct sk_buff_head *);
+	int (*usb_tx_post_hdl)(struct ieee80211_hw *,
+			       struct urb *, struct sk_buff *);
+	void (*usb_tx_cleanup)(struct ieee80211_hw *, struct sk_buff *);
+#endif
+
+	/* Rx */
+	u8 in_ep_nums;
+	u32 in_ep;		/* Bulk IN endpoint number */
+	u32 rx_max_size;	/* Bulk IN max buffer size */
+	u32 rx_urb_num;		/* How many Bulk INs are submitted to host. */
+	struct usb_anchor	rx_submitted;
+	struct usb_anchor	rx_cleanup_urbs;
+	struct tasklet_struct   rx_work_tasklet;
+	struct sk_buff_head	rx_queue;
+#if 0	/* ULLI : currently not defined */	
+	void (*usb_rx_segregate_hdl)(struct ieee80211_hw *, struct sk_buff *,
+				     struct sk_buff_head *);
+	void (*usb_rx_hdl)(struct ieee80211_hw *, struct sk_buff *);
+#endif	
+	/* ULLI : end of rtlwifi rtl_usb */
+	
+        struct rtl_priv *rtlpriv;
+
+	//for local/global synchronization
+	//
+	spinlock_t	lock;
+	int macid[NUM_STA];
+
+	struct mutex hw_init_mutex;
+	struct mutex h2c_fwcmd_mutex;
+	struct mutex setch_mutex;
+	struct mutex setbw_mutex;
+
+	unsigned char	oper_channel; //saved channel info when call set_channel_bw
+
+	//For 92D, DMDP have 2 interface.
+
+	//In /Out Pipe information
+	int	RtInPipe[2];
+
+	uint8_t	irq_alloc;
+
+/*-------- below is for SDIO INTERFACE --------*/
+
+#ifdef INTF_DATA
+	INTF_DATA intf_data;
+#endif
+
+/*-------- below is for USB INTERFACE --------*/
+
+
+	uint8_t	usb_speed; // 1.1, 2.0 or 3.0
+	uint8_t	nr_endpoint;
+	uint8_t	RtNumInPipes;
+	uint8_t	RtNumOutPipes;
+	int	ep_num[6]; //endpoint number
+
+	int	RegUsbSS;
+
+#ifdef CONFIG_USB_VENDOR_REQ_MUTEX
+	struct mutex usb_vendor_req_mutex;
+#endif
+
+#ifdef CONFIG_USB_VENDOR_REQ_BUFFER_PREALLOC
+	uint8_t * usb_alloc_vendor_req_buf;
+	uint8_t * usb_vendor_req_buf;
+#endif
+
+
+	atomic_t continual_urb_error;
+
+/*-------- below is for PCIE INTERFACE --------*/
+
+};
+
+struct rtl_usb_priv {
+	struct rtl_usb	dev;
+	struct	rtl_led_ctl	ledpriv;
+};
+
+#define rtl_usbpriv(rtl)       (&(rtl->priv))
+
+static inline struct device *dvobj_to_dev(struct rtl_usb *dvobj)
+{
+	/* todo: get interface type from dvobj and the return the dev accordingly */
+	return &dvobj->intf->dev;
+}
+
+void usb_write_port_cancel(struct rtl_priv *rtlpriv);
+void usb_read_port_cancel(struct rtl_priv *rtlprivl);
+
+uint32_t usb_read_port(struct rtl_priv *rtlpriv, uint32_t cnt, uint8_t *rmem);
+
+/* ULLI : _rtlw* prefix because of rtlwifi namespace */
+
+u32  _rtlw_usb_transmit(struct rtl_priv *rtlpriv, u32 addr, u32 cnt, struct xmit_buf *pxmitbu);
+
+
+/* ULLI : we use here rtw_usb_* because interface is not complete */
+struct rtl_hal_cfg;
+int rtw_usb_probe(struct usb_interface *pusb_intf, const struct usb_device_id *pdid,
+		struct rtl_hal_cfg *rtl_hal_cfg);
+void rtw_usb_disconnect(struct usb_interface *pusb_intf);
+void usb_intf_stop(struct rtl_priv *rtlpriv);
+void usb_intf_start(struct rtl_priv *rtlpriv);
+#endif
diff -Naur linux-4.9/drivers/staging/rtl8821au/wifi.h linux-4.9.8821au/drivers/staging/rtl8821au/wifi.h
--- linux-4.9/drivers/staging/rtl8821au/wifi.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-4.9.8821au/drivers/staging/rtl8821au/wifi.h	2016-12-11 19:48:25.186978326 -0600
@@ -0,0 +1,2528 @@
+#ifndef __WIFI_H__
+#define __WIFI_H__
+
+#include <linux/types.h>
+#include "usb.h"
+
+#include "efuse.h"	/* ULLI : Note this belongs to base.h we doesn't have */
+#include "debug.h"
+
+#define TOTAL_CAM_ENTRY		32
+#define MAX_RF_PATH_NUM	2
+#define MAX_CHNL_GROUP		3+9
+
+
+enum intf_type {
+	INTF_PCI = 0,
+	INTF_USB = 1,
+};
+
+enum radio_path {
+	RF90_PATH_A = 0,
+	RF90_PATH_B = 1,
+	RF90_PATH_C = 2,
+	RF90_PATH_D = 3,
+};
+
+enum regulation_txpwr_lmt {
+	TXPWR_LMT_FCC = 0,
+	TXPWR_LMT_MKK = 1,
+	TXPWR_LMT_ETSI = 2,
+	TXPWR_LMT_WW = 3,
+
+	TXPWR_LMT_MAX_REGULATION_NUM = 4
+};
+
+enum rate_section {
+	CCK = 0,
+	OFDM,
+	HT_MCS0_MCS7,
+	HT_MCS8_MCS15,
+	HT_MCS16_MCS23,
+	HT_MCS24_MCS31,
+	VHT_1SSMCS0_1SSMCS9,
+	VHT_2SSMCS0_2SSMCS9,
+	VHT_3SSMCS0_3SSMCS9,
+	VHT_4SSMCS0_4SSMCS9,
+};
+
+enum rf_tx_num {
+	RF_1TX = 0,
+	RF_2TX,
+	RF_3TX,
+	RF_4TX,
+	RF_MAX_TX_NUM,
+	RF_TX_NUM_NONIMPLEMENT,
+};
+
+enum rtl_desc92_rate {
+	DESC_RATE1M = 0x00,
+	DESC_RATE2M = 0x01,
+	DESC_RATE5_5M = 0x02,
+	DESC_RATE11M = 0x03,
+
+	DESC_RATE6M = 0x04,
+	DESC_RATE9M = 0x05,
+	DESC_RATE12M = 0x06,
+	DESC_RATE18M = 0x07,
+	DESC_RATE24M = 0x08,
+	DESC_RATE36M = 0x09,
+	DESC_RATE48M = 0x0a,
+	DESC_RATE54M = 0x0b,
+
+	DESC_RATEMCS0 = 0x0c,
+	DESC_RATEMCS1 = 0x0d,
+	DESC_RATEMCS2 = 0x0e,
+	DESC_RATEMCS3 = 0x0f,
+	DESC_RATEMCS4 = 0x10,
+	DESC_RATEMCS5 = 0x11,
+	DESC_RATEMCS6 = 0x12,
+	DESC_RATEMCS7 = 0x13,
+	DESC_RATEMCS8 = 0x14,
+	DESC_RATEMCS9 = 0x15,
+	DESC_RATEMCS10 = 0x16,
+	DESC_RATEMCS11 = 0x17,
+	DESC_RATEMCS12 = 0x18,
+	DESC_RATEMCS13 = 0x19,
+	DESC_RATEMCS14 = 0x1a,
+	DESC_RATEMCS15 = 0x1b,
+	DESC_RATEMCS15_SG = 0x1c,
+	DESC_RATEMCS32 = 0x20,
+
+	DESC_RATEVHT1SS_MCS0 = 0x2c,
+	DESC_RATEVHT1SS_MCS1 = 0x2d,
+	DESC_RATEVHT1SS_MCS2 = 0x2e,
+	DESC_RATEVHT1SS_MCS3 = 0x2f,
+	DESC_RATEVHT1SS_MCS4 = 0x30,
+	DESC_RATEVHT1SS_MCS5 = 0x31,
+	DESC_RATEVHT1SS_MCS6 = 0x32,
+	DESC_RATEVHT1SS_MCS7 = 0x33,
+	DESC_RATEVHT1SS_MCS8 = 0x34,
+	DESC_RATEVHT1SS_MCS9 = 0x35,
+	DESC_RATEVHT2SS_MCS0 = 0x36,
+	DESC_RATEVHT2SS_MCS1 = 0x37,
+	DESC_RATEVHT2SS_MCS2 = 0x38,
+	DESC_RATEVHT2SS_MCS3 = 0x39,
+	DESC_RATEVHT2SS_MCS4 = 0x3a,
+	DESC_RATEVHT2SS_MCS5 = 0x3b,
+	DESC_RATEVHT2SS_MCS6 = 0x3c,
+	DESC_RATEVHT2SS_MCS7 = 0x3d,
+	DESC_RATEVHT2SS_MCS8 = 0x3e,
+	DESC_RATEVHT2SS_MCS9 = 0x3f,
+};
+
+/* Ref: 802.11i sepc D10.0 7.3.2.25.1
+Cipher Suites Encryption Algorithms */
+enum rt_enc_alg {
+	NO_ENCRYPTION = 0,
+	WEP40_ENCRYPTION = 1,
+	TKIP_ENCRYPTION = 2,
+	RSERVED_ENCRYPTION = 3,
+	AESCCMP_ENCRYPTION = 4,
+	WEP104_ENCRYPTION = 5,
+	AESCMAC_ENCRYPTION = 6,	/*IEEE802.11w */
+};
+
+enum rtl_var_map {
+	/*reg map */
+	SYS_ISO_CTRL = 0,
+#if 0
+	SYS_FUNC_EN,
+	SYS_CLK,
+	MAC_RCR_AM,
+	MAC_RCR_AB,
+	MAC_RCR_ACRC32,
+	MAC_RCR_ACF,
+	MAC_RCR_AAP,
+	MAC_HIMR,
+	MAC_HIMRE,
+	MAC_HSISR,
+#endif
+	/*efuse map */
+	EFUSE_TEST,
+	EFUSE_CTRL,
+	EFUSE_CLK,
+	EFUSE_CLK_CTRL,
+	EFUSE_PWC_EV12V,
+	EFUSE_FEN_ELDR,
+	EFUSE_LOADER_CLK_EN,
+	EFUSE_ANA8M,
+	EFUSE_HWSET_MAX_SIZE,
+	EFUSE_MAX_SECTION_MAP,
+	EFUSE_REAL_CONTENT_SIZE,
+	EFUSE_OOB_PROTECT_BYTES_LEN,
+	EFUSE_ACCESS,
+
+	/*CAM map */
+	RWCAM,
+	WCAMI,
+	RCAMO,
+	CAMDBG,
+	SECR,
+	SEC_CAM_NONE,
+	SEC_CAM_WEP40,
+	SEC_CAM_TKIP,
+	SEC_CAM_AES,
+	SEC_CAM_WEP104,
+#if 0
+	/*IMR map */
+	RTL_IMR_BCNDMAINT6,	/*Beacon DMA Interrupt 6 */
+	RTL_IMR_BCNDMAINT5,	/*Beacon DMA Interrupt 5 */
+	RTL_IMR_BCNDMAINT4,	/*Beacon DMA Interrupt 4 */
+	RTL_IMR_BCNDMAINT3,	/*Beacon DMA Interrupt 3 */
+	RTL_IMR_BCNDMAINT2,	/*Beacon DMA Interrupt 2 */
+	RTL_IMR_BCNDMAINT1,	/*Beacon DMA Interrupt 1 */
+	RTL_IMR_BCNDOK8,	/*Beacon Queue DMA OK Interrup 8 */
+	RTL_IMR_BCNDOK7,	/*Beacon Queue DMA OK Interrup 7 */
+	RTL_IMR_BCNDOK6,	/*Beacon Queue DMA OK Interrup 6 */
+	RTL_IMR_BCNDOK5,	/*Beacon Queue DMA OK Interrup 5 */
+	RTL_IMR_BCNDOK4,	/*Beacon Queue DMA OK Interrup 4 */
+	RTL_IMR_BCNDOK3,	/*Beacon Queue DMA OK Interrup 3 */
+	RTL_IMR_BCNDOK2,	/*Beacon Queue DMA OK Interrup 2 */
+	RTL_IMR_BCNDOK1,	/*Beacon Queue DMA OK Interrup 1 */
+	RTL_IMR_TIMEOUT2,	/*Timeout interrupt 2 */
+	RTL_IMR_TIMEOUT1,	/*Timeout interrupt 1 */
+	RTL_IMR_TXFOVW,		/*Transmit FIFO Overflow */
+	RTL_IMR_PSTIMEOUT,	/*Power save time out interrupt */
+	RTL_IMR_BCNINT,		/*Beacon DMA Interrupt 0 */
+	RTL_IMR_RXFOVW,		/*Receive FIFO Overflow */
+	RTL_IMR_RDU,		/*Receive Descriptor Unavailable */
+	RTL_IMR_ATIMEND,	/*For 92C,ATIM Window End Interrupt */
+	RTL_IMR_BDOK,		/*Beacon Queue DMA OK Interrup */
+	RTL_IMR_HIGHDOK,	/*High Queue DMA OK Interrupt */
+	RTL_IMR_COMDOK,		/*Command Queue DMA OK Interrupt*/
+	RTL_IMR_TBDOK,		/*Transmit Beacon OK interrup */
+	RTL_IMR_MGNTDOK,	/*Management Queue DMA OK Interrupt */
+	RTL_IMR_TBDER,		/*For 92C,Transmit Beacon Error Interrupt */
+	RTL_IMR_BKDOK,		/*AC_BK DMA OK Interrupt */
+	RTL_IMR_BEDOK,		/*AC_BE DMA OK Interrupt */
+	RTL_IMR_VIDOK,		/*AC_VI DMA OK Interrupt */
+	RTL_IMR_VODOK,		/*AC_VO DMA Interrupt */
+	RTL_IMR_ROK,		/*Receive DMA OK Interrupt */
+	RTL_IMR_HSISR_IND,	/*HSISR Interrupt*/
+	RTL_IBSS_INT_MASKS,	/*(RTL_IMR_BCNINT | RTL_IMR_TBDOK |
+				 * RTL_IMR_TBDER) */
+	RTL_IMR_C2HCMD,		/*fw interrupt*/
+#endif
+
+	/*CCK Rates, TxHT = 0 */
+	RTL_RC_CCK_RATE1M,
+	RTL_RC_CCK_RATE2M,
+	RTL_RC_CCK_RATE5_5M,
+	RTL_RC_CCK_RATE11M,
+
+	/*OFDM Rates, TxHT = 0 */
+	RTL_RC_OFDM_RATE6M,
+	RTL_RC_OFDM_RATE9M,
+	RTL_RC_OFDM_RATE12M,
+	RTL_RC_OFDM_RATE18M,
+	RTL_RC_OFDM_RATE24M,
+	RTL_RC_OFDM_RATE36M,
+	RTL_RC_OFDM_RATE48M,
+	RTL_RC_OFDM_RATE54M,
+
+	RTL_RC_HT_RATEMCS7,
+	RTL_RC_HT_RATEMCS15,
+
+	RTL_RC_VHT_RATE_1SS_MCS7,
+	RTL_RC_VHT_RATE_1SS_MCS8,
+	RTL_RC_VHT_RATE_1SS_MCS9,
+	RTL_RC_VHT_RATE_2SS_MCS7,
+	RTL_RC_VHT_RATE_2SS_MCS8,
+	RTL_RC_VHT_RATE_2SS_MCS9,
+
+	/*keep it last */
+	RTL_VAR_MAP_MAX,
+};
+
+struct rtl_hal_ops;
+
+#define CHANNEL_MAX_NUMBER	(14 + 24 + 21)	/* 14 is the max channel no */
+#define CHANNEL_MAX_NUMBER_2G		14
+#define CHANNEL_MAX_NUMBER_5G		54 /* Please refer to
+					    *"phy_GetChnlGroup8812A" and
+					    * "Hal_ReadTxPowerInfo8812A"
+					    */
+#define CHANNEL_MAX_NUMBER_5G_80M	7
+#define CHANNEL_GROUP_MAX	(3 + 9)	/*  ch1~3, 4~9, 10~14 = three groups */
+#define CHANNEL_MAX_NUMBER_5G		54 /* Please refer to
+					    *"phy_GetChnlGroup8812A" and
+					    * "Hal_ReadTxPowerInfo8812A"
+					    */
+#define CHANNEL_MAX_NUMBER_5G_80M	7
+#define MAX_PG_GROUP			13
+#define	CHANNEL_GROUP_MAX_2G		3
+#define	CHANNEL_GROUP_IDX_5GL		3
+#define	CHANNEL_GROUP_IDX_5GM		6
+#define	CHANNEL_GROUP_IDX_5GH		9
+#define	CHANNEL_GROUP_MAX_5G		9
+#define CHANNEL_MAX_NUMBER_2G		14
+#define AVG_THERMAL_NUM			8
+#define AVG_THERMAL_NUM_88E		4
+#define AVG_THERMAL_NUM_8723BE		4
+#define AVG_THERMAL_NUM_8812A		4
+#define MAX_TID_COUNT			9
+
+
+
+
+
+
+#define MAX_REGULATION_NUM						3
+#define MAX_RF_PATH_NUM_IN_POWER_LIMIT_TABLE	4
+#define MAX_2_4G_BANDWITH_NUM					2
+#define MAX_2_4G_RATE_SECTION_NUM				3
+#define MAX_2_4G_CHANNEL_NUM						5 // adopt channel group instead of individual channel
+#define MAX_5G_BANDWITH_NUM						4
+#define MAX_5G_RATE_SECTION_NUM					4
+#define MAX_5G_CHANNEL_NUM						14 // adopt channel group instead of individual channel
+
+/*
+ * ULLI : big remark
+ * ULLI : in rtl8821ae there is no use of external_pa_2g or
+ * ULLI : external_pa_5g in the phy.c file.
+ * ULLI : But we need to configure the external_pa* here, because
+ * ULLI : it is used here in the original source, and we don't want to
+ * ULLI : drop this.
+ * ULLI :
+ * ULLI : Thus we do transmit some values use in rtl_dm (now _rtw_dm) and
+ * ULLI : dm_priv into appreciate struct's (rtl_phy, rtl_hal, rtl_efuse)
+ * ULLI : and use them, to select features.
+ */
+#define	MAX_RF_PATH				4
+#define 	RF_PATH_MAX				MAX_RF_PATH
+#define	MAX_CHNL_GROUP_24G		6
+#define	MAX_CHNL_GROUP_5G		14
+
+//It must always set to 4, otherwise read efuse table secquence will be wrong.
+#define 	MAX_TX_COUNT				4
+
+struct txpower_info_2g {
+	u8 index_cck_base[MAX_RF_PATH][MAX_CHNL_GROUP_24G];
+	u8 index_bw40_base[MAX_RF_PATH][MAX_CHNL_GROUP_24G];
+	/*If only one tx, only BW20 and OFDM are used.*/
+	u8 cck_diff[MAX_RF_PATH][MAX_TX_COUNT];
+	u8 ofdm_diff[MAX_RF_PATH][MAX_TX_COUNT];
+	u8 bw20_diff[MAX_RF_PATH][MAX_TX_COUNT];
+	u8 bw40_diff[MAX_RF_PATH][MAX_TX_COUNT];
+	u8 bw80_diff[MAX_RF_PATH][MAX_TX_COUNT];
+	u8 bw160_diff[MAX_RF_PATH][MAX_TX_COUNT];
+};
+
+struct txpower_info_5g {
+	u8 index_bw40_base[MAX_RF_PATH][MAX_CHNL_GROUP_5G];
+	/*If only one tx, only BW20, OFDM, BW80 and BW160 are used.*/
+	u8 ofdm_diff[MAX_RF_PATH][MAX_TX_COUNT];
+	u8 bw20_diff[MAX_RF_PATH][MAX_TX_COUNT];
+	u8 bw40_diff[MAX_RF_PATH][MAX_TX_COUNT];
+	u8 bw80_diff[MAX_RF_PATH][MAX_TX_COUNT];
+	u8 bw160_diff[MAX_RF_PATH][MAX_TX_COUNT];
+};
+
+
+
+
+#define	EFUSE_MAX_LOGICAL_SIZE			512
+
+struct rtl_efuse {	bool autoLoad_ok;
+	bool bootfromefuse;
+	u16 max_physical_size;
+
+	u8 efuse_map[2][EFUSE_MAX_LOGICAL_SIZE];
+	u16 efuse_usedbytes;
+	u8 efuse_usedpercentage;
+#ifdef EFUSE_REPG_WORKAROUND
+	bool efuse_re_pg_sec1flag;
+	u8 efuse_re_pg_data[8];
+#endif
+
+	u8 autoload_failflag;
+	u8 autoload_status;
+
+	short epromtype;
+	u16 eeprom_vid;
+	u16 eeprom_did;
+	u16 eeprom_svid;
+	u16 eeprom_smid;
+	u8 eeprom_oemid;
+	u16 eeprom_channelplan;
+	u8 eeprom_version;
+	u8 board_type;
+	u8 external_pa;
+
+	u8 dev_addr[6];
+	u8 wowlan_enable;
+	u8 antenna_div_cfg;
+	u8 antenna_div_type;
+
+	bool txpwr_fromeprom;
+	u8 eeprom_crystalcap;
+	u8 eeprom_tssi[2];
+	u8 eeprom_tssi_5g[3][2]; /* for 5GL/5GM/5GH band. */
+	u8 eeprom_pwrlimit_ht20[CHANNEL_GROUP_MAX];
+	u8 eeprom_pwrlimit_ht40[CHANNEL_GROUP_MAX];
+	u8 eeprom_chnlarea_txpwr_cck[MAX_RF_PATH][CHANNEL_GROUP_MAX_2G];
+	u8 eeprom_chnlarea_txpwr_ht40_1s[MAX_RF_PATH][CHANNEL_GROUP_MAX];
+	u8 eprom_chnl_txpwr_ht40_2sdf[MAX_RF_PATH][CHANNEL_GROUP_MAX];
+
+	u8 internal_pa_5g[2];	/* pathA / pathB */
+	u8 eeprom_c9;
+	u8 eeprom_cc;
+
+	/*For power group */
+	u8 eeprom_pwrgroup[2][3];
+	u8 pwrgroup_ht20[2][CHANNEL_MAX_NUMBER];
+	u8 pwrgroup_ht40[2][CHANNEL_MAX_NUMBER];
+
+	u8 txpwrlevel_cck[MAX_RF_PATH][CHANNEL_MAX_NUMBER_2G];
+	/*For HT 40MHZ pwr */
+	u8 txpwrlevel_ht40_1s[MAX_RF_PATH][CHANNEL_MAX_NUMBER];
+	/*For HT 40MHZ pwr */
+	u8 txpwrlevel_ht40_2s[MAX_RF_PATH][CHANNEL_MAX_NUMBER];
+
+	/*--------------------------------------------------------*
+	 * 8192CE\8192SE\8192DE\8723AE use the following 4 arrays,
+	 * other ICs (8188EE\8723BE\8192EE\8812AE...)
+	 * define new arrays in Windows code.
+	 * BUT, in linux code, we use the same array for all ICs.
+	 *
+	 * The Correspondance relation between two arrays is:
+	 * txpwr_cckdiff[][] == CCK_24G_Diff[][]
+	 * txpwr_ht20diff[][] == BW20_24G_Diff[][]
+	 * txpwr_ht40diff[][] == BW40_24G_Diff[][]
+	 * txpwr_legacyhtdiff[][] == OFDM_24G_Diff[][]
+	 *
+	 * Sizes of these arrays are decided by the larger ones.
+	 */
+	char txpwr_cckdiff[MAX_RF_PATH][CHANNEL_MAX_NUMBER];
+	char txpwr_ht20diff[MAX_RF_PATH][CHANNEL_MAX_NUMBER];
+	char txpwr_ht40diff[MAX_RF_PATH][CHANNEL_MAX_NUMBER];
+	char txpwr_legacyhtdiff[MAX_RF_PATH][CHANNEL_MAX_NUMBER];
+
+	u8 txpwr_5g_bw40base[MAX_RF_PATH][CHANNEL_MAX_NUMBER];
+	u8 txpwr_5g_bw80base[MAX_RF_PATH][CHANNEL_MAX_NUMBER_5G_80M];
+	char txpwr_5g_ofdmdiff[MAX_RF_PATH][MAX_TX_COUNT];
+	char txpwr_5g_bw20diff[MAX_RF_PATH][MAX_TX_COUNT];
+	char txpwr_5g_bw40diff[MAX_RF_PATH][MAX_TX_COUNT];
+	char txpwr_5g_bw80diff[MAX_RF_PATH][MAX_TX_COUNT];
+
+	u8 txpwr_safetyflag;			/* Band edge enable flag */
+	u16 eeprom_txpowerdiff;
+	u8 legacy_httxpowerdiff;	/* Legacy to HT rate power diff */
+	u8 antenna_txpwdiff[3];
+
+	u8 eeprom_regulatory;
+	u8 eeprom_thermalmeter;
+	u8 thermalmeter[2]; /*ThermalMeter, index 0 for RFIC0, 1 for RFIC1 */
+	u16 tssi_13dbm;
+	u8 crystalcap;		/* CrystalCap. */
+	u8 delta_iqk;
+	u8 delta_lck;
+
+	u8 legacy_ht_txpowerdiff;	/*Legacy to HT rate power diff */
+	bool apk_thermalmeterignore;
+
+	bool b1x1_recvcombine;
+	bool b1ss_support;
+
+	/*channel plan */
+	u8 channel_plan;
+
+};
+
+#define KEY_BUF_SIZE                             5
+#define MAX_KEY_LEN                              61
+
+struct rtl_security {
+	/*default 0 */
+	bool use_sw_sec;
+
+	bool being_setkey;
+	bool use_defaultkey;
+	/*Encryption Algorithm for Unicast Packet */
+	enum rt_enc_alg pairwise_enc_algorithm;
+	/*Encryption Algorithm for Brocast/Multicast */
+	enum rt_enc_alg group_enc_algorithm;
+	/*Cam Entry Bitmap */
+	u32 hwsec_cam_bitmap;
+	u8 hwsec_cam_sta_addr[TOTAL_CAM_ENTRY][ETH_ALEN];
+	/*local Key buffer, indx 0 is for
+	   pairwise key 1-4 is for agoup key. */
+	u8 key_buf[KEY_BUF_SIZE][MAX_KEY_LEN];
+	u8 key_len[KEY_BUF_SIZE];
+
+	/*The pointer of Pairwise Key,
+	   it always points to KeyBuf[4] */
+	u8 *pairwise_key;
+};
+
+enum hw_variables {
+	HW_VAR_ETHER_ADDR,
+	HW_VAR_MULTICAST_REG,
+	HW_VAR_BASIC_RATE,
+	HW_VAR_BSSID,
+	HW_VAR_MEDIA_STATUS,
+	HW_VAR_SECURITY_CONF,
+	HW_VAR_BEACON_INTERVAL,
+	HW_VAR_ATIM_WINDOW,
+	HW_VAR_LISTEN_INTERVAL,
+	HW_VAR_CS_COUNTER,
+	HW_VAR_DEFAULTKEY0,
+	HW_VAR_DEFAULTKEY1,
+	HW_VAR_DEFAULTKEY2,
+	HW_VAR_DEFAULTKEY3,
+	HW_VAR_SIFS,
+	HW_VAR_R2T_SIFS,
+	HW_VAR_DIFS,
+	HW_VAR_EIFS,
+	HW_VAR_SLOT_TIME,
+	HW_VAR_ACK_PREAMBLE,
+	HW_VAR_CW_CONFIG,
+	HW_VAR_CW_VALUES,
+	HW_VAR_RATE_FALLBACK_CONTROL,
+	HW_VAR_CONTENTION_WINDOW,
+	HW_VAR_RETRY_COUNT,
+	HW_VAR_TR_SWITCH,
+	HW_VAR_COMMAND,
+	HW_VAR_WPA_CONFIG,
+	HW_VAR_AMPDU_MIN_SPACE,
+	HW_VAR_SHORTGI_DENSITY,
+	HW_VAR_AMPDU_FACTOR,
+	HW_VAR_MCS_RATE_AVAILABLE,
+	HW_VAR_AC_PARAM,
+	HW_VAR_ACM_CTRL,
+	HW_VAR_DIS_Req_Qsize,
+	HW_VAR_CCX_CHNL_LOAD,
+	HW_VAR_CCX_NOISE_HISTOGRAM,
+	HW_VAR_CCX_CLM_NHM,
+	HW_VAR_TxOPLimit,
+	HW_VAR_TURBO_MODE,
+	HW_VAR_RF_STATE,
+	HW_VAR_RF_OFF_BY_HW,
+	HW_VAR_BUS_SPEED,
+	HW_VAR_SET_DEV_POWER,
+
+	HW_VAR_RCR,
+	HW_VAR_RATR_0,
+	HW_VAR_RRSR,
+	HW_VAR_CPU_RST,
+	HW_VAR_CHECK_BSSID,
+	HW_VAR_LBK_MODE,
+	HW_VAR_AES_11N_FIX,
+	HW_VAR_USB_RX_AGGR,
+	HW_VAR_USER_CONTROL_TURBO_MODE,
+	HW_VAR_RETRY_LIMIT,
+	HW_VAR_INIT_TX_RATE,
+	HW_VAR_TX_RATE_REG,
+	HW_VAR_EFUSE_USAGE,
+	HW_VAR_EFUSE_BYTES,
+	HW_VAR_AUTOLOAD_STATUS,
+	HW_VAR_RF_2R_DISABLE,
+	HW_VAR_SET_RPWM,
+	HW_VAR_H2C_FW_PWRMODE,
+	HW_VAR_H2C_FW_JOINBSSRPT,
+	HW_VAR_H2C_FW_MEDIASTATUSRPT,
+	HW_VAR_H2C_FW_P2P_PS_OFFLOAD,
+	HW_VAR_FW_PSMODE_STATUS,
+	HW_VAR_INIT_RTS_RATE,
+	HW_VAR_RESUME_CLK_ON,
+	HW_VAR_FW_LPS_ACTION,
+	HW_VAR_1X1_RECV_COMBINE,
+	HW_VAR_STOP_SEND_BEACON,
+	HW_VAR_TSF_TIMER,
+	HW_VAR_IO_CMD,
+
+	HW_VAR_RF_RECOVERY,
+	HW_VAR_H2C_FW_UPDATE_GTK,
+	HW_VAR_WF_MASK,
+	HW_VAR_WF_CRC,
+	HW_VAR_WF_IS_MAC_ADDR,
+	HW_VAR_H2C_FW_OFFLOAD,
+	HW_VAR_RESET_WFCRC,
+
+	HW_VAR_HANDLE_FW_C2H,
+	HW_VAR_DL_FW_RSVD_PAGE,
+	HW_VAR_AID,
+	HW_VAR_HW_SEQ_ENABLE,
+	HW_VAR_CORRECT_TSF,
+	HW_VAR_BCN_VALID,
+	HW_VAR_FWLPS_RF_ON,
+	HW_VAR_DUAL_TSF_RST,
+	HW_VAR_SWITCH_EPHY_WoWLAN,
+	HW_VAR_INT_MIGRATION,
+	HW_VAR_INT_AC,
+	HW_VAR_RF_TIMING,
+
+	HAL_DEF_WOWLAN,
+	HW_VAR_MRC,
+	HW_VAR_KEEP_ALIVE,
+	HW_VAR_NAV_UPPER,
+
+	HW_VAR_MGT_FILTER,
+	HW_VAR_CTRL_FILTER,
+	HW_VAR_DATA_FILTER,
+
+	/* ULLI : HW VARS rtlwifi end */
+
+	HW_VAR_MEDIA_STATUS1,
+	HW_VAR_TXPAUSE,
+	HW_VAR_BCN_FUNC,
+	HW_VAR_MLME_DISCONNECT,
+	HW_VAR_MLME_SITESURVEY,
+	HW_VAR_MLME_JOIN,
+	HW_VAR_ON_RCR_AM,
+	HW_VAR_OFF_RCR_AM,
+	HW_VAR_RESP_SIFS,
+	HW_VAR_SEC_CFG,
+	HW_VAR_CAM_WRITE,
+	HW_VAR_CAM_READ,
+	HW_VAR_AC_PARAM_VO,
+	HW_VAR_AC_PARAM_VI,
+	HW_VAR_AC_PARAM_BE,
+	HW_VAR_AC_PARAM_BK,
+	HW_VAR_RXDMA_AGG_PG_TH,
+	HW_VAR_H2C_PS_TUNE_PARAM,
+	HW_VAR_TDLS_WRCR,
+	HW_VAR_TDLS_INIT_CH_SEN,
+	HW_VAR_TDLS_RS_RCR,
+	HW_VAR_TDLS_DONE_CH_SEN,
+	HW_VAR_INITIAL_GAIN,
+	HW_VAR_TRIGGER_GPIO_0,
+	HW_VAR_BT_SET_COEXIST,
+	HW_VAR_BT_ISSUE_DELBA,
+	HW_VAR_CURRENT_ANTENNA,
+	HW_VAR_ANTENNA_DIVERSITY_LINK,
+	HW_VAR_ANTENNA_DIVERSITY_SELECT,
+	HW_VAR_EFUSE_BT_USAGE,
+	HW_VAR_EFUSE_BT_BYTES,
+	HW_VAR_FIFO_CLEARN_UP,
+	HW_VAR_CHECK_TXBUF,
+	HW_VAR_C2H_HANDLE,
+	HW_VAR_RPT_TIMER_SETTING,
+	HW_VAR_TX_RPT_MAX_MACID,
+	HW_VAR_H2C_MEDIA_STATUS_RPT,
+	HW_VAR_CHK_HI_QUEUE_EMPTY,
+	HW_VAR_DL_BCN_SEL,
+	HW_VAR_AMPDU_MAX_TIME,
+	HW_VAR_WIRELESS_MODE,
+};
+
+typedef enum tag_Board_Definition
+{
+    ODM_BOARD_DEFAULT  	= 0, 	  // The DEFAULT case.
+    ODM_BOARD_MINICARD  = BIT(0), // 0 = non-mini card, 1= mini card.
+    ODM_BOARD_SLIM      = BIT(1), // 0 = non-slim card, 1 = slim card
+    ODM_BOARD_BT        = BIT(2), // 0 = without BT card, 1 = with BT
+    ODM_BOARD_EXT_PA    = BIT(3), // 0 = no 2G ext-PA, 1 = existing 2G ext-PA
+    ODM_BOARD_EXT_LNA   = BIT(4), // 0 = no 2G ext-LNA, 1 = existing 2G ext-LNA
+    ODM_BOARD_EXT_TRSW  = BIT(5), // 0 = no ext-TRSW, 1 = existing ext-TRSW
+    ODM_BOARD_EXT_PA_5G    = BIT(6), // 0 = no 5G ext-PA, 1 = existing 5G ext-PA
+    ODM_BOARD_EXT_LNA_5G   = BIT(7), // 0 = no 5G ext-LNA, 1 = existing 5G ext-LNA
+}ODM_BOARD_TYPE_E;
+
+enum band_type {
+	BAND_ON_2_4G = 0,
+	BAND_ON_5G,
+	BAND_ON_BOTH,
+	BANDMAX
+};
+
+/*mlme related.*/
+enum wireless_mode {
+	WIRELESS_MODE_UNKNOWN = 0x00,
+	WIRELESS_MODE_A = 0x01,
+	WIRELESS_MODE_B = 0x02,
+	WIRELESS_MODE_G = 0x04,
+	WIRELESS_MODE_AUTO = 0x08,
+	WIRELESS_MODE_N_24G = 0x10,
+	WIRELESS_MODE_N_5G = 0x20,
+	WIRELESS_MODE_AC_5G = 0x40,
+	WIRELESS_MODE_AC_24G  = 0x80,
+	WIRELESS_MODE_AC_ONLY = 0x100,
+#if 0	/* ULLI : we can't enable this,but this is not used in rtlwifi */
+	WIRELESS_MODE_MAX = 0x800
+#endif
+};
+
+struct rtl_hal {
+#if 0
+	struct ieee80211_hw *hw;
+#endif
+	bool driver_is_goingto_unload;
+	bool up_first_time;
+	bool first_init;
+	bool being_init_adapter;
+	bool bbrf_ready;
+	bool mac_func_enable;
+	bool pre_edcca_enable;
+#if 0
+	struct bt_coexist_8723 hal_coex_8723;
+#endif
+
+	enum intf_type interface;
+	u16 hw_type;		/*92c or 92d or 92s and so on */
+	u8 ic_class;
+	u8 oem_id;
+	u32 version;		/*version of chip */
+	u8 state;		/*stop 0, start 1 */
+	u8 board_type;
+	u8 external_pa;
+
+	u8 pa_mode;
+	u8 pa_type_2g;
+	u8 pa_type_5g;
+	u8 lna_type_2g;
+	u8 lna_type_5g;
+	u8 external_pa_2g;
+	u8 external_lna_2g;
+	u8 external_pa_5g;
+	u8 external_lna_5g;
+	u8 rfe_type;
+
+	/*firmware */
+	u32 fwsize;
+	u8 *pfirmware;
+	u16 fw_version;
+	u16 fw_subversion;
+	bool h2c_setinprogress;
+	u8 last_hmeboxnum;
+	bool fw_ready;
+	/*Reserve page start offset except beacon in TxQ. */
+	u8 fw_rsvdpage_startoffset;
+	u8 h2c_txcmd_seq;
+	u8 current_ra_rate;
+
+	/* FW Cmd IO related */
+	u16 fwcmd_iomap;
+	u32 fwcmd_ioparam;
+	bool set_fwcmd_inprogress;
+	u8 current_fwcmd_io;
+
+#if 0
+	struct p2p_ps_offload_t p2p_ps_offload;
+#endif
+	bool fw_clk_change_in_progress;
+	bool allow_sw_to_change_hwclc;
+	u8 fw_ps_state;
+	/**/
+	bool driver_going2unload;
+
+	/*AMPDU init min space*/
+	u8 minspace_cfg;	/*For Min spacing configurations */
+
+	/* Dual mac */
+#if 0
+	enum macphy_mode macphymode;
+#endif
+	enum band_type current_bandtype;	/* 0:2.4G, 1:5G */
+#if 0
+	enum band_type current_bandtypebackup;
+#endif
+	enum band_type bandset;
+
+	/* dual MAC 0--Mac0 1--Mac1 */
+	u32 interfaceindex;
+	/* just for DualMac S3S4 */
+	u8 macphyctl_reg;
+	bool earlymode_enable;
+	u8 max_earlymode_num;
+	/* Dual mac*/
+	bool during_mac0init_radiob;
+	bool during_mac1init_radioa;
+	bool reloadtxpowerindex;
+	/* true if IMR or IQK  have done
+	for 2.4G in scan progress */
+	bool load_imrandiqk_setting_for2g;
+
+	bool disable_amsdu_8k;
+	bool master_of_dmsp;
+	bool slave_of_dmsp;
+
+	u16 rx_tag;/*for 92ee*/
+	u8 rts_en;
+
+	/*for wowlan*/
+	bool wow_enable;
+	bool enter_pnp_sleep;
+	bool wake_from_pnp_sleep;
+	bool wow_enabled;
+	__kernel_time_t last_suspend_sec;
+	u32 wowlan_fwsize;
+	u8 *wowlan_firmware;
+
+	u8 hw_rof_enable; /*Enable GPIO[9] as WL RF HW PDn source*/
+
+	bool real_wow_v2_enable;
+	bool re_init_llt_table;
+};
+
+
+#define MAX_TX_COUNT			4
+#define MAX_RATE_SECTION_NUM		6
+#define MAX_5G_BANDWITH_NUM		4
+#define	MAX_RF_PATH			4
+#define	MAX_CHNL_GROUP_24G		6
+#define	MAX_CHNL_GROUP_5G		14
+
+#define TX_PWR_BY_RATE_NUM_BAND		2
+#define TX_PWR_BY_RATE_NUM_RF		4
+#define TX_PWR_BY_RATE_NUM_SECTION	12
+#define MAX_BASE_NUM_IN_PHY_REG_PG_24G  6
+#define MAX_BASE_NUM_IN_PHY_REG_PG_5G	5
+
+
+//###### duplicate code,will move to ODM #########
+#define IQK_MAC_REG_NUM		4
+#define IQK_ADDA_REG_NUM		16
+
+#define IQK_BB_REG_NUM			10
+#define IQK_BB_REG_NUM_92C	9
+#define IQK_BB_REG_NUM_92D	10
+#define IQK_BB_REG_NUM_test	6
+
+
+#define IQK_MATRIX_REG_NUM	8
+#define IQK_MATRIX_SETTINGS_NUM	(1 + 24 + 21)
+
+enum rt_polarity_ctl {
+	RT_POLARITY_LOW_ACT = 0,
+	RT_POLARITY_HIGH_ACT = 1,
+};
+
+struct iqk_matrix_regs {
+	bool iqk_done;
+	long value[1][IQK_MATRIX_REG_NUM];
+};
+
+
+struct phy_parameters {
+	u16 length;
+	u32 *pdata;
+};
+
+enum hw_param_tab_index {
+	PHY_REG_2T,
+	PHY_REG_1T,
+	PHY_REG_PG,
+	RADIOA_2T,
+	RADIOB_2T,
+	RADIOA_1T,
+	RADIOB_1T,
+	MAC_REG,
+	AGCTAB_2T,
+	AGCTAB_1T,
+	MAX_TAB
+};
+
+enum io_type {
+	IO_CMD_PAUSE_DM_BY_SCAN = 0,
+	IO_CMD_PAUSE_BAND0_DM_BY_SCAN = 0,
+	IO_CMD_PAUSE_BAND1_DM_BY_SCAN = 1,
+	IO_CMD_RESUME_DM_BY_SCAN = 2,
+};
+
+struct bb_reg_def {
+	u32 rfintfs;
+	u32 rfintfi;
+	u32 rfintfo;
+	u32 rfintfe;
+	u32 rf3wire_offset;
+	u32 rflssi_select;
+	u32 rftxgain_stage;
+	u32 rfhssi_para1;
+	u32 rfhssi_para2;
+	u32 rfsw_ctrl;
+	u32 rfagc_control1;
+	u32 rfagc_control2;
+	u32 rfrxiq_imbal;
+	u32 rfrx_afe;
+	u32 rftxiq_imbal;
+	u32 rftx_afe;
+	u32 rf_rb;		/* rflssi_readback */
+	u32 rf_rbpi;		/* rflssi_readbackpi */
+};
+
+struct init_gain {
+	u8 xaagccore1;
+	u8 xbagccore1;
+	u8 xcagccore1;
+	u8 xdagccore1;
+	u8 cca;
+
+};
+
+struct rtl_phy {
+	struct bb_reg_def phyreg_def[4];	/*Radio A/B/C/D */
+	struct init_gain initgain_backup;
+	enum io_type current_io_type;
+
+	u8 rf_mode;
+	u8 rf_type;
+	u8 current_chan_bw;
+	u8 set_bwmode_inprogress;
+	u8 sw_chnl_inprogress;
+	u8 sw_chnl_stage;
+	u8 sw_chnl_step;
+	u8 current_channel;
+	u8 h2c_box_num;
+	u8 set_io_inprogress;
+	u8 lck_inprogress;
+
+	/* record for power tracking */
+	s32 reg_e94;
+	s32 reg_e9c;
+	s32 reg_ea4;
+	s32 reg_eac;
+	s32 reg_eb4;
+	s32 reg_ebc;
+	s32 reg_ec4;
+	s32 reg_ecc;
+	u8 rfpienable;
+	u8 reserve_0;
+	u16 reserve_1;
+	u32 reg_c04, reg_c08, reg_874;
+	u32 adda_backup[16];
+	u32 iqk_mac_backup[IQK_MAC_REG_NUM];
+	u32 iqk_bb_backup[10];
+	bool iqk_initialized;
+
+	bool rfpath_rx_enable[MAX_RF_PATH];
+	u8 reg_837;
+	/* Dual mac */
+	bool need_iqk;
+	struct iqk_matrix_regs iqk_matrix[IQK_MATRIX_SETTINGS_NUM];
+
+	bool rfpi_enable;
+	bool iqk_in_progress;
+
+	u8 pwrgroup_cnt;
+	u8 cck_high_power;
+	/* this is for 88E & 8723A */
+	u32 mcs_txpwrlevel_origoffset[MAX_PG_GROUP][16];
+	/* MAX_PG_GROUP groups of pwr diff by rates */
+	u32 mcs_offset[MAX_PG_GROUP][16];
+
+	u32 tx_power_by_rate_offset[TX_PWR_BY_RATE_NUM_BAND]
+				   [TX_PWR_BY_RATE_NUM_RF]
+				   [TX_PWR_BY_RATE_NUM_RF]
+				   [TX_PWR_BY_RATE_NUM_SECTION];
+	u8 txpwr_by_rate_base_24g[TX_PWR_BY_RATE_NUM_RF]
+				 [TX_PWR_BY_RATE_NUM_RF]
+				 [MAX_BASE_NUM_IN_PHY_REG_PG_24G];
+	u8 txpwr_by_rate_base_5g[TX_PWR_BY_RATE_NUM_RF]
+				[TX_PWR_BY_RATE_NUM_RF]
+				[MAX_BASE_NUM_IN_PHY_REG_PG_5G];
+	u8 default_initialgain[4];
+
+	/* the current Tx power level */
+	u8 cur_cck_txpwridx;
+	u8 cur_ofdm24g_txpwridx;
+	u8 cur_bw20_txpwridx;
+	u8 cur_bw40_txpwridx;
+
+	char txpwr_limit_2_4g[MAX_REGULATION_NUM]
+			     [MAX_2_4G_BANDWITH_NUM]
+			     [MAX_RATE_SECTION_NUM]
+			     [CHANNEL_MAX_NUMBER_2G]
+			     [MAX_RF_PATH_NUM];
+	char txpwr_limit_5g[MAX_REGULATION_NUM]
+			   [MAX_5G_BANDWITH_NUM]
+			   [MAX_RATE_SECTION_NUM]
+			   [CHANNEL_MAX_NUMBER_5G]
+			   [MAX_RF_PATH_NUM];
+
+	u32 rfreg_chnlval[2];
+	bool apk_done;
+	u32 reg_rf3c[2];	/* pathA / pathB  */
+
+	u32 backup_rf_0x1a;/*92ee*/
+	/* bfsync */
+	u8 framesync;
+	u32 framesync_c34;
+
+	u8 num_total_rfpath;
+	struct phy_parameters hwparam_tables[MAX_TAB];
+	u16 rf_pathmap;
+
+	u8 hw_rof_enable; /*Enable GPIO[9] as WL RF HW PDn source*/
+	enum rt_polarity_ctl polarity_ctl;
+
+
+	/* ULLI : Border from old (struct rtw_hal) */
+
+#define MAX_BASE_NUM_IN_PHY_REG_PG_2_4G			4 //  CCK:1,OFDM:2, HT:2
+#define MAX_BASE_NUM_IN_PHY_REG_PG_5G			5 // OFDM:1, HT:2, VHT:2
+
+	/* ULLI: neded to convert this */
+
+	//---------------------------------------------------------------------------------//
+
+	// Power Limit Table for 2.4G
+};
+
+
+#define AVG_THERMAL_NUM		8
+#define IQK_Matrix_REG_NUM		8
+#define IQK_Matrix_Settings_NUM	14+24+21 // Channels_2_4G_NUM + Channels_5G_20M_NUM + Channels_5G
+
+#define ASSOCIATE_ENTRY_NUM					32 // Max size of AsocEntry[].
+#define	ODM_ASSOCIATE_ENTRY_NUM				ASSOCIATE_ENTRY_NUM
+
+struct fast_ant_training {
+	u8	bssid[6];
+	u8	antsel_rx_keep_0;
+	u8	antsel_rx_keep_1;
+	u8	antsel_rx_keep_2;
+	u32	ant_sum[7];
+	u32	ant_cnt[7];
+	u32	ant_ave[7];
+	u8	fat_state;
+	u32	train_idx;
+	u8	antsel_a[ASSOCIATE_ENTRY_NUM];
+	u8	antsel_b[ASSOCIATE_ENTRY_NUM];
+	u8	antsel_c[ASSOCIATE_ENTRY_NUM];
+	u32	main_ant_sum[ASSOCIATE_ENTRY_NUM];
+	u32	aux_ant_sum[ASSOCIATE_ENTRY_NUM];
+	u32	main_ant_cnt[ASSOCIATE_ENTRY_NUM];
+	u32	aux_ant_cnt[ASSOCIATE_ENTRY_NUM];
+	u8	rx_idle_ant;
+	bool	becomelinked;
+};
+
+
+struct dm_phy_dbg_info {
+	char rx_snrdb[4];
+	u64 num_qry_phy_status;
+	u64 num_qry_phy_status_cck;
+	u64 num_qry_phy_status_ofdm;
+	u16 num_qry_beacon_pkt;
+	u16 num_non_be_pkt;
+	s32 rx_evm[4];
+};
+
+#define DEL_SW_IDX_SZ		30
+#define BAND_NUM			3
+
+/* ULLI : Follwing needed for Rate Adaptive */
+
+typedef struct _ODM_RA_Info_ {
+	u8 RateID;
+	uint32_t RateMask;
+	uint32_t RAUseRate;
+	u8 RateSGI;
+	u8 RssiStaRA;
+	u8 PreRssiStaRA;
+	u8 SGIEnable;
+	u8 DecisionRate;
+	u8 PreRate;
+	u8 HighestRate;
+	u8 LowestRate;
+	uint32_t NscUp;
+	uint32_t NscDown;
+	u16 RTY[5];
+	uint32_t TOTAL;
+	u16 DROP;
+	u8 Active;
+	u16 RptTime;
+	u8 RAWaitingCounter;
+	u8 RAPendingCounter;
+} ODM_RA_INFO_T,*PODM_RA_INFO_T;
+
+struct rtl_dm {
+	/*PHY status for Dynamic Management */
+	long entry_min_undec_sm_pwdb;
+	long undec_sm_cck;
+	long undec_sm_pwdb;	/*out dm */
+	long entry_max_undec_sm_pwdb;
+	s32 ofdm_pkt_cnt;
+	bool dm_initialgain_enable;
+	bool dynamic_txpower_enable;
+	bool current_turbo_edca;
+	bool is_any_nonbepkts;	/*out dm */
+	bool is_cur_rdlstate;
+	bool txpower_trackinginit;
+	bool disable_framebursting;
+	bool cck_inch14;
+	bool txpower_tracking;
+	bool useramask;
+	bool rfpath_rxenable[4];
+	bool inform_fw_driverctrldm;
+	bool current_mrc_switch;
+	u8 txpowercount;
+	u8 powerindex_backup[6];
+
+	u8 thermalvalue_rxgain;
+	u8 thermalvalue_iqk;
+	u8 thermalvalue_lck;
+	u8 thermalvalue;		/* introduced in commit 1637c1b7e */
+	u8 last_dtp_lvl;
+	u8 thermalvalue_avg[AVG_THERMAL_NUM];
+	u8 thermalvalue_avg_index;
+	u8 tm_trigger;
+	bool done_txpower;
+	u8 dynamic_txhighpower_lvl;	/*Tx high power level */
+	u8 dm_flag;		/*Indicate each dynamic mechanism's status. */
+	u8 dm_flag_tmp;
+	u8 dm_type;
+	u8 dm_rssi_sel;
+	u8 txpower_track_control;
+	bool interrupt_migration;
+	bool disable_tx_int;
+	char ofdm_index[MAX_RF_PATH];
+	u8 default_ofdm_index;
+	u8 default_cck_index;
+	char cck_index;
+	char delta_power_index[MAX_RF_PATH];
+	char delta_power_index_last[MAX_RF_PATH];
+	char power_index_offset[MAX_RF_PATH];
+	char absolute_ofdm_swing_idx[MAX_RF_PATH];
+	char remnant_ofdm_swing_idx[MAX_RF_PATH];
+	char remnant_cck_idx;
+	bool modify_txagc_flag_path_a;
+	bool modify_txagc_flag_path_b;
+
+	bool one_entry_only;
+
+	struct dm_phy_dbg_info dbginfo;
+
+	/* Dynamic ATC switch */
+	bool atc_status;
+	bool large_cfo_hit;
+	bool is_freeze;
+	int cfo_tail[2];
+	int cfo_ave_pre;
+	int crystal_cap;
+	u8 cfo_threshold;
+	u32 packet_count;
+	u32 packet_count_pre;
+	u8 tx_rate;
+
+	/*88e tx power tracking*/
+	u8	swing_idx_ofdm[MAX_RF_PATH];
+	u8	swing_idx_ofdm_cur;
+	u8	swing_idx_ofdm_base[MAX_RF_PATH];
+	bool	swing_flag_ofdm;
+	u8	swing_idx_cck;
+	u8	swing_idx_cck_cur;
+	u8	swing_idx_cck_base;
+	bool	swing_flag_cck;
+
+	char	swing_diff_2g;
+	char	swing_diff_5g;
+
+	u8 delta_swing_table_idx_24gccka_p[DEL_SW_IDX_SZ];
+	u8 delta_swing_table_idx_24gccka_n[DEL_SW_IDX_SZ];
+	u8 delta_swing_table_idx_24gcckb_p[DEL_SW_IDX_SZ];
+	u8 delta_swing_table_idx_24gcckb_n[DEL_SW_IDX_SZ];
+	u8 delta_swing_table_idx_24ga_p[DEL_SW_IDX_SZ];
+	u8 delta_swing_table_idx_24ga_n[DEL_SW_IDX_SZ];
+	u8 delta_swing_table_idx_24gb_p[DEL_SW_IDX_SZ];
+	u8 delta_swing_table_idx_24gb_n[DEL_SW_IDX_SZ];
+	u8 delta_swing_table_idx_5ga_p[BAND_NUM][DEL_SW_IDX_SZ];
+	u8 delta_swing_table_idx_5ga_n[BAND_NUM][DEL_SW_IDX_SZ];
+	u8 delta_swing_table_idx_5gb_p[BAND_NUM][DEL_SW_IDX_SZ];
+	u8 delta_swing_table_idx_5gb_n[BAND_NUM][DEL_SW_IDX_SZ];
+	u8 delta_swing_table_idx_24ga_p_8188e[DEL_SW_IDX_SZ];
+	u8 delta_swing_table_idx_24ga_n_8188e[DEL_SW_IDX_SZ];
+
+	/* DMSP */
+	bool supp_phymode_switch;
+
+	/* DulMac */
+	struct fast_ant_training fat_table;
+
+	u8	resp_tx_path;
+	u8	path_sel;
+	u32	patha_sum;
+	u32	pathb_sum;
+	u32	patha_cnt;
+	u32	pathb_cnt;
+
+	u8 pre_channel;
+	u8 *p_channel;
+	u8 linked_interval;
+
+	u64 last_tx_ok_cnt;
+	u64 last_rx_ok_cnt;
+
+/* ULLI : Form struct _rtw_dm, aka original sources */
+
+	u16 			CurrminRptTime;
+	ODM_RA_INFO_T   RAInfo[ODM_ASSOCIATE_ENTRY_NUM]; //See HalMacID support
+	struct sta_info *pODM_StaInfo[ODM_ASSOCIATE_ENTRY_NUM];
+	bool bOneEntryOnly;
+};
+
+#define rtl_hal(rtlpriv)	(&((rtlpriv)->rtlhal))
+#define rtl_mac(rtlpriv)	(&((rtlpriv)->mac80211))
+#define rtl_efuse(rtlpriv)	(&((rtlpriv)->efuse))
+#define rtl_phy(rtlpriv)	(&((rtlpriv)->phy))
+#define rtl_dm(rtlpriv)		(&((rtlpriv)->dm))
+#define rtl_psc(rtlpriv)	(&((rtlpriv)->psc))
+#define rtl_priv(ndev)		(netdev_priv(ndev))
+
+struct rtl_mod_params {
+	/* default: 0 = using hardware encryption */
+	bool sw_crypto;
+
+	/* default: 0 = DBG_EMERG (0)*/
+	int debug;
+
+	/* default: 1 = using no linked power save */
+	bool inactiveps;
+
+	/* default: 1 = using linked sw power save */
+	bool swctrl_lps;
+
+	/* default: 1 = using linked fw power save */
+	bool fwctrl_lps;
+
+	/* default: 0 = not using MSI interrupts mode
+	 * submodules should set their own default value
+	 */
+	bool msi_support;
+
+	/* default 0: 1 means disable */
+	bool disable_watchdog;
+};
+
+struct rtl_hal_usbint_cfg {
+	/* data - rx */
+	u32 in_ep_num;
+	u32 rx_urb_num;
+	u32 rx_max_size;
+#if 0	/* ULLI Currently disabled */
+	/* op - rx */
+	void (*usb_rx_hdl)(struct ieee80211_hw *, struct sk_buff *);
+	void (*usb_rx_segregate_hdl)(struct ieee80211_hw *, struct sk_buff *,
+				     struct sk_buff_head *);
+
+	/* tx */
+	void (*usb_tx_cleanup)(struct ieee80211_hw *, struct sk_buff *);
+	int (*usb_tx_post_hdl)(struct ieee80211_hw *, struct urb *,
+			       struct sk_buff *);
+	struct sk_buff *(*usb_tx_aggregate_hdl)(struct ieee80211_hw *,
+						struct sk_buff_head *);
+
+	/* endpoint mapping */
+#endif
+	int (*usb_endpoint_mapping)(struct rtl_priv *rtlpriv);
+#if 0
+	u16 (*usb_mq_to_hwq)(__le16 fc, u16 mac80211_queue_index);
+#endif
+};
+
+struct rtl_hal_cfg {
+	u8 bar_id;
+	bool write_readback;
+	char *name;
+	char *fw_name;
+	char *alt_fw_name;
+	struct rtl_hal_ops *ops;
+	struct rtl_mod_params *mod_params;
+	struct rtl_hal_usbint_cfg *usb_interface_cfg;
+	/*this map used for some registers or vars
+	   defined int HAL but used in MAIN */
+	u32 maps[RTL_VAR_MAP_MAX];
+};
+
+struct rtl_priv;
+struct rtl_io {
+	struct device *dev;
+	struct mutex bb_mutex;
+
+	/*PCI MEM map */
+	unsigned long pci_mem_end;	/*shared mem end        */
+	unsigned long pci_mem_start;	/*shared mem start */
+
+	/*PCI IO map */
+	unsigned long pci_base_addr;	/*device I/O address */
+
+	void (*write8_async) (struct rtl_priv *rtlpriv, u32 addr, u8 val);
+	void (*write16_async) (struct rtl_priv *rtlpriv, u32 addr, u16 val);
+	void (*write32_async) (struct rtl_priv *rtlpriv, u32 addr, u32 val);
+	void (*writeN_sync) (struct rtl_priv *rtlpriv, u32 addr, void *buf,
+			     u16 len);
+
+	u8(*read8_sync) (struct rtl_priv *rtlpriv, u32 addr);
+	u16(*read16_sync) (struct rtl_priv *rtlpriv, u32 addr);
+	u32(*read32_sync) (struct rtl_priv *rtlpriv, u32 addr);
+};
+
+struct dig_t {
+	u32 rssi_lowthresh;
+	u32 rssi_highthresh;
+	u32 fa_lowthresh;
+	u32 fa_highthresh;
+	long last_min_undec_pwdb_for_dm;
+	long rssi_highpower_lowthresh;
+	long rssi_highpower_highthresh;
+	u32 recover_cnt;
+	u32 pre_igvalue;
+	u32 cur_igvalue;
+	long rssi_val;
+	u8 dig_enable_flag;
+	u8 dig_ext_port_stage;
+	u8 dig_algorithm;
+	u8 dig_twoport_algorithm;
+	u8 dig_dbgmode;
+	u8 dig_slgorithm_switch;
+	u8 cursta_cstate;
+	u8 presta_cstate;
+	u8 curmultista_cstate;
+	u8 stop_dig;
+	char back_val;
+	char back_range_max;
+	char back_range_min;
+	u8 rx_gain_max;
+	u8 rx_gain_min;
+	u8 min_undec_pwdb_for_dm;
+	u8 rssi_val_min;
+	u8 pre_cck_cca_thres;
+	u8 cur_cck_cca_thres;
+	u8 pre_cck_pd_state;
+	u8 cur_cck_pd_state;
+	u8 pre_cck_fa_state;
+	u8 cur_cck_fa_state;
+	u8 pre_ccastate;
+	u8 cur_ccasate;
+	u8 large_fa_hit;
+	u8 forbidden_igi;
+	u8 dig_state;
+	u8 dig_highpwrstate;
+	u8 cur_sta_cstate;
+	u8 pre_sta_cstate;
+	u8 cur_ap_cstate;
+	u8 pre_ap_cstate;
+	u8 cur_pd_thstate;
+	u8 pre_pd_thstate;
+	u8 cur_cs_ratiostate;
+	u8 pre_cs_ratiostate;
+	u8 backoff_enable_flag;
+	char backoffval_range_max;
+	char backoffval_range_min;
+	u8 dig_min_0;
+	u8 dig_min_1;
+	u8 bt30_cur_igi;
+	bool media_connect_0;
+	bool media_connect_1;
+
+	u32 antdiv_rssi_max;
+	u32 rssi_max;
+
+/* ULLI : not in rtlwifi */
+
+	u8 BackupIGValue;
+};
+
+struct rate_adaptive {
+	u8 rate_adaptive_disabled;
+	u8 ratr_state;
+	u16 reserve;
+
+	u32 high_rssi_thresh_for_ra;
+	u32 high2low_rssi_thresh_for_ra;
+	u8 low2high_rssi_thresh_for_ra40m;
+	u32 low_rssi_thresh_for_ra40m;
+	u8 low2high_rssi_thresh_for_ra20m;
+	u32 low_rssi_thresh_for_ra20m;
+	u32 upper_rssi_threshold_ratr;
+	u32 middleupper_rssi_threshold_ratr;
+	u32 middle_rssi_threshold_ratr;
+	u32 middlelow_rssi_threshold_ratr;
+	u32 low_rssi_threshold_ratr;
+	u32 ultralow_rssi_threshold_ratr;
+	u32 low_rssi_threshold_ratr_40m;
+	u32 low_rssi_threshold_ratr_20m;
+	u8 ping_rssi_enable;
+	u32 ping_rssi_ratr;
+	u32 ping_rssi_thresh_for_ra;
+	u32 last_ratr;
+	u8 pre_ratr_state;
+	u8 ldpc_thres;
+	bool use_ldpc;
+	bool lower_rts_rate;
+	bool is_special_data;
+};
+
+enum rtl_link_state {
+	MAC80211_NOLINK = 0,
+	MAC80211_LINKING = 1,
+	MAC80211_LINKED = 2,
+	MAC80211_LINKED_SCANNING = 3,
+};
+
+struct rtl_mac {
+	u8 mac_addr[ETH_ALEN];
+	u8 mac80211_registered;
+	u8 beacon_enabled;
+
+	u32 tx_ss_num;
+	u32 rx_ss_num;
+
+#if 0	/* ULLI : Currently we are using wireless ext */
+	struct ieee80211_supported_band bands[IEEE80211_NUM_BANDS];
+	struct ieee80211_hw *hw;
+	struct ieee80211_vif *vif;
+	enum nl80211_iftype opmode;
+#endif
+
+	/*Probe Beacon management */
+#if 0	/* Ulli : currently we are using wireless-ext */
+	struct rtl_tid_data tids[MAX_TID_COUNT];
+#endif
+	enum rtl_link_state link_state;
+	int n_channels;
+	int n_bitrates;
+
+	bool offchan_delay;
+	u8 p2p;	/*using p2p role*/
+	bool p2p_in_use;
+
+	/*filters */
+	u32 rx_conf;
+	u16 rx_mgt_filter;
+	u16 rx_ctrl_filter;
+	u16 rx_data_filter;
+
+	bool act_scanning;
+	u8 cnt_after_linked;
+	bool skip_scan;
+
+	/* early mode */
+	/* skb wait queue */
+	struct sk_buff_head skb_waitq[MAX_TID_COUNT];
+
+	u8 ht_stbc_cap;
+	u8 ht_cur_stbc;
+
+	/*vht support*/
+	u8 vht_enable;
+	u8 bw_80;
+	u8 vht_cur_ldpc;
+	u8 vht_cur_stbc;
+	u8 vht_stbc_cap;
+	u8 vht_ldpc_cap;
+
+	/*RDG*/
+	bool rdg_en;
+
+	/*AP*/
+	u8 bssid[ETH_ALEN] __aligned(2);
+	u32 vendor;
+	u8 mcs[16];	/* 16 bytes mcs for HT rates. */
+	u32 basic_rates; /* b/g rates */
+	u8 ht_enable;
+	u8 sgi_40;
+	u8 sgi_20;
+	u8 bw_40;
+	u16 mode;		/* wireless mode */
+	u8 slot_time;
+	u8 short_preamble;
+	u8 use_cts_protect;
+	u8 cur_40_prime_sc;
+	u8 cur_40_prime_sc_bk;
+	u8 cur_80_prime_sc;
+	u64 tsf;
+	u8 retry_short;
+	u8 retry_long;
+	u16 assoc_id;
+	bool hiddenssid;
+
+	/*IBSS*/
+	int beacon_interval;
+
+	/*AMPDU*/
+	u8 min_space_cfg;	/*For Min spacing configurations */
+	u8 max_mss_density;
+	u8 current_ampdu_factor;
+	u8 current_ampdu_density;
+
+	/*QOS & EDCA */
+#if 0	/* Ulli : currently we are using wireless-ext */
+	struct ieee80211_tx_queue_params edca_param[RTL_MAC80211_NUM_QUEUE];
+	struct rtl_qos_parameters ac[AC_MAX];
+#endif
+
+	/* counters */
+	u64 last_txok_cnt;
+	u64 last_rxok_cnt;
+	u32 last_bt_edca_ul;
+	u32 last_bt_edca_dl;
+};
+
+struct false_alarm_statistics {
+	u32 cnt_parity_fail;
+	u32 cnt_rate_illegal;
+	u32 cnt_crc8_fail;
+	u32 cnt_mcs_fail;
+	u32 cnt_fast_fsync_fail;
+	u32 cnt_sb_search_fail;
+	u32 cnt_ofdm_fail;
+	u32 cnt_cck_fail;
+	u32 cnt_all;
+	u32 cnt_ofdm_cca;
+	u32 cnt_cck_cca;
+	u32 cnt_cca_all;
+	u32 cnt_bw_usc;
+	u32 cnt_bw_lsc;
+};
+
+enum rt_psmode {
+	EACTIVE,		/*Active/Continuous access. */
+	EMAXPS,			/*Max power save mode. */
+	EFASTPS,		/*Fast power save mode. */
+	EAUTOPS,		/*Auto power save mode. */
+};
+
+/*RF state.*/
+enum rf_pwrstate {
+	ERFON,
+	ERFSLEEP,
+	ERFOFF
+};
+
+enum p2p_ps_state {
+	P2P_PS_DISABLE = 0,
+	P2P_PS_ENABLE = 1,
+	P2P_PS_SCAN = 2,
+	P2P_PS_SCAN_DONE = 3,
+	P2P_PS_ALLSTASLEEP = 4, /* for P2P GO */
+};
+
+enum p2p_ps_mode {
+	P2P_PS_NONE = 0,
+	P2P_PS_CTWINDOW = 1,
+	P2P_PS_NOA	 = 2,
+	P2P_PS_MIX = 3, /* CTWindow and NoA */
+};
+
+struct rtl_p2p_ps_info {
+	enum p2p_ps_mode p2p_ps_mode; /* indicate p2p ps mode */
+	enum p2p_ps_state p2p_ps_state; /*  indicate p2p ps state */
+	u8 noa_index; /*  Identifies instance of Notice of Absence timing. */
+	/*  Client traffic window. A period of time in TU after TBTT. */
+	u8 ctwindow;
+	u8 opp_ps; /*  opportunistic power save. */
+	u8 noa_num; /*  number of NoA descriptor in P2P IE. */
+	/*  Count for owner, Type of client. */
+	u8 noa_count_type[P2P_MAX_NOA_NUM];
+	/*  Max duration for owner, preferred or min acceptable duration
+	 * for client.
+	 */
+	u32 noa_duration[P2P_MAX_NOA_NUM];
+	/*  Length of interval for owner, preferred or max acceptable intervali
+	 * of client.
+	 */
+	u32 noa_interval[P2P_MAX_NOA_NUM];
+	/*  schedule in terms of the lower 4 bytes of the TSF timer. */
+	u32 noa_start_time[P2P_MAX_NOA_NUM];
+};
+
+struct rtl_ps_ctl {
+	bool pwrdomain_protect;
+	bool in_powersavemode;
+	bool rfchange_inprogress;
+	bool swrf_processing;
+	bool hwradiooff;
+	/*
+	 * just for PCIE ASPM
+	 * If it supports ASPM, Offset[560h] = 0x40,
+	 * otherwise Offset[560h] = 0x00.
+	 * */
+	bool support_aspm;
+	bool support_backdoor;
+
+	/*for LPS */
+	enum rt_psmode dot11_psmode;	/*Power save mode configured. */
+	bool swctrl_lps;
+	bool leisure_ps;
+	bool fwctrl_lps;
+	u8 fwctrl_psmode;
+	/*For Fw control LPS mode */
+	u8 reg_fwctrl_lps;
+	/*Record Fw PS mode status. */
+	bool fw_current_inpsmode;
+	u8 reg_max_lps_awakeintvl;
+	bool report_linked;
+	bool low_power_enable;/*for 32k*/
+
+	/*for IPS */
+	bool inactiveps;
+
+	u32 rfoff_reason;
+
+	/*RF OFF Level */
+	u32 cur_ps_level;
+	u32 reg_rfps_level;
+
+	/*just for PCIE ASPM */
+	u8 const_amdpci_aspm;
+	bool pwrdown_mode;
+
+	enum rf_pwrstate inactive_pwrstate;
+	enum rf_pwrstate rfpwr_state;	/*cur power state */
+
+	/* for SW LPS*/
+	bool sw_ps_enabled;
+	bool state;
+	bool state_inap;
+	bool multi_buffered;
+	u16 nullfunc_seq;
+	unsigned int dtim_counter;
+	unsigned int sleep_ms;
+	unsigned long last_sleep_jiffies;
+	unsigned long last_awake_jiffies;
+	unsigned long last_delaylps_stamp_jiffies;
+	unsigned long last_dtim;
+	unsigned long last_beacon;
+	unsigned long last_action;
+	unsigned long last_slept;
+
+	/*For P2P PS */
+	struct rtl_p2p_ps_info p2p_ps_info;
+	u8 pwr_mode;
+	u8 smart_ps;
+
+	/* wake up on line */
+	u8 wo_wlan_mode;
+	u8 arp_offload_enable;
+	u8 gtk_offload_enable;
+	/* Used for WOL, indicates the reason for waking event.*/
+	u32 wakeup_reason;
+	/* Record the last waking time for comparison with setting key. */
+	u64 last_wakeup_time;
+};
+
+struct pwrctrl_priv {
+	struct semaphore lock;
+	volatile uint8_t rpwm; // requested power state for fw
+	volatile uint8_t cpwm; // fw current power state. updated when 1. read from HCPWM 2. driver lowers power level
+	volatile uint8_t tog; // toggling
+	volatile uint8_t cpwm_tog; // toggling
+
+	uint8_t	pwr_mode;
+	uint8_t	smart_ps;
+	uint8_t	bcn_ant_mode;
+
+	u32	alives;
+	struct work_struct cpwm_event;
+#ifdef CONFIG_LPS_RPWM_TIMER
+	uint8_t brpwmtimeout;
+	struct work_struct rpwmtimeoutwi;
+	_timer pwr_rpwm_timer;
+#endif // CONFIG_LPS_RPWM_TIMER
+	uint8_t	bpower_saving;
+
+	uint8_t	b_hw_radio_off;
+	uint8_t	reg_rfoff;
+	uint8_t	reg_pdnmode; //powerdown mode
+	u32	rfoff_reason;
+
+	//RF OFF Level
+	u32	cur_ps_level;
+	u32	reg_rfps_level;
+
+
+	uint 	ips_enter_cnts;
+	uint 	ips_leave_cnts;
+
+	uint8_t	ips_mode;
+	uint8_t	ips_mode_req; // used to accept the mode setting request, will update to ipsmode later
+	uint bips_processing;
+	u32 ips_deny_time; /* will deny IPS when system time is smaller than this */
+	uint8_t ps_processing; /* temporarily used to mark whether in rtw_ps_processor */
+
+	uint8_t	bLeisurePs;
+	uint8_t	LpsIdleCount;
+	uint8_t	power_mgnt;
+	bool fw_current_inpsmode;
+	u32	DelayLPSLastTimeStamp;
+	uint8_t 	btcoex_rfon;
+	int32_t		pnp_current_pwr_state;
+	uint8_t		pnp_bstop_trx;
+
+
+	uint8_t		bInternalAutoSuspend;
+	uint8_t		bInSuspend;
+	uint8_t		bSupportRemoteWakeup;
+	struct timer_list	pwr_state_check_timer;
+	int		pwr_state_check_interval;
+	uint8_t		pwr_state_check_cnts;
+
+	int 		ps_flag;
+
+	enum rf_pwrstate	rf_pwrstate;//cur power state
+	//rt_rf_power_state 	current_rfpwrstate;
+	enum rf_pwrstate	change_rfpwrstate;
+
+	uint8_t		wepkeymask;
+	uint8_t		bHWPwrPindetect;
+	uint8_t		brfoffbyhw;
+	unsigned long PS_BBRegBackup[PSBBREG_TOTALCNT];
+};
+
+struct rtl_locks {
+#if 0
+	/* mutex */
+	struct mutex conf_mutex;
+	struct mutex ps_mutex;
+
+	/*spin lock */
+	spinlock_t ips_lock;
+	spinlock_t irq_th_lock;
+	spinlock_t irq_pci_lock;
+	spinlock_t tx_lock;
+	spinlock_t h2c_lock;
+	spinlock_t rf_ps_lock;
+	spinlock_t rf_lock;
+	spinlock_t lps_lock;
+	spinlock_t waitq_lock;
+	spinlock_t entry_list_lock;
+#endif
+	spinlock_t usb_lock;
+#if 0
+
+	/*FW clock change */
+	spinlock_t fw_ps_lock;
+
+	/*Dual mac*/
+	spinlock_t cck_and_rw_pagea_lock;
+
+	/*Easy concurrent*/
+	spinlock_t check_sendpkt_lock;
+
+	spinlock_t iqk_lock;
+#endif
+};
+
+struct rtl_works {
+#if 0
+	struct ieee80211_hw *hw;
+
+	/*timer */
+	struct timer_list watchdog_timer;
+	struct timer_list dualmac_easyconcurrent_retrytimer;
+	struct timer_list fw_clockoff_timer;
+	struct timer_list fast_antenna_training_timer;
+	/*task */
+	struct tasklet_struct irq_tasklet;
+	struct tasklet_struct irq_prepare_bcn_tasklet;
+
+	/*work queue */
+	struct workqueue_struct *rtl_wq;
+	struct delayed_work watchdog_wq;
+	struct delayed_work ips_nic_off_wq;
+
+	/* For SW LPS */
+	struct delayed_work ps_work;
+	struct delayed_work ps_rfon_wq;
+	struct delayed_work fwevt_wq;
+
+	struct work_struct lps_change_work;
+	struct work_struct fill_h2c_cmd;
+#endif
+};
+
+struct rtl_debug {
+	u32 dbgp_type[DBGP_TYPE_MAX];
+	int global_debuglevel;
+	u64 global_debugcomponents;
+
+	/* add for proc debug */
+	struct proc_dir_entry *proc_dir;
+	char proc_name[20];
+};
+
+struct rtl_priv {
+	struct net_device *ndev;
+
+	struct rtl_hal rtlhal;		/* Caution new Hal data */
+	struct rtl_phy phy;
+	struct rtl_efuse efuse;
+	struct rtl_ps_ctl psc;
+	struct rtl_dm dm;		/* Caution new dm data */
+	struct rtl_hal_cfg *cfg;
+	struct rtl_io io;
+	struct dig_t dm_digtable;
+	struct rate_adaptive ra;
+	struct rtl_mac mac80211;
+
+	struct false_alarm_statistics falsealm_cnt;
+	struct rtl_usb_priv priv;
+	struct rtl_locks locks;
+	struct rtl_debug dbg;
+	struct rtl_security sec;
+	struct rtl_works works;
+
+	struct _rtw_hal *HalData;
+	bool initialized;
+
+
+	/* Border */
+
+	struct	mlme_priv mlmepriv;
+	struct	mlme_ext_priv mlmeextpriv;
+	struct	cmd_priv	cmdpriv;
+	struct	evt_priv	evtpriv;
+	//struct	io_queue	*pio_queue;
+	struct	xmit_priv	xmitpriv;
+	struct	recv_priv	recvpriv;
+	struct	sta_priv	stapriv;
+	struct	security_priv	securitypriv;
+	struct	registry_priv	registrypriv;
+	struct	pwrctrl_priv	pwrctrlpriv;
+
+#ifdef CONFIG_AP_MODE
+	struct	hostapd_priv	*phostapdpriv;
+#endif
+
+	u32	setband;
+
+	int32_t	bDriverStopped;
+	int32_t	bSurpriseRemoved;
+	int32_t  bCardDisableWOHSM;
+
+	u32	IsrContent;
+	u32	ImrContent;
+
+	uint8_t	EepromAddressSize;
+	uint8_t	hw_init_completed;
+	uint8_t	bDriverIsGoingToUnload;
+	uint8_t	init_adpt_in_progress;
+	uint8_t	bHaltInProgress;
+
+	void *cmdThread;
+	void *evtThread;
+	void *xmitThread;
+	void *recvThread;
+
+	struct net_device_stats stats;
+	struct iw_statistics iwstats;
+
+	int net_closed;
+
+	uint8_t bBTFWReady;
+	uint8_t bReadPortCancel;
+	uint8_t bWritePortCancel;
+	//	Added by Albert 2012/10/26
+	//	The driver will show up the desired channel number when this flag is 1.
+	uint8_t bNotifyChannelChange;
+#ifdef CONFIG_AUTOSUSPEND
+	uint8_t	bDisableAutosuspend;
+#endif
+        uint8_t    fix_rate;
+
+	unsigned char     in_cta_test;
+
+};
+
+
+struct rtl_stats {
+	u8 psaddr[ETH_ALEN];
+	u32 mac_time[2];
+	s8 rssi;
+	u8 signal;
+	u8 noise;
+	u8 rate;		/* hw desc rate */
+	u8 received_channel;
+	u8 control;
+	u8 mask;
+	u8 freq;
+	u16 len;
+	u64 tsf;
+	u32 beacon_time;
+	u8 nic_type;
+	u16 length;
+	u8 signalquality;	/*in 0-100 index. */
+	/*
+	 * Real power in dBm for this packet,
+	 * no beautification and aggregation.
+	 * */
+	s32 recvsignalpower;
+	s8 rxpower;		/*in dBm Translate from PWdB */
+	u8 signalstrength;	/*in 0-100 index. */
+	u16 hwerror:1;
+	u16 crc:1;
+	u16 icv:1;
+	u16 shortpreamble:1;
+	u16 antenna:1;
+	u16 decrypted:1;
+	u16 wakeup:1;
+	u32 timestamp_low;
+	u32 timestamp_high;
+	bool shift;
+
+	u8 rx_drvinfo_size;
+	u8 rx_bufshift;
+	bool isampdu;
+	bool isfirst_ampdu;
+	bool rx_is40Mhzpacket;
+	u8 rx_packet_bw;
+	u32 rx_pwdb_all;
+	u8 rx_mimo_signalstrength[4];	/*in 0~100 index */
+	s8 rx_mimo_signalquality[4];
+	u8 rx_mimo_evm_dbm[4];
+	u16 cfo_short[4];		/* per-path's Cfo_short */
+	u16 cfo_tail[4];
+
+	s8 rx_mimo_sig_qual[4];
+	u8 rx_pwr[4]; /* per-path's pwdb */
+	u8 rx_snr[4]; /* per-path's SNR */
+	u8 bandwidth;
+	u8 bt_coex_pwr_adjust;
+	bool packet_matchbssid;
+	bool is_cck;
+	bool is_ht;
+	bool packet_toself;
+	bool packet_beacon;	/*for rssi */
+	char cck_adc_pwdb[4];	/*for rx path selection */
+
+	bool is_vht;
+	bool is_short_gi;
+	u8 vht_nss;
+
+	u8 packet_report_type;
+
+	u32 macid;
+	u8 wake_match;
+	u32 bt_rx_rssi_percentage;
+	u32 macid_valid_entry[2];
+};
+
+
+
+struct rtl_hal_ops {
+	/*
+	 * New HAL functions with struct net_device  as first param
+	 * this can be (hopefully)switched to struct ieee80211_hw
+	 */
+	int (*init_sw_vars) (struct rtl_priv *rtlpriv);
+	void (*deinit_sw_vars) (struct rtl_priv *rtlpriv);
+
+	void	(*set_hw_reg)(struct rtl_priv *rtlpriv, u8 variable,u8 *val);
+	void	(*get_hw_reg)(struct rtl_priv *rtlpriv, u8 variable,u8 *val);
+/*
+ * 	ULLI from original rtlwifi-lib in wifi.h
+ *
+ * 	void (*fill_fake_txdesc) (struct ieee80211_hw *hw, u8 *pDesc,
+ *				  u32 buffer_len, bool bIsPsPoll);
+*/
+
+	void	(*fill_fake_txdesc) (struct rtl_priv *rtlpriv, u8 *pDesc,
+				     u32 BufferLen, u8 IsPsPoll, u8 IsBTQosNull);
+
+	u32	(*get_bbreg)(struct rtl_priv *rtlpriv, u32 RegAddr, u32 BitMask);
+	void	(*set_bbreg)(struct rtl_priv *rtlpriv, u32 RegAddr, u32 BitMask, u32 Data);
+	u32	(*get_rfreg)(struct rtl_priv *rtlpriv, u32 eRFPath, u32 RegAddr, u32 BitMask);
+	void	(*set_rfreg)(struct rtl_priv *rtlpriv, u32 eRFPath, u32 RegAddr, u32 BitMask, u32 Data);
+
+	void	(*init_sw_leds)(struct rtl_priv *rtlpriv);
+	void	(*deinit_sw_leds)(struct rtl_priv *rtlpriv);
+	void	(*led_control) (struct rtl_priv *rtlpriv, enum led_ctl_mode ledcation);
+	bool	(*radio_onoff_checking) (struct rtl_priv *rtlpriv, u8 *valid);
+	int 	(*set_network_type) (struct rtl_priv *prtpriv, uint8_t val);
+	u32	(*hw_init)(struct rtl_priv *rtlpriv);
+
+	bool	(*phy_rf6052_config) (struct rtl_priv *rtlpriv);
+	void 	(*phy_rf6052_set_cck_txpower) (struct rtl_priv *rtlpriv,
+					       u8 *powerlevel);
+#if 0
+	void 	(*phy_rf6052_set_ofdm_txpower) (struct rtl_priv *rtlpriv,
+					        u8 *ppowerlevel, u8 channel);
+#endif
+	void 	(*phy_rf6052_set_ofdm_txpower)(struct rtl_priv *rtlpriv,
+					       u8 *pPowerLevelOFDM,
+					       u8 *pPowerLevelBW20,
+					       u8 *pPowerLevelBW40,
+					       u8 Channel);
+	bool (*config_bb_with_headerfile) (struct rtl_priv *rtlpriv,
+					   u8 configtype);
+	bool (*config_bb_with_pgheaderfile) (struct rtl_priv *rtlpriv,
+					     u8 configtype);
+
+	void (*phy_set_bw_mode_callback) (struct rtl_priv *rtlpriv);
+	void (*fill_h2c_cmd) (struct rtl_priv *rtlpriv, u8 element_id,
+			      u32 cmd_len, u8 *p_cmdbuffer);
+
+
+	bool (*get_btc_status) (void);
+	void (*dm_watchdog)(struct rtl_priv *rtlpriv);
+	void (*set_bcn_reg)(struct rtl_priv *rtlpriv);
+
+	/* Old HAL functions */
+
+	u32	(*hal_deinit)(struct rtl_priv *rtlpriv);
+
+	void	(*free_hal_data)(struct rtl_priv *rtlpriv);
+
+	u32	(*inirp_deinit)(struct rtl_priv *rtlpriv);
+
+	int32_t	(*init_recv_priv)(struct rtl_priv *rtlpriv);
+	void	(*free_recv_priv)(struct rtl_priv *rtlpriv);
+
+	void	(*dm_init)(struct rtl_priv *rtlpriv);
+	void	(*read_chip_version)(struct rtl_priv *rtlpriv);
+
+	void	(*init_default_value)(struct rtl_priv *rtlpriv);
+
+	void	(*read_adapter_info)(struct rtl_priv *rtlpriv);
+
+	void	(*enable_interrupt)(struct rtl_priv *rtlpriv);
+	void	(*disable_interrupt)(struct rtl_priv *rtlpriv);
+
+	void	(*set_bwmode_handler)(struct rtl_priv *rtlpriv, enum CHANNEL_WIDTH Bandwidth, uint8_t Offset);
+	void	(*set_channel_handler)(struct rtl_priv *rtlpriv, uint8_t channel);
+	void	(*set_chnl_bw_handler)(struct rtl_priv *rtlpriv, uint8_t channel, enum CHANNEL_WIDTH Bandwidth, uint8_t Offset40, uint8_t Offset80);
+
+	void	(*hal_dm_watchdog)(struct rtl_priv *rtlpriv);
+
+	void	(*Add_RateATid)(struct rtl_priv *rtlpriv, u32 bitmap, u8* arg, uint8_t rssi_level);
+
+	int32_t	(*hal_xmit)(struct rtl_priv *rtlpriv, struct xmit_frame *pxmitframe);
+	int32_t (*mgnt_xmit)(struct rtl_priv *rtlpriv, struct xmit_frame *pmgntframe);
+	int32_t	(*hal_xmitframe_enqueue)(struct rtl_priv *rtlpriv, struct xmit_frame *pxmitframe);
+};
+
+
+static void rtw_hal_fill_fake_txdesc (struct rtl_priv *rtlpriv, u8 *pDesc,
+	u32 BufferLen, u8 IsPsPoll, u8 IsBTQosNull)
+{
+	rtlpriv->cfg->ops->fill_fake_txdesc(rtlpriv, pDesc, BufferLen, IsPsPoll, IsBTQosNull);
+}
+
+
+
+
+/*Only for transition between old (RTW) and new (rtlwifi-lib) API */
+
+uint32_t rtl8812au_hal_deinit(struct rtl_priv *rtlpriv);
+unsigned int rtl8812au_inirp_deinit(struct rtl_priv *rtlpriv);
+void rtl8812au_init_default_value(struct rtl_priv *rtlpriv);
+void _rtl8821au_read_adapter_info(struct rtl_priv *rtlpriv);
+
+enum hardware_type {
+	HARDWARE_TYPE_RTL8812AU,
+	HARDWARE_TYPE_RTL8811AU,
+	HARDWARE_TYPE_RTL8821U,
+
+	HARDWARE_TYPE_MAX,
+};
+
+// RTL8812 Series
+#define IS_HARDWARE_TYPE_8812AU(rtlhal)	\
+	(rtlhal->hw_type == HARDWARE_TYPE_RTL8812AU)
+#define IS_HARDWARE_TYPE_8812(rtlhal)	\
+	(IS_HARDWARE_TYPE_8812AU(rtlhal))
+
+// RTL8821 Series
+#define IS_HARDWARE_TYPE_8811AU(rtlhal)	\
+	(rtlhal->hw_type == HARDWARE_TYPE_RTL8811AU)
+#define IS_HARDWARE_TYPE_8821U(rtlhal)	\
+	((rtlhal->hw_type == HARDWARE_TYPE_RTL8821U) || \
+       	(rtlhal->hw_type == HARDWARE_TYPE_RTL8811AU))
+#define IS_HARDWARE_TYPE_8821(rtlhal)		\
+	(IS_HARDWARE_TYPE_8821U(rtlhal))
+
+#define	LDPC_HT_ENABLE_RX		BIT(0)
+#define	LDPC_HT_ENABLE_TX		BIT(1)
+#define	LDPC_HT_TEST_TX_ENABLE		BIT(2)
+#define	LDPC_HT_CAP_TX			BIT(3)
+
+#define	STBC_HT_ENABLE_RX		BIT(0)
+#define	STBC_HT_ENABLE_TX		BIT(1)
+#define	STBC_HT_TEST_TX_ENABLE		BIT(2)
+#define	STBC_HT_CAP_TX			BIT(3)
+
+static inline u8 get_rf_type(struct rtl_phy *rtlphy)
+{
+	return rtlphy->rf_type;
+}
+
+/* Not fully compatible */
+#define rtl_usbdev(rtlpriv) (&(rtlpriv->priv.dev))
+
+
+static inline u8 rtl_read_byte(struct rtl_priv *rtlpriv, u32 addr)
+{
+	return rtlpriv->io.read8_sync(rtlpriv, addr);
+}
+
+static inline u16 rtl_read_word(struct rtl_priv *rtlpriv, u32 addr)
+{
+	return rtlpriv->io.read16_sync(rtlpriv, addr);
+}
+
+static inline u32 rtl_read_dword(struct rtl_priv *rtlpriv, u32 addr)
+{
+	return rtlpriv->io.read32_sync(rtlpriv, addr);
+}
+
+static inline void rtl_write_byte(struct rtl_priv *rtlpriv, u32 addr, u8 val8)
+{
+	rtlpriv->io.write8_async(rtlpriv, addr, val8);
+}
+
+static inline void rtl_write_word(struct rtl_priv *rtlpriv, u32 addr, u16 val16)
+{
+	rtlpriv->io.write16_async(rtlpriv, addr, val16);
+}
+
+static inline void rtl_write_dword(struct rtl_priv *rtlpriv,
+				   u32 addr, u32 val32)
+{
+	rtlpriv->io.write32_async(rtlpriv, addr, val32);
+}
+
+static inline void rtl_writeN(struct rtl_priv *rtlpriv,
+				   u32 addr, void *data, u16 len)
+{
+	rtlpriv->io.writeN_sync(rtlpriv, addr, data, len);
+}
+
+static u32 rtl_get_bbreg(struct rtl_priv *rtlpriv, uint32_t RegAddr,
+		         uint32_t BitMask)
+{
+	return rtlpriv->cfg->ops->get_bbreg(rtlpriv, RegAddr, BitMask);
+}
+
+static void rtl_set_bbreg(struct rtl_priv *rtlpriv, uint32_t RegAddr,
+			  uint32_t BitMask, uint32_t Data)
+{
+	rtlpriv->cfg->ops->set_bbreg(rtlpriv, RegAddr, BitMask, Data);
+}
+
+static inline void rtl_set_rfreg(struct rtl_priv *rtlpriv,
+				 enum radio_path rfpath, u32 regaddr,
+				 u32 bitmask, u32 data)
+{
+	rtlpriv->cfg->ops->set_rfreg(rtlpriv, rfpath, regaddr, bitmask, data);
+}
+
+static inline u32 rtl_get_rfreg(struct rtl_priv *rtlpriv, enum radio_path rfpath,
+		       u32 regaddr, u32 bitmask)
+{
+	return rtlpriv->cfg->ops->get_rfreg(rtlpriv, rfpath, regaddr,
+						    bitmask);
+}
+
+/****************************************
+	mem access macro define start
+	Call endian free function when
+	1. Read/write packet content.
+	2. Before write integer to IO.
+	3. After read integer from IO.
+****************************************/
+/* Convert little data endian to host ordering */
+#define EF1BYTE(_val)		\
+	((u8)(_val))
+#define EF2BYTE(_val)		\
+	(le16_to_cpu(_val))
+#define EF4BYTE(_val)		\
+	(le32_to_cpu(_val))
+
+/* Read data from memory */
+#define READEF1BYTE(_ptr)	\
+	EF1BYTE(*((u8 *)(_ptr)))
+/* Read le16 data from memory and convert to host ordering */
+#define READEF2BYTE(_ptr)	\
+	EF2BYTE(*(_ptr))
+#define READEF4BYTE(_ptr)	\
+	EF4BYTE(*(_ptr))
+
+/* Write data to memory */
+#define WRITEEF1BYTE(_ptr, _val)	\
+	(*((u8 *)(_ptr))) = EF1BYTE(_val)
+/* Write le16 data to memory in host ordering */
+#define WRITEEF2BYTE(_ptr, _val)	\
+	(*((u16 *)(_ptr))) = EF2BYTE(_val)
+#define WRITEEF4BYTE(_ptr, _val)	\
+	(*((u32 *)(_ptr))) = EF2BYTE(_val)
+
+/* Create a bit mask
+ * Examples:
+ * BIT_LEN_MASK_32(0) => 0x00000000
+ * BIT_LEN_MASK_32(1) => 0x00000001
+ * BIT_LEN_MASK_32(2) => 0x00000003
+ * BIT_LEN_MASK_32(32) => 0xFFFFFFFF
+ */
+#define BIT_LEN_MASK_32(__bitlen)	 \
+	(0xFFFFFFFF >> (32 - (__bitlen)))
+#define BIT_LEN_MASK_16(__bitlen)	 \
+	(0xFFFF >> (16 - (__bitlen)))
+#define BIT_LEN_MASK_8(__bitlen) \
+	(0xFF >> (8 - (__bitlen)))
+
+/* Create an offset bit mask
+ * Examples:
+ * BIT_OFFSET_LEN_MASK_32(0, 2) => 0x00000003
+ * BIT_OFFSET_LEN_MASK_32(16, 2) => 0x00030000
+ */
+#define BIT_OFFSET_LEN_MASK_32(__bitoffset, __bitlen) \
+	(BIT_LEN_MASK_32(__bitlen) << (__bitoffset))
+#define BIT_OFFSET_LEN_MASK_16(__bitoffset, __bitlen) \
+	(BIT_LEN_MASK_16(__bitlen) << (__bitoffset))
+#define BIT_OFFSET_LEN_MASK_8(__bitoffset, __bitlen) \
+	(BIT_LEN_MASK_8(__bitlen) << (__bitoffset))
+
+/*Description:
+ * Return 4-byte value in host byte ordering from
+ * 4-byte pointer in little-endian system.
+ */
+#define LE_P4BYTE_TO_HOST_4BYTE(__pstart) \
+	(EF4BYTE(*((__le32 *)(__pstart))))
+#define LE_P2BYTE_TO_HOST_2BYTE(__pstart) \
+	(EF2BYTE(*((__le16 *)(__pstart))))
+#define LE_P1BYTE_TO_HOST_1BYTE(__pstart) \
+	(EF1BYTE(*((u8 *)(__pstart))))
+
+/*Description:
+Translate subfield (continuous bits in little-endian) of 4-byte
+value to host byte ordering.*/
+#define LE_BITS_TO_4BYTE(__pstart, __bitoffset, __bitlen) \
+	( \
+		(LE_P4BYTE_TO_HOST_4BYTE(__pstart) >> (__bitoffset))  & \
+		BIT_LEN_MASK_32(__bitlen) \
+	)
+#define LE_BITS_TO_2BYTE(__pstart, __bitoffset, __bitlen) \
+	( \
+		(LE_P2BYTE_TO_HOST_2BYTE(__pstart) >> (__bitoffset)) & \
+		BIT_LEN_MASK_16(__bitlen) \
+	)
+#define LE_BITS_TO_1BYTE(__pstart, __bitoffset, __bitlen) \
+	( \
+		(LE_P1BYTE_TO_HOST_1BYTE(__pstart) >> (__bitoffset)) & \
+		BIT_LEN_MASK_8(__bitlen) \
+	)
+
+/* Description:
+ * Mask subfield (continuous bits in little-endian) of 4-byte value
+ * and return the result in 4-byte value in host byte ordering.
+ */
+#define LE_BITS_CLEARED_TO_4BYTE(__pstart, __bitoffset, __bitlen) \
+	( \
+		LE_P4BYTE_TO_HOST_4BYTE(__pstart)  & \
+		(~BIT_OFFSET_LEN_MASK_32(__bitoffset, __bitlen)) \
+	)
+#define LE_BITS_CLEARED_TO_2BYTE(__pstart, __bitoffset, __bitlen) \
+	( \
+		LE_P2BYTE_TO_HOST_2BYTE(__pstart) & \
+		(~BIT_OFFSET_LEN_MASK_16(__bitoffset, __bitlen)) \
+	)
+#define LE_BITS_CLEARED_TO_1BYTE(__pstart, __bitoffset, __bitlen) \
+	( \
+		LE_P1BYTE_TO_HOST_1BYTE(__pstart) & \
+		(~BIT_OFFSET_LEN_MASK_8(__bitoffset, __bitlen)) \
+	)
+
+/* Description:
+ * Set subfield of little-endian 4-byte value to specified value.
+ */
+#define SET_BITS_TO_LE_4BYTE(__pstart, __bitoffset, __bitlen, __val) \
+	*((u32 *)(__pstart)) = \
+	( \
+		LE_BITS_CLEARED_TO_4BYTE(__pstart, __bitoffset, __bitlen) | \
+		((((u32)__val) & BIT_LEN_MASK_32(__bitlen)) << (__bitoffset)) \
+	);
+#define SET_BITS_TO_LE_2BYTE(__pstart, __bitoffset, __bitlen, __val) \
+	*((u16 *)(__pstart)) = \
+	( \
+		LE_BITS_CLEARED_TO_2BYTE(__pstart, __bitoffset, __bitlen) | \
+		((((u16)__val) & BIT_LEN_MASK_16(__bitlen)) << (__bitoffset)) \
+	);
+#define SET_BITS_TO_LE_1BYTE(__pstart, __bitoffset, __bitlen, __val) \
+	*((u8 *)(__pstart)) = EF1BYTE \
+	( \
+		LE_BITS_CLEARED_TO_1BYTE(__pstart, __bitoffset, __bitlen) | \
+		((((u8)__val) & BIT_LEN_MASK_8(__bitlen)) << (__bitoffset)) \
+	);
+
+
+/* ULLI : Hope this is an border, for old code  */
+
+
+
+
+
+#define IQK_Matrix_Settings_NUM_92D	1+24+21
+
+#define HP_THERMAL_NUM		8
+
+struct dm_priv {
+	// Add for Reading Initial Data Rate SEL Register 0x484 during watchdog. Using for fill tx desc. 2011.3.21 by Thomas
+	uint8_t	INIDATA_RATE[32];
+};
+
+//
+// <Roger_Notes> For RTL8723 WiFi PDn/GPIO polarity control configuration. 2010.10.08.
+//
+
+// For RTL8723 regulator mode. by tynli. 2011.01.14.
+typedef enum _RT_REGULATOR_MODE {
+	RT_SWITCHING_REGULATOR 	= 0,
+	RT_LDO_REGULATOR 			= 1,
+} RT_REGULATOR_MODE, *PRT_REGULATOR_MODE;
+
+//
+// Interface type.
+//
+
+typedef enum _RT_AMPDU_BRUST_MODE{
+	RT_AMPDU_BRUST_NONE 		= 0,
+	RT_AMPDU_BRUST_92D 		= 1,
+	RT_AMPDU_BRUST_88E 		= 2,
+	RT_AMPDU_BRUST_8812_4 	= 3,
+	RT_AMPDU_BRUST_8812_8 	= 4,
+	RT_AMPDU_BRUST_8812_12 	= 5,
+	RT_AMPDU_BRUST_8812_15	= 6,
+	RT_AMPDU_BRUST_8723B	 	= 7,
+}RT_AMPDU_BRUST,*PRT_AMPDU_BRUST_MODE;
+
+
+
+//###### duplicate code,will move to ODM #########
+
+typedef struct _EDCA_TURBO_
+{
+	uint32_t	prv_traffic_idx; // edca turbo
+}EDCA_T,*pEDCA_T;
+
+
+//#endif
+
+//
+// 2011/09/22 MH Copy from SD4 defined structure. We use to support PHY DM integration.
+//
+struct _rtw_dm {
+	//
+	//	Add for different team use temporarily
+	//
+	struct rtl_priv *	rtlpriv;		// For CE/NIC team
+	// WHen you use rtlpriv or priv pointer, you must make sure the pointer is ready.
+	bool			odm_ready;
+
+	uint64_t			NumQryPhyStatusAll; 	//CCK + OFDM
+	uint64_t			LastNumQryPhyStatusAll;
+	uint64_t			RxPWDBAve;
+	uint64_t			RxPWDBAve_final;
+	bool			MPDIG_2G; 		//off MPDIG
+	u8			Times_2G;
+
+//------ ODM HANDLE, DRIVER NEEDS NOT TO HOOK------//
+//------ ODM HANDLE, DRIVER NEEDS NOT TO HOOK------//
+
+//--------REMOVED COMMON INFO----------//
+	//u8				PseudoMacPhyMode;
+	//bool			*BTCoexist;
+	//bool			PseudoBtCoexist;
+	//u8				OPMode;
+	//bool			bAPMode;
+	//bool			bClientMode;
+	//bool			bAdHocMode;
+	//bool			bSlaveOfDMSP;
+//--------REMOVED COMMON INFO----------//
+
+
+//1  COMMON INFORMATION
+
+	//
+	// Init Value
+	//
+//-----------HOOK BEFORE REG INIT-----------//
+	// ODM Support Ability DIG/RATR/TX_PWR_TRACK/ KK = 1/2/3/K
+	// ODM PCIE/USB/SDIO = 1/2/3
+	u8			SupportInterface;
+	// Cut Version TestChip/A-cut/B-cut... = 0/1/2/3/...
+	u8			CutVersion;
+
+	// with external TRSW  NO/Yes = 0/1
+	u8			PatchID; //Customer ID
+
+//-----------HOOK BEFORE REG INIT-----------//
+
+	//
+	// Dynamic Value
+	//
+//--------- POINTER REFERENCE-----------//
+
+	u8			u8_temp;
+
+	// Security mode Open/WEP/AES/TKIP = 0/1/2/3
+	u8			*pSecurity;
+	// Common info for 92D DMSP
+
+	//u8			*pAidMap;
+//------------CALL BY VALUE-------------//
+	u8          InterfaceIndex; // Add for 92D  dual MAC: 0--Mac0 1--Mac1
+	bool			bOneEntryOnly;
+	// Common info for BTDM
+//------------CALL BY VALUE-------------//
+	u8			RSSI_A;
+	u8			RSSI_B;
+	u8			RxRate;
+	uint32_t			TH_H;
+	uint32_t			TH_L;
+	uint32_t			IGI_Base;
+	uint32_t			IGI_target;
+	bool			ForceEDCCA;
+	u8			AdapEn_RSSI;
+
+	//
+	// 2012/02/14 MH Add to share 88E ra with other SW team.
+	// We need to colelct all support abilit to a proper area.
+	//
+	bool				RaSupport88E;
+
+	// Define ...........
+
+	// Different Team independt structure??
+
+	//
+	//TX_RTP_CMN		TX_retrpo;
+	//TX_RTP_88E		TX_retrpo;
+	//TX_RTP_8195		TX_retrpo;
+
+	//
+	//ODM Structure
+	//
+
+	EDCA_T		DM_EDCA_Table;
+	uint32_t		WMMEDCA_BE;
+	// Copy from SD4 structure
+	//
+	// ==================================================
+	//
+
+	//common
+	//u8    PSD_Report_RXHP[80];   // Add By Gary
+	//u8    PSD_func_flag;               // Add By Gary
+	//for DIG
+	//u8		binitialized; // for dm_initial_gain_Multi_STA use.
+	//for Antenna diversity
+	//u8	AntDivCfg;// 0:OFF , 1:ON, 2:by efuse
+	//struct sta_info *RSSI_target;
+
+	//PSD
+
+	//
+	// TX power tracking
+	//
+
+	//
+	// Dynamic ATC switch
+	//
+	int				CFO_tail[2];
+	uint32_t			packetCount;
+};
+
+struct _rtw_hal {
+	//current WIFI_PHY values
+	enum wireless_mode CurrentWirelessMode;
+
+	u16	CustomerID;
+	u32	ReceiveConfig;
+
+	//rf_ctrl
+	uint8_t	DefaultInitialGain[4];
+
+	uint8_t	bTXPowerDataReadFromEEPORM;
+	//uint8_t				EfuseMap[2][HWSET_MAX_SIZE_JAGUAR];
+
+
+//	uint8_t	Regulation2_4G;
+//	uint8_t	Regulation5G;
+	//
+	// TX power by rate table at most 4RF path.
+	// The register is
+	//
+	// VHT TX power by rate off setArray =
+	// Band:-2G&5G = 0 / 1
+	// RF: at most 4*4 = ABCD=0/1/2/3
+	// CCK=0 OFDM=1/2 HT-MCS 0-15=3/4/56 VHT=7/8/9/10/11
+	//
+	uint8_t	TxPwrByRateTable;
+ 	uint8_t	TxPwrByRateBand;
+
+
+
+	uint8_t	LegacyHTTxPowerDiff;// Legacy to HT rate power diff
+
+	// Read/write are allow for following hardware information variables
+	u32	CCKTxPowerLevelOriginalOffset;
+
+	uint8_t	bIQKInitialized;
+	bool		bLCKInProgress;
+
+	bool		bChnlBWInitialzed;
+
+	uint8_t	TxPowerTrackControl; //for mp mode, turn off txpwrtracking as default
+	uint8_t	b1x1RecvCombine;	// for 1T1R receive combining
+
+	u32	AcParam_BE; //Original parameter for BE, use for EDCA turbo.
+
+	u32	RfRegChnlVal[2];
+
+	//RDG enable
+	bool	 bRDGEnable;
+
+	uint8_t	fw_ractrl;
+	uint8_t	RegTxPause;
+	// Beacon function related global variable.
+	uint8_t	RegFwHwTxQCtrl;
+	uint8_t	RegReg542;
+	uint8_t	RegCR_1;
+	u16	RegRRSR;
+
+	uint8_t	CurAntenna;
+	uint8_t	AntDivCfg;
+
+	uint8_t	FwRsvdPageStartOffset; //2010.06.23. Added by tynli. Reserve page start offset except beacon in TxQ.
+
+	// 2010/12/10 MH Add for USB aggreation mode dynamic shceme.
+	bool		UsbRxHighSpeedMode;
+
+	uint8_t	AMPDUDensity;
+
+	// Auto FSM to Turn On, include clock, isolation, power control for MAC only
+	uint8_t	bMacPwrCtrlOn;
+
+	RT_AMPDU_BRUST		AMPDUBurstMode; //92C maybe not use, but for compile successfully
+
+	uint8_t	C2hArray[16];
+	uint8_t	UsbTxAggDescNum;
+
+	u16	HwRxPageSize;				// Hardware setting
+	u32	MaxUsbRxAggBlock;
+
+	uint8_t	UsbRxAggBlockCount;			// USB Block count. Block size is 512-byte in hight speed and 64-byte in full speed
+	uint8_t	UsbRxAggBlockTimeout;
+	uint8_t	UsbRxAggPageCount;			// 8192C DMA page count
+	uint8_t	UsbRxAggPageTimeout;
+
+	uint8_t	RegAcUsbDmaSize;
+	uint8_t	RegAcUsbDmaTime;
+
+
+
+	struct dm_priv	dmpriv;
+	struct _rtw_dm odmpriv;
+};
+
+static inline struct _rtw_hal *GET_HAL_DATA(struct rtl_priv *priv)
+{
+	return priv->HalData;
+}
+
+/* ULLI : we must get rid of this studip code */
+
+static inline uint8_t rtw_get_oper_ch(struct rtl_priv *rtlpriv)
+{
+	return rtl_usbdev(rtlpriv)->oper_channel;
+}
+
+static inline void rtw_set_oper_ch(struct rtl_priv *rtlpriv, uint8_t ch)
+{
+	rtl_usbdev(rtlpriv)->oper_channel = ch;
+}
+
+#endif
